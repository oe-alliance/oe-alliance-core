diff -Naur linux-3.9.2.ref/arch/mips/boot/Makefile linux-3.9.2/arch/mips/boot/Makefile
--- linux-3.9.2.ref/arch/mips/boot/Makefile	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/arch/mips/boot/Makefile	2013-07-23 19:37:23.000000000 +0200
@@ -40,3 +40,72 @@
       cmd_srec = $(OBJCOPY) -S -O srec $(strip-flags) $(VMLINUX) $@
 $(obj)/vmlinux.srec: $(VMLINUX) FORCE
 	$(call if_changed,srec)
+sigma.bin: $(VMLINUX)
+	$(OBJCOPY) -O binary $(strip-flags) $(VMLINUX) $(obj)/sigma.bin
+$(obj)/vmlinux.gz: $(obj)/sigma.bin
+ifdef CONFIG_TANGO2
+	gzip -c9 $< > $@
+else
+	gzip -c9nf $< > $@
+endif
+
+ifdef CONFIG_TANGO2
+
+$(obj)/vmlinux_gz.zbf: $(obj)/vmlinux.gz
+	cp -f $< $@
+
+$(obj)/vmlinux_xload.zbf: $(obj)/vmlinux_gz.zbf
+	$(srctree)/arch/mips/boot/genzbf -l $(loadaddr) -s 0x90020000 -a lzf -o $@ $<
+
+zbimage-linux-xload: $(obj)/zbimage-linux-xload
+endif
+
+ifdef CONFIG_TANGO3
+
+$(obj)/vmlinux_gz.zbf: $(obj)/vmlinux.gz
+	cp -f $< $@
+
+$(obj)/vmlinux_xload.zbf: $(obj)/vmlinux_gz.zbf
+	$(srctree)/arch/mips/boot/genzbf -l $(loadaddr) -s 0x`$(NM) $(VMLINUX) | grep kernel_entry | awk '{ print $$1 }'` -a lzf -o $@ $<
+
+zbimage-linux-xload: $(obj)/zbimage-linux-xload
+
+endif
+
+ifdef CONFIG_TANGO4
+$(obj)/vmlinux.gz.xload3: $(obj)/vmlinux.gz
+	bash $(srctree)/arch/mips/boot/create_xload3.bash -p $(obj)/vmlinux.gz -c $(certid)
+
+$(obj)/vmlinux_xload.zbf: $(obj)/vmlinux.gz.xload3
+	genzbf -l $(loadaddr) -s 0x`$(NM) $(VMLINUX) | grep kernel_entry | awk '{ print $$1 }'` -a lzef -o $@ $<
+
+zbimage-linux-xload: $(obj)/zbimage-linux-xload
+endif
+
+ifdef CONFIG_TANGO2
+$(obj)/zbimage-linux-xload: $(obj)/vmlinux_xload.zbf
+	mkdir romfs
+	cp -f $< romfs
+	genromfs -V MIPS_LINUX_XRPC -d romfs -f $@
+	cp  $(srctree)/arch/mips/boot/zbimage-linux-xload $(srctree)/
+	rm -rf romfs
+endif
+ifdef CONFIG_TANGO3
+$(obj)/zbimage-linux-xload: $(obj)/vmlinux_xload.zbf
+	mkdir romfs
+	cp -f $< romfs
+	genromfs -V MIPSLINUX_XLOAD -d romfs -f $@
+	cp  $(srctree)/arch/mips/boot/zbimage-linux-xload $(srctree)/
+	rm -rf romfs
+endif
+ifdef CONFIG_TANGO4
+$(obj)/zbimage-linux-xload: $(obj)/vmlinux_xload.zbf
+	mkdir romfs
+	cp -f $< romfs
+	genromfs -V MIPSLINUX_XLOAD -d romfs -f $@
+	cp  $(srctree)/arch/mips/boot/zbimage-linux-xload $(srctree)/
+	rm -rf romfs
+endif
+
+
+
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/barrier.h linux-3.9.2/arch/mips/include/asm/barrier.h
--- linux-3.9.2.ref/arch/mips/include/asm/barrier.h	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/arch/mips/include/asm/barrier.h	2013-07-23 19:31:23.000000000 +0200
@@ -80,6 +80,31 @@
 #define __sync()	do { } while(0)
 #endif
 
+#if defined(CONFIG_TANGO2)
+#include <asm/tango2/emhwlib_registers_tango2.h>
+#include <asm/tango2/emhwlib_dram_tango2.h>
+#define __fast_iob()				\
+	__asm__ __volatile__(			\
+		".set	push\n\t"		\
+		".set	noreorder\n\t"		\
+		"lw	$0,%0\n\t"		\
+		"nop\n\t"			\
+		".set	pop"			\
+		: /* no output */		\
+		: "m" (*(int *)(CKSEG1+MEM_BASE_dram_controller_0+FM_RESERVED))	\
+		: "memory")
+#elif defined(CONFIG_TANGO3)
+#define __fast_iob()				\
+	__asm__ __volatile__(			\
+		".set	push\n\t"		\
+		".set	noreorder\n\t"		\
+		"lw	$0,%0\n\t"		\
+		"nop\n\t"			\
+		".set	pop"			\
+		: /* no output */		\
+		: "m" (*(int *)(CKSEG1+CPU_REMAP_SPACE))	\
+		: "memory")
+#else
 #define __fast_iob()				\
 	__asm__ __volatile__(			\
 		".set	push\n\t"		\
@@ -90,6 +115,7 @@
 		: /* no output */		\
 		: "m" (*(int *)CKSEG1)		\
 		: "memory")
+#endif
 #ifdef CONFIG_CPU_CAVIUM_OCTEON
 # define OCTEON_SYNCW_STR	".set push\n.set arch=octeon\nsyncw\nsyncw\n.set pop\n"
 # define __syncw()	__asm__ __volatile__(OCTEON_SYNCW_STR : : : "memory")
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/bootinfo.h linux-3.9.2/arch/mips/include/asm/bootinfo.h
--- linux-3.9.2.ref/arch/mips/include/asm/bootinfo.h	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/arch/mips/include/asm/bootinfo.h	2013-07-23 19:31:23.000000000 +0200
@@ -77,6 +77,12 @@
 #define  MACH_INGENIC_JZ4730	0	/* JZ4730 SOC		*/
 #define  MACH_INGENIC_JZ4740	1	/* JZ4740 SOC		*/
 
+/*
+ * Valid machtype for group SIGMADESIGNS
+ */
+#define MACH_TANGOX		1	/* TangoX */
+#define CL_SIZE			COMMAND_LINE_SIZE
+
 extern char *system_type;
 const char *get_system_type(void);
 
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/cacheflush.h linux-3.9.2/arch/mips/include/asm/cacheflush.h
--- linux-3.9.2.ref/arch/mips/include/asm/cacheflush.h	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/arch/mips/include/asm/cacheflush.h	2013-07-23 19:31:23.000000000 +0200
@@ -58,11 +58,7 @@
 		__flush_anon_page(page, vmaddr);
 }
 
-static inline void flush_icache_page(struct vm_area_struct *vma,
-	struct page *page)
-{
-}
-
+extern void (*flush_icache_page)(struct vm_area_struct *vma, struct page *page);
 extern void (*flush_icache_range)(unsigned long start, unsigned long end);
 extern void (*local_flush_icache_range)(unsigned long start, unsigned long end);
 
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/checksum.h linux-3.9.2/arch/mips/include/asm/checksum.h
--- linux-3.9.2.ref/arch/mips/include/asm/checksum.h	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/arch/mips/include/asm/checksum.h	2013-07-23 19:31:23.000000000 +0200
@@ -15,6 +15,8 @@
 
 #include <asm/uaccess.h>
 
+#include <asm/unaligned.h>
+
 /*
  * computes the checksum of a memory block at buff, length len,
  * and adds in "sum" (32-bit)
@@ -102,26 +104,30 @@
 {
 	const unsigned int *word = iph;
 	const unsigned int *stop = word + ihl;
-	unsigned int csum;
+	unsigned int csum, tmp;
 	int carry;
 
-	csum = word[0];
-	csum += word[1];
-	carry = (csum < word[1]);
+	csum = get_unaligned(word);
+	tmp = get_unaligned(word + 1);
+	csum += tmp;
+	carry = (csum < tmp);
 	csum += carry;
 
-	csum += word[2];
-	carry = (csum < word[2]);
+	tmp = get_unaligned(word + 2);
+	csum += tmp;
+	carry = (csum < tmp);
 	csum += carry;
 
-	csum += word[3];
-	carry = (csum < word[3]);
+	tmp = get_unaligned(word + 3);
+	csum += tmp;
+	carry = (csum < tmp);
 	csum += carry;
 
 	word += 4;
 	do {
-		csum += *word;
-		carry = (csum < *word);
+		tmp = get_unaligned(word);
+		csum += tmp;
+		carry = (csum < tmp);
 		csum += carry;
 		word++;
 	} while (word != stop);
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/compiler.h linux-3.9.2/arch/mips/include/asm/compiler.h
--- linux-3.9.2.ref/arch/mips/include/asm/compiler.h	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/arch/mips/include/asm/compiler.h	2013-07-23 19:31:23.000000000 +0200
@@ -16,4 +16,13 @@
 #define GCC_REG_ACCUM "accum"
 #endif
 
+#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4)
+#define GCC_NO_H_CONSTRAINT
+#ifdef CONFIG_64BIT
+typedef unsigned int uintx_t __attribute__((mode(TI)));
+#else
+typedef u64 uintx_t;
+#endif
+#endif
+
 #endif /* _ASM_COMPILER_H */
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/delay.h linux-3.9.2/arch/mips/include/asm/delay.h
--- linux-3.9.2.ref/arch/mips/include/asm/delay.h	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/arch/mips/include/asm/delay.h	2013-07-23 19:31:23.000000000 +0200
@@ -18,7 +18,12 @@
 extern void __udelay(unsigned long us);
 
 #define ndelay(ns) __ndelay(ns)
+#ifdef CONFIG_TANGOX
+void tangox_udelay(unsigned usec);
+#define udelay(usecs) tangox_udelay(usecs)
+#else
 #define udelay(us) __udelay(us)
+#endif
 
 /* make sure "usecs *= ..." in udelay do not overflow. */
 #if HZ >= 1000
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/dma.h linux-3.9.2/arch/mips/include/asm/dma.h
--- linux-3.9.2.ref/arch/mips/include/asm/dma.h	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/arch/mips/include/asm/dma.h	2013-07-23 19:31:23.000000000 +0200
@@ -86,6 +86,8 @@
 #if defined(CONFIG_SGI_IP22) || defined(CONFIG_SGI_IP28)
 /* don't care; ISA bus master won't work, ISA slave DMA supports 32bit addr */
 #define MAX_DMA_ADDRESS		PAGE_OFFSET
+#elif defined(CONFIG_TANGOX)
+#define MAX_DMA_ADDRESS		(PAGE_OFFSET + 0x20000000)
 #else
 #define MAX_DMA_ADDRESS		(PAGE_OFFSET + 0x01000000)
 #endif
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/io.h linux-3.9.2/arch/mips/include/asm/io.h
--- linux-3.9.2.ref/arch/mips/include/asm/io.h	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/arch/mips/include/asm/io.h	2013-07-23 19:31:23.000000000 +0200
@@ -339,6 +339,7 @@
 			local_irq_restore(__flags);			\
 	} else								\
 		BUG();							\
+	__sync();                                                       \
 }									\
 									\
 static inline type pfx##read##bwlq(const volatile void __iomem *mem)	\
@@ -382,7 +383,7 @@
 									\
 	war_octeon_io_reorder_wmb();					\
 									\
-	__addr = (void *)__swizzle_addr_##bwlq(mips_io_port_base + port); \
+	__addr = (void *)(mips_io_port_base + __swizzle_addr_##bwlq(port)); \
 									\
 	__val = pfx##ioswab##bwlq(__addr, val);				\
 									\
@@ -390,6 +391,7 @@
 	BUILD_BUG_ON(sizeof(type) > sizeof(unsigned long));		\
 									\
 	*__addr = __val;						\
+	__sync();                                                       \
 	slow;								\
 }									\
 									\
@@ -398,7 +400,7 @@
 	volatile type *__addr;						\
 	type __val;							\
 									\
-	__addr = (void *)__swizzle_addr_##bwlq(mips_io_port_base + port); \
+	__addr = (void *)(mips_io_port_base + __swizzle_addr_##bwlq(port)); \
 									\
 	BUILD_BUG_ON(sizeof(type) > sizeof(unsigned long));		\
 									\
@@ -554,6 +556,15 @@
 	memcpy((void __force *) dst, src, count);
 }
 
+/* Create a virtual mapping cookie for an IO port range */
+extern void __iomem *ioport_map(unsigned long port, unsigned int nr);
+extern void ioport_unmap(void __iomem *);
+
+/* Create a virtual mapping cookie for a PCI BAR (memory or IO) */
+struct pci_dev;
+extern void __iomem *pci_iomap(struct pci_dev *dev, int bar, unsigned long max);
+extern void pci_iounmap(struct pci_dev *dev, void __iomem *);
+
 /*
  * The caches on some architectures aren't dma-coherent and have need to
  * handle this in software.  There are three types of operations that
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/mach-tango2/dma-coherence.h linux-3.9.2/arch/mips/include/asm/mach-tango2/dma-coherence.h
--- linux-3.9.2.ref/arch/mips/include/asm/mach-tango2/dma-coherence.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/mach-tango2/dma-coherence.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,140 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * 
+ *
+ */
+#ifndef __ASM_MACH_TANGO2_DMA_COHERENCE_H
+#define __ASM_MACH_TANGO2_DMA_COHERENCE_H
+
+
+struct device;
+
+#include <linux/export.h>
+#include <asm/tango2/hardware.h>
+
+extern unsigned long g_pcimem_busaddr;
+extern unsigned long g_pcimem_physaddr;
+extern unsigned long g_pcimem_physaddr_end;
+extern struct bus_type pci_bus_type;
+
+#ifdef CONFIG_PCI
+#define IS_PCIDEV(x)	(((x) != NULL) && ((x)->bus == &pci_bus_type))
+#else
+#define IS_PCIDEV(x)	0
+#endif
+
+#ifdef CONFIG_PCI
+static inline unsigned long __pci_phys_to_bus(unsigned long physaddr)
+{
+	if ((physaddr < g_pcimem_physaddr) || (physaddr >= g_pcimem_physaddr_end)) {
+		printk("phys2bus: Not a dma-able address: 0x%08lx\n", physaddr);
+		return 0;
+	}
+	return (unsigned long)((physaddr - g_pcimem_physaddr) + g_pcimem_busaddr);
+}
+
+static inline unsigned long __pci_virt_to_bus(unsigned long virt)
+{
+	return __pci_phys_to_bus(CPHYSADDR(virt));
+}
+
+static inline unsigned long __pci_bus_to_phys(unsigned long busaddr) 
+{
+	if ((busaddr < g_pcimem_busaddr) ||
+	    (busaddr >= (g_pcimem_busaddr + (g_pcimem_physaddr_end - g_pcimem_physaddr)))) {
+		printk("bus2phys: Not a valid bus address: 0x%08lx\n", busaddr);
+		return 0;
+	}
+	return (unsigned long)(busaddr - g_pcimem_busaddr) + g_pcimem_physaddr;
+}
+
+static inline unsigned long __pci_bus_to_virt(unsigned long busaddr)
+{
+	return (unsigned long)phys_to_virt(__pci_bus_to_phys(busaddr));
+}
+#else
+static inline unsigned long __pci_virt_to_bus(unsigned long addr)
+{
+	BUG();
+	return 0;
+}
+
+static inline unsigned long __pci_bus_to_virt(unsigned long addr)
+{
+	BUG();
+	return 0;
+}
+#endif
+
+static inline dma_addr_t plat_map_dma_mem(struct device *dev, void *addr,
+	size_t size)
+{
+#ifdef CONFIG_PCI
+	if (IS_PCIDEV(dev))
+		return __pci_virt_to_bus((unsigned long)addr);
+#endif
+	return tangox_dma_address((unsigned long)addr);
+}
+
+static inline dma_addr_t plat_map_dma_mem_page(struct device *dev,
+	struct page *page)
+{
+#ifdef CONFIG_PCI
+	if (IS_PCIDEV(dev))
+		return __pci_virt_to_bus((unsigned long)page_to_phys(page));
+#endif
+	return tangox_dma_address(page_to_phys(page));
+}
+
+/* This is almost certainly wrong but it's what dma-ip32.c used to use	*/
+static inline unsigned long plat_dma_addr_to_phys(struct device *dev,
+	dma_addr_t dma_addr)
+{
+#ifdef CONFIG_PCI
+	if (IS_PCIDEV(dev)) {
+		if ((dma_addr >= g_pcimem_busaddr) &&
+		    (dma_addr < (g_pcimem_busaddr + (g_pcimem_physaddr_end - g_pcimem_physaddr)))) 
+			return __pci_bus_to_phys(dma_addr);
+	}
+#endif
+	return tangox_inv_dma_address(dma_addr);
+}
+
+static inline void plat_unmap_dma_mem(struct device *dev, dma_addr_t dma_addr,
+	size_t size, enum dma_data_direction direction)
+{
+}
+
+static inline int plat_dma_supported(struct device *dev, u64 mask)
+{
+	/*
+	 * we fall back to GFP_DMA when the mask isn't all 1s,
+	 * so we can't guarantee allocations that must be
+	 * within a tighter range than GFP_DMA..
+	 */
+	if (mask < DMA_BIT_MASK(24))
+		return 0;
+
+	return 1;
+}
+
+static inline void plat_extra_sync_for_device(struct device *dev)
+{
+	return;
+}
+
+static inline int plat_dma_mapping_error(struct device *dev,
+					 dma_addr_t dma_addr)
+{
+	return (dma_addr == 0) ? 1 : 0;
+}
+
+static inline int plat_device_is_coherent(struct device *dev)
+{
+	return 0; /* Always noncoherent for Tango2/3/4 */	
+}
+
+#endif /* __ASM_MACH_TANGO2_DMA_COHERENCE_H */
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/mach-tango2/irq.h linux-3.9.2/arch/mips/include/asm/mach-tango2/irq.h
--- linux-3.9.2.ref/arch/mips/include/asm/mach-tango2/irq.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/mach-tango2/irq.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,8 @@
+
+#ifndef __ASM_MACH_TANGO2_IRQ_H
+#define __ASM_MACH_TANGO2_IRQ_H
+
+#define MIPS_CPU_IRQ_BASE 0
+#define NR_IRQS 256
+
+#endif
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/mach-tango2/param.h linux-3.9.2/arch/mips/include/asm/mach-tango2/param.h
--- linux-3.9.2.ref/arch/mips/include/asm/mach-tango2/param.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/mach-tango2/param.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,5 @@
+
+#ifndef __ASM_MACH_TANGO2_PARAM_H
+#define __ASM_MACH_TANGO2_PARAM_H
+
+#endif /* __ASM_MACH_TANGO2_PARAM_H */
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/mach-tango2/spaces.h linux-3.9.2/arch/mips/include/asm/mach-tango2/spaces.h
--- linux-3.9.2.ref/arch/mips/include/asm/mach-tango2/spaces.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/mach-tango2/spaces.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,36 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2007 Sigma Designs, Inc.
+ * Copyright (C) 1994 - 1999, 2000, 03, 04 Ralf Baechle
+ * Copyright (C) 2000, 2002  Maciej W. Rozycki
+ * Copyright (C) 1990, 1999, 2000 Silicon Graphics, Inc.
+ */
+#ifndef _ASM_MACH_TANGO2_SPACES_H
+#define _ASM_MACH_TANGO2_SPACES_H
+
+#define PHYS_OFFSET             0x00000000UL
+#define CAC_BASE		0x80000000UL
+#define IO_BASE			0xa0000000UL
+#define UNCAC_BASE		0xa0000000UL
+#define MAP_BASE		0xc0000000UL
+
+
+#define FIXADDR_TOP		((unsigned long)(long)(int)0xfffe0000)
+
+/*
+ * This handles the memory map.
+ * We handle pages at KSEG0 for kernels with 32 bit address space.
+ */
+#define PAGE_OFFSET		0x80000000UL
+
+/*
+ * Memory above this physical address will be considered highmem.
+ */
+#ifndef HIGHMEM_START
+#define HIGHMEM_START		0x20000000UL
+#endif
+
+#endif /* __ASM_MACH_TANGO2_SPACES_H */
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/mach-tango2/war.h linux-3.9.2/arch/mips/include/asm/mach-tango2/war.h
--- linux-3.9.2.ref/arch/mips/include/asm/mach-tango2/war.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/mach-tango2/war.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,26 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2002, 2004, 2007 by Ralf Baechle <ralf@linux-mips.org>
+ */
+#ifndef __ASM_MIPS_MACH_TANGO2_WAR_H
+#define __ASM_MIPS_MACH_TANGO2_WAR_H
+
+#define R4600_V1_INDEX_ICACHEOP_WAR	0
+#define R4600_V1_HIT_CACHEOP_WAR	0
+#define R4600_V2_HIT_CACHEOP_WAR	0
+#define R5432_CP0_INTERRUPT_WAR		0
+#define BCM1250_M3_WAR			0
+#define SIBYTE_1956_WAR			0
+#define MIPS4K_ICACHE_REFILL_WAR	0
+#define MIPS_CACHE_SYNC_WAR		0
+#define TX49XX_ICACHE_INDEX_INV_WAR	0
+#define RM9000_CDEX_SMP_WAR		0
+#define ICACHE_REFILLS_WORKAROUND_WAR	0
+#define R10000_LLSC_WAR			0
+#define MIPS34K_MISSED_ITLB_WAR		0
+
+#endif /* __ASM_MIPS_MACH_TANGO2_WAR_H */
+
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/mach-tango3/dma-coherence.h linux-3.9.2/arch/mips/include/asm/mach-tango3/dma-coherence.h
--- linux-3.9.2.ref/arch/mips/include/asm/mach-tango3/dma-coherence.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/mach-tango3/dma-coherence.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,140 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * 
+ *
+ */
+#ifndef __ASM_MACH_TANGO3_DMA_COHERENCE_H
+#define __ASM_MACH_TANGO3_DMA_COHERENCE_H
+
+
+struct device;
+
+#include <linux/export.h>
+#include <asm/tango3/hardware.h>
+
+extern unsigned long g_pcimem_busaddr;
+extern unsigned long g_pcimem_physaddr;
+extern unsigned long g_pcimem_physaddr_end;
+extern struct bus_type pci_bus_type;
+
+#ifdef CONFIG_PCI
+#define IS_PCIDEV(x)	(((x) != NULL) && ((x)->bus == &pci_bus_type))
+#else
+#define IS_PCIDEV(x)	0
+#endif
+
+#ifdef CONFIG_PCI
+static inline unsigned long __pci_phys_to_bus(unsigned long physaddr)
+{
+	if ((physaddr < g_pcimem_physaddr) || (physaddr >= g_pcimem_physaddr_end)) {
+		printk("phys2bus: Not a dma-able address: 0x%08lx\n", physaddr);
+		return 0;
+	}
+	return (unsigned long)((physaddr - g_pcimem_physaddr) + g_pcimem_busaddr);
+}
+
+static inline unsigned long __pci_virt_to_bus(unsigned long virt)
+{
+	return __pci_phys_to_bus(CPHYSADDR(virt));
+}
+
+static inline unsigned long __pci_bus_to_phys(unsigned long busaddr) 
+{
+	if ((busaddr < g_pcimem_busaddr) ||
+	    (busaddr >= (g_pcimem_busaddr + (g_pcimem_physaddr_end - g_pcimem_physaddr)))) {
+		printk("bus2phys: Not a valid bus address: 0x%08lx\n", busaddr);
+		return 0;
+	}
+	return (unsigned long)(busaddr - g_pcimem_busaddr) + g_pcimem_physaddr;
+}
+
+static inline unsigned long __pci_bus_to_virt(unsigned long busaddr)
+{
+	return (unsigned long)phys_to_virt(__pci_bus_to_phys(busaddr));
+}
+#else
+static inline unsigned long __pci_virt_to_bus(unsigned long addr)
+{
+	BUG();
+	return 0;
+}
+
+static inline unsigned long __pci_bus_to_virt(unsigned long addr)
+{
+	BUG();
+	return 0;
+}
+#endif
+
+static inline dma_addr_t plat_map_dma_mem(struct device *dev, void *addr,
+	size_t size)
+{
+#ifdef CONFIG_PCI
+	if (IS_PCIDEV(dev))
+		return __pci_virt_to_bus((unsigned long)addr);
+#endif
+	return tangox_dma_address((unsigned long)addr);
+}
+
+static inline dma_addr_t plat_map_dma_mem_page(struct device *dev,
+	struct page *page)
+{
+#ifdef CONFIG_PCI
+	if (IS_PCIDEV(dev))
+		return __pci_virt_to_bus((unsigned long)page_to_phys(page));
+#endif
+	return tangox_dma_address(page_to_phys(page));
+}
+
+/* This is almost certainly wrong but it's what dma-ip32.c used to use	*/
+static inline unsigned long plat_dma_addr_to_phys(struct device *dev,
+	dma_addr_t dma_addr)
+{
+#ifdef CONFIG_PCI
+	if (IS_PCIDEV(dev)) {
+		if ((dma_addr >= g_pcimem_busaddr) &&
+		    (dma_addr < (g_pcimem_busaddr + (g_pcimem_physaddr_end - g_pcimem_physaddr)))) 
+			return __pci_bus_to_phys(dma_addr);
+	}
+#endif
+	return tangox_inv_dma_address(dma_addr);
+}
+
+static inline void plat_unmap_dma_mem(struct device *dev, dma_addr_t dma_addr,
+	size_t size, enum dma_data_direction direction)
+{
+}
+
+static inline int plat_dma_supported(struct device *dev, u64 mask)
+{
+	/*
+	 * we fall back to GFP_DMA when the mask isn't all 1s,
+	 * so we can't guarantee allocations that must be
+	 * within a tighter range than GFP_DMA..
+	 */
+	if (mask < DMA_BIT_MASK(24))
+		return 0;
+
+	return 1;
+}
+
+static inline void plat_extra_sync_for_device(struct device *dev)
+{
+	return;
+}
+
+static inline int plat_dma_mapping_error(struct device *dev,
+					 dma_addr_t dma_addr)
+{
+	return (dma_addr == 0) ? 1 : 0;
+}
+
+static inline int plat_device_is_coherent(struct device *dev)
+{
+	return 0; /* Always noncoherent for Tango2/3/4 */	
+}
+
+#endif /* __ASM_MACH_TANGO3_DMA_COHERENCE_H */
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/mach-tango3/irq.h linux-3.9.2/arch/mips/include/asm/mach-tango3/irq.h
--- linux-3.9.2.ref/arch/mips/include/asm/mach-tango3/irq.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/mach-tango3/irq.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,8 @@
+
+#ifndef __ASM_MACH_TANGO3_IRQ_H
+#define __ASM_MACH_TANGO3_IRQ_H
+
+#define MIPS_CPU_IRQ_BASE 0
+#define NR_IRQS 256
+
+#endif
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/mach-tango3/param.h linux-3.9.2/arch/mips/include/asm/mach-tango3/param.h
--- linux-3.9.2.ref/arch/mips/include/asm/mach-tango3/param.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/mach-tango3/param.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,5 @@
+
+#ifndef __ASM_MACH_TANGO3_PARAM_H
+#define __ASM_MACH_TANGO3_PARAM_H
+
+#endif /* __ASM_MACH_TANGO3_PARAM_H */
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/mach-tango3/spaces.h linux-3.9.2/arch/mips/include/asm/mach-tango3/spaces.h
--- linux-3.9.2.ref/arch/mips/include/asm/mach-tango3/spaces.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/mach-tango3/spaces.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,35 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2007 Sigma Designs, Inc.
+ * Copyright (C) 1994 - 1999, 2000, 03, 04 Ralf Baechle
+ * Copyright (C) 2000, 2002  Maciej W. Rozycki
+ * Copyright (C) 1990, 1999, 2000 Silicon Graphics, Inc.
+ */
+#ifndef _ASM_MACH_TANGO3_SPACES_H
+#define _ASM_MACH_TANGO3_SPACES_H
+
+#define PHYS_OFFSET             0x00000000UL
+#define CAC_BASE		0x80000000UL
+#define IO_BASE			0xa0000000UL
+#define UNCAC_BASE		0xa0000000UL
+#define MAP_BASE		0xc0000000UL
+
+#define FIXADDR_TOP		((unsigned long)(long)(int)0xfffe0000)
+
+/*
+ * This handles the memory map.
+ * We handle pages at KSEG0 for kernels with 32 bit address space.
+ */
+#define PAGE_OFFSET		0x80000000UL
+
+/*
+ * Memory above this physical address will be considered highmem.
+ */
+#ifndef HIGHMEM_START
+#define HIGHMEM_START		0x20000000UL
+#endif
+
+#endif /* __ASM_MACH_TANGO3_SPACES_H */
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/mach-tango3/war.h linux-3.9.2/arch/mips/include/asm/mach-tango3/war.h
--- linux-3.9.2.ref/arch/mips/include/asm/mach-tango3/war.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/mach-tango3/war.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,26 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2002, 2004, 2007 by Ralf Baechle <ralf@linux-mips.org>
+ */
+#ifndef __ASM_MIPS_MACH_TANGO3_WAR_H
+#define __ASM_MIPS_MACH_TANGO3_WAR_H
+
+#define R4600_V1_INDEX_ICACHEOP_WAR	0
+#define R4600_V1_HIT_CACHEOP_WAR	0
+#define R4600_V2_HIT_CACHEOP_WAR	0
+#define R5432_CP0_INTERRUPT_WAR		0
+#define BCM1250_M3_WAR			0
+#define SIBYTE_1956_WAR			0
+#define MIPS4K_ICACHE_REFILL_WAR	0
+#define MIPS_CACHE_SYNC_WAR		0
+#define TX49XX_ICACHE_INDEX_INV_WAR	0
+#define RM9000_CDEX_SMP_WAR		0
+#define ICACHE_REFILLS_WORKAROUND_WAR	0
+#define R10000_LLSC_WAR			0
+#define MIPS34K_MISSED_ITLB_WAR		0
+
+#endif /* __ASM_MIPS_MACH_TANGO3_WAR_H */
+
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango2/emhwlib_dram.h linux-3.9.2/arch/mips/include/asm/tango2/emhwlib_dram.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango2/emhwlib_dram.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango2/emhwlib_dram.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,65 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/**
+  @file   emhwlib_dram.h
+  @brief  
+
+  fm stands for: first megabyte.
+
+  THE CODE USING THESE SYMBOLS ASSUMES THAT THE END BOUNDARY OF AN
+  ENTITY IS THE START BOUNDARY OF THE NEXT ENTITY
+  
+  htoinc.pl emhwlib_dram.h emhwlib_dram.inc
+  
+  @author Emmanuel Michon
+  @date   2004-07-26
+*/
+
+#ifndef __EMHWLIB_DRAM_H__
+#define __EMHWLIB_DRAM_H__
+
+#if EM86XX_CHIP>=EM86XX_CHIPID_TANGO2
+#include "emhwlib_dram_tango2.h"
+#else
+#include "emhwlib_dram_others.h"
+#endif
+
+#define MEMCFG_SIGNATURE	0x6766636d // `m' `c' `f' `g'
+
+#ifndef __ASSEMBLY__
+
+/* This is the memory map data structure, the size is 64 bytes */
+typedef struct {
+	unsigned int signature;                                                           // ...fc0
+	unsigned int dram0_size;            /* The size of DRAM0 */
+	unsigned int dram1_size;            /* The size of DRAM1 */
+	unsigned int dram2_size;            /* The size of DRAM2 */
+	unsigned int dram0_removable_topreserved;     /* The size of top reserved in DRAM0   ...fd0 */
+	unsigned int dram1_removable_topreserved;     /* The size of top reserved in DRAM1 */
+	unsigned int dram0_top_removable_area;    /* for special use such as splash screen */ 
+	                                          /* users can use set and get properties on the memory reserved by this variable */
+	unsigned int dram0_fixed_topreserved;     /* The size of top reserved in DRAM0 */
+	unsigned int dram1_fixed_topreserved;     /* The size of top reserved in DRAM1       ...fe0 */
+	unsigned int dram2_fixed_topreserved;     /* The size of top reserved in DRAM2 */
+	unsigned int kernel_end;            /* The end offset of kernel */
+	unsigned int checksum;		    /* The checksum */
+#if EM86XX_CHIP>=EM86XX_CHIPID_TANGO2
+	unsigned int dram1_kernel_end;	    /* The end offset of kernel used data in second dram */
+	unsigned int curtainA0;                                                      
+	unsigned int curtainB0;
+	unsigned int curtainC;
+#else
+	unsigned int reserved[4];           /* Reserved for extension */
+#endif
+} memcfg_t;
+
+#endif /* __ASSEMBLY__ */
+
+#endif // __EMHWLIB_DRAM_H__
+ 
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango2/emhwlib_dram_others.h linux-3.9.2/arch/mips/include/asm/tango2/emhwlib_dram_others.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango2/emhwlib_dram_others.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango2/emhwlib_dram_others.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,37 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/**
+  @file   emhwlib_dram_others.h
+  @brief  
+
+  Addresses appear in increasing order. It is assumed
+  that computing FM_IRQHANDLER_STACKTOP_USR-FM_IRQHANDLER_CODE
+  is a proper way to access the max usable size for
+  FM_IRQHANDLER_CODE.
+
+  @author Emmanuel Michon
+  @date   2005-04-11
+*/
+
+#ifndef __EMHWLIB_DRAM_OTHERS_H__
+#define __EMHWLIB_DRAM_OTHERS_H__
+
+#define FM_MEMCFG                  0x00000fc0
+#define FM_IRQHANDLER_API          0x00001000
+#define FM_IRQHANDLER_CODE         0x00011000
+#define FM_IRQHANDLER_STACKTOP_USR 0x00040000 /* defined, but never used */
+#define FM_IRQHANDLER_STACKTOP_IRQ 0x00048000
+#define FM_IRQHANDLER_STACKTOP_FIQ 0x00050000
+#define FM_STACKTOP_SVC            0x00058000
+#define FM_DRM			   0x00058000
+#define FM_GNET			   0x00058000 /* incompatible with DRM */
+#define FM_BOOTLOADER_CODE         0x00060000
+#define FM_RESERVED                0x00080000 /* The size reserved */
+
+#endif // __EMHWLIB_DRAM_OTHERS_H__
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango2/emhwlib_dram_others.inc linux-3.9.2/arch/mips/include/asm/tango2/emhwlib_dram_others.inc
--- linux-3.9.2.ref/arch/mips/include/asm/tango2/emhwlib_dram_others.inc	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango2/emhwlib_dram_others.inc	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,25 @@
+#
+#******************************************************
+#* This file is generated automatically, DO NOT EDIT! *
+#******************************************************
+#*
+#* destined to be included by a shell script or a Makefile (keep syntax adapted to both)
+#*
+#* emhwlib/include/emhwlib_dram_others.inc (generated from emhwlib/include/emhwlib_dram_others.h)
+#*
+#* Copyright (C) Sigma Designs, Inc. 2007.
+#*
+i386=0x1
+linux=0x1
+unix=0x1
+FM_MEMCFG=0xfc0
+FM_IRQHANDLER_API=0x1000
+FM_IRQHANDLER_CODE=0x11000
+FM_IRQHANDLER_STACKTOP_USR=0x40000
+FM_IRQHANDLER_STACKTOP_IRQ=0x48000
+FM_IRQHANDLER_STACKTOP_FIQ=0x50000
+FM_STACKTOP_SVC=0x58000
+FM_DRM=0x58000
+FM_GNET=0x58000
+FM_BOOTLOADER_CODE=0x60000
+FM_RESERVED=0x80000
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango2/emhwlib_dram_tango2.h linux-3.9.2/arch/mips/include/asm/tango2/emhwlib_dram_tango2.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango2/emhwlib_dram_tango2.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango2/emhwlib_dram_tango2.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,52 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/**
+  @file   emhwlib_dram_tango2.h
+  @brief  
+
+  Addresses appear in increasing order. It is assumed that computing
+  FM_Y-FM_X is a proper way to access the max usable size for FM_X.
+
+  See SMP8630 software spec 3.3
+
+  @author Emmanuel Michon, YH Lin, Julien Soulier
+  @date   2005-04-06
+*/
+
+#ifndef __EMHWLIB_DRAM_TANGO2_H__
+#define __EMHWLIB_DRAM_TANGO2_H__
+
+/* Spec 3.3.5: stage (S4) [fully functional player memory map] */
+#define FM_GNET                    0x00000000
+#define FM_SCRATCH                 0x00000f08 /* 184 bytes */
+#define FM_MEMCFG                  0x00000fc0
+#define FM_IRQHANDLER_API          0x00001000
+#define FM_XTASK_API               0x00009e00 /* 512 bytes */
+#define FM_XOSDBG                  0x0000a000
+#define FM_XTASK1DBG               0x0000c000
+#define FM_XTASK2DBG               0x0000d000
+#define FM_XTASK3DBG               0x0000e000
+#define FM_XTASK4DBG               0x0000f000
+#define FM_SCRATCH2                0x00010000
+#define FM_DRAMCALIBRATION         0x0001f000
+#define FM_RESERVED                0x00020000
+
+/*
+  Spec 3.3.5: stage (S0) [bootstrap memory map]
+
+  Because you will use zboot/yamon to download linux/CE
+  at start of DRAM, the former are away from beginning.
+*/
+#define FM_ZBOOT                   0x01000000
+#define FM_YAMON_text_ram          0x01000000
+#define FM_YAMON__ftext_init       0x01200000
+#define FM_yamon_appl__ftext       0x01210000
+#define FM_linuxmips__ftext        0x00020000
+
+#endif // __EMHWLIB_DRAM_TANGO2_H__
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango2/emhwlib_dram_tango2.inc linux-3.9.2/arch/mips/include/asm/tango2/emhwlib_dram_tango2.inc
--- linux-3.9.2.ref/arch/mips/include/asm/tango2/emhwlib_dram_tango2.inc	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango2/emhwlib_dram_tango2.inc	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,32 @@
+#
+#******************************************************
+#* This file is generated automatically, DO NOT EDIT! *
+#******************************************************
+#*
+#* destined to be included by a shell script or a Makefile (keep syntax adapted to both)
+#*
+#* emhwlib/include/emhwlib_dram_tango2.inc (generated from emhwlib/include/emhwlib_dram_tango2.h)
+#*
+#* Copyright (C) Sigma Designs, Inc. 2007.
+#*
+i386=0x1
+linux=0x1
+unix=0x1
+FM_GNET=0x0
+FM_SCRATCH=0xf08
+FM_MEMCFG=0xfc0
+FM_IRQHANDLER_API=0x1000
+FM_XTASK_API=0x9e00
+FM_XOSDBG=0xa000
+FM_XTASK1DBG=0xc000
+FM_XTASK2DBG=0xd000
+FM_XTASK3DBG=0xe000
+FM_XTASK4DBG=0xf000
+FM_SCRATCH2=0x10000
+FM_DRAMCALIBRATION=0x1f000
+FM_RESERVED=0x20000
+FM_ZBOOT=0x1000000
+FM_YAMON_text_ram=0x1000000
+FM_YAMON__ftext_init=0x1200000
+FM_yamon_appl__ftext=0x1210000
+FM_linuxmips__ftext=0x20000
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango2/emhwlib_lram.h linux-3.9.2/arch/mips/include/asm/tango2/emhwlib_lram.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango2/emhwlib_lram.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango2/emhwlib_lram.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,46 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/**
+  @file   emhwlib_lram.h
+  @brief  
+
+  Map of the localram (8KBytes)
+
+  Traditionnally the start of localram is used to setup
+  a few kilobytes bootstrap routine code+data
+  (cache init, tlb init, load something bigger to DRAM, jump there).
+
+  Fixed offsets are defined in this file as communication devices
+  between hardware blocks.
+  Even debug locations must be present here.
+
+  The bootstrap routine is expected to preserve these and setup
+  its stack under LR_STACKTOP.
+
+  Keep addresses increasing in this file.
+
+  See emhwlib_resources_shared.h how some resources bw. 0 and 0x100 are used already
+  only when uCLinux is up with irq handler running
+
+  @author Emmanuel Michon
+  @date   2005-03-17
+*/
+
+#ifndef __EMHWLIB_LRAM_H__
+#define __EMHWLIB_LRAM_H__
+
+#if (EM86XX_CHIP<EM86XX_CHIPID_TANGO3)
+#include "emhwlib_lram_others.h"
+#elif (EM86XX_CHIP==EM86XX_CHIPID_TANGO3)
+#include "emhwlib_lram_tango3.h"
+#else
+#error EM86XX_CHIP is not set in RMCFLAGS: refer to rmdef/rmem86xxid.h. 
+#endif
+
+#endif // __EMHWLIB_LRAM_H__
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango2/emhwlib_lram.inc linux-3.9.2/arch/mips/include/asm/tango2/emhwlib_lram.inc
--- linux-3.9.2.ref/arch/mips/include/asm/tango2/emhwlib_lram.inc	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango2/emhwlib_lram.inc	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,41 @@
+#
+#******************************************************
+#* This file is generated automatically, DO NOT EDIT! *
+#******************************************************
+#*
+#* destined to be included by a shell script or a Makefile (keep syntax adapted to both)
+#*
+#* emhwlib_hal/include/emhwlib_lram.inc (generated from emhwlib_hal/include/emhwlib_lram.h)
+#*
+#* Copyright (c) Sigma Designs, Inc. 2003.
+#*
+i386=0x1
+linux=0x1
+unix=0x1
+LR_VSYNC_STRUCT=0x200
+LR_VSYNC_CODE=0xa00
+LR_VSYNC_END=0x1200
+LR_STACKTOP=0x1800
+LR_PCI_INTERRUPT_ENABLE=0x19ac
+LR_HOST_INTERRUPT_STATUS=0x19b0
+LR_DRAM_DMA_SUSPEND=0x19b4
+LR_SUSPEND_ACK_MPEG0=0x19b8
+LR_SUSPEND_ACK_MPEG1=0x19bc
+LR_SUSPEND_ACK_AUDIO0=0x19c0
+LR_SUSPEND_ACK_AUDIO1=0x19c4
+LR_SUSPEND_ACK_DEMUX=0x19c8
+LR_SUSPEND_ACK_IH=0x19cc
+LR_HB_IH=0x19d0
+LR_HB_HOST=0x19d4
+LR_HB_CPU=0x19d8
+LR_HB_MPEG0=0x19dc
+LR_HB_MPEG1=0x19e0
+LR_HB_AUDIO0=0x19e4
+LR_HB_AUDIO1=0x19e8
+LR_HB_DEMUX=0x19ec
+LR_HB_XPU=0x19f0
+LR_HB_VSYNC=0x19f4
+LR_SW_VAL_VSYNC_COUNT=0x19f8
+LR_SW_VAL_PIXEL_ADDR=0x19fc
+LR_XENV2_RW=0x1a00
+LR_XENV2_RO=0x1d00
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango2/emhwlib_lram_others.h linux-3.9.2/arch/mips/include/asm/tango2/emhwlib_lram_others.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango2/emhwlib_lram_others.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango2/emhwlib_lram_others.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,106 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/**
+  @file   emhwlib_lram_others.h
+  @brief  
+
+  Map of the localram (8KBytes)
+
+  Traditionnally the start of localram is used to setup
+  a few kilobytes bootstrap routine code+data
+  (cache init, tlb init, load something bigger to DRAM, jump there).
+
+  Fixed offsets are defined in this file as communication devices
+  between hardware blocks.
+  Even debug locations must be present here.
+
+  The bootstrap routine is expected to preserve these and setup
+  its stack under LR_STACKTOP.
+
+  Keep addresses increasing in this file.
+
+  See emhwlib_resources_shared.h how some resources bw. 0 and 0x100 are used already
+  only when uCLinux is up with irq handler running
+
+  @author Sebastien Beysserie
+  @date   2007-06-26
+*/
+
+#ifndef __EMHWLIB_LRAM_OTHERS_H__
+#define __EMHWLIB_LRAM_OTHERS_H__
+
+#define LR_CPU_IDLELOOP          0x00000000 /* CPU uses 0x80 bytes, up to 0x0080 */
+#define LR_UCLINUX_END           0x00000100
+
+#define LR_VSYNC_STRUCT          0x00000200 /* 2KB of data structures */
+#define LR_VSYNC_CODE            0x00000a00 /* 2KB of code */
+#define LR_VSYNC_END             0x00001200
+
+#define LR_STACKTOP              0x000017F4 /* in case a bootstrap routine needs a stack in local ram. Use this boundary */
+
+#define LR_PCI_INTERRUPT_ENABLE  0x000017F4
+#define LR_HOST_INTERRUPT_STATUS 0x000017F8
+#define LR_CPU_BRU_JUMP          0x000017FC /* `bootrom_ucos jump' (debug purpose) */
+
+#define LR_MU_PROFILE_STATUS     0x00001800
+
+#define LR_DRAM_DMA_SUSPEND               0x00001c8c
+#define LR_SUSPEND_ACK_MPEG0              0x00001c90
+#define LR_SUSPEND_ACK_MPEG1              0x00001c94
+#define LR_SUSPEND_ACK_AUDIO0             0x00001c98
+#define LR_SUSPEND_ACK_AUDIO1             0x00001c9c
+#define LR_SUSPEND_ACK_DEMUX0             0x00001ca0
+#define LR_SUSPEND_ACK_IH                 0x00001ca4
+
+#define LR_HB_IH                 0x00001ca8
+
+#define LR_IH_LOG_FIFO           0x00001cac /* in some cases (splash screen) find the location of the log_fifo is not that easy. Read it here. */
+
+#define LR_HB_HOST               0x00001cb0
+#define LR_HB_CPU                0x00001cb4
+#define LR_HB_MPEG0              0x00001cb8
+#define LR_HB_MPEG1              0x00001cbc
+#define LR_HB_AUDIO0             0x00001cc0
+#define LR_HB_AUDIO1             0x00001cc4
+#define LR_HB_DEMUX0             0x00001cc8
+#define LR_HB_XPU                0x00001ccc
+
+#define LR_IDMA                  0x00001cd0 /* 16bytes. Obsoletizes LR_HMMAD */
+
+#define LR_ETH_MAC_LO            0x00001ce0 /* Ethernet MAC addr low 4 bytes */
+#define LR_ETH_MAC_HI            0x00001ce4 /* Ethernet MAC addr high bytes */
+#define LR_HB_VSYNC              0x00001ce8
+ 
+#define LR_SW_VAL_VSYNC_COUNT    0x00001cec /* this location is used to count captured VSYNC */
+#define LR_SW_VAL_PIXEL_ADDR     0x00001cf0 /* this location is used to store a pixel address to write the frame count */
+
+#define LR_HMMAD                 0x00001cf4
+#define LR_KEY_ZONE              0x00001D00 /* 0x200 bytes, up to 0x1F00 */
+#define LR_YAMON_DIGITS          0x00001F00
+#define LR_XPU_DUMP              0x00001F00 /* 0x80 bytes, up to 0x1F80 */
+
+#define LR_VSYNC_PERIOD          0x00001FA0 /* 0x20 bytes, up to 0x1FC0 */
+
+#define LR_RANDOM_SEED           0x00001FC8 /* 0x08 bytes, up to 0x1FD0 */
+#define LR_LOCAL_DEBUG_PROBE     0x00001FD0 /* 0x20 bytes, up to 0x1FF0 */
+
+#define LR_XENV_LOCATION         0x00001FF0 /* Location of XENV, found by XOS */
+#define LR_GNET_MAC              0x00001FF4
+#define LR_ZBOOT_STAGE           0x00001FF8
+#define LR_XPU_STAGE             0x00001FFC
+
+/* for backward compatibility */
+#define LR_HB_DEMUX              LR_HB_DEMUX0
+#define LR_SUSPEND_ACK_DEMUX     LR_SUSPEND_ACK_DEMUX0
+
+#if (EM86XX_CHIP == EM86XX_CHIPID_TANGO2)
+#define LR_CHANNEL_INDEX         LR_GNET_MAC
+#endif
+
+#endif // __EMHWLIB_LRAM_OTHERS_H__
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango2/emhwlib_lram_others.inc linux-3.9.2/arch/mips/include/asm/tango2/emhwlib_lram_others.inc
--- linux-3.9.2.ref/arch/mips/include/asm/tango2/emhwlib_lram_others.inc	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango2/emhwlib_lram_others.inc	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,58 @@
+#
+#******************************************************
+#* This file is generated automatically, DO NOT EDIT! *
+#******************************************************
+#*
+#* destined to be included by a shell script or a Makefile (keep syntax adapted to both)
+#*
+#* emhwlib_hal/include/emhwlib_lram_others.inc (generated from emhwlib_hal/include/emhwlib_lram_others.h)
+#*
+#* Copyright (c) Sigma Designs, Inc. 2003.
+#*
+i386=0x1
+linux=0x1
+unix=0x1
+LR_CPU_IDLELOOP=0x0
+LR_UCLINUX_END=0x100
+LR_VSYNC_STRUCT=0x200
+LR_VSYNC_CODE=0xa00
+LR_VSYNC_END=0x1200
+LR_STACKTOP=0x17f4
+LR_PCI_INTERRUPT_ENABLE=0x17f4
+LR_HOST_INTERRUPT_STATUS=0x17f8
+LR_CPU_BRU_JUMP=0x17fc
+LR_MU_PROFILE_STATUS=0x1800
+LR_DRAM_DMA_SUSPEND=0x1c8c
+LR_SUSPEND_ACK_MPEG0=0x1c90
+LR_SUSPEND_ACK_MPEG1=0x1c94
+LR_SUSPEND_ACK_AUDIO0=0x1c98
+LR_SUSPEND_ACK_AUDIO1=0x1c9c
+LR_SUSPEND_ACK_DEMUX=0x1ca0
+LR_SUSPEND_ACK_IH=0x1ca4
+LR_HB_IH=0x1ca8
+LR_IH_LOG_FIFO=0x1cac
+LR_HB_HOST=0x1cb0
+LR_HB_CPU=0x1cb4
+LR_HB_MPEG0=0x1cb8
+LR_HB_MPEG1=0x1cbc
+LR_HB_AUDIO0=0x1cc0
+LR_HB_AUDIO1=0x1cc4
+LR_HB_DEMUX=0x1cc8
+LR_HB_XPU=0x1ccc
+LR_IDMA=0x1cd0
+LR_ETH_MAC_LO=0x1ce0
+LR_ETH_MAC_HI=0x1ce4
+LR_HB_VSYNC=0x1ce8
+LR_SW_VAL_VSYNC_COUNT=0x1cec
+LR_SW_VAL_PIXEL_ADDR=0x1cf0
+LR_HMMAD=0x1cf4
+LR_KEY_ZONE=0x1d00
+LR_YAMON_DIGITS=0x1f00
+LR_XPU_DUMP=0x1f00
+LR_VSYNC_PERIOD=0x1fa0
+LR_RANDOM_SEED=0x1fc8
+LR_LOCAL_DEBUG_PROBE=0x1fd0
+LR_XENV_LOCATION=0x1ff0
+LR_GNET_MAC=0x1ff4
+LR_ZBOOT_STAGE=0x1ff8
+LR_XPU_STAGE=0x1ffc
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango2/emhwlib_lram_tango3.h linux-3.9.2/arch/mips/include/asm/tango2/emhwlib_lram_tango3.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango2/emhwlib_lram_tango3.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango2/emhwlib_lram_tango3.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,126 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/**
+  @file   emhwlib_lram_tango3.h
+  @brief  
+
+  Map of the localram (8KBytes)
+
+  Traditionnally the start of localram is used to setup
+  a few kilobytes bootstrap routine code+data
+  (cache init, tlb init, load something bigger to DRAM, jump there).
+
+  Fixed offsets are defined in this file as communication devices
+  between hardware blocks.
+  Even debug locations must be present here.
+
+  The bootstrap routine is expected to preserve these and setup
+  its stack under LR_STACKTOP.
+
+  Keep addresses increasing in this file.
+
+  See emhwlib_resources_shared.h how some resources bw. 0 and 0x100 are used already
+  only when uCLinux is up with irq handler running
+
+  @author Sebastien Beysserie
+  @date   2007-06-26
+*/
+
+#ifndef __EMHWLIB_LRAM_TANGO3_H__
+#define __EMHWLIB_LRAM_TANGO3_H__
+
+/*
+  Leaving 2.3KB to for some startup code and stack
+  
+  as long as the value of this symbol moves only up with time, backward compatibility is ok */
+#define LR_STACKTOP              0x00000900
+
+#define LR_XOS2K_C2X             0x00000900
+#define LR_XOS2K_X2C             0x00000a00
+#define LR_XOS2K_I2X             0x00000b00
+#define LR_XOS2K_X2I             0x00000c00
+#define LR_XOS2K_END             0x00000d00
+
+#define LR_VSYNC_STRUCT          0x00000d00
+
+/*
+  shortcoming to be address with first hw releases
+
+  and garbles lram round 0x1680-0x1800
+ */
+#define LR_SHUTTLE_STACKTOP      0x00001800
+
+#define LR_VSYNC_STRUCT_END      0x00001900
+
+/*
+  range from LR_STACKTOP to the first of the below block is 
+  reserved for future use (~100 slots)
+ */
+#define LR_CPU_BOOTSEL           0x00001950 /* relying on the fact the soft reset & cpu bist does not clear lram */
+#define LR_CPU_PERF0_CTRL        0x00001954
+#define LR_CPU_PERF0_CNT         0x00001958
+#define LR_CPU_PERF1_CTRL        0x0000195c
+#define LR_CPU_PERF1_CNT         0x00001960
+#define LR_HB_AUDIO2             0x00001964 /* to check if AUDIO2 will coexist with DEMUX1 */
+#define LR_SUSPEND_ACK_AUDIO2    0x00001968
+#define LR_HB_DEMUX1             0x0000196c
+#define LR_SUSPEND_ACK_DEMUX1    0x00001970
+#define LR_VSYNC_PERIOD          0x00001974 /* 0x20 bytes */
+
+#define LR_ZBOOTXENV_LOCATION    0x00001994
+#define LR_BAT_D0                0x00001998
+#define LR_BAT_D1                0x0000199c
+
+/* rather use the http://bugs.soft.sdesigns.com/twiki/bin/view/Main/SevenSegmentDisplay if you can */
+#define LR_ZBOOT_STAGE           0x000019a0 
+
+#define LR_CHANNEL_INDEX         0x000019a4
+#define LR_HB_IPU                0x000019a8
+#define LR_PCI_INTERRUPT_ENABLE  0x000019ac
+#define LR_HOST_INTERRUPT_STATUS 0x000019b0
+#define LR_DRAM_DMA_SUSPEND      0x000019b4
+#define LR_SUSPEND_ACK_MPEG0     0x000019b8
+#define LR_SUSPEND_ACK_MPEG1     0x000019bc
+#define LR_SUSPEND_ACK_AUDIO0    0x000019c0
+#define LR_SUSPEND_ACK_AUDIO1    0x000019c4
+#define LR_SUSPEND_ACK_DEMUX0    0x000019c8
+#define LR_SUSPEND_ACK_IH        0x000019cc
+#define LR_HB_IH                 0x000019d0
+#define LR_HB_HOST               0x000019d4
+#define LR_HB_CPU                0x000019d8
+#define LR_HB_MPEG0              0x000019dc
+#define LR_HB_MPEG1              0x000019e0
+#define LR_HB_AUDIO0             0x000019e4
+#define LR_HB_AUDIO1             0x000019e8
+#define LR_HB_DEMUX0             0x000019ec
+/* empty slot here keep it so til mid2008 */
+#define LR_HB_VSYNC              0x000019f4
+#define LR_SW_VAL_VSYNC_COUNT    0x000019f8 /* this location is used to count captured VSYNC */
+#define LR_SW_VAL_PIXEL_ADDR     0x000019fc /* this location is used to store a pixel address to write the frame count */
+
+#define LR_XENV2_RW              0x00001a00 /* up to 628 bytes */
+
+#define LR_XOS_DUMP              0x00001c74 /* xtask dump --- might change */
+#define LR_XENV2_RO              0x00001d00 /* up to the end, 512 bytes. This area is written by xpu, r.o. for others */
+
+#define LR_XOS_SECOND_COUNT      0x00001f74 /* second counter */
+#define LR_XOS_SECOND_COUNT_ATX  0x00001f78 /* value of xtal cnt at last update of second counter */
+#define LR_XOS_F_SYS_HZ          0x00001f7c /* system frequency in Hz */
+#define LR_XOS_C2X_RO            0x00001f80 /* xos trusted copies of channel structures */
+#define LR_XOS_X2C_RO            0x00001fa0
+#define LR_XOS_I2X_RO            0x00001fc0
+#define LR_XOS_X2I_RO            0x00001fe0
+
+/* for backward compatibility */
+#define LR_HB_DEMUX              LR_HB_DEMUX0
+#define LR_SUSPEND_ACK_DEMUX     LR_SUSPEND_ACK_DEMUX0
+
+#define LR_HB_XPU LR_XOS_SECOND_COUNT
+
+#endif // __EMHWLIB_LRAM_TANGO3_H__
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango2/emhwlib_lram_tango3.inc linux-3.9.2/arch/mips/include/asm/tango2/emhwlib_lram_tango3.inc
--- linux-3.9.2.ref/arch/mips/include/asm/tango2/emhwlib_lram_tango3.inc	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango2/emhwlib_lram_tango3.inc	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,57 @@
+#
+#******************************************************
+#* This file is generated automatically, DO NOT EDIT! *
+#******************************************************
+#*
+#* destined to be included by a shell script or a Makefile (keep syntax adapted to both)
+#*
+#* emhwlib_lram_tango3.inc (generated from emhwlib_lram_tango3.h)
+#*
+#* Copyright (c) Sigma Designs, Inc. 2003.
+#*
+i386=0x1
+linux=0x1
+unix=0x1
+LR_STACKTOP=0x900
+LR_XOS2K_C2X=0x900
+LR_XOS2K_X2C=0xa00
+LR_XOS2K_I2X=0xb00
+LR_XOS2K_X2I=0xc00
+LR_XOS2K_END=0xd00
+LR_VSYNC_STRUCT=0xd00
+LR_SHUTTLE_STACKTOP=0x1800
+LR_VSYNC_STRUCT_END=0x1900
+LR_VSYNC_PERIOD=0x1974
+LR_ZBOOTXENV_LOCATION=0x1994
+LR_BAT_D0=0x1998
+LR_BAT_D1=0x199c
+LR_BAT_D2=0x19a0
+LR_CHANNEL_INDEX=0x19a4
+LR_HB_IPU=0x19a8
+LR_PCI_INTERRUPT_ENABLE=0x19ac
+LR_HOST_INTERRUPT_STATUS=0x19b0
+LR_DRAM_DMA_SUSPEND=0x19b4
+LR_SUSPEND_ACK_MPEG0=0x19b8
+LR_SUSPEND_ACK_MPEG1=0x19bc
+LR_SUSPEND_ACK_AUDIO0=0x19c0
+LR_SUSPEND_ACK_AUDIO1=0x19c4
+LR_SUSPEND_ACK_DEMUX=0x19c8
+LR_SUSPEND_ACK_IH=0x19cc
+LR_HB_IH=0x19d0
+LR_HB_HOST=0x19d4
+LR_HB_CPU=0x19d8
+LR_HB_MPEG0=0x19dc
+LR_HB_MPEG1=0x19e0
+LR_HB_AUDIO0=0x19e4
+LR_HB_AUDIO1=0x19e8
+LR_HB_DEMUX=0x19ec
+LR_HB_XPU=0x19f0
+LR_HB_VSYNC=0x19f4
+LR_SW_VAL_VSYNC_COUNT=0x19f8
+LR_SW_VAL_PIXEL_ADDR=0x19fc
+LR_XENV2_RW=0x1a00
+LR_XENV2_RO=0x1d00
+LR_XOS_C2X_RO=0x1f80
+LR_XOS_X2C_RO=0x1fa0
+LR_XOS_I2X_RO=0x1fc0
+LR_XOS_X2I_RO=0x1fe0
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango2/emhwlib_registers_tango2.h linux-3.9.2/arch/mips/include/asm/tango2/emhwlib_registers_tango2.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango2/emhwlib_registers_tango2.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango2/emhwlib_registers_tango2.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,648 @@
+/******************************************************/
+/* This file is generated automatically, DO NOT EDIT! */
+/******************************************************/
+/*
+ * ../emhwlib_hal/include/tango2/emhwlib_registers_tango2.h
+ *
+ * Copyright (C) 2001-2007 Sigma Designs, Inc. 
+ * 
+ *
+ */
+ 
+/**
+  @file ../emhwlib_hal/include/tango2/emhwlib_registers_tango2.h
+  @brief emhwlib generated file
+   
+  @author Jacques Mahe, Christian Wolff, Julien Soulier, Emmanuel Michon
+  @ingroup hwlproperties
+*/
+
+#ifndef __EMHWLIB_REGISTERS_TANGO2_H__
+#define __EMHWLIB_REGISTERS_TANGO2_H__
+
+/* SystemBlock registers */
+#define REG_BASE_system_block 0x00010000 /* width RMuint32 */
+#define SYS_clkgen0_pll 0x0000 /* width RMuint32 */
+#define SYS_clkgen0_div 0x0004 /* width RMuint32 */
+#define SYS_clkgen1_pll 0x0008 /* width RMuint32 */
+#define SYS_clkgen1_div 0x000C /* width RMuint32 */
+#define SYS_clkgen2_pll 0x0010 /* width RMuint32 */
+#define SYS_clkgen2_div 0x0014 /* width RMuint32 */
+#define SYS_clkgen3_pll 0x0018 /* width RMuint32 */
+#define SYS_clkgen3_div 0x001C /* width RMuint32 */
+#define SYS_avclk_mux 0x0038 /* width RMuint32 */
+#define SYS_sysclk_mux 0x003C /* width RMuint32 */
+#define SYS_clk_cnt 0x0040 /* width RMuint32 */
+#define SYS_xtal_in_cnt 0x0048 /* width RMuint32 */
+#define DRAM_vbus_w0_cfg 0x0300 /* width RMuint32 */
+#define DRAM_vbus_w1_cfg 0x0304 /* width RMuint32 */
+#define DRAM_vbus_w2_cfg 0x0308 /* width RMuint32 */
+#define DRAM_vbus_w3_cfg 0x030c /* width RMuint32 */
+#define DRAM_vbus_r0_cfg 0x0340 /* width RMuint32 */
+#define DRAM_vbus_r1_cfg 0x0344 /* width RMuint32 */
+#define DRAM_vbus_r2_cfg 0x0348 /* width RMuint32 */
+#define DRAM_vbus_r3_cfg 0x034c /* width RMuint32 */
+#define DRAM_vbus_r4_cfg 0x0350 /* width RMuint32 */
+#define DRAM_vbus_r5_cfg 0x0354 /* width RMuint32 */
+#define DRAM_vbus_r6_cfg 0x0358 /* width RMuint32 */
+#define DRAM_vbus_r7_cfg 0x035c /* width RMuint32 */
+#define DRAM_vbus_r8_cfg 0x0360 /* width RMuint32 */
+#define DRAM_vbus_r9_cfg 0x0364 /* width RMuint32 */
+#define DRAM_vbus_r10_cfg 0x0368 /* width RMuint32 */
+#define DRAM_vbus_r11_cfg 0x036c /* width RMuint32 */
+#define DRAM_mbus_w0_cfg 0x0200 /* width RMuint32 */
+#define DRAM_mbus_w1_cfg 0x0204 /* width RMuint32 */
+#define DRAM_mbus_w2_cfg 0x0208 /* width RMuint32 */
+#define DRAM_mbus_w3_cfg 0x020c /* width RMuint32 */
+#define DRAM_mbus_w4_cfg 0x0210 /* width RMuint32 */
+#define DRAM_mbus_w5_cfg 0x0214 /* width RMuint32 */
+#define DRAM_mbus_w6_cfg 0x0218 /* width RMuint32 */
+#define DRAM_mbus_w7_cfg 0x021c /* width RMuint32 */
+#define DRAM_mbus_w8_cfg 0x0220 /* width RMuint32 */
+#define DRAM_mbus_w9_cfg 0x0224 /* width RMuint32 */
+#define DRAM_mbus_w10_cfg 0x0228 /* width RMuint32 */
+#define DRAM_mbus_r0_cfg 0x0240 /* width RMuint32 */
+#define DRAM_mbus_r1_cfg 0x0244 /* width RMuint32 */
+#define DRAM_mbus_r2_cfg 0x0248 /* width RMuint32 */
+#define DRAM_mbus_r3_cfg 0x024c /* width RMuint32 */
+#define DRAM_mbus_r4_cfg 0x0250 /* width RMuint32 */
+#define DRAM_mbus_r5_cfg 0x0254 /* width RMuint32 */
+#define DRAM_mbus_r6_cfg 0x0258 /* width RMuint32 */
+#define DRAM_mbus_r7_cfg 0x025c /* width RMuint32 */
+#define DRAM_mbus_r8_cfg 0x0260 /* width RMuint32 */
+#define DRAM_mbus_r9_cfg 0x0264 /* width RMuint32 */
+#define DRAM_mbus_r10_cfg 0x0268 /* width RMuint32 */
+#define SYS_hostclk_mux 0x0030 /* width RMuint32 */
+#define SYS_sysclk_premux 0x0034 /* width RMuint32 */
+#define SYS_rnd_cnt 0x0044 /* width RMuint32 */
+#define SYS_cnt_cfg 0x004c /* width RMuint32 */
+#define SYS_cfg_cnt0 0x0050 /* width RMuint32 */
+#define SYS_cfg_cnt1 0x0054 /* width RMuint32 */
+#define SYS_cfg_cnt2 0x0058 /* width RMuint32 */
+#define SYS_cfg_cnt3 0x005c /* width RMuint32 */
+#define SYS_cfg_cnt4 0x0060 /* width RMuint32 */
+#define SYS_cleandiv0_div 0x0080 /* width RMuint32 */
+#define SYS_cleandiv1_div 0x0088 /* width RMuint32 */
+#define SYS_cleandiv2_div 0x0090 /* width RMuint32 */
+#define SYS_cleandiv3_div 0x0098 /* width RMuint32 */
+#define SYS_cleandiv4_div 0x00a0 /* width RMuint32 */
+#define SYS_cleandiv5_div 0x00a8 /* width RMuint32 */
+#define SYS_cleandiv6_div 0x00b0 /* width RMuint32 */
+#define SYS_cleandiv7_div 0x00b8 /* width RMuint32 */
+#define SYS_cleandiv8_div 0x00c0 /* width RMuint32 */
+#define SYS_cleandiv9_div 0x00c8 /* width RMuint32 */
+#define SYS_cleandiv10_div 0x00d0 /* width RMuint32 */
+#define MARB_mid01_cfg 0x0200 /* width RMuint32 */
+#define MARB_mid21_cfg 0x0204 /* width RMuint32 */
+#define MARB_mid02_cfg 0x0208 /* width RMuint32 */
+#define MARB_mid22_cfg 0x020c /* width RMuint32 */
+#define MARB_mid04_cfg 0x0210 /* width RMuint32 */
+#define MARB_mid24_cfg 0x0214 /* width RMuint32 */
+#define MARB_mid25_cfg 0x0218 /* width RMuint32 */
+#define MARB_mid08_cfg 0x021c /* width RMuint32 */
+#define MARB_mid28_cfg 0x0220 /* width RMuint32 */
+#define MARB_mid29_cfg 0x0224 /* width RMuint32 */
+#define MARB_mid0C_cfg 0x0228 /* width RMuint32 */
+#define MARB_mid2C_cfg 0x022c /* width RMuint32 */
+#define MARB_mid10_cfg 0x0230 /* width RMuint32 */
+#define MARB_mid30_cfg 0x0234 /* width RMuint32 */
+#define MARB_mid31_cfg 0x0238 /* width RMuint32 */
+#define MARB_mid12_cfg 0x023c /* width RMuint32 */
+#define MARB_mid32_cfg 0x0240 /* width RMuint32 */
+#define SYS_gpio_dir 0x0500 /* width RMuint32 */
+#define SYS_gpio_data 0x0504 /* width RMuint32 */
+#define SYS_gpio_int 0x0508 /* width RMuint32 */
+#define SYS_gpio15_pwm 0x0510 /* width RMuint32 */
+#define SYS_gpio14_pwm 0x0514 /* width RMuint32 */
+#define REG_BASE_dram_controller_0 0x00030000 /* width RMuint32 */
+#define REG_BASE_dram_controller_1 0x00040000 /* width RMuint32 */
+#define MEM_BASE_dram_controller_0_alias 0x10000000 /* width RMuint32 */
+#define MEM_BASE_dram_controller_0 0x10000000 /* width RMuint32 */
+#define MEM_BASE_dram_controller_1_alias 0x20000000 /* width RMuint32 */
+#define MEM_BASE_dram_controller_1 0x20000000 /* width RMuint32 */
+#define DRAM_dunit_cfg 0x0000 /* width RMuint32 */
+#define DRAM_dunit_delay0_ctrl 0x0004 /* width RMuint32 */
+#define DRAM_dunit_delay1_ctrl 0x0008 /* width RMuint32 */
+#define DRAM_dunit_auto_delay 0x000c /* width RMuint32 */
+#define DRAM_dunit_fall_delay0 0x0010 /* width RMuint32 */
+#define DRAM_dunit_fall_delay1 0x0014 /* width RMuint32 */
+#define DRAM_dunit_bw_lobound 0x0018 /* width RMuint32 */
+#define DRAM_dunit_bw_hibound 0x001c /* width RMuint32 */
+#define DRAM_dunit_bw_probe_cfg 0x0020 /* width RMuint32 */
+#define DRAM_dunit_bw_probe_cnt 0x0024 /* width RMuint32 */
+#define DRAM_dunit_bw_cntall 0x0028 /* width RMuint32 */
+#define DRAM_dunit_calibration_delay 0x0030 /* width RMuint32 */
+#define DRAM_dunit_calibration_rise_err 0x0034 /* width RMuint32 */
+#define DRAM_dunit_calibration_fall_err 0x0038 /* width RMuint32 */
+#define DRAM_dunit_calibration_page 0x0088 /* width RMuint32 */
+#define DRAM_dunit_flush_buffer 0x0104 /* width RMuint32 */
+#define REG_BASE_host_interface 0x00020000 /* width RMuint32 */
+#define MEM_BASE_host_interface 0x40000000 /* width RMuint32 */
+#define IDE_data 0x0000 /* width RMuint32 */
+#define IDE_error 0x0004 /* width RMuint32 */
+#define IDE_count 0x0008 /* width RMuint32 */
+#define IDE_start_sector 0x000c /* width RMuint32 */
+#define IDE_cylinder_lo 0x0010 /* width RMuint32 */
+#define IDE_cylinder_hi 0x0014 /* width RMuint32 */
+#define IDE_head_device 0x0018 /* width RMuint32 */
+#define IDE_cmd_stat 0x001c /* width RMuint32 */
+#define IDE_irq_stat 0x0218 /* width RMuint32 */
+#define IDE_cmd_stat__ 0x021c /* width RMuint32 */
+#define PB_timing0 0x0800 /* width RMuint32 */
+#define PB_timing1 0x0804 /* width RMuint32 */
+#define PB_timing2 0x0808 /* width RMuint32 */
+#define PB_timing3 0x080c /* width RMuint32 */
+#define PB_timing4 0x0810 /* width RMuint32 */
+#define PB_timing5 0x0814 /* width RMuint32 */
+#define PB_default_timing 0x0818 /* width RMuint32 */
+#define PB_use_timing0 0x081c /* width RMuint32 */
+#define PB_use_timing1 0x0820 /* width RMuint32 */
+#define PB_use_timing2 0x0824 /* width RMuint32 */
+#define PB_use_timing3 0x0828 /* width RMuint32 */
+#define PB_use_timing4 0x082c /* width RMuint32 */
+#define PB_use_timing5 0x0830 /* width RMuint32 */
+#define PB_CS_config 0x0834 /* width RMuint32 */
+#define PB_automode_start_address 0x0840 /* width RMuint32 */
+#define PB_automode_control 0x0844 /* width RMuint32 */
+#define EMHWLIB_IS_HOST 0xe000 /* width RMuint32 */
+#define HOST_REG1 0xfed0 /* width RMuint32 */
+#define HOST_REG2 0xfed4 /* width RMuint32 */
+#define READ_ADDRESS 0xfec0 /* width RMuint32 */
+#define READ_COUNTER 0xfec4 /* width RMuint32 */
+#define READ_ENABLE 0xfec8 /* width RMuint32 */
+#define REV_ORDER 0xfecc /* width RMuint32 */
+#define WRITE_ADDRESS 0xfed8 /* width RMuint32 */
+#define WRITE_COUNTER 0xfedc /* width RMuint32 */
+#define WRITE_ENABLE 0xfee0 /* width RMuint32 */
+#define BURST 0xfee4 /* width RMuint32 */
+#define PCI_TIMEOUT 0x8000 /* width RMuint32 */
+#define PCI_TIMEOUT_STATUS 0x8004 /* width RMuint32 */
+#define PCI_TIMER 0x8008 /* width RMuint32 */
+#define PCI_TIMER_TEST 0x800c /* width RMuint32 */
+#define PCI_WAKEUP 0x8010 /* width RMuint32 */
+#define PCI_REGION_0_BASE 0x9000 /* width RMuint32 */
+#define PCI_REGION_1_BASE 0x9004 /* width RMuint32 */
+#define PCI_REGION_2_BASE 0x9008 /* width RMuint32 */
+#define PCI_REGION_3_BASE 0x900c /* width RMuint32 */
+#define PCI_REGION_4_BASE 0x9010 /* width RMuint32 */
+#define PCI_REGION_5_BASE 0x9014 /* width RMuint32 */
+#define PCI_REGION_6_BASE 0x9018 /* width RMuint32 */
+#define PCI_REGION_7_BASE 0x901c /* width RMuint32 */
+#define PCI_irq_status 0x9020 /* width RMuint32 */
+#define PCI_irq_set 0x9024 /* width RMuint32 */
+#define PCI_irq_clear 0x9028 /* width RMuint32 */
+#define SBOX_FIFO_RESET 0x90a0 /* width RMuint32 */
+#define SBOX_ROUTE 0x90a8 /* width RMuint32 */
+#define output_SBOX_MBUS_W0 0x9080 /* width RMuint32 */
+#define output_SBOX_MBUS_W1 0x9084 /* width RMuint32 */
+#define output_SBOX_PCI_MASTER 0x9088 /* width RMuint32 */
+#define output_SBOX_PCI_SLAVE 0x908c /* width RMuint32 */
+#define output_SBOX_CIPHER 0x9090 /* width RMuint32 */
+#define output_SBOX_IDE_ISA 0x9094 /* width RMuint32 */
+#define output_SBOX_IDE_DVD 0x9098 /* width RMuint32 */
+#define input_keep_SBOX 0 /* width RMuint32 */
+#define input_MBUS_R0_SBOX 1 /* width RMuint32 */
+#define input_MBUS_R1_SBOX 2 /* width RMuint32 */
+#define input_PCI_MASTER_SBOX 3 /* width RMuint32 */
+#define input_PCI_SLAVE_SBOX 4 /* width RMuint32 */
+#define input_CIPHER_SBOX 5 /* width RMuint32 */
+#define input_IDE_DVD_SBOX 6 /* width RMuint32 */
+#define input_IDE_ISA_SBOX 7 /* width RMuint32 */
+#define input_SFLA_SBOX 8 /* width RMuint32 */
+#define input_unconnected_SBOX 0xf /* width RMuint32 */
+#define host_mutex0 0x9040 /* width RMuint32 */
+#define host_mutex1 0x9044 /* width RMuint32 */
+#define host_mutex2 0x9048 /* width RMuint32 */
+#define host_mutex3 0x904c /* width RMuint32 */
+#define host_mutex4 0x9050 /* width RMuint32 */
+#define host_mutex5 0x9054 /* width RMuint32 */
+#define host_mutex6 0x9058 /* width RMuint32 */
+#define host_mutex7 0x905c /* width RMuint32 */
+#define host_mutex8 0x9060 /* width RMuint32 */
+#define host_mutex9 0x9064 /* width RMuint32 */
+#define host_mutex10 0x9068 /* width RMuint32 */
+#define host_mutex11 0x906c /* width RMuint32 */
+#define host_mutex12 0x9070 /* width RMuint32 */
+#define host_mutex13 0x9074 /* width RMuint32 */
+#define host_mutex14 0x9078 /* width RMuint32 */
+#define host_mutex15 0x907c /* width RMuint32 */
+#define PCI_host_reg5 0xfe94 /* width RMuint32 */
+#define PCI_chip_is_host 0xfe90 /* width RMuint32 */
+#define IDECTRL_idesrc 0x20d0 /* width RMuint32 */
+#define IDECTRL_pri_drv1udmatim1 0x20e0 /* width RMuint32 */
+#define IDECTRL_pri_drv1udmatim2 0x20f0 /* width RMuint32 */
+#define IDECTRL_pri_idectl 0x2100 /* width RMuint32 */
+#define IDECTRL_pri_drv0tim 0x2110 /* width RMuint32 */
+#define IDECTRL_pri_drv1tim 0x2120 /* width RMuint32 */
+#define IDECTRL_idemisc 0x2130 /* width RMuint32 */
+#define IDECTRL_idestatus 0x2140 /* width RMuint32 */
+#define IDECTRL_udmactl 0x2150 /* width RMuint32 */
+#define IDECTRL_pri_drv0udmatim1 0x2160 /* width RMuint32 */
+#define IDECTRL_pri_drv0udmatim2 0x2170 /* width RMuint32 */
+#define IDECTRL_pref_st 0x2310 /* width RMuint32 */
+#define IDECTRL_pri_ctrlblock 0x2398 /* width RMuint32 */
+#define IDECTRL_pri_cmdblock 0x23c0 /* width RMuint32 */
+#define IDECTRL_bmic 0x2400 /* width RMuint32 */
+#define IDECTRL_bmis 0x2410 /* width RMuint32 */
+#define IDECTRL_bmidtp 0x2420 /* width RMuint32 */
+#define IDECTRL_ide_dmaptr 0x2780 /* width RMuint32 */
+#define IDECTRL_ide_dmalen 0x2790 /* width RMuint32 */
+#define IDECTRL_pio_prefetch_data 0x27c0 /* width RMuint32 */
+#define MEM_BASE_pfla 0x40000000 /* width RMuint32 */
+#define PB_CS0_OFFSET 0x00000000 /* width RMuint32 */
+#define PB_CS1_OFFSET 0x04000000 /* width RMuint32 */
+#define PB_CS2_OFFSET 0x08000000 /* width RMuint32 */
+#define PB_CS3_OFFSET 0x0c000000 /* width RMuint32 */
+#define ETH_gpio_dir1 0x7100 /* width RMuint32 */
+#define ETH_gpio_data1 0x7104 /* width RMuint32 */
+#define ETH_gpio_mask1 0x7108 /* width RMuint32 */
+#define ETH_gpio_dir2 0x710c /* width RMuint32 */
+#define ETH_gpio_data2 0x7110 /* width RMuint32 */
+#define PCI_host_reg1 0xfed0 /* width RMuint32 */
+#define PCI_host_reg2 0xfed4 /* width RMuint32 */
+#define PCI_host_reg3 0xfe80 /* width RMuint32 */
+#define PCI_host_reg4 0xfe84 /* width RMuint32 */
+#define PCI_pcictrl_reg1 0xfe88 /* width RMuint32 */
+#define PCI_pcictrl_reg2 0xfe8c /* width RMuint32 */
+#define PCI_pcictrl_reg3 0xfefc /* width RMuint32 */
+#define PCI_REG0 0xfee8 /* width RMuint32 */
+#define PCI_REG1 0xfeec /* width RMuint32 */
+#define PCI_REG2 0xfef0 /* width RMuint32 */
+#define PCI_REG3 0xfef4 /* width RMuint32 */
+#define PCI_CONFIG 0xfef8 /* width RMuint32 */
+#define MIF_W0_ADD 0xb000 /* width RMuint32 */
+#define MIF_W0_CNT 0xb004 /* width RMuint32 */
+#define MIF_W0_SKIP 0xb008 /* width RMuint32 */
+#define MIF_W0_CMD 0xb00c /* width RMuint32 */
+#define MIF_W1_ADD 0xb040 /* width RMuint32 */
+#define MIF_W1_CNT 0xb044 /* width RMuint32 */
+#define MIF_W1_SKIP 0xb048 /* width RMuint32 */
+#define MIF_W1_CMD 0xb04c /* width RMuint32 */
+#define MIF_R0_ADD 0xb080 /* width RMuint32 */
+#define MIF_R0_CNT 0xb084 /* width RMuint32 */
+#define MIF_R0_SKIP 0xb088 /* width RMuint32 */
+#define MIF_R0_CMD 0xb08c /* width RMuint32 */
+#define MIF_R1_ADD 0xb0c0 /* width RMuint32 */
+#define MIF_R1_CNT 0xb0c4 /* width RMuint32 */
+#define MIF_R1_SKIP 0xb0c8 /* width RMuint32 */
+#define MIF_R1_CMD 0xb0cc /* width RMuint32 */
+#define MBUS_IDLE 0 /* width RMuint32 */
+#define MBUS_LINEAR 1 /* width RMuint32 */
+#define MBUS_DOUBLE 2 /* width RMuint32 */
+#define MBUS_RECTANGLE 3 /* width RMuint32 */
+#define MBUS_VOID 4 /* width RMuint32 */
+#define MBUS_LINEAR_VOID 5 /* width RMuint32 */
+#define MBUS_DOUBLE_VOID 6 /* width RMuint32 */
+#define MBUS_RECTANGLE_VOID 7 /* width RMuint32 */
+#define MBUS_TILED 8 /* width RMuint32 */
+/* SystemBlock registers done */
+
+/* CPUBlock registers */
+#define REG_BASE_cpu_block 0x00060000 /* width RMuint32 */
+#define CPU_time0_load 0xc500 /* width RMuint32 */
+#define CPU_time0_value 0xc504 /* width RMuint32 */
+#define CPU_time0_ctrl 0xc508 /* width RMuint32 */
+#define CPU_time0_clr 0xc50c /* width RMuint32 */
+#define CPU_time1_load 0xc600 /* width RMuint32 */
+#define CPU_time1_value 0xc604 /* width RMuint32 */
+#define CPU_time1_ctrl 0xc608 /* width RMuint32 */
+#define CPU_time1_clr 0xc60c /* width RMuint32 */
+#define CPU_rtc_data 0xc800 /* width RMuint32 */
+#define CPU_rtc_match 0xc804 /* width RMuint32 */
+#define CPU_rtc_stat 0xc808 /* width RMuint32 */
+#define CPU_rtc_load 0xc80c /* width RMuint32 */
+#define CPU_rtc_ctrl 0xc810 /* width RMuint32 */
+#define CPU_irq_status 0xe000 /* width RMuint32 */
+#define CPU_irq_rawstat 0xe004 /* width RMuint32 */
+#define CPU_irq_enableset 0xe008 /* width RMuint32 */
+#define CPU_irq_enableclr 0xe00c /* width RMuint32 */
+#define CPU_irq_softset 0xe010 /* width RMuint32 */
+#define CPU_irq_softclr 0xe014 /* width RMuint32 */
+#define CPU_fiq_status 0xe100 /* width RMuint32 */
+#define CPU_fiq_rawstat 0xe104 /* width RMuint32 */
+#define CPU_fiq_enableset 0xe108 /* width RMuint32 */
+#define CPU_fiq_enableclr 0xe10c /* width RMuint32 */
+#define CPU_fiq_softset 0xe110 /* width RMuint32 */
+#define CPU_fiq_softclr 0xe114 /* width RMuint32 */
+#define CPU_edge_status 0xe200 /* width RMuint32 */
+#define CPU_edge_rawstat 0xe204 /* width RMuint32 */
+#define CPU_edge_config_rise 0xe208 /* width RMuint32 */
+#define CPU_edge_config_fall 0xe20c /* width RMuint32 */
+#define CPU_SOFT_INT 0x00000001 /* width RMuint32 */
+#define CPU_UART0_INT 0x00000002 /* width RMuint32 */
+#define CPU_UART1_INT 0x00000004 /* width RMuint32 */
+#define CPU_TIMER0_INT 0x00000020 /* width RMuint32 */
+#define CPU_TIMER1_INT 0x00000040 /* width RMuint32 */
+#define CPU_HOST_MBUS_W0_INT 0x00000200 /* width RMuint32 */
+#define CPU_HOST_MBUS_W1_INT 0x00000400 /* width RMuint32 */
+#define CPU_HOST_MBUS_R0_INT 0x00000800 /* width RMuint32 */
+#define CPU_HOST_MBUS_R1_INT 0x00001000 /* width RMuint32 */
+#define CPU_PCI_INTA 0x00002000 /* width RMuint32 */
+#define CPU_PCI_INTB 0x00004000 /* width RMuint32 */
+#define CPU_PCI_INTC 0x00008000 /* width RMuint32 */
+#define CPU_PCI_INTD 0x00010000 /* width RMuint32 */
+#define CPU_PCI_FAULT_INT 0x00100000 /* width RMuint32 */
+#define CPU_INFRARED_INT 0x00200000 /* width RMuint32 */
+#define CPU_SFLA_INT 0x00000010 /* width RMuint32 */
+#define CPU_DVD_INT 0x00000080 /* width RMuint32 */
+#define CPU_ETH_INT 0x00000100 /* width RMuint32 */
+#define CPU_DMAIDE_INT 0x00020000 /* width RMuint32 */
+#define CPU_IDE_INT 0x00040000 /* width RMuint32 */
+#define CPU_FRONTPANEL_INT 0x00080000 /* width RMuint32 */
+#define CPU_I2C_INT 0x00400000 /* width RMuint32 */
+#define CPU_GFX_ACCEL_INT 0x00800000 /* width RMuint32 */
+#define CPU_VSYNC0_INT 0x01000000 /* width RMuint32 */
+#define CPU_VSYNC1_INT 0x02000000 /* width RMuint32 */
+#define CPU_VSYNC2_INT 0x04000000 /* width RMuint32 */
+#define CPU_VSYNC3_INT 0x08000000 /* width RMuint32 */
+#define CPU_VSYNC4_INT 0x10000000 /* width RMuint32 */
+#define CPU_VSYNC4BKEND_INT 0x20000000 /* width RMuint32 */
+#define CPU_VSYNC5_INT 0x40000000 /* width RMuint32 */
+#define CPU_VSYNC5BKEND_INT 0x80000000 /* width RMuint32 */
+#define CPU_SMARTCARD_HI_INT 0x00000001 /* width RMuint32 */
+#define CPU_HDMI_HI_INT 0x00000002 /* width RMuint32 */
+#define CPU_HDMI_I2C_HI_INT 0x00000004 /* width RMuint32 */
+#define CPU_VBUS_W0_HI_INT 0x00000008 /* width RMuint32 */
+#define CPU_VBUS_W3_HI_INT 0x00000010 /* width RMuint32 */
+#define CPU_ETH_PHY_HI_INT 0x00000020 /* width RMuint32 */
+#define CPU_ETH_MAC_HI_INT 0x00000040 /* width RMuint32 */
+#define CPU_USB_OHCI_MAC_HI_INT 0x00000080 /* width RMuint32 */
+#define CPU_USB_EHCI_MAC_HI_INT 0x00000100 /* width RMuint32 */
+#define LOG2_CPU_SOFT_INT 0 /* width RMuint32 */
+#define LOG2_CPU_UART0_INT 1 /* width RMuint32 */
+#define LOG2_CPU_UART1_INT 2 /* width RMuint32 */
+#define LOG2_CPU_TIMER0_INT 5 /* width RMuint32 */
+#define LOG2_CPU_TIMER1_INT 6 /* width RMuint32 */
+#define LOG2_CPU_DVD_INT 7 /* width RMuint32 */
+#define LOG2_CPU_RTC_INT 8 /* width RMuint32 */
+#define LOG2_CPU_HOST_MBUS_W0_INT 9 /* width RMuint32 */
+#define LOG2_CPU_HOST_MBUS_W1_INT 10 /* width RMuint32 */
+#define LOG2_CPU_HOST_MBUS_R0_INT 11 /* width RMuint32 */
+#define LOG2_CPU_HOST_MBUS_R1_INT 12 /* width RMuint32 */
+#define LOG2_CPU_PCI_INTA 13 /* width RMuint32 */
+#define LOG2_CPU_PCI_INTB 14 /* width RMuint32 */
+#define LOG2_CPU_PCI_INTC 15 /* width RMuint32 */
+#define LOG2_CPU_PCI_INTD 16 /* width RMuint32 */
+#define LOG2_CPU_DMAIDE_INT 17 /* width RMuint32 */
+#define LOG2_CPU_IDE_INT 18 /* width RMuint32 */
+#define LOG2_CPU_FRONTPANEL_INT 19 /* width RMuint32 */
+#define LOG2_CPU_PCI_FAULT_INT 20 /* width RMuint32 */
+#define LOG2_CPU_INFRARED_INT 21 /* width RMuint32 */
+#define LOG2_CPU_I2C_INT 22 /* width RMuint32 */
+#define LOG2_CPU_GFX_ACCEL_INT 23 /* width RMuint32 */
+#define LOG2_CPU_VSYNC0_INT 24 /* width RMuint32 */
+#define LOG2_CPU_VSYNC1_INT 25 /* width RMuint32 */
+#define LOG2_CPU_VSYNC2_INT 26 /* width RMuint32 */
+#define LOG2_CPU_VSYNC3_INT 27 /* width RMuint32 */
+#define LOG2_CPU_VSYNC4_INT 28 /* width RMuint32 */
+#define LOG2_CPU_VSYNC4BKEND_INT 29 /* width RMuint32 */
+#define LOG2_CPU_VSYNC5_INT 30 /* width RMuint32 */
+#define LOG2_CPU_VSYNC5BKEND_INT 31 /* width RMuint32 */
+#define LOG2_CPU_SMARTCARD_INT 32 /* width RMuint32 */
+#define LOG2_CPU_HDMI_INT 33 /* width RMuint32 */
+#define LOG2_CPU_HDMI_I2C_INT 34 /* width RMuint32 */
+#define LOG2_CPU_VBUS_W0_INT 35 /* width RMuint32 */
+#define LOG2_CPU_VBUS_W3_INT 36 /* width RMuint32 */
+#define LOG2_CPU_ETH_PHY_INT 37 /* width RMuint32 */
+#define LOG2_CPU_ETH_MAC_INT 38 /* width RMuint32 */
+#define LOG2_CPU_USB_OHCI_INT 39 /* width RMuint32 */
+#define LOG2_CPU_USB_EHCI_INT 40 /* width RMuint32 */
+#define CPU_edge_status_hi 0xe220 /* width RMuint32 */
+#define CPU_edge_rawstat_hi 0xe224 /* width RMuint32 */
+#define CPU_edge_config_rise_hi 0xe228 /* width RMuint32 */
+#define CPU_edge_config_fall_hi 0xe22c /* width RMuint32 */
+#define CPU_irq_status_hi 0xe018 /* width RMuint32 */
+#define CPU_irq_rawstat_hi 0xe01c /* width RMuint32 */
+#define CPU_irq_enableset_hi 0xe020 /* width RMuint32 */
+#define CPU_irq_enableclr_hi 0xe024 /* width RMuint32 */
+#define CPU_fiq_status_hi 0xe118 /* width RMuint32 */
+#define CPU_fiq_rawstat_hi 0xe11c /* width RMuint32 */
+#define CPU_fiq_enableset_hi 0xe120 /* width RMuint32 */
+#define CPU_fiq_enableclr_hi 0xe124 /* width RMuint32 */
+#define CPU_iiq_status 0xe300 /* width RMuint32 */
+#define CPU_iiq_rawstat 0xe304 /* width RMuint32 */
+#define CPU_iiq_enableset 0xe308 /* width RMuint32 */
+#define CPU_iiq_enableclr 0xe30c /* width RMuint32 */
+#define CPU_iiq_softset 0xe310 /* width RMuint32 */
+#define CPU_iiq_softclr 0xe314 /* width RMuint32 */
+#define CPU_iiq_status_hi 0xe318 /* width RMuint32 */
+#define CPU_iiq_rawstat_hi 0xe31c /* width RMuint32 */
+#define CPU_iiq_enableset_hi 0xe320 /* width RMuint32 */
+#define CPU_iiq_enableclr_hi 0xe324 /* width RMuint32 */
+#define CPU_UART_GPIOMODE 0x38 /* width RMuint32 */
+#define CPU_UART_GPIODIR 0x30 /* width RMuint32 */
+#define CPU_UART_GPIODATA 0x34 /* width RMuint32 */
+#define CPU_edge_config_rise_set 0xe210 /* width RMuint32 */
+#define CPU_edge_config_rise_clr 0xe214 /* width RMuint32 */
+#define CPU_edge_config_fall_set 0xe218 /* width RMuint32 */
+#define CPU_edge_config_fall_clr 0xe21c /* width RMuint32 */
+#define CPU_edge_config_rise_set_hi 0xe230 /* width RMuint32 */
+#define CPU_edge_config_rise_clr_hi 0xe234 /* width RMuint32 */
+#define CPU_edge_config_fall_set_hi 0xe238 /* width RMuint32 */
+#define CPU_edge_config_fall_clr_hi 0xe23c /* width RMuint32 */
+#define CPU_pm_select_0 0xc900 /* width RMuint32 */
+#define CPU_pm_counter_0 0xc904 /* width RMuint32 */
+#define CPU_pm_select_1 0xc908 /* width RMuint32 */
+#define CPU_pm_counter_1 0xc90c /* width RMuint32 */
+#define CPU_remap 0xf000 /* width RMuint32 */
+#define CPU_remap1 0xf004 /* width RMuint32 */
+#define CPU_remap2 0xf008 /* width RMuint32 */
+#define CPU_remap3 0xf00c /* width RMuint32 */
+#define CPU_remap4 0xf010 /* width RMuint32 */
+#define CPU_remap_address 0x1fc00000 /* width RMuint32 */
+#define CPU_remap1_address 0 /* width RMuint32 */
+#define CPU_remap2_address 0x04000000 /* width RMuint32 */
+#define CPU_remap3_address 0x08000000 /* width RMuint32 */
+#define CPU_remap4_address 0x0c000000 /* width RMuint32 */
+#define REG_BASE_irq_handler_block 0xe0000 /* width RMuint32 */
+#define G2L_BIST_BUSY 0xffe0 /* width RMuint32 */
+#define G2L_BIST_PASS 0xffe4 /* width RMuint32 */
+#define G2L_BIST_MASK 0xffe8 /* width RMuint32 */
+#define G2L_RESET_CONTROL 0xfffc /* width RMuint32 */
+#define CPU_UART0_base 0xc100 /* width RMuint32 */
+#define CPU_UART1_base 0xc200 /* width RMuint32 */
+#define CPU_UART_RBR 0x00 /* width RMuint32 */
+#define CPU_UART_THR 0x04 /* width RMuint32 */
+#define CPU_UART_IER 0x08 /* width RMuint32 */
+#define CPU_UART_IIR 0x0c /* width RMuint32 */
+#define CPU_UART_FCR 0x10 /* width RMuint32 */
+#define CPU_UART_LCR 0x14 /* width RMuint32 */
+#define CPU_UART_MCR 0x18 /* width RMuint32 */
+#define CPU_UART_LSR 0x1c /* width RMuint32 */
+#define CPU_UART_MSR 0x20 /* width RMuint32 */
+#define CPU_UART_SCR 0x24 /* width RMuint32 */
+#define CPU_UART_CLKDIV 0x28 /* width RMuint32 */
+#define CPU_UART_CLKSEL 0x2c /* width RMuint32 */
+/* CPUBlock registers done */
+
+/* XPUBlock registers */
+#define REG_BASE_xpu_block 0x000e0000 /* width RMuint32 */
+/* XPUBlock registers done */
+
+/* IPUBlock registers */
+#define REG_BASE_ipu_block 0x000f0000 /* width RMuint32 */
+/* IPUBlock registers done */
+
+/* DisplayBlock registers */
+#define REG_BASE_display_block 0x00070000 /* width RMuint32 */
+#define PMEM_BASE_display_block 0x00300000 /* width RMuint32 */
+#define VBUS_IDLE 0x0 /* width RMuint32 */
+#define VBUS_LINEAR 0x1 /* width RMuint32 */
+#define VBUS_DOUBLE 0x2 /* width RMuint32 */
+#define VBUS_RECTANGLE 0x3 /* width RMuint32 */
+#define VBUS_DOUBLE_FIELD 0x4 /* width RMuint32 */
+#define VBUS_DOUBLE_RECTANGLE 0x5 /* width RMuint32 */
+#define VBUS_8BYTE_COLUMN 0x6 /* width RMuint32 */
+#define VBUS_VOID 0x8 /* width RMuint32 */
+#define VBUS_LINEAR_VOID 0x9 /* width RMuint32 */
+#define VBUS_DOUBLE_VOID 0xa /* width RMuint32 */
+#define VBUS_RECTANGLE_VOID 0xb /* width RMuint32 */
+#define VBUS_DOUBLE_FIELD_VOID 0xc /* width RMuint32 */
+#define VBUS_DOUBLE_RECTANGLE_VOID 0xd /* width RMuint32 */
+#define VBUS_8BYTE_COLUMN_VOID 0xe /* width RMuint32 */
+/* DisplayBlock registers done */
+
+/* DemuxEngine registers */
+#define REG_BASE_demux_engine 0x000A0000 /* width RMuint32 */
+#define MEM_BASE_demux_engine 0x00140000 /* width RMuint32 */
+#define PMEM_BASE_demux_engine 0x00140000 /* width RMuint32 */
+#define DMEM_BASE_demux_engine 0x00150000 /* width RMuint32 */
+#define REG_BASE_demux_engine_0 0x000A0000 /* width RMuint32 */
+#define MEM_BASE_demux_engine_0 0x00140000 /* width RMuint32 */
+#define PMEM_BASE_demux_engine_0 0x00140000 /* width RMuint32 */
+#define DMEM_BASE_demux_engine_0 0x00150000 /* width RMuint32 */
+#define REG_BASE_demux_engine_1 0x000b0000 /* width RMuint32 */
+#define MEM_BASE_demux_engine_1 0x00160000 /* width RMuint32 */
+#define PMEM_BASE_demux_engine_1 0x00160000 /* width RMuint32 */
+#define DMEM_BASE_demux_engine_1 0x00170000 /* width RMuint32 */
+#define TDMX_gpio_data 0x2e0c /* width RMuint32 */
+#define TDMX_gpio_dir 0x2e0d /* width RMuint32 */
+/* DemuxEngine registers done */
+
+/* MpegEngine registers */
+#define REG_BASE_mpeg_engine_0 0x00080000 /* width RMuint32 */
+#define MEM_BASE_mpeg_engine_0 0x00100000 /* width RMuint32 */
+#define PMEM_BASE_mpeg_engine_0 0x00100000 /* width RMuint32 */
+#define DMEM_BASE_mpeg_engine_0 0x00110000 /* width RMuint32 */
+#define REG_BASE_mpeg_engine_1 0x00090000 /* width RMuint32 */
+#define MEM_BASE_mpeg_engine_1 0x00120000 /* width RMuint32 */
+#define PMEM_BASE_mpeg_engine_1 0x00120000 /* width RMuint32 */
+#define DMEM_BASE_mpeg_engine_1 0x00130000 /* width RMuint32 */
+#define RBUS_offset 0x4000 /* width RMuint32 */
+/* MpegEngine registers done */
+
+/* AudioEngine registers */
+#define REG_BASE_audio_engine_0 0x000c0000 /* width RMuint32 */
+#define MEM_BASE_audio_engine_0 0x00180000 /* width RMuint32 */
+#define PMEM_BASE_audio_engine_0 0x00180000 /* width RMuint32 */
+#define DMEM_BASE_audio_engine_0 0x00190000 /* width RMuint32 */
+#define REG_BASE_audio_engine_1 0x000d0000 /* width RMuint32 */
+#define MEM_BASE_audio_engine_1 0x001a0000 /* width RMuint32 */
+#define PMEM_BASE_audio_engine_1 0x001a0000 /* width RMuint32 */
+#define DMEM_BASE_audio_engine_1 0x001b0000 /* width RMuint32 */
+#define audio_mutex0 0x3e90 /* width RMuint32 */
+#define audio_mutex1 0x3e91 /* width RMuint32 */
+#define audio_mutex2 0x3e92 /* width RMuint32 */
+#define audio_mutex3 0x3e93 /* width RMuint32 */
+#define audio_mutex4 0x3e94 /* width RMuint32 */
+#define audio_mutex5 0x3e95 /* width RMuint32 */
+#define audio_mutex6 0x3e96 /* width RMuint32 */
+#define audio_mutex7 0x3e97 /* width RMuint32 */
+/* AudioEngine registers done */
+
+/* AudioDecoder registers */
+/* AudioDecoder registers done */
+
+/* AudioCapture registers */
+/* AudioCapture registers done */
+
+/* VoipCodec registers */
+/* VoipCodec registers done */
+
+/* CRCDecoder registers */
+/* CRCDecoder registers done */
+
+/* XCRCDecoder registers */
+/* XCRCDecoder registers done */
+
+/* StreamCapture registers */
+/* StreamCapture registers done */
+
+/* RawDataTransfer registers */
+/* RawDataTransfer registers done */
+
+/* I2C registers */
+#define I2C_MASTER_CONFIG 0x80 /* width RMuint32 */
+#define I2C_MASTER_CLK_DIV 0x84 /* width RMuint32 */
+#define I2C_MASTER_DEV_ADDR 0x88 /* width RMuint32 */
+#define I2C_MASTER_ADDR 0x8c /* width RMuint32 */
+#define I2C_MASTER_DATA_OUT 0x90 /* width RMuint32 */
+#define I2C_MASTER_DATA_IN 0x94 /* width RMuint32 */
+#define I2C_MASTER_STATUS 0x98 /* width RMuint32 */
+#define I2C_MASTER_STARTXFER 0x9c /* width RMuint32 */
+#define I2C_MASTER_BYTE_CNT 0xa0 /* width RMuint32 */
+#define I2C_MASTER_INTEN 0xa4 /* width RMuint32 */
+#define I2C_MASTER_INT 0xa8 /* width RMuint32 */
+#define I2C_SLAVE_ADDR_REG 0xC0 /* width RMuint32 */
+#define I2C_SLAVE_DATAOUT 0xC4 /* width RMuint32 */
+#define I2C_SLAVE_DATAIN 0xC8 /* width RMuint32 */
+#define I2C_SLAVE_STATUS 0xCC /* width RMuint32 */
+#define I2C_SLAVE_INTEN 0xD0 /* width RMuint32 */
+#define I2C_SLAVE_INT 0xD4 /* width RMuint32 */
+#define I2C_SLAVE_BUS_HOLD 0xD8 /* width RMuint32 */
+/* I2C registers done */
+
+/* MM registers */
+/* MM registers done */
+
+/* SpuDecoder registers */
+/* SpuDecoder registers done */
+
+/* PictureTransform registers */
+/* PictureTransform registers done */
+
+/* ClosedCaptionDecoder registers */
+/* ClosedCaptionDecoder registers done */
+
+/* RTC registers */
+/* RTC registers done */
+
+/* Cipher registers */
+/* Cipher registers done */
+
+/* STC registers */
+/* STC registers done */
+
+/* PLL registers */
+/* PLL registers done */
+
+/* DemuxCipher registers */
+/* DemuxCipher registers done */
+
+/* DemuxTask registers */
+/* DemuxTask registers done */
+
+/* DemuxOutput registers */
+/* DemuxOutput registers done */
+
+/* CCFifo registers */
+/* CCFifo registers done */
+
+/* Sha1Sum registers */
+/* Sha1Sum registers done */
+
+/* XTask registers */
+/* XTask registers done */
+
+/* TTXFifo registers */
+/* TTXFifo registers done */
+
+/* VCXO registers */
+/* VCXO registers done */
+
+/* PPF registers */
+/* PPF registers done */
+
+#endif /* __EMHWLIB_REGISTERS_TANGO2_H__ */
+
+/* End of generated file ../emhwlib_hal/include/tango2/emhwlib_registers_tango2.h */
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango2/emhwlib_registers_tango2.inc linux-3.9.2/arch/mips/include/asm/tango2/emhwlib_registers_tango2.inc
--- linux-3.9.2.ref/arch/mips/include/asm/tango2/emhwlib_registers_tango2.inc	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango2/emhwlib_registers_tango2.inc	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,538 @@
+#
+#******************************************************
+#* This file is generated automatically, DO NOT EDIT! *
+#******************************************************
+#*
+#* destined to be included by a shell script or a Makefile (keep syntax adapted to both)
+#*
+#* emhwlib_hal/include/tango2/emhwlib_registers_tango2.inc (generated from emhwlib_hal/include/tango2/emhwlib_registers_tango2.h)
+#*
+#* Copyright (C) Sigma Designs, Inc. 2007.
+#*
+i386=0x1
+linux=0x1
+unix=0x1
+REG_BASE_system_block=0x10000
+SYS_clkgen0_pll=0x0
+SYS_clkgen0_div=0x4
+SYS_clkgen1_pll=0x8
+SYS_clkgen1_div=0xc
+SYS_clkgen2_pll=0x10
+SYS_clkgen2_div=0x14
+SYS_clkgen3_pll=0x18
+SYS_clkgen3_div=0x1c
+SYS_avclk_mux=0x38
+SYS_sysclk_mux=0x3c
+SYS_clk_cnt=0x40
+SYS_xtal_in_cnt=0x48
+DRAM_vbus_w0_cfg=0x300
+DRAM_vbus_w1_cfg=0x304
+DRAM_vbus_w2_cfg=0x308
+DRAM_vbus_w3_cfg=0x30c
+DRAM_vbus_r0_cfg=0x340
+DRAM_vbus_r1_cfg=0x344
+DRAM_vbus_r2_cfg=0x348
+DRAM_vbus_r3_cfg=0x34c
+DRAM_vbus_r4_cfg=0x350
+DRAM_vbus_r5_cfg=0x354
+DRAM_vbus_r6_cfg=0x358
+DRAM_vbus_r7_cfg=0x35c
+DRAM_vbus_r8_cfg=0x360
+DRAM_vbus_r9_cfg=0x364
+DRAM_vbus_r10_cfg=0x368
+DRAM_vbus_r11_cfg=0x36c
+DRAM_mbus_w0_cfg=0x200
+DRAM_mbus_w1_cfg=0x204
+DRAM_mbus_w2_cfg=0x208
+DRAM_mbus_w3_cfg=0x20c
+DRAM_mbus_w4_cfg=0x210
+DRAM_mbus_w5_cfg=0x214
+DRAM_mbus_w6_cfg=0x218
+DRAM_mbus_w7_cfg=0x21c
+DRAM_mbus_w8_cfg=0x220
+DRAM_mbus_w9_cfg=0x224
+DRAM_mbus_w10_cfg=0x228
+DRAM_mbus_r0_cfg=0x240
+DRAM_mbus_r1_cfg=0x244
+DRAM_mbus_r2_cfg=0x248
+DRAM_mbus_r3_cfg=0x24c
+DRAM_mbus_r4_cfg=0x250
+DRAM_mbus_r5_cfg=0x254
+DRAM_mbus_r6_cfg=0x258
+DRAM_mbus_r7_cfg=0x25c
+DRAM_mbus_r8_cfg=0x260
+DRAM_mbus_r9_cfg=0x264
+DRAM_mbus_r10_cfg=0x268
+SYS_hostclk_mux=0x30
+SYS_sysclk_premux=0x34
+SYS_rnd_cnt=0x44
+SYS_cnt_cfg=0x4c
+SYS_cfg_cnt0=0x50
+SYS_cfg_cnt1=0x54
+SYS_cfg_cnt2=0x58
+SYS_cfg_cnt3=0x5c
+SYS_cfg_cnt4=0x60
+SYS_cleandiv0_div=0x80
+SYS_cleandiv1_div=0x88
+SYS_cleandiv2_div=0x90
+SYS_cleandiv3_div=0x98
+SYS_cleandiv4_div=0xa0
+SYS_cleandiv5_div=0xa8
+SYS_cleandiv6_div=0xb0
+SYS_cleandiv7_div=0xb8
+SYS_cleandiv8_div=0xc0
+SYS_cleandiv9_div=0xc8
+SYS_cleandiv10_div=0xd0
+MARB_mid01_cfg=0x200
+MARB_mid21_cfg=0x204
+MARB_mid02_cfg=0x208
+MARB_mid22_cfg=0x20c
+MARB_mid04_cfg=0x210
+MARB_mid24_cfg=0x214
+MARB_mid25_cfg=0x218
+MARB_mid08_cfg=0x21c
+MARB_mid28_cfg=0x220
+MARB_mid29_cfg=0x224
+MARB_mid0C_cfg=0x228
+MARB_mid2C_cfg=0x22c
+MARB_mid10_cfg=0x230
+MARB_mid30_cfg=0x234
+MARB_mid31_cfg=0x238
+MARB_mid12_cfg=0x23c
+MARB_mid32_cfg=0x240
+SYS_gpio_dir=0x500
+SYS_gpio_data=0x504
+SYS_gpio_int=0x508
+SYS_gpio15_pwm=0x510
+SYS_gpio14_pwm=0x514
+REG_BASE_dram_controller_0=0x30000
+REG_BASE_dram_controller_1=0x40000
+MEM_BASE_dram_controller_0_alias=0x10000000
+MEM_BASE_dram_controller_0=0x10000000
+MEM_BASE_dram_controller_1_alias=0x20000000
+MEM_BASE_dram_controller_1=0x20000000
+DRAM_dunit_cfg=0x0
+DRAM_dunit_delay0_ctrl=0x4
+DRAM_dunit_delay1_ctrl=0x8
+DRAM_dunit_auto_delay=0xc
+DRAM_dunit_fall_delay0=0x10
+DRAM_dunit_fall_delay1=0x14
+DRAM_dunit_bw_lobound=0x18
+DRAM_dunit_bw_hibound=0x1c
+DRAM_dunit_bw_probe_cfg=0x20
+DRAM_dunit_bw_probe_cnt=0x24
+DRAM_dunit_bw_cntall=0x28
+DRAM_dunit_calibration_delay=0x30
+DRAM_dunit_calibration_rise_err=0x34
+DRAM_dunit_calibration_fall_err=0x38
+DRAM_dunit_calibration_page=0x88
+DRAM_dunit_flush_buffer=0x104
+REG_BASE_host_interface=0x20000
+MEM_BASE_host_interface=0x40000000
+IDE_data=0x0
+IDE_error=0x4
+IDE_count=0x8
+IDE_start_sector=0xc
+IDE_cylinder_lo=0x10
+IDE_cylinder_hi=0x14
+IDE_head_device=0x18
+IDE_cmd_stat=0x1c
+IDE_irq_stat=0x218
+IDE_cmd_stat__=0x21c
+PB_timing0=0x800
+PB_timing1=0x804
+PB_timing2=0x808
+PB_timing3=0x80c
+PB_timing4=0x810
+PB_timing5=0x814
+PB_default_timing=0x818
+PB_use_timing0=0x81c
+PB_use_timing1=0x820
+PB_use_timing2=0x824
+PB_use_timing3=0x828
+PB_use_timing4=0x82c
+PB_use_timing5=0x830
+PB_CS_config=0x834
+PB_automode_start_address=0x840
+PB_automode_control=0x844
+EMHWLIB_IS_HOST=0xe000
+HOST_REG1=0xfed0
+HOST_REG2=0xfed4
+READ_ADDRESS=0xfec0
+READ_COUNTER=0xfec4
+READ_ENABLE=0xfec8
+REV_ORDER=0xfecc
+WRITE_ADDRESS=0xfed8
+WRITE_COUNTER=0xfedc
+WRITE_ENABLE=0xfee0
+BURST=0xfee4
+PCI_TIMEOUT=0x8000
+PCI_TIMEOUT_STATUS=0x8004
+PCI_TIMER=0x8008
+PCI_TIMER_TEST=0x800c
+PCI_WAKEUP=0x8010
+PCI_REGION_0_BASE=0x9000
+PCI_REGION_1_BASE=0x9004
+PCI_REGION_2_BASE=0x9008
+PCI_REGION_3_BASE=0x900c
+PCI_REGION_4_BASE=0x9010
+PCI_REGION_5_BASE=0x9014
+PCI_REGION_6_BASE=0x9018
+PCI_REGION_7_BASE=0x901c
+PCI_irq_status=0x9020
+PCI_irq_set=0x9024
+PCI_irq_clear=0x9028
+SBOX_FIFO_RESET=0x90a0
+SBOX_ROUTE=0x90a8
+output_SBOX_MBUS_W0=0x9080
+output_SBOX_MBUS_W1=0x9084
+output_SBOX_PCI_MASTER=0x9088
+output_SBOX_PCI_SLAVE=0x908c
+output_SBOX_CIPHER=0x9090
+output_SBOX_IDE_ISA=0x9094
+output_SBOX_IDE_DVD=0x9098
+input_keep_SBOX=0x0
+input_MBUS_R0_SBOX=0x1
+input_MBUS_R1_SBOX=0x2
+input_PCI_MASTER_SBOX=0x3
+input_PCI_SLAVE_SBOX=0x4
+input_CIPHER_SBOX=0x5
+input_IDE_DVD_SBOX=0x6
+input_IDE_ISA_SBOX=0x7
+input_SFLA_SBOX=0x8
+input_unconnected_SBOX=0xf
+host_mutex0=0x9040
+host_mutex1=0x9044
+host_mutex2=0x9048
+host_mutex3=0x904c
+host_mutex4=0x9050
+host_mutex5=0x9054
+host_mutex6=0x9058
+host_mutex7=0x905c
+host_mutex8=0x9060
+host_mutex9=0x9064
+host_mutex10=0x9068
+host_mutex11=0x906c
+host_mutex12=0x9070
+host_mutex13=0x9074
+host_mutex14=0x9078
+host_mutex15=0x907c
+PCI_host_reg5=0xfe94
+PCI_chip_is_host=0xfe90
+IDECTRL_idesrc=0x20d0
+IDECTRL_pri_drv1udmatim1=0x20e0
+IDECTRL_pri_drv1udmatim2=0x20f0
+IDECTRL_pri_idectl=0x2100
+IDECTRL_pri_drv0tim=0x2110
+IDECTRL_pri_drv1tim=0x2120
+IDECTRL_idemisc=0x2130
+IDECTRL_idestatus=0x2140
+IDECTRL_udmactl=0x2150
+IDECTRL_pri_drv0udmatim1=0x2160
+IDECTRL_pri_drv0udmatim2=0x2170
+IDECTRL_pref_st=0x2310
+IDECTRL_pri_ctrlblock=0x2398
+IDECTRL_pri_cmdblock=0x23c0
+IDECTRL_bmic=0x2400
+IDECTRL_bmis=0x2410
+IDECTRL_bmidtp=0x2420
+IDECTRL_ide_dmaptr=0x2780
+IDECTRL_ide_dmalen=0x2790
+IDECTRL_pio_prefetch_data=0x27c0
+MEM_BASE_pfla=0x40000000
+PB_CS0_OFFSET=0x0
+PB_CS1_OFFSET=0x4000000
+PB_CS2_OFFSET=0x8000000
+PB_CS3_OFFSET=0xc000000
+ETH_gpio_dir1=0x7100
+ETH_gpio_data1=0x7104
+ETH_gpio_mask1=0x7108
+ETH_gpio_dir2=0x710c
+ETH_gpio_data2=0x7110
+PCI_host_reg1=0xfed0
+PCI_host_reg2=0xfed4
+PCI_host_reg3=0xfe80
+PCI_host_reg4=0xfe84
+PCI_pcictrl_reg1=0xfe88
+PCI_pcictrl_reg2=0xfe8c
+PCI_pcictrl_reg3=0xfefc
+PCI_REG0=0xfee8
+PCI_REG1=0xfeec
+PCI_REG2=0xfef0
+PCI_REG3=0xfef4
+PCI_CONFIG=0xfef8
+MIF_W0_ADD=0xb000
+MIF_W0_CNT=0xb004
+MIF_W0_SKIP=0xb008
+MIF_W0_CMD=0xb00c
+MIF_W1_ADD=0xb040
+MIF_W1_CNT=0xb044
+MIF_W1_SKIP=0xb048
+MIF_W1_CMD=0xb04c
+MIF_R0_ADD=0xb080
+MIF_R0_CNT=0xb084
+MIF_R0_SKIP=0xb088
+MIF_R0_CMD=0xb08c
+MIF_R1_ADD=0xb0c0
+MIF_R1_CNT=0xb0c4
+MIF_R1_SKIP=0xb0c8
+MIF_R1_CMD=0xb0cc
+MBUS_IDLE=0x0
+MBUS_LINEAR=0x1
+MBUS_DOUBLE=0x2
+MBUS_RECTANGLE=0x3
+MBUS_VOID=0x4
+MBUS_LINEAR_VOID=0x5
+MBUS_DOUBLE_VOID=0x6
+MBUS_RECTANGLE_VOID=0x7
+MBUS_TILED=0x8
+REG_BASE_cpu_block=0x60000
+CPU_time0_load=0xc500
+CPU_time0_value=0xc504
+CPU_time0_ctrl=0xc508
+CPU_time0_clr=0xc50c
+CPU_time1_load=0xc600
+CPU_time1_value=0xc604
+CPU_time1_ctrl=0xc608
+CPU_time1_clr=0xc60c
+CPU_rtc_data=0xc800
+CPU_rtc_match=0xc804
+CPU_rtc_stat=0xc808
+CPU_rtc_load=0xc80c
+CPU_rtc_ctrl=0xc810
+CPU_irq_status=0xe000
+CPU_irq_rawstat=0xe004
+CPU_irq_enableset=0xe008
+CPU_irq_enableclr=0xe00c
+CPU_irq_softset=0xe010
+CPU_irq_softclr=0xe014
+CPU_fiq_status=0xe100
+CPU_fiq_rawstat=0xe104
+CPU_fiq_enableset=0xe108
+CPU_fiq_enableclr=0xe10c
+CPU_fiq_softset=0xe110
+CPU_fiq_softclr=0xe114
+CPU_edge_status=0xe200
+CPU_edge_rawstat=0xe204
+CPU_edge_config_rise=0xe208
+CPU_edge_config_fall=0xe20c
+CPU_SOFT_INT=0x1
+CPU_UART0_INT=0x2
+CPU_UART1_INT=0x4
+CPU_TIMER0_INT=0x20
+CPU_TIMER1_INT=0x40
+CPU_HOST_MBUS_W0_INT=0x200
+CPU_HOST_MBUS_W1_INT=0x400
+CPU_HOST_MBUS_R0_INT=0x800
+CPU_HOST_MBUS_R1_INT=0x1000
+CPU_PCI_INTA=0x2000
+CPU_PCI_INTB=0x4000
+CPU_PCI_INTC=0x8000
+CPU_PCI_INTD=0x10000
+CPU_PCI_FAULT_INT=0x100000
+CPU_INFRARED_INT=0x200000
+CPU_SFLA_INT=0x10
+CPU_DVD_INT=0x80
+CPU_ETH_INT=0x100
+CPU_DMAIDE_INT=0x20000
+CPU_IDE_INT=0x40000
+CPU_FRONTPANEL_INT=0x80000
+CPU_I2C_INT=0x400000
+CPU_GFX_ACCEL_INT=0x800000
+CPU_VSYNC0_INT=0x1000000
+CPU_VSYNC1_INT=0x2000000
+CPU_VSYNC2_INT=0x4000000
+CPU_VSYNC3_INT=0x8000000
+CPU_VSYNC4_INT=0x10000000
+CPU_VSYNC4BKEND_INT=0x20000000
+CPU_VSYNC5_INT=0x40000000
+CPU_VSYNC5BKEND_INT=0x80000000
+CPU_SMARTCARD_HI_INT=0x1
+CPU_HDMI_HI_INT=0x2
+CPU_HDMI_I2C_HI_INT=0x4
+CPU_VBUS_W0_HI_INT=0x8
+CPU_VBUS_W3_HI_INT=0x10
+CPU_ETH_PHY_HI_INT=0x20
+CPU_ETH_MAC_HI_INT=0x40
+CPU_USB_OHCI_MAC_HI_INT=0x80
+CPU_USB_EHCI_MAC_HI_INT=0x100
+LOG2_CPU_SOFT_INT=0x0
+LOG2_CPU_UART0_INT=0x1
+LOG2_CPU_UART1_INT=0x2
+LOG2_CPU_TIMER0_INT=0x5
+LOG2_CPU_TIMER1_INT=0x6
+LOG2_CPU_DVD_INT=0x7
+LOG2_CPU_RTC_INT=0x8
+LOG2_CPU_HOST_MBUS_W0_INT=0x9
+LOG2_CPU_HOST_MBUS_W1_INT=0xa
+LOG2_CPU_HOST_MBUS_R0_INT=0xb
+LOG2_CPU_HOST_MBUS_R1_INT=0xc
+LOG2_CPU_PCI_INTA=0xd
+LOG2_CPU_PCI_INTB=0xe
+LOG2_CPU_PCI_INTC=0xf
+LOG2_CPU_PCI_INTD=0x10
+LOG2_CPU_DMAIDE_INT=0x11
+LOG2_CPU_IDE_INT=0x12
+LOG2_CPU_FRONTPANEL_INT=0x13
+LOG2_CPU_PCI_FAULT_INT=0x14
+LOG2_CPU_INFRARED_INT=0x15
+LOG2_CPU_I2C_INT=0x16
+LOG2_CPU_GFX_ACCEL_INT=0x17
+LOG2_CPU_VSYNC0_INT=0x18
+LOG2_CPU_VSYNC1_INT=0x19
+LOG2_CPU_VSYNC2_INT=0x1a
+LOG2_CPU_VSYNC3_INT=0x1b
+LOG2_CPU_VSYNC4_INT=0x1c
+LOG2_CPU_VSYNC4BKEND_INT=0x1d
+LOG2_CPU_VSYNC5_INT=0x1e
+LOG2_CPU_VSYNC5BKEND_INT=0x1f
+LOG2_CPU_SMARTCARD_INT=0x20
+LOG2_CPU_HDMI_INT=0x21
+LOG2_CPU_HDMI_I2C_INT=0x22
+LOG2_CPU_VBUS_W0_INT=0x23
+LOG2_CPU_VBUS_W3_INT=0x24
+LOG2_CPU_ETH_PHY_INT=0x25
+LOG2_CPU_ETH_MAC_INT=0x26
+LOG2_CPU_USB_OHCI_INT=0x27
+LOG2_CPU_USB_EHCI_INT=0x28
+CPU_edge_status_hi=0xe220
+CPU_edge_rawstat_hi=0xe224
+CPU_edge_config_rise_hi=0xe228
+CPU_edge_config_fall_hi=0xe22c
+CPU_irq_status_hi=0xe018
+CPU_irq_rawstat_hi=0xe01c
+CPU_irq_enableset_hi=0xe020
+CPU_irq_enableclr_hi=0xe024
+CPU_fiq_status_hi=0xe118
+CPU_fiq_rawstat_hi=0xe11c
+CPU_fiq_enableset_hi=0xe120
+CPU_fiq_enableclr_hi=0xe124
+CPU_iiq_status=0xe300
+CPU_iiq_rawstat=0xe304
+CPU_iiq_enableset=0xe308
+CPU_iiq_enableclr=0xe30c
+CPU_iiq_softset=0xe310
+CPU_iiq_softclr=0xe314
+CPU_iiq_status_hi=0xe318
+CPU_iiq_rawstat_hi=0xe31c
+CPU_iiq_enableset_hi=0xe320
+CPU_iiq_enableclr_hi=0xe324
+CPU_UART_GPIOMODE=0x38
+CPU_UART_GPIODIR=0x30
+CPU_UART_GPIODATA=0x34
+CPU_edge_config_rise_set=0xe210
+CPU_edge_config_rise_clr=0xe214
+CPU_edge_config_fall_set=0xe218
+CPU_edge_config_fall_clr=0xe21c
+CPU_edge_config_rise_set_hi=0xe230
+CPU_edge_config_rise_clr_hi=0xe234
+CPU_edge_config_fall_set_hi=0xe238
+CPU_edge_config_fall_clr_hi=0xe23c
+CPU_pm_select_0=0xc900
+CPU_pm_counter_0=0xc904
+CPU_pm_select_1=0xc908
+CPU_pm_counter_1=0xc90c
+CPU_remap=0xf000
+CPU_remap1=0xf004
+CPU_remap2=0xf008
+CPU_remap3=0xf00c
+CPU_remap4=0xf010
+CPU_remap_address=0x1fc00000
+CPU_remap1_address=0x0
+CPU_remap2_address=0x4000000
+CPU_remap3_address=0x8000000
+CPU_remap4_address=0xc000000
+REG_BASE_irq_handler_block=0xe0000
+G2L_BIST_BUSY=0xffe0
+G2L_BIST_PASS=0xffe4
+G2L_BIST_MASK=0xffe8
+G2L_RESET_CONTROL=0xfffc
+CPU_UART0_base=0xc100
+CPU_UART1_base=0xc200
+CPU_UART_RBR=0x0
+CPU_UART_THR=0x4
+CPU_UART_IER=0x8
+CPU_UART_IIR=0xc
+CPU_UART_FCR=0x10
+CPU_UART_LCR=0x14
+CPU_UART_MCR=0x18
+CPU_UART_LSR=0x1c
+CPU_UART_MSR=0x20
+CPU_UART_SCR=0x24
+CPU_UART_CLKDIV=0x28
+CPU_UART_CLKSEL=0x2c
+REG_BASE_xpu_block=0xe0000
+REG_BASE_ipu_block=0xf0000
+REG_BASE_display_block=0x70000
+PMEM_BASE_display_block=0x300000
+VBUS_IDLE=0x0
+VBUS_LINEAR=0x1
+VBUS_DOUBLE=0x2
+VBUS_RECTANGLE=0x3
+VBUS_DOUBLE_FIELD=0x4
+VBUS_DOUBLE_RECTANGLE=0x5
+VBUS_8BYTE_COLUMN=0x6
+VBUS_VOID=0x8
+VBUS_LINEAR_VOID=0x9
+VBUS_DOUBLE_VOID=0xa
+VBUS_RECTANGLE_VOID=0xb
+VBUS_DOUBLE_FIELD_VOID=0xc
+VBUS_DOUBLE_RECTANGLE_VOID=0xd
+VBUS_8BYTE_COLUMN_VOID=0xe
+REG_BASE_demux_engine=0xa0000
+MEM_BASE_demux_engine=0x140000
+PMEM_BASE_demux_engine=0x140000
+DMEM_BASE_demux_engine=0x150000
+REG_BASE_demux_engine_0=0xa0000
+MEM_BASE_demux_engine_0=0x140000
+PMEM_BASE_demux_engine_0=0x140000
+DMEM_BASE_demux_engine_0=0x150000
+REG_BASE_demux_engine_1=0xb0000
+MEM_BASE_demux_engine_1=0x160000
+PMEM_BASE_demux_engine_1=0x160000
+DMEM_BASE_demux_engine_1=0x170000
+TDMX_gpio_data=0x2e0c
+TDMX_gpio_dir=0x2e0d
+REG_BASE_mpeg_engine_0=0x80000
+MEM_BASE_mpeg_engine_0=0x100000
+PMEM_BASE_mpeg_engine_0=0x100000
+DMEM_BASE_mpeg_engine_0=0x110000
+REG_BASE_mpeg_engine_1=0x90000
+MEM_BASE_mpeg_engine_1=0x120000
+PMEM_BASE_mpeg_engine_1=0x120000
+DMEM_BASE_mpeg_engine_1=0x130000
+RBUS_offset=0x4000
+REG_BASE_audio_engine_0=0xc0000
+MEM_BASE_audio_engine_0=0x180000
+PMEM_BASE_audio_engine_0=0x180000
+DMEM_BASE_audio_engine_0=0x190000
+REG_BASE_audio_engine_1=0xd0000
+MEM_BASE_audio_engine_1=0x1a0000
+PMEM_BASE_audio_engine_1=0x1a0000
+DMEM_BASE_audio_engine_1=0x1b0000
+audio_mutex0=0x3e90
+audio_mutex1=0x3e91
+audio_mutex2=0x3e92
+audio_mutex3=0x3e93
+audio_mutex4=0x3e94
+audio_mutex5=0x3e95
+audio_mutex6=0x3e96
+audio_mutex7=0x3e97
+I2C_MASTER_CONFIG=0x80
+I2C_MASTER_CLK_DIV=0x84
+I2C_MASTER_DEV_ADDR=0x88
+I2C_MASTER_ADDR=0x8c
+I2C_MASTER_DATA_OUT=0x90
+I2C_MASTER_DATA_IN=0x94
+I2C_MASTER_STATUS=0x98
+I2C_MASTER_STARTXFER=0x9c
+I2C_MASTER_BYTE_CNT=0xa0
+I2C_MASTER_INTEN=0xa4
+I2C_MASTER_INT=0xa8
+I2C_SLAVE_ADDR_REG=0xc0
+I2C_SLAVE_DATAOUT=0xc4
+I2C_SLAVE_DATAIN=0xc8
+I2C_SLAVE_STATUS=0xcc
+I2C_SLAVE_INTEN=0xd0
+I2C_SLAVE_INT=0xd4
+I2C_SLAVE_BUS_HOLD=0xd8
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango2/emhwlib_resources_shared.h linux-3.9.2/arch/mips/include/asm/tango2/emhwlib_resources_shared.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango2/emhwlib_resources_shared.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango2/emhwlib_resources_shared.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,114 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/**
+  @file   emhwlib_resources_shared.h
+  @brief  
+
+  long description
+
+  @author Emmanuel Michon
+  @date   2005-03-22
+*/
+
+#ifndef __EMHWLIB_RESOURCES_SHARED_H__
+#define __EMHWLIB_RESOURCES_SHARED_H__
+
+#define VIDEO_0_RPC_MUTEX ((struct gbus_mutex *)(DMEM_BASE_mpeg_engine_0  + 4 * mpeg_mutex1))
+#define VIDEO_1_RPC_MUTEX ((struct gbus_mutex *)(DMEM_BASE_mpeg_engine_1  + 4 * mpeg_mutex1))
+#define AUDIO_0_RPC_MUTEX ((struct gbus_mutex *)(DMEM_BASE_audio_engine_0 + 4 * audio_mutex1))
+#define DEMUX_RPC_MUTEX   ((struct gbus_mutex *)(DMEM_BASE_demux_engine   + 4 * demux_mutex3))
+
+// pt110 local ram map
+#define UCLINUX_CURRENT_PROCESS (REG_BASE_cpu_block + 0x0000)
+
+#define RESET_VECTOR   (REG_BASE_cpu_block + 0x0000)
+#define UNDEF_VECTOR   (REG_BASE_cpu_block + 0x0004)
+#define SWI_VECTOR     (REG_BASE_cpu_block + 0x0008)
+#define I_ABORT_VECTOR (REG_BASE_cpu_block + 0x000c)
+#define D_ABORT_VECTOR (REG_BASE_cpu_block + 0x0010)
+#define RSV_VECTOR     (REG_BASE_cpu_block + 0x0014)
+#define IRQ_VECTOR     (REG_BASE_cpu_block + 0x0018)
+#define FIQ_VECTOR     (REG_BASE_cpu_block + 0x001c)
+
+#define RESET_JUMP     (REG_BASE_cpu_block + 0x0020)
+#define UNDEF_JUMP     (REG_BASE_cpu_block + 0x0024)
+#define SWI_JUMP       (REG_BASE_cpu_block + 0x0028)
+#define I_ABORT_JUMP   (REG_BASE_cpu_block + 0x002c)
+#define D_ABORT_JUMP   (REG_BASE_cpu_block + 0x0030)
+#define RSV_JUMP       (REG_BASE_cpu_block + 0x0034)
+#define IRQ_JUMP       (REG_BASE_cpu_block + 0x0038)
+#define FIQ_JUMP       (REG_BASE_cpu_block + 0x003c)
+
+#define INFINITE_LOOP  (REG_BASE_cpu_block + 0x0040)
+
+/* where to store uclinux interrupt handler */
+#define UCLINUX_RESET_VECTOR   (REG_BASE_cpu_block + 0x0044)
+#define UCLINUX_UNDEF_VECTOR   (REG_BASE_cpu_block + 0x0048)
+#define UCLINUX_SWI_VECTOR     (REG_BASE_cpu_block + 0x004c)
+#define UCLINUX_I_ABORT_VECTOR (REG_BASE_cpu_block + 0x0050)
+#define UCLINUX_D_ABORT_VECTOR (REG_BASE_cpu_block + 0x0054)
+#define UCLINUX_RSV_VECTOR     (REG_BASE_cpu_block + 0x0058)
+#define UCLINUX_IRQ_VECTOR     (REG_BASE_cpu_block + 0x005c)
+#define UCLINUX_FIQ_VECTOR     (REG_BASE_cpu_block + 0x0060)
+
+/* where to store fiq/irq enable values */
+#define UCLINUX_IRQ_ENABLE      (REG_BASE_cpu_block + 0x0064)
+#define UCLINUX_FIQ_ENABLE      (REG_BASE_cpu_block + 0x0068)
+
+/* we use this in uClinux to handshake llad with the hardware library. llad will 
+   initialize the value to 0. As long as this value is 0, llad will mask the
+   triggered interrupt. When the CPUBlock is done loading the IRQ handler, it
+   will set this value to all the IRQ that are now being handled by itself. Next
+   time llad receives an IRQ, it will read this value and if set to the proper
+   interrupt value, it will return without masking the interrupt.
+   This value is a mask of all the IRQs handled by the IRQ handler (see em8xxx
+   hardware IRQ register).
+
+   *** IMPORTANT *** This value must be update in llad.c if changed.
+*/
+#define UCLINUX_LLAD_IRQHANDLER_HANDSHAKE    (REG_BASE_cpu_block + 0x006C)
+
+/* these symbols are used to store the entry point of the irqhandler
+   loaded by the bootloader.  when uclinux boots it overwrites the
+   interrupt vector, and when we load emhwlib we must restore the RUA
+   entry point in the vector. Since the current version of the emhwlib
+   loaded may not match the irqhandler loaded by bootloader, the entry
+   points should not be determined at compilation time, but rather at
+   runtime.
+*/
+#define IRQHANDLER_ENTRY   (REG_BASE_cpu_block + 0x0070) 
+#define FIQHANDLER_ENTRY   (REG_BASE_cpu_block + 0x0074) 
+#define UNDEFHANDLER_ENTRY (REG_BASE_cpu_block + 0x0078) 
+#define JUMPTABLE_ADDRESS  (REG_BASE_cpu_block + 0x007c)
+
+/* address of linux General exeption handler */
+#define LINUX_GE (REG_BASE_cpu_block + 0x0080)
+
+// random seeds (refer to gbuslib/include/gbus_random.h)
+#define RANDOM0              (REG_BASE_cpu_block + LR_RANDOM_SEED + 0)
+#define RANDOM1              (REG_BASE_cpu_block + LR_RANDOM_SEED + 4)
+
+#define PCI_INTERRUPT_ENABLE    (REG_BASE_cpu_block + LR_PCI_INTERRUPT_ENABLE)
+#define HOST_INTERRUPT_STATUS   (REG_BASE_cpu_block + LR_HOST_INTERRUPT_STATUS)
+
+// next 8 dword locations are for local debug, they are reset to 0 at vsync_init time.
+// Please do not affect them in cvs source.
+#define DEBUG_PROBE0                  (REG_BASE_cpu_block + LR_LOCAL_DEBUG_PROBE + 0x00)
+#define DEBUG_PROBE1                  (REG_BASE_cpu_block + LR_LOCAL_DEBUG_PROBE + 0x04)
+#define DEBUG_PROBE2                  (REG_BASE_cpu_block + LR_LOCAL_DEBUG_PROBE + 0x08)
+#define DEBUG_PROBE3                  (REG_BASE_cpu_block + LR_LOCAL_DEBUG_PROBE + 0x0c)
+#define DEBUG_PROBE4                  (REG_BASE_cpu_block + LR_LOCAL_DEBUG_PROBE + 0x10)
+#define DEBUG_PROBE5                  (REG_BASE_cpu_block + LR_LOCAL_DEBUG_PROBE + 0x14)
+#define DEBUG_PROBE6                  (REG_BASE_cpu_block + LR_LOCAL_DEBUG_PROBE + 0x18)
+#define DEBUG_PROBE7                  (REG_BASE_cpu_block + LR_LOCAL_DEBUG_PROBE + 0x1c)
+
+// uses 8 entries, up to 0x1EF0
+#define PARAM_VSYNC_PERIOD_DEC0        (REG_BASE_cpu_block + LR_VSYNC_PERIOD)  // video decoder 0
+
+#endif // __EMHWLIB_RESOURCES_SHARED_H__
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango2/emhwlib_resources_shared.inc linux-3.9.2/arch/mips/include/asm/tango2/emhwlib_resources_shared.inc
--- linux-3.9.2.ref/arch/mips/include/asm/tango2/emhwlib_resources_shared.inc	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango2/emhwlib_resources_shared.inc	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,14 @@
+#
+#******************************************************
+#* This file is generated automatically, DO NOT EDIT! *
+#******************************************************
+#*
+#* destined to be included by a shell script or a Makefile (keep syntax adapted to both)
+#*
+#* emhwlib/include/emhwlib_resources_shared.inc (generated from emhwlib/include/emhwlib_resources_shared.h)
+#*
+#* Copyright (C) Sigma Designs, Inc. 2007.
+#*
+i386=0x1
+linux=0x1
+unix=0x1
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango2/emhwlib_resources_tango2.h linux-3.9.2/arch/mips/include/asm/tango2/emhwlib_resources_tango2.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango2/emhwlib_resources_tango2.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango2/emhwlib_resources_tango2.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,47 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/**
+  @file   emhwlib_resources_tango2.h
+  @brief  
+
+  long description
+
+  @author Emmanuel Michon
+  @date   2004-01-28y
+*/
+
+#ifndef __EMHWLIB_RESOURCES_TANGO2_H__
+#define __EMHWLIB_RESOURCES_TANGO2_H__
+
+#define VSYNC_PARAM_MUTEX   ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex2))
+#define PCI_IRQ_MUTEX       ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex3))
+#define GFX_MUTEX           ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex4))
+#define HOST_MBUS_MUTEX     ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex5))
+#define SOFT_IRQ_MUTEX_TASK ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex6))
+#define SOFT_IRQ_MUTEX_IRQ  ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex7))
+#define SOFT_IRQ_MUTEX_FIQ  ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex8))
+#define RTC_IRQ_MUTEX       ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex9))
+#define XRPC_MUTEX          ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex10))
+#define XTASK_MUTEX         ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex11))
+#define IDMA_MUTEX          ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex12)) /* keep same as tango15 */
+#define TIMER_IRQ_MUTEX     ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex13)) 
+
+#define AUDIO_0_IRQ_MUTEX   ((struct gbus_mutex *)(DMEM_BASE_audio_engine_0 + 4 * audio_mutex0))
+#define AUDIO_1_IRQ_MUTEX   ((struct gbus_mutex *)(DMEM_BASE_audio_engine_1 + 4 * audio_mutex0))
+#define VIDEO_0_FIFO_MUTEX  ((struct gbus_mutex *)(DMEM_BASE_mpeg_engine_0  + 4 * mpeg_mutex0))
+#define VIDEO_1_FIFO_MUTEX  ((struct gbus_mutex *)(DMEM_BASE_mpeg_engine_1  + 4 * mpeg_mutex0))
+#define DEMUX_IRQ_MUTEX     ((struct gbus_mutex *)(DMEM_BASE_demux_engine   + 4 * demux_mutex0))
+#define DEMUX_EMHWLIB_MUTEX ((struct gbus_mutex *)(DMEM_BASE_demux_engine   + 4 * demux_mutex4))
+#define TIMER_UPDATE_MUTEX  ((struct gbus_mutex *)(DMEM_BASE_demux_engine   + 4 * demux_mutex5))
+
+#define AUDIO_1_RPC_MUTEX ((struct gbus_mutex *)(DMEM_BASE_audio_engine_1 + 4 * audio_mutex1))
+#define AUDIO_1_ENET_MUTEX ((struct gbus_mutex *)(DMEM_BASE_audio_engine_1 + 4 * audio_mutex2))
+#define AUDIO_1_INTSTATUS_MUTEX ((struct gbus_mutex *)(DMEM_BASE_audio_engine_1 + 4 * audio_mutex3))
+
+#endif // __EMHWLIB_RESOURCES_TANGO2_H__
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango2/emhwlib_resources_tango2.inc linux-3.9.2/arch/mips/include/asm/tango2/emhwlib_resources_tango2.inc
--- linux-3.9.2.ref/arch/mips/include/asm/tango2/emhwlib_resources_tango2.inc	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango2/emhwlib_resources_tango2.inc	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,14 @@
+#
+#******************************************************
+#* This file is generated automatically, DO NOT EDIT! *
+#******************************************************
+#*
+#* destined to be included by a shell script or a Makefile (keep syntax adapted to both)
+#*
+#* emhwlib/include/tango2/emhwlib_resources_tango2.inc (generated from emhwlib/include/tango2/emhwlib_resources_tango2.h)
+#*
+#* Copyright (C) Sigma Designs, Inc. 2007.
+#*
+i386=0x1
+linux=0x1
+unix=0x1
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango2/fip.h linux-3.9.2/arch/mips/include/asm/tango2/fip.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango2/fip.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango2/fip.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,121 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+/*
+ * FIP related definitions, and function prototypes.
+ */
+#ifndef _FIP_H_
+#define _FIP_H_
+
+#ifdef __KERNEL__
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <asm/ioctl.h>
+#endif /* __KERNEL__ */
+
+/* Valid symbols */
+#if defined(CONFIG_TANGOX_FIP_REF1)
+#define DVD_FIP_ON			0
+#define PLAY_FIP_ON			1
+#define DTS_FIP_ON			2
+#define MP3_FIP_ON			3
+#define DOLBYDIGITAL_FIP_ON		4
+#define MPEG4_FIP_ON			5
+#define PAUSE_FIP_ON			6
+#define DVI_FIP_ON              	7
+#define TWIRL_1_FIP_ON			8
+#define TWIRL_2_FIP_ON			9
+#define TWIRL_3_FIP_ON			10
+#define TWIRL_4_FIP_ON			11
+#define TWIRL_5_FIP_ON			12
+#define TWIRL_6_FIP_ON			13
+#define ALL_FIP_ON			14
+#define REPEAT_FIP_ON			15
+#define COLON_MIN_SEC_FIP_ON		16
+#define R1080_FIP_ON			17
+#define R720_FIP_ON			18
+#define COLON_HOUR_MIN_FIP_ON		19
+#define R480_FIP_ON			20
+#define PAL_FIP_ON			21
+#define NTSC_FIP_ON			22
+#elif defined(CONFIG_TANGOX_FIP_REF2)
+#define DVD_FIP				201
+#define VCD_FIP				202
+#define MP3_FIP				203
+#define CD_FIP				204
+#define TITLE_FIP			205
+#define TRACK_CHAPTER_FIP		206
+#else
+#error Unsupport front panel.
+#endif
+
+/* Alignment */
+#define FIP_LEFT		0x0000	/* flags for fip_write_text() */
+#define FIP_CENTER		0x0001
+#define FIP_RIGHT		0x0002
+
+/* FIP Keys */
+#if defined(CONFIG_TANGOX_FIP_REF1)
+#define FIP_KEY_EJECT		0x00000004
+#define FIP_KEY_PREV		0x00000800
+#define FIP_KEY_NEXT		0x00008000
+#define FIP_KEY_FBWD		0x00000008
+#define FIP_KEY_FFWD		0x00000080
+#define FIP_KEY_PLAYPAUSE	0x00000040
+#define FIP_KEY_STOP		0x00000400
+#elif defined(CONFIG_TANGOX_FIP_REF2)
+#define FIP_KEY_EJECT		0x00000001
+#define FIP_KEY_PLAYPAUSE	0x00000002
+#define FIP_KEY_STOP		0x00000004
+#define FIP_KEY_PREV		0x00000008
+#define FIP_KEY_NEXT		0x00000010
+#define FIP_KEY_FBWD		0x00000020
+#define FIP_KEY_FFWD		0x00000040
+#define FIP_KEY_MENU		0x00000080
+#else
+#error Unsupport front panel.
+#endif
+
+#if defined(__KERNEL__) || !defined(BOOTLOADER)
+/* ioctl commands for user level applications*/
+#define FIP_IOC_MAGIC		'F'
+#define FIP_IOCSHOWSYMBOL	_IO(FIP_IOC_MAGIC, 0)
+#define FIP_IOCSHOWHMS		_IO(FIP_IOC_MAGIC, 1)
+#define FIP_IOCDISPCHAR		_IO(FIP_IOC_MAGIC, 2)
+#define FIP_IOCDISPRAW		_IO(FIP_IOC_MAGIC, 3)
+#define FIP_IOCDISPTEXT		_IO(FIP_IOC_MAGIC, 4)
+#define FIP_IOCCLEAR		_IO(FIP_IOC_MAGIC, 5)
+#define FIP_IOCGETFPTYPE	_IO(FIP_IOC_MAGIC, 6)
+#endif /* __KERNEL__ || !BOOTLOADER */
+
+#ifdef __KERNEL__
+static void fip_write_text(const int position, const char *text, const int flags);
+static int fip_show_hms(int hour, int minute, int second);
+static void fip_display_symbol(const int symbol, const int on);
+static int fip_display_character(const int position, const char character);
+static void fip_display_raw(const int byte, const int bit, const int on); 
+static int is_fip_busy(void);
+static void fip_wait_ready(void);
+static void fip_clear(void);
+#elif defined(BOOTLOADER)
+void fip_write_text(const int position, const char *text, const int flags);
+int fip_show_hms(int hour, int minute, int second);
+void fip_display_symbol(const int symbol, const int on);
+int fip_display_character(const int position, const char character);
+void fip_display_raw(const int byte, const int bit, const int on); 
+int is_fip_busy(void);
+void fip_wait_ready(void);
+void fip_clear(void);
+int fip_init(void);
+int fip_exit(void);
+unsigned long fip_readkey(void);
+#endif /* __KERNEL__ */
+
+#endif
+
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango2/hardware.h linux-3.9.2/arch/mips/include/asm/tango2/hardware.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango2/hardware.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango2/hardware.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,122 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+#ifndef __HARDWARE_H
+#define __HARDWARE_H
+
+#include <linux/version.h>
+#include <asm/tango2/emhwlib_registers_tango2.h>
+#include <asm/tango2/tango2_gbus.h>
+
+/* UART0 */
+#define CPU_uart0_gpio_dir	    (CPU_UART0_base + CPU_UART_GPIODIR)
+#define CPU_uart0_gpio_data	    (CPU_UART0_base + CPU_UART_GPIODATA)
+#define CPU_uart0_gpio_mode	    (CPU_UART0_base + CPU_UART_GPIOMODE)
+
+/* UART1 */
+#define CPU_uart1_gpio_dir	    (CPU_UART1_base + CPU_UART_GPIODIR)
+#define CPU_uart1_gpio_data	    (CPU_UART1_base + CPU_UART_GPIODATA)
+#define CPU_uart1_gpio_mode	    (CPU_UART1_base + CPU_UART_GPIOMODE)
+
+#define MIPS_CPU_IRQ_BASE 0
+
+#define IRQ_CONTROLLER_IRQ_BASE 8
+#define FIQ_CONTROLLER_IRQ_BASE 72
+#define IIQ_CONTROLLER_IRQ_BASE 136 // bit31 of iiq is linux irq 199
+#define IRQ_COUNT               64  // 64 interrupt sources
+
+#define IRQ_SOFTINT                     (IRQ_CONTROLLER_IRQ_BASE+0)   // gnet compatibility
+/* IDE interrupts */
+#define IRQ_IDECTRL_IDEDMA	(LOG2_CPU_DMAIDE_INT + IRQ_CONTROLLER_IRQ_BASE)
+#define IRQ_IDECTRL_IDE		(LOG2_CPU_IDE_INT + IRQ_CONTROLLER_IRQ_BASE)
+
+/* MBUS interface */
+#define MIF_add_offset		    0x0
+#define MIF_cnt_offset              (MIF_W0_CNT - MIF_W0_ADD) //0x04
+#define MIF_add2_skip_offset        (MIF_W0_SKIP - MIF_W0_ADD) //0x08
+#define MIF_cmd_offset              (MIF_W0_CMD - MIF_W0_ADD) //0x0c
+
+/* GPIO */
+#define GPIO_DIR_INPUT(gpio)        ((1 << (16 + (gpio))))
+#define GPIO_DIR_OUTPUT(gpio)       ((1 << (16 + (gpio))) | (1 << (gpio)))
+#define GPIO_DATA_SET(gpio)         ((1 << (16 + (gpio))) | (1 << (gpio)))
+#define GPIO_DATA_CLEAR(gpio)       ((1 << (16 + (gpio))))
+
+/* UART GPIO */
+#define UART_GPIO_DIR_INPUT(gpio)        ((1 << (8 + (gpio))))
+#define UART_GPIO_DIR_OUTPUT(gpio)       ((1 << (8 + (gpio))) | (1 << (gpio)))
+#define UART_GPIO_DATA_SET(gpio)         ((1 << (8 + (gpio))) | (1 << (gpio)))
+#define UART_GPIO_DATA_CLEAR(gpio)       ((1 << (8 + (gpio))))
+
+/* PCI Memories */
+#define MEMORY_BASE_PCI_CONFIG      0x50000000UL  /* PCI configuration */
+#define MEMORY_BASE_PCI_IO          0x58000000UL  /* PCI I/O space */
+#define MEMORY_BASE_PCI_MEMORY      0x60000000UL  /* PCI Memory Base */
+
+#define MAX_LOG2_PCIMEM_MAP  	7   	/* 2^7 = 128MB */
+#define MAX_PCIMEM_MAP_SIZE  	(((1<<MAX_LOG2_PCIMEM_MAP)*7)>>3)	/* Max 112MB */
+
+#define PCIBIOS_MIN_MEM_EM86XX  (MEMORY_BASE_PCI_MEMORY + 0x10000000UL)   /* base address of EM86xx PCI slave */
+
+/* Peripheral bus Registers */
+#define HOST_pb0_base               0x0000
+#define HOST_pb_base_cs(n)          (HOST_pb0_base + (0x0200 * (n)))
+
+#define PB_timing_slot(n)	    (PB_timing0 + (0x04 * (n)))
+
+/* Bus Master IDE */
+#define REG_BASE_host_interface_BMIDE         (REG_BASE_host_interface + IDECTRL_pri_cmdblock)
+
+#define REG_BASE_host_interface_ISAIDE(x)  (REG_BASE_host_interface + HOST_pb_base_cs(x))
+
+#ifndef MAX_KERNEL_MEMSIZE
+#define MAX_KERNEL_MEMSIZE	0x10000000UL
+#endif
+
+#ifndef __ASSEMBLY__
+/* Physical address mapping */
+static inline unsigned long tangox_dma_address(unsigned long physaddr)
+{
+#ifndef CONFIG_TANGOX_USE_TLB_REMAP_DRAM1
+	if (physaddr >= MEM_BASE_dram_controller_0)
+		return(physaddr); /* for Tango2, it's the same */
+	else if (physaddr >= CPU_remap4_address) 
+		return(gbus_read_reg32(REG_BASE_cpu_block + CPU_remap4) + (physaddr - CPU_remap4_address));
+	else if (physaddr >= CPU_remap3_address) 
+		return(gbus_read_reg32(REG_BASE_cpu_block + CPU_remap3) + (physaddr - CPU_remap3_address));
+	else if (physaddr >= CPU_remap2_address) 
+		return(gbus_read_reg32(REG_BASE_cpu_block + CPU_remap2) + (physaddr - CPU_remap2_address));
+#endif
+	return(physaddr); 
+}
+
+/* Inverted physical address mapping */
+static inline unsigned long tangox_inv_dma_address(unsigned long mapaddr)
+{
+#ifndef CONFIG_TANGOX_USE_TLB_REMAP_DRAM1
+	if ((mapaddr >= MEM_BASE_dram_controller_0) && (mapaddr < MEM_BASE_dram_controller_1))
+		return(mapaddr); /* for Tango2, it's the same */
+	else {
+		unsigned long remap;
+		remap = gbus_read_reg32(REG_BASE_cpu_block + CPU_remap4);
+		if ((mapaddr >= remap) && (mapaddr < (remap + 0x04000000)))
+			return(CPU_remap4_address + (mapaddr - remap));
+		remap = gbus_read_reg32(REG_BASE_cpu_block + CPU_remap3);
+		if ((mapaddr >= remap) && (mapaddr < (remap + 0x04000000)))
+			return(CPU_remap3_address + (mapaddr - remap));
+		remap = gbus_read_reg32(REG_BASE_cpu_block + CPU_remap2);
+		if ((mapaddr >= remap) && (mapaddr < (remap + 0x04000000)))
+			return(CPU_remap2_address + (mapaddr - remap));
+	}
+#endif
+	return(mapaddr); /* for Tango2, it's the same */
+}
+#endif
+		
+#endif /* __HARDWARE_H */
+
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango2/ir.h linux-3.9.2/arch/mips/include/asm/tango2/ir.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango2/ir.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango2/ir.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,34 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+                                                                                
+/*
+ * IR related definitions, and function prototypes.
+ */
+#ifndef _IR_H_
+#define _IR_H_
+                                                                                
+#ifdef __KERNEL__
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <asm/ioctl.h>
+#elif !defined(BOOTLOADER)
+#include <sys/ioctl.h>
+#endif /* __KERNEL__ */
+
+#if defined(__KERNEL__) || !defined(BOOTLOADER)
+/* ioctl commands for user level applications*/
+#define IR_IOC_MAGIC           'I'
+#define IR_IOCSETREPEATKEYS	_IO(IR_IOC_MAGIC, 0)
+#define IR_IOCGETREPEATKEYS	_IO(IR_IOC_MAGIC, 1)
+#define IR_IOCSETWAITPERIOD	_IO(IR_IOC_MAGIC, 2)
+#define IR_IOCGETWAITPERIOD	_IO(IR_IOC_MAGIC, 3)
+#endif /* __KERNEL__ || !BOOTLOADER */
+                                                                                
+#endif /* _IR_H_ */
+
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango2/memcfg.h linux-3.9.2/arch/mips/include/asm/tango2/memcfg.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango2/memcfg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango2/memcfg.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,44 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/* For more memcfg operations */
+
+#ifndef _MEMCFG_H_
+#define _MEMCFG_H_
+
+#include <asm/tango2/tango2.h>
+#include <asm/tango2/rmem86xxid.h>
+#include <asm/tango2/emhwlib_lram.h>
+#include <asm/tango2/emhwlib_dram.h>
+
+static inline int is_valid_memcfg(memcfg_t *memcfg_ptr)
+{
+	unsigned int sum, i, *ptr;
+
+	if ((memcfg_ptr->signature) != MEMCFG_SIGNATURE)
+		return(0);
+	for (sum = i = 0, ptr = (unsigned int *)memcfg_ptr;
+		i < (sizeof(memcfg_t) / sizeof(unsigned int)); i++, ptr++)
+		sum += (*ptr);
+	return((sum == 0) ? 1 : 0);
+}
+
+static inline void gen_memcfg_checksum(memcfg_t *memcfg_ptr)
+{
+	unsigned int sum, i, *ptr;
+
+	memcfg_ptr->checksum = 0;
+	for (sum = i = 0, ptr = (unsigned int *)memcfg_ptr;
+		i < (sizeof(memcfg_t) / sizeof(unsigned int)); i++, ptr++)
+		sum += (*ptr);
+	memcfg_ptr->checksum = ~sum + 1;
+}
+
+#endif /* _MEMCFG_H_ */
+
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango2/rmdefs.h linux-3.9.2/arch/mips/include/asm/tango2/rmdefs.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango2/rmdefs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango2/rmdefs.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,11 @@
+
+#ifndef __RMDEFS_H
+#define __RMDEFS_H
+
+typedef unsigned long RMuint32;
+typedef unsigned short RMuint16;
+typedef unsigned char RMuint8;
+typedef char RMascii;
+typedef int RMstatus;
+
+#endif
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango2/rmem86xxid.h linux-3.9.2/arch/mips/include/asm/tango2/rmem86xxid.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango2/rmem86xxid.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango2/rmem86xxid.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,203 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/**
+  @file   rmem86xxid.h
+  @brief  
+
+  long description
+
+  @author Emmanuel Michon
+  @date   2004-09-22
+*/
+
+#ifndef __RMEM86XXID_H__
+#define __RMEM86XXID_H__
+
+/*
+  the main chip ids 
+  
+  tango3 is for asic development (should be tango\infty)
+
+  Usually, users do not set by hand, but thru `rmcflags' helper
+*/
+#define EM86XX_CHIPID_MAMBO      1000
+#define EM86XX_CHIPID_MAMBOLIGHT 2000
+#define EM86XX_CHIPID_TANGO      3000
+#define EM86XX_CHIPID_TANGOLIGHT 4000
+#define EM86XX_CHIPID_TANGO15    4500
+#define EM86XX_CHIPID_TANGO2     5000
+#define EM86XX_CHIPID_TANGO3    10000
+
+#if (EM86XX_CHIP==EM86XX_CHIPID_MAMBO)
+#define S_EM86XX_CHIPID "mambo"
+#elif (EM86XX_CHIP==EM86XX_CHIPID_MAMBOLIGHT)
+#define S_EM86XX_CHIPID "mambolight"
+#elif (EM86XX_CHIP==EM86XX_CHIPID_TANGOLIGHT)
+#define S_EM86XX_CHIPID "tangolight"
+#elif (EM86XX_CHIP==EM86XX_CHIPID_TANGO15)
+#define S_EM86XX_CHIPID "tango15"
+#elif (EM86XX_CHIP==EM86XX_CHIPID_TANGO2)
+#define S_EM86XX_CHIPID "tango2"
+#elif (EM86XX_CHIP==EM86XX_CHIPID_TANGO3)
+#define S_EM86XX_CHIPID "tango3"
+#else
+#error EM86XX_CHIP is not set
+#endif
+
+/* 
+  revisions...
+  
+  Referring to whatever is written at the surface of the BGA,
+  not the PCI revid / subid / etc. This detail is important for some chips
+  are ambiguous software wise.
+  
+  1: ES1
+  2: ES2
+  3: ES3
+  4: ES4 
+  5: ES5 
+  6: ES6 
+  65: revA
+  66: revB
+  67: revC
+  
+  No ID, but numbers. For a 8630ES2 for instance: build with
+  RMCFLAGS="... -DEM86XX_CHIP=EM86XX_CHIPID_TANGO2 -DEM86XX_REVISION=2 ..."
+
+  --------------------------------------------------------------------------
+  package writing          ES1  ES2  ES3  ES4     ES5     ES6  ES7  ES8  ES9 revA revB revC
+
+  EM86XX_REVISION            1    2    3    4       5       6    7    8    9  'A'  'B'  'C'
+
+  8600 `mambo' series                                                           1    2    3
+
+  8620 `tangolight' series                                                    (a)  (b) 0x82
+  8622 `tango15' series   0x81                (d)0x81                   0x82
+                                                                           ^this is the PCI revID
+
+  863x `tango2' series (c)0x81 0x81 0x81 0x82 (e)0x82 (f)0x83 0x84 0x85 0x86                
+
+  (a) don't remember
+  (b) no such chip
+  (c) 8630: FibbedES1 ES1 ES2 ES3 are the same chip
+  (d) 8622: ES1 and revA cannot be distinguished from revID. Software test impossible in practice
+  (e) 8630: ES4 and ES5 cannot be distinguished from revID. Software test with 0x6c900 bit12
+  (f) 8634: ES6 and RevA have the same revID (just different bonding option)
+      8634: ES7 and RevB have the same revID (just different bonding option)
+      8634: ES9 and RevC have the same revID (just different bonding option)
+  --------------------------------------------------------------------------
+
+  Usually, users do not set by hand, but thru `rmcflags' helper
+*/
+#ifndef EM86XX_REVISION
+#error EM86XX_REVISION is not set
+#endif
+
+#if (EM86XX_CHIP==EM86XX_CHIPID_TANGO2) && (EM86XX_REVISION=='A') 
+#error inconsistent: 863x revA is actually -DWITH_PROD=1 -DEM86XX_REVISION=6
+#endif
+
+#if (EM86XX_CHIP==EM86XX_CHIPID_TANGO2) && (EM86XX_REVISION=='B') 
+#error inconsistent: 863x revB is actually -DWITH_PROD=1 -DEM86XX_REVISION=7
+#endif
+
+#if (EM86XX_CHIP==EM86XX_CHIPID_TANGO2) && (EM86XX_REVISION=='C') 
+#error inconsistent: 863x revC is actually -DWITH_PROD=1 -DEM86XX_REVISION=9
+#endif
+
+#if (EM86XX_REVISION==1)
+#define S_EM86XX_REVISION "ES1"
+#elif (EM86XX_REVISION==2)
+#define S_EM86XX_REVISION "ES2"
+#elif (EM86XX_REVISION==3)
+#define S_EM86XX_REVISION "ES3"
+#elif (EM86XX_REVISION==4)
+#define S_EM86XX_REVISION "ES4"
+#elif (EM86XX_REVISION==5)
+#define S_EM86XX_REVISION "ES5"
+#elif (EM86XX_REVISION==6)
+#if (EM86XX_CHIP==EM86XX_CHIPID_TANGO2) && (defined(WITH_PROD) || defined(WITH_FACSPROD))
+#define S_EM86XX_REVISION "revA"
+#else
+#define S_EM86XX_REVISION "ES6"
+#endif
+#elif (EM86XX_REVISION==7)
+#if (EM86XX_CHIP==EM86XX_CHIPID_TANGO2) && (defined(WITH_PROD) || defined(WITH_FACSPROD))
+#define S_EM86XX_REVISION "revB"
+#else
+#define S_EM86XX_REVISION "ES7"
+#endif
+#elif (EM86XX_REVISION==8)
+#define S_EM86XX_REVISION "ES8"
+#elif (EM86XX_REVISION==9)
+#if (EM86XX_CHIP==EM86XX_CHIPID_TANGO2) && (defined(WITH_PROD) || defined(WITH_FACSPROD))
+#define S_EM86XX_REVISION "revC"
+#else
+#define S_EM86XX_REVISION "ES9"
+#endif
+
+#elif (EM86XX_REVISION=='A')
+#define S_EM86XX_REVISION "revA"
+#elif (EM86XX_REVISION=='B')
+#define S_EM86XX_REVISION "revB"
+#elif (EM86XX_REVISION=='C')
+#define S_EM86XX_REVISION "revC"
+#else
+#error complete revision strings
+#endif
+
+/* the compilation modes */
+#define EM86XX_MODEID_WITHHOST   1000
+#define EM86XX_MODEID_STANDALONE 2000
+
+/* the dsps */
+#define EM86XX_ENGINEID_MPEG0 10
+#define EM86XX_ENGINEID_MPEG1 11
+#define EM86XX_ENGINEID_AUDIO0 20
+#define EM86XX_ENGINEID_AUDIO1 21
+#define EM86XX_ENGINEID_DEMUX 30
+
+/* user does not have to set an engine id. This makes sense for mu only */
+#ifdef EM86XX_ENGINE
+#if (EM86XX_ENGINE==EM86XX_ENGINEID_MPEG0)
+#define SENG "mpeg0"
+#elif (EM86XX_ENGINE==EM86XX_ENGINEID_MPEG1)
+#define SENG "mpeg1"
+#elif (EM86XX_ENGINE==EM86XX_ENGINEID_AUDIO0)
+#define SENG "audio0"
+#elif (EM86XX_ENGINE==EM86XX_ENGINEID_AUDIO1)
+#define SENG "audio1"
+#elif (EM86XX_ENGINE==EM86XX_ENGINEID_DEMUX)
+#define SENG "demux"
+#else
+#endif // end of engine dependent stuff
+#endif
+
+#if (EM86XX_CHIP==EM86XX_CHIPID_TANGO2)
+/*
+#if (defined(WITH_PROD) || defined(WITH_FACSPROD)) && !defined WITH_XLOADED_UCODE
+#error inconsistent flag combination.
+#endif
+
+#if (defined(WITH_PROD) || defined(WITH_FACSPROD)) && !defined WITH_IRQHANDLER_BOOTLOADER
+#error inconsistent flag combination.
+#endif
+*/
+#ifdef WITH_UCODE_BOOTLOADER
+#error inconsistent flag combination. You probably want WITH_XLOADED_UCODE
+#endif
+
+#endif
+
+/* the microcode debug mode */
+
+#define EM86XX_DEBUG_CHIP	1000
+#define EM86XX_DEBUG_SIMU	2000
+
+#endif // __RMEM86XXID_H__
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango2/scard.h linux-3.9.2/arch/mips/include/asm/tango2/scard.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango2/scard.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango2/scard.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,31 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+                                                                                
+/*
+ * Smart card related definitions, and function prototypes.
+ */
+#ifndef _SCARD_H_
+#define _SCARD_H_
+                                                                                
+#ifdef __KERNEL__
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <asm/ioctl.h>
+#else
+#include <sys/ioctl.h>
+#endif /* __KERNEL__ */
+
+/* ioctl commands for user level applications*/
+#define SCARD_IOC_MAGIC		'S'
+#define SCARD_IOC_WARMRESET	_IO(SCARD_IOC_MAGIC, 0)
+#define SCARD_IOC_CLOCKSTOP	_IO(SCARD_IOC_MAGIC, 1)
+#define SCARD_IOC_CLOCKSTART	_IO(SCARD_IOC_MAGIC, 2)
+                                                                                
+#endif /* _SCARD_H_ */
+
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango2/sigblock.h linux-3.9.2/arch/mips/include/asm/tango2/sigblock.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango2/sigblock.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango2/sigblock.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,261 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#ifndef __SIG_BLOCK_H__
+#define __SIG_BLOCK_H__
+
+#define DEFAULT_IRQ_ROUTE1	0x55555555 /* All PCI IRQs route to LOG2_CPU_PCI_INTB */
+#define DEFAULT_IRQ_ROUTE2	0x00030000 /* ISA IDE uses LOG2_CPU_PCU_INTD, Timing slot 0 */
+#define DEFAULT_IRQ_RISE_EDGE_LO	0xff284a00 /* IRQ14 active low level, IRQ19/21 active riseedge */
+#define DEFAULT_IRQ_RISE_EDGE_HI	0x00000000 /* IRQ14 active low level, IRQ19/21 active rise edge */
+#define DEFAULT_IRQ_FALL_EDGE_LO	0x00004000
+#define DEFAULT_IRQ_FALL_EDGE_HI	0x00000000
+#define DEFAULT_IRQ_GPIO_MAP	0x0607080d /* ISA IDE/GPIO 6, PCI/GPIO 8 */
+#define DEFAULT_DEV_ENABLED	0x00003cf7 /* ISAIDE/BMIDE/PCIHOST/IR/FIP/I2CM/I2CS/PCI1-4 enabled */
+#define DEFAULT_PB_DEF_TIMING	0x01090008
+#define DEFAULT_PB_CS_CONFIG	0x00001044
+#define DEFAULT_PB_TIMING0	0x01090008
+#define DEFAULT_PB_USE_TIMING0	0x000001f4
+#define DEFAULT_PB_TIMING1	0x00110101
+#define DEFAULT_PB_USE_TIMING1	0x000003f3
+#define DEFAULT_PB_TIMING2	0
+#define DEFAULT_PB_USE_TIMING2	0
+#define DEFAULT_PB_TIMING3	0
+#define DEFAULT_PB_USE_TIMING3	0
+#define DEFAULT_PB_TIMING4	0
+#define DEFAULT_PB_USE_TIMING4	0
+#define DEFAULT_PB_TIMING5	0
+#define DEFAULT_PB_USE_TIMING5	0
+
+#define DEFAULT_SYSCLK_PLL	0x0 /* Set by XOS */
+#define DEFAULT_SYSCLK_DIV	0x0 /* Not changed */
+
+#define DEFAULT_ETH_MAC_HI	0x00000000 /* MAC address */
+#define DEFAULT_ETH_MAC_LO	0x00000000
+
+/* This list of devices in the enable list field (irq_route2) */
+#define ISAIDE_SHIFT		0
+#define BMIDE_SHIFT		1
+#define PCIHOST_SHIFT		2
+#define ETHERNET_SHIFT		3
+#define IR_SHIFT		4
+#define FIP_SHIFT		5	
+#define I2CM_SHIFT		6
+#define I2CS_SHIFT		7
+#define SDIO_SHIFT		8
+#define USB_SHIFT		9
+#define PCI1_SHIFT		10
+#define PCI2_SHIFT		11
+#define PCI3_SHIFT		12
+#define PCI4_SHIFT		13
+#define PCI5_SHIFT		14
+#define PCI6_SHIFT		15
+#define SATA_SHIFT		16
+#define SCARD_SHIFT		17
+#define GNET_SHIFT		18
+/*				19-32: undefined */
+
+#ifndef __ASSEMBLY__
+
+struct hwinfo {
+	unsigned long sysclk_pll; /* The setting for the PLL */
+	unsigned long sysclk_div;
+
+	/* Only 4 IRQs can be used for PCI devices (LOG2_CPU_PCI_INTA-D,
+	   so we can encode it in 2 bits. Each device can have 4 IRQ
+	   routing and as as result we can use one byte to represent
+	   the IRQ route for a given device (IDSELx). Bu using 8 bytes,
+	   we can represent the PCI devices (IDSEL1-6, 5-6 reserved) as
+	   well as ISA IDE information and device enabling list*/
+	unsigned long irq_route1;	/* PCI dev 1-4 */
+
+	/* PCI dev 5-6, ISA IDE information, device enabling list */
+	unsigned long irq_route2;	/* PCI dev 5-6: bit 0-15 */
+					/* ISA IDE: bit 16-17: IRQ offset */
+
+	unsigned long irq_rise_edge_hi; /* Rising edge config */
+	unsigned long irq_rise_edge_lo; /* Rising edge config */
+	unsigned long irq_fall_edge_hi; /* Falling edge config */
+	unsigned long irq_fall_edge_lo; /* Falling edge config */
+
+	unsigned long gpio_irq_map; /* GPIO pins hook to IRQ13..16 */
+	unsigned long dev_enabled;  /* Device enabling list*/
+
+	unsigned long pb_def_timing;
+	unsigned long pb_cs_config;
+	unsigned long pb_timing0;
+	unsigned long pb_use_timing0;
+	unsigned long pb_timing1;
+	unsigned long pb_use_timing1;
+	unsigned long pb_timing2;
+	unsigned long pb_use_timing2;
+	unsigned long pb_timing3;
+	unsigned long pb_use_timing3;
+	unsigned long pb_timing4;
+	unsigned long pb_use_timing4;
+	unsigned long pb_timing5;
+	unsigned long pb_use_timing5;
+
+	unsigned long mac_hi;	/* Ethernet MAC address */
+	unsigned long mac_lo;
+};
+
+/* Definition of signature block (192bytes), which should start at 0xbfc00000 */
+/* There'll be 20bytes sha1sum afterward (0xbfc000c0-0xbfc000d3) */
+struct signature_block {
+	unsigned long opcodes[2];  /* For opcodes, fixed value 0x10000034/0x00000000 */
+	struct hwinfo hwinfo;
+	/* 
+	   zboot or such specific extensions 
+
+	   Note that YAMON requires extension[2]=0x1105e0 (product ID `thirdparty')
+	 */
+	unsigned long extension[20];	
+};
+
+//RMmustBeEqual(sizeof(struct signature_block),3*64,seed0);
+
+#ifdef __EMHWLIB_REGISTERS_TANGO2_H__
+static inline int isaide_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> ISAIDE_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int bmide_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> BMIDE_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int sata_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> SATA_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int scard_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> SCARD_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int gnet_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> GNET_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int pci_host_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> PCIHOST_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int ethernet_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> ETHERNET_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int ir_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> IR_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int fip_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> FIP_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int i2cm_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> I2CM_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int i2cs_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> I2CS_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int sdio_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> SDIO_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int usb_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> USB_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int pcidev_enabled(const struct signature_block *sigptr, int pci_idsel)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> (pci_idsel - 1 + PCI1_SHIFT)) & 1) != 0) ? 1 : 0);
+}
+
+/* Given PCI device idsel number and INT number, returning the IRQ number
+   for it */
+static inline int pcidev_intr_num(const struct signature_block *sigptr,
+				const int pci_idsel, const int int_num)
+{
+	unsigned long route;
+	int irq;
+
+	if (pcidev_enabled(sigptr, pci_idsel) == 0)
+		return(-1);
+	else if ((pci_idsel >= 1) && (pci_idsel <= 4)) {
+		/* Get the routing information for specific device */
+		route = ((sigptr->hwinfo.irq_route1) >> ((pci_idsel - 1) * 8)) & 0xff;
+		irq = (int)((route >> (int_num * 2)) & 0x3); /* int_num: 0-3 = INTA-D */
+	} else if ((pci_idsel >= 5) && (pci_idsel <= 6)) {
+		/* Get the routing information for specific device */
+		route = ((sigptr->hwinfo.irq_route2) >> ((pci_idsel - 5) * 8)) & 0xff;
+		irq = (int)((route >> (int_num * 2)) & 0x3); /* int_num: 0-3 = INTA-D */
+	} else 
+		return(-1);
+
+	return(LOG2_CPU_PCI_INTA + irq);
+}
+ 
+/* Find out the CS# used by ISA IDE */
+static inline int isaide_cs_select(const struct signature_block *sigptr)
+{
+	unsigned long cs_config = (sigptr->hwinfo.pb_cs_config >> 12) & 0xf;
+	int i;
+
+	if (isaide_enabled(sigptr) == 0)
+		return(-1);
+
+	for (i = 0; i < 4; i++) {
+		if ((cs_config & 0x1) != 0) 
+			return(i);
+		else
+			cs_config >>= 1;
+	}
+	return(-1);
+}
+
+/* Return the IRQ number for ISA IDE */
+static inline int isaide_intr_num(const struct signature_block *sigptr)
+{
+	int irq;
+
+	if (isaide_enabled(sigptr) == 0)
+		return(-1);
+	else
+		irq = (int)(((sigptr->hwinfo.irq_route2) >> 16) & 0x3);
+	return(LOG2_CPU_PCI_INTA + irq);
+}
+
+static inline int isaide_timing_slot(const struct signature_block *sigptr)
+{
+	unsigned long slot;
+
+	slot = ((sigptr->hwinfo.irq_route2) >> 18) & 0x7;
+	return((int)slot);
+}
+#endif /* __EMHWLIB_REGISTERS_TANGO2_H__ */
+
+#endif /* !__ASSEMBLY__ */
+
+#endif /* !__SIG_BLOCK_H__ */
+
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango2/sigblock.inc linux-3.9.2/arch/mips/include/asm/tango2/sigblock.inc
--- linux-3.9.2.ref/arch/mips/include/asm/tango2/sigblock.inc	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango2/sigblock.inc	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,59 @@
+#
+#******************************************************
+#* This file is generated automatically, DO NOT EDIT! *
+#******************************************************
+#*
+#* destined to be included by a shell script or a Makefile (keep syntax adapted to both)
+#*
+#* emhwlib_hal/include/sigblock.inc (generated from emhwlib_hal/include/sigblock.h)
+#*
+#* Copyright (C) Sigma Designs, Inc. 2007.
+#*
+i386=0x1
+linux=0x1
+unix=0x1
+DEFAULT_IRQ_ROUTE1=0x55555555
+DEFAULT_IRQ_ROUTE2=0x30000
+DEFAULT_IRQ_RISE_EDGE_LO=0xff284a00
+DEFAULT_IRQ_RISE_EDGE_HI=0x0
+DEFAULT_IRQ_FALL_EDGE_LO=0x4000
+DEFAULT_IRQ_FALL_EDGE_HI=0x0
+DEFAULT_IRQ_GPIO_MAP=0x607080d
+DEFAULT_DEV_ENABLED=0x3cf7
+DEFAULT_PB_DEF_TIMING=0x1090008
+DEFAULT_PB_CS_CONFIG=0x1044
+DEFAULT_PB_TIMING0=0x1090008
+DEFAULT_PB_USE_TIMING0=0x1f4
+DEFAULT_PB_TIMING1=0x110101
+DEFAULT_PB_USE_TIMING1=0x3f3
+DEFAULT_PB_TIMING2=0x0
+DEFAULT_PB_USE_TIMING2=0x0
+DEFAULT_PB_TIMING3=0x0
+DEFAULT_PB_USE_TIMING3=0x0
+DEFAULT_PB_TIMING4=0x0
+DEFAULT_PB_USE_TIMING4=0x0
+DEFAULT_PB_TIMING5=0x0
+DEFAULT_PB_USE_TIMING5=0x0
+DEFAULT_SYSCLK_PLL=0x0
+DEFAULT_SYSCLK_DIV=0x0
+DEFAULT_ETH_MAC_HI=0x0
+DEFAULT_ETH_MAC_LO=0x0
+ISAIDE_SHIFT=0x0
+BMIDE_SHIFT=0x1
+PCIHOST_SHIFT=0x2
+ETHERNET_SHIFT=0x3
+IR_SHIFT=0x4
+FIP_SHIFT=0x5
+I2CM_SHIFT=0x6
+I2CS_SHIFT=0x7
+SDIO_SHIFT=0x8
+USB_SHIFT=0x9
+PCI1_SHIFT=0xa
+PCI2_SHIFT=0xb
+PCI3_SHIFT=0xc
+PCI4_SHIFT=0xd
+PCI5_SHIFT=0xe
+PCI6_SHIFT=0xf
+SATA_SHIFT=0x10
+SCARD_SHIFT=0x11
+GNET_SHIFT=0x12
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango2/tango2api.h linux-3.9.2/arch/mips/include/asm/tango2/tango2api.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango2/tango2api.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango2/tango2api.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,115 @@
+/*
+ * include/asm-mips/tango2/tangoa2pi.h
+ *
+ * Copyright 2002-2007, Sigma Designs, Inc 
+ *
+ * This file contains SMP86XX controling functions
+ *
+ */
+
+#ifndef __ASM_ARCH_EM86XX_H
+#define __ASM_ARCH_EM86XX_H
+#include <asm/tango2/hardware.h>
+//
+// global variables
+// 
+
+//
+// from arch/arm/arch-em86xx/irq.c
+//
+
+// irq
+void em86xx_mask_irq(unsigned int irq);
+void em86xx_unmask_irq(unsigned int irq);
+void em86xx_wait_irq(unsigned int irq);
+
+// fiq
+void em86xx_mask_fiq(unsigned int fiq);
+void em86xx_unmask_fiq(unsigned int fiq);
+
+// software interrupt
+int em86xx_softirq_isset(int irq);
+void em86xx_softirq_set(int irq);
+void em86xx_softirq_clr(int irq);
+void em86xx_irq_clr(int irq);
+
+//
+// from arch/arm/arch-em86xx/em86xxapi.c
+//
+
+// Cache
+// clean : write dirty buffer (D cache only)
+// invalidate : invalidate the contents of cache (I & D cache)
+// flush : clean + invalidate
+void em86xx_get_cache_state(int *picache, int *pdcache, int *pwriteback);
+void em86xx_enable_cache(int icache, int dcache, int writeback);
+void em86xx_clean_cache_data(void);
+void em86xx_clean_cache_data_region(unsigned int from, unsigned int to);
+void em86xx_invalidate_cache_instruction(void);
+void em86xx_invalidate_cache_instruction_region(unsigned int from, unsigned int to);
+void em86xx_invalidate_cache_data(void);
+void em86xx_invalidate_cache_data_region(unsigned int from, unsigned int to);
+
+void em86xx_flush_cache_all(void);
+void em86xx_flush_cache_data(void);
+void em86xx_flush_cache_data_region(unsigned int from, unsigned int to);
+
+// memory
+unsigned int em86xx_get_pciregionsize(void);
+unsigned int em86xx_get_dmamemorysize(void);
+
+// switchbox (Host interface)
+enum { 
+	SBOX_MBUS_W0 = 0, SBOX_MBUS_W1, SBOX_PCIMASTER, SBOX_PCISLAVE, 
+	SBOX_SATA0, SBOX_IDEFLASH, SBOX_IDEDVD, SBOX_UNUSED1, SBOX_MAX
+};
+
+int em86xx_sbox_init(void);
+#if 0
+void em86xx_sbox_reset(void);
+int em86xx_sbox_setup(void);
+int em86xx_sbox_connect(int iface);
+void em86xx_sbox_disconnect(int port);
+#endif
+
+// MBUS DMA 
+typedef void (*mbus_irq_handler_t)(int irq, void *arg);
+
+int em86xx_mbus_alloc_dma(int sbox, int fromdev, unsigned long *pregbase, int *pirq, int canwait);
+void em86xx_mbus_free_dma(unsigned long regbase, int sbox);
+int em86xx_mbus_setup_dma(unsigned int regbase, unsigned int addr, unsigned int count, mbus_irq_handler_t handler, void *arg, unsigned int flags);
+int em86xx_mbus_notification(unsigned int regbase, mbus_irq_handler_t handler, void *arg);
+int em86xx_mbus_inuse(unsigned int regbase);
+int em86xx_mbus_wait(unsigned int regbase, int sbox);
+void em86xx_mbus_reset(unsigned int regbase, int sbox);
+int mbus_memcpy(unsigned int regbase, unsigned int src, unsigned int dst, unsigned int size);
+
+// PCI master
+void em86xx_pcimaster_setup_read(unsigned int addr, unsigned int count);
+void em86xx_pcimaster_start_read(int start);
+void em86xx_pcimaster_setup_write(unsigned int addr, unsigned int count);
+void em86xx_pcimaster_start_write(int start);
+
+// GPIO
+#define GPIO_INPUT		0
+#define GPIO_OUTPUT		1
+
+int em86xx_gpio_read(int gpio);
+void em86xx_gpio_write(int gpio, int data);
+void em86xx_gpio_setdirection(int gpio, int dir);
+
+int em86xx_uart0_gpio_read(int gpio);
+void em86xx_uart0_gpio_write(int gpio, int data);
+void em86xx_uart0_gpio_setdirection(int gpio, int dir);
+int em86xx_uart1_gpio_read(int gpio);
+void em86xx_uart1_gpio_write(int gpio, int data);
+void em86xx_uart1_gpio_setdirection(int gpio, int dir);
+
+#define NUM_TANGOX_MUTEX	4
+#define MUTEX_PBI		0
+
+int tangox_mutex_lock(unsigned int idx);
+int tangox_mutex_unlock(unsigned int idx);
+
+#endif
+
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango2/tango2_gbus.h linux-3.9.2/arch/mips/include/asm/tango2/tango2_gbus.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango2/tango2_gbus.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango2/tango2_gbus.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,147 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+/*
+  Refer to bug #3644.
+
+  TLB-based implementation works on the ranges:
+  [0x00000000..0x20000000[ access thru kseg1
+  [0x20000000..0x2xxxxxxx (size  of dram1, a  parameter of ioremap())[
+  access thru tlb. Outside: unpredictable/oops.
+
+  Remap-based implementation does:
+  00xy b27b26..b0 to 101y(b27|x)b26..b0.
+  and works  everywhere excepted ranges:  [0x18000000..0x20000000[ and
+  [0x28000000..0xffffffff]
+
+  Test with
+  {
+	volatile int q=gbus_read_uint32(pGBus,0x1020212c); // correct
+	q=gbus_read_uint32(pGBus,0x1f20212c);              // incorrect
+	q=gbus_read_uint32(pGBus,0x2020212c);              // correct
+	q=gbus_read_uint32(pGBus,0x2720212c);              // correct
+	q=gbus_read_uint32(pGBus,0x2820212c);              // incorrect
+	q=gbus_read_uint32(pGBus,0x2f20212c);              // incorrect
+  }
+*/
+
+#ifndef __TANGO2_GBUS_H
+#define __TANGO2_GBUS_H
+
+#ifndef __ASSEMBLY__
+
+#include "rmdefs.h"
+
+#include <asm/addrspace.h>
+
+struct gbus;
+#define pGBus ((struct gbus *)1)
+
+#ifdef CONFIG_TANGOX_USE_TLB_REMAP_DRAM1
+
+__asm__ (
+	"	.macro gbus_swizzle_addr res tmp addr			\n"
+	"	ext	\\res, \\addr, 29, 1				\n"
+	"	bnez	\\res, 1f					\n"
+	"	lui	\\tmp, 0xa000					\n"
+	"	or	\\res, \\tmp, \\addr				\n"
+	"	j	2f						\n"
+	"	nop							\n"
+	"1:								\n"
+	"	lui	\\tmp, 0x2000					\n"
+	"	sub	\\res, \\addr, \\tmp				\n"
+	"	lw	\\tmp, em86xx_tlb_dram1_map_base		\n"
+	"	add	\\res, \\tmp					\n"
+	"2:								\n"
+	"	.endm");
+
+#else
+
+__asm__ (
+	"	.macro gbus_swizzle_addr res tmp addr			\n"
+	"	rotr	\\res, \\addr, 29				\n"
+	"	ins	\\res, \\res, 30, 1				\n"
+	"	or	\\res, 5					\n"
+	"	rotr	\\res, 3					\n"
+	"	.endm");
+#endif
+
+
+/*
+ * we just want to set kseg1 bit, most of the time address is known at
+ * compile time, so this will usually be reduced to 2 instructions
+ */
+
+#define BUILD_GBUS_READ(size)						\
+static inline RMuint32 gbus_read_dram_uint##size(struct gbus *pgbus,	\
+					    RMuint32 byte_address)	\
+{									\
+	if (__builtin_constant_p(byte_address)) {			\
+		if ((byte_address & 0x70000000) == 0x20000000) {	\
+			byte_address &= ~0x20000000;			\
+			byte_address |= 0x08000000;			\
+		}							\
+		return *((volatile RMuint##size *)KSEG1ADDR(byte_address)); \
+	} else {							\
+		RMuint32 res, tmp;					\
+									\
+		__asm__ __volatile(					\
+			"gbus_swizzle_addr\t%0 %1 %2\n"			\
+			: "=&r" (res), "=&r" (tmp) : "r" (byte_address)); \
+		return *((volatile RMuint##size *)res);			\
+	}								\
+}
+
+BUILD_GBUS_READ(8);
+BUILD_GBUS_READ(16);
+BUILD_GBUS_READ(32);
+
+#define BUILD_GBUS_WRITE(size)						\
+static inline void gbus_write_dram_uint##size(struct gbus *pgbus,	\
+				     RMuint32 byte_address,		\
+				     RMuint##size data)			\
+{									\
+	if (__builtin_constant_p(byte_address)) {			\
+		if ((byte_address & 0x70000000) == 0x20000000) {	\
+			byte_address &= ~0x20000000;			\
+			byte_address |= 0x08000000;			\
+		}							\
+		*((volatile RMuint##size *)KSEG1ADDR(byte_address)) = data; \
+	} else {							\
+		RMuint32 res, tmp;					\
+									\
+		__asm__ __volatile(					\
+			"gbus_swizzle_addr\t%0 %1 %2\n"			\
+			: "=&r" (res), "=&r" (tmp) : "r" (byte_address)); \
+		*((volatile RMuint##size *)res) = data;			\
+	}								\
+}
+
+BUILD_GBUS_WRITE(8);
+BUILD_GBUS_WRITE(16);
+BUILD_GBUS_WRITE(32);
+
+RMuint32 gbus_read_uint32(struct gbus *pgbus, RMuint32 byte_address);
+RMuint16 gbus_read_uint16(struct gbus *pgbus, RMuint32 byte_address);
+RMuint8 gbus_read_uint8(struct gbus *pgbus, RMuint32 byte_address);
+void gbus_write_uint32(struct gbus *pgbus, RMuint32 byte_address, RMuint32 data);
+void gbus_write_uint16(struct gbus *pgbus, RMuint32 byte_address, RMuint16 data);
+void gbus_write_uint8(struct gbus *pgbus, RMuint32 byte_address, RMuint8 data);
+
+#define gbus_read_reg32(r)      __raw_readl((volatile void __iomem *)KSEG1ADDR(r))
+#define gbus_read_reg16(r)      __raw_readw((volatile void __iomem *)KSEG1ADDR(r))
+#define gbus_read_reg8(r)       __raw_readb((volatile void __iomem *)KSEG1ADDR(r))
+#define gbus_write_reg32(r, v)  __raw_writel(v, (volatile void __iomem *)KSEG1ADDR(r))
+#define gbus_write_reg16(r, v)  __raw_writew(v, (volatile void __iomem *)KSEG1ADDR(r))
+#define gbus_write_reg8(r, v)   __raw_writeb(v, (volatile void __iomem *)KSEG1ADDR(r))
+
+#endif /* !__ASSEMBLY__ */
+#endif /* __TANGO2_GBUS_H */
+
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango2/tango2.h linux-3.9.2/arch/mips/include/asm/tango2/tango2.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango2/tango2.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango2/tango2.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,67 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+/**
+  @file   tango2.h
+  @brief  
+
+  <long description>
+
+  @author Emmanuel Michon
+  @date   2004-05-10
+*/
+
+#ifndef __TANGO2_H__
+#define __TANGO2_H__
+#include <asm/tango2/hardware.h>
+#define EM86XX_CHIP EM86XX_CHIPID_TANGO2
+#include <asm/tango2/rmem86xxid.h>
+#include <asm/tango2/emhwlib_lram.h>
+#include <asm/tango2/emhwlib_resources_tango2.h>
+#ifndef CONFIG_TANGOX_BASE_FREQUENCY
+#define TANGOX_BASE_FREQUENCY	27000000 
+#else
+#define TANGOX_BASE_FREQUENCY CONFIG_TANGOX_BASE_FREQUENCY
+#endif
+/* Baudrate setting */
+#if defined(CONFIG_TANGO2_SMP863X)
+#ifndef CONFIG_TANGOX_BASE_BAUD
+#define TANGOX_BASE_BAUD 38400
+#else
+#define TANGOX_BASE_BAUD CONFIG_TANGOX_BASE_BAUD
+#endif
+//#define TANGOX_CPU_FREQUENCY 333000000
+#else
+#error "Unsupported platform"
+#endif /* CONFIG_TANGO2_SMP863X */
+
+/* Memory size used by Linux */
+#ifndef CONFIG_TANGOX_MEMSIZE
+#if defined(CONFIG_TANGO2_SMP863X)
+#define  TANGOX_SYSTEMRAM_ACTUALSIZE   (32*1024*1024)
+#else
+#error "Unsupported platform"
+#endif /* CONFIG_TANGO2_SMP863X */
+#else
+#define TANGOX_SYSTEMRAM_ACTUALSIZE    CONFIG_TANGOX_MEMSIZE
+#endif /* !CONFIG_TANGOX_MEMSIZE */
+
+#define TANGOX_CTRLIRQ 0
+#define TANGOX_CTRLFIQ 1
+#define TANGOX_CTRLIIQ 2
+
+#if defined(CONFIG_TANGO2_SMP863X)
+#define SYS_clkgen_pll        SYS_clkgen3_pll
+#endif
+
+#define RMCHIP_ID_SMP8634 (8634)
+
+#endif // __TANGO2_H__
+
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango2/tango2_pci.h linux-3.9.2/arch/mips/include/asm/tango2/tango2_pci.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango2/tango2_pci.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango2/tango2_pci.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,74 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#ifndef __TANGO2_PCI_H
+#define __TANGO2_PCI_H
+
+#include <asm/tango2/hardware.h>
+#include <asm/tango2/tango2_gbus.h>
+
+#define PCIEM86XX_PCIFAULT_INTR		((IRQ_CONTROLLER_IRQ_BASE) + \
+						(LOG2_CPU_PCI_FAULT_INT))
+
+#define PCIEM86XX_ARBITER_LEVEL		0x00
+#define PCIEM86XX_ARBITER_GRANTTIMEOUT	0x10101010
+
+#define PCIEM86XX_IDSEL_MAX		0x05
+#define PCIEM86XX_IDSEL_BITS		0x03
+
+/*
+ * helpers to access host interface registers
+ */
+#define RD_HOST_REG32(r)	\
+		gbus_read_reg32(REG_BASE_host_interface + (r))
+
+#define WR_HOST_REG32(r, v)	\
+		gbus_write_reg32(REG_BASE_host_interface + (r), (v))
+
+#define RD_HOST_REG8(r)	\
+		gbus_read_reg8(REG_BASE_host_interface + (r))
+
+#define WR_HOST_REG8(r, v)	\
+		gbus_write_reg8(REG_BASE_host_interface + (r), (v))
+
+
+/*
+ * read/write data  from/to the configuration space.  The  only way to
+ * know if there is a device is by checking that we did not generate a
+ * bus fault interrupt, so we need to mask them during the access.
+ */
+#define BUILD_TANGOX_CFG_ACCESS(pfx, __x)				\
+static inline int tangox_cfg_##pfx(void __iomem *addr, u32 *data)	\
+{									\
+	unsigned long flags, status;					\
+	extern spinlock_t tangox_pci_lock;				\
+									\
+	spin_lock_irqsave(&tangox_pci_lock, flags);			\
+									\
+	__x;								\
+	status = (RD_HOST_REG8(PCI_host_reg2 + 3) >> 1) & 0x3;		\
+	if (status) {							\
+		WR_HOST_REG8(PCI_host_reg2 + 3, 1);			\
+		WR_HOST_REG8(PCI_host_reg2 + 3, 0);			\
+	}								\
+									\
+	spin_unlock_irqrestore(&tangox_pci_lock, flags);		\
+	return status ? 1 : 0;						\
+}
+
+BUILD_TANGOX_CFG_ACCESS(read8, *data = readb(addr) & 0xff)
+BUILD_TANGOX_CFG_ACCESS(read16, *data = readw(addr) & 0xffff)
+BUILD_TANGOX_CFG_ACCESS(read32, *data = readl(addr))
+BUILD_TANGOX_CFG_ACCESS(write8, writeb(*data & 0xff, addr))
+BUILD_TANGOX_CFG_ACCESS(write16, writew(*data & 0xffff, addr))
+BUILD_TANGOX_CFG_ACCESS(write32, writel(*data, addr))
+
+#endif
+
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango2/tango2_usb.h linux-3.9.2/arch/mips/include/asm/tango2/tango2_usb.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango2/tango2_usb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango2/tango2_usb.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,39 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#ifndef __TANGO2_USB_H
+#define __TANGO2_USB_H
+
+#include <asm/tango2/hardware.h>
+#include <asm/tango2/tango2_gbus.h>
+
+#define TANGOX_EHCI_IRQ	(IRQ_CONTROLLER_IRQ_BASE + LOG2_CPU_USB_EHCI_INT)
+#define TANGOX_OHCI_IRQ	(IRQ_CONTROLLER_IRQ_BASE + LOG2_CPU_USB_OHCI_INT)
+
+#define TANGOX_EHCI_BASE_ADDR		(REG_BASE_host_interface + 0x1400)
+#define TANGOX_OHCI_BASE_ADDR		(REG_BASE_host_interface + 0x1500)
+#define TANGOX_USB_CTL_STATUS_REG_BASE	(REG_BASE_host_interface + 0x1700)
+
+/*
+ * helpers to access USB registers
+ */
+#define RD_OHCI_REG32(r)	\
+		gbus_read_reg32(TANGOX_OHCI_BASE_ADDR + (r))
+
+#define WR_OHCI_REG32(r, v)	\
+		gbus_write_reg32(TANGOX_OHCI_BASE_ADDR + (r), (v))
+
+#define RD_USB_REG32(r)	\
+		gbus_read_reg32(TANGOX_USB_CTL_STATUS_REG_BASE + (r))
+
+#define WR_USB_REG32(r, v)	\
+		gbus_write_reg32(TANGOX_USB_CTL_STATUS_REG_BASE + (r), (v))
+
+#endif
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango3/emhwlib_dram.h linux-3.9.2/arch/mips/include/asm/tango3/emhwlib_dram.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango3/emhwlib_dram.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango3/emhwlib_dram.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,67 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/**
+  @file   emhwlib_dram.h
+  @brief  
+
+  fm stands for: first megabyte.
+
+  THE CODE USING THESE SYMBOLS ASSUMES THAT THE END BOUNDARY OF AN
+  ENTITY IS THE START BOUNDARY OF THE NEXT ENTITY
+  
+  htoinc.pl emhwlib_dram.h emhwlib_dram.inc
+  
+  @author Emmanuel Michon
+  @date   2004-07-26
+*/
+
+#ifndef __EMHWLIB_DRAM_H__
+#define __EMHWLIB_DRAM_H__
+
+#if EM86XX_CHIP>=EM86XX_CHIPID_TANGO3
+#include "emhwlib_dram_tango3.h"
+#elif EM86XX_CHIP>=EM86XX_CHIPID_TANGO2
+#include "emhwlib_dram_tango2.h"
+#else
+#include "emhwlib_dram_others.h"
+#endif
+
+#define MEMCFG_SIGNATURE	0x6766636d // `m' `c' `f' `g'
+
+#ifndef __ASSEMBLY__
+
+/* This is the memory map data structure, the size is 64 bytes */
+typedef struct {
+	unsigned int signature;                                                           // ...fc0
+	unsigned int dram0_size;            /* The size of DRAM0 */
+	unsigned int dram1_size;            /* The size of DRAM1 */
+	unsigned int dram2_size;            /* The size of DRAM2 */
+	unsigned int dram0_removable_topreserved;     /* The size of top reserved in DRAM0   ...fd0 */
+	unsigned int dram1_removable_topreserved;     /* The size of top reserved in DRAM1 */
+	unsigned int dram0_top_removable_area;    /* for special use such as splash screen */ 
+	                                          /* users can use set and get properties on the memory reserved by this variable */
+	unsigned int dram0_fixed_topreserved;     /* The size of top reserved in DRAM0 */
+	unsigned int dram1_fixed_topreserved;     /* The size of top reserved in DRAM1       ...fe0 */
+	unsigned int dram2_fixed_topreserved;     /* The size of top reserved in DRAM2 */
+	unsigned int kernel_end;            /* The end offset of kernel */
+	unsigned int checksum;		    /* The checksum */
+#if EM86XX_CHIP>=EM86XX_CHIPID_TANGO2
+	unsigned int dram1_kernel_end;	    /* The end offset of kernel used data in second dram */
+	unsigned int curtainA0;                                                      
+	unsigned int curtainB0;
+	unsigned int curtainC;
+#else
+	unsigned int reserved[4];           /* Reserved for extension */
+#endif
+} memcfg_t;
+
+#endif /* __ASSEMBLY__ */
+
+#endif // __EMHWLIB_DRAM_H__
+ 
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango3/emhwlib_dram_others.h linux-3.9.2/arch/mips/include/asm/tango3/emhwlib_dram_others.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango3/emhwlib_dram_others.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango3/emhwlib_dram_others.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,37 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/**
+  @file   emhwlib_dram_others.h
+  @brief  
+
+  Addresses appear in increasing order. It is assumed
+  that computing FM_IRQHANDLER_STACKTOP_USR-FM_IRQHANDLER_CODE
+  is a proper way to access the max usable size for
+  FM_IRQHANDLER_CODE.
+
+  @author Emmanuel Michon
+  @date   2005-04-11
+*/
+
+#ifndef __EMHWLIB_DRAM_OTHERS_H__
+#define __EMHWLIB_DRAM_OTHERS_H__
+
+#define FM_MEMCFG                  0x00000fc0
+#define FM_IRQHANDLER_API          0x00001000
+#define FM_IRQHANDLER_CODE         0x00011000
+#define FM_IRQHANDLER_STACKTOP_USR 0x00040000 /* defined, but never used */
+#define FM_IRQHANDLER_STACKTOP_IRQ 0x00048000
+#define FM_IRQHANDLER_STACKTOP_FIQ 0x00050000
+#define FM_STACKTOP_SVC            0x00058000
+#define FM_DRM			   0x00058000
+#define FM_GNET			   0x00058000 /* incompatible with DRM */
+#define FM_BOOTLOADER_CODE         0x00060000
+#define FM_RESERVED                0x00080000 /* The size reserved */
+
+#endif // __EMHWLIB_DRAM_OTHERS_H__
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango3/emhwlib_dram_others.inc linux-3.9.2/arch/mips/include/asm/tango3/emhwlib_dram_others.inc
--- linux-3.9.2.ref/arch/mips/include/asm/tango3/emhwlib_dram_others.inc	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango3/emhwlib_dram_others.inc	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,25 @@
+#
+#******************************************************
+#* This file is generated automatically, DO NOT EDIT! *
+#******************************************************
+#*
+#* destined to be included by a shell script or a Makefile (keep syntax adapted to both)
+#*
+#* emhwlib/include/emhwlib_dram_others.inc (generated from emhwlib/include/emhwlib_dram_others.h)
+#*
+#* Copyright (C) Sigma Designs, Inc. 2007.
+#*
+i386=0x1
+linux=0x1
+unix=0x1
+FM_MEMCFG=0xfc0
+FM_IRQHANDLER_API=0x1000
+FM_IRQHANDLER_CODE=0x11000
+FM_IRQHANDLER_STACKTOP_USR=0x40000
+FM_IRQHANDLER_STACKTOP_IRQ=0x48000
+FM_IRQHANDLER_STACKTOP_FIQ=0x50000
+FM_STACKTOP_SVC=0x58000
+FM_DRM=0x58000
+FM_GNET=0x58000
+FM_BOOTLOADER_CODE=0x60000
+FM_RESERVED=0x80000
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango3/emhwlib_dram_tango3.h linux-3.9.2/arch/mips/include/asm/tango3/emhwlib_dram_tango3.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango3/emhwlib_dram_tango3.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango3/emhwlib_dram_tango3.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,48 @@
+/*****************************************
+ Copyright  2004-2005
+ Sigma Designs, Inc. 
+ *****************************************/
+/**
+  @file   emhwlib_dram_tango2.h
+  @brief  
+
+  Addresses appear in increasing order. It is assumed that computing
+  FM_Y-FM_X is a proper way to access the max usable size for FM_X.
+
+  See SMP8630 software spec 3.3
+
+  @author Emmanuel Michon, YH Lin, Julien Soulier
+  @date   2005-04-06
+*/
+
+#ifndef __EMHWLIB_DRAM_TANGO2_H__
+#define __EMHWLIB_DRAM_TANGO2_H__
+
+/* Spec 3.3.5: stage (S4) [fully functional player memory map] */
+#define FM_GNET                    0x00000000
+#define FM_SCRATCH                 0x00000f08 /* 184 bytes */
+#define FM_MEMCFG                  0x00000fc0
+#define FM_IRQHANDLER_API          0x00001000
+#define FM_XTASK_API               0x00009e00 /* 512 bytes */
+#define FM_XOSDBG                  0x0000a000
+#define FM_XTASK1DBG               0x0000c000
+#define FM_XTASK2DBG               0x0000d000
+#define FM_XTASK3DBG               0x0000e000
+#define FM_XTASK4DBG               0x0000f000
+#define FM_SCRATCH2                0x00010000
+#define FM_DRAMCALIBRATION         0x0001f000
+#define FM_RESERVED                0x00020000
+
+/*
+  Spec 3.3.5: stage (S0) [bootstrap memory map]
+
+  Because you will use zboot/yamon to download linux/CE
+  at start of DRAM, the former are away from beginning.
+*/
+#define FM_ZBOOT                   0x01000000
+#define FM_YAMON_text_ram          0x01000000
+#define FM_YAMON__ftext_init       0x01200000
+#define FM_yamon_appl__ftext       0x01210000
+#define FM_linuxmips__ftext        0x00020000
+
+#endif // __EMHWLIB_DRAM_TANGO2_H__
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango3/emhwlib_dram_tango3.inc linux-3.9.2/arch/mips/include/asm/tango3/emhwlib_dram_tango3.inc
--- linux-3.9.2.ref/arch/mips/include/asm/tango3/emhwlib_dram_tango3.inc	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango3/emhwlib_dram_tango3.inc	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,32 @@
+#
+#******************************************************
+#* This file is generated automatically, DO NOT EDIT! *
+#******************************************************
+#*
+#* destined to be included by a shell script or a Makefile (keep syntax adapted to both)
+#*
+#* emhwlib/include/emhwlib_dram_tango2.inc (generated from emhwlib/include/emhwlib_dram_tango2.h)
+#*
+#* Copyright (c) Sigma Designs, Inc. 2003.
+#*
+i386=0x1
+linux=0x1
+unix=0x1
+FM_GNET=0x0
+FM_SCRATCH=0xf08
+FM_MEMCFG=0xfc0
+FM_IRQHANDLER_API=0x1000
+FM_XTASK_API=0x9e00
+FM_XOSDBG=0xa000
+FM_XTASK1DBG=0xc000
+FM_XTASK2DBG=0xd000
+FM_XTASK3DBG=0xe000
+FM_XTASK4DBG=0xf000
+FM_SCRATCH2=0x10000
+FM_DRAMCALIBRATION=0x1f000
+FM_RESERVED=0x20000
+FM_ZBOOT=0x1000000
+FM_YAMON_text_ram=0x1000000
+FM_YAMON__ftext_init=0x1200000
+FM_yamon_appl__ftext=0x1210000
+FM_linuxmips__ftext=0x20000
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango3/emhwlib_lram.h linux-3.9.2/arch/mips/include/asm/tango3/emhwlib_lram.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango3/emhwlib_lram.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango3/emhwlib_lram.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,46 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/**
+  @file   emhwlib_lram.h
+  @brief  
+
+  Map of the localram (8KBytes)
+
+  Traditionnally the start of localram is used to setup
+  a few kilobytes bootstrap routine code+data
+  (cache init, tlb init, load something bigger to DRAM, jump there).
+
+  Fixed offsets are defined in this file as communication devices
+  between hardware blocks.
+  Even debug locations must be present here.
+
+  The bootstrap routine is expected to preserve these and setup
+  its stack under LR_STACKTOP.
+
+  Keep addresses increasing in this file.
+
+  See emhwlib_resources_shared.h how some resources bw. 0 and 0x100 are used already
+  only when uCLinux is up with irq handler running
+
+  @author Emmanuel Michon
+  @date   2005-03-17
+*/
+
+#ifndef __EMHWLIB_LRAM_H__
+#define __EMHWLIB_LRAM_H__
+
+#if (EM86XX_CHIP<EM86XX_CHIPID_TANGO3)
+#include "emhwlib_lram_others.h"
+#elif (EM86XX_CHIP==EM86XX_CHIPID_TANGO3)
+#include "emhwlib_lram_tango3.h"
+#else
+#error EM86XX_CHIP is not set in RMCFLAGS: refer to rmdef/rmem86xxid.h. 
+#endif
+
+#endif // __EMHWLIB_LRAM_H__
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango3/emhwlib_lram.inc linux-3.9.2/arch/mips/include/asm/tango3/emhwlib_lram.inc
--- linux-3.9.2.ref/arch/mips/include/asm/tango3/emhwlib_lram.inc	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango3/emhwlib_lram.inc	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,41 @@
+#
+#******************************************************
+#* This file is generated automatically, DO NOT EDIT! *
+#******************************************************
+#*
+#* destined to be included by a shell script or a Makefile (keep syntax adapted to both)
+#*
+#* emhwlib_hal/include/emhwlib_lram.inc (generated from emhwlib_hal/include/emhwlib_lram.h)
+#*
+#* Copyright (c) Sigma Designs, Inc. 2003.
+#*
+i386=0x1
+linux=0x1
+unix=0x1
+LR_VSYNC_STRUCT=0x200
+LR_VSYNC_CODE=0xa00
+LR_VSYNC_END=0x1200
+LR_STACKTOP=0x1800
+LR_PCI_INTERRUPT_ENABLE=0x19ac
+LR_HOST_INTERRUPT_STATUS=0x19b0
+LR_DRAM_DMA_SUSPEND=0x19b4
+LR_SUSPEND_ACK_MPEG0=0x19b8
+LR_SUSPEND_ACK_MPEG1=0x19bc
+LR_SUSPEND_ACK_AUDIO0=0x19c0
+LR_SUSPEND_ACK_AUDIO1=0x19c4
+LR_SUSPEND_ACK_DEMUX=0x19c8
+LR_SUSPEND_ACK_IH=0x19cc
+LR_HB_IH=0x19d0
+LR_HB_HOST=0x19d4
+LR_HB_CPU=0x19d8
+LR_HB_MPEG0=0x19dc
+LR_HB_MPEG1=0x19e0
+LR_HB_AUDIO0=0x19e4
+LR_HB_AUDIO1=0x19e8
+LR_HB_DEMUX=0x19ec
+LR_HB_XPU=0x19f0
+LR_HB_VSYNC=0x19f4
+LR_SW_VAL_VSYNC_COUNT=0x19f8
+LR_SW_VAL_PIXEL_ADDR=0x19fc
+LR_XENV2_RW=0x1a00
+LR_XENV2_RO=0x1d00
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango3/emhwlib_lram_others.h linux-3.9.2/arch/mips/include/asm/tango3/emhwlib_lram_others.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango3/emhwlib_lram_others.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango3/emhwlib_lram_others.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,106 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/**
+  @file   emhwlib_lram_others.h
+  @brief  
+
+  Map of the localram (8KBytes)
+
+  Traditionnally the start of localram is used to setup
+  a few kilobytes bootstrap routine code+data
+  (cache init, tlb init, load something bigger to DRAM, jump there).
+
+  Fixed offsets are defined in this file as communication devices
+  between hardware blocks.
+  Even debug locations must be present here.
+
+  The bootstrap routine is expected to preserve these and setup
+  its stack under LR_STACKTOP.
+
+  Keep addresses increasing in this file.
+
+  See emhwlib_resources_shared.h how some resources bw. 0 and 0x100 are used already
+  only when uCLinux is up with irq handler running
+
+  @author Sebastien Beysserie
+  @date   2007-06-26
+*/
+
+#ifndef __EMHWLIB_LRAM_OTHERS_H__
+#define __EMHWLIB_LRAM_OTHERS_H__
+
+#define LR_CPU_IDLELOOP          0x00000000 /* CPU uses 0x80 bytes, up to 0x0080 */
+#define LR_UCLINUX_END           0x00000100
+
+#define LR_VSYNC_STRUCT          0x00000200 /* 2KB of data structures */
+#define LR_VSYNC_CODE            0x00000a00 /* 2KB of code */
+#define LR_VSYNC_END             0x00001200
+
+#define LR_STACKTOP              0x000017F4 /* in case a bootstrap routine needs a stack in local ram. Use this boundary */
+
+#define LR_PCI_INTERRUPT_ENABLE  0x000017F4
+#define LR_HOST_INTERRUPT_STATUS 0x000017F8
+#define LR_CPU_BRU_JUMP          0x000017FC /* `bootrom_ucos jump' (debug purpose) */
+
+#define LR_MU_PROFILE_STATUS     0x00001800
+
+#define LR_DRAM_DMA_SUSPEND               0x00001c8c
+#define LR_SUSPEND_ACK_MPEG0              0x00001c90
+#define LR_SUSPEND_ACK_MPEG1              0x00001c94
+#define LR_SUSPEND_ACK_AUDIO0             0x00001c98
+#define LR_SUSPEND_ACK_AUDIO1             0x00001c9c
+#define LR_SUSPEND_ACK_DEMUX0             0x00001ca0
+#define LR_SUSPEND_ACK_IH                 0x00001ca4
+
+#define LR_HB_IH                 0x00001ca8
+
+#define LR_IH_LOG_FIFO           0x00001cac /* in some cases (splash screen) find the location of the log_fifo is not that easy. Read it here. */
+
+#define LR_HB_HOST               0x00001cb0
+#define LR_HB_CPU                0x00001cb4
+#define LR_HB_MPEG0              0x00001cb8
+#define LR_HB_MPEG1              0x00001cbc
+#define LR_HB_AUDIO0             0x00001cc0
+#define LR_HB_AUDIO1             0x00001cc4
+#define LR_HB_DEMUX0             0x00001cc8
+#define LR_HB_XPU                0x00001ccc
+
+#define LR_IDMA                  0x00001cd0 /* 16bytes. Obsoletizes LR_HMMAD */
+
+#define LR_ETH_MAC_LO            0x00001ce0 /* Ethernet MAC addr low 4 bytes */
+#define LR_ETH_MAC_HI            0x00001ce4 /* Ethernet MAC addr high bytes */
+#define LR_HB_VSYNC              0x00001ce8
+ 
+#define LR_SW_VAL_VSYNC_COUNT    0x00001cec /* this location is used to count captured VSYNC */
+#define LR_SW_VAL_PIXEL_ADDR     0x00001cf0 /* this location is used to store a pixel address to write the frame count */
+
+#define LR_HMMAD                 0x00001cf4
+#define LR_KEY_ZONE              0x00001D00 /* 0x200 bytes, up to 0x1F00 */
+#define LR_YAMON_DIGITS          0x00001F00
+#define LR_XPU_DUMP              0x00001F00 /* 0x80 bytes, up to 0x1F80 */
+
+#define LR_VSYNC_PERIOD          0x00001FA0 /* 0x20 bytes, up to 0x1FC0 */
+
+#define LR_RANDOM_SEED           0x00001FC8 /* 0x08 bytes, up to 0x1FD0 */
+#define LR_LOCAL_DEBUG_PROBE     0x00001FD0 /* 0x20 bytes, up to 0x1FF0 */
+
+#define LR_XENV_LOCATION         0x00001FF0 /* Location of XENV, found by XOS */
+#define LR_GNET_MAC              0x00001FF4
+#define LR_ZBOOT_STAGE           0x00001FF8
+#define LR_XPU_STAGE             0x00001FFC
+
+/* for backward compatibility */
+#define LR_HB_DEMUX              LR_HB_DEMUX0
+#define LR_SUSPEND_ACK_DEMUX     LR_SUSPEND_ACK_DEMUX0
+
+#if (EM86XX_CHIP == EM86XX_CHIPID_TANGO2)
+#define LR_CHANNEL_INDEX         LR_GNET_MAC
+#endif
+
+#endif // __EMHWLIB_LRAM_OTHERS_H__
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango3/emhwlib_lram_others.inc linux-3.9.2/arch/mips/include/asm/tango3/emhwlib_lram_others.inc
--- linux-3.9.2.ref/arch/mips/include/asm/tango3/emhwlib_lram_others.inc	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango3/emhwlib_lram_others.inc	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,58 @@
+#
+#******************************************************
+#* This file is generated automatically, DO NOT EDIT! *
+#******************************************************
+#*
+#* destined to be included by a shell script or a Makefile (keep syntax adapted to both)
+#*
+#* emhwlib_hal/include/emhwlib_lram_others.inc (generated from emhwlib_hal/include/emhwlib_lram_others.h)
+#*
+#* Copyright (c) Sigma Designs, Inc. 2003.
+#*
+i386=0x1
+linux=0x1
+unix=0x1
+LR_CPU_IDLELOOP=0x0
+LR_UCLINUX_END=0x100
+LR_VSYNC_STRUCT=0x200
+LR_VSYNC_CODE=0xa00
+LR_VSYNC_END=0x1200
+LR_STACKTOP=0x17f4
+LR_PCI_INTERRUPT_ENABLE=0x17f4
+LR_HOST_INTERRUPT_STATUS=0x17f8
+LR_CPU_BRU_JUMP=0x17fc
+LR_MU_PROFILE_STATUS=0x1800
+LR_DRAM_DMA_SUSPEND=0x1c8c
+LR_SUSPEND_ACK_MPEG0=0x1c90
+LR_SUSPEND_ACK_MPEG1=0x1c94
+LR_SUSPEND_ACK_AUDIO0=0x1c98
+LR_SUSPEND_ACK_AUDIO1=0x1c9c
+LR_SUSPEND_ACK_DEMUX=0x1ca0
+LR_SUSPEND_ACK_IH=0x1ca4
+LR_HB_IH=0x1ca8
+LR_IH_LOG_FIFO=0x1cac
+LR_HB_HOST=0x1cb0
+LR_HB_CPU=0x1cb4
+LR_HB_MPEG0=0x1cb8
+LR_HB_MPEG1=0x1cbc
+LR_HB_AUDIO0=0x1cc0
+LR_HB_AUDIO1=0x1cc4
+LR_HB_DEMUX=0x1cc8
+LR_HB_XPU=0x1ccc
+LR_IDMA=0x1cd0
+LR_ETH_MAC_LO=0x1ce0
+LR_ETH_MAC_HI=0x1ce4
+LR_HB_VSYNC=0x1ce8
+LR_SW_VAL_VSYNC_COUNT=0x1cec
+LR_SW_VAL_PIXEL_ADDR=0x1cf0
+LR_HMMAD=0x1cf4
+LR_KEY_ZONE=0x1d00
+LR_YAMON_DIGITS=0x1f00
+LR_XPU_DUMP=0x1f00
+LR_VSYNC_PERIOD=0x1fa0
+LR_RANDOM_SEED=0x1fc8
+LR_LOCAL_DEBUG_PROBE=0x1fd0
+LR_XENV_LOCATION=0x1ff0
+LR_GNET_MAC=0x1ff4
+LR_ZBOOT_STAGE=0x1ff8
+LR_XPU_STAGE=0x1ffc
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango3/emhwlib_lram_tango3.h linux-3.9.2/arch/mips/include/asm/tango3/emhwlib_lram_tango3.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango3/emhwlib_lram_tango3.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango3/emhwlib_lram_tango3.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,126 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/**
+  @file   emhwlib_lram_tango3.h
+  @brief  
+
+  Map of the localram (8KBytes)
+
+  Traditionnally the start of localram is used to setup
+  a few kilobytes bootstrap routine code+data
+  (cache init, tlb init, load something bigger to DRAM, jump there).
+
+  Fixed offsets are defined in this file as communication devices
+  between hardware blocks.
+  Even debug locations must be present here.
+
+  The bootstrap routine is expected to preserve these and setup
+  its stack under LR_STACKTOP.
+
+  Keep addresses increasing in this file.
+
+  See emhwlib_resources_shared.h how some resources bw. 0 and 0x100 are used already
+  only when uCLinux is up with irq handler running
+
+  @author Sebastien Beysserie
+  @date   2007-06-26
+*/
+
+#ifndef __EMHWLIB_LRAM_TANGO3_H__
+#define __EMHWLIB_LRAM_TANGO3_H__
+
+/*
+  Leaving 2.3KB to for some startup code and stack
+  
+  as long as the value of this symbol moves only up with time, backward compatibility is ok */
+#define LR_STACKTOP              0x00000900
+
+#define LR_XOS2K_C2X             0x00000900
+#define LR_XOS2K_X2C             0x00000a00
+#define LR_XOS2K_I2X             0x00000b00
+#define LR_XOS2K_X2I             0x00000c00
+#define LR_XOS2K_END             0x00000d00
+
+#define LR_VSYNC_STRUCT          0x00000d00
+
+/*
+  shortcoming to be address with first hw releases
+
+  and garbles lram round 0x1680-0x1800
+ */
+#define LR_SHUTTLE_STACKTOP      0x00001800
+
+#define LR_VSYNC_STRUCT_END      0x00001900
+
+/*
+  range from LR_STACKTOP to the first of the below block is 
+  reserved for future use (~100 slots)
+ */
+#define LR_CPU_BOOTSEL           0x00001950 /* relying on the fact the soft reset & cpu bist does not clear lram */
+#define LR_CPU_PERF0_CTRL        0x00001954
+#define LR_CPU_PERF0_CNT         0x00001958
+#define LR_CPU_PERF1_CTRL        0x0000195c
+#define LR_CPU_PERF1_CNT         0x00001960
+#define LR_HB_AUDIO2             0x00001964 /* to check if AUDIO2 will coexist with DEMUX1 */
+#define LR_SUSPEND_ACK_AUDIO2    0x00001968
+#define LR_HB_DEMUX1             0x0000196c
+#define LR_SUSPEND_ACK_DEMUX1    0x00001970
+#define LR_VSYNC_PERIOD          0x00001974 /* 0x20 bytes */
+
+#define LR_ZBOOTXENV_LOCATION    0x00001994
+#define LR_BAT_D0                0x00001998
+#define LR_BAT_D1                0x0000199c
+
+/* rather use the http://bugs.soft.sdesigns.com/twiki/bin/view/Main/SevenSegmentDisplay if you can */
+#define LR_ZBOOT_STAGE           0x000019a0 
+
+#define LR_CHANNEL_INDEX         0x000019a4
+#define LR_HB_IPU                0x000019a8
+#define LR_PCI_INTERRUPT_ENABLE  0x000019ac
+#define LR_HOST_INTERRUPT_STATUS 0x000019b0
+#define LR_DRAM_DMA_SUSPEND      0x000019b4
+#define LR_SUSPEND_ACK_MPEG0     0x000019b8
+#define LR_SUSPEND_ACK_MPEG1     0x000019bc
+#define LR_SUSPEND_ACK_AUDIO0    0x000019c0
+#define LR_SUSPEND_ACK_AUDIO1    0x000019c4
+#define LR_SUSPEND_ACK_DEMUX0    0x000019c8
+#define LR_SUSPEND_ACK_IH        0x000019cc
+#define LR_HB_IH                 0x000019d0
+#define LR_HB_HOST               0x000019d4
+#define LR_HB_CPU                0x000019d8
+#define LR_HB_MPEG0              0x000019dc
+#define LR_HB_MPEG1              0x000019e0
+#define LR_HB_AUDIO0             0x000019e4
+#define LR_HB_AUDIO1             0x000019e8
+#define LR_HB_DEMUX0             0x000019ec
+/* empty slot here keep it so til mid2008 */
+#define LR_HB_VSYNC              0x000019f4
+#define LR_SW_VAL_VSYNC_COUNT    0x000019f8 /* this location is used to count captured VSYNC */
+#define LR_SW_VAL_PIXEL_ADDR     0x000019fc /* this location is used to store a pixel address to write the frame count */
+
+#define LR_XENV2_RW              0x00001a00 /* up to 628 bytes */
+
+#define LR_XOS_DUMP              0x00001c74 /* xtask dump --- might change */
+#define LR_XENV2_RO              0x00001d00 /* up to the end, 512 bytes. This area is written by xpu, r.o. for others */
+
+#define LR_XOS_SECOND_COUNT      0x00001f74 /* second counter */
+#define LR_XOS_SECOND_COUNT_ATX  0x00001f78 /* value of xtal cnt at last update of second counter */
+#define LR_XOS_F_SYS_HZ          0x00001f7c /* system frequency in Hz */
+#define LR_XOS_C2X_RO            0x00001f80 /* xos trusted copies of channel structures */
+#define LR_XOS_X2C_RO            0x00001fa0
+#define LR_XOS_I2X_RO            0x00001fc0
+#define LR_XOS_X2I_RO            0x00001fe0
+
+/* for backward compatibility */
+#define LR_HB_DEMUX              LR_HB_DEMUX0
+#define LR_SUSPEND_ACK_DEMUX     LR_SUSPEND_ACK_DEMUX0
+
+#define LR_HB_XPU LR_XOS_SECOND_COUNT
+
+#endif // __EMHWLIB_LRAM_TANGO3_H__
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango3/emhwlib_lram_tango3.inc linux-3.9.2/arch/mips/include/asm/tango3/emhwlib_lram_tango3.inc
--- linux-3.9.2.ref/arch/mips/include/asm/tango3/emhwlib_lram_tango3.inc	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango3/emhwlib_lram_tango3.inc	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,57 @@
+#
+#******************************************************
+#* This file is generated automatically, DO NOT EDIT! *
+#******************************************************
+#*
+#* destined to be included by a shell script or a Makefile (keep syntax adapted to both)
+#*
+#* emhwlib_lram_tango3.inc (generated from emhwlib_lram_tango3.h)
+#*
+#* Copyright (c) Sigma Designs, Inc. 2003.
+#*
+i386=0x1
+linux=0x1
+unix=0x1
+LR_STACKTOP=0x900
+LR_XOS2K_C2X=0x900
+LR_XOS2K_X2C=0xa00
+LR_XOS2K_I2X=0xb00
+LR_XOS2K_X2I=0xc00
+LR_XOS2K_END=0xd00
+LR_VSYNC_STRUCT=0xd00
+LR_SHUTTLE_STACKTOP=0x1800
+LR_VSYNC_STRUCT_END=0x1900
+LR_VSYNC_PERIOD=0x1974
+LR_ZBOOTXENV_LOCATION=0x1994
+LR_BAT_D0=0x1998
+LR_BAT_D1=0x199c
+LR_BAT_D2=0x19a0
+LR_CHANNEL_INDEX=0x19a4
+LR_HB_IPU=0x19a8
+LR_PCI_INTERRUPT_ENABLE=0x19ac
+LR_HOST_INTERRUPT_STATUS=0x19b0
+LR_DRAM_DMA_SUSPEND=0x19b4
+LR_SUSPEND_ACK_MPEG0=0x19b8
+LR_SUSPEND_ACK_MPEG1=0x19bc
+LR_SUSPEND_ACK_AUDIO0=0x19c0
+LR_SUSPEND_ACK_AUDIO1=0x19c4
+LR_SUSPEND_ACK_DEMUX=0x19c8
+LR_SUSPEND_ACK_IH=0x19cc
+LR_HB_IH=0x19d0
+LR_HB_HOST=0x19d4
+LR_HB_CPU=0x19d8
+LR_HB_MPEG0=0x19dc
+LR_HB_MPEG1=0x19e0
+LR_HB_AUDIO0=0x19e4
+LR_HB_AUDIO1=0x19e8
+LR_HB_DEMUX=0x19ec
+LR_HB_XPU=0x19f0
+LR_HB_VSYNC=0x19f4
+LR_SW_VAL_VSYNC_COUNT=0x19f8
+LR_SW_VAL_PIXEL_ADDR=0x19fc
+LR_XENV2_RW=0x1a00
+LR_XENV2_RO=0x1d00
+LR_XOS_C2X_RO=0x1f80
+LR_XOS_X2C_RO=0x1fa0
+LR_XOS_I2X_RO=0x1fc0
+LR_XOS_X2I_RO=0x1fe0
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango3/emhwlib_registers_tango3.h linux-3.9.2/arch/mips/include/asm/tango3/emhwlib_registers_tango3.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango3/emhwlib_registers_tango3.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango3/emhwlib_registers_tango3.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,786 @@
+/******************************************************/
+/* This file is generated automatically, DO NOT EDIT! */
+/******************************************************/
+/*
+ * ../emhwlib_hal/include/tango3/emhwlib_registers_tango3.h
+ *
+ * Copyright (c) 2001-2007 Sigma Designs, Inc. 
+ *
+ *
+ */
+ 
+/**
+  @file ../emhwlib_hal/include/tango3/emhwlib_registers_tango3.h
+  @brief emhwlib generated file
+   
+  @author Jacques Mahe, Christian Wolff, Julien Soulier, Emmanuel Michon
+  @ingroup hwlproperties
+*/
+
+#ifndef __EMHWLIB_REGISTERS_TANGO3_H__
+#define __EMHWLIB_REGISTERS_TANGO3_H__
+
+/* SystemBlock registers */
+#define REG_BASE_system_block 0x00010000 /* width RMuint32 */
+#define SYS_clkgen0_pll 0x0000 /* width RMuint32 */
+#define SYS_clkgen0_div 0x0004 /* width RMuint32 */
+#define SYS_clkgen1_pll 0x0008 /* width RMuint32 */
+#define SYS_clkgen1_div 0x000C /* width RMuint32 */
+#define SYS_clkgen2_pll 0x0010 /* width RMuint32 */
+#define SYS_clkgen2_div 0x0014 /* width RMuint32 */
+#define SYS_clkgen3_pll 0x0018 /* width RMuint32 */
+#define SYS_clkgen3_div 0x001C /* width RMuint32 */
+#define SYS_avclk_mux 0x0038 /* width RMuint32 */
+#define SYS_sysclk_mux 0x003C /* width RMuint32 */
+#define SYS_clk_cnt 0x0040 /* width RMuint32 */
+#define SYS_xtal_in_cnt 0x0048 /* width RMuint32 */
+#define DRAM_vbus_w0_cfg 0x0300 /* width RMuint32 */
+#define DRAM_vbus_w1_cfg 0x0304 /* width RMuint32 */
+#define DRAM_vbus_w2_cfg 0x0308 /* width RMuint32 */
+#define DRAM_vbus_w3_cfg 0x030c /* width RMuint32 */
+#define DRAM_vbus_r0_cfg 0x0340 /* width RMuint32 */
+#define DRAM_vbus_r1_cfg 0x0344 /* width RMuint32 */
+#define DRAM_vbus_r2_cfg 0x0348 /* width RMuint32 */
+#define DRAM_vbus_r3_cfg 0x034c /* width RMuint32 */
+#define DRAM_vbus_r4_cfg 0x0350 /* width RMuint32 */
+#define DRAM_vbus_r5_cfg 0x0354 /* width RMuint32 */
+#define DRAM_vbus_r6_cfg 0x0358 /* width RMuint32 */
+#define DRAM_vbus_r7_cfg 0x035c /* width RMuint32 */
+#define DRAM_vbus_r8_cfg 0x0360 /* width RMuint32 */
+#define DRAM_vbus_r9_cfg 0x0364 /* width RMuint32 */
+#define DRAM_vbus_r10_cfg 0x0368 /* width RMuint32 */
+#define DRAM_vbus_r11_cfg 0x036c /* width RMuint32 */
+#define DRAM_mbus_w0_cfg 0x0200 /* width RMuint32 */
+#define DRAM_mbus_w1_cfg 0x0204 /* width RMuint32 */
+#define DRAM_mbus_w2_cfg 0x0208 /* width RMuint32 */
+#define DRAM_mbus_w3_cfg 0x020c /* width RMuint32 */
+#define DRAM_mbus_w4_cfg 0x0210 /* width RMuint32 */
+#define DRAM_mbus_w5_cfg 0x0214 /* width RMuint32 */
+#define DRAM_mbus_w6_cfg 0x0218 /* width RMuint32 */
+#define DRAM_mbus_w7_cfg 0x021c /* width RMuint32 */
+#define DRAM_mbus_w8_cfg 0x0220 /* width RMuint32 */
+#define DRAM_mbus_w9_cfg 0x0224 /* width RMuint32 */
+#define DRAM_mbus_w10_cfg 0x0228 /* width RMuint32 */
+#define DRAM_mbus_r0_cfg 0x0240 /* width RMuint32 */
+#define DRAM_mbus_r1_cfg 0x0244 /* width RMuint32 */
+#define DRAM_mbus_r2_cfg 0x0248 /* width RMuint32 */
+#define DRAM_mbus_r3_cfg 0x024c /* width RMuint32 */
+#define DRAM_mbus_r4_cfg 0x0250 /* width RMuint32 */
+#define DRAM_mbus_r5_cfg 0x0254 /* width RMuint32 */
+#define DRAM_mbus_r6_cfg 0x0258 /* width RMuint32 */
+#define DRAM_mbus_r7_cfg 0x025c /* width RMuint32 */
+#define DRAM_mbus_r8_cfg 0x0260 /* width RMuint32 */
+#define DRAM_mbus_r9_cfg 0x0264 /* width RMuint32 */
+#define DRAM_mbus_r10_cfg 0x0268 /* width RMuint32 */
+#define SYS_hostclk_mux 0x0030 /* width RMuint32 */
+#define SYS_sysclk_premux 0x0034 /* width RMuint32 */
+#define SYS_rnd_cnt 0x0044 /* width RMuint32 */
+#define SYS_cnt_cfg 0x004c /* width RMuint32 */
+#define SYS_cfg_cnt0 0x0050 /* width RMuint32 */
+#define SYS_cfg_cnt1 0x0054 /* width RMuint32 */
+#define SYS_cfg_cnt2 0x0058 /* width RMuint32 */
+#define SYS_cfg_cnt3 0x005c /* width RMuint32 */
+#define SYS_cfg_cnt4 0x0060 /* width RMuint32 */
+#define SYS_cleandiv0_div 0x0080 /* width RMuint32 */
+#define SYS_cleandiv1_div 0x0088 /* width RMuint32 */
+#define SYS_cleandiv2_div 0x0090 /* width RMuint32 */
+#define SYS_cleandiv3_div 0x0098 /* width RMuint32 */
+#define SYS_cleandiv4_div 0x00a0 /* width RMuint32 */
+#define SYS_cleandiv5_div 0x00a8 /* width RMuint32 */
+#define SYS_cleandiv6_div 0x00b0 /* width RMuint32 */
+#define SYS_cleandiv7_div 0x00b8 /* width RMuint32 */
+#define SYS_cleandiv8_div 0x00c0 /* width RMuint32 */
+#define SYS_cleandiv9_div 0x00c8 /* width RMuint32 */
+#define SYS_cleandiv10_div 0x00d0 /* width RMuint32 */
+#define SYS_watchdog_counter 0xfd00 /* width RMuint32 */
+#define SYS_watchdog_configuration 0xfd04 /* width RMuint32 */
+#define MARB_mid01_cfg 0x0200 /* width RMuint32 */
+#define MARB_mid21_cfg 0x0204 /* width RMuint32 */
+#define MARB_mid02_cfg 0x0208 /* width RMuint32 */
+#define MARB_mid22_cfg 0x020c /* width RMuint32 */
+#define MARB_mid03_cfg 0x0210 /* width RMuint32 */
+#define MARB_mid23_cfg 0x0214 /* width RMuint32 */
+#define MARB_mid04_cfg 0x0218 /* width RMuint32 */
+#define MARB_mid24_cfg 0x021c /* width RMuint32 */
+#define MARB_mid25_cfg 0x0220 /* width RMuint32 */
+#define MARB_mid08_cfg 0x0224 /* width RMuint32 */
+#define MARB_mid28_cfg 0x0228 /* width RMuint32 */
+#define MARB_mid29_cfg 0x022c /* width RMuint32 */
+#define MARB_mid0C_cfg 0x0230 /* width RMuint32 */
+#define MARB_mid2C_cfg 0x0234 /* width RMuint32 */
+#define MARB_mid0E_cfg 0x0238 /* width RMuint32 */
+#define MARB_mid2E_cfg 0x023c /* width RMuint32 */
+#define MARB_mid10_cfg 0x0240 /* width RMuint32 */
+#define MARB_mid30_cfg 0x0244 /* width RMuint32 */
+#define MARB_mid14_cfg 0x0248 /* width RMuint32 */
+#define MARB_mid34_cfg 0x024c /* width RMuint32 */
+#define MARB_mid05_cfg 0x0250 /* width RMuint32 */
+#define MARB_mid26_cfg 0x0254 /* width RMuint32 */
+#define MARB_mid09_cfg 0x0258 /* width RMuint32 */
+#define MARB_mid2A_cfg 0x025c /* width RMuint32 */
+#define MARB_mid06_cfg 0x0260 /* width RMuint32 */
+#define MARB_mid0A_cfg 0x0264 /* width RMuint32 */
+#define MARB_mid1C_cfg 0x0268 /* width RMuint32 */
+#define MARB_mid3C_cfg 0x026c /* width RMuint32 */
+#define SYS_gpio_dir 0x0500 /* width RMuint32 */
+#define SYS_gpio_data 0x0504 /* width RMuint32 */
+#define SYS_gpio_int 0x0508 /* width RMuint32 */
+#define SYS_gpio15_pwm 0x0510 /* width RMuint32 */
+#define SYS_gpio14_pwm 0x0514 /* width RMuint32 */
+#define REG_BASE_dram_controller_0 0x00030000 /* width RMuint32 */
+#define REG_BASE_dram_controller_1 0x00040000 /* width RMuint32 */
+#define MEM_BASE_dram_controller_0_alias 0x10000000 /* width RMuint32 */
+#define MEM_BASE_dram_controller_0 0x80000000 /* width RMuint32 */
+#define MEM_BASE_dram_controller_1_alias 0x20000000 /* width RMuint32 */
+#define MEM_BASE_dram_controller_1 0xc0000000 /* width RMuint32 */
+#define DRAM_dunit_cfg 0x0000 /* width RMuint32 */
+#define DRAM_dunit_delay0_ctrl 0x0004 /* width RMuint32 */
+#define DRAM_dunit_delay1_ctrl 0x0008 /* width RMuint32 */
+#define DRAM_dunit_auto_delay 0x000c /* width RMuint32 */
+#define DRAM_dunit_fall_delay0 0x0010 /* width RMuint32 */
+#define DRAM_dunit_fall_delay1 0x0014 /* width RMuint32 */
+#define DRAM_dunit_bw_lobound 0x0018 /* width RMuint32 */
+#define DRAM_dunit_bw_hibound 0x001c /* width RMuint32 */
+#define DRAM_dunit_bw_probe_cfg 0x0020 /* width RMuint32 */
+#define DRAM_dunit_bw_probe_cnt 0x0024 /* width RMuint32 */
+#define DRAM_dunit_bw_cntall 0x0028 /* width RMuint32 */
+#define DRAM_dunit_calibration_delay 0x0030 /* width RMuint32 */
+#define DRAM_dunit_calibration_rise_err 0x0034 /* width RMuint32 */
+#define DRAM_dunit_calibration_fall_err 0x0038 /* width RMuint32 */
+#define DRAM_dunit_calibration_page 0x0088 /* width RMuint32 */
+#define DRAM_dunit_flush_buffer 0x0104 /* width RMuint32 */
+#define REG_BASE_host_interface 0x00020000 /* width RMuint32 */
+#define MEM_BASE_host_interface 0x40000000 /* width RMuint32 */
+#define IDE_data 0x0000 /* width RMuint32 */
+#define IDE_error 0x0004 /* width RMuint32 */
+#define IDE_count 0x0008 /* width RMuint32 */
+#define IDE_start_sector 0x000c /* width RMuint32 */
+#define IDE_cylinder_lo 0x0010 /* width RMuint32 */
+#define IDE_cylinder_hi 0x0014 /* width RMuint32 */
+#define IDE_head_device 0x0018 /* width RMuint32 */
+#define IDE_cmd_stat 0x001c /* width RMuint32 */
+#define IDE_irq_stat 0x0218 /* width RMuint32 */
+#define IDE_cmd_stat__ 0x021c /* width RMuint32 */
+#define PB_timing0 0x0800 /* width RMuint32 */
+#define PB_timing1 0x0804 /* width RMuint32 */
+#define PB_timing2 0x0808 /* width RMuint32 */
+#define PB_timing3 0x080c /* width RMuint32 */
+#define PB_timing4 0x0810 /* width RMuint32 */
+#define PB_timing5 0x0814 /* width RMuint32 */
+#define PB_default_timing 0x0818 /* width RMuint32 */
+#define PB_use_timing0 0x081c /* width RMuint32 */
+#define PB_use_timing1 0x0820 /* width RMuint32 */
+#define PB_use_timing2 0x0824 /* width RMuint32 */
+#define PB_use_timing3 0x0828 /* width RMuint32 */
+#define PB_use_timing4 0x082c /* width RMuint32 */
+#define PB_use_timing5 0x0830 /* width RMuint32 */
+#define PB_CS_config 0x0834 /* width RMuint32 */
+#define PB_automode_start_address 0x0840 /* width RMuint32 */
+#define PB_automode_control 0x0844 /* width RMuint32 */
+#define EMHWLIB_IS_HOST 0xe000 /* width RMuint32 */
+#define HOST_REG1 0xfed0 /* width RMuint32 */
+#define HOST_REG2 0xfed4 /* width RMuint32 */
+#define READ_ADDRESS 0xfec0 /* width RMuint32 */
+#define READ_COUNTER 0xfec4 /* width RMuint32 */
+#define READ_ENABLE 0xfec8 /* width RMuint32 */
+#define REV_ORDER 0xfecc /* width RMuint32 */
+#define WRITE_ADDRESS 0xfed8 /* width RMuint32 */
+#define WRITE_COUNTER 0xfedc /* width RMuint32 */
+#define WRITE_ENABLE 0xfee0 /* width RMuint32 */
+#define BURST 0xfee4 /* width RMuint32 */
+#define PCI_TIMEOUT 0x8000 /* width RMuint32 */
+#define PCI_TIMEOUT_STATUS 0x8004 /* width RMuint32 */
+#define PCI_TIMER 0x8008 /* width RMuint32 */
+#define PCI_TIMER_TEST 0x800c /* width RMuint32 */
+#define PCI_WAKEUP 0x8010 /* width RMuint32 */
+#define PCI_REGION_0_BASE 0x9000 /* width RMuint32 */
+#define PCI_REGION_1_BASE 0x9004 /* width RMuint32 */
+#define PCI_REGION_2_BASE 0x9008 /* width RMuint32 */
+#define PCI_REGION_3_BASE 0x900c /* width RMuint32 */
+#define PCI_REGION_4_BASE 0x9010 /* width RMuint32 */
+#define PCI_REGION_5_BASE 0x9014 /* width RMuint32 */
+#define PCI_REGION_6_BASE 0x9018 /* width RMuint32 */
+#define PCI_REGION_7_BASE 0x901c /* width RMuint32 */
+#define PCI_irq_status 0x9020 /* width RMuint32 */
+#define PCI_irq_set 0x9024 /* width RMuint32 */
+#define PCI_irq_clear 0x9028 /* width RMuint32 */
+#define SBOX_FIFO_RESET 0x90a0 /* width RMuint32 */
+#define SBOX_FIFO_RESET2 0x90a4 /* width RMuint32 */
+#define SBOX_ROUTE 0x90a8 /* width RMuint32 */
+#define SBOX_ROUTE2 0x90ac /* width RMuint32 */
+#define output_SBOX_MBUS_W0 0x9080 /* width RMuint32 */
+#define output_SBOX_MBUS_W1 0x9084 /* width RMuint32 */
+#define output_SBOX_PCI_MASTER 0x9088 /* width RMuint32 */
+#define output_SBOX_PCI_SLAVE 0x908c /* width RMuint32 */
+#define output_SBOX_SATA 0x9090 /* width RMuint32 */
+#define output_SBOX_IDE_ISA 0x9094 /* width RMuint32 */
+#define output_SBOX_IDE_DVD 0x9098 /* width RMuint32 */
+#define output_SBOX_SATA2 0x909c /* width RMuint32 */
+#define output_SBOX_MBUS_W2 0x90b0 /* width RMuint32 */
+#define input_keep_SBOX 0 /* width RMuint32 */
+#define input_MBUS_R0_SBOX 1 /* width RMuint32 */
+#define input_MBUS_R1_SBOX 2 /* width RMuint32 */
+#define input_PCI_MASTER_SBOX 3 /* width RMuint32 */
+#define input_PCI_SLAVE_SBOX 4 /* width RMuint32 */
+#define input_SATA_SBOX 5 /* width RMuint32 */
+#define input_IDE_ISA_SBOX 6 /* width RMuint32 */
+#define input_IDE_DVD_SBOX 7 /* width RMuint32 */
+#define input_SATA2_SBOX 8 /* width RMuint32 */
+#define input_MBUS_R2_SBOX 9 /* width RMuint32 */
+#define input_unconnected_SBOX 0xf /* width RMuint32 */
+#define host_mutex0 0x9040 /* width RMuint32 */
+#define host_mutex1 0x9044 /* width RMuint32 */
+#define host_mutex2 0x9048 /* width RMuint32 */
+#define host_mutex3 0x904c /* width RMuint32 */
+#define host_mutex4 0x9050 /* width RMuint32 */
+#define host_mutex5 0x9054 /* width RMuint32 */
+#define host_mutex6 0x9058 /* width RMuint32 */
+#define host_mutex7 0x905c /* width RMuint32 */
+#define host_mutex8 0x9060 /* width RMuint32 */
+#define host_mutex9 0x9064 /* width RMuint32 */
+#define host_mutex10 0x9068 /* width RMuint32 */
+#define host_mutex11 0x906c /* width RMuint32 */
+#define host_mutex12 0x9070 /* width RMuint32 */
+#define host_mutex13 0x9074 /* width RMuint32 */
+#define host_mutex14 0x9078 /* width RMuint32 */
+#define host_mutex15 0x907c /* width RMuint32 */
+#define PCI_host_reg5 0xfe94 /* width RMuint32 */
+#define PCI_chip_is_host 0xfe90 /* width RMuint32 */
+#define IDECTRL_idesrc 0x20d0 /* width RMuint32 */
+#define IDECTRL_pri_drv1udmatim1 0x20e0 /* width RMuint32 */
+#define IDECTRL_pri_drv1udmatim2 0x20f0 /* width RMuint32 */
+#define IDECTRL_pri_idectl 0x2100 /* width RMuint32 */
+#define IDECTRL_pri_drv0tim 0x2110 /* width RMuint32 */
+#define IDECTRL_pri_drv1tim 0x2120 /* width RMuint32 */
+#define IDECTRL_idemisc 0x2130 /* width RMuint32 */
+#define IDECTRL_idestatus 0x2140 /* width RMuint32 */
+#define IDECTRL_udmactl 0x2150 /* width RMuint32 */
+#define IDECTRL_pri_drv0udmatim1 0x2160 /* width RMuint32 */
+#define IDECTRL_pri_drv0udmatim2 0x2170 /* width RMuint32 */
+#define IDECTRL_pref_st 0x2310 /* width RMuint32 */
+#define IDECTRL_pri_ctrlblock 0x2398 /* width RMuint32 */
+#define IDECTRL_pri_cmdblock 0x23c0 /* width RMuint32 */
+#define IDECTRL_bmic 0x2400 /* width RMuint32 */
+#define IDECTRL_bmis 0x2410 /* width RMuint32 */
+#define IDECTRL_bmidtp 0x2420 /* width RMuint32 */
+#define IDECTRL_ide_dmaptr 0x2780 /* width RMuint32 */
+#define IDECTRL_ide_dmalen 0x2790 /* width RMuint32 */
+#define IDECTRL_pio_prefetch_data 0x27c0 /* width RMuint32 */
+#define MEM_BASE_pfla 0x40000000 /* width RMuint32 */
+#define PB_CS0_OFFSET 0x00000000 /* width RMuint32 */
+#define PB_CS1_OFFSET 0x04000000 /* width RMuint32 */
+#define PB_CS2_OFFSET 0x08000000 /* width RMuint32 */
+#define PB_CS3_OFFSET 0x0c000000 /* width RMuint32 */
+#define ETH_gpio_dir1 0x7100 /* width RMuint32 */
+#define ETH_gpio_data1 0x7104 /* width RMuint32 */
+#define ETH_gpio_mask1 0x7108 /* width RMuint32 */
+#define ETH_gpio_dir2 0x710c /* width RMuint32 */
+#define ETH_gpio_data2 0x7110 /* width RMuint32 */
+#define PB_automode_control1 0x0848 /* width RMuint32 */
+#define PB_CS_config1 0x0838 /* width RMuint32 */
+#define PB_CS_ctrl 0x083c /* width RMuint32 */
+#define PB_strap_ctrl 0x0880 /* width RMuint32 */
+#define PB_strap0 0x0884 /* width RMuint32 */
+#define PB_strap1 0x0888 /* width RMuint32 */
+#define PB_ECC_code0 0x08c0 /* width RMuint32 */
+#define PB_ECC_code1 0x08c4 /* width RMuint32 */
+#define PB_ECC_code2 0x08c8 /* width RMuint32 */
+#define PB_ECC_code3 0x08cc /* width RMuint32 */
+#define PB_ECC_clear 0x08d0 /* width RMuint32 */
+#define PB_ECC1_code0 0x08d4 /* width RMuint32 */
+#define PB_ECC1_code1 0x08d8 /* width RMuint32 */
+#define PB_ECC1_code2 0x08dc /* width RMuint32 */
+#define PB_ECC1_code3 0x08e0 /* width RMuint32 */
+#define PB_ECC1_clear 0x08e4 /* width RMuint32 */
+#define PB_SPI_ctrl 0x08e8 /* width RMuint32 */
+#define PB1_timing0 0x0900 /* width RMuint32 */
+#define PB1_timing1 0x0904 /* width RMuint32 */
+#define PB1_timing2 0x0908 /* width RMuint32 */
+#define PB1_timing3 0x090c /* width RMuint32 */
+#define PB1_timing4 0x0910 /* width RMuint32 */
+#define PB1_timing5 0x0914 /* width RMuint32 */
+#define PB1_default_timing 0x0918 /* width RMuint32 */
+#define PB1_use_timing0 0x091c /* width RMuint32 */
+#define PB1_use_timing1 0x0920 /* width RMuint32 */
+#define PB1_use_timing2 0x0924 /* width RMuint32 */
+#define PB1_use_timing3 0x0928 /* width RMuint32 */
+#define PB1_use_timing4 0x092c /* width RMuint32 */
+#define PB1_use_timing5 0x0930 /* width RMuint32 */
+#define PB1_CS_config 0x0934 /* width RMuint32 */
+#define PB1_CS_config1 0x0938 /* width RMuint32 */
+#define PB1_CS_ctrl 0x093c /* width RMuint32 */
+#define PB1_automode_start_address 0x0940 /* width RMuint32 */
+#define PB1_automode_control 0x0944 /* width RMuint32 */
+#define PB1_automode_control1 0x0948 /* width RMuint32 */
+#define PB1_strap_ctrl 0x0980 /* width RMuint32 */
+#define PB1_strap0 0x0984 /* width RMuint32 */
+#define PB1_strap1 0x0988 /* width RMuint32 */
+#define PB1_ECC_code0 0x09c0 /* width RMuint32 */
+#define PB1_ECC_code1 0x09c4 /* width RMuint32 */
+#define PB1_ECC_code2 0x09c8 /* width RMuint32 */
+#define PB1_ECC_code3 0x09cc /* width RMuint32 */
+#define PB1_ECC_clear 0x09d0 /* width RMuint32 */
+#define PB1_ECC1_code0 0x09d4 /* width RMuint32 */
+#define PB1_ECC1_code1 0x09d8 /* width RMuint32 */
+#define PB1_ECC1_code2 0x09dc /* width RMuint32 */
+#define PB1_ECC1_code3 0x09e0 /* width RMuint32 */
+#define PB1_ECC1_clear 0x09e4 /* width RMuint32 */
+#define PB1_SPI_ctrl 0x09e8 /* width RMuint32 */
+#define MIF_W2_ADD 0xb100 /* width RMuint32 */
+#define MIF_W2_CNT 0xb104 /* width RMuint32 */
+#define MIF_W2_SKIP 0xb108 /* width RMuint32 */
+#define MIF_W2_CMD 0xb10c /* width RMuint32 */
+#define MIF_R2_ADD 0xb140 /* width RMuint32 */
+#define MIF_R2_CNT 0xb144 /* width RMuint32 */
+#define MIF_R2_SKIP 0xb148 /* width RMuint32 */
+#define MIF_R2_CMD 0xb14c /* width RMuint32 */
+#define PCI_host_reg1 0xfed0 /* width RMuint32 */
+#define PCI_host_reg2 0xfed4 /* width RMuint32 */
+#define PCI_host_reg3 0xfe80 /* width RMuint32 */
+#define PCI_host_reg4 0xfe84 /* width RMuint32 */
+#define PCI_pcictrl_reg1 0xfe88 /* width RMuint32 */
+#define PCI_pcictrl_reg2 0xfe8c /* width RMuint32 */
+#define PCI_pcictrl_reg3 0xfefc /* width RMuint32 */
+#define PCI_REG0 0xfee8 /* width RMuint32 */
+#define PCI_REG1 0xfeec /* width RMuint32 */
+#define PCI_REG2 0xfef0 /* width RMuint32 */
+#define PCI_REG3 0xfef4 /* width RMuint32 */
+#define PCI_CONFIG 0xfef8 /* width RMuint32 */
+#define MIF_W0_ADD 0xb000 /* width RMuint32 */
+#define MIF_W0_CNT 0xb004 /* width RMuint32 */
+#define MIF_W0_SKIP 0xb008 /* width RMuint32 */
+#define MIF_W0_CMD 0xb00c /* width RMuint32 */
+#define MIF_W1_ADD 0xb040 /* width RMuint32 */
+#define MIF_W1_CNT 0xb044 /* width RMuint32 */
+#define MIF_W1_SKIP 0xb048 /* width RMuint32 */
+#define MIF_W1_CMD 0xb04c /* width RMuint32 */
+#define MIF_R0_ADD 0xb080 /* width RMuint32 */
+#define MIF_R0_CNT 0xb084 /* width RMuint32 */
+#define MIF_R0_SKIP 0xb088 /* width RMuint32 */
+#define MIF_R0_CMD 0xb08c /* width RMuint32 */
+#define MIF_R1_ADD 0xb0c0 /* width RMuint32 */
+#define MIF_R1_CNT 0xb0c4 /* width RMuint32 */
+#define MIF_R1_SKIP 0xb0c8 /* width RMuint32 */
+#define MIF_R1_CMD 0xb0cc /* width RMuint32 */
+#define MBUS_IDLE 0 /* width RMuint32 */
+#define MBUS_LINEAR 1 /* width RMuint32 */
+#define MBUS_DOUBLE 2 /* width RMuint32 */
+#define MBUS_RECTANGLE 3 /* width RMuint32 */
+#define MBUS_VOID 4 /* width RMuint32 */
+#define MBUS_LINEAR_VOID 5 /* width RMuint32 */
+#define MBUS_DOUBLE_VOID 6 /* width RMuint32 */
+#define MBUS_RECTANGLE_VOID 7 /* width RMuint32 */
+#define MBUS_TILED 8 /* width RMuint32 */
+/* SystemBlock registers done */
+
+/* CPUBlock registers */
+#define REG_BASE_cpu_block 0x00060000 /* width RMuint32 */
+#define CPU_time0_load 0xc500 /* width RMuint32 */
+#define CPU_time0_value 0xc504 /* width RMuint32 */
+#define CPU_time0_ctrl 0xc508 /* width RMuint32 */
+#define CPU_time0_clr 0xc50c /* width RMuint32 */
+#define CPU_time1_load 0xc600 /* width RMuint32 */
+#define CPU_time1_value 0xc604 /* width RMuint32 */
+#define CPU_time1_ctrl 0xc608 /* width RMuint32 */
+#define CPU_time1_clr 0xc60c /* width RMuint32 */
+#define CPU_rtc_data 0xc800 /* width RMuint32 */
+#define CPU_rtc_match 0xc804 /* width RMuint32 */
+#define CPU_rtc_stat 0xc808 /* width RMuint32 */
+#define CPU_rtc_load 0xc80c /* width RMuint32 */
+#define CPU_rtc_ctrl 0xc810 /* width RMuint32 */
+#define CPU_irq_status 0xe000 /* width RMuint32 */
+#define CPU_irq_rawstat 0xe004 /* width RMuint32 */
+#define CPU_irq_enableset 0xe008 /* width RMuint32 */
+#define CPU_irq_enableclr 0xe00c /* width RMuint32 */
+#define CPU_irq_softset 0xe010 /* width RMuint32 */
+#define CPU_irq_softclr 0xe014 /* width RMuint32 */
+#define CPU_fiq_status 0xe100 /* width RMuint32 */
+#define CPU_fiq_rawstat 0xe104 /* width RMuint32 */
+#define CPU_fiq_enableset 0xe108 /* width RMuint32 */
+#define CPU_fiq_enableclr 0xe10c /* width RMuint32 */
+#define CPU_fiq_softset 0xe110 /* width RMuint32 */
+#define CPU_fiq_softclr 0xe114 /* width RMuint32 */
+#define CPU_edge_status 0xe200 /* width RMuint32 */
+#define CPU_edge_rawstat 0xe204 /* width RMuint32 */
+#define CPU_edge_config_rise 0xe208 /* width RMuint32 */
+#define CPU_edge_config_fall 0xe20c /* width RMuint32 */
+#define CPU_SOFT_INT 0x00000001 /* width RMuint32 */
+#define CPU_UART0_INT 0x00000002 /* width RMuint32 */
+#define CPU_UART1_INT 0x00000004 /* width RMuint32 */
+#define CPU_TIMER0_INT 0x00000020 /* width RMuint32 */
+#define CPU_TIMER1_INT 0x00000040 /* width RMuint32 */
+#define CPU_HOST_MBUS_W0_INT 0x00000200 /* width RMuint32 */
+#define CPU_HOST_MBUS_W1_INT 0x00000400 /* width RMuint32 */
+#define CPU_HOST_MBUS_R0_INT 0x00000800 /* width RMuint32 */
+#define CPU_HOST_MBUS_R1_INT 0x00001000 /* width RMuint32 */
+#define CPU_PCI_INTA 0x00002000 /* width RMuint32 */
+#define CPU_PCI_INTB 0x00004000 /* width RMuint32 */
+#define CPU_PCI_INTC 0x00008000 /* width RMuint32 */
+#define CPU_PCI_INTD 0x00010000 /* width RMuint32 */
+#define CPU_PCI_FAULT_INT 0x00100000 /* width RMuint32 */
+#define CPU_INFRARED_INT 0x00200000 /* width RMuint32 */
+#define CPU_SFLA_INT 0x00000010 /* width RMuint32 */
+#define CPU_DVD_INT 0x00000080 /* width RMuint32 */
+#define CPU_ETH_INT 0x00000100 /* width RMuint32 */
+#define CPU_DMAIDE_INT 0x00020000 /* width RMuint32 */
+#define CPU_IDE_INT 0x00040000 /* width RMuint32 */
+#define CPU_FRONTPANEL_INT 0x00080000 /* width RMuint32 */
+#define CPU_I2C_INT 0x00400000 /* width RMuint32 */
+#define CPU_GFX_ACCEL_INT 0x00800000 /* width RMuint32 */
+#define CPU_VSYNC0_INT 0x01000000 /* width RMuint32 */
+#define CPU_VSYNC1_INT 0x02000000 /* width RMuint32 */
+#define CPU_VSYNC2_INT 0x04000000 /* width RMuint32 */
+#define CPU_VSYNC3_INT 0x08000000 /* width RMuint32 */
+#define CPU_VSYNC4_INT 0x10000000 /* width RMuint32 */
+#define CPU_VSYNC4BKEND_INT 0x20000000 /* width RMuint32 */
+#define CPU_VSYNC5_INT 0x40000000 /* width RMuint32 */
+#define CPU_VSYNC5BKEND_INT 0x80000000 /* width RMuint32 */
+#define CPU_SMARTCARD_HI_INT 0x00000001 /* width RMuint32 */
+#define CPU_HDMI_HI_INT 0x00000002 /* width RMuint32 */
+#define CPU_HDMI_I2C_HI_INT 0x00000004 /* width RMuint32 */
+#define CPU_VBUS_W0_HI_INT 0x00000008 /* width RMuint32 */
+#define CPU_VBUS_W3_HI_INT 0x00000010 /* width RMuint32 */
+#define CPU_ETH_PHY_HI_INT 0x00000020 /* width RMuint32 */
+#define CPU_ETH_MAC_HI_INT 0x00000040 /* width RMuint32 */
+#define CPU_USB_OHCI_MAC_HI_INT 0x00000080 /* width RMuint32 */
+#define CPU_USB_EHCI_MAC_HI_INT 0x00000100 /* width RMuint32 */
+#define LOG2_CPU_SOFT_INT 0 /* width RMuint32 */
+#define LOG2_CPU_UART0_INT 1 /* width RMuint32 */
+#define LOG2_CPU_UART1_INT 2 /* width RMuint32 */
+#define LOG2_CPU_TIMER0_INT 5 /* width RMuint32 */
+#define LOG2_CPU_TIMER1_INT 6 /* width RMuint32 */
+#define LOG2_CPU_DVD_INT 7 /* width RMuint32 */
+#define LOG2_CPU_RTC_INT 8 /* width RMuint32 */
+#define LOG2_CPU_HOST_MBUS_W0_INT 9 /* width RMuint32 */
+#define LOG2_CPU_HOST_MBUS_W1_INT 10 /* width RMuint32 */
+#define LOG2_CPU_HOST_MBUS_R0_INT 11 /* width RMuint32 */
+#define LOG2_CPU_HOST_MBUS_R1_INT 12 /* width RMuint32 */
+#define LOG2_CPU_PCI_INTA 13 /* width RMuint32 */
+#define LOG2_CPU_PCI_INTB 14 /* width RMuint32 */
+#define LOG2_CPU_PCI_INTC 15 /* width RMuint32 */
+#define LOG2_CPU_PCI_INTD 16 /* width RMuint32 */
+#define LOG2_CPU_DMAIDE_INT 17 /* width RMuint32 */
+#define LOG2_CPU_IDE_INT 18 /* width RMuint32 */
+#define LOG2_CPU_FRONTPANEL_INT 19 /* width RMuint32 */
+#define LOG2_CPU_PCI_FAULT_INT 20 /* width RMuint32 */
+#define LOG2_CPU_INFRARED_INT 21 /* width RMuint32 */
+#define LOG2_CPU_I2C_INT 22 /* width RMuint32 */
+#define LOG2_CPU_GFX_ACCEL_INT 23 /* width RMuint32 */
+#define LOG2_CPU_VSYNC0_INT 24 /* width RMuint32 */
+#define LOG2_CPU_VSYNC1_INT 25 /* width RMuint32 */
+#define LOG2_CPU_VSYNC2_INT 26 /* width RMuint32 */
+#define LOG2_CPU_VSYNC3_INT 27 /* width RMuint32 */
+#define LOG2_CPU_VSYNC4_INT 28 /* width RMuint32 */
+#define LOG2_CPU_VSYNC4BKEND_INT 29 /* width RMuint32 */
+#define LOG2_CPU_VSYNC5_INT 30 /* width RMuint32 */
+#define LOG2_CPU_VSYNC5BKEND_INT 31 /* width RMuint32 */
+#define LOG2_CPU_SMARTCARD_INT 32 /* width RMuint32 */
+#define LOG2_CPU_HDMI_INT 33 /* width RMuint32 */
+#define LOG2_CPU_HDMI_I2C_INT 34 /* width RMuint32 */
+#define LOG2_CPU_VBUS_W0_INT 35 /* width RMuint32 */
+#define LOG2_CPU_VBUS_W3_INT 36 /* width RMuint32 */
+#define LOG2_CPU_ETH_PHY_INT 37 /* width RMuint32 */
+#define LOG2_CPU_ETH_MAC_INT 38 /* width RMuint32 */
+#define LOG2_CPU_USB_OHCI_INT 39 /* width RMuint32 */
+#define LOG2_CPU_USB_EHCI_INT 40 /* width RMuint32 */
+#define LOG2_CPU_SATA_INT 41 /* width RMuint32 */
+#define LOG2_CPU_DMASATA_INT 42 /* width RMuint32 */
+#define LOG2_XPU_W0_INT 43 /* width RMuint32 */
+#define LOG2_XPU_R0_INT 44 /* width RMuint32 */
+#define LOG2_XPU_W_SP_INT 45 /* width RMuint32 */
+#define LOG2_XPU_R_SP_INT 46 /* width RMuint32 */
+#define LOG2_CPU_GPIO24_INT 47 /* width RMuint32 */
+#define LOG2_CPU_GPIO25_INT 48 /* width RMuint32 */
+#define LOG2_CPU_GPIO26_INT 49 /* width RMuint32 */
+#define LOG2_CPU_GPIO27_INT 50 /* width RMuint32 */
+#define LOG2_CPU_VBUS_W4_INT 51 /* width RMuint32 */
+#define LOG2_CPU_SMARTCARD1_INT 52 /* width RMuint32 */
+#define LOG2_CPU_HDMI_CEC_INT 53 /* width RMuint32 */
+#define LOG2_CPU_SATA1_INT 54 /* width RMuint32 */
+#define LOG2_CPU_DMASATA1_INT 55 /* width RMuint32 */
+#define LOG2_CPU_ETH_PHY1_INT 56 /* width RMuint32 */
+#define LOG2_CPU_ETH_MAC1_INT 57 /* width RMuint32 */
+#define LOG2_CPU_HOST_MBUS_W2_INT 58 /* width RMuint32 */
+#define LOG2_CPU_HOST_MBUS_R2_INT 59 /* width RMuint32 */
+#define LOG2_CPU_SDIO0_INT 60 /* width RMuint32 */
+#define LOG2_CPU_SDIO1_INT 61 /* width RMuint32 */
+#define LOG2_CPU_SPI_INT 62 /* width RMuint32 */
+#define LOG2_CPU_UART2_INT 63 /* width RMuint32 */
+#define CPU_edge_status_hi 0xe220 /* width RMuint32 */
+#define CPU_edge_rawstat_hi 0xe224 /* width RMuint32 */
+#define CPU_edge_config_rise_hi 0xe228 /* width RMuint32 */
+#define CPU_edge_config_fall_hi 0xe22c /* width RMuint32 */
+#define CPU_irq_status_hi 0xe018 /* width RMuint32 */
+#define CPU_irq_rawstat_hi 0xe01c /* width RMuint32 */
+#define CPU_irq_enableset_hi 0xe020 /* width RMuint32 */
+#define CPU_irq_enableclr_hi 0xe024 /* width RMuint32 */
+#define CPU_fiq_status_hi 0xe118 /* width RMuint32 */
+#define CPU_fiq_rawstat_hi 0xe11c /* width RMuint32 */
+#define CPU_fiq_enableset_hi 0xe120 /* width RMuint32 */
+#define CPU_fiq_enableclr_hi 0xe124 /* width RMuint32 */
+#define CPU_iiq_status 0xe300 /* width RMuint32 */
+#define CPU_iiq_rawstat 0xe304 /* width RMuint32 */
+#define CPU_iiq_enableset 0xe308 /* width RMuint32 */
+#define CPU_iiq_enableclr 0xe30c /* width RMuint32 */
+#define CPU_iiq_softset 0xe310 /* width RMuint32 */
+#define CPU_iiq_softclr 0xe314 /* width RMuint32 */
+#define CPU_iiq_status_hi 0xe318 /* width RMuint32 */
+#define CPU_iiq_rawstat_hi 0xe31c /* width RMuint32 */
+#define CPU_iiq_enableset_hi 0xe320 /* width RMuint32 */
+#define CPU_iiq_enableclr_hi 0xe324 /* width RMuint32 */
+#define CPU_UART_GPIOMODE 0x38 /* width RMuint32 */
+#define CPU_UART_GPIODIR 0x30 /* width RMuint32 */
+#define CPU_UART_GPIODATA 0x34 /* width RMuint32 */
+#define CPU_edge_config_rise_set 0xe210 /* width RMuint32 */
+#define CPU_edge_config_rise_clr 0xe214 /* width RMuint32 */
+#define CPU_edge_config_fall_set 0xe218 /* width RMuint32 */
+#define CPU_edge_config_fall_clr 0xe21c /* width RMuint32 */
+#define CPU_edge_config_rise_set_hi 0xe230 /* width RMuint32 */
+#define CPU_edge_config_rise_clr_hi 0xe234 /* width RMuint32 */
+#define CPU_edge_config_fall_set_hi 0xe238 /* width RMuint32 */
+#define CPU_edge_config_fall_clr_hi 0xe23c /* width RMuint32 */
+#define intentionaldiff_em 0xeee0 /* width RMuint32 */
+#define CPU_pm_select_0 0xc900 /* width RMuint32 */
+#define CPU_pm_counter_0 0xc904 /* width RMuint32 */
+#define CPU_pm_select_1 0xc908 /* width RMuint32 */
+#define CPU_pm_counter_1 0xc90c /* width RMuint32 */
+#define CPU_remap 0xf000 /* width RMuint32 */
+#define CPU_remap1 0xf004 /* width RMuint32 */
+#define CPU_remap2 0xf008 /* width RMuint32 */
+#define CPU_remap3 0xf00c /* width RMuint32 */
+#define CPU_remap4 0xf010 /* width RMuint32 */
+#define CPU_remap5 0xf014 /* width RMuint32 */
+#define CPU_remap6 0xf018 /* width RMuint32 */
+#define CPU_remap7 0xf01c /* width RMuint32 */
+#define CPU_remap_address 0x1fc00000 /* width RMuint32 */
+#define CPU_remap1_address 0 /* width RMuint32 */
+#define CPU_remap2_address 0x04000000 /* width RMuint32 */
+#define CPU_remap3_address 0x08000000 /* width RMuint32 */
+#define CPU_remap4_address 0x0c000000 /* width RMuint32 */
+#define CPU_remap5_address 0x10000000 /* width RMuint32 */
+#define CPU_remap6_address 0x14000000 /* width RMuint32 */
+#define CPU_remap7_address 0x18000000 /* width RMuint32 */
+#define REG_BASE_irq_handler_block 0xf0000 /* width RMuint32 */
+#define G2L_BIST_BUSY 0xffe0 /* width RMuint32 */
+#define G2L_BIST_PASS 0xffe4 /* width RMuint32 */
+#define G2L_BIST_MASK 0xffe8 /* width RMuint32 */
+#define G2L_RESET_CONTROL 0xfffc /* width RMuint32 */
+#define CPU_UART0_base 0xc100 /* width RMuint32 */
+#define CPU_UART1_base 0xc200 /* width RMuint32 */
+#define CPU_UART2_base 0xcd00 /* width RMuint32 */
+#define CPU_UART_RBR 0x00 /* width RMuint32 */
+#define CPU_UART_THR 0x04 /* width RMuint32 */
+#define CPU_UART_IER 0x08 /* width RMuint32 */
+#define CPU_UART_IIR 0x0c /* width RMuint32 */
+#define CPU_UART_FCR 0x10 /* width RMuint32 */
+#define CPU_UART_LCR 0x14 /* width RMuint32 */
+#define CPU_UART_MCR 0x18 /* width RMuint32 */
+#define CPU_UART_LSR 0x1c /* width RMuint32 */
+#define CPU_UART_MSR 0x20 /* width RMuint32 */
+#define CPU_UART_SCR 0x24 /* width RMuint32 */
+#define CPU_UART_CLKDIV 0x28 /* width RMuint32 */
+#define CPU_UART_CLKSEL 0x2c /* width RMuint32 */
+/* CPUBlock registers done */
+
+/* XPUBlock registers */
+#define REG_BASE_xpu_block 0x000e0000 /* width RMuint32 */
+/* XPUBlock registers done */
+
+/* IPUBlock registers */
+#define REG_BASE_ipu_block 0x000f0000 /* width RMuint32 */
+/* IPUBlock registers done */
+
+/* DisplayBlock registers */
+#define REG_BASE_display_block 0x00070000 /* width RMuint32 */
+#define PMEM_BASE_display_block 0x00300000 /* width RMuint32 */
+#define VIF_w0 0x4000 /* width RMuint32 */
+#define VIF_w1 0x4100 /* width RMuint32 */
+#define VIF_w2 0x4200 /* width RMuint32 */
+#define VIF_w3 0x4F00 /* width RMuint32 */
+#define VIF_r0 0x4300 /* width RMuint32 */
+#define VIF_r1 0x4400 /* width RMuint32 */
+#define VIF_r2 0x4500 /* width RMuint32 */
+#define VIF_r3 0x4600 /* width RMuint32 */
+#define VIF_r4 0x4700 /* width RMuint32 */
+#define VIF_r5 0x4800 /* width RMuint32 */
+#define VIF_r6 0x4900 /* width RMuint32 */
+#define VIF_r7 0x4A00 /* width RMuint32 */
+#define VIF_r8 0x4B00 /* width RMuint32 */
+#define VIF_r9 0x4C00 /* width RMuint32 */
+#define VIF_r10 0x4D00 /* width RMuint32 */
+#define VIF_r11 0x4E00 /* width RMuint32 */
+#define VIF_offs 0x0100 /* width RMuint32 */
+#define VIF_add 0x0000 /* width RMuint32 */
+#define VIF_cnt 0x0004 /* width RMuint32 */
+#define VIF_skip 0x0008 /* width RMuint32 */
+#define VIF_cmd 0x000c /* width RMuint32 */
+#define VIF_addB 0x0010 /* width RMuint32 */
+#define VIF_cntB 0x0014 /* width RMuint32 */
+#define VIF_skipB 0x0018 /* width RMuint32 */
+#define VBUS_IDLE 0x0 /* width RMuint32 */
+#define VBUS_LINEAR 0x1 /* width RMuint32 */
+#define VBUS_DOUBLE 0x2 /* width RMuint32 */
+#define VBUS_RECTANGLE 0x3 /* width RMuint32 */
+#define VBUS_DOUBLE_FIELD 0x4 /* width RMuint32 */
+#define VBUS_DOUBLE_RECTANGLE 0x5 /* width RMuint32 */
+#define VBUS_8BYTE_COLUMN 0x6 /* width RMuint32 */
+#define VBUS_VOID 0x8 /* width RMuint32 */
+#define VBUS_LINEAR_VOID 0x9 /* width RMuint32 */
+#define VBUS_DOUBLE_VOID 0xa /* width RMuint32 */
+#define VBUS_RECTANGLE_VOID 0xb /* width RMuint32 */
+#define VBUS_DOUBLE_FIELD_VOID 0xc /* width RMuint32 */
+#define VBUS_DOUBLE_RECTANGLE_VOID 0xd /* width RMuint32 */
+#define VBUS_8BYTE_COLUMN_VOID 0xe /* width RMuint32 */
+/* DisplayBlock registers done */
+
+/* DemuxEngine registers */
+#define REG_BASE_demux_engine 0x000A0000 /* width RMuint32 */
+#define MEM_BASE_demux_engine 0x00140000 /* width RMuint32 */
+#define PMEM_BASE_demux_engine 0x00140000 /* width RMuint32 */
+#define DMEM_BASE_demux_engine 0x00150000 /* width RMuint32 */
+#define REG_BASE_demux_engine_0 0x000A0000 /* width RMuint32 */
+#define MEM_BASE_demux_engine_0 0x00140000 /* width RMuint32 */
+#define PMEM_BASE_demux_engine_0 0x00140000 /* width RMuint32 */
+#define DMEM_BASE_demux_engine_0 0x00150000 /* width RMuint32 */
+#define REG_BASE_demux_engine_1 0x000b0000 /* width RMuint32 */
+#define MEM_BASE_demux_engine_1 0x00160000 /* width RMuint32 */
+#define PMEM_BASE_demux_engine_1 0x00160000 /* width RMuint32 */
+#define DMEM_BASE_demux_engine_1 0x00170000 /* width RMuint32 */
+#define TDMX_gpio_data 0x2e0c /* width RMuint32 */
+#define TDMX_gpio_dir 0x2e0d /* width RMuint32 */
+/* DemuxEngine registers done */
+
+/* MpegEngine registers */
+#define REG_BASE_mpeg_engine_0 0x00080000 /* width RMuint32 */
+#define MEM_BASE_mpeg_engine_0 0x00100000 /* width RMuint32 */
+#define PMEM_BASE_mpeg_engine_0 0x00100000 /* width RMuint32 */
+#define DMEM_BASE_mpeg_engine_0 0x00110000 /* width RMuint32 */
+#define REG_BASE_mpeg_engine_1 0x00090000 /* width RMuint32 */
+#define MEM_BASE_mpeg_engine_1 0x00120000 /* width RMuint32 */
+#define PMEM_BASE_mpeg_engine_1 0x00120000 /* width RMuint32 */
+#define DMEM_BASE_mpeg_engine_1 0x00130000 /* width RMuint32 */
+#define RBUS_offset 0x4000 /* width RMuint32 */
+/* MpegEngine registers done */
+
+/* VideoDecoder registers */
+/* VideoDecoder registers done */
+
+/* AudioEngine registers */
+#define REG_BASE_audio_engine_0 0x000c0000 /* width RMuint32 */
+#define MEM_BASE_audio_engine_0 0x00180000 /* width RMuint32 */
+#define PMEM_BASE_audio_engine_0 0x00180000 /* width RMuint32 */
+#define DMEM_BASE_audio_engine_0 0x00190000 /* width RMuint32 */
+#define REG_BASE_audio_engine_1 0x000d0000 /* width RMuint32 */
+#define MEM_BASE_audio_engine_1 0x001a0000 /* width RMuint32 */
+#define PMEM_BASE_audio_engine_1 0x001a0000 /* width RMuint32 */
+#define DMEM_BASE_audio_engine_1 0x001b0000 /* width RMuint32 */
+#define REG_BASE_audio_engine_2 0x000b0000 /* width RMuint32 */
+#define MEM_BASE_audio_engine_2 0x00160000 /* width RMuint32 */
+#define PMEM_BASE_audio_engine_2 0x00160000 /* width RMuint32 */
+#define DMEM_BASE_audio_engine_2 0x00170000 /* width RMuint32 */
+#define audio_mutex0 0x3e90 /* width RMuint32 */
+#define audio_mutex1 0x3e91 /* width RMuint32 */
+#define audio_mutex2 0x3e92 /* width RMuint32 */
+#define audio_mutex3 0x3e93 /* width RMuint32 */
+#define audio_mutex4 0x3e94 /* width RMuint32 */
+#define audio_mutex5 0x3e95 /* width RMuint32 */
+#define audio_mutex6 0x3e96 /* width RMuint32 */
+#define audio_mutex7 0x3e97 /* width RMuint32 */
+/* AudioEngine registers done */
+
+/* AudioDecoder registers */
+/* AudioDecoder registers done */
+
+/* AudioCapture registers */
+/* AudioCapture registers done */
+
+/* VoipCodec registers */
+/* VoipCodec registers done */
+
+/* CRCDecoder registers */
+/* CRCDecoder registers done */
+
+/* XCRCDecoder registers */
+/* XCRCDecoder registers done */
+
+/* StreamCapture registers */
+/* StreamCapture registers done */
+
+/* RawDataTransfer registers */
+/* RawDataTransfer registers done */
+
+/* I2C registers */
+#define I2C_MASTER_CONFIG 0x80 /* width RMuint32 */
+#define I2C_MASTER_CLK_DIV 0x84 /* width RMuint32 */
+#define I2C_MASTER_DEV_ADDR 0x88 /* width RMuint32 */
+#define I2C_MASTER_ADDR 0x8c /* width RMuint32 */
+#define I2C_MASTER_DATA_OUT 0x90 /* width RMuint32 */
+#define I2C_MASTER_DATA_IN 0x94 /* width RMuint32 */
+#define I2C_MASTER_STATUS 0x98 /* width RMuint32 */
+#define I2C_MASTER_STARTXFER 0x9c /* width RMuint32 */
+#define I2C_MASTER_BYTE_CNT 0xa0 /* width RMuint32 */
+#define I2C_MASTER_INTEN 0xa4 /* width RMuint32 */
+#define I2C_MASTER_INT 0xa8 /* width RMuint32 */
+#define I2C_SLAVE_ADDR_REG 0xC0 /* width RMuint32 */
+#define I2C_SLAVE_DATAOUT 0xC4 /* width RMuint32 */
+#define I2C_SLAVE_DATAIN 0xC8 /* width RMuint32 */
+#define I2C_SLAVE_STATUS 0xCC /* width RMuint32 */
+#define I2C_SLAVE_INTEN 0xD0 /* width RMuint32 */
+#define I2C_SLAVE_INT 0xD4 /* width RMuint32 */
+#define I2C_SLAVE_BUS_HOLD 0xD8 /* width RMuint32 */
+/* I2C registers done */
+
+/* MM registers */
+/* MM registers done */
+
+/* SpuDecoder registers */
+/* SpuDecoder registers done */
+
+/* PictureTransform registers */
+/* PictureTransform registers done */
+
+/* ClosedCaptionDecoder registers */
+/* ClosedCaptionDecoder registers done */
+
+/* RTC registers */
+/* RTC registers done */
+
+/* Cipher registers */
+/* Cipher registers done */
+
+/* STC registers */
+/* STC registers done */
+
+/* PLL registers */
+/* PLL registers done */
+
+/* DemuxCipher registers */
+/* DemuxCipher registers done */
+
+/* DemuxTask registers */
+/* DemuxTask registers done */
+
+/* DemuxOutput registers */
+/* DemuxOutput registers done */
+
+/* CCFifo registers */
+/* CCFifo registers done */
+
+/* Sha1Sum registers */
+/* Sha1Sum registers done */
+
+/* XTask registers */
+/* XTask registers done */
+
+/* TTXFifo registers */
+/* TTXFifo registers done */
+
+/* VCXO registers */
+/* VCXO registers done */
+
+/* PPF registers */
+/* PPF registers done */
+
+#endif /* __EMHWLIB_REGISTERS_TANGO3_H__ */
+
+/* End of generated file ../emhwlib_hal/include/tango3/emhwlib_registers_tango3.h */
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango3/emhwlib_registers_tango3.inc linux-3.9.2/arch/mips/include/asm/tango3/emhwlib_registers_tango3.inc
--- linux-3.9.2.ref/arch/mips/include/asm/tango3/emhwlib_registers_tango3.inc	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango3/emhwlib_registers_tango3.inc	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,590 @@
+#
+#******************************************************
+#* This file is generated automatically, DO NOT EDIT! *
+#******************************************************
+#*
+#* destined to be included by a shell script or a Makefile (keep syntax adapted to both)
+#*
+#* emhwlib_hal/include/tango3/emhwlib_registers_tango3.inc (generated from emhwlib_hal/include/tango3/emhwlib_registers_tango3.h)
+#*
+#* Copyright (C) Sigma Designs, Inc. 2007.
+#*
+i386=0x1
+linux=0x1
+unix=0x1
+REG_BASE_system_block=0x10000
+SYS_clkgen0_pll=0x0
+SYS_clkgen0_div=0x4
+SYS_clkgen1_pll=0x8
+SYS_clkgen1_div=0xc
+SYS_clkgen2_pll=0x10
+SYS_clkgen2_div=0x14
+SYS_clkgen3_pll=0x18
+SYS_clkgen3_div=0x1c
+SYS_avclk_mux=0x38
+SYS_sysclk_mux=0x3c
+SYS_clk_cnt=0x40
+SYS_xtal_in_cnt=0x48
+DRAM_vbus_w0_cfg=0x300
+DRAM_vbus_w1_cfg=0x304
+DRAM_vbus_w2_cfg=0x308
+DRAM_vbus_w3_cfg=0x30c
+DRAM_vbus_r0_cfg=0x340
+DRAM_vbus_r1_cfg=0x344
+DRAM_vbus_r2_cfg=0x348
+DRAM_vbus_r3_cfg=0x34c
+DRAM_vbus_r4_cfg=0x350
+DRAM_vbus_r5_cfg=0x354
+DRAM_vbus_r6_cfg=0x358
+DRAM_vbus_r7_cfg=0x35c
+DRAM_vbus_r8_cfg=0x360
+DRAM_vbus_r9_cfg=0x364
+DRAM_vbus_r10_cfg=0x368
+DRAM_vbus_r11_cfg=0x36c
+DRAM_mbus_w0_cfg=0x200
+DRAM_mbus_w1_cfg=0x204
+DRAM_mbus_w2_cfg=0x208
+DRAM_mbus_w3_cfg=0x20c
+DRAM_mbus_w4_cfg=0x210
+DRAM_mbus_w5_cfg=0x214
+DRAM_mbus_w6_cfg=0x218
+DRAM_mbus_w7_cfg=0x21c
+DRAM_mbus_w8_cfg=0x220
+DRAM_mbus_w9_cfg=0x224
+DRAM_mbus_w10_cfg=0x228
+DRAM_mbus_r0_cfg=0x240
+DRAM_mbus_r1_cfg=0x244
+DRAM_mbus_r2_cfg=0x248
+DRAM_mbus_r3_cfg=0x24c
+DRAM_mbus_r4_cfg=0x250
+DRAM_mbus_r5_cfg=0x254
+DRAM_mbus_r6_cfg=0x258
+DRAM_mbus_r7_cfg=0x25c
+DRAM_mbus_r8_cfg=0x260
+DRAM_mbus_r9_cfg=0x264
+DRAM_mbus_r10_cfg=0x268
+SYS_hostclk_mux=0x30
+SYS_sysclk_premux=0x34
+SYS_rnd_cnt=0x44
+SYS_cnt_cfg=0x4c
+SYS_cfg_cnt0=0x50
+SYS_cfg_cnt1=0x54
+SYS_cfg_cnt2=0x58
+SYS_cfg_cnt3=0x5c
+SYS_cfg_cnt4=0x60
+SYS_cleandiv0_div=0x80
+SYS_cleandiv1_div=0x88
+SYS_cleandiv2_div=0x90
+SYS_cleandiv3_div=0x98
+SYS_cleandiv4_div=0xa0
+SYS_cleandiv5_div=0xa8
+SYS_cleandiv6_div=0xb0
+SYS_cleandiv7_div=0xb8
+SYS_cleandiv8_div=0xc0
+SYS_cleandiv9_div=0xc8
+SYS_cleandiv10_div=0xd0
+MARB_mid01_cfg=0x200
+MARB_mid21_cfg=0x204
+MARB_mid02_cfg=0x208
+MARB_mid22_cfg=0x20c
+MARB_mid04_cfg=0x210
+MARB_mid24_cfg=0x214
+MARB_mid25_cfg=0x218
+MARB_mid08_cfg=0x21c
+MARB_mid28_cfg=0x220
+MARB_mid29_cfg=0x224
+MARB_mid0C_cfg=0x228
+MARB_mid2C_cfg=0x22c
+MARB_mid10_cfg=0x230
+MARB_mid30_cfg=0x234
+MARB_mid31_cfg=0x238
+MARB_mid12_cfg=0x23c
+MARB_mid32_cfg=0x240
+SYS_gpio_dir=0x500
+SYS_gpio_data=0x504
+SYS_gpio_int=0x508
+SYS_gpio15_pwm=0x510
+SYS_gpio14_pwm=0x514
+REG_BASE_dram_controller_0=0x30000
+REG_BASE_dram_controller_1=0x40000
+MEM_BASE_dram_controller_0=0x80000000
+MEM_BASE_dram_controller_1=0xc0000000
+MEM_BASE_dram_controller_0_alias=0x10000000
+MEM_BASE_dram_controller_1_alias=0x20000000 
+DRAM_dunit_cfg=0x0
+DRAM_dunit_delay0_ctrl=0x4
+DRAM_dunit_delay1_ctrl=0x8
+DRAM_dunit_auto_delay=0xc
+DRAM_dunit_fall_delay0=0x10
+DRAM_dunit_fall_delay1=0x14
+DRAM_dunit_bw_lobound=0x18
+DRAM_dunit_bw_hibound=0x1c
+DRAM_dunit_bw_probe_cfg=0x20
+DRAM_dunit_bw_probe_cnt=0x24
+DRAM_dunit_bw_cntall=0x28
+DRAM_dunit_calibration_delay=0x30
+DRAM_dunit_calibration_rise_err=0x34
+DRAM_dunit_calibration_fall_err=0x38
+DRAM_dunit_calibration_page=0x88
+DRAM_dunit_flush_buffer=0x104
+REG_BASE_host_interface=0x20000
+MEM_BASE_host_interface=0x40000000
+IDE_data=0x0
+IDE_error=0x4
+IDE_count=0x8
+IDE_start_sector=0xc
+IDE_cylinder_lo=0x10
+IDE_cylinder_hi=0x14
+IDE_head_device=0x18
+IDE_cmd_stat=0x1c
+IDE_irq_stat=0x218
+IDE_cmd_stat__=0x21c
+PB_timing0=0x800
+PB_timing1=0x804
+PB_timing2=0x808
+PB_timing3=0x80c
+PB_timing4=0x810
+PB_timing5=0x814
+PB_default_timing=0x818
+PB_use_timing0=0x81c
+PB_use_timing1=0x820
+PB_use_timing2=0x824
+PB_use_timing3=0x828
+PB_use_timing4=0x82c
+PB_use_timing5=0x830
+PB_CS_config=0x834
+PB_automode_start_address=0x840
+PB_automode_control=0x844
+EMHWLIB_IS_HOST=0xe000
+HOST_REG1=0xfed0
+HOST_REG2=0xfed4
+READ_ADDRESS=0xfec0
+READ_COUNTER=0xfec4
+READ_ENABLE=0xfec8
+REV_ORDER=0xfecc
+WRITE_ADDRESS=0xfed8
+WRITE_COUNTER=0xfedc
+WRITE_ENABLE=0xfee0
+BURST=0xfee4
+PCI_TIMEOUT=0x8000
+PCI_TIMEOUT_STATUS=0x8004
+PCI_TIMER=0x8008
+PCI_TIMER_TEST=0x800c
+PCI_WAKEUP=0x8010
+PCI_REGION_0_BASE=0x9000
+PCI_REGION_1_BASE=0x9004
+PCI_REGION_2_BASE=0x9008
+PCI_REGION_3_BASE=0x900c
+PCI_REGION_4_BASE=0x9010
+PCI_REGION_5_BASE=0x9014
+PCI_REGION_6_BASE=0x9018
+PCI_REGION_7_BASE=0x901c
+PCI_irq_status=0x9020
+PCI_irq_set=0x9024
+PCI_irq_clear=0x9028
+SBOX_FIFO_RESET=0x90a0
+SBOX_ROUTE=0x90a8
+output_SBOX_MBUS_W0=0x9080
+output_SBOX_MBUS_W1=0x9084
+output_SBOX_PCI_MASTER=0x9088
+output_SBOX_PCI_SLAVE=0x908c
+output_SBOX_CIPHER=0x9090
+output_SBOX_IDE_ISA=0x9094
+output_SBOX_IDE_DVD=0x9098
+input_keep_SBOX=0x0
+input_MBUS_R0_SBOX=0x1
+input_MBUS_R1_SBOX=0x2
+input_PCI_MASTER_SBOX=0x3
+input_PCI_SLAVE_SBOX=0x4
+input_CIPHER_SBOX=0x5
+input_IDE_DVD_SBOX=0x6
+input_IDE_ISA_SBOX=0x7
+input_SFLA_SBOX=0x8
+input_unconnected_SBOX=0xf
+host_mutex0=0x9040
+host_mutex1=0x9044
+host_mutex2=0x9048
+host_mutex3=0x904c
+host_mutex4=0x9050
+host_mutex5=0x9054
+host_mutex6=0x9058
+host_mutex7=0x905c
+host_mutex8=0x9060
+host_mutex9=0x9064
+host_mutex10=0x9068
+host_mutex11=0x906c
+host_mutex12=0x9070
+host_mutex13=0x9074
+host_mutex14=0x9078
+host_mutex15=0x907c
+PCI_host_reg5=0xfe94
+PCI_chip_is_host=0xfe90
+IDECTRL_idesrc=0x20d0
+IDECTRL_pri_drv1udmatim1=0x20e0
+IDECTRL_pri_drv1udmatim2=0x20f0
+IDECTRL_pri_idectl=0x2100
+IDECTRL_pri_drv0tim=0x2110
+IDECTRL_pri_drv1tim=0x2120
+IDECTRL_idemisc=0x2130
+IDECTRL_idestatus=0x2140
+IDECTRL_udmactl=0x2150
+IDECTRL_pri_drv0udmatim1=0x2160
+IDECTRL_pri_drv0udmatim2=0x2170
+IDECTRL_pref_st=0x2310
+IDECTRL_pri_ctrlblock=0x2398
+IDECTRL_pri_cmdblock=0x23c0
+IDECTRL_bmic=0x2400
+IDECTRL_bmis=0x2410
+IDECTRL_bmidtp=0x2420
+IDECTRL_ide_dmaptr=0x2780
+IDECTRL_ide_dmalen=0x2790
+IDECTRL_pio_prefetch_data=0x27c0
+MEM_BASE_pfla=0x40000000
+PB_CS0_OFFSET=0x0
+PB_CS1_OFFSET=0x4000000
+PB_CS2_OFFSET=0x8000000
+PB_CS3_OFFSET=0xc000000
+ETH_gpio_dir1=0x7100
+ETH_gpio_data1=0x7104
+ETH_gpio_mask1=0x7108
+ETH_gpio_dir2=0x710c
+ETH_gpio_data2=0x7110
+PCI_host_reg1=0xfed0
+PCI_host_reg2=0xfed4
+PCI_host_reg3=0xfe80
+PCI_host_reg4=0xfe84
+PCI_pcictrl_reg1=0xfe88
+PCI_pcictrl_reg2=0xfe8c
+PCI_pcictrl_reg3=0xfefc
+PCI_REG0=0xfee8
+PCI_REG1=0xfeec
+PCI_REG2=0xfef0
+PCI_REG3=0xfef4
+PCI_CONFIG=0xfef8
+MIF_W0_ADD=0xb000
+MIF_W0_CNT=0xb004
+MIF_W0_SKIP=0xb008
+MIF_W0_CMD=0xb00c
+MIF_W1_ADD=0xb040
+MIF_W1_CNT=0xb044
+MIF_W1_SKIP=0xb048
+MIF_W1_CMD=0xb04c
+MIF_R0_ADD=0xb080
+MIF_R0_CNT=0xb084
+MIF_R0_SKIP=0xb088
+MIF_R0_CMD=0xb08c
+MIF_R1_ADD=0xb0c0
+MIF_R1_CNT=0xb0c4
+MIF_R1_SKIP=0xb0c8
+MIF_R1_CMD=0xb0cc
+MBUS_IDLE=0x0
+MBUS_LINEAR=0x1
+MBUS_DOUBLE=0x2
+MBUS_RECTANGLE=0x3
+MBUS_VOID=0x4
+MBUS_LINEAR_VOID=0x5
+MBUS_DOUBLE_VOID=0x6
+MBUS_RECTANGLE_VOID=0x7
+MBUS_TILED=0x8
+REG_BASE_cpu_block=0x60000
+CPU_time0_load=0xc500
+CPU_time0_value=0xc504
+CPU_time0_ctrl=0xc508
+CPU_time0_clr=0xc50c
+CPU_time1_load=0xc600
+CPU_time1_value=0xc604
+CPU_time1_ctrl=0xc608
+CPU_time1_clr=0xc60c
+CPU_rtc_data=0xc800
+CPU_rtc_match=0xc804
+CPU_rtc_stat=0xc808
+CPU_rtc_load=0xc80c
+CPU_rtc_ctrl=0xc810
+CPU_irq_status=0xe000
+CPU_irq_rawstat=0xe004
+CPU_irq_enableset=0xe008
+CPU_irq_enableclr=0xe00c
+CPU_irq_softset=0xe010
+CPU_irq_softclr=0xe014
+CPU_fiq_status=0xe100
+CPU_fiq_rawstat=0xe104
+CPU_fiq_enableset=0xe108
+CPU_fiq_enableclr=0xe10c
+CPU_fiq_softset=0xe110
+CPU_fiq_softclr=0xe114
+CPU_edge_status=0xe200
+CPU_edge_rawstat=0xe204
+CPU_edge_config_rise=0xe208
+CPU_edge_config_fall=0xe20c
+CPU_SOFT_INT=0x1
+CPU_UART0_INT=0x2
+CPU_UART1_INT=0x4
+CPU_TIMER0_INT=0x20
+CPU_TIMER1_INT=0x40
+CPU_HOST_MBUS_W0_INT=0x200
+CPU_HOST_MBUS_W1_INT=0x400
+CPU_HOST_MBUS_R0_INT=0x800
+CPU_HOST_MBUS_R1_INT=0x1000
+CPU_PCI_INTA=0x2000
+CPU_PCI_INTB=0x4000
+CPU_PCI_INTC=0x8000
+CPU_PCI_INTD=0x10000
+CPU_PCI_FAULT_INT=0x100000
+CPU_INFRARED_INT=0x200000
+CPU_SFLA_INT=0x10
+CPU_DVD_INT=0x80
+CPU_ETH_INT=0x100
+CPU_DMAIDE_INT=0x20000
+CPU_IDE_INT=0x40000
+CPU_FRONTPANEL_INT=0x80000
+CPU_I2C_INT=0x400000
+CPU_GFX_ACCEL_INT=0x800000
+CPU_VSYNC0_INT=0x1000000
+CPU_VSYNC1_INT=0x2000000
+CPU_VSYNC2_INT=0x4000000
+CPU_VSYNC3_INT=0x8000000
+CPU_VSYNC4_INT=0x10000000
+CPU_VSYNC4BKEND_INT=0x20000000
+CPU_VSYNC5_INT=0x40000000
+CPU_VSYNC5BKEND_INT=0x80000000
+CPU_SMARTCARD_HI_INT=0x1
+CPU_HDMI_HI_INT=0x2
+CPU_HDMI_I2C_HI_INT=0x4
+CPU_VBUS_W0_HI_INT=0x8
+CPU_VBUS_W3_HI_INT=0x10
+CPU_ETH_PHY_HI_INT=0x20
+CPU_ETH_MAC_HI_INT=0x40
+CPU_USB_OHCI_MAC_HI_INT=0x80
+CPU_USB_EHCI_MAC_HI_INT=0x100
+LOG2_CPU_SOFT_INT=0x0
+LOG2_CPU_UART0_INT=0x1
+LOG2_CPU_UART1_INT=0x2
+LOG2_CPU_TIMER0_INT=0x5
+LOG2_CPU_TIMER1_INT=0x6
+LOG2_CPU_DVD_INT=0x7
+LOG2_CPU_RTC_INT=0x8
+LOG2_CPU_HOST_MBUS_W0_INT=0x9
+LOG2_CPU_HOST_MBUS_W1_INT=0xa
+LOG2_CPU_HOST_MBUS_R0_INT=0xb
+LOG2_CPU_HOST_MBUS_R1_INT=0xc
+LOG2_CPU_PCI_INTA=0xd
+LOG2_CPU_PCI_INTB=0xe
+LOG2_CPU_PCI_INTC=0xf
+LOG2_CPU_PCI_INTD=0x10
+LOG2_CPU_DMAIDE_INT=0x11
+LOG2_CPU_IDE_INT=0x12
+LOG2_CPU_FRONTPANEL_INT=0x13
+LOG2_CPU_PCI_FAULT_INT=0x14
+LOG2_CPU_INFRARED_INT=0x15
+LOG2_CPU_I2C_INT=0x16
+LOG2_CPU_GFX_ACCEL_INT=0x17
+LOG2_CPU_VSYNC0_INT=0x18
+LOG2_CPU_VSYNC1_INT=0x19
+LOG2_CPU_VSYNC2_INT=0x1a
+LOG2_CPU_VSYNC3_INT=0x1b
+LOG2_CPU_VSYNC4_INT=0x1c
+LOG2_CPU_VSYNC4BKEND_INT=0x1d
+LOG2_CPU_VSYNC5_INT=0x1e
+LOG2_CPU_VSYNC5BKEND_INT=0x1f
+LOG2_CPU_SMARTCARD_INT=0x20
+LOG2_CPU_HDMI_INT=0x21
+LOG2_CPU_HDMI_I2C_INT=0x22
+LOG2_CPU_VBUS_W0_INT=0x23
+LOG2_CPU_VBUS_W3_INT=0x24
+LOG2_CPU_ETH_PHY_INT=0x25
+LOG2_CPU_ETH_MAC_INT=0x26
+LOG2_CPU_USB_OHCI_INT=0x27
+LOG2_CPU_USB_EHCI_INT=0x28
+LOG2_CPU_SATA_INT=0x29
+LOG2_CPU_DMASATA_INT=0x2a
+LOG2_XPU_W0_INT=0x2b
+LOG2_XPU_R0_INT=0x2c
+LOG2_XPU_W_SP_INT=0x2d
+LOG2_XPU_R_SP_INT=0x2e
+LOG2_CPU_GPIO24_INT=0x2f
+LOG2_CPU_GPIO25_INT=0x30
+LOG2_CPU_GPIO26_INT=0x31
+LOG2_CPU_GPIO27_INT=0x32
+LOG2_CPU_VBUS_W4_INT=0x33
+LOG2_CPU_SMARTCARD2_INT=0x34
+LOG2_CPU_HDMI_CEC_INT=0x35
+LOG2_CPU_SATA1_INT=0x36
+LOG2_CPU_DMASATA1_INT=0x37
+LOG2_CPU_ETH_PHY1_INT=0x38
+LOG2_CPU_ETH_MAC1_INT=0x39
+LOG2_CPU_HOST_MBUS_W2_INT=0x3a
+LOG2_CPU_HOST_MBUS_R2_INT=0x3b
+LOG2_CPU_SDIO0_INT=0x3c
+LOG2_CPU_SDIO1_INT=0x3d
+CPU_edge_status_hi=0xe220
+CPU_edge_rawstat_hi=0xe224
+CPU_edge_config_rise_hi=0xe228
+CPU_edge_config_fall_hi=0xe22c
+CPU_irq_status_hi=0xe018
+CPU_irq_rawstat_hi=0xe01c
+CPU_irq_enableset_hi=0xe020
+CPU_irq_enableclr_hi=0xe024
+CPU_fiq_status_hi=0xe118
+CPU_fiq_rawstat_hi=0xe11c
+CPU_fiq_enableset_hi=0xe120
+CPU_fiq_enableclr_hi=0xe124
+CPU_iiq_status=0xe300
+CPU_iiq_rawstat=0xe304
+CPU_iiq_enableset=0xe308
+CPU_iiq_enableclr=0xe30c
+CPU_iiq_softset=0xe310
+CPU_iiq_softclr=0xe314
+CPU_iiq_status_hi=0xe318
+CPU_iiq_rawstat_hi=0xe31c
+CPU_iiq_enableset_hi=0xe320
+CPU_iiq_enableclr_hi=0xe324
+CPU_UART_GPIOMODE=0x38
+CPU_UART_GPIODIR=0x30
+CPU_UART_GPIODATA=0x34
+CPU_edge_config_rise_set=0xe210
+CPU_edge_config_rise_clr=0xe214
+CPU_edge_config_fall_set=0xe218
+CPU_edge_config_fall_clr=0xe21c
+CPU_edge_config_rise_set_hi=0xe230
+CPU_edge_config_rise_clr_hi=0xe234
+CPU_edge_config_fall_set_hi=0xe238
+CPU_edge_config_fall_clr_hi=0xe23c
+intentionaldiff_em=0xeee0
+CPU_pm_select_0=0xc900
+CPU_pm_counter_0=0xc904
+CPU_pm_select_1=0xc908
+CPU_pm_counter_1=0xc90c
+CPU_remap=0xf000
+CPU_remap1=0xf004
+CPU_remap2=0xf008
+CPU_remap3=0xf00c
+CPU_remap4=0xf010
+CPU_remap5=0xf014
+CPU_remap6=0xf018
+CPU_remap7=0xf01c
+CPU_remap_address=0x1fc00000
+CPU_remap1_address=0x0
+CPU_remap2_address=0x4000000
+CPU_remap3_address=0x8000000
+CPU_remap4_address=0xc000000
+CPU_remap5_address=0x10000000
+CPU_remap6_address=0x14000000
+CPU_remap7_address=0x18000000
+REG_BASE_irq_handler_block=0xf0000
+G2L_BIST_BUSY=0xffe0
+G2L_BIST_PASS=0xffe4
+G2L_BIST_MASK=0xffe8
+G2L_RESET_CONTROL=0xfffc
+CPU_UART0_base=0xc100
+CPU_UART1_base=0xc200
+CPU_UART_RBR=0x0
+CPU_UART_THR=0x4
+CPU_UART_IER=0x8
+CPU_UART_IIR=0xc
+CPU_UART_FCR=0x10
+CPU_UART_LCR=0x14
+CPU_UART_MCR=0x18
+CPU_UART_LSR=0x1c
+CPU_UART_MSR=0x20
+CPU_UART_SCR=0x24
+CPU_UART_CLKDIV=0x28
+CPU_UART_CLKSEL=0x2c
+REG_BASE_xpu_block=0xe0000
+REG_BASE_ipu_block=0xf0000
+REG_BASE_display_block=0x70000
+PMEM_BASE_display_block=0x300000
+VIF_w0=0x4000
+VIF_w1=0x4100
+VIF_w2=0x4200
+VIF_w3=0x4f00
+VIF_r0=0x4300
+VIF_r1=0x4400
+VIF_r2=0x4500
+VIF_r3=0x4600
+VIF_r4=0x4700
+VIF_r5=0x4800
+VIF_r6=0x4900
+VIF_r7=0x4a00
+VIF_r8=0x4b00
+VIF_r9=0x4c00
+VIF_r10=0x4d00
+VIF_r11=0x4e00
+VIF_offs=0x100
+VIF_add=0x0
+VIF_cnt=0x4
+VIF_skip=0x8
+VIF_cmd=0xc
+VIF_addB=0x10
+VIF_cntB=0x14
+VIF_skipB=0x18
+VBUS_IDLE=0x0
+VBUS_LINEAR=0x1
+VBUS_DOUBLE=0x2
+VBUS_RECTANGLE=0x3
+VBUS_DOUBLE_FIELD=0x4
+VBUS_DOUBLE_RECTANGLE=0x5
+VBUS_8BYTE_COLUMN=0x6
+VBUS_VOID=0x8
+VBUS_LINEAR_VOID=0x9
+VBUS_DOUBLE_VOID=0xa
+VBUS_RECTANGLE_VOID=0xb
+VBUS_DOUBLE_FIELD_VOID=0xc
+VBUS_DOUBLE_RECTANGLE_VOID=0xd
+VBUS_8BYTE_COLUMN_VOID=0xe
+REG_BASE_demux_engine=0xa0000
+MEM_BASE_demux_engine=0x140000
+PMEM_BASE_demux_engine=0x140000
+DMEM_BASE_demux_engine=0x150000
+REG_BASE_demux_engine_0=0xa0000
+MEM_BASE_demux_engine_0=0x140000
+PMEM_BASE_demux_engine_0=0x140000
+DMEM_BASE_demux_engine_0=0x150000
+REG_BASE_demux_engine_1=0xb0000
+MEM_BASE_demux_engine_1=0x160000
+PMEM_BASE_demux_engine_1=0x160000
+DMEM_BASE_demux_engine_1=0x170000
+TDMX_gpio_data=0x2e0c
+TDMX_gpio_dir=0x2e0d
+REG_BASE_mpeg_engine_0=0x80000
+MEM_BASE_mpeg_engine_0=0x100000
+PMEM_BASE_mpeg_engine_0=0x100000
+DMEM_BASE_mpeg_engine_0=0x110000
+REG_BASE_mpeg_engine_1=0x90000
+MEM_BASE_mpeg_engine_1=0x120000
+PMEM_BASE_mpeg_engine_1=0x120000
+DMEM_BASE_mpeg_engine_1=0x130000
+RBUS_offset=0x4000
+REG_BASE_audio_engine_0=0xc0000
+MEM_BASE_audio_engine_0=0x180000
+PMEM_BASE_audio_engine_0=0x180000
+DMEM_BASE_audio_engine_0=0x190000
+REG_BASE_audio_engine_1=0xd0000
+MEM_BASE_audio_engine_1=0x1a0000
+PMEM_BASE_audio_engine_1=0x1a0000
+DMEM_BASE_audio_engine_1=0x1b0000
+audio_mutex0=0x3e90
+audio_mutex1=0x3e91
+audio_mutex2=0x3e92
+audio_mutex3=0x3e93
+audio_mutex4=0x3e94
+audio_mutex5=0x3e95
+audio_mutex6=0x3e96
+audio_mutex7=0x3e97
+I2C_MASTER_CONFIG=0x80
+I2C_MASTER_CLK_DIV=0x84
+I2C_MASTER_DEV_ADDR=0x88
+I2C_MASTER_ADDR=0x8c
+I2C_MASTER_DATA_OUT=0x90
+I2C_MASTER_DATA_IN=0x94
+I2C_MASTER_STATUS=0x98
+I2C_MASTER_STARTXFER=0x9c
+I2C_MASTER_BYTE_CNT=0xa0
+I2C_MASTER_INTEN=0xa4
+I2C_MASTER_INT=0xa8
+I2C_SLAVE_ADDR_REG=0xc0
+I2C_SLAVE_DATAOUT=0xc4
+I2C_SLAVE_DATAIN=0xc8
+I2C_SLAVE_STATUS=0xcc
+I2C_SLAVE_INTEN=0xd0
+I2C_SLAVE_INT=0xd4
+I2C_SLAVE_BUS_HOLD=0xd8
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango3/emhwlib_resources_shared.h linux-3.9.2/arch/mips/include/asm/tango3/emhwlib_resources_shared.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango3/emhwlib_resources_shared.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango3/emhwlib_resources_shared.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,114 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/**
+  @file   emhwlib_resources_shared.h
+  @brief  
+
+  long description
+
+  @author Emmanuel Michon
+  @date   2005-03-22
+*/
+
+#ifndef __EMHWLIB_RESOURCES_SHARED_H__
+#define __EMHWLIB_RESOURCES_SHARED_H__
+
+#define VIDEO_0_RPC_MUTEX ((struct gbus_mutex *)(DMEM_BASE_mpeg_engine_0  + 4 * mpeg_mutex1))
+#define VIDEO_1_RPC_MUTEX ((struct gbus_mutex *)(DMEM_BASE_mpeg_engine_1  + 4 * mpeg_mutex1))
+#define AUDIO_0_RPC_MUTEX ((struct gbus_mutex *)(DMEM_BASE_audio_engine_0 + 4 * audio_mutex1))
+#define DEMUX_RPC_MUTEX   ((struct gbus_mutex *)(DMEM_BASE_demux_engine   + 4 * demux_mutex3))
+
+// pt110 local ram map
+#define UCLINUX_CURRENT_PROCESS (REG_BASE_cpu_block + 0x0000)
+
+#define RESET_VECTOR   (REG_BASE_cpu_block + 0x0000)
+#define UNDEF_VECTOR   (REG_BASE_cpu_block + 0x0004)
+#define SWI_VECTOR     (REG_BASE_cpu_block + 0x0008)
+#define I_ABORT_VECTOR (REG_BASE_cpu_block + 0x000c)
+#define D_ABORT_VECTOR (REG_BASE_cpu_block + 0x0010)
+#define RSV_VECTOR     (REG_BASE_cpu_block + 0x0014)
+#define IRQ_VECTOR     (REG_BASE_cpu_block + 0x0018)
+#define FIQ_VECTOR     (REG_BASE_cpu_block + 0x001c)
+
+#define RESET_JUMP     (REG_BASE_cpu_block + 0x0020)
+#define UNDEF_JUMP     (REG_BASE_cpu_block + 0x0024)
+#define SWI_JUMP       (REG_BASE_cpu_block + 0x0028)
+#define I_ABORT_JUMP   (REG_BASE_cpu_block + 0x002c)
+#define D_ABORT_JUMP   (REG_BASE_cpu_block + 0x0030)
+#define RSV_JUMP       (REG_BASE_cpu_block + 0x0034)
+#define IRQ_JUMP       (REG_BASE_cpu_block + 0x0038)
+#define FIQ_JUMP       (REG_BASE_cpu_block + 0x003c)
+
+#define INFINITE_LOOP  (REG_BASE_cpu_block + 0x0040)
+
+/* where to store uclinux interrupt handler */
+#define UCLINUX_RESET_VECTOR   (REG_BASE_cpu_block + 0x0044)
+#define UCLINUX_UNDEF_VECTOR   (REG_BASE_cpu_block + 0x0048)
+#define UCLINUX_SWI_VECTOR     (REG_BASE_cpu_block + 0x004c)
+#define UCLINUX_I_ABORT_VECTOR (REG_BASE_cpu_block + 0x0050)
+#define UCLINUX_D_ABORT_VECTOR (REG_BASE_cpu_block + 0x0054)
+#define UCLINUX_RSV_VECTOR     (REG_BASE_cpu_block + 0x0058)
+#define UCLINUX_IRQ_VECTOR     (REG_BASE_cpu_block + 0x005c)
+#define UCLINUX_FIQ_VECTOR     (REG_BASE_cpu_block + 0x0060)
+
+/* where to store fiq/irq enable values */
+#define UCLINUX_IRQ_ENABLE      (REG_BASE_cpu_block + 0x0064)
+#define UCLINUX_FIQ_ENABLE      (REG_BASE_cpu_block + 0x0068)
+
+/* we use this in uClinux to handshake llad with the hardware library. llad will 
+   initialize the value to 0. As long as this value is 0, llad will mask the
+   triggered interrupt. When the CPUBlock is done loading the IRQ handler, it
+   will set this value to all the IRQ that are now being handled by itself. Next
+   time llad receives an IRQ, it will read this value and if set to the proper
+   interrupt value, it will return without masking the interrupt.
+   This value is a mask of all the IRQs handled by the IRQ handler (see em8xxx
+   hardware IRQ register).
+
+   *** IMPORTANT *** This value must be update in llad.c if changed.
+*/
+#define UCLINUX_LLAD_IRQHANDLER_HANDSHAKE    (REG_BASE_cpu_block + 0x006C)
+
+/* these symbols are used to store the entry point of the irqhandler
+   loaded by the bootloader.  when uclinux boots it overwrites the
+   interrupt vector, and when we load emhwlib we must restore the RUA
+   entry point in the vector. Since the current version of the emhwlib
+   loaded may not match the irqhandler loaded by bootloader, the entry
+   points should not be determined at compilation time, but rather at
+   runtime.
+*/
+#define IRQHANDLER_ENTRY   (REG_BASE_cpu_block + 0x0070) 
+#define FIQHANDLER_ENTRY   (REG_BASE_cpu_block + 0x0074) 
+#define UNDEFHANDLER_ENTRY (REG_BASE_cpu_block + 0x0078) 
+#define JUMPTABLE_ADDRESS  (REG_BASE_cpu_block + 0x007c)
+
+/* address of linux General exeption handler */
+#define LINUX_GE (REG_BASE_cpu_block + 0x0080)
+
+// random seeds (refer to gbuslib/include/gbus_random.h)
+#define RANDOM0              (REG_BASE_cpu_block + LR_RANDOM_SEED + 0)
+#define RANDOM1              (REG_BASE_cpu_block + LR_RANDOM_SEED + 4)
+
+#define PCI_INTERRUPT_ENABLE    (REG_BASE_cpu_block + LR_PCI_INTERRUPT_ENABLE)
+#define HOST_INTERRUPT_STATUS   (REG_BASE_cpu_block + LR_HOST_INTERRUPT_STATUS)
+
+// next 8 dword locations are for local debug, they are reset to 0 at vsync_init time.
+// Please do not affect them in cvs source.
+#define DEBUG_PROBE0                  (REG_BASE_cpu_block + LR_LOCAL_DEBUG_PROBE + 0x00)
+#define DEBUG_PROBE1                  (REG_BASE_cpu_block + LR_LOCAL_DEBUG_PROBE + 0x04)
+#define DEBUG_PROBE2                  (REG_BASE_cpu_block + LR_LOCAL_DEBUG_PROBE + 0x08)
+#define DEBUG_PROBE3                  (REG_BASE_cpu_block + LR_LOCAL_DEBUG_PROBE + 0x0c)
+#define DEBUG_PROBE4                  (REG_BASE_cpu_block + LR_LOCAL_DEBUG_PROBE + 0x10)
+#define DEBUG_PROBE5                  (REG_BASE_cpu_block + LR_LOCAL_DEBUG_PROBE + 0x14)
+#define DEBUG_PROBE6                  (REG_BASE_cpu_block + LR_LOCAL_DEBUG_PROBE + 0x18)
+#define DEBUG_PROBE7                  (REG_BASE_cpu_block + LR_LOCAL_DEBUG_PROBE + 0x1c)
+
+// uses 8 entries, up to 0x1EF0
+#define PARAM_VSYNC_PERIOD_DEC0        (REG_BASE_cpu_block + LR_VSYNC_PERIOD)  // video decoder 0
+
+#endif // __EMHWLIB_RESOURCES_SHARED_H__
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango3/emhwlib_resources_shared.inc linux-3.9.2/arch/mips/include/asm/tango3/emhwlib_resources_shared.inc
--- linux-3.9.2.ref/arch/mips/include/asm/tango3/emhwlib_resources_shared.inc	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango3/emhwlib_resources_shared.inc	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,14 @@
+#
+#******************************************************
+#* This file is generated automatically, DO NOT EDIT! *
+#******************************************************
+#*
+#* destined to be included by a shell script or a Makefile (keep syntax adapted to both)
+#*
+#* emhwlib/include/emhwlib_resources_shared.inc (generated from emhwlib/include/emhwlib_resources_shared.h)
+#*
+#* Copyright (C) Sigma Designs, Inc. 2007.
+#*
+i386=0x1
+linux=0x1
+unix=0x1
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango3/emhwlib_resources_tango3.h linux-3.9.2/arch/mips/include/asm/tango3/emhwlib_resources_tango3.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango3/emhwlib_resources_tango3.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango3/emhwlib_resources_tango3.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,48 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/**
+  @file   emhwlib_resources_tango2.h
+  @brief  
+
+  long description
+
+  @author Emmanuel Michon
+  @date   2004-01-28y
+*/
+
+#ifndef __EMHWLIB_RESOURCES_TANGO3_H__
+#define __EMHWLIB_RESOURCES_TANGO3_H__
+
+#define VSYNC_PARAM_MUTEX   ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex2))
+#define PCI_IRQ_MUTEX       ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex3))
+#define GFX_MUTEX           ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex4))
+#define HOST_MBUS_MUTEX     ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex5))
+#define SOFT_IRQ_MUTEX_TASK ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex6))
+#define SOFT_IRQ_MUTEX_IRQ  ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex7))
+#define SOFT_IRQ_MUTEX_FIQ  ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex8))
+#define RTC_IRQ_MUTEX       ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex9))
+#define XRPC_MUTEX          ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex10))
+#define XTASK_MUTEX         ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex11))
+#define IDMA_MUTEX          ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex12)) /* keep same as tango15 */
+#define TIMER_IRQ_MUTEX     ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex13)) 
+#define SSD_MUTEX           ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex14)) 
+
+#define AUDIO_0_IRQ_MUTEX   ((struct gbus_mutex *)(DMEM_BASE_audio_engine_0 + 4 * audio_mutex0))
+#define AUDIO_1_IRQ_MUTEX   ((struct gbus_mutex *)(DMEM_BASE_audio_engine_1 + 4 * audio_mutex0))
+#define VIDEO_0_FIFO_MUTEX  ((struct gbus_mutex *)(DMEM_BASE_mpeg_engine_0  + 4 * mpeg_mutex0))
+#define VIDEO_1_FIFO_MUTEX  ((struct gbus_mutex *)(DMEM_BASE_mpeg_engine_1  + 4 * mpeg_mutex0))
+#define DEMUX_IRQ_MUTEX     ((struct gbus_mutex *)(DMEM_BASE_demux_engine   + 4 * demux_mutex0))
+#define DEMUX_EMHWLIB_MUTEX ((struct gbus_mutex *)(DMEM_BASE_demux_engine   + 4 * demux_mutex4))
+#define TIMER_UPDATE_MUTEX  ((struct gbus_mutex *)(DMEM_BASE_demux_engine   + 4 * demux_mutex5))
+
+#define AUDIO_1_RPC_MUTEX ((struct gbus_mutex *)(DMEM_BASE_audio_engine_1 + 4 * audio_mutex1))
+#define AUDIO_1_ENET_MUTEX ((struct gbus_mutex *)(DMEM_BASE_audio_engine_1 + 4 * audio_mutex2))
+#define AUDIO_1_INTSTATUS_MUTEX ((struct gbus_mutex *)(DMEM_BASE_audio_engine_1 + 4 * audio_mutex3))
+
+#endif // __EMHWLIB_RESOURCES_TANGO3_H__
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango3/emhwlib_resources_tango3.inc linux-3.9.2/arch/mips/include/asm/tango3/emhwlib_resources_tango3.inc
--- linux-3.9.2.ref/arch/mips/include/asm/tango3/emhwlib_resources_tango3.inc	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango3/emhwlib_resources_tango3.inc	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,14 @@
+#
+#******************************************************
+#* This file is generated automatically, DO NOT EDIT! *
+#******************************************************
+#*
+#* destined to be included by a shell script or a Makefile (keep syntax adapted to both)
+#*
+#* emhwlib/include/tango3/emhwlib_resources_tango3.inc (generated from emhwlib/include/tango3/emhwlib_resources_tango3.h)
+#*
+#* Copyright (C) Sigma Designs, Inc. 2007.
+#*
+i386=0x1
+linux=0x1
+unix=0x1
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango3/fip.h linux-3.9.2/arch/mips/include/asm/tango3/fip.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango3/fip.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango3/fip.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,121 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+/*
+ * FIP related definitions, and function prototypes.
+ */
+#ifndef _FIP_H_
+#define _FIP_H_
+
+#ifdef __KERNEL__
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <asm/ioctl.h>
+#endif /* __KERNEL__ */
+
+/* Valid symbols */
+#if defined(CONFIG_TANGOX_FIP_REF1)
+#define DVD_FIP_ON			0
+#define PLAY_FIP_ON			1
+#define DTS_FIP_ON			2
+#define MP3_FIP_ON			3
+#define DOLBYDIGITAL_FIP_ON		4
+#define MPEG4_FIP_ON			5
+#define PAUSE_FIP_ON			6
+#define DVI_FIP_ON              	7
+#define TWIRL_1_FIP_ON			8
+#define TWIRL_2_FIP_ON			9
+#define TWIRL_3_FIP_ON			10
+#define TWIRL_4_FIP_ON			11
+#define TWIRL_5_FIP_ON			12
+#define TWIRL_6_FIP_ON			13
+#define ALL_FIP_ON			14
+#define REPEAT_FIP_ON			15
+#define COLON_MIN_SEC_FIP_ON		16
+#define R1080_FIP_ON			17
+#define R720_FIP_ON			18
+#define COLON_HOUR_MIN_FIP_ON		19
+#define R480_FIP_ON			20
+#define PAL_FIP_ON			21
+#define NTSC_FIP_ON			22
+#elif defined(CONFIG_TANGOX_FIP_REF2)
+#define DVD_FIP				201
+#define VCD_FIP				202
+#define MP3_FIP				203
+#define CD_FIP				204
+#define TITLE_FIP			205
+#define TRACK_CHAPTER_FIP		206
+#else
+#error Unsupport front panel.
+#endif
+
+/* Alignment */
+#define FIP_LEFT		0x0000	/* flags for fip_write_text() */
+#define FIP_CENTER		0x0001
+#define FIP_RIGHT		0x0002
+
+/* FIP Keys */
+#if defined(CONFIG_TANGOX_FIP_REF1)
+#define FIP_KEY_EJECT		0x00000004
+#define FIP_KEY_PREV		0x00000800
+#define FIP_KEY_NEXT		0x00008000
+#define FIP_KEY_FBWD		0x00000008
+#define FIP_KEY_FFWD		0x00000080
+#define FIP_KEY_PLAYPAUSE	0x00000040
+#define FIP_KEY_STOP		0x00000400
+#elif defined(CONFIG_TANGOX_FIP_REF2)
+#define FIP_KEY_EJECT		0x00000001
+#define FIP_KEY_PLAYPAUSE	0x00000002
+#define FIP_KEY_STOP		0x00000004
+#define FIP_KEY_PREV		0x00000008
+#define FIP_KEY_NEXT		0x00000010
+#define FIP_KEY_FBWD		0x00000020
+#define FIP_KEY_FFWD		0x00000040
+#define FIP_KEY_MENU		0x00000080
+#else
+#error Unsupport front panel.
+#endif
+
+#if defined(__KERNEL__) || !defined(BOOTLOADER)
+/* ioctl commands for user level applications*/
+#define FIP_IOC_MAGIC		'F'
+#define FIP_IOCSHOWSYMBOL	_IO(FIP_IOC_MAGIC, 0)
+#define FIP_IOCSHOWHMS		_IO(FIP_IOC_MAGIC, 1)
+#define FIP_IOCDISPCHAR		_IO(FIP_IOC_MAGIC, 2)
+#define FIP_IOCDISPRAW		_IO(FIP_IOC_MAGIC, 3)
+#define FIP_IOCDISPTEXT		_IO(FIP_IOC_MAGIC, 4)
+#define FIP_IOCCLEAR		_IO(FIP_IOC_MAGIC, 5)
+#define FIP_IOCGETFPTYPE	_IO(FIP_IOC_MAGIC, 6)
+#endif /* __KERNEL__ || !BOOTLOADER */
+
+#ifdef __KERNEL__
+static void fip_write_text(const int position, const char *text, const int flags);
+static int fip_show_hms(int hour, int minute, int second);
+static void fip_display_symbol(const int symbol, const int on);
+static int fip_display_character(const int position, const char character);
+static void fip_display_raw(const int byte, const int bit, const int on); 
+static int is_fip_busy(void);
+static void fip_wait_ready(void);
+static void fip_clear(void);
+#elif defined(BOOTLOADER)
+void fip_write_text(const int position, const char *text, const int flags);
+int fip_show_hms(int hour, int minute, int second);
+void fip_display_symbol(const int symbol, const int on);
+int fip_display_character(const int position, const char character);
+void fip_display_raw(const int byte, const int bit, const int on); 
+int is_fip_busy(void);
+void fip_wait_ready(void);
+void fip_clear(void);
+int fip_init(void);
+int fip_exit(void);
+unsigned long fip_readkey(void);
+#endif /* __KERNEL__ */
+
+#endif
+
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango3/hardware.h linux-3.9.2/arch/mips/include/asm/tango3/hardware.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango3/hardware.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango3/hardware.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,154 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+#ifndef __HARDWARE_H
+#define __HARDWARE_H
+
+#include <linux/version.h>
+#include <asm/tango3/emhwlib_registers_tango3.h>
+#include <asm/tango3/tango3_gbus.h>
+
+/* UART0 */
+#define CPU_uart0_gpio_dir	    (CPU_UART0_base + CPU_UART_GPIODIR)
+#define CPU_uart0_gpio_data	    (CPU_UART0_base + CPU_UART_GPIODATA)
+#define CPU_uart0_gpio_mode	    (CPU_UART0_base + CPU_UART_GPIOMODE)
+
+/* UART1 */
+#define CPU_uart1_gpio_dir	    (CPU_UART1_base + CPU_UART_GPIODIR)
+#define CPU_uart1_gpio_data	    (CPU_UART1_base + CPU_UART_GPIODATA)
+#define CPU_uart1_gpio_mode	    (CPU_UART1_base + CPU_UART_GPIOMODE)
+
+/* UART2 */
+#define CPU_uart2_gpio_dir	    (CPU_UART2_base + CPU_UART_GPIODIR)
+#define CPU_uart2_gpio_data	    (CPU_UART2_base + CPU_UART_GPIODATA)
+#define CPU_uart2_gpio_mode	    (CPU_UART2_base + CPU_UART_GPIOMODE)
+
+#define MIPS_CPU_IRQ_BASE 0
+
+#if defined(CONFIG_TANGO3_SMP86XX)
+#define IRQ_CONTROLLER_IRQ_BASE 8
+#define FIQ_CONTROLLER_IRQ_BASE 72
+#define IIQ_CONTROLLER_IRQ_BASE 136 // bit31 of iiq is linux irq 199
+#define IRQ_COUNT               64  // 64 interrupt sources
+#else
+#error "Unsupported Tango3 chip."
+#endif
+
+#define IRQ_SOFTINT                     (IRQ_CONTROLLER_IRQ_BASE+0)   // gnet compatibility
+/* IDE interrupts */
+#define IRQ_IDECTRL_IDEDMA	(LOG2_CPU_DMAIDE_INT + IRQ_CONTROLLER_IRQ_BASE)
+#define IRQ_IDECTRL_IDE		(LOG2_CPU_IDE_INT + IRQ_CONTROLLER_IRQ_BASE)
+
+/* MBUS interface */
+#define MIF_add_offset		    0x0
+#define MIF_cnt_offset              (MIF_W0_CNT - MIF_W0_ADD) //0x04
+#define MIF_add2_skip_offset        (MIF_W0_SKIP - MIF_W0_ADD) //0x08
+#define MIF_cmd_offset              (MIF_W0_CMD - MIF_W0_ADD) //0x0c
+
+/* GPIO */
+#define GPIO_DIR_INPUT(gpio)        ((1 << (16 + (gpio))))
+#define GPIO_DIR_OUTPUT(gpio)       ((1 << (16 + (gpio))) | (1 << (gpio)))
+#define GPIO_DATA_SET(gpio)         ((1 << (16 + (gpio))) | (1 << (gpio)))
+#define GPIO_DATA_CLEAR(gpio)       ((1 << (16 + (gpio))))
+
+/* UART GPIO */
+#define UART_GPIO_DIR_INPUT(gpio)        ((1 << (8 + (gpio))))
+#define UART_GPIO_DIR_OUTPUT(gpio)       ((1 << (8 + (gpio))) | (1 << (gpio)))
+#define UART_GPIO_DATA_SET(gpio)         ((1 << (8 + (gpio))) | (1 << (gpio)))
+#define UART_GPIO_DATA_CLEAR(gpio)       ((1 << (8 + (gpio))))
+
+/* PCI Memories */
+#define MEMORY_BASE_PCI_CONFIG      0x50000000UL  /* PCI configuration */
+#define MEMORY_BASE_PCI_IO          0x58000000UL  /* PCI I/O space */
+#define MEMORY_BASE_PCI_MEMORY      0x60000000UL  /* PCI Memory Base */
+
+#define MAX_LOG2_PCIMEM_MAP  	6   	/* 2^(6+3) = 512MB */
+#define MAX_PCIMEM_MAP_SIZE  	(((1<<(MAX_LOG2_PCIMEM_MAP+3))*7)>>3)	/* Max 448MB */
+
+#define PCIBIOS_MIN_MEM_EM86XX  (MEMORY_BASE_PCI_MEMORY + 0x40000000UL)   /* base address of EM86xx PCI slave */
+
+/* Peripheral bus Registers */
+#define HOST_pb0_base               0x0000
+#define HOST_pb_base_cs(n)          (HOST_pb0_base + (0x0200 * (n)))
+
+#define PB_timing_slot(n)	    (PB_timing0 + (0x04 * (n)))
+
+/* Bus Master IDE */
+#define REG_BASE_host_interface_BMIDE         (REG_BASE_host_interface + IDECTRL_pri_cmdblock)
+
+#define REG_BASE_host_interface_ISAIDE(x)  (REG_BASE_host_interface + HOST_pb_base_cs(x))
+
+/* Only applicable to Tango3 */
+#define SDND_MAGIC		0x4d474953      /* SIGM */
+#define SDND_MINORS		16
+#define SDND_MAX_CS		4
+#define KERNEL_SECTOR_SIZE	512
+
+#ifndef __ASSEMBLY__
+
+struct xenv_disk_marker
+{
+	unsigned int magic; 	/* magic# */
+	unsigned int cs;
+};
+
+#ifdef CONFIG_PRINTK
+int printk(const char * fmt, ...) __attribute__ ((format (printf, 1, 2)));
+#else
+static inline int printk(const char *s, ...) __attribute__ ((format (printf, 1, 2)));
+#endif
+
+#ifndef REMAP_IDX
+#define REMAP_IDX      (((CPU_REMAP_SPACE-CPU_remap2_address)/0x04000000UL)+2)
+#endif
+#ifndef MAX_KERNEL_MEMSIZE
+#define MAX_KERNEL_MEMSIZE	(0x1c000000UL-(((REMAP_IDX)-2)*0x04000000UL))
+#endif
+
+/* Physical address mapping */
+static inline unsigned long tangox_dma_address(unsigned long physaddr)
+{
+	extern unsigned long em8xxx_remap_registers[9];
+	extern unsigned long em8xxx_kmem_size;
+
+	if ((physaddr < CPU_REMAP_SPACE) || (physaddr >= (CPU_REMAP_SPACE + em8xxx_kmem_size))) {
+#if !defined(CONFIG_SD_DIRECT_DMA) && !defined(CONFIG_HIGHMEM)
+//		printk("<3>" "dma_address conversion failure (0x%08lx in range 0x%08lx-0x%08lx)\n", 
+//			physaddr, (unsigned long)CPU_REMAP_SPACE, (unsigned long)CPU_REMAP_SPACE + em8xxx_kmem_size); 
+#endif
+		return(physaddr); /* use whatever is specified */
+	} else {
+		return(em8xxx_remap_registers[((physaddr & 0x1c000000UL) >> 26) + 1] + (physaddr & 0x03ffffffUL));
+	}
+}
+
+/* Inverted physical address mapping */
+static inline unsigned long tangox_inv_dma_address(unsigned long mapaddr)
+{
+	extern unsigned long em8xxx_remap_registers[9];
+	extern unsigned long em8xxx_kmem_size;
+	int i;
+	unsigned long msize = 0, offset = mapaddr & 0x03ffffffUL, base = mapaddr & 0xfc000000UL;
+
+	for (i = REMAP_IDX; (msize < em8xxx_kmem_size) && (i < 9); msize += 0x04000000, i++) {
+		if (base == em8xxx_remap_registers[i]) {	/* found the remap register to match */
+			if (((em8xxx_kmem_size - msize) >= 0x04000000UL) || ((em8xxx_kmem_size - msize) > offset))
+				return(((i - REMAP_IDX) * 0x04000000UL) + CPU_REMAP_SPACE + offset);
+			else
+				break;	/* outside kernel memory area, don't translate it */
+		}
+	}
+#if !defined(CONFIG_SD_DIRECT_DMA) && !defined(CONFIG_HIGHMEM)
+//	printk("<3>" "dma_address inversion failure (0x%08lx)\n", mapaddr); 
+#endif
+	return(mapaddr); /* use whatever is specified */
+}
+#endif
+
+#endif /* __HARDWARE_H */
+
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango3/ir.h linux-3.9.2/arch/mips/include/asm/tango3/ir.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango3/ir.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango3/ir.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,34 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+                                                                                
+/*
+ * IR related definitions, and function prototypes.
+ */
+#ifndef _IR_H_
+#define _IR_H_
+                                                                                
+#ifdef __KERNEL__
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <asm/ioctl.h>
+#elif !defined(BOOTLOADER)
+#include <sys/ioctl.h>
+#endif /* __KERNEL__ */
+
+#if defined(__KERNEL__) || !defined(BOOTLOADER)
+/* ioctl commands for user level applications*/
+#define IR_IOC_MAGIC           'I'
+#define IR_IOCSETREPEATKEYS	_IO(IR_IOC_MAGIC, 0)
+#define IR_IOCGETREPEATKEYS	_IO(IR_IOC_MAGIC, 1)
+#define IR_IOCSETWAITPERIOD	_IO(IR_IOC_MAGIC, 2)
+#define IR_IOCGETWAITPERIOD	_IO(IR_IOC_MAGIC, 3)
+#endif /* __KERNEL__ || !BOOTLOADER */
+                                                                                
+#endif /* _IR_H_ */
+
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango3/rmdefs.h linux-3.9.2/arch/mips/include/asm/tango3/rmdefs.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango3/rmdefs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango3/rmdefs.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,11 @@
+
+#ifndef __RMDEFS_H
+#define __RMDEFS_H
+
+typedef unsigned long RMuint32;
+typedef unsigned short RMuint16;
+typedef unsigned char RMuint8;
+typedef char RMascii;
+typedef int RMstatus;
+
+#endif
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango3/rmem86xxid.h linux-3.9.2/arch/mips/include/asm/tango3/rmem86xxid.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango3/rmem86xxid.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango3/rmem86xxid.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,203 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/**
+  @file   rmem86xxid.h
+  @brief  
+
+  long description
+
+  @author Emmanuel Michon
+  @date   2004-09-22
+*/
+
+#ifndef __RMEM86XXID_H__
+#define __RMEM86XXID_H__
+
+/*
+  the main chip ids 
+  
+  tango3 is for asic development (should be tango\infty)
+
+  Usually, users do not set by hand, but thru `rmcflags' helper
+*/
+#define EM86XX_CHIPID_MAMBO      1000
+#define EM86XX_CHIPID_MAMBOLIGHT 2000
+#define EM86XX_CHIPID_TANGO      3000
+#define EM86XX_CHIPID_TANGOLIGHT 4000
+#define EM86XX_CHIPID_TANGO15    4500
+#define EM86XX_CHIPID_TANGO2     5000
+#define EM86XX_CHIPID_TANGO3    10000
+
+#if (EM86XX_CHIP==EM86XX_CHIPID_MAMBO)
+#define S_EM86XX_CHIPID "mambo"
+#elif (EM86XX_CHIP==EM86XX_CHIPID_MAMBOLIGHT)
+#define S_EM86XX_CHIPID "mambolight"
+#elif (EM86XX_CHIP==EM86XX_CHIPID_TANGOLIGHT)
+#define S_EM86XX_CHIPID "tangolight"
+#elif (EM86XX_CHIP==EM86XX_CHIPID_TANGO15)
+#define S_EM86XX_CHIPID "tango15"
+#elif (EM86XX_CHIP==EM86XX_CHIPID_TANGO2)
+#define S_EM86XX_CHIPID "tango2"
+#elif (EM86XX_CHIP==EM86XX_CHIPID_TANGO3)
+#define S_EM86XX_CHIPID "tango3"
+#else
+#error EM86XX_CHIP is not set
+#endif
+
+/* 
+  revisions...
+  
+  Referring to whatever is written at the surface of the BGA,
+  not the PCI revid / subid / etc. This detail is important for some chips
+  are ambiguous software wise.
+  
+  1: ES1
+  2: ES2
+  3: ES3
+  4: ES4 
+  5: ES5 
+  6: ES6 
+  65: revA
+  66: revB
+  67: revC
+  
+  No ID, but numbers. For a 8630ES2 for instance: build with
+  RMCFLAGS="... -DEM86XX_CHIP=EM86XX_CHIPID_TANGO2 -DEM86XX_REVISION=2 ..."
+
+  --------------------------------------------------------------------------
+  package writing          ES1  ES2  ES3  ES4     ES5     ES6  ES7  ES8  ES9 revA revB revC
+
+  EM86XX_REVISION            1    2    3    4       5       6    7    8    9  'A'  'B'  'C'
+
+  8600 `mambo' series                                                           1    2    3
+
+  8620 `tangolight' series                                                    (a)  (b) 0x82
+  8622 `tango15' series   0x81                (d)0x81                   0x82
+                                                                           ^this is the PCI revID
+
+  863x `tango2' series (c)0x81 0x81 0x81 0x82 (e)0x82 (f)0x83 0x84 0x85 0x86                
+
+  (a) don't remember
+  (b) no such chip
+  (c) 8630: FibbedES1 ES1 ES2 ES3 are the same chip
+  (d) 8622: ES1 and revA cannot be distinguished from revID. Software test impossible in practice
+  (e) 8630: ES4 and ES5 cannot be distinguished from revID. Software test with 0x6c900 bit12
+  (f) 8634: ES6 and RevA have the same revID (just different bonding option)
+      8634: ES7 and RevB have the same revID (just different bonding option)
+      8634: ES9 and RevC have the same revID (just different bonding option)
+  --------------------------------------------------------------------------
+
+  Usually, users do not set by hand, but thru `rmcflags' helper
+*/
+#ifndef EM86XX_REVISION
+#error EM86XX_REVISION is not set
+#endif
+
+#if (EM86XX_CHIP==EM86XX_CHIPID_TANGO2) && (EM86XX_REVISION=='A') 
+#error inconsistent: 863x revA is actually -DWITH_PROD=1 -DEM86XX_REVISION=6
+#endif
+
+#if (EM86XX_CHIP==EM86XX_CHIPID_TANGO2) && (EM86XX_REVISION=='B') 
+#error inconsistent: 863x revB is actually -DWITH_PROD=1 -DEM86XX_REVISION=7
+#endif
+
+#if (EM86XX_CHIP==EM86XX_CHIPID_TANGO2) && (EM86XX_REVISION=='C') 
+#error inconsistent: 863x revC is actually -DWITH_PROD=1 -DEM86XX_REVISION=9
+#endif
+
+#if (EM86XX_REVISION==1)
+#define S_EM86XX_REVISION "ES1"
+#elif (EM86XX_REVISION==2)
+#define S_EM86XX_REVISION "ES2"
+#elif (EM86XX_REVISION==3)
+#define S_EM86XX_REVISION "ES3"
+#elif (EM86XX_REVISION==4)
+#define S_EM86XX_REVISION "ES4"
+#elif (EM86XX_REVISION==5)
+#define S_EM86XX_REVISION "ES5"
+#elif (EM86XX_REVISION==6)
+#if (EM86XX_CHIP==EM86XX_CHIPID_TANGO2) && (defined(WITH_PROD) || defined(WITH_FACSPROD))
+#define S_EM86XX_REVISION "revA"
+#else
+#define S_EM86XX_REVISION "ES6"
+#endif
+#elif (EM86XX_REVISION==7)
+#if (EM86XX_CHIP==EM86XX_CHIPID_TANGO2) && (defined(WITH_PROD) || defined(WITH_FACSPROD))
+#define S_EM86XX_REVISION "revB"
+#else
+#define S_EM86XX_REVISION "ES7"
+#endif
+#elif (EM86XX_REVISION==8)
+#define S_EM86XX_REVISION "ES8"
+#elif (EM86XX_REVISION==9)
+#if (EM86XX_CHIP==EM86XX_CHIPID_TANGO2) && (defined(WITH_PROD) || defined(WITH_FACSPROD))
+#define S_EM86XX_REVISION "revC"
+#else
+#define S_EM86XX_REVISION "ES9"
+#endif
+
+#elif (EM86XX_REVISION=='A')
+#define S_EM86XX_REVISION "revA"
+#elif (EM86XX_REVISION=='B')
+#define S_EM86XX_REVISION "revB"
+#elif (EM86XX_REVISION=='C')
+#define S_EM86XX_REVISION "revC"
+#else
+#error complete revision strings
+#endif
+
+/* the compilation modes */
+#define EM86XX_MODEID_WITHHOST   1000
+#define EM86XX_MODEID_STANDALONE 2000
+
+/* the dsps */
+#define EM86XX_ENGINEID_MPEG0 10
+#define EM86XX_ENGINEID_MPEG1 11
+#define EM86XX_ENGINEID_AUDIO0 20
+#define EM86XX_ENGINEID_AUDIO1 21
+#define EM86XX_ENGINEID_DEMUX 30
+
+/* user does not have to set an engine id. This makes sense for mu only */
+#ifdef EM86XX_ENGINE
+#if (EM86XX_ENGINE==EM86XX_ENGINEID_MPEG0)
+#define SENG "mpeg0"
+#elif (EM86XX_ENGINE==EM86XX_ENGINEID_MPEG1)
+#define SENG "mpeg1"
+#elif (EM86XX_ENGINE==EM86XX_ENGINEID_AUDIO0)
+#define SENG "audio0"
+#elif (EM86XX_ENGINE==EM86XX_ENGINEID_AUDIO1)
+#define SENG "audio1"
+#elif (EM86XX_ENGINE==EM86XX_ENGINEID_DEMUX)
+#define SENG "demux"
+#else
+#endif // end of engine dependent stuff
+#endif
+
+#if (EM86XX_CHIP==EM86XX_CHIPID_TANGO2)
+/*
+#if (defined(WITH_PROD) || defined(WITH_FACSPROD)) && !defined WITH_XLOADED_UCODE
+#error inconsistent flag combination.
+#endif
+
+#if (defined(WITH_PROD) || defined(WITH_FACSPROD)) && !defined WITH_IRQHANDLER_BOOTLOADER
+#error inconsistent flag combination.
+#endif
+*/
+#ifdef WITH_UCODE_BOOTLOADER
+#error inconsistent flag combination. You probably want WITH_XLOADED_UCODE
+#endif
+
+#endif
+
+/* the microcode debug mode */
+
+#define EM86XX_DEBUG_CHIP	1000
+#define EM86XX_DEBUG_SIMU	2000
+
+#endif // __RMEM86XXID_H__
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango3/scard.h linux-3.9.2/arch/mips/include/asm/tango3/scard.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango3/scard.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango3/scard.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,31 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+                                                                                
+/*
+ * Smart card related definitions, and function prototypes.
+ */
+#ifndef _SCARD_H_
+#define _SCARD_H_
+                                                                                
+#ifdef __KERNEL__
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <asm/ioctl.h>
+#else
+#include <sys/ioctl.h>
+#endif /* __KERNEL__ */
+
+/* ioctl commands for user level applications*/
+#define SCARD_IOC_MAGIC		'S'
+#define SCARD_IOC_WARMRESET	_IO(SCARD_IOC_MAGIC, 0)
+#define SCARD_IOC_CLOCKSTOP	_IO(SCARD_IOC_MAGIC, 1)
+#define SCARD_IOC_CLOCKSTART	_IO(SCARD_IOC_MAGIC, 2)
+                                                                                
+#endif /* _SCARD_H_ */
+
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango3/sigblock.h linux-3.9.2/arch/mips/include/asm/tango3/sigblock.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango3/sigblock.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango3/sigblock.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,261 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#ifndef __SIG_BLOCK_H__
+#define __SIG_BLOCK_H__
+
+#define DEFAULT_IRQ_ROUTE1	0x55555555 /* All PCI IRQs route to LOG2_CPU_PCI_INTB */
+#define DEFAULT_IRQ_ROUTE2	0x00030000 /* ISA IDE uses LOG2_CPU_PCU_INTD, Timing slot 0 */
+#define DEFAULT_IRQ_RISE_EDGE_LO	0xff284a00 /* IRQ14 active low level, IRQ19/21 active riseedge */
+#define DEFAULT_IRQ_RISE_EDGE_HI	0x00000000 /* IRQ14 active low level, IRQ19/21 active rise edge */
+#define DEFAULT_IRQ_FALL_EDGE_LO	0x00004000
+#define DEFAULT_IRQ_FALL_EDGE_HI	0x00000000
+#define DEFAULT_IRQ_GPIO_MAP	0x0607080d /* ISA IDE/GPIO 6, PCI/GPIO 8 */
+#define DEFAULT_DEV_ENABLED	0x00003cf7 /* ISAIDE/BMIDE/PCIHOST/IR/FIP/I2CM/I2CS/PCI1-4 enabled */
+#define DEFAULT_PB_DEF_TIMING	0x01090008
+#define DEFAULT_PB_CS_CONFIG	0x00001044
+#define DEFAULT_PB_TIMING0	0x01090008
+#define DEFAULT_PB_USE_TIMING0	0x000001f4
+#define DEFAULT_PB_TIMING1	0x00110101
+#define DEFAULT_PB_USE_TIMING1	0x000003f3
+#define DEFAULT_PB_TIMING2	0
+#define DEFAULT_PB_USE_TIMING2	0
+#define DEFAULT_PB_TIMING3	0
+#define DEFAULT_PB_USE_TIMING3	0
+#define DEFAULT_PB_TIMING4	0
+#define DEFAULT_PB_USE_TIMING4	0
+#define DEFAULT_PB_TIMING5	0
+#define DEFAULT_PB_USE_TIMING5	0
+
+#define DEFAULT_SYSCLK_PLL	0x0 /* Set by XOS */
+#define DEFAULT_SYSCLK_DIV	0x0 /* Not changed */
+
+#define DEFAULT_ETH_MAC_HI	0x00000000 /* MAC address */
+#define DEFAULT_ETH_MAC_LO	0x00000000
+
+/* This list of devices in the enable list field (irq_route2) */
+#define ISAIDE_SHIFT		0
+#define BMIDE_SHIFT		1
+#define PCIHOST_SHIFT		2
+#define ETHERNET_SHIFT		3
+#define IR_SHIFT		4
+#define FIP_SHIFT		5	
+#define I2CM_SHIFT		6
+#define I2CS_SHIFT		7
+#define SDIO_SHIFT		8
+#define USB_SHIFT		9
+#define PCI1_SHIFT		10
+#define PCI2_SHIFT		11
+#define PCI3_SHIFT		12
+#define PCI4_SHIFT		13
+#define PCI5_SHIFT		14
+#define PCI6_SHIFT		15
+#define SATA_SHIFT		16
+#define SCARD_SHIFT		17
+#define GNET_SHIFT		18
+/*				19-32: undefined */
+
+#ifndef __ASSEMBLY__
+
+struct hwinfo {
+	unsigned long sysclk_pll; /* The setting for the PLL */
+	unsigned long sysclk_div;
+
+	/* Only 4 IRQs can be used for PCI devices (LOG2_CPU_PCI_INTA-D,
+	   so we can encode it in 2 bits. Each device can have 4 IRQ
+	   routing and as as result we can use one byte to represent
+	   the IRQ route for a given device (IDSELx). Bu using 8 bytes,
+	   we can represent the PCI devices (IDSEL1-6, 5-6 reserved) as
+	   well as ISA IDE information and device enabling list*/
+	unsigned long irq_route1;	/* PCI dev 1-4 */
+
+	/* PCI dev 5-6, ISA IDE information, device enabling list */
+	unsigned long irq_route2;	/* PCI dev 5-6: bit 0-15 */
+					/* ISA IDE: bit 16-17: IRQ offset */
+
+	unsigned long irq_rise_edge_hi; /* Rising edge config */
+	unsigned long irq_rise_edge_lo; /* Rising edge config */
+	unsigned long irq_fall_edge_hi; /* Falling edge config */
+	unsigned long irq_fall_edge_lo; /* Falling edge config */
+
+	unsigned long gpio_irq_map; /* GPIO pins hook to IRQ13..16 */
+	unsigned long dev_enabled;  /* Device enabling list*/
+
+	unsigned long pb_def_timing;
+	unsigned long pb_cs_config;
+	unsigned long pb_timing0;
+	unsigned long pb_use_timing0;
+	unsigned long pb_timing1;
+	unsigned long pb_use_timing1;
+	unsigned long pb_timing2;
+	unsigned long pb_use_timing2;
+	unsigned long pb_timing3;
+	unsigned long pb_use_timing3;
+	unsigned long pb_timing4;
+	unsigned long pb_use_timing4;
+	unsigned long pb_timing5;
+	unsigned long pb_use_timing5;
+
+	unsigned long mac_hi;	/* Ethernet MAC address */
+	unsigned long mac_lo;
+};
+
+/* Definition of signature block (192bytes), which should start at 0xbfc00000 */
+/* There'll be 20bytes sha1sum afterward (0xbfc000c0-0xbfc000d3) */
+struct signature_block {
+	unsigned long opcodes[2];  /* For opcodes, fixed value 0x10000034/0x00000000 */
+	struct hwinfo hwinfo;
+	/* 
+	   zboot or such specific extensions 
+
+	   Note that YAMON requires extension[2]=0x1105e0 (product ID `thirdparty')
+	 */
+	unsigned long extension[20];	
+};
+
+//RMmustBeEqual(sizeof(struct signature_block),3*64,seed0);
+
+#ifdef __EMHWLIB_REGISTERS_TANGO2_H__
+static inline int isaide_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> ISAIDE_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int bmide_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> BMIDE_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int sata_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> SATA_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int scard_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> SCARD_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int gnet_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> GNET_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int pci_host_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> PCIHOST_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int ethernet_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> ETHERNET_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int ir_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> IR_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int fip_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> FIP_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int i2cm_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> I2CM_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int i2cs_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> I2CS_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int sdio_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> SDIO_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int usb_enabled(const struct signature_block *sigptr)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> USB_SHIFT) & 1) != 0) ? 1 : 0);
+}
+
+static inline int pcidev_enabled(const struct signature_block *sigptr, int pci_idsel)
+{
+	return(((((sigptr->hwinfo.dev_enabled) >> (pci_idsel - 1 + PCI1_SHIFT)) & 1) != 0) ? 1 : 0);
+}
+
+/* Given PCI device idsel number and INT number, returning the IRQ number
+   for it */
+static inline int pcidev_intr_num(const struct signature_block *sigptr,
+				const int pci_idsel, const int int_num)
+{
+	unsigned long route;
+	int irq;
+
+	if (pcidev_enabled(sigptr, pci_idsel) == 0)
+		return(-1);
+	else if ((pci_idsel >= 1) && (pci_idsel <= 4)) {
+		/* Get the routing information for specific device */
+		route = ((sigptr->hwinfo.irq_route1) >> ((pci_idsel - 1) * 8)) & 0xff;
+		irq = (int)((route >> (int_num * 2)) & 0x3); /* int_num: 0-3 = INTA-D */
+	} else if ((pci_idsel >= 5) && (pci_idsel <= 6)) {
+		/* Get the routing information for specific device */
+		route = ((sigptr->hwinfo.irq_route2) >> ((pci_idsel - 5) * 8)) & 0xff;
+		irq = (int)((route >> (int_num * 2)) & 0x3); /* int_num: 0-3 = INTA-D */
+	} else 
+		return(-1);
+
+	return(LOG2_CPU_PCI_INTA + irq);
+}
+ 
+/* Find out the CS# used by ISA IDE */
+static inline int isaide_cs_select(const struct signature_block *sigptr)
+{
+	unsigned long cs_config = (sigptr->hwinfo.pb_cs_config >> 12) & 0xf;
+	int i;
+
+	if (isaide_enabled(sigptr) == 0)
+		return(-1);
+
+	for (i = 0; i < 4; i++) {
+		if ((cs_config & 0x1) != 0) 
+			return(i);
+		else
+			cs_config >>= 1;
+	}
+	return(-1);
+}
+
+/* Return the IRQ number for ISA IDE */
+static inline int isaide_intr_num(const struct signature_block *sigptr)
+{
+	int irq;
+
+	if (isaide_enabled(sigptr) == 0)
+		return(-1);
+	else
+		irq = (int)(((sigptr->hwinfo.irq_route2) >> 16) & 0x3);
+	return(LOG2_CPU_PCI_INTA + irq);
+}
+
+static inline int isaide_timing_slot(const struct signature_block *sigptr)
+{
+	unsigned long slot;
+
+	slot = ((sigptr->hwinfo.irq_route2) >> 18) & 0x7;
+	return((int)slot);
+}
+#endif /* __EMHWLIB_REGISTERS_TANGO2_H__ */
+
+#endif /* !__ASSEMBLY__ */
+
+#endif /* !__SIG_BLOCK_H__ */
+
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango3/sigblock.inc linux-3.9.2/arch/mips/include/asm/tango3/sigblock.inc
--- linux-3.9.2.ref/arch/mips/include/asm/tango3/sigblock.inc	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango3/sigblock.inc	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,59 @@
+#
+#******************************************************
+#* This file is generated automatically, DO NOT EDIT! *
+#******************************************************
+#*
+#* destined to be included by a shell script or a Makefile (keep syntax adapted to both)
+#*
+#* emhwlib_hal/include/sigblock.inc (generated from emhwlib_hal/include/sigblock.h)
+#*
+#* Copyright (C) Sigma Designs, Inc. 2007.
+#*
+i386=0x1
+linux=0x1
+unix=0x1
+DEFAULT_IRQ_ROUTE1=0x55555555
+DEFAULT_IRQ_ROUTE2=0x30000
+DEFAULT_IRQ_RISE_EDGE_LO=0xff284a00
+DEFAULT_IRQ_RISE_EDGE_HI=0x0
+DEFAULT_IRQ_FALL_EDGE_LO=0x4000
+DEFAULT_IRQ_FALL_EDGE_HI=0x0
+DEFAULT_IRQ_GPIO_MAP=0x607080d
+DEFAULT_DEV_ENABLED=0x3cf7
+DEFAULT_PB_DEF_TIMING=0x1090008
+DEFAULT_PB_CS_CONFIG=0x1044
+DEFAULT_PB_TIMING0=0x1090008
+DEFAULT_PB_USE_TIMING0=0x1f4
+DEFAULT_PB_TIMING1=0x110101
+DEFAULT_PB_USE_TIMING1=0x3f3
+DEFAULT_PB_TIMING2=0x0
+DEFAULT_PB_USE_TIMING2=0x0
+DEFAULT_PB_TIMING3=0x0
+DEFAULT_PB_USE_TIMING3=0x0
+DEFAULT_PB_TIMING4=0x0
+DEFAULT_PB_USE_TIMING4=0x0
+DEFAULT_PB_TIMING5=0x0
+DEFAULT_PB_USE_TIMING5=0x0
+DEFAULT_SYSCLK_PLL=0x0
+DEFAULT_SYSCLK_DIV=0x0
+DEFAULT_ETH_MAC_HI=0x0
+DEFAULT_ETH_MAC_LO=0x0
+ISAIDE_SHIFT=0x0
+BMIDE_SHIFT=0x1
+PCIHOST_SHIFT=0x2
+ETHERNET_SHIFT=0x3
+IR_SHIFT=0x4
+FIP_SHIFT=0x5
+I2CM_SHIFT=0x6
+I2CS_SHIFT=0x7
+SDIO_SHIFT=0x8
+USB_SHIFT=0x9
+PCI1_SHIFT=0xa
+PCI2_SHIFT=0xb
+PCI3_SHIFT=0xc
+PCI4_SHIFT=0xd
+PCI5_SHIFT=0xe
+PCI6_SHIFT=0xf
+SATA_SHIFT=0x10
+SCARD_SHIFT=0x11
+GNET_SHIFT=0x12
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango3/tango3api.h linux-3.9.2/arch/mips/include/asm/tango3/tango3api.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango3/tango3api.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango3/tango3api.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,118 @@
+/*
+ * include/asm-mips/tango3/tango3api.h
+ *
+ * Copyright 2002-2007, Sigma Designs, Inc 
+ *
+ * This file contains SMP86XX controling functions
+ *
+ */
+
+#ifndef __ASM_ARCH_EM86XX_H
+#define __ASM_ARCH_EM86XX_H
+#include <asm/tango3/hardware.h>
+//
+// global variables
+// 
+
+//
+// from arch/arm/arch-em86xx/irq.c
+//
+
+// irq
+void em86xx_mask_irq(unsigned int irq);
+void em86xx_unmask_irq(unsigned int irq);
+void em86xx_wait_irq(unsigned int irq);
+
+// fiq
+void em86xx_mask_fiq(unsigned int fiq);
+void em86xx_unmask_fiq(unsigned int fiq);
+
+// software interrupt
+int em86xx_softirq_isset(int irq);
+void em86xx_softirq_set(int irq);
+void em86xx_softirq_clr(int irq);
+void em86xx_irq_clr(int irq);
+
+//
+// from arch/arm/arch-em86xx/em86xxapi.c
+//
+
+// Cache
+// clean : write dirty buffer (D cache only)
+// invalidate : invalidate the contents of cache (I & D cache)
+// flush : clean + invalidate
+void em86xx_get_cache_state(int *picache, int *pdcache, int *pwriteback);
+void em86xx_enable_cache(int icache, int dcache, int writeback);
+void em86xx_clean_cache_data(void);
+void em86xx_clean_cache_data_region(unsigned int from, unsigned int to);
+void em86xx_invalidate_cache_instruction(void);
+void em86xx_invalidate_cache_instruction_region(unsigned int from, unsigned int to);
+void em86xx_invalidate_cache_data(void);
+void em86xx_invalidate_cache_data_region(unsigned int from, unsigned int to);
+
+void em86xx_flush_cache_all(void);
+void em86xx_flush_cache_data(void);
+void em86xx_flush_cache_data_region(unsigned int from, unsigned int to);
+
+// memory
+unsigned int em86xx_get_pciregionsize(void);
+unsigned int em86xx_get_dmamemorysize(void);
+
+// switchbox (Host interface)
+enum { 
+	SBOX_MBUS_W0 = 0, SBOX_MBUS_W1, SBOX_PCIMASTER, SBOX_PCISLAVE, 
+	SBOX_SATA0, SBOX_IDEFLASH, SBOX_IDEDVD, SBOX_SATA1, SBOX_MBUS_W2, SBOX_HOST_CIPHER, SBOX_MAX
+};
+
+int em86xx_sbox_init(void);
+#if 0
+void em86xx_sbox_reset(void);
+int em86xx_sbox_setup(void);
+int em86xx_sbox_connect(int iface);
+void em86xx_sbox_disconnect(int port);
+#endif
+
+// MBUS DMA 
+typedef void (*mbus_irq_handler_t)(int irq, void *arg);
+
+int em86xx_mbus_alloc_dma(int sbox, int fromdev, unsigned long *pregbase, int *pirq, int canwait);
+void em86xx_mbus_free_dma(unsigned long regbase, int sbox);
+int em86xx_mbus_setup_dma(unsigned int regbase, unsigned int addr, unsigned int count, mbus_irq_handler_t handler, void *arg, unsigned int flags);
+int em86xx_mbus_notification(unsigned int regbase, mbus_irq_handler_t handler, void *arg);
+int em86xx_mbus_inuse(unsigned int regbase);
+int em86xx_mbus_wait(unsigned int regbase, int sbox);
+void em86xx_mbus_reset(unsigned int regbase, int sbox);
+int mbus_memcpy(unsigned int regbase, unsigned int src, unsigned int dst, unsigned int size);
+
+// PCI master
+void em86xx_pcimaster_setup_read(unsigned int addr, unsigned int count);
+void em86xx_pcimaster_start_read(int start);
+void em86xx_pcimaster_setup_write(unsigned int addr, unsigned int count);
+void em86xx_pcimaster_start_write(int start);
+
+// GPIO
+#define GPIO_INPUT		0
+#define GPIO_OUTPUT		1
+
+int em86xx_gpio_read(int gpio);
+void em86xx_gpio_write(int gpio, int data);
+void em86xx_gpio_setdirection(int gpio, int dir);
+
+int em86xx_gpio_getmode(int gpio);
+int em86xx_gpio_setmode(int gpio, int mode, int *oldmode);
+
+int em86xx_uart0_gpio_read(int gpio);
+void em86xx_uart0_gpio_write(int gpio, int data);
+void em86xx_uart0_gpio_setdirection(int gpio, int dir);
+int em86xx_uart1_gpio_read(int gpio);
+void em86xx_uart1_gpio_write(int gpio, int data);
+void em86xx_uart1_gpio_setdirection(int gpio, int dir);
+
+#define NUM_TANGOX_MUTEX	4
+#define MUTEX_PBI		0
+
+int tangox_mutex_lock(unsigned int idx);
+int tangox_mutex_unlock(unsigned int idx);
+
+#endif
+
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango3/tango3_gbus.h linux-3.9.2/arch/mips/include/asm/tango3/tango3_gbus.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango3/tango3_gbus.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango3/tango3_gbus.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,39 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#ifndef __TANGO3_GBUS_H
+#define __TANGO3_GBUS_H
+
+#ifndef __ASSEMBLY__
+
+#include "rmdefs.h"
+
+#include <asm/addrspace.h>
+
+struct gbus;
+#define pGBus ((struct gbus *)1)
+
+RMuint32 gbus_read_uint32(struct gbus *pgbus, RMuint32 byte_address);
+RMuint16 gbus_read_uint16(struct gbus *pgbus, RMuint32 byte_address);
+RMuint8 gbus_read_uint8(struct gbus *pgbus, RMuint32 byte_address);
+void gbus_write_uint32(struct gbus *pgbus, RMuint32 byte_address, RMuint32 data);
+void gbus_write_uint16(struct gbus *pgbus, RMuint32 byte_address, RMuint16 data);
+void gbus_write_uint8(struct gbus *pgbus, RMuint32 byte_address, RMuint8 data);
+
+#define gbus_read_reg32(r)      __raw_readl((volatile void __iomem *)KSEG1ADDR(r))
+#define gbus_read_reg16(r)      __raw_readw((volatile void __iomem *)KSEG1ADDR(r))
+#define gbus_read_reg8(r)       __raw_readb((volatile void __iomem *)KSEG1ADDR(r))
+#define gbus_write_reg32(r, v)  __raw_writel(v, (volatile void __iomem *)KSEG1ADDR(r))
+#define gbus_write_reg16(r, v)  __raw_writew(v, (volatile void __iomem *)KSEG1ADDR(r))
+#define gbus_write_reg8(r, v)   __raw_writeb(v, (volatile void __iomem *)KSEG1ADDR(r))
+
+#endif /* !__ASSEMBLY__ */
+#endif /* __TANGO3_GBUS_H */
+
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango3/tango3.h linux-3.9.2/arch/mips/include/asm/tango3/tango3.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango3/tango3.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango3/tango3.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,81 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+/**
+  @file   tango3.h
+  @brief  
+
+  <long description>
+
+  @author Emmanuel Michon
+  @date   2004-05-10
+*/
+
+#ifndef __TANGO3_H__
+#define __TANGO3_H__
+#include <asm/tango3/hardware.h>
+#define EM86XX_CHIP EM86XX_CHIPID_TANGO3
+#include <asm/tango3/rmem86xxid.h>
+#include <asm/tango3/emhwlib_lram.h>
+#include <asm/tango3/emhwlib_resources_tango3.h>
+#ifndef CONFIG_TANGOX_BASE_FREQUENCY
+#define TANGOX_BASE_FREQUENCY	27000000 
+#else
+#define TANGOX_BASE_FREQUENCY CONFIG_TANGOX_BASE_FREQUENCY
+#endif
+#define TANGO3_UART_FREQUENCY   7372800
+/* Baudrate setting */
+#if defined(CONFIG_TANGO3_SMP86XX)
+#ifndef CONFIG_TANGOX_BASE_BAUD
+#define TANGOX_BASE_BAUD 38400
+#else
+#define TANGOX_BASE_BAUD CONFIG_TANGOX_BASE_BAUD
+#endif
+//#define TANGOX_CPU_FREQUENCY 333000000
+#else
+#error "Unsupported platform"
+#endif /* CONFIG_TANGO3_SMP86XX */
+
+/* Memory size used by Linux */
+#ifndef CONFIG_TANGOX_MEMSIZE
+#if defined(CONFIG_TANGO3_SMP86XX)
+#define  TANGOX_SYSTEMRAM_ACTUALSIZE   (32*1024*1024)
+#else
+#error "Unsupported platform"
+#endif /* CONFIG_TANGO3_SMP86XX */
+#else
+#define TANGOX_SYSTEMRAM_ACTUALSIZE    CONFIG_TANGOX_MEMSIZE
+#endif /* !CONFIG_TANGOX_MEMSIZE */
+
+#define TANGOX_CTRLIRQ 0
+#define TANGOX_CTRLFIQ 1
+#define TANGOX_CTRLIIQ 2
+
+#if defined(CONFIG_TANGO3_SMP86XX)
+#define SYS_clkgen_pll        SYS_clkgen1_pll
+#endif
+
+#define RMCHIP_ID_SMP8644 (8644)
+#define RMCHIP_ID_SMP8642 (8642)
+#define RMCHIP_ID_SMP8646 (8646)
+
+#define RMCHIP_ID_SMP8654 (8654)
+#define RMCHIP_ID_SMP8652 (8652)
+#define RMCHIP_ID_SMP8656 (8656)
+#define RMCHIP_ID_SMP8658 (8658)
+#define RMCHIP_ID_SMP8670 (8670)
+#define RMCHIP_ID_SMP8672 (8672)
+#define RMCHIP_ID_SMP8674 (8674)
+#define RMCHIP_ID_SMP8680 (8680)
+#define RMCHIP_ID_SMP8682 (8682)
+#define RMCHIP_ID_SMP868A (0x868A)
+
+#endif // __TANGO3_H__
+
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango3/tango3_pci.h linux-3.9.2/arch/mips/include/asm/tango3/tango3_pci.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango3/tango3_pci.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango3/tango3_pci.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,74 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#ifndef __TANGO3_PCI_H
+#define __TANGO3_PCI_H
+
+#include <asm/tango3/hardware.h>
+#include <asm/tango3/tango3_gbus.h>
+
+#define PCIEM86XX_PCIFAULT_INTR		((IRQ_CONTROLLER_IRQ_BASE) + \
+						(LOG2_CPU_PCI_FAULT_INT))
+
+#define PCIEM86XX_ARBITER_LEVEL		0x00
+#define PCIEM86XX_ARBITER_GRANTTIMEOUT	0x10101010
+
+#define PCIEM86XX_IDSEL_MAX		0x05 	/* SMP865x:4, SMP864x:5 */
+#define PCIEM86XX_IDSEL_BITS		0x03
+
+/*
+ * helpers to access host interface registers
+ */
+#define RD_HOST_REG32(r)	\
+		gbus_read_reg32(REG_BASE_host_interface + (r))
+
+#define WR_HOST_REG32(r, v)	\
+		gbus_write_reg32(REG_BASE_host_interface + (r), (v))
+
+#define RD_HOST_REG8(r)	\
+		gbus_read_reg8(REG_BASE_host_interface + (r))
+
+#define WR_HOST_REG8(r, v)	\
+		gbus_write_reg8(REG_BASE_host_interface + (r), (v))
+
+
+/*
+ * read/write data  from/to the configuration space.  The  only way to
+ * know if there is a device is by checking that we did not generate a
+ * bus fault interrupt, so we need to mask them during the access.
+ */
+#define BUILD_TANGOX_CFG_ACCESS(pfx, __x)				\
+static inline int tangox_cfg_##pfx(void __iomem *addr, u32 *data)	\
+{									\
+	unsigned long flags, status;					\
+	extern spinlock_t tangox_pci_lock;				\
+									\
+	spin_lock_irqsave(&tangox_pci_lock, flags);			\
+									\
+	__x;								\
+	status = (RD_HOST_REG8(PCI_host_reg2 + 3) >> 1) & 0x3;		\
+	if (status) {							\
+		WR_HOST_REG8(PCI_host_reg2 + 3, 1);			\
+		WR_HOST_REG8(PCI_host_reg2 + 3, 0);			\
+	}								\
+									\
+	spin_unlock_irqrestore(&tangox_pci_lock, flags);		\
+	return status ? 1 : 0;						\
+}
+
+BUILD_TANGOX_CFG_ACCESS(read8, *data = readb(addr) & 0xff)
+BUILD_TANGOX_CFG_ACCESS(read16, *data = readw(addr) & 0xffff)
+BUILD_TANGOX_CFG_ACCESS(read32, *data = readl(addr))
+BUILD_TANGOX_CFG_ACCESS(write8, writeb(*data & 0xff, addr))
+BUILD_TANGOX_CFG_ACCESS(write16, writew(*data & 0xffff, addr))
+BUILD_TANGOX_CFG_ACCESS(write32, writel(*data, addr))
+
+#endif
+
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango3/tango3_usb.h linux-3.9.2/arch/mips/include/asm/tango3/tango3_usb.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango3/tango3_usb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango3/tango3_usb.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,39 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#ifndef __TANGO3_USB_H
+#define __TANGO3_USB_H
+
+#include <asm/tango3/hardware.h>
+#include <asm/tango3/tango3_gbus.h>
+
+#define TANGOX_EHCI_IRQ	(IRQ_CONTROLLER_IRQ_BASE + LOG2_CPU_USB_EHCI_INT)
+#define TANGOX_OHCI_IRQ	(IRQ_CONTROLLER_IRQ_BASE + LOG2_CPU_USB_OHCI_INT)
+
+#define TANGOX_EHCI_BASE_ADDR		(REG_BASE_host_interface + 0x1400)
+#define TANGOX_OHCI_BASE_ADDR		(REG_BASE_host_interface + 0x1500)
+#define TANGOX_USB_CTL_STATUS_REG_BASE	(REG_BASE_host_interface + 0x1700)
+
+/*
+ * helpers to access USB registers
+ */
+#define RD_OHCI_REG32(r)	\
+		gbus_read_reg32(TANGOX_OHCI_BASE_ADDR + (r))
+
+#define WR_OHCI_REG32(r, v)	\
+		gbus_write_reg32(TANGOX_OHCI_BASE_ADDR + (r), (v))
+
+#define RD_USB_REG32(r)	\
+		gbus_read_reg32(TANGOX_USB_CTL_STATUS_REG_BASE + (r))
+
+#define WR_USB_REG32(r, v)	\
+		gbus_write_reg32(TANGOX_USB_CTL_STATUS_REG_BASE + (r), (v))
+
+#endif
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/tango3/uir.h linux-3.9.2/arch/mips/include/asm/tango3/uir.h
--- linux-3.9.2.ref/arch/mips/include/asm/tango3/uir.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/include/asm/tango3/uir.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,34 @@
+/*********************************************************************
+ Copyright (C) 2001-2009
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+                                                                                
+/*
+ * UIR related definitions, and function prototypes.
+ */
+#ifndef _UIR_H_
+#define _UIR_H_
+                                                                                
+#ifdef __KERNEL__
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <asm/ioctl.h>
+#else
+#include <sys/ioctl.h>
+#endif /* __KERNEL__ */
+
+/* ioctl commands for user level applications*/
+#define UIR_IOC_MAGIC           'U'
+#define UIR_IOCSETDENOISETIME	_IO(UIR_IOC_MAGIC, 0)
+#define UIR_IOCGETDENOISETIME	_IO(UIR_IOC_MAGIC, 1)
+#define UIR_IOCSETTIMEOUT	_IO(UIR_IOC_MAGIC, 2)
+#define UIR_IOCGETTIMEOUT	_IO(UIR_IOC_MAGIC, 3)
+#define UIR_IOCSETSUBSTRACT	_IO(UIR_IOC_MAGIC, 4)
+#define UIR_IOCGETSUBSTRACT	_IO(UIR_IOC_MAGIC, 5)
+
+#endif /* _UIR_H_ */
+
diff -Naur linux-3.9.2.ref/arch/mips/include/asm/uaccess.h linux-3.9.2/arch/mips/include/asm/uaccess.h
--- linux-3.9.2.ref/arch/mips/include/asm/uaccess.h	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/arch/mips/include/asm/uaccess.h	2013-07-23 19:31:23.000000000 +0200
@@ -692,6 +692,11 @@
 	__cu_len_r;							\
 })
 
+#ifdef CONFIG_TANGOX
+extern size_t __invoke_copy_to_user_dma(void __user * __cu_to, const void * __cu_from, long __cu_len);
+extern size_t __invoke_copy_from_user_dma(void * __cu_to, const void __user * __cu_from, long __cu_len);
+#endif
+
 /*
  * __copy_to_user: - Copy a block of data into user space, with less checking.
  * @to:	  Destination address, in user space.
@@ -706,6 +711,21 @@
  * Returns number of bytes that could not be copied.
  * On success, this will be zero.
  */
+#ifdef CONFIG_TANGOX
+#define __copy_to_user(to, from, n)					\
+({									\
+	void __user *__cu_to;						\
+	const void *__cu_from;						\
+	long __cu_len;							\
+									\
+	__cu_to = (to);							\
+	__cu_from = (from);						\
+	__cu_len = (n);							\
+	might_fault();							\
+	__cu_len = __invoke_copy_to_user_dma(__cu_to, __cu_from, __cu_len); \
+	__cu_len;							\
+})
+#else
 #define __copy_to_user(to, from, n)					\
 ({									\
 	void __user *__cu_to;						\
@@ -719,9 +739,24 @@
 	__cu_len = __invoke_copy_to_user(__cu_to, __cu_from, __cu_len); \
 	__cu_len;							\
 })
+#endif
 
 extern size_t __copy_user_inatomic(void *__to, const void *__from, size_t __n);
 
+#ifdef CONFIG_TANGOX
+#define __copy_to_user_inatomic(to, from, n)				\
+({									\
+	void __user *__cu_to;						\
+	const void *__cu_from;						\
+	long __cu_len;							\
+									\
+	__cu_to = (to);							\
+	__cu_from = (from);						\
+	__cu_len = (n);							\
+	__cu_len = __invoke_copy_to_user_dma(__cu_to, __cu_from, __cu_len); \
+	__cu_len;							\
+})
+#else
 #define __copy_to_user_inatomic(to, from, n)				\
 ({									\
 	void __user *__cu_to;						\
@@ -734,6 +769,7 @@
 	__cu_len = __invoke_copy_to_user(__cu_to, __cu_from, __cu_len); \
 	__cu_len;							\
 })
+#endif
 
 #define __copy_from_user_inatomic(to, from, n)				\
 ({									\
@@ -762,6 +798,24 @@
  * Returns number of bytes that could not be copied.
  * On success, this will be zero.
  */
+#ifdef CONFIG_TANGOX
+#define copy_to_user(to, from, n)					\
+({									\
+	void __user *__cu_to;						\
+	const void *__cu_from;						\
+	long __cu_len;							\
+									\
+	__cu_to = (to);							\
+	__cu_from = (from);						\
+	__cu_len = (n);							\
+	if (access_ok(VERIFY_WRITE, __cu_to, __cu_len)) {		\
+		might_fault();						\
+		__cu_len = __invoke_copy_to_user_dma(__cu_to, __cu_from,	\
+						 __cu_len);		\
+	}								\
+	__cu_len;							\
+})
+#else
 #define copy_to_user(to, from, n)					\
 ({									\
 	void __user *__cu_to;						\
@@ -778,6 +832,7 @@
 	}								\
 	__cu_len;							\
 })
+#endif
 
 #define __invoke_copy_from_user(to, from, n)				\
 ({									\
@@ -842,6 +897,22 @@
  * If some data could not be copied, this function will pad the copied
  * data to the requested size using zero bytes.
  */
+#ifdef CONFIG_TANGOX
+#define __copy_from_user(to, from, n)					\
+({									\
+	void *__cu_to;							\
+	const void __user *__cu_from;					\
+	long __cu_len;							\
+									\
+	__cu_to = (to);							\
+	__cu_from = (from);						\
+	__cu_len = (n);							\
+	might_fault();							\
+	__cu_len = __invoke_copy_from_user_dma(__cu_to, __cu_from,		\
+					   __cu_len);			\
+	__cu_len;							\
+})
+#else
 #define __copy_from_user(to, from, n)					\
 ({									\
 	void *__cu_to;							\
@@ -856,6 +927,7 @@
 					   __cu_len);			\
 	__cu_len;							\
 })
+#endif
 
 /*
  * copy_from_user: - Copy a block of data from user space.
@@ -873,6 +945,24 @@
  * If some data could not be copied, this function will pad the copied
  * data to the requested size using zero bytes.
  */
+#ifdef CONFIG_TANGOX
+#define copy_from_user(to, from, n)					\
+({									\
+	void *__cu_to;							\
+	const void __user *__cu_from;					\
+	long __cu_len;							\
+									\
+	__cu_to = (to);							\
+	__cu_from = (from);						\
+	__cu_len = (n);							\
+	if (access_ok(VERIFY_READ, __cu_from, __cu_len)) {		\
+		might_fault();						\
+		__cu_len = __invoke_copy_from_user_dma(__cu_to, __cu_from,	\
+						   __cu_len);		\
+	}								\
+	__cu_len;							\
+})
+#else
 #define copy_from_user(to, from, n)					\
 ({									\
 	void *__cu_to;							\
@@ -889,6 +979,7 @@
 	}								\
 	__cu_len;							\
 })
+#endif
 
 #define __copy_in_user(to, from, n)					\
 ({									\
@@ -905,6 +996,25 @@
 	__cu_len;							\
 })
 
+#ifdef CONFIG_TANGOX
+#define copy_in_user(to, from, n)					\
+({									\
+	void __user *__cu_to;						\
+	const void __user *__cu_from;					\
+	long __cu_len;							\
+									\
+	__cu_to = (to);							\
+	__cu_from = (from);						\
+	__cu_len = (n);							\
+	if (likely(access_ok(VERIFY_READ, __cu_from, __cu_len) &&	\
+		   access_ok(VERIFY_WRITE, __cu_to, __cu_len))) {	\
+		might_fault();						\
+		__cu_len = __invoke_copy_from_user_dma(__cu_to, __cu_from,	\
+						   __cu_len);		\
+	}								\
+	__cu_len;							\
+})
+#else
 #define copy_in_user(to, from, n)					\
 ({									\
 	void __user *__cu_to;						\
@@ -922,6 +1032,7 @@
 	}								\
 	__cu_len;							\
 })
+#endif
 
 /*
  * __clear_user: - Zero a block of memory in user space, with less checking.
diff -Naur linux-3.9.2.ref/arch/mips/Kbuild.platforms linux-3.9.2/arch/mips/Kbuild.platforms
--- linux-3.9.2.ref/arch/mips/Kbuild.platforms	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/arch/mips/Kbuild.platforms	2013-07-23 19:31:22.000000000 +0200
@@ -28,6 +28,7 @@
 platforms += sgi-ip32
 platforms += sibyte
 platforms += sni
+platforms += tangox
 platforms += txx9
 platforms += vr41xx
 platforms += wrppmc
diff -Naur linux-3.9.2.ref/arch/mips/Kconfig linux-3.9.2/arch/mips/Kconfig
--- linux-3.9.2.ref/arch/mips/Kconfig	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/arch/mips/Kconfig	2013-07-23 19:31:22.000000000 +0200
@@ -689,6 +689,24 @@
 	  Technology and now in turn merged with Fujitsu.  Say Y here to
 	  support this machine type.
 
+config TANGOX
+	bool "Sigma Designs TangoX chips/boards"
+	select BOOT_RAW
+	select CEVT_R4K
+#	select CSRC_R4K
+ 	select CRYPTO_SHA1
+	select DMA_NONCOHERENT
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_HAS_CPU_MIPS32_R2
+	select SYS_SUPPORTS_HIGHMEM
+	select OWN_DMA
+	select DMA_TANGOX
+	select ZONE_DMA
+	help
+	  Enable the support for Sigma Designs chips/boards. 
+
 config MACH_TX39XX
 	bool "Toshiba TX39 series based machines"
 
@@ -850,6 +868,7 @@
 source "arch/mips/ralink/Kconfig"
 source "arch/mips/sgi-ip27/Kconfig"
 source "arch/mips/sibyte/Kconfig"
+source "arch/mips/tangox/Kconfig"
 source "arch/mips/txx9/Kconfig"
 source "arch/mips/vr41xx/Kconfig"
 source "arch/mips/cavium-octeon/Kconfig"
@@ -948,6 +967,10 @@
 config DMA_COHERENT
 	bool
 
+config DMA_TANGOX
+	bool
+	select NEED_DMA_MAP_STATE
+
 config DMA_NONCOHERENT
 	bool
 	select NEED_DMA_MAP_STATE
@@ -1155,6 +1178,8 @@
 	default "4" if MACH_DECSTATION || MIKROTIK_RB532 || PMC_MSP4200_EVAL
 	default "6" if MIPS_CPU_SCACHE
 	default "7" if SGI_IP22 || SGI_IP27 || SGI_IP28 || SNI_RM || CPU_CAVIUM_OCTEON
+	default "4" if TANGO2
+	default "5" if TANGO3 && !MIPS_CPU_SCACHE
 	default "5"
 
 config HAVE_STD_PC_SERIAL_PORT
diff -Naur linux-3.9.2.ref/arch/mips/kernel/cevt-r4k.c linux-3.9.2/arch/mips/kernel/cevt-r4k.c
--- linux-3.9.2.ref/arch/mips/kernel/cevt-r4k.c	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/arch/mips/kernel/cevt-r4k.c	2013-07-23 19:31:23.000000000 +0200
@@ -11,12 +11,36 @@
 #include <linux/percpu.h>
 #include <linux/smp.h>
 #include <linux/irq.h>
+#include <linux/export.h>
 
 #include <asm/smtc_ipi.h>
 #include <asm/time.h>
 #include <asm/cevt-r4k.h>
 #include <asm/gic.h>
 
+#ifdef CONFIG_TANGOX
+#if defined(CONFIG_TANGO2)
+#include <asm/tango2/tango2.h>
+#include <asm/tango2/tango2_gbus.h>
+#include <asm/tango2/emhwlib_registers_tango2.h>
+#include <asm/tango3/emhwlib_lram_others.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/tango3.h>
+#include <asm/tango3/tango3_gbus.h>
+#include <asm/tango3/emhwlib_registers_tango3.h>
+#include <asm/tango3/emhwlib_lram_tango3.h>
+#endif
+void reset_timer(unsigned long cpu, unsigned long sys, unsigned long pll, unsigned long premux, unsigned long mux);
+extern unsigned long tangox_get_cpuclock(void);
+extern unsigned long tangox_get_sysclock(void);
+extern unsigned long em8xxx_cpu_frequency;
+extern unsigned long em8xxx_sys_frequency;
+extern unsigned long em8xxx_sys_clkgen_pll;
+extern unsigned long em8xxx_sys_premux;
+extern unsigned long em8xxx_sys_mux;
+extern unsigned long orig_cpu_freq;
+#endif /* CONFIG_TANGOX */
+
 /*
  * The SMTC Kernel for the 34K, 1004K, et. al. replaces several
  * of these routines with SMTC-specific variants.
@@ -55,6 +79,31 @@
 	const int r2 = cpu_has_mips_r2;
 	struct clock_event_device *cd;
 	int cpu = smp_processor_id();
+#ifdef CONFIG_TANGOX
+	static unsigned long last_jiffies = ((unsigned long)(unsigned int)(-600*HZ));
+#ifndef CONFIG_TANGOX_FIXED_FREQUENCIES
+	unsigned long clkgen_pll = gbus_read_reg32(REG_BASE_system_block + SYS_clkgen_pll);
+	unsigned long premux = gbus_read_reg32(REG_BASE_system_block + SYS_sysclk_premux) & 0x3;
+	unsigned long mux = gbus_read_reg32(REG_BASE_system_block + SYS_sysclk_mux) & 0xf01;
+#endif
+
+	if (time_after(jiffies, last_jiffies + HZ)) { 
+		last_jiffies = jiffies;
+		/* Update heart beat counter */
+		gbus_write_reg32(REG_BASE_cpu_block + LR_HB_CPU,
+				gbus_read_reg32(REG_BASE_cpu_block + LR_HB_CPU) + 1);
+#if defined(CONFIG_PRINTK_TIME)
+//		printk("*** time marker *** (0x%08x)\n", gbus_read_reg32(REG_BASE_system_block + SYS_xtal_in_cnt));
+#endif
+	}
+
+#ifndef CONFIG_TANGOX_FIXED_FREQUENCIES
+	if ((em8xxx_sys_clkgen_pll != clkgen_pll) || (em8xxx_sys_premux != premux) || (em8xxx_sys_mux != mux)) {
+		/* Detected potential CPU/System frequency change */
+		reset_timer(tangox_get_cpuclock(), tangox_get_sysclock(), clkgen_pll, premux, mux);
+        }
+#endif
+#endif /* CONFIG_TANGOX */
 
 	/*
 	 * Suckage alert:
@@ -219,3 +268,34 @@
 }
 
 #endif /* Not CONFIG_MIPS_MT_SMTC */
+
+#ifdef CONFIG_TANGOX
+#ifndef CONFIG_TANGOX_FIXED_FREQUENCIES
+void reset_timer(unsigned long cpuf, unsigned long sysf, unsigned long pll, unsigned long premux, unsigned long mux)
+{
+	unsigned int cpu = smp_processor_id();
+	struct clock_event_device *cd;
+	unsigned long flags;
+
+	printk("Detected frequency changed ...\n");
+
+	em8xxx_sys_clkgen_pll = pll;
+	em8xxx_sys_premux = premux;
+	em8xxx_sys_mux = mux;
+        em8xxx_cpu_frequency = cpuf;
+        em8xxx_sys_frequency = sysf;
+
+	local_irq_save(flags);
+        mips_hpt_frequency = em8xxx_cpu_frequency / 2;
+	cd = &per_cpu(mips_clockevent_device, cpu);
+	clockevents_set_mode(cd, CLOCK_EVT_MODE_SHUTDOWN);
+	cd->mult	= div_sc((unsigned long)mips_hpt_frequency, NSEC_PER_SEC, 32);
+	cd->max_delta_ns	= clockevent_delta2ns(0x7fffffff, cd);
+	cd->min_delta_ns	= clockevent_delta2ns(0x300, cd);
+	local_irq_restore(flags);
+	clockevents_set_mode(cd, CLOCK_EVT_MODE_ONESHOT);
+}
+EXPORT_SYMBOL(reset_timer);
+#endif
+#endif /* CONFIG_TANGOX */
+
diff -Naur linux-3.9.2.ref/arch/mips/kernel/head.S linux-3.9.2/arch/mips/kernel/head.S
--- linux-3.9.2.ref/arch/mips/kernel/head.S	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/arch/mips/kernel/head.S	2013-07-23 19:31:23.000000000 +0200
@@ -130,7 +130,7 @@
 
 EXPORT(_stext)
 
-#ifdef CONFIG_BOOT_RAW
+#if defined(CONFIG_BOOT_RAW)
 	/*
 	 * Give us a fighting chance of running if execution beings at the
 	 * kernel load address.	 This is needed because this platform does
@@ -140,6 +140,12 @@
 	j	kernel_entry
 #endif
 
+#if defined(CONFIG_TANGOX)
+	/* Creating some buffer for power management purpose */
+	/* Mark 16KB off the starting point */
+	.org 0x4000
+#endif
+
 	__REF
 
 NESTED(kernel_entry, 16, sp)			# kernel entry point
diff -Naur linux-3.9.2.ref/arch/mips/kernel/proc.c linux-3.9.2/arch/mips/kernel/proc.c
--- linux-3.9.2.ref/arch/mips/kernel/proc.c	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/arch/mips/kernel/proc.c	2013-07-23 19:31:23.000000000 +0200
@@ -111,6 +111,21 @@
 	seq_printf(m, fmt, 'I', vcei_count);
 	seq_printf(m, "\n");
 
+#ifdef CONFIG_TANGOX
+	{
+		extern unsigned long tangox_get_cpuclock(void);
+		extern unsigned long tangox_get_sysclock(void);
+		extern unsigned long tangox_get_dspclock(void);
+		extern unsigned long tangox_chip_id(void);
+		unsigned long chip_id = (tangox_chip_id() >> 16) & 0xffff;
+		unsigned long chip_rev = tangox_chip_id() & 0xff;
+		seq_printf(m, "SMP8XXX Chip ID\t\t: %lx\n", chip_id);
+		seq_printf(m, "SMP8XXX Rev ID\t\t: %lx\n", chip_rev);
+		seq_printf(m, "System bus frequency\t: %ld Hz\n", tangox_get_sysclock());
+		seq_printf(m, "CPU frequency\t\t: %ld Hz\n", tangox_get_cpuclock());
+		seq_printf(m, "DSP frequency\t\t: %ld Hz\n", tangox_get_dspclock());
+	}
+#endif
 	return 0;
 }
 
diff -Naur linux-3.9.2.ref/arch/mips/kernel/setup.c linux-3.9.2/arch/mips/kernel/setup.c
--- linux-3.9.2.ref/arch/mips/kernel/setup.c	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/arch/mips/kernel/setup.c	2013-07-23 19:31:23.000000000 +0200
@@ -34,6 +34,19 @@
 #include <asm/smp-ops.h>
 #include <asm/prom.h>
 
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/rmdefs.h>
+#include <asm/tango2/memcfg.h>
+#include <asm/tango2/tango2.h>
+#include <asm/tango2/hardware.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/rmdefs.h>
+#include <asm/tango3/tango3.h>
+#include <asm/tango3/hardware.h>
+#include "../tangox/xenv.h"
+#include "../tangox/xenvkeys.h"
+#endif
+
 struct cpuinfo_mips cpu_data[NR_CPUS] __read_mostly;
 
 EXPORT_SYMBOL(cpu_data);
@@ -74,6 +87,8 @@
 const unsigned long mips_io_port_base = -1;
 EXPORT_SYMBOL(mips_io_port_base);
 
+extern void * __rd_start, * __rd_end;
+
 static struct resource code_resource = { .name = "Kernel code", };
 static struct resource data_resource = { .name = "Kernel data", };
 
@@ -184,6 +199,11 @@
 {
 	unsigned long end;
 
+	if ((!initrd_start) && (&__rd_start != &__rd_end)) {
+		initrd_start = (unsigned long)&__rd_start;
+		initrd_end = (unsigned long)&__rd_end;
+	}
+
 	/*
 	 * Board specific code or command line parser should have
 	 * already set up initrd_start and initrd_end. In these cases
@@ -331,7 +351,6 @@
 	/*
 	 * Determine low and high memory ranges
 	 */
-	max_pfn = max_low_pfn;
 	if (max_low_pfn > PFN_DOWN(HIGHMEM_START)) {
 #ifdef CONFIG_HIGHMEM
 		highstart_pfn = PFN_DOWN(HIGHMEM_START);
@@ -339,6 +358,8 @@
 #endif
 		max_low_pfn = PFN_DOWN(HIGHMEM_START);
 	}
+	/* Propagate final value of max_low_pfn to max_pfn */
+	max_pfn = max_low_pfn;
 
 	/*
 	 * Initialize the boot-time allocator with low memory only.
@@ -460,6 +481,14 @@
 static int __init early_parse_mem(char *p)
 {
 	unsigned long start, size;
+#ifdef CONFIG_TANGOX
+        extern unsigned long em8xxx_kmem_start;
+        extern unsigned long em8xxx_kmem_size;
+#ifdef CONFIG_HIGHMEM
+	extern unsigned long em8xxx_himem_start;
+	extern unsigned long em8xxx_himem_size;
+#endif
+#endif
 
 	/*
 	 * If a user specifies memory size, we
@@ -474,8 +503,33 @@
 	size = memparse(p, &p);
 	if (*p == '@')
 		start = memparse(p + 1, &p);
+	else {
+#ifdef CONFIG_TANGOX
+		start = CPHYSADDR(em8xxx_kmem_start);
+#else
+		start = 0;
+#endif
+        }
 
+#ifdef CONFIG_TANGOX
+	printk("parsing kernel command line for memory options ..\n");
+	if (start == CPHYSADDR(em8xxx_kmem_start)) {
+		void tangox_mem_setup(unsigned long size);
+		tangox_mem_setup(size);
+		add_memory_region(start, em8xxx_kmem_size, BOOT_MEM_RAM);
+	} else {
+		/* We just add this blindly as the alignment can be wrong, use it as own risk */
+		add_memory_region(start, size, BOOT_MEM_RAM);
+	}
+#ifdef CONFIG_HIGHMEM
+	if ((em8xxx_himem_start != 0) && (em8xxx_himem_size != 0)) {
+		add_memory_region(em8xxx_himem_start, em8xxx_himem_size, BOOT_MEM_RAM);
+		printk("adding [0x%08lx..0x%08lx) as highmem area.\n", em8xxx_himem_start, em8xxx_himem_start + em8xxx_himem_size);
+	}
+#endif
+#else
 	add_memory_region(start, size, BOOT_MEM_RAM);
+#endif 
 	return 0;
 }
 early_param("mem", early_parse_mem);
diff -Naur linux-3.9.2.ref/arch/mips/kernel/traps.c linux-3.9.2/arch/mips/kernel/traps.c
--- linux-3.9.2.ref/arch/mips/kernel/traps.c	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/arch/mips/kernel/traps.c	2013-07-23 19:31:23.000000000 +0200
@@ -56,6 +56,16 @@
 #include <asm/stacktrace.h>
 #include <asm/uasm.h>
 
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/emhwlib_registers_tango2.h>
+#include <asm/tango2/emhwlib_dram_tango2.h>
+#include <asm/tango2/hardware.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/emhwlib_registers_tango3.h>
+#include <asm/tango3/emhwlib_dram_tango3.h>
+#include <asm/tango3/hardware.h>
+#endif
+
 extern void check_wait(void);
 extern asmlinkage void r4k_wait(void);
 extern asmlinkage void rollback_handle_int(void);
@@ -1579,6 +1589,15 @@
 	change_c0_status(ST0_CU|ST0_MX|ST0_RE|ST0_FR|ST0_BEV|ST0_TS|ST0_KX|ST0_SX|ST0_UX,
 			 status_set);
 
+#ifdef CONFIG_TANGOX
+#if defined(CONFIG_TANGO3)
+	ebase = KSEG0ADDR(CPU_REMAP_SPACE);
+#else
+	ebase = KSEG0ADDR(MEM_BASE_dram_controller_0 + FM_RESERVED);
+#endif
+	write_c0_ebase(ebase);
+#endif
+
 	if (cpu_has_mips_r2)
 		hwrena |= 0x0000000f;
 
@@ -1625,6 +1644,10 @@
 		cp0_compare_irq_shift = CP0_LEGACY_PERFCNT_IRQ;
 		cp0_perfcount_irq = -1;
 	}
+#ifdef CONFIG_TANGO2
+	cp0_compare_irq = 7; /* hard-wired, cannot be checked by c0_intctl */
+	cp0_perfcount_irq = -1; /* no perfcount_irq */
+#endif
 
 #ifdef CONFIG_MIPS_MT_SMTC
 	}
diff -Naur linux-3.9.2.ref/arch/mips/kernel/unaligned.c linux-3.9.2/arch/mips/kernel/unaligned.c
--- linux-3.9.2.ref/arch/mips/kernel/unaligned.c	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/arch/mips/kernel/unaligned.c	2013-07-23 19:31:23.000000000 +0200
@@ -116,6 +116,32 @@
 	 */
 	__get_user(insn.word, pc);
 
+#if defined(CONFIG_TANGO3_864X)
+	/*
+	  fix DSP r2 lhx and lwx too. see MD00374 page 131 (works on 74K only; on 24K you don't get AdEL but RI!)
+
+	  verified with
+	  
+	  *iptr=0x42434445;
+	  
+	  int q=0xffffffff;
+	  asm __volatile__(".set dspr2; lhx %0, $0(%1)":"=&r"(q):"r"(iptr));
+	  printf("0x%08lx\n",q);
+	  asm __volatile__(".set dspr2; lwx %0, $0(%1)":"=&r"(q):"r"(iptr));
+	  printf("0x%08lx\n",q);
+	*/
+	if ((insn.r_format.opcode==31)
+	    &&(insn.r_format.func==10)) {
+		// cheat the destination
+		insn.i_format.rt=insn.r_format.rd;
+		// cheat the function
+		if (insn.r_format.re==0)
+			insn.i_format.opcode=lw_op;
+		if (insn.r_format.re==4)
+			insn.i_format.opcode=lh_op;
+	}
+#endif
+	
 	switch (insn.i_format.opcode) {
 	/*
 	 * These are instructions that a compiler doesn't generate.  We
diff -Naur linux-3.9.2.ref/arch/mips/kernel/vmlinux.lds.S linux-3.9.2/arch/mips/kernel/vmlinux.lds.S
--- linux-3.9.2.ref/arch/mips/kernel/vmlinux.lds.S	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/arch/mips/kernel/vmlinux.lds.S	2013-07-23 19:31:23.000000000 +0200
@@ -86,6 +86,14 @@
 		CACHELINE_ALIGNED_DATA(1 << CONFIG_MIPS_L1_CACHE_SHIFT)
 		READ_MOSTLY_DATA(1 << CONFIG_MIPS_L1_CACHE_SHIFT)
 		DATA_DATA
+
+		/* Align the initial ramdisk image (INITRD) on page boundaries. */
+		. = ALIGN(_PAGE_SIZE);
+		__rd_start = .;
+		*(.initrd)
+		. = ALIGN(_PAGE_SIZE);
+		__rd_end = .;
+
 		CONSTRUCTORS
 	}
 	_gp = . + 0x8000;
diff -Naur linux-3.9.2.ref/arch/mips/lib/archop_cw.c linux-3.9.2/arch/mips/lib/archop_cw.c
--- linux-3.9.2.ref/arch/mips/lib/archop_cw.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/lib/archop_cw.c	2013-07-23 19:31:22.000000000 +0200
@@ -0,0 +1,68 @@
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/bitops.h>
+
+#include <asm/bcache.h>
+#include <asm/bootinfo.h>
+#include <asm/cache.h>
+#include <asm/cacheops.h>
+#include <asm/cpu.h>
+#include <asm/cpu-features.h>
+#include <asm/io.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <asm/r4kcache.h>
+#include <asm/mmu_context.h>
+#include <asm/war.h>
+#include <asm/cacheflush.h> /* for run_uncached() */
+
+// those are left un-documented and have many bizarre requirements. read the ASM. loopCnt is cache lines + 2. 
+void mips_memcopy_std(int *p_src, int *p_dst, int loopCnt);
+void mips_memcopy_std_ua(int *p_uasrc, int *p_dst, int loopCnt);
+void mips_memset(int v,int *p_dst, int loopCnt);
+size_t mips_memcmp(int *p_src, int *p_dst, int loopCnt);
+size_t mips_memcmp_ua(int *p_uasrc, int *p_dst, int loopCnt);
+size_t mips_strnlen(int *p_src, int loopCnt); // return non-zero means found
+size_t mips_strnlen_c(int *p_src,int v, int loopCnt); // return non-zero means found
+void mips_hhblend(int *p_src0,int *p_src1, int *p_dst, int loopCnt);
+
+size_t __strnlen_user_nocheck_asm_alt(const char *s, size_t maxlen)
+{
+	char *src=(void *)s;
+	int n=maxlen;
+	int lines;
+
+	// word align src
+
+	while ((n>0)&&((int)src&3)) {
+		if (*src==0)
+			return maxlen-n;
+		n--;
+		src++;
+	}
+	
+	// do as many lines as possible
+
+	lines=n>>5;
+	if (lines>0) {
+		int l;
+		
+		l=lines-mips_strnlen((int *)src,lines-1);
+
+		src+=l<<5; 
+		n-=l<<5;
+	}
+	
+	// finish quietly
+
+	while (n>0) {
+		if (*src==0)
+			return maxlen-n;
+		n--;
+		src++;
+	}
+	
+	return maxlen;
+}
diff -Naur linux-3.9.2.ref/arch/mips/lib/archop_mips.S linux-3.9.2/arch/mips/lib/archop_mips.S
--- linux-3.9.2.ref/arch/mips/lib/archop_mips.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/lib/archop_mips.S	2013-07-23 19:31:22.000000000 +0200
@@ -0,0 +1,71 @@
+#include <asm/asm.h>
+#include <asm/asm-offsets.h>
+#include <asm/regdef.h>
+
+.set noat
+.set noreorder
+	
+/* size_t mips_strnlen(int *p_src, int loopCnt); */
+LEAF(mips_strnlen)
+
+	move	a2, $0
+
+	li	v0, 0x80808080 
+	li	v1, 0xfefefeff # nice trick, google on it
+	
+	pref	0, 0x0(a0)	# bring the first line of src
+	pref	0, 0x20(a0)	# bring the first line of src
+	pref	0, 0x40(a0)	# bring the first line of src
+1:
+	pref	0, 0x60(a0)	# bring the next lines of src
+
+	lw 	t0, 0x0(a0)
+	addu	t0, v1
+	and	t0, v0
+	addu	a2, t0
+
+	lw 	t1, 0x4(a0)
+	addu	t1, v1
+	and	t1, v0
+	addu	a2, t1
+
+	lw 	t2, 0x8(a0)
+	addu	t2, v1
+	and	t2, v0
+	addu	a2, t2
+
+	lw 	t3, 0xc(a0)
+	addu	t3, v1
+	and	t3, v0
+	addu	a2, t3
+
+	lw 	t0, 0x10(a0)
+	addu	t0, v1
+	and	t0, v0
+	addu	a2, t0
+
+	lw 	t1, 0x14(a0)
+	addu	t1, v1
+	and	t1, v0
+	addu	a2, t1
+
+	lw 	t2, 0x18(a0)
+	addu	t2, v1
+	and	t2, v0
+	addu	a2, t2
+
+	lw 	t3, 0x1c(a0)
+	addu	t3, v1
+	and	t3, v0
+	addu	a2, t3
+
+	bnez	a2, 2f
+	addu	a0, 0x20
+
+	bnez	a1, 1b
+	subu    a1, 1
+
+2:	
+	jr	ra
+	addu	v0, a1, 1
+END(mips_strnlen)
diff -Naur linux-3.9.2.ref/arch/mips/lib/iomap-pci.c linux-3.9.2/arch/mips/lib/iomap-pci.c
--- linux-3.9.2.ref/arch/mips/lib/iomap-pci.c	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/arch/mips/lib/iomap-pci.c	2013-07-23 19:31:22.000000000 +0200
@@ -10,12 +10,23 @@
 #include <linux/module.h>
 #include <asm/io.h>
 
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/hardware.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/hardware.h>
+#endif
+
 void __iomem *__pci_ioport_map(struct pci_dev *dev,
 			       unsigned long port, unsigned int nr)
 {
 	struct pci_controller *ctrl = dev->bus->sysdata;
 	unsigned long base = ctrl->io_map_base;
 
+#ifdef CONFIG_TANGOX
+	/* some quirk for TangoX */
+	port = (port >= MEMORY_BASE_PCI_IO) ? (port - MEMORY_BASE_PCI_IO) : port;
+#endif
+
 	/* This will eventually become a BUG_ON but for now be gentle */
 	if (unlikely(!ctrl->io_map_base)) {
 		struct pci_bus *bus = dev->bus;
diff -Naur linux-3.9.2.ref/arch/mips/lib/Makefile linux-3.9.2/arch/mips/lib/Makefile
--- linux-3.9.2.ref/arch/mips/lib/Makefile	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/arch/mips/lib/Makefile	2013-07-23 19:31:22.000000000 +0200
@@ -6,6 +6,8 @@
 	   mips-atomic.o strlen_user.o strncpy_user.o \
 	   strnlen_user.o uncached.o
 
+obj-$(CONFIG_TANGO3) += archop_mips.o archop_cw.o
+
 obj-y			+= iomap.o
 obj-$(CONFIG_PCI)	+= iomap-pci.o
 
diff -Naur linux-3.9.2.ref/arch/mips/lib/memcpy.S linux-3.9.2/arch/mips/lib/memcpy.S
--- linux-3.9.2.ref/arch/mips/lib/memcpy.S	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/arch/mips/lib/memcpy.S	2013-07-23 19:31:22.000000000 +0200
@@ -197,7 +197,11 @@
  * memcpy sets v0 to dst.
  */
 	.align	5
+#ifdef CONFIG_TANGOX
+LEAF(memcpy_original)				/* a0=dst a1=src a2=len */
+#else
 LEAF(memcpy)					/* a0=dst a1=src a2=len */
+#endif
 	move	v0, dst				/* return value */
 .L__memcpy:
 FEXPORT(__copy_user)
@@ -238,10 +242,21 @@
 	 SRL	t0, len, LOG_NBYTES+3	 # +3 for 8 units/iter
 	beqz	t0, .Lcleanup_both_aligned # len < 8*NBYTES
 	 and	rem, len, (8*NBYTES-1)	 # rem = len % (8*NBYTES)
+#if !defined(CONFIG_TANGO3)
 	PREF(	0, 3*32(src) )
 	PREF(	1, 3*32(dst) )
 	.align	4
+#else
+	# len>=32, but is it <64?
+	SUB     t0, len, 64
+	bltz    t0, 2f
+	SUB     len, 32
+#endif
 1:
+#if defined(CONFIG_TANGO3)
+	pref    0,  0x60(src)
+	pref    30, 0x20(dst) # we assume dst is 0x20-aligned, not sure
+#endif
 	R10KCBARRIER(0(ra))
 EXC(	LOAD	t0, UNIT(0)(src),	.Ll_exc)
 EXC(	LOAD	t1, UNIT(1)(src),	.Ll_exc_copy)
@@ -262,11 +277,35 @@
 EXC(	STORE	t7, UNIT(-3)(dst),	.Ls_exc_p3u)
 EXC(	STORE	t0, UNIT(-2)(dst),	.Ls_exc_p2u)
 EXC(	STORE	t1, UNIT(-1)(dst),	.Ls_exc_p1u)
+#if !defined(CONFIG_TANGO3)
 	PREF(	0, 8*32(src) )
 	PREF(	1, 8*32(dst) )
+#endif
 	bne	len, rem, 1b
 	 nop
 
+#if defined(CONFIG_TANGO3)
+2:
+EXC(    LOAD    t0, UNIT(0)(src),       .Ll_exc)
+EXC(    LOAD    t1, UNIT(1)(src),       .Ll_exc_copy)
+EXC(    LOAD    t2, UNIT(2)(src),       .Ll_exc_copy)
+EXC(    LOAD    t3, UNIT(3)(src),       .Ll_exc_copy)
+EXC(    LOAD    t4, UNIT(4)(src),       .Ll_exc_copy)
+EXC(    LOAD    t7, UNIT(5)(src),       .Ll_exc_copy)
+EXC(    STORE   t0, UNIT(0)(dst),       .Ls_exc_p8u)
+EXC(    STORE   t1, UNIT(1)(dst),       .Ls_exc_p7u)
+EXC(    LOAD    t0, UNIT(6)(src),       .Ll_exc_copy)
+EXC(    LOAD    t1, UNIT(7)(src),       .Ll_exc_copy)
+        ADD     src, src, 8*NBYTES
+        ADD     dst, dst, 8*NBYTES
+EXC(    STORE   t2, UNIT(-6)(dst),      .Ls_exc_p6u)
+EXC(    STORE   t3, UNIT(-5)(dst),      .Ls_exc_p5u)
+EXC(    STORE   t4, UNIT(-4)(dst),      .Ls_exc_p4u)
+EXC(    STORE   t7, UNIT(-3)(dst),      .Ls_exc_p3u)
+EXC(    STORE   t0, UNIT(-2)(dst),      .Ls_exc_p2u)
+EXC(    STORE   t1, UNIT(-1)(dst),      .Ls_exc_p1u)
+#endif
+
 	/*
 	 * len == rem == the number of bytes left to copy < 8*NBYTES
 	 */
@@ -438,7 +477,11 @@
 .Ldone:
 	jr	ra
 	 nop
+#ifdef CONFIG_TANGOX
+	END(memcpy_original)
+#else
 	END(memcpy)
+#endif
 
 .Ll_exc_copy:
 	/*
diff -Naur linux-3.9.2.ref/arch/mips/lib/memset.S linux-3.9.2/arch/mips/lib/memset.S
--- linux-3.9.2.ref/arch/mips/lib/memset.S	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/arch/mips/lib/memset.S	2013-07-23 19:31:22.000000000 +0200
@@ -101,14 +101,28 @@
 	beqz		t1, .Lmemset_partial	/* no block to fill */
 	 andi		t0, a2, 0x40-LONGSIZE
 
+#if defined(CONFIG_TANGO3)
+	subu    t1, 0x40 # distinguish one or >=2 blocks: pref 30 is destructive
+	beqz    t1, 2f
+#endif
+
 	PTR_ADDU	t1, a0			/* end address */
 	.set		reorder
 1:	PTR_ADDIU	a0, 64
+#if defined(CONFIG_TANGO3)
+	pref 30, 0(a0) # we assume a0 is 0x20-aligned
+	pref 30, 32(a0)
+#endif
 	R10KCBARRIER(0(ra))
 	f_fill64 a0, -64, a1, .Lfwd_fixup
 	bne		t1, a0, 1b
 	.set		noreorder
 
+#if defined(CONFIG_TANGO3)
+2:	PTR_ADDIU       a0, 64
+	f_fill64 a0, -64, a1, .Lfwd_fixup
+#endif
+
 .Lmemset_partial:
 	R10KCBARRIER(0(ra))
 	PTR_LA		t1, 2f			/* where to start */
diff -Naur linux-3.9.2.ref/arch/mips/Makefile linux-3.9.2/arch/mips/Makefile
--- linux-3.9.2.ref/arch/mips/Makefile	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/arch/mips/Makefile	2013-07-23 19:31:22.000000000 +0200
@@ -18,7 +18,7 @@
 # Select the object file format to substitute into the linker script.
 #
 ifdef CONFIG_CPU_LITTLE_ENDIAN
-32bit-tool-archpref	= mipsel
+32bit-tool-archpref	= mipsel-oe-linux
 64bit-tool-archpref	= mips64el
 32bit-bfd		= elf32-tradlittlemips
 64bit-bfd		= elf64-tradlittlemips
@@ -274,6 +274,25 @@
 
 all:	$(all-y)
 
+ifdef CONFIG_TANGOX
+
+makeboot =$(Q)$(MAKE) $(build)=arch/mips/boot VMLINUX=$(vmlinux-32) $(1) loadaddr=$(2) certtype=$(3) certid=$(4)
+
+sigma.bin vmlinux.bin vmlinux.ecoff vmlinux.srec: $(vmlinux-32) FORCE
+	+@$(call makeboot,$@)
+
+ifdef CONFIG_TANGO2
+zbimage-linux-xload: sigma.bin
+	+@$(call makeboot,$@,$(load-y),$(CERT_TYPE),$(CERT_ID))
+
+endif
+
+ifdef CONFIG_TANGO3
+zbimage-linux-xload: sigma.bin
+	+@$(call makeboot,$@,$(load-y),$(CERT_TYPE),$(CERT_ID))
+endif
+
+else
 # boot
 vmlinux.bin vmlinux.ecoff vmlinux.srec: $(vmlinux-32) FORCE
 	$(Q)$(MAKE) $(build)=arch/mips/boot VMLINUX=$(vmlinux-32) arch/mips/boot/$@
@@ -282,7 +301,7 @@
 vmlinuz vmlinuz.bin vmlinuz.ecoff vmlinuz.srec: $(vmlinux-32) FORCE
 	$(Q)$(MAKE) $(build)=arch/mips/boot/compressed \
 	   VMLINUX_LOAD_ADDRESS=$(load-y) 32bit-bfd=$(32bit-bfd) $@
-
+endif
 
 CLEAN_FILES += vmlinux.32 vmlinux.64
 
diff -Naur linux-3.9.2.ref/arch/mips/mm/cache.c linux-3.9.2/arch/mips/mm/cache.c
--- linux-3.9.2.ref/arch/mips/mm/cache.c	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/arch/mips/mm/cache.c	2013-07-23 19:31:24.000000000 +0200
@@ -30,6 +30,7 @@
 void (*flush_cache_page)(struct vm_area_struct *vma, unsigned long page,
 	unsigned long pfn);
 void (*flush_icache_range)(unsigned long start, unsigned long end);
+void (*flush_icache_page)(struct vm_area_struct *vma, struct page *page);
 void (*local_flush_icache_range)(unsigned long start, unsigned long end);
 
 void (*__flush_cache_vmap)(void);
@@ -57,6 +58,8 @@
 void (*_dma_cache_inv)(unsigned long start, unsigned long size);
 
 EXPORT_SYMBOL(_dma_cache_wback_inv);
+EXPORT_SYMBOL(_dma_cache_wback);
+EXPORT_SYMBOL(_dma_cache_inv);
 
 #endif /* CONFIG_DMA_NONCOHERENT */
 
diff -Naur linux-3.9.2.ref/arch/mips/mm/c-r4k.c linux-3.9.2/arch/mips/mm/c-r4k.c
--- linux-3.9.2.ref/arch/mips/mm/c-r4k.c	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/arch/mips/mm/c-r4k.c	2013-07-23 19:31:24.000000000 +0200
@@ -536,6 +536,12 @@
 	r4k_on_each_cpu(local_r4k_flush_cache_page, &args);
 }
 
+static void r4k_flush_icache_range(unsigned long start, unsigned long end);
+static void r4k_flush_icache_page(struct vm_area_struct *vma, struct page *page)
+{
+	r4k_flush_icache_range((unsigned long)page_address(page), (unsigned long)page_address(page) + PAGE_SIZE);
+}
+
 static inline void local_r4k_flush_data_cache_page(void * addr)
 {
 	r4k_blast_dcache_page((unsigned long) addr);
@@ -1457,6 +1463,7 @@
 	flush_data_cache_page	= r4k_flush_data_cache_page;
 	flush_icache_range	= r4k_flush_icache_range;
 	local_flush_icache_range	= local_r4k_flush_icache_range;
+	flush_icache_page       = r4k_flush_icache_page;
 
 #if defined(CONFIG_DMA_NONCOHERENT)
 	if (coherentio) {
diff -Naur linux-3.9.2.ref/arch/mips/mm/dma-default.c linux-3.9.2/arch/mips/mm/dma-default.c
--- linux-3.9.2.ref/arch/mips/mm/dma-default.c	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/arch/mips/mm/dma-default.c	2013-07-23 19:31:24.000000000 +0200
@@ -22,6 +22,7 @@
 
 #include <dma-coherence.h>
 
+
 static inline struct page *dma_addr_to_page(struct device *dev,
 	dma_addr_t dma_addr)
 {
diff -Naur linux-3.9.2.ref/arch/mips/mm/dma-tangox.c linux-3.9.2/arch/mips/mm/dma-tangox.c
--- linux-3.9.2.ref/arch/mips/mm/dma-tangox.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/mm/dma-tangox.c	2013-07-23 19:31:24.000000000 +0200
@@ -0,0 +1,336 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2000  Ani Joshi <ajoshi@unixbox.com>
+ * Copyright (C) 2000, 2001, 06	 Ralf Baechle <ralf@linux-mips.org>
+ * swiped from i386, and cloned for MIPS by Geert, polished by Ralf.
+ */
+
+#include <linux/types.h>
+#include <linux/dma-mapping.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/scatterlist.h>
+#include <linux/string.h>
+#include <linux/gfp.h>
+#include <linux/highmem.h>
+
+#include <asm/cache.h>
+#include <asm/io.h>
+
+#include <dma-coherence.h>
+
+
+unsigned long pci_virt_to_bus(unsigned long addr)
+{
+	return __pci_virt_to_bus(addr);
+}
+EXPORT_SYMBOL(pci_virt_to_bus);
+
+unsigned long pci_bus_to_virt(unsigned long addr)
+{
+	return __pci_bus_to_virt(addr);
+}
+EXPORT_SYMBOL(pci_bus_to_virt);
+
+
+static inline struct page *dma_addr_to_page(struct device *dev,
+	dma_addr_t dma_addr)
+{
+	return pfn_to_page(
+		plat_dma_addr_to_phys(dev, dma_addr) >> PAGE_SHIFT);
+}
+
+/*
+ * Warning on the terminology - Linux calls an uncached area coherent;
+ * MIPS terminology calls memory areas with hardware maintained coherency
+ * coherent.
+ */
+
+static inline int cpu_is_noncoherent_r10000(struct device *dev)
+{
+	return !plat_device_is_coherent(dev) &&
+	       (current_cpu_type() == CPU_R10000 ||
+	       current_cpu_type() == CPU_R12000);
+}
+
+static gfp_t massage_gfp_flags(const struct device *dev, gfp_t gfp)
+{
+	/* ignore region specifiers */
+	gfp &= ~(__GFP_DMA | __GFP_DMA32 | __GFP_HIGHMEM);
+
+#ifdef CONFIG_ZONE_DMA
+	if (dev == NULL)
+		gfp |= __GFP_DMA;
+	else if (dev->coherent_dma_mask < DMA_BIT_MASK(24))
+		gfp |= __GFP_DMA;
+	else
+#endif
+#ifdef CONFIG_ZONE_DMA32
+	     if (dev->coherent_dma_mask < DMA_BIT_MASK(32))
+		gfp |= __GFP_DMA32;
+	else
+#endif
+		;
+
+	/* Don't invoke OOM killer */
+	gfp |= __GFP_NORETRY;
+
+	return gfp;
+}
+
+void *dma_alloc_noncoherent(struct device *dev, size_t size,
+	dma_addr_t * dma_handle, gfp_t gfp)
+{
+	void *ret;
+
+	gfp = massage_gfp_flags(dev, gfp);
+
+	ret = (void *)__get_free_pages(gfp, get_order(size));
+
+	if (ret != NULL) {
+		memset(ret, 0, size);
+		*dma_handle = plat_map_dma_mem(dev, (void *)virt_to_phys(ret), size);
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(dma_alloc_noncoherent);
+
+static void *mips_dma_alloc_coherent(struct device *dev, size_t size,
+	dma_addr_t * dma_handle, gfp_t gfp, struct dma_attrs *attrs)
+{
+	void *ret;
+
+	ret = dma_alloc_noncoherent(dev, size, dma_handle, gfp);
+	if (ret != NULL) {
+		if (!plat_device_is_coherent(dev)) {
+			dma_cache_wback_inv((unsigned long)ret, size);
+			ret = UNCAC_ADDR(ret);
+		}
+	}
+	return ret;
+}
+
+
+void dma_free_noncoherent(struct device *dev, size_t size, void *vaddr,
+	dma_addr_t dma_handle)
+{
+	plat_unmap_dma_mem(dev, dma_handle, size, DMA_BIDIRECTIONAL);
+	free_pages((unsigned long) vaddr, get_order(size));
+}
+EXPORT_SYMBOL(dma_free_noncoherent);
+
+static void mips_dma_free_coherent(struct device *dev, size_t size, void *vaddr,
+	dma_addr_t dma_handle, struct dma_attrs *attrs)
+{
+	unsigned long addr = (unsigned long)vaddr;
+
+	if (!plat_device_is_coherent(dev))
+		addr = CAC_ADDR(addr);
+	dma_free_noncoherent(dev, size, (void *)addr, dma_handle);
+}
+
+static inline void __dma_sync_virtual(void *addr, size_t size,
+	enum dma_data_direction direction)
+{
+	switch (direction) {
+	case DMA_TO_DEVICE:
+		dma_cache_wback((unsigned long)addr, size);
+		break;
+
+	case DMA_FROM_DEVICE:
+		dma_cache_inv((unsigned long)addr, size);
+		break;
+
+	case DMA_BIDIRECTIONAL:
+		dma_cache_wback_inv((unsigned long)addr, size);
+		break;
+
+	default:
+		BUG();
+	}
+}
+
+/*
+ * A single sg entry may refer to multiple physically contiguous
+ * pages. But we still need to process highmem pages individually.
+ * If highmem is not configured then the bulk of this loop gets
+ * optimized out.
+ */
+static inline void __dma_sync(struct page *page,
+	unsigned long offset, size_t size, enum dma_data_direction direction)
+{
+	size_t left = size;
+
+	do {
+		size_t len = left;
+
+		if (PageHighMem(page)) {
+			void *addr;
+
+			if (offset + len > PAGE_SIZE) {
+				if (offset >= PAGE_SIZE) {
+					page += offset >> PAGE_SHIFT;
+					offset &= ~PAGE_MASK;
+				}
+				len = PAGE_SIZE - offset;
+			}
+
+			addr = kmap_atomic(page);
+			__dma_sync_virtual(addr + offset, len, direction);
+			kunmap_atomic(addr);
+		} else
+			__dma_sync_virtual(page_address(page) + offset,
+					   size, direction);
+		offset = 0;
+		page++;
+		left -= len;
+	} while (left);
+}
+
+static void mips_dma_unmap_page(struct device *dev, dma_addr_t dma_addr,
+	size_t size, enum dma_data_direction direction, struct dma_attrs *attrs)
+{
+
+	if (!plat_device_is_coherent(dev) && direction != DMA_TO_DEVICE) 
+		__dma_sync(dma_addr_to_page(dev, dma_addr), dma_addr & ~PAGE_MASK, size, direction);
+
+	plat_unmap_dma_mem(dev, dma_addr, size, direction);
+}
+
+static int mips_dma_map_sg(struct device *dev, struct scatterlist *sg,
+	int nents, enum dma_data_direction direction, struct dma_attrs *attrs)
+{
+	int i;
+
+	for (i = 0; i < nents; i++, sg++) {
+		if (!plat_device_is_coherent(dev))
+			__dma_sync(sg_page(sg), sg->offset, sg->length,
+				   direction);
+		sg->dma_address = plat_map_dma_mem_page(dev, sg_page(sg)) +
+				  sg->offset;
+	}
+
+	return nents;
+}
+
+static dma_addr_t mips_dma_map_page(struct device *dev, struct page *page,
+	unsigned long offset, size_t size, enum dma_data_direction direction,
+	struct dma_attrs *attrs)
+{
+	if (!plat_device_is_coherent(dev))
+		__dma_sync(page, offset, size, direction);
+
+	return plat_map_dma_mem_page(dev, page) + offset;
+}
+
+static void mips_dma_unmap_sg(struct device *dev, struct scatterlist *sg,
+	int nhwentries, enum dma_data_direction direction,
+	struct dma_attrs *attrs)
+{
+	int i;
+
+	for (i = 0; i < nhwentries; i++, sg++) {
+		if (!plat_device_is_coherent(dev) &&
+		    direction != DMA_TO_DEVICE)
+			__dma_sync(sg_page(sg), sg->offset, sg->length,
+				   direction);
+		plat_unmap_dma_mem(dev, sg->dma_address, sg->length, direction);
+	}
+}
+
+static void mips_dma_sync_single_for_cpu(struct device *dev,
+	dma_addr_t dma_handle, size_t size, enum dma_data_direction direction)
+{
+	if (cpu_is_noncoherent_r10000(dev))
+		__dma_sync(dma_addr_to_page(dev, dma_handle),
+			   dma_handle & ~PAGE_MASK, size, direction);
+}
+
+static void mips_dma_sync_single_for_device(struct device *dev,
+	dma_addr_t dma_handle, size_t size, enum dma_data_direction direction)
+{
+	plat_extra_sync_for_device(dev);
+	if (!plat_device_is_coherent(dev))
+		__dma_sync(dma_addr_to_page(dev, dma_handle),
+			   dma_handle & ~PAGE_MASK, size, direction);
+}
+
+static void mips_dma_sync_sg_for_cpu(struct device *dev,
+	struct scatterlist *sg, int nelems, enum dma_data_direction direction)
+{
+	int i;
+
+	/* Make sure that gcc doesn't leave the empty loop body.  */
+	for (i = 0; i < nelems; i++, sg++) {
+		if (cpu_is_noncoherent_r10000(dev))
+			__dma_sync(sg_page(sg), sg->offset, sg->length,
+				   direction);
+	}
+}
+
+static void mips_dma_sync_sg_for_device(struct device *dev,
+	struct scatterlist *sg, int nelems, enum dma_data_direction direction)
+{
+	int i;
+
+	/* Make sure that gcc doesn't leave the empty loop body.  */
+	for (i = 0; i < nelems; i++, sg++) {
+		if (!plat_device_is_coherent(dev))
+			__dma_sync(sg_page(sg), sg->offset, sg->length,
+				   direction);
+	}
+}
+
+int mips_dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
+{
+	return plat_dma_mapping_error(dev, dma_addr);
+}
+
+int mips_dma_supported(struct device *dev, u64 mask)
+{
+	return plat_dma_supported(dev, mask);
+}
+
+void dma_cache_sync(struct device *dev, void *vaddr, size_t size,
+			 enum dma_data_direction direction)
+{
+	BUG_ON(direction == DMA_NONE);
+
+	plat_extra_sync_for_device(dev);
+	if (!plat_device_is_coherent(dev))
+		__dma_sync_virtual(vaddr, size, direction);
+}
+
+EXPORT_SYMBOL(dma_cache_sync);
+
+static struct dma_map_ops mips_default_dma_map_ops = {
+	.alloc = mips_dma_alloc_coherent,
+	.free = mips_dma_free_coherent,
+	.map_page = mips_dma_map_page,
+	.unmap_page = mips_dma_unmap_page,
+	.map_sg = mips_dma_map_sg,
+	.unmap_sg = mips_dma_unmap_sg,
+	.sync_single_for_cpu = mips_dma_sync_single_for_cpu,
+	.sync_single_for_device = mips_dma_sync_single_for_device,
+	.sync_sg_for_cpu = mips_dma_sync_sg_for_cpu,
+	.sync_sg_for_device = mips_dma_sync_sg_for_device,
+	.mapping_error = mips_dma_mapping_error,
+	.dma_supported = mips_dma_supported
+};
+
+struct dma_map_ops *mips_dma_map_ops = &mips_default_dma_map_ops;
+EXPORT_SYMBOL(mips_dma_map_ops);
+
+#define PREALLOC_DMA_DEBUG_ENTRIES (1 << 16)
+
+static int __init mips_dma_init(void)
+{
+	dma_debug_init(PREALLOC_DMA_DEBUG_ENTRIES);
+
+	return 0;
+}
+fs_initcall(mips_dma_init);
diff -Naur linux-3.9.2.ref/arch/mips/mm/init.c linux-3.9.2/arch/mips/mm/init.c
--- linux-3.9.2.ref/arch/mips/mm/init.c	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/arch/mips/mm/init.c	2013-07-23 19:31:24.000000000 +0200
@@ -43,6 +43,12 @@
 #include <asm/tlb.h>
 #include <asm/fixmap.h>
 
+#if defined(CONFIG_TANGO2)
+#include <asm/tango2/hardware.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/hardware.h>
+#endif
+
 /* Atomicity and interruptability */
 #ifdef CONFIG_MIPS_MT_SMTC
 
@@ -329,6 +335,12 @@
 	unsigned long max_zone_pfns[MAX_NR_ZONES];
 	unsigned long lastpfn __maybe_unused;
 
+#if defined(CONFIG_TANGOX) && defined(CONFIG_PCI)
+	extern unsigned long em8xxx_kmem_start;
+	extern unsigned long em8xxx_kmem_size;
+	extern int tangox_pci_host_enabled(void);
+#endif
+
 	pagetable_init();
 
 #ifdef CONFIG_HIGHMEM
@@ -337,7 +349,13 @@
 	kmap_coherent_init();
 
 #ifdef CONFIG_ZONE_DMA
-	max_zone_pfns[ZONE_DMA] = MAX_DMA_PFN;
+#if defined(CONFIG_TANGOX) && defined(CONFIG_PCI)
+	/* If PCI is used, then limit DMA memory to MAX_PCIMEM_MAP_SIZE if kernel memory is > MAX_PCIMEM_MAP_SIZE */
+	if (tangox_pci_host_enabled() && (em8xxx_kmem_size>(MAX_PCIMEM_MAP_SIZE<<20)))
+		max_zone_pfns[ZONE_DMA] = PFN_DOWN(virt_to_phys((void *)((em8xxx_kmem_start+(MAX_PCIMEM_MAP_SIZE<<20))&0xfff00000)));
+	else
+#endif
+		max_zone_pfns[ZONE_DMA] = MAX_DMA_PFN;
 #endif
 #ifdef CONFIG_ZONE_DMA32
 	max_zone_pfns[ZONE_DMA32] = MAX_DMA32_PFN;
diff -Naur linux-3.9.2.ref/arch/mips/mm/Makefile linux-3.9.2/arch/mips/mm/Makefile
--- linux-3.9.2.ref/arch/mips/mm/Makefile	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/arch/mips/mm/Makefile	2013-07-23 19:31:24.000000000 +0200
@@ -2,7 +2,7 @@
 # Makefile for the Linux/MIPS-specific parts of the memory manager.
 #
 
-obj-y				+= cache.o dma-default.o extable.o fault.o \
+obj-y				+= cache.o extable.o fault.o \
 				   gup.o init.o mmap.o page.o page-funcs.o \
 				   tlbex.o tlbex-fault.o uasm.o
 
@@ -22,3 +22,10 @@
 obj-$(CONFIG_R5000_CPU_SCACHE)	+= sc-r5k.o
 obj-$(CONFIG_RM7000_CPU_SCACHE) += sc-rm7k.o
 obj-$(CONFIG_MIPS_CPU_SCACHE)	+= sc-mips.o
+
+ifdef CONFIG_DMA_TANGOX
+obj-y   += dma-tangox.o
+else
+obj-y   += dma-default.o
+endif
+
diff -Naur linux-3.9.2.ref/arch/mips/pci/fixup-tangox.c linux-3.9.2/arch/mips/pci/fixup-tangox.c
--- linux-3.9.2.ref/arch/mips/pci/fixup-tangox.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/pci/fixup-tangox.c	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,59 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+ *********************************************************************/
+
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/hardware.h>
+#include <asm/tango2/tango2_pci.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/hardware.h>
+#include <asm/tango3/tango3_pci.h>
+#endif
+
+extern int tangox_pcidev_irq_map(int pci_idsel, int int_num);
+
+int pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+	/* return xenv config */
+	return tangox_pcidev_irq_map(slot, pin);
+}
+
+int pcibios_plat_dev_init(struct pci_dev *dev)
+{
+	return 0;
+}
+
+/*
+ * final fixup for our pci bus, called after all resource allocation.
+ */
+static void tangox_fixup(struct pci_dev *dev)
+{
+	dev->dev.platform_data = 0;
+}
+
+DECLARE_PCI_FIXUP_FINAL(PCI_ANY_ID, PCI_ANY_ID, tangox_fixup);
+
diff -Naur linux-3.9.2.ref/arch/mips/pci/Makefile linux-3.9.2/arch/mips/pci/Makefile
--- linux-3.9.2.ref/arch/mips/pci/Makefile	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/arch/mips/pci/Makefile	2013-07-23 19:31:23.000000000 +0200
@@ -55,6 +55,7 @@
 obj-$(CONFIG_WR_PPMC)		+= fixup-wrppmc.o
 obj-$(CONFIG_MIKROTIK_RB532)	+= pci-rc32434.o ops-rc32434.o fixup-rc32434.o
 obj-$(CONFIG_CPU_CAVIUM_OCTEON) += pci-octeon.o pcie-octeon.o
+obj-$(CONFIG_TANGOX)		+= pci-tangox.o fixup-tangox.o ops-tangox.o
 obj-$(CONFIG_CPU_XLR)		+= pci-xlr.o
 obj-$(CONFIG_CPU_XLP)		+= pci-xlp.o
 
diff -Naur linux-3.9.2.ref/arch/mips/pci/ops-tangox.c linux-3.9.2/arch/mips/pci/ops-tangox.c
--- linux-3.9.2.ref/arch/mips/pci/ops-tangox.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/pci/ops-tangox.c	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,135 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+ *********************************************************************/
+
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <asm/io.h>
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/tango2_pci.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/tango3_pci.h>
+#endif
+
+/*
+ * remapped address to access config space from kernel
+ */
+void __iomem *tangox_pci_config_base;
+
+/*
+ * list of devices for which we allow configuration access
+ */
+int enabled_devices[PCIEM86XX_IDSEL_MAX];
+
+/*
+ * find cfg address to use for given bus/device/Address
+ */
+#define CFG_ADDR(bus,devfn,where)	\
+	(tangox_pci_config_base + (((bus) << 16) + ((devfn) << 8) + (where)))
+
+/*
+ * read/write callbacks for pci configuration memory access
+ */
+int tangox_pcibios_read(struct pci_bus *bus, unsigned int devfn,
+			int where, int size, u32 *val)
+{
+	void __iomem *addr = CFG_ADDR(bus->number, devfn, where);
+	int ret, slot;
+
+	slot = PCI_SLOT(devfn);
+
+	/*
+	 * check that it is ok to use this slot
+	 */
+	if (!enabled_devices[slot] || slot >= PCIEM86XX_IDSEL_MAX)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	/*
+	 * reject silly sizes
+	 */
+	if ((size == 2) && (where & 1))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+	else if ((size == 4) && (where & 3))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	switch (size) {
+	case 1:
+		ret = tangox_cfg_read8(addr, val);
+		break;
+
+	case 2:
+		ret = tangox_cfg_read16(addr, val);
+		break;
+
+	default:
+		ret = tangox_cfg_read32(addr, val);
+		break;
+	}
+
+	return ret;
+}
+
+int tangox_pcibios_write(struct pci_bus *bus, unsigned int devfn,
+			 int where, int size, u32 val)
+{
+	void __iomem *addr = CFG_ADDR(bus->number, devfn, where);
+	int ret, slot;
+
+	slot = PCI_SLOT(devfn);
+
+	/*
+	 * check that it is ok to use this slot
+	 */
+	if (!enabled_devices[slot] || slot >= PCIEM86XX_IDSEL_MAX)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	/*
+	 * reject silly sizes
+	 */
+	if ((size == 2) && (where & 1))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+	else if ((size == 4) && (where & 3))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	switch (size) {
+	case 1:
+		ret = tangox_cfg_write8(addr, &val);
+		break;
+
+	case 2:
+		ret = tangox_cfg_write16(addr, &val);
+		break;
+
+	default:
+		ret = tangox_cfg_write32(addr, &val);
+		break;
+	}
+
+	return ret;
+}
+
+struct pci_ops tangox_pci_ops = {
+	.read = tangox_pcibios_read,
+	.write = tangox_pcibios_write,
+};
diff -Naur linux-3.9.2.ref/arch/mips/pci/pci.c linux-3.9.2/arch/mips/pci/pci.c
--- linux-3.9.2.ref/arch/mips/pci/pci.c	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/arch/mips/pci/pci.c	2013-07-23 19:31:23.000000000 +0200
@@ -352,8 +352,14 @@
 
 char * (*pcibios_plat_setup)(char *str) __initdata;
 
+int pci_enabled = 1;
+
 char *__init pcibios_setup(char *str)
 {
+	if (strcmp(str, "disabled") == 0) {
+		pci_enabled = 0;
+		return(NULL);
+	}
 	if (pcibios_plat_setup)
 		return pcibios_plat_setup(str);
 	return str;
diff -Naur linux-3.9.2.ref/arch/mips/pci/pci-tangox.c linux-3.9.2/arch/mips/pci/pci-tangox.c
--- linux-3.9.2.ref/arch/mips/pci/pci-tangox.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/pci/pci-tangox.c	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,454 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+ *********************************************************************/
+
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/export.h>
+
+#include <asm/pci.h>
+#include <asm/dma.h>
+
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/tango2_gbus.h>
+#include <asm/tango2/hardware.h>
+#include <asm/tango2/tango2_pci.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/tango3_gbus.h>
+#include <asm/tango3/hardware.h>
+#include <asm/tango3/tango3_pci.h>
+#endif
+
+#include <asm/cacheflush.h>
+
+/*
+ * computed in prom.c
+ */
+extern unsigned long em8xxx_kmem_start;
+extern unsigned long em8xxx_kmem_size;
+
+/*
+ * pci addresses used by dma subsystem
+ */
+unsigned long g_pcimem_busaddr;
+unsigned long g_pcimem_physaddr;
+unsigned long g_pcimem_physaddr_end;
+
+DEFINE_SPINLOCK(tangox_pci_lock);
+EXPORT_SYMBOL(tangox_pci_lock);
+
+void __iomem *pci_iomap(struct pci_dev *dev, int bar, unsigned long maxlen);
+//void pci_iounmap(struct pci_dev *dev, void __iomem *addr);
+unsigned char *__unused_ptr1__ = (unsigned char *)pci_iomap;
+//unsigned char *__unused_ptr2__ = (unsigned char *)pci_iounmap;
+
+/*
+ * We can't  touch iospace directly from  kseg1, we need  to remap it.
+ * No  need to  remap too  much space,  only 256  bytes per  device is
+ * allowed, so 64k should be more than enough.
+ */
+#define MEMORY_SIZE_PCI_IO			(64 * 1024)
+
+static struct resource tangox_pci_io_resource = {
+	.name   = "tangox pci IO space",
+ 	.start  = MEMORY_BASE_PCI_IO,
+ 	.end    = MEMORY_BASE_PCI_IO + MEMORY_SIZE_PCI_IO - 1,
+	.flags  = IORESOURCE_IO
+};
+
+/*
+ * give 512MB for PCI memory space
+ */
+static struct resource tangox_pci_mem_resource = {
+        .name   = "tangox pci memory space",
+        .start  = MEMORY_BASE_PCI_MEMORY + 0x02000000, /* from 32MB offset */
+        .end    = MEMORY_BASE_PCI_MEMORY + 0x1fffffff,
+        .flags  = IORESOURCE_MEM
+};
+
+
+/*
+ * Need to  remap config  space to access  it from kernel.   Note that
+ * remap size is just enough for PCIEM86XX_IDSEL_MAX devices on 1 bus.
+ */
+#define MEMORY_SIZE_PCI_CONFIG	(PCIEM86XX_IDSEL_MAX * (1 << 11))
+
+/*
+ * in ops-tangox.c
+ */
+extern void __iomem *tangox_pci_config_base;
+extern struct pci_ops tangox_pci_ops;
+extern int enabled_devices[PCIEM86XX_IDSEL_MAX];
+
+struct pci_controller tangox_controller = {
+        .pci_ops        = &tangox_pci_ops,
+        .io_resource    = &tangox_pci_io_resource,
+        .mem_resource   = &tangox_pci_mem_resource,
+
+	/*
+	 * gbus  addresses are  not the  same as  pci  addresses, tell
+	 * Linux about this so it can adjust resource addresses.
+	 */
+	.mem_offset	= MEMORY_BASE_PCI_MEMORY,
+	.io_offset	= MEMORY_BASE_PCI_CONFIG,
+};
+
+/*
+ * helpers to access host interface registers
+ */
+#define RD_HOST_REG32(r)	\
+		gbus_read_reg32(REG_BASE_host_interface + (r))
+
+#define WR_HOST_REG32(r, v)	\
+		gbus_write_reg32(REG_BASE_host_interface + (r), (v))
+
+#define RD_HOST_REG8(r)	\
+		gbus_read_reg8(REG_BASE_host_interface + (r))
+
+#define WR_HOST_REG8(r, v)	\
+		gbus_write_reg8(REG_BASE_host_interface + (r), (v))
+
+
+/*
+ * This is the  interrupt handler for bus fault  interrupt. Just clear
+ * it and warn user
+ */
+static irqreturn_t pci_busfault_intr(int irq, void *devinfo)
+{
+	static const char *reasons[] = {
+		"OK", "Master Abort", "Retry timer expired", "Unknown" };
+	static int faultcount = 0;
+	unsigned int data;
+
+	data = (RD_HOST_REG8(PCI_host_reg2 + 3) >> 1) & 3;
+	WR_HOST_REG8(PCI_host_reg2 + 3, 1);
+	WR_HOST_REG8(PCI_host_reg2 + 3, 0);
+
+	/* don't flood */
+	if (printk_ratelimit())
+		printk("PCI: PCI bus fault (count %d): %s\n",
+		       ++faultcount, reasons[data]);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * platform initialization code
+ */
+extern int tangox_pci_host_enabled(void);
+extern int tangox_pcidev_enabled(int idsel);
+extern unsigned long tangox_chip_id(void);
+
+/* can turned on/off by XENV or cmd line */
+extern int pci_enabled; 
+
+/* Status of PCI host */
+static int pci_active = 0;
+
+/* the maximum idsel */
+static int pci_idsel_max = PCIEM86XX_IDSEL_MAX;
+
+static int __init tangox_pci_init(void)
+{
+	void __iomem *pci_io_base;
+	unsigned long memsize, regsize, membase, max_dma_size;
+	u32 data;
+	int i;
+#if defined(CONFIG_TANGO3)
+	u32 pf = 0;
+#endif
+
+	/* don't do anything if pci support is not enabled in xenv nor is it by cmd line */
+	if (!pci_enabled) {
+		return 0;
+	} else if (!tangox_pci_host_enabled()) {
+		printk(KERN_NOTICE "PCI: pci host support disabled\n");
+		return 0;
+	} 
+
+	if (((tangox_chip_id() >> 16) & 0xfff0) == 0x8650)
+		pci_idsel_max--; /* one less for 865x */
+
+	printk("PCI: Initializing SMP8xxx PCI host controller\n");
+
+	/*
+	 * Enable pci host support
+	 */
+	WR_HOST_REG32(PCI_chip_is_host, 0); /* Reset PCI host */
+	udelay(1000);
+	WR_HOST_REG32(PCI_chip_is_host, 1);
+
+	/*
+	 * HOST_REG1 :
+	 * [31:16] : # of PCI retry cycle = 0xffff (default = 0xff)
+	 * [8] : host Super Request = 0
+	 * [3:0] arbitration level = 0x00 (Level 1)
+	 */
+	WR_HOST_REG32(PCI_host_reg1, 0xffff0000 | PCIEM86XX_ARBITER_LEVEL);
+
+	/*
+	 * PCI_CTRL1 :
+	 * [17] : enable "Memory Read Multiple" and "Memory Read Line"
+	 * [16] [7:0] : enable "prefetch" for PCI slave regions 2..7
+	 * [17] : Always enabled
+	 * [18] : additional bit for Tango. Long PCI memory read burst
+	 */
+	WR_HOST_REG32(PCI_pcictrl_reg1, 0x00030000);
+
+	/*
+	 * PCI_CTRL2 :
+	 * [18] : fast back-to-back capable = 0 (default)
+	 * [17] : read FIFO level = 1 (8 level deep, default)
+	 * [16] : discard timer enable = 1 (default)
+	 * [15:8] : subs latency = 0x06 (default = 0x08)
+	 * [7:0] : initial latency = 0x0d (default = 0x0b)
+	 */
+	WR_HOST_REG32(PCI_pcictrl_reg2, 0x0003060d);
+
+	/*
+	 * PCI_CTRL3 :
+	 * [16] : slave abort clear = 0
+	 * [10:8] : abort interrupt enable = 0 (default)
+	 * [2:0] : abort status = 0
+	 */
+	WR_HOST_REG32(PCI_pcictrl_reg3, 0);
+
+	/* clear any pending PCI bus fault */
+	if ((RD_HOST_REG8(PCI_host_reg2 + 3) >> 1) & 0x3) {
+		WR_HOST_REG8(PCI_host_reg2 + 3, 1);
+		WR_HOST_REG8(PCI_host_reg2 + 3, 0);
+	}
+
+	/* Setting pci_configuration_vld */
+	WR_HOST_REG8(PCI_host_reg2 + 2, 1);
+
+	/* grant timeout */
+	WR_HOST_REG32(PCI_host_reg3, PCIEM86XX_ARBITER_GRANTTIMEOUT);
+	WR_HOST_REG32(PCI_host_reg5,
+		      PCIEM86XX_ARBITER_GRANTTIMEOUT & 0x000000ff);
+
+	/* initialize arbiter */
+	WR_HOST_REG32(PCI_host_reg4, 0);
+
+	/*
+	 * remap iorange and give port base to linux.
+	 */
+	pci_io_base = ioremap(MEMORY_BASE_PCI_IO, MEMORY_SIZE_PCI_IO);
+	set_io_port_base((unsigned long)pci_io_base - MEMORY_BASE_PCI_IO);
+
+	tangox_controller.io_map_base = (unsigned long)pci_io_base;
+
+	printk("PCI: Remapped PCI I/O space 0x%08lx to 0x%p, size %u kB\n",
+	       MEMORY_BASE_PCI_IO, pci_io_base, MEMORY_SIZE_PCI_IO / 1024);
+
+	/*
+	 * remap configuration space also
+	 */
+	tangox_pci_config_base = ioremap(MEMORY_BASE_PCI_CONFIG,
+					 MEMORY_SIZE_PCI_CONFIG);
+
+	printk("PCI: Remapped PCI config space 0x%08lx to 0x%p, size %u kB\n",
+	       MEMORY_BASE_PCI_CONFIG, tangox_pci_config_base,
+	       MEMORY_SIZE_PCI_CONFIG / 1024);
+
+	memset(&enabled_devices, 0, sizeof (enabled_devices));
+	for (i = 1; i < pci_idsel_max; i++) {
+		if (tangox_pcidev_enabled(i)) {
+			enabled_devices[i] = 1;
+		} else {
+			printk("PCI: device %d disabled\n", i);
+		}
+	}
+
+	/*
+	 * check that we can probe the EM8XXX at id 0
+	 */
+	if (tangox_cfg_read32(tangox_pci_config_base, &data)) {
+		printk("PCI: Can't initialize EM86XX as a PCI slave\n");
+		memset(&enabled_devices, 0, sizeof (enabled_devices));
+		return 1;
+	}
+
+	/*
+	 * configure it as a PCI slave
+	 *
+	 * set PCI memory size to maximum, so the PCI memory will cover the
+	 * whole memory if the total DRAM size is smaller than 112MB/448MB (Tango2/Tango3).
+	 * For Tango2, maximum = 128MB => 16MB per region => DMA memory = 16 * 7 = 112MB
+	 * For Tango3, maximum = 512MB => 64MB per region => DMA memory = 64 * 7 = 448MB
+	 */
+	WR_HOST_REG8(PCI_REG3, MAX_LOG2_PCIMEM_MAP);
+
+	memsize = RD_HOST_REG32(PCI_REG3) & 0x07;
+
+#ifdef CONFIG_TANGO2
+	memsize = 1 << memsize;  /* from 1MB to 128MB */
+#elif defined(CONFIG_TANGO3)
+	memsize = 1 << (memsize + 3); /* from 8MB to 1024MB */
+#else
+#error Unsupported chip!
+#endif
+
+	/* get memory size in bytes / 8 */
+	regsize = (memsize << 20) >> 3; /* regsize in MB */
+
+	/* pci command */
+	__raw_writew(PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER,
+		     (void *)(tangox_pci_config_base + PCI_COMMAND));
+
+	/* base address 0 */
+	g_pcimem_busaddr = PCIBIOS_MIN_MEM_EM86XX - MEMORY_BASE_PCI_MEMORY;
+	__raw_writel(g_pcimem_busaddr,
+		     (void *)(tangox_pci_config_base + PCI_BASE_ADDRESS_0));
+
+	/*
+	 * PCI slave access
+	 * region 0 (R) : Configuration area
+	 * region 1 - 7: mapped to DRAM starting from DRAM_BASE */
+	g_pcimem_busaddr += (regsize * 1);
+	printk("PCI: Configured SMP8xxx as PCI slave with %ldMB "
+	       "PCI memory\n", memsize);
+	membase = CPHYSADDR(em8xxx_kmem_start);
+	max_dma_size = (unsigned long)MAX_DMA_ADDRESS - em8xxx_kmem_start;
+	g_pcimem_physaddr = membase;
+	g_pcimem_physaddr_end = g_pcimem_physaddr + em8xxx_kmem_size;
+
+	for (i = 1; (i < 8) && (max_dma_size > 0); ++i) {
+		/* PCI region base registers should contain low address */
+		WR_HOST_REG32(PCI_REGION_0_BASE + (i * 4), tangox_dma_address(CPHYSADDR(membase)));
+		membase += regsize; 
+		max_dma_size -= regsize;
+#if defined(CONFIG_TANGO3)
+		pf |= (1 << i);
+#endif
+		if ((regsize * i) >= em8xxx_kmem_size) {
+			++i;
+			break;
+		}
+	}
+	for (; i < 8; ++i) /* park the unused region to 0 */
+		WR_HOST_REG32(PCI_REGION_0_BASE + (i * 4), 0);
+
+#if defined(CONFIG_TANGO3)
+	/* Set up pre-fetchable regions */
+	WR_HOST_REG32(PCI_pcictrl_reg1, 0x00030000 | pf);
+	/* increase gbus bandwidth */
+	gbus_write_reg32(REG_BASE_system_block + 0x138, 0x00a0803f);
+#endif
+
+	if (g_pcimem_physaddr_end > membase)
+		g_pcimem_physaddr_end = membase;
+        printk("PCI: Region size is %ldKB\n", regsize >> 10);
+        printk("PCI: Map DMA memory 0x%08lx-0x%08lx for PCI at 0x%08lx\n",
+	       g_pcimem_physaddr, g_pcimem_physaddr_end, g_pcimem_busaddr);
+
+	/*
+	 * register the PCI bus fault interrupt
+	 */
+	if (request_irq(PCIEM86XX_PCIFAULT_INTR, pci_busfault_intr,
+		    IRQF_DISABLED, "tangox_pci_fault", &tangox_controller) != 0) {
+		printk("PCI: fail to register PCI fault ISR(%d)\n", PCIEM86XX_PCIFAULT_INTR);
+		return 0;
+	}
+
+	/* finally register pci controller */
+	register_pci_controller(&tangox_controller);
+
+	pci_active = 1;
+
+	return 0;
+}
+
+arch_initcall(tangox_pci_init);
+
+/* For shutting down all PCI devices on this bus */
+void tangox_pci_shutdown(void)
+{
+	struct pci_dev *dev;
+	struct pci_bus *bus = tangox_controller.bus;
+    
+
+	if (pci_active && bus) {
+		 list_for_each_entry(dev, &bus->devices, bus_list) {
+			if (pci_is_enabled(dev))
+				pci_disable_device(dev);
+		}
+	}
+}
+
+int
+pci_set_dma_mask(struct pci_dev *dev, u64 mask)
+{
+	if (!pci_dma_supported(dev, mask))
+		return -EIO;
+
+	if (em8xxx_kmem_size > (MAX_PCIMEM_MAP_SIZE << 20)) {
+#if defined(CONFIG_TANGO2)
+		dev->dma_mask = mask & 0x07ffffff;
+#elif defined(CONFIG_TANGO3)
+		dev->dma_mask = mask & 0x3fffffff;
+#else
+		dev->dma_mask = mask;
+#endif
+	} else
+		dev->dma_mask = mask;
+
+	return 0;
+}
+EXPORT_SYMBOL(pci_set_dma_mask);
+int
+pci_set_consistent_dma_mask(struct pci_dev *dev, u64 mask)
+{
+	if (!pci_dma_supported(dev, mask))
+		return -EIO;
+
+	if (em8xxx_kmem_size > (MAX_PCIMEM_MAP_SIZE << 20)) {
+#if defined(CONFIG_TANGO2)
+		dev->dev.coherent_dma_mask = mask & 0x07ffffff;
+#elif defined(CONFIG_TANGO3)
+		dev->dev.coherent_dma_mask = mask & 0x3fffffff;
+#else
+		dev->dev.coherent_dma_mask = mask;
+#endif
+	} else
+		dev->dev.coherent_dma_mask = mask;
+
+	return 0;
+}
+EXPORT_SYMBOL(pci_set_consistent_dma_mask);
+void tangox_pci_enable(void)
+{
+	struct pci_dev *dev;
+	struct pci_bus *bus = tangox_controller.bus;
+   
+	if (pci_active) {
+		 list_for_each_entry(dev, &bus->devices, bus_list) {
+			pci_set_master(dev);
+		}
+	}
+}
+
+EXPORT_SYMBOL(tangox_pci_shutdown);
+EXPORT_SYMBOL(tangox_pci_enable);
+
diff -Naur linux-3.9.2.ref/arch/mips/ramdisk/ld.script linux-3.9.2/arch/mips/ramdisk/ld.script
--- linux-3.9.2.ref/arch/mips/ramdisk/ld.script	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/ramdisk/ld.script	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,9 @@
+OUTPUT_ARCH(mips)
+SECTIONS
+{
+  .initrd :
+  {
+       *(.data)
+  }
+}
+
diff -Naur linux-3.9.2.ref/arch/mips/ramdisk/Makefile linux-3.9.2/arch/mips/ramdisk/Makefile
--- linux-3.9.2.ref/arch/mips/ramdisk/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/ramdisk/Makefile	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,23 @@
+#
+# Makefile for a ramdisk image
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+
+ifneq ($(CONFIG_EMBEDDED_RAMDISK),)
+ifneq ($(CONFIG_EMBEDDED_RAMDISK_IMAGE),)
+IMAGENAME := $(CONFIG_EMBEDDED_RAMDISK_IMAGE)
+else
+IMAGENAME := $(SMP86XX_ROOTFS_PATH)/root_fs_mipsel.cramfs
+endif
+RDPATH := $(TOPDIR)/arch/mips/ramdisk
+O_FORMAT := $(shell $(OBJDUMP) -i | head -2 | grep elf32)
+RD_MADE := $(shell $(LD) $(LDFLAGS) -T $(RDPATH)/ld.script -b binary --oformat $(O_FORMAT) -o $(RDPATH)/ramdisk.o $(IMAGENAME))
+endif
+
+obj-$(CONFIG_EMBEDDED_RAMDISK) += ramdisk.o
+
+clean-files += ramdisk.o
+
diff -Naur linux-3.9.2.ref/arch/mips/tangox/console.c linux-3.9.2/arch/mips/tangox/console.c
--- linux-3.9.2.ref/arch/mips/tangox/console.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/tangox/console.c	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,130 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+/*
+ * simple  uart support for  tango2/tango3 board,  register an  early console
+ * that make boot problem easier to debug.
+ *
+ * this uart init code comes from zboot
+ */
+
+#include <linux/init.h>
+#include <linux/console.h>
+
+#include "setup.h"
+
+extern int tangox_uart_baudrate(int uart);
+extern int tangox_uart_console_port(void);
+extern unsigned long tangox_chip_id(void);
+extern unsigned int tangox_uart_base[];
+
+/*
+ * helpers to access uart0/uart1/uart2 register
+ */
+#define RD_UART_REG32_IDX(i,r)							\
+		gbus_read_reg32(tangox_uart_base[i] + (r))
+#define WR_UART_REG32_IDX(i,r,v)						\
+		gbus_write_reg32(tangox_uart_base[i] + (r), (v))
+
+#ifdef CONFIG_TANGOX_PROM_CONSOLE
+/*
+ * print given char to uart0/uart1/uart2
+ */
+static void __init prom_putc(char c)
+{
+	int console = tangox_uart_console_port();
+
+	/* if '\n', then print '\r' also */
+	if (c == '\n') {
+		prom_putc('\r');
+	}
+
+	while ((RD_UART_REG32_IDX(console, CPU_UART_LSR) & 0x20) == 0);
+	WR_UART_REG32_IDX(console, CPU_UART_THR, (unsigned long)c);
+	while ((RD_UART_REG32_IDX(console, CPU_UART_LSR) & 0x20) == 0);
+}
+
+/*
+ * print given string to uart0/uart1/uart2
+ */
+void __init prom_puts(const char *s)
+{
+	while (*s)
+		prom_putc(*s++);
+}
+#endif
+
+/*
+ * initialize uart0/uart1/uart2 with given parameters
+ */
+void __init uart_init(int idx, int baud, int fifo)
+{
+	unsigned int div;
+
+	WR_UART_REG32_IDX(idx, CPU_UART_IER, 0x0);
+	WR_UART_REG32_IDX(idx, CPU_UART_FCR, (fifo ? 0x1f : 0x0));
+	WR_UART_REG32_IDX(idx, CPU_UART_LCR, 0x3);
+
+#ifdef CONFIG_TANGOX_UART_USE_SYSCLK
+	WR_UART_REG32_IDX(idx, CPU_UART_CLKSEL, 0x0);
+	div = (tangox_get_sysclock() / baud) >> 4;
+	if (((((tangox_get_sysclock() * 10) / baud) >> 4) % 10) >= 5)
+		div++;
+	WR_UART_REG32_IDX(idx, CPU_UART_CLKDIV, div);
+#else
+	WR_UART_REG32_IDX(idx, CPU_UART_CLKSEL, 0x1);
+#ifdef CONFIG_TANGO2
+	div = (TANGOX_BASE_FREQUENCY / baud) >> 4;
+	if (((((TANGOX_BASE_FREQUENCY * 10) / baud) >> 4) % 10) >= 5)
+		div++;
+#elif defined(CONFIG_TANGO3)
+	div = (TANGO3_UART_FREQUENCY / baud) >> 4;
+	if (((((TANGO3_UART_FREQUENCY * 10) / baud) >> 4) % 10) >= 5)
+		div++;
+#else
+#error Unsupported platform.
+#endif
+	WR_UART_REG32_IDX(idx, CPU_UART_CLKDIV, div);
+#endif
+}
+
+#ifdef CONFIG_TANGOX_PROM_CONSOLE
+/*
+ * kernel console write callback
+ */
+static void __init prom_console_write(struct console *con, const char *s,
+				      unsigned int c)
+{
+	prom_puts(s);
+}
+
+static struct console promcons __initdata = {
+	.name   = "prom",
+	.write  = prom_console_write,
+	.flags  = CON_PRINTBUFFER | CON_BOOT,
+	.index  = -1,
+};
+
+/*
+ * init uart0/uart1/uart2 and register a console that will use our prom console
+ * callbacks
+ */
+void __init prom_console_register(void)
+{
+	int console = tangox_uart_console_port();
+
+	uart_init(console, tangox_uart_baudrate(console), 0);
+	register_console(&promcons);
+
+	/* hello world ! */
+	printk(KERN_INFO "prom console registered\n");
+}
+#endif
+
diff -Naur linux-3.9.2.ref/arch/mips/tangox/cpucache.c linux-3.9.2/arch/mips/tangox/cpucache.c
--- linux-3.9.2.ref/arch/mips/tangox/cpucache.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/tangox/cpucache.c	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,113 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+/**
+  @file  cpucache.c
+  @brief  
+
+  Implementing /proc/cpucache_info interface
+
+  @author YH Lin
+  @date   2006-08-16
+*/
+
+#include <linux/jiffies.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/hardware.h>
+#include <asm/tango2/tango2api.h>
+#include <asm/tango2/tango2_gbus.h>
+#else
+#error Only Tango2 is supported ...
+#endif
+
+static int cpucache_info_read_proc(char *buf, char **start, off_t off, int count, int *eof, void *data);
+static unsigned long cpucache_saved_jiffies = 0;
+static unsigned icache_missed = 0, dcache_missed = 0;
+
+extern unsigned long em8xxx_cpu_frequency;
+
+//
+// init
+//
+int __init cpucache_info_init(void)
+{
+	create_proc_read_entry("cpucache_info", S_IRUGO, NULL, cpucache_info_read_proc, NULL);
+
+        printk("Created /proc/cpucache_info entry.\n");
+
+	/* Enable performance monitor and start counting */
+	/* 0: DCache Hit 
+	 * 1: DCache Miss
+	 * 2: TLB Hit
+	 * 3: TLB Miss
+	 * 4: ICache Hit
+	 * 5: ICache Miss
+	 * 6: Instn Complete
+	 * 7: ITLB Hit
+	 * 8: ITLB Miss
+	 * 9: JTLB Hit
+	 * 10: JTLB Miss
+	 * 11: WTB Merge */
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_pm_select_1, (1<<5));
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_pm_select_0, (1<<1));
+	cpucache_saved_jiffies = jiffies;
+	icache_missed = gbus_read_reg32(REG_BASE_cpu_block + CPU_pm_counter_1);
+	dcache_missed = gbus_read_reg32(REG_BASE_cpu_block + CPU_pm_counter_0);
+	return 0;
+}
+
+__initcall(cpucache_info_init);
+
+static int cpucache_info_read_proc(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+        int len = 0;
+	unsigned long diffj, diffi, diffd, icache_miss, dcache_miss, tmpj;
+	unsigned long pd, pi;
+        
+	icache_miss = gbus_read_reg32(REG_BASE_cpu_block + CPU_pm_counter_1);
+	dcache_miss = gbus_read_reg32(REG_BASE_cpu_block + CPU_pm_counter_0);
+	tmpj = jiffies;
+	diffj = tmpj - cpucache_saved_jiffies; 
+	cpucache_saved_jiffies = tmpj;
+	if (diffj == 0)
+		diffj = 1;
+
+	if (icache_miss < icache_missed)
+		diffi = (0xffffffff - icache_missed) + icache_miss;
+	else
+		diffi = icache_miss - icache_missed;
+	icache_missed = icache_miss;
+
+	if (dcache_miss < dcache_missed)
+		diffd = (0xffffffff - dcache_missed) + dcache_miss;
+	else
+		diffd = dcache_miss - dcache_missed;
+	dcache_missed = dcache_miss;
+
+	len += sprintf(page+off+len, "jiffies");
+	/* The average miss per jiffies is (diffx / diffj), per second is then ((diffx * HZ) / diffj).
+	 * Assuming one instruction per clock, we have (((diffx * HZ) / diffj) / em8xxx_cpu_frequency)
+	 * as average ratio of cache miss per instruction at given period of time (from last 
+	 * measured, as expressed as (diffj / HZ)). */
+	pi = ((diffi * HZ) / diffj) / (em8xxx_cpu_frequency / 10000); /* Times 10000 to get percentage */
+	pd = ((diffd * HZ) / diffj) / (em8xxx_cpu_frequency / 10000);
+
+	len += sprintf(page+off+len, "(%ld): I-Cache miss ratio(%ld): %ld.%02ld%c, D-Cache miss ratio(%ld): %ld.%02ld%c\n",
+			diffj, diffi, pi / 100, pi % 100, '%', diffd, pd / 100, pd % 100, '%');
+	*eof = 1;
+
+        return(len);
+}
+
diff -Naur linux-3.9.2.ref/arch/mips/tangox/delay.c linux-3.9.2/arch/mips/tangox/delay.c
--- linux-3.9.2.ref/arch/mips/tangox/delay.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/tangox/delay.c	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,218 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2009
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+/*
+ * arch/mips/tangox/delay.c
+ *
+ * Copyright (C) 2003-2009 Sigma Designs, Inc
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <linux/irq.h>
+#include <linux/sched.h>
+
+#include "setup.h"
+
+/*
+ * helpers to access cpu block registers
+ */
+#define RD_CPU_REG32(r)	\
+		gbus_read_reg32(REG_BASE_cpu_block + (r))
+
+#define WR_CPU_REG32(r, v)	\
+		gbus_write_reg32(REG_BASE_cpu_block + (r), (v))
+
+#define MAX_POLL_TIME		(25)	/* less than this we use busy polling */
+
+typedef int (*COND_FUNC_PTR)(void *);
+
+static unsigned long timer_status = 0;
+
+/* given micro seconds, rerurn corresponding cp0 timer cout */
+static inline unsigned long tangox_get_c0_timecount(unsigned usec)
+{
+	extern unsigned long em8xxx_cpu_frequency;
+	unsigned long cnt = em8xxx_cpu_frequency / (1000000 * 2);
+	if ((cnt * (1000000 * 2)) < em8xxx_cpu_frequency)
+		cnt++; /* take the ceiling */
+	return (usec * cnt);
+}
+
+/* check if given timestamp is in the time range of [start, end) */
+static inline int tangox_time_in_range(unsigned long start, unsigned long end, unsigned long timestamp)
+{
+	return (end > start) ? ((timestamp < end) && (timestamp >= start)) : ((timestamp < end) || (timestamp >= start));
+}
+
+/* wait until we are outside the time range [start, end), or condition is false */
+static inline int tangox_wait_until(unsigned long start, unsigned long end, COND_FUNC_PTR func_ptr, void *arg)
+{
+	unsigned long timestamp;
+
+	/* wait until it's out of range, or condition evaluation is false */
+	for (timestamp = read_c0_count(); tangox_time_in_range(start, end, timestamp); timestamp = read_c0_count()) {
+		if ((func_ptr != NULL) && (((*func_ptr)(arg)) == 0))
+			return 0;
+	}
+	return (func_ptr != NULL) ? (*func_ptr)(arg) : 1; /* time's up and condition may be still true */
+}
+
+/* cp0_timer is used for system timer, and timer0 is free to be used here */
+/*
+ * CPU_time0_load
+ *  clock / HZ / (2 * prescale)
+ * CPU_time0_ctrl
+ *  PS(D2-3) : prescale. 0x00 = 1, 0x01 = 16, 0x10 = 256
+ *    There is a bug, and the actual prescale is 0x01 = 32, 0x10 = 512
+ *  M(D6) : periodic mode
+ *  E(D7) : enable
+ */
+#define TIMER_ENABLE            0x80    // D7
+#define TIMER_PERIODIC          0x40    // D6
+#define TIMER_PRESCALE_1        0x00    // D[2-3] = 00b
+#define TIMER_PRESCALE_32       0x04    // D[2-3] = 01b
+#define TIMER_PRESCALE_512      0x08    // D[2-3] = 10b
+
+static const unsigned timer_prescale_bit[3] = { 0, 5, 9 };
+static const unsigned timer_prescale[3] = { TIMER_PRESCALE_1, TIMER_PRESCALE_32, TIMER_PRESCALE_512 };
+
+static DECLARE_WAIT_QUEUE_HEAD(timer0_wq);
+static int timer0_expired = 0, timer0_init = 0;
+static spinlock_t timer0_lock;		/* Spin lock */
+static unsigned int timer0_val = 0, timer0_idx = 0;
+
+static irqreturn_t timer0_isr(int irq, void *dev_id)
+{
+	wait_queue_head_t *q = (wait_queue_head_t *)dev_id;
+	unsigned long flags;
+
+	if (q != &timer0_wq)		/* Paranoid check */
+		return IRQ_NONE;
+
+	spin_lock_irqsave(&timer0_lock, flags);
+	WR_CPU_REG32(CPU_time0_ctrl, 0); /* disable timer */
+	WR_CPU_REG32(CPU_time0_clr, 1);
+	timer0_expired = 1;
+	wake_up_interruptible(&timer0_wq);
+
+	spin_unlock_irqrestore(&timer0_lock, flags);
+	return IRQ_HANDLED;
+}
+
+/*
+ * udelay with timer0 implementation if possible
+ */
+int tangox_udelay_with_condition(unsigned int usecond, COND_FUNC_PTR func_ptr, void *arg)
+{
+	unsigned long start = read_c0_count();
+	unsigned long end = start + tangox_get_c0_timecount(usecond);
+	unsigned long flags, tmp;
+
+	if (unlikely(usecond == 0))
+		return 1;
+	else if ((func_ptr == NULL) || (usecond < MAX_POLL_TIME))
+		goto poll;	/* no condition or too short */
+	else if (in_atomic() || in_interrupt() || ((current != NULL) && signal_pending(current)))
+		goto poll;	/* not safe for context switching */
+	else if (unlikely(timer0_init == 0)) 
+		goto poll;
+	else if (test_and_set_bit(0, &timer_status) != 0)
+		goto poll;
+
+	while (usecond >= MAX_POLL_TIME) { 
+		if ((func_ptr != NULL) && (((*func_ptr)(arg)) == 0)) { /* evaluate condition first */
+			clear_bit(0, &timer_status);
+			return 0;
+		}
+		if (!tangox_time_in_range(start, end, read_c0_count())) {
+			clear_bit(0, &timer_status);
+			return (func_ptr != NULL) ? (*func_ptr)(arg) : 1; /* time's up and condition may be still true */
+		}
+
+		/* CPU_time0_value register contains just 16-bits value so
+		   take care not to let the value to overflow */
+		for (timer0_idx = 0; timer0_idx < 3; timer0_idx++) {
+			tmp = (MAX_POLL_TIME * (em8xxx_sys_frequency / 1000)) / 1000; /* MAX_POLL_TIME needs to be <= 10000 */
+			timer0_val = tmp >> timer_prescale_bit[timer0_idx];
+			if (tmp & ((1 << timer_prescale_bit[timer0_idx]) - 1))
+				timer0_val++;
+			if ((timer0_val & 0xffff0000) == 0)
+				break;
+		}
+		if (timer0_idx >= 3)	/* no prescaling factor can be found */
+			break;
+
+		spin_lock_irqsave(&timer0_lock, flags);
+		timer0_expired = 0;
+		WR_CPU_REG32(CPU_time0_load, timer0_val);
+		WR_CPU_REG32(CPU_time0_ctrl, TIMER_ENABLE | TIMER_PERIODIC | timer_prescale[timer0_idx]);
+		spin_unlock_irqrestore(&timer0_lock, flags);
+
+		/* sleep in the wait queue until timer expired, or timeout */
+		if (wait_event_interruptible(timer0_wq, timer0_expired != 0)) {
+			/* received signal -- switch to busy polling then */
+			spin_lock_irqsave(&timer0_lock, flags);
+			WR_CPU_REG32(CPU_time0_ctrl, 0); /* disable timer */
+			WR_CPU_REG32(CPU_time0_clr, 1);
+			spin_unlock_irqrestore(&timer0_lock, flags);
+			break;
+		}
+		usecond -= MAX_POLL_TIME;
+	}
+	clear_bit(0, &timer_status);
+
+poll:
+	return tangox_wait_until(start, end, func_ptr, arg);
+}
+
+int __init tangox_timer0_init(void)
+{
+	unsigned int tmp;
+
+	WR_CPU_REG32(CPU_time0_ctrl, 0); /* disable timer to begin with */
+	WR_CPU_REG32(CPU_time0_clr, 1);
+	spin_lock_init(&timer0_lock);
+
+	if (request_irq(LOG2_CPU_TIMER0_INT + IRQ_CONTROLLER_IRQ_BASE, timer0_isr, IRQF_DISABLED, "timer0", 
+			&timer0_wq) != 0) {
+		printk(KERN_ERR "timer0: cannot register IRQ (%d)\n", LOG2_CPU_TIMER0_INT + IRQ_CONTROLLER_IRQ_BASE);
+		return -EIO;
+	}
+
+	/* CPU_time0_value register contains just 16-bits value So
+	   take care not to let the value to overflow */
+	for (timer0_idx = 0; timer0_idx < 3; timer0_idx++) {
+		tmp = (MAX_POLL_TIME * (em8xxx_sys_frequency / 1000)) / 1000; /* MAX_POLL_TIME needs to be <= 10000 */
+		timer0_val = tmp >> timer_prescale_bit[timer0_idx];
+		if ((timer0_val & 0xffff0000) == 0) {
+			if (tmp & ((1 << timer_prescale_bit[timer0_idx]) - 1))
+				timer0_val++;
+			break;
+		}
+	}
+	timer0_init = 1;
+	printk(KERN_INFO "timer0: interrupt registered.\n");
+	return 0;
+}
+
+__initcall(tangox_timer0_init);
+
+void tangox_udelay(unsigned int usec)
+{
+	tangox_udelay_with_condition(usec, NULL, NULL);
+}
+
+EXPORT_SYMBOL(tangox_udelay);
+EXPORT_SYMBOL(tangox_udelay_with_condition);
+
diff -Naur linux-3.9.2.ref/arch/mips/tangox/gbus.c linux-3.9.2/arch/mips/tangox/gbus.c
--- linux-3.9.2.ref/arch/mips/tangox/gbus.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/tangox/gbus.c	2013-07-23 19:31:22.000000000 +0200
@@ -0,0 +1,261 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+/*
+ * export gbus symbol to modules
+ */
+
+#include <linux/module.h>
+
+
+#include "setup.h"
+
+#define TMP_REMAPPED_REG	CPU_remap1
+#define TMP_REMAPPED_BASE	CPU_remap1_address
+#define TMP_REMAPPED_SIZE	0x00010000
+#define TMP_REMAPPED_MASK	~(TMP_REMAPPED_SIZE-1)
+
+#define TMP_REMAPPED_REG1	CPU_remap
+#define TMP_REMAPPED_BASE1	CPU_remap_address
+#define TMP_REMAPPED_SIZE1	0x00010000
+#define TMP_REMAPPED_MASK1	~(TMP_REMAPPED_SIZE1-1)
+
+#if defined(CONFIG_TANGO2) && defined(CONFIG_TANGOX_USE_TLB_REMAP_DRAM1)
+unsigned long em86xx_tlb_dram1_map_base;
+unsigned long em86xx_tlb_dram1_map_size;
+#endif
+
+static DEFINE_SPINLOCK(remap_lock);
+
+static RMuint32 set_remap(RMuint32 remap_reg, RMuint32 value)
+{
+	RMuint32 orig = *((volatile RMuint32 *)KSEG1ADDR(REG_BASE_cpu_block + remap_reg));
+	if (orig != value) {
+		*((volatile RMuint32 *)KSEG1ADDR(REG_BASE_cpu_block + remap_reg)) = value;
+		iob();
+	}
+	return(orig);
+}
+
+#if defined(CONFIG_TANGO3)
+
+#define BUILD_GBUS_READ_OP(size)									\
+RMuint##size gbus_read_uint##size(struct gbus *pgbus, RMuint32 byte_address) 				\
+{													\
+	RMuint32 remap;											\
+	RMuint##size tmp;										\
+	if (byte_address < CPU_remap2_address) {							\
+		tmp = *((volatile RMuint##size *)KSEG1ADDR(byte_address)); 				\
+		rmb();											\
+	} else {											\
+		unsigned long flags;									\
+		spin_lock_irqsave(&remap_lock, flags); /* Ensure remap won't be changed */		\
+		/* Use CPU_remapx to temporarily map the address */					\
+		if (likely(byte_address != (REG_BASE_cpu_block + TMP_REMAPPED_REG))) {			\
+			remap = set_remap(TMP_REMAPPED_REG, byte_address & TMP_REMAPPED_MASK);		\
+			tmp = *((volatile RMuint##size *)KSEG1ADDR(TMP_REMAPPED_BASE + 			\
+								(byte_address & (TMP_REMAPPED_SIZE-1))));	\
+			rmb();										\
+			set_remap(TMP_REMAPPED_REG, remap & TMP_REMAPPED_MASK);				\
+		} else {										\
+			remap = set_remap(TMP_REMAPPED_REG1, byte_address & TMP_REMAPPED_MASK1);	\
+			tmp = *((volatile RMuint##size *)KSEG1ADDR(TMP_REMAPPED_BASE1 + 		\
+								(byte_address & (TMP_REMAPPED_SIZE1-1))));	\
+			rmb();										\
+			set_remap(TMP_REMAPPED_REG1, remap & TMP_REMAPPED_MASK1);			\
+		}											\
+		spin_unlock_irqrestore(&remap_lock, flags); /* Ensure remap won't be changed */		\
+	}												\
+	return(tmp);											\
+}
+
+#define BUILD_GBUS_WRITE_OP(size)									\
+void gbus_write_uint##size(struct gbus *pgbus, RMuint32 byte_address, RMuint##size data)		\
+{													\
+	RMuint32 remap;											\
+	mb();												\
+	if (byte_address < CPU_remap2_address) {							\
+		*((volatile RMuint##size *)KSEG1ADDR(byte_address)) = data;				\
+		iob();											\
+	} else {											\
+		unsigned long flags;									\
+		spin_lock_irqsave(&remap_lock, flags); /* Ensure remap won't be changed */		\
+		/* Use CPU_remapx to temporarily map the address */					\
+		if (likely(byte_address != (REG_BASE_cpu_block + TMP_REMAPPED_REG))) {			\
+			remap = set_remap(TMP_REMAPPED_REG, byte_address & TMP_REMAPPED_MASK);		\
+			*((volatile RMuint##size *)KSEG1ADDR(TMP_REMAPPED_BASE + 			\
+							(byte_address & (TMP_REMAPPED_SIZE-1)))) = data;	\
+			iob();										\
+			set_remap(TMP_REMAPPED_REG, remap & TMP_REMAPPED_MASK);				\
+		} else {										\
+			remap = set_remap(TMP_REMAPPED_REG1, byte_address & TMP_REMAPPED_MASK1);	\
+			*((volatile RMuint##size *)KSEG1ADDR(TMP_REMAPPED_BASE1 + 			\
+							(byte_address & (TMP_REMAPPED_SIZE1-1)))) = data;	\
+			iob();										\
+			set_remap(TMP_REMAPPED_REG1, remap & TMP_REMAPPED_MASK1);			\
+		}											\
+		spin_unlock_irqrestore(&remap_lock, flags); /* Ensure remap won't be changed */		\
+	}												\
+}
+
+#elif defined(CONFIG_TANGO2)
+
+#ifdef CONFIG_TANGOX_USE_TLB_REMAP_DRAM1
+
+#define BUILD_GBUS_READ_OP(size)									\
+RMuint##size gbus_read_uint##size(struct gbus *pgbus, RMuint32 byte_address) 				\
+{													\
+	RMuint32 remap;											\
+	RMuint##size tmp;										\
+	if (byte_address < (MEM_BASE_dram_controller_0 + 0x10000000))					\
+		return gbus_read_dram_uint##size(pgbus, byte_address);					\
+	else if (byte_address < (MEM_BASE_dram_controller_1 + 0x10000000))				\
+		if (byte_address < (MEM_BASE_dram_controller_1 + em86xx_tlb_dram1_map_size))		\
+			return gbus_read_dram_uint##size(pgbus, byte_address);				\
+		else {											\
+			printk("accessing non-existed DRAM1 area 0x%08lx\n", byte_address);		\
+			return(0);									\
+		}											\
+	else {												\
+		unsigned long flags;									\
+		spin_lock_irqsave(&remap_lock, flags); /* Ensure remap won't be changed */		\
+		/* Use CPU_remapx to temporarily map the address */					\
+		if (likely(byte_address != (REG_BASE_cpu_block + TMP_REMAPPED_REG))) {			\
+			remap = set_remap(TMP_REMAPPED_REG, byte_address & TMP_REMAPPED_MASK);		\
+			tmp = *((volatile RMuint##size *)KSEG1ADDR(TMP_REMAPPED_BASE + 			\
+								(byte_address & (TMP_REMAPPED_SIZE-1))));	\
+			set_remap(TMP_REMAPPED_REG, remap & TMP_REMAPPED_MASK);				\
+		} else {										\
+			remap = set_remap(TMP_REMAPPED_REG1, byte_address & TMP_REMAPPED_MASK1);	\
+			tmp = *((volatile RMuint##size *)KSEG1ADDR(TMP_REMAPPED_BASE1 + 		\
+								(byte_address & (TMP_REMAPPED_SIZE1-1))));	\
+			set_remap(TMP_REMAPPED_REG1, remap & TMP_REMAPPED_MASK1);			\
+		}											\
+		spin_unlock_irqrestore(&remap_lock, flags); /* Ensure remap won't be changed */		\
+		return(tmp);										\
+	}												\
+}
+
+#define BUILD_GBUS_WRITE_OP(size)									\
+void gbus_write_uint##size(struct gbus *pgbus, RMuint32 byte_address, RMuint##size data)		\
+{													\
+	RMuint32 remap;											\
+	if (byte_address < (MEM_BASE_dram_controller_0 + 0x10000000))					\
+		gbus_write_dram_uint##size(pgbus, byte_address, data);					\
+	else if (byte_address < (MEM_BASE_dram_controller_1 + 0x10000000))				\
+		if (byte_address < (MEM_BASE_dram_controller_1 + em86xx_tlb_dram1_map_size))		\
+			gbus_write_dram_uint##size(pgbus, byte_address, data);				\
+		else 											\
+			printk("accessing non-existed DRAM1 area 0x%08lx.\n", byte_address);		\
+	else {												\
+		unsigned long flags;									\
+		spin_lock_irqsave(&remap_lock, flags); /* Ensure remap won't be changed */		\
+		/* Use CPU_remapx to temporarily map the address */					\
+		if (likely(byte_address != (REG_BASE_cpu_block + TMP_REMAPPED_REG))) {			\
+			remap = set_remap(TMP_REMAPPED_REG, byte_address & TMP_REMAPPED_MASK);		\
+			*((volatile RMuint##size *)KSEG1ADDR(TMP_REMAPPED_BASE + 			\
+							(byte_address & (TMP_REMAPPED_SIZE-1)))) = data;	\
+			set_remap(TMP_REMAPPED_REG, remap & TMP_REMAPPED_MASK);				\
+		} else {										\
+			remap = set_remap(TMP_REMAPPED_REG1, byte_address & TMP_REMAPPED_MASK1);	\
+			*((volatile RMuint##size *)KSEG1ADDR(TMP_REMAPPED_BASE1 + 			\
+							(byte_address & (TMP_REMAPPED_SIZE1-1)))) = data;	\
+			set_remap(TMP_REMAPPED_REG1, remap & TMP_REMAPPED_MASK1);			\
+		}											\
+		spin_unlock_irqrestore(&remap_lock, flags); /* Ensure remap won't be changed */		\
+	}												\
+	__sync();											\
+}
+
+#else /* CONFIG_TANGOX_USE_TLB_REMAP_DRAM1 */
+
+#define BUILD_GBUS_READ_OP(size)									\
+RMuint##size gbus_read_uint##size(struct gbus *pgbus, RMuint32 byte_address) 				\
+{													\
+	RMuint32 remap;											\
+	RMuint##size tmp;										\
+	if (byte_address < (MEM_BASE_dram_controller_0 + 0x10000000))					\
+		return gbus_read_dram_uint##size(pgbus, byte_address);					\
+	else if (byte_address < (MEM_BASE_dram_controller_1 + 0x10000000))				\
+		return gbus_read_dram_uint##size(pgbus, byte_address);					\
+	else {												\
+		unsigned long flags;									\
+		spin_lock_irqsave(&remap_lock, flags); /* Ensure remap won't be changed */		\
+		/* Use CPU_remapx to temporarily map the address */					\
+		if (likely(byte_address != (REG_BASE_cpu_block + TMP_REMAPPED_REG))) {			\
+			remap = set_remap(TMP_REMAPPED_REG, byte_address & TMP_REMAPPED_MASK);		\
+			tmp = *((volatile RMuint##size *)KSEG1ADDR(TMP_REMAPPED_BASE + 			\
+								(byte_address & (TMP_REMAPPED_SIZE-1))));	\
+			set_remap(TMP_REMAPPED_REG, remap & TMP_REMAPPED_MASK);				\
+		} else {										\
+			remap = set_remap(TMP_REMAPPED_REG1, byte_address & TMP_REMAPPED_MASK1);	\
+			tmp = *((volatile RMuint##size *)KSEG1ADDR(TMP_REMAPPED_BASE1 + 		\
+								(byte_address & (TMP_REMAPPED_SIZE1-1))));	\
+			set_remap(TMP_REMAPPED_REG1, remap & TMP_REMAPPED_MASK1);			\
+		}											\
+		spin_unlock_irqrestore(&remap_lock, flags); /* Ensure remap won't be changed */		\
+		return(tmp);										\
+	}												\
+}
+
+#define BUILD_GBUS_WRITE_OP(size)									\
+void gbus_write_uint##size(struct gbus *pgbus, RMuint32 byte_address, RMuint##size data)		\
+{													\
+	RMuint32 remap;											\
+	if (byte_address < (MEM_BASE_dram_controller_0 + 0x10000000))					\
+		gbus_write_dram_uint##size(pgbus, byte_address, data);					\
+	else if (byte_address < (MEM_BASE_dram_controller_1 + 0x10000000))				\
+		gbus_write_dram_uint##size(pgbus, byte_address, data);					\
+	else {												\
+		unsigned long flags;									\
+		spin_lock_irqsave(&remap_lock, flags); /* Ensure remap won't be changed */		\
+		/* Use CPU_remapx to temporarily map the address */					\
+		if (likely(byte_address != (REG_BASE_cpu_block + TMP_REMAPPED_REG))) {			\
+			remap = set_remap(TMP_REMAPPED_REG, byte_address & TMP_REMAPPED_MASK);		\
+			*((volatile RMuint##size *)KSEG1ADDR(TMP_REMAPPED_BASE + 			\
+							(byte_address & (TMP_REMAPPED_SIZE-1)))) = data;	\
+			set_remap(TMP_REMAPPED_REG, remap & TMP_REMAPPED_MASK);				\
+		} else {										\
+			remap = set_remap(TMP_REMAPPED_REG1, byte_address & TMP_REMAPPED_MASK1);	\
+			*((volatile RMuint##size *)KSEG1ADDR(TMP_REMAPPED_BASE1 + 			\
+							(byte_address & (TMP_REMAPPED_SIZE1-1)))) = data;	\
+			set_remap(TMP_REMAPPED_REG1, remap & TMP_REMAPPED_MASK1);			\
+		}											\
+		spin_unlock_irqrestore(&remap_lock, flags); /* Ensure remap won't be changed */		\
+	}												\
+	__sync();											\
+}
+
+#endif /* CONFIG_TANGOX_USE_TLB_REMAP_DRAM1 */
+
+#else
+#error Unsupported platform.
+#endif /* CONFIG_TANGO3 */
+
+BUILD_GBUS_READ_OP(32);
+BUILD_GBUS_READ_OP(16);
+BUILD_GBUS_READ_OP(8);
+
+BUILD_GBUS_WRITE_OP(32);
+BUILD_GBUS_WRITE_OP(16);
+BUILD_GBUS_WRITE_OP(8);
+
+EXPORT_SYMBOL(gbus_read_uint32);
+EXPORT_SYMBOL(gbus_write_uint32);
+EXPORT_SYMBOL(gbus_read_uint16);
+EXPORT_SYMBOL(gbus_write_uint16);
+EXPORT_SYMBOL(gbus_read_uint8);
+EXPORT_SYMBOL(gbus_write_uint8);
+
+#if defined(CONFIG_TANGO2) && defined(CONFIG_TANGOX_USE_TLB_REMAP_DRAM1)
+EXPORT_SYMBOL(em86xx_tlb_dram1_map_base);
+EXPORT_SYMBOL(em86xx_tlb_dram1_map_size);
+#endif
+
diff -Naur linux-3.9.2.ref/arch/mips/tangox/gpio.c linux-3.9.2/arch/mips/tangox/gpio.c
--- linux-3.9.2.ref/arch/mips/tangox/gpio.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/tangox/gpio.c	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,570 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#include <linux/module.h>
+#include "setup.h"
+
+int em86xx_uart0_get_gpio_mode(void)
+{
+	return gbus_read_reg32(REG_BASE_cpu_block + CPU_uart0_gpio_mode) & 0x7f;
+}
+
+int em86xx_uart0_set_gpio_mode(int mode)
+{
+	int old_mode = em86xx_uart0_get_gpio_mode();
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_uart0_gpio_mode, 0x7f00 | (mode & 0x7f));
+	return(old_mode);
+}
+
+int em86xx_uart0_gpio_read(int gpio)
+{
+	return (gbus_read_reg32(REG_BASE_cpu_block + CPU_uart0_gpio_data) >> gpio) & 1;
+}
+
+void em86xx_uart0_gpio_write(int gpio, int data)
+{
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_uart0_gpio_data,
+			data ? UART_GPIO_DATA_SET(gpio) : UART_GPIO_DATA_CLEAR(gpio));
+}
+
+void em86xx_uart0_gpio_setdirection(int gpio, int dir)
+{
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_uart0_gpio_dir,
+			dir ? UART_GPIO_DIR_OUTPUT(gpio) : UART_GPIO_DIR_INPUT(gpio));
+}
+
+int em86xx_uart1_get_gpio_mode(void)
+{
+	return gbus_read_reg32(REG_BASE_cpu_block + CPU_uart1_gpio_mode) & 0x7f;
+}
+
+int em86xx_uart1_set_gpio_mode(int mode)
+{
+	int old_mode = em86xx_uart1_get_gpio_mode();
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_uart1_gpio_mode, 0x7f00 | (mode & 0x7f));
+	return(old_mode);
+}
+
+int em86xx_uart1_gpio_read(int gpio)
+{
+	return (gbus_read_reg32(REG_BASE_cpu_block + CPU_uart1_gpio_data) >> gpio) & 1;
+}
+
+void em86xx_uart1_gpio_write(int gpio, int data)
+{
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_uart1_gpio_data,
+			data ? UART_GPIO_DATA_SET(gpio) : UART_GPIO_DATA_CLEAR(gpio));
+}
+
+void em86xx_uart1_gpio_setdirection(int gpio, int dir)
+{
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_uart1_gpio_dir,
+			dir ? UART_GPIO_DIR_OUTPUT(gpio) : UART_GPIO_DIR_INPUT(gpio));
+}
+
+#if defined(CONFIG_TANGO3)
+int em86xx_uart2_get_gpio_mode(void)
+{
+	return gbus_read_reg32(REG_BASE_cpu_block + CPU_uart2_gpio_mode) & 0x7f;
+}
+
+int em86xx_uart2_set_gpio_mode(int mode)
+{
+	int old_mode = em86xx_uart2_get_gpio_mode();
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_uart2_gpio_mode, 0x7f00 | (mode & 0x7f));
+	return(old_mode);
+}
+
+int em86xx_uart2_gpio_read(int gpio)
+{
+	return (gbus_read_reg32(REG_BASE_cpu_block + CPU_uart2_gpio_data) >> gpio) & 1;
+}
+
+void em86xx_uart2_gpio_write(int gpio, int data)
+{
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_uart2_gpio_data,
+			data ? UART_GPIO_DATA_SET(gpio) : UART_GPIO_DATA_CLEAR(gpio));
+}
+
+void em86xx_uart2_gpio_setdirection(int gpio, int dir)
+{
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_uart2_gpio_dir,
+			dir ? UART_GPIO_DIR_OUTPUT(gpio) : UART_GPIO_DIR_INPUT(gpio));
+}
+#endif
+
+EXPORT_SYMBOL(em86xx_uart0_gpio_read);
+EXPORT_SYMBOL(em86xx_uart0_gpio_write);
+EXPORT_SYMBOL(em86xx_uart0_gpio_setdirection);
+EXPORT_SYMBOL(em86xx_uart1_gpio_read);
+EXPORT_SYMBOL(em86xx_uart1_gpio_write);
+EXPORT_SYMBOL(em86xx_uart1_gpio_setdirection);
+#ifdef CONFIG_TANGO3
+EXPORT_SYMBOL(em86xx_uart2_gpio_read);
+EXPORT_SYMBOL(em86xx_uart2_gpio_write);
+EXPORT_SYMBOL(em86xx_uart2_gpio_setdirection);
+#endif
+
+#ifdef CONFIG_TANGO2
+/* For Tango2, the GPIO pins are
+ * 	0 .. 15: System GPIO
+ *      16 .. 32: Secondary system GPIO
+ * 	33 .. 34: TDMX GPIO0/1 
+ * 	35 .. 41: UART0 GPIO: RXD, CTS, DSR, DCD, TXD, RTS, DTR
+ *	42 .. 48: UART1 GPIO: RXD, CTS, DSR, DCD, TXD, RTS, DTR
+ *      49 .. 51: SCARD CTL0, CTL1, CTL2
+ *	52 .. 69: ETH GPIO: TXCLK, TXEN, TXD0, TXD1, TXD2, TXD3
+ *			RXCLK, RXDV, RXER, RXD0, RXD1, RXD2, RXD3,
+ *			CRS, COL, MDC, MDIO, MDINT#
+ */
+
+int em86xx_gpio_read(int gpio)
+{
+	if ((gpio >= 0) && (gpio < 16))
+		return (gbus_read_reg32(REG_BASE_system_block +
+				   SYS_gpio_data) >> gpio) & 1;
+	else if ((gpio >= 16) && (gpio < 33))
+		return (gbus_read_reg32(REG_BASE_host_interface +
+				   ETH_gpio_data2) >> (gpio - 16)) & 1;
+	else
+		return -EIO; /* not implemented yet */
+}
+
+void em86xx_gpio_write(int gpio, int data)
+{
+	if ((gpio >= 0) && (gpio < 16))
+		gbus_write_reg32(REG_BASE_system_block + SYS_gpio_data, data ?
+			    GPIO_DATA_SET(gpio) : GPIO_DATA_CLEAR(gpio));
+	else if ((gpio >= 16) && (gpio < 33))
+		gbus_write_reg32(REG_BASE_host_interface + ETH_gpio_data2, data ?
+			    GPIO_DATA_SET(gpio - 16) : GPIO_DATA_CLEAR(gpio - 16));
+	else
+		return; /* not implemented yet */
+}
+
+void em86xx_gpio_setdirection(int gpio, int dir)
+{
+	if ((gpio >= 0) && (gpio < 16))
+		gbus_write_reg32(REG_BASE_system_block + SYS_gpio_dir, dir ?
+			    GPIO_DIR_OUTPUT(gpio) : GPIO_DIR_INPUT(gpio));
+	else if ((gpio >= 16) && (gpio < 33))
+		gbus_write_reg32(REG_BASE_host_interface + ETH_gpio_dir2, dir ?
+			    GPIO_DIR_OUTPUT(gpio - 16) : GPIO_DIR_INPUT(gpio - 16));
+	else
+		return; /* not implemented yet */
+}
+
+#elif defined(CONFIG_TANGO3)
+
+/* For Tango3, the GPIO pins are
+ * 	0 .. 15: System GPIO
+ * 	16 .. 17: TDMX GPIO0/1 (only 864x)
+ * 	18 .. 24: UART0 GPIO: RXD, CTS, DSR, DCD, TXD, RTS, DTR
+ *      25:       SPI_CLK (only 8652/867X/868X)
+ *	26 .. 32: UART1 GPIO: RXD, CTS, DSR, DCD, TXD, RTS, DTR
+ *	33 .. 51: ETH0 GPIO: TXCLK, TXEN, TXD0, TXD1, TXD2, TXD3
+ *			RXCLK, RXDV, RXER, RXD0, RXD1, RXD2, RXD3,
+ *			CRS, COL, MDC, MDIO, MDINT#, TXER
+ *	52 .. 70: ETH1 GPIO: TXCLK, TXEN, TXD0, TXD1, TXD2, TXD3
+ *			RXCLK, RXDV, RXER, RXD0, RXD1, RXD2, RXD3,
+ *			CRS, COL, MDC, MDIO, MDINT#, TXER
+ *	71 .. 77: SCARD0 GPIO: (not 8652/867X/868X)
+ *			RST, CLK, FCB, IO, CTL0, CTL1, CTL2
+ *	78 .. 84: SCARD1 GPIO: (not 8652/867X/868X)
+ *			RST, CLK, FCB, IO, CTL0, CTL1, CTL2
+ *      85 .. 86: SCARD0 IO2, SCARD1 IO2 (only 8656)
+ *	87 .. 93: UART2 GPIO: RXD, CTS, DSR, DCD, TXD, RTS, DTR (only RX/TX 8652/867X/868X)
+ */
+
+#define M_GPIO	6
+unsigned long tangox_chip_id(void);
+
+int em86xx_gpio_read(int gpio)
+{
+	if ((gpio >= 0) && (gpio < 16)) {
+		return (gbus_read_reg32(REG_BASE_system_block + SYS_gpio_data) >> gpio) & 1;
+	} else if ((gpio == 16) || (gpio == 17)) { /* TDMX_GPIO0/1 */
+		unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+		if ((chip_id != 0x8644) && (chip_id != 0x8642))
+			return -EINVAL;
+		return -EIO; /* not yet implemented */
+	} else if ((gpio >= 18) && (gpio < 25)) { /* UART0 */
+		unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+		if ((chip_id & 0xff00) == 0x8900)
+			return -EIO; /* not yet implemented */
+		else
+			return em86xx_uart0_gpio_read(gpio - 18);
+	} else if (gpio == 25) {
+		unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+		if (chip_id == 0x8652)
+			return -EIO; /* not yet implemented */
+		else if ((chip_id & 0xfff0) == 0x8670)
+			return -EIO; /* not yet implemented */
+		else if ((chip_id & 0xfff0) == 0x8680)
+			return -EIO; /* not yet implemented */
+		else if ((chip_id & 0xff00) == 0x8900)
+			return -EIO; /* not yet implemented */
+	} else if ((gpio >= 26) && (gpio < 33)) { /* UART1 */
+		return em86xx_uart1_gpio_read(gpio - 26);
+	} else if ((gpio >= 33) && (gpio < 52)) { /* ETH0 */
+		gpio -= 33;
+		if (gpio < 16)
+			return (gbus_read_reg32(REG_BASE_host_interface + 0x6408) >> gpio) & 1;
+		else 
+			return (gbus_read_reg32(REG_BASE_host_interface + 0x6410) >> (gpio - 16)) & 1;
+	} else if ((gpio >= 52) && (gpio < 71)) { /* ETH1 */
+		gpio -= 52;
+		if (gpio < 16)
+			return (gbus_read_reg32(REG_BASE_host_interface + 0x6c08) >> gpio) & 1;
+		else 
+			return (gbus_read_reg32(REG_BASE_host_interface + 0x6c10) >> (gpio - 16)) & 1;
+	} else if ((gpio >= 71) && (gpio < 78)) { /* SCARD0 */
+		unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+		if (chip_id == 0x8652)
+			return -EINVAL;
+		else if ((chip_id & 0xfff0) == 0x8670)
+			return -EINVAL;
+		else if ((chip_id & 0xfff0) == 0x8680)
+			return -EINVAL;
+		return (gbus_read_reg32(REG_BASE_cpu_block + 0xc35c) >> (gpio - 71)) & 1;
+	} else if ((gpio >= 78) && (gpio < 85)) { /* SCARD1 */
+		unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+		if (chip_id == 0x8652)
+			return -EINVAL;
+		else if ((chip_id & 0xfff0) == 0x8670)
+			return -EINVAL;
+		else if ((chip_id & 0xfff0) == 0x8680)
+			return -EINVAL;
+		return (gbus_read_reg32(REG_BASE_cpu_block + 0xc3dc) >> (gpio - 78)) & 1;
+	} else if ((gpio == 85) || (gpio == 86)) {
+		unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+		if ((chip_id == 0x8656) || ((chip_id & 0xff00) == 0x8900))
+			return -EIO; /* not yet implemented */
+	} else if ((gpio >= 87) || (gpio < 94)) { /* UART2 */
+		unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+		if (chip_id == 0x8652)
+			return em86xx_uart2_gpio_read(gpio - 87);
+		else if ((chip_id & 0xfff0) == 0x8670)
+			return em86xx_uart2_gpio_read(gpio - 87);
+		else if ((chip_id & 0xfff0) == 0x8680)
+			return em86xx_uart2_gpio_read(gpio - 87);
+	}
+	return -EINVAL;
+}
+
+void em86xx_gpio_write(int gpio, int val)
+{
+	int data = (val != 0) ? 1 : 0;
+	if ((gpio >= 0) && (gpio < 16)) {
+		gbus_write_reg32(REG_BASE_system_block + SYS_gpio_data, data ?  GPIO_DATA_SET(gpio) : GPIO_DATA_CLEAR(gpio));
+	} else if ((gpio == 16) || (gpio == 17)) { /* TDMX_GPIO0/1 */
+		unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+		if ((chip_id != 0x8644) && (chip_id != 0x8642))
+			return;
+		return; /* not yet implemented */
+	} else if ((gpio >= 18) && (gpio < 25)) { /* UART0 */
+		unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+		if ((chip_id & 0xff00) == 0x8900)
+			return; /* not yet implemented */
+		else
+			em86xx_uart0_gpio_write(gpio - 18, data);
+	} else if (gpio == 25) {
+		unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+		if (chip_id == 0x8652)
+			return; /* not yet implemented */
+		else if ((chip_id & 0xfff0) == 0x8670)
+			return; /* not yet implemented */
+		else if ((chip_id & 0xfff0) == 0x8680)
+			return; /* not yet implemented */
+		else if ((chip_id & 0xff00) == 0x8900)
+			return; /* not yet implemented */
+	} else if ((gpio >= 26) && (gpio < 33)) { /* UART1 */
+		em86xx_uart1_gpio_write(gpio - 26, data);
+	} else if ((gpio >= 33) && (gpio < 52)) { /* ETH0 */
+		gpio -= 33;
+		if (gpio < 16)
+			gbus_write_reg32(REG_BASE_host_interface + 0x6408, (1 << (gpio + 16)) | (data << gpio));
+		else 
+			gbus_write_reg32(REG_BASE_host_interface + 0x6410, (1 << gpio) | (data << (gpio - 16)));
+	} else if ((gpio >= 52) && (gpio < 71)) { /* ETH1 */
+		gpio -= 52;
+		if (gpio < 16)
+			gbus_write_reg32(REG_BASE_host_interface + 0x6c08, (1 << (gpio + 16)) | (data << gpio));
+		else 
+			gbus_write_reg32(REG_BASE_host_interface + 0x6c10, (1 << gpio) | (data << (gpio - 16)));
+	} else if ((gpio >= 71) && (gpio < 78)) { /* SCARD0 */
+		unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+		if (chip_id == 0x8652)
+			return;
+		else if ((chip_id & 0xfff0) == 0x8670)
+			return;
+		else if ((chip_id & 0xfff0) == 0x8680)
+			return;
+		gpio -= 71;
+		gbus_write_reg32(REG_BASE_cpu_block + 0xc35c, (1 << (gpio + 8)) | (data << gpio));
+	} else if ((gpio >= 78) && (gpio < 85)) { /* SCARD1 */
+		unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+		if (chip_id == 0x8652)
+			return;
+		else if ((chip_id & 0xfff0) == 0x8670)
+			return;
+		else if ((chip_id & 0xfff0) == 0x8680)
+			return;
+		gpio -= 78;
+		gbus_write_reg32(REG_BASE_cpu_block + 0xc3dc, (1 << (gpio + 8)) | (data << gpio));
+	} else if ((gpio == 85) || (gpio == 86)) {
+		unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+		if ((chip_id == 0x8656) || ((chip_id & 0xff00) == 0x8900))
+			return; /* not yet implemented */
+	} else if ((gpio >= 87) || (gpio < 94)) { /* UART2 */
+		unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+		if (chip_id == 0x8652)
+			em86xx_uart2_gpio_write(gpio - 87, data);
+		else if ((chip_id & 0xfff0) == 0x8670)
+			em86xx_uart2_gpio_write(gpio - 87, data);
+		else if ((chip_id & 0xfff0) == 0x8680)
+			em86xx_uart2_gpio_write(gpio - 87, data);
+	}
+}
+
+void em86xx_gpio_setdirection(int gpio, int direction)
+{
+	int dir = (direction != 0) ? 1 : 0;
+	if ((gpio >= 0) && (gpio < 16)) {
+		gbus_write_reg32(REG_BASE_system_block + SYS_gpio_dir, dir ?  GPIO_DIR_OUTPUT(gpio) : GPIO_DIR_INPUT(gpio));
+	} else if ((gpio == 16) || (gpio == 17)) { /* TDMX_GPIO0/1 */
+		unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+		if ((chip_id != 0x8644) && (chip_id != 0x8642))
+			return;
+		return; /* not yet implemented */
+	} else if ((gpio >= 18) && (gpio < 25)) { /* UART0 */
+		unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+		if ((chip_id & 0xff00) == 0x8900)
+			return; /* not yet implemented */
+		else
+			em86xx_uart0_gpio_setdirection(gpio - 18, dir);
+	} else if (gpio == 25) {
+		unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+		if (chip_id == 0x8652)
+			return; /* not yet implemented */
+		else if ((chip_id & 0xfff0) == 0x8670)
+			return; /* not yet implemented */
+		else if ((chip_id & 0xfff0) == 0x8680)
+			return; /* not yet implemented */
+		else if ((chip_id & 0xff00) == 0x8900)
+			return; /* not yet implemented */
+	} else if ((gpio >= 26) && (gpio < 33)) { /* UART1 */
+		em86xx_uart1_gpio_setdirection(gpio - 26, dir);
+	} else if ((gpio >= 33) && (gpio < 52)) { /* ETH0 */
+		gpio -= 33;
+		if (gpio < 16)
+			gbus_write_reg32(REG_BASE_host_interface + 0x6404, (1 << (gpio + 16)) | (dir << gpio));
+		else 
+			gbus_write_reg32(REG_BASE_host_interface + 0x640c, (1 << gpio) | (dir << (gpio - 16)));
+	} else if ((gpio >= 52) && (gpio < 71)) { /* ETH1 */
+		gpio -= 52;
+		if (gpio < 16)
+			gbus_write_reg32(REG_BASE_host_interface + 0x6c04, (1 << (gpio + 16)) | (dir << gpio));
+		else 
+			gbus_write_reg32(REG_BASE_host_interface + 0x6c0c, (1 << gpio) | (dir << (gpio - 16)));
+	} else if ((gpio >= 71) && (gpio < 78)) { /* SCARD0 */
+		unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+		if (chip_id == 0x8652)
+			return;
+		else if ((chip_id & 0xfff0) == 0x8670)
+			return;
+		else if ((chip_id & 0xfff0) == 0x8680)
+			return;
+		gpio -= 71;
+		gbus_write_reg32(REG_BASE_cpu_block + 0xc358, (1 << (gpio + 8)) | (dir << gpio));
+	} else if ((gpio >= 78) && (gpio < 85)) { /* SCARD1 */
+		unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+		if (chip_id == 0x8652)
+			return;
+		else if ((chip_id & 0xfff0) == 0x8670)
+			return;
+		else if ((chip_id & 0xfff0) == 0x8680)
+			return;
+		gpio -= 78;
+		gbus_write_reg32(REG_BASE_cpu_block + 0xc3d8, (1 << (gpio + 8)) | (dir << gpio));
+	} else if ((gpio == 85) || (gpio == 86)) {
+		unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+		if ((chip_id == 0x8656) || ((chip_id & 0xff00) == 0x8900))
+			return; /* not yet implemented */
+	} else if ((gpio >= 87) || (gpio < 94)) { /* UART2 */
+		unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+		if (chip_id == 0x8652)
+			em86xx_uart2_gpio_setdirection(gpio - 87, dir);
+		else if ((chip_id & 0xfff0) == 0x8670)
+			em86xx_uart2_gpio_setdirection(gpio - 87, dir);
+		else if ((chip_id & 0xfff0) == 0x8680)
+			em86xx_uart2_gpio_setdirection(gpio - 87, dir);
+	}
+}
+
+int em86xx_gpio_getmode(int gpio)
+{
+	if ((gpio >= 0) && (gpio < 16)) {
+		return 1; /* always in GPIO mode */
+	} else if ((gpio == 16) || (gpio == 17)) { /* TDMX_GPIO0/1 */
+		unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+		if ((chip_id != 0x8644) && (chip_id != 0x8642))
+			return -EINVAL;
+		return -EIO; /* not yet implemented */
+	} else if ((gpio >= 18) && (gpio < 25)) { /* UART0 */
+		unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+		if ((chip_id & 0xff00) == 0x8900)
+			return -EIO; /* not yet implemented */
+		return ((em86xx_uart0_get_gpio_mode() >> (gpio - 18)) & 1) ? 1 : 0;
+	} else if (gpio == 25) {
+		unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+		if (chip_id == 0x8652)
+			return -EIO; /* not yet implemented */
+		else if ((chip_id & 0xfff0) == 0x8670)
+			return -EIO; /* not yet implemented */
+		else if ((chip_id & 0xfff0) == 0x8680)
+			return -EIO; /* not yet implemented */
+		else if ((chip_id & 0xff00) == 0x8900)
+			return -EIO; /* not yet implemented */
+	} else if ((gpio >= 26) && (gpio < 33)) { /* UART1 */
+		return ((em86xx_uart1_get_gpio_mode() >> (gpio - 26)) & 1) ? 1 : 0;
+	} else if ((gpio >= 33) && (gpio < 52)) { /* ETH0 */
+		unsigned int pad_mode = gbus_read_reg32(REG_BASE_host_interface + 0x6400) & 7;
+		return (pad_mode == M_GPIO) ? 1 : 0;
+	} else if ((gpio >= 52) && (gpio < 71)) { /* ETH1 */
+		unsigned int pad_mode = gbus_read_reg32(REG_BASE_host_interface + 0x6c00) & 7;
+		return (pad_mode == M_GPIO) ? 1 : 0;
+	} else if ((gpio >= 71) && (gpio < 78)) { /* SCARD0 */
+		unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+		if (chip_id == 0x8652)
+			return -EINVAL;
+		else if ((chip_id & 0xfff0) == 0x8670)
+			return -EINVAL;
+		else if ((chip_id & 0xfff0) == 0x8680)
+			return -EINVAL;
+		return (gbus_read_reg32(REG_BASE_cpu_block + 0xc360) >> (gpio - 71)) & 1;
+	} else if ((gpio >= 78) && (gpio < 85)) { /* SCARD1 */
+		unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+		if (chip_id == 0x8652)
+			return -EINVAL;
+		else if ((chip_id & 0xfff0) == 0x8670)
+			return -EINVAL;
+		else if ((chip_id & 0xfff0) == 0x8680)
+			return -EINVAL;
+		return (gbus_read_reg32(REG_BASE_cpu_block + 0xc3e0) >> (gpio - 78)) & 1;
+	} else if ((gpio == 85) || (gpio == 86)) {
+		unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+		if ((chip_id == 0x8656) || ((chip_id & 0xff00) == 0x8900))
+			return -EIO; /* not yet implemented */
+	} else if ((gpio >= 87) || (gpio < 94)) { /* UART2 */
+		unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+		if (chip_id == 0x8652)
+			return ((em86xx_uart2_get_gpio_mode() >> (gpio - 87)) & 1) ? 1 : 0;
+		else if ((chip_id & 0xfff0) == 0x8670)
+			return ((em86xx_uart2_get_gpio_mode() >> (gpio - 87)) & 1) ? 1 : 0;
+		else if ((chip_id & 0xfff0) == 0x8680)
+			return ((em86xx_uart2_get_gpio_mode() >> (gpio - 87)) & 1) ? 1 : 0;
+	}
+	return -EINVAL;
+}
+
+int em86xx_gpio_setmode(int gpio, int mode, int *oldmode)
+{
+	int newmode = (mode != 0) ? 1 : 0;
+	if ((gpio >= 0) && (gpio < 16)) {
+		*oldmode = 1;
+		if (newmode == 0)
+			return -EINVAL; 
+	} else if ((gpio == 16) || (gpio == 17)) { /* TDMX_GPIO0/1 */
+		unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+		if ((chip_id != 0x8644) && (chip_id != 0x8642))
+			return -EINVAL;
+		return -EIO; /* not yet implemented */
+	} else if ((gpio >= 18) && (gpio < 25)) { /* UART0 */
+		unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+		if ((chip_id & 0xff00) == 0x8900)
+			return -EIO; /* not yet implemented */
+		else {
+			gpio -= 18;
+			*oldmode = (gbus_read_reg32(REG_BASE_cpu_block + CPU_uart0_gpio_mode) >> gpio) & 1;
+			gbus_write_reg32(REG_BASE_cpu_block + CPU_uart0_gpio_mode, (1 << (gpio + 8)) | (newmode << gpio));
+		}
+	} else if (gpio == 25) {
+		unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+		if (chip_id == 0x8652)
+			return -EIO; /* not yet implemented */
+		else if ((chip_id & 0xfff0) == 0x8670)
+			return -EIO; /* not yet implemented */
+		else if ((chip_id & 0xfff0) == 0x8680)
+			return -EIO; /* not yet implemented */
+		else if ((chip_id & 0xff00) == 0x8900)
+			return -EIO; /* not yet implemented */
+	} else if ((gpio >= 26) && (gpio < 33)) { /* UART1 */
+		gpio -= 26;
+		*oldmode = (gbus_read_reg32(REG_BASE_cpu_block + CPU_uart1_gpio_mode) >> gpio) & 1;
+		gbus_write_reg32(REG_BASE_cpu_block + CPU_uart1_gpio_mode, (1 << (gpio + 8)) | (newmode << gpio));
+	} else if ((gpio >= 33) && (gpio < 52)) { /* ETH0 */
+		unsigned int pad_mode = gbus_read_reg32(REG_BASE_host_interface + 0x6400) & 7;
+		if ((pad_mode != M_GPIO) && (newmode != 0)) {
+			*oldmode = 0;
+			gbus_write_reg32(REG_BASE_host_interface + 0x6400, (gbus_read_reg32(REG_BASE_host_interface + 0x6400) & ~7) | M_GPIO);
+		}
+	} else if ((gpio >= 52) && (gpio < 71)) { /* ETH1 */
+		unsigned int pad_mode = gbus_read_reg32(REG_BASE_host_interface + 0x6c00) & 7;
+		if ((pad_mode != M_GPIO) && (newmode != 0)) {
+			*oldmode = 0;
+			gbus_write_reg32(REG_BASE_host_interface + 0x6c00, (gbus_read_reg32(REG_BASE_host_interface + 0x6c00) & ~7) | M_GPIO);
+		}
+	} else if ((gpio >= 71) && (gpio < 78)) { /* SCARD0 */
+		unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+		if ((chip_id == 0x8656) || ((chip_id & 0xff00) == 0x8900))
+			return -EINVAL;
+		gpio -= 71;
+		*oldmode = (gbus_read_reg32(REG_BASE_cpu_block + 0xc360) >> gpio) & 1;
+		gbus_write_reg32(REG_BASE_cpu_block + 0xc360, (1 << (gpio + 8)) | (newmode << gpio));
+	} else if ((gpio >= 78) && (gpio < 85)) { /* SCARD1 */
+		unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+		if (chip_id == 0x8652)
+			return -EINVAL;
+		else if ((chip_id & 0xfff0) == 0x8670)
+			return -EINVAL;
+		else if ((chip_id & 0xfff0) == 0x8680)
+			return -EINVAL;
+		gpio -= 78;
+		*oldmode = (gbus_read_reg32(REG_BASE_cpu_block + 0xc3e0) >> gpio) & 1;
+		gbus_write_reg32(REG_BASE_cpu_block + 0xc3e0, (1 << (gpio + 8)) | (newmode << gpio));
+	} else if ((gpio == 85) || (gpio == 86)) {
+		unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+		if ((chip_id == 0x8656) || ((chip_id & 0xff00) == 0x8900))
+			return -EIO; /* not yet implemented */
+	} else if ((gpio >= 87) || (gpio < 94)) { /* UART2 */
+		unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+		if ((chip_id == 0x8652) || ((chip_id & 0xfff0) == 0x8670) || ((chip_id & 0xfff0) == 0x8680)) {
+			gpio -= 87;
+			*oldmode = (gbus_read_reg32(REG_BASE_cpu_block + CPU_uart2_gpio_mode) >> gpio) & 1;
+			gbus_write_reg32(REG_BASE_cpu_block + CPU_uart2_gpio_mode, (1 << (gpio + 8)) | (newmode << gpio));
+		}
+	} else
+		return -EINVAL;
+	return 0;
+}
+#else
+#error Undefined platform.
+#endif
+
+EXPORT_SYMBOL(em86xx_gpio_read);
+EXPORT_SYMBOL(em86xx_gpio_write);
+EXPORT_SYMBOL(em86xx_gpio_setdirection);
+
+#if defined(CONFIG_TANGO3)
+EXPORT_SYMBOL(em86xx_gpio_getmode);
+EXPORT_SYMBOL(em86xx_gpio_setmode);
+#endif
+
diff -Naur linux-3.9.2.ref/arch/mips/tangox/irq.c linux-3.9.2/arch/mips/tangox/irq.c
--- linux-3.9.2.ref/arch/mips/tangox/irq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/tangox/irq.c	2013-07-23 19:31:22.000000000 +0200
@@ -0,0 +1,460 @@
+/*
+ * Copyright 2001 MontaVista Software Inc.
+ * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
+ *
+ * Copyright (C) 2009 Sigma Designs, Inc.
+ *
+ * arch_init_irq for tango2/tango3
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <asm/irq_cpu.h>
+
+#include "setup.h"
+
+/*
+ * helpers to access cpu block registers
+ */
+#define RD_CPU_REG32(r)		\
+		gbus_read_reg32(REG_BASE_cpu_block + (r))
+
+#define WR_CPU_REG32(r, v)	\
+		do {								\
+			gbus_write_reg32(REG_BASE_cpu_block + (r), (v));	\
+			iob();							\
+		} while(0)	
+
+#if defined(CONFIG_TANGO3)
+extern int (*perf_irq)(void);		// defined in kernel/time.c, used in oprofile
+#endif
+
+static DEFINE_SPINLOCK(mips_irq_lock);
+static DEFINE_SPINLOCK(mips_fiq_lock);
+static DEFINE_SPINLOCK(mips_iiq_lock);
+
+static inline u64 get_irq_status(void)
+{
+	u64 status;
+	unsigned long flags;
+	spin_lock_irqsave(&mips_irq_lock, flags);
+	status = (((u64)RD_CPU_REG32(CPU_irq_status_hi))<<32) | ((u64)RD_CPU_REG32(CPU_irq_status));
+	spin_unlock_irqrestore(&mips_irq_lock, flags);
+	return status;
+}
+
+static inline u64 get_fiq_status(void)
+{
+	u64 status;
+	unsigned long flags;
+	spin_lock_irqsave(&mips_fiq_lock, flags);
+	status = (((u64)RD_CPU_REG32(CPU_fiq_status_hi))<<32) | ((u64)RD_CPU_REG32(CPU_fiq_status));
+	spin_unlock_irqrestore(&mips_fiq_lock, flags);
+	return status;
+}
+
+static inline u64 get_iiq_status(void)
+{
+	u64 status;
+	unsigned long flags;
+	spin_lock_irqsave(&mips_iiq_lock, flags);
+	status = (((u64)RD_CPU_REG32(CPU_iiq_status_hi))<<32) | ((u64)RD_CPU_REG32(CPU_iiq_status));
+	spin_unlock_irqrestore(&mips_iiq_lock, flags);
+	return status;
+}
+ 
+static inline int clz(unsigned long x)
+{
+	__asm__ (
+	"	.set	push					\n"
+	"	.set	mips32					\n"
+	"	clz	%0, %1					\n"
+	"	.set	pop					\n"
+	: "=r" (x)
+	: "r" (x));
+
+	return x;
+}
+
+static inline int clz64(u64 x)
+{
+	u32 xl = (u32)(x & 0xffffffff), xh = (u32)((x >> 32) & 0xffffffff);
+	return xh ? clz(xh) : clz(xl) + 32;
+}
+
+static inline unsigned int irq_ffs(unsigned int pending)
+{
+	return -clz(pending) + 31 - CAUSEB_IP;
+}
+
+extern int cp0_compare_irq;
+extern int cp0_perfcount_irq;
+
+static unsigned long edge_trig = 0;
+static unsigned long edge_trig_hi = 0;
+
+/*
+ * dispatch routine called from genex.S
+ */
+extern void spurious_interrupt(void);
+
+asmlinkage void plat_irq_dispatch(void)
+{
+	unsigned int pending = (read_c0_cause() & read_c0_status()) & ST0_IM;
+	int irq;
+	u64 status;
+
+	if (pending == 0) {
+		printk("spurious hwirq: nothing pending\n");
+		goto spurious;
+	} else {
+		irq = irq_ffs(pending);
+
+		switch(irq) {
+			case 2: if ((status = get_irq_status()) == 0) {
+					printk("spurious irq: 0x%llx\n", status);
+					goto spurious;
+				} else {
+					do_IRQ(IRQ_CONTROLLER_IRQ_BASE + (63 - clz64(status)));
+				}
+				break;
+
+			case 3: if ((status = get_fiq_status()) == 0) {
+					printk("spurious fiq: 0x%llx\n", status);
+					goto spurious;
+				} else {
+					/* We need to mask out irq, fiq > irq */
+					u32 sr_old = read_c0_status();
+					u32 sr_new = sr_old & (~STATUSF_IP2);
+
+					write_c0_status(sr_new);
+					do_IRQ(FIQ_CONTROLLER_IRQ_BASE + (63 - clz64(status)));
+					write_c0_status(sr_old);
+				}
+				break;
+
+			case 4: if ((status = get_iiq_status()) == 0) {
+					printk("spurious iiq: 0x%llx\n", status);
+					goto spurious;
+				} else {
+					/* We need to mask out fiq/irq, iiq > fiq > irq */
+					u32 sr_old = read_c0_status();
+					u32 sr_new = sr_old & (~(STATUSF_IP2|STATUSF_IP3));
+
+					write_c0_status(sr_new);
+					do_IRQ(IIQ_CONTROLLER_IRQ_BASE + (63 - clz64(status)));
+					write_c0_status(sr_old);
+				}
+				break;
+
+			default: if ((irq == cp0_compare_irq)
+#if defined(CONFIG_TANGO3)
+					|| (irq == cp0_perfcount_irq)
+#endif
+				) {
+					do_IRQ(irq);
+				} else { 
+					printk("spurious hwirq: %d\n", irq);
+					goto spurious;
+				}
+				break;
+		}
+	}
+	return;
+
+spurious:
+	spurious_interrupt();
+	return;
+}
+
+/*
+ * our hw_irq_controller cb
+ */
+static inline void tangox_irq_enable(struct irq_data *data)
+{
+	int bit = data->irq - IRQ_CONTROLLER_IRQ_BASE;
+	unsigned long flags;
+
+	spin_lock_irqsave(&mips_irq_lock, flags);
+	if (bit >= 32) 
+		WR_CPU_REG32(CPU_irq_enableset_hi, 1 << (bit - 32));
+	else 
+		WR_CPU_REG32(CPU_irq_enableset, 1 << bit);
+	spin_unlock_irqrestore(&mips_irq_lock, flags);
+}
+
+static inline void tangox_fiq_enable(struct irq_data *data)
+{
+	int bit = data->irq - FIQ_CONTROLLER_IRQ_BASE;
+	unsigned long flags;
+
+	spin_lock_irqsave(&mips_fiq_lock, flags);
+	if (bit >= 32) 
+		WR_CPU_REG32(CPU_fiq_enableset_hi, 1 << (bit - 32));
+	else
+		WR_CPU_REG32(CPU_fiq_enableset, 1 << bit);
+	spin_unlock_irqrestore(&mips_fiq_lock, flags);
+}
+
+static inline void tangox_iiq_enable(struct irq_data *data)
+{
+	int bit = data->irq - IIQ_CONTROLLER_IRQ_BASE;
+	unsigned long flags;
+
+	spin_lock_irqsave(&mips_iiq_lock, flags);
+	if (bit >= 32) 
+		WR_CPU_REG32(CPU_iiq_enableset_hi, 1 << (bit - 32));
+	else
+		WR_CPU_REG32(CPU_iiq_enableset, 1 << bit);
+	spin_unlock_irqrestore(&mips_iiq_lock, flags);
+}
+
+static inline void tangox_irq_disable(struct irq_data *data)
+{
+	int bit = data->irq - IRQ_CONTROLLER_IRQ_BASE;
+	unsigned long flags;
+
+	spin_lock_irqsave(&mips_irq_lock, flags);
+	if (bit >= 32) 
+		WR_CPU_REG32(CPU_irq_enableclr_hi, 1 << (bit - 32));
+	else
+		WR_CPU_REG32(CPU_irq_enableclr, 1 << bit);
+	spin_unlock_irqrestore(&mips_irq_lock, flags);
+}
+
+static inline void tangox_fiq_disable(struct irq_data *data)
+{
+	int bit = data->irq - FIQ_CONTROLLER_IRQ_BASE;
+	unsigned long flags;
+
+	spin_lock_irqsave(&mips_fiq_lock, flags);
+	if (bit >= 32) 
+		WR_CPU_REG32(CPU_fiq_enableclr_hi, 1 << (bit - 32));
+	else
+		WR_CPU_REG32(CPU_fiq_enableclr, 1 << bit);
+	spin_unlock_irqrestore(&mips_fiq_lock, flags);
+}
+
+static inline void tangox_iiq_disable(struct irq_data *data)
+{
+	int bit = data->irq - IIQ_CONTROLLER_IRQ_BASE;
+	unsigned long flags;
+
+	spin_lock_irqsave(&mips_iiq_lock, flags);
+	if (bit >= 32) 
+		WR_CPU_REG32(CPU_iiq_enableclr_hi, 1 << (bit - 32));
+	else
+		WR_CPU_REG32(CPU_iiq_enableclr, 1 << bit);
+	spin_unlock_irqrestore(&mips_iiq_lock, flags);
+}
+
+static unsigned int tangox_irq_startup(struct irq_data *data)
+{
+	int bit = data->irq - IRQ_CONTROLLER_IRQ_BASE;
+
+	/* clear any pending interrupt before enabling it */
+	if (bit >= 32) {
+		WR_CPU_REG32(CPU_edge_rawstat_hi, 1 << (bit - 32));
+	} else {
+		WR_CPU_REG32(CPU_edge_rawstat, 1 << bit);
+	}
+
+	tangox_irq_enable(data);
+	return 0;
+}
+
+static unsigned int tangox_fiq_startup(struct irq_data *data)
+{
+	int bit = data->irq - FIQ_CONTROLLER_IRQ_BASE;
+
+	/* clear any pending interrupt before enabling it */
+	if (bit >= 32) {
+		WR_CPU_REG32(CPU_edge_rawstat_hi, 1 << (bit - 32));
+	} else {
+		WR_CPU_REG32(CPU_edge_rawstat, 1 << bit);
+	}
+
+	tangox_fiq_enable(data);
+	return 0;
+}
+
+static unsigned int tangox_iiq_startup(struct irq_data *data)
+{
+	int bit = data->irq - IIQ_CONTROLLER_IRQ_BASE;
+
+	/* clear any pending interrupt before enabling it */
+	if (bit >= 32) {
+		WR_CPU_REG32(CPU_edge_rawstat_hi, 1 << (bit - 32));
+	} else {
+		WR_CPU_REG32(CPU_edge_rawstat, 1 << bit);
+	}
+
+	tangox_iiq_enable(data);
+	return 0;
+}
+
+#define	tangox_irq_shutdown tangox_irq_disable
+#define	tangox_fiq_shutdown tangox_fiq_disable
+#define	tangox_iiq_shutdown tangox_iiq_disable
+
+static void tangox_irq_ack(struct irq_data *data)
+{
+	int bit = data->irq - IRQ_CONTROLLER_IRQ_BASE;
+
+	tangox_irq_disable(data);
+
+	if (bit >= 32) {
+		WR_CPU_REG32(CPU_edge_rawstat_hi, 1 << (bit - 32));
+	} else {
+		WR_CPU_REG32(CPU_edge_rawstat, 1 << bit);
+	}
+}
+
+static void tangox_fiq_ack(struct irq_data *data)
+{
+	int bit = data->irq - FIQ_CONTROLLER_IRQ_BASE;
+
+	tangox_fiq_disable(data);
+
+	if (bit >= 32) {
+		WR_CPU_REG32(CPU_edge_rawstat_hi, 1 << (bit - 32));
+	} else {
+		WR_CPU_REG32(CPU_edge_rawstat, 1 << bit);
+	}
+}
+
+static void tangox_iiq_ack(struct irq_data *data)
+{
+	int bit = data->irq - IIQ_CONTROLLER_IRQ_BASE;
+
+	tangox_iiq_disable(data);
+
+	if (bit >= 32) {
+		WR_CPU_REG32(CPU_edge_rawstat_hi, 1 << (bit - 32));
+	} else {
+		WR_CPU_REG32(CPU_edge_rawstat, 1 << bit);
+	}
+}
+
+/*
+ * our hw_irq_controllers
+ */
+static struct irq_chip tangox_irq_controller = {
+	.name = "tangox_irq",
+	.irq_startup = tangox_irq_startup,
+	.irq_shutdown = tangox_irq_shutdown,
+	.irq_enable = tangox_irq_enable,
+	.irq_disable = tangox_irq_disable,
+	.irq_ack = tangox_irq_ack,
+	.irq_mask = tangox_irq_disable,
+	.irq_mask_ack = tangox_irq_ack,
+	.irq_unmask = tangox_irq_enable,
+	
+};
+
+static struct irq_chip tangox_fiq_controller = {
+	.name = "tangox_fiq",
+	.irq_startup = tangox_fiq_startup,
+	.irq_shutdown = tangox_fiq_shutdown,
+	.irq_enable = tangox_fiq_enable,
+	.irq_disable = tangox_fiq_disable,
+	.irq_ack = tangox_fiq_ack,
+	.irq_mask = tangox_fiq_disable,
+	.irq_mask_ack = tangox_fiq_ack,
+	.irq_unmask = tangox_fiq_enable,
+	
+};
+
+static struct irq_chip tangox_iiq_controller = {
+	.name = "tangox_iiq",
+	.irq_startup = tangox_iiq_startup,
+	.irq_shutdown = tangox_iiq_shutdown,
+	.irq_enable = tangox_iiq_enable,
+	.irq_disable = tangox_iiq_disable,
+	.irq_ack = tangox_iiq_ack,
+	.irq_mask = tangox_iiq_disable,
+	.irq_mask_ack = tangox_iiq_ack,
+	.irq_unmask = tangox_iiq_enable,
+	
+};
+
+static struct irqaction irq_cascade = {
+	.handler	= no_action,
+	.flags		= IRQF_SHARED,
+	.name		= "cascade",
+	.dev_id		= NULL,
+	.next		= NULL,
+};
+
+#if defined(CONFIG_TANGO3)
+irqreturn_t handle_perf_irq(int irqn, void *dummy) 
+{
+	return perf_irq();
+}
+
+static struct irqaction irq_perf_counters = {
+	.handler	= handle_perf_irq,
+	.flags		= 0,
+	.name		= "perf_counter",
+	.dev_id		= NULL,
+	.next		= NULL,
+};
+#endif
+
+void __init arch_init_irq(void)
+{
+	unsigned long x;
+	unsigned long rise = 0;
+	unsigned long fall = 0;
+	unsigned long rise_hi = 0;
+	unsigned long fall_hi = 0;
+
+	/* irq_desc entries 0..7 */
+	mips_cpu_irq_init();
+
+	WR_CPU_REG32(CPU_irq_enableclr, 0xffffffff);
+	WR_CPU_REG32(CPU_fiq_enableclr, 0xffffffff);
+	WR_CPU_REG32(CPU_iiq_enableclr, 0xffffffff);
+	WR_CPU_REG32(CPU_irq_enableclr_hi, 0xffffffff);
+	WR_CPU_REG32(CPU_fiq_enableclr_hi, 0xffffffff);
+	WR_CPU_REG32(CPU_iiq_enableclr_hi, 0xffffffff);
+
+	rise = RD_CPU_REG32(CPU_edge_config_rise);
+	fall = RD_CPU_REG32(CPU_edge_config_fall);
+	edge_trig = rise ^ fall;
+	WR_CPU_REG32(CPU_edge_rawstat, 0xffffffff);
+	rise_hi = RD_CPU_REG32(CPU_edge_config_rise_hi);
+	fall_hi = RD_CPU_REG32(CPU_edge_config_fall_hi);
+	edge_trig_hi = rise_hi ^ fall_hi;
+	WR_CPU_REG32(CPU_edge_rawstat_hi, 0xffffffff);
+
+	for (x = IRQ_CONTROLLER_IRQ_BASE; x < IRQ_CONTROLLER_IRQ_BASE + IRQ_COUNT; x++) {
+		irq_set_chip_and_handler(x, &tangox_irq_controller, handle_level_irq);
+	}
+
+	for (x = FIQ_CONTROLLER_IRQ_BASE; x < FIQ_CONTROLLER_IRQ_BASE + IRQ_COUNT; x++) {
+		irq_set_chip_and_handler(x, &tangox_fiq_controller, handle_level_irq);
+	}
+
+	for (x = IIQ_CONTROLLER_IRQ_BASE; x < IIQ_CONTROLLER_IRQ_BASE + IRQ_COUNT; x++) {
+		irq_set_chip_and_handler(x, &tangox_iiq_controller, handle_level_irq);
+	}
+
+	setup_irq(MIPS_CPU_IRQ_BASE + 2, &irq_cascade);
+	setup_irq(MIPS_CPU_IRQ_BASE + 3, &irq_cascade);
+	setup_irq(MIPS_CPU_IRQ_BASE + 4, &irq_cascade);
+
+#if defined(CONFIG_TANGO3)
+	if (cp0_perfcount_irq > 0)
+		setup_irq(cp0_perfcount_irq, &irq_perf_counters);
+#endif
+
+	return;
+}
+
diff -Naur linux-3.9.2.ref/arch/mips/tangox/Kconfig linux-3.9.2/arch/mips/tangox/Kconfig
--- linux-3.9.2.ref/arch/mips/tangox/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/tangox/Kconfig	2013-07-23 19:31:22.000000000 +0200
@@ -0,0 +1,397 @@
+
+#
+# environment selection
+#
+
+#
+# chip revision selection
+#
+
+choice 
+	prompt "Sigma Designs chips"
+	depends on TANGOX
+
+config TANGO2_ES6
+	bool "SMP863x ES6+"
+	select TANGO2_SMP863X
+	select TANGO2
+	help
+	  Support for Sigma Designs SMP863x chip (Tango2 architecture).
+
+config TANGO3_SMP8652
+	bool "SMP8652"
+	select TANGO3_SMP86XX
+	select TANGO3_865X
+	select TANGO3_8652
+	select TANGO3
+#	select HIGHMEM
+	help 
+	  Support for Sigma Designs SMP8652 chip (Tango3 architecture).
+
+config TANGO3_SMP8654
+	bool "SMP8654"
+	select TANGO3_SMP86XX
+	select TANGO3_865X
+	select TANGO3_8654
+	select TANGO3
+#	select HIGHMEM
+	help 
+	  Support for Sigma Designs SMP8654 chip (Tango3 architecture).
+
+config TANGO3_SMP8656OTP
+	bool "SMP8656 w/OTP"
+	select TANGO3_SMP86XX
+	select TANGO3_865X
+	select TANGO3
+#	select HIGHMEM
+	help 
+	  Support for Sigma Designs SMP8656 chip with OTP technology (aka 8656PS4/8656Bxx, Tango3)).
+
+config TANGO3_SMP8656SF
+	bool "SMP8656 w/Serial Flash"
+	select TANGO3_SMP86XX
+	select TANGO3_865X
+	select TANGO3
+#	select HIGHMEM
+	help 
+	  Support for Sigma Designs SMP8656 chip with embedded serial flash (aka 8656ES1/8656ES5/8656Axx/8656Cxx, Tango3)).
+
+config TANGO3_SMP8642
+	bool "SMP8642"
+	select TANGO3_SMP86XX
+	select TANGO3_864X
+	select TANGO3
+	help
+	  Sigma Designs SMP8642 chip (MIPS 74Kf core based), ES2 or above.
+	  Newer compiler may be needed to support 74Kf core (Tango3 architecture).
+
+config TANGO3_SMP8644
+	bool "SMP8644"
+	select TANGO3_SMP86XX
+	select TANGO3_864X
+	select TANGO3
+	help
+	  Sigma Designs SMP8644 chip (MIPS 74Kf core based), ES2 or above.
+	  Newer compiler may be needed to support 74Kf core (Tango3 architecture).
+
+config TANGO3_SMP8646
+	bool "SMP8646"
+	select TANGO3_SMP86XX
+	select TANGO3_864X
+	select TANGO3
+	help
+	  Sigma Designs SMP8646 chip (MIPS 74Kf core based), ES2 or above.
+	  Newer compiler may be needed to support 74Kf core (Tango3 architecture).
+
+config TANGO3_SMP8670
+	bool "SMP8670"
+	select TANGO3_SMP86XX
+	select TANGO3_867X
+	select TANGO3
+#	select HIGHMEM
+	help
+	  Sigma Designs SMP8670 chip (MIPS 24Kf core based), ES1 or above (Tango3).
+
+config TANGO3_SMP8672
+	bool "SMP8672"
+	select TANGO3_SMP86XX
+	select TANGO3_867X
+	select TANGO3
+	help
+	  Sigma Designs SMP8672 chip (MIPS 74Kf core based), ES1 or above (Tango3).
+
+config TANGO3_SMP8674
+	bool "SMP8674"
+	select TANGO3_SMP86XX
+	select TANGO3_867X
+	select TANGO3
+	help
+	  Sigma Designs SMP8674 chip (MIPS 24Kf core based), ES1 or above (Tango3).
+
+config TANGO3_SMP8680
+	bool "SMP8680"
+	select TANGO3_SMP86XX
+	select TANGO3_868X
+	select TANGO3
+	help
+	  Sigma Designs SMP8680 chip (MIPS 24Kf core based), ES1 or above (Tango3).
+
+config TANGO3_SMP8682
+	bool "SMP8682"
+	select TANGO3_SMP86XX
+	select TANGO3_868X
+	select TANGO3
+	help
+	  Sigma Designs SMP8682 chip (MIPS 24Kf core based), ES1 or above (Tango3).
+
+config TANGO3_SMP868A
+	bool "SMP868A"
+	select TANGO3_SMP86XX
+	select TANGO3_868X
+	select TANGO3
+	help
+	  Sigma Designs SMP868A chip (MIPS 24Kf core based, aka SMP8652HA), ES1 or above (Tango3).
+
+endchoice
+
+config TANGO2
+	bool
+
+config TANGO3
+	bool
+
+config TANGO2_SMP863X
+	bool
+	select IRQ_CPU
+	select HW_HAS_PCI
+	select NR_CPUS_DEFAULT_1
+	select USB_ARCH_HAS_OHCI
+	select USB_ARCH_HAS_EHCI
+
+config TANGO3_SMP86XX
+	bool
+	select CRYPTO_SHA256
+	select IRQ_CPU
+	select MIPS_CPU_SCACHE
+	select NR_CPUS_DEFAULT_1
+	select USB_ARCH_HAS_OHCI
+	select USB_ARCH_HAS_EHCI
+
+config TANGO3_865X
+	bool 
+	select HW_HAS_PCI
+
+config TANGO3_867X
+	bool 
+
+config TANGO3_868X
+	bool 
+
+config TANGO3_864X
+	bool
+
+comment "More configurations"
+	depends on TANGOX
+
+config TANGOX_SYSTEMRAM_ACTUALSIZE
+	int "System RAM size (in MB)"
+	depends on TANGOX
+	default 64
+	help
+	 This is the default amount of RAM available to the Linux kernel. It can be
+	 override with "mem=" command line option.
+
+config TANGOX_IGNORE_CMDLINE
+	bool "Ignore YAMON, XENV & memcfg command line"
+	depends on TANGOX
+	default n
+	help
+	 If you say  yes, boot command line from  YAMON, XENV & memcfg
+	 will be ignored. You can then use CONFIG_CMDLINE to force the
+	 kernel command line.
+
+config TANGOX_PROM_CONSOLE
+	bool "Register an early console"
+	depends on TANGOX
+	default n
+	help
+	 If you say yes, an light console will be available very early
+	 in the  boot process,  this is useful  if the  kernel crashes
+	 before reaching  the main console  code. The console  will be
+	 automatically replaced by the normal one after.
+	 ### NOTE: This console can only do output ###
+
+config TANGOX_FIXED_FREQUENCIES
+	bool "Specified fixed frequencies"
+	depends on TANGOX
+	default n 
+	help
+	 To specify, statically, the frequencies for CPU, System, and Base.
+	 Normally this is only used in experimental purpose where PLL may be
+	 set differently (typical for simulation or FPGA).
+
+config TANGOX_BASE_FREQUENCY
+	int "Base Frequency"
+	depends on TANGOX_FIXED_FREQUENCIES
+	default 27000000
+	help
+	 Base frequency (corresponding to XTAL in).
+
+config TANGOX_CPU_FREQUENCY
+	int "CPU Frequency"
+	depends on TANGOX_FIXED_FREQUENCIES
+	default 300000000
+	help
+	 CPU frequency.
+
+config TANGOX_SYS_FREQUENCY
+	int "System Frequency"
+	depends on TANGOX_FIXED_FREQUENCIES
+	default 200000000
+	help
+	 System frequency.
+
+config TANGOX_DSP_FREQUENCY
+ 	int "DSP Frequency"
+ 	depends on TANGOX_FIXED_FREQUENCIES
+ 	default 200000000
+ 	help
+ 	 DSP frequency.
+ 
+config TANGOX_UART_USE_SYSCLK
+	bool "Use system clock for UART"
+	depends on TANGOX
+	default n
+	help
+	 If you  say yes here, the UART  clock will be  derivated from the
+	 system bus clock. If  you say  no, the  XTAL_in clock  is used
+	 instead.
+
+config TANGOX_USE_TLB_REMAP_DRAM1
+	bool "Use TLB to access DRAM1"
+	depends on TANGO2_SMP863X 
+	default n
+	help
+	 If  you say yes  here, kernel  access to  DRAM1 will  be done
+	 using TLB implementation. gbus() funcs will use an ioremapped
+	 address to access this area of memory. If you say no, special
+	 CPU remap registers are used instead.
+
+#
+# XENV stuffs
+#
+comment "XENV support"
+	depends on TANGOX
+
+config TANGOX_XENV_READ
+	bool "Read config from XENV"
+	depends on TANGOX
+ 	select CRYPTO_SHA1 
+ 	select CRYPTO_SHA256 if TANGO3 
+	help
+	 If you  say yes  here, board configuration  (enabled devices,
+	 pci irq routing,  ...) will be read from  xenv space.
+
+config TANGOX_XENV_DUMP
+	bool "Dump XENV content at boot"
+	depends on TANGOX_XENV_READ
+	default n
+
+config TANGOX_XENV_READ_SAFE
+	bool "Don't boot if XENV invalid"
+	depends on TANGOX_XENV_READ
+	help
+	 If you say yes here and XENV content is invalid, linux wont boot.
+
+menu "XENV failsafe/override values"
+	depends on TANGOX && (!TANGOX_XENV_READ_SAFE)
+
+config TANGOX_XENV_DEF_CS0_SIZE
+	hex "CS0 size (flash0)"
+	default 0x0
+
+config TANGOX_XENV_DEF_CS1_SIZE
+	hex "CS1 size (flash1)"
+	default 0x0
+
+config TANGOX_XENV_DEF_CS2_SIZE
+	hex "CS2 size (flash2)"
+	default 0x400000
+
+config TANGOX_XENV_DEF_CS3_SIZE
+	hex "CS3 size (flash3)"
+	default 0x0
+
+config TANGOX_XENV_DEF_UART0
+	bool "UART0 enabled"
+	default y
+
+config TANGOX_XENV_DEF_UART1
+	bool "UART1 enabled"
+	default y
+
+config TANGOX_XENV_DEF_BAUDRATE
+	int "Default baudrate"
+	default 115200
+
+config TANGOX_XENV_DEF_CONSOLE_UART_PORT
+	int "Console UART port"
+	default 0
+
+config TANGOX_XENV_DEF_ENET
+	bool "Ethernet enabled"
+	default n
+
+config TANGOX_XENV_DEF_FIP
+	bool "FIP enabled"
+	default n
+
+config TANGOX_XENV_DEF_I2CM
+	bool "I2CM enabled"
+	default n
+
+config TANGOX_XENV_DEF_I2CS
+	bool "I2CS enabled"
+	default n
+
+config TANGOX_XENV_DEF_BMIDE
+	bool "BM IDE controller enabled"
+	default n
+
+config TANGOX_XENV_DEF_ISAIDE
+	bool "ISA IDE controller enabled"
+	default n
+
+config TANGOX_XENV_DEF_IR
+	bool "IR enabled"
+	default n
+
+config TANGOX_XENV_DEF_PCIHOST
+	bool "PCI Host enabled"
+	default n
+
+config TANGOX_XENV_DEF_PCI_ID1
+	bool "PCI device 1 enabled"
+	depends on TANGOX_XENV_DEF_PCIHOST
+	default n
+
+config TANGOX_XENV_DEF_PCI_ID1_IRQ
+	hex "PCI device 1 IRQ route"
+	depends on TANGOX_XENV_DEF_PCIHOST && TANGOX_XENV_DEF_PCI_ID1
+	default 0x0
+
+config TANGOX_XENV_DEF_PCI_ID2
+	bool "PCI device 2 enabled"
+	depends on TANGOX_XENV_DEF_PCIHOST
+	default n
+
+config TANGOX_XENV_DEF_PCI_ID2_IRQ
+	hex "PCI device 2 IRQ route"
+	depends on TANGOX_XENV_DEF_PCIHOST && TANGOX_XENV_DEF_PCI_ID2
+	default 0x0
+
+config TANGOX_XENV_DEF_PCI_ID3
+	bool "PCI device 3 enabled"
+	depends on TANGOX_XENV_DEF_PCIHOST
+	default n
+
+config TANGOX_XENV_DEF_PCI_ID3_IRQ
+	hex "PCI device 3 IRQ route"
+	depends on TANGOX_XENV_DEF_PCIHOST && TANGOX_XENV_DEF_PCI_ID3
+	default 0x0
+
+config TANGOX_XENV_DEF_PCI_ID4
+	bool "PCI device 4 enabled"
+	depends on TANGOX_XENV_DEF_PCIHOST
+	default n
+
+config TANGOX_XENV_DEF_PCI_ID4_IRQ
+	hex "PCI device 4 IRQ route"
+	depends on TANGOX_XENV_DEF_PCIHOST && TANGOX_XENV_DEF_PCI_ID4
+	default 0x0
+
+config TANGOX_XENV_DEF_USB
+	bool "USB enabled"
+	default n
+
+endmenu
diff -Naur linux-3.9.2.ref/arch/mips/tangox/Makefile linux-3.9.2/arch/mips/tangox/Makefile
--- linux-3.9.2.ref/arch/mips/tangox/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/tangox/Makefile	2013-07-23 19:31:22.000000000 +0200
@@ -0,0 +1,22 @@
+#
+# Makefile for SigmaDesigns Tango2/Tango3 board
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+
+obj-y += irq.o setup.o prom.o gbus.o xenv_config.o delay.o console.o
+
+obj-$(CONFIG_TANGO2) += cpucache.o
+
+obj-$(CONFIG_TANGOX_XENV_READ) += sha.o xenv.o xenv_config.o
+
+obj-$(CONFIG_TANGOX) += gpio.o
+
+obj-$(CONFIG_TANGOX) += mbus.o
+
+ifdef CONFIG_TANGO3
+obj-$(CONFIG_TANGOX_XENV_READ) += zxenv.o
+endif
+ 
diff -Naur linux-3.9.2.ref/arch/mips/tangox/mbus.c linux-3.9.2/arch/mips/tangox/mbus.c
--- linux-3.9.2.ref/arch/mips/tangox/mbus.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/tangox/mbus.c	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,1557 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2009
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+
+ 01/2009: Merged/adapted the codes from Jean-Francois Thibert (SageTV)
+ *********************************************************************/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+
+#include <asm/uaccess.h>
+#include <asm/r4kcache.h>
+#include <linux/pagemap.h>
+#include <linux/dma-mapping.h>
+
+#include "setup.h"
+
+#if !defined(CONFIG_TANGO2) && !defined(CONFIG_TANGO3)
+#error Undefined Sigma chip!!!
+#endif
+
+//#define MBUS_VERBOSE
+
+#ifdef MBUS_VERBOSE
+#define MSG	printk
+#else
+#define MSG(x, ...)
+#endif
+
+/*
+ * computed in prom.c
+ */
+extern unsigned long em8xxx_kmem_start;
+extern unsigned long em8xxx_kmem_size;
+
+/* uncomment this only if W1/R1 can be used (typically not) */
+// #define WITH_MBUS_W1R1
+
+/* put requester into wait queue if no channel pair available */
+#define MBUS_WAIT_QUEUE
+
+#ifdef MBUS_WAIT_QUEUE
+static DECLARE_WAIT_QUEUE_HEAD(mbus_wq);
+#endif
+
+/* max size for linear transfer */
+#define MBUS_LINEAR_MAX		(0x2000 - 1)
+
+/* the number of available channel pairs */
+#if defined(CONFIG_TANGO3)
+#define NUM_MBUS_CHNPS	3
+#else
+#define NUM_MBUS_CHNPS	2
+#endif /* CONFIG_TANGO3 */
+
+static DEFINE_SPINLOCK(mbus_lock); /* for controlling alloc/free of channel pair */
+static int mbus_free_cnt = 0; /* counter of available channel pairs */
+
+struct mbus_channel_pair
+{
+	unsigned int rx_base;	/* Rx base address */
+	unsigned int wx_base;	/* Wx base address */
+	const unsigned int shift;
+	const unsigned int rx;
+	const unsigned int idx;
+	const unsigned int rx_irq;
+	const unsigned int wx_irq;
+	const char *rx_irq_name;
+	const char *wx_irq_name;
+	spinlock_t lock;		/* spin_lock */
+	mbus_irq_handler_t handler;	
+	void *arg;
+	int iface;			/* which interface it's connected */
+	int fromdev;
+};
+
+static struct mbus_channel_pair mchnp_list[NUM_MBUS_CHNPS] = {
+	{ 
+		.fromdev = 0,
+		.rx_base = REG_BASE_host_interface + MIF_R0_ADD,
+		.wx_base = REG_BASE_host_interface + MIF_W0_ADD, 
+		.handler = NULL,
+		.arg = NULL,
+		.iface = 0xf,
+		.shift = 0,
+		.rx = 1,
+		.idx = 0,
+		.rx_irq = LOG2_CPU_HOST_MBUS_R0_INT,
+		.wx_irq = LOG2_CPU_HOST_MBUS_W0_INT,
+		.rx_irq_name = "tangox_mbus_r0",
+		.wx_irq_name = "tangox_mbus_w0",
+	},
+	{
+		.fromdev = 0,
+		.rx_base = REG_BASE_host_interface + MIF_R1_ADD,
+		.wx_base = REG_BASE_host_interface + MIF_W1_ADD, 
+		.handler = NULL,
+		.arg = NULL,
+#ifdef WITH_MBUS_W1R1
+		.iface = 0xf,
+#else
+		.iface = -1,	/* cannot be allocated */
+#endif
+		.shift = 4,
+		.rx = 2,
+		.idx = 1,
+		.rx_irq = LOG2_CPU_HOST_MBUS_R1_INT,
+		.wx_irq = LOG2_CPU_HOST_MBUS_W1_INT,
+		.rx_irq_name = "tangox_mbus_r1",
+		.wx_irq_name = "tangox_mbus_w1",
+	},
+#if defined(CONFIG_TANGO3)
+	{
+		.fromdev = 0,
+		.rx_base = REG_BASE_host_interface + MIF_R2_ADD,
+		.wx_base = REG_BASE_host_interface + MIF_W2_ADD, 
+		.handler = NULL,
+		.arg = NULL,
+		.iface = 0xf,
+		.shift = 32,
+		.rx = 9,
+		.idx = 2,
+		.rx_irq = LOG2_CPU_HOST_MBUS_R2_INT,
+		.wx_irq = LOG2_CPU_HOST_MBUS_W2_INT,
+		.rx_irq_name = "tangox_mbus_r2",
+		.wx_irq_name = "tangox_mbus_w2",
+	},
+#endif
+};
+
+static inline int mbus_channel_rewire(struct mbus_channel_pair *chnpptr, int iface, int fromdev)
+{
+	u64 route = 0;
+	int ret = -1;
+
+	if (chnpptr->iface != 0xf) 
+		goto done;
+
+	chnpptr->iface = iface;	/* connected */
+	chnpptr->fromdev = fromdev;
+	route = ((u64)(iface + 1)) << chnpptr->shift;	/* hook up Wx */
+	route |= (((u64)chnpptr->rx) << (iface * 4));	/* hook up Rx */
+	wmb();
+	MSG("(%d) %s:%d connect route=0x%llx\n", smp_processor_id(), __FILE__, __LINE__, route);
+	gbus_write_reg32(REG_BASE_host_interface + SBOX_ROUTE, (u32)(route & 0xffffffff));
+#if defined(CONFIG_TANGO3)
+	gbus_write_reg32(REG_BASE_host_interface + SBOX_ROUTE2, (u32)((route >> 32) & 0xffffffff));
+#endif
+	iob();
+	MSG("(%d) %s:%d allocate idx=%d\n", smp_processor_id(), __FILE__, __LINE__, chnpptr->idx);
+	ret = 0;
+
+done:
+	return ret;
+}
+
+/*
+ * given SBOX interface, find/connect one of the available MBUS channel pairs
+ * (i.e. Wx/Rx) and return the channel pair.
+ */
+static struct mbus_channel_pair *mbus_channel_pair_alloc(int iface, int fromdev, int canwait)
+{
+	int i;
+	unsigned long flags;
+	struct mbus_channel_pair *ret = NULL, *chnpptr = NULL;
+	static int order = 0;
+
+	spin_lock_irqsave(&mbus_lock, flags);
+
+	/* look for existed connection first */
+	for (chnpptr = &mchnp_list[0], i = 0; i < NUM_MBUS_CHNPS; i++, chnpptr++) {
+		if (chnpptr->iface == iface) { /* allocated to it already */
+			chnpptr->fromdev = fromdev;
+			ret = chnpptr;
+			MSG("(%d) %s:%d allocated idx=%d\n", smp_processor_id(), __FILE__, __LINE__, chnpptr->idx);
+			goto done;
+		}
+	}
+
+	if (mbus_free_cnt == 0) { /* no channel pair available */
+#ifdef MBUS_WAIT_QUEUE
+		if (canwait) {
+			while (mbus_free_cnt == 0) {
+				spin_unlock_irqrestore(&mbus_lock, flags);
+				if (wait_event_interruptible(mbus_wq, mbus_free_cnt != 0)) 
+					return NULL; /* being interrupted */
+				spin_lock_irqsave(&mbus_lock, flags);
+			}
+		} else 
+#endif
+			goto done;
+	}
+		
+	/* no existed connection found, try forming new connection */
+	if (order == 0) {
+		for (chnpptr = &mchnp_list[0], i = 0; i < NUM_MBUS_CHNPS; i++, chnpptr++) {
+			if (mbus_channel_rewire(chnpptr, iface, fromdev) == 0) {
+				ret = chnpptr;
+				break;
+			}
+		}
+	} else {
+		for (chnpptr = &mchnp_list[NUM_MBUS_CHNPS - 1], i = NUM_MBUS_CHNPS - 1; i >= 0; i--, chnpptr--) {
+			if (mbus_channel_rewire(chnpptr, iface, fromdev) == 0) {
+				ret = chnpptr;
+				break;
+			}
+		}
+	}
+	if (ret) { /* new allocation is done */
+		order = (order ? 0 : 1); /* swap order */
+		--mbus_free_cnt;
+		wmb();
+	}
+
+done:
+	spin_unlock_irqrestore(&mbus_lock, flags);
+	return ret;
+}
+
+/*
+ * free up allocated channel pair based on given SBOX interface.
+ */
+static int mbus_channel_pair_free(int iface)
+{
+	int i, ret = -1;
+	unsigned long flags;
+	struct mbus_channel_pair *chnpptr = NULL;
+
+	spin_lock_irqsave(&mbus_lock, flags);
+
+	for (chnpptr = &mchnp_list[0], i = 0; i < NUM_MBUS_CHNPS; i++, chnpptr++) {
+		if (chnpptr->iface == iface) { /* matched */
+			u64 route = 0;
+			chnpptr->fromdev = 0;
+			chnpptr->iface = 0xf;	/* disconnected */
+			route = ((u64)0xf) << chnpptr->shift;	/* hook up Wx */
+			route |= (((u64)0xf) << (iface * 4));	/* hook up Rx */
+			MSG("(%d) %s:%d disconnect route=0x%llx\n", smp_processor_id(), __FILE__, __LINE__, route);
+			wmb();
+			gbus_write_reg32(REG_BASE_host_interface + SBOX_ROUTE, (u32)(route & 0xffffffff));
+#if defined(CONFIG_TANGO3)
+			gbus_write_reg32(REG_BASE_host_interface + SBOX_ROUTE2, (u32)((route >> 32) & 0xffffffff));
+#endif
+			iob();
+			MSG("(%d) %s:%d free idx=%d\n", smp_processor_id(), __FILE__, __LINE__, chnpptr->idx);
+#ifdef CONFIG_TANGO2
+			MSG("(%d) %s:%d route=0x%x\n", smp_processor_id(), __FILE__, __LINE__, gbus_read_reg32(REG_BASE_host_interface + SBOX_ROUTE));
+#else
+			MSG("(%d) %s:%d route=0x%x%08x\n", smp_processor_id(), __FILE__, __LINE__, gbus_read_reg32(REG_BASE_host_interface + SBOX_ROUTE2), gbus_read_reg32(REG_BASE_host_interface + SBOX_ROUTE));
+#endif
+			ret = 0;
+			++mbus_free_cnt;
+			wmb();
+#ifdef MBUS_WAIT_QUEUE
+			if (mbus_free_cnt == 1) /* one channel pair is available */
+				wake_up_interruptible(&mbus_wq);
+#endif
+			break;
+		}
+	}
+
+	spin_unlock_irqrestore(&mbus_lock, flags);
+	BUG_ON(ret != 0);
+	return ret;
+}
+
+static __init void sbox_init(void)
+{
+	/* Resetting all (or most) channels first */
+	int i;
+	for (i = 0; i < 2; i++) {
+#if defined(CONFIG_TANGO3)
+#ifdef WITH_MBUS_W1R1
+		gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET, 0xffffffff);
+		iob();
+		gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET, 0xff00ff00);
+#else
+		/* Leave W1/R1 alone. */
+		gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET, 0xfdfdfdfd);
+		iob();
+		gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET, 0xfd00fd00);
+#endif
+		gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET2, 0x03030303);
+		iob();
+		gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET2, 0x03000300);
+#else
+#ifdef WITH_MBUS_W1R1
+		gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET, 0x7f7f7f7f);
+		iob();
+		gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET, 0x7f007f00);
+#else
+		/* Leave W1/R1 alone. */
+		gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET, 0x7d7d7d7d);
+		iob();
+		gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET, 0x7d007d00);
+#endif
+#endif
+		iob();
+		udelay(2); /* at least 256 system cycles, 128MHz or above */
+	}
+
+	/* Disconnect all (or most) channels */
+#if defined(CONFIG_TANGO3)
+#ifdef WITH_MBUS_W1R1
+	gbus_write_reg32(REG_BASE_host_interface + SBOX_ROUTE, 0xffff4fff);
+#else
+	gbus_write_reg32(REG_BASE_host_interface + SBOX_ROUTE, 0xffff4f0f);
+#endif
+	gbus_write_reg32(REG_BASE_host_interface + SBOX_ROUTE2, 0x000000ff);
+#else
+#ifdef WITH_MBUS_W1R1
+	gbus_write_reg32(REG_BASE_host_interface + SBOX_ROUTE, 0xffff4fff);
+#else
+	gbus_write_reg32(REG_BASE_host_interface + SBOX_ROUTE, 0xffff4f0f);
+#endif
+#endif
+	iob();
+#ifdef CONFIG_TANGO2
+	MSG("(%d) %s:%d route=0x%x\n", smp_processor_id(), __FILE__, __LINE__, gbus_read_reg32(REG_BASE_host_interface + SBOX_ROUTE));
+#else
+	MSG("(%d) %s:%d route=0x%x%08x\n", smp_processor_id(), __FILE__, __LINE__, gbus_read_reg32(REG_BASE_host_interface + SBOX_ROUTE2), gbus_read_reg32(REG_BASE_host_interface + SBOX_ROUTE));
+#endif
+}
+
+/*
+ * convert MBUS register address to channel pair
+ */
+#if defined(CONFIG_TANGO2) || defined(CONFIG_TANGO3)
+/* old mbus semantics */
+static struct mbus_channel_pair *__old_mbus_reg2chnp(unsigned int regbase)
+{
+	int idx = (regbase - (REG_BASE_host_interface + MIF_W0_ADD)) / 0x40;
+#if defined(CONFIG_TANGO3)
+	static const int chnps[6] = { 0, 1, 0, 1, 2, 2 };
+#elif defined(CONFIG_TANGO2)
+	static const int chnps[4] = { 0, 1, 0, 1 };
+#endif
+	return &mchnp_list[chnps[idx]];
+}
+#endif
+
+#if defined(CONFIG_TANGO3)
+static struct mbus_channel_pair *__new_mbus_reg2chnp(unsigned int regbase)
+{
+	int idx = (regbase - (REG_BASE_host_interface + MIF_W0_ADD)) / 0x40;
+	static const int chnps[8] = { 0, 1, 2, 3, 0, 1, 2, 3 };
+	BUG_ON(chnps[idx] > 2); /* No W3/R3 yet */
+	return &mchnp_list[chnps[idx]];
+}
+#endif
+
+static struct mbus_channel_pair *(*__mbus_reg2chnp)(unsigned int) = NULL;
+
+/*
+ * alloc mbus dma channels, need to be called before setup ...
+ */
+struct mbus_channel_pair *tangox_mbus_alloc_dma(int iface, int fromdev, int canwait)
+{
+	struct mbus_channel_pair *chnpptr = NULL;
+
+	chnpptr = mbus_channel_pair_alloc(iface, fromdev, 
+			(in_atomic() || in_interrupt()) ? 0 : canwait);
+
+	return chnpptr;
+}
+
+/*
+ * free mbus dma channels, need to be called after transfer is done ...
+ */
+void tangox_mbus_free_dma(struct mbus_channel_pair *chnpptr, int iface)
+{
+//	int tangox_mbus_wait(struct mbus_channel_pair *chnpptr, int iface);
+//	tangox_mbus_wait(chnpptr, iface);
+
+	if (mbus_channel_pair_free(iface) != 0) 
+		BUG(); /* freeing non-allocated channels? */
+}
+
+/*
+ * check if mbus is in use for given regbase
+ */
+static inline int __tangox_mbus_inuse(struct mbus_channel_pair *chnpptr, unsigned int rwbase)
+{
+	if (unlikely(chnpptr == NULL)) {
+		MSG("(%d) %s:%d ...\n", smp_processor_id(), __FILE__, __LINE__);
+		BUG();
+	}
+	if (rwbase)
+		return gbus_read_reg32(rwbase + MIF_cmd_offset) & 0x7; 
+	else
+		return gbus_read_reg32((chnpptr->fromdev ? chnpptr->wx_base : chnpptr->rx_base) + MIF_cmd_offset) & 0x7; 
+}
+
+static inline int tangox_mbus_inuse(struct mbus_channel_pair *chnpptr)
+{
+	return __tangox_mbus_inuse(chnpptr, 0);
+}
+
+/*
+ * irq handler for mbus interrupt
+ */
+static irqreturn_t tangox_mbus_intr(int irq, void *devinfo)
+{
+	struct mbus_channel_pair *chnpptr = (struct mbus_channel_pair *)devinfo;
+	unsigned long flags;
+	mbus_irq_handler_t f;
+	void *arg = NULL;
+	unsigned int rwbase;
+	
+	spin_lock_irqsave(&chnpptr->lock, flags);
+#ifdef CONFIG_TANGO2
+	MSG("(%d) %s:%d intr(%d) idx %d, iface %d, route=0x%x, handler=0x%p\n", smp_processor_id(), __FILE__, __LINE__, irq, chnpptr->idx, chnpptr->iface, gbus_read_reg32(REG_BASE_host_interface + SBOX_ROUTE), chnpptr->handler);
+#else
+	MSG("(%d) %s:%d intr(%d) idx %d, iface %d, route=0x%x%08x, handler=0x%p\n", smp_processor_id(), __FILE__, __LINE__, irq, chnpptr->idx, chnpptr->iface, gbus_read_reg32(REG_BASE_host_interface + SBOX_ROUTE2), gbus_read_reg32(REG_BASE_host_interface + SBOX_ROUTE), chnpptr->handler);
+#endif
+
+	rwbase = chnpptr->fromdev ? chnpptr->wx_base : chnpptr->rx_base;
+	if (gbus_read_reg32(rwbase + MIF_cmd_offset) & 0x7)
+		MSG("(%d) %s:%d, mbus busy (irq=%d, idx=%d) ...\n", smp_processor_id(), __FILE__, __LINE__, irq, chnpptr->idx);
+
+	if ((f = chnpptr->handler) != NULL) {
+		arg = chnpptr->arg;
+		chnpptr->handler = chnpptr->arg = NULL;	/* one shot only */
+		wmb();
+	} 
+	spin_unlock_irqrestore(&chnpptr->lock, flags);
+	if (f != NULL)
+		f(irq, arg);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * register mbus interrupt if not done
+ */
+static __init void mbus_register_intr(void)
+{
+	struct mbus_channel_pair *chnpptr = NULL;
+	int i;
+
+	for (chnpptr = &mchnp_list[0], i = 0; i < NUM_MBUS_CHNPS; i++, chnpptr++) {
+		if (chnpptr->iface < 0) 
+			continue;
+		if (request_irq(chnpptr->wx_irq + IRQ_CONTROLLER_IRQ_BASE, tangox_mbus_intr, IRQF_DISABLED, chnpptr->wx_irq_name, chnpptr) != 0) 
+			printk("MBUS: fail to register MBUS ISR(%d)\n", chnpptr->wx_irq + IRQ_CONTROLLER_IRQ_BASE);
+		if (request_irq(chnpptr->rx_irq + IRQ_CONTROLLER_IRQ_BASE, tangox_mbus_intr, IRQF_DISABLED, chnpptr->rx_irq_name, chnpptr) != 0) 
+			printk("MBUS: fail to register MBUS ISR(%d)\n", chnpptr->rx_irq + IRQ_CONTROLLER_IRQ_BASE);
+	}
+}
+
+#if defined(CONFIG_TANGO2) || defined(CONFIG_TANGO3)
+/* old mbus semantics */
+static void __old_mbus_linear(unsigned int rwbase, unsigned int flags)
+{
+	gbus_write_reg32(rwbase + MIF_cmd_offset, (flags<<2)|0x1);
+}
+
+static void __old_mbus_double(unsigned int rwbase, unsigned int flags)
+{
+	gbus_write_reg32(rwbase + MIF_cmd_offset, (flags<<2)|0x2);
+}
+
+static void __old_mbus_rectangle(unsigned int rwbase, unsigned int flags)
+{
+	gbus_write_reg32(rwbase + MIF_cmd_offset, (flags<<2)|0x3);
+}
+
+static void __old_mbus_void(unsigned int rwbase)
+{
+	gbus_write_reg32(rwbase + MIF_cmd_offset, 1<<2);
+}
+#endif
+
+#if defined(CONFIG_TANGO3)
+/* new mbus semantics */
+static void __new_mbus_linear(unsigned int rwbase, unsigned int flags)
+{
+	gbus_write_reg32(rwbase + MIF_cmd_offset, flags|0x2);
+}
+
+static void __new_mbus_double(unsigned int rwbase, unsigned int flags)
+{
+	gbus_write_reg32(rwbase + MIF_cmd_offset, flags|0x4);
+}
+
+static void __new_mbus_rectangle(unsigned int rwbase, unsigned int flags)
+{
+	gbus_write_reg32(rwbase + MIF_cmd_offset, flags|0x6);
+}
+
+static void __new_mbus_void(unsigned int rwbase)
+{
+	gbus_write_reg32(rwbase + MIF_cmd_offset, 1);
+}
+#endif
+
+static void (*__mbus_linear_action)(unsigned int, unsigned int) = NULL;
+static void (*__mbus_double_action)(unsigned int, unsigned int) = NULL;
+static void (*__mbus_rectangle_action)(unsigned int, unsigned int) = NULL;
+static void (*__mbus_void_action)(unsigned int) = NULL;
+
+/*
+ * setup mbus register to start a linear transfer (count bytes from
+ * addr, where count < MBUS_LINEAR_MAX)
+ */
+static void __mbus_setup_dma_linear(struct mbus_channel_pair *chnpptr,
+					unsigned int addr,
+					unsigned int count,
+					unsigned int flags,
+					unsigned int regbase)
+{
+	unsigned int rwbase;
+#if !defined(CONFIG_SD_DIRECT_DMA) && !defined(CONFIG_HIGHMEM)
+	if ((tangox_inv_dma_address(addr) < CPHYSADDR(em8xxx_kmem_start)) || (tangox_inv_dma_address(addr) >= (CPHYSADDR(em8xxx_kmem_start) + em8xxx_kmem_size)))
+		printk("MBUS Warning (linear): bad transfer address 0x%08x\n", addr);
+#endif
+	if (unlikely(chnpptr == NULL)) {
+		MSG("(%d) %s:%d ...\n", smp_processor_id(), __FILE__, __LINE__);
+		BUG();
+	}
+
+#ifdef CONFIG_TANGO2
+	MSG("(%d) %s:%d setup_dma_linear idx=%d, route=0x%x, flags=%d\n", smp_processor_id(), __FILE__, __LINE__, gbus_read_reg32(REG_BASE_host_interface + SBOX_ROUTE), flags);
+#else
+	MSG("(%d) %s:%d setup_dma_linear idx=%d, route=0x%x%08x, flags=%d\n", smp_processor_id(), __FILE__, __LINE__, chnpptr->idx, gbus_read_reg32(REG_BASE_host_interface + SBOX_ROUTE2), gbus_read_reg32(REG_BASE_host_interface + SBOX_ROUTE), flags);
+#endif
+	rwbase = regbase ? regbase : (chnpptr->fromdev ? chnpptr->wx_base : chnpptr->rx_base);
+	gbus_write_reg32(rwbase + MIF_add_offset, addr);
+	gbus_write_reg32(rwbase + MIF_cnt_offset, count);
+	iob();
+	(*__mbus_linear_action)(rwbase, flags);
+	iob();
+}
+
+/*
+ * setup mbus register to start a double transfer (count bytes from
+ * addr and count2 bytes from addr2, where count < MBUS_LINEAR_MAX and
+ * count2 < MBUS_LINEAR_MAX)
+ */
+static void __mbus_setup_dma_double(struct mbus_channel_pair *chnpptr,
+					unsigned int addr,
+					unsigned int count,
+					unsigned int addr2,
+					unsigned int count2,
+					unsigned int flags,
+					unsigned int regbase)
+{
+	unsigned int rwbase;
+#if !defined(CONFIG_SD_DIRECT_DMA) && !defined(CONFIG_HIGHMEM)
+	if ((tangox_inv_dma_address(addr) < CPHYSADDR(em8xxx_kmem_start)) || (tangox_inv_dma_address(addr) >= (CPHYSADDR(em8xxx_kmem_start) + em8xxx_kmem_size)))
+		printk("MBUS Warning (double): bad transfer address 0x%08x\n", addr);
+	if ((tangox_inv_dma_address(addr2) < CPHYSADDR(em8xxx_kmem_start)) || (tangox_inv_dma_address(addr2) >= (CPHYSADDR(em8xxx_kmem_start) + em8xxx_kmem_size)))
+		printk("MBUS Warning (double): bad transfer address2 0x%08x\n", addr2);
+#endif
+	if (unlikely(chnpptr == NULL)) {
+		MSG("(%d) %s:%d ...\n", smp_processor_id(), __FILE__, __LINE__);
+		BUG();
+	}
+
+#ifdef CONFIG_TANGO2
+	MSG("(%d) %s:%d setup_dma_dbl idx=%d, route=0x%x, flags=%d\n", smp_processor_id(), __FILE__, __LINE__, chnpptr->idx, gbus_read_reg32(REG_BASE_host_interface + SBOX_ROUTE), flags);
+#else
+	MSG("(%d) %s:%d setup_dma_dbl idx=%d, route=0x%x%08x, flags=%d\n", smp_processor_id(), __FILE__, __LINE__, chnpptr->idx, gbus_read_reg32(REG_BASE_host_interface + SBOX_ROUTE2), gbus_read_reg32(REG_BASE_host_interface + SBOX_ROUTE), flags);
+#endif
+	rwbase = regbase ? regbase : (chnpptr->fromdev ? chnpptr->wx_base : chnpptr->rx_base);
+	gbus_write_reg32(rwbase + MIF_add_offset, addr);
+	gbus_write_reg32(rwbase + MIF_cnt_offset, (count2 << 16) | count);
+	gbus_write_reg32(rwbase + MIF_add2_skip_offset, addr2);
+	iob();
+	(*__mbus_double_action)(rwbase, flags);
+	iob();
+}
+
+/*
+ * setup mbus register to start a rectangle transfer (horiz * lines
+ * bytes from addr, where horiz < MBUS_LINEAR_MAX and lines  <
+ * MBUS_LINEAR_MAX)
+ */
+static void __mbus_setup_dma_rectangle(struct mbus_channel_pair *chnpptr,
+					unsigned int addr,
+					unsigned int horiz,
+					unsigned int lines,
+					unsigned int flags,
+					unsigned int regbase)
+{
+	unsigned int rwbase;
+#if !defined(CONFIG_SD_DIRECT_DMA) && !defined(CONFIG_HIGHMEM)
+	if ((tangox_inv_dma_address(addr) < CPHYSADDR(em8xxx_kmem_start)) || (tangox_inv_dma_address(addr) >= (CPHYSADDR(em8xxx_kmem_start) + em8xxx_kmem_size)))
+		printk("MBUS Warning (rectangle): bad transfer address 0x%08x\n", addr);
+#endif
+	if (unlikely(chnpptr == NULL)) {
+		MSG("(%d) %s:%d ...\n", smp_processor_id(), __FILE__, __LINE__);
+		BUG();
+	}
+
+#ifdef CONFIG_TANGO2
+	MSG("(%d) %s:%d setup_dma_rect idx=%d, route=0x%x, flags=%d\n", smp_processor_id(), __FILE__, __LINE__, chnpptr->idx, gbus_read_reg32(REG_BASE_host_interface + SBOX_ROUTE), flags);
+#else
+	MSG("(%d) %s:%d setup_dma_rect idx=%d, route=0x%x%08x, flags=%d\n", smp_processor_id(), __FILE__, __LINE__, chnpptr->idx, gbus_read_reg32(REG_BASE_host_interface + SBOX_ROUTE2), gbus_read_reg32(REG_BASE_host_interface + SBOX_ROUTE), flags);
+#endif
+	rwbase = regbase ? regbase : (chnpptr->fromdev ? chnpptr->wx_base : chnpptr->rx_base);
+	gbus_write_reg32(rwbase + MIF_add_offset, addr);
+	gbus_write_reg32(rwbase + MIF_cnt_offset, (lines << 16) | horiz);
+	gbus_write_reg32(rwbase + MIF_add2_skip_offset, horiz);
+	iob();
+	(*__mbus_rectangle_action)(rwbase, flags);
+	iob();
+}
+
+/*
+ * setup void transaction 
+ */
+static void __mbus_setup_dma_void(struct mbus_channel_pair *chnpptr,
+					unsigned int regbase)
+{
+	unsigned int rwbase;
+
+	if (unlikely(chnpptr == NULL)) {
+		MSG("(%d) %s:%d ...\n", smp_processor_id(), __FILE__, __LINE__);
+		BUG();
+	}
+
+#ifdef CONFIG_TANGO2
+	MSG("(%d) %s:%d setup_dma_void idx=%d, route=0x%x\n", smp_processor_id(), __FILE__, __LINE__, chnpptr->idx, gbus_read_reg32(REG_BASE_host_interface + SBOX_ROUTE));
+#else
+	MSG("(%d) %s:%d setup_dma_void idx=%d, route=0x%x%08x\n", smp_processor_id(), __FILE__, __LINE__, chnpptr->idx, gbus_read_reg32(REG_BASE_host_interface + SBOX_ROUTE2), gbus_read_reg32(REG_BASE_host_interface + SBOX_ROUTE));
+#endif
+	rwbase = regbase ? regbase : (chnpptr->fromdev ? chnpptr->wx_base : chnpptr->rx_base);
+	(*__mbus_void_action)(rwbase);
+	iob();
+}
+
+/* 
+ * register a mbus interrupt handler, the caller is responsible to start the MBUS 
+ * transaction itself, it'd better to register notification before startng the transfer
+ */
+int tangox_mbus_notification(struct mbus_channel_pair *chnpptr, mbus_irq_handler_t handler, void *arg)
+{
+	unsigned long flgs;
+
+	if (unlikely(chnpptr == NULL)) {
+		MSG("(%d) %s:%d ...\n", smp_processor_id(), __FILE__, __LINE__);
+		BUG();
+	}
+	spin_lock_irqsave(&chnpptr->lock, flgs);
+	chnpptr->handler = handler;
+	chnpptr->arg = arg;
+	wmb();
+	spin_unlock_irqrestore(&chnpptr->lock, flgs);
+	return 0;
+}
+
+/*
+ * start a mbus dma, use this after a sucessfull call to
+ * tangox_mbus_alloc_dma
+ */
+static int __tangox_mbus_setup_dma(struct mbus_channel_pair *chnpptr,unsigned int addr,
+					unsigned int count, mbus_irq_handler_t handler,
+					void *arg, unsigned int tflags, unsigned int regbase)
+{
+	unsigned long flgs;
+	unsigned int horiz, lines, sz;
+	int idx;
+
+	if (unlikely(chnpptr == NULL)) {
+		MSG("(%d) %s:%d ...\n", smp_processor_id(), __FILE__, __LINE__);
+		BUG();
+	}
+
+	/*
+	 * make sure no one uses the mbus before
+	 */
+	if (unlikely((sz = __tangox_mbus_inuse(chnpptr, regbase)) != 0)) {
+		printk(KERN_ERR "MBUS: error previous command is pending (%d:%d) ...\n", chnpptr->idx, sz);
+		return 1;
+	}
+
+	/* registering given handler */
+	spin_lock_irqsave(&chnpptr->lock, flgs);
+	chnpptr->handler = handler;
+	chnpptr->arg = arg;
+	wmb();
+	MSG("(%d) %s:%d setup_dma idx=%d\n", smp_processor_id(), __FILE__, __LINE__, chnpptr->idx);
+	spin_unlock_irqrestore(&chnpptr->lock, flgs);
+
+	/*
+	 * decide which dma function to use depending on count
+	 */
+	if (count == 0) {
+		__mbus_setup_dma_void(chnpptr, regbase);
+	} else if (count <= MBUS_LINEAR_MAX) {
+		__mbus_setup_dma_linear(chnpptr, addr, count, tflags, regbase);
+	} else if (count <= (MBUS_LINEAR_MAX * 2)) {
+		__mbus_setup_dma_double(chnpptr, addr, MBUS_LINEAR_MAX,
+				      addr + MBUS_LINEAR_MAX,
+				      count - MBUS_LINEAR_MAX, tflags, regbase);
+	} else {
+		/*
+		 * we need to use rectangle, compute  horiz & lines
+		 * values to use
+		 */
+		for (idx = 0, horiz = 1, sz = count; (idx < 10) && ((sz & 0x01) == 0); ++idx, horiz <<= 1, sz >>= 1)
+			;
+		lines = count >> idx;
+		if ((horiz > MBUS_LINEAR_MAX) || (lines > MBUS_LINEAR_MAX)) {
+			printk(KERN_ERR "MBUS: can't handle rectangle transfer "
+		       		"of %d bytes (h: %d, v: %d)\n", count, horiz, lines);
+			BUG();
+			return 1;
+		}
+		__mbus_setup_dma_rectangle(chnpptr, addr, horiz, lines, tflags, regbase);
+	}
+	return 0;
+}
+
+int tangox_mbus_setup_dma(struct mbus_channel_pair *chnpptr,unsigned int addr,
+					unsigned int count, mbus_irq_handler_t handler,
+					void *arg, unsigned int tflags)
+{
+	return __tangox_mbus_setup_dma(chnpptr, addr, count, handler, arg, tflags, 0);
+}
+
+EXPORT_SYMBOL(tangox_mbus_alloc_dma);
+EXPORT_SYMBOL(tangox_mbus_free_dma);
+EXPORT_SYMBOL(tangox_mbus_notification);
+EXPORT_SYMBOL(tangox_mbus_setup_dma);
+
+/*
+ * Bit 0/8: MBUS_R0_SBOX
+ * Bit 1/9: MBUS_R1_SBOX
+ * Bit 2/10: PCI_MASTER_SBOX
+ * Bit 3/11: PCI_SLAVE_SBOX
+ * Bit 4/12: SATA0_SBOX
+ * Bit 5/13: IDE_ISA_SBOX
+ * Bit 6/14: IDE_DVD_SBOX
+ * Bit 7/15: SATA1_SBOX (Tango3)
+ * Bit 16/24: SBOX_MBUS_W0
+ * Bit 17/25: SBOX_MBUS_W1
+ * Bit 18/26: SBOX_PCI_MASTER
+ * Bit 19/27: SBOX_PCI_SLAVE
+ * Bit 20/28: SBOX_SATA0
+ * Bit 21/29: SBOX_ISA
+ * Bit 22/30: SBOX_DVD
+ * Bit 23/31: SBOX_SATA1 (Tango3)
+ *
+ * Bit 32/40: MBUS_R2_SBOX (Tango3)
+ * Bit 48/50: SBOX_MBUS_W2 (Tango3)
+ */
+#if defined(CONFIG_TANGO3)
+static const u64 sbox_reset_vals[4][6] = {
+	{ 0x0000000001011010ULL, 0x0000000002021010ULL, 0x0000000010100101ULL, 0x0000000010100202ULL, 0x0101000000001010ULL, 0x0000010110100000ULL },
+	{ 0x0000000001012020ULL, 0x0000000002022020ULL, 0x0000000020200101ULL, 0x0000000020200202ULL, 0x0101000000002020ULL, 0x0000010120200000ULL },
+	{ 0x0000000001014040ULL, 0x0000000002024040ULL, 0x0000000040400101ULL, 0x0000000040400202ULL, 0x0101000000004040ULL, 0x0000010140400000ULL },
+	{ 0x0000000001018080ULL, 0x0000000002028080ULL, 0x0000000080800101ULL, 0x0000000080800202ULL, 0x0101000000008080ULL, 0x0000010180800000ULL },
+};
+#else
+static const unsigned int sbox_reset_vals[2][4] = {
+	{ 0x01012020, 0x02022020, 0x20200101, 0x20200202 },
+	{ 0x01014040, 0x02024040, 0x40400101, 0x40400202 }
+};
+#endif
+
+#if defined(CONFIG_TANGO2) || defined(CONFIG_TANGO3)
+/* old mbus semantics */
+static int __old_mbus_idx2chn(unsigned int idx)
+{
+	return idx; /* no conversion needed */
+}
+#endif
+
+#if defined(CONFIG_TANGO3)
+static int __new_mbus_idx2chn(unsigned int idx)
+{
+	/* converting w0,w1,w2,hole,r0,r1,r2,hole to w0,w1,r0,r1,w2,r2 index */
+	static const int chn_conv[8] = { 0, 1, 4, -1, 2, 3, 5, -1 };
+	return chn_conv[idx];
+}
+#endif
+
+static int (*__mbus_idx2chn)(unsigned int) = NULL;
+
+/*
+ * clear MBUS transaction for given regbase/sbox
+ */
+void tangox_mbus_reset(struct mbus_channel_pair *chnpptr, int iface)
+{
+	int midx;
+	int sidx;
+	unsigned int rwbase;
+
+#if defined(CONFIG_TANGO3)
+	unsigned int rl, rh;
+
+	/* MBUS is idle, no need to reset */
+	if (tangox_mbus_inuse(chnpptr) == 0)
+		return;
+	
+	rwbase = chnpptr->fromdev ? chnpptr->wx_base : chnpptr->rx_base;
+	midx = (*__mbus_idx2chn)((rwbase - (REG_BASE_host_interface + MIF_W0_ADD)) / 0x40);
+	sidx = iface - SBOX_SATA0;
+
+	if (((midx < 0) || (midx > 5)) || ((sidx < 0) || (sidx > 3))) {
+		printk("MBUS reset: out of range, midx %d, sidx %d\n", midx, sidx);
+		return;
+	}
+	rl = sbox_reset_vals[sidx][midx] & 0xffffffff;
+	rh = (sbox_reset_vals[sidx][midx] >> 32) & 0xffffffff;
+	wmb();
+
+	gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET, rl);
+	if (rh) 
+		gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET2, rh);
+	iob();
+
+	gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET, rl & 0xff00ff00);
+	if (rh) 
+		gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET2, rh & 0xff00ff00);
+	iob();
+
+	udelay(2); /* at least 256 system cycles, 128MHz or above */
+	gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET, rl);
+	if (rh) 
+		gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET2, rh);
+	iob();
+
+	gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET, rl & 0xff00ff00);
+	if (rh) 
+		gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET2, rh & 0xff00ff00);
+	iob();
+#else
+	/* MBUS is idle, no need to reset */
+	if (tangox_mbus_inuse(chnpptr) == 0)
+		return;
+
+	rwbase = chnpptr->fromdev ? chnpptr->wx_base : chnpptr->rx_base;
+	midx = (*__mbus_idx2chn)((rwbase - (REG_BASE_host_interface + MIF_W0_ADD)) / 0x40);
+	sidx = iface - SBOX_IDEFLASH;
+
+	if (((midx < 0) || (midx > 3)) || ((sidx < 0) || (sidx > 2))) {
+		printk("MBUS reset: out of range, midx %d, sidx %d\n", midx, sidx);
+		return;
+	}
+
+	gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET, sbox_reset_vals[sidx][midx]);
+	gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET, sbox_reset_vals[sidx][midx] & 0xff00ff00);
+
+	udelay(2); /* at least 256 system cycles, 128MHz or above */
+	gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET, sbox_reset_vals[sidx][midx]);
+	gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET, sbox_reset_vals[sidx][midx] & 0xff00ff00);
+#endif
+}
+EXPORT_SYMBOL(tangox_mbus_reset);
+
+typedef int (*COND_FUNC_PTR)(void *);
+extern int tangox_udelay_with_condition(unsigned int usecond, COND_FUNC_PTR func_ptr, void *arg);
+
+static int tangox_mbus_busy(void *arg)
+{
+	struct mbus_channel_pair *chnpptr = (struct mbus_channel_pair *)arg;
+	return tangox_mbus_inuse(chnpptr);
+}
+
+static int tangox_pb_busy(void *dummy)
+{
+	return (gbus_read_reg32(REG_BASE_host_interface + PB_automode_control) & 0xffff) ? 1 : 0;
+}
+
+/*
+ * busy wait for current mbus transfer to finish, will not wait for
+ * more than 20 ms.
+ */
+#define MBUS_TIMEOUT	20000
+
+int tangox_mbus_wait(struct mbus_channel_pair *chnpptr, int iface)
+{
+	int timeout;
+	unsigned int rwbase;
+
+	/* wait for mbus to be released */
+	timeout = tangox_udelay_with_condition(MBUS_TIMEOUT, tangox_mbus_busy, (void *)chnpptr);
+	if (timeout == 0) {
+		/* ok */
+		if (iface == SBOX_IDEFLASH) {
+			if ((timeout = tangox_udelay_with_condition(MBUS_TIMEOUT, tangox_pb_busy, NULL)) == 0)
+				return 0;
+		} else
+			return 0;
+	}
+
+	if (tangox_mbus_inuse(chnpptr) == 0)
+		return 0; /* mbus is done */
+
+	rwbase = chnpptr->fromdev ? chnpptr->wx_base : chnpptr->rx_base;
+	/* timeout, let's dump some registers ! */
+        if (iface == SBOX_IDEFLASH) {
+  		printk("MBUS timeout : MBUS CMD = %ld, PB Automode = %08x\n",
+                	(unsigned long)gbus_read_reg32(rwbase + MIF_cmd_offset) & 0x7,
+                	(unsigned int)gbus_read_reg32(REG_BASE_host_interface + PB_automode_control));
+        } else {
+		printk("MBUS timeout : MBUS CMD = %08x\n",
+			(u32)(gbus_read_reg32(rwbase + MIF_cmd_offset) & 0x7));
+	}
+
+	printk("MBUS registers : %08x %08x %08x %08x\n",
+	       (u32)gbus_read_reg32(rwbase + MIF_add_offset),
+	       (u32)gbus_read_reg32(rwbase + MIF_cnt_offset),
+	       (u32)gbus_read_reg32(rwbase + MIF_add2_skip_offset),
+	       (u32)gbus_read_reg32(rwbase + MIF_cmd_offset));
+
+	printk(KERN_ERR "MBUS fails, resetting %d ..\n", iface);
+	tangox_mbus_reset(chnpptr, iface);
+
+	/* If not able to reset, return  1, so the DMA can be disabled
+	   accordingly  */
+	return tangox_mbus_inuse(chnpptr) ? 0 : 1;
+}
+EXPORT_SYMBOL(tangox_mbus_wait);
+
+static __init int tangox_mbus_init(void)
+{
+	unsigned long tangox_chip_id(void);
+	struct mbus_channel_pair *chnpptr = NULL;
+	unsigned long flags;
+	int i;
+
+	/* give better MBUS bandwidth for Wx/Rx channels */
+#if defined(CONFIG_TANGO3)
+	gbus_write_reg32(REG_BASE_system_block + MARB_mid01_cfg, 0x12005);
+	gbus_write_reg32(REG_BASE_system_block + MARB_mid21_cfg, 0x12005);
+	gbus_write_reg32(REG_BASE_system_block + MARB_mid03_cfg, 0x12005);
+	gbus_write_reg32(REG_BASE_system_block + MARB_mid23_cfg, 0x12005);
+#ifdef WITH_MBUS_W1R1
+	gbus_write_reg32(REG_BASE_system_block + MARB_mid02_cfg, 0x12005);
+	gbus_write_reg32(REG_BASE_system_block + MARB_mid22_cfg, 0x12005);
+#endif
+#else
+	gbus_write_reg32(REG_BASE_system_block + MARB_mid02_cfg, 0x11f1f);
+	gbus_write_reg32(REG_BASE_system_block + MARB_mid22_cfg, 0x11f1f);
+#endif
+
+	spin_lock_irqsave(&mbus_lock, flags);
+
+	/* how many channel pairs are available? */
+	for (chnpptr = &mchnp_list[0], mbus_free_cnt = i = 0; i < NUM_MBUS_CHNPS; i++, chnpptr++) {
+		spin_lock_init(&chnpptr->lock);
+		if (chnpptr->iface == 0xf)
+			mbus_free_cnt++; /* count the number of available channel pairs */
+	}
+
+	/* reset sbox to default values */
+	sbox_init();
+
+#ifdef CONFIG_TANGO3
+	if ((((tangox_chip_id() >> 16) & 0xfffe) == 0x8672) || (((tangox_chip_id() >> 16) & 0xfffe) == 0x8674)) { /* 8672/8674 uses new semantics */
+		__mbus_void_action = __new_mbus_void;
+		__mbus_linear_action = __new_mbus_linear;
+		__mbus_double_action = __new_mbus_double;
+		__mbus_rectangle_action = __new_mbus_rectangle;
+		__mbus_idx2chn = __new_mbus_idx2chn;
+		__mbus_reg2chnp = __new_mbus_reg2chnp;
+		/* mbus registers for 8672/8674 is the same as 8910 ... */
+		mchnp_list[0].rx_base = REG_BASE_host_interface + 0xb100;
+		mchnp_list[0].wx_base = REG_BASE_host_interface + 0xb000;
+		mchnp_list[1].rx_base = REG_BASE_host_interface + 0xb140;
+		mchnp_list[1].wx_base = REG_BASE_host_interface + 0xb040;
+		mchnp_list[2].rx_base = REG_BASE_host_interface + 0xb180;
+		mchnp_list[2].wx_base = REG_BASE_host_interface + 0xb080;
+	} else {
+#endif
+		__mbus_void_action = __old_mbus_void;
+		__mbus_linear_action = __old_mbus_linear;
+		__mbus_double_action = __old_mbus_double;
+		__mbus_rectangle_action = __old_mbus_rectangle;
+		__mbus_idx2chn = __old_mbus_idx2chn;
+		__mbus_reg2chnp = __old_mbus_reg2chnp;
+#ifdef CONFIG_TANGO3
+	}
+#endif
+
+	printk("registering mbus interrupt routines.\n");
+	mbus_register_intr();
+
+	spin_unlock_irqrestore(&mbus_lock, flags);
+
+	return 0;
+}
+
+/* TODO: TO BE RELPLACED */
+static inline int mbus_inuse(unsigned int regbase)
+{
+	struct mbus_channel_pair *chnpptr = (*__mbus_reg2chnp)(regbase);
+	if (regbase == 0) {
+		MSG("%s:%d regbase=0x%x\n", __FILE__, __LINE__, regbase);
+		BUG();
+	} else if (chnpptr == NULL) {
+		MSG("%s:%d regbase=0x%x\n", __FILE__, __LINE__, regbase);
+		BUG();
+	} else if ((regbase != chnpptr->wx_base) && (regbase != chnpptr->rx_base)) {
+		MSG("%s:%d regbase=0x%x\n", __FILE__, __LINE__, regbase);
+		BUG();
+	}
+	return tangox_mbus_inuse(chnpptr);
+}
+
+/* TODO: TO BE RELPLACED */
+int em86xx_mbus_alloc_dma(int iface, int fromdev, unsigned long *pregbase, int *pirq, int canwait)
+{
+	struct mbus_channel_pair *chnpptr;
+	if ((chnpptr = tangox_mbus_alloc_dma(iface, fromdev, canwait)) == NULL)
+		return -1;
+
+	if (pirq)
+		*pirq = (fromdev ? chnpptr->wx_irq : chnpptr->rx_irq);
+	if (pregbase)
+		*pregbase = chnpptr->fromdev ? chnpptr->wx_base : chnpptr->rx_base;
+	
+	return 0;
+}
+
+/* TODO: TO BE RELPLACED */
+void em86xx_mbus_free_dma(unsigned long regbase, int iface)
+{
+	struct mbus_channel_pair *chnpptr = (*__mbus_reg2chnp)(regbase);
+	if (regbase == 0) {
+		MSG("%s:%d regbase=0x%x\n", __FILE__, __LINE__, regbase);
+		BUG();
+	} else if (chnpptr == NULL) {
+		MSG("%s:%d regbase=0x%x\n", __FILE__, __LINE__, regbase);
+		BUG();
+	} else if ((regbase != chnpptr->wx_base) && (regbase != chnpptr->rx_base)) {
+		MSG("%s:%d regbase=0x%x\n", __FILE__, __LINE__, regbase);
+		BUG();
+	}
+	tangox_mbus_free_dma(chnpptr, iface);
+}
+
+/* TODO: TO BE RELPLACED */
+int em86xx_mbus_notification(unsigned int regbase, mbus_irq_handler_t handler, void *arg)
+{
+	struct mbus_channel_pair *chnpptr = (*__mbus_reg2chnp)(regbase);
+	if (regbase == 0) {
+		MSG("%s:%d regbase=0x%x\n", __FILE__, __LINE__, regbase);
+		BUG();
+	} else if (chnpptr == NULL) {
+		MSG("%s:%d regbase=0x%x\n", __FILE__, __LINE__, regbase);
+		BUG();
+	} else if ((regbase != chnpptr->wx_base) && (regbase != chnpptr->rx_base)) {
+		MSG("%s:%d regbase=0x%x\n", __FILE__, __LINE__, regbase);
+		BUG();
+	}
+	return tangox_mbus_notification(chnpptr, handler, arg);
+}
+
+/* TODO: TO BE RELPLACED */
+int em86xx_mbus_setup_dma(unsigned int regbase, unsigned int addr,
+			  unsigned int count, mbus_irq_handler_t handler,
+			  void *arg, unsigned int tflags)
+{
+	struct mbus_channel_pair *chnpptr = (*__mbus_reg2chnp)(regbase);
+	if (regbase == 0) {
+		MSG("%s:%d regbase=0x%x\n", __FILE__, __LINE__, regbase);
+		BUG();
+	} else if (chnpptr == NULL) {
+		MSG("%s:%d regbase=0x%x\n", __FILE__, __LINE__, regbase);
+		BUG();
+	} else if ((regbase != chnpptr->wx_base) && (regbase != chnpptr->rx_base)) {
+		MSG("%s:%d regbase=0x%x\n", __FILE__, __LINE__, regbase);
+		BUG();
+	}
+	return tangox_mbus_setup_dma(chnpptr, addr, count, handler, arg, tflags);
+}
+
+/* TODO: TO BE RELPLACED */
+int em86xx_mbus_wait(unsigned int regbase, int iface)
+{
+	struct mbus_channel_pair *chnpptr = (*__mbus_reg2chnp)(regbase);
+	if (regbase == 0) {
+		MSG("%s:%d regbase=0x%x\n", __FILE__, __LINE__, regbase);
+		BUG();
+	} else if (chnpptr == NULL) {
+		MSG("%s:%d regbase=0x%x\n", __FILE__, __LINE__, regbase);
+		BUG();
+	} else if ((regbase != chnpptr->wx_base) && (regbase != chnpptr->rx_base)) {
+		MSG("%s:%d regbase=0x%x\n", __FILE__, __LINE__, regbase);
+		BUG();
+	}
+	return tangox_mbus_wait(chnpptr, iface);
+}
+
+/* TODO: TO BE RELPLACED */
+void em86xx_mbus_reset(unsigned int regbase, int iface)
+{
+	struct mbus_channel_pair *chnpptr = (*__mbus_reg2chnp)(regbase);
+	if (regbase == 0) {
+		MSG("%s:%d regbase=0x%x\n", __FILE__, __LINE__, regbase);
+		BUG();
+	} else if (chnpptr == NULL) {
+		MSG("%s:%d regbase=0x%x\n", __FILE__, __LINE__, regbase);
+		BUG();
+	} else if ((regbase != chnpptr->wx_base) && (regbase != chnpptr->rx_base)) {
+		MSG("%s:%d regbase=0x%x\n", __FILE__, __LINE__, regbase);
+		BUG();
+	}
+	return tangox_mbus_reset(chnpptr, iface);
+}
+
+EXPORT_SYMBOL(em86xx_mbus_alloc_dma);
+EXPORT_SYMBOL(em86xx_mbus_free_dma);
+EXPORT_SYMBOL(em86xx_mbus_notification);
+EXPORT_SYMBOL(em86xx_mbus_setup_dma);
+EXPORT_SYMBOL(em86xx_mbus_wait);
+EXPORT_SYMBOL(em86xx_mbus_reset);
+__initcall(tangox_mbus_init);
+
+/* Comment this to use DMA-like memcpy */
+#define WITH_ORIGINAL_MEMCPY
+
+/* Comment this to use DMA-like copy_to*, copy_from* */
+#define WITH_ORIGINAL_COPYUSER
+
+/* Minimum size of DMA copy (less than this original ones to be used) */
+#define MINIMUM_DMACPY_SIZE	(PAGE_SIZE >> 2)
+
+#ifdef CONFIG_TANGO2
+#define CACHELINE_MASK	0xf
+#define SBOX_TARGET	SBOX_PCIMASTER
+#elif defined(CONFIG_TANGO3)
+#define CACHELINE_MASK	0x1f
+#define SBOX_TARGET	SBOX_IDEDVD
+#else
+#error Not supported platform.
+#endif
+
+static int tangox_mbus_memcpy(struct mbus_channel_pair *chnpptr, unsigned int dst, unsigned int src, unsigned int size);
+
+/* As a replacement of memcpy, original memcpy is renamed to memcpy_original.
+   Use DMA to do copy as much as possible. */
+void *memcpy(void *__to, __const__ void *__from, size_t __n)
+{
+	extern void *memcpy_original(void *dest, const void *source, __kernel_size_t size);
+#if defined(WITH_ORIGINAL_MEMCPY) || defined(CONFIG_SWAP)
+	return memcpy_original(__to, __from, __n);
+#else
+	unsigned long virt_to = (unsigned long)__to;
+	unsigned long virt_from = (unsigned long)__from;
+	int len = __n;
+	unsigned long flags;
+	struct mbus_channel_pair *chnpptr;
+
+	// JFT, We could probably handle more cases
+	if (__n < MINIMUM_DMACPY_SIZE || 
+#ifdef CONFIG_TANGO2
+			virt_from < (KSEG0 + MEM_BASE_dram_controller_0) || virt_to < (KSEG0 + MEM_BASE_dram_controller_0) 
+#elif defined(CONFIG_TANGO3)
+			virt_from < (KSEG0 + CPU_REMAP_SPACE) || virt_to < (KSEG0 + CPU_REMAP_SPACE)
+#endif
+			|| virt_from >= KSEG2 || virt_to >= KSEG2)
+		return memcpy_original(__to, __from, __n);
+#ifdef CONFIG_TANGO2
+	else if (unlikely(((virt_from >= KSEG1) && (virt_from < (KSEG1 + MEM_BASE_dram_controller_0))) ||
+			((virt_to >= KSEG1) && (virt_to < (KSEG1 + MEM_BASE_dram_controller_0)))))
+		return memcpy_original(__to, __from, __n);
+#elif defined(CONFIG_TANGO3)
+	else if (unlikely(((virt_from >= KSEG1) && (virt_from < (KSEG1 + CPU_REMAP_SPACE))) ||
+			((virt_to >= KSEG1) && (virt_to < (KSEG1 + CPU_REMAP_SPACE)))))
+		return memcpy_original(__to, __from, __n);
+#endif
+	else if ((chnpptr = tangox_mbus_alloc_dma(SBOX_TARGET, 1, 0)) == NULL)
+		return memcpy_original(__to, __from, __n);
+
+	// If the virt_to is not aligned we need to flush the data before it
+	if (likely(virt_to < KSEG1)) {
+		if (virt_to & CACHELINE_MASK)
+			flush_dcache_line(virt_to & ~CACHELINE_MASK);
+	}
+	// If the virt_to + cu_len is not aligned we need to flush the data after it
+	if (likely((virt_to + __n) < KSEG1)) {
+		if ((virt_to + __n) & CACHELINE_MASK)
+			flush_dcache_line((virt_to + __n) & ~CACHELINE_MASK);
+	}
+
+	if (likely(virt_from < KSEG1))
+		blast_dcache_range(virt_from, virt_from + len);
+	if (likely(virt_to < KSEG1))
+		blast_inv_dcache_range(virt_to, virt_to + len);
+
+	if (tangox_mbus_memcpy(chnpptr, tangox_dma_address(CPHYSADDR(virt_to)), tangox_dma_address(CPHYSADDR(virt_from)), len) == 0) {
+		printk("%s:%d: MBUS memcpy failure.\n", __FUNCTION__, __LINE__);
+		tangox_mbus_free_dma(chnpptr, SBOX_TARGET);
+		return memcpy_original(__to, __from, __n);
+	}
+
+	tangox_mbus_free_dma(chnpptr, SBOX_TARGET);
+	return __to;
+#endif /* WITH_ORIGINAL_MEMCPY || CONFIG_SWAP */
+}
+
+#define offset_into_page(x) ((x) & (PAGE_SIZE - 1))
+
+size_t __invoke_copy_to_user_dma(void __user *__cu_to, const void *__cu_from, long __cu_len)
+{
+#if defined(WITH_ORIGINAL_COPYUSER) || defined(CONFIG_SWAP)
+        return __invoke_copy_to_user(__cu_to, __cu_from, __cu_len);
+#else
+	unsigned long virt_to = (unsigned long)__cu_to;
+	unsigned long virt_from = (unsigned long)__cu_from;
+	int byte;
+	unsigned long _n;
+	unsigned long flags;
+	struct mbus_channel_pair *chnpptr;
+
+	// JFT, note: this is very common case so make it first
+	if (__cu_len < MINIMUM_DMACPY_SIZE) 
+        	return __invoke_copy_to_user(__cu_to, __cu_from, __cu_len);
+	else if ((virt_to >= KSEG0) || (virt_from >= KSEG2))
+        	return __invoke_copy_to_user(__cu_to, __cu_from, __cu_len);
+	else if (!(virt_addr_valid(__cu_from)) || !(virt_addr_valid(__cu_from + __cu_len))) 
+		return __invoke_copy_to_user(__cu_to, __cu_from, __cu_len);
+	else if ((chnpptr = tangox_mbus_alloc_dma(SBOX_TARGET, 1, 0)) == NULL)
+		return __invoke_copy_to_user(__cu_to, __cu_from, __cu_len);
+
+	// Verify all pages exist
+	for (byte = 0; byte < __cu_len; byte += PAGE_SIZE)
+		__put_user_check(0, (unsigned char *)(virt_to + byte), 1);
+	__put_user_check(0, (unsigned char *)(virt_to + __cu_len - 1), 1);
+
+	// If the virt_to is not aligned we need to flush the data before it
+	if (virt_to & CACHELINE_MASK)
+		flush_dcache_line(virt_to & ~CACHELINE_MASK);
+	// If the virt_to + cu_len is not aligned we need to flush the data after it
+	if ((virt_to + __cu_len) & CACHELINE_MASK)
+		flush_dcache_line((virt_to + __cu_len) & ~CACHELINE_MASK);
+
+	for (byte = 0, _n = __cu_len; byte < __cu_len; ) {
+        	int len = min(PAGE_SIZE - offset_into_page(virt_to + byte), _n);
+		pgd_t *pgd;
+		pud_t *pud;
+		pmd_t *pmd;
+		pte_t *pte;
+		unsigned long pg_addr;
+		unsigned long dma_to;
+
+		pg_addr = (virt_to + byte) & PAGE_MASK; /* address of start page */
+
+		if (pg_addr > TASK_SIZE)
+			pgd = pgd_offset_k(pg_addr);
+		else
+			pgd = pgd_offset_gate(current->mm, pg_addr);
+		BUG_ON(pgd_none(*pgd));
+		pud = pud_offset(pgd, pg_addr);
+		BUG_ON(pud_none(*pud));
+		pmd = pmd_offset(pud, pg_addr);
+		if (pmd_none(*pmd)) 
+			goto error;
+		pte = pte_offset_map(pmd, pg_addr);
+		if (pte_none(*pte)) {
+			pte_unmap(pte);
+			goto error;
+		}
+		dma_to = (pte_val(*pte) & PAGE_MASK) + offset_into_page(virt_to + byte);
+		pte_unmap(pte);
+
+#ifdef CONFIG_TANGO2
+		if (unlikely((dma_to < MEM_BASE_dram_controller_0) || (dma_to >= (KSEG1 - KSEG0)))) 
+			goto error;
+#elif defined(CONFIG_TANGO3)
+		if (unlikely((dma_to < CPU_REMAP_SPACE) || (dma_to >= (KSEG1 - KSEG0)))) 
+			goto error;
+#endif
+
+		blast_dcache_range(virt_from + byte, virt_from + byte + len);
+		blast_inv_dcache_range(virt_to + byte, virt_to + byte + len);
+
+		if (tangox_mbus_memcpy(chnpptr, tangox_dma_address(dma_to), tangox_dma_address(CPHYSADDR(virt_from + byte)), len) == 0) {
+			printk("%s:%d: MBUS memcpy failure.\n", __FUNCTION__, __LINE__);
+			tangox_mbus_free_dma(chnpptr, SBOX_TARGET);
+			return __invoke_copy_to_user(__cu_to, __cu_from, __cu_len);
+		}
+
+		byte += len;
+        	_n -= len;
+	}
+
+error:
+	tangox_mbus_free_dma(chnpptr, SBOX_TARGET);
+	return _n;
+#endif /* WITH_ORIGINAL_COPYUSER || CONFIG_SWAP */
+}
+
+size_t __invoke_copy_from_user_dma(void *__cu_to, const void __user *__cu_from, long __cu_len)
+{
+#if defined(WITH_ORIGINAL_COPYUSER) || defined(CONFIG_SWAP)
+        return __invoke_copy_from_user(__cu_to, __cu_from, __cu_len);
+#else
+	unsigned long virt_to = (unsigned long)__cu_to;
+	unsigned long virt_from = (unsigned long)__cu_from;
+	int byte;
+	unsigned long _n;
+	unsigned long flags;
+	unsigned char val;
+	struct mbus_channel_pair *chnpptr;
+
+	// JFT, this is very common case so make it first
+	if (__cu_len < MINIMUM_DMACPY_SIZE) 
+		return __invoke_copy_from_user(__cu_to, __cu_from, __cu_len);
+	else if ((virt_from >= KSEG0) || (virt_to >= KSEG2))
+        	return __invoke_copy_from_user(__cu_to, __cu_from, __cu_len);
+	else if (!(virt_addr_valid(__cu_to)) || !(virt_addr_valid(__cu_to + __cu_len))) 
+		return __invoke_copy_from_user(__cu_to, __cu_from, __cu_len);
+	else if ((chnpptr = tangox_mbus_alloc_dma(SBOX_TARGET, 1, 0)) == NULL)
+		return __invoke_copy_from_user(__cu_to, __cu_from, __cu_len);
+
+	// Verify all pages exist
+	for (byte = 0; byte < __cu_len; byte += PAGE_SIZE) 
+		__get_user_check(val, (unsigned char *)(virt_from + byte), 1);
+	__get_user_check(val, (unsigned char *)(virt_from + __cu_len - 1), 1);
+
+	// If the virt_to is not aligned we need to flush the data before it
+	if (virt_to & CACHELINE_MASK)
+		flush_dcache_line(virt_to & ~CACHELINE_MASK);
+	// If the virt_to + cu_len is not aligned we need to flush the data after it
+	if ((virt_to + __cu_len) & CACHELINE_MASK) 
+		flush_dcache_line((virt_to + __cu_len) & ~CACHELINE_MASK);
+
+	for (byte = 0, _n = __cu_len; byte < __cu_len; ) {
+		int len = min(PAGE_SIZE - offset_into_page(virt_from + byte), _n);
+		pgd_t *pgd;
+		pud_t *pud;
+		pmd_t *pmd;
+		pte_t *pte;
+		unsigned long pg_addr;
+		unsigned long dma_from;
+
+		pg_addr = (virt_from + byte) & PAGE_MASK; /* address of start page */
+
+		if (pg_addr > TASK_SIZE)
+			pgd = pgd_offset_k(pg_addr);
+		else
+			pgd = pgd_offset_gate(current->mm, pg_addr);
+		BUG_ON(pgd_none(*pgd));
+		pud = pud_offset(pgd, pg_addr);
+		BUG_ON(pud_none(*pud));
+		pmd = pmd_offset(pud, pg_addr);
+		if (pmd_none(*pmd)) 
+			goto error;
+		pte = pte_offset_map(pmd, pg_addr);
+		if (pte_none(*pte)) {
+			pte_unmap(pte);
+			goto error;
+		}
+		dma_from = (pte_val(*pte) & PAGE_MASK) + offset_into_page(virt_from + byte);
+		pte_unmap(pte);
+
+#ifdef CONFIG_TANGO2
+		if (unlikely((dma_from < MEM_BASE_dram_controller_0) || (dma_from >= (KSEG1 - KSEG0)))) 
+			goto error;
+#elif defined(CONFIG_TANGO3)
+		if (unlikely((dma_from < CPU_REMAP_SPACE) || (dma_from >= (KSEG1 - KSEG0)))) 
+			goto error;
+#endif
+		blast_dcache_range(virt_from + byte, virt_from + byte + len);
+		blast_inv_dcache_range(virt_to + byte, virt_to + byte + len);
+	
+		if (tangox_mbus_memcpy(chnpptr, tangox_dma_address(CPHYSADDR(virt_to + byte)), tangox_dma_address(dma_from), len) == 0) {
+			printk("%s:%d: MBUS memcpy failure.\n", __FUNCTION__, __LINE__);
+			tangox_mbus_free_dma(chnpptr, SBOX_TARGET);
+			return __invoke_copy_from_user(__cu_to, __cu_from, __cu_len);
+		}
+
+		byte += len;
+        	_n -= len;
+	}
+	
+error:
+	tangox_mbus_free_dma(chnpptr, SBOX_TARGET);
+	return _n;
+#endif /* WITH_ORIGINAL_COPYUSER || CONFIG_SWAP */
+}
+
+EXPORT_SYMBOL(__invoke_copy_to_user_dma);
+EXPORT_SYMBOL(__invoke_copy_from_user_dma);
+
+/* Fancy version of memcpy, both dst and src need to be physical address */
+/* The channels have to be allocated already */
+static int tangox_mbus_memcpy(struct mbus_channel_pair *chnpptr, unsigned int dst, unsigned int src, unsigned int size)
+{
+	/* Save the old SBOX route */
+	unsigned int sbox_route;
+	unsigned int w_base;
+	unsigned int r_base;
+	int i, chnp;
+	unsigned int tmode_w, tmode_r;
+
+/* 
+ * TRANSFER defines 4 bits, 
+ * Tango3:
+ *    bit 0: followed by void (1) or not (0),
+ *    bit 1: tiled buffer or not.
+ *    bit 3-2: 0 = 8 bit, 1 = 16 bit, 2 = 32 bit.
+ * Tango4: 
+ *    bit 0: followed by void (1) or not (0),
+ *    bit 13: tiled buffer or not.
+ *    bit 15-14: 0 = 8 bit, 1 = 16 bit, 2 = 32 bit.
+ */
+#if defined(CONFIG_TANGO3)
+#define TRANSFER    0x1 /* or 0x9 for 32 bit transfer */
+#else
+#define TRANSFER    0x1
+#endif
+
+#define MBUS_MEMCPY_TIMEOUT	100	/* 100 usec */
+
+	tmode_w = tmode_r = TRANSFER;
+	chnp = chnpptr->idx;
+	w_base = chnpptr->wx_base;
+	r_base = chnpptr->rx_base;
+
+	switch(chnp) {
+		case 0: { /* W0/R0 channel pair is used */
+				sbox_route = gbus_read_reg32(REG_BASE_host_interface + SBOX_ROUTE) & 0xffffff0f;
+
+				/* Hook up W0/R0 and left W1/R1 the same as before */
+				gbus_write_reg32(REG_BASE_host_interface + SBOX_ROUTE, 0xffffff01);
+		
+				if (__tangox_mbus_setup_dma(chnpptr, dst, size, NULL, NULL, tmode_w, w_base) != 0) {
+					gbus_write_reg32(REG_BASE_host_interface + SBOX_ROUTE, sbox_route);
+					goto error;
+				} else if (__tangox_mbus_setup_dma(chnpptr, src, size, NULL, NULL, tmode_r, r_base) != 0) {
+					/* resetting W0 */
+					gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET, 0x01010000);
+					gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET, 0x01000000);
+					gbus_write_reg32(REG_BASE_host_interface + SBOX_ROUTE, sbox_route);
+					goto error;
+				}
+
+				for (i = 0; (i < MBUS_MEMCPY_TIMEOUT) && ((__tangox_mbus_inuse(chnpptr, r_base) != 0) || (__tangox_mbus_inuse(chnpptr, w_base) != 0)); i++)
+					udelay(1);
+
+				if (__tangox_mbus_inuse(chnpptr, w_base) != 0) {
+					gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET, 0x01010000);
+					gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET, 0x01000000);
+				}
+				if (__tangox_mbus_inuse(chnpptr, r_base) != 0) {
+					gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET, 0x00000101);
+					gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET, 0x00000100);
+				}
+
+				/* Restore SBOX route once we're done */
+				gbus_write_reg32(REG_BASE_host_interface + SBOX_ROUTE, sbox_route);
+			}
+			break;
+#ifdef WITH_MBUS_W1R1
+		case 1: { /* W1/R1 channel pair is used */
+				sbox_route = gbus_read_reg32(REG_BASE_host_interface + SBOX_ROUTE) & 0xfffffff0;
+
+				/* Hook up W1/R1 and left W0/R0 the same as before */
+				gbus_write_reg32(REG_BASE_host_interface + SBOX_ROUTE, 0xffffff20);
+	
+				if (__tangox_mbus_setup_dma(chnpptr, dst, size, NULL, NULL, tmode_w, w_base) != 0) {
+					gbus_write_reg32(REG_BASE_host_interface + SBOX_ROUTE, sbox_route);
+					goto error;
+				} else if (__tangox_mbus_setup_dma(chnpptr, src, size, NULL, NULL, tmode_r, r_base) != 0) {
+					/* resetting W1 */
+					gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET, 0x02020000);
+					gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET, 0x02000000);
+					gbus_write_reg32(REG_BASE_host_interface + SBOX_ROUTE, sbox_route);
+					goto error;
+				}
+
+				for (i = 0; (i < MBUS_MEMCPY_TIMEOUT) && ((__tangox_mbus_inuse(chnpptr, r_base) != 0) || (__tangox_mbus_inuse(chnpptr, w_base) != 0)); i++)
+					udelay(1);
+
+				if (__tangox_mbus_inuse(chnpptr, w_base) != 0) {
+					gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET, 0x02020000);
+					gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET, 0x02000000);
+				}
+				if (__tangox_mbus_inuse(chnpptr, r_base) != 0) {
+					gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET, 0x00000202);
+					gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET, 0x00000200);
+				}
+
+				/* Restore SBOX route once we're done */
+				gbus_write_reg32(REG_BASE_host_interface + SBOX_ROUTE, sbox_route);
+			}
+			break;
+#endif
+#if defined(CONFIG_TANGO3)
+		case 2: { /* W2/R2 channel pair is used */
+				sbox_route = gbus_read_reg32(REG_BASE_host_interface + SBOX_ROUTE2);
+
+				/* Hook up W2/R2 */
+				gbus_write_reg32(REG_BASE_host_interface + SBOX_ROUTE2, 0xfffffff9);
+	
+				if (__tangox_mbus_setup_dma(chnpptr, dst, size, NULL, NULL, tmode_w, w_base) != 0) {
+					gbus_write_reg32(REG_BASE_host_interface + SBOX_ROUTE2, sbox_route);
+					goto error;
+				} else if (__tangox_mbus_setup_dma(chnpptr, src, size, NULL, NULL, tmode_r, r_base) != 0) {
+					/* resetting W2 */
+					gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET2, 0x01010000);
+					gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET2, 0x01000000);
+					gbus_write_reg32(REG_BASE_host_interface + SBOX_ROUTE2, sbox_route);
+					goto error;
+				}
+
+				for (i = 0; (i < MBUS_MEMCPY_TIMEOUT) && ((__tangox_mbus_inuse(chnpptr, r_base) != 0) || (__tangox_mbus_inuse(chnpptr, w_base) != 0)); i++)
+					udelay(1);
+
+				if (__tangox_mbus_inuse(chnpptr, w_base) != 0) {
+					gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET2, 0x01010000);
+					gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET2, 0x01000000);
+				}
+				if (__tangox_mbus_inuse(chnpptr, r_base) != 0) {
+					gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET2, 0x00000101);
+					gbus_write_reg32(REG_BASE_host_interface + SBOX_FIFO_RESET2, 0x00000100);
+				}
+
+				/* Restore SBOX route once we're done */
+				gbus_write_reg32(REG_BASE_host_interface + SBOX_ROUTE2, sbox_route);
+			}
+			break;
+#endif
+		default: goto error;
+			break;
+	}
+	return size;
+
+error:
+	return 0;
+}
+
+/* Fancy version of memcpy, both dst and src need to be physical address */
+/* The channels have to be allocated already */
+int mbus_memcpy(unsigned int regbase, unsigned int dst, unsigned int src, unsigned int size)
+{
+	struct mbus_channel_pair *chnpptr = (*__mbus_reg2chnp)(regbase);
+	if (regbase == 0) {
+		MSG("%s:%d regbase=0x%x\n", __FILE__, __LINE__, regbase);
+		BUG();
+	} else if (chnpptr == NULL) {
+		MSG("%s:%d regbase=0x%x\n", __FILE__, __LINE__, regbase);
+		BUG();
+	} else if ((regbase != chnpptr->wx_base) && (regbase != chnpptr->rx_base)) {
+		MSG("%s:%d regbase=0x%x\n", __FILE__, __LINE__, regbase);
+		BUG();
+	}
+	return tangox_mbus_memcpy(chnpptr, dst, src, size);
+}
+EXPORT_SYMBOL(mbus_memcpy);
+
diff -Naur linux-3.9.2.ref/arch/mips/tangox/Platform linux-3.9.2/arch/mips/tangox/Platform
--- linux-3.9.2.ref/arch/mips/tangox/Platform	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/tangox/Platform	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,118 @@
+ifdef CONFIG_TANGO2
+#
+# Sigma Designs Tango2 boards
+#
+  include $(srctree)/arch/mips/include/asm/tango2/emhwlib_registers_tango2.inc
+  include $(srctree)/arch/mips/include/asm/tango2/emhwlib_dram_tango2.inc
+else
+  ifdef CONFIG_TANGO3
+#
+# Sigma Designs Tango3 boards
+#
+    include $(srctree)/arch/mips/include/asm/tango3/emhwlib_registers_tango3.inc
+    include $(srctree)/arch/mips/include/asm/tango3/emhwlib_dram_tango3.inc
+  endif
+endif
+
+ifdef CONFIG_TANGOX
+ifneq ($(XSDK_DEFAULT_CPU_CERTID),)
+CERT_ID=$(XSDK_DEFAULT_CPU_CERTID)
+endif
+
+ifneq ($(XSDK_DEFAULT_KEY_DOMAIN),)
+CERT_TYPE=$(XSDK_DEFAULT_KEY_DOMAIN)
+endif
+
+ifneq ($(CERT_TYPE),)
+  ifneq ($(CERT_ID),)
+    CERT_SET=y
+  endif
+endif
+
+ifneq ($(CERT_SET),y)
+  ifdef CONFIG_TANGO2
+    ifneq '$(filter -DWITH_PROD=1 -DWITH_FACSPROD=1, $(RMCFLAGS))' ''
+      CERT_ID=000c
+      CERT_TYPE=8634_ES4_prod
+    else
+      CERT_ID=000b
+      CERT_TYPE=8634_ES4_dev
+    endif
+  else
+    ifdef CONFIG_TANGO3
+      # Use 0001 for encrypted image (instead of signed-only image) 
+      ifdef CONFIG_TANGO3_SMP8656SF
+        ifneq '$(filter -DWITH_PROD=1 -DWITH_FACSPROD=1, $(RMCFLAGS))' ''
+          CERT_ID=000f
+          CERT_TYPE=8656_ES1_prod
+        else
+          CERT_ID=000f
+          CERT_TYPE=8656_ES1_dev
+        endif
+      else
+        ifdef CONFIG_TANGO3_SMP8656OTP
+          ifneq '$(filter -DWITH_PROD=1 -DWITH_FACSPROD=1, $(RMCFLAGS))' ''
+            CERT_ID=0x000f
+            CERT_TYPE=8656_ES2_prod
+          else
+            CERT_ID=0x000f
+            CERT_TYPE=8656_ES2_dev
+          endif
+	else
+          ifneq '$(filter -DWITH_PROD=1 -DWITH_FACSPROD=1, $(RMCFLAGS))' ''
+            CERT_ID=000f
+            CERT_TYPE=8644_ES1_prod
+          else
+            CERT_ID=000f
+            CERT_TYPE=8644_ES1_dev
+          endif
+        endif
+      endif
+    endif
+  endif
+endif
+
+internal_hex = 0x$(shell printf "%x" $$(($(1))))
+
+platform-$(CONFIG_TANGOX)		+= tangox/
+
+ifdef CONFIG_TANGO2
+  cflags-$(CONFIG_TANGO2)		+= -I$(srctree)/arch/mips/include/asm/mach-tango2
+  load-$(CONFIG_TANGO2)			:= $(call internal_hex,0x80000000+$(MEM_BASE_dram_controller_0)+$(FM_linuxmips__ftext))
+  cflags-$(CONFIG_TANGO2)		+= -DEM86XX_CHIP=EM86XX_CHIPID_TANGO2 -DEM86XX_REVISION=6
+  cflags-$(CONFIG_TANGO2)		+= -DRMCHIP_ID=RMCHIP_ID_SMP8634 -DRMCHIP_REVISION=6
+  cflags-$(CONFIG_TANGO2)		+= -mtune=4kc
+else
+  ifdef CONFIG_TANGO3
+    KERNEL_START_ADDRESS		:= $(CPU_remap2_address)
+    cflags-$(CONFIG_TANGO3)		+= -I$(srctree)/arch/mips/include/asm/mach-tango3
+    load-$(CONFIG_TANGO3)		:= $(call internal_hex,0x80000000+$(KERNEL_START_ADDRESS))
+    cflags-$(CONFIG_TANGO3)		+= -DEM86XX_CHIP=EM86XX_CHIPID_TANGO3 -DEM86XX_REVISION=3
+    cflags-$(CONFIG_TANGO3)		+= -DCPU_REMAP_SPACE=$(KERNEL_START_ADDRESS)UL -mtune=24kf
+    cflags-$(CONFIG_TANGO3_SMP8652)	+= -DRMCHIP_ID=RMCHIP_ID_SMP8652 -DRMCHIP_REVISION=3
+    cflags-$(CONFIG_TANGO3_SMP8654)	+= -DRMCHIP_ID=RMCHIP_ID_SMP8654 -DRMCHIP_REVISION=3
+    cflags-$(CONFIG_TANGO3_SMP8656OTP)	+= -DRMCHIP_ID=RMCHIP_ID_SMP8656 -DRMCHIP_REVISION=3
+    cflags-$(CONFIG_TANGO3_SMP8656SF)	+= -DRMCHIP_ID=RMCHIP_ID_SMP8658 -DRMCHIP_REVISION=3
+    cflags-$(CONFIG_TANGO3_SMP8642)	+= -DRMCHIP_ID=RMCHIP_ID_SMP8642 -DRMCHIP_REVISION=3
+    cflags-$(CONFIG_TANGO3_SMP8644)	+= -DRMCHIP_ID=RMCHIP_ID_SMP8644 -DRMCHIP_REVISION=3
+    cflags-$(CONFIG_TANGO3_SMP8646)	+= -DRMCHIP_ID=RMCHIP_ID_SMP8646 -DRMCHIP_REVISION=3
+    cflags-$(CONFIG_TANGO3_SMP8670)	+= -DRMCHIP_ID=RMCHIP_ID_SMP8670 -DRMCHIP_REVISION=3
+    cflags-$(CONFIG_TANGO3_SMP8672)	+= -DRMCHIP_ID=RMCHIP_ID_SMP8672 -DRMCHIP_REVISION=1
+    cflags-$(CONFIG_TANGO3_SMP8674)	+= -DRMCHIP_ID=RMCHIP_ID_SMP8674 -DRMCHIP_REVISION=1
+    cflags-$(CONFIG_TANGO3_SMP8680)	+= -DRMCHIP_ID=RMCHIP_ID_SMP8680 -DRMCHIP_REVISION=1
+    cflags-$(CONFIG_TANGO3_SMP8682)	+= -DRMCHIP_ID=RMCHIP_ID_SMP8682 -DRMCHIP_REVISION=1
+    cflags-$(CONFIG_TANGO3_SMP868A)	+= -DRMCHIP_ID=RMCHIP_ID_SMP868A -DRMCHIP_REVISION=1
+  endif
+endif
+endif
+CLEAN_FILES += arch/mips/boot/vmlinux.gz \
+		arch/mips/boot/*.bin \
+		arch/mips/boot/*.xload \
+		arch/mips/boot/*.zbf \
+		arch/mips/boot/zbimage-linux-* 
+
+# ramdisk/initrd support
+# You may need a compressed ramdisk image, named ramdisk.gz in
+# arch/mips/ramdisk
+platform-$(CONFIG_EMBEDDED_RAMDISK) += /ramdisk/
+
diff -Naur linux-3.9.2.ref/arch/mips/tangox/prom.c linux-3.9.2/arch/mips/tangox/prom.c
--- linux-3.9.2.ref/arch/mips/tangox/prom.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/tangox/prom.c	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,964 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2009
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#include <linux/init.h>
+#include <asm/bootinfo.h>
+#include <asm/page.h>
+#include <linux/module.h>
+#include <asm/cacheflush.h>
+
+#include "setup.h"
+
+#if defined(CONFIG_TANGO3) 
+#include "xenv.h"
+#include "xenvkeys.h"
+#endif
+
+/*
+ * em8xxx_sys_frequency may be used later in the serial  code, DON'T mark
+ * it as initdata
+ */
+unsigned long em8xxx_sys_frequency;
+unsigned long em8xxx_cpu_frequency;
+unsigned long orig_cpu_freq;
+unsigned long em8xxx_kmem_start;
+unsigned long em8xxx_kmem_size;
+unsigned long em8xxx_himem_start;
+unsigned long em8xxx_himem_size;
+unsigned long em8xxx_sys_clkgen_pll;
+unsigned long em8xxx_sys_premux;
+unsigned long em8xxx_sys_mux;
+#if defined(CONFIG_TANGO3)
+unsigned long max_remap_size = MAX_KERNEL_MEMSIZE;
+#endif 
+
+unsigned long tangox_chip_id(void);
+int is_tango2_chip(void);
+int is_tango3_chip(void);
+int is_tango3_es1(void);
+int is_tango3_es2(void);
+void tangox_get_himem_info(unsigned long *start, unsigned long *size);
+
+/*
+ * we will restore remap registers before rebooting
+ */
+#ifdef CONFIG_TANGO2
+unsigned long em8xxx_remap_registers[5];
+#elif defined(CONFIG_TANGO3)
+unsigned long em8xxx_remap_registers[9];
+unsigned long tangox_zxenv[MAX_XENV_SIZE/sizeof(unsigned long)] = { 0 };
+#endif 
+
+/*
+ * helper to access base registers
+ */
+#define RD_BASE_REG32(r)	\
+		gbus_read_reg32(REG_BASE_system_block + (r))
+
+/*
+ * return system type (/proc/cpuinfo)
+ */
+const char *get_system_type(void)
+{
+	return "Sigma Designs TangoX";
+}
+
+#ifdef CONFIG_TANGOX_FIXED_FREQUENCIES
+unsigned long tangox_get_pllclock(int pll)
+{
+	return(0);
+}
+
+unsigned long tangox_get_sysclock(void)
+{
+	return(CONFIG_TANGOX_SYS_FREQUENCY);
+}
+
+unsigned long tangox_get_cpuclock(void)
+{
+	return(CONFIG_TANGOX_CPU_FREQUENCY);
+}
+
+unsigned long tangox_get_dspclock(void)
+{
+	return(CONFIG_TANGOX_DSP_FREQUENCY);
+}
+#else
+unsigned long tangox_get_pllclock(int pll)
+{
+	unsigned long sys_clkgen_pll, sysclk_mux;
+	unsigned long n, m, freq, k, step;
+
+	sysclk_mux = RD_BASE_REG32(SYS_sysclk_mux) & 0xf01;
+	if ((sysclk_mux & 0x1) == 0) {
+		freq = TANGOX_BASE_FREQUENCY;
+		goto done;
+	}
+
+	sys_clkgen_pll = RD_BASE_REG32(SYS_clkgen0_pll + (pll * 0x8));
+
+	/* Not using XTAL_IN, cannot calculate */
+	if ((sys_clkgen_pll & 0x07000000) != 0x01000000)
+		goto freq_error;
+
+#ifdef CONFIG_TANGO2
+	m = (sys_clkgen_pll >> 16) & 0x1f;
+	n = sys_clkgen_pll & 0x000003ff;
+	k = (pll) ? 0 : ((sys_clkgen_pll >> 14) & 0x3); 
+	step = 2;
+#elif defined(CONFIG_TANGO3)
+	if (pll != 0) { /* PLL1/PLL2 */
+		m = (sys_clkgen_pll >> 16) & 0x1;
+		n = sys_clkgen_pll & 0x0000007f;
+		k = (sys_clkgen_pll >> 13) & 0x7;
+		step = 1;
+	} else {
+		m = (sys_clkgen_pll >> 16) & 0x1f;
+		n = sys_clkgen_pll & 0x000003ff;
+		k = (sys_clkgen_pll >> 14) & 0x3; 
+		step = 2;
+	}
+#else
+#error Unsupported platform.
+#endif
+	freq = ((TANGOX_BASE_FREQUENCY / (m + step)) * (n + step)) / (1 << k);
+
+done:
+	return(freq);
+
+freq_error:
+	printk("%s:%d don't know how to calculate the frequency ..\n", __FILE__, __LINE__);
+	BUG();
+	return(0);
+}
+
+static unsigned long tangox_get_clock(unsigned int clk_dom)
+{
+	unsigned long sysclk_mux, sysclk_premux;
+	unsigned long div, mux, pll, pll_freq;
+	static const unsigned char dividers[3][12] = {
+		{ 2, 4, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4 },
+		{ 2, 2, 2, 3, 3, 2, 3, 2, 4, 2, 4, 2 }, 
+#ifdef CONFIG_TANGO2
+		{ 2, 4, 3, 3, 3, 3, 2, 2, 4, 4, 2, 2 },
+#else
+		{ 2, 4, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4 },
+#endif
+	};
+
+	sysclk_mux = RD_BASE_REG32(SYS_sysclk_mux) & 0xf01;
+	sysclk_premux = RD_BASE_REG32(SYS_sysclk_premux);
+	pll = sysclk_premux & 0x3;
+
+	if (((pll_freq = tangox_get_pllclock(pll)) == 0) || (clk_dom >= 3))
+		goto freq_error;
+	else if ((mux = ((sysclk_mux >> 8) & 0xf)) >= 12)
+		goto freq_error; /* invalid mux value */
+
+	div = (unsigned long)dividers[clk_dom][mux];
+
+	return(pll_freq / div);
+
+freq_error:
+	return(0);
+}
+
+unsigned long tangox_get_sysclock(void)
+{
+	return(tangox_get_clock(0));
+}
+
+unsigned long tangox_get_cpuclock(void)
+{
+	return(tangox_get_clock(1));
+}
+
+unsigned long tangox_get_dspclock(void)
+{
+	return(tangox_get_clock(2));
+}
+#endif
+
+extern int do_syslog(int type, char * buf, int len);
+extern int __init xenv_config(void);
+extern void __init tangox_device_info(void);
+extern const char *tangox_xenv_cmdline(void);
+
+#if defined(CONFIG_TANGO3)
+#define REMAP_SIZE	0x04000000UL
+static inline void update_remap(unsigned int remap, unsigned long mapaddr)
+{
+	if (gbus_read_reg32(REG_BASE_cpu_block + CPU_remap + (remap * 4)) != mapaddr) {
+		gbus_write_reg32(REG_BASE_cpu_block + CPU_remap + (remap * 4), mapaddr);
+		iob();
+	}
+	em8xxx_remap_registers[remap] = mapaddr & 0xfc000000UL;
+}
+
+#ifdef CONFIG_TANGOX_XENV_READ
+unsigned long __init dram_remap_setup(unsigned long dsize)
+{
+	unsigned long max_d0_size = 0, max_d1_size = 0, tmp, tsize = 0, fd0 = 0;
+	unsigned long dx_sizes[2], dx_addrs[2];
+	unsigned int size = sizeof(unsigned long), i, j;
+
+	/* check the boundaries for DRAM0 and DRAM1 */
+	if ((xenv_get((void *)KSEG1ADDR(REG_BASE_cpu_block + LR_XENV2_RW), MAX_LR_XENV2_RW, XENV_LRRW_RUAMM0_GA, &tmp, &size) == 0) 
+			&& (size == sizeof(unsigned long))) 
+		fd0 = max_d0_size = tmp - MEM_BASE_dram_controller_0;
+	if ((xenv_get((void *)KSEG1ADDR(REG_BASE_cpu_block + LR_XENV2_RW), MAX_LR_XENV2_RW, XENV_LRRW_RUAMM1_GA, &tmp, &size) == 0) 
+			&& (size == sizeof(unsigned long))) 
+		max_d1_size = tmp - MEM_BASE_dram_controller_1;
+
+	/* Max. dynamic remap can do only 384MB */
+	max_d0_size = (max_d0_size > 0x18000000UL) ? 0x18000000UL : max_d0_size;
+	max_d1_size = (max_d1_size > 0x18000000UL) ? 0x18000000UL : max_d1_size;
+
+	printk("Desired kernel memory size: 0x%08lx\n", dsize);
+	printk("Max. DRAM0/1 size allowed: 0x%08lx/0x%08lx\n", max_d0_size, max_d1_size);
+
+	if (gbus_read_reg32(REG_BASE_cpu_block + CPU_remap + (REMAP_IDX * 4)) >= MEM_BASE_dram_controller_1) {
+		/* Use DRAM1 first */
+		dx_sizes[0] = max_d1_size;
+		dx_sizes[1] = max_d0_size;
+		dx_addrs[0] = MEM_BASE_dram_controller_1;
+		dx_addrs[1] = MEM_BASE_dram_controller_0;
+	} else {
+		/* Use DRAM0 first */
+		dx_sizes[0] = max_d0_size;
+		dx_sizes[1] = max_d1_size;
+		dx_addrs[0] = MEM_BASE_dram_controller_0;
+		dx_addrs[1] = MEM_BASE_dram_controller_1;
+	}
+
+	for (i = REMAP_IDX, j = 0; (dx_sizes[0] >= REMAP_SIZE) && (dsize >= REMAP_SIZE) && (i < 8); i++, j++) {
+		update_remap(i, dx_addrs[0] + (j * REMAP_SIZE));
+		dx_sizes[0] -= REMAP_SIZE;
+		dsize -= REMAP_SIZE;
+		tsize += REMAP_SIZE;
+		printk(" Mapped 0x%08lx(size 0x%08lx) via remap%d\n", 
+			dx_addrs[0] + (j * REMAP_SIZE), REMAP_SIZE, i);
+	}
+	if (i < 8) {
+		if (dsize > 0) {
+			if (dsize < REMAP_SIZE) {
+				if (dx_sizes[0] >= dsize) {
+					update_remap(i, dx_addrs[0] + (j * REMAP_SIZE));
+					tsize += dsize;
+					printk(" Mapped 0x%08lx(size 0x%08lx) via remap%d\n", 
+						dx_addrs[0] + (j * REMAP_SIZE), dsize, i);
+					goto done;
+				} else if (dx_sizes[0] > dx_sizes[1]) {
+					update_remap(i, dx_addrs[0] + (j * REMAP_SIZE));
+					tsize += dx_sizes[0];
+					printk(" Mapped 0x%08lx(size 0x%08lx) via remap%d\n", 
+						dx_addrs[0] + (j * REMAP_SIZE), dx_sizes[0], i);
+					goto done;
+				}
+			} else {
+				if (dx_sizes[0] > dx_sizes[1]) {
+					update_remap(i, dx_addrs[0] + (j * REMAP_SIZE));
+					tsize += dx_sizes[0];
+					printk(" Mapped 0x%08lx(size 0x%08lx) via remap%d\n", 
+						dx_addrs[0] + (j * REMAP_SIZE), dx_sizes[0], i);
+					goto done;
+				}
+			}
+		}
+	} else {
+		/* Check to see if the last, fixed remap works? */
+		if (dsize > 0) {
+			unsigned long msz = (fd0 > 0x0c000000UL) ? (fd0 - 0x0c000000UL) : 0UL;
+			msz = (msz > dsize) ? dsize : msz;
+			if (msz) {
+				tsize += msz;
+				printk(" Mapped 0x%08lx(size 0x%08lx) via remap%d\n", 
+					MEM_BASE_dram_controller_0 + 0x0c000000UL, msz, i);
+			}
+		}
+		goto done;
+	}
+
+	for (j = 0; (dx_sizes[1] >= REMAP_SIZE) && (dsize >= REMAP_SIZE) && (i < 8); i++, j++) {
+		update_remap(i, dx_addrs[1] + (j * REMAP_SIZE));
+		dx_sizes[1] -= REMAP_SIZE;
+		dsize -= REMAP_SIZE;
+		tsize += REMAP_SIZE;
+		printk(" Mapped 0x%08lx(size 0x%08lx) via remap%d\n", 
+			dx_addrs[1] + (j * REMAP_SIZE), REMAP_SIZE, i);
+	}
+	if (i < 8) {
+		if (dsize > 0) {
+			unsigned long msz = (dx_sizes[1] > dsize) ? dsize : dx_sizes[1];
+			if (msz) {
+				update_remap(i, dx_addrs[1] + (j * REMAP_SIZE));
+				tsize += msz;
+				printk(" Mapped 0x%08lx(size 0x%08lx) via remap%d\n", 
+					dx_addrs[1] + (j * REMAP_SIZE), msz, i);
+			}
+			goto done;
+		}
+	} else {
+		/* Check to see if the last, fixed remap works? */
+		if (dsize > 0) {
+			unsigned long msz = (fd0 > 0x0c000000UL) ? (fd0 - 0x0c000000UL) : 0UL;
+			msz = (msz > dsize) ? dsize : msz;
+			if (msz) {
+				tsize += msz;
+				printk(" Mapped 0x%08lx(size 0x%08lx) via remap%d\n", 
+					MEM_BASE_dram_controller_0 + 0x0c000000UL, msz, i);
+			}
+		}
+		goto done;
+	}
+
+done:
+	printk("Final kernel memory size: 0x%08lx\n", tsize);
+	return(tsize);
+}
+#endif
+
+void __init update_lrrw_kend(unsigned long kend)
+{
+#ifdef CONFIG_TANGOX_XENV_READ
+//	xenv_set((void *)KSEG1ADDR(REG_BASE_cpu_block + LR_XENV2_RW), MAX_LR_XENV2_RW, XENV_LRRW_KERNEL_END, &kend, 0, sizeof(kend));
+#endif
+}
+#endif
+
+void __init tangox_mem_setup(unsigned long size)
+{
+	unsigned long em8xxx_kmem_end;
+#if defined(CONFIG_TANGO3)
+#ifdef CONFIG_TANGOX_XENV_READ
+	em8xxx_kmem_size = dram_remap_setup(size);
+#else
+	em8xxx_kmem_size = size;
+#endif
+	em8xxx_kmem_end = KSEG1ADDR(em8xxx_kmem_start + em8xxx_kmem_size) - KSEG1ADDR(CPU_REMAP_SPACE);
+	update_lrrw_kend(em8xxx_kmem_end);
+#else
+	/*
+	 * check/fill the memcfg
+	 */
+	memcfg_t *m = (memcfg_t *)KSEG1ADDR(MEM_BASE_dram_controller_0 + FM_MEMCFG);
+	em8xxx_kmem_size = ((size + em8xxx_kmem_start) & 0xfff00000) - em8xxx_kmem_start;
+	em8xxx_kmem_end = KSEG1ADDR(em8xxx_kmem_start + em8xxx_kmem_size) - KSEG1ADDR(MEM_BASE_dram_controller_0);
+	if (is_valid_memcfg(m) == 0) {
+		printk("Invalid MEMCFG, creating new one at 0x%08x.\n", MEM_BASE_dram_controller_0 + FM_MEMCFG);
+		memset(m, 0, sizeof (memcfg_t));
+		m->signature = MEMCFG_SIGNATURE;
+		m->dram0_size = TANGOX_SYSTEMRAM_ACTUALSIZE;
+		m->kernel_end = em8xxx_kmem_end;
+		gen_memcfg_checksum(m);
+	} else {
+		printk("Valid MEMCFG found at 0x%08x.\n", MEM_BASE_dram_controller_0 + FM_MEMCFG);
+		m->kernel_end = em8xxx_kmem_end;
+		gen_memcfg_checksum(m);
+	}
+#endif
+
+	return;
+}
+
+#ifdef CONFIG_HIGHMEM
+static void __init tangox_himem_setup(unsigned long *start, unsigned long *size)
+{
+	unsigned long himem_ga = *start, himem_sz = *size, himem_end;
+	
+#ifdef CONFIG_TANGO3
+	int i;
+	unsigned long remap_ga, remap_sz, remap_end, kmem_sz;
+
+	if ((himem_ga == 0) || (himem_sz == 0))
+		return;
+	/* align highmem area to page boundary */
+	himem_ga = (himem_ga & PAGE_MASK) + ((himem_ga & ~PAGE_MASK) ? PAGE_SIZE : 0);
+	himem_end = (himem_ga + himem_sz) & PAGE_MASK;
+	if (himem_ga >= himem_end) 
+		goto no_highmem;
+
+	for (i = REMAP_IDX, kmem_sz = em8xxx_kmem_size; (kmem_sz > 0) && (i < 8); i++) {
+		remap_ga = em8xxx_remap_registers[i];
+		remap_sz = (kmem_sz >= 0x04000000UL) ? 0x04000000UL : kmem_sz;
+		remap_end = remap_ga + remap_sz;
+
+		/* if overlap found in remapped memory and highmem area, we need
+		   to adjust highmem area accordingly. */
+		if ((himem_ga >= remap_ga) && (himem_ga < remap_end))
+			himem_ga = remap_end;
+		if ((himem_end > remap_ga) && (himem_end <= remap_end))
+			himem_end = remap_ga;
+
+		if (himem_ga >= himem_end) 
+			goto no_highmem;
+		kmem_sz -= remap_sz;
+	}
+#else
+	memcfg_t *m = (memcfg_t *)KSEG1ADDR(MEM_BASE_dram_controller_0 + FM_MEMCFG);
+
+	if ((himem_ga == 0) || (himem_sz == 0))
+		return;
+	/* align highmem area to page boundary */
+	himem_ga = (himem_ga & PAGE_MASK) + ((himem_ga & ~PAGE_MASK) ? PAGE_SIZE : 0);
+	himem_end = (himem_ga + himem_sz) & PAGE_MASK;
+	if (himem_ga >= himem_end) 
+		goto no_highmem;
+
+	/* adjust highmem area to restrict it to DRAM1 only */
+	if (himem_ga < MEM_BASE_dram_controller_1)
+		himem_ga = MEM_BASE_dram_controller_1;
+	else if (himem_ga > MEM_BASE_dram_controller_1 + m->dram1_size) 
+		goto no_highmem;
+
+	if (himem_end > MEM_BASE_dram_controller_1 + m->dram1_size)
+		himem_end = MEM_BASE_dram_controller_1 + m->dram1_size;
+	else if (highmem_end < MEM_BASE_dram_controller_1) 
+		goto no_highmem;
+
+	if (himem_ga >= himem_end) 
+		goto no_highmem;
+#endif
+
+	*start = himem_ga;
+	*size = himem_end - himem_ga;
+	return;
+
+no_highmem:
+	*start = *size = 0; /* no highmem available */
+	return;
+}
+#endif
+
+void __init prom_init(void)
+{
+	extern char _text;
+	unsigned long offset;
+	int clksel, xenv_res = 0, i;
+	char *revStr = NULL;
+
+#if 0
+	/* For emulator, setup registers that typically got setup by bootloader */
+	/* Temporary HACK */
+	/* UART0/1 UART mode */
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_uart0_gpio_mode, 0xff00);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_uart1_gpio_mode, 0xff00);
+
+	/* Set interrupt attributes, clear/disable all external interrupts */
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_irq_enableclr, 0xffffffff);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_edge_config_rise_clr, 0xffffffff);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_edge_config_fall_clr, 0xffffffff);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_edge_config_rise_set, 0);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_edge_config_fall_set, 0);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_edge_rawstat, 0xffffffff);
+
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_irq_enableclr_hi, 0xffffffff);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_edge_config_rise_clr_hi, 0xffffffff);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_edge_config_fall_clr_hi, 0xffffffff);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_edge_config_rise_set_hi, 0);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_edge_config_fall_set_hi, 0);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_edge_rawstat_hi, 0xffffffff);
+#endif
+	/*
+	 * save remap registers for reboot time
+	 */
+	for (i = 0;
+#ifdef CONFIG_TANGO2
+		i < 5;
+#elif defined(CONFIG_TANGO3)
+		i < 8;
+#endif
+		i++) {
+		em8xxx_remap_registers[i] = gbus_read_reg32(REG_BASE_cpu_block + CPU_remap + (i * 4));
+	}
+#if defined(CONFIG_TANGO3)
+	em8xxx_remap_registers[8] = MEM_BASE_dram_controller_0 + 0x0c000000UL; /* Fixed "remap" */
+#endif
+
+	/* 
+	 * Set remap so that 0x1fc00000 and 0x0 back to they should be...
+	 */
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_remap, 0x1fc00000);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_remap1, 0x0);
+	iob();
+	
+#if defined(CONFIG_TANGO2_SMP863X)
+	printk("Configured for SMP863%c (revision %s), ",
+			'x', "ES6+/RevA+"
+	      );
+#elif defined(CONFIG_TANGO3_SMP86XX)
+	printk("Configured for SMP%s, ",
+#if defined(CONFIG_TANGO3_865X)
+			"865x"
+#elif defined(CONFIG_TANGO3_864X)
+			"864x"
+#elif defined(CONFIG_TANGO3_867X)
+			"867x"
+#elif defined(CONFIG_TANGO3_868X)
+			"868x"
+#endif
+	      );
+#else
+#error Unsupported platform.
+#endif
+	printk("detected SMP%lx (revision ", (tangox_chip_id()>>16)&0xffff);
+#if defined(CONFIG_TANGO2)
+	if (is_tango2_chip()) {
+		unsigned long revision = tangox_chip_id() & 0xff;
+		switch(revision) {
+			case 0x81: /* ES1-3 */
+				revStr = "ES1-3";
+				break;
+			case 0x82: /* ES4-5 */
+				revStr = "ES4-5";
+				break;
+			case 0x83: /* ES6/RevA */
+				revStr = "ES6/RevA";
+				break;
+			case 0x84: /* ES7/RevB */
+				revStr = "ES7/RevB";
+				break;
+			case 0x85: /* ES8 */
+				revStr = "ES8";
+				break;
+			case 0x86: /* ES9/RevC */
+				revStr = "ES9/RevC";
+				break;
+			default: /* Unknown */
+				revStr = "unknown";
+				break;
+		}
+	} 
+#elif defined(CONFIG_TANGO3)
+	if (is_tango3_chip()) {
+		unsigned long revision = tangox_chip_id() & 0xff;
+		switch(revision) {
+			case 0x1: /* ES1 */
+				revStr = "ES1";
+				break;
+			case 0x2: /* ES2 */
+				revStr = "ES2";
+				break;
+			case 0x3: /* ES3 */
+				revStr = "ES3";
+				break;
+			case 0x4: /* ES4 */
+				revStr = "ES4";
+				break;
+			case 0x5: /* ES5 */
+				revStr = "ES5";
+				break;
+			case 0x6: /* ES6 */
+				revStr = "ES6";
+				break;
+			default: /* Unknown */
+				revStr = "unknown";
+				break;
+		}
+	} 
+#endif
+	else
+		revStr = "unknown";
+	
+	printk("%s).\n", revStr);
+#ifdef CONFIG_TANGOX_FIXED_FREQUENCIES
+	printk("Fixed CPU/System/DSP Frequencies: %ld.%02ld/%ld.%02ld/%ld.%02ldMHz\n",
+		tangox_get_cpuclock() / 1000000, (tangox_get_cpuclock() / 10000) % 100,
+		tangox_get_sysclock() / 1000000, (tangox_get_sysclock() / 10000) % 100,
+		tangox_get_dspclock() / 1000000, (tangox_get_dspclock() / 10000) % 100);
+#else
+	printk("Detected CPU/System/DSP Frequencies: %ld.%02ld/%ld.%02ld/%ld.%02ldMHz\n",
+		tangox_get_cpuclock() / 1000000, (tangox_get_cpuclock() / 10000) % 100,
+		tangox_get_sysclock() / 1000000, (tangox_get_sysclock() / 10000) % 100,
+		tangox_get_dspclock() / 1000000, (tangox_get_dspclock() / 10000) % 100);
+#endif
+
+	/*
+	 * read xenv  configuration, we  need it quickly  to configure
+	 * console accordingly.
+	 *
+	 * NOTE: We  may stay STUCK in  this if safe  mode is required
+	 * and XENV is not valid !
+	 */
+	xenv_res = xenv_config();
+
+	/*
+	 * calculate cpu & sys frequency (may be needed for uart init)
+	 */
+	orig_cpu_freq = em8xxx_cpu_frequency = tangox_get_cpuclock();
+	em8xxx_sys_frequency = tangox_get_sysclock();
+
+	em8xxx_sys_clkgen_pll = RD_BASE_REG32(SYS_clkgen_pll);
+	em8xxx_sys_premux = RD_BASE_REG32(SYS_sysclk_premux) & 0x3;
+	em8xxx_sys_mux = RD_BASE_REG32(SYS_sysclk_mux) & 0xf01;
+
+	/*
+	 * program the right clock divider in both uart
+	 */
+#ifdef CONFIG_TANGOX_UART_USE_SYSCLK
+	clksel = 0;
+#else
+	clksel = 1;
+#endif
+#if defined(CONFIG_TANGO3)
+ 	if ((((tangox_chip_id() >> 16) & 0xfffe) == 0x8656) || (((tangox_chip_id() >> 16) & 0xfffe) == 0x8672) || (((tangox_chip_id() >> 16) & 0xfffe) == 0x8674))
+ 		gbus_write_reg32(REG_BASE_system_block + 0x700 + CPU_UART_CLKSEL, clksel);
+ 	else
+		gbus_write_reg32(REG_BASE_cpu_block + CPU_UART0_base + CPU_UART_CLKSEL, clksel);
+#else
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_UART0_base + CPU_UART_CLKSEL, clksel);
+#endif
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_UART1_base + CPU_UART_CLKSEL, clksel);
+#if defined(CONFIG_TANGO3)
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_UART2_base + CPU_UART_CLKSEL, clksel);
+#endif
+
+	/*
+	 * show KERN_DEBUG message on console
+	 */
+	do_syslog(8, NULL, 8);
+
+#ifdef CONFIG_TANGOX_PROM_CONSOLE
+	/* initialize uart and register early console */
+	prom_console_register();
+#endif
+
+	/* warn user if we use failsafe values for xenv */
+	if (xenv_res)
+		printk("Invalid XENV content, using failsafe values\n");
+	tangox_device_info();
+
+	/*
+	 * compute kernel memory start address/size
+	 * _text section gives kernel address start
+	 */
+	em8xxx_kmem_start = ((unsigned long)(&_text)) & PAGE_MASK;
+
+#if ((CONFIG_TANGOX_SYSTEMRAM_ACTUALSIZE<<20) > MAX_KERNEL_MEMSIZE)
+	em8xxx_kmem_size = ((MAX_KERNEL_MEMSIZE + em8xxx_kmem_start) & 0xfff00000) - em8xxx_kmem_start;
+#else
+	em8xxx_kmem_size = (((CONFIG_TANGOX_SYSTEMRAM_ACTUALSIZE << 20) + em8xxx_kmem_start) & 0xfff00000) - em8xxx_kmem_start;
+#endif
+
+	tangox_mem_setup(em8xxx_kmem_size);
+#ifdef CONFIG_HIGHMEM
+	tangox_get_himem_info(&em8xxx_himem_start, &em8xxx_himem_size);
+	tangox_himem_setup(&em8xxx_himem_start, &em8xxx_himem_size);
+#endif
+
+	/*
+	 * tell kernel about available memory size/offset
+	 */
+#if defined(CONFIG_TANGO3)
+	offset = KSEG1ADDR(em8xxx_kmem_start) - KSEG1ADDR(CPU_REMAP_SPACE);
+	add_memory_region(CPU_REMAP_SPACE + offset, em8xxx_kmem_size, BOOT_MEM_RAM);
+#else
+	offset = KSEG1ADDR(em8xxx_kmem_start) - KSEG1ADDR(MEM_BASE_dram_controller_0);
+	add_memory_region(MEM_BASE_dram_controller_0 + offset, em8xxx_kmem_size, BOOT_MEM_RAM);
+#endif
+#ifdef CONFIG_HIGHMEM
+	if ((em8xxx_himem_start != 0) && (em8xxx_himem_size != 0)) {
+		add_memory_region(em8xxx_himem_start, em8xxx_himem_size, BOOT_MEM_RAM);
+		printk("adding [0x%08lx..0x%08lx) as highmem area.\n", em8xxx_himem_start, em8xxx_himem_start + em8xxx_himem_size);
+	}
+#endif
+
+	arcs_cmdline[CL_SIZE - 1] = '\0';
+#ifndef CONFIG_TANGOX_IGNORE_CMDLINE
+	/*
+	 * set up correct linux command line according to XENV, memcfg
+	 * and YAMON args, if not told to ignore them
+	 */
+#ifdef CONFIG_TANGOX_XENV_READ
+	/* If specified by xenv, override the command line */
+	if (tangox_xenv_cmdline())
+		strncpy(arcs_cmdline, tangox_xenv_cmdline(), CL_SIZE - 1);
+#ifdef CONFIG_CMDLINE
+	else
+		strncpy(arcs_cmdline, CONFIG_CMDLINE, CL_SIZE - 1);
+#endif
+#else
+	strncpy(arcs_cmdline, CONFIG_CMDLINE, CL_SIZE - 1);
+#endif
+
+	/* If specified by memcfg, override the command line */
+//	if (m->linux_cmd != 0 && strnlen((char *)KSEG1ADDR(m->linux_cmd), CL_SIZE - 1) > 0)
+//disabled. e.m. 2006feb3rd		strncpy(arcs_cmdline, (char *)KSEG1ADDR(m->linux_cmd), CL_SIZE - 1);
+
+	/* take regular args given by bootloader */
+	if ((fw_arg0 > 1) && (fw_arg0 < 65)) { /* Up to 64 arguments */
+		int argc, i, pos;
+		char **argv;
+
+		argc = fw_arg0;
+		arcs_cmdline[0] = '\0';
+		argv = (char **) fw_arg1;
+		pos = 0;
+		for (i = 1; i < argc; i++) {
+			int len;
+
+			len = strnlen(argv[i], CL_SIZE - 1);
+			if (pos + 1 + len + 1 > sizeof (arcs_cmdline))
+				break;
+			if (pos)
+				arcs_cmdline[pos++] = ' ';
+			strncpy(arcs_cmdline + pos, argv[i], CL_SIZE - (pos + 1));
+			pos += len;
+		}
+	}
+#else
+#ifdef CONFIG_CMDLINE
+	strncpy(arcs_cmdline, CONFIG_CMDLINE, CL_SIZE - 1);
+#endif
+#endif /* !CONFIG_TANGOX_IGNORE_CMDLINE */
+
+	mips_machtype = MACH_TANGOX;
+	return;
+}
+
+void __init prom_free_prom_memory(void)
+{
+	return;
+}
+
+EXPORT_SYMBOL(tangox_get_sysclock);
+EXPORT_SYMBOL(tangox_get_cpuclock);
+EXPORT_SYMBOL(tangox_get_dspclock);
+EXPORT_SYMBOL(tangox_get_pllclock);
+
+unsigned long tangox_chip_id(void)
+{
+	unsigned long chip_id = 0;
+	if (chip_id == 0)
+		chip_id = ((gbus_read_reg32(REG_BASE_host_interface + PCI_REG0) & 0xffff) << 16) |
+				(gbus_read_reg32(REG_BASE_host_interface + PCI_REG1) & 0xff);
+	return chip_id;
+}
+
+int is_tango2_chip(void)
+{
+	unsigned long chip = (tangox_chip_id()>>16) & 0xfff0;
+	return (chip == 0x8630) ? 1 : 0;
+}
+
+static inline int is_tango2_revision(unsigned char revid)
+{
+	unsigned char rev = tangox_chip_id() & 0xff;
+	return (is_tango2_chip() && rev == revid) ? 1 : 0;
+}
+
+int is_tango2_es123(void)
+{
+	return(is_tango2_revision(0x81));
+}
+
+int is_tango2_es45(void)
+{
+	return(is_tango2_revision(0x82));
+}
+
+int is_tango2_es6(void)
+{
+	return(is_tango2_revision(0x83));
+}
+
+int is_tango2_es7(void)
+{
+	return(is_tango2_revision(0x84));
+}
+
+int is_tango2_es89(void)
+{
+	return(is_tango2_revision(0x85) || is_tango2_revision(0x86));
+}
+
+static inline int is_tango3_revision(unsigned char revid)
+{
+	unsigned char rev = tangox_chip_id() & 0xff;
+	unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+	if (!is_tango3_chip())
+		return(0);
+	else {
+		switch(chip_id) {
+			case 0x8670:
+			case 0x8672:
+			case 0x8674:
+			case 0x8646:
+			case 0x8652:
+			case 0x8656:
+			case 0x8680:
+			case 0x8682:
+			case 0x868A:
+				rev += 2;
+			case 0x8644:
+			case 0x8654:
+				return((rev == revid) ? 1 : 0);
+			default:
+				return(0);
+		}
+	}
+}
+
+int is_tango3_chip(void)
+{
+	unsigned long chip = (tangox_chip_id()>>16) & 0xfff0;
+	return ((chip == 0x8640) || (chip == 0x8650) || (chip == 0x8670) || (chip == 0x8680)) ? 1 : 0;
+}
+
+int is_tango3_es1(void)
+{
+	return(is_tango3_revision(0x1));
+}
+
+int is_tango3_es2(void)
+{
+	return(is_tango3_revision(0x2));
+}
+
+int is_tango3_es3(void)
+{
+	return(is_tango3_revision(0x3));
+}
+
+int is_tango3_es4(void)
+{
+	return(is_tango3_revision(0x4));
+}
+
+int is_tango3_es5(void)
+{
+	return(is_tango3_revision(0x5));
+}
+
+void tangox_flush_cache_all(void)
+{
+	__flush_cache_all();
+}
+
+EXPORT_SYMBOL(tangox_flush_cache_all);
+EXPORT_SYMBOL(tangox_chip_id);
+EXPORT_SYMBOL(is_tango2_chip);
+EXPORT_SYMBOL(is_tango3_chip);
+EXPORT_SYMBOL(is_tango2_es123);
+EXPORT_SYMBOL(is_tango2_es45);
+EXPORT_SYMBOL(is_tango2_es6);
+EXPORT_SYMBOL(is_tango2_es7);
+EXPORT_SYMBOL(is_tango2_es89);
+EXPORT_SYMBOL(is_tango3_es1);
+EXPORT_SYMBOL(is_tango3_es2);
+EXPORT_SYMBOL(is_tango3_es3);
+EXPORT_SYMBOL(is_tango3_es4);
+EXPORT_SYMBOL(is_tango3_es5);
+EXPORT_SYMBOL(em8xxx_kmem_size);
+EXPORT_SYMBOL(em8xxx_kmem_start);
+#if defined(CONFIG_TANGO3)
+EXPORT_SYMBOL(max_remap_size);
+EXPORT_SYMBOL(em8xxx_remap_registers);
+#endif
+
+int tangox_get_order(unsigned long size)
+{
+	return(get_order(size));
+}
+EXPORT_SYMBOL(tangox_get_order);
+
+void tangox_do_timer(unsigned long ticks)
+{
+	
+	extern void do_timer(unsigned long ticks);
+
+	write_seqlock(&jiffies_lock);
+	do_timer(ticks);
+	write_sequnlock(&jiffies_lock);
+}
+  
+EXPORT_SYMBOL(tangox_do_timer);
+
+#ifdef CONFIG_SD_DIRECT_DMA
+
+/* Given an address and length, determine if this area is physically contiguous or not, and
+   return the physical address of starting point, caller needs to ensure the page_table is
+   locked so no change is allowed. */
+int is_contiguous_memory(void __user *userbuf, unsigned int len, unsigned long *physaddr)
+{
+	pgd_t *pgd;
+	pud_t *pud;
+	pmd_t *pmd;
+	pte_t *pte;
+	unsigned long start = (unsigned long)userbuf;
+	unsigned long paddr, ppaddr;
+	unsigned long start_pg_addr, start_pg_offset, end_pg_addr, pg_addr;
+	struct mm_struct *mm = current->mm;
+	int ret = 0;
+
+//printk("%s:%d: start=0x%08lx, len=0x%x\n", __FILE__, __LINE__, start, len);
+
+	*physaddr = 0;
+	start_pg_addr = start & PAGE_MASK; /* address of start page */
+	start_pg_offset = start & ~PAGE_MASK; /* offset within start page */
+	end_pg_addr = ((start + len) & PAGE_MASK) - (((start + len) & ~PAGE_MASK) ? 0 : PAGE_SIZE); /* address of last page */
+
+	for (ppaddr = 0, pg_addr = start_pg_addr; pg_addr <= end_pg_addr; pg_addr += PAGE_SIZE) {
+		if (pg_addr > TASK_SIZE)
+			pgd = pgd_offset_k(pg_addr);
+		else
+			pgd = pgd_offset_gate(mm, pg_addr);
+		BUG_ON(pgd_none(*pgd));
+		pud = pud_offset(pgd, pg_addr);
+		BUG_ON(pud_none(*pud));
+		pmd = pmd_offset(pud, pg_addr);
+		if (pmd_none(*pmd)) 
+			goto error;
+		pte = pte_offset_map(pmd, pg_addr);
+		if (pte_none(*pte)) {
+			pte_unmap(pte);
+			goto error;
+		}
+		paddr = pte_val(*pte) & PAGE_MASK;
+//printk("TRANSLATED 0x%08lx, pte=0x%p, paddr=0x%lx\n", pg, pte, paddr);
+		pte_unmap(pte);
+
+		if (ppaddr == 0) { /* first page */
+			ppaddr = paddr;
+			*physaddr = (ppaddr | start_pg_offset);
+		} else if ((ppaddr + PAGE_SIZE) != paddr) /* not contiguous */
+			goto not_contiguous;
+		else
+			ppaddr = paddr;
+	}
+	ret = 1;
+
+not_contiguous:
+error:
+//printk("%s:%d: return %d\n", __FILE__, __LINE__, ret);
+	return ret;
+}
+
+EXPORT_SYMBOL(is_contiguous_memory);
+
+#endif /* CONFIG_SD_DIRECT_DMA */
+
+/* convering virtual address to physical address (perform page table walking if needed) */
+unsigned long tangox_virt_to_phys(void *pvaddr)
+{
+#if defined(CONFIG_SD_DIRECT_DMA) || defined(CONFIG_HIGHMEM)
+	unsigned long vpa = (unsigned long)pvaddr & PAGE_MASK;
+	if (vpa >= KSEG2)
+		return (pte_val(*(pte_t *)pte_offset(pmd_offset(pud_offset(pgd_offset_k(vpa), vpa), vpa), vpa)) & PAGE_MASK) + ((unsigned long)pvaddr & ~PAGE_MASK);
+	else if (vpa >= KSEG0)
+		return virt_to_phys(pvaddr);
+ 	else
+		return (pte_val(*(pte_t *)pte_offset(pmd_offset(pud_offset(pgd_offset_gate(current->mm, vpa), vpa), vpa), vpa)) & PAGE_MASK) + ((unsigned long)pvaddr & ~PAGE_MASK);
+#else
+	return virt_to_phys(pvaddr);
+#endif
+}
+EXPORT_SYMBOL(tangox_virt_to_phys);
+
diff -Naur linux-3.9.2.ref/arch/mips/tangox/setup.c linux-3.9.2/arch/mips/tangox/setup.c
--- linux-3.9.2.ref/arch/mips/tangox/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/tangox/setup.c	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,520 @@
+/*
+ * Copyright 2001 MontaVista Software Inc.
+ * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
+ *
+ * Copyright (C) 2009 Sigma Designs, Inc.
+ * arch/mips/tangox/setup.c
+ *     The setup file for tango2/tango3
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <linux/serial_8250.h>
+#include <linux/ioport.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <asm/reboot.h>
+#include <asm/io.h>
+#include <asm/cacheflush.h>
+#include <asm/time.h>
+#include <asm/serial.h>
+
+#include "setup.h"
+
+#if defined(CONFIG_TANGO2) && defined(CONFIG_TANGOX_USE_TLB_REMAP_DRAM1)
+extern unsigned long em86xx_tlb_dram1_map_base;
+extern unsigned long em86xx_tlb_dram1_map_size;
+#endif
+
+/*
+ * helpers to access cpu block registers
+ */
+#define RD_CPU_REG32(r)	\
+		gbus_read_reg32(REG_BASE_cpu_block + (r))
+
+#define WR_CPU_REG32(r, v)	\
+		gbus_write_reg32(REG_BASE_cpu_block + (r), (v))
+
+#ifdef CONFIG_PCI
+extern void tangox_pci_shutdown(void);
+#endif
+
+#ifdef CONFIG_TANGO2
+/*
+ * we use xrpc to reboot
+*/
+struct xrpc_block_header {
+	u32 callerid;
+	u32 xrpcid;
+
+	u32 param0;
+	u32 param1;
+	u32 param2;
+	u32 param3;
+	u32 param4;
+
+	u32 headerandblocksize;
+};
+
+#define XRPC_ID_REBOOT		19
+#define SOFT_IRQ_XRPC		(1 << 4)
+#endif
+
+void tangox_machine_restart(char *command)
+{
+	int i;
+#ifdef CONFIG_TANGO2
+	unsigned long tmp;
+ 	struct xrpc_block_header *pB;
+	unsigned long base_addr;
+	int loop;
+#endif
+
+        local_irq_disable();
+
+#ifdef CONFIG_PCI
+	tangox_pci_shutdown();
+#endif
+
+#if defined(CONFIG_TANGO2) 
+	/* Resetting TangoX EHCI */
+	tmp = gbus_read_reg32(REG_BASE_host_interface + 0x1410);
+	tmp &= ~1;
+	gbus_write_reg32(REG_BASE_host_interface + 0x1410, tmp);
+	mdelay(5);
+
+	/* Resetting TangoX OHCI */
+	gbus_write_reg32(REG_BASE_host_interface + 0x1514, 1<<31);
+	gbus_write_reg32(REG_BASE_host_interface + 0x1504, 0);
+	mdelay(5);
+
+	/* Resetting internal USB PHY in USB Control space */
+	tmp = gbus_read_reg32(REG_BASE_host_interface + 0x1700);
+	gbus_write_reg32(REG_BASE_host_interface + 0x1700, tmp | 1);
+	udelay(30);
+	gbus_write_reg32(REG_BASE_host_interface + 0x1700, tmp);
+	mdelay(5);
+
+	/* Resetting internal OHCI in USB OHCI space*/
+	tmp = gbus_read_reg32(REG_BASE_host_interface + 0x1508);
+	gbus_write_reg32(REG_BASE_host_interface + 0x1508, tmp | 0x01);
+
+	/* Reseting OHCI dpll, it says the bit is for simulation */
+	tmp = gbus_read_reg32(REG_BASE_host_interface + 0x1700);
+	gbus_write_reg32(REG_BASE_host_interface + 0x1700, tmp | (1<<19));
+	mdelay(1);
+
+	/* Resetting ethernet interface */
+	gbus_write_reg32(REG_BASE_host_interface + 0x7018, 0);
+	gbus_write_reg32(REG_BASE_host_interface + 0x701c, 0);
+	gbus_write_reg32(REG_BASE_host_interface + 0x7000, 1);
+	for (i = 0; (i < 10) && (gbus_read_reg32(REG_BASE_host_interface + 0x7000) & 1); i++)
+		mdelay(1);
+
+	/* Resetting Video, MPEG0/MPEG1 blocks */ 
+	gbus_write_reg32(REG_BASE_display_block + G2L_RESET_CONTROL, 3);
+	gbus_write_reg32(REG_BASE_mpeg_engine_0 + G2L_RESET_CONTROL, 3);
+	gbus_write_reg32(REG_BASE_mpeg_engine_1 + G2L_RESET_CONTROL, 3);
+	udelay(1);
+	gbus_write_reg32(REG_BASE_display_block + G2L_RESET_CONTROL, 2);
+	gbus_write_reg32(REG_BASE_mpeg_engine_0 + G2L_RESET_CONTROL, 2);
+	gbus_write_reg32(REG_BASE_mpeg_engine_1 + G2L_RESET_CONTROL, 2);
+
+	/* Resetting Transport demux block */
+	gbus_write_reg32(REG_BASE_demux_engine + G2L_RESET_CONTROL, 3);
+	udelay(1);
+	gbus_write_reg32(REG_BASE_demux_engine + G2L_RESET_CONTROL, 2);
+
+	/* Resetting Audio0/1, host interface blocks */
+	gbus_write_reg32(REG_BASE_audio_engine_0 + G2L_RESET_CONTROL, 3);
+	gbus_write_reg32(REG_BASE_audio_engine_1 + G2L_RESET_CONTROL, 3);
+	gbus_write_reg32(REG_BASE_host_interface + G2L_RESET_CONTROL, 3);
+	udelay(1);
+	gbus_write_reg32(REG_BASE_audio_engine_0 + G2L_RESET_CONTROL, 2);
+	gbus_write_reg32(REG_BASE_audio_engine_1 + G2L_RESET_CONTROL, 2);
+	gbus_write_reg32(REG_BASE_host_interface + G2L_RESET_CONTROL, 2);
+#endif
+
+	/* restore remap registers to boot state */
+	for (i = 0; 
+#ifdef CONFIG_TANGO2
+		i < 5; 
+#elif defined(CONFIG_TANGO3)
+		i < 8; 
+#endif
+		i++) {
+		gbus_write_reg32(REG_BASE_cpu_block + CPU_remap + i * 4, em8xxx_remap_registers[i]);
+	}
+	iob();
+
+	/* Now to handle CPU side */
+
+#if defined(CONFIG_TANGO3)
+#ifndef CONFIG_TANGOX_FIXED_FREQUENCIES
+	/* Using watchdog to trigger reset here */
+	gbus_write_reg8(REG_BASE_system_block + SYS_watchdog_configuration + 3, 0x80); 
+	gbus_write_reg8(REG_BASE_system_block + SYS_watchdog_configuration, 0x1); /* Use XTAL_IN as source */
+
+	/* For ~100 usec delay */
+	gbus_write_reg32(REG_BASE_system_block + SYS_watchdog_counter, TANGOX_BASE_FREQUENCY / 10000);
+	gbus_write_reg8(REG_BASE_system_block + SYS_watchdog_configuration + 3, 0); /* Start counting */
+#else
+	/* Don't use watchdog to reboot */
+	printk("System rebooting ...\n");
+#endif
+#else
+	/* nowhere to  jump, everything is  in xload format,  lets ask
+	 * xpu to reboot */
+	base_addr = DMEM_BASE_audio_engine_0;
+
+	pB = (struct xrpc_block_header *)base_addr;
+	gbus_write_reg32((unsigned long)&pB->callerid, 0);
+	gbus_write_reg32((unsigned long)&pB->headerandblocksize,
+		    (sizeof(struct xrpc_block_header) + 63) & ~63);
+	gbus_write_reg32((unsigned long)&pB->xrpcid, XRPC_ID_REBOOT);
+
+	/* try to lock xrpc mutex for at most 1 sec */
+	for (loop = 0; loop < 1000; loop++) {
+		if (!gbus_read_reg32((RMuint32)XRPC_MUTEX))
+			break;
+		mdelay(1);
+	}
+	gbus_write_reg32(REG_BASE_cpu_block + LR_XPU_STAGE, (unsigned long)pB);
+
+	/* cross our fingers now */
+	gbus_write_reg32(REG_BASE_irq_handler_block + CPU_irq_softset,
+		    SOFT_IRQ_XRPC);
+#endif
+	while (1); /* wait forever */
+}
+
+void tangox_machine_halt(void)
+{
+	while (1); /* wait forever */
+}
+
+void tangox_machine_power_off(void)
+{
+	while (1);
+}
+
+union tangox_cycle_cnt_union {
+	u64 cycle64;
+	u32 cycle32[2];
+};
+static DEFINE_SPINLOCK(cycle_cnt_lock);
+static union tangox_cycle_cnt_union tangox_cycle_cnt;
+static u32 tangox_cycle_last = 0;
+
+static cycle_t tangox_read_cycles(struct clocksource *cs)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&cycle_cnt_lock, flags);
+	tangox_cycle_cnt.cycle32[0] = (u32)gbus_read_reg32(REG_BASE_system_block + SYS_xtal_in_cnt);
+	if (tangox_cycle_last > tangox_cycle_cnt.cycle32[0])	
+		tangox_cycle_cnt.cycle32[1]++; /* low 32 overflowed, increase high 32 */
+
+	tangox_cycle_last = tangox_cycle_cnt.cycle32[0];
+	spin_unlock_irqrestore(&cycle_cnt_lock, flags);
+	return (cycle_t)tangox_cycle_cnt.cycle64;
+}
+
+void tangox_set_cycles(unsigned long cnt_low, unsigned long cnt_high, unsigned long cnt_last)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&cycle_cnt_lock, flags);
+	tangox_cycle_cnt.cycle32[0] = cnt_low;
+	tangox_cycle_cnt.cycle32[1] = cnt_high;
+	tangox_cycle_last = cnt_last;
+	spin_unlock_irqrestore(&cycle_cnt_lock, flags);
+}
+EXPORT_SYMBOL(tangox_set_cycles);
+
+void tangox_get_cycles(unsigned long *cnt_low, unsigned long *cnt_high, unsigned long *cnt_last)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&cycle_cnt_lock, flags);
+	*cnt_low = tangox_cycle_cnt.cycle32[0];
+	*cnt_high = tangox_cycle_cnt.cycle32[1];
+	*cnt_last = tangox_cycle_last;
+	spin_unlock_irqrestore(&cycle_cnt_lock, flags);
+}
+EXPORT_SYMBOL(tangox_get_cycles);
+
+struct clocksource clocksource_tangox = {
+	.name		= "TANGOX",
+	.mask		= CLOCKSOURCE_MASK(64),
+	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
+	.read		= tangox_read_cycles,
+};
+
+void __init plat_time_init(void)
+{
+	u64 temp;
+	u32 shift;
+
+	mips_hpt_frequency = em8xxx_cpu_frequency / 2;
+	/* Clear heart beat counter */
+	WR_CPU_REG32(LR_HB_CPU, 0);
+
+	/* Setup clock source from SYS_xtal_in_cnt */
+	clocksource_tangox.rating = em8xxx_cpu_frequency / 1000000;
+	tangox_cycle_cnt.cycle32[0] = tangox_cycle_last = (u32)gbus_read_reg32(REG_BASE_system_block + SYS_xtal_in_cnt);
+	tangox_cycle_cnt.cycle32[1] = 0;
+
+	/* Find a shift value */
+	for (shift = 32; shift > 0; shift--) {
+		temp = (u64) NSEC_PER_SEC << shift;
+		do_div(temp, TANGOX_BASE_FREQUENCY);
+		if ((temp >> 32) == 0)
+			break;
+	}
+	clocksource_tangox.shift = shift;
+	clocksource_tangox.mult = (u32)temp;
+
+	clocksource_register(&clocksource_tangox);
+}
+
+/*
+ * setup remap registers, we may need  to use ioremap() so we can't do
+ * this in plat_setup, this function is set as arch_initcall().
+ */
+static int __init tangox_remap_setup(void)
+{
+#if defined(CONFIG_TANGO2) && defined(CONFIG_TANGOX_USE_TLB_REMAP_DRAM1)
+	memcfg_t *m;
+#endif
+
+#if defined(CONFIG_TANGO2) 
+	/*
+	 * Program CPU_remap so we can see full 256MB space in KSEG0 /
+	 * KSEG1
+	 */
+#ifdef CONFIG_TANGOX_USE_TLB_REMAP_DRAM1
+	/*
+	 * Use TLB mapping to map the DRAM1 (size specified by memcfg)
+	 * into KSEG2
+	 */
+	m = (memcfg_t *)KSEG1ADDR(MEM_BASE_dram_controller_0 + FM_MEMCFG);
+
+	if (m->dram1_size) {
+		em86xx_tlb_dram1_map_size = ((m->dram1_size > 0x20000000) ? 
+			0x20000000 : m->dram1_size); /* Max. 512MB */
+		em86xx_tlb_dram1_map_base =
+			(unsigned long)ioremap(MEM_BASE_dram_controller_1,
+					       m->dram1_size);
+		printk("tangox: creating TLB mapping for 0x%08x at 0x%08lx, "
+		       "size 0x%08lx.\n", MEM_BASE_dram_controller_1,
+		       em86xx_tlb_dram1_map_base, em86xx_tlb_dram1_map_size);
+	} else {
+		printk("tangox: dram1 size is 0, _not_ creating mapping\n");
+	}
+#else
+	/*
+	 * Use remap strategy (CPU_remap3/4 for 128MB resolution)
+	 */
+	printk("tangox: creating CPU mapping for 0x%08x at 0x%08x, "
+	       "size 0x%08x.\n", MEM_BASE_dram_controller_1,
+	       CPU_remap3_address, 0x08000000);
+
+	/*
+	 * remap dram controller 1 at 0x08000000 -> 0x0fffffff (128MB)
+	 * so Linux can see it in KSEG[01]
+	 */
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_remap3,
+		    MEM_BASE_dram_controller_1);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_remap4,
+		    MEM_BASE_dram_controller_1 + 0x04000000);
+	iob();
+#endif
+#endif
+
+	return 0;
+}
+
+arch_initcall(tangox_remap_setup);
+
+extern int tangox_uart_enabled(int uart);
+extern int tangox_uart_baudrate(int uart);
+extern int tangox_uart_console_port(void);
+
+#ifdef CONFIG_SERIAL_8250
+struct tangox_uart_info {
+	int irq;
+	unsigned long base;
+};
+
+#if defined(CONFIG_TANGO3)
+static struct tangox_uart_info __initdata uinfo[3] = {
+	{ LOG2_CPU_UART0_INT, REG_BASE_cpu_block + CPU_UART0_base },
+	{ LOG2_CPU_UART1_INT, REG_BASE_cpu_block + CPU_UART1_base },
+	{ LOG2_CPU_UART2_INT, REG_BASE_cpu_block + CPU_UART2_base }, 
+};
+unsigned int tangox_uart_base[3] = {
+	REG_BASE_cpu_block + CPU_UART0_base, REG_BASE_cpu_block + CPU_UART1_base, REG_BASE_cpu_block + CPU_UART2_base,
+};
+#else
+static struct tangox_uart_info __initdata uinfo[2] = {
+	{ LOG2_CPU_UART0_INT, REG_BASE_cpu_block + CPU_UART0_base },
+	{ LOG2_CPU_UART1_INT, REG_BASE_cpu_block + CPU_UART1_base },
+};
+unsigned int tangox_uart_base[2] = {
+	REG_BASE_cpu_block + CPU_UART0_base, REG_BASE_cpu_block + CPU_UART1_base,
+};
+#endif
+#endif
+
+void uart_init(int uart_idx, int baud, int fifo);
+
+void __init plat_mem_setup(void)
+{
+#ifdef CONFIG_SERIAL_8250
+	int i, idx;
+	struct uart_port uart;
+	int console_port = tangox_uart_console_port();
+	int uinfo_size = sizeof(uinfo) / sizeof(uinfo[0]);
+#if defined(CONFIG_TANGO3)
+	unsigned long tangox_chip_id(void);
+	unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+#endif
+#endif
+
+	_machine_restart = tangox_machine_restart;
+	_machine_halt = tangox_machine_halt;
+	//_machine_power_off = tangox_machine_power_off;
+	pm_power_off = tangox_machine_power_off;
+
+#ifdef CONFIG_TANGO3
+	if ((chip_id == 0x8656) || (chip_id == 0x8672) || (chip_id == 0x8674))
+		tangox_uart_base[0] = REG_BASE_system_block + 0x700;
+#endif
+
+#ifdef CONFIG_SERIAL_8250
+	/* Handle console first */
+	uart_init(console_port, tangox_uart_baudrate(console_port), 1);
+	memset(&uart, 0, sizeof (uart));
+	uart.line = 0;
+#ifdef CONFIG_TANGOX_UART_USE_SYSCLK
+	uart.uartclk = tangox_get_sysclock();
+#else
+#if defined(CONFIG_TANGO2)
+	uart.uartclk = TANGOX_BASE_FREQUENCY;
+#elif defined(CONFIG_TANGO3)
+	uart.uartclk = TANGO3_UART_FREQUENCY;
+#else
+#error Unsupported platform.
+#endif
+#endif
+	uart.irq = IRQ_CONTROLLER_IRQ_BASE + uinfo[console_port].irq;
+	uart.flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST;
+#ifdef CONFIG_TANGO3
+	if (((chip_id == 0x8656) || (chip_id == 0x8672) || (chip_id == 0x8674)) && (console_port == 0))
+		uart.membase = (unsigned char *)(REG_BASE_system_block + 0x700);
+	else
+#endif
+		uart.membase = (unsigned char *)uinfo[console_port].base;
+	uart.iotype = UPIO_MEM;
+	uart.regshift = 2;
+
+	if (early_serial_setup(&uart))
+		printk("early_serial_setup failed\n");
+
+#ifdef CONFIG_TANGO3
+	if ((chip_id != 0x8652) && ((chip_id & 0xfff0) != 0x8670) && ((chip_id & 0xfff0) != 0x8680))
+		uinfo_size--;
+#endif
+
+	for (i = 0, idx = 1; (i < CONFIG_SERIAL_8250_NR_UARTS) && (i < uinfo_size); i++) {
+		if (console_port == i)
+			continue;
+
+		uart_init(i, tangox_uart_baudrate(i), 1);
+		memset(&uart, 0, sizeof (uart));
+		uart.line = idx++;
+#ifdef CONFIG_TANGOX_UART_USE_SYSCLK
+		uart.uartclk = tangox_get_sysclock();
+#else
+#if defined(CONFIG_TANGO2)
+		uart.uartclk = TANGOX_BASE_FREQUENCY;
+#elif defined(CONFIG_TANGO3)
+		uart.uartclk = TANGO3_UART_FREQUENCY;
+#else
+#error Unsupported platform.
+#endif
+#endif
+		uart.irq = IRQ_CONTROLLER_IRQ_BASE + uinfo[i].irq;
+		uart.flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST /* | UPF_SHARE_IRQ */;
+#ifdef CONFIG_TANGO3
+		if (((chip_id == 0x8656) || (chip_id == 0x8672) || (chip_id == 0x8674)) && (i == 0))
+			uart.membase = (unsigned char *)(REG_BASE_system_block + 0x700);
+		else
+#endif
+			uart.membase = (unsigned char *)uinfo[i].base;
+		uart.iotype = UPIO_MEM;
+		uart.regshift = 2;
+
+		if (early_serial_setup(&uart))
+			printk("early_serial_setup failed\n");
+	}
+#endif
+
+	/*
+	 * set I/O /mem regions limit
+	 */
+	ioport_resource.start = 0;
+	ioport_resource.end = 0x80000000UL - 1;
+	iomem_resource.start = 0;
+	iomem_resource.end = 0x80000000UL - 1;
+}
+
+struct tangox_mutex_struct
+{
+	struct mutex mutex;
+	unsigned int lock_cnt;
+};
+
+static struct tangox_mutex_struct tangox_mutex[NUM_TANGOX_MUTEX];
+
+static int __init tangox_mutex_init(void)
+{
+	int i;
+	for (i = 0; i < NUM_TANGOX_MUTEX; i++) {
+		mutex_init(&tangox_mutex[i].mutex);
+		tangox_mutex[i].lock_cnt = 0;
+	}
+	return 0;
+}
+
+int tangox_mutex_lock(unsigned int idx)
+{
+	if (in_interrupt() || in_atomic())
+		return -1; /* not safe for context switching */
+	else if (unlikely(idx >= NUM_TANGOX_MUTEX))
+		return -1;
+
+	mutex_lock(&tangox_mutex[idx].mutex);
+	tangox_mutex[idx].lock_cnt++;
+	return 0;
+}
+
+int tangox_mutex_unlock(unsigned int idx)
+{
+	if ((idx < NUM_TANGOX_MUTEX) && (tangox_mutex[idx].lock_cnt > 0)) {
+		tangox_mutex[idx].lock_cnt--;
+		mutex_unlock(&tangox_mutex[idx].mutex);
+	}
+	return 0;
+}
+
+__initcall(tangox_mutex_init);
+EXPORT_SYMBOL(tangox_mutex_lock);
+EXPORT_SYMBOL(tangox_mutex_unlock);
+
diff -Naur linux-3.9.2.ref/arch/mips/tangox/setup.h linux-3.9.2/arch/mips/tangox/setup.h
--- linux-3.9.2.ref/arch/mips/tangox/setup.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/tangox/setup.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,61 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2008
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+/*
+ * misc vars/func shared by platform setup code
+ */
+
+#ifndef __SETUP_H
+#define __SETUP_H
+
+#ifdef CONFIG_TANGO2
+#define EM86XX_CHIP EM86XX_CHIPID_TANGO2
+#include <linux/interrupt.h>
+#include <asm/tango2/rmem86xxid.h>
+#include <asm/tango2/rmdefs.h>
+#include <asm/tango2/emhwlib_dram.h>
+#include <asm/tango2/tango2_gbus.h>
+#include <asm/tango2/tango2.h>
+#include <asm/tango2/tango2api.h>
+#include <asm/tango2/memcfg.h>
+#elif defined(CONFIG_TANGO3)
+#define EM86XX_CHIP EM86XX_CHIPID_TANGO3
+#include <linux/interrupt.h>
+#include <asm/tango3/rmem86xxid.h>
+#include <asm/tango3/rmdefs.h>
+#include <asm/tango3/emhwlib_dram.h>
+#include <asm/tango3/tango3_gbus.h>
+#include <asm/tango3/tango3.h>
+#include <asm/tango3/tango3api.h>
+#include <asm/tango3/hardware.h>
+#else
+#error "Unknown architecture"
+#endif
+
+/*
+ * in console.c
+ */
+void prom_console_register(void);
+
+/*
+ * in prom.c
+ */
+extern unsigned long em8xxx_cpu_frequency;
+extern unsigned long em8xxx_sys_frequency;
+#ifdef CONFIG_TANGO2
+extern unsigned long em8xxx_remap_registers[5];
+#elif defined(CONFIG_TANGO3)
+extern unsigned long em8xxx_remap_registers[9];
+#endif
+
+unsigned long tangox_get_cpuclock(void);
+unsigned long tangox_get_sysclock(void);
+
+#endif
diff -Naur linux-3.9.2.ref/arch/mips/tangox/sha.c linux-3.9.2/arch/mips/tangox/sha.c
--- linux-3.9.2.ref/arch/mips/tangox/sha.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/tangox/sha.c	2013-07-23 19:31:22.000000000 +0200
@@ -0,0 +1,406 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2008
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/mm.h>
+#include <linux/crypto.h>
+#include <linux/cryptohash.h>
+#include <linux/version.h>
+#include <asm/scatterlist.h>
+#include <asm/byteorder.h>
+
+#include "sha.h"
+	
+#ifdef CONFIG_CRYPTO_SHA1
+#define SHA1_HMAC_BLOCK_SIZE	64
+#define SHA_WORKSPACE_WORDS_ 	80
+
+static void __sha1_init(struct sha1_ctx *sctx)
+{
+	static const struct sha1_ctx initstate = {
+	  0,
+	  { 0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0 },
+	  { 0, }
+	};
+	*sctx = initstate;
+}
+
+static void __sha1_update(struct sha1_ctx *sctx, const u8 *data, unsigned int len)
+{
+	unsigned int partial, done;
+	const u8 *src;
+
+	partial = sctx->count & 0x3f;
+	sctx->count += len;
+	done = 0;
+	src = data;
+
+	if ((partial + len) > 63) {
+		u32 temp[SHA_WORKSPACE_WORDS_];
+
+		if (partial) {
+			done = -partial;
+			memcpy(sctx->buffer + partial, data, done + 64);
+			src = sctx->buffer;
+		}
+
+		do {
+			sha_transform(sctx->state, src, temp);
+			done += 64;
+			src = data + done;
+		} while (done + 63 < len);
+
+		memset(temp, 0, sizeof(temp));
+		partial = 0;
+	}
+	memcpy(sctx->buffer + partial, src, len - done);
+}
+
+/* Add padding and return the message digest. */
+static void __sha1_final(struct sha1_ctx *sctx, u8 *out)
+{
+	__be32 *dst = (__be32 *)out;
+	u32 i, index, padlen;
+	__be64 bits;
+	static const u8 padding[64] = { 0x80, };
+
+	bits = cpu_to_be64(sctx->count << 3);
+
+	/* Pad out to 56 mod 64 */
+	index = sctx->count & 0x3f;
+	padlen = (index < 56) ? (56 - index) : ((64+56) - index);
+	__sha1_update(sctx, padding, padlen);
+
+	/* Append length */
+	__sha1_update(sctx, (const u8 *)&bits, sizeof(bits));
+
+	/* Store state in digest */
+	for (i = 0; i < 5; i++)
+		dst[i] = cpu_to_be32(sctx->state[i]);
+
+	/* Wipe context */
+	memset(sctx, 0, sizeof *sctx);
+}
+#endif /* CONFIG_CRYPTO_SHA1 */
+
+#ifdef CONFIG_CRYPTO_SHA1
+void sha1_full(u8 *digest, const u8 *src, u32 len)
+{
+	int i;
+	u8 tmp;
+
+	struct sha1_ctx ctx;
+
+	__sha1_init(&ctx);
+	__sha1_update(&ctx, src, len);
+	__sha1_final(&ctx, digest);
+
+	for (i = 0; i < SHA1_DIGEST_SIZE / 2; i++) {
+		tmp = digest[i];
+		digest[i] = digest[SHA1_DIGEST_SIZE - i - 1];
+		digest[SHA1_DIGEST_SIZE - i - 1] = tmp;
+	}
+}
+#endif
+
+#ifdef CONFIG_CRYPTO_SHA256
+
+#define SHA256_DIGEST_SIZE	32
+#define SHA256_HMAC_BLOCK_SIZE	64
+
+static inline u32 Ch(u32 x, u32 y, u32 z)
+{
+	return z ^ (x & (y ^ z));
+}
+
+static inline u32 Maj(u32 x, u32 y, u32 z)
+{
+	return (x & y) | (z & (x | y));
+}
+
+#define e0(x)       (ror32(x, 2) ^ ror32(x,13) ^ ror32(x,22))
+#define e1(x)       (ror32(x, 6) ^ ror32(x,11) ^ ror32(x,25))
+#define s0(x)       (ror32(x, 7) ^ ror32(x,18) ^ (x >> 3))
+#define s1(x)       (ror32(x,17) ^ ror32(x,19) ^ (x >> 10))
+
+#define H0         0x6a09e667
+#define H1         0xbb67ae85
+#define H2         0x3c6ef372
+#define H3         0xa54ff53a
+#define H4         0x510e527f
+#define H5         0x9b05688c
+#define H6         0x1f83d9ab
+#define H7         0x5be0cd19
+
+static inline void LOAD_OP(int I, u32 *W, const u8 *input)
+{
+	W[I] = __be32_to_cpu( ((__be32*)(input))[I] );
+}
+
+static inline void BLEND_OP(int I, u32 *W)
+{
+	W[I] = s1(W[I-2]) + W[I-7] + s0(W[I-15]) + W[I-16];
+}
+
+static void __sha256_transform(u32 *state, const u8 *input)
+{
+	u32 a, b, c, d, e, f, g, h, t1, t2;
+	u32 W[64];
+	int i;
+
+	/* load the input */
+	for (i = 0; i < 16; i++)
+		LOAD_OP(i, W, input);
+
+	/* now blend */
+	for (i = 16; i < 64; i++)
+		BLEND_OP(i, W);
+    
+	/* load the state into our registers */
+	a=state[0];  b=state[1];  c=state[2];  d=state[3];
+	e=state[4];  f=state[5];  g=state[6];  h=state[7];
+
+	/* now iterate */
+	t1 = h + e1(e) + Ch(e,f,g) + 0x428a2f98 + W[ 0];
+	t2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;
+	t1 = g + e1(d) + Ch(d,e,f) + 0x71374491 + W[ 1];
+	t2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;
+	t1 = f + e1(c) + Ch(c,d,e) + 0xb5c0fbcf + W[ 2];
+	t2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;
+	t1 = e + e1(b) + Ch(b,c,d) + 0xe9b5dba5 + W[ 3];
+	t2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;
+	t1 = d + e1(a) + Ch(a,b,c) + 0x3956c25b + W[ 4];
+	t2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;
+	t1 = c + e1(h) + Ch(h,a,b) + 0x59f111f1 + W[ 5];
+	t2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;
+	t1 = b + e1(g) + Ch(g,h,a) + 0x923f82a4 + W[ 6];
+	t2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;
+	t1 = a + e1(f) + Ch(f,g,h) + 0xab1c5ed5 + W[ 7];
+	t2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;
+
+	t1 = h + e1(e) + Ch(e,f,g) + 0xd807aa98 + W[ 8];
+	t2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;
+	t1 = g + e1(d) + Ch(d,e,f) + 0x12835b01 + W[ 9];
+	t2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;
+	t1 = f + e1(c) + Ch(c,d,e) + 0x243185be + W[10];
+	t2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;
+	t1 = e + e1(b) + Ch(b,c,d) + 0x550c7dc3 + W[11];
+	t2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;
+	t1 = d + e1(a) + Ch(a,b,c) + 0x72be5d74 + W[12];
+	t2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;
+	t1 = c + e1(h) + Ch(h,a,b) + 0x80deb1fe + W[13];
+	t2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;
+	t1 = b + e1(g) + Ch(g,h,a) + 0x9bdc06a7 + W[14];
+	t2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;
+	t1 = a + e1(f) + Ch(f,g,h) + 0xc19bf174 + W[15];
+	t2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;
+
+	t1 = h + e1(e) + Ch(e,f,g) + 0xe49b69c1 + W[16];
+	t2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;
+	t1 = g + e1(d) + Ch(d,e,f) + 0xefbe4786 + W[17];
+	t2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;
+	t1 = f + e1(c) + Ch(c,d,e) + 0x0fc19dc6 + W[18];
+	t2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;
+	t1 = e + e1(b) + Ch(b,c,d) + 0x240ca1cc + W[19];
+	t2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;
+	t1 = d + e1(a) + Ch(a,b,c) + 0x2de92c6f + W[20];
+	t2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;
+	t1 = c + e1(h) + Ch(h,a,b) + 0x4a7484aa + W[21];
+	t2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;
+	t1 = b + e1(g) + Ch(g,h,a) + 0x5cb0a9dc + W[22];
+	t2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;
+	t1 = a + e1(f) + Ch(f,g,h) + 0x76f988da + W[23];
+	t2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;
+
+	t1 = h + e1(e) + Ch(e,f,g) + 0x983e5152 + W[24];
+	t2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;
+	t1 = g + e1(d) + Ch(d,e,f) + 0xa831c66d + W[25];
+	t2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;
+	t1 = f + e1(c) + Ch(c,d,e) + 0xb00327c8 + W[26];
+	t2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;
+	t1 = e + e1(b) + Ch(b,c,d) + 0xbf597fc7 + W[27];
+	t2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;
+	t1 = d + e1(a) + Ch(a,b,c) + 0xc6e00bf3 + W[28];
+	t2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;
+	t1 = c + e1(h) + Ch(h,a,b) + 0xd5a79147 + W[29];
+	t2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;
+	t1 = b + e1(g) + Ch(g,h,a) + 0x06ca6351 + W[30];
+	t2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;
+	t1 = a + e1(f) + Ch(f,g,h) + 0x14292967 + W[31];
+	t2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;
+
+	t1 = h + e1(e) + Ch(e,f,g) + 0x27b70a85 + W[32];
+	t2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;
+	t1 = g + e1(d) + Ch(d,e,f) + 0x2e1b2138 + W[33];
+	t2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;
+	t1 = f + e1(c) + Ch(c,d,e) + 0x4d2c6dfc + W[34];
+	t2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;
+	t1 = e + e1(b) + Ch(b,c,d) + 0x53380d13 + W[35];
+	t2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;
+	t1 = d + e1(a) + Ch(a,b,c) + 0x650a7354 + W[36];
+	t2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;
+	t1 = c + e1(h) + Ch(h,a,b) + 0x766a0abb + W[37];
+	t2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;
+	t1 = b + e1(g) + Ch(g,h,a) + 0x81c2c92e + W[38];
+	t2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;
+	t1 = a + e1(f) + Ch(f,g,h) + 0x92722c85 + W[39];
+	t2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;
+
+	t1 = h + e1(e) + Ch(e,f,g) + 0xa2bfe8a1 + W[40];
+	t2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;
+	t1 = g + e1(d) + Ch(d,e,f) + 0xa81a664b + W[41];
+	t2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;
+	t1 = f + e1(c) + Ch(c,d,e) + 0xc24b8b70 + W[42];
+	t2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;
+	t1 = e + e1(b) + Ch(b,c,d) + 0xc76c51a3 + W[43];
+	t2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;
+	t1 = d + e1(a) + Ch(a,b,c) + 0xd192e819 + W[44];
+	t2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;
+	t1 = c + e1(h) + Ch(h,a,b) + 0xd6990624 + W[45];
+	t2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;
+	t1 = b + e1(g) + Ch(g,h,a) + 0xf40e3585 + W[46];
+	t2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;
+	t1 = a + e1(f) + Ch(f,g,h) + 0x106aa070 + W[47];
+	t2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;
+
+	t1 = h + e1(e) + Ch(e,f,g) + 0x19a4c116 + W[48];
+	t2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;
+	t1 = g + e1(d) + Ch(d,e,f) + 0x1e376c08 + W[49];
+	t2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;
+	t1 = f + e1(c) + Ch(c,d,e) + 0x2748774c + W[50];
+	t2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;
+	t1 = e + e1(b) + Ch(b,c,d) + 0x34b0bcb5 + W[51];
+	t2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;
+	t1 = d + e1(a) + Ch(a,b,c) + 0x391c0cb3 + W[52];
+	t2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;
+	t1 = c + e1(h) + Ch(h,a,b) + 0x4ed8aa4a + W[53];
+	t2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;
+	t1 = b + e1(g) + Ch(g,h,a) + 0x5b9cca4f + W[54];
+	t2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;
+	t1 = a + e1(f) + Ch(f,g,h) + 0x682e6ff3 + W[55];
+	t2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;
+
+	t1 = h + e1(e) + Ch(e,f,g) + 0x748f82ee + W[56];
+	t2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;
+	t1 = g + e1(d) + Ch(d,e,f) + 0x78a5636f + W[57];
+	t2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;
+	t1 = f + e1(c) + Ch(c,d,e) + 0x84c87814 + W[58];
+	t2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;
+	t1 = e + e1(b) + Ch(b,c,d) + 0x8cc70208 + W[59];
+	t2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;
+	t1 = d + e1(a) + Ch(a,b,c) + 0x90befffa + W[60];
+	t2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;
+	t1 = c + e1(h) + Ch(h,a,b) + 0xa4506ceb + W[61];
+	t2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;
+	t1 = b + e1(g) + Ch(g,h,a) + 0xbef9a3f7 + W[62];
+	t2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;
+	t1 = a + e1(f) + Ch(f,g,h) + 0xc67178f2 + W[63];
+	t2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;
+
+	state[0] += a; state[1] += b; state[2] += c; state[3] += d;
+	state[4] += e; state[5] += f; state[6] += g; state[7] += h;
+
+	/* clear any sensitive info... */
+	a = b = c = d = e = f = g = h = t1 = t2 = 0;
+	memset(W, 0, 64 * sizeof(u32));
+}
+
+static void __sha256_init(struct sha256_ctx *sctx)
+{
+	sctx->state[0] = H0;
+	sctx->state[1] = H1;
+	sctx->state[2] = H2;
+	sctx->state[3] = H3;
+	sctx->state[4] = H4;
+	sctx->state[5] = H5;
+	sctx->state[6] = H6;
+	sctx->state[7] = H7;
+	sctx->count[0] = sctx->count[1] = 0;
+}
+
+static void __sha256_update(struct sha256_ctx *sctx, const u8 *data, unsigned int len)
+{
+	unsigned int i, index, part_len;
+
+	/* Compute number of bytes mod 128 */
+	index = (unsigned int)((sctx->count[0] >> 3) & 0x3f);
+
+	/* Update number of bits */
+	if ((sctx->count[0] += (len << 3)) < (len << 3)) {
+		sctx->count[1]++;
+		sctx->count[1] += (len >> 29);
+	}
+
+	part_len = 64 - index;
+
+	/* Transform as many times as possible. */
+	if (len >= part_len) {
+		memcpy(&sctx->buf[index], data, part_len);
+		__sha256_transform(sctx->state, sctx->buf);
+
+		for (i = part_len; i + 63 < len; i += 64)
+			__sha256_transform(sctx->state, &data[i]);
+		index = 0;
+	} else {
+		i = 0;
+	}
+	
+	/* Buffer remaining input */
+	memcpy(&sctx->buf[index], &data[i], len-i);
+}
+
+static void __sha256_final(struct sha256_ctx *sctx, u8 *out)
+{
+	__be32 *dst = (__be32 *)out;
+	__be32 bits[2];
+	unsigned int index, pad_len;
+	int i;
+	static const u8 padding[64] = { 0x80, };
+
+	/* Save number of bits */
+	bits[1] = cpu_to_be32(sctx->count[0]);
+	bits[0] = cpu_to_be32(sctx->count[1]);
+
+	/* Pad out to 56 mod 64. */
+	index = (sctx->count[0] >> 3) & 0x3f;
+	pad_len = (index < 56) ? (56 - index) : ((64+56) - index);
+	__sha256_update(sctx, padding, pad_len);
+
+	/* Append length (before padding) */
+	__sha256_update(sctx, (const u8 *)bits, sizeof(bits));
+
+	/* Store state in digest */
+	for (i = 0; i < 8; i++)
+		dst[i] = cpu_to_be32(sctx->state[i]);
+
+	/* Zeroize sensitive information. */
+	memset(sctx, 0, sizeof(*sctx));
+}
+#endif
+
+#ifdef CONFIG_CRYPTO_SHA256
+void sha256_full(u8 *digest, const u8 *src, u32 len)
+{
+	int i;
+	u8 tmp;
+	struct sha256_ctx ctx;
+
+	__sha256_init(&ctx);
+	__sha256_update(&ctx, src, len);
+	__sha256_final(&ctx, digest);
+
+	for (i = 0; i < SHA256_DIGEST_SIZE / 2; i++) {
+		tmp = digest[i];
+		digest[i] = digest[SHA256_DIGEST_SIZE - i - 1];
+		digest[SHA256_DIGEST_SIZE - i - 1] = tmp;
+	}
+}
+#endif
diff -Naur linux-3.9.2.ref/arch/mips/tangox/sha.h linux-3.9.2/arch/mips/tangox/sha.h
--- linux-3.9.2.ref/arch/mips/tangox/sha.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/tangox/sha.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,35 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2008
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#ifndef __SHA_H__
+#define __SHA_H__
+
+#ifdef CONFIG_CRYPTO_SHA1
+#define SHA1_DIGEST_SIZE        20
+
+struct sha1_ctx {
+	u64 count;
+        u32 state[5];
+        u8 buffer[64];
+};
+#endif
+
+#ifdef CONFIG_CRYPTO_SHA256
+#define SHA256_DIGEST_SIZE      32
+
+struct sha256_ctx {
+	u32 count[2];
+        u32 state[8];
+        u8 buf[128];
+};
+#endif
+
+#endif
+
diff -Naur linux-3.9.2.ref/arch/mips/tangox/xenv.c linux-3.9.2/arch/mips/tangox/xenv.c
--- linux-3.9.2.ref/arch/mips/tangox/xenv.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/tangox/xenv.c	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,285 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2008
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#include "setup.h"
+#include "xenv.h"
+#include "sha.h"
+
+#include <linux/module.h>
+#if defined(CONFIG_TANGO3)
+#include <asm/tango3/rmdefs.h>
+#endif
+
+#if 1
+# define DPRINTK(fmt, args...)	printk(KERN_DEBUG "xenv: " fmt, ## args)
+#else
+# define DPRINTK(fmt, args...)
+#endif
+
+#if defined(CONFIG_TANGO2)
+#define XENV_DIGEST_SIZE   SHA1_DIGEST_SIZE
+void sha1_full(u8 *digest, const u8 *src, u32 len);
+#elif defined(CONFIG_TANGO3)
+#define XENV_DIGEST_SIZE   SHA256_DIGEST_SIZE
+void sha256_full(u8 *digest, const u8 *src, u32 len);
+#endif
+
+#define XENV_HDR_SIZE      (XENV_DIGEST_SIZE + 4)
+#define REC_SIZE(x)	   ((((u16)x[0] & 0xff) << 8) | ((u16)x[1] & 0xff))
+#define REC_ATTR(x)	   ((x[0] & 0xff) >> 4)
+
+#define xos_strlen(x)	   strlen(x)
+#define xos_strcmp(x,y)	   strcmp(x,y)
+#define xos_memcpy(x,y,z)  memcpy(x,y,z)
+
+void xenv_digest_full(u8 *digest, const u8 *src, u32 len)
+{
+#if defined(CONFIG_TANGO2)
+	sha1_full(digest, src, len);
+#elif defined(CONFIG_TANGO3)
+	sha256_full(digest, src, len);
+#endif
+}
+
+#if 0
+static void dump_digest(const u8 *digest)
+{
+	int i;
+	printk("Dump digest\n");
+	for (i = 0; i < XENV_DIGEST_SIZE; i++, digest++)
+		printk("%02x ", *digest);
+	printk("\n");
+}
+#endif
+
+/*
+ * check for valid XENV at given address
+ */
+int xenv_isvalid(u32 *base, u32 maxsize)
+{
+	u32 env_size = base[0];
+	u32 hash[XENV_DIGEST_SIZE/4];
+
+	if ((XENV_HDR_SIZE <= env_size) && (env_size <= maxsize)) {
+		memset(hash, 0, sizeof (hash));
+		xenv_digest_full((u8 *)hash, (const u8 *)(base + (XENV_HDR_SIZE / 4)), env_size - XENV_HDR_SIZE);
+		if (memcmp((const u8 *)(base + 1), hash, XENV_DIGEST_SIZE) != 0) {
+			DPRINTK("corrupted\n");
+			return -1;
+		}
+		/* valid xenv ! */
+		return env_size;
+	}
+	DPRINTK("runaway %d\n", env_size);
+	return -1;
+}
+
+int xenv_foreach(u32 *xenv_base, u32 size,
+			void (*cb)(char *recordname, void *data, u32 datasize))
+{
+	int i;
+	char *base = (char *)xenv_base;
+
+	/* jump over first header */
+	i = XENV_HDR_SIZE;
+
+	/* loop on each record name */
+	while (i < size) {
+		u16 rec_size;
+		char *recordname;
+		void *data;
+		u32 key_len, data_len;
+
+		rec_size=((base[i]&0xf)<<8) + (((u16)base[i+1])&0xff);
+		recordname=(char *)(base+i+2);
+		key_len=strnlen(recordname, size);
+		data = recordname + key_len + 1;
+		data_len = rec_size - 2 - key_len - 1;
+
+		cb(recordname, data, data_len);
+		i += rec_size;
+	}
+
+	return -1;
+}
+
+#if defined(CONFIG_TANGO3)
+/* Use this to set xenv to lrrw */
+static int xenv_lookup(RMuint32 *base,RMuint32 size,RMascii *recordname)
+{
+	RMascii *p;
+	int i;
+	int env_size;
+	
+	env_size=xenv_isvalid((u32 *)base,size);
+	
+	if (env_size<0) 
+		return -2;
+	
+	// RMDBGLOG((LOCALDBG, "[%s]\n",recordname));
+	
+	p=(RMascii *)base;
+	i=XENV_HDR_SIZE; 			// jump over header
+	
+	while(i<env_size){
+		RMuint16 rec_size=((p[i]&0xf)<<8) + (((RMuint16)p[i+1])&0xff);
+
+		if (!xos_strcmp(recordname, p+i+2)) 
+			return i;
+		
+		i+=rec_size;
+	}
+	
+	return -1;
+}
+
+/* Use this to get xenv to lrrw/lrro */
+int xenv_get(u32 *base, u32 size, char *recordname, void *dst, u32 *datasize)
+{
+	RMascii *p = (RMascii *)base;
+	RMuint32 data_len;
+	RMuint32 key_len;
+	RMuint32 env_size;
+	
+	int i;	
+	
+	env_size=base[0];
+	i = xenv_lookup((RMuint32 *)base, size, recordname);
+	if(i==-2) 
+		return -2 /* RM_ERROR */;
+	if(i==-1) 
+		return -1 /* RM_NOT_FOUND */;
+
+	// else we found the record
+	key_len=xos_strlen(recordname);
+	data_len=((p[i] & 0xf)<<8) + (((RMuint32)p[i+1])&0xff);
+	data_len-=2+key_len+1;
+	
+	if(data_len>*datasize) {
+		*datasize=data_len;
+
+		// RMDBGLOG((ENABLE,"cannot store result\n"));
+		return -3 /* RM_INSUFFICIENT_SIZE */;
+	}
+	
+	*datasize=data_len;
+	xos_memcpy(dst, p+i+2+key_len+1, data_len);
+
+	// RMDBGLOG((LOCALDBG, "found [%s], length %d\n",recordname,*datasize));
+
+	return 0 /* RM_OK */;
+}
+
+int xenv_set(u32 *base, u32 size, char *recordname, void *src, u8 attr, u32 datasize)
+{
+	RMascii *p;
+	RMuint32 env_size;
+	RMuint32 rec_attr;
+	RMuint32 rec_size;
+	RMuint32 key_len;
+	int i;
+
+	// RMDBGLOG((LOCALDBG, "[%s], length %d\n", recordname,datasize));
+	
+	p=(RMascii *)base;
+	i = xenv_lookup((RMuint32 *)base, size, recordname);
+	if(i==-2) 
+		return -1 /* RM_ERROR */;
+	env_size=base[0];
+
+	if(i>=0) {
+		// RMDBGLOG((LOCALDBG, "deleting record\n"));
+		
+		rec_attr=p[i]>>4;
+		rec_size=((p[i]&0xf)<<8) + (((RMuint32)p[i+1])&0xff);
+			
+#if 0
+		if ((rec_attr==XENV_ATTR_RO)&&src) {
+			// RMDBGLOG((ENABLE,"wanna change ro record\n"));
+			return RM_INVALIDMODE;
+		}
+		
+		if (rec_attr==XENV_ATTR_OTP) {
+			// RMDBGLOG((ENABLE,"wanna change/clear otp record\n"));
+			return RM_INVALIDMODE;
+		}
+#endif
+
+		// delete the record. Supposes memcpy is implemented increasing.
+		xos_memcpy(p+i, p+i+rec_size, env_size-(i+rec_size));
+		env_size-=rec_size;
+	}
+		
+	// add the record at the end if needed.
+	if(src) {
+		i=env_size;
+		key_len=xos_strlen(recordname);
+		rec_size=2+key_len+1+datasize;
+
+		if((i+rec_size)>=size)
+			return -3 /* RM_INSUFFICIENT_SIZE */;
+		
+		p[i]=((attr&0xf)<<4) | ((rec_size>>8)&0xf);
+		p[i+1]=rec_size&0xff;
+		
+		xos_memcpy(p+i+2, recordname, key_len+1);
+		xos_memcpy(p+i+2+key_len+1, src, datasize);
+		
+		env_size+=rec_size;
+	}
+	
+	base[0]=env_size;
+	//full_sha256(base+1,(const RMuint8 *)(base+9),env_size-36,0);
+	xenv_digest_full((u8 *)(base+1), (const u8 *)(base + (XENV_HDR_SIZE / 4)), env_size - XENV_HDR_SIZE);
+
+	return 0 /* RM_OK */;
+}
+#endif
+
+#ifdef CONFIG_TANGOX_XENV_DUMP
+void xenv_dump(u32 *xenv_base, u32 size)
+{
+	int i;
+	u32 records = 0;
+	char *base = (char *)xenv_base;
+
+	printk("@%p\n", base);
+
+	/* jump over first header */
+	i = XENV_HDR_SIZE;
+
+	while (i < size){
+		u8 rec_attr;
+		u16 rec_size;
+		char *recordname, *x;
+		u32 key_len;
+
+		rec_attr=(base[i]>>4)&0xf;
+		rec_size=((base[i]&0xf)<<8) + (((u16)base[i+1])&0xff);
+		recordname=(char *)(base+i+2);
+		key_len=strnlen(recordname, size);
+
+		printk("(0x%02x) [%s] =", rec_attr, recordname);
+		for (x = recordname + key_len + 1;
+		     x < recordname + rec_size - 2; x++)
+			printk(" %02x", (u8)*x);
+		printk(" .\n");
+
+		records++;
+		i += rec_size;
+	}
+
+	printk("%d records, %d bytes\n\n", records, size);
+}
+#endif
+
+#if defined(CONFIG_TANGO3)
+EXPORT_SYMBOL(xenv_get);
+#endif
diff -Naur linux-3.9.2.ref/arch/mips/tangox/xenv_config.c linux-3.9.2/arch/mips/tangox/xenv_config.c
--- linux-3.9.2.ref/arch/mips/tangox/xenv_config.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/tangox/xenv_config.c	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,865 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2008
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+/*
+ * Check and  read full xenv config  at boot if valid,  else will stop
+ * boot process or use failsafe values.
+ */
+
+#include "setup.h"
+#include "xenv.h"
+#include "xenvkeys.h"
+
+#include <linux/module.h>
+#include <asm/bootinfo.h>
+
+/*
+ * use CPU_remap1 to access XENV content
+ */
+#define TMP_REMAPPED_REG   CPU_remap1
+#define TMP_REMAPPED_BASE  CPU_remap1_address 
+#define TMP_REMAPPED_SIZE  0x00010000
+#define TMP_REMAPPED_MASK  ~(TMP_REMAPPED_SIZE-1)
+
+/*
+ * cached values of xenv content
+ */
+#define XENV_MAX_FLASH_PARTITIONS   16
+
+typedef union
+{
+	u64 uint64[1];
+	u32 uint32[2];
+	u16 uint16[4];
+	u8 uint8[8];
+} uint_union;
+
+/*
+ * default is  to have one  partition on each  flash at offset  0 that
+ * span all the flash. If CONFIG_TANGOX_XENV_DEF_CSx_SIZE is set to 0,
+ * cs will be ignored.
+ */
+#ifdef CONFIG_TANGOX_XENV_READ_SAFE
+/* The data will be filled from XENV later */
+static uint_union cs_flash_size[4] = { { { 0 } }, { { 0 } }, { { 0 } }, { { 0 } }, };
+static uint_union flash_parts_size[4][XENV_MAX_FLASH_PARTITIONS] = { { { { 0 } } }, { { { 0 } } }, { { { 0 } } }, { { { 0 } } }, };
+static u32 enabled_devices = 0;
+static u32 uart_baudrate = 0;
+static u32 uart_baudrates[3] = { 0, 0, 0 };
+static u32 uart_used_ports = 0;
+static u32 pcidev_irq_route[4] = { 0, 0, 0, 0 };
+static u32 uart_console_port = 0;
+#else
+static uint_union cs_flash_size[4] = {
+	{ { CONFIG_TANGOX_XENV_DEF_CS0_SIZE } },
+	{ { CONFIG_TANGOX_XENV_DEF_CS1_SIZE } },
+	{ { CONFIG_TANGOX_XENV_DEF_CS2_SIZE } },
+	{ { CONFIG_TANGOX_XENV_DEF_CS3_SIZE } },
+};
+
+static uint_union flash_parts_size[4][XENV_MAX_FLASH_PARTITIONS] = {
+	{ { { CONFIG_TANGOX_XENV_DEF_CS0_SIZE } } },
+	{ { { CONFIG_TANGOX_XENV_DEF_CS1_SIZE } } },
+	{ { { CONFIG_TANGOX_XENV_DEF_CS2_SIZE } } },
+	{ { { CONFIG_TANGOX_XENV_DEF_CS3_SIZE } } },
+};
+
+static u32 enabled_devices =
+#ifdef CONFIG_TANGOX_XENV_DEF_PCI_ID1 
+	(CONFIG_TANGOX_XENV_DEF_PCI_ID1 << PCI1_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_PCI_ID2 
+	(CONFIG_TANGOX_XENV_DEF_PCI_ID2 << PCI2_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_PCI_ID3 
+	(CONFIG_TANGOX_XENV_DEF_PCI_ID3 << PCI3_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_PCI_ID4 
+	(CONFIG_TANGOX_XENV_DEF_PCI_ID4 << PCI4_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_ENET 
+	(CONFIG_TANGOX_XENV_DEF_ENET << ETHERNET_SHIFT) |
+#else
+	0 | 
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_FIP 
+	(CONFIG_TANGOX_XENV_DEF_FIP << FIP_SHIFT) |
+#else 
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_I2CM 
+	(CONFIG_TANGOX_XENV_DEF_I2CM << I2CM_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_I2CS 
+	(CONFIG_TANGOX_XENV_DEF_I2CS << I2CS_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_BMIDE 
+	(CONFIG_TANGOX_XENV_DEF_BMIDE << BMIDE_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_ISAIDE 
+	(CONFIG_TANGOX_XENV_DEF_ISAIDE << ISAIDE_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_IR 
+	(CONFIG_TANGOX_XENV_DEF_IR << IR_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_PCIHOST
+	(CONFIG_TANGOX_XENV_DEF_PCIHOST << PCIHOST_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_USB 
+	(CONFIG_TANGOX_XENV_DEF_USB << USB_SHIFT)
+#else
+	0
+#endif
+	;
+
+static u32 uart_baudrate = CONFIG_TANGOX_XENV_DEF_BAUDRATE;
+static u32 uart_baudrates[3] = { CONFIG_TANGOX_XENV_DEF_BAUDRATE, CONFIG_TANGOX_XENV_DEF_BAUDRATE, CONFIG_TANGOX_XENV_DEF_BAUDRATE, };
+
+static u32 uart_used_ports = 
+#ifdef CONFIG_TANGOX_XENV_DEF_UART0
+		1 +
+#else
+		0 +
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_UART1
+		1;
+#else
+		0;
+#endif
+
+static u32 pcidev_irq_route[4] = { 
+#ifdef CONFIG_TANGOX_XENV_DEF_PCI_ID1_IRQ
+	CONFIG_TANGOX_XENV_DEF_PCI_ID1_IRQ,
+#else
+	0,
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_PCI_ID2_IRQ
+	CONFIG_TANGOX_XENV_DEF_PCI_ID2_IRQ,
+#else
+	0,
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_PCI_ID3_IRQ
+	CONFIG_TANGOX_XENV_DEF_PCI_ID3_IRQ,
+#else
+	0,
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_PCI_ID4_IRQ 
+	CONFIG_TANGOX_XENV_DEF_PCI_ID4_IRQ 
+#else
+	0
+#endif
+};
+
+static u32 uart_console_port = CONFIG_TANGOX_XENV_DEF_CONSOLE_UART_PORT;
+#endif
+
+static u32 cs_flash_parts[4] = { 0, 0, 0, 0 };
+static uint_union flash_parts_offset[4][XENV_MAX_FLASH_PARTITIONS] = { { { { 0 } } }, { { { 0 } } }, { { { 0 } } }, { { { 0 } } }, };
+static u32 scard_off_pin = 0;
+static u32 scard_cmd_pin = 0;
+static u32 scard_5v_pin = 0;
+#if defined(CONFIG_TANGO3)
+static u32 scard1_off_pin = 0;
+static u32 scard1_cmd_pin = 0;
+static u32 scard1_5v_pin = 0;
+static u32 sata_channel_cfg = 0;
+static u32 cs_rsvd_pblk[4] = { 0, 0, 0, 0 };
+#endif
+static u32 isaide_timing_slot = 0;
+static u32 isaide_irq = 0;
+
+static u32 xenv_gbus_addr = 0;
+static u32 himem_ga = 0;
+static u32 himem_sz = 0;
+
+/* mac address to use if xenv is not readable  */
+static const u8 def_mac_address[6] = { 0x48, 0x4a, 0xe5, 0x00, 0x00, 0x01 };
+static u8 mac_address[6] = { 0x48, 0x4a, 0xe5, 0x00, 0x00, 0x02 };
+#if defined(CONFIG_TANGO3)
+static u8 mac_address1[6] = { 0x48, 0x4a, 0xe5, 0x00, 0x00, 0x03 };
+#endif
+
+/* for power saving (e.g. low frequency) */
+#ifdef CONFIG_TANGO2
+static u32 ps_pll3=0, ps_pll2=0, ps_pll1=0, ps_pll0=0, ps_mux=0, ps_d0cfg=0, ps_d1cfg=0, ps_d0delay=0, ps_d1delay=0;
+static u32 standby_pll3=0, standby_pll2=0, standby_pll1=0, standby_pll0=0, standby_mux=0, standby_d0cfg=0, standby_d1cfg=0, standby_d0delay=0, standby_d1delay=0;
+static u32 standby_gpiodir = 0, standby_gpiodata = 0;
+#endif
+
+#if defined(CONFIG_TANGO3)
+#define MT3_HS_SIZE	140	/* sizeof(struct mt3_hw_settings_t) */
+static u32 ps_pll2=0, ps_pll0=0, ps_mt3_hs[MT3_HS_SIZE/sizeof(u32)];
+static u32 standby_pll2=0, standby_pll0=0, standby_mt3_hs[MT3_HS_SIZE/sizeof(u32)];
+static u32 standby_gpiodir = 0, standby_gpiodata = 0;
+#endif
+
+static char xenv_cmdline[CL_SIZE] = { 0 };
+
+#if defined(CONFIG_TANGO3)
+extern unsigned long tangox_zxenv[];
+#endif
+
+#ifdef CONFIG_TANGOX_XENV_READ
+/*
+ * called for each entry found in xenv
+ */
+void __init xenv_val_cb(char *recordname, void *data, u32 datasize)
+{
+	char buf[64];
+	int i;
+	static const char *h32str = "_hi";
+
+#define CHECK_AND_STORE(_key, _reqlen, _var)				\
+	if (!strcmp(_key, recordname) && datasize <= _reqlen)	{	\
+		memcpy(&_var, data, _reqlen);				\
+		return;							\
+	}
+#define CHECK_AND_STORE1(_key, _reqlen, _var)				\
+	if (!strcmp(_key, recordname) && datasize <= _reqlen)	{	\
+		memset(&_var, 0, _reqlen);				\
+		memcpy(&_var, data, datasize);				\
+		return;							\
+	}
+
+	CHECK_AND_STORE(XENV_KEY_ENABLED_DEVICES, 4, enabled_devices);
+	CHECK_AND_STORE(XENV_KEY_DEF_BAUDRATE, 4, uart_baudrate);
+	CHECK_AND_STORE(XENV_KEY_UART_USED_PORTS, 4, uart_used_ports);
+	CHECK_AND_STORE(XENV_KEY_CONSOLE_UART_PORT, 4, uart_console_port);
+
+	if (uart_console_port == 0) /* for backward compatibility */
+		uart_used_ports |= 1;
+
+	for (i = 0; i < 3; i++) {
+		sprintf(buf, XENV_KEYS_UART_BAUDRATE, i);
+		CHECK_AND_STORE(buf, 4, uart_baudrates[i]);
+	}
+
+	if (uart_baudrate == 0)
+		uart_baudrate = 115200; /* default 115200 */
+	if (uart_baudrates[0] == 0)
+		uart_baudrates[0] = uart_baudrate;
+	if (uart_baudrates[1] == 0)
+		uart_baudrates[1] = uart_baudrate;
+	if (uart_baudrates[2] == 0)
+		uart_baudrates[2] = uart_baudrate;
+
+	for (i = 1; i < 5; i++) {
+		sprintf(buf, XENV_KEYS_PCI_IRQ_ROUTE, i);
+		CHECK_AND_STORE(buf, 4, pcidev_irq_route[i - 1]);
+	}
+
+	CHECK_AND_STORE(XENV_KEY_SCARD_OFF, 4, scard_off_pin);
+	CHECK_AND_STORE(XENV_KEY_SCARD_5V, 4, scard_5v_pin);
+	CHECK_AND_STORE(XENV_KEY_SCARD_CMD, 4, scard_cmd_pin);
+#if defined(CONFIG_TANGO3)
+	CHECK_AND_STORE(XENV_KEY_SCARD1_OFF, 4, scard1_off_pin);
+	CHECK_AND_STORE(XENV_KEY_SCARD1_5V, 4, scard1_5v_pin);
+	CHECK_AND_STORE(XENV_KEY_SCARD1_CMD, 4, scard1_cmd_pin);
+	CHECK_AND_STORE(XENV_KEY_SATA_CHANNEL_CFG, 4, sata_channel_cfg);
+#endif
+
+	CHECK_AND_STORE(XENV_KEY_HIMEM_GA, 4, himem_ga);
+	CHECK_AND_STORE(XENV_KEY_HIMEM_SZ, 4, himem_sz);
+
+	for (i = 0; i < 4; i++) {
+		int j;
+
+		sprintf(buf, XENV_KEYS_CS_SIZE, i);
+		CHECK_AND_STORE(buf, 4, cs_flash_size[i].uint32[0]);
+		strcat(buf, h32str);
+		CHECK_AND_STORE(buf, 4, cs_flash_size[i].uint32[1]);
+
+		sprintf(buf, XENV_KEYS_CS_PARTS, i);
+		CHECK_AND_STORE(buf, 4, cs_flash_parts[i]);
+
+#if defined(CONFIG_TANGO3)
+		sprintf(buf, XENV_KEYS_CS_RSVD_PBLK, i);
+		CHECK_AND_STORE(buf, 4, cs_rsvd_pblk[i]);
+#endif
+
+		for (j = 1; j < XENV_MAX_FLASH_PARTITIONS; j++) {
+
+			sprintf(buf, XENV_KEYS_CS_PART_SIZE, i, j);
+			CHECK_AND_STORE(buf, 4, flash_parts_size[i][j - 1].uint32[0]);
+			strcat(buf, h32str);
+			CHECK_AND_STORE(buf, 4, flash_parts_size[i][j - 1].uint32[1]);
+
+			sprintf(buf, XENV_KEYS_CS_PART_OFFSET, i, j);
+			CHECK_AND_STORE(buf, 4, flash_parts_offset[i][j - 1].uint32[0]);
+			strcat(buf, h32str);
+			CHECK_AND_STORE(buf, 4, flash_parts_offset[i][j - 1].uint32[1]);
+		}
+	}
+
+	CHECK_AND_STORE(XENV_KEY_ISAIDE_IRQ_ROUTE, 4, isaide_irq);
+	CHECK_AND_STORE(XENV_KEY_ISAIDE_TIMING_SLOT, 4, isaide_timing_slot);
+
+	if (!strcmp(recordname, XENV_KEY_LINUX_CMD) &&
+	    datasize <= sizeof (xenv_cmdline) - 1) {
+		memcpy(xenv_cmdline, data, datasize);
+		xenv_cmdline[datasize] = 0;
+	}
+
+#ifdef CONFIG_TANGO2
+	CHECK_AND_STORE(XENV_KEY_PS_PLL3, 4, ps_pll3);
+	CHECK_AND_STORE(XENV_KEY_PS_PLL2, 4, ps_pll2);
+	CHECK_AND_STORE(XENV_KEY_PS_PLL1, 4, ps_pll1);
+	CHECK_AND_STORE(XENV_KEY_PS_PLL0, 4, ps_pll0);
+	CHECK_AND_STORE(XENV_KEY_PS_MUX, 4, ps_mux);
+	CHECK_AND_STORE(XENV_KEY_PS_D0CFG, 4, ps_d0cfg);
+	CHECK_AND_STORE(XENV_KEY_PS_D1CFG, 4, ps_d1cfg);
+	CHECK_AND_STORE(XENV_KEY_PS_D0DELAY, 4, ps_d0delay);
+	CHECK_AND_STORE(XENV_KEY_PS_D1DELAY, 4, ps_d1delay);
+
+	CHECK_AND_STORE(XENV_KEY_STANDBY_PLL3, 4, standby_pll3);
+	CHECK_AND_STORE(XENV_KEY_STANDBY_PLL2, 4, standby_pll2);
+	CHECK_AND_STORE(XENV_KEY_STANDBY_PLL1, 4, standby_pll1);
+	CHECK_AND_STORE(XENV_KEY_STANDBY_PLL0, 4, standby_pll0);
+	CHECK_AND_STORE(XENV_KEY_STANDBY_MUX, 4, standby_mux);
+	CHECK_AND_STORE(XENV_KEY_STANDBY_D0CFG, 4, standby_d0cfg);
+	CHECK_AND_STORE(XENV_KEY_STANDBY_D1CFG, 4, standby_d1cfg);
+	CHECK_AND_STORE(XENV_KEY_STANDBY_D0DELAY, 4, standby_d0delay);
+	CHECK_AND_STORE(XENV_KEY_STANDBY_D1DELAY, 4, standby_d1delay);
+#endif
+
+#if defined(CONFIG_TANGO3)
+	CHECK_AND_STORE(XENV_KEY_PS_PLL2, 4, ps_pll2);
+	CHECK_AND_STORE(XENV_KEY_PS_PLL0, 4, ps_pll0);
+	CHECK_AND_STORE1(XENV_KEY_PS_MT3_HS, MT3_HS_SIZE, ps_mt3_hs[0]);
+
+	CHECK_AND_STORE(XENV_KEY_STANDBY_PLL2, 4, standby_pll2);
+	CHECK_AND_STORE(XENV_KEY_STANDBY_PLL0, 4, standby_pll0);
+	CHECK_AND_STORE1(XENV_KEY_STANDBY_MT3_HS, MT3_HS_SIZE, standby_mt3_hs[0]);
+#endif
+
+	CHECK_AND_STORE(XENV_KEY_STANDBY_GPIODIR, 4, standby_gpiodir);
+	CHECK_AND_STORE(XENV_KEY_STANDBY_GPIODATA, 4, standby_gpiodata);
+}
+
+/*
+ * try to read config from XENV
+ */
+static int __init xenv_read_content(void)
+{
+	unsigned long xenv_addr, old_remap;
+	int xenv_size, ret = 0;
+	uint32_t mac_lo, mac_hi;
+	/*
+	 * fetch XENV address
+	 */
+#if defined(CONFIG_TANGO3)
+	unsigned int size, tmp, copy_size;
+	unsigned char *xenv_blk = (unsigned char *)tangox_zxenv;
+	xenv_gbus_addr = xenv_addr = gbus_read_reg32(REG_BASE_cpu_block + LR_ZBOOTXENV_LOCATION);
+#else
+	xenv_gbus_addr = xenv_addr = gbus_read_reg32(REG_BASE_cpu_block + LR_XENV_LOCATION);
+#endif
+	if (!xenv_addr)
+		return 1;
+
+	/*
+	 * got the xenv address in  gbus form, now convert it in remap
+	 * form so we can access it
+	 */
+	old_remap = gbus_read_reg32(REG_BASE_cpu_block + TMP_REMAPPED_REG);
+	gbus_write_reg32(REG_BASE_cpu_block + TMP_REMAPPED_REG, xenv_addr & TMP_REMAPPED_MASK);
+	iob();
+	xenv_addr = KSEG1ADDR(TMP_REMAPPED_BASE) + (xenv_addr & (TMP_REMAPPED_SIZE-1));
+
+#if defined(CONFIG_TANGO3)
+	/*
+	 * make a copy of XENV
+	 */
+	xenv_size = *((int *)xenv_addr);
+	copy_size = TMP_REMAPPED_SIZE - (xenv_gbus_addr & (TMP_REMAPPED_SIZE-1));
+	if (xenv_size >= MAX_XENV_SIZE) { /* XENV too big */
+		ret = 1;
+		goto done;
+	} else if (copy_size < xenv_size) { /* across remap boundary */
+		memcpy(xenv_blk, (void *)xenv_addr, copy_size);
+		gbus_write_reg32(REG_BASE_cpu_block + TMP_REMAPPED_REG, (xenv_gbus_addr + TMP_REMAPPED_SIZE) & TMP_REMAPPED_MASK);
+		iob();
+		memcpy(xenv_blk + copy_size, (void *)KSEG1ADDR(TMP_REMAPPED_BASE), xenv_size - copy_size);
+	} else {
+		memcpy(xenv_blk, (void *)xenv_addr, xenv_size);
+	}
+	xenv_addr = (unsigned long)xenv_blk; /* use the copy */
+#endif
+
+	/*
+	 * check xenv sanity
+	 */
+	xenv_size = xenv_isvalid((u32 *)xenv_addr, MAX_XENV_SIZE);
+	if (xenv_size < 0) {
+		xenv_gbus_addr = xenv_addr = 0;
+		ret = 1;
+		goto done;
+	}
+
+#ifdef CONFIG_TANGOX_XENV_DUMP
+	xenv_dump((u32 *)xenv_addr, xenv_size);
+#endif
+
+	/*
+	 * ok, we can start to load each wanted value
+	 */
+	xenv_foreach((u32 *)xenv_addr, xenv_size, xenv_val_cb);
+
+	/*
+	 * load remaining values
+	 */
+#if defined(CONFIG_TANGO3)
+	/* Getting information from LR_XENV2_RW */
+	mac_hi = mac_lo = 0x0; size = sizeof(unsigned int);
+	if ((xenv_get((void *)KSEG1ADDR(REG_BASE_cpu_block + LR_XENV2_RW), MAX_LR_XENV2_RW, XENV_LRRW_ETH_MACL, &tmp, &size) == 0) && (size == sizeof(unsigned int))) {
+		mac_lo = tmp;
+		if ((xenv_get((void *)KSEG1ADDR(REG_BASE_cpu_block + LR_XENV2_RW), MAX_LR_XENV2_RW, XENV_LRRW_ETH_MACH, &tmp, &size) == 0) && (size == sizeof(unsigned int)))
+		mac_hi = tmp;
+	}
+	mac_hi = cpu_to_be32(mac_hi);
+	mac_lo = cpu_to_be32(mac_lo);
+	memcpy(mac_address, (u8 *)&mac_hi + 2, 2);
+	memcpy(mac_address + 2, &mac_lo, 4);
+
+	mac_hi = mac_lo = 0x0; size = sizeof(unsigned int);
+	if ((xenv_get((void *)KSEG1ADDR(REG_BASE_cpu_block + LR_XENV2_RW), MAX_LR_XENV2_RW, XENV_LRRW_ETH1_MACL, &tmp, &size) == 0) && (size == sizeof(unsigned int))) {
+		mac_lo = tmp;
+		if ((xenv_get((void *)KSEG1ADDR(REG_BASE_cpu_block + LR_XENV2_RW), MAX_LR_XENV2_RW, XENV_LRRW_ETH1_MACH, &tmp, &size) == 0) && (size == sizeof(unsigned int)))
+			mac_hi = tmp;
+	}
+	mac_hi = cpu_to_be32(mac_hi);
+	mac_lo = cpu_to_be32(mac_lo);
+	memcpy(mac_address1, (u8 *)&mac_hi + 2, 2);
+	memcpy(mac_address1 + 2, &mac_lo, 4);
+#else
+	mac_hi = gbus_read_reg32(REG_BASE_cpu_block + LR_ETH_MAC_HI);
+	mac_lo = gbus_read_reg32(REG_BASE_cpu_block + LR_ETH_MAC_LO);
+	mac_hi = cpu_to_be32(mac_hi);
+	mac_lo = cpu_to_be32(mac_lo);
+	memcpy(mac_address, (u8 *)&mac_hi + 2, 2);
+	memcpy(mac_address + 2, &mac_lo, 4);
+#endif
+
+done:
+	gbus_write_reg32(REG_BASE_cpu_block + TMP_REMAPPED_REG, old_remap);
+	iob();
+
+	return ret;
+}
+#endif
+
+/*
+ * load default values and try to fetch xenv content
+ */
+int __init xenv_config(void)
+{
+#ifndef CONFIG_TANGOX_XENV_READ
+	/* will use default values */
+	return 0;
+#else
+	/*
+	 * try to load XENV content
+	 */
+	if (xenv_read_content() == 0) {
+		/* ok */
+		return 0;
+	}
+
+#ifndef CONFIG_TANGOX_XENV_READ_SAFE
+
+	/* fallback to failsafe values */
+	return 1;
+#else
+	/* stop boot process */
+	while (1)
+		cpu_relax();
+	/* not reached */
+	return 1;
+#endif
+
+#endif /* !CONFIG_TANGOX_XENV_READ */
+}
+
+
+/*
+ * helpers to access xenv configuration cached data
+ */
+
+/*
+ * enabled device query function
+ */
+#define BUILD_ENABLED(name, shift)					\
+int tangox_##name##_enabled(void)					\
+{									\
+	return (((enabled_devices >> shift) & 1) != 0) ? 1 : 0;	\
+} \
+EXPORT_SYMBOL(tangox_##name##_enabled);
+
+BUILD_ENABLED(isaide, ISAIDE_SHIFT)
+BUILD_ENABLED(bmide, BMIDE_SHIFT)
+BUILD_ENABLED(ir, IR_SHIFT)
+BUILD_ENABLED(fip, FIP_SHIFT)
+BUILD_ENABLED(usb, USB_SHIFT)
+BUILD_ENABLED(i2cm, I2CM_SHIFT)
+BUILD_ENABLED(i2cs, I2CS_SHIFT)
+BUILD_ENABLED(pci_host, PCIHOST_SHIFT)
+BUILD_ENABLED(sata, SATA_SHIFT)
+BUILD_ENABLED(gnet, GNET_SHIFT)
+
+int tangox_scard_enabled(int i)
+{
+#if defined(CONFIG_TANGO3)
+	if (i != 0)
+		return((enabled_devices >> SCARD1_SHIFT) & 1) ? 1 : 0;
+#endif
+	return((enabled_devices >> SCARD_SHIFT) & 1) ? 1 : 0;
+}
+
+int tangox_ethernet_enabled(int i)
+{
+#if defined(CONFIG_TANGO3)
+	if (i != 0)
+		return((enabled_devices >> ETHERNET1_SHIFT) & 1) ? 1 : 0;
+#endif
+	return((enabled_devices >> ETHERNET_SHIFT) & 1) ? 1 : 0;
+}
+
+int tangox_sdio_enabled(int i)
+{
+#if defined(CONFIG_TANGO3)
+	if (i != 0)
+		return((enabled_devices >> SDIO1_SHIFT) & 1) ? 1 : 0;
+#endif
+	return((enabled_devices >> SDIO_SHIFT) & 1) ? 1 : 0;
+}
+
+int tangox_pcidev_enabled(int idsel)
+{
+	if (!tangox_pci_host_enabled())
+		return 0;
+
+	idsel--;
+	return (((enabled_devices >> (idsel + PCI1_SHIFT)) & 1) != 0) ? 1 : 0;
+}
+
+int tangox_pcidev_irq_map(int pci_idsel, int int_num)
+{
+	int route;
+	int irq;
+
+	route = pcidev_irq_route[pci_idsel - 1];
+
+	/* int_num: 0-3 = INTA-D */
+	irq = (int)((route >> (int_num * 8)) & 0x3);
+	if (irq >= 0)
+		irq += (IRQ_CONTROLLER_IRQ_BASE + LOG2_CPU_PCI_INTA);
+	return irq;
+}
+
+int tangox_isaide_irq_map(void)
+{
+	int irq = 0;
+
+	if (tangox_isaide_enabled() == 0)
+		return(-1);
+	irq = isaide_irq;
+	if (irq >= 0)
+		irq += (IRQ_CONTROLLER_IRQ_BASE + LOG2_CPU_PCI_INTA);
+	return irq;
+}
+
+int tangox_isaide_cs_select(void)
+{
+        int i;
+        unsigned long cs_config = (gbus_read_reg32(REG_BASE_host_interface + PB_CS_config) >> 12) & 0xf;
+
+        if (tangox_isaide_enabled() == 0)
+                return(-1);
+
+        for (i = 0; i < 4; i++) {
+                if ((cs_config & 0x1) != 0)
+                        return(i);
+                else
+                        cs_config >>= 1;
+        }
+        return(-1);
+}
+
+int tangox_isaide_timing_slot(void)
+{
+        return(isaide_timing_slot & 0x7);
+}
+
+EXPORT_SYMBOL(tangox_isaide_irq_map);
+EXPORT_SYMBOL(tangox_isaide_cs_select);
+EXPORT_SYMBOL(tangox_isaide_timing_slot);
+EXPORT_SYMBOL(tangox_scard_enabled);
+EXPORT_SYMBOL(tangox_ethernet_enabled);
+EXPORT_SYMBOL(tangox_sdio_enabled);
+
+int tangox_ethernet_getmac(int idx, unsigned char *mac)
+{
+#if defined(CONFIG_TANGO3)
+	if (idx != 0) {
+		/* filter broadcast & multicast addresses */
+		if (mac_address1[0] == 0x01 || mac_address1[0] == 0xff)
+			memcpy(mac, def_mac_address, 6);
+		else
+			memcpy(mac, mac_address1, 6);
+		return 0;
+	}
+#endif
+	/* filter broadcast & multicast addresses */
+	if (mac_address[0] == 0x01 || mac_address[0] == 0xff)
+		memcpy(mac, def_mac_address, 6);
+	else
+		memcpy(mac, mac_address, 6);
+	return 0;
+}
+
+int tangox_uart_baudrate(int uart)
+{
+	return uart_baudrates[uart];
+}
+
+int tangox_uart_console_port(void)
+{
+	return uart_console_port;
+}
+
+int tangox_uart_enabled(int uart)
+{
+	return (((uart_used_ports >= 3) || (uart_console_port == uart)) ? 1 : 0);
+}
+
+int tangox_flash_get_info(int cs, u64 *size, unsigned int *part_count)
+{
+	if (cs > 3)
+		return 1;
+
+	*size = cs_flash_size[cs].uint64[0];
+	*part_count = 0;
+	if (cs_flash_size[cs].uint64[0] > 0)
+		*part_count = cs_flash_parts[cs];
+
+	return 0;
+}
+
+int tangox_flash_get_parts(int cs, u64 offset[], u64 size[])
+{
+	int i;
+
+	if (!cs_flash_size[cs].uint64[0])
+		return 1;
+
+	for (i = 0; i < cs_flash_parts[cs]; i++) {
+		offset[i] = flash_parts_offset[cs][i].uint64[0];
+		size[i] = flash_parts_size[cs][i].uint64[0];
+	}
+
+	return 0;
+}
+
+EXPORT_SYMBOL(tangox_flash_get_info);
+EXPORT_SYMBOL(tangox_flash_get_parts);
+
+#if defined(CONFIG_TANGO3)
+int tangox_flash_get_rsvd_pblk(int cs)
+{
+	if (cs > 3)
+		return 0;
+	else
+		return cs_rsvd_pblk[cs];
+}
+
+EXPORT_SYMBOL(tangox_flash_get_rsvd_pblk);
+#endif
+
+const char *tangox_xenv_cmdline(void)
+{
+	/* remove "" from command line */
+	if (xenv_cmdline[0] == '"') {
+		int len;
+
+		len = strlen(xenv_cmdline);
+		if (xenv_cmdline[len - 1] == '"')
+			xenv_cmdline[len - 1] = 0;
+		return xenv_cmdline + 1;
+	}
+	return xenv_cmdline;
+}
+
+#if defined(CONFIG_TANGO3)
+int tangox_get_sata_channel_cfg(unsigned int *cfg)
+{
+	*cfg = sata_channel_cfg;
+	return 0;
+}
+EXPORT_SYMBOL(tangox_get_sata_channel_cfg);
+#endif
+
+int tangox_get_scard_info(int scard_no, int *pin_5v, int *pin_cmd, int *pin_off)
+{
+#if defined(CONFIG_TANGO3)
+	if (scard_no != 0) {
+		*pin_5v = scard1_5v_pin;
+		*pin_off = scard1_off_pin;
+		*pin_cmd = scard1_cmd_pin;
+		return 0;
+	}
+#endif
+	*pin_5v = scard_5v_pin;
+	*pin_off = scard_off_pin;
+	*pin_cmd = scard_cmd_pin;
+	return 0;
+}
+
+/*
+ * show enabled devices according to xenv content
+ */
+void __init tangox_device_info(void)
+{
+	int i;
+
+	if (!xenv_gbus_addr) 
+		return;
+
+	printk(KERN_INFO "SMP86xx Enabled Devices under Linux/"
+	       "XENV 0x%08x = 0x%08x\n", xenv_gbus_addr, enabled_devices);
+
+	printk(KERN_INFO);
+	if (tangox_isaide_enabled())
+		printk(" ISA/IDE");
+	if (tangox_bmide_enabled())
+		printk(" BM/IDE");
+	if (tangox_pci_host_enabled())
+		printk(" PCIHost");
+	if (tangox_ethernet_enabled(0))
+		printk(" Ethernet");
+#if defined(CONFIG_TANGO3)
+	if (tangox_ethernet_enabled(1))
+		printk(" Ethernet1");
+#endif
+	if (tangox_ir_enabled())
+		printk(" IR");
+	if (tangox_fip_enabled())
+		printk(" FIP");
+	if (tangox_i2cm_enabled())
+		printk(" I2CM");
+	if (tangox_i2cs_enabled())
+		printk(" I2CS");
+	if (tangox_sdio_enabled(0))
+		printk(" SDIO");
+#if defined(CONFIG_TANGO3)
+	if (tangox_sdio_enabled(1))
+		printk(" SDIO1");
+#endif
+	if (tangox_usb_enabled())
+		printk(" USB");
+	for (i = 1; i <= 6; i++) {
+		if (tangox_pcidev_enabled(i))
+			printk(" PCIDev%d", i);
+	}
+	if (tangox_sata_enabled())
+		printk(" SATA");
+	if (tangox_scard_enabled(0))
+		printk(" SCARD");
+#if defined(CONFIG_TANGO3)
+	if (tangox_scard_enabled(1))
+		printk(" SCARD1");
+#endif
+	if (tangox_gnet_enabled())
+		printk(" GNET");
+	printk("\n");
+}
+
+#ifdef CONFIG_TANGO2
+void tangox_get_ps_config(u32 *pll3, u32 *pll2, u32 *pll1, u32 *pll0, u32 *mux, u32 *d0cfg, u32 *d0delay, u32 *d1cfg, u32 *d1delay)
+{
+	*pll3 = ps_pll3;
+	*pll2 = ps_pll2;
+	*pll1 = ps_pll1;
+	*pll0 = ps_pll0;
+	*mux = ps_mux;
+	*d0cfg = ps_d0cfg;
+	*d1cfg = ps_d1cfg;
+	*d0delay = ps_d0delay;
+	*d1delay = ps_d1delay;
+}
+
+void tangox_get_standby_config(u32 *pll3, u32 *pll2, u32 *pll1, u32 *pll0, u32 *mux, u32 *d0cfg, u32 *d0delay, u32 *d1cfg, u32 *d1delay, u32 *gpio_dir, u32 *gpio_data)
+{
+	*pll3 = standby_pll3;
+	*pll2 = standby_pll2;
+	*pll1 = standby_pll1;
+	*pll0 = standby_pll0;
+	*mux = standby_mux;
+	*d0cfg = standby_d0cfg;
+	*d1cfg = standby_d1cfg;
+	*d0delay = standby_d0delay;
+	*d1delay = standby_d1delay;
+	*gpio_dir = standby_gpiodir;
+	*gpio_data = standby_gpiodata;
+}
+#endif
+
+#if defined(CONFIG_TANGO3)
+void tangox_get_ps_config(unsigned long *pll2, unsigned long *pll0, unsigned long *mt3_hw_settings)
+{
+	*pll2 = ps_pll2;
+	*pll0 = ps_pll0;
+	memcpy(mt3_hw_settings, ps_mt3_hs, MT3_HS_SIZE);
+}
+
+void tangox_get_standby_config(unsigned long *pll2, unsigned long *pll0, unsigned long *mt3_hw_settings, u32 *gpio_dir, u32 *gpio_data)
+{
+	*pll2 = standby_pll2;
+	*pll0 = standby_pll0;
+	*gpio_dir = standby_gpiodir;
+	*gpio_data = standby_gpiodata;
+	memcpy(mt3_hw_settings, standby_mt3_hs, MT3_HS_SIZE);
+}
+#endif
+
+void tangox_get_himem_info(unsigned long *start, unsigned long *size)
+{
+	*start = *size = 0;
+	if ((himem_ga != 0) && (himem_sz != 0)) {
+		*start = himem_ga;
+		*size = himem_sz;
+	}
+}
+
+EXPORT_SYMBOL(tangox_ethernet_getmac);
+EXPORT_SYMBOL(tangox_get_scard_info);
+EXPORT_SYMBOL(tangox_get_ps_config);
+EXPORT_SYMBOL(tangox_get_standby_config);
+EXPORT_SYMBOL(tangox_get_himem_info);
+
diff -Naur linux-3.9.2.ref/arch/mips/tangox/xenv.h linux-3.9.2/arch/mips/tangox/xenv.h
--- linux-3.9.2.ref/arch/mips/tangox/xenv.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/tangox/xenv.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,99 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+/**
+  @file   xenv.h
+  @brief
+
+  The prototypes below act on a clear area respecting the xenv format.
+
+  (De)ciphering the  area, as well as committing  the changes (writing
+  the area to flash) are trivial add-ons on top of this API.
+
+  The underlying  implementation is not optimized for  speed (read and
+  write in  O(nrecords)). There  is no fragmentation  (data completely
+  rearranged at each write).
+
+  It is  not advised to repeatedly  act on flash stored  data, for the
+  device does  not support  unlimited read/write operations  (refer to
+  spec)
+
+  Power  loss when  committing the  changes cause  loss of  the stored
+  data.  This  can be avoided  by storing the  same data twice  to two
+  different sectors.
+
+  --------------------------------------------------------------------------
+  Specification   of   a   secure   storage   on   serial   flash   of
+  reboot-persistent data (xenv format)
+
+  We  describe a  way  to  concatenate (at  most  4KByte area  (12bits
+  limit)) variable  length records identified  by a string,  the `key'
+  (working much like Windows registry)
+
+  Page, seen as a byte array, is
+
+  0          4                   24                 env_size         4KB
+  | env_size | SHA-1 of following | rec0 | rec1 | .. | recn | xx xx .. |
+
+  The SHA-1 extent is env_size-24.
+
+  Description of a rec (bytes):
+
+  |4bits   12bits (2bytes)   | variable, NULL terminated | variable         |
+  attr     total record size   record name (string)        record value
+
+  attr =
+   XENV_ATTR_RW
+   XENV_ATTR_RO can be written once only but can be deleted
+   XENV_ATTR_OTP this record can be written once only and cannot be deleted
+  --------------------------------------------------------------------------
+
+  @author Emmanuel Michon
+  @date   2005-05-17
+*/
+
+#ifndef __XENV_H__
+#define __XENV_H__
+
+#include "setup.h"
+
+#define MAX_XENV_SIZE   16384
+
+/**
+   Check for compliance with xenv format
+
+   May be corrupted by:
+   - forgot to format
+   - power loss during sflash write
+   - intrusion
+
+   @param base
+   @param size
+   @return -ReturnValue-: env_size>=0 if valid, -1 if not.
+*/
+int xenv_isvalid(u32 *base, u32 maxsize);
+
+int xenv_foreach(u32 *base, u32 size,
+		 void (*cb)(char *recordname, void *data, u32 datasize));
+
+int xenv_get(u32 *base, u32 size, char *recordname, void *dst, u32 *datasize);
+int xenv_set(u32 *base, u32 size, char *recordname, void *src, u8 attr, u32 datasize);
+
+void xenv_dump(u32 *base, u32 size);
+
+#if defined(CONFIG_TANGO3)
+/*
+ * XENV sizes LRRO/LRRW
+ */
+#define MAX_LR_XENV2_RO 628
+#define MAX_LR_XENV2_RW 628
+#endif
+
+#endif // __XENV_H__
diff -Naur linux-3.9.2.ref/arch/mips/tangox/xenvkeys.h linux-3.9.2/arch/mips/tangox/xenvkeys.h
--- linux-3.9.2.ref/arch/mips/tangox/xenvkeys.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/tangox/xenvkeys.h	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,227 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/* 
+ * The keys defined in XENV, more can be added.
+ */
+
+#ifndef __XENV_KEYS_H__
+#define __XENV_KEYS_H__
+
+#define XENV_KEY_BOARD_ID           "a.board_id"
+#define XENV_KEY_CHIP_REV           "a.chip_rev"
+
+#define XENV_KEY_PREMUX             "a.premux"
+#define XENV_KEY_AVCLK_MUX          "a.avclk_mux"
+#define XENV_KEY_HOSTCLK_MUX        "a.hostclk_mux"
+#define XENV_KEY_IRQ_RISE_EDGE_LO   "a.irq_rise_edge_lo"
+#define XENV_KEY_IRQ_FALL_EDGE_LO   "a.irq_fall_edge_lo"
+#define XENV_KEY_GPIO_IRQ_MAP       "a.gpio_irq_map"
+
+#define XENV_KEY_DEF_BAUDRATE       "a.baudrate"
+#define XENV_KEY_CONSOLE_UART_PORT  "a.uart_console_port"
+#define XENV_KEY_UART_USED_PORTS    "a.uart_used_ports"
+
+#define XENV_KEY_PB_CS_CONFIG       "a.pb_cs_config"
+#if defined(CONFIG_TANGO3)
+#define XENV_KEY_PB_CS_CONFIG1      "a.pb_cs_config1"
+#define XENV_KEY_PB_CS_CTRL         "a.pb_cs_ctrl"
+#endif
+#define XENV_KEY_DEF_TIMING         "a.pb_def_timing"
+#define XENV_KEY_PB_TIMING0         "a.pb_timing0"
+#define XENV_KEY_PB_USE_TIMING0     "a.pb_use_timing0"
+#define XENV_KEY_PB_TIMING1         "a.pb_timing1"
+#define XENV_KEY_PB_USE_TIMING1     "a.pb_use_timing1"
+#define XENV_KEY_PB_TIMING2         "a.pb_timing2"
+#define XENV_KEY_PB_USE_TIMING2     "a.pb_use_timing2"
+#define XENV_KEY_PB_TIMING3         "a.pb_timing3"
+#define XENV_KEY_PB_USE_TIMING3     "a.pb_use_timing3"
+#define XENV_KEY_PB_TIMING4         "a.pb_timing4"
+#define XENV_KEY_PB_USE_TIMING4     "a.pb_use_timing4"
+#define XENV_KEY_PB_TIMING5         "a.pb_timing5"
+#define XENV_KEY_PB_USE_TIMING5     "a.pb_use_timing5"
+
+#define XENV_KEY_IRQ_RISE_EDGE_HI   "a.irq_rise_edge_hi"
+#define XENV_KEY_IRQ_FALL_EDGE_HI   "a.irq_fall_edge_hi"
+
+#define XENV_KEY_ENABLED_DEVICES    "a.enable_devices"
+
+#define XENV_KEY_ETH_MAC            "a.eth_mac"
+#if defined(CONFIG_TANGO3)
+#define XENV_KEY_ETH1_MAC           "a.eth1_mac"
+#endif
+
+#define XENV_KEY_SCARD_OFF          "a.scard_off_pin"
+#define XENV_KEY_SCARD_5V           "a.scard_5v_pin"
+#define XENV_KEY_SCARD_CMD          "a.scard_cmd_pin"
+
+#if defined(CONFIG_TANGO3)
+#define XENV_KEY_SCARD1_OFF         "a.scard1_off_pin"
+#define XENV_KEY_SCARD1_5V          "a.scard1_5v_pin"
+#define XENV_KEY_SCARD1_CMD         "a.scard1_cmd_pin"
+#endif
+
+#define XENV_KEY_ISAIDE_IRQ_ROUTE   "a.isaide_irq_route"
+#define XENV_KEY_ISAIDE_TIMING_SLOT "a.isaide_timing_slot"
+
+#define XENV_KEY_GPIO_DIR           "a.gpio_dir"
+#define XENV_KEY_GPIO_DATA          "a.gpio_data"
+
+#define XENV_KEY_LINUX_CMD          "a.linux_cmd"
+
+#define XENV_KEY_Z_BOOT_DEF         "z.default_boot"
+
+#define XENV_KEY_Z_PROD_TEST        "z.dt"
+#define XENV_KEY_Z_PROD_LOOPS       "z.prod_loops"
+#define XENV_KEY_Z_PROD_FTEST       "z.prod_ftest"
+#define XENV_KEY_Z_PROD_FSTART      "z.prod_fstart"
+#define XENV_KEY_Z_PROD_FEND        "z.prod_fend"
+#define XENV_KEY_Z_PROD_FSTEP       "z.prod_fstep"
+#define XENV_KEY_Z_PROD_RWIN        "z.prod_rwindow"
+#define XENV_KEY_Z_PROD_WWIN        "z.prod_wwindow"
+#define XENV_KEY_Z_PROD_CL          "z.prod_cl"
+#define XENV_KEY_Z_PROD_NBLOCKS     "z.prod_nblocks"
+
+#define XENV_KEY_YAMON_ENV          "y.env"
+#define XENV_KEY_YAMON_IPADDR       "y.ipaddr"
+#define XENV_KEY_YAMON_SUBNET       "y.subnetmask"
+#define XENV_KEY_YAMON_GATEWAY      "y.gateway"
+#define XENV_KEY_YAMON_START        "y.start"
+#define XENV_KEY_YAMON_STARTDELAY   "y.startdelay"
+
+#define XENV_KEYS_PCI_IRQ_ROUTE     "a.pcidev%d_irq_route"
+#define XENV_KEYS_CD_FREQUENCY      "a.cd%d_freq"
+#define XENV_KEYS_CD_DIV            "a.cd%d_div"
+#define XENV_KEYS_UART_GPIO_MODE    "a.uart%d_gpio_mode"
+#define XENV_KEYS_UART_GPIO_DIR     "a.uart%d_gpio_dir"
+#define XENV_KEYS_UART_GPIO_DATA    "a.uart%d_gpio_data"
+#define XENV_KEYS_UART_BAUDRATE     "a.uart%d_baudrate"
+#define XENV_KEYS_GPIO_PULSE        "a.gpio%d_pulse"
+
+#define XENV_KEYS_Z_BOOT_LOCATION   "z.boot%d"
+
+#define XENV_KEYS_CS_SIZE           "l.cs%d_size"
+#define XENV_KEYS_CS_PARTS          "l.cs%d_parts"
+
+#define XENV_KEYS_CS_PART_SIZE      "l.cs%d_part%d_size"
+#define XENV_KEYS_CS_PART_OFFSET    "l.cs%d_part%d_offset" 
+
+#define XENV_KEY_HIMEM_GA	    "l.himem_ga"
+#define XENV_KEY_HIMEM_SZ	    "l.himem_sz"
+
+#if defined(CONFIG_TANGO3)
+#define XENV_KEYS_CS_RSVD_PBLK	    "a.cs%d_rsvd_pblk"
+#define XENV_KEY_SATA_CHANNEL_CFG   "a.sata_channel_cfg"
+#endif
+
+#ifdef CONFIG_TANGO2
+#define XENV_KEY_PS_PLL3            "a.ps.pll3"
+#define XENV_KEY_PS_PLL2            "a.ps.pll2"
+#define XENV_KEY_PS_PLL1            "a.ps.pll1"
+#define XENV_KEY_PS_PLL0            "a.ps.pll0"
+#define XENV_KEY_PS_MUX             "a.ps.mux"
+#define XENV_KEY_PS_D0CFG           "a.ps.d0cfg"
+#define XENV_KEY_PS_D1CFG           "a.ps.d1cfg"
+#define XENV_KEY_PS_D0DELAY         "a.ps.d0delay"
+#define XENV_KEY_PS_D1DELAY         "a.ps.d1delay"
+
+#define XENV_KEY_STANDBY_PLL3       "a.standby.pll3"
+#define XENV_KEY_STANDBY_PLL2       "a.standby.pll2"
+#define XENV_KEY_STANDBY_PLL1       "a.standby.pll1"
+#define XENV_KEY_STANDBY_PLL0       "a.standby.pll0"
+#define XENV_KEY_STANDBY_MUX        "a.standby.mux"
+#define XENV_KEY_STANDBY_D0CFG      "a.standby.d0cfg"
+#define XENV_KEY_STANDBY_D1CFG      "a.standby.d1cfg"
+#define XENV_KEY_STANDBY_D0DELAY    "a.standby.d0delay"
+#define XENV_KEY_STANDBY_D1DELAY    "a.standby.d1delay"
+#endif
+
+#if defined(CONFIG_TANGO3)
+#define XENV_KEY_PS_PLL2            "a.ps.pll2"
+#define XENV_KEY_PS_PLL0            "a.ps.pll0"
+#define XENV_KEY_PS_MT3_HS          "a.ps.mt3_hs"
+
+#define XENV_KEY_STANDBY_PLL2       "a.standby.pll2"
+#define XENV_KEY_STANDBY_PLL0       "a.standby.pll0"
+#define XENV_KEY_STANDBY_MT3_HS     "a.standby.mt3_hs"
+#endif
+
+#define XENV_KEY_STANDBY_GPIODIR    "a.standby.gpio_dir"
+#define XENV_KEY_STANDBY_GPIODATA   "a.standby.gpio_data"
+
+#ifndef CONFIG_SIGBLOCK_SUPPORT
+#define ISAIDE_SHIFT		0
+#define BMIDE_SHIFT		1
+#define PCIHOST_SHIFT		2
+#define ETHERNET_SHIFT		3
+#define IR_SHIFT		4
+#define FIP_SHIFT		5	
+#define I2CM_SHIFT		6
+#define I2CS_SHIFT		7
+#define SDIO_SHIFT		8
+#define USB_SHIFT		9
+#define PCI1_SHIFT		10
+#define PCI2_SHIFT		11
+#define PCI3_SHIFT		12
+#define PCI4_SHIFT		13
+#define PCI5_SHIFT		14
+#define PCI6_SHIFT		15
+#define SATA_SHIFT		16
+#define SCARD_SHIFT		17
+#define GNET_SHIFT		18
+#if defined(CONFIG_TANGO3)
+#define SCARD1_SHIFT		19
+#define ETHERNET1_SHIFT		20
+#define SDIO1_SHIFT		21
+#endif
+#endif
+
+/* Only used internally for LR_XENV2_RW and LR_XENV2_RO. Will be prefixed with z. when read off pfla */
+#if defined(CONFIG_TANGO3)
+/* lrrw */
+#define XENV_LRRW_ETH_MACL	     "lrrw.maclo"
+#define XENV_LRRW_ETH_MACH	     "lrrw.machi"
+#define XENV_LRRW_ETH1_MACL	     "lrrw.mac1lo"
+#define XENV_LRRW_ETH1_MACH	     "lrrw.mac1hi"
+#define XENV_LRRW_KERNEL_END	     "lrrw.kend"
+
+#define XENV_LRRW_RUAMM0_GA          "lrrw.ruamm0_ga"
+#define XENV_LRRW_RUAMM1_GA          "lrrw.ruamm1_ga"
+
+#define XENV_LRRW_0_UZDATA_OFFSET    "lrrw.0.uzdata_offset"
+#define XENV_LRRW_0_ZDATA_OFFSET     "lrrw.0.zdata_offset"
+#define XENV_LRRW_0_DSP_OFFSET       "lrrw.0.dsp_offset"
+#define XENV_LRRW_0_XPU_OFFSET       "lrrw.0.xpu_offset"
+#define XENV_LRRW_1_UZDATA_OFFSET    "lrrw.1.uzdata_offset"
+#define XENV_LRRW_1_ZDATA_OFFSET     "lrrw.1.zdata_offset"
+#define XENV_LRRW_1_DSP_OFFSET       "lrrw.1.dsp_offset"
+#define XENV_LRRW_1_XPU_OFFSET       "lrrw.1.xpu_offset"
+
+#define XENV_LRRW_CHANNEL_INDEX_GA   "lrrw.channel_index_ga"
+#define XENV_LRRW_CHANNEL_INDEX_SIZE "lrrw.channel_index_size"
+#define XENV_LRRW_IOS_GA             "lrrw.ios_ga"
+#define XENV_LRRW_IOS_SIZE           "lrrw.ios_size"
+#define XENV_LRRW_XOS_PUBLIC_GA      "lrrw.xos_public_ga"
+#define XENV_LRRW_XOS_PUBLIC_SIZE    "lrrw.xos_public_size"
+#define XENV_LRRW_IHAPI_GA           "lrrw.ihapi_ga"
+#define XENV_LRRW_MM_VERSION         "lrrw.mm_version"
+
+/* For handshaking and setup purpose */
+#define XENV_HS_RUAMM0_OFFSET	     "a.ruamm0_offset"
+#define XENV_HS_RUAMM1_OFFSET	     "a.ruamm1_offset"
+#define XENV_HS_XOS_PUBLIC_SIZE      "a.xos_public_size"
+#define XENV_HS_IOS_SIZE	     "a.ios_size"
+
+/* lrro */
+#define XENV_LRRO_LOCKED	     "lrro.locked"
+
+#endif
+
+#endif
+
diff -Naur linux-3.9.2.ref/arch/mips/tangox/zxenv.c linux-3.9.2/arch/mips/tangox/zxenv.c
--- linux-3.9.2.ref/arch/mips/tangox/zxenv.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/arch/mips/tangox/zxenv.c	2013-07-23 19:31:23.000000000 +0200
@@ -0,0 +1,159 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2010
+ Sigma Designs, Inc. 
+ 
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/poll.h>
+#include <linux/module.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <asm/io.h>
+
+#if defined(CONFIG_TANGO3)
+#include <asm/tango3/tango3_gbus.h>
+#include <asm/tango3/hardware.h>
+#else
+#error "Unsupported platform"
+#endif
+
+#include "xenv.h"
+
+/* The major device number and name */
+#define ZXENV_DEV_MAJOR		0
+#define ZXENV_DEV_NAME		"zxenv"
+
+extern unsigned long tangox_zxenv[];
+
+MODULE_DESCRIPTION("TANGOX zxenv driver\n");
+MODULE_AUTHOR("TANGOX standalone team");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0");
+
+/* Some prototypes */
+static int zxenv_open(struct inode *, struct file *);
+static int zxenv_release(struct inode *, struct file *);
+static int zxenv_read(struct file *, char *, size_t, loff_t *);
+
+static int major_num = ZXENV_DEV_MAJOR;
+module_param(major_num, int, 0);
+
+/* Global data */
+static char *zxenv_devname = ZXENV_DEV_NAME;
+
+static struct file_operations zxenv_fops = {
+	open: zxenv_open,
+	read: zxenv_read,
+	release: zxenv_release,
+	owner: THIS_MODULE,
+};
+
+static struct cdev cdev;
+static struct class *zxenv_class;
+
+extern int xenv_get(u32 *base, u32 size, char *recordname, void *dst, u32 *datasize);
+
+/* Getting xenv */
+int zxenv_get(char *recordname, void *dst, u32 *datasize)
+{
+	int xenv_size = *((int *)tangox_zxenv);
+	int res = xenv_get((u32 *)&tangox_zxenv[0], xenv_size, recordname, dst, datasize);
+
+	return (res < 0) ? -EIO : res;
+}
+
+EXPORT_SYMBOL(zxenv_get);
+
+/* Reading data */
+static int zxenv_read(struct file *fptr, char *bufptr, size_t size, loff_t *fp)
+{
+	int xenv_size = *((int *)tangox_zxenv);
+
+	if (size < xenv_size)
+		return -EIO;
+
+	/* Get the data to user */
+	if (copy_to_user(bufptr, (char *)&tangox_zxenv[0], xenv_size)) 
+		return -EFAULT;
+
+	return xenv_size;
+}
+
+/* Open the device */
+static int zxenv_open(struct inode *inode_ptr, struct file *fptr)
+{
+	return 0;
+}
+
+/* Close the device */
+static int zxenv_release(struct inode *inode_ptr, struct file *fptr) 
+{
+	return 0;
+}
+
+int __init zxenv_init_module(void)
+{
+	int status = 0;
+	dev_t devid;
+
+	/* Register device, and may be allocating major# */
+	if (major_num) {
+		devid = MKDEV(major_num, 0);
+		status = register_chrdev_region(devid, 1, "zxenv");
+	} else {
+		status = alloc_chrdev_region(&devid, 0, 1, "zxenv");
+		major_num = MAJOR(devid);
+	}
+
+	if (status < 0) {
+		printk(KERN_ERR "%s: cannot get chrdev_region\n", zxenv_devname);
+		return status;
+	}
+
+	cdev_init(&cdev, &zxenv_fops);
+	cdev.owner = THIS_MODULE;
+	cdev.ops = &zxenv_fops;
+	if ((status = cdev_add(&cdev, devid, 1)) < 0) {
+		printk(KERN_ERR "%s: cannot get major number\n", zxenv_devname); 
+		unregister_chrdev_region(MKDEV(major_num, 0), 1);
+		return status;
+	}
+	if (IS_ERR(zxenv_class = class_create(THIS_MODULE, "zxenv_device"))) {
+		printk(KERN_ERR "%s: error creating zxenv_device class.\n", zxenv_devname);
+		cdev_del(&cdev);
+		unregister_chrdev_region(MKDEV(major_num, 0), 1);
+		return -EIO;
+	}
+	if (device_create(zxenv_class, NULL, MKDEV(major_num, 0), NULL, "zxenv") == NULL) {
+		printk(KERN_ERR "%s: error creating zxenv_device.\n", zxenv_devname);
+		class_destroy(zxenv_class);
+		cdev_del(&cdev);
+		unregister_chrdev_region(MKDEV(major_num, 0), 1);
+		return(-EIO);
+	}
+
+	printk(KERN_INFO "SMP86xx %s (%d:0): driver loaded.\n", zxenv_devname, major_num);
+	return 0;
+}
+
+void __exit zxenv_cleanup_module(void)
+{
+	device_destroy(zxenv_class, MKDEV(major_num, 0));
+	class_destroy(zxenv_class);
+	cdev_del(&cdev);
+	unregister_chrdev_region(MKDEV(major_num, 0), 1);
+
+	printk(KERN_INFO "%s: driver unloaded\n", zxenv_devname);
+}
+
+module_init(zxenv_init_module);
+module_exit(zxenv_cleanup_module);
+
diff -Naur linux-3.9.2.ref/drivers/ata/Kconfig linux-3.9.2/drivers/ata/Kconfig
--- linux-3.9.2.ref/drivers/ata/Kconfig	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/drivers/ata/Kconfig	2013-07-23 19:31:11.000000000 +0200
@@ -150,6 +150,13 @@
 
 comment "SFF controllers with custom DMA interface"
 
+config SATA_TANGOX
+	tristate "SMP864x/SMP865x/SMP867x/SMP89xx Embedded SATA support"
+	depends on TANGO3 || TANGO4 
+	help
+	  This option enables SATA support for Sigma Designs' 
+	  SMP864x/SMP865x/SMP867x/SMP89xx chips.
+	  
 config PDC_ADMA
 	tristate "Pacific Digital ADMA support"
 	depends on PCI
diff -Naur linux-3.9.2.ref/drivers/ata/Makefile linux-3.9.2/drivers/ata/Makefile
--- linux-3.9.2.ref/drivers/ata/Makefile	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/drivers/ata/Makefile	2013-07-23 19:31:11.000000000 +0200
@@ -12,6 +12,7 @@
 obj-$(CONFIG_SATA_HIGHBANK)	+= sata_highbank.o libahci.o
 
 # SFF w/ custom DMA
+obj-$(CONFIG_SATA_TANGOX)	+= sata_tangox.o
 obj-$(CONFIG_PDC_ADMA)		+= pdc_adma.o
 obj-$(CONFIG_PATA_ARASAN_CF)	+= pata_arasan_cf.o
 obj-$(CONFIG_PATA_OCTEON_CF)	+= pata_octeon_cf.o
diff -Naur linux-3.9.2.ref/drivers/ata/sata_tangox.c linux-3.9.2/drivers/ata/sata_tangox.c
--- linux-3.9.2.ref/drivers/ata/sata_tangox.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/drivers/ata/sata_tangox.c	2013-07-23 19:31:11.000000000 +0200
@@ -0,0 +1,1549 @@
+/*********************************************************************
+ Copyright (C) 2001-2010
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/*
+ * Driver for SMP864x/SMP865x builtin SATA Based on Synopsys DW SATA Host Core 
+ * device driver and Linux libata driver support layer.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/blkdev.h>
+#include <linux/libata.h>
+#include <linux/export.h>
+#include <linux/module.h>
+#include <linux/hdreg.h>
+#include <scsi/scsi_host.h>
+#include <scsi/scsi.h>
+#include <scsi/scsi_device.h>
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_tcq.h>
+#include <asm/scatterlist.h>
+#if defined(CONFIG_TANGO3)
+#include <asm/tango3/hardware.h>
+#include <asm/tango3/tango3api.h>
+#elif defined(CONFIG_TANGO4)
+#include <asm/tango4/hardware.h>
+#include <asm/tango4/tango4api.h>
+#else
+#error "not supported platform."
+#endif
+#include "libata.h"
+
+#define HSATA_TANGOX_DMA
+#undef HSATA_VERBOSE
+
+MODULE_AUTHOR ("Sigma Designs Inc.");
+MODULE_DESCRIPTION ("TANGOX Bulid-in SATA Host Controller device driver");
+MODULE_LICENSE ("GPL");
+
+#define DRV_NAME0			"pciTangoxSATA0"
+#define DRV_NAME1			"pciTangoxSATA1"
+#define DRIVER_VERSION			"1.3"
+
+/*HSATA Registers*/
+#define HSATA_SCR0_REG			0x0024
+#define HSATA_SCR1_REG			0x0028
+#define HSATA_SCR2_REG			0x002C
+#define HSATA_SCR3_REG			0x0030
+#define HSATA_SCR4_REG			0x0034
+#define HSATA_SERROR_REG		HSATA_SCR1_REG
+#define HSATA_SCONTROL_REG		HSATA_SCR2_REG
+#define HSATA_SACTIVE_REG		HSATA_SCR3_REG
+
+#define HSATA_DMACR_TX_EN		(0x01 /*| HSATA_DMACR_TXMODE_BIT*/)
+#define HSATA_DMACR_RX_EN		(0x02 /*| HSATA_DMACR_TXMODE_BIT*/)
+#define HSATA_DMACR_TXRX_EN		(0x03 | HSATA_DMACR_TXMODE_BIT)
+#define HSATA_DMACR_TXMODE_BIT		0x04
+#define HSATA_FEAT_REG			0x0004
+#define HSATA_CMD_REG			0x001c
+#define HSATA_CONTROL_REG		0x0020
+#define HSATA_DMACR_REG			0x0070
+#define HSATA_DBTSR_REG			0x0074
+#define HSATA_INTPR_REG			0x0078
+#define HSATA_INTPR_ERR_BIT		0x00000008
+#define HSATA_INTPR_FP_BIT		0x00000002	/* new DMA setup FIS arrived */
+#define HSATA_INTMR_REG			0x007C
+#define HSATA_INTMR_ERRM_BIT		0x00000008
+#define HSATA_INTMR_NEWFP_BIT		0x00000002
+#define HSATA_ERRMR_REG			0x0080
+#define HSATA_ERRMR_BITS		0xFFFEF7FF
+#define HSATA_VER_REG			0x00F8
+#define HSATA_IDR_REG			0x00FC
+#define TANGOX_SATA0_BASE		KSEG1ADDR(REG_BASE_host_interface + 0x3000) 
+#define TANGOX_SATA1_BASE		KSEG1ADDR(REG_BASE_host_interface + 0x3800) 
+#define TANGOX_SATA0_CTL_BASE		KSEG1ADDR(REG_BASE_host_interface + 0x4000) 
+#define TANGOX_SATA1_CTL_BASE		KSEG1ADDR(REG_BASE_host_interface + 0x4040) 
+#ifdef CONFIG_TANGO4
+#define TANGOX_SATA_IRQ0		(IRQ_CONTROLLER_IRQ_BASE + LOG2_HOST_HSATA0_INT)
+#define TANGOX_SATA_DMA_IRQ0		(IRQ_CONTROLLER_IRQ_BASE + LOG2_HOST_HSATA0_DMA_INT)
+#define TANGOX_SATA_IRQ1		(IRQ_CONTROLLER_IRQ_BASE + LOG2_HOST_HSATA1_INT)
+#define TANGOX_SATA_DMA_IRQ1		(IRQ_CONTROLLER_IRQ_BASE + LOG2_HOST_HSATA1_DMA_INT)
+#else
+#define TANGOX_SATA_IRQ0		(IRQ_CONTROLLER_IRQ_BASE + LOG2_CPU_SATA_INT)
+#define TANGOX_SATA_DMA_IRQ0		(IRQ_CONTROLLER_IRQ_BASE + LOG2_CPU_DMASATA_INT)
+#define TANGOX_SATA_IRQ1		(IRQ_CONTROLLER_IRQ_BASE + LOG2_CPU_SATA1_INT)
+#define TANGOX_SATA_DMA_IRQ1		(IRQ_CONTROLLER_IRQ_BASE + LOG2_CPU_DMASATA1_INT)
+#endif
+
+#ifdef CONFIG_TANGO4
+/* registers for HOST Cipher */
+#define HC_KEY_TABLE_ENTRY0		KSEG1ADDR(REG_BASE_host_interface + 0x5200)
+#define HC_KEY_TABLE_ENTRY1		KSEG1ADDR(REG_BASE_host_interface + 0x5204)
+#define HC_KEY_TABLE_ENTRY2		KSEG1ADDR(REG_BASE_host_interface + 0x5208)
+#define HC_KEY_TABLE_ENTRY3		KSEG1ADDR(REG_BASE_host_interface + 0x520C)
+#define HC_KEY_TABLE_ENTRY_CTL_STAT	KSEG1ADDR(REG_BASE_host_interface + 0x5210)
+#define HC_OTP_SETTINGS			KSEG1ADDR(REG_BASE_host_interface + 0x5214)
+#define HC_CIPHER_CONFIGURATION		KSEG1ADDR(REG_BASE_host_interface + 0x5240)
+#define HC_TDES				KSEG1ADDR(REG_BASE_host_interface + 0x5250)
+#define HC_AES				KSEG1ADDR(REG_BASE_host_interface + 0x5270)
+#define HC_RC4				KSEG1ADDR(REG_BASE_host_interface + 0x52C0)
+#define HC_SHA1				KSEG1ADDR(REG_BASE_host_interface + 0x5300)
+#define HC_SATA0_AES_CONFIG		KSEG1ADDR(REG_BASE_host_interface + 0x5290)
+#define HC_SATA1_AES_CONFIG		KSEG1ADDR(REG_BASE_host_interface + 0x52B0)
+#endif
+
+static const int tangox_sata_base[2] = {TANGOX_SATA0_BASE, TANGOX_SATA1_BASE};
+static const int tangox_ctl_base[2] = {TANGOX_SATA0_CTL_BASE, TANGOX_SATA1_CTL_BASE};
+static const int tangox_sata_irq[2] = {TANGOX_SATA_IRQ0, TANGOX_SATA_IRQ1};
+static const int tangox_sata_dma_irq[2] = {TANGOX_SATA_DMA_IRQ0, TANGOX_SATA_DMA_IRQ1};
+static const int tangox_sbox[2] = {SBOX_SATA0, SBOX_SATA1};
+#ifdef CONFIG_TANGO4
+static const int tangox_aes_config[2] = {HC_SATA0_AES_CONFIG, HC_SATA1_AES_CONFIG};
+#endif
+
+/*
+ * Per device data struct
+ */
+struct hsata_device
+{
+	struct device *adev;
+	struct ata_host *host;
+	unsigned long membase;
+	unsigned long ctl_base;
+	int sata_irq;
+	int controller;
+	/* dma */
+	int sbox;
+	int dma_irq;
+	int mbus_pending;	/* mbus dma pending */
+	int dev_pending;	/* device dma pending */
+	unsigned long g_mbus_reg;
+	unsigned int g_next_sg;
+	spinlock_t lock;
+};
+
+#define HSDEV_FROM_HOST_SET(hs) (struct hsata_device*)hs->private_data
+#define HSDEV_FROM_AP(ap) (struct hsata_device*)ap->host->private_data
+#define HSDEV_FROM_QC(qc) (struct hsata_device*)qc->ap->host->private_data
+
+#ifdef HSATA_TANGOX_DMA
+#define TANGOX_BURST_LENGTH_TX	16 
+#define BURST_LENGTH_TX		24 
+#define BURST_LENGTH_RX		4 /* was 64 */
+#define HSATA_DMA_DBTSR		((BURST_LENGTH_RX << 16) | (BURST_LENGTH_TX << 0)) 
+#endif 
+
+/* Throttle to gen1 speed */
+static int gen1only = 0;
+static int disable_ports = 0;
+module_param(disable_ports, int, 0444);
+MODULE_PARM_DESC(disable_ports, "which port to disable (1: disable port 0, 2: disable port 1, 3: both ports)");
+
+/* Interrupt stuff*/
+static void hsata_enable_interrupts(struct hsata_device *hsdev) 
+{ 
+	volatile u32 val32; 
+	unsigned long flags;
+
+	spin_lock_irqsave(&hsdev->lock, flags);
+	/* enable all err interrupts */ 
+	writel(HSATA_ERRMR_BITS, (void *)(hsdev->membase + HSATA_ERRMR_REG)); 
+	val32 = readl((void *)(hsdev->membase + HSATA_INTMR_REG)); 
+	writel(val32 | HSATA_INTMR_ERRM_BIT | HSATA_INTMR_NEWFP_BIT,
+			(void *)(hsdev->membase + HSATA_INTMR_REG)); 
+	val32 = readl((void *)(hsdev->membase + HSATA_INTMR_REG)); 
+	DPRINTK("%s INTMR=0x%x\n", __FUNCTION__, val32);
+	spin_unlock_irqrestore(&hsdev->lock, flags);
+}
+
+static void hsata_disable_interrupts(struct hsata_device *hsdev) 
+{ 
+	volatile u32 val32;
+	unsigned long flags;
+
+	spin_lock_irqsave(&hsdev->lock, flags);
+	/* disable all err interrupts */ 
+	writel(0, (void *)(hsdev->membase + HSATA_INTMR_REG)); 
+	val32 = readl((void *)(hsdev->membase + HSATA_INTMR_REG)); 
+	DPRINTK("%s INTMR=0x%x\n", __FUNCTION__, val32);
+	spin_unlock_irqrestore(&hsdev->lock, flags);
+}
+
+static int hsata_scr_read(struct ata_link *link, unsigned int sc_reg, u32 *val)
+{
+	void __iomem *mmio = (void __iomem *)(link->ap->ioaddr.scr_addr + (sc_reg * 4));
+
+	if (mmio) {
+		*val = readl(mmio);
+		return 0;
+	}
+	return -EINVAL;
+}
+
+static int hsata_scr_write(struct ata_link *link, unsigned int sc_reg, u32 val)
+{
+	void __iomem *mmio = (void __iomem *)(link->ap->ioaddr.scr_addr + (sc_reg * 4));
+
+	if (mmio) {
+		writel(val, mmio);
+		return 0;
+	}
+	return -EINVAL;
+}
+
+static void tangox_sata_init(void)
+{
+	unsigned int val;
+	unsigned int cfg = 0;
+	int tangox_get_sata_channel_cfg(unsigned int *);
+	static int sata_init = 0;
+
+	if (sata_init != 0)
+		return;
+	sata_init = 1;
+
+	tangox_get_sata_channel_cfg(&cfg);
+
+	/* bit14: force gen1? */
+	gen1only = (cfg & (1 << 14)) ? 1 : 0; /* force gen1 speed? */
+
+	val = readl((void *)(TANGOX_SATA0_CTL_BASE + 0x0c));
+
+	/* bit15: internal clock? */
+	if (cfg & (1 << 15))
+		val |= (1 << 24);	/* internal clock routing */
+	else
+		val &= ~(1 << 24);	/* external clock is used */
+	val = (val & 0xff0fffff) | ((cfg & 0x0f00) << 12);	/* TX edge rate control */
+
+	writel(val, (void *)(TANGOX_SATA0_CTL_BASE + 0x0c));
+	DPRINTK("PHY stat1(0x%x)=0x%x\n", TANGOX_SATA0_CTL_BASE + 0x0c, val);
+
+	/* 
+	 bit0: RX SSC port0
+	 bit1: RX SSC port1
+	 bit2: TX SSC port0/1
+	 */
+	writel(0x28903 | ((cfg & 1) ? 0x200 : 0) | ((cfg & 2) ? 0x1000 : 0), 
+		(void *)(TANGOX_SATA0_CTL_BASE + 0x10));
+
+	val = readl((void *)(TANGOX_SATA0_CTL_BASE + 0x14));
+	val &= ~0x7fe;
+	val |= ((cfg & 4) ? 0x400 : 0); /* TX SSC enable or not */
+
+	/* bit7..4: reference clock frequency */
+	switch ((cfg >> 4) & 0xf) {
+		case 0: /* 120MHz ref clock */
+			val |= 0x12c;
+			break;
+		case 2: /* 60MHz ref clock */
+			val |= 0x128;
+			break;
+		case 4: /* 30MHz ref clock */
+			val |= 0x12a;
+			break;
+		case 1: /* 100MHz ref clock */
+			val |= 0x234;
+			break;
+		case 3: /* 50MHz ref clock */
+			val |= 0x230;
+			break;
+		case 5: /* 25MHz ref clock */
+			val |= 0x232;
+			break;
+		default:
+			DPRINTK("Invalid frequency selection specified: %d\n", (cfg >> 4) & 0xf);
+			val |= 0x12c;
+			break;
+	}
+	writel(val, (void *)(TANGOX_SATA0_CTL_BASE + 0x14));
+
+	val = readl((void *)(TANGOX_SATA0_CTL_BASE + 0x10));
+	DPRINTK("PHY stat2(0x%x)=0x%x\n", TANGOX_SATA0_CTL_BASE + 0x10, val);
+	val = readl((void *)(TANGOX_SATA0_CTL_BASE + 0x14));
+	DPRINTK("PHY stat3(0x%x)=0x%x\n", TANGOX_SATA0_CTL_BASE + 0x14, val);
+	val = readl((void *)(TANGOX_SATA0_CTL_BASE + 0x18));
+	DPRINTK("PHY stat4(0x%x)=0x%x\n", TANGOX_SATA0_CTL_BASE + 0x18, val);
+	val |= 1<<16; /* fast tech */
+	val |= 1<<18; /* 3.3 v */
+	DPRINTK("Setting PHY stat4(0x%x) to 0x%x\n", (TANGOX_SATA0_CTL_BASE + 0x18), val);
+	writel(val, (void *)(TANGOX_SATA0_CTL_BASE + 0x18));
+	val = readl((void *)(TANGOX_SATA0_CTL_BASE + 0x18));
+	DPRINTK("PHY stat4(0x%x)=0x%x\n", TANGOX_SATA0_CTL_BASE + 0x18, val);
+}
+
+static int hsata_qc_complete(struct ata_port *ap, struct ata_queued_cmd *qc,
+					u32 check_status)
+{
+	u8 status = 0;
+	int i;
+
+	if (check_status) {
+		/* check altstatus */
+		i = 0;
+		do {
+			/* check main status, clearing INTRQ */
+			status = ata_sff_check_status(ap);
+			DPRINTK("STATUS (0x%x) [%d]\n", status, i);
+			if (status & ATA_BUSY)	{
+				DPRINTK("STATUS BUSY (0x%x) [%d]\n", status, i);
+			}
+			if (++i > 10)
+				break;
+		} while (status & ATA_BUSY);
+
+		if (status & (ATA_BUSY | ATA_ERR | ATA_DF)) {
+			DPRINTK("STATUS BUSY/ERROR (0x%x) [%d]\n", status, i);
+		}
+	}
+	DPRINTK("QC COMPLETE status=0x%x ata%u: protocol %d\n", 
+			status, ap->print_id, qc->tf.protocol);
+
+	/* complete taskfile transaction */
+	qc->err_mask |= ac_err_mask(status);
+	ata_qc_complete(qc);
+
+	return 0;
+}
+
+#ifdef HSATA_TANGOX_DMA
+static void hsata_mbus_done(int irq, void *arg)
+{
+	unsigned long flags;
+	struct hsata_device *hsdev = (struct hsata_device *)arg;
+
+	spin_lock_irqsave(&hsdev->lock, flags);
+	hsdev->mbus_pending = 0; /* mbus is done */
+	if (hsdev->dev_pending == 0) { /* free up channel if device is done as well */
+		if (hsdev->g_mbus_reg != 0) {
+			em86xx_mbus_free_dma(hsdev->g_mbus_reg, hsdev->sbox);
+			hsdev->g_mbus_reg = 0;
+		}
+	}
+	spin_unlock_irqrestore(&hsdev->lock, flags);
+}
+
+static void hsata_mbus_intr(int irq, void *arg)
+{
+	struct ata_queued_cmd *qc = (struct ata_queued_cmd *)arg;
+	struct scatterlist *sg = NULL;
+	struct hsata_device *hsdev = NULL;
+	unsigned long flags = 0;
+
+	if (unlikely((qc->sg == NULL) || (qc->ap == NULL) || (qc->ap->host == NULL)))
+		goto err_out;
+	else if (unlikely((hsdev = (struct hsata_device *)HSDEV_FROM_QC(qc)) == NULL))
+		goto err_out;
+
+	spin_lock_irqsave(&hsdev->lock, flags);
+	if (unlikely(hsdev->g_mbus_reg == 0)) /* likely due to ATA error */
+		goto done;
+	BUG_ON(hsdev->g_next_sg == qc->n_elem);
+	/*
+	 * setup a new mbus transfer
+	 */
+	sg = &qc->sg[hsdev->g_next_sg];
+	hsdev->g_next_sg++;
+#ifdef HSATA_VERBOSE
+	printk("(%d) %s setup_dma g_mbus_reg =0x%lx address=0x%x len=0x%x n_elem=0x%x g_next_sg=0x%x\n", smp_processor_id(),
+			__FUNCTION__, hsdev->g_mbus_reg, sg_dma_address(sg), sg_dma_len(sg),
+			qc->n_elem, hsdev->g_next_sg);
+#endif
+	if (hsdev->g_next_sg == qc->n_elem) {
+		if (em86xx_mbus_setup_dma(hsdev->g_mbus_reg, sg_dma_address(sg),
+					sg_dma_len(sg), hsata_mbus_done, hsdev, 1)) {
+			printk("(%d) fail to resetup dma, wait for timeout...\n", smp_processor_id());
+		}
+	} else {
+		if (em86xx_mbus_setup_dma(hsdev->g_mbus_reg, sg_dma_address(sg),
+					sg_dma_len(sg), hsata_mbus_intr, qc, 0)) {
+			printk("(%d) fail to resetup dma, wait for timeout...\n", smp_processor_id());
+		}
+	}
+done:
+	spin_unlock_irqrestore(&hsdev->lock, flags);
+err_out:
+	return;
+}
+
+static irqreturn_t hsata_dma_isr(int irq, void *dev_id)
+{
+	struct ata_host *host = (struct ata_host *)dev_id;
+	struct hsata_device *hsdev = HSDEV_FROM_HOST_SET(host);
+	unsigned long flags;
+
+ 	spin_lock_irqsave(&host->lock, flags);
+	if (readl((void *)(hsdev->ctl_base+0x08))) {
+#ifdef HSATA_VERBOSE
+		printk("(%d) %s got dma interrupt irq=0x%x, 08=0x%x\n", smp_processor_id(), 
+			__FUNCTION__, irq, readl((void *)(hsdev->ctl_base+0x08)));
+#endif
+		/*clear dma interrupt*/
+		writel(0, (void *)(hsdev->ctl_base+0x08));
+		writel(0, (void *)(hsdev->membase + HSATA_DMACR_REG));
+	}
+
+	spin_unlock_irqrestore(&host->lock, flags);
+	return IRQ_HANDLED;
+}
+
+static unsigned long get_dma_len(struct ata_queued_cmd *qc)
+{
+	unsigned long len = 0;
+	struct scatterlist *sg;
+	unsigned int si;
+
+	for_each_sg(qc->sg, sg, qc->n_elem, si) {
+		len += sg_dma_len(sg);
+	}
+
+	return len;
+}
+
+static void hsata_dma_xfer_complete(struct ata_host *host, u32 check_status)
+{
+	struct ata_port *ap;
+	struct ata_queued_cmd *qc;
+	u8 tag = 0;
+	unsigned long flags;
+	struct hsata_device *hsdev;
+
+	ap = host->ports[0];
+	tag = ap->link.active_tag;
+	qc = ata_qc_from_tag(ap, tag);
+	hsdev = HSDEV_FROM_QC(qc);
+
+	DPRINTK("active_tag=%d protocol=%d qc=0x%x \n", tag, qc->tf.protocol, qc);
+
+	switch (qc->tf.protocol) {
+		case ATA_PROT_DMA:
+		case ATAPI_PROT_DMA:
+			spin_lock_irqsave(&hsdev->lock, flags);
+			hsdev->dev_pending = 0; /* device is done */
+			if (hsdev->mbus_pending == 0) { /* free up channel if mbus is done as well */
+				if (hsdev->g_mbus_reg != 0) {
+					em86xx_mbus_free_dma(hsdev->g_mbus_reg, hsdev->sbox);
+					hsdev->g_mbus_reg = 0;
+				}
+			}
+			spin_unlock_irqrestore(&hsdev->lock, flags);
+			dma_unmap_sg((struct device *)qc->dev, qc->sg, qc->n_elem, qc->dma_dir);
+
+			/* !!! FALL THRU TO NEXT CASE !!! */
+		case ATAPI_PROT_PIO:	
+			if (unlikely(hsata_qc_complete(ap, qc, check_status)))
+					;
+	 		break;
+	
+		case ATAPI_PROT_NODATA: 
+		case ATA_PROT_NODATA:
+			DPRINTK(KERN_ERR "WE SHOULDN'T GET HERE");
+			break;
+	}
+}
+#endif
+
+static irqreturn_t hsata_isr(int irq, void *dev_instance)
+{
+	struct ata_host *host = (struct ata_host*)dev_instance;
+	struct hsata_device *hsdev = HSDEV_FROM_HOST_SET(host);
+	unsigned int handled = 0;
+	struct ata_port *ap;
+	struct ata_queued_cmd *qc;
+	unsigned long flags, flgs;
+	u8 status = 0;
+	volatile u32 val32;
+	volatile u32 intpr;
+	u32 err_interrupt;
+	u32 tag_mask;
+	volatile u32 sactive, sactive2;
+	u8 tag;
+	int abort = 0, freeze = 0;
+
+	spin_lock_irqsave(&host->lock, flags);
+	ap = host->ports[0];
+
+	/* clear all*/
+	intpr = readl((void *)(hsdev->membase + HSATA_INTPR_REG));
+	writel(intpr, ((void *)hsdev->membase + HSATA_INTPR_REG));
+
+	if (intpr & HSATA_INTPR_ERR_BIT) {
+		val32 = readl((void *)(hsdev->membase + HSATA_SERROR_REG)); 
+		DPRINTK("SERROR=0x%08x INTPR=0x%x\n", val32, intpr);
+		/* hotplug */
+		if (val32 & (SERR_PHYRDY_CHG | SERR_DEV_XCHG)) {
+			struct ata_link *link;
+			struct ata_eh_info *ehi;
+
+			link = &ap->link;
+			ehi = &link->eh_info;
+			ata_ehi_clear_desc(ehi);
+
+			ata_ehi_hotplugged(ehi);
+			ata_ehi_push_desc(ehi, "%s",
+				val32 & SERR_PHYRDY_CHG ?
+				"PHY RDY changed" : "device exchanged");
+			freeze = 1;	
+		}
+
+		writel(val32, (void *)(hsdev->membase + HSATA_SERROR_REG));	/* to clear */
+		err_interrupt = 1;
+		handled = 1;
+		goto DONE;
+	}
+	else
+		err_interrupt = 0;
+
+	/* 
+	 * ACTIVE TAG
+	 * At this point we need to figure out for which tags we have gotten a
+	 * completion interrupt. One interrupt may serve as completion for 
+	 * more than one operation when commands are queued (NCQ).
+	 * We need to process each completed command.
+	 */
+PROCESS:	/* process completed commands */
+	sactive = readl((void *)(hsdev->membase + HSATA_SACTIVE_REG));	/* remaining pending */
+	if (sactive)
+		DPRINTK("UNEXPECTED SACTIVE??? sactive=0x%x\n", sactive);
+	tag = ap->link.active_tag;
+	if (!(ata_tag_valid(tag))) {
+		printk("(%d) invalid tag 0x%x\n", smp_processor_id(), tag);
+		handled = 1;
+		goto DONE;
+	}
+	tag_mask = 0x01 << tag;
+	/* 
+	 * Check main status, clearing INTRQ 
+	 */
+	status = ata_sff_check_status(ap); 
+	DPRINTK("status=0x%x err_interrupt=0x%x\n", status, err_interrupt);
+
+	if (!err_interrupt && (status & ATA_BUSY)) {
+		DPRINTK("NOT OUR INTERRUPT - STATUS BUSY (0x%x) INTPR=0x%x\n", status, intpr);
+		goto NOTOURINT;
+	}
+
+	tag = 0;
+	while (tag_mask) {
+		while (!(tag_mask & 0x01)) {
+			tag++;
+			tag_mask >>= 1;
+		}
+		tag_mask &= (~0x01);
+
+		qc = ata_qc_from_tag(ap, tag);
+		if (unlikely(!qc)) {
+			printk("(%d) qc is null\n", smp_processor_id());
+			handled = 1;
+			goto DONE;
+		}
+		 /* to be picked up by downstream completion functions */
+		qc->ap->link.active_tag = tag; 
+
+		if (status & ATA_ERR) {
+			DPRINTK("INTERRUPT ATA_ERR (0x%x)\n", status);
+#ifdef HSATA_TANGOX_DMA
+			spin_lock_irqsave(&hsdev->lock, flgs);
+			if ((hsdev->dev_pending != 0) || (hsdev->mbus_pending != 0)) {
+				hsdev->dev_pending = hsdev->mbus_pending = 0;
+				if (hsdev->g_mbus_reg != 0) {
+					em86xx_mbus_wait(hsdev->g_mbus_reg, hsdev->sbox);
+					em86xx_mbus_free_dma(hsdev->g_mbus_reg, hsdev->sbox);
+					hsdev->g_mbus_reg = 0;
+				}
+			}
+			spin_unlock_irqrestore(&hsdev->lock, flgs);
+#endif
+			hsata_qc_complete(ap, qc, 1);
+			handled = 1;
+			goto DONE;
+		}
+#ifdef HSATA_TANGOX_DMA
+		/* Process completed command*/
+		if ((ap->hsm_task_state ==HSM_ST_LAST) && 
+				(qc->tf.protocol == ATA_PROT_DMA || 
+				 qc->tf.protocol == ATAPI_PROT_DMA))
+			hsata_dma_xfer_complete(host, 1);
+#endif
+		handled = /*ata_sff_host_intr*/ ata_bmdma_port_intr(ap, qc);
+		if (handled == 1)
+			goto DONE;
+	} /* while tag_mask */
+
+	/*
+	 * Check to see if any commands completed while we were processing our initial
+	 * set of completed commands (reading of status clears interrupts, so we might
+	 * miss a completed command interrupt if one came in while we were processing --
+	 * we read status as part of processing a completed command).
+	 */
+	sactive2 = readl((void *)(hsdev->membase + HSATA_SACTIVE_REG));
+	if (sactive2 != sactive) {
+		DPRINTK("MORE COMPLETED - sactive=0x%x sactive2=0x%x\n",
+			sactive, sactive2);
+		goto PROCESS;
+	}
+
+	handled = 1;
+	goto DONE;
+
+NOTOURINT:
+	status = ata_sff_check_status(ap);
+	DPRINTK("NOT OUR INTERRUPT status=0x%x", status);
+	handled = 0;
+DONE:
+	/* freeze or abort */
+	if (freeze)
+		ata_port_freeze(ap);
+	else if (abort) {
+		if (qc)
+			ata_link_abort(qc->dev->link);
+		else
+			ata_port_abort(ap);
+	}
+
+	spin_unlock_irqrestore(&host->lock, flags);
+	return IRQ_RETVAL(handled);
+}
+
+static void hsata_irq_clear(struct ata_port *ap)
+{
+	struct hsata_device *hsdev ;
+	hsdev = HSDEV_FROM_AP(ap);
+
+	/* read status reg to clear interrupt in controller */
+	ata_sff_check_status(ap);
+
+	/* reenable interrupt, for hotplug*/
+	hsata_enable_interrupts(hsdev);
+}
+
+static void hsata_host_init(struct hsata_device *hsdev)
+{
+	unsigned int pid, ver;
+	u32 val32;
+
+	/* Read IDR and Version registers*/
+	pid = readl((void *)(hsdev->membase + HSATA_IDR_REG));
+	ver = readl((void *)(hsdev->membase + HSATA_VER_REG));
+
+	printk("SATA version 0x%x ID 0x%x is detected\n", ver, pid);
+
+	/* some other initializations here*/
+	tangox_sata_init();
+
+	/* Enable IPM */
+	val32 = readl((void *) (hsdev->membase + HSATA_SCR2_REG));
+	writel((val32 & ~(0x3 << 8)), (void *)(hsdev->membase + HSATA_SCR2_REG));
+
+	/*
+	 * We clear this bit here so that we can later on check to see if other bus
+	 * errors occured (during debug of this driver).
+	 */
+	val32 = readl((void *) (hsdev->membase + HSATA_SERROR_REG));
+	writel(val32, (void *)(hsdev->membase + HSATA_SERROR_REG));
+}
+
+static void hsata_setup_port(struct ata_ioports *port, unsigned long base)
+{
+	port->cmd_addr = (void __iomem *)(base + 0x00); 
+	port->data_addr	= (void __iomem *)(base + 0x00);
+
+	port->error_addr = (void __iomem *)(base + 0x04);
+	port->feature_addr = (void __iomem *)(base + 0x04);
+
+	port->nsect_addr = (void __iomem *)(base + 0x08);
+
+	port->lbal_addr	= (void __iomem *)(base + 0x0c);
+	port->lbam_addr	= (void __iomem *)(base + 0x10);
+	port->lbah_addr	= (void __iomem *)(base + 0x14);
+
+	port->device_addr = (void __iomem *)(base + 0x18);
+
+	port->command_addr = (void __iomem *)(base + 0x1c);
+	port->status_addr = (void __iomem *)(base + 0x1c);
+
+	port->altstatus_addr = (void __iomem *)(base + 0x20);
+	port->ctl_addr = (void __iomem *)(base + 0x20);
+	port->scr_addr = (void __iomem *)(base + HSATA_SCR0_REG);
+	port->bmdma_addr = NULL; 
+}
+
+static void hsata_reset_port(struct ata_port *ap)
+{
+	u32 sstatus = 0 ;
+	unsigned long timeout = jiffies + (HZ * 5);
+		
+	struct hsata_device *hsdev ;
+	hsdev = HSDEV_FROM_AP(ap);
+
+	/* hard interface reset */
+	hsata_scr_write(&ap->link, 2, 0x001 | (gen1only << 4));
+	mdelay(1);
+	hsata_scr_write(&ap->link, 2, 0x000 | (gen1only << 4));
+
+	/* wait for phy to become ready, if necessary */
+	do {
+		udelay(10);
+		hsata_scr_read(&ap->link, 0, &sstatus);
+		if ((sstatus & 0xf) != 1)
+			break;
+	} while (time_before(jiffies, timeout));
+
+	/* soft interface reset to reset device */
+	writel(1 << 2, (void *)(hsdev->membase + HSATA_CONTROL_REG)); 
+	mdelay(10);
+}
+
+static int hsata_port_start(struct ata_port *ap)
+{
+	int status = 0, port;
+	struct hsata_device *hsdev ;
+	hsdev = HSDEV_FROM_AP(ap);
+	port = ap->port_no;
+	DPRINTK("id=%d port_num=%d port=0x%x\n", ap->print_id, ap->port_no, port);
+
+	/* Grab ptr to this top-level device data. */
+	hsdev->host = ap->host;
+
+	hsata_reset_port(ap);
+
+#ifdef HSATA_TANGOX_DMA
+	status = request_irq(hsdev->dma_irq, hsata_dma_isr, IRQF_DISABLED,
+				((hsdev->controller == 0) ? "HSATA0-DMA": "HSATA1-DMA"),
+				ap->host); 
+	if (status) {
+		DPRINTK("DMA request_irq FAILED (status = %d) irq=0x%x\n", 
+					status, hsdev->dma_irq);
+		status = -ENOMEM;
+		goto CLEANUP;
+	}
+
+	/* Don't enable yet -- we do that right before a xfer */
+	writel(0/*HSATA_DMACR_TXMODE_BIT*/, (void *)(hsdev->membase + HSATA_DMACR_REG)); 
+
+CLEANUP:
+	if (status) {
+		free_irq(hsdev->dma_irq, ap->host);
+	}
+#endif
+	return status;
+}
+
+static void hsata_port_stop(struct ata_port *ap)
+{
+}
+
+static int hsata_scsi_ioctl(struct scsi_device *scsidev, int cmd, 
+				 void __user *arg)
+{
+	int ret;
+	u8 args[4];
+
+	if (arg == NULL)
+		return -EINVAL;
+
+	if (copy_from_user(args, arg, sizeof(args)))
+		return -EFAULT;
+
+	ret = ata_scsi_ioctl(scsidev, cmd, arg);
+
+	/* HIPM mode*/
+	if (cmd == HDIO_DRIVE_CMD) {
+		u32 serr;
+		struct ata_port *ap;
+		struct hsata_device *hsdev;
+
+		ap = ata_shost_to_port(scsidev->host);
+		hsdev = HSDEV_FROM_AP(ap);
+		
+		if (args[0] == ATA_CMD_STANDBYNOW1 || 
+				args[0] == ATA_CMD_STANDBY) {
+
+			/* put the host in slumber bit 13 or partial mode bit 12*/
+			writel(1 << 13, (void *)(hsdev->membase + HSATA_SCR2_REG));
+
+			/* clear the SError Register */
+			serr = readl((void *)(hsdev->membase + HSATA_SERROR_REG));
+			writel(serr, (void *)(hsdev->membase + HSATA_SERROR_REG));
+
+			writel(0, (void *)(hsdev->membase + HSATA_ERRMR_REG)); 
+		} else if (args[0] == ATA_CMD_IDLEIMMEDIATE || 
+					args[0] == ATA_CMD_IDLE) {
+			/* put the host in active mode, bit 14*/
+			writel(1 << 14, (void *)(hsdev->membase + HSATA_SCR2_REG));
+
+			/* clear the SError Register */
+			serr = readl((void *)(hsdev->membase + HSATA_SERROR_REG));
+			writel(serr, (void *)(hsdev->membase + HSATA_SERROR_REG)); 
+
+			writel(HSATA_ERRMR_BITS, (void *)(hsdev->membase + HSATA_ERRMR_REG)); 
+		}
+	}
+	return ret;
+}
+
+static struct ata_device *hsata_ata_find_dev(struct ata_port *ap, int id)
+{
+	if (likely(id < ATA_MAX_DEVICES))
+		return &ap->link.device[id];
+	return NULL;
+}
+
+static struct ata_device *hsata_ata_scsi_find_dev(struct ata_port *ap,
+					const struct scsi_device *scsidev)
+{
+	/* skip commands not addressed to targets we simulate */
+	if (unlikely(scsidev->channel || scsidev->lun))
+		return NULL;
+
+	return hsata_ata_find_dev(ap, scsidev->id);
+}
+
+static int hsata_scsi_queuecmd(struct Scsi_Host *shost, struct scsi_cmnd *cmd)
+{
+	struct ata_port *ap;
+	struct ata_device *dev;
+	struct scsi_device *scsidev = cmd->device;
+	int dir, ret;
+	struct hsata_device *hsdev;
+#ifdef HSATA_TANGOX_DMA
+	unsigned long flgs;
+#endif
+
+	ap = ata_shost_to_port(scsidev->host);
+	dev = hsata_ata_scsi_find_dev(ap, scsidev);
+
+#ifdef HSATA_TANGOX_DMA
+	dir = cmd->sc_data_direction;
+	hsdev = HSDEV_FROM_AP(ap);
+
+	spin_lock_irqsave(&hsdev->lock, flgs);
+	if ((hsdev->dev_pending != 0) || (hsdev->mbus_pending != 0)) { /* busy */
+		spin_unlock_irqrestore(&hsdev->lock, flgs);
+		return SCSI_MLQUEUE_HOST_BUSY;
+	}
+
+	if ((scsi_bufflen(cmd) <= 1024) && (dev->class == ATA_DEV_ATAPI)) {
+		dev->flags |= ATA_DFLAG_PIO;
+		DPRINTK("set to PIO mode len=0x%x\n", scsi_bufflen(cmd));
+	} else { 
+		if (em86xx_mbus_alloc_dma(hsdev->sbox, (dir == DMA_FROM_DEVICE) ? 1 : 0, &hsdev->g_mbus_reg, NULL, 0)) {
+			dev->flags |= ATA_DFLAG_PIO;
+			DPRINTK("set to PIO mode len=0x%x\n", scsi_bufflen(cmd));
+		} else {
+			dev->flags &= ~ATA_DFLAG_PIO;
+			DPRINTK("set to DMA mode len=0x%x\n", scsi_bufflen(cmd));
+		}
+	}
+	spin_unlock_irqrestore(&hsdev->lock, flgs);
+#else
+	dev->flags |= ATA_DFLAG_PIO;
+#endif
+
+	DPRINTK("sn=%d\n", cmd->serial_number);
+	ret = ata_scsi_queuecmd(shost, cmd);
+
+#ifdef HSATA_TANGOX_DMA
+	spin_lock_irqsave(&hsdev->lock, flgs);
+	if ((hsdev->dev_pending == 0) && (hsdev->mbus_pending == 0)) { /* no dma in progress, channel can be de-allocated */
+		if (hsdev->g_mbus_reg != 0) {
+			em86xx_mbus_free_dma(hsdev->g_mbus_reg, hsdev->sbox);
+			hsdev->g_mbus_reg = 0;
+		}
+	}
+	spin_unlock_irqrestore(&hsdev->lock, flgs);
+#endif
+
+	return ret;
+}
+static int atapi_drain_needed(struct request *rq)
+{
+	if (likely(rq->cmd_type != REQ_TYPE_BLOCK_PC))
+		return 0;
+
+	if (!blk_rq_bytes(rq) || (rq->cmd_flags & REQ_WRITE))
+		return 0;
+
+	return atapi_cmd_type(rq->cmd[0]) == ATAPI_MISC;
+}
+
+/* the same as ata_scsi_slave_config, remove later one */
+static int tangox_ata_scsi_slave_config(struct scsi_device *sdev)
+{
+	struct ata_port *ap;
+	struct ata_device *dev;
+	struct request_queue *q = sdev->request_queue;
+	
+	ap = ata_shost_to_port(sdev->host);
+	dev = hsata_ata_scsi_find_dev(ap, sdev);
+		
+	sdev->use_10_for_rw = 1;
+	sdev->use_10_for_ms = 1;
+	sdev->no_report_opcodes = 1;
+	sdev->no_write_same = 1;
+	sdev->max_device_blocked = 1;
+	
+	
+	if (!ata_id_has_unload(dev->id))
+		dev->flags |= ATA_DFLAG_NO_UNLOAD;
+		
+	/* configure max sectors */
+	blk_queue_max_hw_sectors(q, 2*ATA_MAX_SECTORS);
+
+	if (dev->class == ATA_DEV_ATAPI) {
+		void *buf;
+
+		sdev->sector_size = ATA_SECT_SIZE;
+
+		/* set DMA padding */
+		blk_queue_update_dma_pad(q, ATA_DMA_PAD_SZ - 1);
+
+		/* configure draining */
+		buf = kmalloc(ATAPI_MAX_DRAIN, q->bounce_gfp | GFP_KERNEL);
+		if (!buf) {
+			ata_dev_err(dev, "drain buffer allocation failed\n");
+			return -ENOMEM;
+		}
+
+		blk_queue_dma_drain(q, atapi_drain_needed, buf, ATAPI_MAX_DRAIN);
+		} else {
+		sdev->sector_size = ata_id_logical_sector_size(dev->id);
+		sdev->manage_start_stop = 1;
+		}
+
+		/*
+		* ata_pio_sectors() expects buffer for each sector to not cross
+		* page boundary.  Enforce it by requiring buffers to be sector
+		* aligned, which works iff sector_size is not larger than
+		* PAGE_SIZE.  ATAPI devices also need the alignment as
+		* IDENTIFY_PACKET is executed as ATA_PROT_PIO.
+		*/
+		if (sdev->sector_size > PAGE_SIZE)
+			ata_dev_warn(dev,
+			"sector_size=%u > PAGE_SIZE, PIO may malfunction\n",
+			sdev->sector_size);
+
+		blk_queue_update_dma_alignment(q, sdev->sector_size - 1);
+
+		if (dev->flags & ATA_DFLAG_AN)
+			set_bit(SDEV_EVT_MEDIA_CHANGE, sdev->supported_events);
+
+		if (dev->flags & ATA_DFLAG_NCQ) {
+			int depth;
+
+			depth = min(sdev->host->can_queue, ata_id_queue_depth(dev->id));
+			depth = min(ATA_MAX_QUEUE - 1, depth);
+			scsi_adjust_queue_depth(sdev, MSG_SIMPLE_TAG, depth);
+		}
+
+		blk_queue_flush_queueable(q, false);
+
+		dev->sdev = sdev;
+	
+	return 0;	 /* scsi layer doesn't check return value, sigh */
+}
+
+static int hsata_scsi_slave_cfg(struct scsi_device *sdev)
+{
+	DPRINTK("id=%d lun=%d ch=%d mfgr=%d\n", 
+		sdev->id, sdev->lun, sdev->channel, sdev->manufacturer);
+#if 1 
+	return tangox_ata_scsi_slave_config(sdev);
+#else
+	return ata_scsi_slave_config(sdev);
+#endif
+}
+
+static int hsata_std_bios_param(struct scsi_device *sdev, 
+					 struct block_device *bdev,
+					 sector_t capacity, int geom[])
+{
+	DPRINTK("id=%d lun=%d ch=%d mfgr=%d\n", 
+		 sdev->id, sdev->lun, sdev->channel, sdev->manufacturer);
+	return ata_std_bios_param(sdev, bdev, capacity, geom);
+}
+
+
+static void hsata_dev_config(struct ata_device *dev)
+{
+}
+
+static int hsata_set_mode(struct ata_link *link, struct ata_device **r_failed)
+{
+	return 0;
+}
+
+static void hsata_exec_command_by_tag(struct ata_port *ap, const struct ata_taskfile *tf, u8 tag)
+{
+#ifdef HSATA_VERBOSE
+	{
+		volatile u32 val32;
+		struct hsata_device *hsdev = HSDEV_FROM_AP(ap);
+		switch (tf->command) {
+			case ATA_CMD_CHK_POWER		: DPRINTK("ATA_CMD_CHK_POWER - tag=%d\n", tag); break;
+			case ATA_CMD_EDD	 	: DPRINTK("ATA_CMD_EDD - tag=%d\n", tag); break;
+			case ATA_CMD_FLUSH	 	: DPRINTK("ATA_CMD_FLUSH - tag=%d\n", tag); break;
+			case ATA_CMD_FLUSH_EXT		: DPRINTK("ATA_CMD_FLUSH_EXT - tag=%d\n", tag); break;
+			case ATA_CMD_ID_ATA		: DPRINTK("ATA_CMD_ID_ATA - tag=%d\n", tag); break;
+			case ATA_CMD_ID_ATAPI		: DPRINTK("ATA_CMD_ID_ATAPI - tag=%d\n", tag); break;
+			case ATA_CMD_READ		: DPRINTK("ATA_CMD_READ - tag=%d\n", tag); break;
+			case ATA_CMD_READ_EXT		: DPRINTK("ATA_CMD_READ_EXT - tag=%d\n", tag); break;
+			case ATA_CMD_WRITE	 	: DPRINTK("ATA_CMD_WRITE - tag=%d\n", tag); break;
+			case ATA_CMD_WRITE_EXT		: DPRINTK("ATA_CMD_WRITE_EXT - tag=%d\n", tag); break;
+			case ATA_CMD_PIO_READ		: DPRINTK("ATA_CMD_PIO_READ - tag=%d\n", tag); break;
+			case ATA_CMD_PIO_READ_EXT	: DPRINTK("ATA_CMD_PIO_READ_EXT - tag=%d\n", tag); break;
+			case ATA_CMD_PIO_WRITE 		: DPRINTK("ATA_CMD_PIO_WRITE - tag=%d\n", tag); break;
+			case ATA_CMD_PIO_WRITE_EXT 	: DPRINTK("ATA_CMD_PIO_WRITE_EXT - tag=%d\n", tag); break;
+			case ATA_CMD_SET_FEATURES	: DPRINTK("ATA_CMD_SET_FEATURES - tag=%d\n", tag); break;
+			case ATA_CMD_PACKET		: DPRINTK("ATA_CMD_PACKET - tag=%d\n", tag); break;
+			//case HSATA_CMD_QWRITE		: DPRINTK("HSATA_CMD_QWRITE - tag=%d\n", tag); break;
+			//case HSATA_CMD_QREAD		: DPRINTK("HSATA_CMD_QREAD - tag=%d\n", tag); break;
+			default				: DPRINTK("ATA_CMD_??? (0x%X)\n", tf->command); break;
+		}
+		val32 = readl((void *)(hsdev->membase + HSATA_SERROR_REG));
+		DPRINTK("SERROR=0x%X\n", val32);
+		writel(val32, (void *)(hsdev->membase + HSATA_SERROR_REG));
+		val32 = readl((void *)(hsdev->membase + HSATA_INTPR_REG));
+		DPRINTK("INTPR=0x%x\n", val32);
+	}
+#endif 
+
+	ata_sff_exec_command(ap, tf);
+}
+
+static void hsata_exec_command(struct ata_port *ap, const struct ata_taskfile *tf)
+{
+	hsata_exec_command_by_tag(ap, tf, 0);
+}
+
+#ifdef HSATA_TANGOX_DMA
+static u8 hsata_bmdma_status( struct ata_port *ap)
+{
+	return 0;
+}
+
+static void hsata_bmdma_stop(struct ata_queued_cmd *qc)
+{
+}
+
+static int hsata_bmdma_setup_noexec(struct ata_queued_cmd *qc)
+{
+	struct ata_port *ap = qc->ap;
+	struct scatterlist *sg = qc->sg; 
+	int dir;
+	int nents;
+	u32 dma_len = 0, dev_dma_len = 0;
+	u32 dma_addr = 0;
+	struct hsata_device *hsdev = HSDEV_FROM_AP(ap);
+	unsigned long flags;
+
+	dir = qc->dma_dir;
+
+	BUG_ON(hsdev->g_mbus_reg == 0);
+
+	if ((nents = dma_map_sg((struct device *)qc->dev, sg, qc->n_elem, dir)) <= 0) {
+		printk("(%d) dma map sg failed, please check\n", smp_processor_id());
+		return -1;
+	}
+
+	if (dir == DMA_TO_DEVICE) {
+		unsigned int si;
+		for_each_sg(qc->sg, sg, qc->n_elem, si) {
+			dev_dma_len += sg_dma_len(sg);
+		}
+	} else
+		dev_dma_len = get_dma_len(qc);
+
+#ifdef HSATA_VERBOSE
+	printk("(%d) total len=0x%x n_elem=0x%x nents=0x%x dir=0x%x block_len=0x%x dma_len/8k=0x%x\n", smp_processor_id(),
+		 dev_dma_len, qc->n_elem, nents, dir, dev_dma_len / 4, dev_dma_len / (8 * 1024));
+#endif
+
+	/* get the first one*/
+	sg = qc->sg; 
+	dma_len = sg_dma_len(sg);
+	dma_addr= sg_dma_address(sg); 
+#ifdef HSATA_VERBOSE
+	printk("(%d) setup_dma address=0x%x len=0x%x n_elem=0x%x nents=0x%x dir=0x%x block_len=0x%x dma_len/8k=0x%x\n", smp_processor_id(), 
+		 dma_addr, dma_len, qc->n_elem, nents, dir, dma_len / 4, dma_len / (8 * 1024));
+#endif
+
+	spin_lock_irqsave(&hsdev->lock, flags);
+	hsdev->mbus_pending = 1; /* starting mbus operation */
+	hsdev->g_next_sg = 1;
+	if (nents == 1) {
+		if (em86xx_mbus_setup_dma(hsdev->g_mbus_reg, dma_addr, dma_len, hsata_mbus_done, hsdev, 1)) {
+			em86xx_mbus_free_dma(hsdev->g_mbus_reg, hsdev->sbox);
+			hsdev->g_mbus_reg = hsdev->mbus_pending = 0;
+			spin_unlock_irqrestore(&hsdev->lock, flags);
+			return -1;
+		}
+	} else { /* nents > 1 */
+		if (em86xx_mbus_setup_dma(hsdev->g_mbus_reg, dma_addr, dma_len, hsata_mbus_intr, qc, 0)) {
+			em86xx_mbus_free_dma(hsdev->g_mbus_reg, hsdev->sbox);
+			hsdev->g_mbus_reg = hsdev->mbus_pending = 0;
+			spin_unlock_irqrestore(&hsdev->lock, flags);
+			return -1;
+		}
+	}
+
+	hsdev->dev_pending = 1;	/* starting dma operation */
+	writel((dev_dma_len / 4), (void *)(hsdev->ctl_base + 0x04)); /* write length in dword */
+
+	spin_unlock_irqrestore(&hsdev->lock, flags);
+	return 0;
+}
+
+static void hsata_bmdma_setup(struct ata_queued_cmd *qc)
+{
+	if (hsata_bmdma_setup_noexec(qc)== -1)
+		 hsata_reset_port(qc->ap);
+
+	hsata_exec_command(qc->ap, &qc->tf);
+}
+
+static void hsata_bmdma_start(struct ata_queued_cmd *qc)
+{
+	struct hsata_device *hsdev = HSDEV_FROM_QC(qc);
+	int dir = qc->dma_dir;
+#ifdef CONFIG_TANGO4
+	int val;
+#endif
+
+	while (readl((void *)(hsdev->ctl_base + 0x08)))
+		; /* wait for dma cleared */ 
+
+	/* set DBTSR */
+	writel(HSATA_DMA_DBTSR, (void *)(hsdev->membase + HSATA_DBTSR_REG));
+	if (dir == DMA_TO_DEVICE) {
+#ifdef CONFIG_TANGO4
+		/* bypass cipher for writing */
+		val =readl((void *)(tangox_aes_config[hsdev->controller]));
+		val &= ~0xf0;
+		val |= 0x10;
+		writel(val, (void *)(tangox_aes_config[hsdev->controller]));
+#endif
+	 	/* Tx Burst length */
+		writel(TANGOX_BURST_LENGTH_TX, (void *)(hsdev->ctl_base + 0x00));
+		/* Enable Tx*/
+		writel(HSATA_DMACR_TX_EN, (void *)(hsdev->membase + HSATA_DMACR_REG)); 
+	} else {
+#ifdef CONFIG_TANGO4
+		/* bypass cipher for reading */
+		val = readl((void *)(tangox_aes_config[hsdev->controller]));
+		val &= ~0xf0;
+		writel(val, (void *)(tangox_aes_config[hsdev->controller]));
+#endif
+	 	/* Rx Burst length */
+	 	writel(BURST_LENGTH_RX, (void *)(hsdev->ctl_base + 0x00));
+		/* Enable Rx*/
+		writel(HSATA_DMACR_RX_EN, (void *)(hsdev->membase + HSATA_DMACR_REG)); 
+	}
+}
+#endif /* HSATA_TANGOX_DMA */
+
+static void hsata_qc_prep_by_tag(struct ata_queued_cmd *qc, u8 tag)
+{
+#ifdef HSATA_TANGOX_DMA
+	int dir;
+	dir = qc->dma_dir;
+
+	DPRINTK("QC PREP id=%d dma dir=%s n_elem=%d\n", 
+			qc->ap->print_id, 
+			(dir == DMA_FROM_DEVICE) ? "FROM_DEVICE" : "TO_DEVICE",
+			qc->n_elem);
+#else 
+	DPRINTK("QC PREP id=%d n_elem=%d\n", 
+		qc->ap->print_id, 
+		qc->n_elem);
+#endif
+}
+
+static void hsata_qc_prep(struct ata_queued_cmd *qc)
+{
+	hsata_qc_prep_by_tag(qc, 0);
+}
+
+static unsigned int hsata_qc_issue(struct ata_queued_cmd *qc)
+{
+#ifdef HSATA_VERBOSE
+	switch (qc->tf.protocol) {
+		case ATA_PROT_DMA: DPRINTK("ATA_PROT_DMA\n"); break;
+		case ATA_PROT_PIO: DPRINTK("ATA_PROT_PIO\n"); break;
+	}
+#endif 
+	//return ata_sff_qc_issue(qc);
+	return ata_bmdma_qc_issue(qc);
+}
+
+void hsata_error_handler(struct ata_port *ap)
+{
+#ifdef HSATA_TANGOX_DMA
+	struct hsata_device *hsdev = HSDEV_FROM_AP(ap);
+	unsigned long flags;
+	spin_lock_irqsave(&hsdev->lock, flags);
+	if ((hsdev->dev_pending != 0) || (hsdev->mbus_pending != 0)) {
+		hsdev->dev_pending = hsdev->mbus_pending = 0;
+		if (hsdev->g_mbus_reg != 0) {
+			em86xx_mbus_wait(hsdev->g_mbus_reg, hsdev->sbox);
+			em86xx_mbus_free_dma(hsdev->g_mbus_reg, hsdev->sbox);
+			hsdev->g_mbus_reg = 0;
+		}
+	}
+	spin_unlock_irqrestore(&hsdev->lock, flags);
+#endif
+	ata_std_error_handler(ap);
+}
+
+static int hsata_check_atapi_dma(struct ata_queued_cmd *qc)
+{
+	u8 cmnd = qc->scsicmd->cmnd[0];
+
+	if ((cmnd == GPCMD_READ_TOC_PMA_ATIP) || 
+		(cmnd == GPCMD_MODE_SENSE_10)) 
+		return 1;
+	else
+		return 0;
+}
+
+static struct scsi_host_template hsata_sht = {
+	.module			= THIS_MODULE,
+	.name			= DRV_NAME0,
+	.ioctl			= hsata_scsi_ioctl,
+	.queuecommand		= hsata_scsi_queuecmd,
+	.can_queue		= ATA_DEF_QUEUE,
+	.this_id		= ATA_SHT_THIS_ID,
+	.sg_tablesize		= LIBATA_MAX_PRD,
+	.max_sectors		= 2 * ATA_MAX_SECTORS,
+	.cmd_per_lun		= ATA_SHT_CMD_PER_LUN,
+	.emulated		= ATA_SHT_EMULATED,
+	.use_clustering		= ATA_SHT_USE_CLUSTERING,
+	.proc_name		= DRV_NAME0,
+	.dma_boundary		= ATA_DMA_BOUNDARY,
+	.slave_configure	= hsata_scsi_slave_cfg,
+	.slave_destroy		= ata_scsi_slave_destroy,
+	.bios_param		= hsata_std_bios_param,
+};
+
+static struct ata_port_operations hsata_ops = {
+	.inherits		= &ata_bmdma_port_ops,
+	.dev_config		= hsata_dev_config,
+	.set_mode		= hsata_set_mode,
+	.check_atapi_dma	= hsata_check_atapi_dma,
+#ifdef HSATA_TANGOX_DMA
+	.bmdma_setup		= hsata_bmdma_setup,
+	.bmdma_start		= hsata_bmdma_start,
+	.bmdma_stop		= hsata_bmdma_stop,
+	.bmdma_status		= hsata_bmdma_status,
+#endif
+	.qc_prep		= hsata_qc_prep,
+	.qc_issue		= hsata_qc_issue,
+	.freeze			= ata_sff_freeze,
+	.thaw			= ata_sff_thaw,
+	.scr_read		= hsata_scr_read,
+	.scr_write		= hsata_scr_write,
+	.error_handler		= hsata_error_handler,
+	.port_start		= hsata_port_start,
+	.port_stop		= hsata_port_stop,
+	.sff_irq_clear		= hsata_irq_clear,
+	.sff_exec_command	= hsata_exec_command,
+};
+
+static struct ata_port_info hsata_port_info = 
+{
+	.flags	= ATA_FLAG_SATA |	 
+#ifndef HSATA_TANGOX_DMA
+			ATA_DFLAG_PIO |	 /* set to NOT use DMA */
+#endif
+			ATA_DFLAG_LBA48 |	/* READ/WRITE EXT support */
+			0x0,			
+	.pio_mask	= 0x1f, /* pio0-4	- IDENTIFY DEVICE word 63 */
+#ifdef HSATA_TANGOX_DMA
+	.mwdma_mask	= 0x07, /* mwdma0-2	- IDENTIFY DEVICE word 64 */
+	.udma_mask	= 0x7f, /* udma0-6	- IDENTIFY DEVICE word 88 */
+#else
+	.mwdma_mask	= 0x00, 
+	.udma_mask	= 0x00,
+#endif
+	.port_ops	= &hsata_ops,
+};
+
+int hsata_probe(struct device *adev, int controller)
+{
+	int status = 0;
+	int num_ports = 1;
+	struct ata_host *host;
+	struct ata_port *ap;
+	struct hsata_device *hsdev;
+	const struct ata_port_info *ppi[1];
+	unsigned long flags;
+
+	ppi[0] = &hsata_port_info;
+
+	if (adev) {
+		printk("driver=%s\n", 
+			(adev->driver)?
+			((adev->driver->name)?(adev->driver->name):"NO NAME") :
+				"NO DRIVER");
+	} else {
+		printk("NULL dev\n");
+		return -ENODEV;
+	}
+
+	/*
+	 * Device data struct
+	 */
+	if ((hsdev = kzalloc(sizeof(*hsdev), GFP_KERNEL)) == NULL) {
+		status = -ENOMEM;
+		goto CLEANUP;
+	} else if ((host = ata_host_alloc_pinfo(adev, ppi, num_ports)) == NULL) {
+		kfree(hsdev);
+		printk("cannot alloc host port info.\n");
+		return -ENOMEM;
+	}
+
+	spin_lock_init(&hsdev->lock);
+	spin_lock_irqsave(&hsdev->lock, flags);
+	hsdev->adev = adev;
+	hsdev->host = host;
+	hsdev->membase = tangox_sata_base[controller];
+	hsdev->ctl_base = tangox_ctl_base[controller];
+	hsdev->sata_irq = tangox_sata_irq[controller];
+	hsdev->controller = controller;
+	hsdev->g_mbus_reg = 0;
+	hsdev->g_next_sg = 0;
+	hsdev->sbox = tangox_sbox[controller];
+	hsdev->dma_irq = tangox_sata_dma_irq[controller];
+	hsdev->mbus_pending = hsdev->dev_pending = 0;
+	spin_unlock_irqrestore(&hsdev->lock, flags);
+
+	DPRINTK("SATA membase (0x%x)\n", hsdev->membase);
+	DPRINTK("SATA ctl_base (0x%x)\n", hsdev->ctl_base);
+	DPRINTK("SATA sata_irq (0x%x)\n", hsdev->sata_irq);
+	DPRINTK("SATA g_mbus_reg (0x%x)\n", hsdev->g_mbus_reg);
+	DPRINTK("SATA sbox (0x%x)\n", hsdev->sbox);
+	DPRINTK("SATA dma_irq (0x%x)\n", hsdev->dma_irq);	
+
+	host->dev = adev;
+	host->private_data = hsdev;
+
+	ap = host->ports[0];
+	hsata_setup_port(&ap->ioaddr, hsdev->membase);
+
+	/* Init the host controller*/
+	hsata_host_init(hsdev);
+	DPRINTK("hsata_host_init done\n");
+	/*
+	 * Interrupt management for SATA interrupts is done by the libata layer 
+	 * (see ata_device_add). See hsata_port_start() for init of DMAC
+	 * interrupt.
+	 */
+	DPRINTK("start ata_host_activate, status=0x%x irq=0x%x\n", status, hsdev->sata_irq);
+
+	status = ata_host_activate(hsdev->host, hsdev->sata_irq, 
+					hsata_isr, IRQF_DISABLED, &hsata_sht);
+
+	DPRINTK("ata_host_activate done, status=0x%x\n", status);
+
+	hsata_enable_interrupts(hsdev);
+
+CLEANUP:
+	if (status) {
+		dev_set_drvdata(adev, NULL);	/* clear private data ptr */
+
+		if (hsdev && hsdev->adev)		/* decr device ref count */
+			put_device(hsdev->adev);
+
+		if (hsdev) 
+			kfree(hsdev);
+	}
+	DPRINTK("DONE - %s - nports=%d\n", status?"ERROR":"OK", num_ports);
+	return status;
+}
+
+int hsata_probe0(struct device *adev)
+{
+	return hsata_probe(adev, 0);
+}
+
+int hsata_probe1(struct device *adev)
+{
+	return hsata_probe(adev, 1);
+}
+
+static int hsata_remove(struct device *adev, int controller)
+{
+	struct hsata_device *hsdev;
+	struct ata_host *host;
+	struct ata_port *ap;
+
+	DPRINTK("driver=%s\n", 
+		(adev->driver)?
+		((adev->driver->name)?(adev->driver->name):"NO NAME") :
+		"NO DRIVER");
+
+	host = dev_get_drvdata(adev);
+	hsdev = HSDEV_FROM_HOST_SET(host);
+	ap = host->ports[0];
+
+	hsata_disable_interrupts(hsdev);
+	//ata_port_disable(ap);
+
+#ifdef HSATA_TANGOX_DMA
+	free_irq(hsdev->dma_irq, host);
+#endif
+	ata_host_detach(host);
+
+	if (hsdev && hsdev->adev)
+		put_device(hsdev->adev);
+
+	if (hsdev) 
+		kfree(hsdev);
+
+	return 0;
+}
+
+static int hsata_remove0(struct device *adev)
+{
+	hsata_remove(adev, 0);
+	return 0;
+}
+
+static int hsata_remove1(struct device *adev)
+{
+	hsata_remove(adev, 1);
+	return 0;
+}
+
+static struct device_driver hsata_driver0 = {
+	.name	= (char *)DRV_NAME0,
+	.bus	= &platform_bus_type,
+	.probe	= hsata_probe0,
+	.remove	= hsata_remove0,
+};
+
+static struct device_driver hsata_driver1 = {
+	.name	= (char *)DRV_NAME1,
+	.bus	= &platform_bus_type,
+	.probe	= hsata_probe1,
+	.remove	= hsata_remove1,
+};
+
+static void tangox_sata_release_dev(struct device * dev)
+{
+	dev->parent = NULL;
+}
+
+static struct platform_device tangox_sata_device0 = {
+	.name	= (char *)DRV_NAME0,
+	.id	= -1,
+	.dev	= {
+		.release	= tangox_sata_release_dev,
+	},
+	.num_resources	= 0,
+	.resource	= 0,
+};
+
+static struct platform_device tangox_sata_device1 = {
+	.name	= (char *)DRV_NAME1,
+	.id	= -1,
+	.dev	= {
+		.release	= tangox_sata_release_dev,
+	},
+	.num_resources	= 0,
+	.resource	= 0,
+};
+
+static struct platform_device *tangox_platform_devices0[] __initdata = {
+	&tangox_sata_device0,
+};
+
+static struct platform_device *tangox_platform_devices1[] __initdata = {
+	&tangox_sata_device1,
+};
+
+static int __init tangox_hsata_module_init(void)
+{
+	int status = 0;
+	int tangox_sata_enabled(void);
+
+	if (tangox_sata_enabled() == 0) {
+		printk("TangoX SATA support is disabled from XENV.\n");
+		return -EINVAL;
+	}
+
+	if ((disable_ports & 1) == 0) {
+		/* Device 0 registration */
+		status = platform_add_devices(tangox_platform_devices0, 
+							ARRAY_SIZE(tangox_platform_devices0));
+		if (status) {
+			printk("Failed to register device 0.\n");
+			return status;
+		}
+		/* Driver 0 registration*/
+	 	status = driver_register(&hsata_driver0);
+		if (status) {
+			printk("Failed to register driver 0.\n");
+			return status;
+		}
+	}
+
+	if ((disable_ports & 2) == 0) {
+		/* Device 1 registration */
+		status = platform_add_devices(tangox_platform_devices1, 
+							ARRAY_SIZE(tangox_platform_devices1));
+		if (status) {
+			printk("Failed to register device 1.\n");
+			return status;
+		}
+		/* Driver 1 registration*/
+		status = driver_register(&hsata_driver1);
+		if (status) {
+			printk("Failed to register driver 1.\n");
+			return status;
+		}
+	}
+
+	return status;
+}
+
+static void __exit tangox_hsata_module_cleanup(void)
+{
+	if ((disable_ports & 1) == 0) {
+		driver_unregister(&hsata_driver0); 
+		platform_device_unregister(&tangox_sata_device0);
+	}
+
+	if ((disable_ports & 2) == 0) {
+		driver_unregister(&hsata_driver1); 
+		platform_device_unregister(&tangox_sata_device1);
+	}
+}
+
+module_init(tangox_hsata_module_init);
+module_exit(tangox_hsata_module_cleanup);
+
diff -Naur linux-3.9.2.ref/drivers/block/Kconfig linux-3.9.2/drivers/block/Kconfig
--- linux-3.9.2.ref/drivers/block/Kconfig	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/drivers/block/Kconfig	2013-07-23 19:31:17.000000000 +0200
@@ -387,6 +387,24 @@
 	  will prevent RAM block device backing store memory from being
 	  allocated from highmem (only a problem for highmem systems).
 
+config EMBEDDED_RAMDISK
+        bool "Embedded ramdisk"
+        default y
+        depends on BLK_DEV_INITRD=y && INITRAMFS_SOURCE=""
+        help
+          Select this option if you want to build the ramdisk image into the
+          the final kernel binary.
+
+config EMBEDDED_RAMDISK_IMAGE
+        string "File name of the ramdisk"
+        default ""
+        depends on EMBEDDED_RAMDISK=y
+        help
+          This is the filename of the ramdisk image to be built into the
+          kernel.  Relative pathnames are relative to arch/mips/ramdisk/.
+          The ramdisk image is not part of the kernel distribution; you must
+          provide one yourself.
+
 config CDROM_PKTCDVD
 	tristate "Packet writing on CD/DVD media"
 	depends on !UML
diff -Naur linux-3.9.2.ref/drivers/ide/Kconfig linux-3.9.2/drivers/ide/Kconfig
--- linux-3.9.2.ref/drivers/ide/Kconfig	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/drivers/ide/Kconfig	2013-07-23 19:31:07.000000000 +0200
@@ -224,6 +224,22 @@
 
 	  If unsure, say N.
 
+config BLK_DEV_BMIDE_TANGO2
+       select BLK_DEV_IDEDMA_SFF
+       tristate "BMIDE for SMP863x"
+       depends on TANGO2
+       help
+         Enable the support for Bus Mastering IDE controller. 
+
+config BLK_DEV_BMIDE_TANGO2_DMA
+       select SD_CDROM_DMAPACKET if BLK_DEV_IDECD
+       bool "support BMIDE DMA operations"
+       default y
+       depends on BLK_DEV_BMIDE_TANGO2
+       help
+         Enable the DMA support for Bus Mastering IDE controller, which
+	 include support for MDMA and UDMA modes. 
+
 config BLK_DEV_CMD640
 	tristate "CMD640 chipset bugfix/support"
 	depends on X86
diff -Naur linux-3.9.2.ref/drivers/ide/Makefile linux-3.9.2/drivers/ide/Makefile
--- linux-3.9.2.ref/drivers/ide/Makefile	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/drivers/ide/Makefile	2013-07-23 19:31:07.000000000 +0200
@@ -107,6 +107,7 @@
 obj-$(CONFIG_BLK_DEV_IDECS)		+= ide-cs.o
 
 obj-$(CONFIG_BLK_DEV_PLATFORM)		+= ide_platform.o
+obj-$(CONFIG_BLK_DEV_BMIDE_TANGO2)	+= tango2-bmide.o
 
 obj-$(CONFIG_BLK_DEV_IDE_ICSIDE)	+= icside.o
 obj-$(CONFIG_BLK_DEV_IDE_RAPIDE)	+= rapide.o
diff -Naur linux-3.9.2.ref/drivers/ide/tango2-bmide.c linux-3.9.2/drivers/ide/tango2-bmide.c
--- linux-3.9.2.ref/drivers/ide/tango2-bmide.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/drivers/ide/tango2-bmide.c	2013-07-23 19:31:07.000000000 +0200
@@ -0,0 +1,1199 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2009
+ Sigma Designs, Inc. 
+ 
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+  
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/ide.h>
+#include <linux/hdreg.h>
+#include <linux/platform_device.h>
+#include <linux/scatterlist.h>
+#include <asm/tango2/hardware.h>
+#include <asm/tango2/tango2_gbus.h>
+#include <asm/tango2/tango2api.h>
+#include <asm/ide.h>
+
+static DEFINE_SPINLOCK(bmide_tune_chipset_spin_lock);
+
+#define PFX	"tango2_bmide: "
+
+/* some drive cannot use mbus chaining, use bounce buffer instead */
+#undef USE_BOUNCE_BUF
+#ifdef USE_BOUNCE_BUF
+/*maximum = 128 sectors = 2^7 sectors = 2^7 * 2^9 bytes = 2^16 bytes*/
+#define DMA_BOUNCE_BUF_ORDER		(19 - PAGE_SHIFT)	
+static unsigned char *g_bounce_buf = NULL;
+#undef USE_MBUS_MEMCPY
+#endif
+
+/*
+ * helper to access host interface
+ */
+#define HWIF(drive)		((ide_hwif_t *)((drive)->hwif))
+
+#define RD_HOST_REG32(r)	\
+		gbus_read_reg32(REG_BASE_host_interface + (r))
+
+#define WR_HOST_REG32(r, v)	\
+		gbus_write_reg32(REG_BASE_host_interface + (r), (v))
+
+#define RD_HOST_REG8(r)	\
+		gbus_read_reg8(REG_BASE_host_interface + (r))
+
+#define WR_HOST_REG8(r, v)	\
+		gbus_write_reg8(REG_BASE_host_interface + (r), (v))
+
+#define CONFIG_RUNTIME_CLK_CALC
+
+#ifdef CONFIG_RUNTIME_CLK_CALC
+#define TIMING_MARGIN(x) (((x) * 105) / 100) /* add 5% margin */
+
+typedef struct {
+	unsigned long cycle_time;
+	unsigned long active_time;
+	unsigned long recovery_time;
+	unsigned long setup_time;
+	unsigned long hold_time;
+} j2_tim_pio_dma_t;
+
+typedef struct {
+	unsigned long t_zah;//
+	unsigned long t_mli;//
+	unsigned long t_ack;//
+	unsigned long t_env;//
+	unsigned long t_rp;	//
+	unsigned long t_cyc;//
+	unsigned long t_cvh;//
+	unsigned long t_cvs;//
+} j2_tim_udma_t;
+
+static j2_tim_pio_dma_t	j2_pio_timings[] = 
+{
+//	 cycle	, active, recov	, setup	, hold
+	{600	, 165	, 70	, 70	, 30	},
+	{383	, 125	, 70	, 50	, 20	},
+	{240	, 100	, 70	, 30	, 15	},
+	{180	, 80	, 70	, 30	, 10	},
+	{120	, 70	, 25	, 25	, 10	},
+};
+
+static j2_tim_pio_dma_t	j2_dma_timings[] =
+{
+//	 cycle	, active, recov	, setup	, hold
+	{480	, 215	, 215	, 50	, 20	},
+	{150	, 80	, 50	, 30	, 15	},
+	{120	, 70	, 25	, 25	, 10	},
+};
+
+// We round 16.8 to 17 - Ex: mode 5, t_cyc=16.8!!!
+static j2_tim_udma_t j2_udma_timings[] =
+{
+//	 t_zah,  t_mli, t_ack,  t_env,  t_rp,  t_cyc   t_cvh   t_cvs
+	{ 20,	 20,	 20,	20,		160,	120,	  7,	 70	},
+	{ 20,	 20,	 20,	20,		125,	 80,	  7,	 48	},
+	{ 20,	 20,	 20,	20,		100,	 60,	  7,	 31	},
+	{ 20,	 20,	 20,	20,		100,	 45,	  7,	 20	},
+	{ 20,	 20,	 20,	20,		100,	 30,	  7,	  7	},
+	{ 20,	 20,	 20,	20,		 85,	 20,	 10,	 10	},
+	{ 20,	 20,	 20,	20,		 85,	 15,	 10,	 10	},
+	{ 20,	 20,	 20,	20,		 85,	 15,	 10,	 10	},
+};
+
+static unsigned int CalcRegValTiming_PIO_DMA(j2_tim_pio_dma_t *t, unsigned long ide_clock);
+static unsigned int CalcRegValTiming1_UDMA(j2_tim_udma_t *t, unsigned long ide_clock);
+static unsigned int CalcRegValTiming2_UDMA(j2_tim_udma_t *t, unsigned long ide_clock);
+#endif /* CONFIG_RUNTIME_CLK_CALC */
+
+/*
+ * io helpers for PIO access
+ */
+static void tango2_bmide_outb(u8 data, unsigned long port)
+{
+	gbus_write_reg16(port, data);
+}
+
+static void tango2_bmide_outw(u16 data, unsigned long port)
+{
+	gbus_write_reg16(port, data);
+}
+
+static u8 tango2_bmide_inb(unsigned long port)
+{
+	u8 val;
+
+	val = ((u8)(gbus_read_reg16(port) & 0xff));
+	return val;
+}
+
+static u16 tango2_bmide_inw(unsigned long port)
+{
+	u16 val;
+
+	val = ((u16)(gbus_read_reg16(port) & 0xffff));
+	return val;
+}
+#if 0
+static void tango2_bmide_insw(unsigned long port, void *addr, u32 count)
+{
+	while (count--) {
+		*(u16 *)addr = (u16)(gbus_read_reg16(port) & 0xffff);
+		addr += 2;
+	}
+}
+
+static void tango2_bmide_outsw(unsigned long port, void *addr, u32 count)
+{
+	while (count--) {
+		gbus_write_reg16(port, *(u16 *)addr);
+		addr += 2;
+	}
+}
+#endif
+#ifdef CONFIG_BLK_DEV_BMIDE_TANGO2_DMA
+/*
+ * returns closest pio mode timings from given dma speed
+ */
+static u8 dma_2_pio(u8 xfer_rate) {
+
+	switch (xfer_rate) {
+	case XFER_UDMA_6:
+	case XFER_UDMA_5:
+	case XFER_UDMA_4:
+	case XFER_UDMA_3:
+	case XFER_UDMA_2:
+	case XFER_UDMA_1:
+	case XFER_UDMA_0:
+	case XFER_MW_DMA_2:
+	case XFER_PIO_4:
+		return 4;
+
+	case XFER_MW_DMA_1:
+	case XFER_PIO_3:
+		return 3;
+
+	case XFER_SW_DMA_2:
+	case XFER_PIO_2:
+		return 2;
+
+	case XFER_MW_DMA_0:
+	case XFER_SW_DMA_1:
+	case XFER_SW_DMA_0:
+	case XFER_PIO_1:
+	case XFER_PIO_0:
+	case XFER_PIO_SLOW:
+	default:
+		return 0;
+	}
+}
+
+/*
+ * dma related callbacks
+ */
+static unsigned long g_mbus_reg [2] = { 0, 0};
+static unsigned int g_next_sg [2] = { 0, 0 };
+
+static u8 tango2_bmide_dma_sff_read_status(ide_hwif_t *hwif)
+{
+	unsigned long addr = REG_BASE_host_interface + IDECTRL_bmis; 
+	return	tango2_bmide_inb(addr);
+}
+
+static void tango2_bmide_dma_sff_write_status(ide_hwif_t *hwif, u8 val)
+{
+	unsigned long addr = REG_BASE_host_interface + IDECTRL_bmis; 
+	tango2_bmide_outb(val,  addr);
+}
+
+void tango2_bmide_dma_host_set(ide_drive_t *drive, int on)
+{
+	ide_hwif_t *hwif = drive->hwif;
+	u8 unit = drive->dn & 1;
+	u8 dma_stat = tango2_bmide_dma_sff_read_status(hwif);
+	
+	if (on)
+		dma_stat |= (1 << (5 + unit));
+	else
+		dma_stat &= ~(1 << (5 + unit));
+
+	tango2_bmide_dma_sff_write_status(hwif, dma_stat);
+}
+
+static void tango2_mbus_intr(int irq, void *arg)
+{
+	ide_drive_t *drive = (ide_drive_t *)arg;
+	ide_hwif_t *hwif = HWIF(drive);
+	struct ide_cmd *cmd = &hwif->cmd;
+	struct scatterlist *sg;
+
+	if (g_next_sg[drive->dn] == cmd->sg_nents) { /* no more sg */
+		em86xx_mbus_setup_dma(g_mbus_reg[drive->dn], 0, 0, NULL, NULL, 1);
+		return;
+	}
+	/*
+	 * setup a new mbus transfer
+	 */
+	sg = &hwif->sg_table[g_next_sg[drive->dn]];
+	g_next_sg[drive->dn]++;
+
+	if (em86xx_mbus_setup_dma(g_mbus_reg[drive->dn], sg_dma_address(sg), sg_dma_len(sg),
+				  tango2_mbus_intr, drive, 0)) {
+		printk(KERN_ERR PFX "fail to resetup dma, wait "
+		       "for timeout...\n");
+	}
+}
+
+/* Get the I/O size of given request */
+static inline int get_request_size(struct request *rq)
+{
+	unsigned int rq_size;
+	struct bio *bio;
+	
+	for (rq_size = 0, bio = rq->bio; bio != NULL; bio = bio->bi_next)
+		rq_size += bio->bi_size;
+	
+	return rq_size;
+}
+
+static void tango2_bmide_dma_start(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	struct ide_cmd *cmd = &hwif->cmd;
+	struct request *rq;
+	unsigned long val, len;
+
+	rq = hwif->rq;
+	len = get_request_size(rq);
+
+	/* setup IDE DMA transfer len */
+	gbus_write_reg32(REG_BASE_host_interface + IDECTRL_ide_dmalen, len);
+
+	/* enable bus mastering */
+	val = 0x05;
+	if (cmd->sg_dma_direction == DMA_FROM_DEVICE)
+		val |= 0x8;
+
+	WR_HOST_REG32(IDECTRL_bmic, val);
+}
+
+static int tango2_bmide_dma_setup(ide_drive_t *drive, struct ide_cmd *cmd)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	int iswrite ;
+	struct scatterlist *sg = hwif->sg_table;
+	
+	iswrite =  (cmd->tf_flags & IDE_TFLAG_WRITE) ? 1 : 0;
+	
+	/* try to setup dma channel */
+	if (em86xx_mbus_alloc_dma(SBOX_IDEDVD, iswrite ? 0 : 1, &g_mbus_reg[drive->dn],
+				  NULL, 0)) {
+		printk(KERN_ERR PFX "fail to alloc dma, fallback to pio\n");
+		goto fallback_pio;
+	}
+
+	/*
+	 * transfer first segment
+	 */
+	 
+	g_next_sg[drive->dn] = 1;
+
+#ifdef USE_BOUNCE_BUF
+	if ((hwif->sg_nents > 1)) {
+		int i; 
+		unsigned long len = 0, total_len=0, addr;
+		unsigned long buf =  KSEG1ADDR(g_bounce_buf);
+		if (iswrite) { /* write using bounce buffer */
+			for_each_sg(hwif->sg_table, sg, hwif->sg_nents, i) {
+				len = sg_dma_len(sg);
+				addr = (unsigned long) sg_virt(sg);
+#ifndef USE_MBUS_MEMCPY
+				memcpy((void *)buf, (void *)addr, len);
+				mb();
+#else
+				//dma_cache_wback((unsigned long)addr, len);
+				mbus_memcpy(g_mbus_reg, tangox_dma_address(CPHYSADDR(buf)), sg_dma_address(sg), len);
+#endif
+				total_len += len;
+				buf += len;
+			}
+			if (buf > (KSEG1ADDR(g_bounce_buf) + (1 << (DMA_BOUNCE_BUF_ORDER + PAGE_SHIFT)))) {
+				printk("IDE: Bounce buffer is too small to fit requested transfers\n");
+				goto fallback_pio;
+			}
+#ifndef USE_MBUS_MEMCPY
+			mb();
+			dma_cache_wback_inv((unsigned long)g_bounce_buf, total_len);
+#else
+			dma_cache_inv((unsigned long)g_bounce_buf, total_len);
+#endif
+			if (em86xx_mbus_setup_dma(g_mbus_reg, tangox_dma_address(CPHYSADDR(g_bounce_buf)), total_len,
+					   NULL,  drive, 1)) {
+				printk(KERN_ERR PFX "fail to setup dma, fallback to pio\n");
+				em86xx_mbus_free_dma(g_mbus_reg, SBOX_IDEDVD);
+				goto fallback_pio;
+			}
+		} else { /* read using bounce buffer */
+			for (i = 0; i< hwif->sg_nents; i++) {
+				len = sg_dma_len(sg);
+				total_len += len;
+				sg = &hwif->sg_table[g_next_sg];
+				g_next_sg++;
+			}
+			if (em86xx_mbus_setup_dma(g_mbus_reg, tangox_dma_address(CPHYSADDR(g_bounce_buf)), total_len,
+					   NULL,  drive, 1)) {
+				printk(KERN_ERR PFX "fail to setup dma, fallback to pio\n");
+				em86xx_mbus_free_dma(g_mbus_reg, SBOX_IDEDVD);
+				goto fallback_pio;
+			}
+		}
+	} else {
+
+		/*
+		 * setup mbus dma for this address.  we want an mbus interrupt
+		 * only if this is not the last sg element,  so we can refeed
+		 * mbus.
+		 */
+		if (em86xx_mbus_setup_dma(g_mbus_reg, sg_dma_address(sg), sg_dma_len(sg),  NULL , drive, 1)) {
+			printk(KERN_ERR PFX "fail to setup dma, fallback to pio\n");
+			em86xx_mbus_free_dma(g_mbus_reg, SBOX_IDEDVD);
+			goto fallback_pio;
+		}
+	}
+#else
+	/*
+	 * setup mbus dma for this address.  we want an mbus interrupt
+	 * only if this is not the last sg element,  so we can refeed
+	 * mbus.
+	 */
+	if (em86xx_mbus_setup_dma(g_mbus_reg[drive->dn], sg_dma_address(sg),
+				sg_dma_len(sg),
+				(cmd->sg_nents == 1) ? NULL : tango2_mbus_intr,
+				drive,
+				(cmd->sg_nents == 1) ? 1 : 0)) {
+		printk(KERN_ERR PFX "fail to setup dma, fallback to pio\n");
+		em86xx_mbus_free_dma(g_mbus_reg[drive->dn], SBOX_IDEDVD);
+		goto fallback_pio;
+	}
+#endif
+	return 0;
+
+fallback_pio:
+	return 1;
+}
+
+static int tango2_bmide_dma_end(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	u8 dma_stat;
+	int mbus_stat;
+   
+	
+	dma_stat = hwif->dma_ops->dma_sff_read_status(hwif);
+	/*
+	 * make sure DMA is not in progress
+	 */
+	if ((dma_stat & 0x7) == 1) {
+		printk(KERN_ERR PFX "huh ? dma_end called while dma still "
+		       "in progress...dma_stat=0x%x\n", dma_stat);
+	}
+
+	/* clear the INTR & ERROR bits */
+	tango2_bmide_dma_sff_write_status(hwif, dma_stat | 6);
+
+	/*
+	 * confirm whether MBUS transfer is done due to the memory
+	 * arbitration, IDE device thinks the DMA transfer is done,
+	 * but the data might be held in MBUS FIFO
+	 */
+	mbus_stat = em86xx_mbus_wait(g_mbus_reg[drive->dn], SBOX_IDEDVD);
+
+	/* release mbus */
+	em86xx_mbus_free_dma(g_mbus_reg[drive->dn], SBOX_IDEDVD);
+
+	/* stop bus mastering */
+	WR_HOST_REG32(IDECTRL_bmic, 0x4);
+
+
+#ifdef USE_BOUNCE_BUF
+	if (!mbus_stat && ((dma_stat & 0x1) == 0) && 
+		(hwif->sg_dma_direction == DMA_FROM_DEVICE) && 
+		(hwif->sg_nents > 1)) {
+		int i;
+		unsigned long len = 0, addr;
+		unsigned long buf =  KSEG1ADDR(g_bounce_buf);
+
+		for_each_sg(hwif->sg_table, sg, hwif->sg_nents, i) {
+			addr = (unsigned long) sg_virt(sg);
+			len = sg_dma_len(sg);
+
+#ifndef USE_MBUS_MEMCPY
+			memcpy((void *)addr, (void *)buf, len);
+			mb();
+			dma_cache_wback_inv(addr, len);
+#else
+			dma_cache_inv(addr, len);
+			mbus_memcpy(g_mbus_reg, sg_dma_address(sg), 
+					tangox_dma_address(CPHYSADDR(buf)), len);
+#endif
+			buf += len;
+		}
+	}
+#endif
+
+	/* fake  dma  error  in  case  of mbus  timeout,  else  return
+	 * dma_status error bit */
+	return (mbus_stat == 0) ? (dma_stat & 1) : 0x1;
+}
+
+static int tango2_bmide_dma_test_irq(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	u8 dma_stat;
+
+	dma_stat = hwif->dma_ops->dma_sff_read_status(hwif);
+
+	if ((dma_stat & 0x4))
+		return 1;
+	return 0;
+}
+
+#endif
+
+#ifndef CONFIG_RUNTIME_CLK_CALC
+/*
+ * timing values for each ide mode
+ */
+static const unsigned int s_pio_tim[] = {
+	0xff230ee6, 0xd41b0fa4, 0xb4150f63, 0xa7110f62, 0x9a0f0552
+};
+
+static const unsigned int s_dma_tim[] = {
+	0xf33333b4, 0xa3130b73, 0x9c100552
+};
+static const unsigned int s_udma_tim1[] = {
+	0x35440b08, 0x35440a06, 0x35440804
+};
+static const unsigned int s_udma_tim2[] = {
+	0x00000208, 0x00000206, 0x00000204
+};
+
+static const unsigned int s_udma_tim1_alt[] = {
+	0x44442418, 0x44441c10, 0x4444160b, 0x44441608,
+	0x44441605, 0x44441303, 0x44441302, 0x44441302
+};
+static const unsigned int s_udma_tim2_alt[] = {
+	0x0000010f, 0x0000010a, 0x00000106, 0x00000104,
+	0x00000101, 0x00000202, 0x00000202, 0x00000202
+};
+#endif /* !CONFIG_RUNTIME_CLK_CALC */
+
+static u8 drive_speed[2] = { 0xff, 0xff };
+
+static void tango2_bmide_set_pio_mode(ide_hwif_t *hwif, ide_drive_t *drive)
+{
+	int didx;
+	unsigned int ctrlreg, newflag;
+    unsigned long flags;
+	u8 xferspeed, pio;
+	const u8 mode = drive->pio_mode - XFER_PIO_0;
+#ifdef CONFIG_RUNTIME_CLK_CALC
+	extern unsigned long tangox_get_sysclock(void);
+	unsigned int ide_clock = TIMING_MARGIN(tangox_get_sysclock() / 1000000); /* in MHz */
+#endif
+	didx = drive->dn & 1;
+	newflag = 0;
+
+	xferspeed = mode + XFER_PIO_0;
+	spin_lock_irqsave(&bmide_tune_chipset_spin_lock, flags);
+	if (xferspeed >= XFER_PIO_0 && xferspeed <= XFER_PIO_4) {
+		printk("%s: set to PIO mode %d\n", drive->name, mode);
+
+		/* fast timing for PIO, enable IORDY sampling */
+		newflag = 0x03;
+
+#ifdef CONFIG_RUNTIME_CLK_CALC
+		gbus_write_reg32(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0tim : IDECTRL_pri_drv1tim), 
+			    CalcRegValTiming_PIO_DMA(&(j2_pio_timings[mode]), ide_clock));
+#else
+		gbus_write_reg32(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0tim : IDECTRL_pri_drv1tim), 
+			    s_pio_tim[mode]);
+#endif
+	}
+
+	ctrlreg = gbus_read_reg32(REG_BASE_host_interface + IDECTRL_pri_idectl);
+	ctrlreg &= ~(didx == 0 ? 0xf : 0xf0);
+	ctrlreg |= newflag << (didx * 4);
+	gbus_write_reg32(REG_BASE_host_interface + IDECTRL_pri_idectl, ctrlreg);
+
+	spin_unlock_irqrestore(&bmide_tune_chipset_spin_lock, flags);
+	pio = xferspeed - XFER_PIO_0;
+	drive_speed[didx] = xferspeed;
+}
+
+static void tango2_bmide_set_xfer_mode(ide_hwif_t *hwif, ide_drive_t *drive)
+{
+	int didx;
+	unsigned int ctrlreg, newflag;
+    unsigned long flags;
+	u8 mode, pio;
+	const u8 xferspeed = drive->dma_mode;
+#ifdef CONFIG_RUNTIME_CLK_CALC
+	extern unsigned long tangox_get_sysclock(void);
+	unsigned int ide_clock = TIMING_MARGIN(tangox_get_sysclock() / 1000000); /* in MHz */
+#endif
+	didx = drive->dn & 1;
+	newflag = 0;
+
+	spin_lock_irqsave(&bmide_tune_chipset_spin_lock, flags);
+	if (xferspeed >= XFER_PIO_0 && xferspeed <= XFER_PIO_4) {
+		/*
+		 * setup timing for PIO mode
+		 */
+		mode = xferspeed - XFER_PIO_0;
+		printk("%s: set to PIO mode %d\n", drive->name, mode);
+
+		/* fast timing for PIO, enable IORDY sampling */
+		newflag = 0x03;
+
+#ifdef CONFIG_RUNTIME_CLK_CALC
+		gbus_write_reg32(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0tim : IDECTRL_pri_drv1tim), 
+			    CalcRegValTiming_PIO_DMA(&(j2_pio_timings[mode]), ide_clock));
+#else
+		gbus_write_reg32(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0tim : IDECTRL_pri_drv1tim), 
+			    s_pio_tim[mode]);
+#endif
+
+	}
+#ifdef CONFIG_BLK_DEV_BMIDE_TANGO2_DMA
+	else if (xferspeed >= XFER_MW_DMA_0 && xferspeed <= XFER_MW_DMA_2) {
+		/*
+		 * setup timing for Multi-word DMA
+		 */
+		mode = xferspeed - XFER_MW_DMA_0;
+		printk("%s: set to Multi-word DMA mode %d\n", drive->name,
+		       mode);
+
+		/* fast timing for PIO, prefetch enable */
+		newflag = 0x05;
+
+#ifdef CONFIG_RUNTIME_CLK_CALC
+		gbus_write_reg32(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0tim : IDECTRL_pri_drv1tim), 
+			    CalcRegValTiming_PIO_DMA(&(j2_dma_timings[mode]), ide_clock));
+		gbus_write_reg32(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0udmatim1 : IDECTRL_pri_drv1udmatim1), 
+			    CalcRegValTiming1_UDMA(&(j2_udma_timings[mode]), ide_clock));
+		gbus_write_reg32(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0udmatim2 : IDECTRL_pri_drv1udmatim2), 
+			    CalcRegValTiming2_UDMA(&(j2_udma_timings[mode]), ide_clock));
+#else
+		gbus_write_reg32(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0tim : IDECTRL_pri_drv1tim), 
+			    s_dma_tim[mode]);
+		gbus_write_reg32(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0udmatim1 : IDECTRL_pri_drv1udmatim1), 
+			    s_udma_tim1[mode]);
+		gbus_write_reg32(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0udmatim2 : IDECTRL_pri_drv1udmatim2), 
+			    s_udma_tim2[mode]);
+#endif
+
+	} 
+#endif
+	else if (xferspeed >= XFER_UDMA_0 && xferspeed <= XFER_UDMA_7) {
+		unsigned int val;
+
+		/*
+		 * setup timing for Ultra DMA
+		 */
+		mode = xferspeed - XFER_UDMA_0;
+		printk("%s: set to Ultra DMA mode %d\n", drive->name, mode);
+
+		newflag = 0x00;
+
+		/* enable Ultra DMA */
+		val = gbus_read_reg32(REG_BASE_host_interface + IDECTRL_udmactl);
+		val |= (didx == 0) ? 0x01 : 0x02;
+		gbus_write_reg32(REG_BASE_host_interface + IDECTRL_udmactl, val);
+
+#ifdef CONFIG_RUNTIME_CLK_CALC
+		gbus_write_reg32(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0udmatim1 : IDECTRL_pri_drv1udmatim1), 
+			    CalcRegValTiming1_UDMA(&(j2_udma_timings[mode]), ide_clock));
+		gbus_write_reg32(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0udmatim2 : IDECTRL_pri_drv1udmatim2), 
+			    CalcRegValTiming2_UDMA(&(j2_udma_timings[mode]), ide_clock));
+#else
+		gbus_write_reg32(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0udmatim1 : IDECTRL_pri_drv1udmatim1), 
+			    s_udma_tim1_alt[mode]);
+		gbus_write_reg32(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0udmatim2 : IDECTRL_pri_drv1udmatim2), 
+			    s_udma_tim2_alt[mode]);
+#endif
+ 	}
+	else {
+		printk("%s: unknown speed to be set %d\n", drive->name, xferspeed);
+	}
+
+	ctrlreg = gbus_read_reg32(REG_BASE_host_interface + IDECTRL_pri_idectl);
+	ctrlreg &= ~(didx == 0 ? 0xf : 0xf0);
+	ctrlreg |= newflag << (didx * 4);
+	gbus_write_reg32(REG_BASE_host_interface + IDECTRL_pri_idectl, ctrlreg);
+
+	spin_unlock_irqrestore(&bmide_tune_chipset_spin_lock, flags);
+
+#ifdef CONFIG_BLK_DEV_BMIDE_TANGO2_DMA
+	if (xferspeed >= XFER_SW_DMA_0)
+		pio = dma_2_pio(xferspeed);
+	else
+#endif
+		pio = xferspeed - XFER_PIO_0;
+
+	drive_speed[didx] = xferspeed;
+	//ide_config_drive_speed(drive, xferspeed);
+}
+
+static void tango2_hw_setup(struct ide_hw *hw, unsigned long data_port,
+		     unsigned long ctrl_port)
+{
+	int i;
+	unsigned long reg;
+
+	memset(hw, 0, sizeof (*hw));
+	reg = data_port;
+
+	for (i = 0; i <= 7; i++) {
+		hw->io_ports_array[i] = reg;
+		reg += 4;
+	}
+
+	hw->io_ports.ctl_addr = ctrl_port;
+}
+
+/*
+ * init function, ide controller is registred here
+ */
+extern int tangox_bmide_enabled(void);
+
+static void tango2_bmide_clear_irq(ide_drive_t *drive)
+{
+	return;
+}
+
+static u8 tango2_bmide_udma_filter(ide_drive_t *drive)
+{
+	if ((gbus_read_reg32(REG_BASE_host_interface + IDECTRL_idestatus) 
+				& 0x02) == 0x02) {
+		return ATA_UDMA2;
+	} else{
+		return ATA_UDMA5;
+	}
+}
+
+static u8 tango2_bmide_cable_detect(ide_hwif_t *hwif)
+{
+	if ((gbus_read_reg32(REG_BASE_host_interface + IDECTRL_idestatus) 
+				& 0x02) == 0x02) {
+		return ATA_CBL_PATA40;
+	} else{
+		return ATA_CBL_PATA80;
+	}
+}
+
+static void tango2_bmide_init_hwif (ide_hwif_t *hwif)
+{
+	return;
+}
+
+static int tango2_bmide_init_dma(ide_hwif_t *hwif, const struct ide_port_info *d)
+{
+	return 0;
+}
+
+static void tango2_bmide_dev_select(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = drive->hwif;
+	u8 select = drive->select | ATA_DEVICE_OBS;
+
+	tango2_bmide_outb(select, hwif->io_ports.device_addr);
+}
+
+static void tango2_bmide_tf_load(ide_drive_t *drive, struct ide_taskfile *tf, u8 valid)
+{
+	ide_hwif_t *hwif = drive->hwif;
+	struct ide_io_ports *io_ports = &hwif->io_ports;
+
+	if (valid & IDE_VALID_FEATURE)
+		tango2_bmide_outb(tf->feature, io_ports->feature_addr);
+	if (valid & IDE_VALID_NSECT)
+		tango2_bmide_outb(tf->nsect, io_ports->nsect_addr);
+	if (valid & IDE_VALID_LBAL)
+		tango2_bmide_outb(tf->lbal, io_ports->lbal_addr);
+	if (valid & IDE_VALID_LBAM)
+		tango2_bmide_outb(tf->lbam, io_ports->lbam_addr);
+	if (valid & IDE_VALID_LBAH)
+		tango2_bmide_outb(tf->lbah, io_ports->lbah_addr);
+	if (valid & IDE_VALID_DEVICE)
+		tango2_bmide_outb(tf->device, io_ports->device_addr);
+
+}
+
+static void tango2_bmide_tf_read(ide_drive_t *drive, struct ide_taskfile *tf, u8 valid)
+{
+	ide_hwif_t *hwif = drive->hwif;
+	struct ide_io_ports *io_ports = &hwif->io_ports;
+	
+	if (valid & IDE_VALID_ERROR)
+		tf->error  = tango2_bmide_inb(io_ports->feature_addr);
+	if (valid & IDE_VALID_NSECT)
+		tf->nsect  = tango2_bmide_inb(io_ports->nsect_addr);
+	if (valid & IDE_VALID_LBAL)
+		tf->lbal   = tango2_bmide_inb(io_ports->lbal_addr);
+	if (valid & IDE_VALID_LBAM)
+		tf->lbam   = tango2_bmide_inb(io_ports->lbam_addr);
+	if (valid & IDE_VALID_LBAH)
+		tf->lbah   = tango2_bmide_inb(io_ports->lbah_addr);
+	if (valid & IDE_VALID_DEVICE)
+		tf->device = tango2_bmide_inb(io_ports->device_addr);
+
+
+}
+
+u8 tango2_bmide_read_status(ide_hwif_t *hwif)
+{
+	u8 status;
+	status = tango2_bmide_inb(hwif->io_ports.status_addr);
+	return status;
+}
+
+u8 tango2_bmide_read_altstatus(ide_hwif_t *hwif)
+{
+	u8 alt_status;
+	alt_status = tango2_bmide_inb(hwif->io_ports.ctl_addr);
+	return alt_status;
+}
+
+void tango2_bmide_write_devctl(ide_hwif_t *hwif, u8 ctl)
+{
+	tango2_bmide_outb(ctl, hwif->io_ports.ctl_addr);
+}
+
+static void tango2_bmide_input_data(ide_drive_t *drive, struct ide_cmd *cmd,
+				void *buf, unsigned int len)
+{
+	unsigned long port = drive->hwif->io_ports.data_addr;
+	unsigned short *ptr = buf;
+	unsigned int count = (len + 1) / 2;
+
+	while (count--)
+		*ptr++ = cpu_to_le16(tango2_bmide_inw(port));
+	__ide_flush_dcache_range((unsigned long)buf, roundup(len, 2));
+}
+
+static void tango2_bmide_output_data(ide_drive_t *drive, struct ide_cmd *cmd,
+				void *buf, unsigned int len)
+{
+	unsigned long port = drive->hwif->io_ports.data_addr;
+	unsigned short *ptr = buf;
+	unsigned int count = (len + 1) / 2;
+
+	while (count--) {
+		tango2_bmide_outw(le16_to_cpu(*ptr), port);
+		ptr++;
+	}
+	__ide_flush_dcache_range((unsigned long)buf, roundup(len, 2));
+}
+void tango2_bmide_exec_command(ide_hwif_t *hwif, u8 cmd)
+{
+	tango2_bmide_outb(cmd, hwif->io_ports.command_addr);
+}
+
+static const struct ide_tp_ops tango2_bmide_tp_ops = {
+	.exec_command		= tango2_bmide_exec_command,
+	.read_status		= tango2_bmide_read_status,
+	.read_altstatus		= tango2_bmide_read_altstatus,
+	.write_devctl       = tango2_bmide_write_devctl,
+
+	.dev_select			= tango2_bmide_dev_select,
+	.tf_load			= tango2_bmide_tf_load,
+	.tf_read			= tango2_bmide_tf_read,
+
+	.input_data			= tango2_bmide_input_data,
+	.output_data		= tango2_bmide_output_data,
+};
+
+static const struct ide_port_ops tango2_bmide_port_ops = {
+	.set_pio_mode		= tango2_bmide_set_pio_mode,
+	.set_dma_mode		= tango2_bmide_set_xfer_mode,
+	.clear_irq			= tango2_bmide_clear_irq,
+	.udma_filter		= tango2_bmide_udma_filter,
+	.cable_detect		= tango2_bmide_cable_detect,
+};
+
+static const struct ide_dma_ops tango2_bmide_dma_ops = {
+	.dma_host_set		= tango2_bmide_dma_host_set,
+	.dma_setup			= tango2_bmide_dma_setup,
+	.dma_start			= tango2_bmide_dma_start,
+	.dma_end			= tango2_bmide_dma_end,
+	.dma_test_irq		= tango2_bmide_dma_test_irq,
+	.dma_lost_irq		= ide_dma_lost_irq,
+	.dma_timer_expiry	= ide_dma_sff_timer_expiry,
+	.dma_sff_read_status= tango2_bmide_dma_sff_read_status,
+};
+
+static const struct ide_port_info tango2_bmide_port_info = {
+	.init_hwif		= tango2_bmide_init_hwif,
+	.init_dma		= tango2_bmide_init_dma,
+	.port_ops		= &tango2_bmide_port_ops,
+	.dma_ops		= &tango2_bmide_dma_ops,
+	.tp_ops			= &tango2_bmide_tp_ops,
+	.host_flags		= IDE_HFLAG_MMIO,
+	.pio_mask		= ATA_PIO4,
+	.mwdma_mask		= ATA_MWDMA2,
+	.udma_mask		= ATA_UDMA5,
+	.chipset		= ide_generic,
+};
+
+static int tango2_bmide_probe(struct platform_device *pdev)
+{
+	struct ide_hw hw;
+	struct ide_hw *hws[] = { &hw, NULL, NULL, NULL };
+	struct ide_host *host;
+	int  ret;
+	unsigned int mapbase, mapctl;
+
+	if (!tangox_bmide_enabled()) {
+		printk(KERN_NOTICE PFX "bmide support is disabled\n");
+		return -1;
+	}
+
+	/* Enable bus master IDE interface */
+	WR_HOST_REG32(IDECTRL_pri_idectl, 0x8400);
+
+	/* no skew : normal IORDY, normal data */
+	WR_HOST_REG32(IDECTRL_idesrc, 0);
+
+	/* Enable non-PRD mode */
+	WR_HOST_REG32(IDECTRL_bmic, 0x4);
+
+	/*
+	 * set register offset for our controller
+	 */
+	mapbase = KSEG1ADDR(REG_BASE_host_interface_BMIDE);
+	mapctl	= KSEG1ADDR(REG_BASE_host_interface + IDECTRL_pri_ctrlblock);	
+	//ide_std_init_ports(&hw, mapbase, mapctl);
+	tango2_hw_setup(&hw, REG_BASE_host_interface_BMIDE,
+			REG_BASE_host_interface + IDECTRL_pri_ctrlblock);
+	
+	/*
+	 * Tango2   has   two   interrupts   for   IDE   controller   :
+	 * IRQ_IDECTRL_IDE,  IRQ_IDECTRL_IDEDMA
+	 *
+	 * IRQ_IDECTRL_IDEDMA is to be used for DMA transfer but it is
+	 * almost same with IRQ_IDECTRL_IDE interrupt.  Tango triggers
+	 * IDEDMA interrupt  after DMA FIFO  is flushed, and  it stays
+	 * high   until  BMIS   register  bit   2  is   cleared.   Use
+	 * IRQ_IDECTRL_IDE interrupt for both of PIO and DMA.
+	 */
+	hw.irq = IRQ_IDECTRL_IDE;
+
+	/*
+	 * register our controller
+	 */
+	hw.dev = &pdev->dev;
+
+	pr_info("TANGO2 Bus Mastering IDE interface (base 0x%x,ctl 0x%x,irq %d)\n", 
+									mapbase, mapctl, hw.irq);
+	host = ide_host_alloc(&tango2_bmide_port_info, hws, 2);
+	if (!host)
+		return -ENOMEM;
+	/* use extra_base for base address of the all registers */
+	host->ports[0]->extra_base = REG_BASE_host_interface_BMIDE;
+	ret = ide_host_register(host, &tango2_bmide_port_info, hws);
+	if (ret) {
+		ide_host_free(host);
+		return ret;
+	}
+	platform_set_drvdata(pdev, host);
+
+#ifdef USE_BOUNCE_BUF
+	if ((g_bounce_buf = (unsigned char *)__get_free_pages(GFP_KERNEL, DMA_BOUNCE_BUF_ORDER)) == NULL)
+		printk("IDE: Can not allocate buffer for IDE transfer\n");
+
+	printk("Bounce buffer starts at 0x%08lx\n", (unsigned long)g_bounce_buf);
+#endif	
+	
+	return 0;
+}
+
+static int tango2_bmide_remove(struct platform_device *pdev)
+{
+	struct ide_host *host = platform_get_drvdata(pdev);
+
+	ide_host_remove(host);
+
+	return 0;
+}
+
+static int tango2_bmide_resume(struct platform_device *dev)
+{
+	return 0;
+}
+
+static struct platform_driver tango2_bmide_driver = {
+	.driver = {
+		.name = "tango2_bmide",
+		.owner = THIS_MODULE,
+	},
+	.probe  = tango2_bmide_probe,
+	.remove = tango2_bmide_remove,
+	.resume = tango2_bmide_resume,
+};
+
+static void tango2_bmide_release_dev(struct device * dev)
+{
+	dev->parent = NULL;
+}
+
+static struct platform_device tango2_bmide_device = {
+	.name	= "tango2_bmide",
+	.id		= -1,
+	.dev	= {
+		.release = tango2_bmide_release_dev,
+	},
+	.num_resources  = 0,
+	.resource       = 0,
+};
+
+int __init tango2_bmide_init(void)
+{
+   int status = 0;
+
+	platform_device_register(&tango2_bmide_device);
+	platform_driver_register(&tango2_bmide_driver);
+
+  return status;
+}
+
+static void __exit tango2_bmide_exit(void)
+{
+	platform_driver_unregister(&tango2_bmide_driver);
+	platform_device_unregister(&tango2_bmide_device);
+#ifdef USE_BOUNCE_BUF
+	free_pages((unsigned long)g_bounce_buf, DMA_BOUNCE_BUF_ORDER);
+#endif
+	return;
+}
+
+module_init(tango2_bmide_init);
+module_exit(tango2_bmide_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("SMP86xx BM IDE driver");
+
+#ifdef CONFIG_RUNTIME_CLK_CALC
+/* The following is for runtime calculation of register value based on the mode and given
+ * system frequency by Ivan K. */
+static unsigned int CalcRegValTiming_PIO_DMA(j2_tim_pio_dma_t *t, unsigned long ide_clock)
+{
+	unsigned int dwRet;
+	unsigned int cycle_clks;	// ide clocks / cycle
+	unsigned int active_clks;	// ide clocks for active strobe
+	unsigned int recov_clks;	// ide clocks for recovery
+	unsigned int setup_clks;	// ide clocks for setup
+	unsigned int hold_clks;	// ide clocks for hold
+
+	// pio_timings in ns
+	cycle_clks	= (ide_clock * t->cycle_time)/1000;
+	active_clks	= (ide_clock * t->active_time)/1000;
+	recov_clks	= (ide_clock * t->recovery_time)/1000;
+	setup_clks	= (ide_clock * t->setup_time)/1000;
+	hold_clks	= (ide_clock * t->hold_time)/1000;
+
+	if (cycle_clks>0x7F) {
+		cycle_clks = 0x7F;
+	}
+	
+	if (active_clks>0x3F) {
+		active_clks = 0x3F;
+	}
+
+	if (recov_clks>0x3F) {
+		recov_clks = 0x3F;
+	}
+
+	if (setup_clks>0xF) {
+		setup_clks = 0xF;
+	}
+	
+	if (hold_clks>0x7) {
+		setup_clks = 0x7;
+	}
+	
+	dwRet	= (1<<31) | (cycle_clks<<24) | (active_clks<<16) | (recov_clks<<8) | (setup_clks<<4) | (hold_clks);
+
+	return dwRet;
+}
+
+static unsigned int CalcRegValTiming1_UDMA(j2_tim_udma_t *t, unsigned long ide_clock)
+{
+	unsigned int dwRet;
+	unsigned int t_zah,t_mli,t_ack,t_env,t_rp,t_cyc;
+
+	// pio_timings in ns
+	t_zah	= (ide_clock * t->t_zah)/1000;
+	t_mli	= (ide_clock * t->t_mli)/1000;
+	t_ack	= (ide_clock * t->t_ack)/1000;
+	t_env	= (ide_clock * t->t_env)/1000;
+	t_rp	= (ide_clock * t->t_rp) /1000;
+	t_cyc	= (ide_clock * t->t_cyc)/1000;
+
+	if (t_zah > 0x0F) {
+		t_zah = 0x0F;
+	}
+	if (t_mli > 0x0F) {
+		t_mli = 0x0F;
+	}
+	if (t_ack > 0x0F) {
+		t_ack = 0x0F;
+	}
+	if (t_env > 0x0F) {
+		t_env = 0x0F;
+	}
+	if (t_rp > 0x3F) {
+		t_rp = 0x3F;
+	}
+	if (t_cyc > 0x3F) {
+		t_cyc = 0x3F;
+	}
+	
+	dwRet	= (t_zah<<28) | (t_mli<<24) | (t_ack<<20) | (t_env<<16) | (t_rp<<8) | (t_cyc);
+
+	return dwRet;
+}
+
+static unsigned int CalcRegValTiming2_UDMA(j2_tim_udma_t *t, unsigned long ide_clock)
+{
+	unsigned int dwRet;
+	unsigned int t_cvh,t_cvs;
+	
+	// pio_timings in ns
+	t_cvh	= (ide_clock * t->t_cvh)/1000;
+	t_cvs	= (ide_clock * t->t_cvs)/1000;
+
+	if (t_cvh > 0x03) {
+		t_cvh = 0x03;
+	}
+	if (t_cvs > 0x3F) {
+		t_cvs = 0x3F;
+	}
+
+	dwRet	= (t_cvh<<8) | (t_cvs);
+
+	return dwRet;
+}
+#endif /* CONFIG_RUNTIME_CLK_CALC */
+
+/* to calcuate the speed needed,  this is used in fctrl module*/
+void tango2_bmide_calc_speed(void)
+{
+	int didx;
+	u8 xferspeed;
+	u8 mode;
+	unsigned long flags;
+#ifdef CONFIG_RUNTIME_CLK_CALC
+	extern unsigned long tangox_get_sysclock(void);
+	unsigned int ide_clock = TIMING_MARGIN(tangox_get_sysclock() / 1000000); /* in MHz */
+#endif
+	
+	if (!tangox_bmide_enabled())
+		return;
+	
+	spin_lock_irqsave(&bmide_tune_chipset_spin_lock, flags);
+	
+	for (didx = 0; didx < 2; didx++) {
+		if ((xferspeed = drive_speed[didx]) == 0xff)
+			continue;
+		
+		if (xferspeed >= XFER_PIO_0 && xferspeed <= XFER_PIO_4) {
+			/*
+			 * setup timing for PIO mode
+			 */
+			mode = xferspeed - XFER_PIO_0;
+#ifdef CONFIG_RUNTIME_CLK_CALC
+			gbus_write_reg32(REG_BASE_host_interface +
+					((didx == 0) ? IDECTRL_pri_drv0tim : IDECTRL_pri_drv1tim),
+					CalcRegValTiming_PIO_DMA(&(j2_pio_timings[mode]), ide_clock));
+#else
+			gbus_write_reg32(REG_BASE_host_interface +
+					((didx == 0) ? IDECTRL_pri_drv0tim : IDECTRL_pri_drv1tim),
+					s_pio_tim[mode]);
+#endif
+		}
+#ifdef CONFIG_BLK_DEV_BMIDE_TANGO2_DMA
+		else if (xferspeed >= XFER_MW_DMA_0 && xferspeed <= XFER_MW_DMA_2) {
+			/*
+			 * setup timing for Multi-word DMA
+			 */
+			mode = xferspeed - XFER_MW_DMA_0;
+#ifdef CONFIG_RUNTIME_CLK_CALC
+			gbus_write_reg32(REG_BASE_host_interface +
+					((didx == 0) ? IDECTRL_pri_drv0tim : IDECTRL_pri_drv1tim),
+					CalcRegValTiming_PIO_DMA(&(j2_dma_timings[mode]), ide_clock));
+			gbus_write_reg32(REG_BASE_host_interface +
+					((didx == 0) ? IDECTRL_pri_drv0udmatim1 : IDECTRL_pri_drv1udmatim1),
+					
+					CalcRegValTiming1_UDMA(&(j2_udma_timings[mode]), ide_clock));
+			gbus_write_reg32(REG_BASE_host_interface +
+					((didx == 0) ? IDECTRL_pri_drv0udmatim2 : IDECTRL_pri_drv1udmatim2),
+					CalcRegValTiming2_UDMA(&(j2_udma_timings[mode]), ide_clock));
+#else
+			gbus_write_reg32(REG_BASE_host_interface +
+					((didx == 0) ? IDECTRL_pri_drv0tim : IDECTRL_pri_drv1tim),
+					s_dma_tim[mode]);
+			gbus_write_reg32(REG_BASE_host_interface +
+					((didx == 0) ? IDECTRL_pri_drv0udmatim1 : IDECTRL_pri_drv1udmatim1),
+					s_udma_tim1[mode]);
+			gbus_write_reg32(REG_BASE_host_interface +
+					((didx == 0) ? IDECTRL_pri_drv0udmatim2 : IDECTRL_pri_drv1udmatim2),
+					s_udma_tim2[mode]);
+#endif
+		}
+#endif
+		else if (xferspeed >= XFER_UDMA_0 && xferspeed <= XFER_UDMA_7) {
+			/*
+			 * setup timing for Ultra DMA
+			 */
+			mode = xferspeed - XFER_UDMA_0;
+#ifdef CONFIG_RUNTIME_CLK_CALC
+			gbus_write_reg32(REG_BASE_host_interface +
+					((didx == 0) ? IDECTRL_pri_drv0udmatim1 : IDECTRL_pri_drv1udmatim1),
+					CalcRegValTiming1_UDMA(&(j2_udma_timings[mode]), ide_clock));
+			gbus_write_reg32(REG_BASE_host_interface +
+					((didx == 0) ? IDECTRL_pri_drv0udmatim2 : IDECTRL_pri_drv1udmatim2),
+					CalcRegValTiming2_UDMA(&(j2_udma_timings[mode]), ide_clock));
+#else
+			gbus_write_reg32(REG_BASE_host_interface +
+					((didx == 0) ? IDECTRL_pri_drv0udmatim1 : IDECTRL_pri_drv1udmatim1),
+					s_udma_tim1_alt[mode]);
+			gbus_write_reg32(REG_BASE_host_interface +
+					((didx == 0) ? IDECTRL_pri_drv0udmatim2 : IDECTRL_pri_drv1udmatim2),
+					s_udma_tim2_alt[mode]);
+#endif
+		}
+	}
+
+	spin_unlock_irqrestore(&bmide_tune_chipset_spin_lock, flags);
+}
+EXPORT_SYMBOL(tango2_bmide_calc_speed);
+
diff -Naur linux-3.9.2.ref/drivers/media/dvb-core/dmxdev.c linux-3.9.2/drivers/media/dvb-core/dmxdev.c
--- linux-3.9.2.ref/drivers/media/dvb-core/dmxdev.c	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/drivers/media/dvb-core/dmxdev.c	2013-07-23 19:31:11.000000000 +0200
@@ -82,7 +82,12 @@
 
 		ret = wait_event_interruptible(src->queue,
 					       !dvb_ringbuffer_empty(src) ||
-					       (src->error != 0));
+					      (src->error != 0) ||
+						  (src->do_wait != 1));
+						  
+		if (src->do_wait != 1)
+			ret = -EINTR;
+				
 		if (ret < 0)
 			break;
 
@@ -960,6 +965,22 @@
 	return ret;
 }
 
+static int dvb_demux_lock_filter(struct dmxdev_filter *dmxdevfilter)
+{
+	int ret;
+
+	dmxdevfilter->buffer.do_wait = 0;
+
+	if (waitqueue_active(&dmxdevfilter->buffer.queue))
+		wake_up(&dmxdevfilter->buffer.queue);
+
+	ret = mutex_lock_interruptible(&dmxdevfilter->mutex);
+
+	dmxdevfilter->buffer.do_wait = 1;
+
+	return ret;
+}
+
 static int dvb_demux_do_ioctl(struct file *file,
 			      unsigned int cmd, void *parg)
 {
@@ -973,7 +994,7 @@
 
 	switch (cmd) {
 	case DMX_START:
-		if (mutex_lock_interruptible(&dmxdevfilter->mutex)) {
+		if (dvb_demux_lock_filter(dmxdevfilter)) {
 			mutex_unlock(&dmxdev->mutex);
 			return -ERESTARTSYS;
 		}
@@ -985,7 +1006,7 @@
 		break;
 
 	case DMX_STOP:
-		if (mutex_lock_interruptible(&dmxdevfilter->mutex)) {
+		if (dvb_demux_lock_filter(dmxdevfilter)) {
 			mutex_unlock(&dmxdev->mutex);
 			return -ERESTARTSYS;
 		}
@@ -994,7 +1015,7 @@
 		break;
 
 	case DMX_SET_FILTER:
-		if (mutex_lock_interruptible(&dmxdevfilter->mutex)) {
+		if (dvb_demux_lock_filter(dmxdevfilter)) {
 			mutex_unlock(&dmxdev->mutex);
 			return -ERESTARTSYS;
 		}
@@ -1003,7 +1024,7 @@
 		break;
 
 	case DMX_SET_PES_FILTER:
-		if (mutex_lock_interruptible(&dmxdevfilter->mutex)) {
+		if (dvb_demux_lock_filter(dmxdevfilter)) {
 			mutex_unlock(&dmxdev->mutex);
 			return -ERESTARTSYS;
 		}
@@ -1012,7 +1033,7 @@
 		break;
 
 	case DMX_SET_BUFFER_SIZE:
-		if (mutex_lock_interruptible(&dmxdevfilter->mutex)) {
+		if (dvb_demux_lock_filter(dmxdevfilter)) {
 			mutex_unlock(&dmxdev->mutex);
 			return -ERESTARTSYS;
 		}
@@ -1056,7 +1077,7 @@
 		break;
 
 	case DMX_ADD_PID:
-		if (mutex_lock_interruptible(&dmxdevfilter->mutex)) {
+		if (dvb_demux_lock_filter(dmxdevfilter)) {
 			ret = -ERESTARTSYS;
 			break;
 		}
@@ -1065,7 +1086,7 @@
 		break;
 
 	case DMX_REMOVE_PID:
-		if (mutex_lock_interruptible(&dmxdevfilter->mutex)) {
+		if (dvb_demux_lock_filter(dmxdevfilter)) {
 			ret = -ERESTARTSYS;
 			break;
 		}
diff -Naur linux-3.9.2.ref/drivers/media/dvb-core/dvb_ringbuffer.c linux-3.9.2/drivers/media/dvb-core/dvb_ringbuffer.c
--- linux-3.9.2.ref/drivers/media/dvb-core/dvb_ringbuffer.c	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/drivers/media/dvb-core/dvb_ringbuffer.c	2013-07-23 19:31:11.000000000 +0200
@@ -46,6 +46,8 @@
 	rbuf->size=len;
 	rbuf->error=0;
 
+	rbuf->do_wait=1;
+	
 	init_waitqueue_head(&rbuf->queue);
 
 	spin_lock_init(&(rbuf->lock));
diff -Naur linux-3.9.2.ref/drivers/media/dvb-core/dvb_ringbuffer.h linux-3.9.2/drivers/media/dvb-core/dvb_ringbuffer.h
--- linux-3.9.2.ref/drivers/media/dvb-core/dvb_ringbuffer.h	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/drivers/media/dvb-core/dvb_ringbuffer.h	2013-07-23 19:31:11.000000000 +0200
@@ -39,6 +39,7 @@
 
 	wait_queue_head_t queue;
 	spinlock_t        lock;
+	int               do_wait;
 };
 
 #define DVB_RINGBUFFER_PKTHDRSIZE 3
diff -Naur linux-3.9.2.ref/drivers/mtd/chips/cfi_cmdset_0002.c linux-3.9.2/drivers/mtd/chips/cfi_cmdset_0002.c
--- linux-3.9.2.ref/drivers/mtd/chips/cfi_cmdset_0002.c	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/drivers/mtd/chips/cfi_cmdset_0002.c	2013-07-23 19:31:14.000000000 +0200
@@ -61,9 +61,10 @@
 static int cfi_amdstd_reboot(struct notifier_block *, unsigned long, void *);
 static int cfi_amdstd_secsi_read (struct mtd_info *, loff_t, size_t, size_t *, u_char *);
 
+#ifndef CONFIG_TANGOX
 static int cfi_amdstd_panic_write(struct mtd_info *mtd, loff_t to, size_t len,
 				  size_t *retlen, const u_char *buf);
-
+#endif
 static void cfi_amdstd_destroy(struct mtd_info *);
 
 struct mtd_info *cfi_cmdset_0002(struct map_info *, int);
@@ -76,9 +77,11 @@
 static int cfi_atmel_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len);
 static int cfi_atmel_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len);
 
+#ifdef CONFIG_OF
 static int cfi_ppb_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len);
 static int cfi_ppb_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len);
 static int cfi_ppb_is_locked(struct mtd_info *mtd, loff_t ofs, uint64_t len);
+#endif
 
 static struct mtd_chip_driver cfi_amdstd_chipdrv = {
 	.probe		= NULL, /* Not usable directly */
@@ -351,6 +354,16 @@
 	pr_warning("%s: Bad S29NS512P CFI data; adjust to 512 sectors\n", mtd->name);
 }
 
+static void fixup_M29W128G_write_buffer(struct mtd_info *mtd)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	if (cfi->cfiq->BufWriteTimeoutTyp) {
+		pr_warning("Don't use write buffer on ST flash M29W128G\n");
+		cfi->cfiq->BufWriteTimeoutTyp = 0;
+	}
+}
+
 /* Used to fix CFI-Tables of chips without Extended Query Tables */
 static struct cfi_fixup cfi_nopri_fixup_table[] = {
 	{ CFI_MFR_SST, 0x234a, fixup_sst39vf }, /* SST39VF1602 */
@@ -386,6 +399,7 @@
 	{ CFI_MFR_SST, 0x536b, fixup_sst38vf640x_sectorsize }, /* SST38VF6401 */
 	{ CFI_MFR_SST, 0x536c, fixup_sst38vf640x_sectorsize }, /* SST38VF6404 */
 	{ CFI_MFR_SST, 0x536d, fixup_sst38vf640x_sectorsize }, /* SST38VF6403 */
+	{ CFI_MFR_ST,  0x227E, fixup_M29W128G_write_buffer },
 #if !FORCE_WORD_WRITE
 	{ CFI_MFR_ANY, CFI_ID_ANY, fixup_use_write_buffers },
 #endif
@@ -528,8 +542,9 @@
 
 	pr_debug("MTD %s(): write buffer size %d\n", __func__,
 			mtd->writebufsize);
-
+#ifndef CONFIG_TANGOX
 	mtd->_panic_write = cfi_amdstd_panic_write;
+#endif
 	mtd->reboot_notifier.notifier_call = cfi_amdstd_reboot;
 
 	if (cfi->cfi_mode==CFI_MODE_CFI){
@@ -710,6 +725,22 @@
  * correctly and is therefore not done	(particularly with interleaved chips
  * as each chip must be checked independently of the others).
  */
+#ifdef CONFIG_TANGOX
+/* For TANGOX, verify content in start address as well */
+static int __xipram chip_ready(struct map_info *map, unsigned long addr, unsigned long start, map_word z_val)
+{
+	map_word d, t, z;
+
+	d = map_read(map, addr);
+	mb();
+	t = map_read(map, addr);
+	mb();
+	z = map_read(map, start);
+	mb();
+
+	return map_word_equal(map, d, t) && map_word_equal(map, z, z_val);
+}
+#else
 static int __xipram chip_ready(struct map_info *map, unsigned long addr)
 {
 	map_word d, t;
@@ -719,6 +750,7 @@
 
 	return map_word_equal(map, d, t);
 }
+#endif
 
 /*
  * Return true if the chip is ready and has the correct value.
@@ -752,6 +784,9 @@
 	struct cfi_private *cfi = map->fldrv_priv;
 	unsigned long timeo;
 	struct cfi_pri_amdstd *cfip = (struct cfi_pri_amdstd *)cfi->cmdset_priv;
+#ifdef CONFIG_TANGOX
+	map_word z_val = map_read(map, chip->start);
+#endif
 
  resettime:
 	timeo = jiffies + HZ;
@@ -760,8 +795,13 @@
 
 	case FL_STATUS:
 		for (;;) {
+#ifdef CONFIG_TANGOX
+			if (chip_ready(map, adr, chip->start, z_val))
+				break;
+#else
 			if (chip_ready(map, adr))
 				break;
+#endif
 
 			if (time_after(jiffies, timeo)) {
 				printk(KERN_ERR "Waiting for chip to be ready timed out.\n");
@@ -785,6 +825,12 @@
 		    (mode == FL_WRITING && (cfip->EraseSuspend & 0x2))))
 			goto sleep;
 
+		/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		 * Sentivision FIX: map_write here whole flash operation freeze on VIP1216 STB.
+		 *   So we just will sleep waitting for state change: */
+		goto sleep;
+		/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
+
 		/* We could check to see if we're trying to access the sector
 		 * that is currently being erased. However, no user will try
 		 * anything like that so we just wait for the timeout. */
@@ -797,8 +843,13 @@
 		chip->state = FL_ERASE_SUSPENDING;
 		chip->erase_suspended = 1;
 		for (;;) {
+#ifdef CONFIG_TANGOX
+			if (chip_ready(map, adr, chip->start, z_val))
+				break;
+#else
 			if (chip_ready(map, adr))
 				break;
+#endif
 
 			if (time_after(jiffies, timeo)) {
 				/* Should have suspended the erase by now.
@@ -1242,6 +1293,9 @@
 	int ret = 0;
 	map_word oldd;
 	int retry_cnt = 0;
+#ifdef CONFIG_TANGOX
+	map_word z_val;
+#endif
 
 	adr += chip->start;
 
@@ -1261,6 +1315,9 @@
 	 * data at other locations when 0xff is written to a location that
 	 * already contains 0xff.
 	 */
+#ifdef CONFIG_TANGOX
+	z_val = ((adr == chip->start) ? datum : map_read(map, chip->start));
+#endif
 	oldd = map_read(map, adr);
 	if (map_word_equal(map, oldd, datum)) {
 		pr_debug("MTD %s(): NOP\n",
@@ -1299,15 +1356,25 @@
 			continue;
 		}
 
-		if (time_after(jiffies, timeo) && !chip_ready(map, adr)){
+#ifdef CONFIG_TANGOX
+		if (time_after(jiffies, timeo) && !chip_ready(map, adr, chip->start, z_val))
+#else
+		if (time_after(jiffies, timeo) && !chip_ready(map, adr))
+#endif
+		{
 			xip_enable(map, chip, adr);
 			printk(KERN_WARNING "MTD %s(): software timeout\n", __func__);
 			xip_disable(map, chip, adr);
 			break;
 		}
 
+#ifdef CONFIG_TANGOX
+		if (chip_ready(map, adr, chip->start, z_val))
+			break;
+#else
 		if (chip_ready(map, adr))
 			break;
+#endif
 
 		/* Latency issues. Drop the lock, wait a while and retry */
 		UDELAY(map, chip, adr, 1);
@@ -1473,6 +1540,9 @@
 	unsigned long cmd_adr;
 	int z, words;
 	map_word datum;
+#ifdef CONFIG_TANGOX
+	map_word z_val;
+#endif
 
 	adr += chip->start;
 	cmd_adr = adr;
@@ -1493,6 +1563,9 @@
 	ENABLE_VPP(map);
 	xip_disable(map, chip, cmd_adr);
 
+#ifdef CONFIG_TANGOX
+	z_val = ((adr == chip->start) ? datum : map_read(map, chip->start));
+#endif
 	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
 	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);
 
@@ -1542,10 +1615,20 @@
 			continue;
 		}
 
+#ifdef CONFIG_TANGOX
+		if (time_after(jiffies, timeo) && !chip_ready(map, adr, chip->start, z_val))
+			break;
+#else
 		if (time_after(jiffies, timeo) && !chip_ready(map, adr))
 			break;
+#endif
 
-		if (chip_ready(map, adr)) {
+#ifdef CONFIG_TANGOX
+		if (chip_ready(map, adr, chip->start, z_val)) 
+#else
+		if (chip_ready(map, adr)) 
+#endif
+		{
 			xip_enable(map, chip, adr);
 			goto op_done;
 		}
@@ -1659,7 +1742,7 @@
 
 	return 0;
 }
-
+#ifndef CONFIG_TANGOX
 /*
  * Wait for the flash chip to become ready to write data
  *
@@ -1891,7 +1974,7 @@
 
 	return 0;
 }
-
+#endif
 
 /*
  * Handle devices with one erase region, that only implement
@@ -1904,6 +1987,10 @@
 	unsigned long int adr;
 	DECLARE_WAITQUEUE(wait, current);
 	int ret = 0;
+#ifdef CONFIG_TANGOX
+	map_word z_val;
+	z_val.x[0] = ((map->bankwidth == 1) ? 0xff : 0xffff);
+#endif
 
 	adr = cfi->addr_unlock1;
 
@@ -1956,8 +2043,13 @@
 			chip->erase_suspended = 0;
 		}
 
+#ifdef CONFIG_TANGOX
+		if (chip_ready(map, adr, chip->start, z_val))
+			break;
+#else
 		if (chip_ready(map, adr))
 			break;
+#endif
 
 		if (time_after(jiffies, timeo)) {
 			printk(KERN_WARNING "MTD %s(): software timeout\n",
@@ -1993,6 +2085,9 @@
 	unsigned long timeo = jiffies + HZ;
 	DECLARE_WAITQUEUE(wait, current);
 	int ret = 0;
+#ifdef CONFIG_TANGOX
+	map_word z_val;
+#endif
 
 	adr += chip->start;
 
@@ -2005,6 +2100,12 @@
 
 	pr_debug("MTD %s(): ERASE 0x%.8lx\n",
 	       __func__, adr );
+#ifdef CONFIG_TANGOX
+	if (adr == chip->start)
+		z_val.x[0] = ((map->bankwidth == 1) ? 0xff : 0xffff);
+	else
+		z_val = map_read(map, chip->start);
+#endif
 
 	XIP_INVAL_CACHED_RANGE(map, adr, len);
 	ENABLE_VPP(map);
@@ -2045,7 +2146,12 @@
 			chip->erase_suspended = 0;
 		}
 
-		if (chip_ready(map, adr)) {
+#ifdef CONFIG_TANGOX
+		if (chip_ready(map, adr, chip->start, z_val))
+#else
+		if (chip_ready(map, adr)) 
+#endif
+		{
 			xip_enable(map, chip, adr);
 			break;
 		}
@@ -2190,6 +2296,7 @@
 	return cfi_varsize_frob(mtd, do_atmel_unlock, ofs, len, NULL);
 }
 
+#ifdef CONFIG_OF
 /*
  * Advanced Sector Protection - PPB (Persistent Protection Bit) locking
  */
@@ -2389,6 +2496,7 @@
 	return cfi_varsize_frob(mtd, do_ppb_xxlock, ofs, len,
 				DO_XXLOCK_ONEBLOCK_GETLOCK) ? 1 : 0;
 }
+#endif
 
 static void cfi_amdstd_sync (struct mtd_info *mtd)
 {
diff -Naur linux-3.9.2.ref/drivers/mtd/Kconfig linux-3.9.2/drivers/mtd/Kconfig
--- linux-3.9.2.ref/drivers/mtd/Kconfig	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/drivers/mtd/Kconfig	2013-07-23 19:31:14.000000000 +0200
@@ -25,6 +25,7 @@
 
 config MTD_REDBOOT_PARTS
 	tristate "RedBoot partition table parsing"
+	depends on MTD_PARTITIONS && !TANGOX
 	---help---
 	  RedBoot is a ROM monitor and bootloader which deals with multiple
 	  'images' in flash devices by putting a table one of the erase
@@ -75,7 +76,7 @@
 
 config MTD_CMDLINE_PARTS
 	tristate "Command line partition table parsing"
-	depends on MTD
+	depends on MTD_PARTITIONS = "y" && MTD = "y" && !TANGOX_XENV_READ
 	---help---
 	  Allow generic configuration of the MTD partition tables via the kernel
 	  command line. Multiple flash resources are supported for hardware where
diff -Naur linux-3.9.2.ref/drivers/mtd/maps/Kconfig linux-3.9.2/drivers/mtd/maps/Kconfig
--- linux-3.9.2.ref/drivers/mtd/maps/Kconfig	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/drivers/mtd/maps/Kconfig	2013-07-23 19:31:14.000000000 +0200
@@ -4,6 +4,7 @@
 
 config MTD_COMPLEX_MAPPINGS
 	bool "Support non-linear mappings of flash chips"
+	depends on MTD && TANGOX_XENV_READ!=y
 	help
 	  This causes the chip drivers to allow for complicated
 	  paged mappings of flash chips.
@@ -24,7 +25,7 @@
 
 config MTD_PHYSMAP_COMPAT
 	bool "Physmap compat support"
-	depends on MTD_PHYSMAP
+	depends on MTD_PHYSMAP && TANGOX_XENV_READ!=y
 	default n
 	help
 	  Setup a simple mapping via the Kconfig options.  Normally the
@@ -35,7 +36,7 @@
 
 config MTD_PHYSMAP_START
 	hex "Physical start address of flash mapping"
-	depends on MTD_PHYSMAP_COMPAT
+	depends on MTD_PHYSMAP_COMPAT && TANGOX_XENV_READ!=y
 	default "0x8000000"
 	help
 	  This is the physical memory location at which the flash chips
@@ -45,8 +46,8 @@
 
 config MTD_PHYSMAP_LEN
 	hex "Physical length of flash mapping"
-	depends on MTD_PHYSMAP_COMPAT
-	default "0"
+	depends on MTD_PHYSMAP_COMPAT && TANGOX_XENV_READ!=y
+	default "0x4000000"
 	help
 	  This is the total length of the mapping of the flash chips on
 	  your particular board. If there is space, or aliases, in the
@@ -57,7 +58,7 @@
 
 config MTD_PHYSMAP_BANKWIDTH
 	int "Bank width in octets"
-	depends on MTD_PHYSMAP_COMPAT
+	depends on MTD_PHYSMAP_COMPAT && TANGOX_XENV_READ!=y
 	default "2"
 	help
 	  This is the total width of the data bus of the flash devices
diff -Naur linux-3.9.2.ref/drivers/mtd/maps/physmap.c linux-3.9.2/drivers/mtd/maps/physmap.c
--- linux-3.9.2.ref/drivers/mtd/maps/physmap.c	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/drivers/mtd/maps/physmap.c	2013-07-23 19:31:14.000000000 +0200
@@ -20,6 +20,54 @@
 #include <linux/mtd/physmap.h>
 #include <linux/mtd/concat.h>
 #include <linux/io.h>
+#include "../mtdcore.h"
+
+#if defined(CONFIG_TANGOX) && defined(CONFIG_TANGOX_XENV_READ)
+
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/emhwlib_registers_tango2.h>
+#include <asm/tango2/tango2_gbus.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/emhwlib_registers_tango3.h>
+#include <asm/tango3/tango3_gbus.h>
+#endif
+
+#define XENV_MAX_FLASH    4
+#define XENV_MAX_FLASH_PARTITIONS   16
+static struct mtd_info *mymtds[XENV_MAX_FLASH] = { NULL, NULL, NULL, NULL };
+static struct mtd_partition *mtd_parts[XENV_MAX_FLASH] = { NULL, NULL, NULL, NULL };
+static unsigned int p_cnts[XENV_MAX_FLASH] = { 0, 0, 0, 0 };
+static u64 f_sizes[XENV_MAX_FLASH] = { 0, 0, 0, 0 };
+
+struct map_info physmap_maps[XENV_MAX_FLASH] = {
+        {
+                .name = "CS0: Physically mapped flash",
+                .phys = 0x40000000,
+                .size = 0, /* To be filled by XENV */
+                .bankwidth = 2, /* To be checked by PBI registers */
+        },
+        {
+                .name = "CS1: Physically mapped flash",
+                .phys = 0x44000000,
+                .size = 0, /* To be filled by XENV */
+                .bankwidth = 2, /* To be checked by PBI registers */
+        },
+        {
+                .name = "CS2: Physically mapped flash",
+                .phys = 0x48000000,
+                .size = 0, /* To be filled by XENV */
+                .bankwidth = 2, /* To be checked by PBI registers */
+        },
+        {
+                .name = "CS3: Physically mapped flash",
+                .phys = 0x4c000000,
+                .size = 0, /* To be filled by XENV */
+                .bankwidth = 2, /* To be checked by PBI registers */
+        },
+};
+int tangox_flash_get_info(int cs, u64 *size, unsigned int *part_count);
+int tangox_flash_get_parts(int cs, u64 offset[], u64 size[]);
+#endif
 
 #define MAX_RESOURCES		4
 
@@ -33,6 +81,30 @@
 
 static int physmap_flash_remove(struct platform_device *dev)
 {
+#if defined(CONFIG_TANGOX) && defined(CONFIG_TANGOX_XENV_READ)
+        int cs, p;
+        struct mtd_partition *part_ptr;
+
+        for (cs = 0; cs < XENV_MAX_FLASH; cs++) {
+                if (f_sizes[cs] != 0) {
+                        if (p_cnts[cs] != 0) {
+                                for (part_ptr = mtd_parts[cs], p = 0; p < p_cnts[cs]; p++, part_ptr++) {
+                                        if (part_ptr->name) {
+                                                kfree(part_ptr->name);
+                                                part_ptr->name = NULL;
+                                        }
+                                }
+                                del_mtd_partitions(mymtds[cs]);
+                                kfree(mtd_parts[cs]);
+                                mtd_parts[cs] = NULL;
+                        }
+                        del_mtd_device(mymtds[cs]);
+                        map_destroy(mymtds[cs]);
+                        iounmap(physmap_maps[cs].virt);
+                        physmap_maps[cs].virt = NULL;
+                }
+        }
+#else
 	struct physmap_flash_info *info;
 	struct physmap_flash_data *physmap_data;
 	int i;
@@ -58,6 +130,8 @@
 	if (physmap_data->exit)
 		physmap_data->exit(dev);
 
+#endif
+
 	return 0;
 }
 
@@ -93,11 +167,124 @@
 					"qinfo_probe",
 					"map_rom",
 					NULL };
+#ifndef CONFIG_TANGOX
 static const char *part_probe_types[] = { "cmdlinepart", "RedBoot", "afs",
 					  NULL };
-
+#endif
 static int physmap_flash_probe(struct platform_device *dev)
 {
+	const char **probe_type;
+
+#if defined(CONFIG_TANGOX) && defined(CONFIG_TANGOX_XENV_READ)
+        int cs;
+        int part_num = 0;
+        unsigned long csconfig = gbus_read_reg32(REG_BASE_host_interface + PB_CS_config) & 0xf;
+
+        for (cs = 0; cs < XENV_MAX_FLASH; cs++) {
+
+                /* Check XENV for availability */
+                f_sizes[cs] = p_cnts[cs] = 0;
+
+                tangox_flash_get_info(cs, &f_sizes[cs], &p_cnts[cs]);
+                if (f_sizes[cs] == 0)
+                        continue;
+                else {
+                        physmap_maps[cs].size = f_sizes[cs];
+                        physmap_maps[cs].bankwidth = ((csconfig >> cs) & 0x1) ? 1 : 2;
+                }
+
+                printk(KERN_NOTICE "physmap flash device CS%d: 0x%x at 0x%x\n",
+                                cs, (u32)physmap_maps[cs].size, (u32)physmap_maps[cs].phys);
+                physmap_maps[cs].virt = ioremap(physmap_maps[cs].phys, physmap_maps[cs].size);
+
+                if (!physmap_maps[cs].virt) {
+                        printk("Failed to ioremap\n");
+                        continue;
+                }
+
+                simple_map_init(&physmap_maps[cs]);
+
+                mymtds[cs] = NULL;
+                probe_type = rom_probe_types;
+                for(; !mymtds[cs] && *probe_type; probe_type++) {
+                        mymtds[cs] = do_map_probe(*probe_type, &physmap_maps[cs]);
+                }
+
+                if (mymtds[cs] && (mymtds[cs]->size != f_sizes[cs])) {
+                        /* Redo ioremap if size specified is not the same as detected */
+                        iounmap((void *)physmap_maps[cs].virt);
+                        physmap_maps[cs].size = mymtds[cs]->size;
+                        physmap_maps[cs].virt = ioremap(physmap_maps[cs].phys, physmap_maps[cs].size);
+
+                        if (!physmap_maps[cs].virt) {
+                                printk(KERN_NOTICE "Failed to ioremap at 0x%08x, size 0x%08x\n",
+                                                (u32)physmap_maps[cs].phys, (u32)physmap_maps[cs].size);
+                                continue;
+                        }
+                        printk(KERN_NOTICE "CS%d: flash size mismatched, re-do probing/initialization.\n", cs);
+                        printk(KERN_NOTICE "physmap flash device CS%d: 0x%x at 0x%x (remapped 0x%x)\n",
+                                        cs, (u32)physmap_maps[cs].size, (u32)physmap_maps[cs].phys, (u32)physmap_maps[cs].virt);
+
+                        /* Re-do initialization */
+                        simple_map_init(&physmap_maps[cs]);
+                        mymtds[cs] = NULL;
+                        probe_type = rom_probe_types;
+                        for(; !mymtds[cs] && *probe_type; probe_type++) {
+                                mymtds[cs] = do_map_probe(*probe_type, &physmap_maps[cs]);
+                        }
+                }
+
+                if (mymtds[cs]) {
+                        mymtds[cs]->owner = THIS_MODULE;
+                        add_mtd_device(mymtds[cs]);
+                        part_num++;
+
+
+                        if (p_cnts[cs] > 0) {
+                                int p, pcnt;
+                                struct mtd_partition *part_ptr;
+                                u64 offsets[XENV_MAX_FLASH_PARTITIONS];
+                                u64 szs[XENV_MAX_FLASH_PARTITIONS];
+
+                                if ((mtd_parts[cs] = (struct mtd_partition *)kmalloc(
+                                                sizeof(struct mtd_partition) * p_cnts[cs], GFP_KERNEL)) == NULL) {
+                                        printk(KERN_NOTICE "Out of memory.\n");
+                                        return -ENOMEM;
+                                }
+                                memset(mtd_parts[cs], 0, sizeof(struct mtd_partition) * p_cnts[cs]);
+                                tangox_flash_get_parts(cs, offsets, szs);
+
+                                printk(KERN_NOTICE "Using physmap partition definition\n");
+
+                                /* Initialize each partition */
+                                for (pcnt = 0, part_ptr = mtd_parts[cs], p = 0; p < p_cnts[cs]; p++) {
+                                        if (((szs[p] & 0x7fffffff) + offsets[p]) > physmap_maps[cs].size) {
+                                                printk(KERN_NOTICE "CS%d-Part%d (offset:0x%llx, size:0x%llx) outside physical map, removed.\n",
+                                                                cs, p + 1, offsets[p], szs[p] & 0x7fffffffffffffffULL);
+                                                        continue;
+                                        }
+                                        part_ptr->size = szs[p] & 0x7fffffffffffffffULL;
+                                        part_ptr->offset = offsets[p];
+                                        if (part_ptr->size & 0x8000000000000000ULL)
+                                                part_ptr->mask_flags = MTD_WRITEABLE;
+                                        part_ptr->name = (char *)kmalloc(16, GFP_KERNEL);
+                                        if (part_ptr->name != NULL)
+                                                sprintf(part_ptr->name, "CS%d-Part%d", cs, p + 1);
+                                        pcnt++;
+                                        part_ptr++;
+                                }
+                                p_cnts[cs] = pcnt;
+
+                                if (p_cnts[cs] > 0) {
+                                        printk(KERN_NOTICE "Adding partition #%d-#%d\n", part_num, part_num + p_cnts[cs] - 1);
+                                        add_mtd_partitions(mymtds[cs], mtd_parts[cs], p_cnts[cs]);
+                                        part_num += p_cnts[cs];
+                                }
+                        }
+                }
+        }
+        return 0;
+#else
 	struct physmap_flash_data *physmap_data;
 	struct physmap_flash_info *info;
 	const char **probe_type;
@@ -199,9 +386,10 @@
 err_out:
 	physmap_flash_remove(dev);
 	return err;
+#endif /* CONFIG_TANGOX && CONFIG_TANGOX_XENV_READ */
 }
 
-#ifdef CONFIG_PM
+#if  defined(CONFIG_PM) && !defined(CONFIG_TANGOX)  
 static void physmap_flash_shutdown(struct platform_device *dev)
 {
 	struct physmap_flash_info *info = platform_get_drvdata(dev);
@@ -218,7 +406,9 @@
 static struct platform_driver physmap_flash_driver = {
 	.probe		= physmap_flash_probe,
 	.remove		= physmap_flash_remove,
+#if  defined(CONFIG_PM) && !defined(CONFIG_TANGOX) 
 	.shutdown	= physmap_flash_shutdown,
+#endif
 	.driver		= {
 		.name	= "physmap-flash",
 		.owner	= THIS_MODULE,
@@ -261,11 +451,20 @@
 	}
 #endif
 
+#ifdef CONFIG_TANGOX
+	/* a hack to force probing here */
+	err = physmap_flash_probe(NULL);
+#endif
+
 	return err;
 }
 
 static void __exit physmap_exit(void)
 {
+#ifdef CONFIG_TANGOX
+	physmap_flash_remove(NULL);
+#endif
+
 #ifdef CONFIG_MTD_PHYSMAP_COMPAT
 	platform_device_unregister(&physmap_flash);
 #endif
diff -Naur linux-3.9.2.ref/drivers/net/ethernet/Kconfig linux-3.9.2/drivers/net/ethernet/Kconfig
--- linux-3.9.2.ref/drivers/net/ethernet/Kconfig	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/drivers/net/ethernet/Kconfig	2013-07-23 19:31:08.000000000 +0200
@@ -72,6 +72,90 @@
 	  To compile this driver as a module, choose M here. The module
 	  will be called jme.
 
+config TANGO2_ENET
+	tristate "SMP863x Builtin Ethernet support"
+	depends on TANGO2 
+	select NET_CORE
+	select MII
+	select CRC32
+	help
+	 This option adds support for the SMP863x integrated Ethernet
+	 controller.  This driver uses NAPI and generic Linux MII
+	 support.
+
+config TANGOX_ENET
+	tristate "SMP8xxx Builtin Gigabit Ethernet support (SMP864x/SMP865x/SMP867x/SMP89xx)"
+	depends on (TANGO3 || TANGO4)
+	select NET_CORE
+	select MII
+	select CRC32
+	help
+	 This option adds support for the SMP8xxx integrated Gigabit Ethernet
+	 controller.  This driver uses NAPI and generic Linux MII
+	 support.
+
+config TANGOX_ENET0_NOMDIO
+	bool "No MDIO access on ethernet 0"
+	depends on TANGOX_ENET
+	default n
+	help
+	 This option disable the MDIO access, which is needed for some PHY 
+	 emulation device (e.g. Ralink RT2880F wireless card).
+
+config TANGOX_ENET0_NOMDIO_SPEED
+	int "Hard wired communication speed"
+	depends on TANGOX_ENET0_NOMDIO
+	default 100
+	help
+	 Without MDIO access, the speed needs to be hardwired. Valid number
+	 is 10 or 100.
+
+config TANGOX_ENET0_NOMDIO_FULLDUPLEX
+	bool "Hard wired duplex mode"
+	depends on TANGOX_ENET0_NOMDIO
+	default y
+	help
+	 Without MDIO access, the duplex mode needs to be hardwired. 
+
+config TANGOX_ENET0_NOMDIO_PHY_ADDR
+	int "Hard wired PHY address"
+	depends on TANGOX_ENET0_NOMDIO
+	default 1
+	help
+	 Without MDIO access, the PHY address speed needs to be hardwired. 
+	 Valid number is 0~31.
+
+config TANGOX_ENET1_NOMDIO
+	bool "No MDIO access on ethernet 1"
+	depends on TANGOX_ENET
+	default n
+	help
+	 This option disable the MDIO access, which is needed for some PHY 
+	 emulation device (e.g. Ralink RT2880F wireless card).
+
+config TANGOX_ENET1_NOMDIO_SPEED
+	int "Hard wired communication speed"
+	depends on TANGOX_ENET1_NOMDIO
+	default 100
+	help
+	 Without MDIO access, the speed needs to be hardwired. Valid number
+	 is 10 or 100.
+
+config TANGOX_ENET1_NOMDIO_FULLDUPLEX
+	bool "Hard wired duplex mode"
+	depends on TANGOX_ENET1_NOMDIO
+	default y
+	help
+	 Without MDIO access, the duplex mode needs to be hardwired. 
+
+config TANGOX_ENET1_NOMDIO_PHY_ADDR
+	int "Hard wired PHY address"
+	depends on TANGOX_ENET1_NOMDIO
+	default 1
+	help
+	 Without MDIO access, the PHY address speed needs to be hardwired. 
+	 Valid number is 0~31.
+
 config KORINA
 	tristate "Korina (IDT RC32434) Ethernet support"
 	depends on MIKROTIK_RB532
diff -Naur linux-3.9.2.ref/drivers/net/ethernet/Makefile linux-3.9.2/drivers/net/ethernet/Makefile
--- linux-3.9.2.ref/drivers/net/ethernet/Makefile	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/drivers/net/ethernet/Makefile	2013-07-23 19:31:08.000000000 +0200
@@ -34,6 +34,10 @@
 obj-$(CONFIG_NET_VENDOR_XSCALE) += xscale/
 obj-$(CONFIG_IP1000) += icplus/
 obj-$(CONFIG_JME) += jme.o
+# For SMP863x ethernet (Tango2)
+obj-$(CONFIG_TANGO2_ENET) += tango2_enet.o
+# For SMP8xxx ethernet (Tango3/Tango4)
+obj-$(CONFIG_TANGOX_ENET) += tangox_enet.o
 obj-$(CONFIG_KORINA) += korina.o
 obj-$(CONFIG_LANTIQ_ETOP) += lantiq_etop.o
 obj-$(CONFIG_NET_VENDOR_MARVELL) += marvell/
diff -Naur linux-3.9.2.ref/drivers/net/ethernet/tango2_enet.c linux-3.9.2/drivers/net/ethernet/tango2_enet.c
--- linux-3.9.2.ref/drivers/net/ethernet/tango2_enet.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/drivers/net/ethernet/tango2_enet.c	2013-07-23 19:31:09.000000000 +0200
@@ -0,0 +1,1110 @@
+/*
+ * New driver for SMP863x builtin Ethernet mac
+ *
+ * This driver uses NAPI and generic linux MII support.
+ *
+ * Tx path limits the number of interrupt by reclaiming sent buffer in
+ * a timer.  In case  the tx starts  to go  faster, it will  switch to
+ * interrupt mode.
+ *
+ * Note that OOM condition is not handled correctly, and can leave the
+ * rx path  in bad  shape. down/up the  interface should make  it work
+ * again though. But anyway, it's not likely to happen.
+ *
+ * Copyright (C) 2005 Maxime Bizon <mbizon@freebox.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/etherdevice.h>
+#include <linux/delay.h>
+#include <linux/ethtool.h>
+#include <linux/crc32.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+
+#include "tango2_enet.h"
+
+#define PFX	"tango2_enet: "
+
+static struct net_device *gdev;
+static int gphy_id = -1;
+
+/*
+ * mdio read/write callback, can run from userspace or timer
+ */
+static __inline int enet_mdio_read(struct net_device *dev, int phy_id,
+				   int location)
+{
+	int val;
+
+	while (enet_readl(ENET_MAC_MIIAR) & MIIAR_BUSY);
+	enet_writel(ENET_MAC_MIIAR, MIIAR_ADDR(phy_id) | MIIAR_REG(location));
+	udelay(1);
+	while (enet_readl(ENET_MAC_MIIAR) & MIIAR_BUSY);
+	val = enet_readl(ENET_MAC_MIIDR);
+
+	return val;
+}
+
+static void enet_mdio_write(struct net_device *dev, int phy_id,
+				     int location, int val)
+{
+	enet_writel(ENET_MAC_MIIDR, val);
+	enet_writel(ENET_MAC_MIIAR,
+		    MIIAR_ADDR(phy_id) | MIIAR_REG(location) | MIIAR_WRITE);
+	udelay(1);
+	while (enet_readl(ENET_MAC_MIIAR) & MIIAR_BUSY);
+}
+
+/*
+ * enable/disable interrupt helpers
+ * need proper locks since we will call them from any context
+ */
+static __inline void enet_disable_interrupts(struct tango2_enet_priv *priv,
+					     int rx_only)
+{
+	unsigned long flags, val;
+
+	spin_lock_irqsave(&priv->ier_lock, flags);
+	if (rx_only) {
+		val = enet_readl(ENET_DMA_IER);
+		val &= ~IER_R;
+		enet_writel(ENET_DMA_IER, val);
+	} else
+		enet_writel(ENET_DMA_IER, 0);
+	spin_unlock_irqrestore(&priv->ier_lock, flags);
+}
+
+static __inline void enet_enable_interrupts(struct tango2_enet_priv *priv,
+					    int rx_only)
+{
+	unsigned long flags, val;
+
+	spin_lock_irqsave(&priv->ier_lock, flags);
+	if (rx_only) {
+		val = enet_readl(ENET_DMA_IER);
+		val |= IER_R;
+		enet_writel(ENET_DMA_IER, val);
+	} else
+		enet_writel(ENET_DMA_IER, IER_NIS | IER_R | IER_T);
+	spin_unlock_irqrestore(&priv->ier_lock, flags);
+}
+
+
+/*
+ * rx poll func, called by network core
+ */
+static int enet_poll(struct napi_struct *napi, int budget)
+{
+	struct tango2_enet_priv *priv;
+	struct net_device *dev;
+	int limit, received;
+
+	priv = container_of(napi, struct tango2_enet_priv, napi);
+	dev = napi->dev;
+
+	/* calculate how many rx packet we are allowed to fetch */
+	limit = budget;
+	received = 0;
+
+	/* process no more than "limit" done rx */
+	do {
+		volatile struct enet_rx_desc *rx;
+		struct sk_buff *skb;
+		uint32_t rdes0_cache;
+		unsigned int len;
+
+		rx = &priv->rx_descs[priv->last_rx_desc];
+
+		/* we  need  multiple  read  on this  volatile,  avoid
+		 * memory access at each time */
+		rdes0_cache = rx->rdes0;
+		if (rdes0_cache & RDES0_OWN) {
+			break;
+		}
+
+		if (limit <= 0)
+			break;
+		--limit;
+
+		if (likely(skb = priv->rx_skbs[priv->last_rx_desc])) {
+
+			/* we don't handle multipacket frame */
+			if (!(rdes0_cache & RDES0_FIRST) ||
+			    !(rdes0_cache & RDES0_LAST)) {
+				/* we don't handle multipacket frame */
+				priv->stats.rx_errors++;
+				priv->stats.rx_length_errors++;
+				goto rearm;
+			}
+
+			/* check for CRC */
+			if (rdes0_cache & RDES0_CRC) {
+				priv->stats.rx_errors++;
+				priv->stats.rx_crc_errors++;
+				goto rearm;
+			}
+
+			/* sanity check on len field */
+			len = RDES0_FRAME_LEN(rdes0_cache);
+			if (rdes0_cache & (RDES0_TOO_LONG | RDES0_TRUNC) ||
+			    len > RX_BUF_SIZE) {
+				priv->stats.rx_errors++;
+				priv->stats.rx_length_errors++;
+				goto rearm;
+			}
+
+			/* check remaining error */
+			if (rdes0_cache & (RDES0_ERR_SUM | RDES0_COLLISION |
+					   RDES0_WATCHDOG_TMOUT |
+					   RDES0_MII_ERROR)) {
+				priv->stats.rx_errors++;
+				goto rearm;
+			}
+
+			/* ok, seems  valid, adjust skb  proto and len
+			 * and give it to kernel */
+			skb->dev = dev;
+			skb_put(skb, len);
+			skb->protocol = eth_type_trans(skb, dev);
+			netif_receive_skb(skb);
+
+			priv->stats.rx_packets++;
+			priv->stats.rx_bytes += len;
+			dev->last_rx = jiffies;
+			priv->rx_skbs[priv->last_rx_desc] = NULL;
+			/* we will realloc an skb for this slot */
+		}
+
+		skb = dev_alloc_skb(RX_BUF_SIZE + SKB_RESERVE_SIZE);
+		if (unlikely(!skb))
+			break;
+
+		skb_reserve(skb, SKB_RESERVE_SIZE);
+		rx->rdes2 = PHYSADDR(skb->data);
+		dma_cache_inv((unsigned long)skb->data, RX_BUF_SIZE);
+		priv->rx_skbs[priv->last_rx_desc] = skb;
+
+rearm:
+		/* rearm descriptor */
+		wmb();
+		rx->rdes0 = RDES0_OWN;
+		priv->last_rx_desc++;
+		priv->last_rx_desc &= (ENET_RX_DESC_COUNT - 1);
+		received++;
+
+	} while (1);
+
+	budget -= received;
+
+	if (limit <= 0) {
+		/* breaked, but there is still work to do */
+		return 1;
+	}
+
+	__napi_complete(napi);
+	enet_enable_interrupts(priv, 1);
+
+	return 0;
+}
+
+/*
+ * tx reclaim func. Called by timer or tx done tasklet to reclaim sent
+ * buffers.
+ */
+static void enet_tx_reclaim(unsigned long data)
+{
+	struct net_device *dev;
+	struct tango2_enet_priv *priv;
+	volatile struct enet_tx_desc *tx;
+
+	dev = (struct net_device *)data;
+	priv = netdev_priv(dev);
+
+	spin_lock(&priv->tx_lock);
+
+	while (priv->free_tx_desc_count < ENET_TX_DESC_COUNT) {
+		uint32_t tdes0_cache;
+		struct sk_buff *skb;
+
+		tx = &priv->tx_descs[priv->dirty_tx_desc];
+
+		tdes0_cache = tx->tdes0;
+		if (tdes0_cache & TDES0_OWN)
+			break;
+
+		skb = priv->tx_skbs[priv->dirty_tx_desc];
+		priv->stats.tx_packets++;
+
+		/* check  for  transmission  errors and  update  stats
+		 * accordingly */
+		if (tdes0_cache & (TDES0_ERR_SUM | TDES0_CARRIER_LOST |
+				   TDES0_NO_CARRIER | TDES0_LATE_COLLISION |
+				   TDES0_EXC_COLLISION | TDES0_HEARTBEAT |
+				   TDES0_EXC_DEFERAL | TDES0_UNDERFLOW)) {
+			priv->stats.tx_errors++;
+		} else {
+			priv->stats.tx_bytes += skb->len;
+		}
+
+		dev_kfree_skb(skb);
+		priv->tx_skbs[priv->dirty_tx_desc] = NULL;
+		priv->dirty_tx_desc++;
+		priv->dirty_tx_desc %= ENET_TX_DESC_COUNT;
+		priv->free_tx_desc_count++;
+	}
+
+	if (priv->free_tx_desc_count != 0 && netif_queue_stopped(dev))
+		netif_wake_queue(dev);
+
+	spin_unlock(&priv->tx_lock);
+}
+
+/*
+ * tx done timer callback, just call tx_done and reschedule timer
+ */
+static void enet_tx_reclaim_timer(unsigned long data)
+{
+	struct net_device *dev;
+	struct tango2_enet_priv *priv;
+
+	dev = (struct net_device *)data;
+	priv = netdev_priv(dev);
+	enet_tx_reclaim(data);
+
+	priv->tx_reclaim_timer.expires = jiffies + TX_RECLAIM_TIMER_FREQ;
+	add_timer(&priv->tx_reclaim_timer);
+}
+
+
+/*
+ * tx request callback
+ */
+static int enet_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct tango2_enet_priv *priv;
+	volatile struct enet_tx_desc *tx;
+	unsigned long tdes1_cache;
+
+	priv = netdev_priv(dev);
+	spin_lock(&priv->tx_lock);
+
+	tx = &priv->tx_descs[priv->next_tx_desc];
+
+	/* make sure the next free tx desc is available */
+	if (unlikely(priv->free_tx_desc_count == 0)) {
+		/* no, this  should not happen since  queue is stopped
+		 * before we run out of tx desc */
+		printk(KERN_WARNING PFX "no free tx desc to handle pkt\n");
+		netif_stop_queue(dev);
+		spin_unlock(&priv->tx_lock);
+		return NETDEV_TX_BUSY;
+	}
+
+	/* fill the tx desc with this skb address */
+	tdes1_cache = (TDES1_FIRST | TDES1_LAST);
+	if (priv->next_tx_desc == ENET_TX_DESC_COUNT - 1)
+		tdes1_cache |= TDES1_TER;
+
+	/* if we  start to  run low  on free tx  desc, then  enable tx
+	 * interrupt to reclaim them faster */
+	if (priv->free_tx_desc_count == ENET_TX_DESC_LOW) {
+		tdes1_cache |= (TDES1_ENABLE_ISR);
+	}
+	tdes1_cache |= TDES1_TBS1(skb->len);
+
+	tx->tdes1 = tdes1_cache;
+	tx->tdes2 = PHYSADDR(skb->data);
+	dma_cache_wback((unsigned long)skb->data, skb->len);
+
+	/* keep a pointer to it for later and give it to dma  */
+	priv->tx_skbs[priv->next_tx_desc] = skb;
+	wmb();
+	tx->tdes0 = TDES0_OWN;
+
+	/* kick tx dma in case it was suspended */
+	wmb();
+	enet_writel(ENET_DMA_TPDR, 0x1);
+
+	priv->next_tx_desc++;
+	priv->next_tx_desc %= ENET_TX_DESC_COUNT;
+
+	/* if next  tx descriptor is not  clean, then we  have to stop
+	 * queue */
+	if (unlikely(--priv->free_tx_desc_count == 0))
+		netif_stop_queue(dev);
+
+	spin_unlock(&priv->tx_lock);
+
+	return NETDEV_TX_OK;
+}
+
+/*
+ * our  irq handler, just  ack it  and schedule  the right  tasklet to
+ * handle this
+ */
+static irqreturn_t enet_isr(int irq, void *dev_id)
+{
+	struct net_device *dev;
+	struct tango2_enet_priv *priv;
+	unsigned long val;
+
+	dev = (struct net_device *)dev_id;
+	priv = netdev_priv(dev);
+
+	/* fetch status & ack them */
+	val = enet_readl(ENET_DMA_SR);
+	enet_writel(ENET_DMA_SR, val);
+
+	/* handle interrupt */
+	if (val & SR_NIS) {
+		if (val & SR_T) {
+			tasklet_schedule(&priv->tx_reclaim_tasklet);
+		}
+
+		if (val & SR_R) {
+			if (napi_schedule_prep(&priv->napi)) {
+				/* disable rx interrupt */
+				enet_disable_interrupts(priv, 1);
+
+				/* ack  any  interrupt  that may  have
+				 * arrived  between last ack  to avoid
+				 * reentering */
+				enet_writel(ENET_DMA_SR, SR_NIS | SR_R);
+				__napi_schedule(&priv->napi);
+			}
+		}
+	}
+
+        return IRQ_HANDLED;
+}
+
+/*
+ * start/stop dma engine
+ */
+static __inline void enet_start_dma(struct tango2_enet_priv *priv)
+{
+	/* send start command to rx & tx dma */
+	enet_writel(ENET_DMA_CR, CR_SF | CR_SR | CR_ST);
+}
+
+static __inline void enet_stop_dma(struct tango2_enet_priv *priv)
+{
+	unsigned long val;
+
+	/* send stop command to rx & tx dma */
+	enet_writel(ENET_DMA_CR, 0);
+
+	/* wait for them to reach stopped state, should not be long */
+	do {
+		udelay(1);
+		val = enet_readl(ENET_DMA_SR);
+		if ((val & SR_TPS) && (val & SR_RPS))
+			break;
+	} while (1);
+}
+
+/*
+ * reconfigure mac for new link state
+ */
+static void enet_link_reconfigure(struct net_device *dev)
+{
+	struct tango2_enet_priv *priv;
+	unsigned long val;
+
+	priv = netdev_priv(dev);
+
+	if (dev->flags & IFF_UP)
+		enet_stop_dma(priv);
+
+	/* reflect duplex status in dma register */
+	spin_lock(&priv->maccr_lock);
+	val = enet_readl(ENET_MAC_MACCR);
+	if (priv->mii.full_duplex)
+		val |= MACCR_F;
+	else
+		val &= ~MACCR_F;
+	enet_writel(ENET_MAC_MACCR, val);
+	spin_unlock(&priv->maccr_lock);
+
+	if (dev->flags & IFF_UP)
+		enet_start_dma(priv);
+}
+
+/*
+ * link check timer callback
+ */
+static void enet_link_check(unsigned long data)
+{
+	struct net_device *dev;
+	struct tango2_enet_priv *priv;
+	int ret;
+
+	dev = (struct net_device *)data;
+	priv = netdev_priv(dev);
+
+	/* check for duplex change */
+	spin_lock(&priv->mii_lock);
+	ret = mii_check_media(&priv->mii, 1, 0);
+	spin_unlock(&priv->mii_lock);
+
+	if (ret)
+		enet_link_reconfigure(dev);
+
+	/* reschedule timer */
+	priv->link_check_timer.expires = jiffies + LINK_CHECK_TIMER_FREQ;
+	add_timer(&priv->link_check_timer);
+}
+
+/*
+ * program given mac address in hw registers
+ */
+static int enet_set_mac_address(struct net_device *dev, void *addr)
+{
+	unsigned long hi_mac, low_mac;
+	struct sockaddr *sock = addr;
+
+	/* to make it safe, we won't do this while running */
+	if (netif_running(dev))
+		return -EBUSY;
+
+	memcpy(dev->dev_addr, sock->sa_data, ETH_ALEN);
+
+	hi_mac = (dev->dev_addr[5] << 8) | dev->dev_addr[4];
+	low_mac = (dev->dev_addr[3] << 24)| (dev->dev_addr[2] << 16) |
+		(dev->dev_addr[1] << 8) | dev->dev_addr[0];
+
+	enet_writel(ENET_MAC_MACAHR, hi_mac);
+	enet_writel(ENET_MAC_MACALR, low_mac);
+
+	return 0;
+}
+
+/*
+ * update hash table to reflect new device multicast address list
+ */
+static void enet_set_multicast_list(struct net_device *dev)
+{
+	struct tango2_enet_priv *priv;
+	struct netdev_hw_addr *ha;
+	unsigned long val;
+	uint32_t mc_filter[2];
+	
+
+	priv = netdev_priv(dev);
+
+	/* the link check timer might change MACCR, we need to protect
+	 * against it */
+	spin_lock_bh(&priv->maccr_lock);
+	val = enet_readl(ENET_MAC_MACCR);
+
+        if (dev->flags & IFF_PROMISC) {
+                val |= MACCR_PR | MACCR_PM;
+	} else {
+		val &= ~MACCR_PR;
+		/* if we want all multicast or if address count is too
+		 * high, don't try to compute hash value */
+		if (netdev_mc_count(dev) > 64 || dev->flags & IFF_ALLMULTI) {
+			val |= MACCR_PM;
+		}
+	}
+	enet_writel(ENET_MAC_MACCR, val);
+	spin_unlock_bh(&priv->maccr_lock);
+
+	/* we  don't  need  to  update  hash  table  if  we  pass  all
+	 * multicast */
+	if (val & MACCR_PM)
+		return;
+
+	mc_filter[0] = mc_filter[1] = 0;
+	
+
+	netdev_for_each_mc_addr(ha, dev)  {
+		unsigned int n;
+		char *addr;
+
+		addr = ha->addr;
+		if (!(*addr & 1))
+			continue;
+
+		n = ether_crc(ETH_ALEN, addr) >> 26;
+		mc_filter[n >> 5] |= 1 << (n & 31);
+	}
+
+	enet_writel(ENET_MAC_MALR, mc_filter[0]);
+	enet_writel(ENET_MAC_MAHR, mc_filter[1]);
+}
+
+/*
+ * open callback
+ */
+static int enet_open(struct net_device *dev)
+{
+	struct tango2_enet_priv *priv;
+	unsigned long val;
+
+	priv = netdev_priv(dev);
+
+	/* check link */
+	if (mii_check_media(&priv->mii, 1, 1))
+		enet_link_reconfigure(dev);
+
+	/* start rx & tx dma engine */
+	enet_start_dma(priv);
+
+	/* enable mac rx & tx */
+	val = enet_readl(ENET_MAC_MACCR);
+	val |= MACCR_TE | MACCR_RE;
+	enet_writel(ENET_MAC_MACCR, val);
+
+	/*
+	 * clear & enable interrupts, we want:
+	 * - receive complete
+	 * - transmit complete
+	 */
+	enet_writel(ENET_DMA_SR, SR_NIS | SR_R | SR_T);
+	enet_enable_interrupts(priv, 0);
+
+	/* start link check & tx reclaim timer */
+	priv->link_check_timer.expires = jiffies + LINK_CHECK_TIMER_FREQ;
+	add_timer(&priv->link_check_timer);
+
+	priv->tx_reclaim_timer.expires = jiffies + TX_RECLAIM_TIMER_FREQ;
+	add_timer(&priv->tx_reclaim_timer);
+
+	/* and finally start tx queue */
+	netif_start_queue(dev);
+
+	/*enable napi */
+	napi_enable(&priv->napi);
+
+	return 0;
+}
+
+/*
+ * stop callback
+ */
+static int enet_stop(struct net_device *dev)
+{
+	struct tango2_enet_priv *priv;
+	unsigned long val;
+	int i;
+
+	priv = netdev_priv(dev);
+
+	/* stop link timer */
+	del_timer_sync(&priv->link_check_timer);
+
+	/* stop tx queue */
+	netif_stop_queue(dev);
+
+	/*disable napi*/
+	napi_disable(&priv->napi);
+
+	/* wait for all tx buffers to be reclaimed */
+	while (priv->free_tx_desc_count != ENET_TX_DESC_COUNT)
+		yield();
+
+	/* stop tx reclaim timer */
+	del_timer_sync(&priv->tx_reclaim_timer);
+
+	/* disable all interrupts */
+	enet_disable_interrupts(priv, 0);
+
+	/* stop dma */
+	enet_stop_dma(priv);
+
+	/* stop mac rx & tx */
+	val = enet_readl(ENET_MAC_MACCR);
+	val &= ~(MACCR_TE | MACCR_RE);
+	enet_writel(ENET_MAC_MACCR, val);
+
+	/* while we were stopping it,  the rx dma may have filled some
+	 * buffer, consider it junk and rearm all descriptor */
+	for (i = 0; i < ENET_RX_DESC_COUNT; i++) {
+		volatile struct enet_rx_desc *rx;
+
+		rx = &priv->rx_descs[i];
+		rx->rdes0 = RDES0_OWN;
+	}
+
+	/* make  the dma engine  restarts at  first descriptor  in the
+	 * list */
+	enet_writel(ENET_DMA_RBAR, PHYSADDR(priv->rx_descs));
+	enet_writel(ENET_DMA_TBAR, PHYSADDR(priv->tx_descs));
+	priv->dirty_tx_desc = priv->next_tx_desc = 0;
+	priv->last_rx_desc = 0;
+
+	return 0;
+}
+
+/*
+ * get_stats callback
+ */
+static struct net_device_stats *enet_get_stats(struct net_device *dev)
+{
+	struct tango2_enet_priv *priv;
+
+	priv = netdev_priv(dev);
+
+	return &priv->stats;
+}
+
+/*
+ * ethtool callbacks
+ */
+static int enet_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct tango2_enet_priv *priv;
+	int ret;
+
+	priv = netdev_priv(dev);
+
+	spin_lock_bh(&priv->mii_lock);
+	ret = mii_ethtool_gset(&priv->mii, cmd);
+	spin_unlock_bh(&priv->mii_lock);
+
+	return ret;
+}
+
+static int enet_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct tango2_enet_priv *priv;
+	int ret;
+
+	priv = netdev_priv(dev);
+
+	spin_lock_bh(&priv->mii_lock);
+	ret = mii_ethtool_sset(&priv->mii, cmd);
+	spin_unlock_bh(&priv->mii_lock);
+
+	return ret;
+}
+
+static int enet_nway_reset(struct net_device *dev)
+{
+	struct tango2_enet_priv *priv;
+	int ret;
+
+	priv = netdev_priv(dev);
+
+	spin_lock_bh(&priv->mii_lock);
+	ret = mii_nway_restart(&priv->mii);
+	spin_unlock_bh(&priv->mii_lock);
+
+	return ret;
+}
+
+static u32 enet_get_link(struct net_device *dev)
+{
+	struct tango2_enet_priv *priv;
+	int ret;
+
+	priv = netdev_priv(dev);
+
+	spin_lock_bh(&priv->mii_lock);
+	ret = mii_link_ok(&priv->mii);
+	spin_unlock_bh(&priv->mii_lock);
+
+	return ret;
+}
+
+static struct ethtool_ops enet_ethtool_ops = {
+	.get_settings		= enet_get_settings,
+	.set_settings		= enet_set_settings,
+	.nway_reset		= enet_nway_reset,
+	.get_link		= enet_get_link,
+};
+
+static int enet_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	struct tango2_enet_priv *priv;
+	int ret;
+
+	priv = netdev_priv(dev);
+
+	spin_lock_bh(&priv->mii_lock);
+	ret = generic_mii_ioctl(&priv->mii, if_mii(rq), cmd, NULL);
+	spin_unlock_bh(&priv->mii_lock);
+
+	return ret;
+}
+
+/*
+ * dma ring allocation is done here
+ */
+static int enet_dma_init(struct tango2_enet_priv *priv)
+{
+	unsigned int size;
+	int i;
+
+	/*
+	 * allocate rx descriptor list & rx buffers
+	 *
+	 * We allocate  skb now and fill buffer  with their addresses,
+	 * note that we reserve 4 bytes at beginning of data buffer to
+	 * store skb address.
+	 *
+	 */
+	size = ENET_RX_DESC_COUNT * sizeof (struct enet_rx_desc);
+	if (!(priv->rx_descs_cached = kmalloc(size, GFP_KERNEL | GFP_DMA)))
+		return -ENOMEM;
+	priv->rx_descs = (volatile struct enet_rx_desc *)
+		CACHE_TO_NONCACHE((unsigned long)priv->rx_descs_cached);
+	dma_cache_wback_inv((unsigned long)priv->rx_descs_cached, size);
+
+	/*
+	 * initialize all rx descs
+	 */
+	for (i = 0; i < ENET_RX_DESC_COUNT; i++) {
+		volatile struct enet_rx_desc *rx;
+		struct sk_buff *skb;
+
+		rx = &priv->rx_descs[i];
+		rx->rdes0 = RDES0_OWN;
+
+		rx->rdes1 = RDES1_RBS2(0) | RDES1_RBS1(RX_BUF_SIZE);
+		if (i == ENET_RX_DESC_COUNT - 1)
+			rx->rdes1 |= RDES1_RER;
+
+		skb = dev_alloc_skb(RX_BUF_SIZE + SKB_RESERVE_SIZE);
+		if (!skb)
+			return -ENOMEM;
+
+		skb_reserve(skb, SKB_RESERVE_SIZE);
+		rx->rdes2 = PHYSADDR(skb->data);
+		rx->rdes3 = 0;
+
+		dma_cache_inv((unsigned long)skb->data, RX_BUF_SIZE);
+		priv->rx_skbs[i] = skb;
+	}
+	priv->last_rx_desc = 0;
+
+	/*
+	 * allocate tx descriptor list
+	 *
+	 * We allocate  only the descriptor list and  prepare them for
+	 * further use. When tx is needed, we will set the right flags
+	 * and kick the dma.
+	 */
+	size = ENET_TX_DESC_COUNT * sizeof (struct enet_tx_desc);
+	if (!(priv->tx_descs_cached = kmalloc(size, GFP_KERNEL | GFP_DMA)))
+		return -ENOMEM;
+	priv->tx_descs = (volatile struct enet_tx_desc *)
+		CACHE_TO_NONCACHE((unsigned long)priv->tx_descs_cached);
+	dma_cache_wback_inv((unsigned long)priv->tx_descs_cached, size);
+
+	/*
+	 * initialize tx descs
+	 */
+	for (i = 0; i < ENET_TX_DESC_COUNT; i++) {
+		volatile struct enet_tx_desc *tx;
+
+		tx = &priv->tx_descs[i];
+		tx->tdes0 = 0;
+		tx->tdes1 = 0;
+		if (i == ENET_TX_DESC_COUNT - 1)
+			tx->tdes1 |= TDES1_TER;
+		tx->tdes2 = 0;
+		tx->tdes3 = 0;
+	}
+	priv->dirty_tx_desc = priv->next_tx_desc = 0;
+	priv->free_tx_desc_count = ENET_TX_DESC_COUNT;
+
+	/*
+	 * write rx desc list & tx desc list addresses in registers
+	 */
+	enet_writel(ENET_DMA_RBAR, PHYSADDR(priv->rx_descs));
+	enet_writel(ENET_DMA_TBAR, PHYSADDR(priv->tx_descs));
+
+	return 0;
+}
+
+/*
+ * free  all dma rings  memory, called  at uninit  time or  when error
+ * occurs at init time
+ */
+static void enet_dma_free(struct tango2_enet_priv *priv)
+{
+	int i;
+
+	/* note: kfree(NULL) is ok */
+	kfree(priv->rx_descs_cached);
+	kfree(priv->tx_descs_cached);
+
+	/* note: kfree_skb(NULL) is _not_ ok */
+	for (i = 0; i < ENET_RX_DESC_COUNT; i++) {
+		if (priv->rx_skbs[i])
+			kfree_skb(priv->rx_skbs[i]);
+	}
+
+	for (i = 0; i < ENET_TX_DESC_COUNT; i++) {
+		if (priv->tx_skbs[i])
+			kfree_skb(priv->tx_skbs[i]);
+	}
+}
+
+/*
+ * mac hw init is done here
+ */
+static int enet_hw_init(struct net_device *dev)
+{
+	struct tango2_enet_priv *priv;
+	int loop;
+
+	priv = netdev_priv(dev);
+
+	/* reset phy */
+	enet_mdio_write(dev, priv->mii.phy_id, MII_BMCR, BMCR_RESET);
+
+	/* wait for the reset bit to clear */
+	udelay(100);
+	loop = 100;
+	while (loop) {
+		if (!(enet_mdio_read(dev, priv->mii.phy_id,
+				     MII_BMCR) & BMCR_RESET))
+			break;
+		mdelay(1);
+		loop--;
+	}
+
+	if (!loop) {
+		printk(KERN_ERR PFX "PHY reset does not complete...\n");
+		return -EBUSY;
+	}
+
+	/* reset dma engine */
+	enet_writel(ENET_DMA_BMR, BMR_SWR);
+
+	/* wait for the reset bit to clear */
+	udelay(100);
+	loop = 100;
+	while (loop) {
+		if (!(enet_readl(ENET_DMA_BMR) & BMR_SWR))
+			break;
+		mdelay(1);
+		loop--;
+	}
+
+	if (!loop) {
+		printk(KERN_ERR PFX "dma engine does not exit reset...\n");
+		return -EBUSY;
+	}
+
+	/* set bus mode */
+	enet_writel(ENET_DMA_BMR, BMR_PBL(32));
+
+	/* enable MAC flow ctrl */
+	enet_writel(ENET_MAC_FCR, FCR_ENABLE);
+
+	/* configure MAC ctrller to do hash perfect filtering  */
+	enet_writel(ENET_MAC_MACCR, MACCR_ASTP | MACCR_HP);
+
+	/* clear hash table */
+	enet_writel(ENET_MAC_MAHR, 0xffffffff);
+	enet_writel(ENET_MAC_MALR, 0xffffffff);
+
+	return 0;
+}
+
+static const struct net_device_ops tango2_netdev_ops = {
+	.ndo_open = enet_open,
+	.ndo_stop = enet_stop,
+	.ndo_start_xmit = enet_xmit,
+	.ndo_get_stats = enet_get_stats,
+	.ndo_set_mac_address = enet_set_mac_address,
+	.ndo_set_rx_mode = enet_set_multicast_list,
+	.ndo_do_ioctl = enet_ioctl,
+	.ndo_change_mtu = eth_change_mtu,
+	.ndo_validate_addr = eth_validate_addr,
+};
+
+/*
+ * allocate  netdevice structure,  do  all dma  rings allocations  and
+ * register the netdevice
+ */
+extern int tangox_ethernet_getmac(int, unsigned char *);
+
+static int enet_probe(void)
+{
+	struct tango2_enet_priv *priv;
+	struct net_device *dev;
+	int ret;
+	struct sockaddr sock;
+
+	printk(KERN_INFO PFX "ethernet driver for SMP863x internal mac\n");
+
+	/* allocate  netdevice structure  with enough  length  for our
+	 * context data */
+	dev = alloc_etherdev(sizeof (*priv));
+	if (!dev)
+		return -ENOMEM;
+
+	dev->netdev_ops = &tango2_netdev_ops;
+
+	/* initialize private data */
+	priv = netdev_priv(dev);
+	memset(priv, 0, sizeof (*priv));
+	spin_lock_init(&priv->tx_lock);
+	spin_lock_init(&priv->ier_lock);
+	spin_lock_init(&priv->maccr_lock);
+
+	/* init tx done tasklet */
+	tasklet_init(&priv->tx_reclaim_tasklet, enet_tx_reclaim,
+		     (unsigned long)dev);
+
+	/* init tx reclaim timer */
+	init_timer(&priv->tx_reclaim_timer);
+	priv->tx_reclaim_timer.data = (unsigned long )dev;
+	priv->tx_reclaim_timer.function = enet_tx_reclaim_timer;
+
+	/* init link check timer and mii lock */
+	init_timer(&priv->link_check_timer);
+	priv->link_check_timer.data = (unsigned long)dev;
+	priv->link_check_timer.function = enet_link_check;
+	spin_lock_init(&priv->mii_lock);
+
+	/* fill mii info */
+	priv->mii.dev = dev;
+	priv->mii.phy_id_mask = 0x1f;
+	priv->mii.reg_num_mask = 0x1f;
+	priv->mii.mdio_read = enet_mdio_read;
+	priv->mii.mdio_write = enet_mdio_write;
+
+	if (gphy_id != -1) {
+		/* phy id forced, just check for sanity */
+		if (gphy_id < 0 || gphy_id > 31) {
+			ret = -EINVAL;
+			goto err_free;
+		}
+		priv->mii.phy_id = gphy_id;
+
+	} else {
+		int i;
+
+		/* try to probe phy if not given */
+		for (i = 1; i < 32; i++) {
+			uint32_t id;
+			int val;
+
+			val = enet_mdio_read(dev, i, MII_PHYSID1);
+			id = (val << 16);
+			val = enet_mdio_read(dev, i, MII_PHYSID2);
+			id |= val;
+
+			if (id != 0xffffffff && id != 0x00000000)
+				break;
+		}
+
+		if (i == 32) {
+			printk(KERN_ERR PFX "unable to autodetect phy\n");
+			ret = -EIO;
+			goto err_free;
+		}
+
+		printk(KERN_ERR PFX "detected phy at address 0x%02x\n", i);
+		priv->mii.phy_id = i;
+	}
+
+	/* initialize hardware */
+	if ((ret = enet_hw_init(dev)))
+		goto err_free;
+
+	/* initialize dma rings */
+	if ((ret = enet_dma_init(priv)))
+		goto err_free;
+
+	SET_ETHTOOL_OPS(dev, &enet_ethtool_ops);
+	netif_napi_add(dev, &priv->napi, enet_poll, ENET_RX_DESC_COUNT);
+
+	/* set default mac address */
+	tangox_ethernet_getmac(0, dev->dev_addr);
+	memcpy(&(sock.sa_data), dev->dev_addr, ETH_ALEN);
+	enet_set_mac_address(dev, &sock);
+
+	if ((ret = register_netdev(dev))) {
+		printk(KERN_ERR PFX "unable to register netdevice\n");
+		goto err_free;
+	}
+	/* register interrupt handler */
+	ret = request_irq(ENET_IRQ, enet_isr, IRQF_SHARED, "tango2_enet", dev);
+	if (ret)
+		goto err_free;
+	dev->irq = ENET_IRQ;
+
+	printk(KERN_INFO PFX "mac address %02x:%02x:%02x:%02x:%02x:%02x\n",
+	       dev->dev_addr[0], dev->dev_addr[1], dev->dev_addr[2],
+	       dev->dev_addr[3], dev->dev_addr[4], dev->dev_addr[5]);
+
+	gdev = dev;
+	return 0;
+
+err_free:
+	if (dev->irq)
+		free_irq(dev->irq, dev);
+	enet_dma_free(priv);
+	free_netdev(dev);
+	return ret;
+}
+
+
+/*
+ * entry point, checks if ethernet is  enabled on the board and if so,
+ * probes it
+ */
+extern int tangox_ethernet_enabled(int);
+
+int __init tango2_enet_init(void)
+{
+	if (!tangox_ethernet_enabled(0)) {
+		printk(KERN_NOTICE PFX "ethernet support is disabled\n");
+		return -ENODEV;
+	}
+
+	return enet_probe();
+}
+
+/*
+ * exit func, stops hardware and unregisters netdevice
+ */
+void __exit tango2_enet_exit(void)
+{
+	struct tango2_enet_priv *priv;
+	struct net_device *dev;
+
+	dev = gdev;
+
+	free_irq(dev->irq, dev);
+	unregister_netdev(dev);
+
+	priv = netdev_priv(dev);
+	enet_dma_free(priv);
+
+	free_netdev(dev);
+}
+
+
+module_init(tango2_enet_init);
+module_exit(tango2_enet_exit);
+
+MODULE_DESCRIPTION("SMP863x internal ethernet mac driver");
+MODULE_AUTHOR("Maxime Bizon <mbizon@freebox.fr>");
+MODULE_LICENSE("GPL");
+MODULE_PARM_DESC(gphy_id, "PHY id, else autodetect");
+module_param(gphy_id, int, 0);
+
diff -Naur linux-3.9.2.ref/drivers/net/ethernet/tango2_enet.h linux-3.9.2/drivers/net/ethernet/tango2_enet.h
--- linux-3.9.2.ref/drivers/net/ethernet/tango2_enet.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/drivers/net/ethernet/tango2_enet.h	2013-07-23 19:31:09.000000000 +0200
@@ -0,0 +1,315 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+ 
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+  
+#ifndef __TANGO2_ENET_H
+#define __TANGO2_ENET_H
+
+#include <linux/types.h>
+#include <linux/skbuff.h>
+#include <linux/mii.h>
+#include <linux/timer.h>
+
+#include <asm/addrspace.h>
+
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/hardware.h>
+#include <asm/tango2/tango2_gbus.h>
+#include <asm/tango2/emhwlib_dram_tango2.h>
+#else
+#error "Unknown architecture"
+#endif
+
+#define ENET_IRQ	((IRQ_CONTROLLER_IRQ_BASE) + (LOG2_CPU_ETH_MAC_INT))
+
+/*
+ * number of rx/tx buffers available
+ * !!! MUST BE A POWER OF 2 !!!
+ */
+#define ENET_RX_DESC_COUNT	64
+#define ENET_TX_DESC_COUNT	64
+
+/*
+ * we enable tx  interrupt when there is equal to  this number of free
+ * tx desc. Keep it lower than ENET_TX_DESC_COUNT if you change it.
+ */
+#define ENET_TX_DESC_LOW	20
+
+/*
+ * sizeof rx buffers we give to the dma controller
+ */
+#define RX_BUF_SIZE		0x600
+
+/*
+ * ipv4 stack  assumes received  ip header is  32 bits aligned,  so we
+ * keep 2 bytes to align ip header
+ */
+#define SKB_RESERVE_SIZE	2
+
+/*
+ * we reclaim  transmited using a  timer, we switch to  interrupt mode
+ * under high load. this is the timer frequency
+ */
+#define TX_RECLAIM_TIMER_FREQ	(HZ / 100)
+
+/*
+ * link status  is polled on a regular  basis by a timer,  this is its
+ * frequency
+ */
+#define LINK_CHECK_TIMER_FREQ	(HZ)
+
+
+/*
+ * address space conversion
+ */
+#define CACHE_TO_NONCACHE(x)	KSEG1ADDR(x)
+#define PHYSADDR(x)		tangox_dma_address(CPHYSADDR(x))
+
+
+/*
+ * Mac/DMA registers offset, refer to documentation
+ */
+#define ENET_HOST_BASE		REG_BASE_host_interface
+
+/* mac registers */
+#define ENET_MAC_BASE		(ENET_HOST_BASE + 0x6000)
+#define ENET_MAC_MACCR		(ENET_MAC_BASE + 0x0)
+#define MACCR_F			(1 << 20)
+#define MACCR_PM		(1 << 19)
+#define MACCR_PR		(1 << 18)
+#define MACCR_HP		(1 << 13)
+#define MACCR_ASTP		(1 << 8)
+#define MACCR_TE		(1 << 3)
+#define MACCR_RE		(1 << 2)
+#define ENET_MAC_MACAHR		(ENET_MAC_BASE + 0x4)
+#define ENET_MAC_MACALR		(ENET_MAC_BASE + 0x8)
+#define ENET_MAC_MAHR		(ENET_MAC_BASE + 0xc)
+#define ENET_MAC_MALR		(ENET_MAC_BASE + 0x10)
+#define ENET_MAC_MIIAR		(ENET_MAC_BASE + 0x14)
+#define MIIAR_ADDR(x)		((x) << 11)
+#define MIIAR_REG(x)		((x) << 6)
+#define MIIAR_WRITE		(1 << 1)
+#define MIIAR_BUSY		(1 << 0)
+#define ENET_MAC_MIIDR		(ENET_MAC_BASE + 0x18)
+#define ENET_MAC_FCR		(ENET_MAC_BASE + 0x1c)
+#define FCR_ENABLE		(1 << 1)
+
+/* dma registers */
+#define ENET_DMA_BASE		(ENET_HOST_BASE + 0x7000)
+#define ENET_DMA_BMR		(ENET_DMA_BASE + 0x00)
+#define BMR_PBL(x)		((x & 0x3f) << 8)
+#define BMR_SWR			(1 << 0)
+#define ENET_DMA_TPDR		(ENET_DMA_BASE + 0x04)
+#define ENET_DMA_RPDR		(ENET_DMA_BASE + 0x08)
+#define ENET_DMA_RBAR		(ENET_DMA_BASE + 0x0c)
+#define ENET_DMA_TBAR		(ENET_DMA_BASE + 0x10)
+#define ENET_DMA_SR		(ENET_DMA_BASE + 0x14)
+#define SR_EB(x)		(((x) >> 23) & 0x3)
+#define SR_TS(x)		(((x) >> 20) & 0x7)
+#define SR_RS(x)		(((x) >> 17) & 0x7)
+#define SR_NIS			(1 << 16)
+#define SR_AIS			(1 << 15)
+#define SR_ERI			(1 << 14)
+#define SR_FBE			(1 << 13)
+#define SR_ETI			(1 << 12)
+#define SR_RWT			(1 << 11)
+#define SR_RPS			(1 << 8)
+#define SR_RU			(1 << 7)
+#define SR_R			(1 << 6)
+#define SR_UNF			(1 << 5)
+#define SR_TU			(1 << 4)
+#define SR_TPS			(1 << 1)
+#define SR_T			(1 << 0)
+#define ENET_DMA_CR		(ENET_DMA_BASE + 0x18)
+#define CR_SF			(1 << 21)
+#define CR_ST			(1 << 13)
+#define CR_SR			(1 << 1)
+#define ENET_DMA_IER		(ENET_DMA_BASE + 0x1c)
+#define IER_NIS			(1 << 16)
+#define IER_AIS			(1 << 15)
+#define IER_ERE			(1 << 14)
+#define IER_FBE			(1 << 13)
+#define IER_ETE			(1 << 10)
+#define IER_RWT			(1 << 9)
+#define IER_RS			(1 << 8)
+#define IER_RU			(1 << 7)
+#define IER_R			(1 << 6)
+#define IER_UE			(1 << 5)
+#define IER_TBU			(1 << 2)
+#define IER_TS			(1 << 1)
+#define IER_T			(1 << 0)
+#define ENET_DMA_CHRBA		(ENET_DMA_BASE + 0x54)
+
+
+/*
+ * rx dma descriptor definition
+ */
+struct enet_rx_desc {
+	unsigned long rdes0;
+	unsigned long rdes1;
+	unsigned long rdes2;
+	unsigned long rdes3;
+};
+
+#define RDES0_OWN		(1 << 31)
+#define RDES0_FILTER_FAIL	(1 << 30)
+#define RDES0_FRAME_LEN(x)	(((x) & 0x1fff0000) >> 16)
+#define RDES0_ERR_SUM		(1 << 15)
+#define RDES0_TRUNC		(1 << 14)
+#define RDES0_FIRST		(1 << 9)
+#define RDES0_LAST		(1 << 8)
+#define RDES0_TOO_LONG		(1 << 7)
+#define RDES0_COLLISION		(1 << 6)
+#define RDES0_WATCHDOG_TMOUT	(1 << 4)
+#define RDES0_MII_ERROR		(1 << 3)
+#define RDES0_CRC		(1 << 1)
+
+#define RDES1_DISABLE_ISR	(1 << 31)
+#define RDES1_RER		(1 << 25)
+#define RDES1_RCH		(1 << 24)
+#define RDES1_RBS2(x)		((x) << 11)
+#define RDES1_RBS1(x)		(x)
+
+
+
+/*
+ * tx dma descriptor definition
+ */
+struct enet_tx_desc {
+	uint32_t tdes0;
+	uint32_t tdes1;
+	uint32_t tdes2;
+	uint32_t tdes3;
+};
+
+#define TDES0_OWN		(1 << 31)
+#define TDES0_ERR_SUM		(1 << 15)
+#define TDES0_CARRIER_LOST	(1 << 11)
+#define TDES0_NO_CARRIER	(1 << 10)
+#define TDES0_LATE_COLLISION	(1 << 9)
+#define TDES0_EXC_COLLISION	(1 << 8)
+#define TDES0_HEARTBEAT		(1 << 7)
+#define TDES0_EXC_DEFERAL	(1 << 2)
+#define TDES0_UNDERFLOW		(1 << 1)
+
+#define TDES1_ENABLE_ISR	(1 << 31)
+#define TDES1_LAST	 	(1 << 30)
+#define TDES1_FIRST		(1 << 29)
+#define TDES1_DISABLE_FCS	(1 << 26)
+#define TDES1_TER	 	(1 << 25)
+#define TDES1_TCH	 	(1 << 24)
+#define TDES1_DISABLE_PADDING	(1 << 23)
+#define TDES1_TBS2(x)		((x) << 11)
+#define TDES1_TBS1(x)		(x)
+
+
+/*
+ * our private context
+ */
+struct tango2_enet_priv {
+
+	struct napi_struct napi;
+
+	/*
+	 * rx related
+	 */
+
+	/* pointer to rx descriptor array */
+	volatile struct enet_rx_desc	*rx_descs;
+	struct enet_rx_desc		*rx_descs_cached;
+
+	/* last rx descriptor processed */
+	unsigned int			last_rx_desc;
+
+	/* we keep a list of skb given */
+	struct sk_buff			*rx_skbs[ENET_RX_DESC_COUNT];
+
+	/* ethernet device stats */
+	struct net_device_stats		stats;
+
+
+
+
+	/*
+	 * tx related
+	 */
+
+	/* access  to  tx related  dma  stuffs  is  protected by  this
+	 * spinlock, this is because we  access them via a tasklet and
+	 * a timer */
+	spinlock_t			tx_lock;
+
+	/* pointer to tx descriptor array */
+	volatile struct enet_tx_desc	*tx_descs;
+	struct enet_tx_desc		*tx_descs_cached;
+
+	/* index of current dirty tx descriptor */
+	unsigned int			dirty_tx_desc;
+
+	/* index of next clean tx descriptor to use */
+	unsigned int			next_tx_desc;
+
+	/* count of free tx desc to avoid its computation */
+	unsigned int			free_tx_desc_count;
+
+	/* list of sent skb */
+	struct sk_buff			*tx_skbs[ENET_TX_DESC_COUNT];
+
+	/* tx  done operation is  done under  these tasklet  and timer
+	 * context */
+	struct tasklet_struct		tx_reclaim_tasklet;
+	struct timer_list		tx_reclaim_timer;
+
+
+	/*
+	 * misc
+	 */
+
+	/* spinlock used to protect interrupt enable register */
+	spinlock_t			ier_lock;
+
+	/* spinlock used to protect maccr register */
+	spinlock_t			maccr_lock;
+
+	/* our mii state */
+	struct mii_if_info		mii;
+
+	/* mii access is protected by following spinlock */
+	spinlock_t			mii_lock;
+
+	/* link status is checked periodically by this timer */
+	struct timer_list		link_check_timer;
+};
+
+/*
+ * helpers to access registers
+ */
+
+static inline unsigned long enet_readl(unsigned long addr)
+{
+	unsigned long tmp = 0;
+	unsigned long res = gbus_read_reg32(addr);
+	extern int is_tango2_es6(void);
+	if (is_tango2_es6()) 
+		tmp = gbus_read_reg32(REG_BASE_system_block + SYS_xtal_in_cnt);
+	return(res);
+}
+
+static inline void enet_writel(unsigned long addr, unsigned long data)
+{
+	gbus_write_reg32(addr, data);
+
+	/* some write  read sequence seems  to freeze completly  if no
+	 * barrier is done between each access. To be safe, we do this
+	 * after all write access */
+	iob();
+}
+
+#endif /* __TANGO2_ENET_H */
+
diff -Naur linux-3.9.2.ref/drivers/net/ethernet/tangox_enet.c linux-3.9.2/drivers/net/ethernet/tangox_enet.c
--- linux-3.9.2.ref/drivers/net/ethernet/tangox_enet.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/drivers/net/ethernet/tangox_enet.c	2013-07-23 19:31:09.000000000 +0200
@@ -0,0 +1,2002 @@
+/*********************************************************************
+ Copyright (C) 2001-2011
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/*
+ * Driver for tangox SMP864x/SMP865x/SMP867x/SMP868x builtin Ethernet Mac.
+ * The Driver makes use of the tango2_enet framework
+ * written by Maxime Bizon.
+ *
+ * This driver uses NAPI and generic linux MII support.
+ *
+ * Tx path limits the number of interrupt by reclaiming sent buffer in
+ * a timer.  In case  the tx starts  to go  faster, it will  switch to
+ * interrupt mode.
+ *
+ * Note that OOM condition is not handled correctly, and can leave the
+ * rx path  in bad  shape. down/up the  interface should make  it work
+ * again though. But anyway, it's not likely to happen.
+ *
+ * Copyright (C) 2005 Maxime Bizon <mbizon@freebox.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/etherdevice.h>
+#include <linux/delay.h>
+#include <linux/ethtool.h>
+#include <linux/crc32.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+
+#include <asm/barrier.h>
+
+#include "tangox_enet.h"
+
+#define PFX	"tangox_enet: "
+
+//#define ETH_DEBUG 1 
+#ifdef ETH_DEBUG
+#define DBG	printk
+#else
+static void inline DBG(const char *x, ...) { ; }
+#endif /* ETH_DEBUG */
+
+/* for multicast support */
+#define ENABLE_MULTICAST
+
+struct eth_mac_core {
+	unsigned long enet_mac_base;
+	int phy_id;
+	const int irq;
+	struct net_device *gdev;
+	const char *name;
+};
+
+static struct eth_mac_core eth_mac_cores[NUM_MAC_CORES] = {
+	{ REG_BASE_host_interface + 0x6000, -1, ENET_IRQ0, NULL, "tangox_enet0" },
+	{ REG_BASE_host_interface + 0x6800, -1, ENET_IRQ1, NULL, "tangox_enet1" },
+};
+
+static int mac_cores = 3; /* enabled both cores */
+static int phyid_0 = -1;
+static int phyid_1 = -1;
+static int data_aligned = DEF_DATA_ALIGNMENT; /* required alignment, 2^order */
+
+#ifdef CONFIG_TANGOX_ENET0_NOMDIO
+#if (CONFIG_TANGOX_ENET0_NOMDIO_SPEED != 10) && (CONFIG_TANGOX_ENET0_NOMDIO_SPEED != 100) 
+#error Invalid speed setting
+#endif
+#if (CONFIG_TANGOX_ENET0_NOMDIO_PHY_ADDR < 0) || (CONFIG_TANGOX_ENET0_NOMDIO_PHY_ADDR > 31)
+#error Invalid PHY address
+#endif
+#endif
+#ifdef CONFIG_TANGOX_ENET1_NOMDIO
+#if (CONFIG_TANGOX_ENET1_NOMDIO_SPEED != 10) && (CONFIG_TANGOX_ENET1_NOMDIO_SPEED != 100) 
+#error Invalid speed setting
+#endif
+#if (CONFIG_TANGOX_ENET1_NOMDIO_PHY_ADDR < 0) || (CONFIG_TANGOX_ENET1_NOMDIO_PHY_ADDR > 31)
+#error Invalid PHY address
+#endif
+#endif
+
+/*
+ * mdio read/write callback, can run from userspace or timer
+ */
+
+#define MDIO_TIMEOUT	1000
+
+static __inline int enet_mdio_read(struct net_device *dev, int phy_id, int location)
+{
+	int val, i;
+	struct tangox_enet_priv *priv = netdev_priv(dev);
+
+	for (i = 0; (i < MDIO_TIMEOUT) && (gbus_read_reg32(ENET_MDIO_CMD1(priv->enet_mac_base)) & MDIO_CMD_GO); i++)
+		udelay(1);
+	if (i >= MDIO_TIMEOUT)
+		goto err_out;
+
+	val = MIIAR_ADDR(phy_id) | MIIAR_REG(location);
+	gbus_write_reg32(ENET_MDIO_CMD1(priv->enet_mac_base), val);
+
+	udelay(10);
+
+	gbus_write_reg32(ENET_MDIO_CMD1(priv->enet_mac_base), val | MDIO_CMD_GO);
+
+	for (i = 0; (i < MDIO_TIMEOUT) && (gbus_read_reg32(ENET_MDIO_CMD1(priv->enet_mac_base)) & MDIO_CMD_GO); i++)
+		udelay(1);
+	if (i >= MDIO_TIMEOUT)
+		goto err_out;
+
+	val = gbus_read_reg32(ENET_MDIO_STS1(priv->enet_mac_base));
+	if (val & MDIO_STS_ERR)
+		return -1;
+
+	return val & 0xffff;
+
+err_out:
+	return -1;
+}
+
+static void enet_mdio_write(struct net_device *dev, int phy_id, int location, int val)
+{
+	int i, tmp;
+	struct tangox_enet_priv *priv = netdev_priv(dev);
+
+	for (i = 0; (i < MDIO_TIMEOUT) && (gbus_read_reg32(ENET_MDIO_CMD1(priv->enet_mac_base)) & MDIO_CMD_GO); i++)
+		udelay(1);
+	if (i >= MDIO_TIMEOUT)
+		goto err_out;
+
+	tmp = MIIAR_DATA(val) | MIIAR_ADDR(phy_id) | MIIAR_REG(location);
+	gbus_write_reg32(ENET_MDIO_CMD1(priv->enet_mac_base), tmp);
+
+	udelay(10);
+
+	gbus_write_reg32(ENET_MDIO_CMD1(priv->enet_mac_base), tmp | MDIO_CMD_WR);
+
+	udelay(10);
+
+	gbus_write_reg32(ENET_MDIO_CMD1(priv->enet_mac_base), tmp | MDIO_CMD_WR | MDIO_CMD_GO);
+
+	for (i = 0; (i < MDIO_TIMEOUT) && (gbus_read_reg32(ENET_MDIO_CMD1(priv->enet_mac_base)) & MDIO_CMD_GO); i++)
+		udelay(1);
+	if (i >= MDIO_TIMEOUT)
+		goto err_out;
+
+	return;
+
+err_out:
+	return;
+}
+
+/* statistic counter read and write functions
+ * 44 counters are included for tracking 
+ * occurences of frame status evernts.
+ */
+static unsigned long enet_stat_read(struct net_device *dev, unsigned char index)
+{
+	struct tangox_enet_priv *priv = netdev_priv(dev);
+	gbus_write_reg8(ENET_STAT_INDEX(priv->enet_mac_base), index);
+	return gbus_read_reg32(ENET_STAT_DATA1(priv->enet_mac_base));
+}
+
+static void enet_stat_write(struct net_device *dev, unsigned long val, unsigned char index)
+{
+	struct tangox_enet_priv *priv = netdev_priv(dev);
+	gbus_write_reg8(ENET_STAT_INDEX(priv->enet_mac_base), index);
+	gbus_write_reg32(ENET_STAT_DATA1(priv->enet_mac_base), val);
+}
+
+static __inline int enet_rx_error(struct net_device *dev, unsigned long report)
+{
+	if (report & (RX_FCS_ERR | RX_FRAME_LEN_ERROR | RX_FIFO_OVERRUN |
+#ifndef ENABLE_MULTICAST
+		RX_MULTICAST_PKT |
+#endif
+		RX_LENGTH_ERR | RX_LATE_COLLISION | RX_RUNT_PKT))		
+		return 1;
+	else
+		return 0;
+}
+
+static void enet_mac_rx(struct net_device * dev, int enable)
+{
+	int val;
+	struct tangox_enet_priv *priv = netdev_priv(dev);
+
+	while (gbus_read_reg32(ENET_TXC_CR(priv->enet_mac_base)) & TCR_EN)
+		;
+
+	val = gbus_read_reg8(ENET_TX_CTL1(priv->enet_mac_base));
+	if (enable)
+		val |= TX_EN;
+	else
+		val &= ~TX_EN;
+	gbus_write_reg8(ENET_TX_CTL1(priv->enet_mac_base), val);
+}
+
+static void enet_mac_tx(struct net_device * dev, int enable)
+{
+	int val;
+	struct tangox_enet_priv *priv = netdev_priv(dev);
+
+	val = gbus_read_reg8(ENET_RX_CTL(priv->enet_mac_base));
+	if (enable)
+		val |= RX_EN;
+	else
+		val &= ~RX_EN;
+	gbus_write_reg8(ENET_RX_CTL(priv->enet_mac_base), val);
+}
+
+static int enet_get_speed(struct net_device *dev);
+static void enet_ar8035_loopback(struct net_device * dev)
+{
+	int speed = SPEED_1000;
+	struct tangox_enet_priv *priv = netdev_priv(dev);
+
+	if(priv->rgmii != PHY_AR8035)
+		return;
+
+	speed = enet_get_speed(dev);
+	if (speed == SPEED_1000) 
+		enet_mdio_write(dev, priv->mii.phy_id, MII_BMCR, 0x4140);
+	else if (speed == SPEED_100)	
+		enet_mdio_write(dev, priv->mii.phy_id, MII_BMCR, 0x6100);
+	else if (speed == SPEED_10)
+		enet_mdio_write(dev, priv->mii.phy_id, MII_BMCR, 0x4100);
+}
+
+static void enet_mac_loopback(struct net_device * dev, int enable)
+{
+	int val;
+	struct tangox_enet_priv *priv = netdev_priv(dev);
+
+	val = gbus_read_reg8(ENET_MAC_MODE(priv->enet_mac_base));
+	if (enable)
+		val |= LB_EN; 
+	else
+		val &= ~LB_EN; 
+	gbus_write_reg8(ENET_MAC_MODE(priv->enet_mac_base), val);
+}
+
+static void enet_mac_af(struct net_device * dev, int enable)
+{
+	int val;
+	struct tangox_enet_priv *priv = netdev_priv(dev);
+	val = gbus_read_reg8(ENET_RX_CTL(priv->enet_mac_base));
+	if (enable)
+		val |= RX_AF_EN;
+	else
+		val &= ~RX_AF_EN;
+	gbus_write_reg8(ENET_RX_CTL(priv->enet_mac_base), val);
+}
+
+/*
+ * start/stop dma engine
+ */
+static int __enet_xmit(struct sk_buff *skb, struct net_device *dev, int force);
+static void enet_stop_rx(struct net_device *dev)
+{
+	volatile struct enet_desc *rx;
+	int i, cnt;
+	struct sk_buff *dummy_skb = NULL;
+	struct ethhdr *ethr;
+	struct tangox_enet_priv *priv = netdev_priv(dev);
+
+	for (i = 0; i < priv->rx_desc_count; i++) {
+		cnt = (priv->last_rx_desc + priv->rx_desc_count - i) % priv->rx_desc_count;
+		rx = &priv->rx_descs[cnt];
+		rx->config |= DESC_EOC;
+		wmb();
+	}
+
+	/*transmit/receive a dummy packet*/
+	if (unlikely((dummy_skb = dev_alloc_skb(TX_BUF_SIZE + SKB_RESERVE_SIZE)) == NULL)) {
+		printk("%s: failed to allocation sk_buff for stopping rx.\n", priv->name);
+		return;
+	}
+
+	ethr = (struct ethhdr *)dummy_skb->data;
+	memset(dummy_skb->data, 0, ETH_ZLEN);
+	for (i = 0; i < 6; i++) {
+		ethr->h_dest[i] = 0xff;
+		ethr->h_source[i] = dev->dev_addr[i];
+	}
+	dummy_skb->len= ETH_ZLEN;
+
+	/*stop tx and rx in mac*/
+	enet_mac_tx(dev, 0);
+	enet_mac_rx(dev, 0);
+
+	/* set ar8035 to digital loopback mode */
+	enet_ar8035_loopback(dev);
+
+	/* address filtering needs to be disabled */
+	enet_mac_af(dev, 0);
+
+	/*program loopback mode in mac */
+	enet_mac_loopback(dev, 1);
+
+	/*start rx and tx */
+	enet_mac_tx(dev, 1);
+	enet_mac_rx(dev, 1);
+
+	/*send the packet and wait for dma stop */
+	__enet_xmit(dummy_skb, dev, 0);
+	while (gbus_read_reg32(ENET_RXC_CR(priv->enet_mac_base)) & RCR_EN) {
+		udelay(1000);
+		__enet_xmit(NULL, dev, 1);
+	}
+
+	/*stop tx and rx in mac*/
+	enet_mac_tx(dev, 0);
+	enet_mac_rx(dev, 0);
+
+	/*enable Address filter */
+	enet_mac_af(dev, 1);
+
+	/* disable loopback mode */
+	enet_mac_loopback(dev, 0);
+
+	/*start rx and tx */
+	enet_mac_tx(dev, 1);
+	enet_mac_rx(dev, 1);
+
+	kfree_skb(dummy_skb);
+}
+
+static __inline void rearm_rx_descs(struct net_device *dev)
+{
+	int i, cnt;	
+	volatile struct enet_desc *rx;
+	struct tangox_enet_priv *priv = netdev_priv(dev);
+
+	for (i = 0; i < priv->rx_desc_count; i++) {
+		cnt = (priv->last_rx_desc + i) % priv->rx_desc_count;
+		rx = &priv->rx_descs[cnt];
+		priv->rx_report[cnt] = 0;
+		if (cnt != priv->rx_eoc)
+			rx->config &= ~DESC_EOC;
+		else
+			rx->config |= DESC_EOC;
+	}
+	wmb();
+}
+
+static __inline void enet_start_rx(struct net_device *dev)
+{
+	unsigned long val, flags;
+	struct tangox_enet_priv *priv = netdev_priv(dev);
+
+	spin_lock_irqsave(&priv->ier_lock, flags);
+
+	val = gbus_read_reg32(ENET_RXC_CR(priv->enet_mac_base));
+	if ((val & RCR_EN) == 0) {
+		val |= RCR_EN;
+		gbus_write_reg32(ENET_RXC_CR(priv->enet_mac_base), val);
+	}
+	spin_unlock_irqrestore(&priv->ier_lock, flags);
+}
+
+
+#ifdef ETH_DEBUG
+static void dump_desc(struct tangox_enet_priv *priv)
+{
+	volatile struct enet_desc *rx;
+	int i;	
+	printk("\n");
+	for (i = 0; i < priv->rx_desc_count; i++) {
+		int cnt;
+		u32 report;
+		cnt = (priv->last_rx_desc + i) % priv->rx_desc_count;
+		rx = &priv->rx_descs[cnt];
+		report = priv->rx_report[cnt];
+		printk("%d rx[%d]=0x%08x s_addr=0x%08x n_addr=0x%08x r_addr=0x%08x config=0x%08x report=0x%x\n", 
+			i, cnt, (unsigned int)rx, (unsigned int)rx->s_addr, (unsigned int)rx->n_addr,
+			(unsigned int)rx->r_addr, (unsigned int)rx->config, report);
+	}
+	printk("\n");
+}
+
+static void dump_regs(struct tangox_enet_priv *priv)
+{
+	int i;
+	for (i = 0; i < 7; i++)
+		printk("TX reg[%d]=0x%x\n", i, gbus_read_reg32(priv->enet_mac_base +0x100 +i*4));
+
+	for (i = 0; i < 7; i++)
+		printk("RX reg[%d]=0x%x\n", i, gbus_read_reg32(priv->enet_mac_base +0x200 +i*4));
+}
+#endif
+
+/*
+ * rx poll func, called by network core
+ */
+static int enet_poll(struct napi_struct *napi, int budget)
+{
+	struct tangox_enet_priv *priv;
+	struct net_device *dev;
+	volatile struct enet_desc *rx, *rx1;
+	int limit, received, eoc = 0;
+	unsigned int rx_eoc, r_sz;
+
+	priv = container_of(napi, struct tangox_enet_priv, napi);
+	dev = napi->dev;
+	rx_eoc = priv->rx_eoc;
+
+	/* calculate how many rx packet we are allowed to fetch */
+	limit = budget;
+	received = 0;
+
+	/* process no more than "limit" done rx */
+	while (limit > 0) {
+		struct sk_buff *skb;
+		u32 report;
+		unsigned int len = 0;
+		int pkt_dropped = 0;
+
+		rx = &priv->rx_descs[priv->last_rx_desc];
+
+		/* we need multiple read on this volatile, avoid
+		 * memory access at each time */
+		report = priv->rx_report[priv->last_rx_desc];
+
+		if (rx->config & DESC_EOC) {
+			/* should not happen, only when stop rx dma */
+			//DBG("%s i=0x%x rx=0x%p report=0x%x config=0x%lx limit=0x%x\n", 
+			//	__FUNCTION__, priv->last_rx_desc, rx, report, rx->config, limit);
+			eoc = 1;
+			break;
+		}
+
+		if (report == 0) { 
+			uint32_t next_report;
+			next_report = priv->rx_report[(priv->last_rx_desc + 1) % priv->rx_desc_count];
+
+			/*check see if next one on error*/
+			if (enet_rx_error(dev, next_report) == 0)
+				break;
+		}
+
+		--limit;
+
+		if (likely((skb = priv->rx_skbs[priv->last_rx_desc]) != NULL)) {
+
+			len = RX_BYTES_TRANSFERRED(report);
+			if ((report == 0) || enet_rx_error(dev, report)) {
+
+#ifndef ENABLE_MULTICAST
+				if (report & RX_MULTICAST_PKT) { 
+					DBG("%s RX_MULTICAST_PKT report=0x%x\n", __FUNCTION__, report);				
+					priv->stats.rx_length_errors++;
+				}
+#endif
+				if (report & RX_FCS_ERR) {
+					DBG("%s RX_FCS_ERR report=0x%x\n", __FUNCTION__, report);				
+					priv->stats.rx_crc_errors++;
+				}
+
+				if (report & RX_LATE_COLLISION) { 
+					DBG("%s RX_LATE_COLLSION report=0x%x\n", __FUNCTION__, report);				
+				}
+
+				if (report & RX_FIFO_OVERRUN) { 
+					DBG("%s RX_FIFO_OVERRUN report=0x%x fifo_ctl=0x%x\n", __FUNCTION__, report, 
+							gbus_read_reg8(ENET_FIFO_CTL(priv->enet_mac_base)));
+				}
+
+				if (report & RX_RUNT_PKT) {
+					DBG("%s RX_RUNT_PKT report=0x%x\n", __FUNCTION__, report);				
+				}
+
+				if ((report & (RX_FRAME_LEN_ERROR | RX_LENGTH_ERR)) || (len > RX_BUF_SIZE)) {
+					DBG("%s RX LENTH ERROR report=0x%x\n", __FUNCTION__, report);		
+					priv->stats.rx_length_errors++;
+				}
+
+				priv->stats.rx_errors++;
+				pkt_dropped = 1;
+				goto done_checking;
+
+			} else {
+
+				/* ok, seems valid, adjust skb proto and len
+				 * and give it to kernel */
+				skb->dev = dev;
+				skb_put(skb, len);
+				skb->protocol = eth_type_trans(skb, dev);
+				netif_receive_skb(skb);
+#ifdef ETH_DEBUG
+				if (len > 0) {
+					int i;
+					DBG("-----received data len=0x%x-----\n", len);
+					for (i = 0; i < len; i++) {
+						if (i%16==0 && i>0)
+							DBG("\n");
+						DBG("%02x ", skb->data[i]);					
+					}
+					DBG("\n--------------------------\n");
+				}
+#endif
+			}
+done_checking:
+			rx_eoc = priv->last_rx_desc;
+
+			if (pkt_dropped)
+				goto rearm;
+
+			priv->stats.rx_packets++;
+			priv->stats.rx_bytes += len;
+			dev->last_rx = jiffies;
+			priv->rx_skbs[priv->last_rx_desc] = NULL;
+			/* we will re-alloc an skb for this slot */
+		}
+
+		if (unlikely((skb = dev_alloc_skb(RX_BUF_SIZE + SKB_RESERVE_SIZE)) == NULL)) {
+			printk("%s: failed to allocation sk_buff.\n", priv->name);
+			rx->config = DESC_BTS(2) | DESC_EOF/* | DESC_ID*/;
+			wmb();
+			break;
+		}
+		dma_cache_inv((unsigned long)skb->data, RX_BUF_SIZE + SKB_RESERVE_SIZE);
+
+		rx->config = RX_BUF_SIZE | DESC_BTS(2) | DESC_EOF/* | DESC_ID*/;
+
+		r_sz = 8 - (((u32)skb->data) & 0x7);
+		skb_reserve(skb, (r_sz == 8) ? 0 : r_sz); /* make sure it's aligned to 8 bytes boundary */
+		rx->s_addr = DMA_ADDR((void *)skb->data);
+		priv->rx_skbs[priv->last_rx_desc] = skb;
+
+rearm:
+		/* rearm descriptor */
+		priv->rx_report[priv->last_rx_desc] = 0;
+		priv->last_rx_desc++;
+		priv->last_rx_desc %= priv->rx_desc_count;
+		received++;
+		wmb();
+	}
+
+	if (received) {
+		rx = &priv->rx_descs[rx_eoc];
+		rx->config |= DESC_EOC;
+		rx1 = &priv->rx_descs[priv->rx_eoc];
+		rx1->config &= ~DESC_EOC; 
+		priv->rx_eoc = rx_eoc;
+		wmb();
+
+		budget -= received;
+	}
+
+	if (eoc == 0)
+		enet_start_rx(dev);
+
+	if (limit <= 0) {
+		/* breaked, but there is still work to do */
+		DBG("breaked, more work to do, rx dma will be off\n");
+		return 1;
+	}
+
+	__napi_complete(napi);
+	atomic_set(&priv->napi_poll, 0);
+	return 0;
+}
+
+/*
+ * tx request callback
+ */
+static int __enet_xmit(struct sk_buff *skb, struct net_device *dev, int force)
+{
+	struct tangox_enet_priv *priv;
+	volatile struct enet_desc *tx, *stx = NULL;
+	unsigned long tconfig_cache;
+	unsigned long val;
+	int tx_busy = 0, cpsz = 0;
+	unsigned char *txbuf;
+
+	priv = netdev_priv(dev);
+	spin_lock_bh(&priv->tx_lock);
+
+	if ((skb == NULL) && (force == 0) && ((priv->pending_tx < 0) || (priv->pending_tx_cnt <= 0)))
+		goto done; /* nothing needs to be done */
+	else if ((skb != NULL) && (priv->free_tx_desc_count <= ENET_DESC_LOW)) {
+		netif_stop_queue(dev);
+		spin_unlock_bh(&priv->tx_lock);
+		return NETDEV_TX_BUSY;
+	}
+
+	val = gbus_read_reg32(ENET_TXC_CR(priv->enet_mac_base)) & 0xf8ff;
+	if (val & TCR_EN) { 
+		if (skb == NULL) {
+			spin_unlock_bh(&priv->tx_lock);
+			return NETDEV_TX_BUSY;
+		} else if (priv->is_mdesc) {
+			netif_stop_queue(dev);
+			spin_unlock_bh(&priv->tx_lock);
+			return NETDEV_TX_BUSY;
+		}
+		
+		tx_busy = 1;
+		if (priv->pending_tx < 0)
+			priv->pending_tx = priv->next_tx_desc;
+	} 
+
+	/* to transmit the last chain */
+	if (skb == NULL) {
+		unsigned int last_tx = (priv->next_tx_desc + priv->tx_desc_count - 1) % priv->tx_desc_count;
+		stx = &priv->tx_descs[last_tx];
+		stx->config |= DESC_EOC;
+		wmb();
+		goto tx_pending;
+	}
+
+	dma_cache_wback((unsigned long)skb->data, skb->len);
+	cpsz = (data_aligned - ((u32)skb->data & (data_aligned - 1))) % data_aligned;
+
+	/* fill the tx desc with this skb address */
+	if (cpsz) { /* not align by 8 bytes, need to use one extra descriptor */
+		/* use mempcy for this extra descriptor */
+		tconfig_cache = DESC_BTS(2) | cpsz; 
+		stx = &priv->tx_descs[priv->next_tx_desc];
+		txbuf = priv->tx_bufs[priv->next_tx_desc];
+		memcpy(txbuf, skb->data, cpsz); 
+		stx->s_addr = DMA_ADDR((void *)txbuf);
+		stx->n_addr = DMA_ADDR((void *)&(priv->tx_descs[(priv->next_tx_desc + 1) % priv->tx_desc_count]));
+		stx->config = tconfig_cache;
+
+		/* keep a pointer to it for later and give it to dma */
+		priv->tx_skbs[priv->next_tx_desc] = skb;
+		priv->tx_report[priv->next_tx_desc] = 0;
+		priv->next_tx_desc++;
+		priv->next_tx_desc %= priv->tx_desc_count;
+		wmb();
+	}
+
+	tconfig_cache = DESC_BTS(2) | DESC_EOF | (skb->len - cpsz); 
+	tx = &priv->tx_descs[priv->next_tx_desc];
+	tx->s_addr = DMA_ADDR(skb->data + cpsz);
+
+	if (tx_busy) {
+		tx->n_addr = DMA_ADDR((void *)&(priv->tx_descs[(priv->next_tx_desc + 1) % priv->tx_desc_count]));
+	} else {
+		tx->n_addr = 0;
+		tconfig_cache |= DESC_EOC;
+	}
+	tx->config = tconfig_cache;
+
+	/* keep a pointer to it for later and give it to dma if needed */
+	if (cpsz) 
+		priv->tx_skbs[priv->next_tx_desc] = NULL;
+	else {
+		priv->tx_skbs[priv->next_tx_desc] = skb;
+		stx = tx;
+	}
+	priv->tx_report[priv->next_tx_desc] = 0;
+	priv->next_tx_desc++;
+	priv->next_tx_desc %= priv->tx_desc_count;
+	wmb();
+
+#ifdef ETH_DEBUG
+	{
+		int i;			
+ 		for (i = 0; i < skb->len; i++) {
+			if (((i %16) == 0) && (i > 0))
+				DBG("\n");
+			DBG("%02x ", skb->data[i] & 0xff);
+		}
+		DBG("\n");
+		DBG("DESC Mode:  TXC_CR=0x%x  desc_addr=0x%x s_addr=0x%x n_addr=0x%x r_addr=0x%x config=0x%x\n",
+				gbus_read_reg32(ENET_TXC_CR(priv->enet_mac_base)), stx,
+				stx->s_addr, stx->n_addr,
+				stx->r_addr, stx->config); 
+	}
+#endif
+
+tx_pending:
+	if (tx_busy == 0) {
+		if (priv->pending_tx >= 0) {
+			stx = &priv->tx_descs[priv->pending_tx];
+			priv->reclaim_limit = priv->pending_tx;
+			priv->is_mdesc = 1;
+		} else {
+			priv->reclaim_limit = (priv->next_tx_desc - 1 + priv->tx_desc_count) % priv->tx_desc_count;
+			priv->is_mdesc = 0;
+		}
+
+		gbus_write_reg32(ENET_TX_DESC_ADDR(priv->enet_mac_base), DMA_ADDR((void *)stx));
+		gbus_write_reg32(ENET_TX_SAR(priv->enet_mac_base), 0);
+		gbus_write_reg32(ENET_TX_REPORT_ADDR(priv->enet_mac_base), 0);
+
+		/* kick tx dma in case it was suspended */
+		val |= (TCR_EN | (((stx->config >> 16) & 0x7) << 8) | ((stx->config & 0xffff) << 16)); 
+		gbus_write_reg32(ENET_TXC_CR(priv->enet_mac_base), val);
+
+		/* no pending at this stage*/
+		priv->pending_tx = -1;
+		priv->pending_tx_cnt = 0;
+	} else {
+		if (skb)
+			priv->pending_tx_cnt += (cpsz ? 2 : 1);
+	}
+
+	if (skb)
+		priv->free_tx_desc_count -= (cpsz ? 2 : 1); 
+
+done:
+	spin_unlock_bh(&priv->tx_lock);
+
+	return NETDEV_TX_OK;
+}
+
+static int enet_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	return __enet_xmit(skb, dev, 0);
+}
+
+/*
+ * tx reclaim func. Called by timer or tx done tasklet to reclaim sent
+ * buffers.
+ */
+static void enet_tx_reclaim(unsigned long data)
+{
+	struct net_device *dev;
+	struct tangox_enet_priv *priv;
+
+	dev = (struct net_device *)data;
+	priv = netdev_priv(dev);
+
+	__enet_xmit(NULL, dev, 0); /* kick tx dma in case the chain was suspended */
+
+	spin_lock_bh(&priv->tx_lock);
+
+	while (priv->free_tx_desc_count < priv->tx_desc_count) {
+		u32 report;
+		struct sk_buff *skb;
+
+		report = priv->tx_report[priv->dirty_tx_desc];
+		if (priv->dirty_tx_desc == priv->reclaim_limit)
+			break;
+
+		skb = priv->tx_skbs[priv->dirty_tx_desc];
+		priv->stats.tx_packets++;
+		if (skb) {
+			/* check for transmission errors and update stats
+			 * accordingly */
+			if (report & (TX_FIRST_DEFERRAL | TX_LATE_COLLISION |
+					TX_PACKET_DROPPED | TX_FIFO_UNDERRUN)) {
+				priv->stats.tx_errors++;
+			} else {
+				priv->stats.tx_bytes += skb->len;
+			}
+			dev_kfree_skb(skb);
+		}
+		priv->tx_skbs[priv->dirty_tx_desc] = NULL;
+		priv->dirty_tx_desc++;
+		priv->dirty_tx_desc %= priv->tx_desc_count;
+		priv->free_tx_desc_count++;
+		priv->tx_report[priv->dirty_tx_desc] = 0;
+	}
+
+	if (priv->free_tx_desc_count && netif_queue_stopped(dev))
+		netif_wake_queue(dev);
+
+	spin_unlock_bh(&priv->tx_lock);
+}
+
+/*
+ * our irq handler, just ack it and schedule the right tasklet to
+ * handle this
+ */
+static irqreturn_t enet_isr(int irq, void *dev_id)
+{
+	struct net_device *dev;
+	struct tangox_enet_priv *priv;
+	unsigned long val = 0;
+
+	dev = (struct net_device *)dev_id;
+	priv = netdev_priv(dev);
+
+	/* tx interrupt */
+	if ((val = gbus_read_reg32(ENET_TXC_SR(priv->enet_mac_base))) != 0) {
+		gbus_write_reg32(ENET_TXC_SR(priv->enet_mac_base), 0xf);
+		//if (likely(val & TSR_DI)) {
+		if (likely(val & TSR_TI)) {
+			tasklet_schedule(&priv->tx_reclaim_tasklet);
+		}
+		if (unlikely(val & TSR_DE))
+			printk("TX DMA error\n");
+		if (unlikely(val & TSR_TO))
+			printk("TX FIFO overflow\n");
+	}
+	/* rx interrupt */
+	if ((val = gbus_read_reg32(ENET_RXC_SR(priv->enet_mac_base))) != 0) {
+		gbus_write_reg32(ENET_RXC_SR(priv->enet_mac_base), 0xf);
+		if (likely(val & (RSR_RI | RSR_DI | RSR_DE | RSR_RO))) {
+			if (atomic_read(&priv->napi_poll) == 0) {
+				if (napi_schedule_prep(&priv->napi)) {
+					/*TODO: disable rx interrupt */
+					/*avoid reentering */
+					atomic_set(&priv->napi_poll, 1);
+					__napi_schedule(&priv->napi);
+				} 
+			}
+		}
+
+		if (unlikely(val & RSR_DI)) 
+			DBG("RX EOC\n");			
+		if (unlikely(val & RSR_DE))
+			DBG("RX DMA error\n");
+		if (unlikely(val & RSR_RO)) {
+			int i;
+			DBG("RX Status FIFO overflow\n");
+			for (i = 0; i < 4; i++)
+				gbus_read_reg32(ENET_RX_FIFO_SR(priv->enet_mac_base));
+		}
+	}
+
+ 	/* wake on lan */
+ 	if ((val = gbus_read_reg8(ENET_WAKEUP(priv->enet_mac_base))) == 1) {
+ 		/* clear sleeping mode */
+ 		gbus_write_reg8(ENET_SLEEP_MODE(priv->enet_mac_base), 0);
+ 		/* clear wakeup mode */
+ 		gbus_write_reg8(ENET_WAKEUP(priv->enet_mac_base), 0);
+ 	}
+
+	return IRQ_HANDLED;
+}
+
+static int enet_get_speed(struct net_device *dev)
+{
+	struct tangox_enet_priv *priv;
+	int speed = SPEED_100;
+
+	priv = netdev_priv(dev);
+	if ((priv->rgmii == PHY_100) && (priv->no_mdio)) {
+#ifdef CONFIG_TANGOX_ENET0_NOMDIO
+			if (priv->enet_mac_base == REG_BASE_host_interface + 0x6000) 
+				speed = CONFIG_TANGOX_ENET0_NOMDIO_SPEED;
+#endif
+#ifdef CONFIG_TANGOX_ENET1_NOMDIO
+			if (priv->enet_mac_base == REG_BASE_host_interface + 0x6800) 
+				speed = CONFIG_TANGOX_ENET1_NOMDIO_SPEED;
+#endif
+	} else {
+		struct ethtool_cmd ecmd;
+		mii_ethtool_gset(&priv->mii, &ecmd);
+		speed = ecmd.speed;
+	}
+	return speed;
+}
+
+
+static int phy_autoneg(struct net_device *dev)
+{
+	struct tangox_enet_priv *priv;
+	unsigned int val = 0, ctrl_1000 = 0;
+	int mdio_ok = 0;
+	unsigned long start_jiffies;
+	unsigned short advertise =	0; 
+
+
+#define MDIO_MAX_WAIT	5	/* in seconds */
+
+	priv = netdev_priv(dev);
+
+	/* see if complete already */
+	if (enet_mdio_read(dev, priv->mii.phy_id, MII_BMSR) & BMSR_ANEGCOMPLETE)
+		return 0;
+
+	/*check BMSR to check 10/100 baseT supported */
+	val = enet_mdio_read(dev, priv->mii.phy_id, MII_BMSR);
+	if (val & BMSR_10HALF)
+		advertise |=  ADVERTISE_10HALF; 
+	if (val & BMSR_10FULL)
+		advertise |=  ADVERTISE_10FULL;  
+	if (val & BMSR_100HALF)
+		advertise |=  ADVERTISE_100HALF;  
+	if (val & BMSR_100FULL)
+		advertise |=  ADVERTISE_100FULL; 
+
+	/* check extension see if 1000 baseT supported */
+	if ((priv->gigabit == 1) && (priv->rgmii != PHY_100)){
+		if (val & BMSR_ESTATEN) {
+			val = enet_mdio_read(dev, priv->mii.phy_id, MII_ESTATUS);
+			ctrl_1000 = enet_mdio_read(dev, priv->mii.phy_id, MII_CTRL1000);
+			if (val & ESTATUS_1000_TFULL)
+				ctrl_1000 |= ADVERTISE_1000FULL;
+			if (val & ESTATUS_1000_THALF)
+				ctrl_1000 |= ADVERTISE_1000HALF;
+			enet_mdio_write(dev, priv->mii.phy_id, MII_CTRL1000, ctrl_1000);
+		}
+	} else {
+		val = enet_mdio_read(dev, priv->mii.phy_id, MII_ESTATUS);
+		ctrl_1000 = enet_mdio_read(dev, priv->mii.phy_id, MII_CTRL1000);
+		if (val & ESTATUS_1000_TFULL)
+			ctrl_1000 &= ~ADVERTISE_1000FULL;
+		if (val & ESTATUS_1000_THALF)
+			ctrl_1000 &= ~ADVERTISE_1000HALF;
+		enet_mdio_write(dev, priv->mii.phy_id, MII_CTRL1000, ctrl_1000);
+	}
+
+	/* program advertisement reg for autoneg */
+	val = enet_mdio_read(dev, priv->mii.phy_id, MII_ADVERTISE);
+	advertise |= val;
+	enet_mdio_write(dev, priv->mii.phy_id, MII_ADVERTISE, advertise);
+
+	/* power up, autoneg phy */
+	priv->mii.force_media = 0;
+	val = enet_mdio_read(dev, priv->mii.phy_id, MII_BMCR);
+	val &= (~BMCR_PDOWN); 
+	val |= BMCR_ANENABLE | BMCR_ANRESTART;
+	enet_mdio_write(dev, priv->mii.phy_id, MII_BMCR, val);
+	udelay(100);
+
+	for (start_jiffies = jiffies; time_after(start_jiffies + MDIO_MAX_WAIT * HZ, jiffies);) {
+		if (enet_mdio_read(dev, priv->mii.phy_id, MII_BMSR) & BMSR_ANEGCOMPLETE) {
+			mdio_ok = 1;
+			break;
+		}
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(HZ / 10);
+	}
+
+	if (mdio_ok == 0) {
+		printk(KERN_ERR "%s: PHY autonegotiation does not complete...\n", priv->name);
+		return -EBUSY;
+	}
+
+	/* stabilize, ~0.5 second */
+	set_current_state(TASK_INTERRUPTIBLE);
+	schedule_timeout(HZ / 2);
+	return 0;
+}
+
+static void enet_mac_config(struct net_device *dev)
+{
+	struct tangox_enet_priv *priv;
+	int speed,val;
+
+	priv = netdev_priv(dev);
+
+	if (priv->rgmii == PHY_100) {
+		/* 100 baseT, realtek*/
+		val = gbus_read_reg8(ENET_MAC_MODE(priv->enet_mac_base));
+		if (val & (GMAC_MODE | RGMII_MODE)) {
+			val &= ~(GMAC_MODE | RGMII_MODE);	/*disable Gigabit mode for now*/
+			//val |= /*LB_EN |*/ BST_EN;		/*loopback off, burst on*/
+			gbus_write_reg8(ENET_MAC_MODE(priv->enet_mac_base), val);
+		}
+		return;
+	}
+
+	if (priv->rgmii == PHY_VITESSE) {
+		/* Enable LED blink */
+#if 0 
+		/* simple LED Method */
+		enet_mdio_write(dev, priv->mii.phy_id, VITESSE_LED_CTL, 0xf);
+#else
+		/* Enhanced LED Method */
+		enet_mdio_write(dev, priv->mii.phy_id, VITESSE_EXTENDED_PAGE_CTL, 0x0001);
+		enet_mdio_write(dev, priv->mii.phy_id, VITESSE_ENHANCED_LED_METHOD, 0x004a);
+		enet_mdio_write(dev, priv->mii.phy_id, VITESSE_ENHANCED_LED_BEHAVIOR, 0x0c10);
+		enet_mdio_write(dev, priv->mii.phy_id, VITESSE_EXTENDED_PAGE_CTL, 0x0000);
+#endif
+		/* Set RGMII skew timing compensation and ActiPHY mode */
+		/* This added 2ns delay to RX_CLK and TX_CLK */
+		val = enet_mdio_read(dev, priv->mii.phy_id, VITESSE_EXTENDED_PHY_CTL);
+		enet_mdio_write(dev, priv->mii.phy_id, VITESSE_EXTENDED_PHY_CTL, val | (1 << 8) | (1 << 5));
+	}
+	else if (priv->rgmii == PHY_AR8035) {
+#if 0 
+		/* enable regmii rx clock delay */
+		enet_mdio_write(dev, priv->mii.phy_id, 0x1d, 0);
+		val = enet_mdio_read(dev, priv->mii.phy_id, 0x1e) | (1<<15);
+		enet_mdio_write(dev, priv->mii.phy_id, 0x1e, val);
+#endif
+		/* enable regmii tx clock delay */
+		enet_mdio_write(dev, priv->mii.phy_id, 0x1d, 5);
+		val = enet_mdio_read(dev, priv->mii.phy_id, 0x1e) | (1<<8);
+		enet_mdio_write(dev, priv->mii.phy_id, 0x1e, val);
+
+		/* LED control*/
+		enet_mdio_write(dev, priv->mii.phy_id, 0x18, 0x2100);
+	}
+	
+	val = gbus_read_reg8(ENET_MAC_MODE(priv->enet_mac_base));
+	speed = enet_get_speed(dev);
+	if (speed == 1000) {
+		if (((val & RGMII_MODE) == 0) || ((val & GMAC_MODE) == 0)) {
+			val |= (GMAC_MODE | RGMII_MODE);
+			gbus_write_reg8(ENET_MAC_MODE(priv->enet_mac_base), val);
+		}
+	} else {
+		if ((val & RGMII_MODE) || (val & GMAC_MODE)) {
+			val &= ~(GMAC_MODE | RGMII_MODE);
+			gbus_write_reg8(ENET_MAC_MODE(priv->enet_mac_base), val);
+		}
+	}
+
+	/*set threshold for internal clock 0x1*/
+	gbus_write_reg8(ENET_IC_THRESHOLD(priv->enet_mac_base), ((speed == 1000) ? 3 : 1));
+
+	/*set slot time 0x7f for 10/100Mbps*/
+	gbus_write_reg8(ENET_SLOT_TIME(priv->enet_mac_base), ((speed == 1000) ? 0xff : 0x7f));
+}
+
+/*
+ * reconfigure mac for new link state
+ */
+static void enet_link_reconfigure(struct net_device *dev)
+{
+	struct tangox_enet_priv *priv;
+	unsigned char val;
+
+	priv = netdev_priv(dev);
+
+	/* reflect duplex status in dma register */
+	spin_lock_bh(&priv->maccr_lock);
+
+	val = gbus_read_reg8(ENET_MAC_MODE(priv->enet_mac_base));
+	if (priv->mii.full_duplex)
+		val &= ~HALF_DUPLEX;
+	else
+		val |= HALF_DUPLEX;
+	gbus_write_reg8(ENET_MAC_MODE(priv->enet_mac_base), val);
+
+	enet_mac_config(dev);
+
+	spin_unlock_bh(&priv->maccr_lock);
+}
+
+/*
+ * link check timer callback
+ */
+static void enet_link_check(unsigned long data)
+{
+	struct net_device *dev;
+	struct tangox_enet_priv *priv;
+	int ret = 0, speed;
+	static int old_speed, old_full_duplex;
+
+	dev = (struct net_device *)data;
+	priv = netdev_priv(dev);
+
+	/*check speed change in gigabit*/
+	speed = enet_get_speed(dev);
+	
+	if (priv->no_mdio == 0) {
+		/* check for duplex change */
+		spin_lock_bh(&priv->mii_lock);
+		ret = mii_check_media(&priv->mii, 1, 0);
+		spin_unlock_bh(&priv->mii_lock);
+	}
+
+	if (ret || (old_full_duplex != priv->mii.full_duplex) || (speed && (speed !=old_speed)))
+		enet_link_reconfigure(dev);
+
+	if (speed)
+		old_speed = speed;
+
+	old_full_duplex = priv->mii.full_duplex;
+
+	/* reschedule timer */
+	priv->link_check_timer.expires = jiffies + LINK_CHECK_TIMER_FREQ;
+	add_timer(&priv->link_check_timer);
+}
+
+/*
+ * program given mac address in hw registers
+ */
+static int enet_set_mac_address(struct net_device *dev, void *addr)
+{
+	struct sockaddr *sock = addr;
+	struct tangox_enet_priv *priv = netdev_priv(dev);
+
+	/* to make it safe, we won't do this while running */
+	if (netif_running(dev))
+		return -EBUSY;
+
+	memcpy(dev->dev_addr, sock->sa_data, ETH_ALEN);
+
+	/*set mac addr*/
+	gbus_write_reg8(ENET_MAC_ADDR1(priv->enet_mac_base), dev->dev_addr[0]);
+	gbus_write_reg8(ENET_MAC_ADDR2(priv->enet_mac_base), dev->dev_addr[1]);
+	gbus_write_reg8(ENET_MAC_ADDR3(priv->enet_mac_base), dev->dev_addr[2]);
+	gbus_write_reg8(ENET_MAC_ADDR4(priv->enet_mac_base), dev->dev_addr[3]);
+	gbus_write_reg8(ENET_MAC_ADDR5(priv->enet_mac_base), dev->dev_addr[4]);
+	gbus_write_reg8(ENET_MAC_ADDR6(priv->enet_mac_base), dev->dev_addr[5]);
+	
+	/* set unicast addr */
+	gbus_write_reg8(ENET_UC_ADDR1(priv->enet_mac_base), dev->dev_addr[0]);
+	gbus_write_reg8(ENET_UC_ADDR2(priv->enet_mac_base), dev->dev_addr[1]);
+	gbus_write_reg8(ENET_UC_ADDR3(priv->enet_mac_base), dev->dev_addr[2]);
+	gbus_write_reg8(ENET_UC_ADDR4(priv->enet_mac_base), dev->dev_addr[3]);
+	gbus_write_reg8(ENET_UC_ADDR5(priv->enet_mac_base), dev->dev_addr[4]);
+	gbus_write_reg8(ENET_UC_ADDR6(priv->enet_mac_base), dev->dev_addr[5]);
+
+	return 0;
+}
+
+/*
+ * update hash table to reflect new device multicast address list
+ */
+static void enet_set_multicast_list(struct net_device *dev)
+{
+#ifdef ENABLE_MULTICAST
+	struct tangox_enet_priv *priv;
+	struct netdev_hw_addr *ha;
+	unsigned char val;
+	uint32_t mc_filter[2];
+
+	priv = netdev_priv(dev);
+	
+	/* check if the link is ok, otherwise just return*/
+	if (priv->no_mdio == 0) {
+		spin_lock_bh(&priv->mii_lock);
+		val = mii_link_ok(&priv->mii);
+		spin_unlock_bh(&priv->mii_lock);
+
+		if (val == 0)
+			return;
+	}
+
+	/* the link check timer might change RX control, we need to protect
+	 * against it */
+	spin_lock_bh(&priv->maccr_lock);
+	val = gbus_read_reg32(ENET_RX_CTL(priv->enet_mac_base));
+
+	if (dev->flags & IFF_PROMISC) {
+		val &= ~(RX_BC_DISABLE | RX_AF_EN);
+	} else {
+		val |= RX_AF_EN;
+		/* if we want all multicast or if address count is too
+		 * high, don't try to compute hash value */
+		if (netdev_mc_count(dev) > 64 || dev->flags & IFF_ALLMULTI) {
+			val &= ~(RX_BC_DISABLE | RX_AF_EN);
+		}
+	}
+
+	gbus_write_reg32(ENET_RX_CTL(priv->enet_mac_base), val);
+	spin_unlock_bh(&priv->maccr_lock);
+
+	/* we don't need to update hash table if we pass all multicast */
+	if (((val & RX_BC_DISABLE) == 0) && ((val & RX_AF_EN) == 0))
+		return;
+
+	/* clear internal multicast address table */
+	gbus_write_reg8(ENET_MC_INIT(priv->enet_mac_base), 0x0);
+	while (gbus_read_reg8(ENET_MC_INIT(priv->enet_mac_base)))
+		;
+
+	mc_filter[0] = mc_filter[1] = 0;
+
+	netdev_for_each_mc_addr(ha, dev) {
+		char *addr;
+
+		addr = ha->addr;
+		if (!(*addr & 1))
+			continue;
+
+		gbus_write_reg8(ENET_MC_ADDR1(priv->enet_mac_base), addr[0]);
+		gbus_write_reg8(ENET_MC_ADDR2(priv->enet_mac_base), addr[1]);
+		gbus_write_reg8(ENET_MC_ADDR3(priv->enet_mac_base), addr[2]);
+		gbus_write_reg8(ENET_MC_ADDR4(priv->enet_mac_base), addr[3]);
+		gbus_write_reg8(ENET_MC_ADDR5(priv->enet_mac_base), addr[4]);
+		gbus_write_reg8(ENET_MC_ADDR6(priv->enet_mac_base), addr[5]);
+		gbus_write_reg8(ENET_MC_INIT(priv->enet_mac_base), 0xff);
+		while (gbus_read_reg8(ENET_MC_INIT(priv->enet_mac_base)))
+			;
+	}
+#endif
+}
+
+static void enet_dma_reinit(struct net_device *dev)
+{
+	struct tangox_enet_priv *priv = netdev_priv(dev);
+
+	priv->pending_tx = -1;
+	priv->pending_tx_cnt = 0;
+	priv->reclaim_limit = -1;
+	priv->dirty_tx_desc = priv->next_tx_desc = 0;
+	priv->free_tx_desc_count = priv->tx_desc_count;
+
+	priv->last_rx_desc = 0;
+	priv->rx_eoc = priv->rx_desc_count - 1;
+	rearm_rx_descs(dev);
+	wmb();
+
+	/*
+	 * write rx desc list & tx desc list addresses in registers
+	 */
+	gbus_write_reg32(ENET_TX_DESC_ADDR(priv->enet_mac_base), DMA_ADDR((void *)&priv->tx_descs[0]));
+	gbus_write_reg32(ENET_RX_DESC_ADDR(priv->enet_mac_base), DMA_ADDR((void *)&priv->rx_descs[0]));
+}
+
+/*
+ * open callback
+ */
+static int enet_open(struct net_device *dev)
+{
+	struct tangox_enet_priv *priv;
+
+	priv = netdev_priv(dev);
+
+	/* power up the PHY*/
+	if ((priv->no_mdio == 0)) 
+		phy_autoneg(dev);
+
+	/* check link */
+	if (priv->no_mdio || mii_check_media(&priv->mii, 0, 1))
+		enet_link_reconfigure(dev);
+
+	/*clear rx interrupts*/
+	gbus_write_reg32(ENET_RXC_SR(priv->enet_mac_base), 0xf);
+
+	/* start rx dma*/
+	atomic_set(&priv->napi_poll, 0);
+	enet_dma_reinit(dev);
+	enet_start_rx(dev);
+
+	/* enable mac rx */
+	enet_mac_rx(dev, 1);
+
+	/* stabilize the rx*/
+	mdelay(500);
+
+	/* start link check & tx reclaim timer */
+	priv->link_check_timer.expires = jiffies + LINK_CHECK_TIMER_FREQ;
+	add_timer(&priv->link_check_timer);
+
+	//priv->tx_reclaim_timer.expires = jiffies + TX_RECLAIM_TIMER_FREQ;
+	//add_timer(&priv->tx_reclaim_timer);
+
+	/*clear tx interrupts*/
+	gbus_write_reg32(ENET_TXC_SR(priv->enet_mac_base), 0xf);
+
+	/* enable mac tx */
+	enet_mac_tx(dev, 1);
+
+	/*finally start tx */
+	netif_start_queue(dev);
+
+	/* enable napi */
+	napi_enable(&priv->napi);
+
+	return 0;
+}
+
+/*
+ * stop callback
+ */
+static int enet_stop(struct net_device *dev)
+{
+	struct tangox_enet_priv *priv;
+	unsigned char val;
+
+	priv = netdev_priv(dev);
+
+	/* stop link timer */
+	del_timer_sync(&priv->link_check_timer);
+
+	/* stop dma */
+	enet_stop_rx(dev);
+
+	/* stop mac rx */
+	enet_mac_rx(dev, 0);
+
+	/* stop tx queue */
+	netif_stop_queue(dev);
+
+	/* disable napi */
+	napi_disable(&priv->napi);
+
+	/* stop mac tx */
+	enet_mac_tx(dev, 0);
+
+	/* power down the PHY*/
+	val = enet_mdio_read(dev, priv->mii.phy_id, MII_BMCR);
+	enet_mdio_write(dev, priv->mii.phy_id, MII_BMCR, val | BMCR_PDOWN);
+
+	return 0;
+}
+
+/*
+ * get_stats callback
+ */
+static struct net_device_stats *enet_get_stats(struct net_device *dev)
+{
+	struct tangox_enet_priv *priv;
+	priv = netdev_priv(dev);
+	return &priv->stats;
+}
+
+/*
+ * ethtool callbacks
+ */
+static int enet_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct tangox_enet_priv *priv;
+	int ret;
+
+	priv = netdev_priv(dev);
+
+	spin_lock_bh(&priv->mii_lock);
+	ret = mii_ethtool_gset(&priv->mii, cmd);
+	spin_unlock_bh(&priv->mii_lock);
+
+	return ret;
+}
+
+static int enet_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct tangox_enet_priv *priv;
+	int ret;
+
+	priv = netdev_priv(dev);
+
+	spin_lock_bh(&priv->mii_lock);
+	ret = mii_ethtool_sset(&priv->mii, cmd);
+	spin_unlock_bh(&priv->mii_lock);
+
+	return ret;
+}
+
+static int enet_nway_reset(struct net_device *dev)
+{
+	struct tangox_enet_priv *priv;
+	int ret;
+
+	priv = netdev_priv(dev);
+
+	spin_lock_bh(&priv->mii_lock);
+	ret = mii_nway_restart(&priv->mii);
+	spin_unlock_bh(&priv->mii_lock);
+
+	return ret;
+}
+
+static u32 enet_get_link(struct net_device *dev)
+{
+	struct tangox_enet_priv *priv;
+	int ret;
+
+	priv = netdev_priv(dev);
+
+	spin_lock_bh(&priv->mii_lock);
+	ret = mii_link_ok(&priv->mii);
+	spin_unlock_bh(&priv->mii_lock);
+
+	return ret;
+}
+
+static struct ethtool_ops enet_ethtool_ops = {
+	.get_settings		= enet_get_settings,
+	.set_settings		= enet_set_settings,
+	.nway_reset		= enet_nway_reset,
+	.get_link		= enet_get_link,
+};
+
+static int enet_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	struct tangox_enet_priv *priv;
+	int ret;
+
+	priv = netdev_priv(dev);
+
+	spin_lock_bh(&priv->mii_lock);
+	ret = generic_mii_ioctl(&priv->mii, if_mii(rq), cmd, NULL);
+	spin_unlock_bh(&priv->mii_lock);
+
+	return ret;
+}
+
+/*
+ * dma ring allocation is done here
+ */
+static int enet_dma_init(struct net_device *dev)
+{
+#define CEILING(x, c) ((((x) / (1 << (c))) + (((x) % (1 << (c))) ? 1 : 0)) * (1 << (c)))
+	unsigned int r_sz, alloc_size, alloc_order;
+	int i;
+	void *tx_ptr;
+	struct tangox_enet_priv *priv = netdev_priv(dev);
+	
+	/* calculate the size needed */
+	alloc_size = CEILING(priv->rx_desc_count * sizeof(struct enet_desc), L1_CACHE_SHIFT) + 
+			CEILING(priv->rx_desc_count * sizeof(unsigned long), L1_CACHE_SHIFT) +
+			CEILING(priv->rx_desc_count * sizeof(struct skb_buff *), L1_CACHE_SHIFT) + 
+			CEILING(priv->tx_desc_count * sizeof(struct enet_desc), L1_CACHE_SHIFT) + 
+			CEILING(priv->tx_desc_count * sizeof(unsigned long), L1_CACHE_SHIFT) +
+			CEILING(priv->tx_desc_count * sizeof(struct skb_buff *), L1_CACHE_SHIFT) +
+			CEILING(priv->tx_desc_count * sizeof(char *), L1_CACHE_SHIFT) +
+			(priv->tx_desc_count * CEILING(data_aligned, L1_CACHE_SHIFT));
+			
+	for (alloc_order = 0; (PAGE_SIZE << alloc_order) < alloc_size; alloc_order++)
+		;
+	if ((priv->alloc_pages_cached = (void *)__get_free_pages(GFP_KERNEL | GFP_DMA, alloc_order)) == NULL) {
+		printk("%s: cannot allocate memory.\n", priv->name);
+		return -ENOMEM;
+	}
+	memset(priv->alloc_pages_cached, 0, alloc_size);
+	dma_cache_wback_inv((unsigned long)priv->alloc_pages_cached, alloc_size);
+	priv->alloc_pages = (void *)KSEG1ADDR(priv->alloc_pages_cached);
+	priv->alloc_order = alloc_order;
+
+	/* arrange rx */
+	priv->rx_descs = (void *)priv->alloc_pages;
+	priv->rx_report = ((void *)priv->rx_descs) + CEILING(priv->rx_desc_count * sizeof(struct enet_desc), L1_CACHE_SHIFT);
+	priv->rx_skbs = ((void *)priv->rx_report) + CEILING(priv->rx_desc_count * sizeof(unsigned long), L1_CACHE_SHIFT);
+
+	/*
+	 * initialize all rx descs
+	 */
+	for (i = 0; i < priv->rx_desc_count; i++) {
+		volatile struct enet_desc *rx;
+		struct sk_buff *skb;
+
+		rx = &priv->rx_descs[i];
+		rx->config = RX_BUF_SIZE | DESC_BTS(2) | DESC_EOF/* | DESC_ID*/;
+
+		if ((skb = dev_alloc_skb(RX_BUF_SIZE + SKB_RESERVE_SIZE)) == NULL)
+			return -ENOMEM;
+		dma_cache_inv((unsigned long)skb->data, RX_BUF_SIZE + SKB_RESERVE_SIZE);
+		
+		r_sz = (data_aligned - ((u32)skb->data & (data_aligned - 1))) % data_aligned;
+		if (r_sz)
+			skb_reserve(skb, r_sz); /* make sure it's aligned to pre-defined boundary */
+		priv->rx_report[i] = 0; 
+		rx->s_addr = DMA_ADDR((void *)skb->data);
+		rx->r_addr = DMA_ADDR((void *)&priv->rx_report[i]);
+		rx->n_addr = DMA_ADDR((void *)&priv->rx_descs[i + 1]);
+		if (i == (priv->rx_desc_count - 1)) {
+			rx->n_addr = DMA_ADDR((void *)&priv->rx_descs[0]);
+			rx->config |= DESC_EOC;
+			priv->rx_eoc = i;
+		}
+#ifdef ETH_DEBUG
+		DBG("rx[%d]=0x%08x\n", i, (unsigned int)rx);
+		DBG("  s_addr=0x%08x\n", (unsigned int)rx->s_addr);
+		DBG("  n_addr=0x%08x\n", (unsigned int)rx->n_addr);
+		DBG("  r_addr=0x%08x\n", (unsigned int)rx->r_addr);
+		DBG("  config=0x%08x\n", (unsigned int)rx->config);
+#endif
+		priv->rx_skbs[i] = skb;
+	}
+	priv->last_rx_desc = 0;
+	wmb();
+
+	/*
+	 * allocate tx descriptor list
+	 *
+	 * We allocate only the descriptor list and prepare them for
+	 * further use. When tx is needed, we will set the right flags
+	 * and kick the dma.
+	 */
+	priv->tx_descs = ((void *)priv->rx_skbs) + CEILING(priv->rx_desc_count * sizeof(struct skb_buff *), L1_CACHE_SHIFT);
+	priv->tx_report = ((void *)priv->tx_descs) + CEILING(priv->tx_desc_count * sizeof(struct enet_desc), L1_CACHE_SHIFT);
+	priv->tx_skbs = ((void *)priv->tx_report) + CEILING(priv->tx_desc_count * sizeof(unsigned long), L1_CACHE_SHIFT);
+	priv->tx_bufs = ((void *)priv->tx_skbs) + CEILING(priv->tx_desc_count * sizeof(struct skb_buff *), L1_CACHE_SHIFT);
+	tx_ptr = ((void *)priv->tx_bufs) + CEILING(priv->tx_desc_count * sizeof(char *), L1_CACHE_SHIFT); 
+
+	/*
+	 * initialize tx descs
+	 */
+	for (i = 0; i < priv->tx_desc_count; i++) {
+		volatile struct enet_desc *tx;
+
+		priv->tx_bufs[i] = tx_ptr + (i * CEILING(data_aligned, L1_CACHE_SHIFT));
+		tx = &priv->tx_descs[i];
+		priv->tx_report[i] = 0; 
+		tx->r_addr = DMA_ADDR((void *)&priv->tx_report[i]);
+		tx->s_addr = 0;
+		tx->config = DESC_EOF;
+		if (i == (priv->tx_desc_count - 1)) {
+			tx->config |= DESC_EOC;
+			tx->n_addr = DMA_ADDR((void *)&priv->tx_descs[0]);
+		}
+		//DBG("tx[%d]=0x%08x\n", i, (unsigned int)tx);
+	}
+	priv->dirty_tx_desc = priv->next_tx_desc = 0;
+	priv->pending_tx = -1;
+	priv->pending_tx_cnt = 0;
+	priv->reclaim_limit = -1;
+	priv->free_tx_desc_count = priv->tx_desc_count;
+	wmb();
+
+	/*
+	 * write rx desc list & tx desc list addresses in registers
+	 */
+	gbus_write_reg32(ENET_TX_DESC_ADDR(priv->enet_mac_base), DMA_ADDR((void *)&priv->tx_descs[0]));
+	gbus_write_reg32(ENET_RX_DESC_ADDR(priv->enet_mac_base), DMA_ADDR((void *)&priv->rx_descs[0]));
+	return 0;
+}
+
+/*
+ * free all dma rings memory, called at uninit time or when error
+ * occurs at init time
+ */
+static void enet_dma_free(struct tangox_enet_priv *priv)
+{
+	int i;
+
+	if (priv->alloc_pages_cached == NULL)
+		return;
+
+	/* note: kfree_skb(NULL) is _not_ ok */
+	for (i = 0; i < priv->rx_desc_count; i++) {
+		if (priv->rx_skbs[i]) 
+			kfree_skb(priv->rx_skbs[i]);
+	}
+
+	for (i = 0; i < priv->tx_desc_count; i++) {
+		if (priv->tx_skbs[i]) 
+			kfree_skb(priv->tx_skbs[i]);
+	}
+
+	free_pages((u32)priv->alloc_pages_cached, priv->alloc_order);
+}
+
+static int phy_reset(struct net_device *dev)
+{
+	struct tangox_enet_priv *priv;
+	int loop;
+	unsigned int val = 0;
+
+	priv = netdev_priv(dev);
+
+	/* reset phy */
+	val = enet_mdio_read(dev, priv->mii.phy_id, MII_BMCR);
+	enet_mdio_write(dev, priv->mii.phy_id, MII_BMCR, val | BMCR_RESET);
+
+	/* wait for the reset bit to clear */
+	udelay(100);
+	loop = 100;
+	while (loop) {
+		if ((enet_mdio_read(dev, priv->mii.phy_id, MII_BMCR) & BMCR_RESET) == 0)
+			break;
+		mdelay(1);
+		loop--;
+	}
+
+	if (loop == 0) {
+		printk(KERN_ERR "%s: PHY reset does not complete...\n", priv->name);
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+/*
+ * mac hw init is done here
+ */
+static int enet_hw_init(struct net_device *dev)
+{
+	struct tangox_enet_priv *priv;
+	unsigned int val = 0;
+
+	priv = netdev_priv(dev);
+	
+	if (priv->no_mdio == 0) {
+		if (phy_reset(dev))
+			return -EBUSY;
+	}
+
+	/* set pad_mode according to rgmii or not*/
+	val = gbus_read_reg8(priv->enet_mac_base + 0x400) & 0xf0;
+	if (priv->rgmii != PHY_100)
+		gbus_write_reg8(priv->enet_mac_base + 0x400, val | 0x01);
+
+	/* software reset IP */
+	gbus_write_reg8(priv->enet_mac_base + 0x424, 0);
+	udelay(10);
+	gbus_write_reg8(priv->enet_mac_base + 0x424, 1);
+
+	/*set threshold for internal clock 0x1*/
+	gbus_write_reg8(ENET_IC_THRESHOLD(priv->enet_mac_base), 1);
+
+	/*set Random seed 0x8*/
+	gbus_write_reg8(ENET_RANDOM_SEED(priv->enet_mac_base), 0x08);
+
+	/*set TX single deferral params 0xc*/
+	gbus_write_reg8(ENET_TX_SDP(priv->enet_mac_base), 0xc);
+
+	/*set slot time 0x7f for 10/100Mbps*/
+	gbus_write_reg8(ENET_SLOT_TIME(priv->enet_mac_base), 0x7f);
+
+	/*set Threshold for partial full 0xff */
+	gbus_write_reg8(ENET_PF_THRESHOLD(priv->enet_mac_base), 0xff);
+
+	/* set Pause Quanta 65535 */
+	gbus_write_reg8(ENET_PQ1(priv->enet_mac_base), 0xff);
+	gbus_write_reg8(ENET_PQ2(priv->enet_mac_base), 0xff);
+
+	/* configure TX DMA Channels */
+	val = (TCR_RS | TCR_LE | TCR_TFI(1) | /*TCR_DIE |*/ TCR_BTS(2) | TCR_DM);
+	gbus_write_reg32(ENET_TXC_CR(priv->enet_mac_base), val);
+
+	/* TX Interrupt Time Register */
+	val = (gbus_read_reg32(ENET_TXC_CR(priv->enet_mac_base)) >> 4) & 0x7;
+	val *= (TX_BUF_SIZE * (tangox_get_sysclock()/(priv->gigabit ? 125000000 : 25000000) + 2));
+	gbus_write_reg32(ENET_TX_ITR(priv->enet_mac_base), val);
+
+ 	/* configure RX DMA Channels */
+	val = (RCR_RS | RCR_LE | RCR_RFI(7) | RCR_BTS(2) | RCR_FI | RCR_DIE | /*RCR_EN |*/ RCR_DM);
+	val |= (RX_BUF_SIZE << 16);
+	gbus_write_reg32(ENET_RXC_CR(priv->enet_mac_base), val); 
+
+	/* RX Interrupt Time Register */
+	val = (gbus_read_reg32(ENET_RXC_CR(priv->enet_mac_base)) >> 4) & 0x7;
+	val *= (RX_BUF_SIZE * (tangox_get_sysclock()/(priv->gigabit ? 125000000 : 25000000) + 2));
+	gbus_write_reg32(ENET_RX_ITR(priv->enet_mac_base), val);
+
+	/* configure MAC controller */
+	val = (TX_RETRY_EN | TX_PAD_EN | TX_APPEND_FCS);
+	gbus_write_reg8(ENET_TX_CTL1(priv->enet_mac_base), (unsigned char)val);
+
+	/* set retry 5 time when collision occurs */
+	gbus_write_reg8(ENET_TX_CTL2(priv->enet_mac_base), 5);
+
+	val = (RX_RUNT | RX_PAD_STRIP /*| RX_SEND_CRC */ | RX_PAUSE_EN | RX_AF_EN);
+	gbus_write_reg8(ENET_RX_CTL(priv->enet_mac_base), (unsigned char)val);
+
+#ifdef ENABLE_MULTICAST
+	/* clear internal multicast address table */
+	gbus_write_reg8(ENET_MC_INIT(priv->enet_mac_base), 0x00);
+	while (gbus_read_reg8(ENET_MC_INIT(priv->enet_mac_base)))
+		;
+	DBG("Internal multicast address table is cleared\n");
+#endif
+
+	/* unicast */
+	/* Threshold for internal clock*/
+	/* threshold for partial empty*/
+	/* threshold for partial full */
+
+	/* buffer size for transmit must be 1 from the doc
+	   however, it's said that using 0xff ??*/
+	gbus_write_reg8(ENET_TX_BUFSIZE(priv->enet_mac_base), 0xff);
+
+	/* fifo control */
+
+	/*MAC mode*/
+	enet_mac_config(dev);
+
+	/* check gmii mode support */
+	priv->mii.supports_gmii = mii_check_gmii_support(&priv->mii);
+	DBG("gmii support=0x%x id=0x%x\n", priv->mii.supports_gmii, priv->mii.phy_id);
+
+	return 0;
+}
+
+static const struct net_device_ops tangox_netdev_ops = {
+	.ndo_open = enet_open,
+	.ndo_stop = enet_stop,
+	.ndo_start_xmit = enet_xmit,
+	.ndo_get_stats = enet_get_stats,
+	.ndo_set_mac_address = enet_set_mac_address,
+	.ndo_set_rx_mode = enet_set_multicast_list,
+	.ndo_do_ioctl = enet_ioctl,
+	.ndo_change_mtu = eth_change_mtu,
+	.ndo_validate_addr = eth_validate_addr,
+};
+
+/*
+ * allocate netdevice structure, do all dma rings allocations and
+ * register the netdevice
+ */
+extern int tangox_ethernet_getmac(int, unsigned char *);
+
+static int enet_probe(int idx)
+{
+#define MAX_MDC_CLOCK	2500000
+	struct tangox_enet_priv *priv;
+	struct net_device *dev;
+	int ret;
+	struct sockaddr sock;
+	char pad_mode;
+	unsigned short clk_div;
+	unsigned long enet_mac_base;
+	const char *name;
+	unsigned long tangox_chip_id(void);
+	unsigned long chip_id = tangox_chip_id();
+	unsigned long sysfreq = tangox_get_sysclock();
+
+	enet_mac_base = eth_mac_cores[idx].enet_mac_base;
+	name = eth_mac_cores[idx].name;
+
+	/* set pad_mode*/
+	pad_mode = gbus_read_reg8(enet_mac_base + 0x400);
+	gbus_write_reg8(enet_mac_base + 0x400, pad_mode & 0xf0);
+	pad_mode = gbus_read_reg8(enet_mac_base + 0x400);
+
+	/* set MDIO clock divider */
+	//clk_div = gbus_read_reg16(enet_mac_base + 0x420);
+	//DBG("default clk_div =%d\n", clk_div);
+	//gbus_write_reg16(enet_mac_base + 0x420, 50);
+	clk_div = sysfreq / (MAX_MDC_CLOCK * 2);
+	if ((clk_div * MAX_MDC_CLOCK * 2) < sysfreq)
+		clk_div++;
+	gbus_write_reg16(enet_mac_base + 0x420, clk_div);
+	//clk_div = gbus_read_reg16(enet_mac_base + 0x420);
+	//DBG("clk_div =%d: set MDIO clock=200/%d=%dMHz\n", clk_div, clk_div, 200/(clk_div*2));
+
+	/* allocate netdevice structure with enough length for our
+	 * context data */
+	if ((dev = alloc_etherdev(sizeof(*priv))) == NULL)
+		return -ENOMEM;
+
+	dev->netdev_ops = &tangox_netdev_ops;
+
+	/* initialize private data */
+	priv = netdev_priv(dev);
+	memset(priv, 0, sizeof(*priv));
+	priv->enet_mac_base = enet_mac_base;
+	priv->name = name;
+	priv->pending_tx = -1;
+	priv->pending_tx_cnt = 0;
+	priv->reclaim_limit = -1;
+	priv->rx_desc_count = DEF_RX_DESC_COUNT;
+	priv->tx_desc_count = DEF_TX_DESC_COUNT;
+	spin_lock_init(&priv->tx_lock);
+	spin_lock_init(&priv->ier_lock);
+	spin_lock_init(&priv->maccr_lock);
+
+	/* check gigabit mode */
+	if (((chip_id >> 16) & 0xfffe) == 0x8656) {
+		if (idx == 0) { /* only port 0 */
+			priv->gigabit = 1;
+			priv->rx_desc_count *= 2;
+			priv->tx_desc_count *= 2;
+		}
+	} else if ((chip_id & 0xfffe00ff) == 0x86460002) {
+		priv->gigabit = 1;
+		priv->rx_desc_count *= 2;
+		priv->tx_desc_count *= 2;
+	} else if (((chip_id >> 16) & 0xfff0) == 0x8670) {
+		priv->gigabit = 1;
+		priv->rx_desc_count *= 2;
+		priv->tx_desc_count *= 2;
+		data_aligned = 4;
+	} else if (((chip_id >> 16) & 0xfff0) == 0x8680) {
+		priv->gigabit = 1;
+		priv->rx_desc_count *= 2;
+		priv->tx_desc_count *= 2;
+		data_aligned = 4;
+	}
+
+	/* init tx done tasklet */
+	tasklet_init(&priv->tx_reclaim_tasklet, enet_tx_reclaim, (unsigned long)dev);
+#if 0
+	/* init tx reclaim timer */
+	init_timer(&priv->tx_reclaim_timer);
+	priv->tx_reclaim_timer.data = (unsigned long)dev;
+	priv->tx_reclaim_timer.function = enet_tx_reclaim_timer;
+#endif
+	/* init link check timer and mii lock */
+	init_timer(&priv->link_check_timer);
+	priv->link_check_timer.data = (unsigned long)dev;
+	priv->link_check_timer.function = enet_link_check;
+	spin_lock_init(&priv->mii_lock);
+
+	atomic_set(&priv->napi_poll, 0);
+
+	/* fill mii info */
+	priv->mii.dev = dev;
+	priv->mii.phy_id_mask = 0x1f;
+	priv->mii.reg_num_mask = 0x1f;
+	priv->mii.mdio_read = enet_mdio_read;
+	priv->mii.mdio_write = enet_mdio_write;
+	
+	if (eth_mac_cores[idx].phy_id != -1) {
+		/* phy id forced, just check for sanity */
+		if (eth_mac_cores[idx].phy_id < 0 || eth_mac_cores[idx].phy_id > 31) {
+			ret = -EINVAL;
+			goto err_out;
+		}
+		priv->mii.phy_id = eth_mac_cores[idx].phy_id;
+
+	} else {
+		int i;
+
+#ifdef CONFIG_TANGOX_ENET0_NOMDIO
+		if (idx == 0) {
+			priv->no_mdio = 1;
+#ifdef CONFIG_TANGOX_ENET0_NOMDIO_FULLDUPLEX
+			priv->mii.full_duplex = 1;
+#else
+			priv->mii.full_duplex = 0;
+#endif
+			priv->mii.phy_id = CONFIG_TANGOX_ENET0_NOMDIO_PHY_ADDR;
+			goto no_mdio;
+		}
+#endif
+
+#ifdef CONFIG_TANGOX_ENET1_NOMDIO
+		if (idx == 1) {
+			priv->no_mdio = 1;
+#ifdef CONFIG_TANGOX_ENET1_NOMDIO_FULLDUPLEX
+			priv->mii.full_duplex = 1;
+#else
+			priv->mii.full_duplex = 0;
+#endif
+			priv->mii.phy_id = CONFIG_TANGOX_ENET1_NOMDIO_PHY_ADDR;
+			goto no_mdio;
+		}
+#endif
+
+		/* try to probe phy if not given */
+		for (i = 0; i < 32; i++) {
+			uint32_t id;
+			int val;
+
+			val = enet_mdio_read(dev, i, MII_PHYSID1);
+			id = (val << 16);
+			val = enet_mdio_read(dev, i, MII_PHYSID2);
+			id |= val;
+			if ((id != 0xffffffff) && (id != 0x00000000)) {
+				/* check PHY*/
+				switch (id) {
+				case 0x00070421:
+					priv->rgmii = PHY_VITESSE;
+					break;
+				case 0x4dd072:
+					priv->rgmii = PHY_AR8035;
+					break;
+				default:
+					priv->rgmii = PHY_100;
+					priv->gigabit = 0;
+					priv->rx_desc_count = DEF_RX_DESC_COUNT;
+					priv->tx_desc_count = DEF_TX_DESC_COUNT;
+					break;
+				}
+				break;
+			} 
+		}
+
+		if (i == 32) {
+			printk(KERN_ERR "%s: unable to autodetect phy\n", priv->name);
+			ret = -EIO;
+			goto err_out;
+		}
+		priv->mii.phy_id = i;
+
+#if defined(CONFIG_TANGOX_ENET0_NOMDIO) || defined(CONFIG_TANGOX_ENET1_NOMDIO)
+no_mdio:
+#endif
+		if (priv->no_mdio)
+			printk(KERN_ERR "%s: MII interface is enabled on core %d\n", 
+					name,idx);
+		else
+			printk(KERN_ERR "%s: detected phy %s at address 0x%02x\n", 
+					name, (priv->rgmii == PHY_VITESSE ? "vsc8601 " : (priv->rgmii == PHY_AR8035 ? "AR8035 " : "")), priv->mii.phy_id);
+	}
+
+	printk(KERN_INFO "%s: Ethernet driver for SMP8xxx internal MAC core %d: %s Base at 0x%lx\n",
+				 name, idx, priv->rgmii?"1000Mbps":"100Mbps", enet_mac_base);
+
+	/* initialize hardware */
+	if ((ret = enet_hw_init(dev)))
+		goto err_out;
+
+	/* initialize dma descriptors */
+	if ((ret = enet_dma_init(dev)))
+		goto err_free_dma;
+
+//	printk("descs ga: 0x%lx, reports ga: 0x%lx, priv ga/sz: 0x%lx/%d, alloc_pages va: 0x%p, order: %d\n", DMA_ADDR((void *)priv->rx_descs),
+//			DMA_ADDR((void *)priv->rx_report), DMA_ADDR((void *)priv), sizeof(*priv), priv->alloc_pages, priv->alloc_order);
+
+	SET_ETHTOOL_OPS(dev, &enet_ethtool_ops);
+	netif_napi_add(dev, &priv->napi, enet_poll, priv->rx_desc_count/2 + 1);
+
+	dev->tx_queue_len = priv->tx_desc_count;
+#ifdef ENABLE_MULTICAST
+	dev->flags |= IFF_MULTICAST;
+#else	
+	dev->flags &= ~IFF_MULTICAST;
+#endif
+
+	/* set default mac address */
+	tangox_ethernet_getmac(idx, dev->dev_addr);
+	memcpy(&(sock.sa_data), dev->dev_addr, ETH_ALEN);
+
+	enet_set_mac_address(dev, &sock);
+
+	if ((ret = register_netdev(dev))) {
+		printk(KERN_ERR "%s: unable to register netdevice\n", priv->name);
+		goto err_free_dev;
+	}
+
+	ret = request_irq(eth_mac_cores[idx].irq, enet_isr, IRQF_DISABLED,
+				eth_mac_cores[idx].name, dev);
+	if (ret)
+		goto err_free_irq;
+
+	dev->irq = eth_mac_cores[idx].irq;
+
+	printk(KERN_INFO "%s: mac address %02x:%02x:%02x:%02x:%02x:%02x\n", priv->name,
+			dev->dev_addr[0], dev->dev_addr[1], dev->dev_addr[2],
+			dev->dev_addr[3], dev->dev_addr[4], dev->dev_addr[5]);
+
+	eth_mac_cores[idx].gdev = dev;
+
+	/* increase gbus bandwidth */
+	gbus_write_reg32(REG_BASE_system_block + 0x130 + (idx * 4),
+		(gbus_read_reg32(REG_BASE_system_block + 0x130 + (idx * 4)) & 0xffffff00) | 0x3f);
+
+	return 0;
+
+err_free_irq:
+	free_irq(eth_mac_cores[idx].irq, dev);
+err_free_dev:
+	free_netdev(dev);
+err_free_dma:
+	enet_dma_free(priv);
+err_out:
+	return ret;
+}
+
+/*
+ * entry point, checks if ethernet is enabled on the board and if so,
+ * probes it
+ */
+extern int tangox_ethernet_enabled(int);
+
+int __init tangox_enet_init(void)
+{
+	int i;
+
+	/* for command line overwrite */
+	eth_mac_cores[0].phy_id = phyid_0;
+	eth_mac_cores[1].phy_id = phyid_1;
+
+	for (i = 0; i < NUM_MAC_CORES; i++) {
+		if ((1 << i) & mac_cores) {
+			if (tangox_ethernet_enabled(i) == 0) {
+				printk(KERN_NOTICE "%s: ethernet mac_core %d support is disabled from XENV\n", eth_mac_cores[i].name, i);
+				continue;
+			}
+			enet_probe(i);
+		} else {
+			printk(KERN_NOTICE "%s: ethernet mac_core %d support is disabled\n", eth_mac_cores[i].name, i);
+		}
+	}
+	return 0;
+}
+
+/*
+ * exit func, stops hardware and unregisters netdevice
+ */
+void __exit tangox_enet_exit(void)
+{
+	struct tangox_enet_priv *priv;
+	struct net_device *dev;
+	int i;
+
+	for (i = 0; i < NUM_MAC_CORES; i++) {
+		if ((dev = eth_mac_cores[i].gdev) == NULL)
+			continue;
+
+		free_irq(dev->irq, dev);
+		unregister_netdev(dev);
+
+		priv = netdev_priv(dev);
+		enet_dma_free(priv);
+
+		free_netdev(dev);
+	}
+}
+
+module_init(tangox_enet_init);
+module_exit(tangox_enet_exit);
+
+MODULE_DESCRIPTION("SMP8xxx internal ethernet mac driver");
+MODULE_AUTHOR("TANGOX standalone team");
+MODULE_LICENSE("GPL");
+
+MODULE_PARM_DESC(phyid_0, "PHY id for core 0, else autodetect");
+module_param(phyid_0, int, 0);
+
+MODULE_PARM_DESC(phyid_1, "PHY id for core 1, else autodetect");
+module_param(phyid_1, int, 0);
+
+MODULE_PARM_DESC(mac_cores, "MAC core id, 1 for core 0, 2 for core 1, 3 for both");
+module_param(mac_cores, int, 0);
+
diff -Naur linux-3.9.2.ref/drivers/net/ethernet/tangox_enet.h linux-3.9.2/drivers/net/ethernet/tangox_enet.h
--- linux-3.9.2.ref/drivers/net/ethernet/tangox_enet.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/drivers/net/ethernet/tangox_enet.h	2013-07-23 19:31:08.000000000 +0200
@@ -0,0 +1,390 @@
+/*********************************************************************
+ Copyright (C) 2001-2009
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#ifndef __TANGOX_ENET_H
+#define __TANGOX_ENET_H
+
+#include <linux/types.h>
+#include <linux/skbuff.h>
+#include <linux/mii.h>
+#include <linux/timer.h>
+
+#include <asm/addrspace.h>
+
+#if defined(CONFIG_TANGO3)
+#include <asm/tango3/hardware.h>
+#include <asm/tango3/tango3_gbus.h>
+#else
+#error "Unknown architecture"
+#endif
+
+/* how many MAC cores we have */
+#define NUM_MAC_CORES	2
+
+#define ENET_IRQ0	((IRQ_CONTROLLER_IRQ_BASE) + (LOG2_CPU_ETH_MAC_INT))
+#define ENET_IRQ1	((IRQ_CONTROLLER_IRQ_BASE) + (LOG2_CPU_ETH_MAC1_INT))
+
+/*
+ * number of rx/tx buffers available
+ */
+#define DEF_RX_DESC_COUNT	512
+#define DEF_TX_DESC_COUNT	128
+
+/*
+ * we enable tx  interrupt when there is equal to  this number of free
+ * tx desc. Keep it lower than TX_DESC_COUNT if you change it.
+ */
+#define ENET_DESC_LOW	16
+
+/*
+ * sizeof rx buffers we give to the dma controller
+ */
+#define RX_BUF_SIZE		1552	// 0x610
+#define TX_BUF_SIZE		1552	// 0x610
+#define DEF_DATA_ALIGNMENT	8	// default data alignment
+
+/* since the Ethernet header is 14 bytes, so that we need 2 more bytes to align. 
+ * but s_addr need to be 4 bytes aligned, so that we have trade off here
+ */
+#define SKB_RESERVE_SIZE	0	
+
+/*
+ * we reclaim  transmited using a  timer, we switch to  interrupt mode
+ * under high load. this is the timer frequency
+ */
+#define TX_RECLAIM_TIMER_FREQ	(HZ / 100)
+
+/*
+ * link status  is polled on a regular  basis by a timer,  this is its
+ * frequency
+ */
+#define LINK_CHECK_TIMER_FREQ	(HZ)
+
+/*
+ * getting system frequency
+ */
+extern unsigned long tangox_get_sysclock(void);
+
+/*
+ * address space conversion
+ */
+#define CACHE_TO_NONCACHE(x)	KSEG1ADDR(x)
+
+/*
+ * dma address translation
+ */
+static inline unsigned long DMA_ADDR(void *addr) 
+{
+	return tangox_dma_address(CPHYSADDR((unsigned long)addr));
+}
+
+/*
+ * Mac/DMA registers offset, refer to documentation
+ */
+#define ENET_TX_CTL1(mac_base)		((mac_base) + 0x00)
+#define TX_TPD		        	(1 << 5)
+#define TX_APPEND_FCS       		(1 << 4)
+#define TX_PAD_EN          		(1 << 3)
+#define TX_RETRY_EN        		(1 << 2)
+#define TX_EN		        	(1 << 0)
+#define ENET_TX_CTL2(mac_base)		((mac_base) + 0x01)
+#define ENET_RX_CTL(mac_base)	    	((mac_base) + 0x04)
+#define RX_BC_DISABLE			(1 << 7)
+#define RX_RUNT		        	(1 << 6)
+#define RX_AF_EN			(1 << 5)
+#define RX_PAUSE_EN	     		(1 << 3)
+#define RX_SEND_CRC	    		(1 << 2)
+#define RX_PAD_STRIP	   		(1 << 1)
+#define RX_EN		        	(1 << 0)
+#define ENET_RANDOM_SEED(mac_base)	((mac_base) + 0x8)
+#define ENET_TX_SDP(mac_base)	    	((mac_base) + 0x14)
+#define ENET_TX_TPDP1(mac_base)		((mac_base) + 0x18)
+#define ENET_TX_TPDP2(mac_base)		((mac_base) + 0x19)
+#define ENET_SLOT_TIME(mac_base)	((mac_base) + 0x1c)
+#define ENET_MDIO_CMD1(mac_base)	((mac_base) + 0x20)
+#define ENET_MDIO_CMD2(mac_base)	((mac_base) + 0x21)
+#define ENET_MDIO_CMD3(mac_base)	((mac_base) + 0x22)
+#define ENET_MDIO_CMD4(mac_base)	((mac_base) + 0x23)
+#define MIIAR_ADDR(x)      		((x) << 21)
+#define MIIAR_REG(x)       		((x) << 16)
+#define MIIAR_DATA(x)      		((x) <<  0)
+#define MDIO_CMD_GO	    		(1 << 31)
+#define MDIO_CMD_WR   			(1 << 26)
+#define ENET_MDIO_STS1(mac_base)	((mac_base) + 0x24)
+#define ENET_MDIO_STS2(mac_base)	((mac_base) + 0x25)
+#define ENET_MDIO_STS3(mac_base)	((mac_base) + 0x26)
+#define ENET_MDIO_STS4(mac_base)	((mac_base) + 0x27)
+#define MDIO_STS_ERR			(1 << 31)
+#define ENET_MC_ADDR1(mac_base)		((mac_base) + 0x28)
+#define ENET_MC_ADDR2(mac_base)		((mac_base) + 0x29)
+#define ENET_MC_ADDR3(mac_base)		((mac_base) + 0x2a)
+#define ENET_MC_ADDR4(mac_base)		((mac_base) + 0x2b)
+#define ENET_MC_ADDR5(mac_base)		((mac_base) + 0x2c)
+#define ENET_MC_ADDR6(mac_base)		((mac_base) + 0x2d)
+#define ENET_MC_INIT(mac_base)		((mac_base) + 0x2e)
+#define ENET_UC_ADDR1(mac_base)		((mac_base) + 0x3c)
+#define ENET_UC_ADDR2(mac_base)		((mac_base) + 0x3d)
+#define ENET_UC_ADDR3(mac_base)		((mac_base) + 0x3e)
+#define ENET_UC_ADDR4(mac_base)		((mac_base) + 0x3f)
+#define ENET_UC_ADDR5(mac_base)		((mac_base) + 0x40)
+#define ENET_UC_ADDR6(mac_base)		((mac_base) + 0x41)
+#define ENET_MAC_MODE(mac_base)		((mac_base) + 0x44)
+#define RGMII_MODE	    		(1 << 7)
+#define HALF_DUPLEX  			(1 << 4)
+#define BST_EN	    	 		(1 << 3)
+#define LB_EN	    			(1 << 2)
+#define GMAC_MODE	    		(1 << 0)
+#define ENET_IC_THRESHOLD(mac_base)	((mac_base) + 0x50)
+#define ENET_PE_THRESHOLD(mac_base)	((mac_base) + 0x51)
+#define ENET_PF_THRESHOLD(mac_base)	((mac_base) + 0x52)
+/* TX buffer size must be set to 0x01 ??*/
+#define ENET_TX_BUFSIZE(mac_base)	((mac_base) + 0x54)
+#define ENET_FIFO_CTL(mac_base)		((mac_base) + 0x56)
+#define ENET_PQ1(mac_base)	    	((mac_base) + 0x60)
+#define ENET_PQ2(mac_base)	    	((mac_base) + 0x61)
+#define ENET_MAC_ADDR1(mac_base)	((mac_base) + 0x6a)
+#define ENET_MAC_ADDR2(mac_base)	((mac_base) + 0x6b)
+#define ENET_MAC_ADDR3(mac_base)	((mac_base) + 0x6c)
+#define ENET_MAC_ADDR4(mac_base)	((mac_base) + 0x6d)
+#define ENET_MAC_ADDR5(mac_base)	((mac_base) + 0x6e)
+#define ENET_MAC_ADDR6(mac_base)	((mac_base) + 0x6f)
+#define ENET_STAT_DATA1(mac_base)	((mac_base) + 0x78)
+#define ENET_STAT_DATA2(mac_base)	((mac_base) + 0x79)
+#define ENET_STAT_DATA3(mac_base)	((mac_base) + 0x7a)
+#define ENET_STAT_DATA4(mac_base)	((mac_base) + 0x7b)
+#define ENET_STAT_INDEX(mac_base)	((mac_base) + 0x7c)
+#define ENET_STAT_CLEAR(mac_base)	((mac_base) + 0x7d)
+#define ENET_SLEEP_MODE(mac_base)	((mac_base) + 0x7e)
+#define SLEEP_MODE	    		(1 << 0)
+#define ENET_WAKEUP(mac_base)	    	((mac_base) + 0x7f)
+#define WAKEUP		    		(1 << 0)
+
+#define ENET_TXC_CR(mac_base)		((mac_base) + 0x100)
+#define TCR_LK		    		(1 << 12)
+#define TCR_DS		    		(1 << 11)
+#define TCR_BTS(x)          		(((x) & 0x7) << 8)
+#define TCR_DIE		    		(1 << 7)
+#define TCR_TFI(x)          		(((x) & 0x7) << 4)
+#define TCR_LE		    		(1 << 3)
+#define TCR_RS		    		(1 << 2)
+#define TCR_DM		    		(1 << 1)
+#define TCR_EN		    		(1 << 0)
+
+#define ENET_TXC_SR(mac_base)		((mac_base) + 0x104)
+#define TSR_DE				(1 << 3)
+#define TSR_DI				(1 << 2)
+#define TSR_TO				(1 << 1)
+#define TSR_TI				(1 << 0)
+
+#define ENET_TX_SAR(mac_base)		((mac_base) + 0x108)
+#define ENET_TX_DESC_ADDR(mac_base)	((mac_base) + 0x10c)
+
+#define ENET_TX_REPORT_ADDR(mac_base)	((mac_base) + 0x110)
+#define TX_BYTES_TRASFERRED(x)		(((x) >> 16) & 0xffff)
+#define TX_FIRST_DEFERRAL		(1 << 7)
+#define TX_EARLY_COLLISIONS(x)		(((x) >> 3) & 0xf)
+#define TX_LATE_COLLISION		(1 << 2)
+#define TX_PACKET_DROPPED		(1 << 1)
+#define TX_FIFO_UNDERRUN		(1 << 0)
+
+#define ENET_TX_FIFO_SR(mac_base)	((mac_base) + 0x114)
+#define ENET_TX_ITR(mac_base)		((mac_base) + 0x118)
+
+#define ENET_RXC_CR(mac_base)		((mac_base) + 0x200)
+#define RCR_FI				(1 << 13)
+#define RCR_LK				(1 << 12)
+#define RCR_DS				(1 << 11)
+#define RCR_BTS(x)         		(((x) & 7) << 8)
+#define RCR_DIE				(1 << 7)
+#define RCR_RFI(x)         		(((x) & 7) << 4)
+#define RCR_LE				(1 << 3)
+#define RCR_RS				(1 << 2)
+#define RCR_DM				(1 << 1)
+#define RCR_EN				(1 << 0)
+
+#define ENET_RXC_SR(mac_base)		((mac_base) + 0x204)
+#define RSR_DE				(1 << 3)
+#define RSR_DI				(1 << 2)
+#define RSR_RO				(1 << 1)
+#define RSR_RI				(1 << 0)
+
+#define ENET_RX_SAR(mac_base)		((mac_base) + 0x208)
+#define ENET_RX_DESC_ADDR(mac_base)	((mac_base) + 0x20c)
+
+#define ENET_RX_REPORT_ADDR(mac_base)	((mac_base) + 0x210)
+#define RX_BYTES_TRANSFERRED(x)		(((x) >> 16) & 0xFFFF)
+#define RX_MULTICAST_PKT		(1 << 9)
+#define RX_BROADCAST_PKT		(1 << 8)
+#define RX_LENGTH_ERR			(1 << 7)
+#define RX_FCS_ERR			(1 << 6)
+#define RX_RUNT_PKT			(1 << 5)
+#define RX_FIFO_OVERRUN			(1 << 4)
+#define RX_LATE_COLLISION		(1 << 3)
+#define RX_FRAME_LEN_ERROR		(1 << 2)
+
+#define ENET_RX_FIFO_SR(mac_base)	((mac_base) + 0x214)
+#define ENET_RX_ITR(mac_base)		((mac_base) + 0x218)
+
+/* Vitesse PHY Registers */
+#define VITESSE_EXTENDED_PHY_CTL		0x17
+#define VITESSE_LED_CTL					0x1b
+#define VITESSE_EXTENDED_PAGE_CTL		0x1f
+#define VITESSE_ENHANCED_LED_METHOD		0x10
+#define VITESSE_ENHANCED_LED_BEHAVIOR	0x11
+/*
+ * rx dma descriptor definition
+ */
+struct enet_desc {
+	unsigned long s_addr;
+	unsigned long n_addr;
+	unsigned long r_addr;
+	unsigned long config;
+}; 
+
+#define DESC_ID				(1 << 23)
+#define DESC_EOC			(1 << 22)
+#define DESC_EOF			(1 << 21)
+#define DESC_LK				(1 << 20)
+#define DESC_DS				(1 << 19)
+#define DESC_BTS(x)			(((x) & 0x7) <<16)
+#define DESC_TC(x)			(x)
+
+enum {
+	PHY_100,
+	PHY_VITESSE,
+	PHY_AR8035,
+};
+
+/*
+ * our private context
+ */
+struct tangox_enet_priv {
+
+	/*
+	 * tracking the allocated pages
+	 */
+	unsigned int			alloc_order;
+	void				*alloc_pages;
+	void				*alloc_pages_cached;
+	atomic_t			napi_poll;
+
+	struct napi_struct		napi;
+
+	/*
+	 * rx related
+	 */
+
+	/* pointer to rx descriptor array */
+	volatile struct enet_desc	*rx_descs;
+
+	/* last rx descriptor processed */
+	unsigned int			last_rx_desc;
+
+	/* we keep a list of skb given */
+	struct sk_buff			**rx_skbs;
+	
+	/* desc status report */
+	unsigned long 			*rx_report;
+
+	/* ethernet device stats */
+	struct net_device_stats		stats;
+
+	/* rx stopped? */
+	int				rx_stopped;
+
+	/* tracking the EOC */
+	unsigned int			rx_eoc;
+
+	/*
+	 * tx related
+	 */
+
+	/* access  to  tx related  dma  stuffs  is  protected by  this
+	 * spinlock, this is because we  access them via a tasklet and
+	 * a timer */
+	spinlock_t			tx_lock;
+
+	/* pointer to tx descriptor array */
+	volatile struct enet_desc	*tx_descs;
+
+	/* index of current dirty tx descriptor */
+	unsigned int			dirty_tx_desc;
+
+	/* index of next clean tx descriptor to use */
+	unsigned int			next_tx_desc;
+
+	/* count of free tx desc to avoid its computation */
+	unsigned int			free_tx_desc_count;
+
+	/* list of sent skb */
+	struct sk_buff			**tx_skbs;
+
+	/* list of tx_bufs */
+	unsigned char 			**tx_bufs;
+	
+	/* desc status report */
+	unsigned long 			*tx_report;
+
+	/* tx  done operation is  done under  these tasklet  and timer
+	 * context */
+	struct tasklet_struct		tx_reclaim_tasklet;
+	struct timer_list		tx_reclaim_timer;
+
+	/* the 1st pending tx  */
+	int 				pending_tx;
+	
+	/* how many pending desc in this pending tx*/
+	int 				pending_tx_cnt;
+
+	/* reclaim to this limit */
+	int 				reclaim_limit;
+
+	/* desc chained */
+	unsigned int			is_mdesc;
+
+	/*
+	 * misc
+	 */
+
+	/* base address of enet registers */
+	unsigned long			enet_mac_base;
+
+	/* device name */
+	const char 			*name;
+
+	/* spinlock used to protect interrupt enable register */
+	spinlock_t			ier_lock;
+
+	/* spinlock used to protect maccr register */
+	spinlock_t			maccr_lock;
+
+	/* our mii state */
+	struct mii_if_info		mii;
+
+	/* mii access is protected by following spinlock */
+	spinlock_t			mii_lock;
+
+	/* link status is checked periodically by this timer */
+	struct timer_list		link_check_timer;
+
+	/* rgmii */
+	int				rgmii;
+
+	/* no MDIO access */
+	int				no_mdio;
+	
+	/* gigabit enabled? */
+	int				gigabit;
+
+	/* descriptor counts */
+	int				rx_desc_count;
+	int				tx_desc_count;
+};
+
+#endif /* __TANGOX_ENET_H */
diff -Naur linux-3.9.2.ref/drivers/tty/serial/8250/8250_core.c linux-3.9.2/drivers/tty/serial/8250/8250_core.c
--- linux-3.9.2.ref/drivers/tty/serial/8250/8250_core.c	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/drivers/tty/serial/8250/8250_core.c	2013-07-23 19:31:10.000000000 +0200
@@ -42,6 +42,20 @@
 #include <linux/sunserialcore.h>
 #endif
 
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/rmdefs.h>
+#include <asm/tango2/tango2_gbus.h>
+#include <asm/tango2/tango2.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/rmdefs.h>
+#include <asm/tango3/tango3_gbus.h>
+#include <asm/tango3/tango3.h>
+#endif
+
+#ifdef CONFIG_TANGOX
+extern unsigned long tangox_get_sysclock(void);
+#endif
+
 #include <asm/io.h>
 #include <asm/irq.h>
 
@@ -325,6 +339,18 @@
 	},
 };
 
+#ifdef CONFIG_TANGOX
+static int default_serial_dl_read(struct uart_8250_port *up)
+{
+	return serial_in(up, UART_DL);
+}
+
+/* Uart divisor latch write */
+static void default_serial_dl_write(struct uart_8250_port *up, int value)
+{
+	serial_out(up, UART_DL, value);
+}
+#else
 /* Uart divisor latch read */
 static int default_serial_dl_read(struct uart_8250_port *up)
 {
@@ -337,6 +363,7 @@
 	serial_out(up, UART_DLL, value & 0xff);
 	serial_out(up, UART_DLM, value >> 8 & 0xff);
 }
+#endif
 
 #if defined(CONFIG_MIPS_ALCHEMY) || defined(CONFIG_SERIAL_8250_RT288X)
 
@@ -401,13 +428,33 @@
 static unsigned int mem_serial_in(struct uart_port *p, int offset)
 {
 	offset = offset << p->regshift;
+#ifdef CONFIG_TANGOX
+	{
+		unsigned long v;
+
+		/* no EFR on tango2/tango3 */
+		if (offset == (UART_EFR << p->regshift))
+			v = 0;
+		else
+			v = gbus_read_reg32((unsigned long)p->membase + offset);
+		return v;
+	}
+#else
 	return readb(p->membase + offset);
+#endif
 }
 
 static void mem_serial_out(struct uart_port *p, int offset, int value)
 {
 	offset = offset << p->regshift;
+#ifdef CONFIG_TANGOX
+	/* no EFR on tango2/tango3 */
+	if (offset != (UART_EFR << p->regshift))
+		gbus_write_reg32((unsigned long)p->membase + offset, value);
+	return;
+#else
 	writeb(value, p->membase + offset);
+#endif
 }
 
 static void mem32_serial_out(struct uart_port *p, int offset, int value)
@@ -692,6 +739,16 @@
 	old_lcr = serial_in(p, UART_LCR);
 	serial_out(p, UART_LCR, UART_LCR_CONF_MODE_A);
 
+#ifdef CONFIG_TANGOX
+	old_dll = serial_in(p, UART_DL) & 0xff;
+	old_dlm = serial_in(p, UART_DL) >> 8;
+
+	serial_out(p, UART_DL, 0);
+
+	id = serial_in(p, UART_DL);
+
+	serial_out(p, UART_DL, (old_dlm << 8) | old_dll);
+#else
 	old_dll = serial_in(p, UART_DLL);
 	old_dlm = serial_in(p, UART_DLM);
 
@@ -702,6 +759,7 @@
 
 	serial_out(p, UART_DLL, old_dll);
 	serial_out(p, UART_DLM, old_dlm);
+#endif
 	serial_out(p, UART_LCR, old_lcr);
 
 	return id;
@@ -1647,7 +1705,7 @@
 	struct hlist_head *h;
 	struct hlist_node *n;
 	struct irq_info *i;
-	int ret, irq_flags = up->port.flags & UPF_SHARE_IRQ ? IRQF_SHARED : 0;
+	int ret, irq_flags = ((up->port.flags & UPF_SHARE_IRQ) ? IRQF_SHARED : 0);
 
 	mutex_lock(&hash_mutex);
 
@@ -2906,7 +2964,13 @@
 static int __init serial8250_console_setup(struct console *co, char *options)
 {
 	struct uart_port *port;
+#ifdef CONFIG_TANGOX
+	extern int tangox_uart_baudrate(int uart);
+	extern int tangox_uart_console_port(void);
+	int baud = tangox_uart_baudrate(tangox_uart_console_port());
+#else
 	int baud = 9600;
+#endif
 	int bits = 8;
 	int parity = 'n';
 	int flow = 'n';
diff -Naur linux-3.9.2.ref/drivers/tty/serial/8250/8250_early.c linux-3.9.2/drivers/tty/serial/8250/8250_early.c
--- linux-3.9.2.ref/drivers/tty/serial/8250/8250_early.c	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/drivers/tty/serial/8250/8250_early.c	2013-07-23 19:31:10.000000000 +0200
@@ -121,8 +121,13 @@
 
 	lcr = serial8250_early_in(port, UART_LCR);
 	serial8250_early_out(port, UART_LCR, lcr | UART_LCR_DLAB);
+#ifdef CONFIG_TANGOX
+	dll = serial8250_early_in(port, UART_DL) & 0xff;
+	dlm = serial8250_early_in(port, UART_DL) >> 8;
+#else
 	dll = serial8250_early_in(port, UART_DLL);
 	dlm = serial8250_early_in(port, UART_DLM);
+#endif
 	serial8250_early_out(port, UART_LCR, lcr);
 
 	quot = (dlm << 8) | dll;
@@ -143,8 +148,12 @@
 	divisor = DIV_ROUND_CLOSEST(port->uartclk, 16 * device->baud);
 	c = serial8250_early_in(port, UART_LCR);
 	serial8250_early_out(port, UART_LCR, c | UART_LCR_DLAB);
+#ifdef CONFIG_TANGOX
+	serial8250_early_out(port, UART_DL, divisor & 0xffff);
+#else
 	serial8250_early_out(port, UART_DLL, divisor & 0xff);
 	serial8250_early_out(port, UART_DLM, (divisor >> 8) & 0xff);
+#endif
 	serial8250_early_out(port, UART_LCR, c & ~UART_LCR_DLAB);
 }
 
diff -Naur linux-3.9.2.ref/drivers/tty/serial/serial_core.c linux-3.9.2/drivers/tty/serial/serial_core.c
--- linux-3.9.2.ref/drivers/tty/serial/serial_core.c	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/drivers/tty/serial/serial_core.c	2013-07-23 19:31:10.000000000 +0200
@@ -424,7 +424,7 @@
 	else
 		quot = DIV_ROUND_CLOSEST(port->uartclk, 16 * baud);
 
-	return quot;
+	return (quot ? quot : 1);
 }
 
 EXPORT_SYMBOL(uart_get_divisor);
diff -Naur linux-3.9.2.ref/drivers/usb/core/devio.c linux-3.9.2/drivers/usb/core/devio.c
--- linux-3.9.2.ref/drivers/usb/core/devio.c	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/drivers/usb/core/devio.c	2013-07-23 19:31:17.000000000 +0200
@@ -792,6 +792,17 @@
 	if (imajor(inode) == USB_DEVICE_MAJOR)
 		dev = usbdev_lookup_by_devt(inode->i_rdev);
 
+#ifdef CONFIG_USB_DEVICEFS
+	/* procfs file */
+	if (!dev) {
+		dev = inode->i_private;
+		if (dev && dev->usbfs_dentry &&
+					dev->usbfs_dentry->d_inode == inode)
+			usb_get_dev(dev);
+		else
+			dev = NULL;
+	}
+#endif
 	mutex_unlock(&usbfs_mutex);
 
 	if (!dev)
@@ -2218,13 +2229,44 @@
 	}
 }
 
+#ifdef CONFIG_USB_DEVICE_CLASS
+static struct class *usb_classdev_class;
+
+static int usb_classdev_add(struct usb_device *dev)
+{
+	struct device *cldev;
+
+	cldev = device_create(usb_classdev_class, &dev->dev, dev->dev.devt,
+			      NULL, "usbdev%d.%d", dev->bus->busnum,
+			      dev->devnum);
+	if (IS_ERR(cldev))
+		return PTR_ERR(cldev);
+	dev->usb_classdev = cldev;
+	return 0;
+}
+
+static void usb_classdev_remove(struct usb_device *dev)
+{
+	if (dev->usb_classdev)
+		device_unregister(dev->usb_classdev);
+}
+
+#else
+#define usb_classdev_add(dev)		0
+#define usb_classdev_remove(dev)	do {} while (0)
+
+#endif
+
 static int usbdev_notify(struct notifier_block *self,
 			       unsigned long action, void *dev)
 {
 	switch (action) {
 	case USB_DEVICE_ADD:
+		if (usb_classdev_add(dev))
+			return NOTIFY_BAD;
 		break;
 	case USB_DEVICE_REMOVE:
+		usb_classdev_remove(dev);
 		usbdev_remove(dev);
 		break;
 	}
@@ -2254,6 +2296,21 @@
 		       USB_DEVICE_MAJOR);
 		goto error_cdev;
 	}
+#ifdef CONFIG_USB_DEVICE_CLASS
+	usb_classdev_class = class_create(THIS_MODULE, "usb_device");
+	if (IS_ERR(usb_classdev_class)) {
+		printk(KERN_ERR "Unable to register usb_device class\n");
+		retval = PTR_ERR(usb_classdev_class);
+		cdev_del(&usb_device_cdev);
+		usb_classdev_class = NULL;
+		goto out;
+	}
+	/* devices of this class shadow the major:minor of their parent
+	 * device, so clear ->dev_kobj to prevent adding duplicate entries
+	 * to /sys/dev
+	 */
+	usb_classdev_class->dev_kobj = NULL;
+#endif
 	usb_register_notify(&usbdev_nb);
 out:
 	return retval;
@@ -2266,6 +2323,9 @@
 void usb_devio_cleanup(void)
 {
 	usb_unregister_notify(&usbdev_nb);
+#ifdef CONFIG_USB_DEVICE_CLASS
+	class_destroy(usb_classdev_class);
+#endif
 	cdev_del(&usb_device_cdev);
 	unregister_chrdev_region(USB_DEVICE_DEV, USB_DEVICE_MAX);
 }
diff -Naur linux-3.9.2.ref/drivers/usb/core/driver.c linux-3.9.2/drivers/usb/core/driver.c
--- linux-3.9.2.ref/drivers/usb/core/driver.c	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/drivers/usb/core/driver.c	2013-07-23 19:31:17.000000000 +0200
@@ -797,6 +797,15 @@
 		pr_debug("usb %s: bus removed?\n", dev_name(dev));
 		return -ENODEV;
 	}
+#ifdef	CONFIG_USB_DEVICEFS
+	/* If this is available, userspace programs can directly read
+	 * all the device descriptors we don't tell them about.  Or
+	 * act as usermode drivers.
+	 */
+	if (add_uevent_var(env, "DEVICE=/proc/bus/usb/%03d/%03d",
+			   usb_dev->bus->busnum, usb_dev->devnum))
+		return -ENOMEM;
+#endif
 
 	/* per-device configurations are common */
 	if (add_uevent_var(env, "PRODUCT=%x/%x/%x",
@@ -842,13 +851,15 @@
 
 	retval = driver_register(&new_udriver->drvwrap.driver);
 
-	if (!retval)
+	if (!retval) {
 		pr_info("%s: registered new device driver %s\n",
 			usbcore_name, new_udriver->name);
-	else
+		usbfs_update_special();
+	} else {
 		printk(KERN_ERR "%s: error %d registering device "
 			"	driver %s\n",
 			usbcore_name, retval, new_udriver->name);
+	}
 
 	return retval;
 }
@@ -867,6 +878,7 @@
 			usbcore_name, udriver->name);
 
 	driver_unregister(&udriver->drvwrap.driver);
+	usbfs_update_special();
 }
 EXPORT_SYMBOL_GPL(usb_deregister_device_driver);
 
@@ -907,6 +919,8 @@
 	if (retval)
 		goto out;
 
+	usbfs_update_special();
+
 	retval = usb_create_newid_files(new_driver);
 	if (retval)
 		goto out_newid;
@@ -946,6 +960,8 @@
 	usb_remove_newid_files(driver);
 	driver_unregister(&driver->drvwrap.driver);
 	usb_free_dynids(driver);
+
+	usbfs_update_special();
 }
 EXPORT_SYMBOL_GPL(usb_deregister);
 
diff -Naur linux-3.9.2.ref/drivers/usb/core/inode.c linux-3.9.2/drivers/usb/core/inode.c
--- linux-3.9.2.ref/drivers/usb/core/inode.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/drivers/usb/core/inode.c	2013-07-23 19:31:17.000000000 +0200
@@ -0,0 +1,747 @@
+/*****************************************************************************/
+
+/*
+ *	inode.c  --  Inode/Dentry functions for the USB device file system.
+ *
+ *	Copyright (C) 2000 Thomas Sailer (sailer@ife.ee.ethz.ch)
+ *	Copyright (C) 2001,2002,2004 Greg Kroah-Hartman (greg@kroah.com)
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ *	This program is distributed in the hope that it will be useful,
+ *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *	GNU General Public License for more details.
+ *
+ *	You should have received a copy of the GNU General Public License
+ *	along with this program; if not, write to the Free Software
+ *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  History:
+ *   0.1  04.01.2000  Created
+ *   0.2  10.12.2001  converted to use the vfs layer better
+ */
+
+/*****************************************************************************/
+
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/mount.h>
+#include <linux/pagemap.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <linux/usb.h>
+#include <linux/namei.h>
+#include <linux/usbdevice_fs.h>
+#include <linux/parser.h>
+#include <linux/notifier.h>
+#include <linux/seq_file.h>
+#include <linux/usb/hcd.h>
+#include <asm/byteorder.h>
+#include "usb.h"
+
+#define USBFS_DEFAULT_DEVMODE (S_IWUSR | S_IRUGO)
+#define USBFS_DEFAULT_BUSMODE (S_IXUGO | S_IRUGO)
+#define USBFS_DEFAULT_LISTMODE S_IRUGO
+
+static const struct file_operations default_file_operations;
+static struct vfsmount *usbfs_mount;
+static int usbfs_mount_count;	/* = 0 */
+
+static struct dentry *devices_usbfs_dentry;
+static int num_buses;	/* = 0 */
+
+static uid_t devuid;	/* = 0 */
+static uid_t busuid;	/* = 0 */
+static uid_t listuid;	/* = 0 */
+static gid_t devgid;	/* = 0 */
+static gid_t busgid;	/* = 0 */
+static gid_t listgid;	/* = 0 */
+static umode_t devmode = USBFS_DEFAULT_DEVMODE;
+static umode_t busmode = USBFS_DEFAULT_BUSMODE;
+static umode_t listmode = USBFS_DEFAULT_LISTMODE;
+
+static int usbfs_show_options(struct seq_file *seq, struct dentry *root)
+{
+	if (devuid != 0)
+		seq_printf(seq, ",devuid=%u", devuid);
+	if (devgid != 0)
+		seq_printf(seq, ",devgid=%u", devgid);
+	if (devmode != USBFS_DEFAULT_DEVMODE)
+		seq_printf(seq, ",devmode=%o", devmode);
+	if (busuid != 0)
+		seq_printf(seq, ",busuid=%u", busuid);
+	if (busgid != 0)
+		seq_printf(seq, ",busgid=%u", busgid);
+	if (busmode != USBFS_DEFAULT_BUSMODE)
+		seq_printf(seq, ",busmode=%o", busmode);
+	if (listuid != 0)
+		seq_printf(seq, ",listuid=%u", listuid);
+	if (listgid != 0)
+		seq_printf(seq, ",listgid=%u", listgid);
+	if (listmode != USBFS_DEFAULT_LISTMODE)
+		seq_printf(seq, ",listmode=%o", listmode);
+
+	return 0;
+}
+
+enum {
+	Opt_devuid, Opt_devgid, Opt_devmode,
+	Opt_busuid, Opt_busgid, Opt_busmode,
+	Opt_listuid, Opt_listgid, Opt_listmode,
+	Opt_err,
+};
+
+static const match_table_t tokens = {
+	{Opt_devuid, "devuid=%u"},
+	{Opt_devgid, "devgid=%u"},
+	{Opt_devmode, "devmode=%o"},
+	{Opt_busuid, "busuid=%u"},
+	{Opt_busgid, "busgid=%u"},
+	{Opt_busmode, "busmode=%o"},
+	{Opt_listuid, "listuid=%u"},
+	{Opt_listgid, "listgid=%u"},
+	{Opt_listmode, "listmode=%o"},
+	{Opt_err, NULL}
+};
+
+static int parse_options(struct super_block *s, char *data)
+{
+	char *p;
+	int option;
+
+	/* (re)set to defaults. */
+	devuid = 0;
+	busuid = 0;
+	listuid = 0;
+	devgid = 0;
+	busgid = 0;
+	listgid = 0;
+	devmode = USBFS_DEFAULT_DEVMODE;
+	busmode = USBFS_DEFAULT_BUSMODE;
+	listmode = USBFS_DEFAULT_LISTMODE;
+
+	while ((p = strsep(&data, ",")) != NULL) {
+		substring_t args[MAX_OPT_ARGS];
+		int token;
+		if (!*p)
+			continue;
+
+		token = match_token(p, tokens, args);
+		switch (token) {
+		case Opt_devuid:
+			if (match_int(&args[0], &option))
+			       return -EINVAL;
+			devuid = option;
+			break;
+		case Opt_devgid:
+			if (match_int(&args[0], &option))
+			       return -EINVAL;
+			devgid = option;
+			break;
+		case Opt_devmode:
+			if (match_octal(&args[0], &option))
+				return -EINVAL;
+			devmode = option & S_IRWXUGO;
+			break;
+		case Opt_busuid:
+			if (match_int(&args[0], &option))
+			       return -EINVAL;
+			busuid = option;
+			break;
+		case Opt_busgid:
+			if (match_int(&args[0], &option))
+			       return -EINVAL;
+			busgid = option;
+			break;
+		case Opt_busmode:
+			if (match_octal(&args[0], &option))
+				return -EINVAL;
+			busmode = option & S_IRWXUGO;
+			break;
+		case Opt_listuid:
+			if (match_int(&args[0], &option))
+			       return -EINVAL;
+			listuid = option;
+			break;
+		case Opt_listgid:
+			if (match_int(&args[0], &option))
+			       return -EINVAL;
+			listgid = option;
+			break;
+		case Opt_listmode:
+			if (match_octal(&args[0], &option))
+				return -EINVAL;
+			listmode = option & S_IRWXUGO;
+			break;
+		default:
+			printk(KERN_ERR "usbfs: unrecognised mount option "
+			       "\"%s\" or missing value\n", p);
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+static void update_special(struct dentry *special)
+{
+	special->d_inode->i_uid = listuid;
+	special->d_inode->i_gid = listgid;
+	special->d_inode->i_mode = S_IFREG | listmode;
+}
+
+static void update_dev(struct dentry *dev)
+{
+	dev->d_inode->i_uid = devuid;
+	dev->d_inode->i_gid = devgid;
+	dev->d_inode->i_mode = S_IFREG | devmode;
+}
+
+static void update_bus(struct dentry *bus)
+{
+	struct dentry *dev = NULL;
+
+	bus->d_inode->i_uid = busuid;
+	bus->d_inode->i_gid = busgid;
+	bus->d_inode->i_mode = S_IFDIR | busmode;
+
+	mutex_lock(&bus->d_inode->i_mutex);
+
+	list_for_each_entry(dev, &bus->d_subdirs, d_u.d_child)
+		if (dev->d_inode)
+			update_dev(dev);
+
+	mutex_unlock(&bus->d_inode->i_mutex);
+}
+
+static void update_sb(struct super_block *sb)
+{
+	struct dentry *root = sb->s_root;
+	struct dentry *bus = NULL;
+
+	if (!root)
+		return;
+
+	mutex_lock_nested(&root->d_inode->i_mutex, I_MUTEX_PARENT);
+
+	list_for_each_entry(bus, &root->d_subdirs, d_u.d_child) {
+		if (bus->d_inode) {
+			switch (S_IFMT & bus->d_inode->i_mode) {
+			case S_IFDIR:
+				update_bus(bus);
+				break;
+			case S_IFREG:
+				update_special(bus);
+				break;
+			default:
+				printk(KERN_WARNING "usbfs: Unknown node %s "
+				       "mode %x found on remount!\n",
+				       bus->d_name.name, bus->d_inode->i_mode);
+				break;
+			}
+		}
+	}
+
+	mutex_unlock(&root->d_inode->i_mutex);
+}
+
+static int remount(struct super_block *sb, int *flags, char *data)
+{
+	/* If this is not a real mount,
+	 * i.e. it's a simple_pin_fs from create_special_files,
+	 * then ignore it.
+	 */
+	if (*flags & MS_KERNMOUNT)
+		return 0;
+
+	if (parse_options(sb, data)) {
+		printk(KERN_WARNING "usbfs: mount parameter error.\n");
+		return -EINVAL;
+	}
+
+	if (usbfs_mount)
+		update_sb(usbfs_mount->mnt_sb);
+
+	return 0;
+}
+
+static struct inode *usbfs_get_inode (struct super_block *sb, umode_t mode, dev_t dev)
+{
+	struct inode *inode = new_inode(sb);
+
+	if (inode) {
+		inode->i_ino = get_next_ino();
+		inode_init_owner(inode, NULL, mode);
+		inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
+		switch (mode & S_IFMT) {
+		default:
+			init_special_inode(inode, mode, dev);
+			break;
+		case S_IFREG:
+			inode->i_fop = &default_file_operations;
+			break;
+		case S_IFDIR:
+			inode->i_op = &simple_dir_inode_operations;
+			inode->i_fop = &simple_dir_operations;
+
+			/* directory inodes start off with i_nlink == 2 (for "." entry) */
+			inc_nlink(inode);
+			break;
+		}
+	}
+	return inode; 
+}
+
+/* SMP-safe */
+static int usbfs_mknod (struct inode *dir, struct dentry *dentry, umode_t mode,
+			dev_t dev)
+{
+	struct inode *inode = usbfs_get_inode(dir->i_sb, mode, dev);
+	int error = -EPERM;
+
+	if (dentry->d_inode)
+		return -EEXIST;
+
+	if (inode) {
+		d_instantiate(dentry, inode);
+		dget(dentry);
+		error = 0;
+	}
+	return error;
+}
+
+static int usbfs_mkdir (struct inode *dir, struct dentry *dentry, umode_t mode)
+{
+	int res;
+
+	mode = (mode & (S_IRWXUGO | S_ISVTX)) | S_IFDIR;
+	res = usbfs_mknod (dir, dentry, mode, 0);
+	if (!res)
+		inc_nlink(dir);
+	return res;
+}
+
+static int usbfs_create (struct inode *dir, struct dentry *dentry, umode_t mode)
+{
+	mode = (mode & S_IALLUGO) | S_IFREG;
+	return usbfs_mknod (dir, dentry, mode, 0);
+}
+
+static inline int usbfs_positive (struct dentry *dentry)
+{
+	return dentry->d_inode && !d_unhashed(dentry);
+}
+
+static int usbfs_empty (struct dentry *dentry)
+{
+	struct list_head *list;
+
+	spin_lock(&dentry->d_lock);
+	list_for_each(list, &dentry->d_subdirs) {
+		struct dentry *de = list_entry(list, struct dentry, d_u.d_child);
+
+		spin_lock_nested(&de->d_lock, DENTRY_D_LOCK_NESTED);
+		if (usbfs_positive(de)) {
+			spin_unlock(&de->d_lock);
+			spin_unlock(&dentry->d_lock);
+			return 0;
+		}
+		spin_unlock(&de->d_lock);
+	}
+	spin_unlock(&dentry->d_lock);
+	return 1;
+}
+
+static int usbfs_unlink (struct inode *dir, struct dentry *dentry)
+{
+	struct inode *inode = dentry->d_inode;
+	mutex_lock(&inode->i_mutex);
+	drop_nlink(dentry->d_inode);
+	dput(dentry);
+	mutex_unlock(&inode->i_mutex);
+	d_delete(dentry);
+	return 0;
+}
+
+static int usbfs_rmdir(struct inode *dir, struct dentry *dentry)
+{
+	int error = -ENOTEMPTY;
+	struct inode * inode = dentry->d_inode;
+
+	mutex_lock(&inode->i_mutex);
+	dentry_unhash(dentry);
+	if (usbfs_empty(dentry)) {
+		dont_mount(dentry);
+		drop_nlink(dentry->d_inode);
+		drop_nlink(dentry->d_inode);
+		dput(dentry);
+		inode->i_flags |= S_DEAD;
+		drop_nlink(dir);
+		error = 0;
+	}
+	mutex_unlock(&inode->i_mutex);
+	if (!error)
+		d_delete(dentry);
+	return error;
+}
+
+
+/* default file operations */
+static ssize_t default_read_file (struct file *file, char __user *buf,
+				  size_t count, loff_t *ppos)
+{
+	return 0;
+}
+
+static ssize_t default_write_file (struct file *file, const char __user *buf,
+				   size_t count, loff_t *ppos)
+{
+	return count;
+}
+
+static loff_t default_file_lseek (struct file *file, loff_t offset, int orig)
+{
+	loff_t retval = -EINVAL;
+
+	mutex_lock(&file->f_path.dentry->d_inode->i_mutex);
+	switch(orig) {
+	case 0:
+		if (offset > 0) {
+			file->f_pos = offset;
+			retval = file->f_pos;
+		} 
+		break;
+	case 1:
+		if ((offset + file->f_pos) > 0) {
+			file->f_pos += offset;
+			retval = file->f_pos;
+		} 
+		break;
+	default:
+		break;
+	}
+	mutex_unlock(&file->f_path.dentry->d_inode->i_mutex);
+	return retval;
+}
+
+static const struct file_operations default_file_operations = {
+	.read =		default_read_file,
+	.write =	default_write_file,
+	.open =		simple_open,
+	.llseek =	default_file_lseek,
+};
+
+static const struct super_operations usbfs_ops = {
+	.statfs =	simple_statfs,
+	.drop_inode =	generic_delete_inode,
+	.remount_fs =	remount,
+	.show_options = usbfs_show_options,
+};
+
+static int usbfs_fill_super(struct super_block *sb, void *data, int silent)
+{
+	struct inode *inode;
+
+	sb->s_blocksize = PAGE_CACHE_SIZE;
+	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
+	sb->s_magic = USBDEVICE_SUPER_MAGIC;
+	sb->s_op = &usbfs_ops;
+	sb->s_time_gran = 1;
+	inode = usbfs_get_inode(sb, S_IFDIR | 0755, 0);
+	sb->s_root = d_make_root(inode);
+	if (!sb->s_root) {
+	//	printk(KERN_INFO "%s: could not get root dentry!",__func__);
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+/*
+ * fs_create_by_name - create a file, given a name
+ * @name:	name of file
+ * @mode:	type of file
+ * @parent:	dentry of directory to create it in
+ * @dentry:	resulting dentry of file
+ *
+ * This function handles both regular files and directories.
+ */
+static int fs_create_by_name (const char *name, umode_t mode,
+			      struct dentry *parent, struct dentry **dentry)
+{
+	int error = 0;
+
+	/* If the parent is not specified, we create it in the root.
+	 * We need the root dentry to do this, which is in the super 
+	 * block. A pointer to that is in the struct vfsmount that we
+	 * have around.
+	 */
+	if (!parent ) {
+		if (usbfs_mount)
+			parent = usbfs_mount->mnt_root;
+	}
+
+	if (!parent) {
+		//dbg("Ah! can not find a parent!");
+		return -EFAULT;
+	}
+
+	*dentry = NULL;
+	mutex_lock(&parent->d_inode->i_mutex);
+	*dentry = lookup_one_len(name, parent, strlen(name));
+	if (!IS_ERR(*dentry)) {
+		if (S_ISDIR(mode))
+			error = usbfs_mkdir (parent->d_inode, *dentry, mode);
+		else 
+			error = usbfs_create (parent->d_inode, *dentry, mode);
+	} else
+		error = PTR_ERR(*dentry);
+	mutex_unlock(&parent->d_inode->i_mutex);
+
+	return error;
+}
+
+static struct dentry *fs_create_file (const char *name, umode_t mode,
+				      struct dentry *parent, void *data,
+				      const struct file_operations *fops,
+				      uid_t uid, gid_t gid)
+{
+	struct dentry *dentry;
+	int error;
+
+//	dbg("creating file '%s'",name);
+
+	error = fs_create_by_name (name, mode, parent, &dentry);
+	if (error) {
+		dentry = NULL;
+	} else {
+		if (dentry->d_inode) {
+			if (data)
+				dentry->d_inode->i_private = data;
+			if (fops)
+				dentry->d_inode->i_fop = fops;
+			dentry->d_inode->i_uid = uid;
+			dentry->d_inode->i_gid = gid;
+		}
+	}
+
+	return dentry;
+}
+
+static void fs_remove_file (struct dentry *dentry)
+{
+	struct dentry *parent = dentry->d_parent;
+	
+	if (!parent || !parent->d_inode)
+		return;
+
+	mutex_lock_nested(&parent->d_inode->i_mutex, I_MUTEX_PARENT);
+	if (usbfs_positive(dentry)) {
+		if (dentry->d_inode) {
+			if (S_ISDIR(dentry->d_inode->i_mode))
+				usbfs_rmdir(parent->d_inode, dentry);
+			else
+				usbfs_unlink(parent->d_inode, dentry);
+		dput(dentry);
+		}
+	}
+	mutex_unlock(&parent->d_inode->i_mutex);
+}
+
+/* --------------------------------------------------------------------- */
+
+static struct dentry *usb_mount(struct file_system_type *fs_type,
+	int flags, const char *dev_name, void *data)
+{
+	return mount_single(fs_type, flags, data, usbfs_fill_super);
+}
+
+static struct file_system_type usb_fs_type = {
+	.owner =	THIS_MODULE,
+	.name =		"usbfs",
+	.mount =	usb_mount,
+	.kill_sb =	kill_litter_super,
+};
+
+/* --------------------------------------------------------------------- */
+
+static int create_special_files (void)
+{
+	struct dentry *parent;
+	int retval;
+
+	/* create the devices special file */
+	retval = simple_pin_fs(&usb_fs_type, &usbfs_mount, &usbfs_mount_count);
+	if (retval) {
+		printk(KERN_ERR "Unable to get usbfs mount\n");
+		goto exit;
+	}
+
+	parent = usbfs_mount->mnt_root;
+	devices_usbfs_dentry = fs_create_file ("devices",
+					       listmode | S_IFREG, parent,
+					       NULL, &usbfs_devices_fops,
+					       listuid, listgid);
+	if (devices_usbfs_dentry == NULL) {
+		printk(KERN_ERR "Unable to create devices usbfs file\n");
+		retval = -ENODEV;
+		goto error_clean_mounts;
+	}
+
+	goto exit;
+	
+error_clean_mounts:
+	simple_release_fs(&usbfs_mount, &usbfs_mount_count);
+exit:
+	return retval;
+}
+
+static void remove_special_files (void)
+{
+	if (devices_usbfs_dentry)
+		fs_remove_file (devices_usbfs_dentry);
+	devices_usbfs_dentry = NULL;
+	simple_release_fs(&usbfs_mount, &usbfs_mount_count);
+}
+
+void usbfs_update_special (void)
+{
+	struct inode *inode;
+
+	if (devices_usbfs_dentry) {
+		inode = devices_usbfs_dentry->d_inode;
+		if (inode)
+			inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
+	}
+}
+
+static void usbfs_add_bus(struct usb_bus *bus)
+{
+	struct dentry *parent;
+	char name[8];
+	int retval;
+
+	/* create the special files if this is the first bus added */
+	if (num_buses == 0) {
+		retval = create_special_files();
+		if (retval)
+			return;
+	}
+	++num_buses;
+
+	sprintf (name, "%03d", bus->busnum);
+
+	parent = usbfs_mount->mnt_root;
+	bus->usbfs_dentry = fs_create_file (name, busmode | S_IFDIR, parent,
+					    bus, NULL, busuid, busgid);
+	if (bus->usbfs_dentry == NULL) {
+		printk(KERN_ERR "Error creating usbfs bus entry\n");
+		return;
+	}
+}
+
+static void usbfs_remove_bus(struct usb_bus *bus)
+{
+	if (bus->usbfs_dentry) {
+		fs_remove_file (bus->usbfs_dentry);
+		bus->usbfs_dentry = NULL;
+	}
+
+	--num_buses;
+	if (num_buses <= 0) {
+		remove_special_files();
+		num_buses = 0;
+	}
+}
+
+static void usbfs_add_device(struct usb_device *dev)
+{
+	char name[8];
+	int i;
+	int i_size;
+
+	sprintf (name, "%03d", dev->devnum);
+	dev->usbfs_dentry = fs_create_file (name, devmode | S_IFREG,
+					    dev->bus->usbfs_dentry, dev,
+					    &usbdev_file_operations,
+					    devuid, devgid);
+	if (dev->usbfs_dentry == NULL) {
+		printk(KERN_ERR "Error creating usbfs device entry\n");
+		return;
+	}
+
+	/* Set the size of the device's file to be
+	 * equal to the size of the device descriptors. */
+	i_size = sizeof (struct usb_device_descriptor);
+	for (i = 0; i < dev->descriptor.bNumConfigurations; ++i) {
+		struct usb_config_descriptor *config =
+			(struct usb_config_descriptor *)dev->rawdescriptors[i];
+		i_size += le16_to_cpu(config->wTotalLength);
+	}
+	if (dev->usbfs_dentry->d_inode)
+		dev->usbfs_dentry->d_inode->i_size = i_size;
+}
+
+static void usbfs_remove_device(struct usb_device *dev)
+{
+	if (dev->usbfs_dentry) {
+		fs_remove_file (dev->usbfs_dentry);
+		dev->usbfs_dentry = NULL;
+	}
+}
+
+static int usbfs_notify(struct notifier_block *self, unsigned long action, void *dev)
+{
+	switch (action) {
+	case USB_DEVICE_ADD:
+		usbfs_add_device(dev);
+		break;
+	case USB_DEVICE_REMOVE:
+		usbfs_remove_device(dev);
+		break;
+	case USB_BUS_ADD:
+		usbfs_add_bus(dev);
+		break;
+	case USB_BUS_REMOVE:
+		usbfs_remove_bus(dev);
+	}
+
+	usbfs_update_special();
+	usbfs_conn_disc_event();
+	return NOTIFY_OK;
+}
+
+static struct notifier_block usbfs_nb = {
+	.notifier_call = 	usbfs_notify,
+};
+
+/* --------------------------------------------------------------------- */
+
+static struct proc_dir_entry *usbdir = NULL;
+
+int __init usbfs_init(void)
+{
+	int retval;
+
+	retval = register_filesystem(&usb_fs_type);
+	if (retval)
+		return retval;
+
+	usb_register_notify(&usbfs_nb);
+
+	/* create mount point for usbfs */
+	usbdir = proc_mkdir("bus/usb", NULL);
+
+	return 0;
+}
+
+void usbfs_cleanup(void)
+{
+	usb_unregister_notify(&usbfs_nb);
+	unregister_filesystem(&usb_fs_type);
+	if (usbdir)
+		remove_proc_entry("bus/usb", NULL);
+}
diff -Naur linux-3.9.2.ref/drivers/usb/core/Kconfig linux-3.9.2/drivers/usb/core/Kconfig
--- linux-3.9.2.ref/drivers/usb/core/Kconfig	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/drivers/usb/core/Kconfig	2013-07-23 19:31:17.000000000 +0200
@@ -27,6 +27,58 @@
 comment "Miscellaneous USB options"
 	depends on USB
 
+config USB_DEVICEFS
+	bool "USB device filesystem (DEPRECATED)"
+	depends on USB
+	---help---
+	  If you say Y here (and to "/proc file system support" in the "File
+	  systems" section, above), you will get a file /proc/bus/usb/devices
+	  which lists the devices currently connected to your USB bus or
+	  busses, and for every connected device a file named
+	  "/proc/bus/usb/xxx/yyy", where xxx is the bus number and yyy the
+	  device number; the latter files can be used by user space programs
+	  to talk directly to the device. These files are "virtual", meaning
+	  they are generated on the fly and not stored on the hard drive.
+
+	  You may need to mount the usbfs file system to see the files, use
+	  mount -t usbfs none /proc/bus/usb
+
+	  For the format of the various /proc/bus/usb/ files, please read
+	  <file:Documentation/usb/proc_usb_info.txt>.
+
+	  Modern Linux systems do not use this.
+
+	  Usbfs entries are files and not character devices; usbfs can't
+	  handle Access Control Lists (ACL) which are the default way to
+	  grant access to USB devices for untrusted users of a desktop
+	  system.
+
+	  The usbfs functionality is replaced by real device-nodes managed by
+	  udev.  These nodes lived in /dev/bus/usb and are used by libusb.
+
+config USB_DEVICE_CLASS
+	bool "USB device class-devices (DEPRECATED)"
+	depends on USB
+	default y
+	---help---
+	  Userspace access to USB devices is granted by device-nodes exported
+	  directly from the usbdev in sysfs. Old versions of the driver
+	  core and udev needed additional class devices to export device nodes.
+
+	  These additional devices are difficult to handle in userspace, if
+	  information about USB interfaces must be available. One device
+	  contains the device node, the other device contains the interface
+	  data. Both devices are at the same level in sysfs (siblings) and one
+	  can't access the other. The device node created directly by the
+	  usb device is the parent device of the interface and therefore
+	  easily accessible from the interface event.
+
+	  This option provides backward compatibility for libusb device
+	  nodes (lsusb) when usbfs is not used, and the following udev rule
+	  doesn't exist:
+	    SUBSYSTEM=="usb", ACTION=="add", ENV{DEVTYPE}=="usb_device", \
+	    NAME="bus/usb/$env{BUSNUM}/$env{DEVNUM}", MODE="0644"
+
 config USB_DYNAMIC_MINORS
 	bool "Dynamic USB minor allocation"
 	depends on USB
diff -Naur linux-3.9.2.ref/drivers/usb/core/Makefile linux-3.9.2/drivers/usb/core/Makefile
--- linux-3.9.2.ref/drivers/usb/core/Makefile	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/drivers/usb/core/Makefile	2013-07-23 19:31:17.000000000 +0200
@@ -11,5 +11,10 @@
 
 usbcore-$(CONFIG_PCI)		+= hcd-pci.o
 usbcore-$(CONFIG_ACPI)		+= usb-acpi.o
+usbcore-$(CONFIG_USB_DEVICEFS)	+= inode.o
+
+ifeq ($(CONFIG_TANGOX),y)
+        usbcore-y    += tangox-usb.o
+endif
 
 obj-$(CONFIG_USB)		+= usbcore.o
diff -Naur linux-3.9.2.ref/drivers/usb/core/message.c linux-3.9.2/drivers/usb/core/message.c
--- linux-3.9.2.ref/drivers/usb/core/message.c	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/drivers/usb/core/message.c	2013-07-23 19:31:17.000000000 +0200
@@ -152,7 +152,7 @@
 
 	return ret;
 }
-EXPORT_SYMBOL_GPL(usb_control_msg);
+EXPORT_SYMBOL(usb_control_msg);
 
 /**
  * usb_interrupt_msg - Builds an interrupt urb, sends it off and waits for completion
diff -Naur linux-3.9.2.ref/drivers/usb/core/tangox-usb.c linux-3.9.2/drivers/usb/core/tangox-usb.c
--- linux-3.9.2.ref/drivers/usb/core/tangox-usb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/drivers/usb/core/tangox-usb.c	2013-07-23 19:31:17.000000000 +0200
@@ -0,0 +1,288 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2008
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/usb.h>
+#include <linux/export.h>
+
+#include "tangox-usb.h"
+
+#define DEBUG
+
+#ifdef DEBUG
+#define DBG(x...) printk(x)
+#else
+#define DBG(x...)
+#endif
+
+unsigned long tangox_otg_bits = 0;
+EXPORT_SYMBOL(tangox_otg_bits);
+
+static atomic_t usb_ref_cnt[2] = {ATOMIC_INIT(0), ATOMIC_INIT(0)};
+
+void tangox_phy_power_down(int ctrl)
+{
+	unsigned long chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+	unsigned long temp;
+
+	if ((chip_id == 0x8672) || (chip_id == 0x8674) || 
+		((chip_id & 0xfff0) == 0x8680)) {
+		/* put phy into suspend mode */
+		temp = gbus_read_reg32(tangox_ctrl_base[ctrl] + 0x0);				
+		gbus_write_reg32(tangox_ctrl_base[ctrl] + 0x0, temp | (1<<7));
+	
+		udelay(10);
+
+		/* put phy into sleep mode */
+		temp = gbus_read_reg32(tangox_ctrl_base[ctrl] + 0x0);				
+		gbus_write_reg32(tangox_ctrl_base[ctrl] + 0x0, temp | (1<<29));
+		temp = gbus_read_reg32(tangox_ctrl_base[ctrl] + 0xc);				
+		gbus_write_reg32(tangox_ctrl_base[ctrl] + 0xc, temp & ~(1<<29));
+	
+		/* powers down the analog blocks of the usb PHY */
+		temp = gbus_read_reg32(tangox_ctrl_base[ctrl] + 0x10);				
+		gbus_write_reg32(tangox_ctrl_base[ctrl] + 0x10, temp | (1<<7));
+	}
+	return;
+}
+EXPORT_SYMBOL(tangox_phy_power_down);
+
+void tangox_phy_power_up(int ctrl)
+{
+	unsigned long chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+	unsigned long temp;
+
+	if ((chip_id == 0x8672) || (chip_id == 0x8674) ||
+		((chip_id & 0xfff0) == 0x8680)) {
+		/* Powers up the analog blocks of the usb PHY */
+		temp = gbus_read_reg32(tangox_ctrl_base[ctrl] + 0x10);				
+		gbus_write_reg32(tangox_ctrl_base[ctrl] + 0x10, temp & ~(1<<7));
+	
+		/* put phy into active mode */
+		temp = gbus_read_reg32(tangox_ctrl_base[ctrl] + 0xc);				
+		gbus_write_reg32(tangox_ctrl_base[ctrl] + 0xc, temp | (1<<29));
+
+		udelay(10);
+
+		/*transitions the phy out of suspend mode */
+		temp = gbus_read_reg32(tangox_ctrl_base[ctrl] + 0x0);				
+		gbus_write_reg32(tangox_ctrl_base[ctrl] + 0x0, temp & ~(1<<7));
+	}
+	return;	
+}
+EXPORT_SYMBOL(tangox_phy_power_up);
+
+void tangox_usb_init(int ctrl)
+{
+	unsigned long chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+	int  i;
+	unsigned long temp;
+#ifdef CONFIG_TANGOX_XENV_READ
+	if (!tangox_usb_enabled())
+		return;
+#endif
+	if (atomic_add_return(1, &usb_ref_cnt[ctrl]) != 1) {
+		/* someone is either in the middle of init or have done init */
+        	while ((gbus_read_reg32(tangox_ctrl_base[ctrl] + 0x0) & (1<<19)) == 0)
+			schedule_timeout(HZ / 10);
+		printk("TangoX USB was initialized.\n");
+		return;
+	}
+
+	/* Unreset USB block if needed */
+	if ((chip_id != 0x8652) && (chip_id != 0x8646) && ((chip_id & 0xfff0) != 0x8670) && ((chip_id & 0xfff0) != 0x8680)) {
+		/* reset phy software reset */
+		temp = gbus_read_reg32(tangox_ctrl_base[ctrl] + 0x0);				
+		gbus_write_reg32(tangox_ctrl_base[ctrl] + 0x0, temp & ~(1<<0));
+
+		/* delay at least 1 ms*/
+		mdelay(2);
+
+		/* reset host software reset bit, seems didnot documented*/
+		temp = gbus_read_reg32(tangox_ctrl_base[ctrl] + 0x0);				
+		gbus_write_reg32(tangox_ctrl_base[ctrl] + 0x0, temp & ~(1<<1));
+
+		/* put phy in power normal mode */
+		temp = gbus_read_reg32(tangox_ctrl_base[ctrl] + 0xc);				
+		gbus_write_reg32(tangox_ctrl_base[ctrl] + 0xc, temp & ~(1<<6));
+	}
+
+	/*check see if it's inited*/
+        temp = gbus_read_reg32(tangox_ctrl_base[ctrl] + 0x0);
+	if (temp & (1<<19)) {
+		printk("TangoX USB was initialized.\n");
+		return;
+	}
+	else
+		printk("TangoX USB initializing...\n");
+
+	tangox_phy_power_up(ctrl);
+
+	/*
+	1. Program the clean divider and clock multiplexer to provide 
+	   a 48 MHz reference to the USB block.
+	   This is done in bootloader.
+	*/
+
+	if ((chip_id == 0x8652) || (chip_id == 0x8646)) { 
+		/*0. set bit 1 of USB control register 0x21700*/ 
+		temp = gbus_read_reg32(tangox_ctrl_base[ctrl] + 0x0);
+	        gbus_write_reg32(tangox_ctrl_base[ctrl] + 0x0, temp | 0x2);
+       		wait_ms(5);
+		 
+		/* 1. Program the clean divider and clock multiplexors to provide 48MHz clock reference*/
+		/* this is to be done in zboot */
+
+		/* 2. Enable the USB PHY */
+       		temp = gbus_read_reg32(tangox_ctrl_base[ctrl] + 0x0);
+		gbus_write_reg32(tangox_ctrl_base[ctrl] + 0x0, temp & 0xffffff7e);
+		wait_ms(20);
+
+		/* 3. Enable the USB Host EHCI/OHCI */
+		temp = gbus_read_reg32(tangox_ctrl_base[ctrl] + 0x0);
+		gbus_write_reg32(tangox_ctrl_base[ctrl] + 0x0, temp & 0xfffffffd);
+		wait_ms(20);
+
+		/* 4. set it to host mode*/
+		temp = gbus_read_reg32(tangox_ehci_base[ctrl] + TANGOX_EHCI_REG_OFFSET +0xA8);
+		temp |= 3 ;
+		gbus_write_reg32(tangox_ehci_base[ctrl] + TANGOX_EHCI_REG_OFFSET +0xA8, temp);
+		wait_ms(20);
+	} else if (((chip_id & 0xfff0) == 0x8670) || ((chip_id & 0xfff0) == 0x8680)) {
+		/* 0. Program the clean divider and clock multiplexors to provide 48MHz clock reference*/
+		/* this is to be done in zboot */
+
+		/*1. program the phy analog ctrl reg*/ 
+		gbus_write_reg32(tangox_ctrl_base[ctrl] + 0x2c, 0x0020DB91);
+		//gbus_write_reg32(tangox_ctrl_base[ctrl] + 0x2c, 0x003CDB91);
+		wait_ms(5);
+
+		/*2. program the phy clock reference frequency*/ 
+		gbus_write_reg32(tangox_ctrl_base[ctrl] + 0xc, 0x000f9930);
+		wait_ms(5);
+		 
+		/* 3. Releasing USB PHY */
+		gbus_write_reg32(tangox_ctrl_base[ctrl] + 0x0, 0x00000002);
+		wait_ms(5);
+
+		/* 4. Releasing the Host Controller */
+		//PHY force unreset
+		gbus_write_reg32(tangox_ctrl_base[ctrl] + 0x0, 0x10000002);
+		wait_ms(5);
+		gbus_write_reg32(tangox_ctrl_base[ctrl] + 0x0, 0x10000000);
+		wait_ms(5);
+		gbus_write_reg32(tangox_ctrl_base[ctrl] + 0x0, 0x00000000);
+		wait_ms(5);
+
+		/*5. Applying a 2nd HOST reset, after the NanoPHY 60MHz clock has become action */
+		wait_ms(5);
+		gbus_write_reg32(tangox_ctrl_base[ctrl] + 0x0, 0x10000002);
+		wait_ms(5);
+		gbus_write_reg32(tangox_ctrl_base[ctrl] + 0x0, 0x10000000);
+		wait_ms(5);
+		//Remove the PHY force unreset 
+		gbus_write_reg32(tangox_ctrl_base[ctrl] + 0x0, 0x00000000);
+		wait_ms(5);
+#if 0 
+		for(i = 0; i < 5; i++) {
+			temp = gbus_read_reg32(tangox_ctrl_base[ctrl] + i*4);
+			printk("TangoX USB register base= 0x%x %d = 0x%x\n",tangox_ctrl_base[ctrl], i, (u32)temp);
+		}
+#endif
+		/* 6. set it to host mode*/
+		temp = gbus_read_reg32(tangox_ehci_base[ctrl] + TANGOX_EHCI_REG_OFFSET +0xA8);
+		temp |= 3 ;
+		gbus_write_reg32(tangox_ehci_base[ctrl] + TANGOX_EHCI_REG_OFFSET +0xA8, temp);
+		wait_ms(20);
+	} else {
+#if 0		/* If you want to use external crystal at 24MHZ*/
+		printk("TangoX USB using 24MHz external crystal.\n");
+		gbus_write_reg32(REG_BASE_system_block + SYS_hostclk_mux, 0x300);
+		gbus_write_reg32(tangox_ctrl_base[ctrl] + 0x0, 0x70);
+		wait_ms(5);
+		gbus_write_reg32(tangox_ctrl_base[ctrl] + 0xc, 0xf9931);
+		wait_ms(30);
+#endif
+		/*2. PHY software reset*/
+		DBG("Performing PHY Reseting...\n");
+		temp = gbus_read_reg32(tangox_ctrl_base[ctrl] + 0x0);
+		gbus_write_reg32(tangox_ctrl_base[ctrl] + 0x0, temp | 0x01);
+		udelay (30);
+		gbus_write_reg32(tangox_ctrl_base[ctrl] + 0x0, temp);
+		wait_ms(5);
+
+		/*3. Reset Bit 1 of USB register 0x21700 to enable the USB Host controller.
+			This is done in bootloader */
+
+		/*4. OHCI Software reset*/
+		DBG("Performing USB OHCI Reseting...\n");
+		temp = gbus_read_reg32(tangox_ohci_base[ctrl] + 0x08);
+		gbus_write_reg32(tangox_ohci_base[ctrl] + 0x08,  temp | 0x01);
+		wait_ms(5);
+
+		/*5. OHCI DPLL Software reset, it says the bit is for simulation*/
+		DBG("Performing USB OHCI DPLL Reseting...\n");
+		temp = gbus_read_reg32(tangox_ctrl_base[ctrl] + 0x0);
+		gbus_write_reg32(tangox_ctrl_base[ctrl] + 0x0, temp | (1<<19));
+		wait_ms(5);
+	
+		/*6. EHCI Host Software Reset*/
+		DBG("Performing USB EHCI Reseting...\n");
+		temp = gbus_read_reg32(tangox_ehci_base[ctrl] + 0x10);
+		gbus_write_reg32(tangox_ehci_base[ctrl] + 0x10,  temp | 0x02);
+		wait_ms(5);
+
+		for(i = 0; i < 4; i++){
+			temp = gbus_read_reg32(tangox_ctrl_base[ctrl] + i*4);
+			printk("TangoX USB register base= 0x%x %d = 0x%x\n",tangox_ctrl_base[ctrl], i, (u32)temp);
+		}
+	}
+	for(i = 0; i < 4; i++){
+			temp = gbus_read_reg32(tangox_ctrl_base[ctrl] + i*4);
+			printk("TangoX USB register base= 0x%x %d = 0x%x\n",tangox_ctrl_base[ctrl], i, (u32)temp);
+	}
+    return;
+}
+
+EXPORT_SYMBOL(tangox_usb_init);
+
+void tangox_usb_deinit(int ctrl)
+{
+	unsigned long chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+	if (atomic_sub_return(1, &usb_ref_cnt[ctrl]) == 0) {
+		/* Reset USB block if needed */
+		if ((chip_id != 0x8652) && (chip_id != 0x8646) && ((chip_id & 0xfff0) != 0x8670) && ((chip_id & 0xfff0) != 0x8680)) { 
+			unsigned long temp;
+			/* put phy in power saving mode */
+			temp = gbus_read_reg32(tangox_ctrl_base[ctrl] + 0xc);				
+			gbus_write_reg32(tangox_ctrl_base[ctrl] + 0xc, temp | (1<<6));
+
+			/* set host software reset bit 1, seems didnot documented*/
+			temp = gbus_read_reg32(tangox_ctrl_base[ctrl] + 0x0);				
+			gbus_write_reg32(tangox_ctrl_base[ctrl] + 0x0, temp | (1<<1));
+
+			/* delay at least 1 ms*/
+			mdelay(2);
+
+			/* set phy software reset bit */
+			temp = gbus_read_reg32(tangox_ctrl_base[ctrl] + 0x0);				
+			gbus_write_reg32(tangox_ctrl_base[ctrl] + 0x0, temp | (1<<0));
+		}
+
+		tangox_phy_power_down(ctrl);
+	} 
+}
+EXPORT_SYMBOL(tangox_usb_deinit);
+
+
diff -Naur linux-3.9.2.ref/drivers/usb/core/tangox-usb.h linux-3.9.2/drivers/usb/core/tangox-usb.h
--- linux-3.9.2.ref/drivers/usb/core/tangox-usb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/drivers/usb/core/tangox-usb.h	2013-07-23 19:31:17.000000000 +0200
@@ -0,0 +1,100 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2008
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#ifndef __TANGOX_USB_H
+#define __TANGOX_USB_H
+ 
+#include <asm/addrspace.h>
+
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/hardware.h>
+#include <asm/tango2/tango2_gbus.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/hardware.h>
+#include <asm/tango3/tango3_gbus.h>
+#endif
+
+#define NON_CACHED(x)                   KSEG1ADDR((u32)(x))
+#define CACHED(x)                       KSEG0ADDR((u32)(x))
+
+#define TANGOX_EHCI0_BASE	(REG_BASE_host_interface + 0x1400)
+#define TANGOX_OHCI0_BASE	(REG_BASE_host_interface + 0x1500)
+#define TANGOX_CTRL0_BASE	(REG_BASE_host_interface + 0x1700)
+#define TANGOX_EHCI0_IRQ	(IRQ_CONTROLLER_IRQ_BASE + LOG2_CPU_USB_EHCI_INT)
+#define TANGOX_OHCI0_IRQ	(IRQ_CONTROLLER_IRQ_BASE + LOG2_CPU_USB_OHCI_INT)
+#define TANGOX_EHCI1_BASE	(REG_BASE_host_interface + 0x5400)
+#define TANGOX_OHCI1_BASE	(REG_BASE_host_interface + 0x5500)
+#define TANGOX_CTRL1_BASE	(REG_BASE_host_interface + 0x5700)
+#define TANGOX_EHCI1_IRQ	(IRQ_CONTROLLER_IRQ_BASE + LOG2_CPU_USB_EHCI_INT-1)
+#define TANGOX_OHCI1_IRQ	(IRQ_CONTROLLER_IRQ_BASE + LOG2_CPU_USB_OHCI_INT)
+
+/* For 8652/867X/868X OTG host or 8646 host */
+#define TANGOX_EHCI_REG_OFFSET		0x100
+#define TANGOX_USB_MODE				0x1A8
+
+/* tangox ehci */
+#define TANGOX_EHCI_BUS_NAME 		"tangox-ehci-bus"
+#define TANGOX_EHCI_PRODUCT_DESC 	"TangoX Integrated USB 2.0"
+#define EHCI_HCD_NAME		 		"tangox-ehci-hcd"
+/* tangox ohci */
+#define OHCI_HCD_NAME		 		"tangox-ohci-hcd"
+#define TANGOX_OHCI_BUS_NAME 		"tangox-ohci-bus"
+/* for 867x/868x has two controllers */
+static const int tangox_ehci_base[2] = {TANGOX_EHCI0_BASE, TANGOX_EHCI1_BASE};
+static const int tangox_ohci_base[2] = {TANGOX_OHCI0_BASE, TANGOX_OHCI1_BASE};
+static const int tangox_ctrl_base[2] = {TANGOX_CTRL0_BASE, TANGOX_CTRL1_BASE};
+static const int tangox_ehci_irq[2]  = {TANGOX_EHCI0_IRQ, TANGOX_EHCI1_IRQ};
+static const int tangox_ohci_irq[2]  = {TANGOX_OHCI0_IRQ, TANGOX_OHCI1_IRQ};
+#define TANGOX_EHCI_NAME0	"tangox-ehci-hcd-0"
+#define TANGOX_EHCI_NAME1	"tangox-ehci-hcd-1"
+//const char* tangox_ehci_name[2] = {TANGOX_EHCI_NAME0, TANGOX_EHCI_NAME1};
+
+static u32 __inline__ tangox_read_reg( u32 Reg )
+{
+#ifdef CONFIG_TANGOX
+        u32 data = gbus_read_reg32(Reg);
+#else
+        u32 data = __raw_readl(Reg);
+#endif
+
+//        printk("read data=0x%08x from addr=0x%08x\n", data, Reg);
+        return data;
+}
+
+static void __inline__ tangox_write_reg( u32 Reg, u32 Data )
+{
+//       printk("write data=0x%08x to addr=0x%08x\n", Data, Reg);
+#ifdef CONFIG_TANGOX
+        gbus_write_reg32(Reg, Data);
+#else
+        __raw_writel(Data,Reg);
+#endif
+}
+
+static __inline__ void wait_ms(unsigned int ms)
+{
+        if(!in_interrupt()) {
+                current->state = TASK_UNINTERRUPTIBLE;
+                schedule_timeout(1 + ms * HZ / 1000);
+        }
+        else
+                mdelay(ms);
+}
+#ifdef CONFIG_TANGOX_XENV_READ
+extern int tangox_usb_enabled(void);
+#endif
+extern unsigned long tangox_chip_id(void);
+extern int is_tango2_es89(void);
+extern int is_tango3_chip(void);
+extern void tangox_phy_power_up(int ctrl);
+extern void tangox_phy_power_down(int ctrl);
+extern void tangox_usb_init(int);
+extern void tangox_usb_deinit(int);
+#endif
diff -Naur linux-3.9.2.ref/drivers/usb/core/usb.c linux-3.9.2/drivers/usb/core/usb.c
--- linux-3.9.2.ref/drivers/usb/core/usb.c	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/drivers/usb/core/usb.c	2013-07-23 19:31:17.000000000 +0200
@@ -475,7 +475,7 @@
 		get_device(&dev->dev);
 	return dev;
 }
-EXPORT_SYMBOL_GPL(usb_get_dev);
+EXPORT_SYMBOL(usb_get_dev);
 
 /**
  * usb_put_dev - release a use of the usb device structure
@@ -589,6 +589,63 @@
 	return 0;
 }
 EXPORT_SYMBOL_GPL(usb_lock_device_for_reset);
+static struct usb_device *match_device(struct usb_device *dev,
+                                        u16 vendor_id, u16 product_id)
+{
+         struct usb_device *ret_dev = NULL;
+		 struct usb_device *childdev = NULL;
+         int child;
+	
+
+         /* see if this device matches */
+         if ((vendor_id == le16_to_cpu(dev->descriptor.idVendor)) &&
+             (product_id == le16_to_cpu(dev->descriptor.idProduct))) {              
+                 ret_dev = usb_get_dev(dev);
+                 goto exit;
+         }
+ 
+		 usb_hub_for_each_child(dev, child, childdev)
+		 {
+			if (childdev) {
+				usb_lock_device(childdev);
+                ret_dev = match_device(childdev, vendor_id, product_id);
+                usb_unlock_device(childdev);
+                if (ret_dev)
+                 	goto exit;
+
+			}
+
+		 }        
+exit:
+         return ret_dev;
+}
+
+
+struct usb_device *usb_find_device(u16 vendor_id, u16 product_id)
+{
+        struct list_head *buslist;
+        struct usb_bus *bus;
+        struct usb_device *dev = NULL;
+ 
+         mutex_lock(&usb_bus_list_lock);
+         for (buslist = usb_bus_list.next;
+              buslist != &usb_bus_list;
+              buslist = buslist->next) {
+                 bus = container_of(buslist, struct usb_bus, bus_list);
+                 if (!bus->root_hub)
+                         continue;
+                 usb_lock_device(bus->root_hub);
+                 dev = match_device(bus->root_hub, vendor_id, product_id);
+                 usb_unlock_device(bus->root_hub);
+                 if (dev)
+                         goto exit;
+         }
+exit:
+         mutex_unlock(&usb_bus_list_lock);
+         return dev;
+}
+EXPORT_SYMBOL(usb_find_device);
+
 
 /**
  * usb_get_current_frame_number - return current bus frame number
@@ -1023,6 +1080,9 @@
 	retval = usb_devio_init();
 	if (retval)
 		goto usb_devio_init_failed;
+	retval = usbfs_init();
+	if (retval)
+		goto fs_init_failed;
 	retval = usb_hub_init();
 	if (retval)
 		goto hub_init_failed;
@@ -1032,6 +1092,8 @@
 
 	usb_hub_cleanup();
 hub_init_failed:
+	usbfs_cleanup();
+fs_init_failed:
 	usb_devio_cleanup();
 usb_devio_init_failed:
 	usb_deregister(&usbfs_driver);
@@ -1059,6 +1121,7 @@
 
 	usb_deregister_device_driver(&usb_generic_driver);
 	usb_major_cleanup();
+	usbfs_cleanup();
 	usb_deregister(&usbfs_driver);
 	usb_devio_cleanup();
 	usb_hub_cleanup();
diff -Naur linux-3.9.2.ref/drivers/usb/host/ehci-hub.c linux-3.9.2/drivers/usb/host/ehci-hub.c
--- linux-3.9.2.ref/drivers/usb/host/ehci-hub.c	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/drivers/usb/host/ehci-hub.c	2013-07-23 19:31:17.000000000 +0200
@@ -1074,6 +1074,7 @@
 		 * about the EHCI-specific stuff.
 		 */
 		case USB_PORT_FEAT_TEST:
+#ifndef CONFIG_TANGOX		
 			if (!selector || selector > 5)
 				goto error;
 			spin_unlock_irqrestore(&ehci->lock, flags);
@@ -1098,6 +1099,7 @@
 			temp = ehci_readl(ehci, status_reg);
 			temp |= selector << 16;
 			ehci_writel(ehci, temp, status_reg);
+#endif			
 			break;
 
 		default:
diff -Naur linux-3.9.2.ref/drivers/usb/host/ehci-q.c linux-3.9.2/drivers/usb/host/ehci-q.c
--- linux-3.9.2.ref/drivers/usb/host/ehci-q.c	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/drivers/usb/host/ehci-q.c	2013-07-23 19:31:17.000000000 +0200
@@ -1396,4 +1396,5 @@
 		ehci_enable_event(ehci, EHCI_HRTIMER_ASYNC_UNLINKS, true);
 		++ehci->async_unlink_cycle;
 	}
+
 }
diff -Naur linux-3.9.2.ref/drivers/usb/host/ehci-tangox.c linux-3.9.2/drivers/usb/host/ehci-tangox.c
--- linux-3.9.2.ref/drivers/usb/host/ehci-tangox.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/drivers/usb/host/ehci-tangox.c	2013-07-23 19:31:17.000000000 +0200
@@ -0,0 +1,307 @@
+/*
+ * Modified for SMP86XX.
+ *
+ * Copyright (c) 2004-2008 Sigma Designs, Inc.
+ *
+ * EHCI HCD (Host Controller Driver) PCI Bus Glue.
+ *
+ * Copyright (c) 2000-2004 by David Brownell
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/platform_device.h>
+#ifndef CONFIG_TANGOX
+#error "This file is TANGOX EHCI bus glue.  CONFIG_TANGOX must be defined."
+#endif
+
+extern unsigned long tangox_otg_bits;
+static u64 ehci_dmamask = ~(u32)0;
+
+/* called during probe() after chip reset completes */
+static int ehci_tangox_setup(struct usb_hcd *hcd)
+{
+        struct ehci_hcd         *ehci = hcd_to_ehci(hcd);
+        u32                     temp;
+        int                     retval;
+
+        ehci->caps = hcd->regs;
+        ehci->regs = hcd->regs + HC_LENGTH(ehci, readl(&ehci->caps->hc_capbase));
+        dbg_hcs_params(ehci, "reset");
+        dbg_hcc_params(ehci, "reset");
+
+        /* cache this readonly data; minimize chip reads */
+        ehci->hcs_params = readl(&ehci->caps->hcs_params);
+
+        retval = ehci_halt(ehci);
+        if (retval)
+                return retval;
+
+        /* data structure init */
+        retval = ehci_init(hcd);
+        if (retval)
+                return retval;
+
+        ehci_reset(ehci);
+
+        /* at least the Genesys GL880S needs fixup here */
+        temp = HCS_N_CC(ehci->hcs_params) * HCS_N_PCC(ehci->hcs_params);
+        temp &= 0x0f;
+        if (temp && (HCS_N_PORTS(ehci->hcs_params) > temp)) {
+                ehci_dbg(ehci, "bogus port configuration: "
+                        "cc=%d x pcc=%d < ports=%d\n",
+                        HCS_N_CC(ehci->hcs_params),
+                        HCS_N_PCC(ehci->hcs_params),
+                        HCS_N_PORTS(ehci->hcs_params));
+        }
+
+        return retval;
+}
+
+static const struct hc_driver ehci_tangox_hc_driver = {
+	.description =		EHCI_HCD_NAME,
+	.product_desc =		"SMP86xx EHCI Host Controller",
+	.hcd_priv_size =	sizeof(struct ehci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq =			ehci_irq,
+	.flags =		HCD_MEMORY | HCD_USB2,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.reset =		ehci_tangox_setup,
+	.start =		ehci_run,
+#ifdef	CONFIG_PM
+	.bus_suspend =	 ehci_bus_suspend,
+	.bus_resume =	 ehci_bus_resume,
+#endif
+	.stop =			ehci_stop,
+	.shutdown =		ehci_shutdown,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue =		ehci_urb_enqueue,
+	.urb_dequeue =		ehci_urb_dequeue,
+	.endpoint_disable =	ehci_endpoint_disable,
+	.endpoint_reset = ehci_endpoint_reset,
+	.clear_tt_buffer_complete = ehci_clear_tt_buffer_complete,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number =	ehci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data =	ehci_hub_status_data,
+	.hub_control =		ehci_hub_control,
+	.relinquish_port = ehci_relinquish_port,
+	.port_handed_over = ehci_port_handed_over,
+
+	
+
+};
+
+/*-------------------------------------------------------------------------*/
+
+static int tangox_hcd_probe (struct platform_device *pdev, int ctrl)
+{
+	unsigned long tangox_chip_id(void);
+	unsigned long chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+        struct usb_hcd          *hcd;
+        struct ehci_hcd         *ehci;
+        int                     retval;
+	
+		tangox_usb_init(ctrl);
+
+        if (usb_disabled())
+                return -ENODEV;
+
+        hcd = usb_create_hcd (&ehci_tangox_hc_driver, &pdev->dev, EHCI_HCD_NAME);
+        if (!hcd) {
+			printk("cannot create hcd\n");
+                retval = -ENOMEM;
+                goto err1;
+        }
+
+        ehci = hcd_to_ehci(hcd);
+
+		hcd->rsrc_start = NON_CACHED(tangox_ehci_base[ctrl]);
+		hcd->regs = (void *)NON_CACHED(tangox_ehci_base[ctrl]);
+
+		 
+	if ((chip_id == 0x8652) || ((chip_id & 0xfff0) == 0x8670) || ((chip_id & 0xfff0) == 0x8680)) {
+		if (ctrl == 0) {
+			if (test_and_set_bit(0, &tangox_otg_bits) != 0) {
+				printk("Controller %d is used in different mode.\n", ctrl);
+				return -EIO;
+			}
+		} else if (((chip_id & 0xfff0) == 0x8670) || ((chip_id & 0xfff0) == 0x8680)) {
+			if (test_and_set_bit(1, &tangox_otg_bits) != 0) {
+				printk("Controller %d is used in different mode.\n", ctrl);
+				return -EIO;
+			}
+		}
+		hcd->rsrc_start += TANGOX_EHCI_REG_OFFSET;
+		hcd->regs += TANGOX_EHCI_REG_OFFSET;
+		/* TT is available with this controller */
+		hcd->has_tt = 1;
+	} else if (chip_id == 0x8646) {
+		hcd->rsrc_start += TANGOX_EHCI_REG_OFFSET;
+		hcd->regs += TANGOX_EHCI_REG_OFFSET;
+		/* TT is available with this controller */
+		hcd->has_tt = 1;
+	}
+
+	if (((chip_id == 0x8672) || (chip_id == 0x8674)) && (ctrl == 1))
+		hcd->irq = IRQ_CONTROLLER_IRQ_BASE + LOG2_CPU_DVD_INT;
+	else
+		hcd->irq = tangox_ehci_irq[ctrl];
+        hcd->self.controller = &pdev->dev;
+        hcd->self.bus_name = EHCI_HCD_NAME;
+        hcd->product_desc ="TangoX USB 2.0";
+
+        retval = usb_add_hcd(hcd, hcd->irq, 0);
+        if (retval != 0)
+                goto err2;
+        return retval;
+err2:
+        usb_put_hcd (hcd);
+err1:
+	//        dev_err (&pdev->dev, "init %s fail, %d \n", tangox_ehci_name[ctrl], retval);
+		dev_err (&pdev->dev, "init %s fail, %d \n", TANGOX_EHCI_NAME0, retval);
+        return retval;
+}
+
+static int tangox_hcd_remove (struct platform_device *pdev, int ctrl)
+{
+	unsigned long tangox_chip_id(void);
+	unsigned long chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+	struct usb_hcd *hcd = dev_get_drvdata(&pdev->dev);
+	if (!hcd)
+		return -1;
+
+	usb_remove_hcd (hcd);
+	usb_put_hcd (hcd);
+	if ((chip_id == 0x8652) || ((chip_id & 0xfff0) == 0x8670) || ((chip_id & 0xfff0) == 0x8680)) {
+		if (ctrl == 0)
+			clear_bit(0, &tangox_otg_bits);
+		else if (((chip_id & 0xfff0) == 0x8670) || ((chip_id & 0xfff0) == 0x8680))
+			clear_bit(1, &tangox_otg_bits);
+	}
+        tangox_usb_deinit(ctrl);
+	return 0;
+}
+
+#ifdef	CONFIG_PM
+static int tangox_suspend(struct platform_device *dev, pm_message_t state )
+{
+        printk("TangoX EHCI suspend.\n");
+        return 0;
+}
+
+static int tangox_resume(struct platform_device *dev)
+{
+        printk("TangoX EHCI resume.\n");
+        return 0;
+}
+#endif
+int tangox_hcd_probe0 (struct platform_device *pdev)
+{
+	return tangox_hcd_probe (pdev, 0);
+}
+int tangox_hcd_probe1 (struct platform_device *pdev)
+{
+	return tangox_hcd_probe (pdev, 1);
+}
+int tangox_hcd_remove0(struct platform_device *pdev)
+{
+	return tangox_hcd_remove (pdev, 0);
+}
+int tangox_hcd_remove1(struct platform_device *pdev)
+{
+	return tangox_hcd_remove (pdev, 1);
+}
+
+static struct platform_driver ehci_tangox_driver[] = {
+	{
+        .probe   =      tangox_hcd_probe0,
+        .remove  =      tangox_hcd_remove0,
+		.shutdown = usb_hcd_platform_shutdown,
+		.driver = {
+			.name = (char *)TANGOX_EHCI_NAME0,
+			.bus = &platform_bus_type
+		},
+#ifdef CONFIG_PM 
+        .suspend =      tangox_suspend,
+        .resume  =      tangox_resume,
+#endif
+	},
+	{
+        .probe   =      tangox_hcd_probe1,
+        .remove  =      tangox_hcd_remove1,
+		.shutdown = usb_hcd_platform_shutdown,
+		.driver = {
+			.name = TANGOX_EHCI_NAME1,
+			.bus = &platform_bus_type
+		},
+#ifdef CONFIG_PM 
+        .suspend =      tangox_suspend,
+        .resume  =      tangox_resume,
+#endif
+	},
+};
+
+
+static void tangox_ehci_release_dev(struct device * dev)
+{
+        dev->parent = NULL;
+}
+
+
+static struct platform_device tangox_ehci_device[] = {
+	{
+        .name           = (char *)TANGOX_EHCI_NAME0,
+        .id             = -1,
+        .dev = {
+                .dma_mask               = &ehci_dmamask,
+                .coherent_dma_mask      = 0xffffffff,
+                .release                = tangox_ehci_release_dev,
+        },
+       .num_resources  = 0,
+       .resource       = 0,
+	},
+	{
+        .name           = (char *)TANGOX_EHCI_NAME1,
+        .id             = -1,
+        .dev = {
+                .dma_mask               = &ehci_dmamask,
+                .coherent_dma_mask      = 0xffffffff,
+                .release                = tangox_ehci_release_dev,
+        },
+       .num_resources  = 0,
+       .resource       = 0,
+	},
+};
+
+static struct platform_device *tangox_platform_devices[] __initdata = {
+        &tangox_ehci_device[0],
+        &tangox_ehci_device[1],
+};
diff -Naur linux-3.9.2.ref/drivers/usb/host/Kconfig linux-3.9.2/drivers/usb/host/Kconfig
--- linux-3.9.2.ref/drivers/usb/host/Kconfig	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/drivers/usb/host/Kconfig	2013-07-23 19:31:17.000000000 +0200
@@ -40,6 +40,26 @@
 	  This should only be used for debugging xHCI driver bugs.
 
 	  If unsure, say N.
+	  
+config TANGOX_EHCI_HCD
+        tristate "SMP86xx EHCI HCD (USB 2.0) support"
+        depends on USB && TANGOX 
+	---help---
+	  SMP86xx chips has an USB 2.0 host controller integrated. 
+	  Enable this option if your board has this chip. If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called tangox-ehci-hcd.
+
+config TANGOX_OHCI_HCD
+        tristate "SMP86xx OHCI HCD support"
+        depends on USB && USB_ARCH_HAS_OHCI && TANGOX && !USB_EHSET
+        ---help---
+	  SMP86xx chips has an USB 1.1 OHCI controller integrated. 
+	  Enable this option if your board has this chip. If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called tangox-ohci-hcd.
 
 config USB_EHCI_HCD
 	tristate "EHCI HCD (USB 2.0) support"
@@ -65,7 +85,7 @@
 
 config USB_EHCI_ROOT_HUB_TT
 	bool "Root Hub Transaction Translators"
-	depends on USB_EHCI_HCD || USB_CHIPIDEA_HOST
+	depends on (USB_EHCI_HCD || USB_CHIPIDEA_HOST || TANGOX_EHCI_HCD)
 	---help---
 	  Some EHCI chips have vendor-specific extensions to integrate
 	  transaction translators, so that no OHCI or UHCI companion
@@ -77,7 +97,7 @@
 
 config USB_EHCI_TT_NEWSCHED
 	bool "Improved Transaction Translator scheduling"
-	depends on USB_EHCI_HCD || USB_CHIPIDEA_HOST
+	depends on (USB_EHCI_HCD || USB_CHIPIDEA_HOST || TANGOX_EHCI_HCD)
 	default y
 	---help---
 	  This changes the periodic scheduling code to fill more of the low
@@ -298,7 +318,7 @@
 
 config USB_OHCI_HCD
 	tristate "OHCI HCD support"
-	depends on USB && USB_ARCH_HAS_OHCI
+	depends on USB && (USB_ARCH_HAS_OHCI || PCI)
 	select ISP1301_OMAP if MACH_OMAP_H2 || MACH_OMAP_H3
 	select USB_OTG_UTILS if ARCH_OMAP
 	depends on USB_ISP1301 || !ARCH_LPC32XX
diff -Naur linux-3.9.2.ref/drivers/usb/host/Makefile linux-3.9.2/drivers/usb/host/Makefile
--- linux-3.9.2.ref/drivers/usb/host/Makefile	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/drivers/usb/host/Makefile	2013-07-23 19:31:17.000000000 +0200
@@ -46,3 +46,5 @@
 obj-$(CONFIG_USB_OCTEON2_COMMON) += octeon2-common.o
 obj-$(CONFIG_USB_HCD_BCMA)	+= bcma-hcd.o
 obj-$(CONFIG_USB_HCD_SSB)	+= ssb-hcd.o
+obj-$(CONFIG_TANGOX_EHCI_HCD)   += tangox-ehci-hcd.o
+obj-$(CONFIG_TANGOX_OHCI_HCD)   += tangox-ohci-hcd.o
diff -Naur linux-3.9.2.ref/drivers/usb/host/ohci-tangox.c linux-3.9.2/drivers/usb/host/ohci-tangox.c
--- linux-3.9.2.ref/drivers/usb/host/ohci-tangox.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/drivers/usb/host/ohci-tangox.c	2013-07-23 19:31:17.000000000 +0200
@@ -0,0 +1,204 @@
+/*
+ * OHCI HCD (Host Controller Driver) for TangoX USB 1.1.
+ *
+ * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
+ * (C) Copyright 2000-2002 David Brownell <dbrownell@users.sourceforge.net>
+ * (C) Copyright 2002 Hewlett-Packard Company
+ * (C) Copyright 2003-2005 MontaVista Software Inc.
+ * (C) Copyright 2004-2008 Sigma Designs, Inc.
+ * 
+ * Bus Glue for TANGOX OHCI driver. Sigma Designs, Inc.
+ * This file is licenced under the GPL.
+ */
+
+#include <linux/platform_device.h>
+
+/**
+ * tangox_ohci_probe - initialize On-Chip HCDs
+ * Context: !in_interrupt()
+ *
+ * Allocates basic resources for this USB host controller.
+ *
+ * Store this function in the HCD's struct pci_driver as probe().
+ */
+static int tangox_ohci_probe(const struct hc_driver *driver,
+			  struct platform_device *pdev)
+{
+	int retval;
+	struct usb_hcd *hcd;
+	struct ohci_hcd	*ohci;
+
+	hcd = usb_create_hcd(driver, &pdev->dev, "TANGOX OHCI");
+	if (!hcd)
+		return -ENOMEM;
+	hcd->rsrc_start = NON_CACHED(tangox_ohci_base[0]);
+	hcd->regs =(void *)NON_CACHED(tangox_ohci_base[0]);
+	pr_debug("hcd->register=0x%x\n", (unsigned int)hcd->regs);
+
+	ohci = hcd_to_ohci(hcd);
+	ohci_hcd_init(ohci);
+
+	/* reset before request irq */
+	ohci_writel (ohci, 0, hcd->regs + 4);
+	ohci_readl (ohci, hcd->regs + 4);
+	msleep(50);
+
+	retval = usb_add_hcd(hcd, tangox_ohci_irq[0], 0);
+	if (retval == 0)
+		return retval;
+	
+
+	pr_debug("Removing TANGOX USB OHCI Controller\n");
+ 	usb_put_hcd(hcd);
+
+	return retval;
+}
+
+
+/* may be called without controller electrically present */
+/* may be called with controller, bus, and devices active */
+
+/**
+ * tangox_ohci_remove - shutdown processing for On-Chip HCDs
+ * @pdev: USB Host Controller being removed
+ * Context: !in_interrupt()
+ *
+ * Reverses the effect of tangox_ohci_probe().
+ * It is always called from a thread
+ * context, normally "rmmod", "apmd", or something similar.
+ *
+ */
+static void tangox_ohci_remove(struct usb_hcd *hcd,
+		struct platform_device *pdev)
+{
+	
+	usb_remove_hcd(hcd);
+
+	pr_debug("stopping TANGOX USB OHCI Controller\n");
+	usb_put_hcd(hcd);
+}
+
+static int
+tangox_ohci_start(struct usb_hcd *hcd)
+{
+	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
+	int		ret;
+
+	if ((ret = ohci_init(ohci)) < 0)
+		return ret;
+
+	if ((ret = ohci_run(ohci)) < 0) {
+		dev_err(hcd->self.controller, "can't start %s", ohci_to_hcd(ohci)->self.bus_name);
+		ohci_stop(hcd);
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct hc_driver tangox_ohci_hc_driver = {
+	.description =		OHCI_HCD_NAME,
+	.hcd_priv_size =	sizeof(struct ohci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq =			ohci_irq,
+	.flags =		HCD_USB11 | HCD_MEMORY,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.start =		tangox_ohci_start,
+	.stop =			ohci_stop,
+	.shutdown =		ohci_shutdown,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue =		ohci_urb_enqueue,
+	.urb_dequeue =		ohci_urb_dequeue,
+	.endpoint_disable =	ohci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number =	ohci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data =	ohci_hub_status_data,
+	.hub_control =		ohci_hub_control,
+#if defined(CONFIG_PM)
+	.bus_suspend 		= ohci_bus_suspend,
+	.bus_resume 		= ohci_bus_resume,
+#endif
+	.start_port_reset =	ohci_start_port_reset,
+};
+
+static int tangox_ohci_drv_probe(struct platform_device *pdev)
+{
+	int ret;
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	tangox_usb_init(0);
+	
+	printk("Initializing TangoX USB OHCI Controller Membase=0x%x, irq=%d\n", 
+				NON_CACHED(tangox_ohci_base[0]),tangox_ohci_irq[0]);
+
+	ret = tangox_ohci_probe(&tangox_ohci_hc_driver, pdev);
+
+	return ret;
+}
+
+static int tangox_ohci_drv_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = dev_get_drvdata(&pdev->dev);
+
+	tangox_ohci_remove(hcd, pdev);
+	tangox_usb_deinit(0);
+	return 0;
+}
+
+static void tangox_ohci_release_dev(struct device * dev)
+{
+	dev->parent = NULL;
+}
+
+
+static struct platform_driver tangox_ohci_driver = {
+	.probe		= tangox_ohci_drv_probe,
+	.remove		= tangox_ohci_drv_remove,
+	.driver = {
+		.name = (char *)OHCI_HCD_NAME,
+		.bus = &platform_bus_type
+	},
+
+#if	defined(CONFIG_USB_SUSPEND) || defined(CONFIG_PM)
+	.suspend	= NULL,
+	.resume		= NULL,
+#endif
+};
+
+
+/* The dmamask must be set for OHCI to work */
+static u64 ohci_dmamask = ~(u32)0;
+static struct platform_device tangox_ohci_device = {
+	.name           = OHCI_HCD_NAME,
+	.id             = -1,
+	.dev = {
+		.dma_mask               = &ohci_dmamask,
+		.coherent_dma_mask      = 0xffffffff,
+		.release				= tangox_ohci_release_dev,
+	},
+	.num_resources  = 0,
+	.resource       = 0,
+};
+
+static struct platform_device *tangox_platform_devices[] __initdata = {
+	&tangox_ohci_device,
+};
+
diff -Naur linux-3.9.2.ref/drivers/usb/host/tangox-ehci-hcd.c linux-3.9.2/drivers/usb/host/tangox-ehci-hcd.c
--- linux-3.9.2.ref/drivers/usb/host/tangox-ehci-hcd.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/drivers/usb/host/tangox-ehci-hcd.c	2013-07-23 19:31:17.000000000 +0200
@@ -0,0 +1,1366 @@
+/*
+ * Enhanced Host Controller Interface (EHCI) driver for USB.
+ *
+ * Maintainer: Alan Stern <stern@rowland.harvard.edu>
+ *
+ * Copyright (c) 2000-2004 by David Brownell
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/dmapool.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/vmalloc.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/hrtimer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/usb.h>
+#include <linux/usb/hcd.h>
+#include <linux/moduleparam.h>
+#include <linux/dma-mapping.h>
+#include <linux/debugfs.h>
+#include <linux/slab.h>
+
+#include <asm/byteorder.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/unaligned.h>
+
+#if defined(CONFIG_PPC_PS3)
+#include <asm/firmware.h>
+#endif
+
+#include "../core/usb.h"
+#include "../core/tangox-usb.h"
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * EHCI hc_driver implementation ... experimental, incomplete.
+ * Based on the final 1.0 register interface specification.
+ *
+ * USB 2.0 shows up in upcoming www.pcmcia.org technology.
+ * First was PCMCIA, like ISA; then CardBus, which is PCI.
+ * Next comes "CardBay", using USB 2.0 signals.
+ *
+ * Contains additional contributions by Brad Hards, Rory Bolt, and others.
+ * Special thanks to Intel and VIA for providing host controllers to
+ * test this driver on, and Cypress (including In-System Design) for
+ * providing early devices for those host controllers to talk to!
+ */
+
+#define DRIVER_AUTHOR "David Brownell"
+#define DRIVER_DESC "USB 2.0 'Enhanced' Host Controller (EHCI) Driver"
+
+static const char	hcd_name [] = "ehci_hcd";
+
+#undef VERBOSE_DEBUG
+#undef EHCI_URB_TRACE
+
+/* magic numbers that can affect system performance */
+#define	EHCI_TUNE_CERR		3	/* 0-3 qtd retries; 0 == don't stop */
+#define	EHCI_TUNE_RL_HS		4	/* nak throttle; see 4.9 */
+#define	EHCI_TUNE_RL_TT		0
+#define	EHCI_TUNE_MULT_HS	1	/* 1-3 transactions/uframe; 4.10.3 */
+#define	EHCI_TUNE_MULT_TT	1
+/*
+ * Some drivers think it's safe to schedule isochronous transfers more than
+ * 256 ms into the future (partly as a result of an old bug in the scheduling
+ * code).  In an attempt to avoid trouble, we will use a minimum scheduling
+ * length of 512 frames instead of 256.
+ */
+#define	EHCI_TUNE_FLS		1	/* (medium) 512-frame schedule */
+
+
+/* for 867x/868x, it has two controllers */
+static int controller = 2;		// 0,1,2(both)
+module_param (controller, int, S_IRUGO);
+MODULE_PARM_DESC (controller, "TANGOX USB host Controller 0, 1 or 2(both)");
+
+/* Initial IRQ latency:  faster than hw default */
+static int log2_irq_thresh = 1;		// 0 to 6
+module_param (log2_irq_thresh, int, S_IRUGO);
+MODULE_PARM_DESC (log2_irq_thresh, "log2 IRQ latency, 1-64 microframes");
+
+/* initial park setting:  slower than hw default */
+static unsigned park = 0;
+module_param (park, uint, S_IRUGO);
+MODULE_PARM_DESC (park, "park setting; 1-3 back-to-back async packets");
+
+/* for flakey hardware, ignore overcurrent indicators */
+static bool ignore_oc = 0;
+module_param (ignore_oc, bool, S_IRUGO);
+MODULE_PARM_DESC (ignore_oc, "ignore bogus hardware overcurrent indications");
+
+#define	INTR_MASK (STS_IAA | STS_FATAL | STS_PCD | STS_ERR | STS_INT)
+
+/*-------------------------------------------------------------------------*/
+
+#include "ehci.h"
+#include "pci-quirks.h"
+
+/*
+ * The MosChip MCS9990 controller updates its microframe counter
+ * a little before the frame counter, and occasionally we will read
+ * the invalid intermediate value.  Avoid problems by checking the
+ * microframe number (the low-order 3 bits); if they are 0 then
+ * re-read the register to get the correct value.
+ */
+static unsigned ehci_moschip_read_frame_index(struct ehci_hcd *ehci)
+{
+	unsigned uf;
+
+	uf = ehci_readl(ehci, &ehci->regs->frame_index);
+	if (unlikely((uf & 7) == 0))
+		uf = ehci_readl(ehci, &ehci->regs->frame_index);
+	return uf;
+}
+
+static inline unsigned ehci_read_frame_index(struct ehci_hcd *ehci)
+{
+	if (ehci->frame_index_bug)
+		return ehci_moschip_read_frame_index(ehci);
+	return ehci_readl(ehci, &ehci->regs->frame_index);
+}
+
+#include "ehci-dbg.c"
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * handshake - spin reading hc until handshake completes or fails
+ * @ptr: address of hc register to be read
+ * @mask: bits to look at in result of read
+ * @done: value of those bits when handshake succeeds
+ * @usec: timeout in microseconds
+ *
+ * Returns negative errno, or zero on success
+ *
+ * Success happens when the "mask" bits have the specified value (hardware
+ * handshake done).  There are two failure modes:  "usec" have passed (major
+ * hardware flakeout), or the register reads as all-ones (hardware removed).
+ *
+ * That last failure should_only happen in cases like physical cardbus eject
+ * before driver shutdown. But it also seems to be caused by bugs in cardbus
+ * bridge shutdown:  shutting down the bridge before the devices using it.
+ */
+static int handshake (struct ehci_hcd *ehci, void __iomem *ptr,
+		      u32 mask, u32 done, int usec)
+{
+	u32	result;
+
+	do {
+		result = ehci_readl(ehci, ptr);
+		if (result == ~(u32)0)		/* card removed */
+			return -ENODEV;
+		result &= mask;
+		if (result == done)
+			return 0;
+		udelay (1);
+		usec--;
+	} while (usec > 0);
+	return -ETIMEDOUT;
+}
+
+/* check TDI/ARC silicon is in host mode */
+static int tdi_in_host_mode (struct ehci_hcd *ehci)
+{
+	u32		tmp;
+
+	tmp = ehci_readl(ehci, &ehci->regs->usbmode);
+	return (tmp & 3) == USBMODE_CM_HC;
+}
+
+/*
+ * Force HC to halt state from unknown (EHCI spec section 2.3).
+ * Must be called with interrupts enabled and the lock not held.
+ */
+static int ehci_halt (struct ehci_hcd *ehci)
+{
+	u32	temp;
+
+	spin_lock_irq(&ehci->lock);
+
+	/* disable any irqs left enabled by previous code */
+	ehci_writel(ehci, 0, &ehci->regs->intr_enable);
+
+	if (ehci_is_TDI(ehci) && !tdi_in_host_mode(ehci)) {
+		spin_unlock_irq(&ehci->lock);
+		return 0;
+	}
+
+	/*
+	 * This routine gets called during probe before ehci->command
+	 * has been initialized, so we can't rely on its value.
+	 */
+	ehci->command &= ~CMD_RUN;
+	temp = ehci_readl(ehci, &ehci->regs->command);
+	temp &= ~(CMD_RUN | CMD_IAAD);
+	ehci_writel(ehci, temp, &ehci->regs->command);
+
+	spin_unlock_irq(&ehci->lock);
+	synchronize_irq(ehci_to_hcd(ehci)->irq);
+
+	return handshake(ehci, &ehci->regs->status,
+			  STS_HALT, STS_HALT, 16 * 125);
+}
+
+/* put TDI/ARC silicon into EHCI mode */
+static void tdi_reset (struct ehci_hcd *ehci)
+{
+	u32		tmp;
+
+	tmp = ehci_readl(ehci, &ehci->regs->usbmode);
+	tmp |= USBMODE_CM_HC;
+	/* The default byte access to MMR space is LE after
+	 * controller reset. Set the required endian mode
+	 * for transfer buffers to match the host microprocessor
+	 */
+	if (ehci_big_endian_mmio(ehci))
+		tmp |= USBMODE_BE;
+	ehci_writel(ehci, tmp, &ehci->regs->usbmode);
+}
+
+/*
+ * Reset a non-running (STS_HALT == 1) controller.
+ * Must be called with interrupts enabled and the lock not held.
+ */
+static int ehci_reset (struct ehci_hcd *ehci)
+{
+	unsigned long tangox_chip_id(void);
+	unsigned long chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+	int	retval;
+	u32	command = ehci_readl(ehci, &ehci->regs->command);
+
+	/* If the EHCI debug controller is active, special care must be
+	 * taken before and after a host controller reset */
+	if (ehci->debug && !dbgp_reset_prep(ehci_to_hcd(ehci)))
+		ehci->debug = NULL;
+
+	command |= CMD_RESET;
+	dbg_cmd (ehci, "reset", command);
+	ehci_writel(ehci, command, &ehci->regs->command);
+	ehci->rh_state = EHCI_RH_HALTED;
+	ehci->next_statechange = jiffies;
+	retval = handshake (ehci, &ehci->regs->command,
+			    CMD_RESET, 0, 250 * 1000);
+
+	if (ehci->has_hostpc) {
+		ehci_writel(ehci, USBMODE_EX_HC | USBMODE_EX_VBPS,
+				&ehci->regs->usbmode_ex);
+		ehci_writel(ehci, TXFIFO_DEFAULT, &ehci->regs->txfill_tuning);
+	}
+	
+	if ((chip_id == 0x8652) || (chip_id == 0x8646) || ((chip_id & 0xfff0) == 0x8670) || ((chip_id & 0xfff0) == 0x8680)) {
+		int ctrl = (ehci_to_hcd(ehci)->irq == TANGOX_EHCI0_IRQ) ? 0 : 1; 
+		ehci_writel(ehci, 0x3, (void *)(NON_CACHED(tangox_ehci_base[ctrl]) + TANGOX_USB_MODE));
+	}
+	
+	if (retval)
+		return retval;
+
+	if (ehci_is_TDI(ehci))
+		tdi_reset (ehci);
+
+	if (ehci->debug)
+		dbgp_external_startup(ehci_to_hcd(ehci));
+
+	ehci->port_c_suspend = ehci->suspended_ports =
+			ehci->resuming_ports = 0;
+	return retval;
+}
+
+/*
+ * Idle the controller (turn off the schedules).
+ * Must be called with interrupts enabled and the lock not held.
+ */
+static void ehci_quiesce (struct ehci_hcd *ehci)
+{
+	u32	temp;
+
+	if (ehci->rh_state != EHCI_RH_RUNNING)
+		return;
+
+	/* wait for any schedule enables/disables to take effect */
+	temp = (ehci->command << 10) & (STS_ASS | STS_PSS);
+	handshake(ehci, &ehci->regs->status, STS_ASS | STS_PSS, temp, 16 * 125);
+
+	/* then disable anything that's still active */
+	spin_lock_irq(&ehci->lock);
+	ehci->command &= ~(CMD_ASE | CMD_PSE);
+	ehci_writel(ehci, ehci->command, &ehci->regs->command);
+	spin_unlock_irq(&ehci->lock);
+
+	/* hardware can take 16 microframes to turn off ... */
+	handshake(ehci, &ehci->regs->status, STS_ASS | STS_PSS, 0, 16 * 125);
+}
+
+/*-------------------------------------------------------------------------*/
+
+static void end_unlink_async(struct ehci_hcd *ehci);
+static void unlink_empty_async(struct ehci_hcd *ehci);
+static void unlink_empty_async_suspended(struct ehci_hcd *ehci);
+static void ehci_work(struct ehci_hcd *ehci);
+static void start_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh);
+static void end_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh);
+
+#include "ehci-timer.c"
+#include "ehci-hub.c"
+#include "ehci-mem.c"
+#include "ehci-q.c"
+#include "ehci-sched.c"
+#include "ehci-sysfs.c"
+
+/*-------------------------------------------------------------------------*/
+
+/* On some systems, leaving remote wakeup enabled prevents system shutdown.
+ * The firmware seems to think that powering off is a wakeup event!
+ * This routine turns off remote wakeup and everything else, on all ports.
+ */
+static void ehci_turn_off_all_ports(struct ehci_hcd *ehci)
+{
+	int	port = HCS_N_PORTS(ehci->hcs_params);
+
+	while (port--)
+		ehci_writel(ehci, PORT_RWC_BITS,
+				&ehci->regs->port_status[port]);
+}
+
+/*
+ * Halt HC, turn off all ports, and let the BIOS use the companion controllers.
+ * Must be called with interrupts enabled and the lock not held.
+ */
+static void ehci_silence_controller(struct ehci_hcd *ehci)
+{
+	ehci_halt(ehci);
+
+	spin_lock_irq(&ehci->lock);
+	ehci->rh_state = EHCI_RH_HALTED;
+	ehci_turn_off_all_ports(ehci);
+
+	/* make BIOS/etc use companion controller during reboot */
+	ehci_writel(ehci, 0, &ehci->regs->configured_flag);
+
+	/* unblock posted writes */
+	ehci_readl(ehci, &ehci->regs->configured_flag);
+	spin_unlock_irq(&ehci->lock);
+}
+
+/* ehci_shutdown kick in for silicon on any bus (not just pci, etc).
+ * This forcibly disables dma and IRQs, helping kexec and other cases
+ * where the next system software may expect clean state.
+ */
+static void ehci_shutdown(struct usb_hcd *hcd)
+{
+	struct ehci_hcd	*ehci = hcd_to_ehci(hcd);
+
+	spin_lock_irq(&ehci->lock);
+	ehci->shutdown = true;
+	ehci->rh_state = EHCI_RH_STOPPING;
+	ehci->enabled_hrtimer_events = 0;
+	spin_unlock_irq(&ehci->lock);
+
+	ehci_silence_controller(ehci);
+
+	hrtimer_cancel(&ehci->hrtimer);
+}
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * ehci_work is called from some interrupts, timers, and so on.
+ * it calls driver completion functions, after dropping ehci->lock.
+ */
+static void ehci_work (struct ehci_hcd *ehci)
+{
+	/* another CPU may drop ehci->lock during a schedule scan while
+	 * it reports urb completions.  this flag guards against bogus
+	 * attempts at re-entrant schedule scanning.
+	 */
+	if (ehci->scanning) {
+		ehci->need_rescan = true;
+		return;
+	}
+	ehci->scanning = true;
+
+ rescan:
+	ehci->need_rescan = false;
+	if (ehci->async_count)
+		scan_async(ehci);
+	if (ehci->intr_count > 0)
+		scan_intr(ehci);
+	if (ehci->isoc_count > 0)
+		scan_isoc(ehci);
+	if (ehci->need_rescan)
+		goto rescan;
+	ehci->scanning = false;
+
+	/* the IO watchdog guards against hardware or driver bugs that
+	 * misplace IRQs, and should let us run completely without IRQs.
+	 * such lossage has been observed on both VT6202 and VT8235.
+	 */
+	turn_on_io_watchdog(ehci);
+}
+
+/*
+ * Called when the ehci_hcd module is removed.
+ */
+static void ehci_stop (struct usb_hcd *hcd)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
+
+	ehci_dbg (ehci, "stop\n");
+
+	/* no more interrupts ... */
+
+	spin_lock_irq(&ehci->lock);
+	ehci->enabled_hrtimer_events = 0;
+	spin_unlock_irq(&ehci->lock);
+
+	ehci_quiesce(ehci);
+	ehci_silence_controller(ehci);
+	ehci_reset (ehci);
+
+	hrtimer_cancel(&ehci->hrtimer);
+	remove_sysfs_files(ehci);
+	remove_debug_files (ehci);
+
+	/* root hub is shut down separately (first, when possible) */
+	spin_lock_irq (&ehci->lock);
+	end_free_itds(ehci);
+	spin_unlock_irq (&ehci->lock);
+	ehci_mem_cleanup (ehci);
+
+	if (ehci->amd_pll_fix == 1)
+		usb_amd_dev_put();
+
+#ifdef	EHCI_STATS
+	ehci_dbg(ehci, "irq normal %ld err %ld iaa %ld (lost %ld)\n",
+		ehci->stats.normal, ehci->stats.error, ehci->stats.iaa,
+		ehci->stats.lost_iaa);
+	ehci_dbg (ehci, "complete %ld unlink %ld\n",
+		ehci->stats.complete, ehci->stats.unlink);
+#endif
+
+	dbg_status (ehci, "ehci_stop completed",
+		    ehci_readl(ehci, &ehci->regs->status));
+}
+
+/* one-time init, only for memory state */
+static int ehci_init(struct usb_hcd *hcd)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
+	u32			temp;
+	int			retval;
+	u32			hcc_params;
+	struct ehci_qh_hw	*hw;
+
+	spin_lock_init(&ehci->lock);
+
+	/*
+	 * keep io watchdog by default, those good HCDs could turn off it later
+	 */
+	ehci->need_io_watchdog = 1;
+
+	hrtimer_init(&ehci->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);
+	ehci->hrtimer.function = ehci_hrtimer_func;
+	ehci->next_hrtimer_event = EHCI_HRTIMER_NO_EVENT;
+
+	hcc_params = ehci_readl(ehci, &ehci->caps->hcc_params);
+
+	/*
+	 * by default set standard 80% (== 100 usec/uframe) max periodic
+	 * bandwidth as required by USB 2.0
+	 */
+	ehci->uframe_periodic_max = 100;
+
+	/*
+	 * hw default: 1K periodic list heads, one per frame.
+	 * periodic_size can shrink by USBCMD update if hcc_params allows.
+	 */
+	ehci->periodic_size = DEFAULT_I_TDPS;
+	INIT_LIST_HEAD(&ehci->intr_qh_list);
+	INIT_LIST_HEAD(&ehci->cached_itd_list);
+	INIT_LIST_HEAD(&ehci->cached_sitd_list);
+
+	if (HCC_PGM_FRAMELISTLEN(hcc_params)) {
+		/* periodic schedule size can be smaller than default */
+		switch (EHCI_TUNE_FLS) {
+		case 0: ehci->periodic_size = 1024; break;
+		case 1: ehci->periodic_size = 512; break;
+		case 2: ehci->periodic_size = 256; break;
+		default:	BUG();
+		}
+	}
+	if ((retval = ehci_mem_init(ehci, GFP_KERNEL)) < 0)
+		return retval;
+
+	/* controllers may cache some of the periodic schedule ... */
+	if (HCC_ISOC_CACHE(hcc_params))		// full frame cache
+		ehci->i_thresh = 0;
+	else					// N microframes cached
+		ehci->i_thresh = 2 + HCC_ISOC_THRES(hcc_params);
+
+	/*
+	 * dedicate a qh for the async ring head, since we couldn't unlink
+	 * a 'real' qh without stopping the async schedule [4.8].  use it
+	 * as the 'reclamation list head' too.
+	 * its dummy is used in hw_alt_next of many tds, to prevent the qh
+	 * from automatically advancing to the next td after short reads.
+	 */
+	ehci->async->qh_next.qh = NULL;
+	hw = ehci->async->hw;
+	hw->hw_next = QH_NEXT(ehci, ehci->async->qh_dma);
+	hw->hw_info1 = cpu_to_hc32(ehci, QH_HEAD);
+#if defined(CONFIG_PPC_PS3)
+	hw->hw_info1 |= cpu_to_hc32(ehci, QH_INACTIVATE);
+#endif
+	hw->hw_token = cpu_to_hc32(ehci, QTD_STS_HALT);
+	hw->hw_qtd_next = EHCI_LIST_END(ehci);
+	ehci->async->qh_state = QH_STATE_LINKED;
+	hw->hw_alt_next = QTD_NEXT(ehci, ehci->async->dummy->qtd_dma);
+
+	/* clear interrupt enables, set irq latency */
+	if (log2_irq_thresh < 0 || log2_irq_thresh > 6)
+		log2_irq_thresh = 0;
+	temp = 1 << (16 + log2_irq_thresh);
+	if (HCC_PER_PORT_CHANGE_EVENT(hcc_params)) {
+		ehci->has_ppcd = 1;
+		ehci_dbg(ehci, "enable per-port change event\n");
+		temp |= CMD_PPCEE;
+	}
+	if (HCC_CANPARK(hcc_params)) {
+		/* HW default park == 3, on hardware that supports it (like
+		 * NVidia and ALI silicon), maximizes throughput on the async
+		 * schedule by avoiding QH fetches between transfers.
+		 *
+		 * With fast usb storage devices and NForce2, "park" seems to
+		 * make problems:  throughput reduction (!), data errors...
+		 */
+		if (park) {
+			park = min(park, (unsigned) 3);
+			temp |= CMD_PARK;
+			temp |= park << 8;
+		}
+		ehci_dbg(ehci, "park %d\n", park);
+	}
+	if (HCC_PGM_FRAMELISTLEN(hcc_params)) {
+		/* periodic schedule size can be smaller than default */
+		temp &= ~(3 << 2);
+		temp |= (EHCI_TUNE_FLS << 2);
+	}
+	ehci->command = temp;
+
+	/* Accept arbitrarily long scatter-gather lists */
+	if (!(hcd->driver->flags & HCD_LOCAL_MEM))
+		hcd->self.sg_tablesize = ~0;
+	return 0;
+}
+
+/* start HC running; it's halted, ehci_init() has been run (once) */
+static int ehci_run (struct usb_hcd *hcd)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
+	u32			temp;
+	u32			hcc_params;
+
+	hcd->uses_new_polling = 1;
+
+	/* EHCI spec section 4.1 */
+
+	ehci_writel(ehci, ehci->periodic_dma, &ehci->regs->frame_list);
+	ehci_writel(ehci, (u32)ehci->async->qh_dma, &ehci->regs->async_next);
+
+	/*
+	 * hcc_params controls whether ehci->regs->segment must (!!!)
+	 * be used; it constrains QH/ITD/SITD and QTD locations.
+	 * pci_pool consistent memory always uses segment zero.
+	 * streaming mappings for I/O buffers, like pci_map_single(),
+	 * can return segments above 4GB, if the device allows.
+	 *
+	 * NOTE:  the dma mask is visible through dma_supported(), so
+	 * drivers can pass this info along ... like NETIF_F_HIGHDMA,
+	 * Scsi_Host.highmem_io, and so forth.  It's readonly to all
+	 * host side drivers though.
+	 */
+	hcc_params = ehci_readl(ehci, &ehci->caps->hcc_params);
+	if (HCC_64BIT_ADDR(hcc_params)) {
+		ehci_writel(ehci, 0, &ehci->regs->segment);
+#if 0
+// this is deeply broken on almost all architectures
+		if (!dma_set_mask(hcd->self.controller, DMA_BIT_MASK(64)))
+			ehci_info(ehci, "enabled 64bit DMA\n");
+#endif
+	}
+
+
+	// Philips, Intel, and maybe others need CMD_RUN before the
+	// root hub will detect new devices (why?); NEC doesn't
+	ehci->command &= ~(CMD_LRESET|CMD_IAAD|CMD_PSE|CMD_ASE|CMD_RESET);
+	ehci->command |= CMD_RUN;
+	ehci_writel(ehci, ehci->command, &ehci->regs->command);
+	dbg_cmd (ehci, "init", ehci->command);
+
+	/*
+	 * Start, enabling full USB 2.0 functionality ... usb 1.1 devices
+	 * are explicitly handed to companion controller(s), so no TT is
+	 * involved with the root hub.  (Except where one is integrated,
+	 * and there's no companion controller unless maybe for USB OTG.)
+	 *
+	 * Turning on the CF flag will transfer ownership of all ports
+	 * from the companions to the EHCI controller.  If any of the
+	 * companions are in the middle of a port reset at the time, it
+	 * could cause trouble.  Write-locking ehci_cf_port_reset_rwsem
+	 * guarantees that no resets are in progress.  After we set CF,
+	 * a short delay lets the hardware catch up; new resets shouldn't
+	 * be started before the port switching actions could complete.
+	 */
+	down_write(&ehci_cf_port_reset_rwsem);
+	ehci->rh_state = EHCI_RH_RUNNING;
+	ehci_writel(ehci, FLAG_CF, &ehci->regs->configured_flag);
+	ehci_readl(ehci, &ehci->regs->command);	/* unblock posted writes */
+	msleep(5);
+	up_write(&ehci_cf_port_reset_rwsem);
+	ehci->last_periodic_enable = ktime_get_real();
+
+	temp = HC_VERSION(ehci, ehci_readl(ehci, &ehci->caps->hc_capbase));
+	ehci_info (ehci,
+		"USB %x.%x started, EHCI %x.%02x%s\n",
+		((ehci->sbrn & 0xf0)>>4), (ehci->sbrn & 0x0f),
+		temp >> 8, temp & 0xff,
+		ignore_oc ? ", overcurrent ignored" : "");
+
+	ehci_writel(ehci, INTR_MASK,
+		    &ehci->regs->intr_enable); /* Turn On Interrupts */
+
+	/* GRR this is run-once init(), being done every time the HC starts.
+	 * So long as they're part of class devices, we can't do it init()
+	 * since the class device isn't created that early.
+	 */
+	create_debug_files(ehci);
+	create_sysfs_files(ehci);
+
+	return 0;
+}
+
+int ehci_setup(struct usb_hcd *hcd)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	int retval;
+
+	ehci->regs = (void __iomem *)ehci->caps +
+	    HC_LENGTH(ehci, ehci_readl(ehci, &ehci->caps->hc_capbase));
+	dbg_hcs_params(ehci, "reset");
+	dbg_hcc_params(ehci, "reset");
+
+	/* cache this readonly data; minimize chip reads */
+	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
+
+	ehci->sbrn = HCD_USB2;
+
+	/* data structure init */
+	retval = ehci_init(hcd);
+	if (retval)
+		return retval;
+
+	retval = ehci_halt(ehci);
+	if (retval)
+		return retval;
+
+	ehci_reset(ehci);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ehci_setup);
+
+/*-------------------------------------------------------------------------*/
+
+static irqreturn_t ehci_irq (struct usb_hcd *hcd)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
+	u32			status, masked_status, pcd_status = 0, cmd;
+	int			bh;
+
+	spin_lock (&ehci->lock);
+
+	status = ehci_readl(ehci, &ehci->regs->status);
+
+	/* e.g. cardbus physical eject */
+	if (status == ~(u32) 0) {
+		ehci_dbg (ehci, "device removed\n");
+		goto dead;
+	}
+
+	/*
+	 * We don't use STS_FLR, but some controllers don't like it to
+	 * remain on, so mask it out along with the other status bits.
+	 */
+	masked_status = status & (INTR_MASK | STS_FLR);
+
+	/* Shared IRQ? */
+	if (!masked_status || unlikely(ehci->rh_state == EHCI_RH_HALTED)) {
+		spin_unlock(&ehci->lock);
+		return IRQ_NONE;
+	}
+
+	/* clear (just) interrupts */
+	ehci_writel(ehci, masked_status, &ehci->regs->status);
+	cmd = ehci_readl(ehci, &ehci->regs->command);
+	bh = 0;
+
+#ifdef	VERBOSE_DEBUG
+	/* unrequested/ignored: Frame List Rollover */
+	dbg_status (ehci, "irq", status);
+#endif
+
+	/* INT, ERR, and IAA interrupt rates can be throttled */
+
+	/* normal [4.15.1.2] or error [4.15.1.1] completion */
+	if (likely ((status & (STS_INT|STS_ERR)) != 0)) {
+		if (likely ((status & STS_ERR) == 0))
+			COUNT (ehci->stats.normal);
+		else
+			COUNT (ehci->stats.error);
+		bh = 1;
+	}
+
+	/* complete the unlinking of some qh [4.15.2.3] */
+	if (status & STS_IAA) {
+
+		/* Turn off the IAA watchdog */
+		ehci->enabled_hrtimer_events &= ~BIT(EHCI_HRTIMER_IAA_WATCHDOG);
+
+		/*
+		 * Mild optimization: Allow another IAAD to reset the
+		 * hrtimer, if one occurs before the next expiration.
+		 * In theory we could always cancel the hrtimer, but
+		 * tests show that about half the time it will be reset
+		 * for some other event anyway.
+		 */
+		if (ehci->next_hrtimer_event == EHCI_HRTIMER_IAA_WATCHDOG)
+			++ehci->next_hrtimer_event;
+
+		/* guard against (alleged) silicon errata */
+		if (cmd & CMD_IAAD)
+			ehci_dbg(ehci, "IAA with IAAD still set?\n");
+		if (ehci->async_iaa)
+			COUNT(ehci->stats.iaa);
+		end_unlink_async(ehci);
+	}
+
+	/* remote wakeup [4.3.1] */
+	if (status & STS_PCD) {
+		unsigned	i = HCS_N_PORTS (ehci->hcs_params);
+		u32		ppcd = 0;
+
+		/* kick root hub later */
+		pcd_status = status;
+
+		/* resume root hub? */
+		if (ehci->rh_state == EHCI_RH_SUSPENDED)
+			usb_hcd_resume_root_hub(hcd);
+
+		/* get per-port change detect bits */
+		if (ehci->has_ppcd)
+			ppcd = status >> 16;
+
+		while (i--) {
+			int pstatus;
+
+			/* leverage per-port change bits feature */
+			if (ehci->has_ppcd && !(ppcd & (1 << i)))
+				continue;
+			pstatus = ehci_readl(ehci,
+					 &ehci->regs->port_status[i]);
+
+			if (pstatus & PORT_OWNER)
+				continue;
+			if (!(test_bit(i, &ehci->suspended_ports) &&
+					((pstatus & PORT_RESUME) ||
+						!(pstatus & PORT_SUSPEND)) &&
+					(pstatus & PORT_PE) &&
+					ehci->reset_done[i] == 0))
+				continue;
+
+			/* start 20 msec resume signaling from this port,
+			 * and make khubd collect PORT_STAT_C_SUSPEND to
+			 * stop that signaling.  Use 5 ms extra for safety,
+			 * like usb_port_resume() does.
+			 */
+			ehci->reset_done[i] = jiffies + msecs_to_jiffies(25);
+			set_bit(i, &ehci->resuming_ports);
+			ehci_dbg (ehci, "port %d remote wakeup\n", i + 1);
+			usb_hcd_start_port_resume(&hcd->self, i);
+			mod_timer(&hcd->rh_timer, ehci->reset_done[i]);
+		}
+	}
+
+	/* PCI errors [4.15.2.4] */
+	if (unlikely ((status & STS_FATAL) != 0)) {
+		ehci_err(ehci, "fatal error\n");
+		dbg_cmd(ehci, "fatal", cmd);
+		dbg_status(ehci, "fatal", status);
+dead:
+		usb_hc_died(hcd);
+
+		/* Don't let the controller do anything more */
+		ehci->shutdown = true;
+		ehci->rh_state = EHCI_RH_STOPPING;
+		ehci->command &= ~(CMD_RUN | CMD_ASE | CMD_PSE);
+		ehci_writel(ehci, ehci->command, &ehci->regs->command);
+		ehci_writel(ehci, 0, &ehci->regs->intr_enable);
+		ehci_handle_controller_death(ehci);
+
+		/* Handle completions when the controller stops */
+		bh = 0;
+	}
+
+	if (bh)
+		ehci_work (ehci);
+	spin_unlock (&ehci->lock);
+	if (pcd_status)
+		usb_hcd_poll_rh_status(hcd);
+	return IRQ_HANDLED;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * non-error returns are a promise to giveback() the urb later
+ * we drop ownership so next owner (or urb unlink) can get it
+ *
+ * urb + dev is in hcd.self.controller.urb_list
+ * we're queueing TDs onto software and hardware lists
+ *
+ * hcd-specific init for hcpriv hasn't been done yet
+ *
+ * NOTE:  control, bulk, and interrupt share the same code to append TDs
+ * to a (possibly active) QH, and the same QH scanning code.
+ */
+static int ehci_urb_enqueue (
+	struct usb_hcd	*hcd,
+	struct urb	*urb,
+	gfp_t		mem_flags
+) {
+	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
+	struct list_head	qtd_list;
+
+	INIT_LIST_HEAD (&qtd_list);
+
+	switch (usb_pipetype (urb->pipe)) {
+	case PIPE_CONTROL:
+		/* qh_completions() code doesn't handle all the fault cases
+		 * in multi-TD control transfers.  Even 1KB is rare anyway.
+		 */
+		if (urb->transfer_buffer_length > (16 * 1024))
+			return -EMSGSIZE;
+		/* FALLTHROUGH */
+	/* case PIPE_BULK: */
+	default:
+		if (!qh_urb_transaction (ehci, urb, &qtd_list, mem_flags))
+			return -ENOMEM;
+		return submit_async(ehci, urb, &qtd_list, mem_flags);
+
+	case PIPE_INTERRUPT:
+		if (!qh_urb_transaction (ehci, urb, &qtd_list, mem_flags))
+			return -ENOMEM;
+		return intr_submit(ehci, urb, &qtd_list, mem_flags);
+
+	case PIPE_ISOCHRONOUS:
+		if (urb->dev->speed == USB_SPEED_HIGH)
+			return itd_submit (ehci, urb, mem_flags);
+		else
+			return sitd_submit (ehci, urb, mem_flags);
+	}
+}
+
+/* remove from hardware lists
+ * completions normally happen asynchronously
+ */
+
+static int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
+	struct ehci_qh		*qh;
+	unsigned long		flags;
+	int			rc;
+
+	spin_lock_irqsave (&ehci->lock, flags);
+	rc = usb_hcd_check_unlink_urb(hcd, urb, status);
+	if (rc)
+		goto done;
+
+	switch (usb_pipetype (urb->pipe)) {
+	// case PIPE_CONTROL:
+	// case PIPE_BULK:
+	default:
+		qh = (struct ehci_qh *) urb->hcpriv;
+		if (!qh)
+			break;
+		switch (qh->qh_state) {
+		case QH_STATE_LINKED:
+		case QH_STATE_COMPLETING:
+			start_unlink_async(ehci, qh);
+			break;
+		case QH_STATE_UNLINK:
+		case QH_STATE_UNLINK_WAIT:
+			/* already started */
+			break;
+		case QH_STATE_IDLE:
+			/* QH might be waiting for a Clear-TT-Buffer */
+			qh_completions(ehci, qh);
+			break;
+		}
+		break;
+
+	case PIPE_INTERRUPT:
+		qh = (struct ehci_qh *) urb->hcpriv;
+		if (!qh)
+			break;
+		switch (qh->qh_state) {
+		case QH_STATE_LINKED:
+		case QH_STATE_COMPLETING:
+			start_unlink_intr(ehci, qh);
+			break;
+		case QH_STATE_IDLE:
+			qh_completions (ehci, qh);
+			break;
+		default:
+			ehci_dbg (ehci, "bogus qh %p state %d\n",
+					qh, qh->qh_state);
+			goto done;
+		}
+		break;
+
+	case PIPE_ISOCHRONOUS:
+		// itd or sitd ...
+
+		// wait till next completion, do it then.
+		// completion irqs can wait up to 1024 msec,
+		break;
+	}
+done:
+	spin_unlock_irqrestore (&ehci->lock, flags);
+	return rc;
+}
+
+/*-------------------------------------------------------------------------*/
+
+// bulk qh holds the data toggle
+
+static void
+ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
+	unsigned long		flags;
+	struct ehci_qh		*qh, *tmp;
+
+	/* ASSERT:  any requests/urbs are being unlinked */
+	/* ASSERT:  nobody can be submitting urbs for this any more */
+
+rescan:
+	spin_lock_irqsave (&ehci->lock, flags);
+	qh = ep->hcpriv;
+	if (!qh)
+		goto done;
+
+	/* endpoints can be iso streams.  for now, we don't
+	 * accelerate iso completions ... so spin a while.
+	 */
+	if (qh->hw == NULL) {
+		struct ehci_iso_stream	*stream = ep->hcpriv;
+
+		if (!list_empty(&stream->td_list))
+			goto idle_timeout;
+
+		/* BUG_ON(!list_empty(&stream->free_list)); */
+		kfree(stream);
+		goto done;
+	}
+
+	if (ehci->rh_state < EHCI_RH_RUNNING)
+		qh->qh_state = QH_STATE_IDLE;
+	switch (qh->qh_state) {
+	case QH_STATE_LINKED:
+	case QH_STATE_COMPLETING:
+		for (tmp = ehci->async->qh_next.qh;
+				tmp && tmp != qh;
+				tmp = tmp->qh_next.qh)
+			continue;
+		/* periodic qh self-unlinks on empty, and a COMPLETING qh
+		 * may already be unlinked.
+		 */
+		if (tmp)
+			start_unlink_async(ehci, qh);
+		/* FALL THROUGH */
+	case QH_STATE_UNLINK:		/* wait for hw to finish? */
+	case QH_STATE_UNLINK_WAIT:
+idle_timeout:
+		spin_unlock_irqrestore (&ehci->lock, flags);
+		schedule_timeout_uninterruptible(1);
+		goto rescan;
+	case QH_STATE_IDLE:		/* fully unlinked */
+		if (qh->clearing_tt)
+			goto idle_timeout;
+		if (list_empty (&qh->qtd_list)) {
+			qh_destroy(ehci, qh);
+			break;
+		}
+		/* else FALL THROUGH */
+	default:
+		/* caller was supposed to have unlinked any requests;
+		 * that's not our job.  just leak this memory.
+		 */
+		ehci_err (ehci, "qh %p (#%02x) state %d%s\n",
+			qh, ep->desc.bEndpointAddress, qh->qh_state,
+			list_empty (&qh->qtd_list) ? "" : "(has tds)");
+		break;
+	}
+ done:
+	ep->hcpriv = NULL;
+	spin_unlock_irqrestore (&ehci->lock, flags);
+}
+
+static void
+ehci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
+	struct ehci_qh		*qh;
+	int			eptype = usb_endpoint_type(&ep->desc);
+	int			epnum = usb_endpoint_num(&ep->desc);
+	int			is_out = usb_endpoint_dir_out(&ep->desc);
+	unsigned long		flags;
+
+	if (eptype != USB_ENDPOINT_XFER_BULK && eptype != USB_ENDPOINT_XFER_INT)
+		return;
+
+	spin_lock_irqsave(&ehci->lock, flags);
+	qh = ep->hcpriv;
+
+	/* For Bulk and Interrupt endpoints we maintain the toggle state
+	 * in the hardware; the toggle bits in udev aren't used at all.
+	 * When an endpoint is reset by usb_clear_halt() we must reset
+	 * the toggle bit in the QH.
+	 */
+	if (qh) {
+		usb_settoggle(qh->dev, epnum, is_out, 0);
+		if (!list_empty(&qh->qtd_list)) {
+			WARN_ONCE(1, "clear_halt for a busy endpoint\n");
+		} else if (qh->qh_state == QH_STATE_LINKED ||
+				qh->qh_state == QH_STATE_COMPLETING) {
+
+			/* The toggle value in the QH can't be updated
+			 * while the QH is active.  Unlink it now;
+			 * re-linking will call qh_refresh().
+			 */
+			if (eptype == USB_ENDPOINT_XFER_BULK)
+				start_unlink_async(ehci, qh);
+			else
+				start_unlink_intr(ehci, qh);
+		}
+	}
+	spin_unlock_irqrestore(&ehci->lock, flags);
+}
+
+static int ehci_get_frame (struct usb_hcd *hcd)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
+	return (ehci_read_frame_index(ehci) >> 3) % ehci->periodic_size;
+}
+
+/*-------------------------------------------------------------------------*/
+
+#ifdef	CONFIG_PM
+
+/* suspend/resume, section 4.3 */
+
+/* These routines handle the generic parts of controller suspend/resume */
+
+int ehci_suspend(struct usb_hcd *hcd, bool do_wakeup)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
+
+	if (time_before(jiffies, ehci->next_statechange))
+		msleep(10);
+
+	/*
+	 * Root hub was already suspended.  Disable IRQ emission and
+	 * mark HW unaccessible.  The PM and USB cores make sure that
+	 * the root hub is either suspended or stopped.
+	 */
+	ehci_prepare_ports_for_controller_suspend(ehci, do_wakeup);
+
+	spin_lock_irq(&ehci->lock);
+	ehci_writel(ehci, 0, &ehci->regs->intr_enable);
+	(void) ehci_readl(ehci, &ehci->regs->intr_enable);
+
+	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+	spin_unlock_irq(&ehci->lock);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ehci_suspend);
+
+/* Returns 0 if power was preserved, 1 if power was lost */
+int ehci_resume(struct usb_hcd *hcd, bool hibernated)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
+
+	if (time_before(jiffies, ehci->next_statechange))
+		msleep(100);
+
+	/* Mark hardware accessible again as we are back to full power by now */
+	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+
+	if (ehci->shutdown)
+		return 0;		/* Controller is dead */
+
+	/*
+	 * If CF is still set and we aren't resuming from hibernation
+	 * then we maintained suspend power.
+	 * Just undo the effect of ehci_suspend().
+	 */
+	if (ehci_readl(ehci, &ehci->regs->configured_flag) == FLAG_CF &&
+			!hibernated) {
+		int	mask = INTR_MASK;
+
+		ehci_prepare_ports_for_controller_resume(ehci);
+
+		spin_lock_irq(&ehci->lock);
+		if (ehci->shutdown)
+			goto skip;
+
+		if (!hcd->self.root_hub->do_remote_wakeup)
+			mask &= ~STS_PCD;
+		ehci_writel(ehci, mask, &ehci->regs->intr_enable);
+		ehci_readl(ehci, &ehci->regs->intr_enable);
+ skip:
+		spin_unlock_irq(&ehci->lock);
+		return 0;
+	}
+
+	/*
+	 * Else reset, to cope with power loss or resume from hibernation
+	 * having let the firmware kick in during reboot.
+	 */
+	usb_root_hub_lost_power(hcd->self.root_hub);
+	(void) ehci_halt(ehci);
+	(void) ehci_reset(ehci);
+
+	spin_lock_irq(&ehci->lock);
+	if (ehci->shutdown)
+		goto skip;
+
+	ehci_writel(ehci, ehci->command, &ehci->regs->command);
+	ehci_writel(ehci, FLAG_CF, &ehci->regs->configured_flag);
+	ehci_readl(ehci, &ehci->regs->command);	/* unblock posted writes */
+
+	ehci->rh_state = EHCI_RH_SUSPENDED;
+	spin_unlock_irq(&ehci->lock);
+
+	return 1;
+}
+EXPORT_SYMBOL_GPL(ehci_resume);
+
+#endif
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * Generic structure: This gets copied for platform drivers so that
+ * individual entries can be overridden as needed.
+ */
+#if 1
+static const struct hc_driver ehci_hc_driver = {
+	.description =		hcd_name,
+	.product_desc =		"EHCI Host Controller",
+	.hcd_priv_size =	sizeof(struct ehci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq =			ehci_irq,
+	.flags =		HCD_MEMORY | HCD_USB2,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.reset =		ehci_setup,
+	.start =		ehci_run,
+	.stop =			ehci_stop,
+	.shutdown =		ehci_shutdown,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue =		ehci_urb_enqueue,
+	.urb_dequeue =		ehci_urb_dequeue,
+	.endpoint_disable =	ehci_endpoint_disable,
+	.endpoint_reset =	ehci_endpoint_reset,
+	.clear_tt_buffer_complete =	ehci_clear_tt_buffer_complete,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number =	ehci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data =	ehci_hub_status_data,
+	.hub_control =		ehci_hub_control,
+	.bus_suspend =		ehci_bus_suspend,
+	.bus_resume =		ehci_bus_resume,
+	.relinquish_port =	ehci_relinquish_port,
+	.port_handed_over =	ehci_port_handed_over,
+};
+
+void ehci_init_driver(struct hc_driver *drv,
+		const struct ehci_driver_overrides *over)
+{
+	/* Copy the generic table to drv and then apply the overrides */
+	*drv = ehci_hc_driver;
+
+	if (over) {
+		drv->hcd_priv_size += over->extra_priv_size;
+		if (over->reset)
+			drv->reset = over->reset;
+	}
+}
+EXPORT_SYMBOL_GPL(ehci_init_driver);
+#endif
+/*-------------------------------------------------------------------------*/
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR (DRIVER_AUTHOR);
+MODULE_LICENSE ("GPL");
+
+#include "ehci-tangox.c"
+
+static int __init ehci_hcd_init(void)
+{
+	unsigned long tangox_chip_id(void);
+	unsigned long chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+	int retval = 0;
+
+#ifdef CONFIG_TANGOX_XENV_READ
+	if (!tangox_usb_enabled())
+		return -ENODEV;
+#endif
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	printk(KERN_INFO "%s: " DRIVER_DESC "\n", EHCI_HCD_NAME);
+	set_bit(USB_EHCI_LOADED, &usb_hcds_loaded);
+	if (test_bit(USB_UHCI_LOADED, &usb_hcds_loaded) ||
+			test_bit(USB_OHCI_LOADED, &usb_hcds_loaded))
+		printk(KERN_WARNING "Warning! ehci_hcd should always be loaded"
+				" before uhci_hcd and ohci_hcd, not after\n");
+
+	pr_debug("%s: block sizes: qh %Zd qtd %Zd itd %Zd sitd %Zd\n",
+		 EHCI_HCD_NAME,
+		 sizeof(struct ehci_qh), sizeof(struct ehci_qtd),
+		 sizeof(struct ehci_itd), sizeof(struct ehci_sitd));
+
+#ifdef DEBUG
+	ehci_debug_root = debugfs_create_dir("ehci", usb_debug_root);
+	if (!ehci_debug_root) {
+		retval = -ENOENT;
+		goto err_debug;
+	}
+#endif
+
+
+		if (((chip_id & 0xfff0) == 0x8670) || ((chip_id & 0xfff0) == 0x8680)) { 
+		if (controller == 0)
+			retval = platform_add_devices( &tangox_platform_devices[0], 1);
+		else if (controller == 1)
+			retval = platform_add_devices( &tangox_platform_devices[1], 1);
+		else
+			retval = platform_add_devices(tangox_platform_devices,
+							ARRAY_SIZE(tangox_platform_devices));
+	} else
+		retval = platform_add_devices(tangox_platform_devices,
+							ARRAY_SIZE(tangox_platform_devices) - 1);
+
+
+	if (retval) {
+		printk("Failed to register tangox ehci platform device .\n");
+		goto clean0;
+	}
+
+	if ((((chip_id & 0xfff0) != 0x8670) && ((chip_id & 0xfff0) != 0x8680)) || (controller != 1)) {
+		retval = platform_driver_register(&ehci_tangox_driver[0]);
+
+		if (retval) {
+			printk("Failed to register tangox ehci platform driver.\n");
+			platform_device_unregister(&tangox_ehci_device[0]);
+			goto clean0;
+		}
+	}
+
+	if ((((chip_id & 0xfff0) == 0x8670) || ((chip_id & 0xfff0) == 0x8680)) && (controller != 0)) {
+		retval = platform_driver_register(&ehci_tangox_driver[1]);
+		if (retval) {
+			platform_driver_unregister(&ehci_tangox_driver[0]);
+			platform_device_unregister(&tangox_ehci_device[0]);
+			printk("Failed to register tangox ehci platform driver.\n");
+			platform_device_unregister(&tangox_ehci_device[1]);
+			goto clean0;
+		}
+	}
+
+	
+	return retval;
+	
+clean0:
+#ifdef DEBUG
+	debugfs_remove(ehci_debug_root);
+	ehci_debug_root = NULL;
+err_debug:
+#endif
+	clear_bit(USB_EHCI_LOADED, &usb_hcds_loaded);
+	return retval;
+}
+module_init(ehci_hcd_init);
+
+static void __exit ehci_hcd_cleanup(void)
+{
+	unsigned long tangox_chip_id(void);
+	unsigned long chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+
+	if ((((chip_id & 0xfff0) != 0x8670) && ((chip_id & 0xfff0) != 0x8680)) || (controller != 1)) {
+		platform_driver_unregister(&ehci_tangox_driver[0]);
+		platform_device_unregister(&tangox_ehci_device[0]);
+	}
+
+	if ((((chip_id & 0xfff0) == 0x8670) || ((chip_id & 0xfff0) == 0x8680)) && (controller != 0)) {
+		platform_driver_unregister(&ehci_tangox_driver[1]);
+		platform_device_unregister(&tangox_ehci_device[1]);
+	}
+#ifdef DEBUG
+	debugfs_remove(ehci_debug_root);
+#endif
+	clear_bit(USB_EHCI_LOADED, &usb_hcds_loaded);
+}
+module_exit(ehci_hcd_cleanup);
diff -Naur linux-3.9.2.ref/drivers/usb/host/tangox-ohci-hcd.c linux-3.9.2/drivers/usb/host/tangox-ohci-hcd.c
--- linux-3.9.2.ref/drivers/usb/host/tangox-ohci-hcd.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/drivers/usb/host/tangox-ohci-hcd.c	2013-07-23 19:31:17.000000000 +0200
@@ -0,0 +1,1169 @@
+/*
+ * Open Host Controller Interface (OHCI) driver for USB.
+ *
+ * Maintainer: Alan Stern <stern@rowland.harvard.edu>
+ *
+ * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
+ * (C) Copyright 2000-2004 David Brownell <dbrownell@users.sourceforge.net>
+ *
+ * [ Initialisation is based on Linus'  ]
+ * [ uhci code and gregs ohci fragments ]
+ * [ (C) Copyright 1999 Linus Torvalds  ]
+ * [ (C) Copyright 1999 Gregory P. Smith]
+ *
+ *
+ * OHCI is the main "non-Intel/VIA" standard for USB 1.1 host controller
+ * interfaces (though some non-x86 Intel chips use it).  It supports
+ * smarter hardware than UHCI.  A download link for the spec available
+ * through the http://www.usb.org website.
+ *
+ * This file is licenced under the GPL.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/usb.h>
+#include <linux/usb/otg.h>
+#include <linux/usb/hcd.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmapool.h>
+#include <linux/workqueue.h>
+#include <linux/debugfs.h>
+
+
+#include "../core/tangox-usb.h"
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/unaligned.h>
+#include <asm/byteorder.h>
+
+
+#define DRIVER_AUTHOR "Roman Weissgaerber, David Brownell"
+#define DRIVER_DESC "USB 1.1 'Open' Host Controller (OHCI) Driver"
+
+/*-------------------------------------------------------------------------*/
+
+#undef OHCI_VERBOSE_DEBUG	/* not always helpful */
+
+/* For initializing controller (mask in an HCFS mode too) */
+#define	OHCI_CONTROL_INIT	OHCI_CTRL_CBSR
+#define	OHCI_INTR_INIT \
+		(OHCI_INTR_MIE | OHCI_INTR_RHSC | OHCI_INTR_UE \
+		| OHCI_INTR_RD | OHCI_INTR_WDH)
+
+#ifdef __hppa__
+/* On PA-RISC, PDC can leave IR set incorrectly; ignore it there. */
+#define	IR_DISABLE
+#endif
+
+#ifdef CONFIG_ARCH_OMAP
+/* OMAP doesn't support IR (no SMM; not needed) */
+#define	IR_DISABLE
+#endif
+
+/*-------------------------------------------------------------------------*/
+
+static const char	hcd_name [] = "ohci_hcd";
+
+#define	STATECHANGE_DELAY	msecs_to_jiffies(300)
+
+#include "ohci.h"
+#include "pci-quirks.h"
+
+static void ohci_dump (struct ohci_hcd *ohci, int verbose);
+static int ohci_init (struct ohci_hcd *ohci);
+static void ohci_stop (struct usb_hcd *hcd);
+
+#if defined(CONFIG_PM) || defined(CONFIG_PCI)
+static int ohci_restart (struct ohci_hcd *ohci);
+#endif
+
+
+static inline void sb800_prefetch(struct ohci_hcd *ohci, int on)
+{
+	return;
+}
+
+
+
+#include "ohci-hub.c"
+#include "ohci-dbg.c"
+#include "ohci-mem.c"
+#include "ohci-q.c"
+
+
+/*
+ * On architectures with edge-triggered interrupts we must never return
+ * IRQ_NONE.
+ */
+#if defined(CONFIG_SA1111)  /* ... or other edge-triggered systems */
+#define IRQ_NOTMINE	IRQ_HANDLED
+#else
+#define IRQ_NOTMINE	IRQ_NONE
+#endif
+
+/* Some boards misreport power switching/overcurrent */
+static bool distrust_firmware = 1;
+module_param (distrust_firmware, bool, 0);
+MODULE_PARM_DESC (distrust_firmware,
+	"true to distrust firmware power/overcurrent setup");
+
+/* Some boards leave IR set wrongly, since they fail BIOS/SMM handshakes */
+static bool no_handshake = 0;
+module_param (no_handshake, bool, 0);
+MODULE_PARM_DESC (no_handshake, "true (not default) disables BIOS handshake");
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * queue up an urb for anything except the root hub
+ */
+static int ohci_urb_enqueue (
+	struct usb_hcd	*hcd,
+	struct urb	*urb,
+	gfp_t		mem_flags
+) {
+	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
+	struct ed	*ed;
+	urb_priv_t	*urb_priv;
+	unsigned int	pipe = urb->pipe;
+	int		i, size = 0;
+	unsigned long	flags;
+	int		retval = 0;
+
+#ifdef OHCI_VERBOSE_DEBUG
+	urb_print(urb, "SUB", usb_pipein(pipe), -EINPROGRESS);
+#endif
+
+	/* every endpoint has a ed, locate and maybe (re)initialize it */
+	if (! (ed = ed_get (ohci, urb->ep, urb->dev, pipe, urb->interval)))
+		return -ENOMEM;
+
+	/* for the private part of the URB we need the number of TDs (size) */
+	switch (ed->type) {
+		case PIPE_CONTROL:
+			/* td_submit_urb() doesn't yet handle these */
+			if (urb->transfer_buffer_length > 4096)
+				return -EMSGSIZE;
+
+			/* 1 TD for setup, 1 for ACK, plus ... */
+			size = 2;
+			/* FALLTHROUGH */
+		// case PIPE_INTERRUPT:
+		// case PIPE_BULK:
+		default:
+			/* one TD for every 4096 Bytes (can be up to 8K) */
+			size += urb->transfer_buffer_length / 4096;
+			/* ... and for any remaining bytes ... */
+			if ((urb->transfer_buffer_length % 4096) != 0)
+				size++;
+			/* ... and maybe a zero length packet to wrap it up */
+			if (size == 0)
+				size++;
+			else if ((urb->transfer_flags & URB_ZERO_PACKET) != 0
+				&& (urb->transfer_buffer_length
+					% usb_maxpacket (urb->dev, pipe,
+						usb_pipeout (pipe))) == 0)
+				size++;
+			break;
+		case PIPE_ISOCHRONOUS: /* number of packets from URB */
+			size = urb->number_of_packets;
+			break;
+	}
+
+	/* allocate the private part of the URB */
+	urb_priv = kzalloc (sizeof (urb_priv_t) + size * sizeof (struct td *),
+			mem_flags);
+	if (!urb_priv)
+		return -ENOMEM;
+	INIT_LIST_HEAD (&urb_priv->pending);
+	urb_priv->length = size;
+	urb_priv->ed = ed;
+
+	/* allocate the TDs (deferring hash chain updates) */
+	for (i = 0; i < size; i++) {
+		urb_priv->td [i] = td_alloc (ohci, mem_flags);
+		if (!urb_priv->td [i]) {
+			urb_priv->length = i;
+			urb_free_priv (ohci, urb_priv);
+			return -ENOMEM;
+		}
+	}
+
+	spin_lock_irqsave (&ohci->lock, flags);
+
+	/* don't submit to a dead HC */
+	if (!HCD_HW_ACCESSIBLE(hcd)) {
+		retval = -ENODEV;
+		goto fail;
+	}
+	if (ohci->rh_state != OHCI_RH_RUNNING) {
+		retval = -ENODEV;
+		goto fail;
+	}
+	retval = usb_hcd_link_urb_to_ep(hcd, urb);
+	if (retval)
+		goto fail;
+
+	/* schedule the ed if needed */
+	if (ed->state == ED_IDLE) {
+		retval = ed_schedule (ohci, ed);
+		if (retval < 0) {
+			usb_hcd_unlink_urb_from_ep(hcd, urb);
+			goto fail;
+		}
+		if (ed->type == PIPE_ISOCHRONOUS) {
+			u16	frame = ohci_frame_no(ohci);
+
+			/* delay a few frames before the first TD */
+			frame += max_t (u16, 8, ed->interval);
+			frame &= ~(ed->interval - 1);
+			frame |= ed->branch;
+			urb->start_frame = frame;
+		}
+	} else if (ed->type == PIPE_ISOCHRONOUS) {
+		u16	next = ohci_frame_no(ohci) + 2;
+		u16	frame = ed->last_iso + ed->interval;
+
+		/* Behind the scheduling threshold? */
+		if (unlikely(tick_before(frame, next))) {
+
+			/* USB_ISO_ASAP: Round up to the first available slot */
+			if (urb->transfer_flags & URB_ISO_ASAP)
+				frame += (next - frame + ed->interval - 1) &
+						-ed->interval;
+
+			/*
+			 * Not ASAP: Use the next slot in the stream.  If
+			 * the entire URB falls before the threshold, fail.
+			 */
+			else if (tick_before(frame + ed->interval *
+					(urb->number_of_packets - 1), next)) {
+				retval = -EXDEV;
+				usb_hcd_unlink_urb_from_ep(hcd, urb);
+				goto fail;
+			}
+
+			/*
+			 * Some OHCI hardware doesn't handle late TDs
+			 * correctly.  After retiring them it proceeds to
+			 * the next ED instead of the next TD.  Therefore
+			 * we have to omit the late TDs entirely.
+			 */
+			urb_priv->td_cnt = DIV_ROUND_UP(next - frame,
+					ed->interval);
+		}
+		urb->start_frame = frame;
+	}
+
+	/* fill the TDs and link them to the ed; and
+	 * enable that part of the schedule, if needed
+	 * and update count of queued periodic urbs
+	 */
+	urb->hcpriv = urb_priv;
+	td_submit_urb (ohci, urb);
+
+fail:
+	if (retval)
+		urb_free_priv (ohci, urb_priv);
+	spin_unlock_irqrestore (&ohci->lock, flags);
+	return retval;
+}
+
+/*
+ * decouple the URB from the HC queues (TDs, urb_priv).
+ * reporting is always done
+ * asynchronously, and we might be dealing with an urb that's
+ * partially transferred, or an ED with other urbs being unlinked.
+ */
+static int ohci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
+{
+	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
+	unsigned long		flags;
+	int			rc;
+
+#ifdef OHCI_VERBOSE_DEBUG
+	urb_print(urb, "UNLINK", 1, status);
+#endif
+
+	spin_lock_irqsave (&ohci->lock, flags);
+	rc = usb_hcd_check_unlink_urb(hcd, urb, status);
+	if (rc) {
+		;	/* Do nothing */
+	} else if (ohci->rh_state == OHCI_RH_RUNNING) {
+		urb_priv_t  *urb_priv;
+
+		/* Unless an IRQ completed the unlink while it was being
+		 * handed to us, flag it for unlink and giveback, and force
+		 * some upcoming INTR_SF to call finish_unlinks()
+		 */
+		urb_priv = urb->hcpriv;
+		if (urb_priv) {
+			if (urb_priv->ed->state == ED_OPER)
+				start_ed_unlink (ohci, urb_priv->ed);
+		}
+	} else {
+		/*
+		 * with HC dead, we won't respect hc queue pointers
+		 * any more ... just clean up every urb's memory.
+		 */
+		if (urb->hcpriv)
+			finish_urb(ohci, urb, status);
+	}
+	spin_unlock_irqrestore (&ohci->lock, flags);
+	return rc;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* frees config/altsetting state for endpoints,
+ * including ED memory, dummy TD, and bulk/intr data toggle
+ */
+
+static void
+ohci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
+{
+	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
+	unsigned long		flags;
+	struct ed		*ed = ep->hcpriv;
+	unsigned		limit = 1000;
+
+	/* ASSERT:  any requests/urbs are being unlinked */
+	/* ASSERT:  nobody can be submitting urbs for this any more */
+
+	if (!ed)
+		return;
+
+rescan:
+	spin_lock_irqsave (&ohci->lock, flags);
+
+	if (ohci->rh_state != OHCI_RH_RUNNING) {
+sanitize:
+		ed->state = ED_IDLE;
+		if (quirk_zfmicro(ohci) && ed->type == PIPE_INTERRUPT)
+			ohci->eds_scheduled--;
+		finish_unlinks (ohci, 0);
+	}
+
+	switch (ed->state) {
+	case ED_UNLINK:		/* wait for hw to finish? */
+		/* major IRQ delivery trouble loses INTR_SF too... */
+		if (limit-- == 0) {
+			ohci_warn(ohci, "ED unlink timeout\n");
+			if (quirk_zfmicro(ohci)) {
+				ohci_warn(ohci, "Attempting ZF TD recovery\n");
+				ohci->ed_to_check = ed;
+				ohci->zf_delay = 2;
+			}
+			goto sanitize;
+		}
+		spin_unlock_irqrestore (&ohci->lock, flags);
+		schedule_timeout_uninterruptible(1);
+		goto rescan;
+	case ED_IDLE:		/* fully unlinked */
+		if (list_empty (&ed->td_list)) {
+			td_free (ohci, ed->dummy);
+			ed_free (ohci, ed);
+			break;
+		}
+		/* else FALL THROUGH */
+	default:
+		/* caller was supposed to have unlinked any requests;
+		 * that's not our job.  can't recover; must leak ed.
+		 */
+		ohci_err (ohci, "leak ed %p (#%02x) state %d%s\n",
+			ed, ep->desc.bEndpointAddress, ed->state,
+			list_empty (&ed->td_list) ? "" : " (has tds)");
+		td_free (ohci, ed->dummy);
+		break;
+	}
+	ep->hcpriv = NULL;
+	spin_unlock_irqrestore (&ohci->lock, flags);
+}
+
+static int ohci_get_frame (struct usb_hcd *hcd)
+{
+	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
+
+	return ohci_frame_no(ohci);
+}
+
+static void ohci_usb_reset (struct ohci_hcd *ohci)
+{
+	ohci->hc_control = ohci_readl (ohci, &ohci->regs->control);
+	ohci->hc_control &= OHCI_CTRL_RWC;
+	ohci_writel (ohci, ohci->hc_control, &ohci->regs->control);
+	ohci->rh_state = OHCI_RH_HALTED;
+}
+
+/* ohci_shutdown forcibly disables IRQs and DMA, helping kexec and
+ * other cases where the next software may expect clean state from the
+ * "firmware".  this is bus-neutral, unlike shutdown() methods.
+ */
+static void
+ohci_shutdown (struct usb_hcd *hcd)
+{
+	struct ohci_hcd *ohci;
+
+	ohci = hcd_to_ohci (hcd);
+	ohci_writel(ohci, (u32) ~0, &ohci->regs->intrdisable);
+
+	/* Software reset, after which the controller goes into SUSPEND */
+	ohci_writel(ohci, OHCI_HCR, &ohci->regs->cmdstatus);
+	ohci_readl(ohci, &ohci->regs->cmdstatus);	/* flush the writes */
+	udelay(10);
+
+	ohci_writel(ohci, ohci->fminterval, &ohci->regs->fminterval);
+}
+
+static int check_ed(struct ohci_hcd *ohci, struct ed *ed)
+{
+	return (hc32_to_cpu(ohci, ed->hwINFO) & ED_IN) != 0
+		&& (hc32_to_cpu(ohci, ed->hwHeadP) & TD_MASK)
+			== (hc32_to_cpu(ohci, ed->hwTailP) & TD_MASK)
+		&& !list_empty(&ed->td_list);
+}
+
+/* ZF Micro watchdog timer callback. The ZF Micro chipset sometimes completes
+ * an interrupt TD but neglects to add it to the donelist.  On systems with
+ * this chipset, we need to periodically check the state of the queues to look
+ * for such "lost" TDs.
+ */
+static void unlink_watchdog_func(unsigned long _ohci)
+{
+	unsigned long	flags;
+	unsigned	max;
+	unsigned	seen_count = 0;
+	unsigned	i;
+	struct ed	**seen = NULL;
+	struct ohci_hcd	*ohci = (struct ohci_hcd *) _ohci;
+
+	spin_lock_irqsave(&ohci->lock, flags);
+	max = ohci->eds_scheduled;
+	if (!max)
+		goto done;
+
+	if (ohci->ed_to_check)
+		goto out;
+
+	seen = kcalloc(max, sizeof *seen, GFP_ATOMIC);
+	if (!seen)
+		goto out;
+
+	for (i = 0; i < NUM_INTS; i++) {
+		struct ed	*ed = ohci->periodic[i];
+
+		while (ed) {
+			unsigned	temp;
+
+			/* scan this branch of the periodic schedule tree */
+			for (temp = 0; temp < seen_count; temp++) {
+				if (seen[temp] == ed) {
+					/* we've checked it and what's after */
+					ed = NULL;
+					break;
+				}
+			}
+			if (!ed)
+				break;
+			seen[seen_count++] = ed;
+			if (!check_ed(ohci, ed)) {
+				ed = ed->ed_next;
+				continue;
+			}
+
+			/* HC's TD list is empty, but HCD sees at least one
+			 * TD that's not been sent through the donelist.
+			 */
+			ohci->ed_to_check = ed;
+			ohci->zf_delay = 2;
+
+			/* The HC may wait until the next frame to report the
+			 * TD as done through the donelist and INTR_WDH.  (We
+			 * just *assume* it's not a multi-TD interrupt URB;
+			 * those could defer the IRQ more than one frame, using
+			 * DI...)  Check again after the next INTR_SF.
+			 */
+			ohci_writel(ohci, OHCI_INTR_SF,
+					&ohci->regs->intrstatus);
+			ohci_writel(ohci, OHCI_INTR_SF,
+					&ohci->regs->intrenable);
+
+			/* flush those writes */
+			(void) ohci_readl(ohci, &ohci->regs->control);
+
+			goto out;
+		}
+	}
+out:
+	kfree(seen);
+	if (ohci->eds_scheduled)
+		mod_timer(&ohci->unlink_watchdog, round_jiffies(jiffies + HZ));
+done:
+	spin_unlock_irqrestore(&ohci->lock, flags);
+}
+
+/*-------------------------------------------------------------------------*
+ * HC functions
+ *-------------------------------------------------------------------------*/
+
+/* init memory, and kick BIOS/SMM off */
+
+static int ohci_init (struct ohci_hcd *ohci)
+{
+	int ret;
+	struct usb_hcd *hcd = ohci_to_hcd(ohci);
+
+	if (distrust_firmware)
+		ohci->flags |= OHCI_QUIRK_HUB_POWER;
+
+	ohci->rh_state = OHCI_RH_HALTED;
+	ohci->regs = hcd->regs;
+
+	/* REVISIT this BIOS handshake is now moved into PCI "quirks", and
+	 * was never needed for most non-PCI systems ... remove the code?
+	 */
+
+#ifndef IR_DISABLE
+	/* SMM owns the HC?  not for long! */
+	if (!no_handshake && ohci_readl (ohci,
+					&ohci->regs->control) & OHCI_CTRL_IR) {
+		u32 temp;
+
+		ohci_dbg (ohci, "USB HC TakeOver from BIOS/SMM\n");
+
+		/* this timeout is arbitrary.  we make it long, so systems
+		 * depending on usb keyboards may be usable even if the
+		 * BIOS/SMM code seems pretty broken.
+		 */
+		temp = 500;	/* arbitrary: five seconds */
+
+		ohci_writel (ohci, OHCI_INTR_OC, &ohci->regs->intrenable);
+		ohci_writel (ohci, OHCI_OCR, &ohci->regs->cmdstatus);
+		while (ohci_readl (ohci, &ohci->regs->control) & OHCI_CTRL_IR) {
+			msleep (10);
+			if (--temp == 0) {
+				ohci_err (ohci, "USB HC takeover failed!"
+					"  (BIOS/SMM bug)\n");
+				return -EBUSY;
+			}
+		}
+		ohci_usb_reset (ohci);
+	}
+#endif
+
+	/* Disable HC interrupts */
+	ohci_writel (ohci, OHCI_INTR_MIE, &ohci->regs->intrdisable);
+
+	/* flush the writes, and save key bits like RWC */
+	if (ohci_readl (ohci, &ohci->regs->control) & OHCI_CTRL_RWC)
+		ohci->hc_control |= OHCI_CTRL_RWC;
+
+	/* Read the number of ports unless overridden */
+	if (ohci->num_ports == 0)
+		ohci->num_ports = roothub_a(ohci) & RH_A_NDP;
+
+	if (ohci->hcca)
+		return 0;
+
+	ohci->hcca = dma_alloc_coherent (hcd->self.controller,
+			sizeof *ohci->hcca, &ohci->hcca_dma, 0);
+	if (!ohci->hcca)
+		return -ENOMEM;
+
+	if ((ret = ohci_mem_init (ohci)) < 0)
+		ohci_stop (hcd);
+	else {
+		create_debug_files (ohci);
+	}
+
+	return ret;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* Start an OHCI controller, set the BUS operational
+ * resets USB and controller
+ * enable interrupts
+ */
+static int ohci_run (struct ohci_hcd *ohci)
+{
+	u32			mask, val;
+	int			first = ohci->fminterval == 0;
+	struct usb_hcd		*hcd = ohci_to_hcd(ohci);
+
+	ohci->rh_state = OHCI_RH_HALTED;
+
+	/* boot firmware should have set this up (5.1.1.3.1) */
+	if (first) {
+
+		val = ohci_readl (ohci, &ohci->regs->fminterval);
+		ohci->fminterval = val & 0x3fff;
+		if (ohci->fminterval != FI)
+			ohci_dbg (ohci, "fminterval delta %d\n",
+				ohci->fminterval - FI);
+		ohci->fminterval |= FSMP (ohci->fminterval) << 16;
+		/* also: power/overcurrent flags in roothub.a */
+	}
+
+	/* Reset USB nearly "by the book".  RemoteWakeupConnected has
+	 * to be checked in case boot firmware (BIOS/SMM/...) has set up
+	 * wakeup in a way the bus isn't aware of (e.g., legacy PCI PM).
+	 * If the bus glue detected wakeup capability then it should
+	 * already be enabled; if so we'll just enable it again.
+	 */
+	if ((ohci->hc_control & OHCI_CTRL_RWC) != 0)
+		device_set_wakeup_capable(hcd->self.controller, 1);
+
+	switch (ohci->hc_control & OHCI_CTRL_HCFS) {
+	case OHCI_USB_OPER:
+		val = 0;
+		break;
+	case OHCI_USB_SUSPEND:
+	case OHCI_USB_RESUME:
+		ohci->hc_control &= OHCI_CTRL_RWC;
+		ohci->hc_control |= OHCI_USB_RESUME;
+		val = 10 /* msec wait */;
+		break;
+	// case OHCI_USB_RESET:
+	default:
+		ohci->hc_control &= OHCI_CTRL_RWC;
+		ohci->hc_control |= OHCI_USB_RESET;
+		val = 50 /* msec wait */;
+		break;
+	}
+	ohci_writel (ohci, ohci->hc_control, &ohci->regs->control);
+	// flush the writes
+	(void) ohci_readl (ohci, &ohci->regs->control);
+	msleep(val);
+
+	memset (ohci->hcca, 0, sizeof (struct ohci_hcca));
+
+	/* 2msec timelimit here means no irqs/preempt */
+	spin_lock_irq (&ohci->lock);
+
+retry:
+	/* HC Reset requires max 10 us delay */
+	ohci_writel (ohci, OHCI_HCR,  &ohci->regs->cmdstatus);
+	val = 30;	/* ... allow extra time */
+	while ((ohci_readl (ohci, &ohci->regs->cmdstatus) & OHCI_HCR) != 0) {
+		if (--val == 0) {
+			spin_unlock_irq (&ohci->lock);
+			ohci_err (ohci, "USB HC reset timed out!\n");
+			return -1;
+		}
+		udelay (1);
+	}
+
+	/* now we're in the SUSPEND state ... must go OPERATIONAL
+	 * within 2msec else HC enters RESUME
+	 *
+	 * ... but some hardware won't init fmInterval "by the book"
+	 * (SiS, OPTi ...), so reset again instead.  SiS doesn't need
+	 * this if we write fmInterval after we're OPERATIONAL.
+	 * Unclear about ALi, ServerWorks, and others ... this could
+	 * easily be a longstanding bug in chip init on Linux.
+	 */
+	if (ohci->flags & OHCI_QUIRK_INITRESET) {
+		ohci_writel (ohci, ohci->hc_control, &ohci->regs->control);
+		// flush those writes
+		(void) ohci_readl (ohci, &ohci->regs->control);
+	}
+
+	/* Tell the controller where the control and bulk lists are
+	 * The lists are empty now. */
+	ohci_writel (ohci, 0, &ohci->regs->ed_controlhead);
+	ohci_writel (ohci, 0, &ohci->regs->ed_bulkhead);
+
+	/* a reset clears this */
+	ohci_writel (ohci, (u32) ohci->hcca_dma, &ohci->regs->hcca);
+
+	periodic_reinit (ohci);
+
+	/* some OHCI implementations are finicky about how they init.
+	 * bogus values here mean not even enumeration could work.
+	 */
+	if ((ohci_readl (ohci, &ohci->regs->fminterval) & 0x3fff0000) == 0
+			|| !ohci_readl (ohci, &ohci->regs->periodicstart)) {
+		if (!(ohci->flags & OHCI_QUIRK_INITRESET)) {
+			ohci->flags |= OHCI_QUIRK_INITRESET;
+			ohci_dbg (ohci, "enabling initreset quirk\n");
+			goto retry;
+		}
+		spin_unlock_irq (&ohci->lock);
+		ohci_err (ohci, "init err (%08x %04x)\n",
+			ohci_readl (ohci, &ohci->regs->fminterval),
+			ohci_readl (ohci, &ohci->regs->periodicstart));
+		return -EOVERFLOW;
+	}
+
+	/* use rhsc irqs after khubd is fully initialized */
+	set_bit(HCD_FLAG_POLL_RH, &hcd->flags);
+	hcd->uses_new_polling = 1;
+
+	/* start controller operations */
+	ohci->hc_control &= OHCI_CTRL_RWC;
+	ohci->hc_control |= OHCI_CONTROL_INIT | OHCI_USB_OPER;
+	ohci_writel (ohci, ohci->hc_control, &ohci->regs->control);
+	ohci->rh_state = OHCI_RH_RUNNING;
+
+	/* wake on ConnectStatusChange, matching external hubs */
+	ohci_writel (ohci, RH_HS_DRWE, &ohci->regs->roothub.status);
+
+	/* Choose the interrupts we care about now, others later on demand */
+	mask = OHCI_INTR_INIT;
+	ohci_writel (ohci, ~0, &ohci->regs->intrstatus);
+	ohci_writel (ohci, mask, &ohci->regs->intrenable);
+
+	/* handle root hub init quirks ... */
+	val = roothub_a (ohci);
+	val &= ~(RH_A_PSM | RH_A_OCPM);
+	if (ohci->flags & OHCI_QUIRK_SUPERIO) {
+		/* NSC 87560 and maybe others */
+		val |= RH_A_NOCP;
+		val &= ~(RH_A_POTPGT | RH_A_NPS);
+		ohci_writel (ohci, val, &ohci->regs->roothub.a);
+	} else if ((ohci->flags & OHCI_QUIRK_AMD756) ||
+			(ohci->flags & OHCI_QUIRK_HUB_POWER)) {
+		/* hub power always on; required for AMD-756 and some
+		 * Mac platforms.  ganged overcurrent reporting, if any.
+		 */
+		val |= RH_A_NPS;
+		ohci_writel (ohci, val, &ohci->regs->roothub.a);
+	}
+	ohci_writel (ohci, RH_HS_LPSC, &ohci->regs->roothub.status);
+	ohci_writel (ohci, (val & RH_A_NPS) ? 0 : RH_B_PPCM,
+						&ohci->regs->roothub.b);
+	// flush those writes
+	(void) ohci_readl (ohci, &ohci->regs->control);
+
+	ohci->next_statechange = jiffies + STATECHANGE_DELAY;
+	spin_unlock_irq (&ohci->lock);
+
+	// POTPGT delay is bits 24-31, in 2 ms units.
+	mdelay ((val >> 23) & 0x1fe);
+
+	if (quirk_zfmicro(ohci)) {
+		/* Create timer to watch for bad queue state on ZF Micro */
+		setup_timer(&ohci->unlink_watchdog, unlink_watchdog_func,
+				(unsigned long) ohci);
+
+		ohci->eds_scheduled = 0;
+		ohci->ed_to_check = NULL;
+	}
+
+	ohci_dump (ohci, 1);
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* an interrupt happens */
+
+static irqreturn_t ohci_irq (struct usb_hcd *hcd)
+{
+	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
+	struct ohci_regs __iomem *regs = ohci->regs;
+	int			ints;
+
+	/* Read interrupt status (and flush pending writes).  We ignore the
+	 * optimization of checking the LSB of hcca->done_head; it doesn't
+	 * work on all systems (edge triggering for OHCI can be a factor).
+	 */
+	ints = ohci_readl(ohci, &regs->intrstatus);
+
+	/* Check for an all 1's result which is a typical consequence
+	 * of dead, unclocked, or unplugged (CardBus...) devices
+	 */
+	if (ints == ~(u32)0) {
+		ohci->rh_state = OHCI_RH_HALTED;
+		ohci_dbg (ohci, "device removed!\n");
+		usb_hc_died(hcd);
+		return IRQ_HANDLED;
+	}
+
+	/* We only care about interrupts that are enabled */
+	ints &= ohci_readl(ohci, &regs->intrenable);
+
+	/* interrupt for some other device? */
+	if (ints == 0 || unlikely(ohci->rh_state == OHCI_RH_HALTED))
+		return IRQ_NOTMINE;
+			
+	if (ints & OHCI_INTR_UE) {
+		// e.g. due to PCI Master/Target Abort
+		if (quirk_nec(ohci)) {
+			/* Workaround for a silicon bug in some NEC chips used
+			 * in Apple's PowerBooks. Adapted from Darwin code.
+			 */
+			ohci_err (ohci, "OHCI Unrecoverable Error, scheduling NEC chip restart\n");
+
+			ohci_writel (ohci, OHCI_INTR_UE, &regs->intrdisable);
+
+			schedule_work (&ohci->nec_work);
+		} else {
+			ohci_err (ohci, "OHCI Unrecoverable Error, disabled\n");
+			ohci->rh_state = OHCI_RH_HALTED;
+			usb_hc_died(hcd);
+		}
+
+		ohci_dump (ohci, 1);
+		ohci_usb_reset (ohci);
+	}
+
+	if (ints & OHCI_INTR_RHSC) {
+		ohci_vdbg(ohci, "rhsc\n");
+		ohci->next_statechange = jiffies + STATECHANGE_DELAY;
+		ohci_writel(ohci, OHCI_INTR_RD | OHCI_INTR_RHSC,
+				&regs->intrstatus);
+
+		/* NOTE: Vendors didn't always make the same implementation
+		 * choices for RHSC.  Many followed the spec; RHSC triggers
+		 * on an edge, like setting and maybe clearing a port status
+		 * change bit.  With others it's level-triggered, active
+		 * until khubd clears all the port status change bits.  We'll
+		 * always disable it here and rely on polling until khubd
+		 * re-enables it.
+		 */
+		ohci_writel(ohci, OHCI_INTR_RHSC, &regs->intrdisable);
+		usb_hcd_poll_rh_status(hcd);
+	}
+
+	/* For connect and disconnect events, we expect the controller
+	 * to turn on RHSC along with RD.  But for remote wakeup events
+	 * this might not happen.
+	 */
+	else if (ints & OHCI_INTR_RD) {
+		ohci_vdbg(ohci, "resume detect\n");
+		ohci_writel(ohci, OHCI_INTR_RD, &regs->intrstatus);
+		set_bit(HCD_FLAG_POLL_RH, &hcd->flags);
+		if (ohci->autostop) {
+			spin_lock (&ohci->lock);
+			ohci_rh_resume (ohci);
+			spin_unlock (&ohci->lock);
+		} else
+			usb_hcd_resume_root_hub(hcd);
+	}
+
+	if (ints & OHCI_INTR_WDH) {
+		spin_lock (&ohci->lock);
+		dl_done_list (ohci);
+		spin_unlock (&ohci->lock);
+	}
+
+	if (quirk_zfmicro(ohci) && (ints & OHCI_INTR_SF)) {
+		spin_lock(&ohci->lock);
+		if (ohci->ed_to_check) {
+			struct ed *ed = ohci->ed_to_check;
+
+			if (check_ed(ohci, ed)) {
+				/* HC thinks the TD list is empty; HCD knows
+				 * at least one TD is outstanding
+				 */
+				if (--ohci->zf_delay == 0) {
+					struct td *td = list_entry(
+						ed->td_list.next,
+						struct td, td_list);
+					ohci_warn(ohci,
+						  "Reclaiming orphan TD %p\n",
+						  td);
+					takeback_td(ohci, td);
+					ohci->ed_to_check = NULL;
+				}
+			} else
+				ohci->ed_to_check = NULL;
+		}
+		spin_unlock(&ohci->lock);
+	}
+
+	/* could track INTR_SO to reduce available PCI/... bandwidth */
+
+	/* handle any pending URB/ED unlinks, leaving INTR_SF enabled
+	 * when there's still unlinking to be done (next frame).
+	 */
+	spin_lock (&ohci->lock);
+	if (ohci->ed_rm_list)
+		finish_unlinks (ohci, ohci_frame_no(ohci));
+	if ((ints & OHCI_INTR_SF) != 0
+			&& !ohci->ed_rm_list
+			&& !ohci->ed_to_check
+			&& ohci->rh_state == OHCI_RH_RUNNING)
+		ohci_writel (ohci, OHCI_INTR_SF, &regs->intrdisable);
+	spin_unlock (&ohci->lock);
+
+	if (ohci->rh_state == OHCI_RH_RUNNING) {
+		ohci_writel (ohci, ints, &regs->intrstatus);
+		ohci_writel (ohci, OHCI_INTR_MIE, &regs->intrenable);
+		// flush those writes
+		(void) ohci_readl (ohci, &ohci->regs->control);
+	}
+
+	return IRQ_HANDLED;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static void ohci_stop (struct usb_hcd *hcd)
+{
+	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
+
+	ohci_dump (ohci, 1);
+
+	if (quirk_nec(ohci))
+		flush_work(&ohci->nec_work);
+
+	ohci_usb_reset (ohci);
+	ohci_writel (ohci, OHCI_INTR_MIE, &ohci->regs->intrdisable);
+	free_irq(hcd->irq, hcd);
+	hcd->irq = 0;
+
+	if (quirk_zfmicro(ohci))
+		del_timer(&ohci->unlink_watchdog);
+	if (quirk_amdiso(ohci))
+		usb_amd_dev_put();
+
+	remove_debug_files (ohci);
+	ohci_mem_cleanup (ohci);
+	if (ohci->hcca) {
+		dma_free_coherent (hcd->self.controller,
+				sizeof *ohci->hcca,
+				ohci->hcca, ohci->hcca_dma);
+		ohci->hcca = NULL;
+		ohci->hcca_dma = 0;
+	}
+}
+
+/*-------------------------------------------------------------------------*/
+
+#if defined(CONFIG_PM) || defined(CONFIG_PCI)
+
+/* must not be called from interrupt context */
+static int ohci_restart (struct ohci_hcd *ohci)
+{
+	int temp;
+	int i;
+	struct urb_priv *priv;
+
+	spin_lock_irq(&ohci->lock);
+	ohci->rh_state = OHCI_RH_HALTED;
+
+	/* Recycle any "live" eds/tds (and urbs). */
+	if (!list_empty (&ohci->pending))
+		ohci_dbg(ohci, "abort schedule...\n");
+	list_for_each_entry (priv, &ohci->pending, pending) {
+		struct urb	*urb = priv->td[0]->urb;
+		struct ed	*ed = priv->ed;
+
+		switch (ed->state) {
+		case ED_OPER:
+			ed->state = ED_UNLINK;
+			ed->hwINFO |= cpu_to_hc32(ohci, ED_DEQUEUE);
+			ed_deschedule (ohci, ed);
+
+			ed->ed_next = ohci->ed_rm_list;
+			ed->ed_prev = NULL;
+			ohci->ed_rm_list = ed;
+			/* FALLTHROUGH */
+		case ED_UNLINK:
+			break;
+		default:
+			ohci_dbg(ohci, "bogus ed %p state %d\n",
+					ed, ed->state);
+		}
+
+		if (!urb->unlinked)
+			urb->unlinked = -ESHUTDOWN;
+	}
+	finish_unlinks (ohci, 0);
+	spin_unlock_irq(&ohci->lock);
+
+	/* paranoia, in case that didn't work: */
+
+	/* empty the interrupt branches */
+	for (i = 0; i < NUM_INTS; i++) ohci->load [i] = 0;
+	for (i = 0; i < NUM_INTS; i++) ohci->hcca->int_table [i] = 0;
+
+	/* no EDs to remove */
+	ohci->ed_rm_list = NULL;
+
+	/* empty control and bulk lists */
+	ohci->ed_controltail = NULL;
+	ohci->ed_bulktail    = NULL;
+
+	if ((temp = ohci_run (ohci)) < 0) {
+		ohci_err (ohci, "can't restart, %d\n", temp);
+		return temp;
+	}
+	ohci_dbg(ohci, "restart complete\n");
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_PM
+
+static int __maybe_unused ohci_suspend(struct usb_hcd *hcd, bool do_wakeup)
+{
+	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
+	unsigned long	flags;
+
+	/* Disable irq emission and mark HW unaccessible. Use
+	 * the spinlock to properly synchronize with possible pending
+	 * RH suspend or resume activity.
+	 */
+	spin_lock_irqsave (&ohci->lock, flags);
+	ohci_writel(ohci, OHCI_INTR_MIE, &ohci->regs->intrdisable);
+	(void)ohci_readl(ohci, &ohci->regs->intrdisable);
+
+	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+	spin_unlock_irqrestore (&ohci->lock, flags);
+
+	return 0;
+}
+
+
+static int __maybe_unused ohci_resume(struct usb_hcd *hcd, bool hibernated)
+{
+	struct ohci_hcd		*ohci = hcd_to_ohci(hcd);
+	int			port;
+	bool			need_reinit = false;
+
+	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+
+	/* Make sure resume from hibernation re-enumerates everything */
+	if (hibernated)
+		ohci_usb_reset(ohci);
+
+	/* See if the controller is already running or has been reset */
+	ohci->hc_control = ohci_readl(ohci, &ohci->regs->control);
+	if (ohci->hc_control & (OHCI_CTRL_IR | OHCI_SCHED_ENABLES)) {
+		need_reinit = true;
+	} else {
+		switch (ohci->hc_control & OHCI_CTRL_HCFS) {
+		case OHCI_USB_OPER:
+		case OHCI_USB_RESET:
+			need_reinit = true;
+		}
+	}
+
+	/* If needed, reinitialize and suspend the root hub */
+	if (need_reinit) {
+		spin_lock_irq(&ohci->lock);
+		ohci_rh_resume(ohci);
+		ohci_rh_suspend(ohci, 0);
+		spin_unlock_irq(&ohci->lock);
+	}
+
+	/* Normally just turn on port power and enable interrupts */
+	else {
+		ohci_dbg(ohci, "powerup ports\n");
+		for (port = 0; port < ohci->num_ports; port++)
+			ohci_writel(ohci, RH_PS_PPS,
+					&ohci->regs->roothub.portstatus[port]);
+
+		ohci_writel(ohci, OHCI_INTR_MIE, &ohci->regs->intrenable);
+		ohci_readl(ohci, &ohci->regs->intrenable);
+		msleep(20);
+	}
+
+	usb_hcd_resume_root_hub(hcd);
+
+	return 0;
+}
+
+#endif
+
+/*-------------------------------------------------------------------------*/
+
+MODULE_AUTHOR (DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE ("GPL");
+
+#include "ohci-tangox.c"
+
+
+static int __init ohci_hcd_mod_init(void)
+{
+	unsigned long tangox_chip_id(void);
+	unsigned long chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+	int retval = 0;
+
+	if (usb_disabled())
+		return -ENODEV;
+
+#ifdef CONFIG_TANGOX_XENV_READ
+	if (!tangox_usb_enabled())
+		return -ENODEV;
+#endif
+	if ((chip_id == 0x8652) || (chip_id == 0x8646) || ((chip_id & 0xfff0) == 0x8670) || ((chip_id & 0xfff0) == 0x8680)) {
+		printk("No OHCI in SMP8652/SMP8653/SMP8646/SMP8647/SMP867X/SMP868X.\n");
+		return -ENODEV;
+	}
+	
+	printk(KERN_INFO "%s: " DRIVER_DESC "\n", hcd_name);
+	pr_debug ("%s: block sizes: ed %Zd td %Zd\n", hcd_name,
+		sizeof (struct ed), sizeof (struct td));
+	set_bit(USB_OHCI_LOADED, &usb_hcds_loaded);
+
+#ifdef DEBUG
+	ohci_debug_root = debugfs_create_dir("ohci", usb_debug_root);
+	if (!ohci_debug_root) {
+		retval = -ENOENT;
+		goto error_debug;
+	}
+#endif
+
+    retval = platform_add_devices(tangox_platform_devices,
+                             ARRAY_SIZE(tangox_platform_devices));
+	if(retval){
+		printk("Failed to register tangox ohci platform device .\n");
+		goto error_platform;
+	}
+
+	printk (KERN_DEBUG "%s: " DRIVER_DESC "\n", OHCI_HCD_NAME);
+	pr_debug ("%s: block sizes: ed %Zd td %Zd\n", OHCI_HCD_NAME,
+		sizeof (struct ed), sizeof (struct td));
+
+	retval = platform_driver_register(&tangox_ohci_driver);
+	if(retval){
+		printk("Failed to register tangox ohci platform driver.\n");
+		platform_device_unregister(&tangox_ohci_device);
+		goto error_platform;
+	}
+
+	return retval;
+
+error_platform:
+#ifdef DEBUG
+	debugfs_remove(ohci_debug_root);
+	ohci_debug_root = NULL;
+ error_debug:
+#endif
+
+	clear_bit(USB_OHCI_LOADED, &usb_hcds_loaded);
+	return retval;
+}
+module_init(ohci_hcd_mod_init);
+
+static void __exit ohci_hcd_mod_exit(void)
+{
+	platform_driver_unregister(&tangox_ohci_driver);
+	platform_device_unregister(&tangox_ohci_device);
+#ifdef DEBUG
+	debugfs_remove(ohci_debug_root);
+#endif
+	clear_bit(USB_OHCI_LOADED, &usb_hcds_loaded);
+}
+module_exit(ohci_hcd_mod_exit);
+
diff -Naur linux-3.9.2.ref/drivers/usb/Kconfig linux-3.9.2/drivers/usb/Kconfig
--- linux-3.9.2.ref/drivers/usb/Kconfig	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/drivers/usb/Kconfig	2013-07-23 19:31:17.000000000 +0200
@@ -25,6 +25,8 @@
 	# MIPS:
 	default y if MIPS_ALCHEMY
 	default y if MACH_JZ4740
+	default y if TANGO3	
+	default y if TANGO2
 	# more:
 	default PCI
 
@@ -49,6 +51,7 @@
 	default y if ARCH_MMP
 	default y if MACH_LOONGSON1
 	default y if PLAT_ORION
+	default y if TANGOX	
 	default PCI
 
 # some non-PCI HCDs implement xHCI
@@ -83,6 +86,7 @@
 	default y if ARM				# SL-811
 	default y if BLACKFIN				# SL-811
 	default y if SUPERH				# r8a66597-hcd
+	default y if TANGOX	
 	default PCI
 
 # ARM SA1111 chips have a non-PCI based "OHCI-compatible" USB host interface.
diff -Naur linux-3.9.2.ref/drivers/usb/Makefile linux-3.9.2/drivers/usb/Makefile
--- linux-3.9.2.ref/drivers/usb/Makefile	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/drivers/usb/Makefile	2013-07-23 19:31:17.000000000 +0200
@@ -27,6 +27,8 @@
 obj-$(CONFIG_USB_ISP1760_HCD)	+= host/
 obj-$(CONFIG_USB_IMX21_HCD)	+= host/
 obj-$(CONFIG_USB_FSL_MPH_DR_OF)	+= host/
+obj-$(CONFIG_TANGOX_EHCI_HCD)   += host/
+obj-$(CONFIG_TANGOX_OHCI_HCD)   += host/
 
 obj-$(CONFIG_USB_C67X00_HCD)	+= c67x00/
 
diff -Naur linux-3.9.2.ref/drivers/usb/storage/Kconfig linux-3.9.2/drivers/usb/storage/Kconfig
--- linux-3.9.2.ref/drivers/usb/storage/Kconfig	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/drivers/usb/storage/Kconfig	2013-07-23 19:31:17.000000000 +0200
@@ -24,6 +24,14 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called usb-storage.
 
+config USB_STORAGE_DELAY_USE
+	int "Delay use (in seconds)"
+	default "5"
+	depends on USB_STORAGE
+	help
+	  The delay (in seconds) needed before making use of mass storage 
+          device once it has been detected.
+
 config USB_STORAGE_DEBUG
 	bool "USB Mass Storage verbose debug"
 	depends on USB_STORAGE
diff -Naur linux-3.9.2.ref/drivers/usb/storage/usb.c linux-3.9.2/drivers/usb/storage/usb.c
--- linux-3.9.2.ref/drivers/usb/storage/usb.c	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/drivers/usb/storage/usb.c	2013-07-23 19:31:17.000000000 +0200
@@ -78,7 +78,11 @@
 MODULE_DESCRIPTION("USB Mass Storage driver for Linux");
 MODULE_LICENSE("GPL");
 
-static unsigned int delay_use = 1;
+#ifdef CONFIG_USB_STORAGE_DELAY_USE
+static unsigned int delay_use = CONFIG_USB_STORAGE_DELAY_USE;
+#else
+static unsigned int delay_use = 5;
+#endif
 module_param(delay_use, uint, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(delay_use, "seconds to delay before using a new device");
 
diff -Naur linux-3.9.2.ref/drivers/video/Kconfig linux-3.9.2/drivers/video/Kconfig
--- linux-3.9.2.ref/drivers/video/Kconfig	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/drivers/video/Kconfig	2013-07-23 19:31:15.000000000 +0200
@@ -123,7 +123,7 @@
 config FB_CFB_FILLRECT
 	tristate
 	depends on FB
-	default n
+	default FB
 	---help---
 	  Include the cfb_fillrect function for generic software rectangle
 	  filling. This is used by drivers that don't provide their own
@@ -132,7 +132,7 @@
 config FB_CFB_COPYAREA
 	tristate
 	depends on FB
-	default n
+	default FB
 	---help---
 	  Include the cfb_copyarea function for generic software area copying.
 	  This is used by drivers that don't provide their own (accelerated)
@@ -141,7 +141,7 @@
 config FB_CFB_IMAGEBLIT
 	tristate
 	depends on FB
-	default n
+	default FB
 	---help---
 	  Include the cfb_imageblit function for generic software image
 	  blitting. This is used by drivers that don't provide their own
@@ -223,6 +223,7 @@
 config FB_DEFERRED_IO
 	bool
 	depends on FB
+	default n
 
 config FB_HECUBA
 	tristate
diff -Naur linux-3.9.2.ref/fs/nls/nls_ascii.c linux-3.9.2/fs/nls/nls_ascii.c
--- linux-3.9.2.ref/fs/nls/nls_ascii.c	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/fs/nls/nls_ascii.c	2013-07-23 19:31:31.000000000 +0200
@@ -12,6 +12,7 @@
 #include <linux/string.h>
 #include <linux/nls.h>
 #include <linux/errno.h>
+#include <asm/unaligned.h>
 
 static const wchar_t charset2uni[256] = {
 	/* 0x00*/
@@ -136,8 +137,8 @@
 
 static int char2uni(const unsigned char *rawstring, int boundlen, wchar_t *uni)
 {
-	*uni = charset2uni[*rawstring];
-	if (*uni == 0x0000)
+	put_unaligned((wchar_t)charset2uni[*rawstring], uni);
+	if (get_unaligned(uni) == 0x0000)
 		return -EINVAL;
 	return 1;
 }
diff -Naur linux-3.9.2.ref/fs/nls/nls_base.c linux-3.9.2/fs/nls/nls_base.c
--- linux-3.9.2.ref/fs/nls/nls_base.c	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/fs/nls/nls_base.c	2013-07-23 19:31:31.000000000 +0200
@@ -16,6 +16,7 @@
 #include <linux/kmod.h>
 #include <linux/spinlock.h>
 #include <asm/byteorder.h>
+#include <asm/unaligned.h>
 
 static struct nls_table default_table;
 static struct nls_table *tables = &default_table;
@@ -512,8 +513,8 @@
 
 static int char2uni(const unsigned char *rawstring, int boundlen, wchar_t *uni)
 {
-	*uni = charset2uni[*rawstring];
-	if (*uni == 0x0000)
+	put_unaligned((wchar_t)charset2uni[*rawstring], uni);
+	if (get_unaligned(uni) == 0x0000)
 		return -EINVAL;
 	return 1;
 }
diff -Naur linux-3.9.2.ref/fs/nls/nls_cp437.c linux-3.9.2/fs/nls/nls_cp437.c
--- linux-3.9.2.ref/fs/nls/nls_cp437.c	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/fs/nls/nls_cp437.c	2013-07-23 19:31:31.000000000 +0200
@@ -12,6 +12,7 @@
 #include <linux/string.h>
 #include <linux/nls.h>
 #include <linux/errno.h>
+#include <asm/unaligned.h>
 
 static const wchar_t charset2uni[256] = {
 	/* 0x00*/
@@ -357,8 +358,8 @@
 
 static int char2uni(const unsigned char *rawstring, int boundlen, wchar_t *uni)
 {
-	*uni = charset2uni[*rawstring];
-	if (*uni == 0x0000)
+	put_unaligned((wchar_t)charset2uni[*rawstring], uni);
+	if (get_unaligned(uni) == 0x0000)
 		return -EINVAL;
 	return 1;
 }
diff -Naur linux-3.9.2.ref/fs/nls/nls_iso8859-1.c linux-3.9.2/fs/nls/nls_iso8859-1.c
--- linux-3.9.2.ref/fs/nls/nls_iso8859-1.c	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/fs/nls/nls_iso8859-1.c	2013-07-23 19:31:31.000000000 +0200
@@ -12,6 +12,7 @@
 #include <linux/string.h>
 #include <linux/nls.h>
 #include <linux/errno.h>
+#include <asm/unaligned.h>
 
 static const wchar_t charset2uni[256] = {
 	/* 0x00*/
@@ -227,8 +228,8 @@
 
 static int char2uni(const unsigned char *rawstring, int boundlen, wchar_t *uni)
 {
-	*uni = charset2uni[*rawstring];
-	if (*uni == 0x0000)
+	put_unaligned((wchar_t)charset2uni[*rawstring], uni);
+	if (get_unaligned(uni) == 0x0000)
 		return -EINVAL;
 	return 1;
 }
diff -Naur linux-3.9.2.ref/fs/nls/nls_utf8.c linux-3.9.2/fs/nls/nls_utf8.c
--- linux-3.9.2.ref/fs/nls/nls_utf8.c	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/fs/nls/nls_utf8.c	2013-07-23 19:31:31.000000000 +0200
@@ -8,6 +8,7 @@
 #include <linux/string.h>
 #include <linux/nls.h>
 #include <linux/errno.h>
+#include <asm/unaligned.h>
 
 static unsigned char identity[256];
 
@@ -33,10 +34,10 @@
 
 	n = utf8_to_utf32(rawstring, boundlen, &u);
 	if (n < 0 || u > MAX_WCHAR_T) {
-		*uni = 0x003f;	/* ? */
+		put_unaligned((wchar_t)0x003f, uni); /* ? */
 		return -EINVAL;
 	}
-	*uni = (wchar_t) u;
+	put_unaligned((wchar_t)u, uni); /* ? */
 	return n;
 }
 
diff -Naur linux-3.9.2.ref/include/asm-generic/pci-dma-compat.h linux-3.9.2/include/asm-generic/pci-dma-compat.h
--- linux-3.9.2.ref/include/asm-generic/pci-dma-compat.h	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/include/asm-generic/pci-dma-compat.h	2013-07-23 19:31:33.000000000 +0200
@@ -102,6 +102,10 @@
 }
 
 #ifdef CONFIG_PCI
+#ifdef CONFIG_TANGOX
+extern int pci_set_dma_mask(struct pci_dev *dev, u64 mask);
+extern int pci_set_consistent_dma_mask(struct pci_dev *dev, u64 mask);
+#else
 static inline int pci_set_dma_mask(struct pci_dev *dev, u64 mask)
 {
 	return dma_set_mask(&dev->dev, mask);
@@ -112,5 +116,6 @@
 	return dma_set_coherent_mask(&dev->dev, mask);
 }
 #endif
+#endif
 
 #endif
diff -Naur linux-3.9.2.ref/include/linux/jiffies.h linux-3.9.2/include/linux/jiffies.h
--- linux-3.9.2.ref/include/linux/jiffies.h	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/include/linux/jiffies.h	2013-07-23 19:31:34.000000000 +0200
@@ -160,7 +160,11 @@
  * Have the 32 bit jiffies value wrap 5 minutes after boot
  * so jiffies wrap bugs show up earlier.
  */
+#if defined(CONFIG_PRINTK_TIME)
+#define INITIAL_JIFFIES 0
+#else
 #define INITIAL_JIFFIES ((unsigned long)(unsigned int) (-300*HZ))
+#endif
 
 /*
  * Change timeval to jiffies, trying to avoid the
diff -Naur linux-3.9.2.ref/include/linux/netfilter/nf_conntrack_pptp.h linux-3.9.2/include/linux/netfilter/nf_conntrack_pptp.h
--- linux-3.9.2.ref/include/linux/netfilter/nf_conntrack_pptp.h	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/include/linux/netfilter/nf_conntrack_pptp.h	2013-07-23 19:31:34.000000000 +0200
@@ -57,7 +57,7 @@
 	__u16	packetLength;
 	__be16	packetType;
 	__be32	magicCookie;
-};
+} __attribute__ ((packed));
 
 /* PptpControlMessageType values */
 #define PPTP_START_SESSION_REQUEST	1
diff -Naur linux-3.9.2.ref/include/linux/netfilter/nf_conntrack_proto_gre.h linux-3.9.2/include/linux/netfilter/nf_conntrack_proto_gre.h
--- linux-3.9.2.ref/include/linux/netfilter/nf_conntrack_proto_gre.h	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/include/linux/netfilter/nf_conntrack_proto_gre.h	2013-07-23 19:31:34.000000000 +0200
@@ -50,7 +50,7 @@
 #error "Adjust your <asm/byteorder.h> defines"
 #endif
 	__be16	protocol;
-};
+} __attribute__ ((packed));
 
 /* modified GRE header for PPTP */
 struct gre_hdr_pptp {
@@ -62,7 +62,7 @@
 	__be32 seq;		/* sequence number.  Present if S==1 */
 	__be32 ack;		/* seq number of highest packet received by */
 				/*  sender in this session */
-};
+} __attribute__ ((packed));
 
 struct nf_ct_gre {
 	unsigned int stream_timeout;
diff -Naur linux-3.9.2.ref/include/linux/tcp.h linux-3.9.2/include/linux/tcp.h
--- linux-3.9.2.ref/include/linux/tcp.h	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/include/linux/tcp.h	2013-07-23 19:31:34.000000000 +0200
@@ -65,12 +65,12 @@
 struct tcp_sack_block_wire {
 	__be32	start_seq;
 	__be32	end_seq;
-};
+} __attribute__ ((packed));
 
 struct tcp_sack_block {
 	u32	start_seq;
 	u32	end_seq;
-};
+} __attribute__ ((packed));
 
 /*These are used to set the sack_ok field in struct tcp_options_received */
 #define TCP_SACK_SEEN     (1 << 0)   /*1 = peer is SACK capable, */
diff -Naur linux-3.9.2.ref/include/linux/usb/hcd.h linux-3.9.2/include/linux/usb/hcd.h
--- linux-3.9.2.ref/include/linux/usb/hcd.h	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/include/linux/usb/hcd.h	2013-07-23 19:31:35.000000000 +0200
@@ -602,6 +602,28 @@
 }
 #endif /* CONFIG_USB_SUSPEND */
 
+/*
+ * USB device fs stuff
+ */
+
+#ifdef CONFIG_USB_DEVICEFS
+
+/*
+ * these are expected to be called from the USB core/hub thread
+ * with the kernel lock held
+ */
+extern void usbfs_update_special(void);
+extern int usbfs_init(void);
+extern void usbfs_cleanup(void);
+
+#else /* CONFIG_USB_DEVICEFS */
+
+static inline void usbfs_update_special(void) {}
+static inline int usbfs_init(void) { return 0; }
+static inline void usbfs_cleanup(void) { }
+
+#endif /* CONFIG_USB_DEVICEFS */
+
 /*-------------------------------------------------------------------------*/
 
 #if defined(CONFIG_USB_MON) || defined(CONFIG_USB_MON_MODULE)
diff -Naur linux-3.9.2.ref/include/linux/usb.h linux-3.9.2/include/linux/usb.h
--- linux-3.9.2.ref/include/linux/usb.h	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/include/linux/usb.h	2013-07-23 19:31:34.000000000 +0200
@@ -357,6 +357,10 @@
 	int bandwidth_int_reqs;		/* number of Interrupt requests */
 	int bandwidth_isoc_reqs;	/* number of Isoc. requests */
 
+#ifdef CONFIG_USB_DEVICEFS
+	struct dentry *usbfs_dentry;	/* usbfs dentry entry for the bus */
+#endif
+
 	unsigned resuming_ports;	/* bit array: resuming root-hub ports */
 
 #if defined(CONFIG_USB_MON) || defined(CONFIG_USB_MON_MODULE)
@@ -550,6 +554,12 @@
 	char *serial;
 
 	struct list_head filelist;
+#ifdef CONFIG_USB_DEVICE_CLASS
+	struct device *usb_classdev;
+#endif
+#ifdef CONFIG_USB_DEVICEFS
+	struct dentry *usbfs_dentry;
+#endif
 
 	int maxchild;
 
diff -Naur linux-3.9.2.ref/include/uapi/linux/fib_rules.h linux-3.9.2/include/uapi/linux/fib_rules.h
--- linux-3.9.2.ref/include/uapi/linux/fib_rules.h	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/include/uapi/linux/fib_rules.h	2013-07-23 19:31:33.000000000 +0200
@@ -27,7 +27,7 @@
 	__u8		action;
 
 	__u32		flags;
-};
+} __attribute__ ((packed));
 
 enum {
 	FRA_UNSPEC,
diff -Naur linux-3.9.2.ref/include/uapi/linux/icmp.h linux-3.9.2/include/uapi/linux/icmp.h
--- linux-3.9.2.ref/include/uapi/linux/icmp.h	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/include/uapi/linux/icmp.h	2013-07-23 19:31:33.000000000 +0200
@@ -80,7 +80,7 @@
 		__be16	mtu;
 	} frag;
   } un;
-};
+} __attribute__ ((packed));
 
 
 /*
diff -Naur linux-3.9.2.ref/include/uapi/linux/if_arp.h linux-3.9.2/include/uapi/linux/if_arp.h
--- linux-3.9.2.ref/include/uapi/linux/if_arp.h	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/include/uapi/linux/if_arp.h	2013-07-23 19:31:33.000000000 +0200
@@ -153,7 +153,7 @@
 	unsigned char		ar_tip[4];		/* target IP address		*/
 #endif
 
-};
+} __attribute__ ((packed));
 
 
 #endif /* _UAPI_LINUX_IF_ARP_H */
diff -Naur linux-3.9.2.ref/include/uapi/linux/igmp.h linux-3.9.2/include/uapi/linux/igmp.h
--- linux-3.9.2.ref/include/uapi/linux/igmp.h	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/include/uapi/linux/igmp.h	2013-07-23 19:31:33.000000000 +0200
@@ -32,7 +32,7 @@
 	__u8 code;		/* For newer IGMP */
 	__sum16 csum;
 	__be32 group;
-};
+} __attribute__ ((packed));
 
 /* V3 group record types [grec_type] */
 #define IGMPV3_MODE_IS_INCLUDE		1
@@ -48,7 +48,7 @@
 	__be16	grec_nsrcs;
 	__be32	grec_mca;
 	__be32	grec_src[0];
-};
+} __attribute__ ((packed));
 
 struct igmpv3_report {
 	__u8 type;
@@ -57,7 +57,7 @@
 	__be16 resv2;
 	__be16 ngrec;
 	struct igmpv3_grec grec[0];
-};
+} __attribute__ ((packed));
 
 struct igmpv3_query {
 	__u8 type;
@@ -78,7 +78,7 @@
 	__u8 qqic;
 	__be16 nsrcs;
 	__be32 srcs[0];
-};
+} __attribute__ ((packed));
 
 #define IGMP_HOST_MEMBERSHIP_QUERY	0x11	/* From RFC1112 */
 #define IGMP_HOST_MEMBERSHIP_REPORT	0x12	/* Ditto */
diff -Naur linux-3.9.2.ref/include/uapi/linux/ip.h linux-3.9.2/include/uapi/linux/ip.h
--- linux-3.9.2.ref/include/uapi/linux/ip.h	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/include/uapi/linux/ip.h	2013-07-23 19:31:33.000000000 +0200
@@ -102,7 +102,7 @@
 	__be32	saddr;
 	__be32	daddr;
 	/*The options start here. */
-};
+} __attribute__ ((packed));
 
 
 struct ip_auth_hdr {
@@ -112,25 +112,25 @@
 	__be32 spi;
 	__be32 seq_no;		/* Sequence number */
 	__u8  auth_data[0];	/* Variable len but >=4. Mind the 64 bit alignment! */
-};
+} __attribute__ ((packed));
 
 struct ip_esp_hdr {
 	__be32 spi;
 	__be32 seq_no;		/* Sequence number */
 	__u8  enc_data[0];	/* Variable len but >=8. Mind the 64 bit alignment! */
-};
+} __attribute__ ((packed));
 
 struct ip_comp_hdr {
 	__u8 nexthdr;
 	__u8 flags;
 	__be16 cpi;
-};
+} __attribute__ ((packed));
 
 struct ip_beet_phdr {
 	__u8 nexthdr;
 	__u8 hdrlen;
 	__u8 padlen;
 	__u8 reserved;
-};
+} __attribute__ ((packed));
 
 #endif /* _UAPI_LINUX_IP_H */
diff -Naur linux-3.9.2.ref/include/uapi/linux/ipv6.h linux-3.9.2/include/uapi/linux/ipv6.h
--- linux-3.9.2.ref/include/uapi/linux/ipv6.h	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/include/uapi/linux/ipv6.h	2013-07-23 19:31:33.000000000 +0200
@@ -49,7 +49,7 @@
 	 *	type specific data
 	 *	variable length field
 	 */
-};
+} __attribute__ ((packed));
 
 
 struct ipv6_opt_hdr {
@@ -76,7 +76,7 @@
 	struct in6_addr		addr[0];
 
 #define rt0_type		rt_hdr.type
-};
+} __attribute__ ((packed));
 
 /*
  *	routing header type 2
@@ -88,7 +88,7 @@
 	struct in6_addr		addr;
 
 #define rt2_type		rt_hdr.type
-};
+} __attribute__ ((packed));
 
 /*
  *	home address option in destination options header
@@ -125,7 +125,7 @@
 
 	struct	in6_addr	saddr;
 	struct	in6_addr	daddr;
-};
+} __attribute__ ((packed));
 
 
 /* index values for the variables in ipv6_devconf */
diff -Naur linux-3.9.2.ref/include/uapi/linux/serial_reg.h linux-3.9.2/include/uapi/linux/serial_reg.h
--- linux-3.9.2.ref/include/uapi/linux/serial_reg.h	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/include/uapi/linux/serial_reg.h	2013-07-23 19:31:33.000000000 +0200
@@ -15,12 +15,44 @@
 #define _LINUX_SERIAL_REG_H
 
 /*
- * DLAB=0
+ * SMP8xxx has 16550 uarts, but registers are a little bit different...
  */
+#ifdef CONFIG_TANGOX
+
 #define UART_RX		0	/* In:  Receive buffer */
-#define UART_TX		0	/* Out: Transmit buffer */
+#define UART_TX		1	/* Out: Transmit buffer */
+#define UART_IER	2	/* Out: Interrupt Enable Register */
+#define UART_IIR	3	/* In:  Interrupt ID Register */
+#define UART_FCR	4	/* Out: FIFO Control Register */
+#define UART_LCR	5	/* Out: Line Control Register */
+#define UART_MCR	6	/* Out: Modem Control Register */
+#define UART_LSR	7	/* In:  Line Status Register */
+#define UART_MSR	8	/* In:  Modem Status Register */
+#define UART_SCR	9	/* I/O: Scratch Register */
+
+/* EFR does not exist on TANGOX,  we use a magic to catch accesses and
+ * make them nop */
+#define UART_EFR	42
+
+#else
 
+#define UART_RX		0	/* In:  Receive buffer */
+#define UART_TX		0	/* Out: Transmit buffer */
 #define UART_IER	1	/* Out: Interrupt Enable Register */
+#define UART_IIR	2	/* In:  Interrupt ID Register */
+#define UART_EFR	2	/* I/O: Extended Features Register */
+#define UART_FCR	2	/* Out: FIFO Control Register */
+#define UART_LCR	3	/* Out: Line Control Register */
+#define UART_MCR	4	/* Out: Modem Control Register */
+#define UART_LSR	5	/* In:  Line Status Register */
+#define UART_MSR	6	/* In:  Modem Status Register */
+#define UART_SCR	7	/* I/O: Scratch Register */
+
+#endif
+
+/*
+ * DLAB=0
+ */
 #define UART_IER_MSI		0x08 /* Enable Modem status interrupt */
 #define UART_IER_RLSI		0x04 /* Enable receiver line status interrupt */
 #define UART_IER_THRI		0x02 /* Enable Transmitter holding register int. */
@@ -30,7 +62,6 @@
  */
 #define UART_IERX_SLEEP		0x10 /* Enable sleep mode */
 
-#define UART_IIR	2	/* In:  Interrupt ID Register */
 #define UART_IIR_NO_INT		0x01 /* No interrupts pending */
 #define UART_IIR_ID		0x06 /* Mask for the interrupt ID */
 #define UART_IIR_MSI		0x00 /* Modem status interrupt */
@@ -44,7 +75,6 @@
 #define UART_IIR_XOFF		0x10 /* OMAP XOFF/Special Character */
 #define UART_IIR_CTS_RTS_DSR	0x20 /* OMAP CTS/RTS/DSR Change */
 
-#define UART_FCR	2	/* Out: FIFO Control Register */
 #define UART_FCR_ENABLE_FIFO	0x01 /* Enable the FIFO */
 #define UART_FCR_CLEAR_RCVR	0x02 /* Clear the RCVR FIFO */
 #define UART_FCR_CLEAR_XMIT	0x04 /* Clear the XMIT FIFO */
@@ -88,7 +118,6 @@
 #define UART_FCR6_T_TRIGGER_30	0x30 /* Mask for transmit trigger set at 30 */
 #define UART_FCR7_64BYTE	0x20 /* Go into 64 byte mode (TI16C750) */
 
-#define UART_LCR	3	/* Out: Line Control Register */
 /*
  * Note: if the word length is 5 bits (UART_LCR_WLEN5), then setting 
  * UART_LCR_STOP will select 1.5 stop bits, not 2 stop bits.
@@ -111,7 +140,6 @@
 #define UART_LCR_CONF_MODE_A	UART_LCR_DLAB	/* Configutation mode A */
 #define UART_LCR_CONF_MODE_B	0xBF		/* Configutation mode B */
 
-#define UART_MCR	4	/* Out: Modem Control Register */
 #define UART_MCR_CLKSEL		0x80 /* Divide clock by 4 (TI16C752, EFR[4]=1) */
 #define UART_MCR_TCRTLR		0x40 /* Access TCR/TLR (TI16C752, EFR[4]=1) */
 #define UART_MCR_XONANY		0x20 /* Enable Xon Any (TI16C752, EFR[4]=1) */
@@ -122,7 +150,6 @@
 #define UART_MCR_RTS		0x02 /* RTS complement */
 #define UART_MCR_DTR		0x01 /* DTR complement */
 
-#define UART_LSR	5	/* In:  Line Status Register */
 #define UART_LSR_FIFOE		0x80 /* Fifo error */
 #define UART_LSR_TEMT		0x40 /* Transmitter empty */
 #define UART_LSR_THRE		0x20 /* Transmit-hold-register empty */
@@ -133,7 +160,6 @@
 #define UART_LSR_DR		0x01 /* Receiver data ready */
 #define UART_LSR_BRK_ERROR_BITS	0x1E /* BI, FE, PE, OE bits */
 
-#define UART_MSR	6	/* In:  Modem Status Register */
 #define UART_MSR_DCD		0x80 /* Data Carrier Detect */
 #define UART_MSR_RI		0x40 /* Ring Indicator */
 #define UART_MSR_DSR		0x20 /* Data Set Ready */
@@ -144,18 +170,25 @@
 #define UART_MSR_DCTS		0x01 /* Delta CTS */
 #define UART_MSR_ANY_DELTA	0x0F /* Any of the delta bits! */
 
-#define UART_SCR	7	/* I/O: Scratch Register */
 
 /*
  * DLAB=1
  */
+
+/*
+ * SMP8xxx has DLM and DLM in one register
+ */
+#ifdef CONFIG_TANGOX
+#define UART_DL		10
+#define UART_CLKSEL	11	/* Clock selection */
+#else
 #define UART_DLL	0	/* Out: Divisor Latch Low */
 #define UART_DLM	1	/* Out: Divisor Latch High */
+#endif
 
 /*
  * LCR=0xBF (or DLAB=1 for 16C660)
  */
-#define UART_EFR	2	/* I/O: Extended Features Register */
 #define UART_XR_EFR	9	/* I/O: Extended Features Register (XR17D15x) */
 #define UART_EFR_CTS		0x80 /* CTS flow control */
 #define UART_EFR_RTS		0x40 /* RTS flow control */
diff -Naur linux-3.9.2.ref/include/uapi/linux/tcp.h linux-3.9.2/include/uapi/linux/tcp.h
--- linux-3.9.2.ref/include/uapi/linux/tcp.h	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/include/uapi/linux/tcp.h	2013-07-23 19:31:33.000000000 +0200
@@ -54,7 +54,7 @@
 	__be16	window;
 	__sum16	check;
 	__be16	urg_ptr;
-};
+} __attribute__ ((packed));
 
 /*
  *	The union cast uses a gcc extension to avoid aliasing problems
@@ -64,7 +64,7 @@
 union tcp_word_hdr { 
 	struct tcphdr hdr;
 	__be32 		  words[5];
-}; 
+} __attribute__ ((packed));
 
 #define tcp_flag_word(tp) ( ((union tcp_word_hdr *)(tp))->words [3]) 
 
diff -Naur linux-3.9.2.ref/include/uapi/linux/udp.h linux-3.9.2/include/uapi/linux/udp.h
--- linux-3.9.2.ref/include/uapi/linux/udp.h	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/include/uapi/linux/udp.h	2013-07-23 19:31:33.000000000 +0200
@@ -24,7 +24,7 @@
 	__be16	dest;
 	__be16	len;
 	__sum16	check;
-};
+} __attribute__ ((packed));
 
 /* UDP socket options */
 #define UDP_CORK	1	/* Never send partially complete segments */
diff -Naur linux-3.9.2.ref/Makefile linux-3.9.2/Makefile
--- linux-3.9.2.ref/Makefile	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/Makefile	2013-07-23 19:31:04.000000000 +0200
@@ -192,8 +192,8 @@
 # "make" in the configured kernel build directory always uses that.
 # Default value for CROSS_COMPILE is not to prefix executables
 # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
-ARCH		?= $(SUBARCH)
-CROSS_COMPILE	?= $(CONFIG_CROSS_COMPILE:"%"=%)
+ARCH		?= mips
+CROSS_COMPILE	?= mipsel-oe-linux-
 
 # Architecture as present in compile.h
 UTS_MACHINE 	:= $(ARCH)
diff -Naur linux-3.9.2.ref/mm/page_alloc.c linux-3.9.2/mm/page_alloc.c
--- linux-3.9.2.ref/mm/page_alloc.c	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/mm/page_alloc.c	2013-07-23 19:31:36.000000000 +0200
@@ -2375,6 +2375,8 @@
 	bool sync_migration = false;
 	bool deferred_compaction = false;
 	bool contended_compaction = false;
+	int num_retries = 0;
+
 
 	/*
 	 * In the slowpath, we sanity check order to avoid ever trying to
@@ -2558,6 +2560,13 @@
 	}
 
 nopage:
+	if (!(gfp_mask & __GFP_NOWARN) && printk_ratelimit()) {
+		if (wait && !in_atomic() && !in_interrupt() && (++num_retries < 16)) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(HZ);
+			goto rebalance;
+		}
+	}
 	warn_alloc_failed(gfp_mask, order, NULL);
 	return page;
 got_pg:
diff -Naur linux-3.9.2.ref/net/ipv4/tcp_input.c linux-3.9.2/net/ipv4/tcp_input.c
--- linux-3.9.2.ref/net/ipv4/tcp_input.c	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/net/ipv4/tcp_input.c	2013-07-23 19:31:06.000000000 +0200
@@ -3879,13 +3879,13 @@
 {
 	const __be32 *ptr = (const __be32 *)(th + 1);
 
-	if (*ptr == htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16)
+	if (get_unaligned(ptr) == htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16)
 			  | (TCPOPT_TIMESTAMP << 8) | TCPOLEN_TIMESTAMP)) {
 		tp->rx_opt.saw_tstamp = 1;
 		++ptr;
-		tp->rx_opt.rcv_tsval = ntohl(*ptr);
+		tp->rx_opt.rcv_tsval = ntohl(get_unaligned(ptr));
 		++ptr;
-		tp->rx_opt.rcv_tsecr = ntohl(*ptr) - tp->tsoffset;
+		tp->rx_opt.rcv_tsecr = ntohl(get_unaligned(ptr)) - tp->tsoffset;
 		return true;
 	}
 	return false;
diff -Naur linux-3.9.2.ref/net/ipv4/tcp_ipv4.c linux-3.9.2/net/ipv4/tcp_ipv4.c
--- linux-3.9.2.ref/net/ipv4/tcp_ipv4.c	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/net/ipv4/tcp_ipv4.c	2013-07-23 19:31:06.000000000 +0200
@@ -1842,6 +1842,7 @@
 int tcp_v4_do_rcv(struct sock *sk, struct sk_buff *skb)
 {
 	struct sock *rsk;
+	int ttl = ((struct iphdr *)skb_network_header(skb))->ttl;
 #ifdef CONFIG_TCP_MD5SIG
 	/*
 	 * We really want to reject the packet as early as possible
@@ -1868,6 +1869,7 @@
 			rsk = sk;
 			goto reset;
 		}
+		inet_sk(sk)->mc_ttl = ttl;
 		return 0;
 	}
 
@@ -1894,6 +1896,7 @@
 		rsk = sk;
 		goto reset;
 	}
+	inet_sk(sk)->mc_ttl = ttl;
 	return 0;
 
 reset:
diff -Naur linux-3.9.2.ref/net/ipv4/xfrm4_policy.c linux-3.9.2/net/ipv4/xfrm4_policy.c
--- linux-3.9.2.ref/net/ipv4/xfrm4_policy.c	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/net/ipv4/xfrm4_policy.c	2013-07-23 19:31:06.000000000 +0200
@@ -119,8 +119,8 @@
 			    pskb_may_pull(skb, xprth + 4 - skb->data)) {
 				__be16 *ports = (__be16 *)xprth;
 
-				fl4->fl4_sport = ports[!!reverse];
-				fl4->fl4_dport = ports[!reverse];
+				fl4->fl4_sport = get_unaligned(&ports[!!reverse]);
+				fl4->fl4_dport = get_unaligned(&ports[!reverse]);
 			}
 			break;
 
@@ -137,7 +137,7 @@
 			if (pskb_may_pull(skb, xprth + 4 - skb->data)) {
 				__be32 *ehdr = (__be32 *)xprth;
 
-				fl4->fl4_ipsec_spi = ehdr[0];
+				fl4->fl4_ipsec_spi = get_unaligned(&ehdr[0]);
 			}
 			break;
 
@@ -145,7 +145,7 @@
 			if (pskb_may_pull(skb, xprth + 8 - skb->data)) {
 				__be32 *ah_hdr = (__be32 *)xprth;
 
-				fl4->fl4_ipsec_spi = ah_hdr[1];
+				fl4->fl4_ipsec_spi = get_unaligned(&ah_hdr[1]);
 			}
 			break;
 
@@ -153,7 +153,7 @@
 			if (pskb_may_pull(skb, xprth + 4 - skb->data)) {
 				__be16 *ipcomp_hdr = (__be16 *)xprth;
 
-				fl4->fl4_ipsec_spi = htonl(ntohs(ipcomp_hdr[1]));
+				fl4->fl4_ipsec_spi = htonl(ntohs(get_unaligned(&ipcomp_hdr[1])));
 			}
 			break;
 
diff -Naur linux-3.9.2.ref/net/netfilter/ipvs/ip_vs_proto_ah_esp.c linux-3.9.2/net/netfilter/ipvs/ip_vs_proto_ah_esp.c
--- linux-3.9.2.ref/net/netfilter/ipvs/ip_vs_proto_ah_esp.c	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/net/netfilter/ipvs/ip_vs_proto_ah_esp.c	2013-07-23 19:31:06.000000000 +0200
@@ -34,7 +34,7 @@
 	__u8		flags;
 	__u32		msgid;
 	__u32		length;
-};
+} __attribute__ ((packed));
 
 */
 
diff -Naur linux-3.9.2.ref/net/sunrpc/xprtsock.c linux-3.9.2/net/sunrpc/xprtsock.c
--- linux-3.9.2.ref/net/sunrpc/xprtsock.c	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/net/sunrpc/xprtsock.c	2013-07-23 19:31:05.000000000 +0200
@@ -47,6 +47,8 @@
 #include <net/udp.h>
 #include <net/tcp.h>
 
+#include <asm/unaligned.h>
+
 #include "sunrpc.h"
 
 static void xs_close(struct rpc_xprt *xprt);
@@ -995,7 +997,7 @@
 
 	/* Look up and lock the request corresponding to the given XID */
 	spin_lock(&xprt->transport_lock);
-	rovr = xprt_lookup_rqst(xprt, *xp);
+	rovr = xprt_lookup_rqst(xprt, get_unaligned(xp));
 	if (!rovr)
 		goto out_unlock;
 	task = rovr->rq_task;
diff -Naur linux-3.9.2.ref/scripts/Makefile.host linux-3.9.2/scripts/Makefile.host
--- linux-3.9.2.ref/scripts/Makefile.host	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/scripts/Makefile.host	2013-07-23 19:31:35.000000000 +0200
@@ -111,16 +111,16 @@
 
 # Create executable from a single .c file
 # host-csingle -> Executable
-quiet_cmd_host-csingle 	= HOSTCC  $@
-      cmd_host-csingle	= $(HOSTCC) $(hostc_flags) -o $@ $< \
+quiet_cmd_host-csingle 	= HOSTCC  -static $@
+      cmd_host-csingle	= $(HOSTCC) -static $(hostc_flags) -o $@ $< \
 	  	$(HOST_LOADLIBES) $(HOSTLOADLIBES_$(@F))
 $(host-csingle): $(obj)/%: $(src)/%.c FORCE
 	$(call if_changed_dep,host-csingle)
 
 # Link an executable based on list of .o files, all plain c
 # host-cmulti -> executable
-quiet_cmd_host-cmulti	= HOSTLD  $@
-      cmd_host-cmulti	= $(HOSTCC) $(HOSTLDFLAGS) -o $@ \
+quiet_cmd_host-cmulti	= HOSTLD  -static $@
+      cmd_host-cmulti	= $(HOSTCC) -static $(HOSTLDFLAGS) -o $@ \
 			  $(addprefix $(obj)/,$($(@F)-objs)) \
 			  $(HOST_LOADLIBES) $(HOSTLOADLIBES_$(@F))
 $(host-cmulti): $(obj)/%: $(host-cobjs) $(host-cshlib) FORCE
diff -Naur linux-3.9.2.ref/usr/initramfs_default_node_list linux-3.9.2/usr/initramfs_default_node_list
--- linux-3.9.2.ref/usr/initramfs_default_node_list	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.9.2/usr/initramfs_default_node_list	2013-07-23 19:31:36.000000000 +0200
@@ -0,0 +1,274 @@
+nod /dev/null 666 0 0 c 1 3
+nod /dev/zero 666 0 0 c 1 5
+nod /dev/random 666 0 0 c 1 8
+nod /dev/urandom 666 0 0 c 1 9
+nod /dev/console 666 0 0 c 5 1
+dir /dev/pts 755 0 0
+nod /dev/pts/0 664 0 0 c 136 0
+nod /dev/pts/1 664 0 0 c 136 1
+nod /dev/pts/2 664 0 0 c 136 2
+nod /dev/pts/3 664 0 0 c 136 3
+nod /dev/pts/4 664 0 0 c 136 4
+nod /dev/bcmadsl0 644 0 0 c 208 0
+nod /dev/fb0 644 0 0 c 29 0
+nod /dev/fb1 644 0 0 c 29 32
+nod /dev/fb2 644 0 0 c 29 64
+nod /dev/fb3 644 0 0 c 29 96
+nod /dev/fbxmtda0 644 0 0 c 251 0
+nod /dev/fbxmtda1 644 0 0 c 251 1
+nod /dev/fbxmtda2 644 0 0 c 251 2
+nod /dev/fbxmtda3 644 0 0 c 251 3
+nod /dev/fbxmtda4 644 0 0 c 251 4
+nod /dev/fbxmtda5 644 0 0 c 251 5
+nod /dev/fbxmtda6 644 0 0 c 251 6
+nod /dev/fbxmtda7 644 0 0 c 251 7
+nod /dev/fbxmtdb0 644 0 0 c 251 8
+nod /dev/fbxmtdb1 644 0 0 c 251 9
+nod /dev/fbxmtdb2 644 0 0 c 251 10
+nod /dev/fbxmtdb3 644 0 0 c 251 11
+nod /dev/fbxmtdb4 644 0 0 c 251 12
+nod /dev/fbxmtdb5 644 0 0 c 251 13
+nod /dev/fbxmtdb6 644 0 0 c 251 14
+nod /dev/fbxmtdb7 644 0 0 c 251 15
+nod /dev/fbxmtdblka0 644 0 0 b 252 0
+nod /dev/fbxmtdblka1 644 0 0 b 252 1
+nod /dev/fbxmtdblka2 644 0 0 b 252 2
+nod /dev/fbxmtdblka3 644 0 0 b 252 3
+nod /dev/fbxmtdblka4 644 0 0 b 252 4
+nod /dev/fbxmtdblka5 644 0 0 b 252 5
+nod /dev/fbxmtdblka6 644 0 0 b 252 6
+nod /dev/fbxmtdblka7 644 0 0 b 252 7
+nod /dev/fbxmtdblkb0 644 0 0 b 252 8
+nod /dev/fbxmtdblkb1 644 0 0 b 252 9
+nod /dev/fbxmtdblkb2 644 0 0 b 252 10
+nod /dev/fbxmtdblkb3 644 0 0 b 252 11
+nod /dev/fbxmtdblkb4 644 0 0 b 252 12
+nod /dev/fbxmtdblkb5 644 0 0 b 252 13
+nod /dev/fbxmtdblkb6 644 0 0 b 252 14
+nod /dev/fbxmtdblkb7 644 0 0 b 252 15
+nod /dev/hda 644 0 0 b 3 0
+nod /dev/hda1 644 0 0 b 3 1
+nod /dev/hda10 644 0 0 b 3 10
+nod /dev/hda11 644 0 0 b 3 11
+nod /dev/hda12 644 0 0 b 3 12
+nod /dev/hda13 644 0 0 b 3 13
+nod /dev/hda14 644 0 0 b 3 14
+nod /dev/hda2 644 0 0 b 3 2
+nod /dev/hda3 644 0 0 b 3 3
+nod /dev/hda4 644 0 0 b 3 4
+nod /dev/hda5 644 0 0 b 3 5
+nod /dev/hda6 644 0 0 b 3 6
+nod /dev/hda7 644 0 0 b 3 7
+nod /dev/hda8 644 0 0 b 3 8
+nod /dev/hda9 644 0 0 b 3 9
+nod /dev/hdb 644 0 0 b 3 64
+nod /dev/hdb1 644 0 0 b 3 65
+nod /dev/hdb10 644 0 0 b 3 74
+nod /dev/hdb11 644 0 0 b 3 75
+nod /dev/hdb12 644 0 0 b 3 76
+nod /dev/hdb13 644 0 0 b 3 77
+nod /dev/hdb14 644 0 0 b 3 78
+nod /dev/hdb2 644 0 0 b 3 66
+nod /dev/hdb3 644 0 0 b 3 67
+nod /dev/hdb4 644 0 0 b 3 68
+nod /dev/hdb5 644 0 0 b 3 69
+nod /dev/hdb6 644 0 0 b 3 70
+nod /dev/hdb7 644 0 0 b 3 71
+nod /dev/hdb8 644 0 0 b 3 72
+nod /dev/hdb9 644 0 0 b 3 73
+dir /dev/input 755 0 0
+nod /dev/input/mice 666 0 0 c 13 63
+nod /dev/input/mouse0 666 0 0 c 13 32
+nod /dev/input/mouse1 666 0 0 c 13 33
+nod /dev/input/mouse2 666 0 0 c 13 34
+nod /dev/input/mouse3 666 0 0 c 13 35
+nod /dev/input/event0 666 0 0 c 13 64
+nod /dev/input/event1 666 0 0 c 13 65
+nod /dev/input/event2 666 0 0 c 13 66
+nod /dev/input/event3 666 0 0 c 13 67
+nod /dev/input/uinput 666 0 0 c 10 223
+slink /dev/uinput /dev/input/uinput 777 0 0
+nod /dev/kmem 644 0 0 c 1 2
+nod /dev/loop0 644 0 0 b 7 0
+nod /dev/loop1 644 0 0 b 7 1
+nod /dev/mem 644 0 0 c 1 1
+nod /dev/mtd0 644 0 0 c 90 0
+nod /dev/mtd0ro 644 0 0 c 90 1
+nod /dev/mtd1 644 0 0 c 90 2
+nod /dev/mtd10 644 0 0 c 90 20
+nod /dev/mtd10ro 644 0 0 c 90 21
+nod /dev/mtd11 644 0 0 c 90 22
+nod /dev/mtd11ro 644 0 0 c 90 23
+nod /dev/mtd12 644 0 0 c 90 24
+nod /dev/mtd12ro 644 0 0 c 90 25
+nod /dev/mtd13 644 0 0 c 90 26
+nod /dev/mtd13ro 644 0 0 c 90 27
+nod /dev/mtd14 644 0 0 c 90 28
+nod /dev/mtd14ro 644 0 0 c 90 29
+nod /dev/mtd15 644 0 0 c 90 30
+nod /dev/mtd15ro 644 0 0 c 90 31
+nod /dev/mtd1ro 644 0 0 c 90 3
+nod /dev/mtd2 644 0 0 c 90 4
+nod /dev/mtd2ro 644 0 0 c 90 5
+nod /dev/mtd3 644 0 0 c 90 6
+nod /dev/mtd3ro 644 0 0 c 90 7
+nod /dev/mtd4 644 0 0 c 90 8
+nod /dev/mtd4ro 644 0 0 c 90 9
+nod /dev/mtd5 644 0 0 c 90 10
+nod /dev/mtd5ro 644 0 0 c 90 11
+nod /dev/mtd6 644 0 0 c 90 12
+nod /dev/mtd6ro 644 0 0 c 90 13
+nod /dev/mtd7 644 0 0 c 90 14
+nod /dev/mtd7ro 644 0 0 c 90 15
+nod /dev/mtd8 644 0 0 c 90 16
+nod /dev/mtd8ro 644 0 0 c 90 17
+nod /dev/mtd9 644 0 0 c 90 18
+nod /dev/mtd9ro 644 0 0 c 90 19
+nod /dev/mtdblock0 644 0 0 b 31 0
+nod /dev/mtdblock1 644 0 0 b 31 1
+nod /dev/mtdblock10 644 0 0 b 31 10
+nod /dev/mtdblock11 644 0 0 b 31 11
+nod /dev/mtdblock12 644 0 0 b 31 12
+nod /dev/mtdblock13 644 0 0 b 31 13
+nod /dev/mtdblock14 644 0 0 b 31 14
+nod /dev/mtdblock15 644 0 0 b 31 15
+nod /dev/mtdblock2 644 0 0 b 31 2
+nod /dev/mtdblock3 644 0 0 b 31 3
+nod /dev/mtdblock4 644 0 0 b 31 4
+nod /dev/mtdblock5 644 0 0 b 31 5
+nod /dev/mtdblock6 644 0 0 b 31 6
+nod /dev/mtdblock7 644 0 0 b 31 7
+nod /dev/mtdblock8 644 0 0 b 31 8
+nod /dev/mtdblock9 644 0 0 b 31 9
+dir /dev/net 755 0 0
+nod /dev/net/tun 644 0 0 c 10 200
+nod /dev/ppp 644 0 0 c 108 0
+nod /dev/psaux 644 0 0 c 10 1
+nod /dev/ptmx 644 0 0 c 5 2
+nod /dev/ptyp0 644 0 0 c 2 0
+nod /dev/ptyp1 644 0 0 c 2 1
+nod /dev/ptyp2 644 0 0 c 2 2
+nod /dev/ptyp3 644 0 0 c 2 3
+nod /dev/ptyp4 644 0 0 c 2 4
+nod /dev/ptyp5 644 0 0 c 2 5
+nod /dev/ptyp6 644 0 0 c 2 6
+nod /dev/ptyp7 644 0 0 c 2 7
+nod /dev/ptyp8 644 0 0 c 2 8
+nod /dev/ptyp9 644 0 0 c 2 9
+nod /dev/ram 644 0 0 b 1 1
+nod /dev/ram0 644 0 0 b 1 0
+nod /dev/ram1 644 0 0 b 1 1
+nod /dev/ram2 644 0 0 b 1 2
+nod /dev/ram3 644 0 0 b 1 3
+nod /dev/rtc 644 0 0 c 10 135
+nod /dev/sda 664 0 0 b 8 0
+nod /dev/sda1 664 0 0 b 8 1
+nod /dev/sda10 664 0 0 b 8 10
+nod /dev/sda11 664 0 0 b 8 11
+nod /dev/sda12 664 0 0 b 8 12
+nod /dev/sda13 664 0 0 b 8 13
+nod /dev/sda14 664 0 0 b 8 14
+nod /dev/sda15 664 0 0 b 8 15
+nod /dev/sda2 664 0 0 b 8 2
+nod /dev/sda3 664 0 0 b 8 3
+nod /dev/sda4 664 0 0 b 8 4
+nod /dev/sda5 664 0 0 b 8 5
+nod /dev/sda6 664 0 0 b 8 6
+nod /dev/sda7 664 0 0 b 8 7
+nod /dev/sda8 664 0 0 b 8 8
+nod /dev/sda9 664 0 0 b 8 9
+nod /dev/sdb 664 0 0 b 8 16
+nod /dev/sdb1 664 0 0 b 8 17
+nod /dev/sdb10 664 0 0 b 8 26
+nod /dev/sdb11 664 0 0 b 8 27
+nod /dev/sdb12 664 0 0 b 8 28
+nod /dev/sdb13 664 0 0 b 8 29
+nod /dev/sdb14 664 0 0 b 8 30
+nod /dev/sdb15 664 0 0 b 8 31
+nod /dev/sdb2 664 0 0 b 8 18
+nod /dev/sdb3 664 0 0 b 8 19
+nod /dev/sdb4 664 0 0 b 8 20
+nod /dev/sdb5 664 0 0 b 8 21
+nod /dev/sdb6 664 0 0 b 8 22
+nod /dev/sdb7 664 0 0 b 8 23
+nod /dev/sdb8 664 0 0 b 8 24
+nod /dev/sdb9 664 0 0 b 8 25
+nod /dev/sdc 664 0 0 b 8 32
+nod /dev/sdc1 664 0 0 b 8 33
+nod /dev/sdc10 664 0 0 b 8 42
+nod /dev/sdc11 664 0 0 b 8 43
+nod /dev/sdc12 664 0 0 b 8 44
+nod /dev/sdc13 664 0 0 b 8 45
+nod /dev/sdc14 664 0 0 b 8 46
+nod /dev/sdc15 664 0 0 b 8 47
+nod /dev/sdc2 664 0 0 b 8 34
+nod /dev/sdc3 664 0 0 b 8 35
+nod /dev/sdc4 664 0 0 b 8 36
+nod /dev/sdc5 664 0 0 b 8 37
+nod /dev/sdc6 664 0 0 b 8 38
+nod /dev/sdc7 664 0 0 b 8 39
+nod /dev/sdc8 664 0 0 b 8 40
+nod /dev/sdc9 664 0 0 b 8 41
+nod /dev/sdd 664 0 0 b 8 48
+nod /dev/sdd1 664 0 0 b 8 49
+nod /dev/sdd10 664 0 0 b 8 58
+nod /dev/sdd11 664 0 0 b 8 59
+nod /dev/sdd12 664 0 0 b 8 60
+nod /dev/sdd13 664 0 0 b 8 61
+nod /dev/sdd14 664 0 0 b 8 62
+nod /dev/sdd15 664 0 0 b 8 63
+nod /dev/sdd2 664 0 0 b 8 50
+nod /dev/sdd3 664 0 0 b 8 51
+nod /dev/sdd4 664 0 0 b 8 52
+nod /dev/sdd5 664 0 0 b 8 53
+nod /dev/sdd6 664 0 0 b 8 54
+nod /dev/sdd7 664 0 0 b 8 55
+nod /dev/sdd8 664 0 0 b 8 56
+nod /dev/sdd9 664 0 0 b 8 57
+dir /dev/shm 755 0 0
+nod /dev/tty 644 0 0 c 5 0
+nod /dev/tty0 644 0 0 c 4 0
+nod /dev/tty1 644 0 0 c 4 1
+nod /dev/tty2 644 0 0 c 4 2
+nod /dev/tty3 644 0 0 c 4 3
+nod /dev/tty4 644 0 0 c 4 4
+nod /dev/tty5 644 0 0 c 4 5
+nod /dev/tty6 644 0 0 c 4 6
+nod /dev/tty7 644 0 0 c 4 7
+nod /dev/ttyp0 644 0 0 c 3 0
+nod /dev/ttyP0 644 0 0 c 57 0
+nod /dev/ttyp1 644 0 0 c 3 1
+nod /dev/ttyP1 644 0 0 c 57 1
+nod /dev/ttyp2 644 0 0 c 3 2
+nod /dev/ttyP2 644 0 0 c 57 2
+nod /dev/ttyp3 644 0 0 c 3 3
+nod /dev/ttyP3 644 0 0 c 57 3
+nod /dev/ttyp4 644 0 0 c 3 4
+nod /dev/ttyp5 644 0 0 c 3 5
+nod /dev/ttyp6 644 0 0 c 3 6
+nod /dev/ttyp7 644 0 0 c 3 7
+nod /dev/ttyp8 644 0 0 c 3 8
+nod /dev/ttyp9 644 0 0 c 3 9
+nod /dev/ttyS0 644 0 0 c 4 64
+nod /dev/ttyS1 644 0 0 c 4 65
+nod /dev/ttyS2 644 0 0 c 4 66
+nod /dev/ttyS3 644 0 0 c 4 67
+nod /dev/scd0 644 0 0 b 11 0
+nod /dev/scd1 644 0 0 b 11 1
+nod /dev/scd2 644 0 0 b 11 2
+nod /dev/scd3 644 0 0 b 11 3
+slink /dev/sr0 scd0 777 0 0
+slink /dev/sr1 scd1 777 0 0
+slink /dev/sr2 scd2 777 0 0
+slink /dev/sr3 scd3 777 0 0
+nod /dev/ttyUSB0 644 0 0 c 188 0
+nod /dev/ttyUSB1 644 0 0 c 188 1
+nod /dev/ttyUSB2 644 0 0 c 188 2
+nod /dev/ttyUSB3 644 0 0 c 188 3
+nod /dev/watchdog 660 0 0 c 10 130
+dir /dev/oprofile 755 0 0
+dir /sys 755 0 0
+dir /usr/local 755 0 0
+dir /usr/local/.oprofile 755 0 0
+slink /root/.oprofile /usr/local/.oprofile 777 0 0
+slink /var/lib/oprofile /usr/local 777 0 0
diff -Naur linux-3.9.2.ref/usr/Makefile linux-3.9.2/usr/Makefile
--- linux-3.9.2.ref/usr/Makefile	2013-05-11 16:19:28.000000000 +0200
+++ linux-3.9.2/usr/Makefile	2013-07-23 19:31:36.000000000 +0200
@@ -50,8 +50,32 @@
 	include $(obj)/.initramfs_data.cpio.d
 endif
 
+# The $(shell echo $(CONFIG_INITRAMFS_SOURCE)) is to remove the
+# gratuitous begin and end quotes from the Kconfig string type.
+# Internal, escaped quotes in the Kconfig string will loose the
+# escape and become active quotes.
+quotefixed_initramfs_source := $(shell echo $(CONFIG_INITRAMFS_SOURCE))
+
+ifneq '$(quotefixed_initramfs_source)' '' # if the INITRAMFS option is set
+ifeq '$(wildcard $(quotefixed_initramfs_source))' '' # but it does not exist in the file system
+$(warning                                                                    )
+$(warning Error: cannot find the initramfs source $(CONFIG_INITRAMFS_SOURCE) )
+$(warning If you are using integration with the Sigma Designs MIPSutils      )
+$(warning rootfs package, please make sure you have sourced 'rootfs-path.env')
+$(warning in the rootfs package dir, or that you have adequately defined the )
+$(warning 'SMP86XX_ROOTFS_PATH' environment variable.                        )
+$(warning                                                                    )
+$(error   Error: $(CONFIG_INITRAMFS_SOURCE) not found.)
+endif
+endif
+ 
+is_ramfs_input_dir := $(shell if [ -d $(ramfs-input) ]; then echo yes; fi)
+ifeq '$(is_ramfs_input_dir)' 'yes'
+	initramfs_extra_list := usr/initramfs_default_node_list
+endif
+
 quiet_cmd_initfs = GEN     $@
-      cmd_initfs = $(initramfs) -o $@ $(ramfs-args) $(ramfs-input)
+      cmd_initfs = $(initramfs) -o $@ $(ramfs-args) $(ramfs-input) $(initramfs_extra_list)
 
 targets := initramfs_data.cpio.gz initramfs_data.cpio.bz2 initramfs_data.cpio.lzma initramfs_data.cpio.xz initramfs_data.cpio.lzo initramfs_data.cpio
 # do not try to update files included in initramfs
@@ -67,3 +91,17 @@
 	$(Q)$(initramfs) -l $(ramfs-input) > $(obj)/.initramfs_data.cpio.d
 	$(call if_changed,initfs)
 
+is_gawk_installed := $(shell if gawk --version > /dev/null 2>& 1; then echo yes; fi)
+ifneq '$(is_gawk_installed)' 'yes'
+$(warning The 'gawk' utility is not installed on your system\; however it is a )
+$(warning pre-requisite of the SMP86xx dev kit. Please install it before       )
+$(warning proceeding.                                                          )
+$(warning                                                                      )
+$(warning Depending on the specifics of your Linux distribution, you can       )
+$(warning consider the following ways of installing 'gawk' onto your system:   )
+$(warning  - use a package manager, such as apt-get (apt-get install gawk) or  )
+$(warning    yum (yum install gawk).                                           )
+$(warning  - google for the package in rpm form ('gawk rpm download').         )
+$(warning                                                                      )
+$(error Error: 'gawk' not installed.)
+endif

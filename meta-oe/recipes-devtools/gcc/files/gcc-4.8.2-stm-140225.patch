diff -ruN gcc-gnu-4.8.2/ChangeLog.STM gcc-st40-4.8.2.140205/ChangeLog.STM
--- gcc-gnu-4.8.2/ChangeLog.STM	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/ChangeLog.STM	2013-06-04 10:49:15.000000000 +0200
@@ -0,0 +1,12 @@
+2010-04-12  Christian Bruel  <christian.bruel@st.com>
+
+	* config/mh-mingw (LDFLAGS): Remove wrap rename.
+
+2009-12-07  Yvan Roux  <yvan.roux@st.com>
+
+	* config/mh-mingw (LDFLAGS): Wrap syscall for cygwin path support.
+
+2009-02-03  Christian Bruel  <christian.bruel@st.com>
+
+	* config/mt-ospace: Don't overwrite CFLAGS_FOR_TARGET.
+
diff -ruN gcc-gnu-4.8.2/config/mh-mingw gcc-st40-4.8.2.140205/config/mh-mingw
--- gcc-gnu-4.8.2/config/mh-mingw	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/config/mh-mingw	2013-05-28 13:18:15.000000000 +0200
@@ -6,3 +6,9 @@
 # as GCC turns out to need that much more to pass all the limits-* tests.
 LDFLAGS += -Wl,--stack,12582912
 BOOT_LDFLAGS += -Wl,--stack,12582912
+
+# Activation of CYGPATH feature: Support for cygwin pathes in mingwin32 shell
+#   through syscall wrapping at linker level
+LDFLAGS += -Wl,--wrap,open,--wrap,creat,--wrap,fopen,--wrap,freopen,--wrap,remove,--wrap,unlink,--wrap,stat,--wrap,chdir,--wrap,rmdir,--wrap,opendir,--wrap,access
+
+
diff -ruN gcc-gnu-4.8.2/config/mt-ospace gcc-st40-4.8.2.140205/config/mt-ospace
--- gcc-gnu-4.8.2/config/mt-ospace	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/config/mt-ospace	2013-05-28 13:18:15.000000000 +0200
@@ -1,3 +1,3 @@
 # Build libraries optimizing for space, not speed.
- CFLAGS_FOR_TARGET = -g -Os
- CXXFLAGS_FOR_TARGET = -g -Os
+CFLAGS_FOR_TARGET += -g -Os 
+CXXFLAGS_FOR_TARGET += -g -Os 
diff -ruN gcc-gnu-4.8.2/fixincludes/ChangeLog.STM gcc-st40-4.8.2.140205/fixincludes/ChangeLog.STM
--- gcc-gnu-4.8.2/fixincludes/ChangeLog.STM	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/fixincludes/ChangeLog.STM	2013-05-28 13:18:01.000000000 +0200
@@ -0,0 +1,20 @@
+2008-28-08  Antony King  <antony.king@st.com>
+
+	* check.tpl: Avoid premature termination of script on fgrep -v
+	failure.
+
+2008-27-08  Christian Bruel  <christian.bruel@st.com>
+
+	* fixincl.c (test_test). Dont quote test.
+
+2007-10-02  Antony King  <antony.king@st.com>
+
+	* fixincl.c (cygpath_open): New function.
+	(load_file): Replace open() with cygpath_open().
+	(create_file): Likewise.
+	(process): Likewise.
+	(initialize): Add calls to CYGPATH() and CYGPATH_FREE().
+	(test_test): Add missing quotes.
+	(fix_with_system): Likewise.
+	(fix_with_system): Force use of Unix shell.
+	(main): Redirect stdin to nul: on Windows.
diff -ruN gcc-gnu-4.8.2/fixincludes/check.tpl gcc-st40-4.8.2.140205/fixincludes/check.tpl
--- gcc-gnu-4.8.2/fixincludes/check.tpl	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/fixincludes/check.tpl	2013-05-28 13:18:01.000000000 +0200
@@ -141,9 +141,9 @@
 
 cd $TESTBASE
 
-find * -type f -print | \
+( find * -type f -print | \
 fgrep -v 'CVS/' | \
-fgrep -v '.svn/' > ${TESTDIR}/LIST
+fgrep -v '.svn/' > ${TESTDIR}/LIST ; true )
 
 exitok=`
 exec < ${TESTDIR}/LIST
diff -ruN gcc-gnu-4.8.2/fixincludes/fixincl.c gcc-st40-4.8.2.140205/fixincludes/fixincl.c
--- gcc-gnu-4.8.2/fixincludes/fixincl.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/fixincludes/fixincl.c	2013-05-28 13:18:01.000000000 +0200
@@ -87,6 +87,20 @@
 
 #include "fixincl.x"
 
+static int
+cygpath_open (const char *file, int oflag, mode_t mode)
+{
+  int fd;
+
+#ifdef _O_BINARY
+  oflag |= _O_BINARY;
+#endif
+
+  fd = open (file, oflag, mode);
+
+  return fd;
+}
+
 /* * * * * * * * * * * * * * * * * * *
  *
  *  MAIN ROUTINE
@@ -108,7 +122,11 @@
       and err open so that the proper input file does not get closed
       by accident  */
 
+#if defined(__MSDOS__) || defined(_WIN32)
+  freopen ("nul:", "r", stdin);
+#else
   freopen ("/dev/null", "r", stdin);
+#endif
 
   if (file_name_buf == (char *) NULL)
     {
@@ -197,6 +215,8 @@
 void
 initialize ( int argc, char** argv )
 {
+  char *arg;
+
   xmalloc_set_program_name (argv[0]);
 
   switch (argc)
@@ -207,7 +227,8 @@
     case 2:
       if (strcmp (argv[1], "-v") == 0)
         do_version ();
-      if (freopen (argv[1], "r", stdin) == (FILE*)NULL)
+      arg = argv[1];
+      if (freopen (arg, "r", stdin) == (FILE*)NULL)
         {
           fprintf (stderr, "Error %d (%s) reopening %s as stdin\n",
                    errno, xstrerror (errno), argv[1] );
@@ -311,7 +332,7 @@
       the file size is not a multiple of the page size.  If it is a multiple,
       then this adjustment sometimes fails anyway.  */
   data_map_size = stbf.st_size+1;
-  data_map_fd   = open (fname, O_RDONLY);
+  data_map_fd   = cygpath_open (fname, O_RDONLY, 0);
   ttl_data_size += data_map_size-1;
 
   if (data_map_fd < 0)
@@ -471,7 +492,7 @@
 
   sprintf (fname, "%s/%s", pz_dest_dir, pz_curr_file + find_base_len);
 
-  fd = open (fname, O_WRONLY | O_CREAT | O_TRUNC, S_IRALL);
+  fd = cygpath_open (fname, O_WRONLY | O_CREAT | O_TRUNC, S_IRALL);
 
   /*  We may need to create the directories needed... */
   if ((fd < 0) && (errno == ENOENT))
@@ -496,7 +517,7 @@
         }
 
       /*  Now, lets try the open again... */
-      fd = open (fname, O_WRONLY | O_CREAT | O_TRUNC, S_IRALL);
+      fd = cygpath_open (fname, O_WRONLY | O_CREAT | O_TRUNC, S_IRALL);
     }
   if (fd < 0)
     {
@@ -534,7 +555,7 @@
 test_test (tTestDesc* p_test, char* pz_test_file)
 {
   tSCC cmd_fmt[] =
-"file=%s\n\
+"file='%s'\n\
 if ( test %s ) > /dev/null 2>&1\n\
 then echo TRUE\n\
 else echo FALSE\n\
@@ -847,7 +868,7 @@
 #else
       /* Don't use positional formatting arguments because some lame-o
          implementations cannot cope  :-(.  */
-      tSCC   z_cmd_fmt[] = " %s > %sX ; rm -f %s; mv -f %sX %s";
+      tSCC   z_cmd_fmt[] = " '%s' > '%sX'; rm -f '%s'; mv -f '%sX' '%s'";
 #endif
       tCC**  ppArgs = p_fixd->patch_args;
 
@@ -930,7 +951,34 @@
                pz_temp_file, pz_temp_file, pz_temp_file);
 #endif
     }
+#if 1
+  {
+    char *cmd;
+    char *fname = make_temp_file( 0 );
+    FILE *pf = fopen( fname, "w" );
+    if (pf == NULL)
+      {
+	fprintf (stderr, "Error %d (%s) creating %s\n",
+		 errno, xstrerror (errno), fname);
+	exit (EXIT_FAILURE);
+      }
+    fwrite( pz_cmd, 1, strlen( pz_cmd ), pf );
+    fclose( pf );
+    asprintf( &cmd, "sh %s", fname );
+    if (cmd == NULL)
+      {
+	fprintf (stderr, "Error %d (%s)\n",
+		 errno, xstrerror (errno));
+	exit (EXIT_FAILURE);
+      }
+    system( cmd );
+    free( (void*)cmd );
+    unlink( fname );
+    free( (void*)fname );
+  }
+#else
   system( pz_cmd );
+#endif
   free( (void*)pz_cmd );
 }
 
@@ -1278,7 +1326,7 @@
 
       if (read_fd == -1)
         {
-          read_fd = open (pz_curr_file, O_RDONLY);
+          read_fd = cygpath_open (pz_curr_file, O_RDONLY, 0);
           if (read_fd < 0)
             {
               fprintf (stderr, "Error %d (%s) opening %s\n", errno,
@@ -1332,7 +1380,7 @@
       pz_file_source = pz_temp_file;
     }
 
-  read_fd = open (pz_temp_file, O_RDONLY);
+  read_fd = cygpath_open (pz_temp_file, O_RDONLY, 0);
   if (read_fd < 0)
     {
       if (errno != ENOENT)
diff -ruN gcc-gnu-4.8.2/gcc/basic-block.h gcc-st40-4.8.2.140205/gcc/basic-block.h
--- gcc-gnu-4.8.2/gcc/basic-block.h	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/basic-block.h	2013-05-28 13:15:34.000000000 +0200
@@ -1,5 +1,6 @@
 /* Define control flow data structures for the CFG.
    Copyright (C) 1987-2013 Free Software Foundation, Inc.
+   Copyright (c) 2009 STMicroelectronics.
 
 This file is part of GCC.
 
@@ -719,6 +720,9 @@
 extern struct edge_list *pre_edge_lcm (int, sbitmap *, sbitmap *,
 				       sbitmap *, sbitmap *, sbitmap **,
 				       sbitmap **);
+extern struct edge_list *pre_edge_lcm_avs (int, sbitmap *, sbitmap *,
+					   sbitmap *, sbitmap *, sbitmap *,
+					   sbitmap *, sbitmap **, sbitmap **);
 extern struct edge_list *pre_edge_rev_lcm (int, sbitmap *,
 					   sbitmap *, sbitmap *,
 					   sbitmap *, sbitmap **,
diff -ruN gcc-gnu-4.8.2/gcc/bb-reorder.c gcc-st40-4.8.2.140205/gcc/bb-reorder.c
--- gcc-gnu-4.8.2/gcc/bb-reorder.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/bb-reorder.c	2014-01-24 09:25:59.000000000 +0100
@@ -1998,14 +1998,12 @@
       if (JUMP_P (last_insn)
 	  && (succ->flags & EDGE_CROSSING))
 	{
-	  rtx label2, table;
-
 	  gcc_assert (!any_condjump_p (last_insn));
 
 	  /* Make sure the jump is not already an indirect or table jump.  */
 
 	  if (!computed_jump_p (last_insn)
-	      && !tablejump_p (last_insn, &label2, &table))
+	      && !tablejump_p (last_insn, NULL, NULL))
 	    {
 	      /* We have found a "crossing" unconditional branch.  Now
 		 we must convert it to an indirect jump.  First create
diff -ruN gcc-gnu-4.8.2/gcc/builtins.c gcc-st40-4.8.2.140205/gcc/builtins.c
--- gcc-gnu-4.8.2/gcc/builtins.c	2013-06-06 12:32:56.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/builtins.c	2013-06-07 09:56:46.000000000 +0200
@@ -1,5 +1,6 @@
 /* Expand builtin functions.
    Copyright (C) 1988-2013 Free Software Foundation, Inc.
+   Copyright (c) 2009 STMicroelectronics.
 
 This file is part of GCC.
 
@@ -10043,7 +10044,12 @@
     {
     case BUILT_IN_ISINF:
       if (!HONOR_INFINITIES (TYPE_MODE (TREE_TYPE (arg))))
+	{
+	  if (warn_non_finite_math)
+	    warning (OPT_Wnon_finite_math,
+		     "non-finite operation %q+F always returns 0", fndecl);
 	return omit_one_operand_loc (loc, type, integer_zero_node, arg);
+	}
 
       if (TREE_CODE (arg) == REAL_CST)
 	{
@@ -10092,7 +10098,11 @@
     case BUILT_IN_ISFINITE:
       if (!HONOR_NANS (TYPE_MODE (TREE_TYPE (arg)))
 	  && !HONOR_INFINITIES (TYPE_MODE (TREE_TYPE (arg))))
+	{
+	  warning (OPT_Wnon_finite_math, "non-finite operation %q+D not honored" ,
+		   fndecl);
 	return omit_one_operand_loc (loc, type, integer_one_node, arg);
+	}
 
       if (TREE_CODE (arg) == REAL_CST)
 	{
@@ -10104,7 +10114,11 @@
 
     case BUILT_IN_ISNAN:
       if (!HONOR_NANS (TYPE_MODE (TREE_TYPE (arg))))
+	{
+	  warning (OPT_Wnon_finite_math, "non-finite operation %q+D not honored",
+		   fndecl);
 	return omit_one_operand_loc (loc, type, integer_zero_node, arg);
+	}
 
       if (TREE_CODE (arg) == REAL_CST)
 	{
@@ -10228,7 +10242,12 @@
   if (unordered_code == UNORDERED_EXPR)
     {
       if (!HONOR_NANS (TYPE_MODE (TREE_TYPE (arg0))))
+	{
+	  if (warn_non_finite_math)
+	    warning (OPT_Wnon_finite_math,
+		     "non-finite operation %q+F always returns 0", fndecl);
 	return omit_two_operands_loc (loc, type, integer_zero_node, arg0, arg1);
+	}
       return fold_build2_loc (loc, UNORDERED_EXPR, type, arg0, arg1);
     }
 
diff -ruN gcc-gnu-4.8.2/gcc/c/c-typeck.c gcc-st40-4.8.2.140205/gcc/c/c-typeck.c
--- gcc-gnu-4.8.2/gcc/c/c-typeck.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/c/c-typeck.c	2013-05-28 13:15:34.000000000 +0200
@@ -1746,6 +1746,7 @@
       && !TREE_THIS_VOLATILE (decl)
       && TREE_READONLY (decl)
       && DECL_INITIAL (decl) != 0
+      && !DECL_WEAK (decl)
       && TREE_CODE (DECL_INITIAL (decl)) != ERROR_MARK
       /* This is invalid if initial value is not constant.
 	 If it has either a function call, a memory reference,
diff -ruN gcc-gnu-4.8.2/gcc/c-family/c.opt gcc-st40-4.8.2.140205/gcc/c-family/c.opt
--- gcc-gnu-4.8.2/gcc/c-family/c.opt	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/c-family/c.opt	2013-05-28 13:15:34.000000000 +0200
@@ -1,5 +1,6 @@
 ; Options for the C, ObjC, C++ and ObjC++ front ends.
 ; Copyright (C) 2003-2013 Free Software Foundation, Inc.
+; Copyright (c) 2013 STMicroelectronics.
 ;
 ; This file is part of GCC.
 ;
@@ -1117,7 +1118,7 @@
 Generate run time type descriptor information
 
 fshort-double
-C ObjC C++ ObjC++ Optimization Var(flag_short_double)
+C ObjC C++ ObjC++ Optimization LTO Var(flag_short_double)
 Use the same size for double as for float
 
 fshort-enums
diff -ruN gcc-gnu-4.8.2/gcc/cfg.c gcc-st40-4.8.2.140205/gcc/cfg.c
--- gcc-gnu-4.8.2/gcc/cfg.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/cfg.c	2013-05-28 13:15:34.000000000 +0200
@@ -1,5 +1,6 @@
 /* Control flow graph manipulation code for GNU compiler.
    Copyright (C) 1987-2013 Free Software Foundation, Inc.
+   Copyright (c) 2009 STMicroelectronics.
 
 This file is part of GCC.
 
@@ -476,6 +477,9 @@
       fprintf (file, HOST_WIDEST_INT_PRINT_DEC, e->count);
     }
 
+  if (e->goto_locus)
+    fprintf (file, "locus = %d ", e->goto_locus);
+
   if (e->flags && do_details)
     {
       static const char * const bitnames[] =
diff -ruN gcc-gnu-4.8.2/gcc/cgraph.c gcc-st40-4.8.2.140205/gcc/cgraph.c
--- gcc-gnu-4.8.2/gcc/cgraph.c	2013-06-06 12:32:56.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/cgraph.c	2014-01-24 09:25:59.000000000 +0100
@@ -1261,7 +1261,10 @@
   node->callers = NULL;
 }
 
-/* Release memory used to represent body of function NODE.  */
+/* Release memory used to represent body of function NODE.
+   Use this only for functions that are released before being translated to
+   target code (i.e. RTL).  Functions that are compiled to RTL and beyond
+   are free'd in final.c via free_after_compilation().  */
 
 void
 cgraph_release_function_body (struct cgraph_node *node)
@@ -1286,6 +1289,7 @@
 	  gcc_assert (dom_computed[0] == DOM_NONE);
 	  gcc_assert (dom_computed[1] == DOM_NONE);
 	  clear_edges ();
+	  cfun->cfg = NULL;
 	}
       if (cfun->value_histograms)
 	free_histograms ();
diff -ruN gcc-gnu-4.8.2/gcc/ChangeLog.STM gcc-st40-4.8.2.140205/gcc/ChangeLog.STM
--- gcc-gnu-4.8.2/gcc/ChangeLog.STM	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/ChangeLog.STM	2014-02-05 09:08:29.000000000 +0100
@@ -0,0 +1,1213 @@
+2014-02-04  Christian Bruel  <christian.bruel@st.com>
+
+	* jump.c (redirect_exp_1): Handle indirect non-computed jumps.
+
+2014-01-28  Christian Bruel  <christian.bruel@st.com>
+
+	* final.c (insn_current_reference_address): Fix forward references
+
+2014-01-20  Christian Bruel  <christian.bruel@st.com>
+
+	Backport from trunk
+	2013-04-05  Steven Bosscher  <steven@gcc.gnu.org>
+
+	* bb-reorder.c (fix_crossing_unconditional_branches): Remove a
+	set-but-unused variable.
+
+	* cgraph.c (cgraph_release_function_body): Clear cfun->cfg to make
+	basic blocks of released function bodies garbage-collectable.
+
+	* ree.c (find_and_remove_re): Do not call df_finish_pass here.
+	(struct rtl_opt_pass): Add TODO_df_finish.
+
+	* rtl.def (DEFINE_SUBST, DEFINE_SUBST_ATTR): Add documentation.
+
+2014-01-15  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/superh.h (SUBTARGET_OVERRIDE_OPTIONS) define to orce DWARF3.
+
+2014-01-15  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.c (sh_adjust_cost): Adjust costs for sh4-300.
+
+2014-01-09  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh-mem.cc (sh_expand_cmpnstr): Unroll small sizes and
+	  optimized non constant lengths.
+
+2013-11-29  Christian Bruel  <christian.bruel@st.com>
+
+	Backport from trunk
+	2013-11-26  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/58314
+	PR target/50751
+	* config/sh/sh.c (max_mov_insn_displacement, disp_addr_displacement):
+	Prefix function names with 'sh_'.  Make them non-static.
+	* config/sh/sh-protos.h (sh_disp_addr_displacement,
+	sh_max_mov_insn_displacement): Add declarations.
+	* config/sh/constraints.md (Q): Reject QImode.
+	(Sdd): Use match_code "mem".
+	(Snd): Fix erroneous matching of non-memory operands.
+	* config/sh/predicates.md (short_displacement_mem_operand): New
+	predicate.
+	(general_movsrc_operand): Disallow PC relative QImode loads.
+	* config/sh/sh.md (*mov<mode>_reg_reg): Remove it.
+	(*movqi, *movhi): Merge both insns into...
+	(*mov<mode>): ... this new insn.  Replace generic 'm' constraints with
+	'Snd' and 'Sdd' constraints.  Calculate insn length dynamically based
+	on the operand types.
+
+2013-11-18  Christian Bruel  <christian.bruel@st.com>
+
+        * config/sh/sh.md (cbranch_t): Never split.
+
+2013-11-05  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc/config/sh/sh-mem.cc (sh_expand_strlen): New function.
+	* gcc/config/sh/sh-protos.h (sh_expand_strlen): Declare.
+	* gcc/config/sh/sh.md (strlensi): New pattern.
+	(UNSPEC_BUILTIN_STRLEN): Define.
+
+2013-11-05  Christian Bruel  <christian.bruel@st.com>
+	* gcc/config/sh/sh-mem.cc (sh_expand_cmpnstr, sh_expand_cmpstr):
+	Factorize probabilities, Use adjust_address instead of
+	adjust_automodify_address when possible. Enable for optimize.
+
+2013-10-25  Christian Bruel  <christian.bruel@st.com>
+
+	* config.gcc (sh-*): Add sh-mem.o to extra_obj.
+	* gcc/config/sh/t-sh (sh-mem.o): New rule.
+	* gcc/config/sh/sh-mem.cc (expand_block_move): Moved here.
+	(sh4_expand_cmpstr): New function.
+	* gcc/config/sh/sh.c (force_into, expand_block_move): Move to sh-mem.c
+	* gcc/config/sh/sh-protos.h (sh4_expand_cmpstr): Declare.
+	* gcc/config/sh/sh.md (cmpstrsi, cmpstr_t): New patterns.
+	(rotlhi3_8): Rename.
+
+2013-10-01  Laurent Alfonsi  <laurent.alfonsi@st.com>
+
+	https://bugzilla.stlinux.com/show_bug.cgi?id=36994
+	* gcov-io.c (gcov_open): Truncate the open file when mode<0.
+
+2013-09-19  Christian Bruel  <christian.bruel@st.com>
+
+	PR target/58475
+	* config/sh/sh.md (movsf_ie): Allow fpul_operand.
+	* config/sh/predicate.md (arith_reg_operand): Disallow FPUL_REG.
+
+2013-09-13  Christian Bruel  <christian.bruel@st.com>
+
+        PR target/58314
+        * config/sh/sh.md (mov<mode>_reg_reg): Allow memory reloads.
+
+2013-09-05  Laurent Alfonsi  <laurent.alfonsi@st.com>
+
+	http://codex.cro.st.com/tracker/?func=detail&aid=227681
+	* final.c (shorten_branch): alignment applied on first of successive label.
+
+2013-07-12  Christian Bruel  <christian.bruel@st.com>
+
+	http://codex.cro.st.com/tracker/?func=detail&aid=221318
+	* gcc/ipa-inline.c (inline_small_functions): increase max_count with
+	 indirect_calls edges.
+
+2013-08-30  Christian Bruel  <christian.bruel@st.com>
+
+	Backport from trunk
+	2013-07-24  Joern Rennecke  <joern.rennecke@embecosm.com>
+
+        PR rtl-optimization/57968
+        * mode-switching.c (create_pre_exit): Allow instructions that
+        don't set a return register to need a non-exit mode.
+
+2013-07-24  Laurent Alfonsi  <laurent.alfonsi@st.com>
+
+	* config/sh/sh.md (*cbranch_t): Block optimization if a label is found
+	in between.
+
+2013-07-17  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.md (movsf_ie): Don't generate fmov double_constant->fpul.
+
+2013-05-23  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc.c (do_spec_1): Rename %M to %N.
+
+2013-05-22  Christian Bruel  <christian.bruel@st.com>
+
+	PR debug/57351
+	* config/arm/arm.c (arm_dwarf_register_span): Do not use dbx number.
+
+2013-04-26  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc/config/sh/ieee-754-df.S: Move to libgcc.
+	* gcc/config/sh/ieee-754-df.S: Likewise
+
+2013-04-26  Christian Bruel  <christian.bruel@st.com>
+
+	* dwarf2out.c (multiple_reg_loc_descriptor): Use DBX_REGISTER_NUMBER
+	 for spanning registers.
+
+2013-04-22  Christian Bruel  <christian.bruel@st.com>
+
+	* tree-chrec.c (chrec_convert_1): Check modes.
+	* tree-scalar-evolution.c (interpret_rhs_expr): Likewise.
+
+2013-04-18  Christian Bruel  <christian.bruel@st.com>
+
+	PR target/56995
+	* config/sh/sh.h (enum reg_class): Remove DF_HI_REGS.
+	(REG_CLASS_NAMES): Idem.
+	(REG_CLASS_CONTENTS): Idem.
+	(REGCLASS_HAS_FP_REG): Idem.
+	* config/sh/sh.c (sh_cannot_change_mode_class): Idem.
+	(sh_conditional_register_usage): Idem.
+
+2013-04-12  Laurent Alfonsi  <laurent.alfonsi@st.com>
+
+	* tree-chrec.c (chrec_convert_1): Extend fix PR53676 to unsigned.
+	* tree-scalar-evolution.c (interpret_rhs_expr): Likewise.
+
+2013-03-23  Christian Bruel  <christian.bruel@st.com>
+
+	* sh.md (short_cbranch_p, med_branch_p, med_cbranch_p): Remove.
+	(braf_branch_p, braf_cbranch_p); Remove.
+	(length): Rewrite attribute.
+	* sh.c (short_cbranch_p, med_branch_p, med_cbranch_p): New predicate function.
+	(braf_branch_p, braf_cbranch_p); Likewise.
+	(sh_insn_length_adjustment): Adjust padding for braf branches.
+	(output_far_jump): Refine and add assertions.
+	* sh-protos.h (short_cbranch_p, med_branch_p, med_cbranch_p): Declare.
+	(braf_branch_p, braf_cbranch_p); Declare.
+
+2013-02-13  Laurent Alfonsi  <laurent.alfonsi@st.com>
+
+	* tree.c (build_one_cst, build_zero_cst): Use boolean global nodes.
+
+2013-01-31  Christian Bruel  <christian.bruel@st.com>
+
+	* sh.c (sh_expand_prologue): Check args.pretend_args_size to push args.
+
+2013-01-31  Laurent Alfonsi  <laurent.alfonsi@st.com>
+
+	http://codex.cro.st.com/tracker/?func=detail&aid=197859
+	* config/sh/sh.c (sh_insn_length_adjustment): Fix adjustment size for
+	insn located inside the sequences.
+
+2013-01-21  Christian Bruel  <christian.bruel@st.com>
+
+	* sh.h (CASE_VECTOR_SHORTEN_MODE): Pessimize switch mode before
+	 constant pools.
+
+2012-11-23  Christian Bruel  <christian.bruel@st.com>
+
+	* toplev.c (compile_file): Emit __gnu_lto_v1 only if HAVE_LTO_PLUGIN.
+	* collect2.c (scan_prog_file): __gnu_lto_v1 not implemented check.
+
+2013-01-12  Christian Bruel  <christian.bruel@st.com>
+
+	https://bugzilla.stlinux.com/show_bug.cgi?id=25892
+	* config/sh/sh.c (sh_expand_prologue): Postpone new_stack mem symbol.
+	(broken_move): Handle UNSPECV_SP_SWITCH_B.
+	* config/sh/sh.md (sp_switch_1): Use set (reg:SI SP_REG).
+
+2013-01-12  DJ Delorie  <dj@redhat.com>
+
+	* config/sh/sh.md (UNSPECV_SP_SWITCH_B): New.
+	(UNSPECV_SP_SWITCH_E): New.
+	(sp_switch_1): Change to an unspec.
+	(sp_switch_2): Change to an unspec.  Don't use post-inc when we
+	replace $r15.
+
+2013-01-10  Laurent Alfonsi  <laurent.alfonsi@st.com>
+
+	* c-family/c.opt (flag_short_double): Useful also for LTO phase.
+	* lto/lto-lang.c (lto_init): LTO initialized with flag_short_double.
+
+2012-12-21  Christian Bruel  <christian.bruel@st.com>
+
+       * configure.ac: Set target_header_dir with build-sysroot.
+       * configure: Regenerate.
+       * config.in: Regenerate.
+
+2012-11-18  Christian Bruel  <christian.bruel@st.com>
+
+        * lto-opts.c (append_to_collect_gcc_options): Check !*first_p.
+
+2012-12-05  Laurent Alfonsi  <laurent.alfonsi@st.com>
+
+	* config/sh/sh.md (*muladdsi3): add clobber register macl.
+
+2012-11-08  Laurent Alfonsi  <laurent.alfonsi@st.com>
+
+	http://codex.cro.st.com/tracker/?func=detail&aid=180343
+	* gcc.c (LINK_COMMAND_SPEC): Skip -lgcov in case of nostdlib.
+
+2012-11-05  Christian Bruel  <christian.bruel@st.com>
+
+	* tree-ssa-tail-merge.c (replace_block_by): Update bb->count.
+
+2012-10-29  Christian Bruel  <christian.bruel@st.com>
+
+	PR target/32163
+	* config/sh/sh.md (stack_protect_test_si): Check stack_protector_block.
+	(sym_label2reg): Revert use of gen_chk_guard_add.
+	(chk_guard_add): Delete.
+	(UNSPEC_CHKADD): Delete.
+	* config/sh/sh.c (stack_protector_block): New function.
+	* config/sh/sh-protos.h (stack_protector_block): Declare.
+
+2012-08-29  Christian Bruel  <christian.bruel@st.com>
+
+	PR target/54546
+	* config/sh/sh-protos.h (sh_need_epilogue): Delete.
+	(sh_can_use_simple_return_p): Declare.
+	* config/sh/sh.c (sh_can_use_simple_return_p): Define.
+	(sh_need_epilogue, sh_need_epilogue_known): Delete.
+	(sh_output_function_epilogue): Remove sh_need_epilogue_known.
+	* config/sh/sh.md (simple_return, return): Define.
+	(epilogue): Use inline return rtl.
+	(sh_expand_epilogue): Cleanup parameters boolean type.
+	(any_return): New iterator.
+
+2012-08-09 Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/newlib.h: Add NO_IMPLICIT_EXTERN_C.
+
+2012-07-19  Christian Bruel  <christian.bruel@st.com>
+
+	PR target/54029
+	* config/sh/sh.c (gen_far_branch): Set JUMP_LABEL for return jumps.
+
+2012-06-22  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.md (*muladdsi3): New pattern.
+
+2012-06-22  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.c (sh_reorg): Check for return rtx.
+
+2012-06-13  Christian Bruel  <christian.bruel@st.com>
+
+	PR target/53621
+	* config/sh/sh.c (sh_option_override): Don't force
+	 flag_omit_frame_pointer and maccumulate_outgoing_args.
+	* config/sh/sh.opt (maccumulate-outgoing-args): Init as Var.
+
+2012-06-06  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.md (arith_shiftsi): New pattern.
+
+2012-05-21  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/superh.h (LIB_SPEC): Use board_link libs for LTO.
+
+2012-04-23  Christian Bruel  <christian.bruel@st.com>
+
+	https://bugzilla.stlinux.com/show_bug.cgi?id=18466
+	* config/sh/sh.c (sh_asm_count): Handle .fill directive.
+	(sh_insn_length_adjustment): Fix far jump offset.
+	(output_far_jump): Likewise.
+
+2012-04-23  Christian Bruel  <christian.bruel@st.com>
+
+	* final.c (print_address): New debug function.
+	* insn-addr.h (print_address): Declare.
+
+2012-04-11 Christian Bruel  <christian.bruel@st.com>
+
+	* gcc/gcc/opts.c (default_options_table): Add OPT_fcse_sincos.
+	* gcc/gcc/tree-ssa-math-opts.c (execute_cse_sincos): Test OPT_fcse_sincos.
+	* gcc/doc/invoke.tex (-fcse-sincos): Describe.
+
+2012-03-15  Laurent Alfonsi <laurent.alfonsi@st.com>
+	Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.c (sh_reorg): Uses eh_label instead of eh_region.
+	(handler_uses_reg): Don't check defs after jump.
+	* except.c (for_each_eh_region): Deleted.
+	(for_each_eh_label): Add parameter.
+	* reload1.c (set_initial_label_offsets): Likewise.
+	 (set_initial_eh_label_offset): Likewise.
+
+2012-02-10  Christian Bruel  <christian.bruel@st.com>
+
+	* reload1.c (calculate_elim_costs_all_insns): Allow PARALLEL patterns.
+
+2012-01-18  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.md (UNSPEC_STR): Fix.
+	(UNSPEC_ROT): Likewise.
+
+2011-12-22  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.h (MOVE_BY_PIECES_P): Tuned.
+	(MOVE_BY_PIECES_P): Likewise.
+
+2011-11-22  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.c (sh_hw_workaround): Handle .align in absolute offsets.
+
+2011-11-15  Christian Bruel  <christian.bruel@st.com>
+
+	Port from Stlinux Mon Feb 02 2009 Carl Shaw <carl.shaw@st.com>
+	* config/sh/lib1funcs.asm (_ic_invalidate_syscall): New function.
+	* config/sh/t-linux (LIB1ASMFUNCS_CACHE: Add _ic_invalidate_syscall.
+
+2011-11-15  Christian Bruel  <christian.bruel@st.com>
+
+	* final.c (shorten_branches): Shorten branches even in -O0.
+
+2011-11-15  Christian Bruel  <christian.bruel@st.com>
+
+	* varasm.c (default_unique_section): Fix order of partition strings.
+
+2011-11-14  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/linux.h (SUBTARGET_CPP_SPEC): Define __SH4_300__ if -m4-300.
+
+2011-10-26  Christian Bruel  <christian.bruel@st.com>
+
+        https://bugzilla.stlinux.com/show_bug.cgi?id=14812
+	* final.c (insn_current_reference_address): Use min length to pessimize
+	a forward branch address.
+
+2011-10-13  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.c (sh_insn_length_adjustment): Use cur_length.
+
+2011-07-09  Christian Bruel  <christian.bruel@st.com>
+
+	* tree-inline.c (tree_inlinable_function_p): Use sorry instead of error.
+
+2011-08-05  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.h (LEGITIMATE_CONSTANT_P): replace by
+	 sh_legitimate_constant_p().
+	* config/sh/sh.c (sh_legitimate_constant_p): New function from
+	 LEGITIMATE_CONSTANT_P.
+	Don't allow fldi1/fldi0 in reload propagation.
+	(fldi_ok): Check TARGERT_FLDI.
+	* config/sh/sh-protos.h (sh_legitimate_constant_p): Add prototype.
+	* config/sh/sh.opt (-mfldi): New option.
+	* gcc/doc/invoke.tex (-mfldi): Describe.
+
+2011-07-19  Christian Bruel  <christian.bruel@st.com>
+
+	* cgraphunit.c (process_function_and_variable_attributes): don't warn
+	always_inline for static functions.
+
+2011-05-25  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/embed-elf.h (TARGET_BUILTIN_TRAPA): Define.
+	* config/sh/sh.md (trap): Define insn.
+
+2011-04-19  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc/config/sh/sh.h (TARGET_IEEE): Set to 1.
+
+2011-03-21  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc/defaults.h (ASM_ALIGN_FUNCTION_LOG): Define.
+	* gcc/varasm.c (assemble_start_function): Use ASM_ALIGN_FUNCTION_LOG.
+	* gcc/config/sh/sh-protos.h (sh_align_function_log): Declare.
+	* gcc/config/sh/sh.c (sh_align_function_log): Define.
+	* gcc/config/sh/sh.h (sh_align_function_log): Define.
+	* gcc/defaults.h (ASM_ALIGN_FUNCTION_LOG): Define.
+
+2011-04-18  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc/config/sh/sh.md (divsi3): Emit barrier after jump.
+
+2011-03-07  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc/config/sh/sh.c (expand_block_move): Optimize block copies by chunks of 48 bytes.
+
+2011-03-07  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc/config/sh/sh.c (expand_sfunc_op): Fix REG_EQUAL note.
+	(sh_output_mi_thunk): Fix REG_DEAD note.
+
+2011-04-15  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc/config/sh/sh.c (sh_output_function_epilogue): Reset mdep_reorg_phase.
+	  (sh_output_mi_thunk): Add barrier.
+	* gcc/resource.c (incr_ticks_for_insn): Add assert.
+
+2011-03-29  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.c (sh4_expand_cmpstr): Define.
+	* config/sh/sh.md (cmpstrsi): Define.
+
+2011-01-24  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc/read-md.c (print_rtx_ptr_loc): Don't emit #line for .md files
+
+2011-01-24  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc/config/sh/sh.md (movsf_ie): Adjust fp_mode for fldi instructions.
+
+2011-01-12  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc/config/sh/sh.c (handler_uses_reg): Fix landing_pad scan.
+
+2011-01-11  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc/config/sh/sh.c (movsf_ie): Fix fp_mode.
+
+2010-11-30  Christian Bruel  <christian.bruel@st.com>
+
+        https://bugzilla.stlinux.com/show_bug.cgi?id=10586
+	* gcc/config/sh/sh.c (find_barrier): Skip notes.
+	(sh_asm_count): Conservately count aligns before reorg.
+
+2010-11-08  Christian Bruel  <christian.bruel@st.com>
+
+        https://bugzilla.stlinux.com/show_bug.cgi?id=10391
+	* gcc/ira.c (update_equiv_regs): Don't propagate after blockage.
+
+2010-11-03  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh-protos.h (sh_expand_lround): Addto_nearest flag.
+	* gcc/config/sh/sh.c (sh_expand_lround): Use to_nearest flag.
+	* gcc/config/sh/sh.md (lroundsfsi2): Define.
+
+2010-10-13  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh-protos.h (sh_expand_lround): Declare.
+	* gcc/config/sh/sh.c (sh_expand_lround): Define.
+	* gcc/config/sh/sh.md (UNSPEC_BUILTIN_ROUND, lrintsfsi2): Define.
+
+2010-09-29  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.h (sh_compare_op0, sh_compare_op1): Delete.
+
+2010-09-24  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc/gcc.c (process_command): -no-canonical-prefixes set by default.
+
+2010-09-23  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.h (TARGET_CPU_CPP_BUILTINS): Define __MOVD__.
+	(ROUND_TYPE_ALIGN, MOVE_BY_PIECES_P): Fix test.
+	* config/sh/sh.c (expand_block_move): Don't toggle sz bit.
+
+2010-09-20  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.c (dump_table): Fixed constants alignments for 
+	TARGET_ALIGN_DOUBLE.
+
+2010-09-02  Christian Bruel  <christian.bruel@st.com>
+
+	* final.c (remap_debug_filename): translate filename for CYGPATH.
+
+2010-08-12  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.opt (mdiv=call-pre1): New option.
+	* config/sh/sh.h (SH_DIV_CALL_PRE1): New sh_div_strategy.
+	* config/sh/sh.md (sdivsi3): Use TARGET_DIVIDE_CALL_PRE1.
+	 (ashlsi3_k): New pattern.
+	* doc/invoke.texi (mdiv=call-pre1): Document.
+
+2010-07-21  Christian Bruel  <christian.bruel@st.com>
+
+        https://bugzilla.stlinux.com/show_bug.cgi?id=9620
+        * config/sh/sh.c (find_barrier): Update alignement after barrier.
+
+2010-07-07  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.h (SUBTARGET_ASM_ISA_SPEC): Pass --tas to assembler
+	(TARGET_CPU_CPP_BUILTINS): Define __HAVE_TAS__.
+
+2010-07-05  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc/config/sh/sh.c (sh_dwarf_register_span): No span if TARGET_FMOVD.
+	(push_regs): Push FP_REGISTER first.
+	(pop_regs): Pop FP_REGISTER last.
+	(emit_fpu_flip): Switch size if TARGET_FMOVD.
+
+2010-07-02  Christian Bruel  <christian.bruel@st.com>
+
+	* doc/md.texi: Document SH constraints.
+
+2010-06-04  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc/config/sh/supervisor-atomic.asm: (sync_nand_and_fetch): Fix
+	* gcc/config/sh/linux-atomic.asm: (sync_nand_and_fetch): Fix
+	(__sync_bool_compare_and_swap_, __sync_val_compare_and_swap_).
+	 Reorganized.
+
+2010-06-04  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc/gthr-generic.c: Change license to GPLv3.
+	* gcc/gthr-generic.h: Likewise
+	* gcc/config/sh/supervisor-atomic.asm: Likewise
+	* gcc/config/sh/ieee-754-df.S: Likewise
+	* gcc/config/sh/ieee-754-df.S: Likewise
+
+2010-06-03  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/crti.asm (_init, _fini): Remove underscore.
+	* config/sh/crt1.asm (_init, _fini): Likewise.
+
+2010-06-02  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/linux.h (TARGET_OS_CPP_BUILTINS): Make __GNUC_STM_RELEASE__.
+
+2010-04-20  Christian Bruel  <christian.bruel@st.com>
+
+	INSbl30850:
+	* config/sh/ieee-754-df.S (nedf2f): Don't check Qbit for NaNs.
+	* config/sh/ieee-754-sf.S (nesf2f): Likewise.
+	* config/sh/sh.md (cmpunsf_i1, cmpundf_i1): Likewise. Clobber R2.
+
+2010-04-09  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc/sched-deps.c (sched_analyze_1): Don't extend R0 lifetime.
+	* config/sh/sh.md (movsf_ie): fix clobber constraint.
+
+2010-03-27  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.c (sh_insn_length_adjustment): Adjust instruction size
+	 for jump_compact.
+
+2010-02-10  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.c (find_barrier): Don't emit a CP inside the GP setting.
+
+2010-01-04  Christian Bruel  <christian.bruel@st.com>
+
+        https://bugzilla.stlinux.com/show_bug.cgi?id=8178
+	* final.c (shorten_branches): Enable asm statements to vary.
+ 	* config/sh/sh.c (asm_size): Catch multiple .long asm statements.
+	(sh_insn_length_alignment): New function.
+	(sh_asm_count): force max addr if insn_current_address unknown.
+	* config/sh/sh-protos.h (sh_insn_length_alignment): Declare.
+	* config/sh/sh.h (INSN_LENGTH_ALIGNMENT): Call sh_insn_length_alignment.
+
+2010-01-26  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/t-sh: Remove duplicate gt-sh.h dependencies.
+
+2009-10-26  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.h (ACCUMULATE_OUTGOING_ARGS): Define.
+	(MASK_ADJUST_UNROLL): Remove.
+        (OVERRIDE_OPTION): Check and set.
+	* config/sh/sh.opt (maccumulate-outgoing-args): New Target option.
+	(madjust-unroll): Remove.
+	* doc/invoke.texi (maccumulate-outgoing-args, madjust-unroll): Likewise.
+	* gcc/config/sh/sh.c (rounded_frame_size): Alloc outgoing args.
+
+2009-11-03  Christian Bruel  <christian.bruel@st.com>
+
+        https://bugzilla.stlinux.com/show_bug.cgi?id=7377
+ 	* config/sh/sh.c (sh_insn_length_adjustment): Adjust jumps labels with
+	alignment.
+
+2009-10-29  Yvan Roux  <yvan.roux@st.com>
+
+	* doc/invoke.texi (-Wbranch-probabilities-computation): Document.
+	* common.opt (-Wbranch-probabilities-computation): New warning option.
+	* profile.c (compute_branch_probabilities): Ignore inconsistent bb
+	and/or edge counts computation if -Wbranch-probabilities-computation is
+	given.
+
+2009-10-28  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.h (SUBTARGET_ASM_ISA_SPEC): --isa=sh4-up for generic SH4s.
+
+2009-10-26  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.h (SUBTARGET_ASM_ISA_SPEC): Fix specs for -m4-singles.
+
+2009-10-22  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/lib1funcs.asm (udiv_qrnnd_16): Fix alignment.
+
+2009-10-21  Christian Bruel  <christian.bruel@st.com>
+	    Yvan Roux  <yvan.roux@st.com>
+
+	* config/sh/sh.c (sh_reorg): Fix relax after incoming edges.
+
+2009-10-16  Christian Bruel  <christian.bruel@st.com>
+
+	* cfg.c (dump_edge_info): Print locus.
+	* cfgexpand.c (expand_gimple_basic_block): Initialize goto_locus.
+
+2009-10-14  Antony King  <antony.king@st.com>
+
+	INSbl30528:
+	* gcc.c (do_spec_1): Add support for %M specs.
+	(getenv_spec_function): Allow multiple arguments.
+	* doc/invoke.texi: Likewise.
+
+2009-10-15  Christian Bruel  <christian.bruel@st.com>
+	    Yvan Roux  <yvan.roux@st.com>
+
+	* config/sh/sh.c (handler_uses_reg): New function.
+	(sh_reorg): Call for each region.
+	* except.c (struct eh_region): Move to except.h
+	(for_each_eh_region): Accepts parameter.
+	* except.h (struct eh_region): Move here.
+	* tree-cfg.c (for_each_eh_region): Accepts parameter.
+
+2009-10-12  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.c (sh_output_mi_thunk): Mark temporary dead.
+
+2009-10-06  Antony King  <antony.king@st.com>
+
+	INSbl30052:
+	* config/sh/t-superh [LIB2FUNCS_EXTRA]: Add.
+	* config/sh/supervisor-atomic.asm: New file.
+
+2009-10-09  Christian Bruel  <christian.bruel@st.com>
+
+	* doc/invoke.texi (mdead-delay): Document.
+	* doc/gcc.info (mdead-delay): Document.
+
+2009-10-05  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.c (sh_reorg): Call df_analyze for notes.
+
+2009-10-02  Christian Bruel  <christian.bruel@st.com>
+	    Yvan Roux  <yvan.roux@st.com>
+
+	* defaults.h (HOT_TEXT_SECTION_PREFIX,
+	 UNLIKELY_EXECUTED_TEXT_SECTION_PREFIX): New macros.
+	* dwarf2out.c (dwarf2out_init, dwarf2out_finish): unlikely_text_section
+	takes param.
+	* predict.c (choose_function_section): Remove.
+	* varasm.c (first_function_block_is_cold): Remove.
+	(initialize_cold_section_name): Handle named unlikely sections.
+	(unlikely_text_section): Takes tree parameter.
+	(unlikely_text_section_p): Remove.
+	(function_section): Handle cold sections.
+	* output.h (first_function_block_is_cold): Remove.
+	(unlikely_text_section_p): Likewise.
+	(unlikely_text_section): Takes tree parameter.
+	* config/i386/i386.c: first_function_block_is_cold renamed 
+	in_cold_section_p.
+
+2009-08-28  Jan Beulich  <jbeulich@novell.com>
+
+	* configure.ac: For in-tree ld, do a plain version check to
+	determine whether comdat groups are supported.
+	* configure: Regenerate.
+
+2009-09-24  Christian Bruel  <christian.bruel@st.com>
+
+	http://gcc.gnu.org/bugzilla/show_bug.cgi?id=41486
+	* config/sh/sh.h (flag_tree_cselim): Unset flag_tree_cselim.
+
+2009-09-24  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.c (sh_set_return_address): Fix adjustment.
+	* config/sh/sh.h (flag_omit_frame_pointer): Set.
+	* config/sh/sh.md (RTX_FRAME_RELATED_P): Set.
+
+2009-09-24  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.c (sh_optimization_options): Set flag_omit_frame_pointer.
+
+2009-09-03  Christian Bruel  <christian.bruel@st.com>
+
+	https://bugzilla.stlinux.com/show_bug.cgi?id=7000
+	* config/sh/sh.md (movdf_i4): Fix length attribute.
+	* config/sh/sh.c (sh_jump_align): Rework.
+
+2008-05-06  Christian Bruel  <christian.bruel@st.com>
+
+	INSbl/28671
+	* tree-ssa-ccp.c (get_symbol_constant_value): Check DECL_WEAK.
+	* c-typeck.c (decl_constant_value): Likewise.
+
+2009-08-14  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/t-linux (LIB1ASMMFUNCS_DIVTABLE): Define.
+	* config/sh/t-sh (libgcc-4-200.a): Create.
+	(LIB1ASMMFUNCS_DIVTABLE): Use.
+	(LIB1ASMFUNCS): Remove _sdivsi3_i4 _udivsi3_i4 _div_table from built.
+	* config/sh/embed-elf.h (LIBGCC_SPEC): Fixed lgcc-X-4-200 specs.
+	* config/sh/lib1funcs.asm (ieee-754-X.S): Guard against L_div_table.
+
+2009-08-07  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc/config/sh.c (fixup_mova): Fix casesi_worker access.
+	(dump_table): Likewise.
+
+2009-07-30  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc/config.gcc (fix-proto): Set to no for SH.
+
+2009-07-27  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/t-linux (EXTRA_MULTILIB_PARTS): Set.
+	* config/sh/t-sh (unwind-dw2-Os-4-200.o): Remove.
+
+2009-07-27  Christian Bruel  <christian.bruel@st.com>
+
+        * config/sh/sh.h (OPTIMIZATION_OPTIONS): Set dead-delay if optimizing.
+	* config/sh/sh.opt (mdead-delay): don't force 0.
+
+2009-07-02  Christian Bruel  <christian.bruel@st.com>
+
+	* tree-sra.c (bitfield_overlaps_p): Fix array tree type check.
+
+2009-06-18  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.h (simultaneous-prefetches): Set for st40-300.
+
+2009-06-18  Christian Bruel  <christian.bruel@st.com>
+
+	https://bugzilla.stlinux.com/show_bug.cgi?id=6459
+	* config/sh/sh.md (cbranchdi4_i): Don't define insn.
+
+2009-06-05  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc/config/sh.c (expand_block_move): Improve 64 bit -mfmovd.
+
+2009-06-09  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.h (SUBTARGET_ASM_ISA_SPEC): Pass -isa=sh4-nofpu-up
+	 for m4-nofpu.
+
+2009-04-12  Christian Bruel  <christian.bruel@st.com>
+
+	* default.h (TARGET_USES_LEB128): New macro.
+	* config/sh/sh.h (TARGET_USES_LEB128): Redefine.
+	* dwarf2asm.c (TARGET_USES_LEB128): Use instead of HAVE_AS_LEB128.
+	* except.c: Likewise.
+	* doc/tm.texi (TARGET_USES_LEB128): Document.
+	* doc/tm.texi.in (TARGET_USES_LEB128): Document.
+	* doc/gccint.info (TARGET_USES_LEB128): Likewise.
+
+2009-05-05  Antony King  <antony.king@st.com>
+	    Christian Bruel  <christian.bruel@st.com>
+
+        INSbl30131
+	* lib1funcs.asm: Change local label naming convention.
+	* lib1funcs-Os-4-200.asm: Idem.
+
+2009-04-09  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/t-sh (ic_invalidate_array_4a.o): Fix st40-300 isa build.
+       (ic_invalidate_4a): Idem.
+        * config/sh/embed-elf.h (LIBGCC_SPEC): Fix ic_invalidate*.
+	* config/sh/sh.h (TARGET_CPU_DEFAULT, SUBTARGET_ASM_ISA_SPEC): Idem.
+	(ASM_ISA_SPEC_DEFAULT): Idem.
+
+2009-04-09  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.md (load_gbr): Fix operand constraint.
+
+2009-03-31  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.c (broken_move): Fixed.
+
+2009-03-31  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.h (OVERRIDE_OPTIONS, OPTIMIZATION_OPTIONS): Set
+	flag_emit_frame_pointer.
+
+2009-03-24  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/trap-handler.c (exit): Declare noreturn.
+	* config/sh/t-sh $(CFLAGS_FOR_TARGET): passed to trap-handler build.
+
+2009-03-10  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.c (sh_expand_epilogue): Don't insert blockage.
+
+2009-03-09  Christian Bruel  <christian.bruel@st.com>
+
+	INSbl21915
+	* config/sh/sh.h (SH_LINK_SPEC): Pass -shared on -pic.
+
+2009-03-09  Christian Bruel  <christian.bruel@st.com>
+
+	* configure.ac: Change BUGURL, PKGVERSION.
+	* configure: Regenerate.
+
+2009-03-03  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.h (CASE_VECTOR_MODE): Fix offset size for hwbug.
+	* config/sh/sh.c (sh_insn_length_adjustment): Fix pools for hwbug.
+
+2009-02-16  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/superh.h (SUBTARGET_ASM_RELAX_SPEC): Remove.
+	* config/sh/sh.h (SUBTARGET_ASM_RELAX_SPEC): Likewise.
+	(subtarget_asm_relax_spec). Likewise.
+
+2009-02-05  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.c (asm_size): Handle alignments.
+	(sh_asm_count): Likewise.
+	(sh_hw_workaround): Redesigned.
+	* config/sh/sh.h (SH_LINK_SPEC): pass --db-page-bug to the linker.
+	(INSN_LENGTH_ALIGNMENT): Fix minimum alignment.
+	* config/sh/linux-atomic.h: DB_ST40300_BUG_WORKAROUND fixes.
+	* config/sh/lib1funcs.asm: Likewise.
+
+2009-01-24  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.md (ivsi_inv_hitable): Fix alternative.
+	(divsi_inv_qitable): Likewise.
+
+2009-01-24  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/constraints.md (R03): New constraint.
+
+2009-01-24  Christian Bruel  <christian.bruel@st.com>
+
+	* emit-rtl.c (emit_insn_after_1): Update SEQUENCE.
+
+2009-01-20  Christian Bruel  <christian.bruel@st.com>
+
+	* final.c (TARGET_ASM_COUNT): Use.
+	* config/sh/sh-protos.h (sh_asm_count): Declared.
+	* config/sh/sh.h (TARGET_ASM_COUNT): Declared.
+	* config/sh/sh.c (sh_asm_count): Defined.
+
+2009-01-19  Christian Bruel  <christian.bruel@st.com>
+
+	* final.c (asm_insn_count): Check for empty asm.
+
+2009-01-05  Christian Bruel  <christian.bruel@st.com>
+
+	INSbl29600
+	* config/sh/sh.c (sh_dwarf_register_span): New function.
+	(TARGET_DWARF_REGISTER_SPAN): Defined.
+	* config/sh/sh-protos.h (sh_dwarf_register_span): Declared.
+
+2008-12-08  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.c (sh_insn_length_adjustment): Optimize out delay slot.
+	* config/sh/sh.md (dup_db_insn): New unspec pattern.
+	* config/sh/sh.opt (mdead-delay): New option.
+	* final.c (realloc_insn_lengths): New function.
+	* output.h (realloc_insn_lengths): Declare.
+
+2008-12-08  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.h (OPVERRIDE_OPTIONS): Don't force function alignment.
+
+2008-11-28  Christian Bruel  <christian.bruel@st.com>
+
+	INSbl29605
+	* config/sh/sh.opt (mfmovd): Document.
+
+2008-11-27  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.h (CAN_DEBUG_WITHOUT_FP): Defined.
+
+2008-11-14  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.opt (mspace): Removed.
+	* doc/invoke.texi (mspace): Removed.
+	* config/sh/sh.h: Use optimize_size for TARGET_SMALLCODE.
+	* config/sh/sh.c: Likewise.
+	* config/sh/t-sh (TARGET_LIBGCC2_CFLAGS): Defined.
+
+2008-10-30  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.c (sh_reorg): Allow relaxation within simple loops.
+
+2008-10-24  Christian Bruel  <christian.bruel@st.com>
+
+	https://bugzilla.stlinux.com/show_bug.cgi?id=4907
+	* config/sh/sh.md (casesi_worker_x): Add MEM indirect.
+	* config/sh/sh.c (sh_insn_length_adjustment): Handle casesi_worker.
+
+2008-10-12  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.c (sh_forward_branch_p): Handle casesi_worker.
+
+2008-05-28  Antony King  <antony.king@st.com>
+
+	Fix INSbl27707:
+	* config/sh/superh.h (LIB_SPEC): Re-order libraries.
+
+2008-08-03  Christian Bruel  <christian.bruel@st.com>
+
+	INSbl/24528
+	* config/sh/sh.md (ashrsi2_16): make it a define_expand.
+	(ashrsi2_31): Likewise.
+
+2008-08-03  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.c (find_barrier): Update lengths for conditional branches.
+
+2008-07-09  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/linux.h: (SUBTARGET_LINK_SPEC): Options passed to the linker.
+	* config/sh/sh.h (TARGET_CPU_CPP_BUILTINS): Define DB_ST40300_BUG_WORKAROUND.
+	(OVERRIDE_OPTIONS): Set align_functions.
+	* config/sh/sh.c (sh_hw_workaround, sh_forward_branch_p): New function.
+	(sh_insn_length_adjustment): Add length parameter, 
+	adjust length for workaround.
+	* config/sh/sh_protos.h (sh_hw_workaround): Likewise.
+	(sh_insn_length_adjustment): Add length parameter.
+	* final.c (final_scan_insn): call FINAL_PRESCAN_INSN.
+	* config/sh/sh.md (db-page-bug): new option.
+	* config/sh/sh.opt (mdb-page-bug): New option.
+
+2008-07-02  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.md (consttable_end): set length.
+	* config/sh/sh.h (MD_CAN_REDIRECT_BRANCH): Disable.
+	* final.c (shorten_branches): Add assertion.
+	* config/sh/sh.c (sh_jump_align): Use get_attr_min_length.
+	(barrier_align): Likewise.
+	(find_barrier): Take into account alignments into size.
+	(sh_reorg): use init_insn_lengths instead of INSN_ADDRESSES_FREE.
+
+2008-06-22  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.c (sh_cfun_naked_p): New function.
+	(sh_handle_fndecl_attribute): Likewise.
+	(sh_attribute_table): Add "naked".
+	(sh_expand_prologue): Check sh_cfun_naked_p.
+	(sh_expand_prologue): Likewise.
+
+2008-06-22  Christian Bruel  <christian.bruel@st.com>
+
+	INSbl/24993
+	* config/sh/elf.h (MAX_OFILE_ALIGNMENT): Define.
+
+2008-04-25  Christian Bruel  <christian.bruel@st.com>
+
+	INSbl/28502
+	* config/sh/sh.c (barrier_align): Skip notes.
+
+2007-12-12  Christian Bruel  <christian.bruel@st.com>
+
+	* store-layout.c (finalize_record_size): Fixed TYPE_ALIGN.
+	* sh.c (expand_block_move): Optimize 64 bits copies if -mfmovd.
+	* sh.h (MOVE_BY_PIECES_P): Handle -mfmov.
+	(ROUND_TYPE_ALIGN): Likewise.
+
+2007-10-23  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/t-sh (_addsub_sf, _mul_sf, _addsub_df,  _extendsfdf2,
+	 _truncdfsf2, _fixunssfsi, _fixsfsi, _floatunssisf, _floatsisf,
+	_fixdfsi _floatunssidf _floatsidf, _muldf3, _divsf3): Renamed.
+	* config/sh/ieee-754-df.S: Likewise.
+	* config/sh/ieee-754-sf.S: Likewise.
+
+2007-10-23  Yvan Roux  <yvan.roux@st.com>
+
+	* config/sh/lib1funcs-4-300.asm (le128_neg): Fixed.
+
+2007-10-04  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc.c (for_each_path): Check just_multi_suffix and multi_suffix.
+
+2007-10-04  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/t-linux (LIB1ASMFUNCS_CACHE): Cleaned up.
+
+2007-10-03  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.md (cmpnedf_i1): Fix.
+
+2007-09-20  Yvan Roux  <yvan.roux@st.com>
+
+	* config/sh/t-sh: (LIB1ASMFUNCS) Add asm functions.
+	* config/sh/ieee-754-df.S: Fixed.
+	* config/sh/IEEE-754/m3/divsf3.S: Fixed.
+	* config/sh/IEEE-754/m3/divdf3.S: Fixed.
+	* config/sh/IEEE-754/m3/addsf3.S: Fixed.
+	* config/sh/IEEE-754/m3/adddf3.S: Fixed.
+	* config/sh/IEEE-754/m3/mulsf3.S: Fixed.
+	* config/sh/IEEE-754/m3muldf3.S: Fixed.
+
+2007-08-14  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* configure.ac (SYSTEM_HEADER_DIR): Adjust for in-tree Newlib.
+	* configure: Regenerate.
+
+2007-07-16  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.h (MOVE_MAX_PIECES): Tuned for TARGET_SH1.
+
+2007-05-23  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.opt (align-small-blocks=): New Optimisation.
+	* doc/invoke.texi (align-small-blocks=): Likewise.
+	* config/sh/sh.c (sh_jump_align): Check sh_align_small_blocks.
+
+2007-04-30  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh-protos.h (sh_jump_align): New Function.
+	* config/sh/sh.c (sh_jump_align): Likewise.
+	(barrier_align): compute alignment based on TARGET_CACHE32.
+	* config/sh/sh.h (JUMP_ALIGN): Define.
+
+2007-03-29  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc/config/sh/sh.h (OVERRIDE_OPTIONS): Set assembler_dialect for sh1.
+
+2007-03-28  Christian Bruel  <christian.bruel@st.com>
+	* doc/invoke.texi: Document -m4-300.
+
+2007-03-09  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/sh.c (__nesf2): Renamed.
+	(__nedf2): Likewise.
+	* config/sh/ieee-754-df.S (__nesf2): Likewise.
+	* config/sh/ieee-754-sf.S (__nedf2): Likewise.
+	* config/sh/t-sh: Likewise.
+
+2007-01-31  Christian Bruel  <christian.bruel@st.com>
+
+	* basic-block.h (pre_edge_lcm_avs): Declare.
+	* config/i386/i386.h (EMIT_MODE_SET): Add FLIP parameter.
+	* doc/tm.texi (EMIT_MODE_SET): Idem.
+	* doc/tm.texi.in (EMIT_MODE_SET): Idem.
+	* config/sh/sh.h (EMIT_MODE_SET): Idem. Call emit_fpu_flip.
+        (CONDITIONAL_REGISTER_USAGE): Set global_regs[FPSCR_REG].
+	* config/sh/sh-protos.h	(emit_fpu_flip): Add proto.
+	* config/sh/sh.c (emit_fpu_flip): New function.
+	* config/sh/sh.md (toggle_pr): Defined for TARGET_SH4_300.
+	Defined if TARGET_FPU_SINGLE.
+	fpscr_toggle don't go in delay slot (temporary fix).
+	* lcm.c (pre_edge_lcm_avs): Renamed from pre_edge_lcm.
+	Call clear_aux_for_edges. Fix comments.
+	(pre_edge_lcm): New wrapper function to call pre_edge_lcm_avs.
+	(pre_edge_rev_lcm): Idem.
+	* mode-switching.c (init_modes_infos): New function.
+	(bb_has_complex_pred): New function.
+	(free_modes_infos): Idem.
+	(init_modes_infos): Idem
+	(add_mode_set): Idem.
+	(get_mode): Idem.
+	(commit_mode_sets): Idem.
+	(merge_modes): Idem.
+	(set_flip_status): Idem
+	(test_flip_status): Idem.
+	(optimize_mode_switching): Add support to maintain flip mode information.
+
+2007-01-29  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/IEEE-754/m3/adddf3.S: Fix inf mantissa.
+	* config/sh/IEEE-754/m3/addsf3.S: Likewise.
+	* config/sh/IEEE-754/m3/divsf3.S: Intialize xff000000 label.
+	* config/sh/sh.c (expand_sfunc_op): Use FIRST_FP_PARM_REG for
+	parameters.
+	* config/sh/sh.h (TARGET_OSFP): Disable.
+	* config/sh/sh.md (addsf3, subsf3, mulsf3): Use expand_sfunc_binopt
+	only when TARGET_OSFP.
+	(adddf3, subdf3, muldf3): Likewise.
+	(trunkdfsf2): Likewise.
+
+2007-01-22  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/t-sh (LIB1ASMFUNCS): Remove _add_sub_sf3, _mulsf3,
+	_hypotf, _muldf3, _add_sub_df3, _divsf3, _divdf3, _fixunssfsi,
+	_fixsfsi, _fixunsdfsi, _fixdfsi, _floatunssisf, _floatsisf,
+	_floatunssidf and _floatsidf.
+	(FPBIT, DPBIT, dp-bit.c, fp-bit.c): Re-instated.
+
+2007-01-12  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* config/sh/trap-handler.c: Call exit like old one used to.
+
+2006-09-02  J"orn Rennecke  <joern.rennecke@st.com>
+
+	* sh.md (*movsicc_t_false, *movsicc_t_true): Add mode.
+
+2006-11-10  J"orn Rennecke  <joern.rennecke@st.com> 
+	    Aanchal Khanna   <aanchalk@noida.hcltech.com>
+	    Rakesh Kumar  <rakesh.kumar@noida.hcltech.com>
+
+	PR target/29845
+	* config/sh/sh-protos.h (sh_function_kind): New enumerator
+	SFUNC_FREQUENT.
+	(expand_sfunc_unop, expand_sfunc_binop): Declare.
+	* config/sh/lib1funcs.asm (ieee-754-sf.S, ieee-754-df.S): #include.
+	* config/sh/t-sh (LIB1ASMFUNCS): Add nesf2, _nedf2, _gtsf2t, _gtdf2t,
+	_gesf2f, _gedf2f, _extendsfdf2, , _truncdfsf2, _add_sub_sf3, _mulsf3,
+	_hypotf, _muldf3, _add_sub_df3, _divsf3, _divdf3, _fixunssfsi,
+	_fixsfsi, _fixunsdfsi, _fixdfsi, _floatunssisf, _floatsisf,
+	_floatunssidf and _floatsidf.
+	(FPBIT, DPBIT, dp-bit.c, fp-bit.c): Removed.
+	* config/sh/ieee-754-df.S, config/sh/ieee-754-sf.S: New files.
+	* config/sh/predicates.md (soft_fp_comparison_operand): New predicate.
+	(soft_fp_comparison_operator): Likewise.
+	* config/sh/sh.c (sh_soft_fp_cmp, expand_sfunc_op): New functions.
+	(expand_sfunc_unop, expand_sfunc_binop): Likewise.
+	(from_compare): Add support for software floating point.
+	(function_symbol): Always look up name.  Add SFUNC_FREQUENT case.
+	* config/sh/sh.h (TARGET_SH1_SOFTFP): New macro.
+	(TARGET_SH1_SOFTFP_MODE): Likewise.
+	* config/sh/sh-modes.def (CC_FP_NE, CC_FP_GT, CC_FP_UNLT): New modes.
+	* config/sh/lib1funcs.h (SLC, SLI, SLCMP, DMULU_SAVE): New macros.
+	(DMULUL, DMULUH, DMULU_RESTORE, SHLL4, SHLR4, SHLL6, SHLR6): Likewise.
+	(SHLL12, SHLR12, SHLR19, SHLL23, SHLR24, SHLR21, SHLL21): Likewise.
+	(SHLR11, SHLR22, SHLR23, SHLR20, SHLL20, SHLD_COUNT, SHLRN): Likewise.
+	(SHLLN, DYN_SHIFT): Likewise.
+	(SUPPORT_SH3_OSFP, SUPPORT_SH3E_OSFP): Likewise.
+	(SUPPORT_SH4_NOFPU_OSFP, SUPPORT_SH4_SINGLE_ONLY_OSFP): Likewise.
+	(TARGET_OSFP): Likewise.
+	(OPTIMIZATION_OPTIONS): Always enable TARGET_CBRANCHDI4 and
+	TARGET_EXPAND_CBRANCHDI4.
+	If flag_trapping_math is set, make it 2.
+	(OVERRIDE_OPTIONS): If flag_trapping_math is 2 and non-trapping
+	software floating point is used, clear flag_trapping_math.
+	For SH1, set TARGET_EXPAND_CBRANCHDI4
+	* config/sh/ieee-754-df.S, config/sh/ieee-754-sf.S: New files.
+	* config/sh/IEEE-754/m3/divsf3.S: Likewise.
+	* config/sh/IEEE-754/m3/divdf3.S: Likewise.
+	* config/sh/IEEE-754/m3/floatunssisf.S: Likewise.
+	* config/sh/IEEE-754/m3/floatunssidf.S: Likewise.
+	* config/sh/IEEE-754/m3/fixunsdfsi.S: Likewise.
+	* config/sh/IEEE-754/m3/divdf3-rt.S: Likewise.
+	* config/sh/IEEE-754/m3/addsf3.S: Likewise.
+	* config/sh/IEEE-754/m3/adddf3.S: Likewise.
+	* config/sh/IEEE-754/m3/mulsf3.S: Likewise.
+	* config/sh/IEEE-754/m3/muldf3.S: Likewise.
+	* config/sh/IEEE-754/m3/floatsisf.S: Likewise.
+	* config/sh/IEEE-754/m3/floatsidf.S: Likewise.
+	* config/sh/IEEE-754/m3/fixdfsi.S: Likewise.
+	* config/sh/IEEE-754/divdf3.S: Likewise.
+	* config/sh/IEEE-754/floatunssisf.S: Likewise.
+	* config/sh/IEEE-754/fixunsdfsi.S: Likewise.
+	* config/sh/IEEE-754/adddf3.S: Likewise.
+	* config/sh/IEEE-754/floatsisf.S: Likewise.
+	* config/sh/IEEE-754/muldf3.S: Likewise.
+	* config/sh/IEEE-754/fixdfsi.S: Likewise.
+	* config/sh/IEEE-754/divsf3.S: Likewise.
+	* config/sh/IEEE-754/fixunssfsi.S: Likewise.
+	* config/sh/IEEE-754/floatunssidf.S: Likewise.
+	* config/sh/IEEE-754/addsf3.S: Likewise.
+	* config/sh/IEEE-754/mulsf3.S: Likewise.
+	* config/sh/IEEE-754/floatsidf.S: Likewise.
+	* config/sh/IEEE-754/fixsfsi.S: Likewise.
+	* config/sh/sh.md (SF_NAN_MASK, DF_NAN_MASK, FR4_REG): New constants.
+	(fpcmp_i1, addsf3_i3, subsf3_i3): New patterns.
+	(mulsf3_i3, cmpnesf_i1, cmpgtsf_i1, cmpunltsf_i1): Likewise.
+	(cmpeqsf_i1_finite, cmplesf_i1_finite, cmpunsf_i1): Likewise.
+	(cmpuneqsf_i1, movcc_fp_ne, movcc_fp_gtmovcc_fp_unlt): Likewise.
+	(cmpltgtsf_t, cmporderedsf_t, cmpltgtsf_t_4): Likewise.
+	(cmporderedsf_t_4, abssc2, adddf3_i3_wrap, adddf3_i3): Likewise.
+	(muldf3_i3_wrap, muldf3_i3, cmpnedf_i1, cmpgtdf_i1): Likewise.
+	(cmpunltdf_i1, cmpeqdf_i1_finite, cmpundf_i1, cmpuneqdf_i1): Likewise.
+	(cmpltgtdf_t, cmpordereddf_t_4, extendsfdf2_i1): Likewise.
+	(extendsfdf2_i2e, extendsfdf2_i2e_r0, truncdfsf2_i2e): Likewise.
+	(extendsfdf2_i1_r0, truncdfsf2_i1): Likewise.
+	(cmpun_sdf, sunle, cmpuneq_sdf, bunle, bunlt): Likewise.
+
+2006-11-03  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* config/sh/crt1.asm (_superh_trap_handler): Remove function.
+	* config/sh/trap-handler.c: New file.
+	* config/sh/t-elf (EXTRA_MULTILIB_PARTS): Add trap-handler.o.
+	* config/sh/t-superh (EXTRA_MULTILIB_PARTS): Likewise.
+	* config/sh/t-sh: Add rule for trap-handler.o.
+	* config/sh/elf.h (STARTFILE_SPEC): Add trap-handler.o.
+	* config/sh/superh.h (STARTFILE_SPEC): Likewise.
+
diff -ruN gcc-gnu-4.8.2/gcc/collect2.c gcc-st40-4.8.2.140205/gcc/collect2.c
--- gcc-gnu-4.8.2/gcc/collect2.c	2013-10-16 16:17:23.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/collect2.c	2013-10-17 12:15:29.000000000 +0200
@@ -4,6 +4,7 @@
    Contributed by Chris Smith (csmith@convex.com).
    Heavily modified by Michael Meissner (meissner@cygnus.com),
    Per Bothner (bothner@cygnus.com), and John Gilmore (gnu@cygnus.com).
+   Copyright (c) 2013 STMicroelectronics.
 
 This file is part of GCC.
 
@@ -2489,6 +2490,8 @@
           if (found_lto)
             continue;
 
+	  fatal_error ("__gnu_lto_v1 not implemented");
+
           /* Look for the LTO info marker symbol, and add filename to
              the LTO objects list if found.  */
           for (p = buf; (ch = *p) != '\0' && ch != '\n'; p++)
diff -ruN gcc-gnu-4.8.2/gcc/common/config/sh/sh-common.c gcc-st40-4.8.2.140205/gcc/common/config/sh/sh-common.c
--- gcc-gnu-4.8.2/gcc/common/config/sh/sh-common.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/common/config/sh/sh-common.c	2013-05-28 13:15:34.000000000 +0200
@@ -1,5 +1,6 @@
 /* Common hooks for Renesas / SuperH SH.
    Copyright (C) 1993-2013 Free Software Foundation, Inc.
+   Copyright (c) 2013 STMicroelectronics.
 
 This file is part of GCC.
 
@@ -188,7 +189,8 @@
 static void
 sh_option_default_params (void)
 {
-  set_default_param_value (PARAM_SIMULTANEOUS_PREFETCHES, 2);
+   set_default_param_value (PARAM_SIMULTANEOUS_PREFETCHES,
+ 			   (TARGET_SH4_300 ? 6 : 2));
 }
 
 #undef TARGET_OPTION_OPTIMIZATION_TABLE
diff -ruN gcc-gnu-4.8.2/gcc/common.opt gcc-st40-4.8.2.140205/gcc/common.opt
--- gcc-gnu-4.8.2/gcc/common.opt	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/common.opt	2013-05-28 13:15:34.000000000 +0200
@@ -1,6 +1,7 @@
 ; Options for the language- and target-independent parts of the compiler.
 
 ; Copyright (C) 2003-2013 Free Software Foundation, Inc.
+; Copyright (c) 2009 STMicroelectronics.
 ;
 ; This file is part of GCC.
 ;
@@ -549,6 +550,10 @@
 Common Var(flag_fatal_errors)
 Exit on the first error occurred
 
+Wnon-finite-math
+Common Var(warn_non_finite_math) Warning
+Warn if explicit NaNs or infinities are used with -ffinite-math-only
+
 Wframe-larger-than=
 Common RejectNegative Joined UInteger
 -Wframe-larger-than=<number>	Warn if a function's stack frame requires more than <number> bytes
@@ -711,6 +716,10 @@
 Z
 Driver
 
+Wbranch-probabilities-computation
+Common Var(warn_branch_probabilities_computation) Warning
+Warn instead of error in probabilities computation in -fbranch-probabilities
+
 aux-info
 Common Separate Var(aux_info_file_name)
 -aux-info <file>	Emit declaration information into <file>
@@ -1187,6 +1196,10 @@
 Perform redundant load after store elimination in global common subexpression
 elimination
 
+fcse-sincos
+Common Report Var(flag_cse_sincos) Optimization
+Enable sincos merging
+
 fgcse-after-reload
 Common Report Var(flag_gcse_after_reload) Optimization
 Perform global common subexpression elimination after register allocation
diff -ruN gcc-gnu-4.8.2/gcc/config/arm/arm.c gcc-st40-4.8.2.140205/gcc/config/arm/arm.c
--- gcc-gnu-4.8.2/gcc/config/arm/arm.c	2013-10-16 16:17:23.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/config/arm/arm.c	2013-10-17 12:15:29.000000000 +0200
@@ -25227,9 +25227,8 @@
 
   nregs = GET_MODE_SIZE (GET_MODE (rtl)) / 8;
   p = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (nregs));
-  regno = (regno - FIRST_VFP_REGNUM) / 2;
   for (i = 0; i < nregs; i++)
-    XVECEXP (p, 0, i) = gen_rtx_REG (DImode, 256 + regno + i);
+    XVECEXP (p, 0, i) = gen_rtx_REG (DImode, regno + i);
 
   return p;
 }
diff -ruN gcc-gnu-4.8.2/gcc/config/i386/i386.h gcc-st40-4.8.2.140205/gcc/config/i386/i386.h
--- gcc-gnu-4.8.2/gcc/config/i386/i386.h	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/config/i386/i386.h	2013-05-28 13:15:34.000000000 +0200
@@ -1,5 +1,6 @@
 /* Definitions of target machine for GCC for IA-32.
    Copyright (C) 1988-2013 Free Software Foundation, Inc.
+   Copyright (c) 2009  STMicroelectronics.
 
 This file is part of GCC.
 
@@ -2233,8 +2234,9 @@
    is the set of hard registers live at the point where the insn(s)
    are to be inserted.  */
 
-#define EMIT_MODE_SET(ENTITY, MODE, HARD_REGS_LIVE) \
+#define EMIT_MODE_SET(ENTITY, MODE, FLIP, HARD_REGS_LIVE)	\
   ix86_emit_mode_set ((ENTITY), (MODE), (HARD_REGS_LIVE))
+
 
 /* Avoid renaming of stack registers, as doing so in combination with
    scheduling just increases amount of live registers at time and in
diff -ruN gcc-gnu-4.8.2/gcc/config/sh/constraints.md gcc-st40-4.8.2.140205/gcc/config/sh/constraints.md
--- gcc-gnu-4.8.2/gcc/config/sh/constraints.md	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/config/sh/constraints.md	2013-12-02 10:57:54.000000000 +0100
@@ -1,5 +1,6 @@
 ;; Constraint definitions for Renesas / SuperH SH.
 ;; Copyright (C) 2007-2013 Free Software Foundation, Inc.
+;; Copyright (c) 2009 STMicroelectronics.
 ;;
 ;; This file is part of GCC.
 ;;
@@ -100,6 +101,9 @@
 (define_register_constraint "z" "R0_REGS"
   "R0 register.")
 
+(define_register_constraint "R03" "R0R3_REGS"
+  "R0/R3 registers.")
+
 ;; Integer constraints
 (define_constraint "I06"
   "A signed 6-bit constant, as used in SHmedia beqi, bnei and xori."
@@ -221,6 +225,7 @@
 (define_constraint "Q"
   "A pc relative load operand."
   (and (match_code "mem")
+       (match_test "GET_MODE (op) != QImode")
        (match_test "IS_PC_RELATIVE_LOAD_ADDR_P (XEXP (op, 0))")))
 
 (define_constraint "Bsc"
@@ -295,13 +300,15 @@
 
 (define_memory_constraint "Sdd"
   "A memory reference that uses displacement addressing."
-  (and (match_test "MEM_P (op) && GET_CODE (XEXP (op, 0)) == PLUS")
+  (and (match_code "mem")
+       (match_test "GET_CODE (XEXP (op, 0)) == PLUS")
        (match_test "REG_P (XEXP (XEXP (op, 0), 0))")
        (match_test "CONST_INT_P (XEXP (XEXP (op, 0), 1))")))
 
 (define_memory_constraint "Snd"
   "A memory reference that excludes displacement addressing."
-  (match_test "! satisfies_constraint_Sdd (op)"))
+  (and (match_code "mem")
+       (match_test "! satisfies_constraint_Sdd (op)")))
 
 (define_memory_constraint "Sbv"
   "A memory reference, as used in SH2A bclr.b, bset.b, etc."
diff -ruN gcc-gnu-4.8.2/gcc/config/sh/elf.h gcc-st40-4.8.2.140205/gcc/config/sh/elf.h
--- gcc-gnu-4.8.2/gcc/config/sh/elf.h	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/config/sh/elf.h	2013-05-28 13:15:34.000000000 +0200
@@ -1,6 +1,7 @@
 /* Definitions of target machine for gcc for Renesas / SuperH SH using ELF.
    Copyright (C) 1996-2013 Free Software Foundation, Inc.
    Contributed by Ian Lance Taylor <ian@cygnus.com>.
+   Copyright (c) 2009 STMicroelectronics.
 
 This file is part of GCC.
 
@@ -34,11 +35,10 @@
 #undef WCHAR_TYPE
 /* #define WCHAR_TYPE (TARGET_SH5 ? "int" : "long int")  */
 #define WCHAR_TYPE SH_ELF_WCHAR_TYPE
-   
+
 #undef WCHAR_TYPE_SIZE
 #define WCHAR_TYPE_SIZE 32
 
-
 /* The prefix to add to user-visible assembler symbols.  */
 #undef LOCAL_LABEL_PREFIX
 #define LOCAL_LABEL_PREFIX "."
@@ -73,7 +73,7 @@
 
 #undef STARTFILE_SPEC
 #define STARTFILE_SPEC \
-  "%{!shared: crt1.o%s} crti.o%s \
+  "%{!shared: crt1.o%s trap-handler.o%s} crti.o%s \
    %{!shared:crtbegin.o%s} %{shared:crtbeginS.o%s}"
 
 #undef ENDFILE_SPEC
@@ -86,3 +86,6 @@
 /* ASM_OUTPUT_CASE_LABEL is defined in elfos.h.  With it,
    a redundant .align was generated.  */
 #undef  ASM_OUTPUT_CASE_LABEL
+
+#undef MAX_OFILE_ALIGNMENT
+#define MAX_OFILE_ALIGNMENT (((unsigned int) 1 << 20) * 8)
diff -ruN gcc-gnu-4.8.2/gcc/config/sh/embed-elf.h gcc-st40-4.8.2.140205/gcc/config/sh/embed-elf.h
--- gcc-gnu-4.8.2/gcc/config/sh/embed-elf.h	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/config/sh/embed-elf.h	2013-05-28 13:15:34.000000000 +0200
@@ -1,7 +1,8 @@
-/* Definitions of target machine for GNU compiler for Renesas / SuperH SH 
+/* Definitions of target machine for GNU compiler for Renesas / SuperH SH
    non-Linux embedded targets.
    Copyright (C) 2002-2013 Free Software Foundation, Inc.
    Contributed by J"orn Rennecke <joern.rennecke@superh.com>
+   Copyright (c) 2009  STMicroelectronics.
 
 This file is part of GCC.
 
@@ -22,15 +23,20 @@
 #undef USER_LABEL_PREFIX
 #define USER_LABEL_PREFIX "_"
 
+/* builtin_trap can use trapa.  */
+#undef TARGET_BUILTIN_TRAPA
+#define TARGET_BUILTIN_TRAPA 1
+
 /* While the speed-optimized implementations of udivsi3_i4i / sdivsi3_i4i
    in libgcc are not available for SH2, the space-optimized ones in
    libgcc-Os-4-200 are.  Thus, when not optimizing for space, link
    libgcc-Os-4-200 after libgcc, so that -mdiv=call-table works for -m2.  */
 #define LIBGCC_SPEC "%{!shared: \
-  %{m4-100*:-lic_invalidate_array_4-100} \
-  %{m4-200*:-lic_invalidate_array_4-200} \
-  %{m4-300*|m4-340:-lic_invalidate_array_4a %{!Os: -lgcc-4-300}} \
-  %{m4a*:-lic_invalidate_array_4a}} \
-  %{Os: -lgcc-Os-4-200} \
+  %{!m4-100*:%{!m4-200*:%{!m4-300*:%{!m4a*:-lic_invalidate}}}}	\
+  %{m4-100*:-lic_invalidate_4-100}				\
+  %{m4-200*:-lic_invalidate_4-200}				\
+  %{m4-300*|-m4-340:-lic_invalidate_4a}			        \
+  %{m4a*:-lic_invalidate_4a}}					\
   -lgcc \
-  %{!Os: -lgcc-Os-4-200}"
+  %{Os: -lgcc-Os-4-200}					        \
+  %{!Os: %{m4-300*|-m4-340: -lgcc-4-300} %{!m4-300*:%{!m4-340: -lgcc-4-200}}}"
diff -ruN gcc-gnu-4.8.2/gcc/config/sh/linux.h gcc-st40-4.8.2.140205/gcc/config/sh/linux.h
--- gcc-gnu-4.8.2/gcc/config/sh/linux.h	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/config/sh/linux.h	2013-05-28 13:15:34.000000000 +0200
@@ -1,6 +1,7 @@
 /* Definitions for SH running Linux-based GNU systems using ELF
    Copyright (C) 1999-2013 Free Software Foundation, Inc.
    Contributed by Kazumoto Kojima <kkojima@rr.iij4u.or.jp>
+   Copyright (c) 2009 STMicroelectronics.
 
 This file is part of GCC.
 
@@ -28,11 +29,13 @@
 #define SUBTARGET_CPP_SPEC "\
    %{posix:-D_POSIX_SOURCE} \
    %{pthread:-D_REENTRANT -D_PTHREADS} \
-"
+   %{m4-300*:-D__SH4_300__} "
 
 #define TARGET_OS_CPP_BUILTINS() \
   do						\
     {						\
+      extern const char version_string[];       \
+      builtin_define_with_value ("__GNUC_STM_RELEASE__", version_string, 1); \
       GNU_USER_TARGET_OS_CPP_BUILTINS();	\
     }						\
   while (0)
diff -ruN gcc-gnu-4.8.2/gcc/config/sh/predicates.md gcc-st40-4.8.2.140205/gcc/config/sh/predicates.md
--- gcc-gnu-4.8.2/gcc/config/sh/predicates.md	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/config/sh/predicates.md	2013-12-02 10:57:54.000000000 +0100
@@ -1,5 +1,6 @@
 ;; Predicate definitions for Renesas / SuperH SH.
 ;; Copyright (C) 2005-2013 Free Software Foundation, Inc.
+;; Copyright (c) 2009 STMicroelectronics.;;
 ;;
 ;; This file is part of GCC.
 ;;
@@ -154,7 +155,7 @@
 
       return (regno != T_REG && regno != PR_REG
 	      && ! TARGET_REGISTER_P (regno)
-	      && (regno != FPUL_REG || TARGET_SH4)
+	      && (regno != FPUL_REG)
 	      && regno != MACH_REG && regno != MACL_REG);
     }
   /* Allow a no-op sign extension - compare LOAD_EXTEND_OP.
@@ -389,6 +390,12 @@
 					   XEXP (XEXP (op, 0), 1),
 					   TARGET_SH2A, true)")))
 
+;; Returns true if OP is a displacement address that can fit into a
+;; 16 bit (non-SH2A) memory load / store insn.
+(define_predicate "short_displacement_mem_operand"
+  (match_test "sh_disp_addr_displacement (op)
+	       <= sh_max_mov_insn_displacement (GET_MODE (op), false)"))
+
 ;; Returns 1 if the operand can be used in an SH2A movu.{b|w} insn.
 (define_predicate "zero_extend_movu_operand"
   (and (match_operand 0 "displacement_mem_operand")
@@ -413,6 +420,11 @@
   if (t_reg_operand (op, mode))
     return 0;
 
+  /* Disallow PC relative QImode loads, since these is no insn to do that
+     and an imm8 load should be used instead.  */
+  if (IS_PC_RELATIVE_LOAD_ADDR_P (op) && GET_MODE (op) == QImode)
+    return false;
+
   if (MEM_P (op))
     {
       rtx inside = XEXP (op, 0);
@@ -868,6 +880,33 @@
 (define_predicate "symbol_ref_operand"
   (match_code "symbol_ref"))
 
+(define_special_predicate "soft_fp_comparison_operand"
+  (match_code "subreg,reg")
+{
+  switch (GET_MODE (op))
+    {
+    default:
+      return 0;
+    case CC_FP_NEmode: case CC_FP_GTmode: case CC_FP_UNLTmode:
+      break;
+    }
+  return register_operand (op, mode);
+})
+
+(define_predicate "soft_fp_comparison_operator"
+  (match_code "eq, unle, ge")
+{
+  switch (GET_CODE (op))
+    {
+    default:
+      return 0;
+    case EQ:  mode = CC_FP_NEmode;    break;
+    case UNLE:        mode = CC_FP_GTmode;    break;
+    case GE:  mode = CC_FP_UNLTmode;  break;
+    }
+  return register_operand (XEXP (op, 0), mode);
+})
+
 ;; Same as target_reg_operand, except that label_refs and symbol_refs
 ;; are accepted before reload.
 (define_special_predicate "target_operand"
diff -ruN gcc-gnu-4.8.2/gcc/config/sh/sh.c gcc-st40-4.8.2.140205/gcc/config/sh/sh.c
--- gcc-gnu-4.8.2/gcc/config/sh/sh.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/config/sh/sh.c	2014-01-24 10:24:17.000000000 +0100
@@ -59,6 +59,7 @@
 #include "alloc-pool.h"
 #include "tm-constrs.h"
 #include "opts.h"
+#include "except.h"
 
 #include <sstream>
 #include <vector>
@@ -177,7 +178,6 @@
 
 static void split_branches (rtx);
 static int branch_dest (rtx);
-static void force_into (rtx, rtx);
 static void print_slot (rtx);
 static rtx add_constant (rtx, enum machine_mode, rtx);
 static void dump_table (rtx, rtx);
@@ -197,12 +197,14 @@
 static HOST_WIDE_INT rounded_frame_size (int);
 static bool sh_frame_pointer_required (void);
 static rtx mark_constant_pool_use (rtx);
+static bool sh_cfun_naked_p (void);
 static tree sh_handle_interrupt_handler_attribute (tree *, tree, tree,
 						   int, bool *);
 static tree sh_handle_resbank_handler_attribute (tree *, tree,
 						 tree, int, bool *);
 static tree sh2a_handle_function_vector_handler_attribute (tree *, tree,
 							   tree, int, bool *);
+static tree  sh_handle_fndecl_attribute (tree *, tree, tree, int, bool *);
 static tree sh_handle_sp_switch_attribute (tree *, tree, tree, int, bool *);
 static tree sh_handle_trap_exit_attribute (tree *, tree, tree, int, bool *);
 static tree sh_handle_renesas_attribute (tree *, tree, tree, int, bool *);
@@ -310,9 +312,7 @@
 static void sh_conditional_register_usage (void);
 static bool sh_legitimate_constant_p (enum machine_mode, rtx);
 static int mov_insn_size (enum machine_mode, bool);
-static int max_mov_insn_displacement (enum machine_mode, bool);
 static int mov_insn_alignment_mask (enum machine_mode, bool);
-static HOST_WIDE_INT disp_addr_displacement (rtx);
 static bool sequence_insn_p (rtx);
 static void sh_canonicalize_comparison (int *, rtx *, rtx *, bool);
 static void sh_canonicalize_comparison (enum rtx_code&, rtx&, rtx&,
@@ -340,6 +340,9 @@
     sh_handle_resbank_handler_attribute, false },
   { "function_vector",   1, 1, true,  false, false,
     sh2a_handle_function_vector_handler_attribute, false },
+ /* don't generate function prologue/epilogue and `ret' command.  */
+  { "naked",             0, 0, true, false, false,
+    sh_handle_fndecl_attribute, false },
   { NULL,                0, 0, false, false, false, NULL, false }
 };
 
@@ -727,7 +730,10 @@
   if (optimize > 1 && !optimize_size)
     target_flags |= MASK_SAVE_ALL_TARGET_REGS;
   sh_cpu = PROCESSOR_SH1;
-  assembler_dialect = 0;
+  if (TARGET_SH1)
+    assembler_dialect = 1;
+  else
+    assembler_dialect = 0;
   if (TARGET_SH2)
     sh_cpu = PROCESSOR_SH2;
   if (TARGET_SH2E)
@@ -821,6 +827,8 @@
 	sh_div_strategy = SH_DIV_CALL_FP;
       else if (! strcmp (sh_div_str, "call-table") && TARGET_DYNSHIFT)
 	sh_div_strategy = SH_DIV_CALL_TABLE;
+     else if (! strcmp (sh_div_str, "call-pre1"))
+ 	sh_div_strategy = SH_DIV_CALL_PRE1;
       else
 	/* Pick one that makes most sense for the target in general.
 	   It is not much good to use different functions depending
@@ -883,32 +891,18 @@
 
   if (targetm.small_register_classes_for_mode_p (VOIDmode))
     {
-      /* Never run scheduling before reload, since that can
-	 break global alloc, and generates slower code anyway due
-	 to the pressure on R0.  */
-      /* Enable sched1 for SH4 if the user explicitly requests.
-	 When sched1 is enabled, the ready queue will be reordered by
-	 the target hooks if pressure is high.  We can not do this for
-	 PIC, SH3 and lower as they give spill failures for R0.  */
-      if (!TARGET_HARD_SH4 || flag_pic)
-	flag_schedule_insns = 0;
       /* ??? Current exception handling places basic block boundaries
 	 after call_insns.  It causes the high pressure on R0 and gives
 	 spill failures for R0 in reload.  See PR 22553 and the thread
 	 on gcc-patches
 	 <http://gcc.gnu.org/ml/gcc-patches/2005-10/msg00816.html>.  */
-      else if (flag_exceptions)
-	{
-	  if (flag_schedule_insns && global_options_set.x_flag_schedule_insns)
-	    warning (0, "ignoring -fschedule-insns because of exception "
-			"handling bug");
+      if (flag_exceptions)
 	  flag_schedule_insns = 0;
-	}
-      else if (flag_schedule_insns
-	       && !global_options_set.x_flag_schedule_insns)
-	flag_schedule_insns = 0;
     }
 
+  if (TARGET_DBHWBUG)
+       align_functions = 32;
+
   /* Unwind info is not correct around the CFG unless either a frame
      pointer is present or M_A_O_A is set.  Fixing this requires rewriting
      unwind info generation to be aware of the CFG and propagating states
@@ -972,6 +966,8 @@
   else if (align_jumps < (TARGET_SHMEDIA ? 4 : 2))
     align_jumps = TARGET_SHMEDIA ? 4 : 2;
 
+  flag_tree_cselim = 0;
+
   if (align_functions == 0)
     {
       if (TARGET_SHMEDIA)
@@ -981,20 +977,6 @@
 	align_functions = optimize_size ? 2 : 4;
     }
 
-  /* The linker relaxation code breaks when a function contains
-     alignments that are larger than that at the start of a
-     compilation unit.  */
-  if (TARGET_RELAX)
-    {
-      int min_align = align_loops > align_jumps ? align_loops : align_jumps;
-
-      /* Also take possible .long constants / mova tables into account.	*/
-      if (min_align < 4)
-	min_align = 4;
-      if (align_functions < min_align)
-	align_functions = min_align;
-    }
-
   if (flag_unsafe_math_optimizations)
     {
       /* Enable fsca insn for SH4A if not otherwise specified by the user.  */
@@ -1029,6 +1011,7 @@
   selected_atomic_model_
     = parse_validate_atomic_model_option (sh_atomic_model_str);
 }
+
 
 /* Print the operand address in x to the stream.  */
 static void
@@ -1085,6 +1068,12 @@
     }
 }
 
+static int deleted_delay_slot_p (rtx insn)
+{
+  return (GET_CODE (PATTERN (insn)) == UNSPEC_VOLATILE
+	  && XINT (PATTERN (insn), 1) == UNSPECV_DB_INSN);
+}
+
 /* Print operand x (an rtx) in assembler syntax to file stream
    according to modifier code.
 
@@ -1122,7 +1111,8 @@
     case '.':
       if (final_sequence
 	  && ! INSN_ANNULLED_BRANCH_P (XVECEXP (final_sequence, 0, 0))
-	  && get_attr_length (XVECEXP (final_sequence, 0, 1)))
+	  && (get_attr_length (XVECEXP (final_sequence, 0, 1))
+	      || deleted_delay_slot_p (XVECEXP (final_sequence, 0, 1))))
 	fprintf (stream, ASSEMBLER_DIALECT ? "/s" : ".s");
       break;
     case ',':
@@ -1590,156 +1580,6 @@
     SYMBOL_REF_FLAGS (XEXP (rtl, 0)) |= SYMBOL_FLAG_FUNCVEC_FUNCTION;
 }
 
-/* Like force_operand, but guarantees that VALUE ends up in TARGET.  */
-static void
-force_into (rtx value, rtx target)
-{
-  value = force_operand (value, target);
-  if (! rtx_equal_p (value, target))
-    emit_insn (gen_move_insn (target, value));
-}
-
-/* Emit code to perform a block move.  Choose the best method.
-
-   OPERANDS[0] is the destination.
-   OPERANDS[1] is the source.
-   OPERANDS[2] is the size.
-   OPERANDS[3] is the alignment safe to use.  */
-bool
-expand_block_move (rtx *operands)
-{
-  int align = INTVAL (operands[3]);
-  int constp = (CONST_INT_P (operands[2]));
-  int bytes = (constp ? INTVAL (operands[2]) : 0);
-
-  if (! constp)
-    return false;
-
-  /* If we could use mov.l to move words and dest is word-aligned, we
-     can use movua.l for loads and still generate a relatively short
-     and efficient sequence.  */
-  if (TARGET_SH4A_ARCH && align < 4
-      && MEM_ALIGN (operands[0]) >= 32
-      && can_move_by_pieces (bytes, 32))
-    {
-      rtx dest = copy_rtx (operands[0]);
-      rtx src = copy_rtx (operands[1]);
-      /* We could use different pseudos for each copied word, but
-	 since movua can only load into r0, it's kind of
-	 pointless.  */
-      rtx temp = gen_reg_rtx (SImode);
-      rtx src_addr = copy_addr_to_reg (XEXP (src, 0));
-      int copied = 0;
-
-      while (copied + 4 <= bytes)
-	{
-	  rtx to = adjust_address (dest, SImode, copied);
-	  rtx from = adjust_automodify_address (src, BLKmode,
-						src_addr, copied);
-
-	  set_mem_size (from, 4);
-	  emit_insn (gen_movua (temp, from));
-	  emit_move_insn (src_addr, plus_constant (Pmode, src_addr, 4));
-	  emit_move_insn (to, temp);
-	  copied += 4;
-	}
-
-      if (copied < bytes)
-	move_by_pieces (adjust_address (dest, BLKmode, copied),
-			adjust_automodify_address (src, BLKmode,
-						   src_addr, copied),
-			bytes - copied, align, 0);
-
-      return true;
-    }
-
-  /* If it isn't a constant number of bytes, or if it doesn't have 4 byte
-     alignment, or if it isn't a multiple of 4 bytes, then fail.  */
-  if (align < 4 || (bytes % 4 != 0))
-    return false;
-
-  if (TARGET_HARD_SH4)
-    {
-      if (bytes < 12)
-	return false;
-      else if (bytes == 12)
-	{
-	  rtx func_addr_rtx = gen_reg_rtx (Pmode);
-	  rtx r4 = gen_rtx_REG (SImode, 4);
-	  rtx r5 = gen_rtx_REG (SImode, 5);
-
-	  function_symbol (func_addr_rtx, "__movmemSI12_i4", SFUNC_STATIC);
-	  force_into (XEXP (operands[0], 0), r4);
-	  force_into (XEXP (operands[1], 0), r5);
-	  emit_insn (gen_block_move_real_i4 (func_addr_rtx));
-	  return true;
-	}
-      else if (! optimize_size)
-	{
-	  const char *entry_name;
-	  rtx func_addr_rtx = gen_reg_rtx (Pmode);
-	  int dwords;
-	  rtx r4 = gen_rtx_REG (SImode, 4);
-	  rtx r5 = gen_rtx_REG (SImode, 5);
-	  rtx r6 = gen_rtx_REG (SImode, 6);
-
-	  entry_name = (bytes & 4 ? "__movmem_i4_odd" : "__movmem_i4_even");
-	  function_symbol (func_addr_rtx, entry_name, SFUNC_STATIC);
-	  force_into (XEXP (operands[0], 0), r4);
-	  force_into (XEXP (operands[1], 0), r5);
-
-	  dwords = bytes >> 3;
-	  emit_insn (gen_move_insn (r6, GEN_INT (dwords - 1)));
-	  emit_insn (gen_block_lump_real_i4 (func_addr_rtx));
-	  return true;
-	}
-      else
-	return false;
-    }
-  if (bytes < 64)
-    {
-      char entry[30];
-      rtx func_addr_rtx = gen_reg_rtx (Pmode);
-      rtx r4 = gen_rtx_REG (SImode, 4);
-      rtx r5 = gen_rtx_REG (SImode, 5);
-
-      sprintf (entry, "__movmemSI%d", bytes);
-      function_symbol (func_addr_rtx, entry, SFUNC_STATIC);
-      force_into (XEXP (operands[0], 0), r4);
-      force_into (XEXP (operands[1], 0), r5);
-      emit_insn (gen_block_move_real (func_addr_rtx));
-      return true;
-    }
-
-  /* This is the same number of bytes as a memcpy call, but to a different
-     less common function name, so this will occasionally use more space.  */
-  if (! optimize_size)
-    {
-      rtx func_addr_rtx = gen_reg_rtx (Pmode);
-      int final_switch, while_loop;
-      rtx r4 = gen_rtx_REG (SImode, 4);
-      rtx r5 = gen_rtx_REG (SImode, 5);
-      rtx r6 = gen_rtx_REG (SImode, 6);
-
-      function_symbol (func_addr_rtx, "__movmem", SFUNC_STATIC);
-      force_into (XEXP (operands[0], 0), r4);
-      force_into (XEXP (operands[1], 0), r5);
-
-      /* r6 controls the size of the move.  16 is decremented from it
-	 for each 64 bytes moved.  Then the negative bit left over is used
-	 as an index into a list of move instructions.  e.g., a 72 byte move
-	 would be set up with size(r6) = 14, for one iteration through the
-	 big while loop, and a switch of -2 for the last part.  */
-
-      final_switch = 16 - ((bytes / 4) % 16);
-      while_loop = ((bytes / 4) / 16 - 1) * 16;
-      emit_insn (gen_move_insn (r6, GEN_INT (while_loop + final_switch)));
-      emit_insn (gen_block_lump_real (func_addr_rtx));
-      return true;
-    }
-
-  return false;
-}
 
 /* Prepare operands for a move define_expand; specifically, one of the
    operands must be in a register.  */
@@ -2699,45 +2539,111 @@
   INSN_DELETED_P (XVECEXP (insn, 0, 1)) = 1;
 }
 
+/* min/max for a 16-bits relative jump */
+#define FAR_JUMP_MIN -32764
+#define FAR_JUMP_MAX 32776
+
 const char *
 output_far_jump (rtx insn, rtx op)
 {
   struct { rtx lab, reg, op; } this_jmp;
   rtx braf_base_lab = NULL_RTX;
   const char *jump;
-  int far;
-  int offset = branch_dest (insn) - INSN_ADDRESSES (INSN_UID (insn));
+  bool far;
+  int offset, baddr;
   rtx prev;
+  int prev_count;
 
   this_jmp.lab = gen_label_rtx ();
 
-  if (TARGET_SH2
-      && offset >= -32764
-      && offset - get_attr_length (insn) <= 32766)
+  /* number of instructions before the jmp.  */
+  prev = prev_nonnote_insn (insn);
+  if (prev && NONJUMP_INSN_P (prev)
+      && INSN_CODE (prev) == CODE_FOR_indirect_jump_scratch)
+    prev_count = 2;
+  else
+    prev_count = 4;
+
+  baddr = INSN_ADDRESSES (INSN_UID (insn)) + prev_count;
+
+  /* First assume a braf_branch_p and see if it fits.  */
+  if (prev_count == 4)
+    {
+      /* The delayed instruction will be emitted BEFORE the braf !!. */
+      if (dbr_sequence_length ())
+	baddr += 2;
+    }
+
+  offset = branch_dest (insn) - baddr;
+
+  if (TARGET_SH2 && offset >= -32768 + 4 && offset <= 32767 + 4)
     {
-      far = 0;
-      jump =   "mov.w	%O0,%1" "\n"
-	     "	braf	%1";
+      if (TARGET_DBHWBUG && prev_count == 4)
+	{
+	  /* we have */
+	  /* delayed instruction (size on its own)
+	     push  (2)
+	     mov   (2)
+	     bra   (2)
+             pop   (2)
+             .word (2) */
+	  /* or */
+	  /* push  (2)
+	     mov   (2)
+	     bra   (2)
+             pop   (2)
+             .word (2) */
+	  gcc_assert (get_attr_length (insn) == 10);
+	}
+      else if (TARGET_DBHWBUG)
+	{
+	  if (dbr_sequence_length ())
+	    gcc_assert (get_attr_length (insn) == 6);
+	  else
+	    gcc_assert (get_attr_length (insn) == 8);
+	}
+
+      far = false;
+      jump = "mov.w	%O0,%1\n\tbraf	%1";
     }
   else
     {
-      far = 1;
+      if (TARGET_DBHWBUG && NONJUMP_INSN_P ((prev = prev_nonnote_insn (insn)))
+	  && INSN_CODE (prev) == CODE_FOR_indirect_jump_scratch)
+	{
+	  if (dbr_sequence_length ())
+	    gcc_assert (get_attr_length (insn) == 10 || get_attr_length (insn) == 8);
+	  else
+	    gcc_assert (get_attr_length (insn) == 12 || get_attr_length (insn) == 10);
+	}
+      else if (TARGET_DBHWBUG)
+	{
+	  if (dbr_sequence_length ())
+	    {
+	      if (flag_pic)
+		gcc_assert (get_attr_length (insn) == 14);
+	      else
+		gcc_assert (get_attr_length (insn) == 14 || get_attr_length (insn) == 12);
+	    }
+	  else
+	    {
+	      if (flag_pic)
+		gcc_assert (get_attr_length (insn) == 16);
+	      else
+		gcc_assert (get_attr_length (insn) == 16 || get_attr_length (insn) == 14);
+	    }
+	}
+
+      far = true;
       if (flag_pic)
 	{
 	  if (TARGET_SH2)
-	    jump =     "mov.l	%O0,%1" "\n"
-		   "	braf	%1";
+	    jump = "mov.l	%O0,%1\n\tbraf	%1";
 	  else
-	    jump =     "mov.l	r0,@-r15"	"\n"
-		   "	mova	%O0,r0"		"\n"
-		   "	mov.l	@r0,%1"		"\n"
-		   "	add	r0,%1"		"\n"
-		   "	mov.l	@r15+,r0"	"\n"
-		   "	jmp	@%1";
+	    jump = "mov.l	r0,@-r15\n\tmova	%O0,r0\n\t mov.l	@r0,%1\n\tadd	r0,%1\n\t mov.l	@r15+,r0\n\tjmp	@%1";
 	}
       else
-	jump =         "mov.l	%O0,%1" "\n"
-	       "	jmp	@%1";
+	jump = "mov.l	%O0,%1\n\tjmp	@%1";
     }
   /* If we have a scratch register available, use it.  */
   if (NONJUMP_INSN_P ((prev = prev_nonnote_insn (insn)))
@@ -2745,12 +2651,7 @@
     {
       this_jmp.reg = SET_DEST (XVECEXP (PATTERN (prev), 0, 0));
       if (REGNO (this_jmp.reg) == R0_REG && flag_pic && ! TARGET_SH2)
-	jump =         "mov.l	r1,@-r15"	"\n"
-	       "	mova	%O0,r0"		"\n"
-	       "	mov.l	@r0,r1"		"\n"
-	       "	add	r1,r0"		"\n"
-	       "	mov.l	@r15+,r1"	"\n"
-	       "	jmp	@%1";
+	jump = "mov.l	r1,@-r15\n\t mova	%O0,r0\n\t mov.l	@r0,r1\n\t add	r1,r0\n\t mov.l	@r15+,r1\n\tjmp	@%1";
       output_asm_insn (jump, &this_jmp.lab);
       if (dbr_sequence_length ())
 	print_slot (final_sequence);
@@ -2769,12 +2670,15 @@
 	 need its value across jumps, so save r13 in it instead of in
 	 the stack.  */
       if (TARGET_SH5)
-	output_asm_insn ("lds	r13,macl", 0);
-      else
-	output_asm_insn ("mov.l	r13,@-r15", 0);
+	output_asm_insn ("lds	r13, macl", 0);
+      else {
+	asm_fprintf (asm_out_file, "\tmov.l	r13,@-r15 \t%s %d\t[length = %d]\n",
+		     ASM_COMMENT_START, INSN_UID (insn),
+		     get_attr_length (insn));
+      }
       output_asm_insn (jump, &this_jmp.lab);
       if (TARGET_SH5)
-	output_asm_insn ("sts	macl,r13", 0);
+	output_asm_insn ("sts	macl, r13", 0);
       else
 	output_asm_insn ("mov.l	@r15+,r13", 0);
     }
@@ -2804,6 +2708,7 @@
 static int lf = 100;
 
 /* Output code for ordinary branches.  */
+
 const char *
 output_branch (int logic, rtx insn, rtx *operands)
 {
@@ -2817,6 +2722,7 @@
 	 It can also happen when other condbranches hoist delay slot insn
 	 from their destination, thus leading to code size increase.
 	 But the branch will still be in the range -4092..+4098 bytes.  */
+
       if (! TARGET_RELAX)
 	{
 	  int label = lf++;
@@ -2831,8 +2737,12 @@
 	      && ! INSN_ANNULLED_BRANCH_P (XVECEXP (final_sequence, 0, 0))
 	      && get_attr_length (XVECEXP (final_sequence, 0, 1)))
 	    {
-	      asm_fprintf (asm_out_file, "\tb%s%ss\t%LLF%d\n", logic ? "f" : "t",
+	      asm_fprintf (asm_out_file, "\tb%s%ss\t%LLF%d", logic ? "f" : "t",
 	                   ASSEMBLER_DIALECT ? "/" : ".", label);
+
+	      asm_fprintf (asm_out_file, "\t%s %d\t[length = %d]\n",
+			   ASM_COMMENT_START, INSN_UID (insn),
+			   get_attr_length (insn));
 	      print_slot (final_sequence);
 	    }
 	  else
@@ -3628,8 +3538,8 @@
 
 /* Determine the maximum possible displacement for a move insn for the
    specified mode.  */
-static int
-max_mov_insn_displacement (enum machine_mode mode, bool consider_sh2a)
+int
+sh_max_mov_insn_displacement (machine_mode mode, bool consider_sh2a)
 {
   /* The 4 byte displacement move insns are the same as the 2 byte
      versions but take a 12 bit displacement.  All we need to do is to
@@ -3665,8 +3575,8 @@
 }
 
 /* Return the displacement value of a displacement address.  */
-static inline HOST_WIDE_INT
-disp_addr_displacement (rtx x)
+HOST_WIDE_INT
+sh_disp_addr_displacement (rtx x)
 {
   gcc_assert (satisfies_constraint_Sdd (x));
   return INTVAL (XEXP (XEXP (x, 0), 1));
@@ -3703,12 +3613,12 @@
 	 HImode and QImode loads/stores with displacement put pressure on
 	 R0 which will most likely require another reg copy.  Thus account
 	 a higher cost for that.  */
-      if (offset > 0 && offset <= max_mov_insn_displacement (mode, false))
+      if (offset > 0 && offset <= sh_max_mov_insn_displacement (mode, false))
 	return (mode == HImode || mode == QImode) ? 2 : 1;
 
       /* The displacement would fit into a 4 byte move insn (SH2A).  */
       if (TARGET_SH2A
-	  && offset > 0 && offset <= max_mov_insn_displacement (mode, true))
+	  && offset > 0 && offset <= sh_max_mov_insn_displacement (mode, true))
 	return 2;
 
       /* The displacement is probably out of range and will require extra
@@ -4694,9 +4604,9 @@
   rtx scan = barrier;
   int i;
   bool need_align = true;
+  bool need_align_d = true;
   rtx lab;
   label_ref_list_t ref;
-  bool have_df = false;
 
   /* Do two passes, first time dump out the HI sized constants.  */
 
@@ -4721,11 +4631,10 @@
 	      scan = emit_insn_after (gen_consttable_window_end (lab), scan);
 	    }
 	}
-      else if (p->mode == DFmode)
-	have_df = true;
     }
 
   need_align = true;
+  need_align_d = true;
 
   if (start)
     {
@@ -4736,84 +4645,14 @@
 	    && recog_memoized (start) == CODE_FOR_casesi_worker_2)
 	  {
 	    rtx src = SET_SRC (XVECEXP (PATTERN (start), 0, 0));
-	    rtx lab = XEXP (XVECEXP (src, 0, 3), 0);
+	    rtx lab;
 
+	    gcc_assert (MEM_P (src));
+	    src = XEXP (src, 0);
+	    lab = XEXP (XVECEXP (src, 0, 3), 0);
 	    scan = emit_label_after (lab, scan);
 	  }
     }
-  if (TARGET_FMOVD && TARGET_ALIGN_DOUBLE && have_df)
-    {
-      rtx align_insn = NULL_RTX;
-
-      scan = emit_label_after (gen_label_rtx (), scan);
-      scan = emit_insn_after (gen_align_log (GEN_INT (3)), scan);
-      need_align = false;
-
-      for (i = 0; i < pool_size; i++)
-	{
-	  pool_node *p = &pool_vector[i];
-
-	  switch (p->mode)
-	    {
-	    case HImode:
-	      break;
-	    case SImode:
-	    case SFmode:
-	      if (align_insn && !p->part_of_sequence_p)
-		{
-		  for (lab = p->label; lab; lab = LABEL_REFS (lab))
-		    emit_label_before (lab, align_insn);
-		  emit_insn_before (gen_consttable_4 (p->value, const0_rtx),
-				    align_insn);
-		  for (ref = p->wend; ref; ref = ref->next)
-		    {
-		      lab = ref->label;
-		      emit_insn_before (gen_consttable_window_end (lab),
-					align_insn);
-		    }
-		  delete_insn (align_insn);
-		  align_insn = NULL_RTX;
-		  continue;
-		}
-	      else
-		{
-		  for (lab = p->label; lab; lab = LABEL_REFS (lab))
-		    scan = emit_label_after (lab, scan);
-		  scan = emit_insn_after (gen_consttable_4 (p->value,
-							    const0_rtx), scan);
-		  need_align = ! need_align;
-		}
-	      break;
-	    case DFmode:
-	      if (need_align)
-		{
-		  scan = emit_insn_after (gen_align_log (GEN_INT (3)), scan);
-		  align_insn = scan;
-		  need_align = false;
-		}
-	    case DImode:
-	      for (lab = p->label; lab; lab = LABEL_REFS (lab))
-		scan = emit_label_after (lab, scan);
-	      scan = emit_insn_after (gen_consttable_8 (p->value, const0_rtx),
-				      scan);
-	      break;
-	    default:
-	      gcc_unreachable ();
-	    }
-
-	  if (p->mode != HImode)
-	    {
-	      for (ref = p->wend; ref; ref = ref->next)
-		{
-		  lab = ref->label;
-		  scan = emit_insn_after (gen_consttable_window_end (lab),
-					  scan);
-		}
-	    }
-	}
-
-      pool_size = 0;
-    }
 
   for (i = 0; i < pool_size; i++)
     {
@@ -4835,8 +4674,15 @@
 	    scan = emit_label_after (lab, scan);
 	  scan = emit_insn_after (gen_consttable_4 (p->value, const0_rtx),
 				  scan);
+	  need_align_d = true;
 	  break;
 	case DFmode:
+	  if (TARGET_ALIGN_DOUBLE && need_align_d)
+	    {
+	      need_align = false;
+	      need_align_d = false;
+	      scan = emit_insn_after (gen_align_log (GEN_INT (3)), scan);
+	    }
 	case DImode:
 	  if (need_align)
 	    {
@@ -4963,6 +4809,10 @@
       wpat0 = XVECEXP (wpat, 0, 0);
       wpat1 = XVECEXP (wpat, 0, 1);
       wsrc = SET_SRC (wpat0);
+
+      gcc_assert (MEM_P (wsrc));
+      wsrc = XEXP (wsrc, 0);
+
       PATTERN (worker) = (gen_casesi_worker_2
 			  (SET_DEST (wpat0), XVECEXP (wsrc, 0, 1),
 			   XEXP (XVECEXP (wsrc, 0, 2), 0), lab,
@@ -5069,11 +4919,23 @@
   si_limit = 1018;
   hi_limit = 510;
 
+  if (TARGET_DBHWBUG)
+    {
+      hi_limit -= 2;
+      si_limit -= 2;
+    }
+
   while (from && count_si < si_limit && count_hi < hi_limit)
     {
       int inc = get_attr_length (from);
       int new_align = 1;
 
+      if (NOTE_P (from))
+	{
+	  from = NEXT_INSN (from);
+	  continue;
+	}
+
       /* If this is a label that existed at the time of the compute_alignments
 	 call, determine the alignment.  N.B.  When find_barrier recurses for
 	 an out-of-reach mova, we might see labels at the start of previously
@@ -5109,14 +4971,17 @@
       if (BARRIER_P (from))
 	{
 	  rtx next;
-
+	  int bar_align = barrier_align (from);
 	  found_barrier = from;
 
 	  /* If we are at the end of the function, or in front of an alignment
 	     instruction, we need not insert an extra alignment.  We prefer
 	     this kind of barrier.  */
-	  if (barrier_align (from) > 2)
-	    good_barrier = from;
+	  if (bar_align > 2)
+	    {
+	      new_align = 1 << bar_align;
+	      good_barrier = from;
+	    }
 
 	  /* If we are at the end of a hot/cold block, dump the constants
 	     here.  */
@@ -5245,12 +5110,19 @@
 	       && ! optimize_size)
 	new_align = 4;
 
+      /* long jumps will change the alignment for the .long label.  */
+      else if (GET_CODE (from) == JUMP_INSN
+ 	       && GET_CODE (PATTERN (from)) == SET
+ 	       && recog_memoized (from) == CODE_FOR_jump_compact
+ 	       && inc == 10)
+ 	new_align = 4;
+
       /* There is a possibility that a bf is transformed into a bf/s by the
 	 delay slot scheduler.  */
-      if (JUMP_P (from) && !JUMP_TABLE_DATA_P (from) 
-	  && get_attr_type (from) == TYPE_CBRANCH
-	  && ! sequence_insn_p (from))
-	inc += 2;
+      if (flag_delayed_branch)
+	if (JUMP_P (from) && !JUMP_TABLE_DATA_P (from) 
+	    && get_attr_type (from) == TYPE_CBRANCH)
+	  inc += 2;
 
       if (found_si)
 	{
@@ -5261,6 +5133,9 @@
 	      si_align = new_align;
 	    }
 	  count_si = (count_si + new_align - 1) & -new_align;
+
+	  if (new_align < si_align)
+	    si_align = new_align;
 	}
       if (found_hi)
 	{
@@ -5271,6 +5146,9 @@
 	      hi_align = new_align;
 	    }
 	  count_hi = (count_hi + new_align - 1) & -new_align;
+
+	  if (new_align < hi_align)
+	    hi_align = new_align; 
 	}
       from = NEXT_INSN (from);
     }
@@ -5330,13 +5208,6 @@
       if (last_got && last_got != orig)
         from = PREV_INSN (last_got);
 
-      /* Don't insert the constant pool table at the position which
-	 may be the landing pad.  */
-      if (flag_exceptions
-	  && CALL_P (from)
-	  && find_reg_note (from, REG_EH_REGION, NULL_RTX))
-	from = PREV_INSN (from);
-
       /* Walk back to be just before any jump or label.
 	 Putting it before a label reduces the number of times the branch
 	 around the constant pool table will be hit.  Putting it before
@@ -5836,6 +5707,29 @@
     }
 }
 
+int
+sh_jump_align (rtx label)
+{
+  rtx insn;
+  int size = 0;
+
+  gcc_assert (label && GET_CODE (label) == CODE_LABEL);
+
+  for (insn = NEXT_INSN (label);
+       insn && GET_CODE (insn) != BARRIER &&
+	 GET_CODE (insn) != CODE_LABEL;
+       insn = NEXT_INSN (insn))
+    {
+      if (INSN_P (insn))
+	size += get_attr_min_length (insn);
+
+      if (size > sh_align_small_blocks)
+	return align_jumps_log;
+    }
+
+  return 0;
+}
+
 /* BARRIER_OR_LABEL is either a BARRIER or a CODE_LABEL immediately following
    a barrier.  Return the base 2 logarithm of the desired alignment.  */
 int
@@ -5950,7 +5844,21 @@
 	}
     }
 
-  return align_jumps_log;
+  while (BARRIER_P (barrier_or_label))
+    barrier_or_label = next_nonnote_insn (barrier_or_label);
+
+  return sh_jump_align (barrier_or_label);
+}
+
+static bool
+in_between(rtx start, rtx end, rtx r)
+{
+  rtx scan;
+  for (scan = NEXT_INSN (start); scan && scan != end; scan = NEXT_INSN (scan))
+    if (scan == r)
+      return 1;
+
+  return 0;
 }
 
 /* If we are inside a phony loop, almost any kind of label can turn up as the
@@ -5980,6 +5888,49 @@
   return align_loops_log;
 }
 
+static int fixup_addr;
+
+/* Check if a register function load is not alive in an exception handler
+   and can be safely removed when relaxing.  */
+
+typedef struct
+{
+  bool ret;
+  rtx reg;
+} rdata;
+
+/* Conservative approach. Will return true even if reg is set in the handler
+so its value could be dead. */
+static void
+handler_uses_reg (rtx scan, void *arg)
+{
+  rdata *rarg = (rdata*)arg;
+  bool seen_jump = false;;
+
+  if (rarg->ret)
+    return;
+
+  for (; scan; scan = NEXT_INSN (scan))
+    {
+      if (INSN_P (scan) || CALL_P (scan))
+        seen_jump = true;
+
+      if (! reg_mentioned_p (rarg->reg, scan))
+        continue;
+
+      if (!seen_jump && reg_set_p (rarg->reg, scan))
+	{
+	  rarg->ret = false;
+	  return;
+	}
+      if (reg_referenced_p (rarg->reg, PATTERN (scan)))
+	{
+	  rarg->ret = true;
+	  return;
+	}
+    }
+}
+
 /* Do a final pass over the function, just before delayed branch
    scheduling.  */
 static void
@@ -6029,10 +5980,17 @@
 	    }
 	}
 
+      if (df && optimize)
+	{
+	  df_note_add_problem ();
+	  df_analyze ();
+	}
+
       for (insn = first; insn; insn = NEXT_INSN (insn))
 	{
 	  rtx pattern, reg, link, set, scan, dies, label;
 	  int rescan = 0, foundinsn = 0;
+	  rdata region_arg;
 
 	  if (CALL_P (insn))
 	    {
@@ -6114,7 +6072,7 @@
 		 the call, and can result in situations where a single call
 		 insn may have two targets depending on where we came from.  */
 
-	      if (LABEL_P (scan) && ! foundinsn)
+	      if (LABEL_P (scan) && (LABEL_NUSES (scan) > 0))
 		break;
 
 	      if (! INSN_P (scan))
@@ -6125,7 +6083,21 @@
 		 instructions at the jump destination did not use REG.  */
 
 	      if (JUMP_P (scan))
-		break;
+		{
+		  if (ANY_RETURN_P (PATTERN (scan)))
+		    break;
+
+		  if (simplejump_p (scan))
+		    {
+		      rtx lab = JUMP_LABEL(scan);
+		      rtx next = next_active_insn (lab);
+
+		      if (next && in_between (link, scan, next))
+			continue;
+		    }
+
+		  break;
+		}
 
 	      if (! reg_mentioned_p (reg, scan))
 		continue;
@@ -6175,6 +6147,15 @@
 	      continue;
 	    }
 
+	  /* If the register is in use in one of the exception handler,
+	     can't relax it.  */
+
+	  region_arg.reg = reg;
+	  region_arg.ret = false;
+	  for_each_eh_label (handler_uses_reg, (void *)&region_arg);
+	  if (region_arg.ret)
+	    continue;
+
 	  /* Create a code label, and put it in a REG_LABEL_OPERAND note
 	     on the insn which sets the register, and on each call insn
 	     which uses the register.  In final_prescan_insn we look for
@@ -6413,7 +6394,7 @@
     PUT_MODE (insn, VOIDmode);
 
   mdep_reorg_phase = SH_SHORTEN_BRANCHES1;
-  INSN_ADDRESSES_FREE ();
+  init_insn_lengths ();
   split_branches (first);
 
   /* The INSN_REFERENCES_ARE_DELAYED in sh.h is problematic because it
@@ -6440,6 +6421,8 @@
     REG_USERVAR_P (get_fpscr_rtx ()) = 0;
 #endif
   mdep_reorg_phase = SH_AFTER_MDEP_REORG;
+
+   fixup_addr = 0;
 }
 
 /* Return the UID of the insn that follows the specified label.  */
@@ -6566,6 +6549,7 @@
 		    bp->address = addr;
 		  }
 		ok = redirect_jump (insn, label, 0);
+		/* thie branch length will be 2 !!!\n"); */
 		gcc_assert (ok);
 	      }
 	    else
@@ -6685,6 +6669,8 @@
   init_insn_lengths ();
 }
 
+static void sh_hw_workaround (rtx insn);
+
 /* Dump out instruction addresses, which is useful for debugging the
    constant pool table stuff.
 
@@ -6699,6 +6685,9 @@
 final_prescan_insn (rtx insn, rtx *opvec ATTRIBUTE_UNUSED,
 		    int noperands ATTRIBUTE_UNUSED)
 {
+  if (TARGET_DBHWBUG)
+    sh_hw_workaround (insn);
+
   if (TARGET_DUMPISIZE)
     fprintf (asm_out_file, "\n! at %04x\n", INSN_ADDRESSES (INSN_UID (insn)));
 
@@ -7499,6 +7488,9 @@
   tree sp_switch_attr
     = lookup_attribute ("sp_switch", DECL_ATTRIBUTES (current_function_decl));
 
+  if (sh_cfun_naked_p ())
+    return;
+
   current_function_interrupt = sh_cfun_interrupt_handler_p ();
 
   /* We have pretend args if we had an object sent partially in registers
@@ -7861,6 +7853,9 @@
   int fpscr_deferred = 0;
   int e = sibcall_p ? -1 : 1;
 
+  if (sh_cfun_naked_p ())
+    return;
+
   d = calc_live_regs (&live_regs_mask);
 
   save_size = d;
@@ -8227,6 +8222,7 @@
 sh_output_function_epilogue (FILE *file ATTRIBUTE_UNUSED,
 			     HOST_WIDE_INT size ATTRIBUTE_UNUSED)
 {
+  mdep_reorg_phase = SH_BEFORE_MDEP_REORG;
 }
 
 static rtx
@@ -9517,6 +9513,22 @@
   return NULL_TREE;
 }
 
+/* Handle an attribute requiring a FUNCTION_DECL;
+   arguments as in struct attribute_spec.handler.  */
+static tree
+sh_handle_fndecl_attribute (tree *node, tree name, tree args ATTRIBUTE_UNUSED,
+			     int flags ATTRIBUTE_UNUSED, bool *no_add_attrs)
+{
+  if (TREE_CODE (*node) != FUNCTION_DECL)
+    {
+      warning (OPT_Wattributes, "%qs attribute only applies to functions",
+	       IDENTIFIER_POINTER (name));
+      *no_add_attrs = true;
+    }
+
+  return NULL_TREE;
+}
+
 /* Handle an "interrupt_handler" attribute; arguments as in
    struct attribute_spec.handler.  */
 static tree
@@ -9754,6 +9766,15 @@
 	      != NULL_TREE) && TARGET_SH2A);
 }
 
+/* Return nonzero if the current function has attribute naked .  */
+static bool
+sh_cfun_naked_p (void)
+{
+  return (lookup_attribute ("naked",
+			    DECL_ATTRIBUTES (current_function_decl))
+	  != NULL_TREE);
+}
+
 /* Returns true if the current function has a "trap_exit" attribute set.  */
 bool
 sh_cfun_trap_exit_p (void)
@@ -9849,6 +9870,8 @@
   rtx dest = SET_SRC (PATTERN (branch));
   int dest_uid;
 
+  gcc_assert (INSN_ADDRESSES_SET_P ());
+
   if (GET_CODE (dest) == IF_THEN_ELSE)
     dest = XEXP (dest, 1);
   dest = XEXP (dest, 0);
@@ -10081,6 +10104,15 @@
   return gen_rtx_REG (Pmode, 7);
 }
 
+/* This function switches the fpscr.  */
+void
+emit_fpu_flip (void)
+{
+  emit_insn (gen_toggle_pr ());
+  if (TARGET_FMOVD)
+    emit_insn (gen_toggle_sz ());
+}
+
 /* This function will set the fpscr from memory.
    MODE is the mode we are setting it to.  */
 void
@@ -10099,6 +10131,52 @@
 #define IS_ASM_LOGICAL_LINE_SEPARATOR(C, STR) ((C) == ';')
 #endif
 
+int
+sh_insn_length_alignment (rtx insn)
+{
+  int align = 1;
+
+  if (INSN_P (insn))
+    {
+      rtx body = PATTERN (insn);
+
+      if (GET_CODE (body) == ASM_INPUT || asm_noperands (body) >= 0)
+	{
+	  const char *templ;
+
+	  if (GET_CODE (body) == ASM_INPUT)
+	    templ = XSTR (body, 0);
+	  else
+	    templ = decode_asm_operands (body, NULL, NULL, NULL, NULL, NULL);
+
+	  (void) sh_asm_count (templ, &align);
+	  return align;
+	}
+
+      return 1 << TARGET_SHMEDIA;
+    }
+
+#if 0
+  (NONJUMP_INSN_P (A_INSN)						\
+   ? 1 << TARGET_SHMEDIA						\
+   : JUMP_P (A_INSN) || CALL_P (A_INSN)					\
+   ? 1 << TARGET_SHMEDIA						\
+   : CACHE_LOG)
+#endif
+
+  align = GET_CODE (insn) == JUMP_INSN
+    && GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC
+    && GET_MODE (PATTERN (insn)) == HImode
+    ? 0
+    : GET_CODE (insn) == BARRIER
+    ? 0
+    : GET_CODE (insn) == JUMP_INSN || GET_CODE (insn) == CALL_INSN
+    ? 1 << TARGET_SHMEDIA
+    : 1;
+
+  return align;
+}
+
 static bool
 sequence_insn_p (rtx insn)
 {
@@ -10116,15 +10194,85 @@
 }
 
 int
-sh_insn_length_adjustment (rtx insn)
+sh_insn_length_adjustment (rtx insn, const int cur_length)
 {
-  /* Instructions with unfilled delay slots take up an extra two bytes for
-     the nop in the delay slot.  */
-  if (((NONJUMP_INSN_P (insn)
-	&& GET_CODE (PATTERN (insn)) != USE
-	&& GET_CODE (PATTERN (insn)) != CLOBBER)
-       || CALL_P (insn)
-       || (JUMP_P (insn) && !JUMP_TABLE_DATA_P (insn)))
+  /* optimize DC introduced by reorg.  */
+  if (TARGET_DEAD_DELAY && mdep_reorg_phase == SH_AFTER_MDEP_REORG && INSN_ADDRESSES_SET_P ())
+    {
+      if (deleted_delay_slot_p (insn))
+	return 0;
+
+      if (NONJUMP_INSN_P (insn) && GET_CODE (PATTERN (insn)) == SEQUENCE && cur_length == 4)
+	{
+	  rtx body = PATTERN (insn);
+	  rtx delay_insn = XVECEXP (body, 0, 1);
+	  rtx dpat = PATTERN (delay_insn);
+	  rtx nexti = next_real_insn (delay_insn);
+	  rtx label = NEXT_INSN (delay_insn);
+	  int log = 0;
+
+	  if (label && BARRIER_P (label))
+	    {
+	      for (; label && ! INSN_P (label);
+		   label = NEXT_INSN (label))
+		if (LABEL_P (label))
+		  {
+		    log = label_to_alignment (label);
+		    if (log) break;
+		  }
+	    }
+
+	  if (nexti && GET_CODE (dpat) == SET)
+	    {
+	      rtx jump_insn = XVECEXP (body, 0, 0);
+	      enum attr_type jump_type = get_attr_type (jump_insn);
+
+	      if ((jump_type != TYPE_SFUNC && jump_type != TYPE_CALL)
+		  && GET_CODE (jump_insn) == JUMP_INSN
+		  && rtx_equal_p (PATTERN (nexti), dpat)
+		  && ! reg_overlap_mentioned_p (SET_DEST (dpat), dpat))
+		{
+		  rtx lab = JUMP_LABEL (jump_insn);
+		  rtx prev = prev_real_insn (lab);
+
+		  /* bug 50754 optimize 2 instructions :
+		     br .l
+		     mov r1,r3
+		     .l: mov r1,r3  */
+		  if (nexti == prev)
+		    {
+		      delete_insn (insn);
+		      return -4;
+		    }
+		  /* bug 58105: optimize 1 instruction :
+		     bf/s .l
+		     mov r1,r3
+		     mov r1,r3  */
+		  else if (!log)
+		    {
+		      rtx old_delay = delay_insn;
+		      delay_insn = make_insn_raw (gen_dup_db_insn ());
+
+		      NEXT_INSN (delay_insn) = NEXT_INSN (old_delay);
+		      PREV_INSN (delay_insn) = jump_insn;
+		      NEXT_INSN (jump_insn) = delay_insn;
+		      XVECEXP (body, 0, 1) = delay_insn;
+
+		      INSN_ADDRESSES_NEW (delay_insn, -1);
+		      return -2;
+		    }
+		}
+	    }
+	}
+    }
+
+  /* Instructions with unfilled delay slots take up an extra two bytes for
+     the nop in the delay slot.  */
+  if (((NONJUMP_INSN_P (insn)
+	&& GET_CODE (PATTERN (insn)) != USE
+	&& GET_CODE (PATTERN (insn)) != CLOBBER)
+       || CALL_P (insn)
+       || (JUMP_P (insn) && !JUMP_TABLE_DATA_P (insn)))
       && ! sequence_insn_p (insn)
       && get_attr_needs_delay_slot (insn) == NEEDS_DELAY_SLOT_YES)
     return 2;
@@ -10192,6 +10340,7 @@
     }
   return 0;
 }
+
 
 /* Return TRUE for a valid displacement for the REG+disp addressing
    with MODE.  */
@@ -10218,7 +10367,7 @@
   else
     {
       const HOST_WIDE_INT offset = INTVAL (op);
-      const int max_disp = max_mov_insn_displacement (mode, consider_sh2a);
+      const int max_disp = sh_max_mov_insn_displacement (mode, consider_sh2a);
       const int align_mask = mov_insn_alignment_mask (mode, consider_sh2a);
 
       /* If the mode does not support any displacement always return false.
@@ -10231,6 +10380,7 @@
 
       return offset >= 0 && offset <= max_disp && (offset & align_mask) == 0;
     }
+  return false;
 }
 
 /* Recognize an RTL expression that is a valid memory address for
@@ -10404,7 +10554,7 @@
      effectively disable the small displacement insns.  */
   const int mode_sz = GET_MODE_SIZE (mode);
   const int mov_insn_sz = mov_insn_size (mode, false);
-  const int max_disp = max_mov_insn_displacement (mode, false);
+  const int max_disp = sh_max_mov_insn_displacement (mode, false);
   const int max_disp_next = max_disp + mov_insn_sz;
   HOST_WIDE_INT align_modifier = offset > 127 ? mov_insn_sz : 0;
   HOST_WIDE_INT offset_adjust;
@@ -10827,7 +10977,8 @@
 	  if (! reg_set_p (reg, dep_insn))
 	    cost -= TARGET_SH4_300 ? 1 : 4;
 	}
-      if (TARGET_HARD_SH4 && !TARGET_SH4_300)
+
+      else if (TARGET_HARD_SH4)
 	{
 	  enum attr_type dep_type = get_attr_type (dep_insn);
 
@@ -10866,26 +11017,20 @@
 	  if (get_attr_any_fp_comp (dep_insn) == ANY_FP_COMP_YES
 	      && get_attr_late_fp_use (insn) == LATE_FP_USE_YES)
 	    cost -= 1;
-	}
-      else if (TARGET_SH4_300)
-	{
-	  /* Stores need their input register two cycles later.  */
-	  if (dep_set && cost >= 1
-	      && ((type = get_attr_type (insn)) == TYPE_STORE
-		  || type == TYPE_PSTORE
-		  || type == TYPE_FSTORE || type == TYPE_MAC_MEM))
-	    {
-	      rtx set = single_set (insn);
-
-	      if (!reg_mentioned_p (SET_SRC (set), XEXP (SET_DEST (set), 0))
-		  && rtx_equal_p (SET_SRC (set), SET_DEST (dep_set)))
-		{
-		  cost -= 2;
-		  /* But don't reduce the cost below 1 if the address depends
-		     on a side effect of dep_insn.  */
-		  if (cost < 1
-		      && modified_in_p (XEXP (SET_DEST (set), 0), dep_insn))
-		    cost = 1;
+
+	  if (TARGET_SH4_300)
+	    {
+	      /* Stores need their input register two cycles later.  */
+	      if (dep_set && cost >= 1
+		  && ((type = get_attr_type (insn)) == TYPE_STORE
+		      || type == TYPE_PSTORE
+		      || type == TYPE_FSTORE || type == TYPE_MAC_MEM))
+		{
+		  rtx set = single_set (insn);
+
+		  if (!reg_mentioned_p (SET_SRC (set), XEXP (SET_DEST (set), 0))
+		      && regno_use_in (REGNO (SET_DEST (dep_set)), SET_SRC (set)))
+		      cost --;
 		}
 	    }
 	}
@@ -12032,6 +12177,61 @@
 }
 
 void
+sh_expand_lround (rtx op0, rtx op1, bool to_nearest)
+{
+  rtx tmp3;
+  rtx tmp2 = gen_reg_rtx (SImode);
+  rtx tmp1 = gen_reg_rtx (SImode);
+  rtx ftmp1 = gen_reg_rtx (SFmode);
+  rtx ftmp0 = gen_reg_rtx (SFmode);
+  rtx fpul = gen_rtx_REG (SImode, FPUL_REG);
+
+  emit_insn (gen_movsi_i (tmp2, GEN_INT (1 << 31)));
+
+  emit_move_insn (ftmp0, op1);
+
+  emit_move_insn (fpul, gen_lowpart (SImode, ftmp0));
+  emit_move_insn (tmp1, fpul);
+  emit_insn (gen_andsi3 (tmp2, tmp2, tmp1));
+
+  tmp3 = gen_lowpart (SImode,
+		      force_reg (SFmode,
+				 CONST_DOUBLE_ATOF ("0.5", SFmode)));
+
+  emit_insn (gen_iorsi3 (tmp3, tmp3, tmp2));
+
+  emit_insn (gen_addsf3 (ftmp0, ftmp0, gen_lowpart (SFmode, tmp3)));
+
+  emit_sf_insn (gen_fix_truncsfsi2_i4 (fpul, ftmp0, get_fpscr_rtx ()));
+
+  emit_move_insn (op0, fpul);
+
+  if (to_nearest)
+    {
+      rtx lab = gen_label_rtx ();
+
+      emit_sf_insn (gen_floatsisf2_i4 (ftmp1, fpul, get_fpscr_rtx ()));
+
+      emit_sf_insn (gen_cmpeqsf_t_i4 (ftmp1, ftmp0, get_fpscr_rtx ()));
+
+      emit_jump_insn (gen_branch_false (lab));
+
+      emit_move_insn (tmp3, const1_rtx);
+      emit_insn (gen_andsi3 (tmp3, tmp3, op0));
+      emit_insn (gen_cmpeqsi_t (tmp3, const0_rtx));
+      emit_jump_insn (gen_branch_true (lab));
+
+      emit_insn (gen_cmpeqsi_t (tmp2, const0_rtx));
+      emit_insn (gen_movt (tmp2, get_t_reg_rtx ()));
+      emit_insn (gen_shll (tmp2, tmp2));
+      emit_insn (gen_addsi3 (tmp2, tmp2, GEN_INT (-1)));
+      emit_insn (gen_subsi3 (op0, op0, tmp2));
+
+      emit_label (lab);
+    }
+}
+
+void
 sh_expand_binop_v2sf (enum rtx_code code, rtx op0, rtx op1, rtx op2)
 {
   rtx op = gen_rtx_fmt_ee (code, SFmode, op1, op2);
@@ -12164,11 +12364,6 @@
 	  if (GET_MODE_SIZE (to) < 8 || GET_MODE_SIZE (from) < 8)
 	    return reg_classes_intersect_p (DF_REGS, rclass);
 	}
-      else
-	{
-	  if (GET_MODE_SIZE (from) < 8)
-	    return reg_classes_intersect_p (DF_HI_REGS, rclass);
-	}
     }
   return false;
 }
@@ -12310,6 +12505,8 @@
 
   emit_note (NOTE_INSN_PROLOGUE_END);
 
+  emit_barrier ();
+
   /* Find the "this" pointer.  We have such a wide range of ABIs for the
      SH that it's best to do this completely machine independently.
      "this" is passed as first argument, unless a structure return pointer
@@ -12454,6 +12651,7 @@
       emit_move_insn (scratch2, funexp);
       funexp = gen_rtx_MEM (FUNCTION_MODE, scratch2);
       sibcall = gen_sibcall (funexp, const0_rtx, NULL_RTX);
+      add_reg_note (sibcall, REG_DEAD, scratch2);
     }
   sibcall = emit_call_insn (sibcall);
   SIBLING_CALL_P (sibcall) = 1;
@@ -12500,6 +12698,10 @@
       {
       case FUNCTION_ORDINARY:
 	break;
+      case SFUNC_FREQUENT:
+	if (!optimize || optimize_size)
+	  break;
+	/* Fall through.  */
       case SFUNC_GOT:
 	{
 	  rtx reg = target ? target : gen_reg_rtx (Pmode);
@@ -13165,7 +13367,8 @@
      the insns must have the appropriate alternatives.  */
   if ((mode == QImode || mode == HImode) && rclass != R0_REGS
       && satisfies_constraint_Sdd (x)
-      && disp_addr_displacement (x) <= max_mov_insn_displacement (mode, false))
+      && sh_disp_addr_displacement (x)
+	 <= sh_max_mov_insn_displacement (mode, false))
     return R0_REGS;
 
   /* When reload is trying to address a QImode or HImode subreg on the stack, 
@@ -13189,6 +13392,8 @@
   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno ++)
     if (! VALID_REGISTER_P (regno))
       fixed_regs[regno] = call_used_regs[regno] = 1;
+  if (TARGET_SH4A_FP || TARGET_SH4_300)
+    global_regs[FPSCR_REG] = 1;
   /* R8 and R9 are call-clobbered on SH5, but not on earlier SH ABIs.  */
   if (TARGET_SH5)
     {
@@ -13203,6 +13408,10 @@
       CLEAR_HARD_REG_SET (reg_class_contents[FP0_REGS]);
       regno_reg_class[FIRST_FP_REG] = FP_REGS;
     }
+  if (TARGET_R0R3_TO_REG_MUL < 2)
+    regno_reg_class[R1_REG] = regno_reg_class[R2_REG]
+      = regno_reg_class[R3_REG] = GENERAL_REGS;
+    /* The peephole2s needs reg_class_contents[R0R3_REGS].  */ 
   if (flag_pic)
     {
       fixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;
@@ -13214,9 +13423,6 @@
       call_really_used_regs[MACH_REG] = 0;
       call_really_used_regs[MACL_REG] = 0;
     }
-  for (regno = FIRST_FP_REG + (TARGET_LITTLE_ENDIAN != 0);
-       regno <= LAST_FP_REG; regno += 2)
-    SET_HARD_REG_BIT (reg_class_contents[DF_HI_REGS], regno);
   if (TARGET_SHMEDIA)
     {
       for (regno = FIRST_TARGET_REG; regno <= LAST_TARGET_REG; regno ++)
@@ -13253,6 +13459,519 @@
   init_sync_libfuncs (UNITS_PER_WORD);
 }
 
+static int asm_size (char *s, int addr, int *seen_align)
+{
+  char *pt;
+
+  if (*s == ';' || *s == '\n' || *s == '\0')
+    return 0;
+
+  else if (strstr (s, ".long"))
+    {
+      int n = 1;
+      /* parse .long	1, 3 syntax.  */
+      while (*s != '\n' && *s != '\0')
+	{
+	  s++;
+	  if (*s == ',')  n++;
+	}
+      return 2 * n;
+    }
+
+  else if (strstr (s, ".short") || strstr (s, ".word"))
+    {
+      int n = 1;
+      /* parse .short	1, 3 syntax.  */
+      while (*s != '\n' && *s != '\0')
+	{
+	  s++;
+	  if (*s == ',')  n++;
+	}
+      return n;
+    }
+
+  else if (insn_current_address != -1 && strstr (s, ".balign"))
+    {
+      long int align;
+      int new_address;
+
+      while (*s != '\t' && *s != ' ') s++;
+      align = strtol (s, NULL, 10);
+      if (errno == ERANGE || errno == EINVAL)
+	{
+	  warning (OPT_mdb_page_bug, "unsupported %s asm for w/a.", s);
+	  return 0;
+	}
+
+      /* return log.  */
+      if (seen_align)
+	*seen_align = exact_log2 (align);
+      new_address = (addr + align - 1) & -align;
+      /* return size / insn_default_length().  */
+      return (new_address - addr) / 2;
+    }
+
+  else if (insn_current_address != -1 && strstr (s, ".align"))
+    {
+      long int align;
+      int new_address;
+
+      while (*s != '\t' && *s != ' ') s++;
+      align = strtol (s, NULL, 10);
+      if (errno == ERANGE || errno == EINVAL)
+	{
+	  warning (OPT_mdb_page_bug, "unsupported %s asm for w/a.", s);
+	  return 0;
+	}
+
+      /* return log.  */
+      if (seen_align)
+	*seen_align = align;
+
+      align = 1 << align;
+      new_address = (addr + align - 1) & -align;
+      /* return size / insn_default_length().  */
+      return (new_address - addr) / 2;
+    }
+
+  else if (strstr (s, ".space") || strstr (s, ".skip"))
+    {
+      long int align;
+      errno = 0;
+      while (*s != '\t' && *s != ' ') s++;
+      align = strtol (s, NULL, 10);
+      if (errno == ERANGE || errno == EINVAL)
+	{
+	  warning (OPT_mdb_page_bug, "unsupported %s asm for w/a.", s);
+	  return 0;
+	}
+      return align / 2;
+    }
+
+  else if (strstr (s, ".fill"))
+    {
+      char delim[] = ",\n";
+      char *size;
+      char *n;
+      while (*s != '\t' && *s != ' ') s++;
+      size = strtok(s, delim);
+      n = strtok(NULL, delim);
+      if (n)
+	{
+	  (void) strtok(NULL, delim);
+	  return strtol (size, NULL, 10) * strtol (n, NULL, 10) / 2;
+	}
+      return 1;
+    }
+
+  else if ((pt = strrchr (s, ':')) != NULL)
+    {
+      while (*pt == '\t' || *pt == ' ' || *pt == ':') pt++;
+      return asm_size (pt, addr, seen_align);
+    }
+
+  if (*s == '.' && mdep_reorg_phase == SH_AFTER_MDEP_REORG)
+    warning (OPT_mdb_page_bug, "unsupported %s asm for w/a.", s);
+
+  return 1;
+}
+
+int
+sh_align_function_log(tree fn)
+{
+  int first, last;
+
+  if (! INSN_ADDRESSES_SET_P () || optimize <= 0)
+    return align_functions_log;
+
+  if (lookup_attribute ("cold", DECL_ATTRIBUTES (fn)))
+    return 1;
+
+  first = INSN_ADDRESSES (INSN_UID (get_insns()));
+  last = INSN_ADDRESSES (INSN_UID (get_last_insn ()));
+
+ if (last - first < 32)
+    return 2;
+  else
+    return align_functions_log;
+}
+
+int
+sh_asm_count (const char *templ, int *seen_align)
+{
+  int count = 0;
+  char *s, *lt;
+  char delim[] = ";\n";
+  int in_sub = 0;
+  int addr;
+
+  addr = mdep_reorg_phase == SH_AFTER_MDEP_REORG && INSN_ADDRESSES_SET_P () ?
+    insn_current_address : 2;
+
+  lt = (char *) alloca (strlen (templ) + 1);
+  strcpy (lt, templ);
+
+  s = strtok(lt, delim);
+
+  while (s != NULL)
+    {
+      while (*s == '\t' || *s == ' ') s++;
+
+      if (strstr (s, ".pushsection") || strstr (s, ".section"))
+	in_sub++;
+
+      if (! in_sub)
+	count += asm_size (s, addr + (count * 2), seen_align);
+
+      if (strstr (s, ".popsection") || strstr (s, ".previous"))
+	in_sub--;
+
+      s = strtok(NULL, delim);
+    }
+
+  return count;
+}
+
+static int align_next_insn;
+
+static void
+sh_hw_workaround (rtx insn)
+{
+  int uid_address = INSN_ADDRESSES (INSN_UID (insn));
+  int real_address = uid_address + fixup_addr;
+
+  if (GET_CODE (insn) == CODE_LABEL)
+    {
+      rtx barrier = prev_nonnote_insn (insn);
+      if (barrier && BARRIER_P (barrier))
+	{
+	  int log = label_to_alignment (insn);
+	  int align = 1 << log;
+
+	  int aligned_real_address;
+	  int last_unaligned_uid_address = INSN_ADDRESSES (INSN_UID (barrier));
+
+	  real_address -= (uid_address - last_unaligned_uid_address);
+	  aligned_real_address = (real_address + align - 1) & -align;
+
+	  fixup_addr = aligned_real_address - uid_address;
+	  return;
+	}
+    }
+
+  if (INSN_P (insn))
+    {
+      rtx body = PATTERN (insn);
+
+      if (GET_CODE (body) == UNSPEC_VOLATILE && XINT (body, 1) == UNSPECV_ALIGN)
+	{
+	  int log = INTVAL (XVECEXP (body, 0, 0));
+	  int align = 1 << log;
+	  int aligned_real_address = (real_address + align - 1) & -align;
+	  int aligned_current_address = (uid_address + align - 1) & -align;
+
+	  fixup_addr = aligned_real_address - aligned_current_address;
+	  return;
+	}
+
+      if (align_next_insn)
+	{
+	  align_next_insn = 0;
+	  fixup_addr = -uid_address;
+	  fprintf (asm_out_file, ".align 5\t\t! for hw workaround \n");
+	}
+
+      if (GET_CODE (body) == ASM_INPUT || asm_noperands (body) >= 0)
+	{
+	  int align = 0;
+	  const char *templ;
+
+	  if (GET_CODE (body) == ASM_INPUT)
+	    templ = XSTR (body, 0);
+	  else
+	    templ = decode_asm_operands (body, NULL, NULL, NULL, NULL, NULL);
+
+	  (void) sh_asm_count (templ, &align);
+	  if (align)
+	    {
+	      align_next_insn = 1;
+	      return;
+	    }
+	}
+
+      gcc_assert (! (real_address % 2));
+
+      /* +2 because we check that the ds is not aligned on 32.  */
+      real_address += 2;
+
+      if (recog_memoized (insn) == CODE_FOR_cmpgtudi_t
+	  || recog_memoized (insn) == CODE_FOR_cmpgeudi_t
+	  || recog_memoized (insn) == CODE_FOR_cmpgtdi_t
+	  || recog_memoized (insn) == CODE_FOR_cmpgedi_t)
+	if (!((real_address + 2) % 32))
+	  {
+	    fprintf (asm_out_file,
+		     "\tnop\t\t! for hw workaround @%d\n", real_address);
+	    fixup_addr += 2;
+	    return;
+	  }
+
+      if (recog_memoized (insn) == CODE_FOR_tls_global_dynamic
+	  || recog_memoized (insn) == CODE_FOR_tls_local_dynamic)
+	{
+	  int aligned_real_address;
+	  int align = 4;
+
+	  if (!((real_address + 8) % 32) || !((real_address + 12) % 32))
+	    {
+	      fprintf (asm_out_file,
+		       "\tnop\t\t! for hw workaround @%d\n", real_address);
+	      fixup_addr += 2;
+	      real_address += get_attr_length (insn);
+	    }
+	  else
+	    real_address += get_attr_length (insn) - 2;
+
+	  aligned_real_address = (real_address + align - 1) & -align;
+	  fixup_addr += aligned_real_address - real_address;
+	  return;
+	}
+
+      if (recog_memoized (insn) == CODE_FOR_tls_initial_exec)
+	{
+	  int aligned_real_address;
+	  int align = 4;
+
+	  if (!((real_address + 6) % 32))
+	    {
+	      fprintf (asm_out_file,
+		       "\tnop\t\t! for hw workaround @%d\n", real_address);
+	      fixup_addr += 2;
+	      real_address += get_attr_length (insn);
+	    }
+	  else
+	    real_address += get_attr_length (insn) - 2;
+
+	  aligned_real_address = (real_address + align - 1) & -align;
+	  fixup_addr += aligned_real_address - real_address;
+	  return;
+	}
+
+      if (recog_memoized (insn) == CODE_FOR_jump_compact)
+	{
+	  int offset = branch_dest (insn) - INSN_ADDRESSES (INSN_UID (insn));
+	  int far;
+
+	  far = ! (offset >= FAR_JUMP_MIN && offset <= FAR_JUMP_MAX);
+
+	  /* length = 6
+	     mov.w	.L8588,r1
+	     braf	r1
+	     mov	#81,r4	         [length = 2]
+	     .L8588: .word .L12-.L8588
+
+	     length = 8
+	     mov.w	.L8588,r1
+	     braf	r1
+	     nop
+	     .L8588: .word .L12-.L8588
+
+	     length = 10
+	     mov	#81,r4	         [length = 2]
+	     mov.l	r13,@-r15
+	     mov.w	.L,r13
+	     braf	r13
+	     mov.l	@r15+,r13
+	     .L: .word
+	  */
+	  if (!far)
+	    {
+	      if (get_attr_length (insn) == 6 || get_attr_length (insn) == 8)
+		real_address += 2;
+	      if (get_attr_length (insn) == 10)
+		{
+		  if (dbr_sequence_length ())
+		    real_address += 6;
+		  else
+		    real_address += 4;
+		}
+	    }
+	  /* length = 8/10 depending on alignment
+	     mov.l	.L8586,r4
+	     jmp	@r4
+	     mov	#81,r4         [length = 2]
+	     .align	2
+	     .L8586:  .long	.L5
+
+	     length = 10/12 depending on alignment
+	     mov.l	.L8589,r3
+	     jmp	@r3
+	     nop
+	     .align	2
+	     .L8589:  .long	.L2242
+
+	     length = 12/14 depending on alignment
+	     mov.l	r13,@-r15
+	     mov.l	.L4981,r13
+	     jmp	@r13
+	     mov.l	@r15+,r13
+	     .align	2
+	     .L4981:	.long	.L16
+	  */
+	  else
+	    {
+	      int long_address;
+	      int uid_long_address;
+	      int aligned_long_address;
+	      int aligned_uid_long_address;
+
+	      if (get_attr_length (insn) == 8 || get_attr_length (insn) == 10)
+		{
+		  if (!((real_address + 2) % 32))
+		    {
+		      fprintf (asm_out_file,
+			       "\tnop\t\t! for hw workaround @%d\n", real_address);
+		      real_address += 2;
+		    }
+
+		  long_address = real_address + 4;
+		  uid_long_address = uid_address + 6;
+		  aligned_long_address = (long_address + 3) & -4;
+		  aligned_uid_long_address = (uid_long_address + 3) & -4;
+
+		  fixup_addr = aligned_long_address - aligned_uid_long_address;
+		  if (fixup_addr && (fixup_addr % 4))
+		    fixup_addr -= 4;
+
+		  return;
+	      }
+	      else if (get_attr_length (insn) == 12)
+		{
+		  rtx prev;
+
+		  if (!((real_address + 2) % 32))
+		    {
+		      fprintf (asm_out_file,
+			       "\tnop\t\t! for hw workaround @%d\n", real_address);
+		      real_address += 2;
+		    }
+
+		if (GET_CODE ((prev = prev_nonnote_insn (insn))) == INSN
+		    && INSN_CODE (prev) == CODE_FOR_indirect_jump_scratch)
+		  {
+		    long_address = real_address + 4;
+		    uid_long_address = uid_address + 6;
+		  }
+		else
+		  {
+		    long_address = real_address + 6;
+		    uid_long_address = uid_address + 8;
+		  }
+
+		  aligned_long_address = (long_address + 3) & -4;
+		  aligned_uid_long_address = (uid_long_address + 3) & -4;
+
+		  fixup_addr = aligned_long_address - aligned_uid_long_address;
+		  if (fixup_addr && (fixup_addr % 4))
+		    fixup_addr -= 4;
+
+		  return;
+		}
+	      else if (get_attr_length (insn) == 14)
+		{
+		  if (!((real_address + 4) % 32))
+		    {
+		      fprintf (asm_out_file,
+			       "\tnop\t\t! for hw workaround @%d\n", real_address);
+		      real_address += 2;
+		    }
+
+		  long_address = real_address + 6;
+		  uid_long_address = uid_address + 8;
+		  aligned_long_address = (long_address + 3) & -4;
+		  aligned_uid_long_address = (uid_long_address + 3) & -4;
+
+		  fixup_addr = aligned_long_address - aligned_uid_long_address;
+		  if (fixup_addr && (fixup_addr % 4))
+		    fixup_addr -= 4;
+
+		  return;
+		}
+	    }
+
+	  if (!(real_address % 32))
+	    {
+	      fprintf (asm_out_file,
+		       "\tnop\t\t! for hw workaround 1 @%d\n", real_address);
+	      fixup_addr += 2;
+	      return;
+	    }
+	}
+
+      /* we have bt; (aligned)bra; nop; avoid nop ; (aligned)bt; bra; nop.  */
+      /* or bt; delayed instruction; (aligned)bra.  */
+      if ((recog_memoized (insn) == CODE_FOR_branch_true
+	   || recog_memoized (insn) == CODE_FOR_branch_false)
+	  && get_attr_length (insn) == 6)
+	{
+	  if (!((real_address + 2) % 32))
+	    {
+	      fprintf (asm_out_file,
+		       "\tnop\t\t! for hw workaround @%d\n", real_address-2);
+	      fprintf (asm_out_file,
+		       "\tnop\t\t! for hw workaround @%d\n", real_address);
+	      fixup_addr += 4;
+	    }
+	  else if (!(real_address % 32))
+	    {
+	      fprintf (asm_out_file,
+		       "\tnop\t\t! for hw workaround @%d\n", real_address);
+	      fixup_addr += 2;
+	    }
+	  else if (!((real_address + 4) % 32)
+		   && (dbr_sequence_length ()
+		       && ! INSN_ANNULLED_BRANCH_P (XVECEXP (final_sequence, 0, 0))
+		       && get_attr_length (XVECEXP (final_sequence, 0, 1))))
+	    {
+	      fprintf (asm_out_file,
+		       "\tnop\t\t! for hw workaround @%d\n", real_address);
+	      fixup_addr += 2;
+	    }
+	}
+
+      if ((GET_CODE (insn) == JUMP_INSN
+	   && GET_CODE (PATTERN (insn)) != ADDR_DIFF_VEC
+	   && GET_CODE (PATTERN (insn)) != ADDR_VEC))
+	{
+	  if (!(real_address % 32)
+	      && (dbr_sequence_length ()
+		  && ! INSN_ANNULLED_BRANCH_P (XVECEXP (final_sequence, 0, 0))
+		  && get_attr_length (XVECEXP (final_sequence, 0, 1))))
+	    {
+	      fprintf (asm_out_file,
+		       "\tnop\t\t! for hw workaround @%d\n", real_address);
+	      fixup_addr += 2;
+	    }
+	  else if (GET_CODE (insn) == CALL_INSN
+		   && !(real_address % 32))
+	    {
+	      fprintf (asm_out_file,
+		       "\tnop\t\t! for hw workaround @%d\n", real_address);
+	      fixup_addr += 2;
+	    }
+	}
+
+	if ((GET_CODE (insn) == CALL_INSN || INSN_P (insn))
+	    && !(real_address % 32)
+	    && get_attr_needs_delay_slot (insn) == NEEDS_DELAY_SLOT_YES)
+	{
+	  fprintf (asm_out_file,
+		   "\tnop\t\t! for hw workaround @%d\n", real_address);
+	  fixup_addr += 2;
+	}
+    }
+}
+
 /* Return true if it is appropriate to emit `ret' instructions in the
    body of a function.  */
 bool
@@ -13283,6 +14002,232 @@
   return true;
 }
 
+/* When the stack protector inserts codes after R0 is set,
+   a load of @(rX, r12) will cause a spill failure for R0.  Avoid combining
+   (set A (plus rX r12)) and (set op0 (mem A)) when R0 is alive.  */
+bool
+stack_protector_block (rtx insn, rtx op)
+{
+  rtx addr;
+
+  if (!MEM_P (op))
+    return false;
+
+  addr = XEXP (op, 0);
+
+  if (GET_CODE (addr) == PLUS
+      && REG_P (XEXP (addr, 0)) && REG_P (XEXP (addr, 1)))
+    {
+      bool r0_seen = false;
+
+      for (insn = next_real_insn (insn); insn; insn = next_real_insn (insn))
+	{
+	  rtx pat = PATTERN (insn);
+
+	  if (dead_or_set_regno_p (insn, R0_REG))
+	    return false;
+
+	  if (GET_CODE (insn) == JUMP_INSN)
+	    {
+	      /* Must have a jump_insn after the SP test.  Check if R0 is alive here.  */
+	      if (r0_seen)
+		for (insn = NEXT_INSN (JUMP_LABEL (insn));
+		     insn; insn = NEXT_INSN (insn))
+		  if (INSN_P (insn)
+		      && refers_to_regno_p (R0_REG, R0_REG+1, PATTERN (insn), (rtx *)0))
+		    return true;
+
+	      /* No need to check further.  */
+	      return false;
+	    }
+
+	  /* Find stack-protector test. After this point R0 is under pressure.  */
+	  if (GET_CODE (pat) == PARALLEL)
+	    {
+	      pat = XVECEXP (pat, 0, 0);
+	      if (GET_CODE (pat) == SET)
+		{
+		  rtx src = XEXP (pat, 1);
+		  if (GET_CODE (src) == UNSPEC && (XINT (src, 1) == UNSPEC_SP_TEST))
+		    r0_seen = true;
+		}
+	    }
+	}
+    }
+
+  return false;
+}
+
+/*
+; If a conditional branch destination is within -252..258 bytes away
+; from the instruction it can be 2 bytes long.  Something in the
+; range -4090..4100 bytes can be 6 bytes long.  All other conditional
+; branches are initially assumed to be 16 bytes long.
+; In machine_dependent_reorg, we split all branches that are longer than
+; 2 bytes.
+
+;; The maximum range used for SImode constant pool entries is 1018.  A final
+;; instruction can add 8 bytes while only being 4 bytes in size, thus we
+;; can have a total of 1022 bytes in the pool.  Add 4 bytes for a branch
+;; instruction around the pool table, 2 bytes of alignment before the table,
+;; and 30 bytes of alignment after the table.  That gives a maximum total
+;; pool size of 1058 bytes.
+;; Worst case code/pool content size ratio is 1:2 (using asms).
+;; Thus, in the worst case, there is one instruction in front of a maximum
+;; sized pool, and then there are 1052 bytes of pool for every 508 bytes of
+;; code.  For the last n bytes of code, there are 2n + 36 bytes of pool.
+;; If we have a forward branch, the initial table will be put after the
+;; unconditional branch.
+;;
+;; ??? We could do much better by keeping track of the actual pcloads within
+;; the branch range and in the pcload range in front of the branch range.
+*/
+
+bool short_cbranch_p (rtx insn)
+{
+  int baddr, offset;
+
+  if (mdep_reorg_phase <= SH_FIXUP_PCLOAD)
+    return false;
+
+  baddr = insn_current_reference_address (insn);
+  offset = branch_dest (insn) - baddr;
+
+  /* bt, bt/s */
+  if (offset >= -256 + 4 && offset <= 254 + 4)
+    return true;
+
+  return false;
+}
+
+bool med_branch_p (rtx insn)
+{
+  int baddr, offset;
+
+  baddr = insn_current_reference_address (insn);
+  offset = branch_dest (insn) - baddr;
+
+  /* bra .L */
+  if (offset >= -4096 + 4 && offset <= 4094 + 4)
+    {
+      return mdep_reorg_phase > SH_FIXUP_PCLOAD
+	|| (offset >= -1024 && offset <= 1024);
+    }
+
+  return false;
+}
+
+bool med_cbranch_p (rtx insn)
+{
+  int baddr, offset;
+
+  baddr = insn_current_reference_address (insn);
+
+  /* we'll have
+     bt .l2
+     bra .l
+     nop
+     .2:
+  */
+
+  /* we'll start at bra, next instruction */
+  baddr += 2;
+
+  offset = branch_dest (insn) - baddr;
+
+  if (offset >= -4096 + 4 && offset <= 4094 + 4)
+    {
+      return mdep_reorg_phase > SH_FIXUP_PCLOAD
+	|| (offset >= -1024 && offset <= 1024);
+    }
+
+  return false;
+}
+
+bool braf_branch_p (rtx insn)
+{
+  rtx prev;
+  int baddr, offset, prev_count;
+
+  if (! TARGET_SH2)
+    return false;
+
+  baddr = insn_current_reference_address (insn);
+
+   /* DS
+      push
+      mov
+      braf
+      pop
+      .word (2)
+
+      push
+      mov
+      braf
+      pop
+      .word (2) */
+
+  prev = prev_nonnote_insn (insn);
+  if (prev && NONJUMP_INSN_P (prev)
+      && INSN_CODE (prev) == CODE_FOR_indirect_jump_scratch)
+    prev_count = 2;
+  else
+    prev_count = 4;
+
+  baddr += prev_count;
+
+  /* The delayed instruction will be emitted BEFORE the braf !!. */
+  if (NEXT_INSN (PREV_INSN (insn)) != insn && prev_count == 4)
+    baddr += 2;
+
+  offset = branch_dest (insn) - baddr;
+
+  if (offset >= -32768 + 4 && offset <= 32767 + 4)
+    {
+      return mdep_reorg_phase > SH_FIXUP_PCLOAD
+	|| (offset >= -8192 && offset <= 8192);
+    }
+
+  return false;
+}
+
+bool braf_cbranch_p (rtx insn)
+{
+  int baddr, offset;
+
+  if (! TARGET_SH2)
+    return false;
+
+  baddr = insn_current_reference_address (insn);
+
+
+  /* we'll have
+     bt .l2
+     mov  .l,r1
+     braf .l
+     nop
+     .word
+     .2:
+  */
+
+  /* we'll start at bra, next instruction avec the mov. */
+  baddr += 4;
+
+  /* The delayed instruction will be emitted BEFORE the braf !!. */
+  if (NEXT_INSN (PREV_INSN (insn)) != insn)
+    baddr += 2;
+
+  offset = branch_dest (insn) - baddr;
+
+  if (offset >= -32768 + 4 && offset <= 32767 + 4)
+    {
+      return mdep_reorg_phase > SH_FIXUP_PCLOAD
+	|| (offset >= -8192 && offset <= 8192);
+    }
+
+  return false;
+}
+
 /*------------------------------------------------------------------------------
   Address mode optimization support code
 */
diff -ruN gcc-gnu-4.8.2/gcc/config/sh/sh-c.c gcc-st40-4.8.2.140205/gcc/config/sh/sh-c.c
--- gcc-gnu-4.8.2/gcc/config/sh/sh-c.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/config/sh/sh-c.c	2013-05-28 13:15:34.000000000 +0200
@@ -76,6 +76,10 @@
 void
 sh_cpu_cpp_builtins (cpp_reader* pfile)
 {
+  if (TARGET_DBHWBUG) \
+      builtin_define_with_value ("DB_ST40300_BUG_WORKAROUND", "32", 0); \
+  if (TARGET_ENABLE_TAS) \
+      builtin_define ("__HAVE_TAS__"); \
   builtin_define ("__sh__");
   builtin_assert ("cpu=sh");
   builtin_assert ("machine=sh");
diff -ruN gcc-gnu-4.8.2/gcc/config/sh/sh.h gcc-st40-4.8.2.140205/gcc/config/sh/sh.h
--- gcc-gnu-4.8.2/gcc/config/sh/sh.h	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/config/sh/sh.h	2014-01-29 12:57:17.000000000 +0100
@@ -2,6 +2,7 @@
    Copyright (C) 1993-2013 Free Software Foundation, Inc.
    Contributed by Steve Chamberlain (sac@cygnus.com).
    Improved by Jim Wilson (wilson@cygnus.com).
+   Copyright (c) 2011  STMicroelectronics.
 
 This file is part of GCC.
 
@@ -63,6 +64,11 @@
 #define TARGET_FPU_DOUBLE \
   ((target_flags & MASK_SH4) != 0 || TARGET_SH2A_DOUBLE)
 
+#define TARGET_SH1_SOFTFP (TARGET_SH1 && !TARGET_FPU_DOUBLE)
+
+#define TARGET_SH1_SOFTFP_MODE(MODE) \
+  (TARGET_SH1_SOFTFP && (!TARGET_SH2E || (MODE) == DFmode))
+
 /* Nonzero if an FPU is available.  */
 #define TARGET_FPU_ANY (TARGET_SH2E || TARGET_FPU_DOUBLE)
 
@@ -97,13 +103,16 @@
 /* Nonzero if we should generate code using SHmedia FPU instructions.  */
 #define TARGET_SHMEDIA_FPU (TARGET_SHMEDIA && TARGET_FPU_DOUBLE)
 
+/* builtin_trap can uses abort() by default.  */
+#define TARGET_BUILTIN_TRAPA 0
+
 /* This is not used by the SH2E calling convention  */
 #define TARGET_VARARGS_PRETEND_ARGS(FUN_DECL) \
   (TARGET_SH1 && ! TARGET_SH2E && ! TARGET_SH5 \
    && ! (TARGET_HITACHI || sh_attr_renesas_p (FUN_DECL)))
 
 #ifndef TARGET_CPU_DEFAULT
-#define TARGET_CPU_DEFAULT SELECT_SH1
+#define TARGET_CPU_DEFAULT SELECT_SH4
 #define SUPPORT_SH1 1
 #define SUPPORT_SH2E 1
 #define SUPPORT_SH4 1
@@ -127,7 +136,9 @@
 #define TARGET_DIVIDE_INV_CALL2 (sh_div_strategy == SH_DIV_INV_CALL2)
 #define TARGET_DIVIDE_CALL_DIV1 (sh_div_strategy == SH_DIV_CALL_DIV1)
 #define TARGET_DIVIDE_CALL_FP (sh_div_strategy == SH_DIV_CALL_FP)
-#define TARGET_DIVIDE_CALL_TABLE (sh_div_strategy == SH_DIV_CALL_TABLE)
+#define TARGET_DIVIDE_CALL_PRE1 (sh_div_strategy == SH_DIV_CALL_PRE1)
+#define TARGET_DIVIDE_CALL_TABLE (sh_div_strategy == SH_DIV_CALL_TABLE \
+   || TARGET_DIVIDE_CALL_PRE1)
 
 #define SELECT_SH1		 (MASK_SH1)
 #define SELECT_SH2		 (MASK_SH2 | SELECT_SH1)
@@ -162,6 +173,42 @@
 #define SELECT_SH5_COMPACT	 (MASK_SH5 | MASK_SH4 | SELECT_SH3E)
 #define SELECT_SH5_COMPACT_NOFPU (MASK_SH5 | SELECT_SH3)
 
+/* Check if we have support for optimized software floating point using
+   dynamic shifts - then some function calls clobber fewer registers.  */
+#ifdef SUPPORT_SH3
+#define SUPPORT_SH3_OSFP 1
+#else
+#define SUPPORT_SH3_OSFP 0
+#endif
+
+#ifdef SUPPORT_SH3E
+#define SUPPORT_SH3E_OSFP 1
+#else
+#define SUPPORT_SH3E_OSFP 0
+#endif
+
+#if defined(SUPPORT_SH4_NOFPU) || defined(SUPPORT_SH3_OSFP)
+#define SUPPORT_SH4_NOFPU_OSFP 1
+#else
+#define SUPPORT_SH4_NOFPU_OSFP 0
+#endif
+
+#if defined(SUPPORT_SH4_SINGLE_ONLY) || defined (SUPPORT_SH3E_OSFP)
+#define SUPPORT_SH4_SINGLE_ONLY_OSFP 1
+#else
+#define SUPPORT_SH4_SINGLE_ONLY_OSFP 0
+#endif
+
+#ifdef notyet
+#define TARGET_OSFP (0 \
+ || (TARGET_SH3 && !TARGET_SH2E && SUPPORT_SH3_OSFP) \
+ || (TARGET_SH3E && SUPPORT_SH3E_OSFP) \
+ || (TARGET_HARD_SH4 && !TARGET_SH2E && SUPPORT_SH4_NOFPU_OSFP) \
+ || (TARGET_HARD_SH4 && TARGET_SH2E && SUPPORT_SH4_SINGLE_ONLY_OSFP))
+#else
+#define TARGET_OSFP (0)
+#endif
+
 #if SUPPORT_SH1
 #define SUPPORT_SH2 1
 #endif
@@ -256,19 +303,12 @@
   { "subtarget_link_emul_suffix", SUBTARGET_LINK_EMUL_SUFFIX },	\
   { "subtarget_link_spec", SUBTARGET_LINK_SPEC },		\
   { "subtarget_asm_endian_spec", SUBTARGET_ASM_ENDIAN_SPEC },	\
-  { "subtarget_asm_relax_spec", SUBTARGET_ASM_RELAX_SPEC },	\
   { "subtarget_asm_isa_spec", SUBTARGET_ASM_ISA_SPEC },		\
   { "subtarget_asm_spec", SUBTARGET_ASM_SPEC },			\
   SUBTARGET_EXTRA_SPECS
 
-#if TARGET_CPU_DEFAULT & MASK_HARD_SH4
-#define SUBTARGET_ASM_RELAX_SPEC "%{!m1:%{!m2:%{!m3*:%{!m5*:-isa=sh4-up}}}}"
-#else
-#define SUBTARGET_ASM_RELAX_SPEC "%{m4*:-isa=sh4-up}"
-#endif
-
 #define SH_ASM_SPEC \
- "%(subtarget_asm_endian_spec) %{mrelax:-relax %(subtarget_asm_relax_spec)} \
+"%(subtarget_asm_endian_spec) %{mrelax:-relax} \
 %(subtarget_asm_isa_spec) %(subtarget_asm_spec) \
 %{m2a:--isa=sh2a} \
 %{m2a-single:--isa=sh2a} \
@@ -277,7 +317,8 @@
 %{m5-compact*:--isa=SHcompact} \
 %{m5-32media*:--isa=SHmedia --abi=32} \
 %{m5-64media*:--isa=SHmedia --abi=64} \
-%{m4al:-dsp} %{mcut2-workaround:-cut2-workaround}"
+%{m4al:-dsp} %{mcut2-workaround:-cut2-workaround} \
+%{mtas:--tas}"
 
 #define ASM_SPEC SH_ASM_SPEC
 
@@ -293,14 +334,18 @@
 /* Strict nofpu means that the compiler should tell the assembler
    to reject FPU instructions. E.g. from ASM inserts.  */
 #if TARGET_CPU_DEFAULT & MASK_HARD_SH4 && !(TARGET_CPU_DEFAULT & MASK_SH_E)
-#define SUBTARGET_ASM_ISA_SPEC "%{!m1:%{!m2:%{!m3*:%{m4-nofpu|!m4*:%{!m5:-isa=sh4-nofpu}}}}}"
+#define SUBTARGET_ASM_ISA_SPEC "%{!m1:%{!m2:%{!m3*:%{m4-nofpu|!m4*:%{!m5:--isa=sh4-nofpu}}}}}"
 #else
 /* If there were an -isa option for sh5-nofpu then it would also go here. */
 #define SUBTARGET_ASM_ISA_SPEC \
- "%{m4-nofpu:-isa=sh4-nofpu} " ASM_ISA_DEFAULT_SPEC
+ "%{m4-nofpu:--isa=sh4-nofpu} " ASM_ISA_DEFAULT_SPEC
 #endif
 #else /* ! STRICT_NOFPU */
-#define SUBTARGET_ASM_ISA_SPEC ASM_ISA_DEFAULT_SPEC
+#define SUBTARGET_ASM_ISA_SPEC "%{m4-nofpu:--isa=sh4-nofpu-up} \
+ %{m4|m4-single*:--isa=sh4-up} \
+ %{m4-300-nofpu:--isa=st40-300-nofpu} \
+ %{m4-300|m4-300-single|m4-300-single-only:--isa=st40-300}" \
+ ASM_ISA_DEFAULT_SPEC
 #endif
 
 #ifndef SUBTARGET_ASM_SPEC
@@ -328,8 +373,14 @@
 #define ASM_ISA_DEFAULT_SPEC \
 " %{!m1:%{!m2*:%{!m3*:%{!m4*:%{!m5*:" ASM_ISA_SPEC_DEFAULT "}}}}}"
 #else /* !MASK_SH5 */
-#define LINK_DEFAULT_CPU_EMUL ""
+#if TARGET_CPU_DEFAULT & MASK_SH4
+#define ASM_ISA_SPEC_DEFAULT "--isa=sh4-up"
+#define ASM_ISA_DEFAULT_SPEC \
+" %{!m1:%{!m2*:%{!m3*:%{!m4*:%{!m5*:" ASM_ISA_SPEC_DEFAULT "}}}}}"
+#else /* !MASK_SH4 */
 #define ASM_ISA_DEFAULT_SPEC ""
+#endif
+#define LINK_DEFAULT_CPU_EMUL ""
 #endif /* MASK_SH5 */
 
 #define SUBTARGET_LINK_EMUL_SUFFIX ""
@@ -344,6 +395,8 @@
 %{m5-64media*:64}\
 %{!m1:%{!m2:%{!m3*:%{!m4*:%{!m5*:%(link_default_cpu_emul)}}}}}\
 %(subtarget_link_emul_suffix) \
+%{mdb-page-bug:--db-page-bug} \
+%{shared:-shared} \
 %{mrelax:-relax} %(subtarget_link_spec)"
 
 #ifndef SH_DIV_STR_FOR_SIZE
@@ -391,6 +444,7 @@
   SH_DIV_CALL_DIV1, /* No FPU, medium size, highest latency.  */
   SH_DIV_CALL_FP,     /* FPU needed, small size, high latency.  */
   SH_DIV_CALL_TABLE,  /* No FPU, large size, medium latency. */
+  SH_DIV_CALL_PRE1,  /* Preheader to optimize return 1 cases. */
   SH_DIV_INTRINSIC
 };
 
@@ -504,6 +558,18 @@
    multiple of this.  */
 #define STRUCTURE_SIZE_BOUNDARY (TARGET_PADSTRUCT ? 32 : 8)
 
+/* Define this macro as an expression for the alignment of a structure
+   (given by STRUCT as a tree node) if the alignment computed in the
+   usual way is COMPUTED and the alignment explicitly specified was
+   SPECIFIED.
+*/
+#define ROUND_TYPE_ALIGN(STRUCT, COMPUTED, SPECIFIED)	\
+    ((TARGET_ALIGN_DOUBLE &&						       \
+      TREE_CODE (STRUCT) == RECORD_TYPE && TYPE_FIELDS (STRUCT) != 0 && \
+      TREE_INT_CST_LOW (TYPE_SIZE (STRUCT)) > 64)	\
+     ? MAX (MAX ((COMPUTED), (SPECIFIED)), 64)		\
+     : MAX ((COMPUTED), (SPECIFIED)))
+
 /* Set this nonzero if move instructions will actually fail to work
    when given unaligned data.  */
 #define STRICT_ALIGNMENT 1
@@ -512,8 +578,11 @@
 #define LABEL_ALIGN_AFTER_BARRIER(LABEL_AFTER_BARRIER) \
   barrier_align (LABEL_AFTER_BARRIER)
 
+
 #define LOOP_ALIGN(A_LABEL) sh_loop_align (A_LABEL)
 
+#define JUMP_ALIGN(LABEL) sh_jump_align (LABEL)
+
 #define LABEL_ALIGN(A_LABEL) \
 (									\
   (PREV_INSN (A_LABEL)							\
@@ -528,12 +597,10 @@
 #define ADDR_VEC_ALIGN(ADDR_VEC) 2
 
 /* The base two logarithm of the known minimum alignment of an insn length.  */
-#define INSN_LENGTH_ALIGNMENT(A_INSN)					\
-  (NONJUMP_INSN_P (A_INSN)						\
-   ? 1 << TARGET_SHMEDIA						\
-   : JUMP_P (A_INSN) || CALL_P (A_INSN)					\
-   ? 1 << TARGET_SHMEDIA						\
-   : CACHE_LOG)
+/* After a addr_diff_vec:HI the log align is 1.  Update it so the  next
+   insn_current_address can correctly be computed in final.  */
+#define INSN_LENGTH_ALIGNMENT(X) sh_insn_length_alignment (X)
+
 
 /* Standard register usage.  */
 
@@ -975,6 +1042,7 @@
 {
   NO_REGS,
   R0_REGS,
+  R0R3_REGS,
   PR_REGS,
   T_REGS,
   MAC_REGS,
@@ -984,7 +1052,6 @@
   GENERAL_REGS,
   FP0_REGS,
   FP_REGS,
-  DF_HI_REGS,
   DF_REGS,
   FPSCR_REGS,
   GENERAL_FP_REGS,
@@ -1001,6 +1068,7 @@
 {			\
   "NO_REGS",		\
   "R0_REGS",		\
+  "R0R3_REGS",		\
   "PR_REGS",		\
   "T_REGS",		\
   "MAC_REGS",		\
@@ -1010,7 +1078,6 @@
   "GENERAL_REGS",	\
   "FP0_REGS",		\
   "FP_REGS",		\
-  "DF_HI_REGS",		\
   "DF_REGS",		\
   "FPSCR_REGS",		\
   "GENERAL_FP_REGS",	\
@@ -1028,6 +1095,8 @@
   { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },	\
 /* R0_REGS:  */								\
   { 0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },	\
+/* R0R3_REGS:  */							\
+  { 0x0000000f, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },	\
 /* PR_REGS:  */								\
   { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00040000 },	\
 /* T_REGS:  */								\
@@ -1046,8 +1115,6 @@
   { 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000000 },	\
 /* FP_REGS:  */								\
   { 0x00000000, 0x00000000, 0xffffffff, 0xffffffff, 0x00000000 },	\
-/* DF_HI_REGS:  Initialized in TARGET_CONDITIONAL_REGISTER_USAGE.  */	\
-  { 0x00000000, 0x00000000, 0xffffffff, 0xffffffff, 0x0000ff00 },	\
 /* DF_REGS:  */								\
   { 0x00000000, 0x00000000, 0xffffffff, 0xffffffff, 0x0000ff00 },	\
 /* FPSCR_REGS:  */							\
@@ -1584,15 +1651,18 @@
 					  ? 0 : TARGET_SH1)
 
 #define MOVE_BY_PIECES_P(SIZE, ALIGN) \
-  (move_by_pieces_ninsns (SIZE, ALIGN, MOVE_MAX_PIECES + 1) \
-   < (optimize_size ? 2 : ((ALIGN >= 32) ? 16 : 2)))
+     ((TARGET_ALIGN_DOUBLE) ? ((SIZE)*8 <= 64 || ALIGN != 64)	\
+      : (move_by_pieces_ninsns ((SIZE), ALIGN, MOVE_MAX_PIECES + 1)	\
+	 <= (optimize_size ? 2 : ((ALIGN >= 32) ? 16 : 4))))
 
 #define STORE_BY_PIECES_P(SIZE, ALIGN) \
   (move_by_pieces_ninsns (SIZE, ALIGN, STORE_MAX_PIECES + 1) \
-   < (optimize_size ? 2 : ((ALIGN >= 32) ? 16 : 2)))
+   <= (optimize_size ? 2 : ((ALIGN >= 32) ? 16 : 4)))
 
 #define SET_BY_PIECES_P(SIZE, ALIGN) STORE_BY_PIECES_P(SIZE, ALIGN)
 
+#define CLEAR_RATIO(speed) ((speed) ? 15 :3)
+
 /* Macros to check register numbers against specific register classes.  */
 
 /* These assume that REGNO is a hard or pseudo reg number.
@@ -1757,7 +1827,8 @@
 #define CASE_VECTOR_MODE ((! optimize || TARGET_BIGTABLE) ? SImode : HImode)
 
 #define CASE_VECTOR_SHORTEN_MODE(MIN_OFFSET, MAX_OFFSET, BODY) \
-((MIN_OFFSET) >= 0 && (MAX_OFFSET) <= 127 \
+(mdep_reorg_phase <= SH_FIXUP_PCLOAD ? SImode               \
+ : (MIN_OFFSET) >= 0 && (MAX_OFFSET) <= 127		    \
  ? (ADDR_DIFF_VEC_FLAGS (BODY).offset_unsigned = 0, QImode) \
  : (MIN_OFFSET) >= 0 && (MAX_OFFSET) <= 255 \
  ? (ADDR_DIFF_VEC_FLAGS (BODY).offset_unsigned = 1, QImode) \
@@ -1802,7 +1873,7 @@
 
 /* Max number of bytes we want move_by_pieces to be able to copy
    efficiently.  */
-#define MOVE_MAX_PIECES (TARGET_SH4 || TARGET_SHMEDIA ? 8 : 4)
+#define MOVE_MAX_PIECES (TARGET_SH1 || TARGET_SH5 ? 8 : 4)
 
 /* Define if operations between registers always perform the operation
    on the full register even if a narrower mode is specified.  */
@@ -1922,7 +1993,7 @@
 
 #define REGCLASS_HAS_FP_REG(CLASS) \
   ((CLASS) == FP0_REGS || (CLASS) == FP_REGS \
-   || (CLASS) == DF_REGS || (CLASS) == DF_HI_REGS)
+   || (CLASS) == DF_REGS)
 
 /* ??? Perhaps make MEMORY_MOVE_COST depend on compiler option?  This
    would be so that people with slow memory systems could generate
@@ -2087,9 +2158,13 @@
   if ((LOG) != 0)			\
     fprintf ((FILE), "\t.align %d\n", (LOG))
 
+#define ASM_ALIGN_FUNCTION_LOG(DECL) sh_align_function_log(DECL)
+
 /* Globalizing directive for a label.  */
 #define GLOBAL_ASM_OP "\t.global\t"
 
+#define TARGET_ASM_COUNT(TEMP, ALIGNP) sh_asm_count (TEMP, ALIGNP)
+
 /* #define ASM_OUTPUT_CASE_END(STREAM,NUM,TABLE)  */
 
 /* Output a relative address table.  */
@@ -2199,7 +2274,8 @@
    extra two bytes for the nop in the delay slot.
    sh-dsp parallel processing insns are four bytes long.  */
 #define ADJUST_INSN_LENGTH(X, LENGTH)				\
-  (LENGTH) += sh_insn_length_adjustment (X);
+  (LENGTH) += sh_insn_length_adjustment (X, LENGTH);
+
 
 /* Define this macro if it is advisable to hold scalars in registers
    in a wider mode than that declared by the program.  In such cases,
@@ -2258,11 +2334,16 @@
 #define MODE_PRIORITY_TO_MODE(ENTITY, N) \
   ((TARGET_FPU_SINGLE != 0) ^ (N) ? FP_MODE_SINGLE : FP_MODE_DOUBLE)
 
-#define EMIT_MODE_SET(ENTITY, MODE, HARD_REGS_LIVE) \
-  fpscr_set_from_mem ((MODE), (HARD_REGS_LIVE))
+#define EMIT_MODE_SET(ENTITY, MODE, FLIP, HARD_REGS_LIVE) \
+  ((TARGET_SH4A_FP || TARGET_SH4_300)                     \
+   && (FLIP) ? emit_fpu_flip ()                           \
+   : fpscr_set_from_mem ((MODE), (HARD_REGS_LIVE)))
 
+/* Too conservative, if distances are not computed get_attr_length is too
+   much conservative. better let it go and split_branches afterwards.
 #define MD_CAN_REDIRECT_BRANCH(INSN, SEQ) \
   sh_can_redirect_branch ((INSN), (SEQ))
+ */
 
 #define DWARF_FRAME_RETURN_COLUMN \
   (TARGET_SH5 ? DWARF_FRAME_REGNUM (PR_MEDIA_REG) : DWARF_FRAME_REGNUM (PR_REG))
@@ -2307,4 +2388,7 @@
 2:\n" TEXT_SECTION_ASM_OP);
 #endif /* (defined CRT_BEGIN || defined CRT_END) && ! __SHMEDIA__ */
 
+#define TARGET_USES_LEB128 \
+  (! TARGET_RELAX || (!flag_unwind_tables && !flag_exceptions))
+
 #endif /* ! GCC_SH_H */
diff -ruN gcc-gnu-4.8.2/gcc/config/sh/sh.md gcc-st40-4.8.2.140205/gcc/config/sh/sh.md
--- gcc-gnu-4.8.2/gcc/config/sh/sh.md	2013-10-16 16:17:23.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/config/sh/sh.md	2014-01-29 12:57:17.000000000 +0100
@@ -2,6 +2,7 @@
 ;;  Copyright (C) 1993-2013 Free Software Foundation, Inc.
 ;;  Contributed by Steve Chamberlain (sac@cygnus.com).
 ;;  Improved by Jim Wilson (wilson@cygnus.com).
+;;  Copyright (c) 2009  STMicroelectronics.
 
 ;; This file is part of GCC.
 
@@ -31,9 +32,6 @@
 ;; ??? The MAC.W and MAC.L instructions are not supported.  There is no
 ;; way to generate them.
 
-;; ??? The cmp/str instruction is not supported.  Perhaps it can be used
-;; for a str* inline function.
-
 ;; BSR is not generated by the compiler proper, but when relaxing, it
 ;; generates .uses pseudo-ops that allow linker relaxation to create
 ;; BSR.  This is actually implemented in bfd/{coff,elf32}-sh.c
@@ -45,6 +43,8 @@
 ;;    l -- pr
 ;;    z -- r0
 ;;
+;;    R03 -- r0, r1, r2 or r3  - experimental constraint for SH4-300
+;;
 ;; Special formats used for outputting SH instructions:
 ;;
 ;;   %.  --  print a .s if insn needs delay slot
@@ -105,6 +105,7 @@
   (DR0_REG	64)
   (DR2_REG	66)
   (DR4_REG	68)
+  (FR4_REG	68)
   (FR23_REG	87)
 
   (TR0_REG	128)
@@ -148,7 +149,6 @@
   (UNSPEC_DIV_INV_TABLE	37)
   (UNSPEC_ASHIFTRT	35)
   (UNSPEC_THUNK		36)
-  (UNSPEC_CHKADD	38)
   (UNSPEC_SP_SET	40)
   (UNSPEC_SP_TEST	41)
   (UNSPEC_MOVUA		42)
@@ -164,6 +164,10 @@
   ;; (unspec [OFFSET ANCHOR] UNSPEC_PCREL_SYMOFF) == OFFSET - (ANCHOR - .).
   (UNSPEC_PCREL_SYMOFF	46)
 
+  ;; Misc builtins
+  (UNSPEC_BUILTIN_STRLEN 47)
+  (UNSPEC_BUILTIN_ROUND	48)
+
   ;; These are used with unspec_volatile.
   (UNSPECV_BLOCKAGE	0)
   (UNSPECV_ALIGN	1)
@@ -176,6 +180,17 @@
   (UNSPECV_GBR		13)
   (UNSPECV_SP_SWITCH_B  14)
   (UNSPECV_SP_SWITCH_E  15)
+  (UNSPECV_DB_INSN	16)
+
+  ;; NaN handling for software floating point:
+  ;; We require one bit specific for a precision to be set in all NaNs,
+  ;; so that we can test them with a not / tst sequence.
+  ;; ??? Ironically, this is the quiet bit for now, because that is the
+  ;; only bit set by __builtin_nan ("").
+  ;; ??? Should really use one bit lower and force it set by using
+  ;; a custom encoding function.
+  (SF_NAN_MASK		0x7fc00000)
+  (DF_NAN_MASK		0x7ff80000)
 ])
 
 ;; -------------------------------------------------------------------------
@@ -352,69 +367,6 @@
 ;; If we have a forward branch, the initial table will be put after the
 ;; unconditional branch.
 ;;
-;; ??? We could do much better by keeping track of the actual pcloads within
-;; the branch range and in the pcload range in front of the branch range.
-
-;; ??? This looks ugly because genattrtab won't allow if_then_else or cond
-;; inside an le.
-(define_attr "short_cbranch_p" "no,yes"
-  (cond [(match_test "mdep_reorg_phase <= SH_FIXUP_PCLOAD")
-	 (const_string "no")
-	 (leu (plus (minus (match_dup 0) (pc)) (const_int 252)) (const_int 506))
-	 (const_string "yes")
-	 (match_test "NEXT_INSN (PREV_INSN (insn)) != insn")
-	 (const_string "no")
-	 (leu (plus (minus (match_dup 0) (pc)) (const_int 252)) (const_int 508))
-	 (const_string "yes")
-	 ] (const_string "no")))
-
-(define_attr "med_branch_p" "no,yes"
-  (cond [(leu (plus (minus (match_dup 0) (pc)) (const_int 990))
-	      (const_int 1988))
-	 (const_string "yes")
-	 (match_test "mdep_reorg_phase <= SH_FIXUP_PCLOAD")
-	 (const_string "no")
-	 (leu (plus (minus (match_dup 0) (pc)) (const_int 4092))
-	      (const_int 8186))
-	 (const_string "yes")
-	 ] (const_string "no")))
-
-(define_attr "med_cbranch_p" "no,yes"
-  (cond [(leu (plus (minus (match_dup 0) (pc)) (const_int 988))
-	      (const_int 1986))
-	 (const_string "yes")
-	 (match_test "mdep_reorg_phase <= SH_FIXUP_PCLOAD")
-	 (const_string "no")
-	 (leu (plus (minus (match_dup 0) (pc)) (const_int 4090))
-	       (const_int 8184))
-	 (const_string "yes")
-	 ] (const_string "no")))
-
-(define_attr "braf_branch_p" "no,yes"
-  (cond [(match_test "! TARGET_SH2")
-	 (const_string "no")
-	 (leu (plus (minus (match_dup 0) (pc)) (const_int 10330))
-	      (const_int 20660))
-	 (const_string "yes")
-	 (match_test "mdep_reorg_phase <= SH_FIXUP_PCLOAD")
-	 (const_string "no")
-	 (leu (plus (minus (match_dup 0) (pc)) (const_int 32764))
-	      (const_int 65530))
-	 (const_string "yes")
-	 ] (const_string "no")))
-
-(define_attr "braf_cbranch_p" "no,yes"
-  (cond [(match_test "! TARGET_SH2")
-	 (const_string "no")
-	 (leu (plus (minus (match_dup 0) (pc)) (const_int 10328))
-	      (const_int 20658))
-	 (const_string "yes")
-	 (match_test "mdep_reorg_phase <= SH_FIXUP_PCLOAD")
-	 (const_string "no")
-	 (leu (plus (minus (match_dup 0) (pc)) (const_int 32762))
-	      (const_int 65528))
-	 (const_string "yes")
-	 ] (const_string "no")))
 
 ;; An unconditional jump in the range -4092..4098 can be 2 bytes long.
 ;; For wider ranges, we need a combination of a code and a data part.
@@ -425,43 +377,43 @@
 
 ;; All other instructions are two bytes long by default.
 
-;; ??? This should use something like *branch_p (minus (match_dup 0) (pc)),
-;; but getattrtab doesn't understand this.
 (define_attr "length" ""
   (cond [(eq_attr "type" "cbranch")
-	 (cond [(eq_attr "short_cbranch_p" "yes")
+	 (cond [(match_test "short_cbranch_p (insn)")
 		(const_int 2)
-		(eq_attr "med_cbranch_p" "yes")
+		(match_test "med_cbranch_p (insn)")
 		(const_int 6)
-		(eq_attr "braf_cbranch_p" "yes")
+		(match_test "braf_cbranch_p (insn)")
 		(const_int 12)
 ;; ??? using pc is not computed transitively.
 		(ne (match_dup 0) (match_dup 0))
-		(const_int 14)
-		(match_test "flag_pic")
-		(const_int 24)
+		(const_int 2)
+;; ??? is it necessary use pcrel braf instead of jmp. why ?
+;;		(match_test "flag_pic")
+;;		(const_int 24)
 		] (const_int 16))
 	 (eq_attr "type" "jump")
-	 (cond [(eq_attr "med_branch_p" "yes")
+	 (cond [(match_test "med_branch_p (insn)")
 		(const_int 2)
 		(and (match_test "prev_nonnote_insn (insn)")
-		     (and (eq (symbol_ref "GET_CODE (prev_nonnote_insn (insn))")
-			      (symbol_ref "INSN"))
-			  (eq (symbol_ref "INSN_CODE (prev_nonnote_insn (insn))")
-			      (symbol_ref "code_for_indirect_jump_scratch"))))
-		(cond [(eq_attr "braf_branch_p" "yes")
-		       (const_int 6)
-		       (not (match_test "flag_pic"))
-		       (const_int 10)
-		       (match_test "TARGET_SH2")
-		       (const_int 10)] (const_int 18))
-		(eq_attr "braf_branch_p" "yes")
+		     (and (eq (symbol_ref "GET_CODE (prev_nonnote_insn (insn))") (symbol_ref "INSN"))
+			  (eq (symbol_ref "INSN_CODE (prev_nonnote_insn (insn))") (symbol_ref "code_for_indirect_jump_scratch"))))
+                (cond [(match_test "braf_branch_p (insn)")
+                       (const_int 6)
+		       (and (match_test "flag_pic")
+			    (match_test "! TARGET_SH2"))
+                       (const_int 18)
+;; not braf_branch_p but reg to use.
+		       ] (const_int 10))
+		(match_test "braf_branch_p (insn)")
 		(const_int 10)
 ;; ??? using pc is not computed transitively.
 		(ne (match_dup 0) (match_dup 0))
-		(const_int 12)
-		(match_test "flag_pic")
-		(const_int 22)
+		(const_int 2)
+;; ??? is it necessary use pcrel braf instead of jmp. why ?
+;;		(match_test "flag_pic")
+;;		(const_int 22)
+;; not braf_branch_p and no reg to use.
 		] (const_int 14))
 	 (eq_attr "type" "pt_media")
 	 (if_then_else (match_test "TARGET_SHMEDIA64")
@@ -785,6 +737,14 @@
 	cmp/eq	%1,%0"
    [(set_attr "type" "mt_group")])
 
+(define_insn "fpcmp_i1"
+  [(set (reg:SI T_REG)
+	(match_operator:SI 1 "soft_fp_comparison_operator"
+	  [(match_operand 0 "soft_fp_comparison_operand" "r") (const_int 0)]))]
+  "TARGET_SH1_SOFTFP"
+  "tst	%0,%0"
+   [(set_attr "type" "mt_group")])
+
 ;; FIXME: For some reason, on SH4A and SH2A combine fails to simplify this
 ;; pattern by itself.  What this actually does is:
 ;;	x == 0: (1 >> 0-0) & 1 = 1
@@ -1721,6 +1681,45 @@
     }
 })
 
+;; Combiner can transform add sequences into
+;;  r1 = r0 + x
+;;  r2 = r1 + x
+;;  r3 = r2 + x
+;;  r4 = r3 + x
+;;  =>
+;;  r2 = r0 + 2x
+;;  r4 = r2 + 2x
+;;  =>
+;;  r4 = r0 + 4x
+
+(define_insn_and_split "*muladdsi3"
+  [(set (match_operand:SI 0 "arith_reg_dest")
+        (plus:SI (plus:SI (mult:SI (match_operand:SI 1 "arith_reg_operand")
+				   (match_operand:SI 2 "const_int_operand"))
+			  (match_operand:SI 3 "arith_reg_operand"))
+		 (match_dup 1)))]
+   "TARGET_DYNSHIFT
+     && (REGNO (operands[0]) != REGNO (operands[1]))
+     && (REGNO (operands[0]) != REGNO (operands[3]))"
+  "#"
+  "&& 1"
+  [(set (match_dup 0) (plus:SI (match_dup 0) (match_dup 3)))]
+{
+   int n = INTVAL (operands[2]);
+   int l = exact_log2 (n);
+
+   if (l != -1) {
+      emit_move_insn (operands[0], operands[1]);
+      emit_insn (gen_ashlsi3 (operands[0], operands[0], GEN_INT (l)));
+      emit_insn (gen_addsi3 (operands[0], operands[0], operands[1]));
+   }
+   else {
+      emit_move_insn (operands[0], GEN_INT (n+1));
+      emit_insn (gen_mulsi3 (operands[0], operands[0], operands[1]));
+   }
+}
+  [(set_attr "type" "arith")])
+
 (define_insn "*adddi3_media"
   [(set (match_operand:DI 0 "arith_reg_dest" "=r,r")
 	(plus:DI (match_operand:DI 1 "arith_reg_operand" "%r,r")
@@ -2538,6 +2537,7 @@
   ""
 {
   rtx last;
+  rtx lab2 = NULL_RTX;
 
   operands[3] = gen_reg_rtx (Pmode);
   /* Emit the move of the address to a pseudo outside of the libcall.  */
@@ -2676,9 +2676,44 @@
       function_symbol (operands[3], sh_divsi3_libfunc, SFUNC_GOT);
       last = gen_divsi3_i1 (operands[0], operands[3]);
     }
+
+   if (TARGET_DIVIDE_CALL_PRE1)
+   {
+      rtx tmp = gen_reg_rtx (SImode);
+      rtx lab = gen_label_rtx ();
+      rtx jump;
+
+      lab2 = gen_label_rtx ();
+
+      operands[1] = force_reg (SImode, operands[1]);
+      operands[2] = force_reg (SImode, operands[2]);
+
+      emit_move_insn (tmp, operands[1]);
+      emit_insn (gen_iorsi3 (tmp, tmp, operands[2]));
+      emit_insn (gen_ashlsi3_k (tmp, tmp, GEN_INT (1)));
+      emit_jump_insn (gen_branch_true (lab));
+      emit_move_insn (tmp, operands[1]);
+      emit_insn (gen_subc (tmp, tmp, operands[2]));
+
+      emit_jump_insn (gen_branch_true (lab));
+
+      emit_insn (gen_subc (tmp, tmp, operands[2]));
+      emit_jump_insn (gen_branch_false (lab));
+
+      emit_move_insn (operands[0], GEN_INT (1));
+      jump = emit_jump_insn (gen_jump_compact (lab2));
+      emit_barrier_after (jump);
+
+      emit_label (lab);
+    }
+
   emit_move_insn (gen_rtx_REG (SImode, 4), operands[1]);
   emit_move_insn (gen_rtx_REG (SImode, 5), operands[2]);
   emit_insn (last);
+
+  if (TARGET_DIVIDE_CALL_PRE1)
+    emit_label (lab2);
+
   DONE;
 })
 
@@ -3253,6 +3288,16 @@
   "mul.l	%1,%0"
   [(set_attr "type" "dmpy")])
 
+(define_insn "mulr03"
+  [(set (match_operand:SI 0 "arith_reg_operand" "=r")
+	(mult:SI (match_operand:SI 1 "arith_reg_operand" "%0")
+		 (match_operand:SI 2 "arith_reg_operand" "R03")))]
+  "TARGET_R0R3_TO_REG_MUL - !reload_completed >= 1"
+  "mulr	%2,%0"
+  [(set_attr "type" "dmpy")])
+
+;; ??? should we also use mulr if we'd need two reg-reg copies?
+
 (define_expand "mulsi3"
   [(set (reg:SI MACL_REG)
 	(mult:SI  (match_operand:SI 1 "arith_reg_operand" "")
@@ -3993,7 +4038,7 @@
   DONE;
 })
 
-(define_insn "*rotlhi3_8"
+(define_insn "rotlhi3_8"
   [(set (match_operand:HI 0 "arith_reg_dest" "=r")
 	(rotate:HI (match_operand:HI 1 "arith_reg_operand" "r")
 		   (const_int 8)))]
@@ -6447,7 +6492,10 @@
    && ! TARGET_SH2E
    && ! TARGET_SH2A
    && (register_operand (operands[0], SImode)
-       || register_operand (operands[1], SImode))"
+       || register_operand (operands[1], SImode))
+   && (!flag_stack_protect || TARGET_SHMEDIA
+       || reload_completed || reload_in_progress || !virtuals_instantiated
+       || !stack_protector_block (insn, operands[1]))"
   "@
 	mov.l	%1,%0
 	mov	%1,%0
@@ -6480,7 +6528,10 @@
 	 "Q,r,I08,I20,I28,mr,x,l,r,x,l,r,r,>,>,>,y,i,r,y,y,*f,*f,y"))]
   "(TARGET_SH2E || TARGET_SH2A)
    && (register_operand (operands[0], SImode)
-       || register_operand (operands[1], SImode))"
+       || register_operand (operands[1], SImode))
+   && (!flag_stack_protect || TARGET_SHMEDIA
+       || reload_completed || reload_in_progress || !virtuals_instantiated
+       || !stack_protector_block (insn, operands[1]))"
   "@
 	mov.l	%1,%0
 	mov	%1,%0
@@ -6831,34 +6882,6 @@
   prepare_move_operands (operands, QImode);
 })
 
-;; If movqi_reg_reg is specified as an alternative of movqi, movqi will be
-;; selected to copy QImode regs.  If one of them happens to be allocated
-;; on the stack, reload will stick to movqi insn and generate wrong
-;; displacement addressing because of the generic m alternatives.
-;; With the movqi_reg_reg being specified before movqi it will be initially
-;; picked to load/store regs.  If the regs regs are on the stack reload
-;; try other insns and not stick to movqi_reg_reg, unless there were spilled
-;; pseudos in which case 'm' constraints pertain.
-;; The same applies to the movhi variants.
-;;
-;; Notice, that T bit is not allowed as a mov src operand here.  This is to
-;; avoid things like (set (reg:QI) (subreg:QI (reg:SI T_REG) 0)), which
-;; introduces zero extensions after T bit stores and redundant reg copies.
-;;
-;; FIXME: We can't use 'arith_reg_operand' (which disallows T_REG) as a
-;; predicate for the mov src operand because reload will have trouble
-;; reloading MAC subregs otherwise.  For that probably special patterns
-;; would be required.
-(define_insn "*mov<mode>_reg_reg"
-  [(set (match_operand:QIHI 0 "arith_reg_dest" "=r,m,*z")
-	(match_operand:QIHI 1 "register_operand" "r,*z,m"))]
-  "TARGET_SH1 && !t_reg_operand (operands[1], VOIDmode)"
-  "@
-    mov		%1,%0
-    mov.<bw>	%1,%0
-    mov.<bw>	%1,%0"
-  [(set_attr "type" "move,store,load")])
-
 ;; FIXME: The non-SH2A and SH2A variants should be combined by adding
 ;; "enabled" attribute as it is done in other targets.
 (define_insn "*mov<mode>_store_mem_disp04"
@@ -6908,38 +6931,44 @@
   [(set_attr "type" "load")
    (set_attr "length" "2,2,4")])
 
-;; The m constraints basically allow any kind of addresses to be used with any
-;; source/target register as the other operand.  This is not true for 
-;; displacement addressing modes on anything but SH2A.  That's why the
-;; specialized load/store insns are specified above.
-(define_insn "*movqi"
-  [(set (match_operand:QI 0 "general_movdst_operand" "=r,r,m,r,l")
-	(match_operand:QI 1 "general_movsrc_operand"  "i,m,r,l,r"))]
+;; The order of the constraint alternatives is important here.
+;; Q/r has to come first, otherwise PC relative loads might wrongly get
+;; placed into delay slots.  Since there is no QImode PC relative load, the
+;; Q constraint and general_movsrc_operand will reject it for QImode.
+;; The Snd alternatives should come before Sdd in order to avoid a preference
+;; of using r0 als the register operand for addressing modes other than
+;; displacement addressing.
+;; The Sdd alternatives allow only r0 as register operand, even though on
+;; SH2A any register could be allowed by switching to a 32 bit insn.
+;; Generally sticking to the r0 is preferrable, since it generates smaller
+;; code.  Obvious r0 reloads can then be eliminated with a peephole on SH2A.
+(define_insn "*mov<mode>"
+  [(set (match_operand:QIHI 0 "general_movdst_operand"
+			      "=r,r,r,Snd,r,  Sdd,z,  r,l")
+	(match_operand:QIHI 1 "general_movsrc_operand"
+			       "Q,r,i,r,  Snd,z,  Sdd,l,r"))]
   "TARGET_SH1
-   && (arith_reg_operand (operands[0], QImode)
-       || arith_reg_operand (operands[1], QImode))"
+   && (arith_reg_operand (operands[0], <MODE>mode)
+       || arith_reg_operand (operands[1], <MODE>mode))"
   "@
+	mov.<bw>	%1,%0
 	mov	%1,%0
-	mov.b	%1,%0
-	mov.b	%1,%0
-	sts	%1,%0
-	lds	%1,%0"
- [(set_attr "type" "movi8,load,store,prget,prset")])
-
-(define_insn "*movhi"
-  [(set (match_operand:HI 0 "general_movdst_operand" "=r,r,r,m,r,l")
-	(match_operand:HI 1 "general_movsrc_operand"  "Q,i,m,r,l,r"))]
-  "TARGET_SH1
-   && (arith_reg_operand (operands[0], HImode)
-       || arith_reg_operand (operands[1], HImode))"
-  "@
-	mov.w	%1,%0
 	mov	%1,%0
-	mov.w	%1,%0
-	mov.w	%1,%0
+	mov.<bw>	%1,%0
+	mov.<bw>	%1,%0
+	mov.<bw>	%1,%0
+	mov.<bw>	%1,%0
 	sts	%1,%0
 	lds	%1,%0"
- [(set_attr "type" "pcload,movi8,load,store,prget,prset")])
+  [(set_attr "type" "pcload,move,movi8,store,load,store,load,prget,prset")
+   (set (attr "length")
+	(cond [(and (match_operand 0 "displacement_mem_operand")
+		    (not (match_operand 0 "short_displacement_mem_operand")))
+	       (const_int 4)
+	       (and (match_operand 1 "displacement_mem_operand")
+		    (not (match_operand 1 "short_displacement_mem_operand")))
+	       (const_int 4)]
+	      (const_int 2)))])
 
 (define_insn "*movqi_media"
   [(set (match_operand:QI 0 "general_movdst_operand" "=r,r,r,m")
@@ -8153,21 +8182,15 @@
 ;; when the destination changes mode.
 (define_insn "movsf_ie"
   [(set (match_operand:SF 0 "general_movdst_operand"
-	 "=f,r,f,f,fy,f,m,r,r,m,f,y,y,rf,r,y,<,y,y")
+	 "=f,r,f,f,f,f ,m,r ,r ,m,f,y,y,rf,r,y,<,y,y")
 	(match_operand:SF 1 "general_movsrc_operand"
 	  "f,r,G,H,FQ,mf,f,FQ,mr,r,y,f,>,fr,y,r,y,>,y"))
    (use (match_operand:PSI 2 "fpscr_operand" "c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c"))
    (clobber (match_scratch:SI 3 "=X,X,Bsc,Bsc,&z,X,X,X,X,X,X,X,X,y,X,X,X,X,X"))]
   "TARGET_SH2E
-   && (arith_reg_operand (operands[0], SFmode)
-       || arith_reg_operand (operands[1], SFmode)
-       || arith_reg_operand (operands[3], SImode)
-       || (fpul_operand (operands[0], SFmode)
-	   && memory_operand (operands[1], SFmode)
-	   && GET_CODE (XEXP (operands[1], 0)) == POST_INC)
-       || (fpul_operand (operands[1], SFmode)
-	   && memory_operand (operands[0], SFmode)
-	   && GET_CODE (XEXP (operands[0], 0)) == PRE_DEC))"
+   && (arith_reg_operand (operands[0], SFmode) || fpul_operand (operands[0], SFmode)
+       || arith_reg_operand (operands[1], SFmode) || fpul_operand (operands[1], SFmode)
+       || arith_reg_operand (operands[3], SImode))"
   "@
 	fmov	%1,%0
 	mov	%1,%0
@@ -8219,9 +8242,26 @@
       (const_int 2)
       (const_int 2)
       (const_int 0)])
-   (set (attr "fp_mode") (if_then_else (eq_attr "fmovd" "yes")
+  (set_attr_alternative "fp_mode"
+     [(if_then_else (eq_attr "fmovd" "yes") (const_string "single") (const_string "none"))
+      (const_string "none")
+      (const_string "single")
 					   (const_string "single")
-					   (const_string "single")))])
+      (const_string "none")
+      (if_then_else (eq_attr "fmovd" "yes") (const_string "single") (const_string "none"))
+      (if_then_else (eq_attr "fmovd" "yes") (const_string "single") (const_string "none"))
+      (const_string "none")
+      (const_string "none")
+      (const_string "none")
+      (const_string "none")
+      (const_string "none")
+      (const_string "none")
+      (const_string "none")
+      (const_string "none")
+      (const_string "none")
+      (const_string "none")
+      (const_string "none")
+      (const_string "none")])])
 
 (define_split
   [(set (match_operand:SF 0 "register_operand" "")
@@ -8380,7 +8420,7 @@
 {
   return output_branch (sh_eval_treg_value (operands[1]), insn, operands);
 }
-  "&& 1"
+  "&& 0"
   [(set (pc) (if_then_else (eq (reg:SI T_REG) (match_dup 2))
 			   (label_ref (match_dup 0))
 			   (pc)))]
@@ -8454,7 +8494,8 @@
 	   T bit.  Notice that some T bit stores such as negc also modify
 	   the T bit.  */
 	if (modified_between_p (get_t_reg_rtx (), s1.insn, testing_insn)
-	    || modified_in_p (get_t_reg_rtx (), s1.insn))
+	    || modified_in_p (get_t_reg_rtx (), s1.insn)
+	    || !no_labels_between_p (s1.insn, testing_insn))
 	  operands[2] = NULL_RTX;
 
 	break;
@@ -9945,6 +9986,14 @@
 
   DONE;
 })
+
+(define_insn "dup_db_insn"
+  [(unspec_volatile [(const_int 0)] UNSPECV_DB_INSN)]
+  "TARGET_DEAD_DELAY"
+  ""
+  [(set_attr "length" "0")
+   (set_attr "in_delay_slot" "yes")])
+
 
 ;; ------------------------------------------------------------------------
 ;; Misc insns
@@ -10094,21 +10143,6 @@
   i++;
 })
 
-;; op0 = op1 + r12 but hide it before reload completed.  See the comment
-;; in symGOT_load expand.
-(define_insn_and_split "chk_guard_add"
-  [(set (match_operand:SI 0 "register_operand" "=&r")
-	(unspec:SI [(match_operand:SI 1 "register_operand" "r")
-		    (reg:SI PIC_REG)]
-		   UNSPEC_CHKADD))]
-  "TARGET_SH1"
-  "#"
-  "TARGET_SH1 && reload_completed"
-  [(set (match_dup 0) (reg:SI PIC_REG))
-   (set (match_dup 0) (plus:SI (match_dup 0) (match_dup 1)))]
-  ""
-  [(set_attr "type" "arith")])
-
 (define_expand "sym_label2reg"
   [(set (match_operand:SI 0 "" "")
 	(const:SI (unspec:SI [(match_operand:SI 1 "" "")
@@ -10150,20 +10184,6 @@
   else
     emit_move_insn (operands[2], operands[1]);
 
-  /* When stack protector inserts codes after the result is set to
-     R0, @(rX, r12) will cause a spill failure for R0.  Use a unspec
-     insn to avoid combining (set A (plus rX r12)) and (set op0 (mem A))
-     when rX is a GOT address for the guard symbol.  Ugly but doesn't
-     matter because this is a rare situation.  */
-  if (!TARGET_SHMEDIA
-      && flag_stack_protect
-      && GET_CODE (operands[1]) == CONST
-      && GET_CODE (XEXP (operands[1], 0)) == UNSPEC
-      && GET_CODE (XVECEXP (XEXP (operands[1], 0), 0, 0)) == SYMBOL_REF
-      && strcmp (XSTR (XVECEXP (XEXP (operands[1], 0), 0, 0), 0),
-		 "__stack_chk_guard") == 0)
-    emit_insn (gen_chk_guard_add (operands[3], operands[2]));
-  else
     emit_move_insn (operands[3], gen_rtx_PLUS (Pmode, operands[2],
 					       gen_rtx_REG (Pmode, PIC_REG)));
 
@@ -10679,8 +10699,8 @@
 ;; So we keep the use of r0 hidden in a R0_REGS clobber until after reload.
 (define_insn "casesi_worker_0"
   [(set (match_operand:SI 0 "register_operand" "=r,r")
-	(unspec:SI [(match_operand:SI 1 "register_operand" "0,r")
-		 (label_ref (match_operand 2 "" ""))] UNSPEC_CASESI))
+	(mem:SI (unspec:SI [(match_operand:SI 1 "register_operand" "0,r")
+		 (label_ref (match_operand 2 "" ""))] UNSPEC_CASESI)))
    (clobber (match_scratch:SI 3 "=X,1"))
    (clobber (match_scratch:SI 4 "=&z,z"))]
   "TARGET_SH1"
@@ -10688,15 +10708,15 @@
 
 (define_split
   [(set (match_operand:SI 0 "register_operand" "")
-	(unspec:SI [(match_operand:SI 1 "register_operand" "")
-		    (label_ref (match_operand 2 "" ""))] UNSPEC_CASESI))
+	(mem:SI (unspec:SI [(match_operand:SI 1 "register_operand" "")
+		    (label_ref (match_operand 2 "" ""))] UNSPEC_CASESI)))
    (clobber (match_scratch:SI 3 ""))
    (clobber (match_scratch:SI 4 ""))]
   "TARGET_SH1 && ! TARGET_SH2 && reload_completed"
   [(set (reg:SI R0_REG) (unspec:SI [(label_ref (match_dup 2))] UNSPEC_MOVA))
    (parallel [(set (match_dup 0)
-	      (unspec:SI [(reg:SI R0_REG) (match_dup 1)
-			  (label_ref (match_dup 2))] UNSPEC_CASESI))
+	      (mem:SI (unspec:SI [(reg:SI R0_REG) (match_dup 1)
+			  (label_ref (match_dup 2))] UNSPEC_CASESI)))
 	      (clobber (match_dup 3))])
    (set (match_dup 0) (plus:SI (match_dup 0) (reg:SI R0_REG)))]
 {
@@ -10706,15 +10726,15 @@
 
 (define_split
   [(set (match_operand:SI 0 "register_operand" "")
-	(unspec:SI [(match_operand:SI 1 "register_operand" "")
-		    (label_ref (match_operand 2 "" ""))] UNSPEC_CASESI))
+	(mem:SI (unspec:SI [(match_operand:SI 1 "register_operand" "")
+		    (label_ref (match_operand 2 "" ""))] UNSPEC_CASESI)))
    (clobber (match_scratch:SI 3 ""))
    (clobber (match_scratch:SI 4 ""))]
   "TARGET_SH2 && reload_completed"
   [(set (reg:SI R0_REG) (unspec:SI [(label_ref (match_dup 2))] UNSPEC_MOVA))
    (parallel [(set (match_dup 0)
-	      (unspec:SI [(reg:SI R0_REG) (match_dup 1)
-			  (label_ref (match_dup 2))] UNSPEC_CASESI))
+	      (mem:SI (unspec:SI [(reg:SI R0_REG) (match_dup 1)
+			  (label_ref (match_dup 2))] UNSPEC_CASESI)))
 	      (clobber (match_dup 3))])]
 {
   if (GET_CODE (operands[2]) == CODE_LABEL)
@@ -10723,9 +10743,9 @@
 
 (define_insn "casesi_worker_1"
   [(set (match_operand:SI 0 "register_operand" "=r,r")
-	(unspec:SI [(reg:SI R0_REG)
+	(mem:SI (unspec:SI [(reg:SI R0_REG)
 		    (match_operand:SI 1 "register_operand" "0,r")
-		    (label_ref (match_operand 2 "" ""))] UNSPEC_CASESI))
+		    (label_ref (match_operand 2 "" ""))] UNSPEC_CASESI)))
    (clobber (match_scratch:SI 3 "=X,1"))]
   "TARGET_SH1"
 {
@@ -10756,10 +10776,10 @@
 
 (define_insn "casesi_worker_2"
   [(set (match_operand:SI 0 "register_operand" "=r,r")
-	(unspec:SI [(reg:SI R0_REG)
+	(mem:SI (unspec:SI [(reg:SI R0_REG)
 		    (match_operand:SI 1 "register_operand" "0,r")
 		    (label_ref (match_operand 2 "" ""))
-		    (label_ref (match_operand 3 "" ""))] UNSPEC_CASESI))
+		    (label_ref (match_operand 3 "" ""))] UNSPEC_CASESI)))
    (clobber (match_operand:SI 4 "" "=X,1"))]
   "TARGET_SH2 && reload_completed && flag_pic"
 {
@@ -10899,6 +10919,19 @@
   "%@"
   [(set_attr "type" "return")])
 
+;; Unconditional traps are assumed to have (const_int 1) for the condition.
+(define_insn "trap"
+  [(trap_if (const_int 1) (const_int 42))]
+  "TARGET_BUILTIN_TRAPA"
+  "*
+{
+  static char templ[16];
+
+  sprintf (templ, \"trapa\t#%d\", 42);
+  return templ;
+}"
+  [(set_attr "in_delay_slot" "no")])
+
 (define_expand "shcompact_return_tramp"
   [(return)]
   "TARGET_SHCOMPACT
@@ -11244,6 +11277,19 @@
    DONE;
 })
 
+(define_expand "sunle"
+  [(set (match_operand:SI 0 "arith_reg_operand" "")
+	(match_dup 1))]
+  "TARGET_SH1_SOFTFP"
+  "
+{
+  if (! currently_expanding_to_rtl)
+    FAIL;
+    sh_emit_compare_and_branch (operands, DFmode);
+  emit_insn (gen_movt (operands[0], get_t_reg_rtx ()));
+  DONE;
+}")
+
 ;; Move the complement of the T reg to a reg.
 ;; On SH2A the movrt insn can be used.
 ;; On anything else than SH2A this has to be done with multiple instructions.
@@ -11795,6 +11841,84 @@
   [(set_attr "type" "sfunc")
    (set_attr "needs_delay_slot" "yes")])
 
+
+;; byte compare pattern
+;; temp = a ^ b;
+;; !((temp & 0xF000) && (temp & 0x0F00) && (temp & 0x00F0) && (temp & 0x000F))
+(define_insn "cmpstr_t"
+  [(set (reg:SI T_REG)
+	(eq:SI (and:SI
+		 (and:SI
+		  (and:SI
+		   (zero_extract:SI (xor:SI (match_operand:SI 0 "arith_reg_operand" "r")
+					    (match_operand:SI 1 "arith_reg_operand" "r"))
+				    (const_int 8) (const_int 0))
+		   (zero_extract:SI (xor:SI (match_dup 0) (match_dup 1))
+				    (const_int 8) (const_int 8)))
+		  (zero_extract:SI (xor:SI (match_dup 0) (match_dup 1))
+				   (const_int 8) (const_int 16)))
+		 (zero_extract:SI (xor:SI (match_dup 0) (match_dup 1))
+				  (const_int 8) (const_int 24))) (const_int 0)))]
+  "TARGET_SH1"
+  "cmp/str	%0,%1"
+  [(set_attr "type" "mt_group")])
+
+(define_expand "cmpstrsi"
+  [(set (match_operand:SI 0 "register_operand")
+	(compare:SI (match_operand:BLK 1 "memory_operand")
+		    (match_operand:BLK 2 "memory_operand")))
+   (use (match_operand:SI 3 "immediate_operand"))]
+  "TARGET_SH1 && optimize"
+{
+ if (! optimize_insn_for_size_p () && sh_expand_cmpstr (operands))
+    DONE;
+  else
+    FAIL;
+})
+
+(define_expand "cmpstrnsi"
+  [(set (match_operand:SI 0 "register_operand")
+	(compare:SI (match_operand:BLK 1 "memory_operand")
+		    (match_operand:BLK 2 "memory_operand")))
+   (use (match_operand:SI 3 "immediate_operand"))
+   (use (match_operand:SI 4 "immediate_operand"))]
+  "TARGET_SH1 && optimize"
+{
+ if (! optimize_insn_for_size_p () && sh_expand_cmpnstr (operands))
+    DONE;
+  else
+    FAIL;
+})
+
+(define_expand "strlensi"
+  [(set (match_operand:SI 0 "register_operand")
+	(unspec:SI [(match_operand:BLK 1 "memory_operand")
+		   (match_operand:SI 2 "immediate_operand")
+		   (match_operand:SI 3 "immediate_operand")]
+		  UNSPEC_BUILTIN_STRLEN))]
+  "TARGET_SH1 && optimize"
+{
+ if (! optimize_insn_for_size_p () && sh_expand_strlen (operands))
+   DONE;
+ else
+   FAIL;
+})
+
+(define_expand "setmemqi"
+  [(parallel [(set (match_operand:BLK 0 "memory_operand")
+                   (match_operand 2 "const_int_operand"))
+              (use (match_operand:QI 1 "const_int_operand"))
+              (use (match_operand:QI 3 "const_int_operand"))])]
+  "TARGET_SH1 && optimize"
+  {
+    if (optimize_insn_for_size_p ())
+       FAIL;
+
+    sh_expand_setmem (operands);
+    DONE;
+  })
+
+
 ;; -------------------------------------------------------------------------
 ;; Floating point instructions.
 ;; -------------------------------------------------------------------------
@@ -11895,7 +12019,7 @@
 (define_insn "toggle_pr"
   [(set (reg:PSI FPSCR_REG)
 	(xor:PSI (reg:PSI FPSCR_REG) (const_int 524288)))]
-  "TARGET_SH4A_FP && ! TARGET_FPU_SINGLE"
+  "(TARGET_SH4A_FP || TARGET_SH4_300)" 
   "fpchg"
   [(set_attr "type" "fpscr_toggle")])
 
@@ -11903,13 +12027,19 @@
   [(set (match_operand:SF 0 "arith_reg_operand" "")
 	(plus:SF (match_operand:SF 1 "arith_reg_operand" "")
 		 (match_operand:SF 2 "arith_reg_operand" "")))]
-  "TARGET_SH2E || TARGET_SHMEDIA_FPU"
+  "TARGET_SH2E || (TARGET_SH3 && TARGET_OSFP) || TARGET_SHMEDIA_FPU"
 {
   if (TARGET_SH2E)
     {
       expand_sf_binop (&gen_addsf3_i, operands);
       DONE;
     }
+  else if (TARGET_OSFP)
+    {
+      expand_sfunc_binop (SFmode, &gen_addsf3_i3, \"__addsf3\", PLUS,
+			  operands);
+      DONE;
+    }
 })
 
 (define_insn "*addsf3_media"
@@ -12002,6 +12132,22 @@
 }
   [(set_attr "type" "fparith_media")])
 
+(define_insn "addsf3_i3"
+  [(set (match_operand:SF 0 "arith_reg_dest" "=z")
+	(plus:SF (reg:SF R4_REG) (reg:SF R5_REG)))
+   (clobber (reg:SI T_REG))
+   (clobber (reg:SI PR_REG))
+   (clobber (reg:SI R1_REG))
+   (clobber (reg:SI R2_REG))
+   (clobber (reg:SI R3_REG))
+   (clobber (reg:SI R6_REG))
+   (clobber (reg:SI R7_REG))
+   (use (match_operand:SI 1 "arith_reg_operand" "r"))]
+  "TARGET_OSFP && ! TARGET_SH2E"
+  "jsr	@%1%#"
+  [(set_attr "type" "sfunc")
+   (set_attr "needs_delay_slot" "yes")])
+
 (define_insn "addsf3_i"
   [(set (match_operand:SF 0 "fp_arith_reg_operand" "=f")
 	(plus:SF (match_operand:SF 1 "fp_arith_reg_operand" "%0")
@@ -12016,13 +12162,19 @@
   [(set (match_operand:SF 0 "fp_arith_reg_operand" "")
 	(minus:SF (match_operand:SF 1 "fp_arith_reg_operand" "")
 		  (match_operand:SF 2 "fp_arith_reg_operand" "")))]
-  "TARGET_SH2E || TARGET_SHMEDIA_FPU"
+  "TARGET_SH2E || (TARGET_SH3 && TARGET_OSFP) || TARGET_SHMEDIA_FPU"
 {
   if (TARGET_SH2E)
     {
       expand_sf_binop (&gen_subsf3_i, operands);
       DONE;
     }
+  else if (TARGET_OSFP)
+    {
+      expand_sfunc_binop (SFmode, &gen_subsf3_i3, \"__subsf3\", MINUS,
+			  operands);
+      DONE;
+    }
 })
 
 (define_insn "*subsf3_media"
@@ -12033,6 +12185,23 @@
   "fsub.s	%1, %2, %0"
   [(set_attr "type" "fparith_media")])
 
+(define_insn "subsf3_i3"
+  [(set (match_operand:SF 0 "arith_reg_dest" "=z")
+	(minus:SF (reg:SF R4_REG) (reg:SF R5_REG)))
+   (clobber (reg:SI T_REG))
+   (clobber (reg:SI PR_REG))
+   (clobber (reg:SI R1_REG))
+   (clobber (reg:SI R2_REG))
+   (clobber (reg:SI R3_REG))
+   (clobber (reg:SI R5_REG))
+   (clobber (reg:SI R6_REG))
+   (clobber (reg:SI R7_REG))
+   (use (match_operand:SI 1 "arith_reg_operand" "r"))]
+  "TARGET_OSFP && ! TARGET_SH2E"
+  "jsr	@%1%#"
+  [(set_attr "type" "sfunc")
+   (set_attr "needs_delay_slot" "yes")])
+
 (define_insn "subsf3_i"
   [(set (match_operand:SF 0 "fp_arith_reg_operand" "=f")
 	(minus:SF (match_operand:SF 1 "fp_arith_reg_operand" "0")
@@ -12047,7 +12216,7 @@
   [(set (match_operand:SF 0 "fp_arith_reg_operand" "")
 	(mult:SF (match_operand:SF 1 "fp_arith_reg_operand" "")
 		 (match_operand:SF 2 "fp_arith_reg_operand" "")))]
-  "TARGET_SH2E || TARGET_SHMEDIA_FPU"
+  "TARGET_SH2E || (TARGET_SH3 && TARGET_OSFP) || TARGET_SHMEDIA_FPU"
 {
   if (TARGET_SH2E)
     {
@@ -12055,8 +12224,30 @@
 		 get_fpscr_rtx ()));
       DONE;
     }
+  if (TARGET_OSFP)
+    {
+      expand_sfunc_binop (SFmode, &gen_mulsf3_i3, \"__mulsf3\", MULT,
+                         operands);
+      DONE;
+    }
 })
 
+(define_insn "mulsf3_i3"
+  [(set (match_operand:SF 0 "arith_reg_dest" "=z")
+	(mult:SF (reg:SF R4_REG) (reg:SF R5_REG)))
+   (clobber (reg:SI MACH_REG))
+   (clobber (reg:SI MACL_REG))
+   (clobber (reg:SI T_REG))
+   (clobber (reg:SI PR_REG))
+   (clobber (reg:SI R1_REG))
+   (clobber (reg:SI R2_REG))
+   (clobber (reg:SI R3_REG))
+   (use (match_operand:SI 1 "arith_reg_operand" "r"))]
+  "TARGET_OSFP && ! TARGET_SH2E"
+   "jsr	@%1%#"
+   [(set_attr "type" "sfunc")
+    (set_attr "needs_delay_slot" "yes")])
+
 (define_insn "*mulsf3_media"
   [(set (match_operand:SF 0 "fp_arith_reg_operand" "=f")
 	(mult:SF (match_operand:SF 1 "fp_arith_reg_operand" "%f")
@@ -12280,6 +12471,79 @@
 ;;	      (use (match_dup 2))])
 ;;   (set (match_dup 0) (reg:SI FPUL_REG))])
 
+(define_insn "cmpnedf_i1"
+  [(set (match_operand:CC_FP_NE 0 "register_operand" "=z")
+	(compare:CC_FP_NE (reg:DF R4_REG) (reg:DF R6_REG)))
+   (clobber (reg:SI T_REG))
+   (clobber (reg:SI PR_REG))
+   (clobber (reg:SI R1_REG))
+   (clobber (reg:SI R2_REG))
+   (use (match_operand:SI 1 "arith_reg_operand" "r"))]
+  "TARGET_SH1_SOFTFP"
+  "jsr	@%1%#"
+  [(set_attr "type" "sfunc")
+   (set_attr "needs_delay_slot" "yes")])
+
+(define_insn "cmpgtdf_i1"
+  [(set (match_operand:CC_FP_GT 0 "register_operand" "=z")
+	(compare:CC_FP_GT (reg:DF R4_REG) (reg:DF R6_REG)))
+   (clobber (reg:SI T_REG))
+   (clobber (reg:SI PR_REG))
+   (clobber (reg:SI R1_REG))
+   (use (match_operand:SI 1 "arith_reg_operand" "r"))]
+  "TARGET_SH1_SOFTFP"
+  "jsr	@%1%#"
+  [(set_attr "type" "sfunc")
+   (set_attr "needs_delay_slot" "yes")])
+
+(define_insn "cmpunltdf_i1"
+  [(set (match_operand:CC_FP_UNLT 0 "register_operand" "=z")
+	(compare:CC_FP_UNLT (reg:DF R4_REG) (reg:DF R6_REG)))
+   (clobber (reg:SI T_REG))
+   (clobber (reg:SI PR_REG))
+   (clobber (reg:SI R1_REG))
+   (use (match_operand:SI 1 "arith_reg_operand" "r"))]
+  "TARGET_SH1_SOFTFP"
+  "jsr	@%1%#"
+  [(set_attr "type" "sfunc")
+   (set_attr "needs_delay_slot" "yes")])
+
+(define_insn "cmpeqdf_i1_finite"
+  [(set (reg:SI T_REG)
+	(eq:SI (match_operand:DF 0 "arith_reg_operand" "r")
+	       (match_operand:DF 1 "arith_reg_operand" "r")))
+   (clobber (match_scratch:SI 2 "=&r"))]
+  "TARGET_SH1_SOFTFP && flag_finite_math_only"
+  "cmp/eq\t%R0,%R1\;mov\t%S0,%2\;bf\t0f\;cmp/eq\t%S0,%S1\;bt\t0f\;or\t%S1,%2\;add\t%2,%2\;or\t%R0,%2\;tst\t%2,%2\\n0:"
+  [(set_attr "length" "18")])
+
+(define_insn "cmpundf_i1"
+  [(set (reg:SI T_REG)
+	(unordered:SI (match_operand:DF 0 "arith_reg_operand" "r")
+		      (match_operand:DF 1 "arith_reg_operand" "r")))
+   (use (match_operand:SI 2 "arith_reg_operand" "r"))
+   (clobber (match_scratch:SI 3 "=&r"))]
+  "TARGET_SH1 && ! TARGET_SH2E"
+   "not\t%S0,%3\;tst\t%2,%3\;bt.s\t0f
+  \tnot\t%S1,%3\;tst\t%2,%3\;bt.s\t0f
+  \tmov\t#12,%3\;shll16\t%3\;xor\t%3,%2
+  \tnot\t%S0,%3\;tst\t%2,%3\;bt.s\t0f
+  \tnot\t%S1,%3\;tst\t%2,%3
+0:"
+  [(set_attr "length" "28")])
+
+;; ??? This is a lot of code with a lot of branches; a library function
+;; might be better.
+(define_insn "cmpuneqdf_i1"
+  [(set (reg:SI T_REG)
+	(uneq:SI (match_operand:DF 0 "arith_reg_operand" "r")
+		 (match_operand:DF 1 "arith_reg_operand" "r")))
+   (use (match_operand:SI 2 "arith_reg_operand" "r"))
+   (clobber (match_scratch:SI 3 "=&r"))]
+  "TARGET_SH1_SOFTFP"
+  "not\t%S0,%3\;tst\t%2,%3\;not\t%S1,%3\;bt\t0f\;tst\t%2,%3\;bt\t0f\;cmp/eq\t%R0,%R1\; bf\t0f\;cmp/eq\t%S0,%S1\;bt\t0f\;mov\t%S0,%3\;or\t%S1,%3\;add\t%3,%3\;or\t%R0,%3\;tst\t%3,%3\\n0:"
+  [(set_attr "length" "30")])
+
 (define_insn "*fixsfsi"
   [(set (match_operand:SI 0 "fpul_operand" "=y")
 	(fix:SI (match_operand:SF 1 "fp_arith_reg_operand" "f")))]
@@ -12551,17 +12815,51 @@
   [(set_attr "type" "fmove")
    (set_attr "fp_mode" "single")])
 
+(define_expand "abssc2"
+  [(set (match_operand:SF 0 "fp_arith_reg_operand" "")
+	(abs:SF (match_operand:SC 1 "fp_arith_reg_operand" "")))]
+  "TARGET_OSFP && ! TARGET_SH2E"
+  "
+{
+  expand_sfunc_unop (SCmode, &gen_abssc2_i3, \"__hypotf\", ABS, operands);
+  DONE;
+}")
+
+(define_insn "abssc2_i3"
+  [(set (match_operand:SF 0 "arith_reg_dest" "=z")
+	(abs:SF (reg:SC R4_REG)))
+   (clobber (reg:SI MACH_REG))
+   (clobber (reg:SI MACL_REG))
+   (clobber (reg:SI T_REG))
+   (clobber (reg:SI PR_REG))
+   (clobber (reg:SI R1_REG))
+   (clobber (reg:SI R2_REG))
+   (clobber (reg:SI R3_REG))
+   (clobber (reg:SI R4_REG))
+   (clobber (reg:SI R5_REG))
+   (use (match_operand:SI 1 "arith_reg_operand" "r"))]
+  "TARGET_OSFP && ! TARGET_SH2E"
+  "jsr	@%1%#"
+  [(set_attr "type" "sfunc")
+   (set_attr "needs_delay_slot" "yes")])
+
 (define_expand "adddf3"
   [(set (match_operand:DF 0 "fp_arith_reg_operand" "")
 	(plus:DF (match_operand:DF 1 "fp_arith_reg_operand" "")
 		 (match_operand:DF 2 "fp_arith_reg_operand" "")))]
-  "(TARGET_SH4 || TARGET_SH2A_DOUBLE) || TARGET_SHMEDIA_FPU"
+  "TARGET_FPU_DOUBLE || (TARGET_SH3 && TARGET_OSFP)"
 {
   if (TARGET_SH4 || TARGET_SH2A_DOUBLE)
     {
       expand_df_binop (&gen_adddf3_i, operands);
       DONE;
     }
+  else if (TARGET_SH3 && TARGET_OSFP)
+    {
+      expand_sfunc_binop (DFmode, &gen_adddf3_i3_wrap, \"__adddf3\", PLUS,
+			  operands);
+      DONE;
+    }
 })
 
 (define_insn "*adddf3_media"
@@ -12582,6 +12880,30 @@
   [(set_attr "type" "dfp_arith")
    (set_attr "fp_mode" "double")])
 
+(define_expand "adddf3_i3_wrap"
+  [(match_operand:DF 0 "" "") (match_operand:SI 1 "" "")]
+  "TARGET_SH3"
+  "
+{
+  emit_insn (gen_adddf3_i3 (operands[1]));
+  emit_move_insn (operands[0], gen_rtx_REG (DFmode, R0_REG));
+  DONE;
+}")
+
+(define_insn "adddf3_i3"
+  [(set (reg:DF R0_REG)
+	(plus:DF (reg:DF R4_REG) (reg:DF R6_REG)))
+   (clobber (reg:SI T_REG))
+   (clobber (reg:SI PR_REG))
+   (clobber (reg:DI R2_REG))
+   (clobber (reg:DF R4_REG))
+   (clobber (reg:DF R6_REG))
+   (use (match_operand:SI 0 "arith_reg_operand" "r"))]
+  "TARGET_SH3"
+  "jsr	@%0%#"
+  [(set_attr "type" "sfunc")
+   (set_attr "needs_delay_slot" "yes")])
+
 (define_expand "subdf3"
   [(set (match_operand:DF 0 "fp_arith_reg_operand" "")
 	(minus:DF (match_operand:DF 1 "fp_arith_reg_operand" "")
@@ -12617,13 +12939,19 @@
   [(set (match_operand:DF 0 "fp_arith_reg_operand" "")
 	(mult:DF (match_operand:DF 1 "fp_arith_reg_operand" "")
 		 (match_operand:DF 2 "fp_arith_reg_operand" "")))]
-  "(TARGET_SH4 || TARGET_SH2A_DOUBLE) || TARGET_SHMEDIA_FPU"
+  "TARGET_FPU_DOUBLE || (TARGET_SH3 && TARGET_OSFP)"
 {
   if (TARGET_SH4 || TARGET_SH2A_DOUBLE)
     {
       expand_df_binop (&gen_muldf3_i, operands);
       DONE;
     }
+  else if (TARGET_SH3 && TARGET_OSFP)
+    {
+      expand_sfunc_binop (DFmode, &gen_muldf3_i3_wrap, \"__muldf3\", MULT,
+			  operands);
+      DONE;
+    }
 })
 
 (define_insn "*muldf3_media"
@@ -12644,6 +12972,32 @@
   [(set_attr "type" "dfp_mul")
    (set_attr "fp_mode" "double")])
 
+(define_expand "muldf3_i3_wrap"
+  [(match_operand:DF 0 "" "") (match_operand:SI 1 "" "")]
+  "TARGET_SH3"
+   "
+ {
+   emit_insn (gen_muldf3_i3 (operands[1]));
+   emit_move_insn (operands[0], gen_rtx_REG (DFmode, R0_REG));
+   DONE;
+ }")
+
+ (define_insn "muldf3_i3"
+   [(set (reg:DF R0_REG)
+ 	(mult:DF (reg:DF R4_REG) (reg:DF R6_REG)))
+    (clobber (reg:SI MACH_REG))
+    (clobber (reg:SI MACL_REG))
+    (clobber (reg:SI T_REG))
+    (clobber (reg:SI PR_REG))
+    (clobber (reg:DI R2_REG))
+    (clobber (reg:DF R4_REG))
+    (clobber (reg:DF R6_REG))
+    (use (match_operand:SI 0 "arith_reg_operand" "r"))]
+   "TARGET_SH3"
+   "jsr	@%0%#"
+   [(set_attr "type" "sfunc")
+    (set_attr "needs_delay_slot" "yes")])
+
 (define_expand "divdf3"
   [(set (match_operand:DF 0 "fp_arith_reg_operand" "")
 	(div:DF (match_operand:DF 1 "fp_arith_reg_operand" "")
@@ -12940,7 +13294,7 @@
 (define_expand "extendsfdf2"
   [(set (match_operand:DF 0 "fp_arith_reg_operand" "")
 	(float_extend:DF (match_operand:SF 1 "fpul_operand" "")))]
-  "(TARGET_SH4 || TARGET_SH2A_DOUBLE) || TARGET_SHMEDIA_FPU"
+  "TARGET_FPU_DOUBLE || (TARGET_SH3 && TARGET_OSFP) || TARGET_SHMEDIA_FPU"
 {
   if (TARGET_SH4 || TARGET_SH2A_DOUBLE)
     {
@@ -12948,6 +13302,18 @@
 					get_fpscr_rtx ()));
       DONE;
     }
+  if (TARGET_SH2E && TARGET_OSFP)
+    {
+      expand_sfunc_unop (SFmode, &gen_extendsfdf2_i2e, \"__extendsfdf2\",
+ 		 FLOAT_EXTEND, operands);
+      DONE;
+    }
+  else if (TARGET_SH1 && TARGET_OSFP)
+    {
+      expand_sfunc_unop (SFmode, &gen_extendsfdf2_i1, \"__extendsfdf2\",
+			 FLOAT_EXTEND, operands);
+      DONE;
+    }
 })
 
 (define_insn "*extendsfdf2_media"
@@ -12966,10 +13332,76 @@
   [(set_attr "type" "fp")
    (set_attr "fp_mode" "double")])
 
+;; ??? In order to use this efficiently, we'd have to have an extra
+;; register class for r0 and r1 - and that would cause repercussions in
+;; register allocation elsewhere.  So just say we clobber r0 / r1, and
+;; that we can use an arbitrary target.  */
+(define_insn_and_split "extendsfdf2_i1"
+  [(set (match_operand:DF 0 "arith_reg_dest" "=r")
+	(float_extend:DF (reg:SF R4_REG)))
+   (clobber (reg:SI T_REG))
+   (clobber (reg:SI PR_REG))
+   (clobber (reg:SI R0_REG))
+   (clobber (reg:SI R1_REG))
+   (clobber (reg:SI R2_REG))
+   (clobber (reg:SI R3_REG))
+   (use (match_operand:SI 1 "arith_reg_operand" "r"))]
+  "TARGET_SH1_SOFTFP && !TARGET_SH2E"
+  "#"
+  "&& reload_completed"
+  [(set (match_dup 0) (reg:DF R0_REG))]
+  "emit_insn (gen_extendsfdf2_i1_r0 (operands[1]));"
+  [(set_attr "type" "sfunc")])
+
+(define_insn "extendsfdf2_i1_r0"
+  [(set (reg:DF R0_REG) (float_extend:DF (reg:SF R4_REG)))
+   (clobber (reg:SI T_REG))
+   (clobber (reg:SI PR_REG))
+   (clobber (reg:SI R2_REG))
+   (clobber (reg:SI R3_REG))
+   (use (match_operand:SI 0 "arith_reg_operand" "r"))]
+  "TARGET_SH1_SOFTFP && !TARGET_SH2E"
+  "jsr	@%0%#"
+  [(set_attr "type" "sfunc")
+   (set_attr "needs_delay_slot" "yes")])
+
+(define_insn_and_split "extendsfdf2_i2e"
+  [(set (match_operand:DF 0 "arith_reg_dest" "=r")
+	(float_extend:DF (reg:SF FR4_REG)))
+   (clobber (reg:SI T_REG))
+   (clobber (reg:SI PR_REG))
+   (clobber (reg:SI R0_REG))
+   (clobber (reg:SI R1_REG))
+   (clobber (reg:SI R2_REG))
+   (clobber (reg:SI R3_REG))
+   (clobber (reg:SI R4_REG))
+   (clobber (reg:SI FPUL_REG))
+   (use (match_operand:SI 1 "arith_reg_operand" "r"))]
+  "TARGET_SH1_SOFTFP && TARGET_SH2E"
+  "#"
+  "&& reload_completed"
+  [(set (match_dup 0) (reg:DF R0_REG))]
+  "emit_insn (gen_extendsfdf2_i2e_r0 (operands[1]));"
+  [(set_attr "type" "sfunc")])
+
+(define_insn "extendsfdf2_i2e_r0"
+  [(set (reg:DF R0_REG) (float_extend:DF (reg:SF FR4_REG)))
+   (clobber (reg:SI T_REG))
+   (clobber (reg:SI PR_REG))
+   (clobber (reg:SI R2_REG))
+   (clobber (reg:SI R3_REG))
+   (clobber (reg:SI R4_REG))
+   (clobber (reg:SI FPUL_REG))
+   (use (match_operand:SI 0 "arith_reg_operand" "r"))]
+  "TARGET_SH1_SOFTFP && TARGET_SH2E"
+  "jsr	@%0%#"
+  [(set_attr "type" "sfunc")
+   (set_attr "needs_delay_slot" "yes")])
+
 (define_expand "truncdfsf2"
   [(set (match_operand:SF 0 "fpul_operand" "")
 	(float_truncate:SF (match_operand:DF 1 "fp_arith_reg_operand" "")))]
-  "(TARGET_SH4 || TARGET_SH2A_DOUBLE) || TARGET_SHMEDIA_FPU"
+  "TARGET_FPU_DOUBLE || (TARGET_SH3 && TARGET_OSFP) || TARGET_SHMEDIA_FPU"
 {
   if (TARGET_SH4 || TARGET_SH2A_DOUBLE)
     {
@@ -12977,6 +13409,18 @@
 				       get_fpscr_rtx ()));
       DONE;
     }
+  else if (TARGET_SH2E && TARGET_OSFP)
+    {
+      expand_sfunc_unop (DFmode, &gen_truncdfsf2_i2e, \"__truncdfsf2\",
+			 FLOAT_TRUNCATE, operands);
+      DONE;
+    }
+  else if (TARGET_SH1 && TARGET_OSFP)
+    {
+      expand_sfunc_unop (DFmode, &gen_truncdfsf2_i1, \"__truncdfsf2\",
+			 FLOAT_TRUNCATE, operands);
+      DONE;
+    }
 })
 
 (define_insn "*truncdfsf2_media"
@@ -12995,6 +13439,36 @@
   [(set_attr "type" "fp")
    (set_attr "fp_mode" "double")])
 
+(define_insn "truncdfsf2_i1"
+  [(set (match_operand:SF 0 "arith_reg_dest" "=z")
+	(float_truncate:SF (reg:DF R4_REG)))
+   (clobber (reg:SI T_REG))
+   (clobber (reg:SI PR_REG))
+   (clobber (reg:SI R1_REG))
+   (clobber (reg:SI R2_REG))
+   (clobber (reg:SI R3_REG))
+   (use (match_operand:SI 1 "arith_reg_operand" "r"))]
+  "TARGET_SH1_SOFTFP && !TARGET_SH2E"
+  "jsr	@%1%#"
+  [(set_attr "type" "sfunc")
+   (set_attr "needs_delay_slot" "yes")])
+
+(define_insn "truncdfsf2_i2e"
+  [(set (match_operand:SF 0 "arith_reg_dest" "=w")
+	(float_truncate:SF (reg:DF R4_REG)))
+   (clobber (reg:SI T_REG))
+   (clobber (reg:SI PR_REG))
+   (clobber (reg:SI FPUL_REG))
+   (clobber (reg:SI R0_REG))
+   (clobber (reg:SI R1_REG))
+   (clobber (reg:SI R2_REG))
+   (clobber (reg:SI R3_REG))
+   (use (match_operand:SI 1 "arith_reg_operand" "r"))]
+  "TARGET_SH1_SOFTFP && TARGET_SH2E"
+  "jsr	@%1%#"
+  [(set_attr "type" "sfunc")
+   (set_attr "needs_delay_slot" "yes")])
+
 ;; -------------------------------------------------------------------------
 ;; Bit field extract patterns.
 ;; -------------------------------------------------------------------------
@@ -13397,6 +13871,29 @@
   return alt[which_alternative];
 }
   [(set_attr "length" "6,6")])
+
+(define_expand "lrintsfsi2"
+  [(set (match_operand:SI 0 "general_operand" "")
+	(unspec:SI [(match_operand:SF 1 "fp_arith_reg_operand" "")]
+		   UNSPEC_BUILTIN_ROUND))]
+  "(TARGET_SH4 || TARGET_SH2A_SINGLE) && !optimize_size"
+  "
+{
+  sh_expand_lround (operand0, operand1, 1);
+  DONE;
+}")
+
+(define_expand "lroundsfsi2"
+  [(set (match_operand:SI 0 "general_operand" "")
+	(unspec:SI [(match_operand:SF 1 "fp_arith_reg_operand" "")]
+		   UNSPEC_BUILTIN_ROUND))]
+  "(TARGET_SH4 || TARGET_SH2A_SINGLE) && !optimize_size"
+  "
+{
+  sh_expand_lround (operand0, operand1, 0);
+  DONE;
+}")
+
 
 ;; -------------------------------------------------------------------------
 ;; Peepholes
diff -ruN gcc-gnu-4.8.2/gcc/config/sh/sh-mem.cc gcc-st40-4.8.2.140205/gcc/config/sh/sh-mem.cc
--- gcc-gnu-4.8.2/gcc/config/sh/sh-mem.cc	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/config/sh/sh-mem.cc	2014-01-29 12:57:17.000000000 +0100
@@ -0,0 +1,793 @@
+/* Helper routines for memory move and comparison insns.
+   Copyright (C) 2011.
+   Free Software Foundation, Inc.
+   Copyright (c) 2013 STMicroelectronics.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "machmode.h"
+#include "rtl.h"
+#include "tree.h"
+#include "expr.h"
+#include "tm_p.h"
+#include "basic-block.h"
+
+/* Like force_operand, but guarantees that VALUE ends up in TARGET.  */
+static void
+force_into (rtx value, rtx target)
+{
+  value = force_operand (value, target);
+  if (! rtx_equal_p (value, target))
+    emit_insn (gen_move_insn (target, value));
+}
+
+/* Emit code to perform a block move.  Choose the best method.
+
+   OPERANDS[0] is the destination.
+   OPERANDS[1] is the source.
+   OPERANDS[2] is the size.
+   OPERANDS[3] is the alignment safe to use.  */
+bool
+expand_block_move (rtx *operands)
+{
+  int align = INTVAL (operands[3]);
+  int constp = (CONST_INT_P (operands[2]));
+  int bytes = (constp ? INTVAL (operands[2]) : 0);
+
+  if (! constp)
+    return false;
+
+  if ((TARGET_SH4 || TARGET_SH2A_DOUBLE)
+      && TARGET_FMOVD
+      && !optimize_size && align == 8 && bytes > 4)
+  {
+      rtx dest = copy_rtx (operands[0]);
+      rtx src = copy_rtx (operands[1]);
+      rtx src_addr = copy_addr_to_reg (XEXP (src, 0));
+
+      int copied = 0;
+
+      while (copied + 48 <= bytes)
+	{
+	  rtx temp0 = gen_reg_rtx (DFmode);
+	  rtx temp1 = gen_reg_rtx (DFmode);
+	  rtx temp2 = gen_reg_rtx (DFmode);
+	  rtx temp3 = gen_reg_rtx (DFmode);
+	  rtx temp4 = gen_reg_rtx (DFmode);
+	  rtx temp5 = gen_reg_rtx (DFmode);
+
+	  rtx to0 = adjust_address (dest, DFmode, copied);
+	  rtx to1 = adjust_address (dest, DFmode, copied+8);
+	  rtx to2 = adjust_address (dest, DFmode, copied+16);
+	  rtx to3 = adjust_address (dest, DFmode, copied+24);
+	  rtx to4 = adjust_address (dest, DFmode, copied+32);
+	  rtx to5 = adjust_address (dest, DFmode, copied+40);
+
+	  rtx from0 = adjust_automodify_address (src, DFmode, src_addr, copied);
+	  rtx from1 = adjust_automodify_address (src, DFmode, src_addr, copied + 8);
+	  rtx from2 = adjust_automodify_address (src, DFmode, src_addr, copied + 16);
+	  rtx from3 = adjust_automodify_address (src, DFmode, src_addr, copied + 24);
+	  rtx from4 = adjust_automodify_address (src, DFmode, src_addr, copied + 32);
+	  rtx from5 = adjust_automodify_address (src, DFmode, src_addr, copied + 40);
+
+	  emit_move_insn (temp0, from0);
+	  emit_move_insn (src_addr, plus_constant (Pmode, src_addr, 8));
+
+	  emit_move_insn (temp1, from1);
+	  emit_move_insn (src_addr, plus_constant (Pmode, src_addr, 8));
+
+	  emit_move_insn (temp2, from2);
+	  emit_move_insn (src_addr, plus_constant (Pmode, src_addr, 8));
+
+	  emit_move_insn (temp3, from3);
+	  emit_move_insn (src_addr, plus_constant (Pmode, src_addr, 8));
+
+	  emit_move_insn (temp4, from4);
+	  emit_move_insn (src_addr, plus_constant (Pmode, src_addr, 8));
+
+	  emit_move_insn (temp5, from5);
+	  emit_move_insn (src_addr, plus_constant (Pmode, src_addr, 8));
+
+	  emit_move_insn (to0, temp0);
+	  emit_move_insn (to1, temp1);
+	  emit_move_insn (to2, temp2);
+	  emit_move_insn (to3, temp3);
+	  emit_move_insn (to4, temp4);
+	  emit_move_insn (to5, temp5);
+
+	  copied += 48;
+	}
+
+      while (copied + 8 <= bytes)
+	{
+	  rtx temp0 = gen_reg_rtx (DFmode);
+	  rtx to0 = adjust_address (dest, DFmode, copied);
+	  rtx from0 = adjust_automodify_address (src, DFmode, src_addr, copied);
+
+	  emit_move_insn (temp0, from0);
+	  emit_move_insn (src_addr, plus_constant (Pmode, src_addr, 8));
+	  emit_move_insn (to0, temp0);
+	  copied += 8;
+	}
+
+      if (copied < bytes)
+	move_by_pieces (adjust_address (dest, BLKmode, copied),
+			adjust_automodify_address (src, BLKmode,
+						   src_addr, copied),
+			bytes - copied, align, 0);
+
+      return true;
+  }
+
+
+  /* If we could use mov.l to move words and dest is word-aligned, we
+     can use movua.l for loads and still generate a relatively short
+     and efficient sequence.  */
+  if (TARGET_SH4A_ARCH && align < 4
+      && MEM_ALIGN (operands[0]) >= 32
+      && can_move_by_pieces (bytes, 32))
+    {
+      rtx dest = copy_rtx (operands[0]);
+      rtx src = copy_rtx (operands[1]);
+      /* We could use different pseudos for each copied word, but
+	 since movua can only load into r0, it's kind of
+	 pointless.  */
+      rtx temp = gen_reg_rtx (SImode);
+      rtx src_addr = copy_addr_to_reg (XEXP (src, 0));
+      int copied = 0;
+
+      while (copied + 4 <= bytes)
+	{
+	  rtx to = adjust_address (dest, SImode, copied);
+	  rtx from = adjust_automodify_address (src, BLKmode,
+						src_addr, copied);
+
+	  set_mem_size (from, 4);
+	  emit_insn (gen_movua (temp, from));
+	  emit_move_insn (src_addr, plus_constant (Pmode, src_addr, 4));
+	  emit_move_insn (to, temp);
+	  copied += 4;
+	}
+
+      if (copied < bytes)
+	move_by_pieces (adjust_address (dest, BLKmode, copied),
+			adjust_automodify_address (src, BLKmode,
+						   src_addr, copied),
+			bytes - copied, align, 0);
+
+      return true;
+    }
+
+  /* If it isn't a constant number of bytes, or if it doesn't have 4 byte
+     alignment, or if it isn't a multiple of 4 bytes, then fail.  */
+  if (align < 4 || (bytes % 4 != 0))
+    return false;
+
+  if (TARGET_HARD_SH4)
+    {
+      if (bytes < 12)
+	return false;
+      else if (bytes == 12)
+	{
+	  rtx func_addr_rtx = gen_reg_rtx (Pmode);
+	  rtx r4 = gen_rtx_REG (SImode, 4);
+	  rtx r5 = gen_rtx_REG (SImode, 5);
+
+	  function_symbol (func_addr_rtx, "__movmemSI12_i4", SFUNC_STATIC);
+	  force_into (XEXP (operands[0], 0), r4);
+	  force_into (XEXP (operands[1], 0), r5);
+	  emit_insn (gen_block_move_real_i4 (func_addr_rtx));
+	  return true;
+	}
+      else if (! optimize_size)
+	{
+	  const char *entry_name;
+	  rtx func_addr_rtx = gen_reg_rtx (Pmode);
+	  int dwords;
+	  rtx r4 = gen_rtx_REG (SImode, 4);
+	  rtx r5 = gen_rtx_REG (SImode, 5);
+	  rtx r6 = gen_rtx_REG (SImode, 6);
+
+	  entry_name = (bytes & 4 ? "__movmem_i4_odd" : "__movmem_i4_even");
+	  function_symbol (func_addr_rtx, entry_name, SFUNC_STATIC);
+	  force_into (XEXP (operands[0], 0), r4);
+	  force_into (XEXP (operands[1], 0), r5);
+
+	  dwords = bytes >> 3;
+	  emit_insn (gen_move_insn (r6, GEN_INT (dwords - 1)));
+	  emit_insn (gen_block_lump_real_i4 (func_addr_rtx));
+	  return true;
+	}
+      else
+	return false;
+    }
+  if (bytes < 64)
+    {
+      char entry[30];
+      rtx func_addr_rtx = gen_reg_rtx (Pmode);
+      rtx r4 = gen_rtx_REG (SImode, 4);
+      rtx r5 = gen_rtx_REG (SImode, 5);
+
+      sprintf (entry, "__movmemSI%d", bytes);
+      function_symbol (func_addr_rtx, entry, SFUNC_STATIC);
+      force_into (XEXP (operands[0], 0), r4);
+      force_into (XEXP (operands[1], 0), r5);
+      emit_insn (gen_block_move_real (func_addr_rtx));
+      return true;
+    }
+
+  /* This is the same number of bytes as a memcpy call, but to a different
+     less common function name, so this will occasionally use more space.  */
+  if (! optimize_size)
+    {
+      rtx func_addr_rtx = gen_reg_rtx (Pmode);
+      int final_switch, while_loop;
+      rtx r4 = gen_rtx_REG (SImode, 4);
+      rtx r5 = gen_rtx_REG (SImode, 5);
+      rtx r6 = gen_rtx_REG (SImode, 6);
+
+      function_symbol (func_addr_rtx, "__movmem", SFUNC_STATIC);
+      force_into (XEXP (operands[0], 0), r4);
+      force_into (XEXP (operands[1], 0), r5);
+
+      /* r6 controls the size of the move.  16 is decremented from it
+	 for each 64 bytes moved.  Then the negative bit left over is used
+	 as an index into a list of move instructions.  e.g., a 72 byte move
+	 would be set up with size(r6) = 14, for one iteration through the
+	 big while loop, and a switch of -2 for the last part.  */
+
+      final_switch = 16 - ((bytes / 4) % 16);
+      while_loop = ((bytes / 4) / 16 - 1) * 16;
+      emit_insn (gen_move_insn (r6, GEN_INT (while_loop + final_switch)));
+      emit_insn (gen_block_lump_real (func_addr_rtx));
+      return true;
+    }
+
+  return false;
+}
+
+/* Emit code to perform a strcmp.
+
+   OPERANDS[0] is the destination.
+   OPERANDS[1] is the first string.
+   OPERANDS[2] is the second string.
+   OPERANDS[3] is the known alignment.  */
+bool
+sh_expand_cmpstr (rtx *operands)
+{
+  rtx addr1 = operands[1];
+  rtx addr2 = operands[2];
+  rtx s1_addr = copy_addr_to_reg (XEXP (addr1, 0));
+  rtx s2_addr = copy_addr_to_reg (XEXP (addr2, 0));
+  rtx tmp0 = gen_reg_rtx (SImode);
+  rtx tmp1 = gen_reg_rtx (SImode);
+  rtx tmp2 = gen_reg_rtx (SImode);
+  rtx tmp3 = gen_reg_rtx (SImode);
+
+  rtx jump;
+  rtx L_return = gen_label_rtx ();
+  rtx L_loop_byte = gen_label_rtx ();
+  rtx L_end_loop_byte = gen_label_rtx ();
+  rtx L_loop_long = gen_label_rtx ();
+  rtx L_end_loop_long = gen_label_rtx ();
+
+  int align = INTVAL (operands[3]);
+  rtx prob_unlikely = GEN_INT (REG_BR_PROB_BASE / 10);
+  rtx prob_likely = GEN_INT (REG_BR_PROB_BASE / 4);
+
+  emit_move_insn (tmp0, const0_rtx);
+
+  if (align < 4)
+    {
+      emit_insn (gen_iorsi3 (tmp1, s1_addr, s2_addr));
+      emit_insn (gen_tstsi_t (GEN_INT (3), tmp1));
+      jump = emit_jump_insn (gen_branch_false (L_loop_byte));
+      add_reg_note (jump, REG_BR_PROB, prob_likely);
+    }
+
+  addr1 = adjust_automodify_address (addr1, SImode, s1_addr, 0);
+  addr2 = adjust_automodify_address (addr2, SImode, s2_addr, 0);
+
+  /* tmp2 is aligned, OK to load.  */
+  emit_move_insn (tmp3, addr2);
+  emit_move_insn (s2_addr, plus_constant (Pmode, s2_addr, 4));
+
+  /*start long loop.  */
+  emit_label (L_loop_long);
+
+  emit_move_insn (tmp2, tmp3);
+
+  /* tmp1 is aligned, OK to load.  */
+  emit_move_insn (tmp1, addr1);
+  emit_move_insn (s1_addr, plus_constant (Pmode, s1_addr, 4));
+
+  /* Is there a 0 byte ?  */
+  emit_insn (gen_andsi3 (tmp3, tmp3, tmp1));
+
+  emit_insn (gen_cmpstr_t (tmp0, tmp3));
+  jump = emit_jump_insn (gen_branch_true (L_end_loop_long));
+  add_reg_note (jump, REG_BR_PROB, prob_unlikely);
+
+  emit_insn (gen_cmpeqsi_t (tmp1, tmp2));
+
+  /* tmp2 is aligned, OK to load.  */
+  emit_move_insn (tmp3, addr2);
+  emit_move_insn (s2_addr, plus_constant (Pmode, s2_addr, 4));
+
+  jump = emit_jump_insn (gen_branch_true (L_loop_long));
+  add_reg_note (jump, REG_BR_PROB, prob_likely);
+  /* end loop.  */
+
+  /* Fallthu, substract words.  */
+  if (TARGET_LITTLE_ENDIAN)
+    {
+      rtx low_1 = gen_lowpart (HImode, tmp1);
+      rtx low_2 = gen_lowpart (HImode, tmp2);
+
+      emit_insn (gen_rotlhi3_8 (low_1, low_1));
+      emit_insn (gen_rotlhi3_8 (low_2, low_2));
+      emit_insn (gen_rotlsi3_16 (tmp1, tmp1));
+      emit_insn (gen_rotlsi3_16 (tmp2, tmp2));
+      emit_insn (gen_rotlhi3_8 (low_1, low_1));
+      emit_insn (gen_rotlhi3_8 (low_2, low_2));
+    }
+
+  jump = emit_jump_insn (gen_jump_compact (L_return));
+  emit_barrier_after (jump);
+
+  emit_label (L_end_loop_long);
+
+  emit_move_insn (s1_addr, plus_constant (Pmode, s1_addr, -4));
+  emit_move_insn (s2_addr, plus_constant (Pmode, s2_addr, -4));
+
+  /* start byte loop.  */
+  addr1 = adjust_address (addr1, QImode, 0);
+  addr2 = adjust_address (addr2, QImode, 0);
+
+  emit_label (L_loop_byte);
+
+  emit_insn (gen_extendqisi2 (tmp2, addr2));
+  emit_move_insn (s2_addr, plus_constant (Pmode, s2_addr, 1));
+
+  emit_insn (gen_extendqisi2 (tmp1, addr1));
+  emit_move_insn (s1_addr, plus_constant (Pmode, s1_addr, 1));
+
+  emit_insn (gen_cmpeqsi_t (tmp2, const0_rtx));
+  jump = emit_jump_insn (gen_branch_true (L_end_loop_byte));
+  add_reg_note (jump, REG_BR_PROB, prob_unlikely);
+
+  emit_insn (gen_cmpeqsi_t (tmp1, tmp2));
+  if (flag_delayed_branch)
+    emit_insn (gen_zero_extendqisi2 (tmp2, gen_lowpart (QImode, tmp2)));
+  jump = emit_jump_insn (gen_branch_true (L_loop_byte));
+  add_reg_note (jump, REG_BR_PROB, prob_likely);
+  /* end loop.  */
+
+  emit_label (L_end_loop_byte);
+
+  if (! flag_delayed_branch)
+    emit_insn (gen_zero_extendqisi2 (tmp2, gen_lowpart (QImode, tmp2)));
+  emit_insn (gen_zero_extendqisi2 (tmp1, gen_lowpart (QImode, tmp1)));
+
+  emit_label (L_return);
+
+  emit_insn (gen_subsi3 (operands[0], tmp1, tmp2));
+
+  return true;
+}
+
+/* Emit code to perform a strncmp.
+
+   OPERANDS[0] is the destination.
+   OPERANDS[1] is the first string.
+   OPERANDS[2] is the second string.
+   OPERANDS[3] is the length.
+   OPERANDS[4] is the known alignment.  */
+bool
+sh_expand_cmpnstr (rtx *operands)
+{
+  rtx addr1 = operands[1];
+  rtx addr2 = operands[2];
+  rtx s1_addr = copy_addr_to_reg (XEXP (addr1, 0));
+  rtx s2_addr = copy_addr_to_reg (XEXP (addr2, 0));
+  rtx tmp1 = gen_reg_rtx (SImode);
+  rtx tmp2 = gen_reg_rtx (SImode);
+
+  rtx jump;
+  rtx L_return = gen_label_rtx ();
+  rtx L_loop_byte = gen_label_rtx ();
+  rtx L_end_loop_byte = gen_label_rtx ();
+
+  rtx len = force_reg (SImode, operands[3]);
+  int constp = CONST_INT_P (operands[3]);
+
+  rtx prob_unlikely = GEN_INT (REG_BR_PROB_BASE / 10);
+  rtx prob_likely = GEN_INT (REG_BR_PROB_BASE / 4);
+
+  /* Loop on a register count. */
+  if (constp)
+    {
+      rtx tmp0 = gen_reg_rtx (SImode);
+      rtx tmp3 = gen_reg_rtx (SImode);
+      rtx lenw = gen_reg_rtx (SImode);
+
+      rtx L_loop_long = gen_label_rtx ();
+      rtx L_end_loop_long = gen_label_rtx ();
+
+      int align = INTVAL (operands[4]);
+      int bytes = INTVAL (operands[3]);
+      int witers = bytes / 4;
+
+      if (witers > 1)
+        {
+          addr1 = adjust_automodify_address (addr1, SImode, s1_addr, 0);
+          addr2 = adjust_automodify_address (addr2, SImode, s2_addr, 0);
+
+          emit_move_insn (tmp0, const0_rtx);
+
+          if (align < 4)
+            {
+              emit_insn (gen_iorsi3 (tmp1, s1_addr, s2_addr));
+              emit_insn (gen_tstsi_t (GEN_INT (3), tmp1));
+              jump = emit_jump_insn (gen_branch_false (L_loop_byte));
+              add_reg_note (jump, REG_BR_PROB, prob_likely);
+            }
+
+          /* word count. Do we have iterations ? */
+          emit_insn (gen_lshrsi3 (lenw, len, GEN_INT (2)));
+
+          /*start long loop.  */
+          emit_label (L_loop_long);
+
+          /* tmp2 is aligned, OK to load.  */
+          emit_move_insn (tmp2, addr2);
+          emit_move_insn (s2_addr, plus_constant (Pmode, s2_addr,
+                                                  GET_MODE_SIZE (SImode)));
+
+          /* tmp1 is aligned, OK to load.  */
+          emit_move_insn (tmp1, addr1);
+          emit_move_insn (s1_addr, plus_constant (Pmode, s1_addr,
+                                                  GET_MODE_SIZE (SImode)));
+
+          /* Is there a 0 byte ?  */
+          emit_insn (gen_andsi3 (tmp3, tmp2, tmp1));
+
+          emit_insn (gen_cmpstr_t (tmp0, tmp3));
+          jump = emit_jump_insn (gen_branch_true (L_end_loop_long));
+          add_reg_note (jump, REG_BR_PROB, prob_unlikely);
+
+          emit_insn (gen_cmpeqsi_t (tmp1, tmp2));
+          jump = emit_jump_insn (gen_branch_false (L_end_loop_long));
+          add_reg_note (jump, REG_BR_PROB, prob_unlikely);
+
+          if (TARGET_SH2)
+            emit_insn (gen_dect (lenw, lenw));
+          else
+            {
+              emit_insn (gen_addsi3 (lenw, lenw, GEN_INT (-1)));
+              emit_insn (gen_tstsi_t (lenw, lenw));
+            }
+
+          jump = emit_jump_insn (gen_branch_false (L_loop_long));
+          add_reg_note (jump, REG_BR_PROB, prob_likely);
+
+         int sbytes = bytes % 4;
+
+          /* end loop.  Reached max iterations.  */
+          if (! sbytes)
+            {
+              jump = emit_jump_insn (gen_jump_compact (L_return));
+              emit_barrier_after (jump);
+            }
+          else
+            {
+              addr1 = adjust_automodify_address (addr1, QImode, s1_addr, 0);
+              addr2 = adjust_automodify_address (addr2, QImode, s2_addr, 0);
+
+              while (sbytes--)
+                {
+                  emit_insn (gen_extendqisi2 (tmp1, addr1));
+                  emit_insn (gen_extendqisi2 (tmp2, addr2));
+
+                  emit_insn (gen_cmpeqsi_t (tmp2, const0_rtx));
+                  jump = emit_jump_insn (gen_branch_true (L_end_loop_byte));
+                  add_reg_note (jump, REG_BR_PROB, prob_unlikely);
+
+                  emit_insn (gen_cmpeqsi_t (tmp1, tmp2));
+                  if (flag_delayed_branch)
+                    emit_insn (gen_zero_extendqisi2 (tmp2, gen_lowpart (QImode, tmp2)));
+                  jump = emit_jump_insn (gen_branch_false (L_end_loop_byte));
+                  add_reg_note (jump, REG_BR_PROB, prob_unlikely);
+
+                  addr1 = adjust_address (addr1, QImode, GET_MODE_SIZE (QImode));
+                  addr2 = adjust_address (addr2, QImode, GET_MODE_SIZE (QImode));
+                }
+
+              jump = emit_jump_insn (gen_jump_compact( L_end_loop_byte));
+              emit_barrier_after (jump);
+            }
+
+          emit_label (L_end_loop_long);
+
+          /* Found last word.  Restart it byte per byte. */
+
+          emit_move_insn (s1_addr, plus_constant (Pmode, s1_addr,
+                                                  -GET_MODE_SIZE (SImode)));
+          emit_move_insn (s2_addr, plus_constant (Pmode, s2_addr,
+                                                  -GET_MODE_SIZE (SImode)));
+        }
+
+      addr1 = adjust_automodify_address (addr1, QImode, s1_addr, 0);
+      addr2 = adjust_automodify_address (addr2, QImode, s2_addr, 0);
+
+      while (bytes--)
+        {
+          emit_insn (gen_extendqisi2 (tmp1, addr1));
+          emit_insn (gen_extendqisi2 (tmp2, addr2));
+
+          emit_insn (gen_cmpeqsi_t (tmp2, const0_rtx));
+          jump = emit_jump_insn (gen_branch_true (L_end_loop_byte));
+          add_reg_note (jump, REG_BR_PROB, prob_unlikely);
+
+          emit_insn (gen_cmpeqsi_t (tmp1, tmp2));
+          if (flag_delayed_branch)
+            emit_insn (gen_zero_extendqisi2 (tmp2, gen_lowpart (QImode, tmp2)));
+          jump = emit_jump_insn (gen_branch_false (L_end_loop_byte));
+          add_reg_note (jump, REG_BR_PROB, prob_unlikely);
+
+          addr1 = adjust_address (addr1, QImode, GET_MODE_SIZE (QImode));
+          addr2 = adjust_address (addr2, QImode, GET_MODE_SIZE (QImode));
+        }
+
+      jump = emit_jump_insn (gen_jump_compact( L_end_loop_byte));
+      emit_barrier_after (jump);
+    }
+
+  addr1 = adjust_automodify_address (addr1, QImode, s1_addr, 0);
+  addr2 = adjust_automodify_address (addr2, QImode, s2_addr, 0);
+
+  emit_label (L_loop_byte);
+
+  emit_insn (gen_extendqisi2 (tmp2, addr2));
+  emit_move_insn (s2_addr, plus_constant (Pmode, s2_addr, 1));
+
+  emit_insn (gen_extendqisi2 (tmp1, addr1));
+  emit_move_insn (s1_addr, plus_constant (Pmode, s1_addr, 1));
+
+  emit_insn (gen_cmpeqsi_t (tmp2, const0_rtx));
+  jump = emit_jump_insn (gen_branch_true (L_end_loop_byte));
+  add_reg_note (jump, REG_BR_PROB, prob_unlikely);
+
+  emit_insn (gen_cmpeqsi_t (tmp1, tmp2));
+  if (flag_delayed_branch)
+    emit_insn (gen_zero_extendqisi2 (tmp2, gen_lowpart (QImode, tmp2)));
+  jump = emit_jump_insn (gen_branch_false (L_end_loop_byte));
+  add_reg_note (jump, REG_BR_PROB, prob_unlikely);
+
+  if (TARGET_SH2)
+    emit_insn (gen_dect (len, len));
+  else
+    {
+      emit_insn (gen_addsi3 (len, len, GEN_INT (-1)));
+      emit_insn (gen_tstsi_t (len, len));
+    }
+
+  jump = emit_jump_insn (gen_branch_false (L_loop_byte));
+  add_reg_note (jump, REG_BR_PROB, prob_likely);
+  /* end byte loop.  */
+
+  emit_label (L_end_loop_byte);
+
+  if (! flag_delayed_branch)
+    emit_insn (gen_zero_extendqisi2 (tmp2, gen_lowpart (QImode, tmp2)));
+  emit_insn (gen_zero_extendqisi2 (tmp1, gen_lowpart (QImode, tmp1)));
+
+  emit_label (L_return);
+
+  emit_insn (gen_subsi3 (operands[0], tmp1, tmp2));
+
+  return true;
+}
+
+/* Emit code to perform a strlen
+
+   OPERANDS[0] is the destination.
+   OPERANDS[1] is the string.
+   OPERANDS[2] is the char to search.
+   OPERANDS[3] is the alignment.  */
+bool
+sh_expand_strlen (rtx *operands)
+{
+  rtx addr1 = operands[1];
+  rtx current_addr = copy_addr_to_reg (XEXP (addr1, 0));
+  rtx start_addr = gen_reg_rtx (Pmode);
+  rtx tmp0 = gen_reg_rtx (SImode);
+  rtx tmp1 = gen_reg_rtx (SImode);
+  rtx L_return = gen_label_rtx ();
+  rtx L_loop_byte = gen_label_rtx ();
+
+  rtx jump;
+  rtx L_loop_long = gen_label_rtx ();
+  rtx L_end_loop_long = gen_label_rtx ();
+
+  int align = INTVAL (operands[3]);
+  rtx prob_likely = GEN_INT (REG_BR_PROB_BASE / 4);
+
+  emit_move_insn (operands[0], GEN_INT (-1));
+
+  /* remember start of string.  */
+  emit_move_insn (start_addr, current_addr);
+
+  if (align < 4)
+    {
+      emit_insn (gen_tstsi_t (GEN_INT (3), current_addr));
+      jump = emit_jump_insn (gen_branch_false (L_loop_byte));
+      add_reg_note (jump, REG_BR_PROB, prob_likely);
+    }
+
+  emit_move_insn (tmp0, operands[2]);
+
+  addr1 = adjust_automodify_address (addr1, SImode, current_addr, 0);
+
+  /*start long loop.  */
+  emit_label (L_loop_long);
+
+  /* tmp1 is aligned, OK to load.  */
+  emit_move_insn (tmp1, addr1);
+  emit_move_insn (current_addr, plus_constant (Pmode, current_addr, 4));
+
+  /* Is there a 0 byte ?  */
+  emit_insn (gen_cmpstr_t (tmp0, tmp1));
+
+  jump = emit_jump_insn (gen_branch_false (L_loop_long));
+  add_reg_note (jump, REG_BR_PROB, prob_likely);
+  /* end loop.  */
+
+  emit_label (L_end_loop_long);
+
+  emit_move_insn (current_addr, plus_constant (Pmode, current_addr, -4));
+
+  /* start byte loop.  */
+  addr1 = adjust_address (addr1, QImode, 0);
+
+  emit_label (L_loop_byte);
+
+  emit_insn (gen_extendqisi2 (tmp1, addr1));
+  emit_move_insn (current_addr, plus_constant (Pmode, current_addr, 1));
+
+  emit_insn (gen_cmpeqsi_t (tmp1, const0_rtx));
+  jump = emit_jump_insn (gen_branch_false (L_loop_byte));
+  add_reg_note (jump, REG_BR_PROB, prob_likely);
+
+  /* end loop.  */
+
+  emit_label (L_return);
+
+  emit_insn (gen_addsi3 (start_addr, start_addr, GEN_INT (1)));
+
+  emit_insn (gen_subsi3 (operands[0], current_addr, start_addr));
+
+  return true;
+}
+
+/* Emit code to perform a memset
+
+   OPERANDS[0] is the destination.
+   OPERANDS[1] is the size;
+   OPERANDS[2] is the char to search.
+   OPERANDS[3] is the alignment.  */
+void
+sh_expand_setmem (rtx *operands)
+{
+  rtx L_loop_byte = gen_label_rtx ();
+  rtx L_loop_word = gen_label_rtx ();
+  rtx L_return = gen_label_rtx ();
+  rtx prob_likely = GEN_INT (REG_BR_PROB_BASE / 4);
+  rtx jump;
+  rtx dest = copy_rtx (operands[0]);
+  rtx dest_addr = copy_addr_to_reg (XEXP (dest, 0));
+  rtx val = force_reg (SImode, operands[2]);
+  int align = INTVAL (operands[3]);
+  int count = 0;
+  rtx len = force_reg (SImode, operands[1]);
+
+  if (! CONST_INT_P (operands[1]))
+    return;
+
+  count = INTVAL (operands[1]);
+
+  if (CONST_INT_P (operands[2])
+      && (INTVAL (operands[2]) == 0 || INTVAL (operands[2]) == -1) && count > 8)
+    {
+      rtx lenw = gen_reg_rtx (SImode);
+
+      if (align < 4)
+        {
+          emit_insn (gen_tstsi_t (GEN_INT (3), dest_addr));
+          jump = emit_jump_insn (gen_branch_false (L_loop_byte));
+          add_reg_note (jump, REG_BR_PROB, prob_likely);
+        }
+
+      /* word count. Do we have iterations ? */
+      emit_insn (gen_lshrsi3 (lenw, len, GEN_INT (2)));
+
+      dest = adjust_automodify_address (dest, SImode, dest_addr, 0);
+
+      /* start loop.  */
+      emit_label (L_loop_word);
+
+      if (TARGET_SH2)
+        emit_insn (gen_dect (lenw, lenw));
+      else
+        {
+          emit_insn (gen_addsi3 (lenw, lenw, GEN_INT (-1)));
+          emit_insn (gen_tstsi_t (lenw, lenw));
+        }
+
+      emit_move_insn (dest, val);
+      emit_move_insn (dest_addr, plus_constant (Pmode, dest_addr,
+                                                GET_MODE_SIZE (SImode)));
+
+
+      jump = emit_jump_insn (gen_branch_false (L_loop_word));
+      add_reg_note (jump, REG_BR_PROB, prob_likely);
+      count = count % 4;
+
+      dest = adjust_address (dest, QImode, 0);
+
+      val = gen_lowpart (QImode, val);
+
+      while (count--)
+        {
+          emit_move_insn (dest, val);
+          emit_move_insn (dest_addr, plus_constant (Pmode, dest_addr,
+                                                    GET_MODE_SIZE (QImode)));
+        }
+
+      jump = emit_jump_insn (gen_jump_compact (L_return));
+      emit_barrier_after (jump);
+    }
+
+  dest = adjust_automodify_address (dest, QImode, dest_addr, 0);
+
+  /* start loop.  */
+  emit_label (L_loop_byte);
+
+  if (TARGET_SH2)
+    emit_insn (gen_dect (len, len));
+  else
+    {
+      emit_insn (gen_addsi3 (len, len, GEN_INT (-1)));
+      emit_insn (gen_tstsi_t (len, len));
+    }
+
+  val = gen_lowpart (QImode, val);
+  emit_move_insn (dest, val);
+  emit_move_insn (dest_addr, plus_constant (Pmode, dest_addr,
+                                            GET_MODE_SIZE (QImode)));
+
+  jump = emit_jump_insn (gen_branch_false (L_loop_byte));
+  add_reg_note (jump, REG_BR_PROB, prob_likely);
+
+  emit_label (L_return);
+
+  return;
+}
diff -ruN gcc-gnu-4.8.2/gcc/config/sh/sh-modes.def gcc-st40-4.8.2.140205/gcc/config/sh/sh-modes.def
--- gcc-gnu-4.8.2/gcc/config/sh/sh-modes.def	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/config/sh/sh-modes.def	2013-05-28 13:15:34.000000000 +0200
@@ -1,5 +1,6 @@
-/* SH extra machine modes. 
+/* SH extra machine modes.
    Copyright (C) 2003-2013 Free Software Foundation, Inc.
+   Copyright (c) 2013  STMicroelectronics.
 
 This file is part of GCC.
 
@@ -22,6 +23,11 @@
 /* PDI mode is used to represent a function address in a target register.  */
 PARTIAL_INT_MODE (DI);
 
+/* For software floating point comparisons.  */
+CC_MODE (CC_FP_NE);
+CC_MODE (CC_FP_GT);
+CC_MODE (CC_FP_UNLT);
+
 /* Vector modes.  */
 VECTOR_MODE  (INT, QI, 2);    /*                 V2QI */
 VECTOR_MODES (INT, 4);        /*            V4QI V2HI */
diff -ruN gcc-gnu-4.8.2/gcc/config/sh/sh.opt gcc-st40-4.8.2.140205/gcc/config/sh/sh.opt
--- gcc-gnu-4.8.2/gcc/config/sh/sh.opt	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/config/sh/sh.opt	2013-05-31 10:50:12.000000000 +0200
@@ -1,6 +1,7 @@
 ; Options for the SH port of the compiler.
 
 ; Copyright (C) 2005-2013 Free Software Foundation, Inc.
+; Copyright (c) 2011  STMicroelectronics.
 ;
 ; This file is part of GCC.
 ;
@@ -21,7 +22,7 @@
 ;; Used for various architecture options.
 Mask(SH_E)
 
-;; Set if the default precision of th FPU is single.
+;; Set if the default precision of the FPU is single.
 Mask(FPU_SINGLE)
 
 ;; Set if the a double-precision FPU is present but is restricted to
@@ -208,9 +209,9 @@
 Target Report Var(TARGET_ACCUMULATE_OUTGOING_ARGS) Init(1)
 Reserve space for outgoing arguments in the function prologue
 
-madjust-unroll
-Target Ignore
-Does nothing.  Preserved for backward compatibility.
+malign-small-blocks=
+Target RejectNegative Joined UInteger Var(sh_align_small_blocks) Init(32)
+Honor align-jump-loops for basic block bigger than number of instructions.
 
 mb
 Target Report RejectNegative InverseMask(LITTLE_ENDIAN)
@@ -248,9 +249,13 @@
 Target Report RejectNegative Mask(ALIGN_DOUBLE)
 Align doubles at 64-bit boundaries
 
+mdb-page-bug
+Target Report RejectNegative Var(TARGET_DBHWBUG)
+Undocumented
+
 mdiv=
 Target RejectNegative Joined Var(sh_div_str) Init("")
-Division strategy, one of: call, call2, fp, inv, inv:minlat, inv20u, inv20l, inv:call, inv:call2, inv:fp, call-div1, call-fp, call-table
+Division strategy, one of: call, call2, fp, inv, inv:minlat, inv20u, inv20l, inv:call, inv:call2, inv:fp, call-div1, call-fp, call-table, call-pre1
 
 mdivsi3_libfunc=
 Target RejectNegative Joined Var(sh_divsi3_libfunc) Init("")
@@ -260,6 +265,10 @@
 Target RejectNegative Mask(FMOVD)
 Enable the use of 64-bit floating point registers in fmov instructions.  See -mdalign if 64-bit alignment is required.
 
+mfldi
+Target Var(TARGET_FLDI) Init(1)
+Allow the use of fldi0/1 instructions.
+
 mfixed-range=
 Target RejectNegative Joined Var(sh_fixed_range_str)
 Specify range of registers to make fixed
@@ -296,6 +305,14 @@
 Target Report RejectNegative Mask(LITTLE_ENDIAN)
 Generate code in little endian mode
 
+mlate-r0r3-to-reg-mul
+Target RejectNegative Var(TARGET_R0R3_TO_REG_MUL, 1) VarExists
+Assume availability of integer multiply instruction (src only opd in r0-r3), but only try to use this instruction after register allocation.
+
+mdead-delay
+Target Report Mask(DEAD_DELAY)
+Try to eliminate a dead delay slot instruction.
+
 mnomacsave
 Target Report RejectNegative Mask(NOMACSAVE)
 Mark MAC register as call-clobbered
@@ -314,6 +331,10 @@
 Target Report Mask(PT_FIXED) Condition(SUPPORT_ANY_SH5)
 Assume pt* instructions won't trap
 
+mr0r3-to-reg-mul
+Target Var(TARGET_R0R3_TO_REG_MUL, 2) Init(-1)
+Assume availability of integer multiply instruction (src only opd in r0-r3)
+
 mrelax
 Target Report RejectNegative Mask(RELAX)
 Shorten address references during linking
@@ -334,10 +355,6 @@
 Target Report RejectNegative Var(TARGET_ENABLE_TAS)
 Use tas.b instruction for __atomic_test_and_set
 
-mspace
-Target RejectNegative Alias(Os)
-Deprecated.  Use -Os instead
-
 multcost=
 Target RejectNegative Joined UInteger Var(sh_multcost) Init(-1)
 Cost to assume for a multiply insn
diff -ruN gcc-gnu-4.8.2/gcc/config/sh/sh-protos.h gcc-st40-4.8.2.140205/gcc/config/sh/sh-protos.h
--- gcc-gnu-4.8.2/gcc/config/sh/sh-protos.h	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/config/sh/sh-protos.h	2014-01-29 12:57:17.000000000 +0100
@@ -2,6 +2,7 @@
    Copyright (C) 1993-2013 Free Software Foundation, Inc.
    Contributed by Steve Chamberlain (sac@cygnus.com).
    Improved by Jim Wilson (wilson@cygnus.com).
+   Copyright (c) 2011  STMicroelectronics.
 
 This file is part of GCC.
 
@@ -23,8 +24,13 @@
 #define GCC_SH_PROTOS_H
 
 enum sh_function_kind {
-  /* A function with normal C ABI  */
+  /* A function with normal C ABI, or an SH1..SH4 sfunc that may resolved via
+     a PLT.  */
   FUNCTION_ORDINARY,
+  /* A function that is a bit large to put it in every calling dso, but that's
+     typically used often enough so that calling via GOT makes sense for
+     speed.  */
+  SFUNC_FREQUENT,
   /* A special function that guarantees that some otherwise call-clobbered
      registers are not clobbered.  These can't go through the SH5 resolver,
      because it only saves argument passing registers.  */
@@ -102,6 +108,7 @@
 extern const char *output_far_jump (rtx, rtx);
 
 extern rtx sfunc_uses_reg (rtx);
+extern int sh_jump_align (rtx);
 extern int barrier_align (rtx);
 extern int sh_loop_align (rtx);
 extern bool fp_zero_operand (rtx);
@@ -116,6 +123,10 @@
 extern void output_pic_addr_const (FILE *, rtx);
 extern bool expand_block_move (rtx *);
 extern void prepare_move_operands (rtx[], enum machine_mode mode);
+extern bool sh_expand_cmpstr (rtx *);
+extern bool sh_expand_cmpnstr (rtx *);
+extern bool sh_expand_strlen (rtx *);
+extern void sh_expand_setmem (rtx *);
 extern enum rtx_code prepare_cbranch_operands (rtx *, enum machine_mode mode,
 					       enum rtx_code comparison);
 extern void expand_cbranchsi4 (rtx *operands, enum rtx_code comparison, int);
@@ -149,16 +160,25 @@
 extern void expand_sf_binop (rtx (*)(rtx, rtx, rtx, rtx), rtx *);
 extern void expand_df_unop (rtx (*)(rtx, rtx, rtx), rtx *);
 extern void expand_df_binop (rtx (*)(rtx, rtx, rtx, rtx), rtx *);
-extern int sh_insn_length_adjustment (rtx);
+extern void expand_sfunc_unop (enum machine_mode, rtx (*) (rtx, rtx),
+			       const char *, enum rtx_code code, rtx *);
+extern void expand_sfunc_binop (enum machine_mode, rtx (*) (rtx, rtx),
+				const char *, enum rtx_code code, rtx *);
+extern int sh_insn_length_adjustment (rtx, const int);
+extern int sh_insn_length_alignment (rtx);
 extern bool sh_can_redirect_branch (rtx, rtx);
 extern void sh_expand_unop_v2sf (enum rtx_code, rtx, rtx);
 extern void sh_expand_binop_v2sf (enum rtx_code, rtx, rtx, rtx);
 extern bool sh_expand_t_scc (rtx *);
+extern void sh_expand_lround (rtx, rtx, bool);
 extern rtx sh_gen_truncate (enum machine_mode, rtx, int);
 extern bool sh_vector_mode_supported_p (enum machine_mode);
+extern bool stack_protector_block (rtx, rtx);
 extern bool sh_cfun_trap_exit_p (void);
 extern rtx sh_find_equiv_gbr_addr (rtx cur_insn, rtx mem);
 extern int sh_eval_treg_value (rtx op);
+extern HOST_WIDE_INT sh_disp_addr_displacement (rtx mem_op);
+extern int sh_max_mov_insn_displacement (machine_mode mode, bool consider_sh2a);
 
 /* Result value of sh_find_set_of_reg.  */
 struct set_of_reg
@@ -205,6 +225,7 @@
 #ifdef HARD_CONST
 extern void fpscr_set_from_mem (int, HARD_REG_SET);
 #endif
+extern void emit_fpu_flip (void);
 
 extern void sh_pr_interrupt (struct cpp_reader *);
 extern void sh_pr_trapa (struct cpp_reader *);
@@ -227,4 +248,16 @@
 extern void sh_fix_range (const char *);
 extern bool sh_hard_regno_mode_ok (unsigned int, enum machine_mode);
 extern bool sh_can_use_simple_return_p (void);
+
+extern int sh_asm_count (const char *, int *);
+extern int sh_align_function_log (tree);
+extern bool sh_can_use_simple_return_p (void);
+
+extern bool short_cbranch_p (rtx insn);
+extern bool med_cbranch_p (rtx insn);
+extern bool braf_cbranch_p (rtx insn);
+
+extern bool med_branch_p (rtx insn);
+extern bool braf_branch_p (rtx insn);
+
 #endif /* ! GCC_SH_PROTOS_H */
diff -ruN gcc-gnu-4.8.2/gcc/config/sh/superh.h gcc-st40-4.8.2.140205/gcc/config/sh/superh.h
--- gcc-gnu-4.8.2/gcc/config/sh/superh.h	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/config/sh/superh.h	2014-01-24 09:25:59.000000000 +0100
@@ -1,5 +1,6 @@
 /* Definitions of target machine for gcc for Super-H using sh-superh-elf.
    Copyright (C) 2001-2013 Free Software Foundation, Inc.
+   Copyright (c) 2013  STMicroelectronics.
 
 This file is part of GNU CC.
 
@@ -78,11 +79,6 @@
 #undef SUBTARGET_ASM_SPEC
 #define SUBTARGET_ASM_SPEC "%{m4-100*|m4-200*:-isa=sh4} %{m4-400|m4-340:-isa=sh4-nommu-nofpu} %{m4-500:-isa=sh4-nofpu} %(asruntime)"
 
-/* Override the SUBTARGET_ASM_RELAX_SPEC so it doesn't interfere with the
-   runtime support by adding -isa=sh4 in the wrong place.  */
-#undef SUBTARGET_ASM_RELAX_SPEC
-#define SUBTARGET_ASM_RELAX_SPEC "%{!m4-100*:%{!m4-200*:%{!m4-300*:%{!m4-340:%{!m4-400:%{!m4-500:-isa=sh4}}}}}}"
-
 /* Create the CC1_SPEC to add the runtime support */
 #undef CC1_SPEC
 #define CC1_SPEC "%(cc1runtime)"
@@ -90,10 +86,18 @@
 #undef CC1PLUS_SPEC
 #define CC1PLUS_SPEC "%(cc1runtime)"
 
-
 /* Override the LIB_SPEC to add the runtime support */
+/* board_link defines both --defsyms and libraries. Libraries should be
+   imported from LIB_SPEC that goes at the end of the command line, but
+   redefines user --defsyms, that should to into LINK_SPEC. For the BSP
+   libraries to be added to the command line, make sure that the board_spec
+   is included.  */
 #undef LIB_SPEC
-#define LIB_SPEC "%{!shared:%{!symbolic:%(libruntime) -lc}} %{pg:-lprofile -lc}"
+#define LIB_SPEC "%{!shared:%{!symbolic:%{pg:-lprofile} \
+%{"PLUGIN_COND": \
+%{!nostdlib:%{!nodefaultlibs:%:pass-through-libs(%(board_link))}} \
+}"PLUGIN_COND_CLOSE" \
+%(libruntime) -lc}}"
 
 /* Override STARTFILE_SPEC to add profiling and MMU support.  */
 #undef STARTFILE_SPEC
@@ -101,4 +105,15 @@
   "%{!shared: %{!m4-400*:%{!m4-340*: %{pg:gcrt1-mmu.o%s}%{!pg:crt1-mmu.o%s}}}} \
    %{!shared: %{m4-340*|m4-400*: %{pg:gcrt1.o%s}%{!pg:crt1.o%s}}} \
    crti.o%s \
-   %{!shared:crtbegin.o%s} %{shared:crtbeginS.o%s}"
+   %{!shared:crtbegin.o%s trap-handler.o%s} %{shared:crtbeginS.o%s}"
+
+#undef SUBTARGET_OVERRIDE_OPTIONS
+#define SUBTARGET_OVERRIDE_OPTIONS					\
+  do									\
+    {									\
+      /* Don't emit DWARF3/4 unless specifically selected.  The ST40    \
+	 debuggers do not yet support DWARF 3/4.  */                    \
+      if (!global_options_set.x_dwarf_version)                          \
+         dwarf_version = 3;                                             \
+    }									\
+  while (0)
diff -ruN gcc-gnu-4.8.2/gcc/config/sh/t-mlib-sh4-300 gcc-st40-4.8.2.140205/gcc/config/sh/t-mlib-sh4-300
--- gcc-gnu-4.8.2/gcc/config/sh/t-mlib-sh4-300	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/config/sh/t-mlib-sh4-300	2013-05-28 13:15:34.000000000 +0200
@@ -0,0 +1 @@
+ML_sh4_300=m4-300/
diff -ruN gcc-gnu-4.8.2/gcc/config/sh/t-sh gcc-st40-4.8.2.140205/gcc/config/sh/t-sh
--- gcc-gnu-4.8.2/gcc/config/sh/t-sh	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/config/sh/t-sh	2013-10-25 10:18:36.000000000 +0200
@@ -1,4 +1,5 @@
 # Copyright (C) 1993-2013 Free Software Foundation, Inc.
+# Copyright (c) 2013  STMicroelectronics.#
 #
 # This file is part of GCC.
 #
@@ -21,6 +22,10 @@
 	$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
 		$(srcdir)/config/sh/sh-c.c
 
+sh-mem.o: $(srcdir)/config/sh/sh-mem.cc \
+  $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(TM_H) $(TM_P_H)
+	$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<
+
 DEFAULT_ENDIAN = $(word 1,$(TM_ENDIAN_CONFIG))
 OTHER_ENDIAN = $(word 2,$(TM_ENDIAN_CONFIG))
 
diff -ruN gcc-gnu-4.8.2/gcc/config.gcc gcc-st40-4.8.2.140205/gcc/config.gcc
--- gcc-gnu-4.8.2/gcc/config.gcc	2013-10-16 16:17:23.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/config.gcc	2013-10-17 12:15:29.000000000 +0200
@@ -1,5 +1,6 @@
 # GCC target-specific configuration file.
 # Copyright (C) 1997-2013 Free Software Foundation, Inc.
+# Copyright (c) 2013  STMicroelectronics.
 
 #This file is part of GCC.
 
@@ -459,6 +460,7 @@
 	cpu_type=sh
 	need_64bit_hwint=yes
 	extra_options="${extra_options} fused-madd.opt"
+	extra_objs="${extra_objs} sh-mem.o"
 	;;
 v850*-*-*)
 	cpu_type=v850
@@ -1259,7 +1261,7 @@
 	gnu_ld=yes
 	;;
 i[34567]86-*-linux* | i[34567]86-*-kfreebsd*-gnu | i[34567]86-*-knetbsd*-gnu | i[34567]86-*-gnu* | i[34567]86-*-kopensolaris*-gnu)
-			# Intel 80386's running GNU/*
+			# Intel 80386\'s running GNU/*
 			# with ELF format using glibc 2
 	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h gnu-user.h glibc-stdint.h"
 	case ${target} in
@@ -3729,7 +3731,7 @@
 
 	powerpc*-*-* | rs6000-*-*)
 		# FIXME: The PowerPC port uses the value set at compile time,
-		# although it's only cosmetic.
+		# although it\'s only cosmetic.
 		if test "x$with_cpu" != x
 		then
 			target_cpu_default2="\\\"$with_cpu\\\""
diff -ruN gcc-gnu-4.8.2/gcc/configure gcc-st40-4.8.2.140205/gcc/configure
--- gcc-gnu-4.8.2/gcc/configure	2013-10-16 16:17:23.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/configure	2013-10-17 12:15:29.000000000 +0200
@@ -5,6 +5,7 @@
 # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 # 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software
 # Foundation, Inc.
+# Copyright (c) 2013  STMicroelectronics.
 #
 # This configure script is free software; the Free Software Foundation
 # gives unlimited permission to copy, distribute and modify it.
@@ -11637,6 +11638,16 @@
 	CROSS="-DCROSS_DIRECTORY_STRUCTURE"
 	ALL=all.cross
 	SYSTEM_HEADER_DIR=$build_system_header_dir
+
+ 	# For builds with an in-tree newlib, then the headers are not
+ 	# copied to build_system_header_dir, so things like limits.h
+ 	# won't work unless we point at the real headers.
+ 	if test "$with_newlib" = yes \
+ 		&& (test -z "$with_headers" || test "$with_headers" = yes) \
+ 		&& test -d $srcdir/../newlib/libc/include; then
+ 	  SYSTEM_HEADER_DIR="\$(abs_srcdir)/../newlib/libc/include"
+ 	fi
+
 	case "$host","$target" in
 	# Darwin crosses can use the host system's libraries and headers,
 	# because of the fat library support.  Of course, it must be the
@@ -26727,6 +26738,8 @@
   else
     target_header_dir="${with_sysroot}${native_system_header_dir}"
   fi
+elif test x$host != x$build && test "x$with_build_sysroot" != "x"; then
+  target_header_dir="${with_build_sysroot}${native_system_header_dir}"
 else
   target_header_dir=${native_system_header_dir}
 fi
diff -ruN gcc-gnu-4.8.2/gcc/configure.ac gcc-st40-4.8.2.140205/gcc/configure.ac
--- gcc-gnu-4.8.2/gcc/configure.ac	2013-10-16 16:17:23.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/configure.ac	2013-10-17 12:15:29.000000000 +0200
@@ -2,6 +2,7 @@
 # Process this file with autoconf to generate a configuration script.
 
 # Copyright (C) 1997-2013 Free Software Foundation, Inc.
+# Copyright (c) 2013  STMicroelectronics.
 
 #This file is part of GCC.
 
@@ -1821,6 +1822,16 @@
 	CROSS="-DCROSS_DIRECTORY_STRUCTURE"
 	ALL=all.cross
 	SYSTEM_HEADER_DIR=$build_system_header_dir
+ 
+ 	# For builds with an in-tree newlib, then the headers are not
+ 	# copied to build_system_header_dir, so things like limits.h
+ 	# won't work unless we point at the real headers.
+ 	if test "$with_newlib" = yes \
+ 		&& (test -z "$with_headers" || test "$with_headers" = yes) \
+ 		&& test -d $srcdir/../newlib/libc/include; then
+ 	  SYSTEM_HEADER_DIR="\$(abs_srcdir)/../newlib/libc/include"
+ 	fi
+ 
 	case "$host","$target" in
 	# Darwin crosses can use the host system's libraries and headers,
 	# because of the fat library support.  Of course, it must be the
@@ -4713,6 +4724,8 @@
   else
     target_header_dir="${with_sysroot}${native_system_header_dir}"
   fi
+elif test x$host != x$build && test "x$with_build_sysroot" != "x"; then
+  target_header_dir="${with_build_sysroot}${native_system_header_dir}"
 else
   target_header_dir=${native_system_header_dir}
 fi
diff -ruN gcc-gnu-4.8.2/gcc/convert.c gcc-st40-4.8.2.140205/gcc/convert.c
--- gcc-gnu-4.8.2/gcc/convert.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/convert.c	2013-05-28 13:15:34.000000000 +0200
@@ -1,5 +1,6 @@
 /* Utility routines for data type conversion for GCC.
    Copyright (C) 1987-2013 Free Software Foundation, Inc.
+   Copyright (c) 2013  STMicroelectronics.
 
 This file is part of GCC.
 
diff -ruN gcc-gnu-4.8.2/gcc/cp/ChangeLog.STM gcc-st40-4.8.2.140205/gcc/cp/ChangeLog.STM
--- gcc-gnu-4.8.2/gcc/cp/ChangeLog.STM	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/cp/ChangeLog.STM	2013-05-28 13:15:34.000000000 +0200
@@ -0,0 +1,9 @@
+2011-03-21  Christian Bruel  <christian.bruel@st.com>
+
+	Backport from trunk: PH_CPP 82Y23
+	* parser.c: (cp_parser_primary_expressio): Don't warn.
+
+2009-03-26  Christian Bruel  <christian.bruel@st.com>
+
+	INSbl27506
+	* name-lookup.c: (do_nonmember_using_decl): Fixed error handling.
diff -ruN gcc-gnu-4.8.2/gcc/cp/name-lookup.c gcc-st40-4.8.2.140205/gcc/cp/name-lookup.c
--- gcc-gnu-4.8.2/gcc/cp/name-lookup.c	2013-10-16 16:17:23.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/cp/name-lookup.c	2013-10-17 12:15:29.000000000 +0200
@@ -1,6 +1,7 @@
 /* Definitions for C++ name lookup routines.
    Copyright (C) 2003-2013 Free Software Foundation, Inc.
    Contributed by Gabriel Dos Reis <gdr@integrable-solutions.net>
+   Copyright (c) 2013  STMicroelectronics.
 
 This file is part of GCC.
 
@@ -2565,7 +2566,11 @@
     {
       *newtype = decls.type;
       if (oldtype && *newtype && !decls_match (oldtype, *newtype))
+	{
 	error ("%qD is already declared in this scope", name);
+	  *newtype = NULL_TREE;
+	}
+
     }
 
     /* If *newval is empty, shift any class or enumeration name down.  */
diff -ruN gcc-gnu-4.8.2/gcc/cppdefault.h gcc-st40-4.8.2.140205/gcc/cppdefault.h
--- gcc-gnu-4.8.2/gcc/cppdefault.h	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/cppdefault.h	2013-05-28 13:15:34.000000000 +0200
@@ -3,6 +3,7 @@
    Contributed by Per Bothner, 1994-95.
    Based on CCCP program by Paul Rubin, June 1986
    Adapted to ANSI C, Richard Stallman, Jan 1987
+   Copyright (c) 2013  STMicroelectronics.
 
    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
@@ -68,4 +69,11 @@
 /* Return true if the toolchain is relocated.  */
 bool cpp_relocated (void);
 
+extern const char cpp_STANDARD_EXEC_PREFIX[];
+extern const size_t cpp_STANDARD_EXEC_PREFIX_len;
+extern const char *gcc_exec_prefix;
+
+/* Return true if the toolchain is relocated.  */
+bool cpp_relocated (void);
+
 #endif /* ! GCC_CPPDEFAULT_H */
diff -ruN gcc-gnu-4.8.2/gcc/defaults.h gcc-st40-4.8.2.140205/gcc/defaults.h
--- gcc-gnu-4.8.2/gcc/defaults.h	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/defaults.h	2013-05-28 13:15:34.000000000 +0200
@@ -1,6 +1,7 @@
 /* Definitions of various defaults for tm.h macros.
    Copyright (C) 1992-2013 Free Software Foundation, Inc.
    Contributed by Ron Guilmette (rfg@monkeys.com)
+   Copyright (c) 2009  STMicroelectronics.
 
 This file is part of GCC.
 
@@ -309,6 +310,15 @@
 #define TARGET_USES_WEAK_UNWIND_INFO 0
 #endif
 
+/* Use leb128 encoding based on command line options.  */
+#ifndef TARGET_USES_LEB128
+#ifdef HAVE_AS_LEB128
+#define TARGET_USES_LEB128 1
+#else
+#define TARGET_USES_LEB128 0
+#endif
+#endif
+
 /* By default, there is no prefix on user-defined symbols.  */
 #ifndef USER_LABEL_PREFIX
 #define USER_LABEL_PREFIX ""
@@ -871,6 +881,10 @@
 #define ASM_PREFERRED_EH_DATA_FORMAT(CODE,GLOBAL)  DW_EH_PE_absptr
 #endif
 
+#ifndef ASM_ALIGN_FUNCTION_LOG 
+#define ASM_ALIGN_FUNCTION_LOG(DECL) align_functions_log
+#endif
+
 /* By default, the C++ compiler will use the lowest bit of the pointer
    to function to indicate a pointer-to-member-function points to a
    virtual member function.  However, if FUNCTION_BOUNDARY indicates
diff -ruN gcc-gnu-4.8.2/gcc/doc/invoke.texi gcc-st40-4.8.2.140205/gcc/doc/invoke.texi
--- gcc-gnu-4.8.2/gcc/doc/invoke.texi	2013-10-16 16:17:23.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/doc/invoke.texi	2013-10-17 12:15:29.000000000 +0200
@@ -1,4 +1,5 @@
 @c Copyright (C) 1988-2013 Free Software Foundation, Inc.
+@c Copyright (c) 2011  STMicroelectronics.
 @c This is part of the GCC manual.
 @c For copying conditions, see the file gcc.texi.
 
@@ -234,6 +235,7 @@
 -pedantic-errors @gol
 -w  -Wextra  -Wall  -Waddress  -Waggregate-return  @gol
 -Waggressive-loop-optimizations -Warray-bounds @gol
+-Wbranch-probabilities-computation
 -Wno-attributes -Wno-builtin-macro-redefined @gol
 -Wc++-compat -Wc++11-compat -Wcast-align  -Wcast-qual  @gol
 -Wchar-subscripts -Wclobbered  -Wcomment @gol
@@ -254,7 +256,7 @@
 -Wmain -Wmaybe-uninitialized -Wmissing-braces  -Wmissing-field-initializers @gol
 -Wmissing-include-dirs @gol
 -Wno-mudflap @gol
--Wno-multichar  -Wnonnull  -Wno-overflow @gol
+-Wno-multichar -Wnonnull -Wnon-finite-math -Wno-overflow @gol
 -Woverlength-strings  -Wpacked  -Wpacked-bitfield-compat  -Wpadded @gol
 -Wparentheses  -Wpedantic-ms-format -Wno-pedantic-ms-format @gol
 -Wpointer-arith  -Wno-pointer-to-int-cast @gol
@@ -404,6 +406,7 @@
 -fschedule-insns -fschedule-insns2 -fsection-anchors @gol
 -fselective-scheduling -fselective-scheduling2 @gol
 -fsel-sched-pipelining -fsel-sched-pipelining-outer-loops @gol
+-fcse-sincos @gol
 -fshrink-wrap -fsignaling-nans -fsingle-precision-constant @gol
 -fsplit-ivs-in-unroller -fsplit-wide-types -fstack-protector @gol
 -fstack-protector-all -fstrict-aliasing -fstrict-overflow @gol
@@ -893,14 +896,16 @@
 -m2a-nofpu -m2a-single-only -m2a-single -m2a @gol
 -m3  -m3e @gol
 -m4-nofpu  -m4-single-only  -m4-single  -m4 @gol
+-m4-300-nofpu  -m4-300-single-only  -m4-300-single  -m4-300 @gol
 -m4a-nofpu -m4a-single-only -m4a-single -m4a -m4al @gol
 -m5-64media  -m5-64media-nofpu @gol
 -m5-32media  -m5-32media-nofpu @gol
 -m5-compact  -m5-compact-nofpu @gol
--mb  -ml  -mdalign  -mrelax @gol
+-mb  -ml  -mdalign  -mrelax -malign-small-blocks=@var{block-size} @gol
+-mfldi -mno-fldi -mmdead-delay @gol
 -mbigtable -mfmovd -mhitachi -mrenesas -mno-renesas -mnomacsave @gol
--mieee -mno-ieee -mbitops  -misize  -minline-ic_invalidate -mpadstruct @gol
--mspace -mprefergot  -musermode -multcost=@var{number} -mdiv=@var{strategy} @gol
+-mieee -mno-ieee  -mbitops  -misize  -minline-ic_invalidate -mpadstruct @gol
+-mprefergot  -musermode -multcost=@var{number} -mdiv=@var{strategy} @gol
 -mdivsi3_libfunc=@var{name} -mfixed-range=@var{register-range} @gol
 -mindexed-addressing -mgettrcost=@var{number} -mpt-fixed @gol
 -maccumulate-outgoing-args -minvalid-symbols @gol
@@ -2913,6 +2918,11 @@
 Generate C header describing the largest structure that is passed by
 value, if any.
 
+@item -Wbranch-probabilities-computation
+@opindex Wbranch-probabilities-computation
+Warn if edge and/or basic block counts computation is not consistent
+when using the @option{-fbranch-probabilities} option.
+
 @end table
 
 @node Language Independent Options
@@ -3129,6 +3139,7 @@
 -Wmaybe-uninitialized @gol
 -Wmissing-braces @r{(only for C/ObjC)} @gol
 -Wnonnull  @gol
+-Wnon-finite-math @gol
 -Wparentheses  @gol
 -Wpointer-sign  @gol
 -Wreorder   @gol
@@ -3377,6 +3388,11 @@
 @option{-Wnonnull} is included in @option{-Wall} and @option{-Wformat}.  It
 can be disabled with the @option{-Wno-nonnull} option.
 
+@item -Wnon-finite-math
+@opindex Wnon-finite-math
+@opindex Wno-non-finite-math
+Warn if non-finite builtins are used with -ffinite-math-only.
+
 @item -Winit-self @r{(C, C++, Objective-C and Objective-C++ only)}
 @opindex Winit-self
 @opindex Wno-init-self
@@ -7354,6 +7370,10 @@
 When pipelining loops during selective scheduling, also pipeline outer loops.
 This option has no effect unless @option{-fsel-sched-pipelining} is turned on.
 
+@item -fcse-sincos
+@opindex fcse-sincos
+Disable merging of the @samp{sin}, @samp{cos} operations.
+
 @item -fshrink-wrap
 @opindex fshrink-wrap
 Emit function prologues only before parts of the function that need it,
@@ -10428,6 +10448,10 @@
 designated output file of this compilation.  This puts the argument
 into the sequence of arguments that @samp{%o} substitutes.
 
+@item %N
+If the target supports multilibs substitute the current multilib directory
+otherwise substitute @samp{.}.
+
 @item %o
 Substitutes the names of all the output files, with spaces
 automatically placed around them.  You should write spaces
@@ -10566,11 +10590,11 @@
 
 @table @code
 @item @code{getenv}
-The @code{getenv} spec function takes two arguments: an environment
-variable name and a string.  If the environment variable is not
-defined, a fatal error is issued.  Otherwise, the return value is the
-value of the environment variable concatenated with the string.  For
-example, if @env{TOPDIR} is defined as @file{/path/to/top}, then:
+The @code{getenv} spec function takes two or more arguments: an environment
+variable name and a list of strings.  If the environment variable is not
+defined, a fatal error is issued.  Otherwise, the return value is the value
+of the environment variable concatenated with the strings.  For example, if
+@env{TOPDIR} is defined as @file{/path/to/top}, then:
 
 @smallexample
 %:getenv(TOPDIR /include)
@@ -18558,6 +18582,24 @@
 @opindex m4
 Generate code for the SH4.
 
+@item -m4-300-nofpu
+@opindex m4-300-nofpu
+Generate code for the ST40-300 without a floating-point unit.
+
+@item -m4-300-single-only
+@opindex m4-300-single-only
+Generate code for the ST40-300 with a floating-point unit that only
+supports single-precision arithmetic.
+
+@item -m4-300-single
+@opindex m4-300-single
+Generate code for the ST40-300 assuming the floating-point unit is in
+single-precision mode by default.
+
+@item -m4-300
+@opindex m4-300
+Generate code for the ST40-300.
+
 @item -m4a-nofpu
 @opindex m4a-nofpu
 Generate code for the SH4al-dsp, or for a SH4a in such a way that the
@@ -18611,6 +18653,16 @@
 @opindex mbitops
 Enable the use of bit manipulation instructions on SH2A.
 
+@item -mdead-delay
+@opindex mdead-delay
+Try to eliminate dead delay slot instructions.
+
+@item -mfldi
+@itemx -mno-fldfi
+@opindex mfldi
+@opindex mno-fldi
+Enable or disable the use of the instruction @code{fldi0} and @code{fldi1}. When disabled floating point zero/one constants are loaded from the constant pool. Default is enabled.
+
 @item -mfmovd
 @opindex mfmovd
 Enable the use of the instruction @code{fmovd}.  Check @option{-mdalign} for
@@ -18739,10 +18791,6 @@
 processors the @code{tas.b} instruction must be used with caution since it
 can result in data corruption for certain cache configurations.
 
-@item -mspace
-@opindex mspace
-Optimize for space instead of speed.  Implied by @option{-Os}.
-
 @item -mprefergot
 @opindex mprefergot
 When generating position-independent code, emit function calls using
@@ -18872,6 +18920,11 @@
 two registers separated by a dash.  Multiple register ranges can be
 specified separated by a comma.
 
+@item -malign-small-blocks=@var{number}
+@opindex align-small-blocks=@var{number}
+Set the size among which basic blocks are aligned on cache line boundaries.
+Default is 16 bytes. 0 means default alignment.
+
 @item -mindexed-addressing
 @opindex mindexed-addressing
 Enable the use of the indexed addressing mode for SHmedia32/SHcompact.
diff -ruN gcc-gnu-4.8.2/gcc/doc/md.texi gcc-st40-4.8.2.140205/gcc/doc/md.texi
--- gcc-gnu-4.8.2/gcc/doc/md.texi	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/doc/md.texi	2013-05-28 13:15:34.000000000 +0200
@@ -1,4 +1,5 @@
 @c Copyright (C) 1988-2013 Free Software Foundation, Inc.
+@c Copyright (c) 2013  STMicroelectronics.
 @c This is part of the GCC manual.
 @c For copying conditions, see the file gcc.texi.
 
@@ -3292,6 +3293,37 @@
 
 @end table
 
+@item SH---@file{config/sh/constraints.md}
+@table @code
+@item c
+FPSCR. Floating-point status/control register
+
+@item d
+Any 64-bit Floating-point register
+
+@item f
+Any 32-bit Floating-point register
+
+@item l
+PR register
+
+@item t
+T bit from SR. Status register
+
+@item w
+FR0 floating-point register
+
+@item x
+MAC register (MACH and MACL)
+
+@item y
+FPUL register
+
+@item z
+R0 register
+
+@end table
+
 @item SPU---@file{config/spu/spu.h}
 @table @code
 @item a
diff -ruN gcc-gnu-4.8.2/gcc/doc/tm.texi gcc-st40-4.8.2.140205/gcc/doc/tm.texi
--- gcc-gnu-4.8.2/gcc/doc/tm.texi	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/doc/tm.texi	2013-05-28 13:15:34.000000000 +0200
@@ -3460,6 +3460,13 @@
 linkage is necessary.  The default is @code{0}.
 @end defmac
 
+@defmac TARGET_USES_LEB128
+A C expression that evaluates to true if the target requires leb128
+to be used for dwarf compression.  Define it to be @code{1} if leb128
+linkage is necessary.  The default is @code{1} if @code{HAVE_AS_LEB128}
+is defined.
+@end defmac
+
 @node Stack Checking
 @subsection Specifying How Stack Checking is Done
 
@@ -9737,10 +9744,10 @@
 @code{num_modes_for_mode_switching[@var{entity}] - 1}.
 @end defmac
 
-@defmac EMIT_MODE_SET (@var{entity}, @var{mode}, @var{hard_regs_live})
+@defmac EMIT_MODE_SET (@var{entity}, @var{mode}, @var{flip}, @var{hard_regs_live})
 Generate one or more insns to set @var{entity} to @var{mode}.
 @var{hard_reg_live} is the set of hard registers live at the point where
-the insn(s) are to be inserted.
+the insn(s) are to be inserted. @var{flip} is a boolean to indicate that current mode can be flipped.
 @end defmac
 
 @node Target Attributes
diff -ruN gcc-gnu-4.8.2/gcc/doc/tm.texi.in gcc-st40-4.8.2.140205/gcc/doc/tm.texi.in
--- gcc-gnu-4.8.2/gcc/doc/tm.texi.in	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/doc/tm.texi.in	2013-05-28 13:15:34.000000000 +0200
@@ -3428,6 +3428,13 @@
 linkage is necessary.  The default is @code{0}.
 @end defmac
 
+@defmac TARGET_USES_LEB128
+A C expression that evaluates to true if the target requires leb128
+to be used for dwarf compression.  Define it to be @code{1} if leb128
+linkage is necessary.  The default is @code{1} if @code{HAVE_AS_LEB128}
+is defined.
+@end defmac
+
 @node Stack Checking
 @subsection Specifying How Stack Checking is Done
 
@@ -9600,10 +9607,10 @@
 @code{num_modes_for_mode_switching[@var{entity}] - 1}.
 @end defmac
 
-@defmac EMIT_MODE_SET (@var{entity}, @var{mode}, @var{hard_regs_live})
+@defmac EMIT_MODE_SET (@var{entity}, @var{mode}, @var{flip}, @var{hard_regs_live})
 Generate one or more insns to set @var{entity} to @var{mode}.
 @var{hard_reg_live} is the set of hard registers live at the point where
-the insn(s) are to be inserted.
+the insn(s) are to be inserted. @var{flip} is a boolean to indicate that current mode can be flipped.
 @end defmac
 
 @node Target Attributes
diff -ruN gcc-gnu-4.8.2/gcc/dwarf2asm.c gcc-st40-4.8.2.140205/gcc/dwarf2asm.c
--- gcc-gnu-4.8.2/gcc/dwarf2asm.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/dwarf2asm.c	2013-05-28 13:15:34.000000000 +0200
@@ -1,5 +1,6 @@
 /* Dwarf2 assembler output helper routines.
    Copyright (C) 2001-2013 Free Software Foundation, Inc.
+   Copyright (c) 2013  STMicroelectronics.
 
 This file is part of GCC.
 
@@ -590,31 +591,33 @@
 
   va_start (ap, comment);
 
-#ifdef HAVE_AS_LEB128
-  fputs ("\t.uleb128 ", asm_out_file);
-  fprint_whex (asm_out_file, value);
-
-  if (flag_debug_asm && comment)
+  if (TARGET_USES_LEB128)
     {
-      fprintf (asm_out_file, "\t%s ", ASM_COMMENT_START);
-      vfprintf (asm_out_file, comment, ap);
+      fputs ("\t.uleb128 ", asm_out_file);
+      fprint_whex (asm_out_file, value);
+
+      if (flag_debug_asm && comment)
+	{
+	  fprintf (asm_out_file, "\t%s ", ASM_COMMENT_START);
+	  vfprintf (asm_out_file, comment, ap);
+	}
     }
-#else
-  {
-    unsigned HOST_WIDE_INT work = value;
-    const char *byte_op = targetm.asm_out.byte_op;
+  else
+    {
+      unsigned HOST_WIDE_INT work = value;
+      const char *byte_op = targetm.asm_out.byte_op;
 
-    if (byte_op)
-      fputs (byte_op, asm_out_file);
-    do
-      {
-	int byte = (work & 0x7f);
-	work >>= 7;
-	if (work != 0)
-	  /* More bytes to follow.  */
-	  byte |= 0x80;
+      if (byte_op)
+	fputs (byte_op, asm_out_file);
+      do
+	{
+	  int byte = (work & 0x7f);
+	  work >>= 7;
+	  if (work != 0)
+	    /* More bytes to follow.  */
+	    byte |= 0x80;
 
-	if (byte_op)
+	  if (byte_op)
 	  {
 	    fprintf (asm_out_file, "%#x", byte);
 	    if (work != 0)
@@ -622,21 +625,21 @@
 	  }
 	else
 	  assemble_integer (GEN_INT (byte), 1, BITS_PER_UNIT, 1);
-      }
-    while (work != 0);
+	}
+      while (work != 0);
 
-  if (flag_debug_asm)
-    {
-      fprintf (asm_out_file, "\t%s uleb128 " HOST_WIDE_INT_PRINT_HEX,
-	       ASM_COMMENT_START, value);
-      if (comment)
+      if (flag_debug_asm)
 	{
-	  fputs ("; ", asm_out_file);
-	  vfprintf (asm_out_file, comment, ap);
+	  fprintf (asm_out_file, "\t%s uleb128 " HOST_WIDE_INT_PRINT_HEX,
+		   ASM_COMMENT_START, value);
+	  if (comment)
+	    {
+	      fputs ("; ", asm_out_file);
+	      vfprintf (asm_out_file, comment, ap);
+	    }
 	}
     }
-  }
-#endif
+
   putc ('\n', asm_out_file);
 
   va_end (ap);
@@ -738,14 +741,15 @@
 
   va_start (ap, comment);
 
-#ifdef HAVE_AS_LEB128
-  fputs ("\t.uleb128 ", asm_out_file);
-  assemble_name (asm_out_file, lab1);
-  putc ('-', asm_out_file);
-  assemble_name (asm_out_file, lab2);
-#else
-  gcc_unreachable ();
-#endif
+  if (TARGET_USES_LEB128)
+    {
+      fputs ("\t.uleb128 ", asm_out_file);
+      assemble_name (asm_out_file, lab1);
+      putc ('-', asm_out_file);
+      assemble_name (asm_out_file, lab2);
+    }
+  else
+    gcc_unreachable ();
 
   if (flag_debug_asm && comment)
     {
diff -ruN gcc-gnu-4.8.2/gcc/dwarf2out.c gcc-st40-4.8.2.140205/gcc/dwarf2out.c
--- gcc-gnu-4.8.2/gcc/dwarf2out.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/dwarf2out.c	2013-05-28 13:15:34.000000000 +0200
@@ -10535,25 +10535,27 @@
 multiple_reg_loc_descriptor (rtx rtl, rtx regs,
 			     enum var_init_status initialized)
 {
-  int nregs, size, i;
-  unsigned reg;
+  int size, i;
   dw_loc_descr_ref loc_result = NULL;
 
-  reg = REGNO (rtl);
-#ifdef LEAF_REG_REMAP
-  if (crtl->uses_only_leaf_regs)
-    {
-      int leaf_reg = LEAF_REG_REMAP (reg);
-      if (leaf_reg != -1)
-	reg = (unsigned) leaf_reg;
-    }
-#endif
-  gcc_assert ((unsigned) DBX_REGISTER_NUMBER (reg) == dbx_reg_number (rtl));
-  nregs = hard_regno_nregs[REGNO (rtl)][GET_MODE (rtl)];
-
   /* Simple, contiguous registers.  */
   if (regs == NULL_RTX)
     {
+      unsigned reg = REGNO (rtl);
+      int nregs;
+
+#ifdef LEAF_REG_REMAP
+      if (crtl->uses_only_leaf_regs)
+	{
+	  int leaf_reg = LEAF_REG_REMAP (reg);
+	  if (leaf_reg != -1)
+	    reg = (unsigned) leaf_reg;
+	}
+#endif
+
+      gcc_assert ((unsigned) DBX_REGISTER_NUMBER (reg) == dbx_reg_number (rtl));
+      nregs = hard_regno_nregs[REGNO (rtl)][GET_MODE (rtl)];
+
       size = GET_MODE_SIZE (GET_MODE (rtl)) / nregs;
 
       loc_result = NULL;
@@ -10581,10 +10583,9 @@
     {
       dw_loc_descr_ref t;
 
-      t = one_reg_loc_descriptor (REGNO (XVECEXP (regs, 0, i)),
+      t = one_reg_loc_descriptor (dbx_reg_number (XVECEXP (regs, 0, i)),
 				  VAR_INIT_STATUS_INITIALIZED);
       add_loc_descr (&loc_result, t);
-      size = GET_MODE_SIZE (GET_MODE (XVECEXP (regs, 0, 0)));
       add_loc_descr_op_piece (&loc_result, size);
     }
 
diff -ruN gcc-gnu-4.8.2/gcc/emit-rtl.c gcc-st40-4.8.2.140205/gcc/emit-rtl.c
--- gcc-gnu-4.8.2/gcc/emit-rtl.c	2013-06-06 12:32:56.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/emit-rtl.c	2013-06-07 09:56:46.000000000 +0200
@@ -1,5 +1,6 @@
 /* Emit RTL for the GCC expander.
    Copyright (C) 1987-2013 Free Software Foundation, Inc.
+   Copyright (c) 2009  STMicroelectronics.
 
 This file is part of GCC.
 
@@ -4357,8 +4358,18 @@
   PREV_INSN (first) = after;
   NEXT_INSN (last) = after_after;
   if (after_after)
+
+    {
     PREV_INSN (after_after) = last;
 
+      if (NONJUMP_INSN_P (after_after)
+	  && GET_CODE (PATTERN (after_after)) == SEQUENCE)
+	{
+	  rtx sequence = PATTERN (after_after);
+	  PREV_INSN (XVECEXP (sequence, 0, 0)) = last;
+	}
+    }
+
   if (after == get_last_insn())
     set_last_insn (last);
 
diff -ruN gcc-gnu-4.8.2/gcc/except.c gcc-st40-4.8.2.140205/gcc/except.c
--- gcc-gnu-4.8.2/gcc/except.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/except.c	2013-05-28 13:15:34.000000000 +0200
@@ -1,5 +1,6 @@
 /* Implements exception handling.
    Copyright (C) 1989-2013 Free Software Foundation, Inc.
+   Copyright (c) 2013  STMicroelectronics.
    Contributed by Mike Stump <mrs@cygnus.com>.
 
 This file is part of GCC.
@@ -189,10 +190,10 @@
 
 static void push_uleb128 (vec<uchar, va_gc> **, unsigned int);
 static void push_sleb128 (vec<uchar, va_gc> **, int);
-#ifndef HAVE_AS_LEB128
+
 static int dw2_size_of_call_site_table (int);
 static int sjlj_size_of_call_site_table (void);
-#endif
+
 static void dw2_output_call_site_table (int, int);
 static void sjlj_output_call_site_table (void);
 
@@ -1596,7 +1597,7 @@
    Only used by reload hackery; should not be used by new code.  */
 
 void
-for_each_eh_label (void (*callback) (rtx))
+for_each_eh_label (void (*callback) (rtx, void *), void *arg)
 {
   eh_landing_pad lp;
   int i;
@@ -1607,7 +1608,7 @@
 	{
 	  rtx lab = lp->landing_pad;
 	  if (lab && LABEL_P (lab))
-	    (*callback) (lab);
+	    (*callback) (lab, arg);
 	}
     }
 }
@@ -2650,7 +2651,6 @@
 }
 
 
-#ifndef HAVE_AS_LEB128
 static int
 dw2_size_of_call_site_table (int section)
 {
@@ -2685,7 +2685,6 @@
 
   return size;
 }
-#endif
 
 static void
 dw2_output_call_site_table (int cs_format, int section)
@@ -2875,13 +2874,10 @@
 output_one_function_exception_table (int section)
 {
   int tt_format, cs_format, lp_format, i;
-#ifdef HAVE_AS_LEB128
   char ttype_label[32];
   char cs_after_size_label[32];
   char cs_end_label[32];
-#else
   int call_site_len;
-#endif
   int have_tt_data;
   int tt_format_size = 0;
 
@@ -2896,11 +2892,11 @@
   else
     {
       tt_format = ASM_PREFERRED_EH_DATA_FORMAT (/*code=*/0, /*global=*/1);
-#ifdef HAVE_AS_LEB128
-      ASM_GENERATE_INTERNAL_LABEL (ttype_label,
-				   section ? "LLSDATTC" : "LLSDATT",
-				   current_function_funcdef_no);
-#endif
+      if (TARGET_USES_LEB128)
+	ASM_GENERATE_INTERNAL_LABEL (ttype_label,
+				     section ? "LLSDATTC" : "LLSDATT",
+				     current_function_funcdef_no);
+
       tt_format_size = size_of_encoded_value (tt_format);
 
       assemble_align (tt_format_size * BITS_PER_UNIT);
@@ -2926,27 +2922,31 @@
   dw2_asm_output_data (1, tt_format, "@TType format (%s)",
 		       eh_data_format_name (tt_format));
 
-#ifndef HAVE_AS_LEB128
-  if (targetm_common.except_unwind_info (&global_options) == UI_SJLJ)
-    call_site_len = sjlj_size_of_call_site_table ();
-  else
-    call_site_len = dw2_size_of_call_site_table (section);
-#endif
+  if (! TARGET_USES_LEB128)
+    {
+      if (targetm_common.except_unwind_info (&global_options) == UI_SJLJ)
+	call_site_len = sjlj_size_of_call_site_table ();
+      else
+	call_site_len = dw2_size_of_call_site_table (section);
+    }
 
   /* A pc-relative 4-byte displacement to the @TType data.  */
   if (have_tt_data)
     {
-#ifdef HAVE_AS_LEB128
-      char ttype_after_disp_label[32];
-      ASM_GENERATE_INTERNAL_LABEL (ttype_after_disp_label,
-				   section ? "LLSDATTDC" : "LLSDATTD",
-				   current_function_funcdef_no);
-      dw2_asm_output_delta_uleb128 (ttype_label, ttype_after_disp_label,
-				    "@TType base offset");
-      ASM_OUTPUT_LABEL (asm_out_file, ttype_after_disp_label);
-#else
-      /* Ug.  Alignment queers things.  */
-      unsigned int before_disp, after_disp, last_disp, disp;
+      if (TARGET_USES_LEB128)
+	{
+	  char ttype_after_disp_label[32];
+	  ASM_GENERATE_INTERNAL_LABEL (ttype_after_disp_label,
+				       section ? "LLSDATTDC" : "LLSDATTD",
+				       current_function_funcdef_no);
+	  dw2_asm_output_delta_uleb128 (ttype_label, ttype_after_disp_label,
+					"@TType base offset");
+	  ASM_OUTPUT_LABEL (asm_out_file, ttype_after_disp_label);
+	}
+      else
+	{
+	  /* Ug.  Alignment queers things.  */
+	  unsigned int before_disp, after_disp, last_disp, disp;
 
       before_disp = 1 + 1;
       after_disp = (1 + size_of_uleb128 (call_site_len)
@@ -2955,57 +2955,60 @@
 		    + (vec_safe_length (cfun->eh->ttype_data)
 		       * tt_format_size));
 
-      disp = after_disp;
-      do
-	{
-	  unsigned int disp_size, pad;
+	  disp = after_disp;
+	  do
+	    {
+	      unsigned int disp_size, pad;
 
-	  last_disp = disp;
-	  disp_size = size_of_uleb128 (disp);
-	  pad = before_disp + disp_size + after_disp;
-	  if (pad % tt_format_size)
-	    pad = tt_format_size - (pad % tt_format_size);
-	  else
-	    pad = 0;
-	  disp = after_disp + pad;
-	}
-      while (disp != last_disp);
+	      last_disp = disp;
+	      disp_size = size_of_uleb128 (disp);
+	      pad = before_disp + disp_size + after_disp;
+	      if (pad % tt_format_size)
+		pad = tt_format_size - (pad % tt_format_size);
+	      else
+		pad = 0;
+	      disp = after_disp + pad;
+	    }
+	  while (disp != last_disp);
 
-      dw2_asm_output_data_uleb128 (disp, "@TType base offset");
-#endif
+	  dw2_asm_output_data_uleb128 (disp, "@TType base offset");
+	}
     }
 
   /* Indicate the format of the call-site offsets.  */
-#ifdef HAVE_AS_LEB128
-  cs_format = DW_EH_PE_uleb128;
-#else
-  cs_format = DW_EH_PE_udata4;
-#endif
+ if (TARGET_USES_LEB128)
+   cs_format = DW_EH_PE_uleb128;
+ else
+   cs_format = DW_EH_PE_udata4;
+
   dw2_asm_output_data (1, cs_format, "call-site format (%s)",
 		       eh_data_format_name (cs_format));
 
-#ifdef HAVE_AS_LEB128
-  ASM_GENERATE_INTERNAL_LABEL (cs_after_size_label,
-			       section ? "LLSDACSBC" : "LLSDACSB",
-			       current_function_funcdef_no);
-  ASM_GENERATE_INTERNAL_LABEL (cs_end_label,
-			       section ? "LLSDACSEC" : "LLSDACSE",
-			       current_function_funcdef_no);
-  dw2_asm_output_delta_uleb128 (cs_end_label, cs_after_size_label,
-				"Call-site table length");
-  ASM_OUTPUT_LABEL (asm_out_file, cs_after_size_label);
-  if (targetm_common.except_unwind_info (&global_options) == UI_SJLJ)
-    sjlj_output_call_site_table ();
-  else
-    dw2_output_call_site_table (cs_format, section);
-  ASM_OUTPUT_LABEL (asm_out_file, cs_end_label);
-#else
-  dw2_asm_output_data_uleb128 (call_site_len, "Call-site table length");
-  if (targetm_common.except_unwind_info (&global_options) == UI_SJLJ)
-    sjlj_output_call_site_table ();
-  else
-    dw2_output_call_site_table (cs_format, section);
-#endif
+if (TARGET_USES_LEB128)
+    {
+      ASM_GENERATE_INTERNAL_LABEL (cs_after_size_label,
+				   section ? "LLSDACSBC" : "LLSDACSB",
+				   current_function_funcdef_no);
+      ASM_GENERATE_INTERNAL_LABEL (cs_end_label,
+				   section ? "LLSDACSEC" : "LLSDACSE",
+				   current_function_funcdef_no);
+      dw2_asm_output_delta_uleb128 (cs_end_label, cs_after_size_label,
+				    "Call-site table length");
+      ASM_OUTPUT_LABEL (asm_out_file, cs_after_size_label);
+      if (targetm_common.except_unwind_info (&global_options) == UI_SJLJ)
+	sjlj_output_call_site_table ();
+      else
+	dw2_output_call_site_table (cs_format, section);
+      ASM_OUTPUT_LABEL (asm_out_file, cs_end_label);
+    }
+ else
+   {
+     dw2_asm_output_data_uleb128 (call_site_len, "Call-site table length");
+     if (targetm_common.except_unwind_info (&global_options) == UI_SJLJ)
+       sjlj_output_call_site_table ();
+     else
+       dw2_output_call_site_table (cs_format, section);
+   }
 
   /* ??? Decode and interpret the data for flag_debug_asm.  */
   {
@@ -3024,10 +3027,8 @@
       output_ttype (type, tt_format, tt_format_size);
     }
 
-#ifdef HAVE_AS_LEB128
-  if (have_tt_data)
+  if (TARGET_USES_LEB128 && have_tt_data)
       ASM_OUTPUT_LABEL (asm_out_file, ttype_label);
-#endif
 
   /* ??? Decode and interpret the data for flag_debug_asm.  */
   if (targetm.arm_eabi_unwinder)
diff -ruN gcc-gnu-4.8.2/gcc/except.h gcc-st40-4.8.2.140205/gcc/except.h
--- gcc-gnu-4.8.2/gcc/except.h	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/except.h	2013-05-28 13:15:34.000000000 +0200
@@ -1,6 +1,7 @@
 /* Exception Handling interface routines.
    Copyright (C) 1996-2013 Free Software Foundation, Inc.
    Contributed by Mike Stump <mrs@cygnus.com>.
+   Copyright (c) 2013  STMicroelectronics.
 
 This file is part of GCC.
 
@@ -223,7 +224,7 @@
 
 /* Invokes CALLBACK for every exception handler label.  Only used by old
    loop hackery; should not be used by new code.  */
-extern void for_each_eh_label (void (*) (rtx));
+extern void for_each_eh_label (void (*) (rtx, void*), void*);
 
 extern void init_eh_for_function (void);
 
diff -ruN gcc-gnu-4.8.2/gcc/final.c gcc-st40-4.8.2.140205/gcc/final.c
--- gcc-gnu-4.8.2/gcc/final.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/final.c	2014-01-28 09:59:31.000000000 +0100
@@ -665,14 +665,16 @@
   if (INSN_SHUID (seq) < INSN_SHUID (dest))
     {
       /* Forward branch.  */
-      return (insn_last_address + insn_lengths[seq_uid]
+      /* label was computed using this old address.  */
+      /* Assumes that branch is first instruction and no DS.  */
+      return (insn_last_address
 	      - align_fuzz (seq, dest, length_unit_log, ~0));
     }
   else
     {
       /* Backward branch.  */
-      return (insn_current_address
-	      + align_fuzz (dest, seq, length_unit_log, ~0));
+      /* label is correct from this address. */
+      return insn_current_address;
     }
 }
 
@@ -937,6 +939,21 @@
 		  max_skip = targetm.asm_out.label_align_max_skip (insn);
 		}
 	    }
+
+	  next = next_nonnote_insn (insn);
+	  while (next && LABEL_P (next))
+	    {
+	      log = LABEL_TO_ALIGNMENT (next);
+	      if (max_log < log)
+		{
+		  max_log = log;
+		  max_skip = LABEL_TO_MAX_SKIP (next);
+		}
+	      LABEL_TO_ALIGNMENT (next) = 0;
+	      LABEL_TO_MAX_SKIP (next) = 0;
+	      next = next_nonnote_insn (next);
+	    }
+
 	  LABEL_TO_ALIGNMENT (insn) = max_log;
 	  LABEL_TO_MAX_SKIP (insn) = max_skip;
 	  max_log = 0;
@@ -1106,7 +1123,10 @@
 	  /* Alignment is handled by ADDR_VEC_ALIGN.  */
 	}
       else if (GET_CODE (body) == ASM_INPUT || asm_noperands (body) >= 0)
-	insn_lengths[uid] = asm_insn_count (body) * insn_default_length (insn);
+	{
+	  insn_lengths[uid] = asm_insn_count (body) * insn_default_length (insn);
+	  varying_length[uid] = 1;
+	}
       else if (GET_CODE (body) == SEQUENCE)
 	{
 	  int i;
@@ -1404,7 +1424,13 @@
 	    }
 	  else
 	    {
-	      new_length = insn_current_length (insn);
+	      rtx body = PATTERN (insn);
+
+	      if (GET_CODE (body) == ASM_INPUT || asm_noperands (body) >= 0)
+		new_length = asm_insn_count (body) * insn_default_length (insn);
+	      else
+		new_length = insn_current_length (insn);
+
 	      insn_current_address += new_length;
 	    }
 
@@ -1424,6 +1450,7 @@
 	  else
 	    insn_current_address += insn_lengths[uid] - new_length;
 	}
+
       /* For a non-optimizing compile, do only a single pass.  */
       if (!increasing)
 	break;
@@ -1459,10 +1486,14 @@
   if (!*templ)
     return 0;
 
+#ifdef TARGET_ASM_COUNT
+  count = TARGET_ASM_COUNT (templ, 0);
+#else
   for (; *templ; templ++)
     if (IS_ASM_LOGICAL_LINE_SEPARATOR (*templ, templ)
 	|| *templ == '\n')
       count++;
+#endif
 
   return count;
 }
@@ -1520,6 +1551,8 @@
   const char *name;
   size_t name_len;
 
+  CYGPATH (filename);
+
   for (map = debug_prefix_maps; map; map = map->next)
     if (filename_ncmp (filename, map->old_prefix, map->old_len) == 0)
       break;
@@ -4584,3 +4617,12 @@
   0                                     /* todo_flags_finish */
  }
 };
+
+int
+print_address (int uid)
+{
+  if (! INSN_ADDRESSES_SET_P ())
+    return 0;
+
+  return INSN_ADDRESSES (uid);
+}
diff -ruN gcc-gnu-4.8.2/gcc/fwprop.c gcc-st40-4.8.2.140205/gcc/fwprop.c
--- gcc-gnu-4.8.2/gcc/fwprop.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/fwprop.c	2013-05-28 13:15:34.000000000 +0200
@@ -1,6 +1,7 @@
 /* RTL-based forward propagation pass for GNU compiler.
    Copyright (C) 2005-2013 Free Software Foundation, Inc.
    Contributed by Paolo Bonzini and Steven Bosscher.
+   Copyright (c) 2013  STMicroelectronics.
 
 This file is part of GCC.
 
diff -ruN gcc-gnu-4.8.2/gcc/gcc.c gcc-st40-4.8.2.140205/gcc/gcc.c
--- gcc-gnu-4.8.2/gcc/gcc.c	2013-06-06 12:32:56.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/gcc.c	2013-06-07 09:56:46.000000000 +0200
@@ -1,5 +1,6 @@
 /* Compiler driver program that can handle many languages.
    Copyright (C) 1987-2013 Free Software Foundation, Inc.
+   Copyright (c) 2009, 2012  STMicroelectronics.
 
 This file is part of GCC.
 
@@ -339,6 +340,7 @@
  %W{...}
 	like %{...} but mark last argument supplied within
 	as a file to be deleted on failure.
+ %N	substitue the current multilib directory.
  %o	substitutes the names of all the output files, with spaces
 	automatically placed around them.  You should write spaces
 	around the %o as well or the results are undefined.
@@ -745,7 +747,7 @@
     %{fopenmp|ftree-parallelize-loops=*:%:include(libgomp.spec)%(link_gomp)}\
     %{fgnu-tm:%:include(libitm.spec)%(link_itm)}\
     %(mflib) " STACK_SPLIT_SPEC "\
-    %{fprofile-arcs|fprofile-generate*|coverage:-lgcov} " SANITIZER_SPEC " \
+    %{!nostdlib:%{fprofile-arcs|fprofile-generate*|coverage:-lgcov}} " SANITIZER_SPEC " \
     %{!nostdlib:%{!nodefaultlibs:%(link_ssp) %(link_gcc_c_sequence)}}\
     %{!nostdlib:%{!nostartfiles:%E}} %{T*} }}}}}}"
 #endif
@@ -2181,8 +2183,8 @@
       size_t multi_dir_len = 0;
       size_t multi_os_dir_len = 0;
       size_t multiarch_len = 0;
-      size_t suffix_len;
-      size_t just_suffix_len;
+      size_t suffix_len = 0;
+      size_t just_suffix_len = 0;
       size_t len;
 
       if (multi_dir)
@@ -2191,8 +2193,10 @@
 	multi_os_dir_len = strlen (multi_os_dir);
       if (multiarch_suffix)
 	multiarch_len = strlen (multiarch_suffix);
-      suffix_len = strlen (multi_suffix);
-      just_suffix_len = strlen (just_multi_suffix);
+      if (multi_suffix)
+	suffix_len = strlen (multi_suffix);
+      if (just_multi_suffix)
+	just_suffix_len = strlen (just_multi_suffix);
 
       if (path == NULL)
 	{
@@ -2207,7 +2211,7 @@
 	  memcpy (path, pl->prefix, len);
 
 	  /* Look first in MACHINE/VERSION subdirectory.  */
-	  if (!skip_multi_dir)
+	  if (!skip_multi_dir && multi_suffix)
 	    {
 	      memcpy (path + len, multi_suffix, suffix_len + 1);
 	      ret = callback (path, callback_info);
@@ -2217,7 +2221,7 @@
 
 	  /* Some paths are tried with just the machine (ie. target)
 	     subdir.  This is used for finding as, ld, etc.  */
-	  if (!skip_multi_dir
+	  if (!skip_multi_dir && just_multi_suffix
 	      && pl->require_machine_suffix == 2)
 	    {
 	      memcpy (path + len, just_multi_suffix, just_suffix_len + 1);
@@ -3562,7 +3566,10 @@
 
     case OPT_B:
       {
-	size_t len = strlen (arg);
+	size_t len;
+
+	CYGPATH (arg);
+	len = strlen (arg);
 
 	/* Catch the case where the user has forgotten to append a
 	   directory separator to the path.  Note, they may be using
@@ -3689,20 +3696,7 @@
 	}
     }
 
-  /* Handle any -no-canonical-prefixes flag early, to assign the function
-     that builds relative prefixes.  This function creates default search
-     paths that are needed later in normal option handling.  */
-
-  for (j = 1; j < decoded_options_count; j++)
-    {
-      if (decoded_options[j].opt_index == OPT_no_canonical_prefixes)
-	{
-	  get_relative_prefix = make_relative_prefix_ignore_links;
-	  break;
-	}
-    }
-  if (! get_relative_prefix)
-    get_relative_prefix = make_relative_prefix;
+  get_relative_prefix = make_relative_prefix_ignore_links;
 
   /* Set up the default search paths.  If there is no GCC_EXEC_PREFIX,
      see if we can create it from the pathname specified in
@@ -5050,6 +5044,14 @@
 	    }
 	    break;
 
+	  case 'N':
+	    {
+	      const char *mlib = multilib_dir ? multilib_dir : ".";
+	      obstack_grow (&obstack, mlib, strlen (mlib));
+	      arg_going = 1;
+	    }
+	    break;
+
 	  case 'o':
 	    {
 	      int max = n_infiles;
@@ -7988,7 +7990,7 @@
 /* getenv built-in spec function.
 
    Returns the value of the environment variable given by its first
-   argument, concatenated with the second argument.  If the
+   argument, concatenated with the remaining arguments.  If the
    environment variable is not defined, a fatal error is issued.  */
 
 static const char *
@@ -7998,8 +8000,9 @@
   char *result;
   char *ptr;
   size_t len;
+  int i;
 
-  if (argc != 2)
+  if (argc < 2)
     return NULL;
 
   value = getenv (argv[0]);
@@ -8010,7 +8013,9 @@
      they are not interpreted as active spec characters.  A
      particularly painful case is when we are reading a variable
      holding a windows path complete with \ separators.  */
-  len = strlen (value) * 2 + strlen (argv[1]) + 1;
+  len = strlen (value) * 2 + 1;
+  for (i = 1; i < argc; i++)
+    len += strlen (argv[i]);
   result = XNEWVAR (char, len);
   for (ptr = result; *value; ptr += 2)
     {
@@ -8018,7 +8023,11 @@
       ptr[1] = *value++;
     }
 
-  strcpy (ptr, argv[1]);
+  for (i = 1; i < argc; i++)
+    {
+      strcpy (ptr, argv[i]);
+      ptr += strlen (argv[i]);
+    }
 
   return result;
 }
diff -ruN gcc-gnu-4.8.2/gcc/gcov-io.c gcc-st40-4.8.2.140205/gcc/gcov-io.c
--- gcc-gnu-4.8.2/gcc/gcov-io.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/gcov-io.c	2013-10-02 16:24:03.000000000 +0200
@@ -94,9 +94,15 @@
       /* pass mode (ignored) for compatibility */
       fd = open (name, O_RDONLY, S_IRUSR | S_IWUSR);
     }
-  else
+  else if (mode < 0)
+     {
+       /* Write mode - acquire a write-lock.  */
+       s_flock.l_type = F_WRLCK;
+      fd = open (name, O_RDWR | O_CREAT | O_TRUNC, 0666);
+    }
+  else /* mode == 0 */
     {
-      /* Write mode - acquire a write-lock.  */
+      /* Read-Write mode - acquire a write-lock.  */
       s_flock.l_type = F_WRLCK;
       fd = open (name, O_RDWR | O_CREAT, 0666);
     }
diff -ruN gcc-gnu-4.8.2/gcc/gimple-fold.c gcc-st40-4.8.2.140205/gcc/gimple-fold.c
--- gcc-gnu-4.8.2/gcc/gimple-fold.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/gimple-fold.c	2013-05-28 13:15:34.000000000 +0200
@@ -1,6 +1,7 @@
 /* Statement simplification on GIMPLE.
    Copyright (C) 2010-2013 Free Software Foundation, Inc.
    Split out from tree-ssa-ccp.c.
+   Copyright (c) 2013  STMicroelectronics.
 
 This file is part of GCC.
 
@@ -197,7 +198,7 @@
 tree
 get_symbol_constant_value (tree sym)
 {
-  if (const_value_known_p (sym))
+  if (const_value_known_p (sym) && !DECL_WEAK (sym))
     {
       tree val = DECL_INITIAL (sym);
       if (val)
diff -ruN gcc-gnu-4.8.2/gcc/insn-addr.h gcc-st40-4.8.2.140205/gcc/insn-addr.h
--- gcc-gnu-4.8.2/gcc/insn-addr.h	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/insn-addr.h	2013-05-28 13:15:34.000000000 +0200
@@ -1,5 +1,6 @@
 /* Macros to support INSN_ADDRESSES
    Copyright (C) 2000-2013 Free Software Foundation, Inc.
+   Copyright (c) 2013  STMicroelectronics.
 
 This file is part of GCC.
 
@@ -60,4 +61,6 @@
 #define INSN_ADDRESSES_NEW(insn, addr)		\
   (insn_addresses_new (insn, addr))
 
+extern int print_address (int uid);
+
 #endif /* ! GCC_INSN_ADDR_H */
diff -ruN gcc-gnu-4.8.2/gcc/ipa-inline.c gcc-st40-4.8.2.140205/gcc/ipa-inline.c
--- gcc-gnu-4.8.2/gcc/ipa-inline.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/ipa-inline.c	2013-08-06 13:40:26.000000000 +0200
@@ -1445,6 +1445,11 @@
 	for (edge = node->callers; edge; edge = edge->next_caller)
 	  if (max_count < edge->count)
 	    max_count = edge->count;
+
+	for (edge = node->indirect_calls; edge; edge = edge->next_callee)
+	  if (max_count < edge->count)
+	    max_count = edge->count;
+
       }
   ipa_free_postorder_info ();
   initialize_growth_caches ();
diff -ruN gcc-gnu-4.8.2/gcc/ira.c gcc-st40-4.8.2.140205/gcc/ira.c
--- gcc-gnu-4.8.2/gcc/ira.c	2013-10-16 16:17:23.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/ira.c	2013-10-17 12:15:29.000000000 +0200
@@ -2979,6 +2979,16 @@
 	     only mark all destinations as having no known equivalence.  */
 	  if (set == 0)
 	    {
+	      if (GET_CODE (PATTERN (insn)) == UNSPEC_VOLATILE)
+		{
+		  int i;
+		  /* UNSPEC_VOLATILE is considered to use and clobber all hard 
+		     registers and all of memory.  This blocks insns from being
+		     combined across this point.  */
+		  for (i = FIRST_PSEUDO_REGISTER; i < vec_safe_length (reg_equivs); i++)
+		    reg_equiv[i].replace = 0;
+		}
+
 	      note_stores (PATTERN (insn), no_equiv, NULL);
 	      continue;
 	    }
diff -ruN gcc-gnu-4.8.2/gcc/jump.c gcc-st40-4.8.2.140205/gcc/jump.c
--- gcc-gnu-4.8.2/gcc/jump.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/jump.c	2014-02-05 09:08:29.000000000 +0100
@@ -1444,6 +1444,27 @@
       return;
     }
 
+  /* Handle non computed jump sequences created by
+     fix_crossing_unconditional_branches in bb-reorder.  */
+  if (code == SET && SET_DEST (x) == pc_rtx)
+    {
+      rtx prev = PREV_INSN (insn);
+      rtx label_set = single_set (prev);
+      rtx label_dest = label_set != NULL ? SET_DEST (label_set) : NULL;
+
+      if (label_set != NULL
+	  /* The source must be the direct LABEL_REF, not a
+	     computed one.  */
+	  && GET_CODE (SET_SRC (label_set)) == LABEL_REF
+	  && rtx_equal_p (label_dest, SET_SRC (x))
+	  && find_regno_note (insn, REG_DEAD, REGNO (label_dest)))
+	{
+	  rtx label_addr = gen_rtx_LABEL_REF (Pmode, nlabel);
+	  validate_change (prev, &XEXP (PATTERN (prev), 1), label_addr, 1);
+	  return;
+	}
+    }
+
   if (code == IF_THEN_ELSE)
     {
       /* Skip the condition of an IF_THEN_ELSE.  We only want to
diff -ruN gcc-gnu-4.8.2/gcc/lcm.c gcc-st40-4.8.2.140205/gcc/lcm.c
--- gcc-gnu-4.8.2/gcc/lcm.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/lcm.c	2013-05-28 13:15:34.000000000 +0200
@@ -1,5 +1,6 @@
 /* Generic partial redundancy elimination with lazy code motion support.
    Copyright (C) 1998-2013 Free Software Foundation, Inc.
+   Copyright (c) 2009  STMicroelectronics.
 
 This file is part of GCC.
 
@@ -365,17 +366,18 @@
     }
 }
 
-/* Given local properties TRANSP, ANTLOC, AVOUT, KILL return the insert and
-   delete vectors for edge based LCM.  Returns an edgelist which is used to
-   map the insert vector to what edge an expression should be inserted on.  */
+/* Given local properties TRANSP, ANTLOC, AVLOC, KILL return the insert and
+   delete vectors for edge based LCM, and return the AVIN, AVOUT bitmap.
+   Returns an edgelist which is used to map the insert vector to
+   what edge an expression should be inserted on.  */
 
 struct edge_list *
-pre_edge_lcm (int n_exprs, sbitmap *transp,
+pre_edge_lcm_avs (int n_exprs, sbitmap *transp,
 	      sbitmap *avloc, sbitmap *antloc, sbitmap *kill,
+		  sbitmap *avin, sbitmap *avout,
 	      sbitmap **insert, sbitmap **del)
 {
   sbitmap *antin, *antout, *earliest;
-  sbitmap *avin, *avout;
   sbitmap *later, *laterin;
   struct edge_list *edge_list;
   int num_edges;
@@ -397,10 +399,7 @@
 #endif
 
   /* Compute global availability.  */
-  avin = sbitmap_vector_alloc (last_basic_block, n_exprs);
-  avout = sbitmap_vector_alloc (last_basic_block, n_exprs);
   compute_available (avloc, kill, avout, avin);
-  sbitmap_vector_free (avin);
 
   /* Compute global anticipatability.  */
   antin = sbitmap_vector_alloc (last_basic_block, n_exprs);
@@ -426,7 +425,6 @@
 
   sbitmap_vector_free (antout);
   sbitmap_vector_free (antin);
-  sbitmap_vector_free (avout);
 
   later = sbitmap_vector_alloc (num_edges, n_exprs);
 
@@ -465,6 +463,28 @@
   return edge_list;
 }
 
+/* Wrapper to allocate avin/avout and call pre_edge_lcm_avs.  */
+
+struct edge_list *
+pre_edge_lcm (int n_exprs, sbitmap *transp,
+	      sbitmap *avloc, sbitmap *antloc, sbitmap *kill,
+	      sbitmap **insert, sbitmap **del)
+{
+  struct edge_list *edge_list;
+  sbitmap *avin, *avout;
+
+  avin = sbitmap_vector_alloc (last_basic_block, n_exprs);
+  avout = sbitmap_vector_alloc (last_basic_block, n_exprs);
+
+  edge_list = pre_edge_lcm_avs (n_exprs, transp, avloc, antloc, kill,
+				 avin, avout, insert, del);
+
+  sbitmap_vector_free (avout);
+  sbitmap_vector_free (avin);
+
+  return edge_list;
+}
+
 /* Compute the AVIN and AVOUT vectors from the AVLOC and KILL vectors.
    Return the number of passes we performed to iterate to a solution.  */
 
diff -ruN gcc-gnu-4.8.2/gcc/lto/lto-lang.c gcc-st40-4.8.2.140205/gcc/lto/lto-lang.c
--- gcc-gnu-4.8.2/gcc/lto/lto-lang.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/lto/lto-lang.c	2013-05-28 13:15:34.000000000 +0200
@@ -1,6 +1,7 @@
 /* Language-dependent hooks for LTO.
    Copyright (C) 2009-2013 Free Software Foundation, Inc.
    Contributed by CodeSourcery, Inc.
+   Copyright (c) 2013  STMicroelectronics.
 
 This file is part of GCC.
 
@@ -1157,7 +1158,7 @@
   flag_generate_lto = flag_wpa;
 
   /* Create the basic integer types.  */
-  build_common_tree_nodes (flag_signed_char, /*short_double=*/false);
+  build_common_tree_nodes (flag_signed_char, flag_short_double);
 
   /* The global tree for the main identifier is filled in by
      language-specific front-end initialization that is not run in the
diff -ruN gcc-gnu-4.8.2/gcc/lto-opts.c gcc-st40-4.8.2.140205/gcc/lto-opts.c
--- gcc-gnu-4.8.2/gcc/lto-opts.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/lto-opts.c	2013-05-28 13:15:34.000000000 +0200
@@ -2,6 +2,7 @@
 
    Copyright (C) 2009-2013 Free Software Foundation, Inc.
    Contributed by Simon Baldwin <simonb@google.com>
+   Copyright (c) 2013  STMicroelectronics.
 
 This file is part of GCC.
 
diff -ruN gcc-gnu-4.8.2/gcc/Makefile.in gcc-st40-4.8.2.140205/gcc/Makefile.in
--- gcc-gnu-4.8.2/gcc/Makefile.in	2013-10-16 16:17:23.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/Makefile.in	2013-10-17 12:15:29.000000000 +0200
@@ -820,7 +820,7 @@
 # comma in the $(if ...) constructs is significant - do not remove it.
 BASEVER_s   := "\"$(BASEVER_c)\""
 DEVPHASE_s  := "\"$(if $(DEVPHASE_c), ($(DEVPHASE_c)))\""
-DATESTAMP_s := "\"$(if $(DEVPHASE_c), $(DATESTAMP_c))\""
+DATESTAMP_s := "\"$(if $(DATESTAMP_c), $(DATESTAMP_c))\""
 PKGVERSION_s:= "\"@PKGVERSION@\""
 BUGURL_s    := "\"@REPORT_BUGS_TO@\""
 
diff -ruN gcc-gnu-4.8.2/gcc/mode-switching.c gcc-st40-4.8.2.140205/gcc/mode-switching.c
--- gcc-gnu-4.8.2/gcc/mode-switching.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/mode-switching.c	2013-08-01 10:05:25.000000000 +0200
@@ -1,5 +1,6 @@
 /* CPU mode switching
    Copyright (C) 1998-2013 Free Software Foundation, Inc.
+   Copyright (c) 2009  STMicroelectronics.
 
 This file is part of GCC.
 
@@ -94,6 +95,181 @@
 static void reg_becomes_live (rtx, const_rtx, void *);
 static void make_preds_opaque (basic_block, int);
 
+/* Bitmap to compute mode flipping.  */
+
+static sbitmap *mode_in_flip;  /* flip in mode status for each basic blocks.  */
+static sbitmap *mode_out_flip; /* flip out mode status for each basic blocks.  */
+/* To support mode switching, the algorithm cannot set the modes after
+   the insert and delete bitmaps are computed by pre_edge_lcm, because
+   'avin' is computed iteratively for each possible modes for each entity.
+   The mode emission will be done after all mode are processed.
+   (see commit_mode_sets).  */
+
+static int **modes_needed;  /* modes needs to be inserted on this edge.  */
+
+/* Indicates that edge mode information is unknown. Cannot use 'no_mode'
+   because its value depends of its entity */
+#define NO_MODE -1
+
+
+/* Return true when one of the predecessor edges of BB is marked with
+   EDGE_COMPLEX. (similar to bb_has_eh_pred in basic_block.h).  */
+static bool
+bb_has_complex_pred (basic_block bb)
+{
+  edge e;
+  edge_iterator ei;
+
+  FOR_EACH_EDGE (e, ei, bb->preds)
+    {
+      if (e->flags & EDGE_COMPLEX)
+	return true;
+    }
+  return false;
+}
+
+/* Test avin modes.
+   if 'out' is 'true' we want to know if the mode out of the basic block
+   can be flipped. If 'in' is true we want to know if the mode entering the basic
+   block can be flipped.  */
+
+static int
+test_flip_status(int entity, basic_block bb, bool out)
+{
+  if (out)
+    return bitmap_bit_p (mode_out_flip[bb->index], entity);
+  else
+    return bitmap_bit_p (mode_in_flip[bb->index], entity);
+}
+
+/* Merges the avin modes.  */
+
+static void
+set_flip_status (sbitmap *avin, sbitmap *avout)
+{
+  basic_block bb;
+
+  FOR_EACH_BB (bb)
+    {
+      int i = bb->index;
+
+      /* Merge modes for each entity for each bb.
+	 If multiple avin modes are set for the same bb, they are not
+	 exclusive and a flip may not be emitted.
+	 If more that 2 modes can be defined, flip may not be emitted.  */
+      if (! bb_has_complex_pred (bb))
+	{
+	  bitmap_xor (mode_in_flip[i], mode_in_flip[i], avin[i]);
+	  bitmap_xor (mode_out_flip[i], mode_out_flip[i], avout[i]);
+	}
+    }
+}
+
+/* Allocates and initializes modes_infos.  */
+
+static void
+init_modes_infos (int n_entities)
+{
+  int j;
+  int num_edges = 0;
+  basic_block bb;
+
+  /* How many edges do we have ?  */
+
+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)
+      num_edges += EDGE_COUNT (bb->succs);
+
+  modes_needed = XNEWVEC (int *, n_entities);
+
+  for (j = 0; j < n_entities; j++)
+    {
+      modes_needed[j] = XNEWVEC (int, num_edges);
+
+      /* Initial NO_MODE value is -1, because 0 is a value mode.  */
+      memset (modes_needed[j], NO_MODE, num_edges * sizeof (int));
+    }
+
+  /* Allocates bitmaps for modes.  */
+  mode_in_flip = sbitmap_vector_alloc (last_basic_block, n_entities);
+  mode_out_flip = sbitmap_vector_alloc (last_basic_block, n_entities);
+  bitmap_vector_clear (mode_in_flip, last_basic_block);
+  bitmap_vector_clear (mode_out_flip, last_basic_block);
+}
+
+/* frees memory used to hold the modes information.  */
+
+static void
+free_modes_infos (int n_entities)
+{
+  int j;
+
+  for (j = 0; j < n_entities; j++)
+    free (modes_needed[j]);
+
+  free (modes_needed);
+  sbitmap_vector_free (mode_in_flip);
+  sbitmap_vector_free (mode_out_flip);
+}
+
+/* records the mode associated with edge e for entity j.  */
+
+static void
+add_mode_set (int j, int e, int mode)
+{
+  modes_needed[j][e] = mode;
+}
+
+/* returns the mode needed on edge e for entity j. -1 if none.  */
+
+static int
+get_mode (int j, int e)
+{
+  return modes_needed[j][e];
+}
+
+/* Finally, after all the modes after been inserted after lcm, we can
+   process with the mode emission.  */
+
+static int
+commit_mode_sets (struct edge_list *edge_list, int j, int *entity_map)
+{
+  int need_commit = 0;
+  int e;
+
+  for (e = 0; e < NUM_EDGES (edge_list); e++)
+    {
+      HARD_REG_SET live_at_edge;
+      edge eg = INDEX_EDGE (edge_list, e);
+      basic_block src_bb = eg->src;
+      int mode, prev_mode;
+      rtx mode_set;
+
+      if ((mode = get_mode (j, e)) == NO_MODE)
+	continue;
+
+      prev_mode = test_flip_status (j, src_bb, true);
+
+      REG_SET_TO_HARD_REG_SET (live_at_edge, df_get_live_out (src_bb));
+
+      start_sequence ();
+      EMIT_MODE_SET (entity_map[j], mode, prev_mode, live_at_edge);
+
+      mode_set = get_insns ();
+      end_sequence ();
+
+      /* Do not bother to insert empty sequence.  */
+      if (mode_set == NULL_RTX)
+	continue;
+
+      /* We should not get an abnormal edge here.  */
+      gcc_assert (! (eg->flags & EDGE_ABNORMAL));
+	
+      need_commit = 1;
+      insert_insn_on_edge (mode_set, eg);
+    }
+
+  return need_commit;
+}
 
 /* This function will allocate a new BBINFO structure, initialized
    with the MODE, INSN, and basic block BB parameters.  */
@@ -330,12 +506,10 @@
 			break;
 		      }
 		    if (!targetm.calls.function_value_regno_p (copy_start))
-		      {
-			last_insn = return_copy;
-			continue;
-		      }
-		    copy_num
-		      = hard_regno_nregs[copy_start][GET_MODE (copy_reg)];
+		      copy_num = 0;
+		    else
+		      copy_num
+			= hard_regno_nregs[copy_start][GET_MODE (copy_reg)];
 
 		    /* If the return register is not likely spilled, - as is
 		       the case for floating point on SH4 - then it might
@@ -372,6 +546,11 @@
 			  forced_late_switch = 1;
 			break;
 		      }
+		    if (copy_num == 0)
+		      {
+			last_insn = return_copy;
+			continue;
+		      }
 
 		    if (copy_start >= ret_start
 			&& copy_start + copy_num <= ret_end)
@@ -454,7 +633,6 @@
   basic_block bb;
   int need_commit = 0;
   sbitmap *kill;
-  struct edge_list *edge_list;
   static const int num_modes[] = NUM_MODES_FOR_MODE_SWITCHING;
 #define N_ENTITIES ARRAY_SIZE (num_modes)
   int entity_map[N_ENTITIES];
@@ -464,6 +642,8 @@
   int max_num_modes = 0;
   bool emitted ATTRIBUTE_UNUSED = false;
   basic_block post_entry ATTRIBUTE_UNUSED, pre_exit ATTRIBUTE_UNUSED;
+  sbitmap *avin, *avout;
+  struct edge_list *edge_list = 0;
 
   for (e = N_ENTITIES - 1, n_entities = 0; e >= 0; e--)
     if (OPTIMIZE_MODE_SWITCHING (e))
@@ -500,6 +680,8 @@
   antic = sbitmap_vector_alloc (last_basic_block, n_entities);
   transp = sbitmap_vector_alloc (last_basic_block, n_entities);
   comp = sbitmap_vector_alloc (last_basic_block, n_entities);
+  avin = sbitmap_vector_alloc (last_basic_block, n_entities);
+  avout = sbitmap_vector_alloc (last_basic_block, n_entities);
 
   bitmap_vector_ones (transp, last_basic_block);
 
@@ -603,6 +785,9 @@
     }
 
   kill = sbitmap_vector_alloc (last_basic_block, n_entities);
+
+  init_modes_infos (n_entities);
+
   for (i = 0; i < max_num_modes; i++)
     {
       int current_mode[N_ENTITIES];
@@ -632,8 +817,11 @@
 
       FOR_EACH_BB (bb)
 	bitmap_not (kill[bb->index], transp[bb->index]);
-      edge_list = pre_edge_lcm (n_entities, transp, comp, antic,
-				kill, &insert, &del);
+      edge_list = pre_edge_lcm_avs (n_entities, transp, comp, antic,
+				    kill, avin, avout, &insert, &del);
+
+      /* Merge modes for all entities.  */
+      set_flip_status (avin, avout);
 
       for (j = n_entities - 1; j >= 0; j--)
 	{
@@ -650,10 +838,6 @@
 	  for (e = NUM_EDGES (edge_list) - 1; e >= 0; e--)
 	    {
 	      edge eg = INDEX_EDGE (edge_list, e);
-	      int mode;
-	      basic_block src_bb;
-	      HARD_REG_SET live_at_edge;
-	      rtx mode_set;
 
 	      eg->aux = 0;
 
@@ -662,25 +846,8 @@
 
 	      eg->aux = (void *)1;
 
-	      mode = current_mode[j];
-	      src_bb = eg->src;
-
-	      REG_SET_TO_HARD_REG_SET (live_at_edge, df_get_live_out (src_bb));
-
-	      start_sequence ();
-	      EMIT_MODE_SET (entity_map[j], mode, live_at_edge);
-	      mode_set = get_insns ();
-	      end_sequence ();
-
-	      /* Do not bother to insert empty sequence.  */
-	      if (mode_set == NULL_RTX)
-		continue;
-
-	      /* We should not get an abnormal edge here.  */
-	      gcc_assert (! (eg->flags & EDGE_ABNORMAL));
-
-	      need_commit = 1;
-	      insert_insn_on_edge (mode_set, eg);
+	      /* Remember we need to emit it.  */
+	      add_mode_set(j, e, current_mode[j]);
 	    }
 
 	  FOR_EACH_BB_REVERSE (bb)
@@ -695,6 +862,9 @@
       sbitmap_vector_free (del);
       sbitmap_vector_free (insert);
       clear_aux_for_edges ();
+
+      /* Keep an edge_list for later.  */
+      if (i != max_num_modes - 1)
       free_edge_list (edge_list);
     }
 
@@ -703,9 +873,16 @@
     {
       int no_mode = num_modes[entity_map[j]];
 
+      /* In case there was no mode inserted. the mode information on the edge
+	 might not be complete.
+	 Update mode info on edges and commit pending mode sets.  */
+      need_commit |= commit_mode_sets (edge_list, j, entity_map);
+
       FOR_EACH_BB_REVERSE (bb)
 	{
 	  struct seginfo *ptr, *next;
+	  int last_mode = test_flip_status (j, bb, false);
+
 	  for (ptr = bb_info[j][bb->index].seginfo; ptr; ptr = next)
 	    {
 	      next = ptr->next;
@@ -714,10 +891,14 @@
 		  rtx mode_set;
 
 		  start_sequence ();
-		  EMIT_MODE_SET (entity_map[j], ptr->mode, ptr->regs_live);
+		  EMIT_MODE_SET (entity_map[j], ptr->mode, last_mode,
+				 ptr->regs_live);
 		  mode_set = get_insns ();
 		  end_sequence ();
 
+		  /* modes are are localy set.  */
+		  last_mode = 1;
+
 		  /* Insert MODE_SET only if it is nonempty.  */
 		  if (mode_set != NULL_RTX)
 		    {
@@ -736,6 +917,9 @@
       free (bb_info[j]);
     }
 
+  free_edge_list (edge_list);
+  free_modes_infos (n_entities);
+
   /* Finished. Free up all the things we've allocated.  */
   sbitmap_vector_free (kill);
   sbitmap_vector_free (antic);
diff -ruN gcc-gnu-4.8.2/gcc/opts.c gcc-st40-4.8.2.140205/gcc/opts.c
--- gcc-gnu-4.8.2/gcc/opts.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/opts.c	2013-05-28 13:15:34.000000000 +0200
@@ -1,6 +1,7 @@
 /* Command line option handling.
    Copyright (C) 2002-2013 Free Software Foundation, Inc.
    Contributed by Neil Booth.
+   Copyright (c) 2013  STMicroelectronics.
 
 This file is part of GCC.
 
@@ -457,6 +458,7 @@
     { OPT_LEVELS_2_PLUS, OPT_fcrossjumping, NULL, 1 },
     { OPT_LEVELS_2_PLUS, OPT_foptimize_sibling_calls, NULL, 1 },
     { OPT_LEVELS_2_PLUS, OPT_fcse_follow_jumps, NULL, 1 },
+    { OPT_LEVELS_2_PLUS, OPT_fcse_sincos, NULL, 1 },
     { OPT_LEVELS_2_PLUS, OPT_fgcse, NULL, 1 },
     { OPT_LEVELS_2_PLUS, OPT_fexpensive_optimizations, NULL, 1 },
     { OPT_LEVELS_2_PLUS, OPT_frerun_cse_after_loop, NULL, 1 },
diff -ruN gcc-gnu-4.8.2/gcc/output.h gcc-st40-4.8.2.140205/gcc/output.h
--- gcc-gnu-4.8.2/gcc/output.h	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/output.h	2013-05-28 13:15:34.000000000 +0200
@@ -1,6 +1,7 @@
 /* Declarations for insn-output.c and other code to write to asm_out_file.
    These functions are defined in final.c, and varasm.c.
    Copyright (C) 1987-2013 Free Software Foundation, Inc.
+   Copyright (c) 2009  STMicroelectronics.
 
 This file is part of GCC.
 
@@ -52,6 +53,9 @@
    any branches of variable length if possible.  */
 extern void shorten_branches (rtx);
 
+/* Returns the actual insn length without adjustment.  */
+int get_insn_current_length (rtx insn);
+
 /* Output assembler code for the start of a function,
    and initialize some of the variables in this file
    for the new function.  The label for the function and associated
diff -ruN gcc-gnu-4.8.2/gcc/profile.c gcc-st40-4.8.2.140205/gcc/profile.c
--- gcc-gnu-4.8.2/gcc/profile.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/profile.c	2013-05-28 13:15:34.000000000 +0200
@@ -3,6 +3,7 @@
    Contributed by James E. Wilson, UC Berkeley/Cygnus Support;
    based on some ideas from Dain Samples of UC Berkeley.
    Further mangling by Bob Manson, Cygnus Support.
+   Copyright (c) 2013  STMicroelectronics.
 
 This file is part of GCC.
 
@@ -819,8 +820,13 @@
 
       if (bb->count < 0)
 	{
-	  error ("corrupted profile info: number of iterations for basic block %d thought to be %i",
-		 bb->index, (int)bb->count);
+	  if (warn_branch_probabilities_computation)
+	    warning (OPT_Wbranch_probabilities_computation, "corrupted profile "
+		     "info: number of iterations for basic block %d thought to "
+		     "be %i", bb->index, (int)bb->count);
+	  else
+	    error ("corrupted profile info: number of iterations for basic "
+		   "block %d thought to be %i", bb->index, (int)bb->count);
 	  bb->count = 0;
 	}
       FOR_EACH_EDGE (e, ei, bb->succs)
@@ -840,8 +846,14 @@
 	    }
 	  if (e->count < 0 || e->count > bb->count)
 	    {
-	      error ("corrupted profile info: number of executions for edge %d-%d thought to be %i",
-		     e->src->index, e->dest->index,
+	      if (warn_branch_probabilities_computation)
+		warning (OPT_Wbranch_probabilities_computation, "corrupted "
+			 "profile info: number of executions for edge %d-%d "
+			 "thought to be %i", e->src->index, e->dest->index,
+			 (int)e->count);
+	      else 
+		error ("corrupted profile info: number of executions for edge "
+		       "%d-%d thought to be %i", e->src->index, e->dest->index,
 		     (int)e->count);
 	      e->count = bb->count / 2;
 	    }
diff -ruN gcc-gnu-4.8.2/gcc/read-md.c gcc-st40-4.8.2.140205/gcc/read-md.c
--- gcc-gnu-4.8.2/gcc/read-md.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/read-md.c	2013-09-25 15:49:06.000000000 +0200
@@ -170,9 +170,11 @@
 void
 fprint_md_ptr_loc (FILE *outf, const void *ptr)
 {
+#if 0
   const struct ptr_loc *loc = get_md_ptr_loc (ptr);
   if (loc != 0)
     fprintf (outf, "#line %d \"%s\"\n", loc->lineno, loc->filename);
+#endif
 }
 
 /* Special fprint_md_ptr_loc for writing to STDOUT.  */
diff -ruN gcc-gnu-4.8.2/gcc/ree.c gcc-st40-4.8.2.140205/gcc/ree.c
--- gcc-gnu-4.8.2/gcc/ree.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/ree.c	2014-01-24 09:25:59.000000000 +0100
@@ -919,8 +919,6 @@
   if (dump_file && num_re_opportunities > 0)
     fprintf (dump_file, "Elimination opportunities = %d realized = %d\n",
 	     num_re_opportunities, num_realized);
-
-  df_finish_pass (false);
 }
 
 /* Find and remove redundant extensions.  */
@@ -958,7 +956,8 @@
   0,                                    /* properties_provided */
   0,                                    /* properties_destroyed */
   0,                                    /* todo_flags_start */
-  TODO_ggc_collect |
-  TODO_verify_rtl_sharing,              /* todo_flags_finish */
+  TODO_df_finish
+    | TODO_ggc_collect
+    | TODO_verify_rtl_sharing,          /* todo_flags_finish */
  }
 };
diff -ruN gcc-gnu-4.8.2/gcc/reload1.c gcc-st40-4.8.2.140205/gcc/reload1.c
--- gcc-gnu-4.8.2/gcc/reload1.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/reload1.c	2013-07-18 10:02:03.000000000 +0200
@@ -1,5 +1,6 @@
 /* Reload pseudo regs into hard regs for insns that require hard regs.
    Copyright (C) 1987-2013 Free Software Foundation, Inc.
+   Copyright (c) 2013  STMicroelectronics.
 
 This file is part of GCC.
 
@@ -1503,6 +1504,9 @@
 	  int operands_changed = 0;
 	  rtx set = single_set (insn);
 
+	  if (set && GET_CODE (set) == PARALLEL)
+	    continue;
+
 	  /* Skip insns that only set an equivalence.  */
 	  if (set && REG_P (SET_DEST (set))
 	      && reg_renumber[REGNO (SET_DEST (set))] < 0
@@ -1628,6 +1632,9 @@
 	    {
 	      rtx set = single_set (insn);
 
+	      if (set && GET_CODE (set) == PARALLEL)
+		continue;
+
 	      /* Skip insns that only set an equivalence.  */
 	      if (set && REG_P (SET_DEST (set))
 		  && reg_renumber[REGNO (SET_DEST (set))] < 0
@@ -3236,6 +3243,7 @@
     {
       gcc_assert (GET_CODE (PATTERN (insn)) == USE
 		  || GET_CODE (PATTERN (insn)) == CLOBBER
+		  || GET_CODE (PATTERN (insn)) == PARALLEL
 		  || GET_CODE (PATTERN (insn)) == ADDR_VEC
 		  || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC
 		  || GET_CODE (PATTERN (insn)) == ASM_INPUT
@@ -3647,6 +3655,7 @@
     {
       gcc_assert (GET_CODE (PATTERN (insn)) == USE
 		  || GET_CODE (PATTERN (insn)) == CLOBBER
+		  || GET_CODE (PATTERN (insn)) == PARALLEL
 		  || GET_CODE (PATTERN (insn)) == ADDR_VEC
 		  || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC
 		  || GET_CODE (PATTERN (insn)) == ASM_INPUT
@@ -3897,7 +3906,7 @@
 /* Subroutine of set_initial_label_offsets called via for_each_eh_label.  */
 
 static void
-set_initial_eh_label_offset (rtx label)
+set_initial_eh_label_offset (rtx label, void *ignored ATTRIBUTE_UNUSED)
 {
   set_label_offsets (label, NULL_RTX, 1);
 }
@@ -3923,7 +3932,7 @@
     if (XEXP (x, 0))
       set_label_offsets (XEXP (x, 0), NULL_RTX, 1);
 
-  for_each_eh_label (set_initial_eh_label_offset);
+  for_each_eh_label (set_initial_eh_label_offset, NULL);
 }
 
 /* Set all elimination offsets to the known values for the code label given
diff -ruN gcc-gnu-4.8.2/gcc/resource.c gcc-st40-4.8.2.140205/gcc/resource.c
--- gcc-gnu-4.8.2/gcc/resource.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/resource.c	2013-05-28 13:15:34.000000000 +0200
@@ -1,5 +1,6 @@
 /* Definitions for computing resource usage of specific insns.
    Copyright (C) 1999-2013 Free Software Foundation, Inc.
+   Copyright (c) 2013  STMicroelectronics.
 
 This file is part of GCC.
 
@@ -1276,6 +1277,8 @@
 {
   int b = find_basic_block (insn, MAX_DELAY_SLOT_LIVE_SEARCH);
 
+  gcc_assert (b < last_basic_block);
+
   if (b != -1)
     bb_ticks[b]++;
 }
diff -ruN gcc-gnu-4.8.2/gcc/rtl.def gcc-st40-4.8.2.140205/gcc/rtl.def
--- gcc-gnu-4.8.2/gcc/rtl.def	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/rtl.def	2014-01-24 09:25:59.000000000 +0100
@@ -1279,8 +1279,41 @@
    true, the second operand will be used as the value of the conditional.  */
 DEF_RTL_EXPR(COND, "cond", "Ee", RTX_EXTRA)
 
+/* Definition of a pattern substitution meta operation on a DEFINE_EXPAND
+   or a DEFINE_INSN.  Automatically generates new instances of DEFINE_INSNs
+   that match the substitution pattern.
+
+   Operand:
+   0: The name of the substitition template.
+   1: Input template to match to see if a substitution is applicable.
+   2: A C expression giving an additional condition for the generated
+      new define_expand or define_insn.
+   3: Output tempalate to generate via substitution.
+
+   Within a DEFINE_SUBST template, the meaning of some RTL expressions is
+   different from their usual interpretation: a MATCH_OPERAND matches any
+   expression tree with matching machine mode or with VOIDmode.  Likewise,
+   MATCH_OP_DUP and MATCH_DUP match more liberally in a DEFINE_SUBST than
+   in other RTL expressions.  MATCH_OPERATOR matches allc common operators
+   but also UNSPEC, UNSPEC_VOLATILE, and MATCH_OPERATORS from the input
+   DEFINE_EXPAND or DEFINE_INSN.  */
 DEF_RTL_EXPR(DEFINE_SUBST, "define_subst", "sEsE", RTX_EXTRA)
+
+/* Substitution attribute to apply a DEFINE_SUBST to a pattern.
+
+   Operand:
+   0: The name of the subst-attribute.
+   1: The name of the DEFINE_SUBST to be applied for this attribute.
+   2: String to substitute for the subst-attribute name in the pattern
+      name, for the case that the DEFINE_SUBST is not applied (i.e. the
+      unmodified version of the pattern).
+   3: String to substitute for the subst-attribute name in the pattern
+      name, for the case that the DEFINE_SUBST is applied to the patten.
+      
+   The use of DEFINE_SUBST and DEFINE_SUBST_ATTR is explained in the
+   GCC internals manual, under "RTL Templates Transformations".  */
 DEF_RTL_EXPR(DEFINE_SUBST_ATTR, "define_subst_attr", "ssss", RTX_EXTRA)
+
 #endif /* GENERATOR_FILE */
 
 /*
diff -ruN gcc-gnu-4.8.2/gcc/sched-deps.c gcc-st40-4.8.2.140205/gcc/sched-deps.c
--- gcc-gnu-4.8.2/gcc/sched-deps.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/sched-deps.c	2013-05-28 13:15:34.000000000 +0200
@@ -3,6 +3,7 @@
    Copyright (C) 1992-2013 Free Software Foundation, Inc.
    Contributed by Michael Tiemann (tiemann@cygnus.com) Enhanced by,
    and currently maintained by, Jim Wilson (wilson@cygnus.com)
+   Copyright (c) 2013  STMicroelectronics.
 
 This file is part of GCC.
 
@@ -2447,6 +2448,20 @@
       int regno = REGNO (dest);
       enum machine_mode mode = GET_MODE (dest);
 
+      /* Don't extend the lifetime of CLASS_LIKELY_SPILLED registers before RA
+	 since the clobbers due to reload are not yet computed.  */
+      if (!reload_completed && regno < FIRST_PSEUDO_REGISTER)
+	{
+	  int i = hard_regno_nregs[regno][mode];
+	  
+	  while (--i >= 0)
+	    if (targetm.class_likely_spilled_p (REGNO_REG_CLASS (regno + i)))
+	      {
+		flush_pending_lists (deps, insn, false, true);
+		break;
+	      }
+	}
+
       sched_analyze_reg (deps, regno, mode, code, insn);
 
 #ifdef STACK_REGS
diff -ruN gcc-gnu-4.8.2/gcc/stor-layout.c gcc-st40-4.8.2.140205/gcc/stor-layout.c
--- gcc-gnu-4.8.2/gcc/stor-layout.c	2013-06-06 12:32:56.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/stor-layout.c	2013-06-07 09:56:46.000000000 +0200
@@ -1,5 +1,6 @@
 /* C-compiler utilities for types and variables storage layout
    Copyright (C) 1987-2013 Free Software Foundation, Inc.
+   Copyright (c) 2013  STMicroelectronics.
 
 This file is part of GCC.
 
@@ -1515,14 +1516,6 @@
   rli->offset_align = BITS_PER_UNIT;
   normalize_rli (rli);
 
-  /* Determine the desired alignment.  */
-#ifdef ROUND_TYPE_ALIGN
-  TYPE_ALIGN (rli->t) = ROUND_TYPE_ALIGN (rli->t, TYPE_ALIGN (rli->t),
-					  rli->record_align);
-#else
-  TYPE_ALIGN (rli->t) = MAX (TYPE_ALIGN (rli->t), rli->record_align);
-#endif
-
   /* Compute the size so far.  Be sure to allow for extra bits in the
      size in bytes.  We have guaranteed above that it will be no more
      than a single byte.  */
@@ -1532,6 +1525,17 @@
     unpadded_size_unit
       = size_binop (PLUS_EXPR, unpadded_size_unit, size_one_node);
 
+
+  /* Determine the desired alignment.  */
+#ifdef ROUND_TYPE_ALIGN
+  TYPE_SIZE (rli->t) = unpadded_size;
+  TYPE_ALIGN (rli->t) = ROUND_TYPE_ALIGN (rli->t, TYPE_ALIGN (rli->t),
+					  rli->record_align);
+
+#else
+  TYPE_ALIGN (rli->t) = MAX (TYPE_ALIGN (rli->t), rli->record_align);
+#endif
+
   /* Round the size up to be a multiple of the required alignment.  */
   TYPE_SIZE (rli->t) = round_up (unpadded_size, TYPE_ALIGN (rli->t));
   TYPE_SIZE_UNIT (rli->t)
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/ChangeLog.STM gcc-st40-4.8.2.140205/gcc/testsuite/ChangeLog.STM
--- gcc-gnu-4.8.2/gcc/testsuite/ChangeLog.STM	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/ChangeLog.STM	2014-01-28 09:59:31.000000000 +0100
@@ -0,0 +1,220 @@
+2014-01-20  Christian Bruel  <christian.bruel@st.com>
+
+	Codex 245080
+        https://bugzilla.stlinux.com/show_bug.cgi?id=14812
+	* gcc.target/sh/torture/pr58475.c: New test.
+	* gcc.target/sh/torture/dce.C: New test.
+
+2014-01-20  Christian Bruel  <christian.bruel@st.com>
+
+	Codex 244873
+	* gcc.target/sh/torture/keywords.c: New test.
+
+2014-01-09  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc.c-torture/execute/builtins/strncmp-2.c: Enable for SH.
+	* gcc.target/sh/cmpstr.c: New test.
+	* gcc.target/sh/cmpstr.c: New test.
+	* gcc.target/sh/strncmp.c: New test.
+	* gcc.target/sh/cmpstrn.c: New test.
+
+2013-11-05  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc.target/sh/strlen.c: New test.
+
+2013-09-19  Christian Bruel  <christian.bruel@st.com>
+
+	PR target/58475
+	* gcc.target/sh/torture/pr58475.c: New test.
+
+2013-09-13  Christian Bruel  <christian.bruel@st.com>
+
+        PR target/58314
+        * gcc.target/sh/torture/pr58314.c: New test.
+
+2013-04-25  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc.dg/debug/dwarf2/dwarf_span.c: New test case.
+
+2013-04-22  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc.dg/tree-ssa/scev-bitfield.c: New test.
+
+2013-04-18  Christian Bruel  <christian.bruel@st.com>
+
+	PR target/56995
+	* gcc.target/sh/mfmovd.c: Add new function and check hard_float.
+
+2013-04-08  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc.target/sh/mfmovd.c: Add testcase and fix skip list.
+
+2013-01-13  Christian Bruel  <christian.bruel@st.com>
+
+	https://bugzilla.stlinux.com/show_bug.cgi?id=25892
+	* gcc.target/sh/sh-switch.c: New testcase.
+
+2012-12-06  Laurent Alfonsi  <laurent.alfonsi@st.com>
+
+	https://bugzilla.stlinux.com/show_bug.cgi?id=24977
+	* gcc.dg/muladdsi3.c: New test.
+
+2012-04-25  Laurent Alfonsi  <laurent.alfonsi@st.com>
+
+        * lib/c-torture.exp (c-torture-execute): Appends 
+	additional linker flag if exists.
+
+2012-09-10  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc.target/sh/muladd.c: New test.
+
+2012-08-23  Laurent Alfonsi  <laurent.alfonsi@st.com>
+
+	* lib/scanobj.exp: Added
+	* gcc.dg/profiling/profiling.exp: Added
+	* gcc.dg/profiling/default: New tests.
+	* gcc.dg/profiling/branch-probabilities: New tests.
+	* gcc.dg/profiling/function-section: New tests.
+	* gcc.dg/profiling/branch-probabilities-function-section: New tests.
+
+2012-04-23  Christian Bruel  <christian.bruel@st.com>
+
+        https://bugzilla.stlinux.com/show_bug.cgi?id=18466
+        * gcc.target/sh/jump_compact_1.c: New test.
+        * gcc.target/sh/jump_compact_2.c: New test.
+
+2010-02-15  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc.dg/case-const-1.c: Add cond expr label and cast case.
+	* gcc.dg/case-const-2.c: Likewise.
+	* gcc.dg/case-const-3.c: Likewise.
+
+2012-02-14  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc.dg/pr49948.c: Disable if no pthread.
+
+2011-09-02  Christian Bruel  <christian.bruel@st.com>
+
+	https://bugzilla.stlinux.com/show_bug.cgi?id=14098
+	* gcc.c-torture/execute/st14098.c: New.
+
+2010-06-30  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc.target/sh/sh-trapa.c: Test trapa.
+
+2011-03-18 Christian Bruel  <christian.bruel@st.com>
+
+	* g++.dg/warn/Wstrict-aliasing-float-ref-int-obj.C: Test success.
+
+2011-02-11 Christian Bruel  <christian.bruel@st.com>
+
+	* gcc.c-torture/gcc.dg/cpp/_Pragma3.c: xfail.
+
+2010-12-07  Christian Bruel  <christian.bruel@st.com>
+
+	* lib/lto.exp: Disable whopr.
+	* lib/gcc.exp: Likewise.
+	* lib/c-torture.exp: Likewise.
+
+2010-11-08  Christian Bruel  <christian.bruel@st.com>
+
+	https://bugzilla.stlinux.com/show_bug.cgi?id=10391
+	* gcc.dg/ssp.c: New testcase. 
+
+2010-11-03  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc.c-torture/execute/lroundf.c: New testcase. 
+	* gcc.c-torture/execute/lroundf.x: New.
+
+2010-10-14  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc.c-torture/execute/lrintf.c: New testcase. 
+	* gcc.c-torture/execute/lrintf.x: New.
+
+2010-08-10  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc.c-torture/execute/builtin-prefetch-6.c: xfail for sh-linux.
+
+2010-06-15  Christian Bruel  <christian.bruel@st.com>
+
+	https://bugzilla.stlinux.com/show_bug.cgi?id=9320
+	* gcc.dg/shlrtst.c: New testcase. 
+
+2010-06-07  Christian Bruel  <christian.bruel@st.com>
+
+	* lib/target-supports.exp (check_effective_target_complex): Define.
+	* gcc.dg/pr42427.c: Check complex available.
+
+2010-04-20  Christian Bruel  <christian.bruel@st.com>
+
+	INSbl30850:
+	* gcc.dg/builtins-nan.c: New test.
+
+2010-01-26  Christian Bruel  <christian.bruel@st.com>
+
+	http://gcc.gnu.org/bugzilla/show_bug.cgi?id=39423
+	* gcc.dg/fold-plusmult.c: Check rtl instead of gimple.
+
+2010-01-26  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc.target/sh/20080410-1.c: Remove -fira option.
+
+2009-11-10  Christian Bruel  <christian.bruel@st.com>
+
+	* g++.dg/eh/postreload.C: New test.
+
+2009-10-06  Antony King  <antony.king@st.com>
+
+	INSbl30052:
+	* lib/target-supports.exp (check_effective_target_sync_int_long):
+	Enable atomic builtins for sh*-superh-elf.
+	(check_effective_target_sync_char_short): Likewise.
+
+2009-09-29  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc.dg/const-weak.c: Change dump.
+
+2009-09-03  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc.dg/memcpy-1.c: xfail for SH.
+
+2009-09-03  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc.dg/const-weak.c: Update dg-final rules.
+
+2009-07-03  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc.dg/torture/pr36998.c: Add -fno-omit-frame-pointer for SH.
+
+2009-06-18  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc.dg/torture/pr37868.c: xfail for SH.
+
+2009-06-26  Christian Bruel  <christian.bruel@st.com>
+
+	* lib/target-supports.exp: Disable profiling for SH when on the simu.
+
+2009-03-12  Christian Bruel  <christian.bruel@st.com>
+
+	 PR tree-optimization/39423
+	* gcc.target/sh/array-index.c: New optimisation test.
+
+2008-05-06  Christian Bruel  <christian.bruel@st.com>
+
+	INSbl/28671
+	* gcc.dg/const-weak.c: New testcase.
+
+2008-04-17  Christian Bruel  <christian.bruel@st.com>
+
+	INSbl/28594
+	* gcc.dg/long-long-compare-1.c: New testcase.
+
+2008-01-28  Christian Bruel  <christian.bruel@st.com>
+
+	https://bugzilla.stlinux.com/show_bug.cgi?id=3313
+	* gcc.dg/packed-array.c: New testcase.
+
+2007-01-31  Christian Bruel  <christian.bruel@st.com>
+
+	* gcc.target/sh/fpchg1.c: New test.
+	* gcc.target/sh/fpchg2.c: Idem.
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.c-torture/execute/builtin-prefetch-6.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.c-torture/execute/builtin-prefetch-6.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.c-torture/execute/builtin-prefetch-6.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.c-torture/execute/builtin-prefetch-6.c	2013-05-28 13:15:34.000000000 +0200
@@ -1,3 +1,6 @@
+/* can trap for SH with RADDERR on MMU with 31th bit set.  */
+/* { dg-do run { xfail sh*-*linux* } } */
+
 /* Test that __builtin_prefetch does no harm.
 
    Data prefetch should not fault if used with an invalid address.  */
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.c-torture/execute/builtins/strncmp-2.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.c-torture/execute/builtins/strncmp-2.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.c-torture/execute/builtins/strncmp-2.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.c-torture/execute/builtins/strncmp-2.c	2013-10-25 10:58:32.000000000 +0200
@@ -12,7 +12,7 @@
 void
 main_test (void)
 {
-#if !defined(__OPTIMIZE__) || ((defined(__i386__) || defined (__x86_64__)) && !defined(__OPTIMIZE_SIZE__))
+#if !defined(__OPTIMIZE__) || ((defined(__sh__) || defined(__i386__) || defined (__x86_64__)) && !defined(__OPTIMIZE_SIZE__))
   /* These tests work on platforms which support cmpstrsi.  We test it
      at -O0 on all platforms to ensure the strncmp logic is correct.  */
   const char *const s1 = "hello world";
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.c-torture/execute/lrintf.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.c-torture/execute/lrintf.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.c-torture/execute/lrintf.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.c-torture/execute/lrintf.c	2013-05-28 13:15:34.000000000 +0200
@@ -0,0 +1,53 @@
+#include <math.h>
+
+extern void abort (void);
+extern void exit (int);
+
+void __attribute__ ((noinline))
+test(float a)
+{
+  int a1 = __builtin_lrintf (a);
+  int a3 = lrintf (a);
+
+  if (a1 != a3)
+    exit (1);
+}
+
+int main()
+{
+  test (__builtin_nanf(""));
+  test (__builtin_inff());
+
+  test (0);
+  test (1);
+
+  test (2.5);
+  test (3.5);
+  test (-2.5);
+  test (-3.5);
+
+  test (2.4);
+  test (3.4);
+  test (-2.4);
+  test (-3.4);
+
+  test (2.0);
+  test (3.0);
+  test (-2.0);
+  test (-3.0);
+
+  test (2.9);
+  test (3.9);
+  test (-2.9);
+  test (-3.9);
+
+  test (2.1);
+  test (3.1);
+  test (-2.1);
+  test (-3.1);
+
+  test (0.1);
+  test (-0.1);
+
+  return 0;
+}
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.c-torture/execute/lrintf.x gcc-st40-4.8.2.140205/gcc/testsuite/gcc.c-torture/execute/lrintf.x
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.c-torture/execute/lrintf.x	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.c-torture/execute/lrintf.x	2013-05-28 13:15:34.000000000 +0200
@@ -0,0 +1,3 @@
+set additional_flags "-fno-math-errno -std=c99 -fno-builtin -fno-finite-math-only"
+
+return 0
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.c-torture/execute/lroundf.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.c-torture/execute/lroundf.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.c-torture/execute/lroundf.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.c-torture/execute/lroundf.c	2013-05-28 13:15:34.000000000 +0200
@@ -0,0 +1,53 @@
+#include <math.h>
+
+extern void abort (void);
+extern void exit (int);
+
+void __attribute__ ((noinline))
+test(float a)
+{
+  int a1 = __builtin_lroundf (a);
+  int a3 = lroundf (a);
+
+  if (a1 != a3)
+    exit (1);
+}
+
+int main()
+{
+  test (__builtin_nanf(""));
+  test (__builtin_inff());
+
+  test (0);
+  test (1);
+
+  test (2.5);
+  test (3.5);
+  test (-2.5);
+  test (-3.5);
+
+  test (2.4);
+  test (3.4);
+  test (-2.4);
+  test (-3.4);
+
+  test (2.0);
+  test (3.0);
+  test (-2.0);
+  test (-3.0);
+
+  test (2.9);
+  test (3.9);
+  test (-2.9);
+  test (-3.9);
+
+  test (2.1);
+  test (3.1);
+  test (-2.1);
+  test (-3.1);
+
+  test (0.1);
+  test (-0.1);
+
+  return 0;
+}
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.c-torture/execute/lroundf.x gcc-st40-4.8.2.140205/gcc/testsuite/gcc.c-torture/execute/lroundf.x
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.c-torture/execute/lroundf.x	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.c-torture/execute/lroundf.x	2013-05-28 13:15:34.000000000 +0200
@@ -0,0 +1,3 @@
+set additional_flags "-fno-math-errno -std=c99 -fno-builtin -fno-finite-math-only"
+
+return 0
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.c-torture/execute/st14098.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.c-torture/execute/st14098.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.c-torture/execute/st14098.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.c-torture/execute/st14098.c	2013-05-28 13:15:34.000000000 +0200
@@ -0,0 +1,21 @@
+extern void abort (void);
+
+unsigned long long int i = 0x100000000LL;
+
+int
+foo(void)
+{
+  if( i < 127LL ) return 1;
+
+  if( i == 0x8000 ) return 5;
+
+  return 0;
+}
+
+main()
+{
+  if (foo())
+    abort();
+
+  return 0;
+}
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.c-torture/unsorted/dump-noaddr.x gcc-st40-4.8.2.140205/gcc/testsuite/gcc.c-torture/unsorted/dump-noaddr.x
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.c-torture/unsorted/dump-noaddr.x	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.c-torture/unsorted/dump-noaddr.x	2013-05-28 13:15:34.000000000 +0200
@@ -10,10 +10,10 @@
     # loop through all the options
     foreach option $option_list {
 	file delete -force dump1
-	file mkdir dump1
+	file mkdir $tmpdir/dump1
 	c-torture-compile $src "$option $options -dumpbase dump1/$dumpbase -DMASK=1 -x c --param ggc-min-heapsize=1 -fdump-ipa-all -fdump-rtl-all -fdump-tree-all -fdump-noaddr"
 	file delete -force dump2
-	file mkdir dump2
+	file mkdir $tmpdir/dump2
 	c-torture-compile $src "$option $options -dumpbase dump2/$dumpbase -DMASK=2 -x c -fdump-ipa-all -fdump-rtl-all -fdump-tree-all -fdump-noaddr"
 	foreach dump1 [lsort [glob -nocomplain dump1/*]] {
 	    regsub dump1/ $dump1 dump2/ dump2
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/always_inline2.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/always_inline2.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/always_inline2.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/always_inline2.c	2013-05-28 13:15:34.000000000 +0200
@@ -1,8 +1,8 @@
 /* { dg-do compile } */
-/* { dg-options "-O2" } */
-inline __attribute__ ((always_inline)) void t(void); /* { dg-error "body not available" } */
+/* { dg-options "-Winline -O2" } */
+inline __attribute__ ((always_inline)) void t(void); /* { dg-warning "body not available" } */
 void
 q(void)
 {
-  t(); 				/* { dg-error "called from here" } */
+  t(); 				/* { dg-warning "called from here" } */
 }
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/always_inline3.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/always_inline3.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/always_inline3.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/always_inline3.c	2013-05-28 13:15:34.000000000 +0200
@@ -1,11 +1,11 @@
 /* { dg-do compile } */
-/* { dg-options "-O2" } */
+/* { dg-options "-Winline -O2" } */
 int do_something_evil (void);
 inline __attribute__ ((always_inline)) void
-q2(void) /* { dg-error "recursive inlining" } */
+q2(void) /* { dg-warning "recursive inlining" } */
 {
   if (do_something_evil ())
     return;
-  q2(); 			/* { dg-error "called from here" } */
+  q2(); 			/* { dg-warning "called from here" } */
   q2(); /* With -O2 we don't warn here, it is eliminated by tail recursion.  */
 }
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/builtins-nan.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/builtins-nan.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/builtins-nan.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/builtins-nan.c	2013-05-28 13:15:34.000000000 +0200
@@ -0,0 +1,54 @@
+/* { dg-do run } */
+/* { dg-options "-mieee" { target sh*-*-* } } */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+
+static int lisnan(double v)
+{
+  return (v != v);
+}
+
+static int lisnanf(float v)
+{
+  return (v != v);
+}
+
+int main(void)
+{
+  double d;
+  float f;
+
+  /* double */
+  d = __builtin_nans("");
+  if (! lisnan(d))
+    abort();
+
+  if (! __builtin_isnan(d))
+    abort();
+
+  d = __builtin_nan("");
+  if (! lisnan(d))
+    abort();
+
+  if (! __builtin_isnan(d))
+    abort();
+
+  /* float */
+  f = __builtin_nansf("");
+  if (! lisnanf(f))
+    abort();
+
+  if (! __builtin_isnanf(f))
+    abort();
+
+  f = __builtin_nanf("");
+  if (! lisnanf(f))
+    abort();
+
+  if (! __builtin_isnanf(f))
+    abort();
+
+  exit (0);
+}
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/case-const-1.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/case-const-1.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/case-const-1.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/case-const-1.c	2013-05-28 13:15:34.000000000 +0200
@@ -1,9 +1,11 @@
 /* Test for case labels not integer constant expressions but folding
-   to integer constants (used in Linux kernel, PR 39613).  */
+   to integer constants (used in Linux kernel, PR 39613, 52283).  */
 /* { dg-do compile } */
 /* { dg-options "" } */
 
 extern int i;
+extern unsigned int u;
+
 void
 f (int c)
 {
@@ -13,3 +15,13 @@
       ;
     }
 }
+
+void
+b (int c)
+{
+  switch (c)
+    {
+    case (int) (2  | ((4 < 8) ? 8 : u)):
+      ;
+    }
+}
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/case-const-2.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/case-const-2.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/case-const-2.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/case-const-2.c	2013-05-28 13:15:34.000000000 +0200
@@ -1,9 +1,11 @@
 /* Test for case labels not integer constant expressions but folding
-   to integer constants (used in Linux kernel, PR 39613).  */
+   to integer constants (used in Linux kernel, PR 39613, 52283).  */
 /* { dg-do compile } */
 /* { dg-options "-pedantic" } */
 
 extern int i;
+extern unsigned int u;
+
 void
 f (int c)
 {
@@ -13,3 +15,14 @@
       ;
     }
 }
+
+void
+b (int c)
+{
+  switch (c)
+    {
+    case (int) (2  | ((4 < 8) ? 8 : u)): /* { dg-warning "case label is not an integer constant expression" } */
+      ;
+    }
+}
+
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/case-const-3.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/case-const-3.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/case-const-3.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/case-const-3.c	2013-05-28 13:15:34.000000000 +0200
@@ -1,9 +1,11 @@
 /* Test for case labels not integer constant expressions but folding
-   to integer constants (used in Linux kernel, PR 39613).  */
+   to integer constants (used in Linux kernel, PR 39613, 52283, ).  */
 /* { dg-do compile } */
 /* { dg-options "-pedantic-errors" } */
 
 extern int i;
+extern unsigned int u;
+
 void
 f (int c)
 {
@@ -13,3 +15,16 @@
       ;
     }
 }
+
+void
+b (int c)
+{
+  switch (c)
+    {
+    case (int) (2  | ((4 < 8) ? 8 : u)): /* { dg-error "case label is not an integer constant expression" } */
+      ;
+    }
+}
+
+
+
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/const-weak.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/const-weak.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/const-weak.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/const-weak.c	2013-05-28 13:15:34.000000000 +0200
@@ -0,0 +1,16 @@
+/* weak constants can be replaced at link time. */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-pre" } */
+
+const int wconst __attribute__((weak)) = 2;
+
+int f(void)
+{
+  return wconst;
+}
+
+/* { dg-final { scan-tree-dump-not "return 2" "pre"} } */
+/* { dg-final { cleanup-tree-dump "pre*]" } } */
+
+	
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/cpp/_Pragma3.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/cpp/_Pragma3.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/cpp/_Pragma3.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/cpp/_Pragma3.c	2013-05-28 13:15:34.000000000 +0200
@@ -1,6 +1,6 @@
 /* Copyright (C) 2002 Free Software Foundation, Inc.  */
 
-/* { dg-do preprocess } */
+/* { dg-do preprocess  { xfail *-*-* } } */
 
 /* Pragma buffers have a NULL "inc" member, which we would dereference
    when getting a file's date and time.
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/debug/dwarf2/dwarf_span.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/debug/dwarf2/dwarf_span.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/debug/dwarf2/dwarf_span.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/debug/dwarf2/dwarf_span.c	2013-05-28 13:15:34.000000000 +0200
@@ -0,0 +1,19 @@
+/* { dg-do compile { target "sh*-*-*" } } */
+/* { dg-require-effective-target hard_float } */
+/* { dg-skip-if "" { *-*-* }  { "*-single-only" } { "" } } */
+/* { dg-options "-g -dA" } */
+/* { dg-final { scan-assembler-times "DW_OP_regx" 4 } } */
+
+double
+add_double (register double u, register double v)
+{
+  return u + v;
+}
+
+double
+wack_double (register double u, register double v)
+{
+  register double l = u, r = v;
+  l = add_double (l, r);
+  return l + r;
+}
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/fail_always_inline.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/fail_always_inline.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/fail_always_inline.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/fail_always_inline.c	2013-05-28 13:15:34.000000000 +0200
@@ -6,6 +6,5 @@
 void
 f()
 {
-  bar(); 
+  bar();
 }
-
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/muladdsi3.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/muladdsi3.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/muladdsi3.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/muladdsi3.c	2013-05-28 13:15:34.000000000 +0200
@@ -0,0 +1,19 @@
+/* { dg-do run } */
+
+int test_status=1;
+__attribute__((noinline)) void bar(int a, int b, int c)
+{
+  if (a==33 && b==44 && c==55) 
+     test_status=0;
+}
+
+void foo(int a, int b)
+{
+  bar(11 + 22 * a, 44 * b, 55);
+}
+
+int main()
+{
+  foo(1, 1);
+  return test_status;
+}
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/nested-func-4.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/nested-func-4.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/nested-func-4.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/nested-func-4.c	2013-05-28 13:15:34.000000000 +0200
@@ -1,4 +1,3 @@
-/* { dg-do run } */
 /* { dg-options "-pg" } */
 /* { dg-options "-pg -static" { target hppa*-*-hpux* } } */
 /* { dg-require-profiling "-pg" } */
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/pr36998.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/pr36998.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/pr36998.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/pr36998.c	2013-05-28 13:15:34.000000000 +0200
@@ -2,7 +2,7 @@
 /* { dg-do compile } */
 /* { dg-options "-Os -fasynchronous-unwind-tables" } */
 /* { dg-options "-Os -mpreferred-stack-boundary=2 -fasynchronous-unwind-tables" { target { { i?86-*-* x86_64-*-* } && ia32 } } } */
-/* { dg-options "-fno-omit-frame-pointer" { target { avr-*-* } } } */
+/* { dg-options "-fno-omit-frame-pointer" { target { avr-*-* sh-*-* } } } */
 
 void foo (const char *, ...) __attribute__ ((noreturn));
 int bar (const char *, ...);
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/pr42427.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/pr42427.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/pr42427.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/pr42427.c	2013-05-28 13:15:34.000000000 +0200
@@ -2,6 +2,7 @@
 /* { dg-options "-O2 -fexceptions -fnon-call-exceptions -fpeel-loops" } */
 /* { dg-add-options c99_runtime } */
 /* { dg-require-effective-target ilp32 } */
+/* { dg-require-effective-target complex } */
 
 #include <complex.h>
 
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/profiling/branch-probabilities/main.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/profiling/branch-probabilities/main.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/profiling/branch-probabilities/main.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/profiling/branch-probabilities/main.c	2013-05-28 13:15:34.000000000 +0200
@@ -0,0 +1,22 @@
+/* { dg-do link } */
+/* { dg-options { -O2 -fno-inline -fprofile-arcs } } */
+/* { dg-additional-sources "others.c others3.c" } */
+/* { dg-do run { target native } } */
+
+main()
+{
+  int i = 0;
+
+  puts ("foo");
+
+  for (i=0; i < 100000; i++)
+    {
+      freq();
+      freq1();
+    }
+
+  unfreq1();
+  unfreq2();
+
+  return 0;
+}
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/profiling/branch-probabilities/others3.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/profiling/branch-probabilities/others3.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/profiling/branch-probabilities/others3.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/profiling/branch-probabilities/others3.c	2013-05-28 13:15:34.000000000 +0200
@@ -0,0 +1,9 @@
+/* { dg-do assemble } */
+/* { dg-options { -O2 -fno-inline -fbranch-probabilities } } */
+
+never3()
+{
+}
+
+/* { dg-final { scan-obj { <_never3> }    { section .text.unlikely: }          { Disassembly of section } { others3.o } } } */
+/* { dg-final { cleanup-saved-temps ".gcda" } } */
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/profiling/branch-probabilities/others.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/profiling/branch-probabilities/others.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/profiling/branch-probabilities/others.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/profiling/branch-probabilities/others.c	2013-05-28 13:15:34.000000000 +0200
@@ -0,0 +1,52 @@
+/* { dg-do assemble } */
+/* { dg-options { -O2 -fno-inline -fbranch-probabilities } } */
+
+void unfreq1() __attribute__ ((cold)) ;
+void freq1() __attribute__ ((hot)) ;
+void notfreq1() __attribute__ ((hot)) ;
+
+void
+unfreq1()
+{
+}
+
+void
+freq1()
+{
+}
+
+void
+notfreq1()
+{
+}
+
+
+freq()
+{
+}
+
+
+never()
+{
+}
+
+unfreq2()
+{
+}
+
+never2()
+{
+}
+
+__attribute__ ((weak)) wnever()
+{
+}
+
+/* { dg-final { scan-obj { <_unfreq1> }   { section .text: }          { Disassembly of section } { others.o } } } */
+/* { dg-final { scan-obj { <_unfreq2> }   { section .text: }	      { Disassembly of section } { others.o } } } */
+/* { dg-final { scan-obj { <_freq1> }	  { section .text.hot: }      { Disassembly of section } { others.o } } } */
+/* { dg-final { scan-obj { <_freq> }	  { section .text.hot: }      { Disassembly of section } { others.o } } } */
+/* { dg-final { scan-obj { <_notfreq1> }  { section .text.unlikely: } { Disassembly of section } { others.o } } } */
+/* { dg-final { scan-obj { <_never> }	  { section .text.unlikely: } { Disassembly of section } { others.o } } } */
+/* { dg-final { scan-obj { <_never2> }    { section .text.unlikely: } { Disassembly of section } { others.o } } } */
+/* { dg-final { scan-obj { <_wnever> }    { section .text.unlikely: } { Disassembly of section } { others.o } } } */
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/profiling/branch-probabilities-function-section/main.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/profiling/branch-probabilities-function-section/main.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/profiling/branch-probabilities-function-section/main.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/profiling/branch-probabilities-function-section/main.c	2013-05-28 13:15:34.000000000 +0200
@@ -0,0 +1,22 @@
+/* { dg-do link } */
+/* { dg-options { -O2 -fno-inline -fprofile-arcs } } */
+/* { dg-additional-sources "others.c others3.c" } */
+/* { dg-do run { target native } } */
+
+main()
+{
+  int i = 0;
+
+  puts ("foo");
+
+  for (i=0; i < 100000; i++)
+    {
+      freq();
+      freq1();
+    }
+
+  unfreq1();
+  unfreq2();
+
+  return 0;
+}
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/profiling/branch-probabilities-function-section/others3.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/profiling/branch-probabilities-function-section/others3.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/profiling/branch-probabilities-function-section/others3.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/profiling/branch-probabilities-function-section/others3.c	2013-05-28 13:15:34.000000000 +0200
@@ -0,0 +1,9 @@
+/* { dg-do assemble } */
+/* { dg-options { -O2 -fno-inline -fbranch-probabilities -ffunction-sections -fdata-sections -Wl,-gc-section } } */
+
+never3()
+{
+}
+
+/* { dg-final { scan-obj { <_never3> }    { section .text.unlikely.never3: }	      { Disassembly of section } { others3.o } } } */
+/* { dg-final { cleanup-saved-temps ".gcda" } } */
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/profiling/branch-probabilities-function-section/others.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/profiling/branch-probabilities-function-section/others.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/profiling/branch-probabilities-function-section/others.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/profiling/branch-probabilities-function-section/others.c	2013-05-28 13:15:34.000000000 +0200
@@ -0,0 +1,52 @@
+/* { dg-do assemble } */
+/* { dg-options { -O2 -fno-inline -fbranch-probabilities -ffunction-sections -fdata-sections -Wl,-gc-section } } */
+
+void unfreq1() __attribute__ ((cold)) ;
+void freq1() __attribute__ ((hot)) ;
+void notfreq1() __attribute__ ((hot)) ;
+
+void
+unfreq1()
+{
+}
+
+void
+freq1()
+{
+}
+
+void
+notfreq1()
+{
+}
+
+
+freq()
+{
+}
+
+
+never()
+{
+}
+
+unfreq2()
+{
+}
+
+never2()
+{
+}
+
+__attribute__ ((weak)) wnever()
+{
+}
+
+/* { dg-final { scan-obj { <_unfreq1> }   { section .text.unfreq1: }           { Disassembly of section } { others.o } } } */
+/* { dg-final { scan-obj { <_unfreq2> }   { section .text.unfreq2: }	       { Disassembly of section } { others.o } } } */
+/* { dg-final { scan-obj { <_freq1> }	  { section .text.hot.freq1: }         { Disassembly of section } { others.o } } } */
+/* { dg-final { scan-obj { <_freq> }	  { section .text.hot.freq: }	       { Disassembly of section } { others.o } } } */
+/* { dg-final { scan-obj { <_notfreq1> }  { section .text.unlikely.notfreq1: } { Disassembly of section } { others.o } } } */
+/* { dg-final { scan-obj { <_never> }	  { section .text.unlikely.never: }    { Disassembly of section } { others.o } } } */
+/* { dg-final { scan-obj { <_never2> }    { section .text.unlikely.never2: }   { Disassembly of section } { others.o } } } */
+/* { dg-final { scan-obj { <_wnever> }    { section .text.unlikely.wnever: }   { Disassembly of section } { others.o } } } */
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/profiling/default/main.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/profiling/default/main.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/profiling/default/main.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/profiling/default/main.c	2013-05-28 13:15:34.000000000 +0200
@@ -0,0 +1,22 @@
+/* { dg-do link } */
+/* { dg-options { -O2 -fno-inline -fprofile-arcs } } */
+/* { dg-additional-sources "others.c others3.c" } */
+/* { dg-do run { target native } } */
+
+main()
+{
+  int i = 0;
+
+  puts ("foo");
+
+  for (i=0; i < 100000; i++)
+    {
+      freq();
+      freq1();
+    }
+
+  unfreq1();
+  unfreq2();
+
+  return 0;
+}
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/profiling/default/others3.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/profiling/default/others3.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/profiling/default/others3.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/profiling/default/others3.c	2013-05-28 13:15:34.000000000 +0200
@@ -0,0 +1,10 @@
+/* { dg-do assemble } */
+/* { dg-options { -O2 -fno-inline } } */
+
+never3()
+{
+}
+
+/* { dg-final { scan-obj { <_never3> }   { section .text: }	     { Disassembly of section } { others3.o } } } */
+/* { dg-final { cleanup-saved-temps ".gcda" } } */
+
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/profiling/default/others.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/profiling/default/others.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/profiling/default/others.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/profiling/default/others.c	2013-05-28 13:15:34.000000000 +0200
@@ -0,0 +1,52 @@
+/* { dg-do assemble } */
+/* { dg-options { -O2 -fno-inline } } */
+
+void unfreq1() __attribute__ ((cold)) ;
+void freq1() __attribute__ ((hot)) ;
+void notfreq1() __attribute__ ((hot)) ;
+
+void
+unfreq1()
+{
+}
+
+void
+freq1()
+{
+}
+
+void
+notfreq1()
+{
+}
+
+
+freq()
+{
+}
+
+
+never()
+{
+}
+
+unfreq2()
+{
+}
+
+never2()
+{
+}
+
+__attribute__ ((weak)) wnever()
+{
+}
+
+/* { dg-final { scan-obj { <_unfreq1> }  { section .text.unlikely: } { Disassembly of section } { others.o } } } */
+/* { dg-final { scan-obj { <_freq1> }	 { section .text.hot: }      { Disassembly of section } { others.o } } } */
+/* { dg-final { scan-obj { <_notfreq1> } { section .text.hot: }      { Disassembly of section } { others.o } } } */
+/* { dg-final { scan-obj { <_freq> }	 { section .text: }	     { Disassembly of section } { others.o } } } */
+/* { dg-final { scan-obj { <_never> }	 { section .text: }	     { Disassembly of section } { others.o } } } */
+/* { dg-final { scan-obj { <_unfreq2> }  { section .text: }	     { Disassembly of section } { others.o } } } */
+/* { dg-final { scan-obj { <_never2> }   { section .text: }	     { Disassembly of section } { others.o } } } */
+/* { dg-final { scan-obj { <_wnever> }   { section .text: }	     { Disassembly of section } { others.o } } } */
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/profiling/function-section/main.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/profiling/function-section/main.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/profiling/function-section/main.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/profiling/function-section/main.c	2013-05-28 13:15:34.000000000 +0200
@@ -0,0 +1,22 @@
+/* { dg-do link } */
+/* { dg-options { -O2 -fno-inline -fprofile-arcs } } */
+/* { dg-additional-sources "others.c others3.c" } */
+/* { dg-do run { target native } } */
+
+main()
+{
+  int i = 0;
+
+  puts ("foo");
+
+  for (i=0; i < 100000; i++)
+    {
+      freq();
+      freq1();
+    }
+
+  unfreq1();
+  unfreq2();
+
+  return 0;
+}
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/profiling/function-section/others3.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/profiling/function-section/others3.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/profiling/function-section/others3.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/profiling/function-section/others3.c	2013-05-28 13:15:34.000000000 +0200
@@ -0,0 +1,9 @@
+/* { dg-do assemble } */
+/* { dg-options { -O2 -fno-inline -ffunction-sections } } */
+
+never3()
+{
+}
+
+/* { dg-final { scan-obj { <_never3> }   { section .text.never3: }	     { Disassembly of section } { others3.o } } } */
+/* { dg-final { cleanup-saved-temps ".gcda" } } */
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/profiling/function-section/others.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/profiling/function-section/others.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/profiling/function-section/others.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/profiling/function-section/others.c	2013-05-28 13:15:34.000000000 +0200
@@ -0,0 +1,52 @@
+/* { dg-do assemble } */
+/* { dg-options { -O2 -fno-inline -ffunction-sections } } */
+
+void unfreq1() __attribute__ ((cold)) ;
+void freq1() __attribute__ ((hot)) ;
+void notfreq1() __attribute__ ((hot)) ;
+
+void
+unfreq1()
+{
+}
+
+void
+freq1()
+{
+}
+
+void
+notfreq1()
+{
+}
+
+
+freq()
+{
+}
+
+
+never()
+{
+}
+
+unfreq2()
+{
+}
+
+never2()
+{
+}
+
+__attribute__ ((weak)) wnever()
+{
+}
+
+/* { dg-final { scan-obj { <_unfreq1> }  { section .text.unlikely.unfreq1: } { Disassembly of section } { others.o } } } */
+/* { dg-final { scan-obj { <_freq1> }	 { section .text.hot.freq1: }	     { Disassembly of section } { others.o } } } */
+/* { dg-final { scan-obj { <_notfreq1> } { section .text.hot.notfreq1: }     { Disassembly of section } { others.o } } } */
+/* { dg-final { scan-obj { <_freq> }	 { section .text.freq: }	     { Disassembly of section } { others.o } } } */
+/* { dg-final { scan-obj { <_never> }	 { section .text.never: }	     { Disassembly of section } { others.o } } } */
+/* { dg-final { scan-obj { <_unfreq2> }  { section .text.unfreq2: }	     { Disassembly of section } { others.o } } } */
+/* { dg-final { scan-obj { <_never2> }   { section .text.never2: }	     { Disassembly of section } { others.o } } } */
+/* { dg-final { scan-obj { <_wnever> }   { section .text.wnever: }	     { Disassembly of section } { others.o } } } */
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/profiling/profiling.exp gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/profiling/profiling.exp
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/profiling/profiling.exp	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/profiling/profiling.exp	2013-05-28 13:15:34.000000000 +0200
@@ -0,0 +1,34 @@
+#   Copyright (C) 2004, 2007 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+# Profiling option to add to the existing options set
+# The first argument is the line number of the dg-profile-options directive
+# within the test file. Remaining arguments are as for xfail lists:
+# option { target }
+
+# Load support procs.
+load_lib gcc-dg.exp
+load_lib scanobj.exp
+
+# Initialize `dg'.
+dg-init
+
+# Main loop.
+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*/*.c ]] \
+        "" ""
+
+# All done.
+dg-finish
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/shlrtst.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/shlrtst.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/shlrtst.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/shlrtst.c	2013-05-28 13:15:34.000000000 +0200
@@ -0,0 +1,25 @@
+/* { dg-do run } */
+
+extern void abort (void);
+unsigned char test_char[2] ={0x80,0x40};
+
+void Funtion_test(unsigned char *buf, unsigned int num)
+{
+    unsigned int byte = num / 2;
+
+    if(!num)
+      buf[ byte] |= 0x80;
+    else
+      buf[ byte] |= 0x7f;      
+}
+
+main()
+{
+  Funtion_test(test_char, 0);
+
+  if (test_char[0] != 0x80)
+    abort();
+
+  return 0;
+}
+
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/ssp.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/ssp.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/ssp.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/ssp.c	2013-05-28 13:15:34.000000000 +0200
@@ -0,0 +1,13 @@
+/* { dg-do compile { target fpic } } */
+/* { dg-options "-Os -fpic -fstack-protector-all -fnon-call-exceptions " } */
+/* Causes error: unable to find a register to spill in class 'R0_REGS' on SH4 */
+
+int
+foo (int d, int rp)
+{
+  if (d == 0)
+    if (rp == 0)
+      return 1;
+
+  return 0;
+}
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/tree-ssa/scev-bitfield.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/tree-ssa/scev-bitfield.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.dg/tree-ssa/scev-bitfield.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.dg/tree-ssa/scev-bitfield.c	2013-05-28 13:15:34.000000000 +0200
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-Os" } */
+
+struct dwarf_frame_register
+{
+  long long value:(sizeof (long long) * 8 - 3);
+};
+
+void
+execute_cfi (int address_size,  struct dwarf_frame_register *fs)
+{
+  long long regno = 0 ;
+
+  for (; regno < 32; ++regno)
+    fs[regno].value = regno * address_size;
+}
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.target/sh/array-index.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.target/sh/array-index.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.target/sh/array-index.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.target/sh/array-index.c	2013-06-28 16:03:15.000000000 +0200
@@ -0,0 +1,13 @@
+/* PR tree-optimization/39423 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+int
+foo (int tab[], int index)
+{
+  return tab [index + 1];
+}
+
+/* { dg-final { scan-assembler "mov.l\t@\\(4,r\[0-9]\+\\)" } } */
+
+
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.target/sh/cmpstr.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.target/sh/cmpstr.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.target/sh/cmpstr.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.target/sh/cmpstr.c	2013-11-05 14:59:40.000000000 +0100
@@ -0,0 +1,27 @@
+/* Check that the __builtin_strcmp function is inlined with cmp/str
+   when optimizing for speed.  */
+/* { dg-do compile { target "sh*-*-*" } } */
+/* { dg-options "-O2" } */
+/* { dg-skip-if "" { "sh*-*-*" } { "-m5*" } { "" } } */
+/* { dg-final { scan-assembler-not "jmp" } } */
+/* { dg-final { scan-assembler-times "cmp/str" 3 } } */
+/* { dg-final { scan-assembler-times "tst\t#3" 2 } } */
+
+test00 (const char *s1, const char *s2)
+{
+  return __builtin_strcmp (s1, s2);
+}
+
+/* NB: This might change as further optimisation might detect the
+   max length and fallback to cmpstrn.  */
+test01(const char *s2)
+{
+  return __builtin_strcmp ("abc", s2);
+}
+
+/* Check that no test for alignment is needed.  */
+test03(const char *s1, const char *s2)
+{
+  return __builtin_strcmp (__builtin_assume_aligned (s1, 4),
+			   __builtin_assume_aligned (s2, 4));
+}
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.target/sh/cmpstrn.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.target/sh/cmpstrn.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.target/sh/cmpstrn.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.target/sh/cmpstrn.c	2014-01-13 10:24:57.000000000 +0100
@@ -0,0 +1,28 @@
+/* Check that the __builtin_strncmp function is inlined
+   when optimizing for speed.  */
+/* { dg-do compile }  */
+/* { dg-options "-O2" } */
+/* { dg-skip-if "" { "sh*-*-*" } { "-m5*" } { "" } } */
+/* { dg-final { scan-assembler-not "jmp" } } */
+/* { dg-final { scan-assembler-times "cmp/str" 1 } } */
+
+/* Test that cmp/str is not used for small lengths.  */
+test01(const char *s1)
+{
+  return __builtin_strncmp (s1, "abcde", 3);
+}
+
+/* Test that the cmp/str loop is used.  */
+test02(const char *s1)
+{
+  return __builtin_strncmp (s1, "abcdefghi", 8);
+}
+
+/* Test that no call is generated  */
+test03(const char *s1, int n)
+{
+  return __builtin_strncmp (s1, "abcde", n);
+}
+
+
+
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.target/sh/executejava_standard.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.target/sh/executejava_standard.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.target/sh/executejava_standard.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.target/sh/executejava_standard.c	2013-05-28 13:15:34.000000000 +0200
@@ -0,0 +1,10235 @@
+/* { dg-do compile { target "sh-*-*" } } */
+/* { dg-options "-w" } */
+
+typedef long long CVMInt64;
+typedef int CVMInt32;
+typedef short CVMInt16;
+typedef signed char CVMInt8;
+typedef unsigned long long CVMUint64;
+typedef unsigned int CVMUint32;
+typedef unsigned short CVMUint16;
+typedef unsigned char CVMUint8;
+typedef float CVMfloat32;
+typedef double CVMfloat64;
+typedef unsigned int CVMAddr;
+typedef unsigned int CVMSize;
+typedef int ptrdiff_t;
+typedef unsigned int size_t;
+typedef long int wchar_t;
+typedef unsigned char __u_char;
+typedef unsigned short int __u_short;
+typedef unsigned int __u_int;
+typedef unsigned long int __u_long;
+typedef signed char __int8_t;
+typedef unsigned char __uint8_t;
+typedef signed short int __int16_t;
+typedef unsigned short int __uint16_t;
+typedef signed int __int32_t;
+typedef unsigned int __uint32_t;
+__extension__ typedef signed long long int __int64_t;
+__extension__ typedef unsigned long long int __uint64_t;
+__extension__ typedef long long int __quad_t;
+__extension__ typedef unsigned long long int __u_quad_t;
+__extension__ typedef __u_quad_t __dev_t;
+__extension__ typedef unsigned int __uid_t;
+__extension__ typedef unsigned int __gid_t;
+__extension__ typedef unsigned long int __ino_t;
+__extension__ typedef __u_quad_t __ino64_t;
+__extension__ typedef unsigned int __mode_t;
+__extension__ typedef unsigned int __nlink_t;
+__extension__ typedef long int __off_t;
+__extension__ typedef __quad_t __off64_t;
+__extension__ typedef int __pid_t;
+__extension__ typedef struct { int __val[2]; } __fsid_t;
+__extension__ typedef long int __clock_t;
+__extension__ typedef unsigned long int __rlim_t;
+__extension__ typedef __u_quad_t __rlim64_t;
+__extension__ typedef unsigned int __id_t;
+__extension__ typedef long int __time_t;
+__extension__ typedef unsigned int __useconds_t;
+__extension__ typedef long int __suseconds_t;
+__extension__ typedef int __daddr_t;
+__extension__ typedef long int __swblk_t;
+__extension__ typedef int __key_t;
+__extension__ typedef int __clockid_t;
+__extension__ typedef void * __timer_t;
+__extension__ typedef long int __blksize_t;
+__extension__ typedef long int __blkcnt_t;
+__extension__ typedef __quad_t __blkcnt64_t;
+__extension__ typedef unsigned long int __fsblkcnt_t;
+__extension__ typedef __u_quad_t __fsblkcnt64_t;
+__extension__ typedef unsigned long int __fsfilcnt_t;
+__extension__ typedef __u_quad_t __fsfilcnt64_t;
+__extension__ typedef int __ssize_t;
+typedef __off64_t __loff_t;
+typedef __quad_t *__qaddr_t;
+typedef char *__caddr_t;
+__extension__ typedef int __intptr_t;
+__extension__ typedef unsigned int __socklen_t;
+struct _IO_FILE;
+typedef struct _IO_FILE FILE;
+typedef struct _IO_FILE __FILE;
+typedef struct
+{
+  int __count;
+  union
+  {
+    unsigned int __wch;
+    char __wchb[4];
+  } __value;
+} __mbstate_t;
+typedef struct
+{
+  __off_t __pos;
+  __mbstate_t __state;
+} _G_fpos_t;
+typedef struct
+{
+  __off64_t __pos;
+  __mbstate_t __state;
+} _G_fpos64_t;
+typedef int _G_int16_t __attribute__ ((__mode__ (__HI__)));
+typedef int _G_int32_t __attribute__ ((__mode__ (__SI__)));
+typedef unsigned int _G_uint16_t __attribute__ ((__mode__ (__HI__)));
+typedef unsigned int _G_uint32_t __attribute__ ((__mode__ (__SI__)));
+typedef __builtin_va_list __gnuc_va_list;
+struct _IO_jump_t; struct _IO_FILE;
+typedef void _IO_lock_t;
+struct _IO_marker {
+  struct _IO_marker *_next;
+  struct _IO_FILE *_sbuf;
+  int _pos;
+};
+enum __codecvt_result
+{
+  __codecvt_ok,
+  __codecvt_partial,
+  __codecvt_error,
+  __codecvt_noconv
+};
+struct _IO_FILE {
+  int _flags;
+  char* _IO_read_ptr;
+  char* _IO_read_end;
+  char* _IO_read_base;
+  char* _IO_write_base;
+  char* _IO_write_ptr;
+  char* _IO_write_end;
+  char* _IO_buf_base;
+  char* _IO_buf_end;
+  char *_IO_save_base;
+  char *_IO_backup_base;
+  char *_IO_save_end;
+  struct _IO_marker *_markers;
+  struct _IO_FILE *_chain;
+  int _fileno;
+  int _flags2;
+  __off_t _old_offset;
+  unsigned short _cur_column;
+  signed char _vtable_offset;
+  char _shortbuf[1];
+  _IO_lock_t *_lock;
+  __off64_t _offset;
+  void *__pad1;
+  void *__pad2;
+  void *__pad3;
+  void *__pad4;
+  size_t __pad5;
+  int _mode;
+  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
+};
+typedef struct _IO_FILE _IO_FILE;
+struct _IO_FILE_plus;
+extern struct _IO_FILE_plus _IO_2_1_stdin_;
+extern struct _IO_FILE_plus _IO_2_1_stdout_;
+extern struct _IO_FILE_plus _IO_2_1_stderr_;
+typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);
+typedef __ssize_t __io_write_fn (void *__cookie, __const char *__buf,
+     size_t __n);
+typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);
+typedef int __io_close_fn (void *__cookie);
+typedef __io_read_fn cookie_read_function_t;
+typedef __io_write_fn cookie_write_function_t;
+typedef __io_seek_fn cookie_seek_function_t;
+typedef __io_close_fn cookie_close_function_t;
+typedef struct
+{
+  __io_read_fn *read;
+  __io_write_fn *write;
+  __io_seek_fn *seek;
+  __io_close_fn *close;
+} _IO_cookie_io_functions_t;
+typedef _IO_cookie_io_functions_t cookie_io_functions_t;
+struct _IO_cookie_file;
+extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
+        void *__cookie, _IO_cookie_io_functions_t __fns);
+extern int __underflow (_IO_FILE *);
+extern int __uflow (_IO_FILE *);
+extern int __overflow (_IO_FILE *, int);
+extern int _IO_getc (_IO_FILE *__fp);
+extern int _IO_putc (int __c, _IO_FILE *__fp);
+extern int _IO_feof (_IO_FILE *__fp) __attribute__ ((__nothrow__));
+extern int _IO_ferror (_IO_FILE *__fp) __attribute__ ((__nothrow__));
+extern int _IO_peekc_locked (_IO_FILE *__fp);
+extern void _IO_flockfile (_IO_FILE *) __attribute__ ((__nothrow__));
+extern void _IO_funlockfile (_IO_FILE *) __attribute__ ((__nothrow__));
+extern int _IO_ftrylockfile (_IO_FILE *) __attribute__ ((__nothrow__));
+extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
+   __gnuc_va_list, int *__restrict);
+extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
+    __gnuc_va_list);
+extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
+extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);
+extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
+extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);
+extern void _IO_free_backup_area (_IO_FILE *) __attribute__ ((__nothrow__));
+typedef __gnuc_va_list va_list;
+typedef _G_fpos_t fpos_t;
+typedef _G_fpos64_t fpos64_t;
+extern struct _IO_FILE *stdin;
+extern struct _IO_FILE *stdout;
+extern struct _IO_FILE *stderr;
+extern int remove (__const char *__filename) __attribute__ ((__nothrow__));
+extern int rename (__const char *__old, __const char *__new) __attribute__ ((__nothrow__));
+extern int renameat (int __oldfd, __const char *__old, int __newfd,
+       __const char *__new) __attribute__ ((__nothrow__));
+extern FILE *tmpfile (void) __attribute__ ((__warn_unused_result__));
+extern FILE *tmpfile64 (void) __attribute__ ((__warn_unused_result__));
+extern char *tmpnam (char *__s) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern char *tempnam (__const char *__dir, __const char *__pfx)
+     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));
+extern int fclose (FILE *__stream);
+extern int fflush (FILE *__stream);
+extern int fflush_unlocked (FILE *__stream);
+extern int fcloseall (void);
+extern FILE *fopen (__const char *__restrict __filename,
+      __const char *__restrict __modes) __attribute__ ((__warn_unused_result__));
+extern FILE *freopen (__const char *__restrict __filename,
+        __const char *__restrict __modes,
+        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
+extern FILE *fopen64 (__const char *__restrict __filename,
+        __const char *__restrict __modes) __attribute__ ((__warn_unused_result__));
+extern FILE *freopen64 (__const char *__restrict __filename,
+   __const char *__restrict __modes,
+   FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
+extern FILE *fdopen (int __fd, __const char *__modes) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern FILE *fopencookie (void *__restrict __magic_cookie,
+     __const char *__restrict __modes,
+     _IO_cookie_io_functions_t __io_funcs) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern FILE *fmemopen (void *__s, size_t __len, __const char *__modes)
+  __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__));
+extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
+      int __modes, size_t __n) __attribute__ ((__nothrow__));
+extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
+         size_t __size) __attribute__ ((__nothrow__));
+extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__));
+extern int fprintf (FILE *__restrict __stream,
+      __const char *__restrict __format, ...);
+extern int printf (__const char *__restrict __format, ...);
+extern int sprintf (char *__restrict __s,
+      __const char *__restrict __format, ...) __attribute__ ((__nothrow__));
+extern int vfprintf (FILE *__restrict __s, __const char *__restrict __format,
+       __gnuc_va_list __arg);
+extern int vprintf (__const char *__restrict __format, __gnuc_va_list __arg);
+extern int vsprintf (char *__restrict __s, __const char *__restrict __format,
+       __gnuc_va_list __arg) __attribute__ ((__nothrow__));
+extern int snprintf (char *__restrict __s, size_t __maxlen,
+       __const char *__restrict __format, ...)
+     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));
+extern int vsnprintf (char *__restrict __s, size_t __maxlen,
+        __const char *__restrict __format, __gnuc_va_list __arg)
+     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));
+extern int vasprintf (char **__restrict __ptr, __const char *__restrict __f,
+        __gnuc_va_list __arg)
+     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0))) __attribute__ ((__warn_unused_result__));
+extern int __asprintf (char **__restrict __ptr,
+         __const char *__restrict __fmt, ...)
+     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) __attribute__ ((__warn_unused_result__));
+extern int asprintf (char **__restrict __ptr,
+       __const char *__restrict __fmt, ...)
+     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) __attribute__ ((__warn_unused_result__));
+extern int vdprintf (int __fd, __const char *__restrict __fmt,
+       __gnuc_va_list __arg)
+     __attribute__ ((__format__ (__printf__, 2, 0)));
+extern int dprintf (int __fd, __const char *__restrict __fmt, ...)
+     __attribute__ ((__format__ (__printf__, 2, 3)));
+extern int fscanf (FILE *__restrict __stream,
+     __const char *__restrict __format, ...) __attribute__ ((__warn_unused_result__));
+extern int scanf (__const char *__restrict __format, ...) __attribute__ ((__warn_unused_result__));
+extern int sscanf (__const char *__restrict __s,
+     __const char *__restrict __format, ...) __attribute__ ((__nothrow__));
+extern int vfscanf (FILE *__restrict __s, __const char *__restrict __format,
+      __gnuc_va_list __arg)
+     __attribute__ ((__format__ (__scanf__, 2, 0))) __attribute__ ((__warn_unused_result__));
+extern int vscanf (__const char *__restrict __format, __gnuc_va_list __arg)
+     __attribute__ ((__format__ (__scanf__, 1, 0))) __attribute__ ((__warn_unused_result__));
+extern int vsscanf (__const char *__restrict __s,
+      __const char *__restrict __format, __gnuc_va_list __arg)
+     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__scanf__, 2, 0)));
+extern int fgetc (FILE *__stream);
+extern int getc (FILE *__stream);
+extern int getchar (void);
+extern int getc_unlocked (FILE *__stream);
+extern int getchar_unlocked (void);
+extern int fgetc_unlocked (FILE *__stream);
+extern int fputc (int __c, FILE *__stream);
+extern int putc (int __c, FILE *__stream);
+extern int putchar (int __c);
+extern int fputc_unlocked (int __c, FILE *__stream);
+extern int putc_unlocked (int __c, FILE *__stream);
+extern int putchar_unlocked (int __c);
+extern int getw (FILE *__stream);
+extern int putw (int __w, FILE *__stream);
+extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
+     __attribute__ ((__warn_unused_result__));
+extern char *gets (char *__s) __attribute__ ((__warn_unused_result__));
+extern char *fgets_unlocked (char *__restrict __s, int __n,
+        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
+extern __ssize_t __getdelim (char **__restrict __lineptr,
+          size_t *__restrict __n, int __delimiter,
+          FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
+extern __ssize_t getdelim (char **__restrict __lineptr,
+        size_t *__restrict __n, int __delimiter,
+        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
+extern __ssize_t getline (char **__restrict __lineptr,
+       size_t *__restrict __n,
+       FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
+extern int fputs (__const char *__restrict __s, FILE *__restrict __stream);
+extern int puts (__const char *__s);
+extern int ungetc (int __c, FILE *__stream);
+extern size_t fread (void *__restrict __ptr, size_t __size,
+       size_t __n, FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
+extern size_t fwrite (__const void *__restrict __ptr, size_t __size,
+        size_t __n, FILE *__restrict __s) __attribute__ ((__warn_unused_result__));
+extern int fputs_unlocked (__const char *__restrict __s,
+      FILE *__restrict __stream);
+extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
+         size_t __n, FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
+extern size_t fwrite_unlocked (__const void *__restrict __ptr, size_t __size,
+          size_t __n, FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
+extern int fseek (FILE *__stream, long int __off, int __whence);
+extern long int ftell (FILE *__stream) __attribute__ ((__warn_unused_result__));
+extern void rewind (FILE *__stream);
+extern int fseeko (FILE *__stream, __off_t __off, int __whence);
+extern __off_t ftello (FILE *__stream) __attribute__ ((__warn_unused_result__));
+extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);
+extern int fsetpos (FILE *__stream, __const fpos_t *__pos);
+extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
+extern __off64_t ftello64 (FILE *__stream) __attribute__ ((__warn_unused_result__));
+extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
+extern int fsetpos64 (FILE *__stream, __const fpos64_t *__pos);
+extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__));
+extern int feof (FILE *__stream) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern int ferror (FILE *__stream) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__));
+extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern void perror (__const char *__s);
+extern int sys_nerr;
+extern __const char *__const sys_errlist[];
+extern int _sys_nerr;
+extern __const char *__const _sys_errlist[];
+extern int fileno (FILE *__stream) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern FILE *popen (__const char *__command, __const char *__modes) __attribute__ ((__warn_unused_result__));
+extern int pclose (FILE *__stream);
+extern char *ctermid (char *__s) __attribute__ ((__nothrow__));
+extern char *cuserid (char *__s);
+struct obstack;
+extern int obstack_printf (struct obstack *__restrict __obstack,
+      __const char *__restrict __format, ...)
+     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3)));
+extern int obstack_vprintf (struct obstack *__restrict __obstack,
+       __const char *__restrict __format,
+       __gnuc_va_list __args)
+     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0)));
+extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__));
+extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__));
+extern __inline int
+getchar (void)
+{
+  return _IO_getc (stdin);
+}
+extern __inline int
+fgetc_unlocked (FILE *__fp)
+{
+  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
+}
+extern __inline int
+getc_unlocked (FILE *__fp)
+{
+  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
+}
+extern __inline int
+getchar_unlocked (void)
+{
+  return (__builtin_expect (((stdin)->_IO_read_ptr >= (stdin)->_IO_read_end), 0) ? __uflow (stdin) : *(unsigned char *) (stdin)->_IO_read_ptr++);
+}
+extern __inline int
+putchar (int __c)
+{
+  return _IO_putc (__c, stdout);
+}
+extern __inline int
+fputc_unlocked (int __c, FILE *__stream)
+{
+  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
+}
+extern __inline int
+putc_unlocked (int __c, FILE *__stream)
+{
+  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
+}
+extern __inline int
+putchar_unlocked (int __c)
+{
+  return (__builtin_expect (((stdout)->_IO_write_ptr >= (stdout)->_IO_write_end), 0) ? __overflow (stdout, (unsigned char) (__c)) : (unsigned char) (*(stdout)->_IO_write_ptr++ = (__c)));
+}
+extern __inline __ssize_t
+getline (char **__lineptr, size_t *__n, FILE *__stream)
+{
+  return __getdelim (__lineptr, __n, '\n', __stream);
+}
+extern __inline int
+__attribute__ ((__nothrow__)) feof_unlocked (FILE *__stream)
+{
+  return (((__stream)->_flags & 0x10) != 0);
+}
+extern __inline int
+__attribute__ ((__nothrow__)) ferror_unlocked (FILE *__stream)
+{
+  return (((__stream)->_flags & 0x20) != 0);
+}
+extern int __sprintf_chk (char *__restrict __s, int __flag, size_t __slen,
+     __const char *__restrict __format, ...) __attribute__ ((__nothrow__));
+extern int __vsprintf_chk (char *__restrict __s, int __flag, size_t __slen,
+      __const char *__restrict __format,
+      __gnuc_va_list __ap) __attribute__ ((__nothrow__));
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
+__attribute__ ((__nothrow__)) sprintf (char *__restrict __s, __const char *__restrict __fmt, ...)
+{
+  return __builtin___sprintf_chk (__s, 2 - 1,
+      __builtin_object_size (__s, 2 > 1), __fmt, __builtin_va_arg_pack ());
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
+__attribute__ ((__nothrow__)) vsprintf (char *__restrict __s, __const char *__restrict __fmt, __gnuc_va_list __ap)
+{
+  return __builtin___vsprintf_chk (__s, 2 - 1,
+       __builtin_object_size (__s, 2 > 1), __fmt, __ap);
+}
+extern int __snprintf_chk (char *__restrict __s, size_t __n, int __flag,
+      size_t __slen, __const char *__restrict __format,
+      ...) __attribute__ ((__nothrow__));
+extern int __vsnprintf_chk (char *__restrict __s, size_t __n, int __flag,
+       size_t __slen, __const char *__restrict __format,
+       __gnuc_va_list __ap) __attribute__ ((__nothrow__));
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
+__attribute__ ((__nothrow__)) snprintf (char *__restrict __s, size_t __n, __const char *__restrict __fmt, ...)
+{
+  return __builtin___snprintf_chk (__s, __n, 2 - 1,
+       __builtin_object_size (__s, 2 > 1), __fmt, __builtin_va_arg_pack ());
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
+__attribute__ ((__nothrow__)) vsnprintf (char *__restrict __s, size_t __n, __const char *__restrict __fmt, __gnuc_va_list __ap)
+{
+  return __builtin___vsnprintf_chk (__s, __n, 2 - 1,
+        __builtin_object_size (__s, 2 > 1), __fmt, __ap);
+}
+extern int __fprintf_chk (FILE *__restrict __stream, int __flag,
+     __const char *__restrict __format, ...);
+extern int __printf_chk (int __flag, __const char *__restrict __format, ...);
+extern int __vfprintf_chk (FILE *__restrict __stream, int __flag,
+      __const char *__restrict __format, __gnuc_va_list __ap);
+extern int __vprintf_chk (int __flag, __const char *__restrict __format,
+     __gnuc_va_list __ap);
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
+fprintf (FILE *__restrict __stream, __const char *__restrict __fmt, ...)
+{
+  return __fprintf_chk (__stream, 2 - 1, __fmt,
+   __builtin_va_arg_pack ());
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
+printf (__const char *__restrict __fmt, ...)
+{
+  return __printf_chk (2 - 1, __fmt, __builtin_va_arg_pack ());
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
+vprintf (__const char *__restrict __fmt, __gnuc_va_list __ap)
+{
+  return __vfprintf_chk (stdout, 2 - 1, __fmt, __ap);
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
+vfprintf (FILE *__restrict __stream,
+   __const char *__restrict __fmt, __gnuc_va_list __ap)
+{
+  return __vfprintf_chk (__stream, 2 - 1, __fmt, __ap);
+}
+extern int __asprintf_chk (char **__restrict __ptr, int __flag,
+      __const char *__restrict __fmt, ...)
+     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4))) __attribute__ ((__warn_unused_result__));
+extern int __vasprintf_chk (char **__restrict __ptr, int __flag,
+       __const char *__restrict __fmt, __gnuc_va_list __arg)
+     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0))) __attribute__ ((__warn_unused_result__));
+extern int __dprintf_chk (int __fd, int __flag, __const char *__restrict __fmt,
+     ...) __attribute__ ((__format__ (__printf__, 3, 4)));
+extern int __vdprintf_chk (int __fd, int __flag,
+      __const char *__restrict __fmt, __gnuc_va_list __arg)
+     __attribute__ ((__format__ (__printf__, 3, 0)));
+extern int __obstack_printf_chk (struct obstack *__restrict __obstack,
+     int __flag, __const char *__restrict __format,
+     ...)
+     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));
+extern int __obstack_vprintf_chk (struct obstack *__restrict __obstack,
+      int __flag,
+      __const char *__restrict __format,
+      __gnuc_va_list __args)
+     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
+__attribute__ ((__nothrow__)) asprintf (char **__restrict __ptr, __const char *__restrict __fmt, ...)
+{
+  return __asprintf_chk (__ptr, 2 - 1, __fmt,
+    __builtin_va_arg_pack ());
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
+__attribute__ ((__nothrow__)) __asprintf (char **__restrict __ptr, __const char *__restrict __fmt, ...)
+{
+  return __asprintf_chk (__ptr, 2 - 1, __fmt,
+    __builtin_va_arg_pack ());
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
+dprintf (int __fd, __const char *__restrict __fmt, ...)
+{
+  return __dprintf_chk (__fd, 2 - 1, __fmt,
+   __builtin_va_arg_pack ());
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
+__attribute__ ((__nothrow__)) obstack_printf (struct obstack *__restrict __obstack, __const char *__restrict __fmt, ...)
+{
+  return __obstack_printf_chk (__obstack, 2 - 1, __fmt,
+          __builtin_va_arg_pack ());
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
+__attribute__ ((__nothrow__)) vasprintf (char **__restrict __ptr, __const char *__restrict __fmt, __gnuc_va_list __ap)
+{
+  return __vasprintf_chk (__ptr, 2 - 1, __fmt, __ap);
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
+vdprintf (int __fd, __const char *__restrict __fmt, __gnuc_va_list __ap)
+{
+  return __vdprintf_chk (__fd, 2 - 1, __fmt, __ap);
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
+__attribute__ ((__nothrow__)) obstack_vprintf (struct obstack *__restrict __obstack, __const char *__restrict __fmt, __gnuc_va_list __ap)
+{
+  return __obstack_vprintf_chk (__obstack, 2 - 1, __fmt,
+    __ap);
+}
+extern char *__gets_chk (char *__str, size_t) __attribute__ ((__warn_unused_result__));
+extern char *__gets_warn (char *__str) __asm__ ("" "gets")
+     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("please use fgets or getline instead, gets can't " "specify buffer size")))
+                               ;
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) char *
+gets (char *__str)
+{
+  if (__builtin_object_size (__str, 2 > 1) != (size_t) -1)
+    return __gets_chk (__str, __builtin_object_size (__str, 2 > 1));
+  return __gets_warn (__str);
+}
+extern char *__fgets_chk (char *__restrict __s, size_t __size, int __n,
+     FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
+extern char *__fgets_alias (char *__restrict __s, int __n, FILE *__restrict __stream) __asm__ ("" "fgets")
+                                        __attribute__ ((__warn_unused_result__));
+extern char *__fgets_chk_warn (char *__restrict __s, size_t __size, int __n, FILE *__restrict __stream) __asm__ ("" "__fgets_chk")
+     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fgets called with bigger size than length " "of destination buffer")))
+                                 ;
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) char *
+fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
+{
+  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__n) || __n <= 0)
+ return __fgets_chk (__s, __builtin_object_size (__s, 2 > 1), __n, __stream);
+      if ((size_t) __n > __builtin_object_size (__s, 2 > 1))
+ return __fgets_chk_warn (__s, __builtin_object_size (__s, 2 > 1), __n, __stream);
+    }
+  return __fgets_alias (__s, __n, __stream);
+}
+extern size_t __fread_chk (void *__restrict __ptr, size_t __ptrlen,
+      size_t __size, size_t __n,
+      FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
+extern size_t __fread_alias (void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "fread")
+            __attribute__ ((__warn_unused_result__));
+extern size_t __fread_chk_warn (void *__restrict __ptr, size_t __ptrlen, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "__fread_chk")
+     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fread called with bigger size * nmemb than length " "of destination buffer")))
+                                 ;
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) size_t
+fread (void *__restrict __ptr, size_t __size, size_t __n,
+       FILE *__restrict __stream)
+{
+  if (__builtin_object_size (__ptr, 0) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__size)
+   || !__builtin_constant_p (__n)
+   || (__size | __n) >= (((size_t) 1) << (8 * sizeof (size_t) / 2)))
+ return __fread_chk (__ptr, __builtin_object_size (__ptr, 0), __size, __n, __stream);
+      if (__size * __n > __builtin_object_size (__ptr, 0))
+ return __fread_chk_warn (__ptr, __builtin_object_size (__ptr, 0), __size, __n, __stream);
+    }
+  return __fread_alias (__ptr, __size, __n, __stream);
+}
+extern char *__fgets_unlocked_chk (char *__restrict __s, size_t __size,
+       int __n, FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
+extern char *__fgets_unlocked_alias (char *__restrict __s, int __n, FILE *__restrict __stream) __asm__ ("" "fgets_unlocked")
+                                                 __attribute__ ((__warn_unused_result__));
+extern char *__fgets_unlocked_chk_warn (char *__restrict __s, size_t __size, int __n, FILE *__restrict __stream) __asm__ ("" "__fgets_unlocked_chk")
+     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fgets_unlocked called with bigger size than length " "of destination buffer")))
+                                 ;
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) char *
+fgets_unlocked (char *__restrict __s, int __n, FILE *__restrict __stream)
+{
+  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__n) || __n <= 0)
+ return __fgets_unlocked_chk (__s, __builtin_object_size (__s, 2 > 1), __n, __stream);
+      if ((size_t) __n > __builtin_object_size (__s, 2 > 1))
+ return __fgets_unlocked_chk_warn (__s, __builtin_object_size (__s, 2 > 1), __n, __stream);
+    }
+  return __fgets_unlocked_alias (__s, __n, __stream);
+}
+extern size_t __fread_unlocked_chk (void *__restrict __ptr, size_t __ptrlen,
+        size_t __size, size_t __n,
+        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
+extern size_t __fread_unlocked_alias (void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "fread_unlocked")
+                     __attribute__ ((__warn_unused_result__));
+extern size_t __fread_unlocked_chk_warn (void *__restrict __ptr, size_t __ptrlen, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "__fread_unlocked_chk")
+     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fread_unlocked called with bigger size * nmemb than " "length of destination buffer")))
+                                        ;
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) size_t
+fread_unlocked (void *__restrict __ptr, size_t __size, size_t __n,
+  FILE *__restrict __stream)
+{
+  if (__builtin_object_size (__ptr, 0) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__size)
+   || !__builtin_constant_p (__n)
+   || (__size | __n) >= (((size_t) 1) << (8 * sizeof (size_t) / 2)))
+ return __fread_unlocked_chk (__ptr, __builtin_object_size (__ptr, 0), __size, __n,
+         __stream);
+      if (__size * __n > __builtin_object_size (__ptr, 0))
+ return __fread_unlocked_chk_warn (__ptr, __builtin_object_size (__ptr, 0), __size, __n,
+       __stream);
+    }
+  if (__builtin_constant_p (__size)
+      && __builtin_constant_p (__n)
+      && (__size | __n) < (((size_t) 1) << (8 * sizeof (size_t) / 2))
+      && __size * __n <= 8)
+    {
+      size_t __cnt = __size * __n;
+      char *__cptr = (char *) __ptr;
+      if (__cnt == 0)
+ return 0;
+      for (; __cnt > 0; --__cnt)
+ {
+   int __c = (__builtin_expect (((__stream)->_IO_read_ptr >= (__stream)->_IO_read_end), 0) ? __uflow (__stream) : *(unsigned char *) (__stream)->_IO_read_ptr++);
+   if (__c == (-1))
+     break;
+   *__cptr++ = __c;
+ }
+      return (__cptr - (char *) __ptr) / __size;
+    }
+  return __fread_unlocked_alias (__ptr, __size, __n, __stream);
+}
+extern void *malloc (size_t __size) __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));
+extern void *calloc (size_t __nmemb, size_t __size) __attribute__ ((__nothrow__))
+       __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));
+extern void *realloc (void *__ptr, size_t __size) __attribute__ ((__nothrow__))
+       __attribute__ ((__warn_unused_result__));
+extern void free (void *__ptr) __attribute__ ((__nothrow__));
+extern void cfree (void *__ptr) __attribute__ ((__nothrow__));
+extern void *memalign (size_t __alignment, size_t __size) __attribute__ ((__nothrow__))
+       __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));
+extern void *valloc (size_t __size) __attribute__ ((__nothrow__))
+       __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));
+extern void * pvalloc (size_t __size) __attribute__ ((__nothrow__))
+       __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));
+extern void *(*__morecore) (ptrdiff_t __size);
+extern void *__default_morecore (ptrdiff_t __size) __attribute__ ((__nothrow__))
+       __attribute__ ((__malloc__));
+struct mallinfo {
+  int arena;
+  int ordblks;
+  int smblks;
+  int hblks;
+  int hblkhd;
+  int usmblks;
+  int fsmblks;
+  int uordblks;
+  int fordblks;
+  int keepcost;
+};
+extern struct mallinfo mallinfo (void) __attribute__ ((__nothrow__));
+extern int mallopt (int __param, int __val) __attribute__ ((__nothrow__));
+extern int malloc_trim (size_t __pad) __attribute__ ((__nothrow__));
+extern size_t malloc_usable_size (void *__ptr) __attribute__ ((__nothrow__));
+extern void malloc_stats (void) __attribute__ ((__nothrow__));
+extern int malloc_info (int __options, FILE *__fp);
+extern void *malloc_get_state (void) __attribute__ ((__nothrow__));
+extern int malloc_set_state (void *__ptr) __attribute__ ((__nothrow__));
+extern void (*__malloc_initialize_hook) (void);
+extern void (*__free_hook) (void *__ptr, __const void *)
+                             ;
+extern void *(*__malloc_hook) (size_t __size, __const void *)
+                                  ;
+extern void *(*__realloc_hook) (void *__ptr, size_t __size, __const void *)
+                                   ;
+extern void *(*__memalign_hook) (size_t __alignment, size_t __size, __const void *)
+                                    ;
+extern void (*__after_morecore_hook) (void);
+extern void __malloc_check_init (void) __attribute__ ((__nothrow__));
+struct timespec
+  {
+    __time_t tv_sec;
+    long int tv_nsec;
+  };
+struct sched_param
+  {
+    int __sched_priority;
+  };
+extern int clone (int (*__fn) (void *__arg), void *__child_stack,
+    int __flags, void *__arg, ...) __attribute__ ((__nothrow__));
+extern int unshare (int __flags) __attribute__ ((__nothrow__));
+extern int sched_getcpu (void) __attribute__ ((__nothrow__));
+struct __sched_param
+  {
+    int __sched_priority;
+  };
+typedef unsigned long int __cpu_mask;
+typedef struct
+{
+  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
+} cpu_set_t;
+extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
+  __attribute__ ((__nothrow__));
+extern cpu_set_t *__sched_cpualloc (size_t __count) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern void __sched_cpufree (cpu_set_t *__set) __attribute__ ((__nothrow__));
+extern int sched_setparam (__pid_t __pid, __const struct sched_param *__param)
+     __attribute__ ((__nothrow__));
+extern int sched_getparam (__pid_t __pid, struct sched_param *__param) __attribute__ ((__nothrow__));
+extern int sched_setscheduler (__pid_t __pid, int __policy,
+          __const struct sched_param *__param) __attribute__ ((__nothrow__));
+extern int sched_getscheduler (__pid_t __pid) __attribute__ ((__nothrow__));
+extern int sched_yield (void) __attribute__ ((__nothrow__));
+extern int sched_get_priority_max (int __algorithm) __attribute__ ((__nothrow__));
+extern int sched_get_priority_min (int __algorithm) __attribute__ ((__nothrow__));
+extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) __attribute__ ((__nothrow__));
+extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
+         __const cpu_set_t *__cpuset) __attribute__ ((__nothrow__));
+extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
+         cpu_set_t *__cpuset) __attribute__ ((__nothrow__));
+typedef __clock_t clock_t;
+typedef __time_t time_t;
+typedef __clockid_t clockid_t;
+typedef __timer_t timer_t;
+struct tm
+{
+  int tm_sec;
+  int tm_min;
+  int tm_hour;
+  int tm_mday;
+  int tm_mon;
+  int tm_year;
+  int tm_wday;
+  int tm_yday;
+  int tm_isdst;
+  long int tm_gmtoff;
+  __const char *tm_zone;
+};
+struct itimerspec
+  {
+    struct timespec it_interval;
+    struct timespec it_value;
+  };
+struct sigevent;
+typedef __pid_t pid_t;
+extern clock_t clock (void) __attribute__ ((__nothrow__));
+extern time_t time (time_t *__timer) __attribute__ ((__nothrow__));
+extern double difftime (time_t __time1, time_t __time0)
+     __attribute__ ((__nothrow__)) __attribute__ ((__const__));
+extern time_t mktime (struct tm *__tp) __attribute__ ((__nothrow__));
+extern size_t strftime (char *__restrict __s, size_t __maxsize,
+   __const char *__restrict __format,
+   __const struct tm *__restrict __tp) __attribute__ ((__nothrow__));
+extern char *strptime (__const char *__restrict __s,
+         __const char *__restrict __fmt, struct tm *__tp)
+     __attribute__ ((__nothrow__));
+typedef struct __locale_struct
+{
+  struct locale_data *__locales[13];
+  const unsigned short int *__ctype_b;
+  const int *__ctype_tolower;
+  const int *__ctype_toupper;
+  const char *__names[13];
+} *__locale_t;
+typedef __locale_t locale_t;
+extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
+     __const char *__restrict __format,
+     __const struct tm *__restrict __tp,
+     __locale_t __loc) __attribute__ ((__nothrow__));
+extern char *strptime_l (__const char *__restrict __s,
+    __const char *__restrict __fmt, struct tm *__tp,
+    __locale_t __loc) __attribute__ ((__nothrow__));
+extern struct tm *gmtime (__const time_t *__timer) __attribute__ ((__nothrow__));
+extern struct tm *localtime (__const time_t *__timer) __attribute__ ((__nothrow__));
+extern struct tm *gmtime_r (__const time_t *__restrict __timer,
+       struct tm *__restrict __tp) __attribute__ ((__nothrow__));
+extern struct tm *localtime_r (__const time_t *__restrict __timer,
+          struct tm *__restrict __tp) __attribute__ ((__nothrow__));
+extern char *asctime (__const struct tm *__tp) __attribute__ ((__nothrow__));
+extern char *ctime (__const time_t *__timer) __attribute__ ((__nothrow__));
+extern char *asctime_r (__const struct tm *__restrict __tp,
+   char *__restrict __buf) __attribute__ ((__nothrow__));
+extern char *ctime_r (__const time_t *__restrict __timer,
+        char *__restrict __buf) __attribute__ ((__nothrow__));
+extern char *__tzname[2];
+extern int __daylight;
+extern long int __timezone;
+extern char *tzname[2];
+extern void tzset (void) __attribute__ ((__nothrow__));
+extern int daylight;
+extern long int timezone;
+extern int stime (__const time_t *__when) __attribute__ ((__nothrow__));
+extern time_t timegm (struct tm *__tp) __attribute__ ((__nothrow__));
+extern time_t timelocal (struct tm *__tp) __attribute__ ((__nothrow__));
+extern int dysize (int __year) __attribute__ ((__nothrow__)) __attribute__ ((__const__));
+extern int nanosleep (__const struct timespec *__requested_time,
+        struct timespec *__remaining);
+extern int clock_getres (clockid_t __clock_id, struct timespec *__res) __attribute__ ((__nothrow__));
+extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) __attribute__ ((__nothrow__));
+extern int clock_settime (clockid_t __clock_id, __const struct timespec *__tp)
+     __attribute__ ((__nothrow__));
+extern int clock_nanosleep (clockid_t __clock_id, int __flags,
+       __const struct timespec *__req,
+       struct timespec *__rem);
+extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) __attribute__ ((__nothrow__));
+extern int timer_create (clockid_t __clock_id,
+    struct sigevent *__restrict __evp,
+    timer_t *__restrict __timerid) __attribute__ ((__nothrow__));
+extern int timer_delete (timer_t __timerid) __attribute__ ((__nothrow__));
+extern int timer_settime (timer_t __timerid, int __flags,
+     __const struct itimerspec *__restrict __value,
+     struct itimerspec *__restrict __ovalue) __attribute__ ((__nothrow__));
+extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
+     __attribute__ ((__nothrow__));
+extern int timer_getoverrun (timer_t __timerid) __attribute__ ((__nothrow__));
+extern int getdate_err;
+extern struct tm *getdate (__const char *__string);
+extern int getdate_r (__const char *__restrict __string,
+        struct tm *__restrict __resbufp);
+typedef int __sig_atomic_t;
+typedef struct
+  {
+    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
+  } __sigset_t;
+typedef __sigset_t sigset_t;
+typedef unsigned long int pthread_t;
+typedef union
+{
+  char __size[36];
+  long int __align;
+} pthread_attr_t;
+typedef struct __pthread_internal_slist
+{
+  struct __pthread_internal_slist *__next;
+} __pthread_slist_t;
+typedef union
+{
+  struct __pthread_mutex_s
+  {
+    int __lock;
+    unsigned int __count;
+    int __owner;
+    int __kind;
+    unsigned int __nusers;
+    __extension__ union
+    {
+      int __spins;
+      __pthread_slist_t __list;
+    };
+  } __data;
+  char __size[24];
+  long int __align;
+} pthread_mutex_t;
+typedef union
+{
+  char __size[4];
+  long int __align;
+} pthread_mutexattr_t;
+typedef union
+{
+  struct
+  {
+    int __lock;
+    unsigned int __futex;
+    __extension__ unsigned long long int __total_seq;
+    __extension__ unsigned long long int __wakeup_seq;
+    __extension__ unsigned long long int __woken_seq;
+    void *__mutex;
+    unsigned int __nwaiters;
+    unsigned int __broadcast_seq;
+  } __data;
+  char __size[48];
+  __extension__ long long int __align;
+} pthread_cond_t;
+typedef union
+{
+  char __size[4];
+  long int __align;
+} pthread_condattr_t;
+typedef unsigned int pthread_key_t;
+typedef int pthread_once_t;
+typedef union
+{
+  struct
+  {
+    int __lock;
+    unsigned int __nr_readers;
+    unsigned int __readers_wakeup;
+    unsigned int __writer_wakeup;
+    unsigned int __nr_readers_queued;
+    unsigned int __nr_writers_queued;
+    unsigned char __flags;
+    unsigned char __shared;
+    unsigned char __pad1;
+    unsigned char __pad2;
+    pthread_t __writer;
+  } __data;
+  char __size[32];
+  long int __align;
+} pthread_rwlock_t;
+typedef union
+{
+  char __size[8];
+  long int __align;
+} pthread_rwlockattr_t;
+typedef volatile int pthread_spinlock_t;
+typedef union
+{
+  char __size[20];
+  long int __align;
+} pthread_barrier_t;
+typedef union
+{
+  char __size[4];
+  int __align;
+} pthread_barrierattr_t;
+typedef struct __jmp_buf_internal_tag
+  {
+    int __regs[8];
+    void * __pc;
+    void * __gbr;
+    int __fpscr;
+    int __fpregs[4];
+  } __jmp_buf[1];
+enum
+{
+  PTHREAD_CREATE_JOINABLE,
+  PTHREAD_CREATE_DETACHED
+};
+enum
+{
+  PTHREAD_MUTEX_TIMED_NP,
+  PTHREAD_MUTEX_RECURSIVE_NP,
+  PTHREAD_MUTEX_ERRORCHECK_NP,
+  PTHREAD_MUTEX_ADAPTIVE_NP
+  ,
+  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
+  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
+  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
+  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL
+  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP
+};
+enum
+{
+  PTHREAD_MUTEX_STALLED,
+  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
+  PTHREAD_MUTEX_ROBUST,
+  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
+};
+enum
+{
+  PTHREAD_PRIO_NONE,
+  PTHREAD_PRIO_INHERIT,
+  PTHREAD_PRIO_PROTECT
+};
+enum
+{
+  PTHREAD_RWLOCK_PREFER_READER_NP,
+  PTHREAD_RWLOCK_PREFER_WRITER_NP,
+  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
+  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
+};
+enum
+{
+  PTHREAD_INHERIT_SCHED,
+  PTHREAD_EXPLICIT_SCHED
+};
+enum
+{
+  PTHREAD_SCOPE_SYSTEM,
+  PTHREAD_SCOPE_PROCESS
+};
+enum
+{
+  PTHREAD_PROCESS_PRIVATE,
+  PTHREAD_PROCESS_SHARED
+};
+struct _pthread_cleanup_buffer
+{
+  void (*__routine) (void *);
+  void *__arg;
+  int __canceltype;
+  struct _pthread_cleanup_buffer *__prev;
+};
+enum
+{
+  PTHREAD_CANCEL_ENABLE,
+  PTHREAD_CANCEL_DISABLE
+};
+enum
+{
+  PTHREAD_CANCEL_DEFERRED,
+  PTHREAD_CANCEL_ASYNCHRONOUS
+};
+extern int pthread_create (pthread_t *__restrict __newthread,
+      __const pthread_attr_t *__restrict __attr,
+      void *(*__start_routine) (void *),
+      void *__restrict __arg) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3)));
+extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));
+extern int pthread_join (pthread_t __th, void **__thread_return);
+extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) __attribute__ ((__nothrow__));
+extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
+     __const struct timespec *__abstime);
+extern int pthread_detach (pthread_t __th) __attribute__ ((__nothrow__));
+extern pthread_t pthread_self (void) __attribute__ ((__nothrow__)) __attribute__ ((__const__));
+extern int pthread_equal (pthread_t __thread1, pthread_t __thread2) __attribute__ ((__nothrow__));
+extern int pthread_attr_init (pthread_attr_t *__attr) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_attr_destroy (pthread_attr_t *__attr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_attr_getdetachstate (__const pthread_attr_t *__attr,
+     int *__detachstate)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
+     int __detachstate)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_attr_getguardsize (__const pthread_attr_t *__attr,
+          size_t *__guardsize)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
+          size_t __guardsize)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_attr_getschedparam (__const pthread_attr_t *__restrict
+           __attr,
+           struct sched_param *__restrict __param)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
+           __const struct sched_param *__restrict
+           __param) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_attr_getschedpolicy (__const pthread_attr_t *__restrict
+     __attr, int *__restrict __policy)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_attr_getinheritsched (__const pthread_attr_t *__restrict
+      __attr, int *__restrict __inherit)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
+      int __inherit)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_attr_getscope (__const pthread_attr_t *__restrict __attr,
+      int *__restrict __scope)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_attr_getstackaddr (__const pthread_attr_t *__restrict
+          __attr, void **__restrict __stackaddr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));
+extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
+          void *__stackaddr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));
+extern int pthread_attr_getstacksize (__const pthread_attr_t *__restrict
+          __attr, size_t *__restrict __stacksize)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
+          size_t __stacksize)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_attr_getstack (__const pthread_attr_t *__restrict __attr,
+      void **__restrict __stackaddr,
+      size_t *__restrict __stacksize)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2, 3)));
+extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
+      size_t __stacksize) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
+     size_t __cpusetsize,
+     __const cpu_set_t *__cpuset)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3)));
+extern int pthread_attr_getaffinity_np (__const pthread_attr_t *__attr,
+     size_t __cpusetsize,
+     cpu_set_t *__cpuset)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3)));
+extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));
+extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
+      __const struct sched_param *__param)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3)));
+extern int pthread_getschedparam (pthread_t __target_thread,
+      int *__restrict __policy,
+      struct sched_param *__restrict __param)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));
+extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
+     __attribute__ ((__nothrow__));
+extern int pthread_getconcurrency (void) __attribute__ ((__nothrow__));
+extern int pthread_setconcurrency (int __level) __attribute__ ((__nothrow__));
+extern int pthread_yield (void) __attribute__ ((__nothrow__));
+extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
+       __const cpu_set_t *__cpuset)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3)));
+extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
+       cpu_set_t *__cpuset)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3)));
+extern int pthread_once (pthread_once_t *__once_control,
+    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_setcancelstate (int __state, int *__oldstate);
+extern int pthread_setcanceltype (int __type, int *__oldtype);
+extern int pthread_cancel (pthread_t __th);
+extern void pthread_testcancel (void);
+typedef struct
+{
+  struct
+  {
+    __jmp_buf __cancel_jmp_buf;
+    int __mask_was_saved;
+  } __cancel_jmp_buf[1];
+  void *__pad[4];
+} __pthread_unwind_buf_t __attribute__ ((__aligned__));
+struct __pthread_cleanup_frame
+{
+  void (*__cancel_routine) (void *);
+  void *__cancel_arg;
+  int __do_it;
+  int __cancel_type;
+};
+extern void __pthread_register_cancel (__pthread_unwind_buf_t *__buf)
+     ;
+extern void __pthread_unregister_cancel (__pthread_unwind_buf_t *__buf)
+  ;
+extern void __pthread_register_cancel_defer (__pthread_unwind_buf_t *__buf)
+     ;
+extern void __pthread_unregister_cancel_restore (__pthread_unwind_buf_t *__buf)
+  ;
+extern void __pthread_unwind_next (__pthread_unwind_buf_t *__buf)
+     __attribute__ ((__noreturn__))
+     __attribute__ ((__weak__))
+     ;
+struct __jmp_buf_tag;
+extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) __attribute__ ((__nothrow__));
+extern int pthread_mutex_init (pthread_mutex_t *__mutex,
+          __const pthread_mutexattr_t *__mutexattr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
+                                    __const struct timespec *__restrict
+                                    __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_mutex_getprioceiling (__const pthread_mutex_t *
+      __restrict __mutex,
+      int *__restrict __prioceiling)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
+      int __prioceiling,
+      int *__restrict __old_ceiling)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3)));
+extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_mutexattr_getpshared (__const pthread_mutexattr_t *
+      __restrict __attr,
+      int *__restrict __pshared)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
+      int __pshared)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_mutexattr_gettype (__const pthread_mutexattr_t *__restrict
+          __attr, int *__restrict __kind)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_mutexattr_getprotocol (__const pthread_mutexattr_t *
+       __restrict __attr,
+       int *__restrict __protocol)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
+       int __protocol)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_mutexattr_getprioceiling (__const pthread_mutexattr_t *
+          __restrict __attr,
+          int *__restrict __prioceiling)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
+          int __prioceiling)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_mutexattr_getrobust (__const pthread_mutexattr_t *__attr,
+     int *__robustness)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_mutexattr_getrobust_np (__const pthread_mutexattr_t *__attr,
+        int *__robustness)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
+     int __robustness)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
+        int __robustness)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
+    __const pthread_rwlockattr_t *__restrict
+    __attr) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
+  __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
+           __const struct timespec *__restrict
+           __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
+           __const struct timespec *__restrict
+           __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_rwlockattr_getpshared (__const pthread_rwlockattr_t *
+       __restrict __attr,
+       int *__restrict __pshared)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
+       int __pshared)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_rwlockattr_getkind_np (__const pthread_rwlockattr_t *
+       __restrict __attr,
+       int *__restrict __pref)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
+       int __pref) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
+         __const pthread_condattr_t *__restrict
+         __cond_attr) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_cond_destroy (pthread_cond_t *__cond)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_cond_signal (pthread_cond_t *__cond)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_cond_broadcast (pthread_cond_t *__cond)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
+         pthread_mutex_t *__restrict __mutex)
+     __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
+       pthread_mutex_t *__restrict __mutex,
+       __const struct timespec *__restrict
+       __abstime) __attribute__ ((__nonnull__ (1, 2, 3)));
+extern int pthread_condattr_init (pthread_condattr_t *__attr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_condattr_getpshared (__const pthread_condattr_t *
+                                        __restrict __attr,
+                                        int *__restrict __pshared)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
+                                        int __pshared) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_condattr_getclock (__const pthread_condattr_t *
+          __restrict __attr,
+          __clockid_t *__restrict __clock_id)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
+          __clockid_t __clock_id)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_spin_lock (pthread_spinlock_t *__lock)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
+     __const pthread_barrierattr_t *__restrict
+     __attr, unsigned int __count)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_barrierattr_getpshared (__const pthread_barrierattr_t *
+        __restrict __attr,
+        int *__restrict __pshared)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
+                                           int __pshared)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_key_create (pthread_key_t *__key,
+          void (*__destr_function) (void *))
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int pthread_key_delete (pthread_key_t __key) __attribute__ ((__nothrow__));
+extern void *pthread_getspecific (pthread_key_t __key) __attribute__ ((__nothrow__));
+extern int pthread_setspecific (pthread_key_t __key,
+    __const void *__pointer) __attribute__ ((__nothrow__)) ;
+extern int pthread_getcpuclockid (pthread_t __thread_id,
+      __clockid_t *__clock_id)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));
+extern int pthread_atfork (void (*__prepare) (void),
+      void (*__parent) (void),
+      void (*__child) (void)) __attribute__ ((__nothrow__));
+extern __inline int
+__attribute__ ((__nothrow__)) pthread_equal (pthread_t __thread1, pthread_t __thread2)
+{
+  return __thread1 == __thread2;
+}
+typedef __u_char u_char;
+typedef __u_short u_short;
+typedef __u_int u_int;
+typedef __u_long u_long;
+typedef __quad_t quad_t;
+typedef __u_quad_t u_quad_t;
+typedef __fsid_t fsid_t;
+typedef __loff_t loff_t;
+typedef __ino_t ino_t;
+typedef __ino64_t ino64_t;
+typedef __dev_t dev_t;
+typedef __gid_t gid_t;
+typedef __mode_t mode_t;
+typedef __nlink_t nlink_t;
+typedef __uid_t uid_t;
+typedef __off_t off_t;
+typedef __off64_t off64_t;
+typedef __id_t id_t;
+typedef __ssize_t ssize_t;
+typedef __daddr_t daddr_t;
+typedef __caddr_t caddr_t;
+typedef __key_t key_t;
+typedef __useconds_t useconds_t;
+typedef __suseconds_t suseconds_t;
+typedef unsigned long int ulong;
+typedef unsigned short int ushort;
+typedef unsigned int uint;
+typedef int int8_t __attribute__ ((__mode__ (__QI__)));
+typedef int int16_t __attribute__ ((__mode__ (__HI__)));
+typedef int int32_t __attribute__ ((__mode__ (__SI__)));
+typedef int int64_t __attribute__ ((__mode__ (__DI__)));
+typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
+typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
+typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
+typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));
+typedef int register_t __attribute__ ((__mode__ (__word__)));
+struct timeval
+  {
+    __time_t tv_sec;
+    __suseconds_t tv_usec;
+  };
+typedef long int __fd_mask;
+typedef struct
+  {
+    __fd_mask fds_bits[1024 / (8 * sizeof (__fd_mask))];
+  } fd_set;
+typedef __fd_mask fd_mask;
+extern int select (int __nfds, fd_set *__restrict __readfds,
+     fd_set *__restrict __writefds,
+     fd_set *__restrict __exceptfds,
+     struct timeval *__restrict __timeout);
+extern int pselect (int __nfds, fd_set *__restrict __readfds,
+      fd_set *__restrict __writefds,
+      fd_set *__restrict __exceptfds,
+      const struct timespec *__restrict __timeout,
+      const __sigset_t *__restrict __sigmask);
+__extension__
+extern unsigned int gnu_dev_major (unsigned long long int __dev)
+     __attribute__ ((__nothrow__));
+__extension__
+extern unsigned int gnu_dev_minor (unsigned long long int __dev)
+     __attribute__ ((__nothrow__));
+__extension__
+extern unsigned long long int gnu_dev_makedev (unsigned int __major,
+            unsigned int __minor)
+     __attribute__ ((__nothrow__));
+__extension__ extern __inline unsigned int
+__attribute__ ((__nothrow__)) gnu_dev_major (unsigned long long int __dev)
+{
+  return ((__dev >> 8) & 0xfff) | ((unsigned int) (__dev >> 32) & ~0xfff);
+}
+__extension__ extern __inline unsigned int
+__attribute__ ((__nothrow__)) gnu_dev_minor (unsigned long long int __dev)
+{
+  return (__dev & 0xff) | ((unsigned int) (__dev >> 12) & ~0xff);
+}
+__extension__ extern __inline unsigned long long int
+__attribute__ ((__nothrow__)) gnu_dev_makedev (unsigned int __major, unsigned int __minor)
+{
+  return ((__minor & 0xff) | ((__major & 0xfff) << 8)
+   | (((unsigned long long int) (__minor & ~0xff)) << 12)
+   | (((unsigned long long int) (__major & ~0xfff)) << 32));
+}
+typedef __blksize_t blksize_t;
+typedef __blkcnt_t blkcnt_t;
+typedef __fsblkcnt_t fsblkcnt_t;
+typedef __fsfilcnt_t fsfilcnt_t;
+typedef __blkcnt64_t blkcnt64_t;
+typedef __fsblkcnt64_t fsblkcnt64_t;
+typedef __fsfilcnt64_t fsfilcnt64_t;
+typedef union
+{
+  char __size[16];
+  long int __align;
+} sem_t;
+extern int sem_init (sem_t *__sem, int __pshared, unsigned int __value)
+     __attribute__ ((__nothrow__));
+extern int sem_destroy (sem_t *__sem) __attribute__ ((__nothrow__));
+extern sem_t *sem_open (__const char *__name, int __oflag, ...) __attribute__ ((__nothrow__));
+extern int sem_close (sem_t *__sem) __attribute__ ((__nothrow__));
+extern int sem_unlink (__const char *__name) __attribute__ ((__nothrow__));
+extern int sem_wait (sem_t *__sem);
+extern int sem_timedwait (sem_t *__restrict __sem,
+     __const struct timespec *__restrict __abstime);
+extern int sem_trywait (sem_t *__sem) __attribute__ ((__nothrow__));
+extern int sem_post (sem_t *__sem) __attribute__ ((__nothrow__));
+extern int sem_getvalue (sem_t *__restrict __sem, int *__restrict __sval)
+     __attribute__ ((__nothrow__));
+typedef CVMInt8 CVMJavaByte;
+typedef CVMInt16 CVMJavaShort;
+typedef CVMUint16 CVMJavaChar;
+typedef CVMUint8 CVMJavaBoolean;
+typedef CVMInt32 CVMJavaInt;
+typedef CVMfloat32 CVMJavaFloat;
+typedef CVMInt64 CVMJavaLong;
+typedef CVMfloat64 CVMJavaDouble;
+typedef CVMUint32 CVMBool;
+typedef struct CVMMutex CVMMutex;
+typedef struct CVMCondVar CVMCondVar;
+typedef struct CVMMicroLock CVMMicroLock;
+typedef struct CVMThreadID CVMThreadID;
+typedef struct CVMTargetGlobalState CVMTargetGlobalState;
+typedef char CVMUtf8;
+typedef struct CVMObjectHeader CVMObjectHeader;
+typedef union CVMVariousBits CVMVariousBits;
+typedef union CVMJavaVal8 CVMJavaVal8;
+typedef union CVMJavaVal16 CVMJavaVal16;
+typedef union CVMJavaVal32 CVMJavaVal32;
+typedef union CVMJavaVal64 CVMJavaVal64;
+typedef struct CVMjava_lang_Object CVMjava_lang_Object;
+typedef struct CVMSyncVector CVMSyncVector;
+typedef CVMjava_lang_Object CVMObject;
+typedef struct CVMArrayOfByte CVMArrayOfByte;
+typedef struct CVMArrayOfShort CVMArrayOfShort;
+typedef struct CVMArrayOfChar CVMArrayOfChar;
+typedef struct CVMArrayOfBoolean CVMArrayOfBoolean;
+typedef struct CVMArrayOfInt CVMArrayOfInt;
+typedef struct CVMArrayOfRef CVMArrayOfRef;
+typedef struct CVMArrayOfFloat CVMArrayOfFloat;
+typedef struct CVMArrayOfLong CVMArrayOfLong;
+typedef struct CVMArrayOfDouble CVMArrayOfDouble;
+typedef struct CVMArrayOfAnyType CVMArrayOfAnyType;
+typedef struct CVMjava_lang_ObjectICell CVMjava_lang_ObjectICell;
+typedef struct CVMObjectICell CVMObjectICell;
+typedef struct CVMArrayOfByteICell CVMArrayOfByteICell;
+typedef struct CVMArrayOfShortICell CVMArrayOfShortICell;
+typedef struct CVMArrayOfCharICell CVMArrayOfCharICell;
+typedef struct CVMArrayOfBooleanICell CVMArrayOfBooleanICell;
+typedef struct CVMArrayOfIntICell CVMArrayOfIntICell;
+typedef struct CVMArrayOfRefICell CVMArrayOfRefICell;
+typedef struct CVMArrayOfFloatICell CVMArrayOfFloatICell;
+typedef struct CVMArrayOfLongICell CVMArrayOfLongICell;
+typedef struct CVMArrayOfDoubleICell CVMArrayOfDoubleICell;
+typedef struct CVMArrayOfAnyTypeICell CVMArrayOfAnyTypeICell;
+typedef struct CVMClassBlock CVMClassBlock;
+typedef union CVMGCBitMap CVMGCBitMap;
+typedef struct CVMBigGCBitMap CVMBigGCBitMap;
+typedef struct CVMArrayInfo CVMArrayInfo;
+typedef struct CVMInterfaces CVMInterfaces;
+typedef struct CVMInterfaceTable CVMInterfaceTable;
+typedef struct CVMMethodBlock CVMMethodBlock;
+typedef struct CVMMethodBlockImmutable CVMMethodBlockImmutable;
+typedef struct CVMMethodRange CVMMethodRange;
+typedef struct CVMMethodArray CVMMethodArray;
+typedef struct CVMCheckedExceptions CVMCheckedExceptions;
+typedef struct CVMJavaMethodDescriptor CVMJavaMethodDescriptor;
+typedef struct CVMExceptionHandler CVMExceptionHandler;
+typedef struct CVMLineNumberEntry CVMLineNumberEntry;
+typedef struct CVMLocalVariableEntry CVMLocalVariableEntry;
+typedef struct CVMFieldBlock CVMFieldBlock;
+typedef struct CVMFieldRange CVMFieldRange;
+typedef struct CVMFieldArray CVMFieldArray;
+typedef struct CVMInnerClassInfo CVMInnerClassInfo;
+typedef struct CVMInnerClassesInfo CVMInnerClassesInfo;
+typedef union CVMConstantPool CVMConstantPool;
+typedef struct CVMTransitionConstantPool CVMTransitionConstantPool;
+typedef union CVMConstantPoolEntry CVMConstantPoolEntry;
+typedef struct CVMStackMapEntry CVMStackMapEntry;
+typedef struct CVMStackMaps CVMStackMaps;
+typedef CVMObjectICell CVMThreadICell;
+typedef CVMObjectICell CVMThrowableICell;
+typedef CVMObjectICell CVMStringICell;
+typedef CVMObjectICell CVMClassICell;
+typedef CVMObjectICell CVMClassLoaderICell;
+typedef CVMObject* CVMStringObject;
+typedef struct CVMExecEnv CVMExecEnv;
+typedef CVMBool CVMTryLockFunc (CVMExecEnv* ee,
+        CVMObject* obj);
+typedef CVMBool CVMLockFunc (CVMExecEnv* ee,
+        CVMObjectICell* indirectObj);
+typedef CVMBool CVMNotifyFunc (CVMExecEnv* ee,
+        CVMObjectICell* indirectObj);
+typedef CVMBool CVMNotifyAllFunc (CVMExecEnv* ee,
+        CVMObjectICell* indirectObj);
+typedef CVMBool CVMWaitFunc (CVMExecEnv* ee,
+        CVMObjectICell* indirectObj,
+        CVMJavaLong millis);
+typedef struct CVMReentrantMutex CVMReentrantMutex;
+typedef struct CVMSysMutex CVMSysMutex;
+typedef struct CVMSysMonitor CVMSysMonitor;
+typedef struct CVMProfiledMonitor CVMProfiledMonitor;
+typedef struct CVMNamedSysMonitor CVMNamedSysMonitor;
+typedef struct CVMObjMonitor CVMObjMonitor;
+typedef struct CVMOwnedMonitor CVMOwnedMonitor;
+typedef struct CVMCState CVMCState;
+typedef struct CVMTCState CVMTCState;
+typedef struct CVMLoaderCacheEntry CVMLoaderCacheEntry;
+typedef struct CVMLoaderConstraint CVMLoaderConstraint;
+typedef struct CVMSeenClass CVMSeenClass;
+typedef struct CVMClassPathEntry CVMClassPathEntry;
+typedef union CVMStackVal32 CVMStackVal32;
+typedef struct CVMStack CVMStack;
+typedef struct CVMStackChunk CVMStackChunk;
+typedef struct CVMFrame CVMFrame;
+typedef struct CVMFrameIterator CVMFrameIterator;
+typedef struct CVMLocalRootsFrame CVMLocalRootsFrame;
+typedef struct CVMFreelistFrame CVMFreelistFrame;
+typedef struct CVMInterpreterFrame CVMInterpreterFrame;
+typedef struct CVMJavaFrame CVMJavaFrame;
+typedef struct CVMTransitionFrame CVMTransitionFrame;
+typedef struct CVMStackWalkContext CVMStackWalkContext;
+typedef struct CVMGlobalState CVMGlobalState;
+typedef struct CVMGCGlobalState CVMGCGlobalState;
+typedef struct CVMOptions CVMOptions;
+typedef struct CVMGCOptions CVMGCOptions;
+typedef struct CVMJavaAssertionsOptionList CVMJavaAssertionsOptionList;
+typedef void (*CVMRefCallbackFunc)(CVMObject** refAddr, void* data);
+typedef CVMBool (*CVMRefLivenessQueryFunc)(CVMObject** refAddr, void* data);
+typedef CVMBool (*CVMObjectCallbackFunc)(CVMObject* obj, CVMClassBlock* cb,
+                                         CVMUint32 objSize, void* data);
+typedef void CVMFrameGCScannerFunc(CVMExecEnv* ee,
+       CVMFrame* thisFrame,
+       CVMStackChunk* thisChunk,
+       CVMRefCallbackFunc refCallback,
+       void* data,
+       CVMGCOptions* gcOpts);
+struct JNINativeInterface;
+typedef const struct JNINativeInterface *JNIEnv;
+typedef CVMUint32 CVMTypeID;
+typedef CVMUint16 CVMTypeIDPart;
+typedef CVMTypeID CVMMethodTypeID;
+typedef CVMTypeID CVMFieldTypeID;
+typedef CVMTypeID CVMClassTypeID;
+typedef CVMTypeIDPart CVMTypeIDNamePart;
+typedef CVMTypeIDPart CVMTypeIDTypePart;
+extern int CVMtypeidGetArrayDepthX( CVMClassTypeID );
+extern CVMClassTypeID CVMtypeidGetArrayBasetypeX( CVMClassTypeID );
+extern CVMBool
+CVMtypeidInit(CVMExecEnv *ee);
+extern void
+CVMtypeidRegisterPreloadedPackages();
+extern void
+CVMtypeidDestroy();
+extern CVMMethodTypeID
+CVMtypeidLookupMethodIDFromNameAndSig( CVMExecEnv *ee,
+      const CVMUtf8* memberName, const CVMUtf8* memberSig);
+extern CVMMethodTypeID
+CVMtypeidNewMethodIDFromNameAndSig( CVMExecEnv *ee,
+      const CVMUtf8* memberName, const CVMUtf8* memberSig);
+extern CVMMethodTypeID
+CVMtypeidCloneMethodID( CVMExecEnv *ee, CVMMethodTypeID cookie );
+extern void
+CVMtypeidDisposeMethodID( CVMExecEnv *ee, CVMMethodTypeID cookie );
+extern CVMFieldTypeID
+CVMtypeidLookupFieldIDFromNameAndSig( CVMExecEnv *ee,
+   const CVMUtf8* memberName, const CVMUtf8* memberSig);
+extern CVMFieldTypeID
+CVMtypeidNewFieldIDFromNameAndSig( CVMExecEnv *ee,
+   const CVMUtf8* memberName, const CVMUtf8* memberSig);
+extern CVMFieldTypeID
+CVMtypeidCloneFieldID( CVMExecEnv *ee, CVMFieldTypeID cookie );
+extern void
+CVMtypeidDisposeFieldID( CVMExecEnv *ee, CVMFieldTypeID cookie );
+extern CVMClassTypeID
+CVMtypeidLookupClassID( CVMExecEnv *ee, const char * name, int nameLength );
+extern CVMClassTypeID
+CVMtypeidNewClassID( CVMExecEnv *ee, const char * name, int nameLength );
+extern CVMClassTypeID
+CVMtypeidCloneClassID( CVMExecEnv *ee, CVMClassTypeID cookie );
+extern void
+CVMtypeidDisposeClassID( CVMExecEnv *ee, CVMClassTypeID cookie );
+extern CVMTypeID
+CVMtypeidLookupMembername( CVMExecEnv *ee, const char * name );
+extern CVMTypeID
+CVMtypeidNewMembername( CVMExecEnv *ee, const char * name );
+extern CVMTypeID
+CVMtypeidCloneMembername( CVMExecEnv *ee, CVMTypeID cookie );
+extern void
+CVMtypeidDisposeMembername( CVMExecEnv *ee, CVMTypeID cookie );
+extern char
+CVMtypeidGetReturnType(CVMMethodTypeID type);
+extern CVMUint16
+CVMtypeidGetArgsSize( CVMMethodTypeID methodTypeID );
+extern CVMBool
+CVMtypeidMethodIsRef(CVMMethodTypeID type);
+extern size_t
+CVMtypeidFieldTypeLength0(CVMFieldTypeID type, CVMBool isField);
+extern size_t
+CVMtypeidMethodTypeLength(CVMMethodTypeID type);
+extern size_t
+CVMtypeidMemberNameLength(CVMMethodTypeID type);
+extern size_t
+CVMtypeidClassNameLength(CVMClassTypeID type);
+extern CVMBool
+CVMtypeidMethodTypeToCString(CVMMethodTypeID type, char* buf, int bufLength);
+extern CVMBool
+CVMtypeidFieldTypeToCString(CVMFieldTypeID type, char* buf, int bufLength);
+extern CVMBool
+CVMtypeidMethodNameToCString(CVMMethodTypeID type, char* buf, int bufLength);
+extern CVMBool
+CVMtypeidFieldNameToCString(CVMFieldTypeID type, char* buf, int bufLength);
+extern CVMBool
+CVMtypeidClassNameToCString(CVMClassTypeID type, char* buf, int bufLength);
+extern char *
+CVMtypeidMethodTypeToAllocatedCString( CVMMethodTypeID type );
+extern char *
+CVMtypeidFieldTypeToAllocatedCString( CVMFieldTypeID type );
+extern char *
+CVMtypeidMethodNameToAllocatedCString( CVMMethodTypeID type );
+extern char *
+CVMtypeidFieldNameToAllocatedCString( CVMFieldTypeID type );
+extern char *
+CVMtypeidClassNameToAllocatedCString( CVMClassTypeID type );
+int CVMtypeidIncrementFieldRefcount( CVMFieldTypeID );
+int CVMtypeidDecrementFieldRefcount( CVMFieldTypeID );
+extern CVMClassTypeID
+CVMtypeidIncrementArrayDepth( CVMExecEnv *ee, CVMClassTypeID base,
+         int depthIncrement );
+extern CVMBool
+CVMtypeidIsSameClassPackage( CVMClassTypeID classname1,
+        CVMClassTypeID classname2 );
+typedef struct CVMterseSig {
+    CVMUint32 * datap;
+    int nParameters;
+} CVMterseSig;
+typedef struct CVMterseSigIterator {
+    CVMterseSig thisSig;
+    int word;
+    int syllableInWord;
+} CVMterseSigIterator;
+void
+CVMtypeidGetTerseSignature( CVMMethodTypeID tid, CVMterseSig* result );
+void
+CVMtypeidGetTerseSignatureIterator( CVMMethodTypeID tid, CVMterseSigIterator* result );
+typedef struct CVMSigIterator {
+    CVMterseSigIterator terseSig;
+    CVMTypeIDTypePart* parameterDetails;
+    CVMClassTypeID returnType;
+    CVMClassTypeID temp;
+} CVMSigIterator;
+void
+CVMtypeidGetSignatureIterator( CVMMethodTypeID tid, CVMSigIterator* result );
+extern void CVMtypeidPrintStats();
+extern void CVMtypeidPrintDiffs( CVMBool verbose );
+extern void CVMtypeidCheckTables();
+enum CVMBasicType {
+    CVM_T_ERR = 0,
+    CVM_T_CLASS = 2,
+    CVM_T_BOOLEAN = 4,
+    CVM_T_CHAR,
+    CVM_T_FLOAT,
+    CVM_T_DOUBLE,
+    CVM_T_BYTE,
+    CVM_T_SHORT,
+    CVM_T_INT,
+    CVM_T_LONG,
+    CVM_T_VOID = 17
+};
+typedef enum CVMBasicType CVMBasicType;
+extern const CVMUint32 CVMbasicTypeSizes[];
+extern const char CVMbasicTypeSignatures[];
+extern const CVMClassTypeID CVMbasicTypeID[];
+extern const CVMClassBlock* const CVMbasicTypeClassblocks[];
+extern const CVMClassBlock* const CVMbasicTypeArrayClassblocks[];
+extern const CVMClassBlock* const CVMterseTypeClassblocks[];
+extern const CVMBasicType CVMterseTypeBasicTypes[];
+extern const char CVMterseTypePrimitiveSignatures[];
+extern CVMBool CVMmicrolockInit (CVMMicroLock* m);
+extern void CVMmicrolockDestroy(CVMMicroLock* m);
+extern void CVMmicrolockLock (CVMMicroLock* m);
+extern void CVMmicrolockUnlock (CVMMicroLock* m);
+extern CVMBool CVMmutexInit (CVMMutex* m);
+extern void CVMmutexDestroy(CVMMutex* m);
+extern CVMBool CVMmutexTryLock(CVMMutex* m);
+extern void CVMmutexLock (CVMMutex* m);
+extern void CVMmutexUnlock (CVMMutex* m);
+extern void CVMmutexSetOwner(CVMThreadID *self, CVMMutex* m,
+    CVMThreadID *ti);
+extern CVMBool CVMcondvarInit (CVMCondVar *c, CVMMutex* m);
+extern void CVMcondvarDestroy(CVMCondVar *c);
+extern CVMBool CVMcondvarWait (CVMCondVar* c, CVMMutex* m,
+       CVMJavaLong millis);
+extern void CVMcondvarNotify (CVMCondVar* c);
+extern void CVMcondvarNotifyAll(CVMCondVar* c);
+typedef struct {
+    pthread_mutex_t m;
+} POSIXMutex;
+typedef struct {
+    pthread_cond_t c;
+} POSIXCondVar;
+extern CVMBool POSIXmutexInit(POSIXMutex * m);
+extern void POSIXmutexDestroy(POSIXMutex * m);
+extern CVMBool POSIXmutexTryLock(POSIXMutex * m);
+extern void POSIXmutexLock(POSIXMutex * m);
+extern void POSIXmutexUnlock(POSIXMutex * m);
+extern CVMBool POSIXcondvarInit(POSIXCondVar * c, POSIXMutex * m);
+extern void POSIXcondvarDestroy(POSIXCondVar * c);
+extern int POSIXcondvarWait(POSIXCondVar * c, POSIXMutex * m,
+ CVMJavaLong millis);
+extern void POSIXcondvarNotify(POSIXCondVar * c);
+extern void POSIXcondvarNotifyAll(POSIXCondVar * c);
+CVMBool linuxSyncInit(void);
+void linuxSyncInterruptWait(CVMThreadID *thread);
+void linuxSyncSuspend(CVMThreadID *thread);
+void linuxSyncResume(CVMThreadID *thread);
+struct CVMMutex {
+    POSIXMutex pmtx;
+};
+struct CVMCondVar {
+    POSIXCondVar pcv;
+    CVMThreadID *waiters;
+    CVMThreadID **last_p;
+};
+typedef enum {
+    CVM_CODE_MICROLOCK,
+    CVM_CONSTANTPOOL_MICROLOCK,
+    CVM_TOOLS_MICROLOCK,
+    CVM_GC_LOCKER_MICROLOCK,
+    CVM_METHOD_TRACE_MICROLOCK,
+    CVM_ACCESS_VOLATILE_MICROLOCK,
+    CVM_NUM_SYS_MICROLOCKS
+} CVMSysMicroLock;
+void
+CVMsysMicroLock(CVMExecEnv *ee, CVMSysMicroLock lock);
+void
+CVMsysMicroUnlock(CVMExecEnv *ee, CVMSysMicroLock lock);
+void
+CVMsysMicroLockAll(CVMExecEnv *ee);
+void
+CVMsysMicroUnlockAll(CVMExecEnv *ee);
+struct CVMReentrantMutex {
+    CVMExecEnv *owner;
+    CVMUint32 count;
+    CVMMutex mutex;
+};
+extern CVMBool CVMreentrantMutexInit (CVMReentrantMutex *rm,
+     CVMExecEnv *owner, CVMUint32 count);
+extern void CVMreentrantMutexDestroy(CVMReentrantMutex *rm);
+extern CVMBool CVMreentrantMutexTryLock(CVMExecEnv *ee, CVMReentrantMutex *rm);
+extern void CVMreentrantMutexLock (CVMExecEnv *ee, CVMReentrantMutex *rm);
+extern void CVMreentrantMutexUnlock (CVMExecEnv *ee, CVMReentrantMutex *rm);
+extern CVMBool CVMreentrantMutexWait (CVMExecEnv *ee, CVMReentrantMutex *rm,
+     CVMCondVar *c, CVMInt64 millis);
+extern CVMBool CVMreentrantMutexIAmOwner(CVMExecEnv *ee, CVMReentrantMutex *rm);
+struct CVMSysMutex {
+    const char *name;
+    CVMUint8 rank;
+    CVMReentrantMutex rmutex;
+    CVMSysMutex *nextOwned;
+};
+extern CVMBool CVMsysMutexInit (CVMSysMutex* m,
+         const char *name,
+         CVMUint8 rank);
+extern void CVMsysMutexDestroy(CVMSysMutex* m);
+extern CVMBool CVMsysMutexTryLock(CVMExecEnv *ee, CVMSysMutex* m);
+extern void CVMsysMutexLock (CVMExecEnv *ee, CVMSysMutex* m);
+extern void CVMsysMutexUnlock (CVMExecEnv *ee, CVMSysMutex* m);
+extern CVMBool CVMsysMutexWait (CVMExecEnv *ee, CVMSysMutex* m,
+         CVMCondVar *c, CVMInt64 millis);
+typedef enum {
+    CVM_WAIT_OK,
+    CVM_WAIT_INTERRUPTED,
+    CVM_WAIT_NOT_OWNER
+} CVMWaitStatus;
+struct CVMSysMonitor {
+    CVMReentrantMutex rmutex;
+    CVMCondVar condvar;
+};
+extern CVMBool
+CVMsysMonitorInit(CVMSysMonitor* m, CVMExecEnv *owner, CVMUint32 count);
+extern void
+CVMsysMonitorDestroy(CVMSysMonitor* m);
+extern void
+CVMsysMonitorEnter(CVMExecEnv *ee, CVMSysMonitor* m);
+extern void
+CVMsysMonitorExit(CVMExecEnv *ee, CVMSysMonitor* m);
+extern CVMBool
+CVMsysMonitorNotify(CVMExecEnv *ee, CVMSysMonitor* m);
+extern CVMBool
+CVMsysMonitorNotifyAll(CVMExecEnv *ee, CVMSysMonitor* m);
+extern CVMWaitStatus
+CVMsysMonitorWait(CVMExecEnv *ee, CVMSysMonitor* m, CVMInt64 millis);
+enum {
+    CVM_LOCKTYPE_UNKNOWN = 0,
+    CVM_LOCKTYPE_OBJ_MONITOR,
+    CVM_LOCKTYPE_NAMED_SYSMONITOR
+};
+struct CVMProfiledMonitor {
+    CVMSysMonitor _super;
+    CVMUint8 type;
+    CVMUint32 contentionCount;
+    CVMProfiledMonitor *next;
+    CVMProfiledMonitor **previousPtr;
+};
+extern CVMBool
+CVMprofiledMonitorInit(CVMProfiledMonitor *self, CVMExecEnv *owner,
+                       CVMUint32 count, CVMUint8 lockType);
+extern void
+CVMprofiledMonitorExit(CVMProfiledMonitor *self, CVMExecEnv *currentEE);
+extern CVMWaitStatus
+CVMprofiledMonitorWait(CVMProfiledMonitor *self, CVMExecEnv *currentEE,
+                       CVMInt64 millis);
+extern void
+CVMprofiledMonitorEnterUnsafe(CVMProfiledMonitor *self,
+         CVMExecEnv *currentEE, CVMBool doPost);
+extern void
+CVMprofiledMonitorEnterSafe(CVMProfiledMonitor *self, CVMExecEnv *currentEE, CVMBool doPost);
+extern void
+CVMdeleteUnreferencedMonitors(CVMExecEnv *ee,
+         CVMRefLivenessQueryFunc isLive,
+         void* isLiveData,
+         CVMRefCallbackFunc transitiveScanner,
+         void* transitiveScannerData);
+extern void
+CVMscanMonitors(CVMExecEnv *ee, CVMRefCallbackFunc refCallback, void* data);
+extern CVMBool
+CVMeeSyncInit(CVMExecEnv *ee);
+extern void
+CVMeeSyncDestroy(CVMExecEnv *ee);
+extern CVMBool
+CVMeeSyncInitGlobal(CVMExecEnv *ee, CVMGlobalState *gs);
+extern void
+CVMeeSyncDestroyGlobal(CVMExecEnv *ee, CVMGlobalState *gs);
+struct CVMObjectHeader {
+    volatile CVMClassBlock *clas;
+    volatile CVMAddr various32;
+};
+enum {
+    CVM_LOCKSTATE_LOCKED = 0,
+    CVM_LOCKSTATE_MONITOR = 1,
+    CVM_LOCKSTATE_UNLOCKED = 2
+};
+extern CVMInt32
+CVMobjectGetHashSafe(CVMExecEnv *ee, CVMObjectICell* indirectObj);
+extern CVMInt32
+CVMobjectGetHashNoSet(CVMExecEnv *ee, CVMObject* directObj);
+struct CVMjava_lang_ObjectICell { CVMjava_lang_Object * volatile ref_DONT_ACCESS_DIRECTLY; };
+struct CVMObjectICell { CVMObject * volatile ref_DONT_ACCESS_DIRECTLY; };
+enum {
+    CVM_OBJMON_OWNED_NEXT,
+    CVM_OBJMON_SCAN_NEXT,
+    CVM_OBJMON_NUM_LISTS
+};
+typedef enum {
+    CVM_OBJMON_FREE = 0,
+    CVM_OBJMON_BOUND = 1,
+    CVM_OBJMON_OWNED = 2,
+    CVM_OBJMON_BUSY = 0x4
+} CVMObjMonitorState;
+struct CVMObjMonitor {
+    CVMAddr bits;
+    CVMProfiledMonitor mon;
+    CVMUint32 magic;
+    CVMOwnedMonitor *owner;
+    CVMBool sticky;
+    CVMObject *obj;
+    CVMObjMonitorState state;
+    CVMObjMonitor *next;
+};
+extern CVMBool
+CVMobjMonitorInit(CVMExecEnv *ee, CVMObjMonitor *, CVMExecEnv *owner,
+    CVMUint32 count);
+extern void
+CVMobjMonitorDestroy(CVMObjMonitor *m);
+extern CVMObjMonitor *
+CVMobjectInflatePermanently(CVMExecEnv *ee, CVMObjectICell* indirectObj);
+typedef enum {
+    CVM_OWNEDMON_FAST = 0,
+    CVM_OWNEDMON_HEAVY = 1
+} CVMOwnedMonitorType;
+typedef enum {
+    CVM_OWNEDMON_FREE = 0,
+    CVM_OWNEDMON_OWNED = 1
+} CVMOwnedMonitorState;
+struct CVMOwnedMonitor {
+    CVMExecEnv *owner;
+    CVMOwnedMonitorType type;
+    CVMObject *object;
+    union {
+ struct {
+     CVMAddr bits;
+ } fast;
+ struct {
+     CVMObjMonitor *mon;
+ } heavy;
+    } u;
+    CVMOwnedMonitor *next;
+    CVMUint32 magic;
+    CVMOwnedMonitorState state;
+    volatile CVMAddr count;
+};
+void
+CVMsyncGCSafeAllMonitorScavenge(CVMExecEnv *ee);
+union CVMJavaVal32 {
+    CVMJavaInt i;
+    CVMJavaFloat f;
+    CVMObjectICell r;
+    CVMAddr raw;
+};
+union CVMJavaVal64 {
+    CVMJavaLong l;
+    CVMJavaDouble d;
+    CVMAddr v[2];
+};
+union CVMJavaVal16 {
+    CVMJavaShort s;
+    CVMJavaChar c;
+};
+union CVMJavaVal8 {
+    CVMJavaByte b;
+    CVMJavaBoolean z;
+};
+struct CVMjava_lang_Object {
+    volatile CVMObjectHeader hdr;
+    volatile CVMJavaVal32 fields[1];
+};
+struct CVMSyncVector {
+    CVMTryLockFunc *tryLock;
+    CVMLockFunc *lock;
+    CVMTryLockFunc *tryUnlock;
+    CVMLockFunc *unlock;
+    CVMWaitFunc *wait;
+    CVMNotifyFunc *notify;
+    CVMNotifyAllFunc *notifyAll;
+    void *dummyWord;
+};
+extern const CVMSyncVector CVMsyncKinds[];
+extern CVMTryLockFunc CVMfastTryLock, CVMfastTryUnlock;
+extern CVMBool CVMobjectLockedByCurrentThread(CVMExecEnv *ee,
+                                              CVMObjectICell *objICell);
+extern CVMBool CVMgcSafeObjectLock(CVMExecEnv *ee, CVMObjectICell *o);
+extern CVMBool CVMgcSafeObjectUnlock(CVMExecEnv *ee, CVMObjectICell *o);
+extern CVMBool CVMgcSafeObjectNotify(CVMExecEnv *ee, CVMObjectICell *o);
+extern CVMBool CVMgcSafeObjectNotifyAll(CVMExecEnv *ee, CVMObjectICell *o);
+extern CVMBool CVMgcSafeObjectWait(CVMExecEnv *ee, CVMObjectICell *o,
+       CVMInt64 millis);
+extern void CVMobjectMicroLock(CVMExecEnv *ee, CVMObject *obj);
+extern void CVMobjectMicroUnlock(CVMExecEnv *ee, CVMObject *obj);
+struct CVMArrayInfo {
+    CVMUint16 depth;
+    CVMBasicType baseType;
+    CVMClassBlock* baseCb;
+    CVMClassBlock* elementCb;
+};
+typedef CVMJavaVal32 CVMTwoJavaWords[2];
+struct CVMArrayOfByte { CVMObjectHeader hdr; CVMJavaInt length; CVMJavaByte elems[1]; };
+struct CVMArrayOfShort { CVMObjectHeader hdr; CVMJavaInt length; CVMJavaShort elems[1]; };
+struct CVMArrayOfChar { CVMObjectHeader hdr; CVMJavaInt length; CVMJavaChar elems[1]; };
+struct CVMArrayOfBoolean { CVMObjectHeader hdr; CVMJavaInt length; CVMJavaBoolean elems[1]; };
+struct CVMArrayOfInt { CVMObjectHeader hdr; CVMJavaInt length; CVMJavaInt elems[1]; };
+struct CVMArrayOfRef { CVMObjectHeader hdr; CVMJavaInt length; CVMObjectICell elems[1]; };
+struct CVMArrayOfFloat { CVMObjectHeader hdr; CVMJavaInt length; CVMJavaFloat elems[1]; };
+struct CVMArrayOfLong { CVMObjectHeader hdr; CVMJavaInt length; CVMTwoJavaWords elems[1]; };
+struct CVMArrayOfDouble { CVMObjectHeader hdr; CVMJavaInt length; CVMTwoJavaWords elems[1]; };
+struct CVMArrayOfAnyType { CVMObjectHeader hdr; CVMJavaInt length; CVMJavaVal32 elems[1]; };
+struct CVMArrayOfByteICell { CVMArrayOfByte * volatile ref_DONT_ACCESS_DIRECTLY; };
+struct CVMArrayOfShortICell { CVMArrayOfShort * volatile ref_DONT_ACCESS_DIRECTLY; };
+struct CVMArrayOfCharICell { CVMArrayOfChar * volatile ref_DONT_ACCESS_DIRECTLY; };
+struct CVMArrayOfBooleanICell { CVMArrayOfBoolean * volatile ref_DONT_ACCESS_DIRECTLY; };
+struct CVMArrayOfIntICell { CVMArrayOfInt * volatile ref_DONT_ACCESS_DIRECTLY; };
+struct CVMArrayOfRefICell { CVMArrayOfRef * volatile ref_DONT_ACCESS_DIRECTLY; };
+struct CVMArrayOfFloatICell { CVMArrayOfFloat * volatile ref_DONT_ACCESS_DIRECTLY; };
+struct CVMArrayOfLongICell { CVMArrayOfLong * volatile ref_DONT_ACCESS_DIRECTLY; };
+struct CVMArrayOfDoubleICell { CVMArrayOfDouble * volatile ref_DONT_ACCESS_DIRECTLY; };
+struct CVMArrayOfAnyTypeICell { CVMArrayOfAnyType * volatile ref_DONT_ACCESS_DIRECTLY; };
+typedef enum {
+    CVM_GC_SAFE,
+    CVM_NUM_CONSISTENT_STATES
+} CVMCStateID;
+struct CVMCState {
+    volatile CVMBool request;
+    CVMUint32 count;
+    volatile CVMBool reached;
+    CVMExecEnv *requester;
+    volatile CVMUint32 inconsistentThreadCount;
+    CVMSysMutex mutex;
+    CVMCondVar consistentCV;
+    CVMCondVar resumeCV;
+    const char *name;
+};
+struct CVMTCState {
+    volatile CVMBool isConsistent;
+    volatile CVMBool wasConsistent;
+};
+extern CVMBool CVMcsInit(CVMCState *,
+    const char *name,
+    CVMUint8 rank);
+extern void CVMcsDestroy(CVMCState *);
+extern void CVMtcsInit(CVMTCState *);
+extern void CVMtcsDestroy(CVMTCState *);
+extern void CVMcsReachConsistentState(CVMExecEnv *, CVMCStateID);
+extern void CVMcsResumeConsistentState(CVMExecEnv *, CVMCStateID);
+extern CVMBool CVMcsCheckRequest(CVMCState *);
+extern void CVMcsBecomeConsistent(CVMCState *, CVMTCState *);
+extern void CVMcsBecomeInconsistent(CVMCState *, CVMTCState *);
+extern void CVMcsRendezvous(CVMExecEnv *, CVMCState *, CVMTCState *,
+     CVMBool block);
+extern const char * const CVMcstateNames[CVM_NUM_CONSISTENT_STATES];
+typedef union {
+    CVMInt32 i;
+    CVMJavaFloat f;
+    CVMAddr v64[2];
+    void * o;
+} CVMJNIReturnValue;
+extern CVMInt32
+CVMjniInvokeNative(void * env, void * nativeCode, CVMAddr * args,
+     CVMUint32 * terseSig, CVMInt32 argsSize,
+     void * classObject,
+     CVMJNIReturnValue * returnValue);
+typedef enum {
+    CNI_VOID = 0,
+    CNI_SINGLE = 1,
+    CNI_DOUBLE = 2,
+    CNI_NEW_TRANSITION_FRAME = -1,
+    CNI_NEW_MB = -3,
+    CNI_EXCEPTION = -4
+} CNIResultCode;
+typedef CNIResultCode CNINativeMethod(CVMExecEnv* ee,
+          CVMStackVal32* arguments,
+          CVMMethodBlock** p_mb);
+typedef CVMJavaBoolean jboolean;
+typedef CVMJavaChar jchar;
+typedef CVMJavaShort jshort;
+typedef CVMJavaFloat jfloat;
+typedef CVMJavaDouble jdouble;
+typedef CVMJavaInt jint;
+typedef CVMJavaByte jbyte;
+typedef CVMJavaLong jlong;
+typedef jint jsize;
+typedef CVMObjectICell* jobject;
+typedef jobject jclass;
+typedef jobject jthrowable;
+typedef jobject jstring;
+typedef jobject jarray;
+typedef jarray jbooleanArray;
+typedef jarray jbyteArray;
+typedef jarray jcharArray;
+typedef jarray jshortArray;
+typedef jarray jintArray;
+typedef jarray jlongArray;
+typedef jarray jfloatArray;
+typedef jarray jdoubleArray;
+typedef jarray jobjectArray;
+typedef jobject jweak;
+typedef union jvalue {
+    jboolean z;
+    jbyte b;
+    jchar c;
+    jshort s;
+    jint i;
+    jlong j;
+    jfloat f;
+    jdouble d;
+    jobject l;
+} jvalue;
+typedef CVMMethodBlock* jmethodID;
+typedef CVMFieldBlock* jfieldID;
+typedef struct {
+    char *name;
+    char *signature;
+    void *fnPtr;
+} JNINativeMethod;
+struct JNIInvokeInterface;
+typedef const struct JNIInvokeInterface *JavaVM;
+struct JNINativeInterface {
+    void *reserved0;
+    void *reserved1;
+    void *reserved2;
+    void *reserved3;
+    jint ( *GetVersion)(JNIEnv *env);
+    jclass ( *DefineClass)
+      (JNIEnv *env, const char *name, jobject loader, const jbyte *buf,
+       jsize len);
+    jclass ( *FindClass)
+      (JNIEnv *env, const char *name);
+    jmethodID ( *FromReflectedMethod)
+      (JNIEnv *env, jobject method);
+    jfieldID ( *FromReflectedField)
+      (JNIEnv *env, jobject field);
+    jobject ( *ToReflectedMethod)
+      (JNIEnv *env, jclass cls, jmethodID methodID, jboolean isStatic);
+    jclass ( *GetSuperclass)
+      (JNIEnv *env, jclass sub);
+    jboolean ( *IsAssignableFrom)
+      (JNIEnv *env, jclass sub, jclass sup);
+    jobject ( *ToReflectedField)
+      (JNIEnv *env, jclass cls, jfieldID fieldID, jboolean isStatic);
+    jint ( *Throw)
+      (JNIEnv *env, jthrowable obj);
+    jint ( *ThrowNew)
+      (JNIEnv *env, jclass clazz, const char *msg);
+    jthrowable ( *ExceptionOccurred)
+      (JNIEnv *env);
+    void ( *ExceptionDescribe)
+      (JNIEnv *env);
+    void ( *ExceptionClear)
+      (JNIEnv *env);
+    void ( *FatalError)
+      (JNIEnv *env, const char *msg);
+    jint ( *PushLocalFrame)
+      (JNIEnv *env, jint capacity);
+    jobject ( *PopLocalFrame)
+      (JNIEnv *env, jobject result);
+    jobject ( *NewGlobalRef)
+      (JNIEnv *env, jobject lobj);
+    void ( *DeleteGlobalRef)
+      (JNIEnv *env, jobject gref);
+    void ( *DeleteLocalRef)
+      (JNIEnv *env, jobject obj);
+    jboolean ( *IsSameObject)
+      (JNIEnv *env, jobject obj1, jobject obj2);
+    jobject ( *NewLocalRef)
+      (JNIEnv *env, jobject ref);
+    jint ( *EnsureLocalCapacity)
+      (JNIEnv *env, jint capacity);
+    jobject ( *AllocObject)
+      (JNIEnv *env, jclass clazz);
+    jobject ( *NewObject)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jobject ( *NewObjectV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jobject ( *NewObjectA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);
+    jclass ( *GetObjectClass)
+      (JNIEnv *env, jobject obj);
+    jboolean ( *IsInstanceOf)
+      (JNIEnv *env, jobject obj, jclass clazz);
+    jmethodID ( *GetMethodID)
+      (JNIEnv *env, jclass clazz, const char *name, const char *sig);
+    jobject ( *CallObjectMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    jobject ( *CallObjectMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    jobject ( *CallObjectMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue * args);
+    jboolean ( *CallBooleanMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    jboolean ( *CallBooleanMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    jboolean ( *CallBooleanMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue * args);
+    jbyte ( *CallByteMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    jbyte ( *CallByteMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    jbyte ( *CallByteMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args);
+    jchar ( *CallCharMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    jchar ( *CallCharMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    jchar ( *CallCharMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args);
+    jshort ( *CallShortMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    jshort ( *CallShortMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    jshort ( *CallShortMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args);
+    jint ( *CallIntMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    jint ( *CallIntMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    jint ( *CallIntMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args);
+    jlong ( *CallLongMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    jlong ( *CallLongMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    jlong ( *CallLongMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args);
+    jfloat ( *CallFloatMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    jfloat ( *CallFloatMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    jfloat ( *CallFloatMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args);
+    jdouble ( *CallDoubleMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    jdouble ( *CallDoubleMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    jdouble ( *CallDoubleMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args);
+    void ( *CallVoidMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    void ( *CallVoidMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    void ( *CallVoidMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue * args);
+    jobject ( *CallNonvirtualObjectMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    jobject ( *CallNonvirtualObjectMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    jobject ( *CallNonvirtualObjectMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       const jvalue * args);
+    jboolean ( *CallNonvirtualBooleanMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    jboolean ( *CallNonvirtualBooleanMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    jboolean ( *CallNonvirtualBooleanMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       const jvalue * args);
+    jbyte ( *CallNonvirtualByteMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    jbyte ( *CallNonvirtualByteMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    jbyte ( *CallNonvirtualByteMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       const jvalue *args);
+    jchar ( *CallNonvirtualCharMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    jchar ( *CallNonvirtualCharMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    jchar ( *CallNonvirtualCharMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       const jvalue *args);
+    jshort ( *CallNonvirtualShortMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    jshort ( *CallNonvirtualShortMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    jshort ( *CallNonvirtualShortMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       const jvalue *args);
+    jint ( *CallNonvirtualIntMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    jint ( *CallNonvirtualIntMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    jint ( *CallNonvirtualIntMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       const jvalue *args);
+    jlong ( *CallNonvirtualLongMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    jlong ( *CallNonvirtualLongMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    jlong ( *CallNonvirtualLongMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       const jvalue *args);
+    jfloat ( *CallNonvirtualFloatMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    jfloat ( *CallNonvirtualFloatMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    jfloat ( *CallNonvirtualFloatMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       const jvalue *args);
+    jdouble ( *CallNonvirtualDoubleMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    jdouble ( *CallNonvirtualDoubleMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    jdouble ( *CallNonvirtualDoubleMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       const jvalue *args);
+    void ( *CallNonvirtualVoidMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    void ( *CallNonvirtualVoidMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    void ( *CallNonvirtualVoidMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       const jvalue * args);
+    jfieldID ( *GetFieldID)
+      (JNIEnv *env, jclass clazz, const char *name, const char *sig);
+    jobject ( *GetObjectField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jboolean ( *GetBooleanField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jbyte ( *GetByteField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jchar ( *GetCharField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jshort ( *GetShortField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jint ( *GetIntField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jlong ( *GetLongField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jfloat ( *GetFloatField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jdouble ( *GetDoubleField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID);
+    void ( *SetObjectField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID, jobject val);
+    void ( *SetBooleanField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID, jboolean val);
+    void ( *SetByteField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID, jbyte val);
+    void ( *SetCharField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID, jchar val);
+    void ( *SetShortField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID, jshort val);
+    void ( *SetIntField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID, jint val);
+    void ( *SetLongField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID, jlong val);
+    void ( *SetFloatField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID, jfloat val);
+    void ( *SetDoubleField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID, jdouble val);
+    jmethodID ( *GetStaticMethodID)
+      (JNIEnv *env, jclass clazz, const char *name, const char *sig);
+    jobject ( *CallStaticObjectMethod)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jobject ( *CallStaticObjectMethodV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jobject ( *CallStaticObjectMethodA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);
+    jboolean ( *CallStaticBooleanMethod)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jboolean ( *CallStaticBooleanMethodV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jboolean ( *CallStaticBooleanMethodA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);
+    jbyte ( *CallStaticByteMethod)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jbyte ( *CallStaticByteMethodV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jbyte ( *CallStaticByteMethodA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);
+    jchar ( *CallStaticCharMethod)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jchar ( *CallStaticCharMethodV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jchar ( *CallStaticCharMethodA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);
+    jshort ( *CallStaticShortMethod)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jshort ( *CallStaticShortMethodV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jshort ( *CallStaticShortMethodA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);
+    jint ( *CallStaticIntMethod)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jint ( *CallStaticIntMethodV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jint ( *CallStaticIntMethodA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);
+    jlong ( *CallStaticLongMethod)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jlong ( *CallStaticLongMethodV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jlong ( *CallStaticLongMethodA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);
+    jfloat ( *CallStaticFloatMethod)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jfloat ( *CallStaticFloatMethodV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jfloat ( *CallStaticFloatMethodA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);
+    jdouble ( *CallStaticDoubleMethod)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jdouble ( *CallStaticDoubleMethodV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jdouble ( *CallStaticDoubleMethodA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);
+    void ( *CallStaticVoidMethod)
+      (JNIEnv *env, jclass cls, jmethodID methodID, ...);
+    void ( *CallStaticVoidMethodV)
+      (JNIEnv *env, jclass cls, jmethodID methodID, va_list args);
+    void ( *CallStaticVoidMethodA)
+      (JNIEnv *env, jclass cls, jmethodID methodID, const jvalue * args);
+    jfieldID ( *GetStaticFieldID)
+      (JNIEnv *env, jclass clazz, const char *name, const char *sig);
+    jobject ( *GetStaticObjectField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jboolean ( *GetStaticBooleanField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jbyte ( *GetStaticByteField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jchar ( *GetStaticCharField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jshort ( *GetStaticShortField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jint ( *GetStaticIntField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jlong ( *GetStaticLongField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jfloat ( *GetStaticFloatField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jdouble ( *GetStaticDoubleField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    void ( *SetStaticObjectField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID, jobject value);
+    void ( *SetStaticBooleanField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID, jboolean value);
+    void ( *SetStaticByteField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID, jbyte value);
+    void ( *SetStaticCharField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID, jchar value);
+    void ( *SetStaticShortField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID, jshort value);
+    void ( *SetStaticIntField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID, jint value);
+    void ( *SetStaticLongField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID, jlong value);
+    void ( *SetStaticFloatField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID, jfloat value);
+    void ( *SetStaticDoubleField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID, jdouble value);
+    jstring ( *NewString)
+      (JNIEnv *env, const jchar *unicode, jsize len);
+    jsize ( *GetStringLength)
+      (JNIEnv *env, jstring str);
+    const jchar *( *GetStringChars)
+      (JNIEnv *env, jstring str, jboolean *isCopy);
+    void ( *ReleaseStringChars)
+      (JNIEnv *env, jstring str, const jchar *chars);
+    jstring ( *NewStringUTF)
+      (JNIEnv *env, const char *utf);
+    jsize ( *GetStringUTFLength)
+      (JNIEnv *env, jstring str);
+    const char* ( *GetStringUTFChars)
+      (JNIEnv *env, jstring str, jboolean *isCopy);
+    void ( *ReleaseStringUTFChars)
+      (JNIEnv *env, jstring str, const char* chars);
+    jsize ( *GetArrayLength)
+      (JNIEnv *env, jarray array);
+    jobjectArray ( *NewObjectArray)
+      (JNIEnv *env, jsize len, jclass clazz, jobject init);
+    jobject ( *GetObjectArrayElement)
+      (JNIEnv *env, jobjectArray array, jsize index);
+    void ( *SetObjectArrayElement)
+      (JNIEnv *env, jobjectArray array, jsize index, jobject val);
+    jbooleanArray ( *NewBooleanArray)
+      (JNIEnv *env, jsize len);
+    jbyteArray ( *NewByteArray)
+      (JNIEnv *env, jsize len);
+    jcharArray ( *NewCharArray)
+      (JNIEnv *env, jsize len);
+    jshortArray ( *NewShortArray)
+      (JNIEnv *env, jsize len);
+    jintArray ( *NewIntArray)
+      (JNIEnv *env, jsize len);
+    jlongArray ( *NewLongArray)
+      (JNIEnv *env, jsize len);
+    jfloatArray ( *NewFloatArray)
+      (JNIEnv *env, jsize len);
+    jdoubleArray ( *NewDoubleArray)
+      (JNIEnv *env, jsize len);
+    jboolean * ( *GetBooleanArrayElements)
+      (JNIEnv *env, jbooleanArray array, jboolean *isCopy);
+    jbyte * ( *GetByteArrayElements)
+      (JNIEnv *env, jbyteArray array, jboolean *isCopy);
+    jchar * ( *GetCharArrayElements)
+      (JNIEnv *env, jcharArray array, jboolean *isCopy);
+    jshort * ( *GetShortArrayElements)
+      (JNIEnv *env, jshortArray array, jboolean *isCopy);
+    jint * ( *GetIntArrayElements)
+      (JNIEnv *env, jintArray array, jboolean *isCopy);
+    jlong * ( *GetLongArrayElements)
+      (JNIEnv *env, jlongArray array, jboolean *isCopy);
+    jfloat * ( *GetFloatArrayElements)
+      (JNIEnv *env, jfloatArray array, jboolean *isCopy);
+    jdouble * ( *GetDoubleArrayElements)
+      (JNIEnv *env, jdoubleArray array, jboolean *isCopy);
+    void ( *ReleaseBooleanArrayElements)
+      (JNIEnv *env, jbooleanArray array, jboolean *elems, jint mode);
+    void ( *ReleaseByteArrayElements)
+      (JNIEnv *env, jbyteArray array, jbyte *elems, jint mode);
+    void ( *ReleaseCharArrayElements)
+      (JNIEnv *env, jcharArray array, jchar *elems, jint mode);
+    void ( *ReleaseShortArrayElements)
+      (JNIEnv *env, jshortArray array, jshort *elems, jint mode);
+    void ( *ReleaseIntArrayElements)
+      (JNIEnv *env, jintArray array, jint *elems, jint mode);
+    void ( *ReleaseLongArrayElements)
+      (JNIEnv *env, jlongArray array, jlong *elems, jint mode);
+    void ( *ReleaseFloatArrayElements)
+      (JNIEnv *env, jfloatArray array, jfloat *elems, jint mode);
+    void ( *ReleaseDoubleArrayElements)
+      (JNIEnv *env, jdoubleArray array, jdouble *elems, jint mode);
+    void ( *GetBooleanArrayRegion)
+      (JNIEnv *env, jbooleanArray array, jsize start, jsize l, jboolean *buf);
+    void ( *GetByteArrayRegion)
+      (JNIEnv *env, jbyteArray array, jsize start, jsize len, jbyte *buf);
+    void ( *GetCharArrayRegion)
+      (JNIEnv *env, jcharArray array, jsize start, jsize len, jchar *buf);
+    void ( *GetShortArrayRegion)
+      (JNIEnv *env, jshortArray array, jsize start, jsize len, jshort *buf);
+    void ( *GetIntArrayRegion)
+      (JNIEnv *env, jintArray array, jsize start, jsize len, jint *buf);
+    void ( *GetLongArrayRegion)
+      (JNIEnv *env, jlongArray array, jsize start, jsize len, jlong *buf);
+    void ( *GetFloatArrayRegion)
+      (JNIEnv *env, jfloatArray array, jsize start, jsize len, jfloat *buf);
+    void ( *GetDoubleArrayRegion)
+      (JNIEnv *env, jdoubleArray array, jsize start, jsize len, jdouble *buf);
+    void ( *SetBooleanArrayRegion)
+      (JNIEnv *env, jbooleanArray array, jsize start, jsize l,
+       const jboolean *buf);
+    void ( *SetByteArrayRegion)
+      (JNIEnv *env, jbyteArray array, jsize start, jsize len, const jbyte *buf);
+    void ( *SetCharArrayRegion)
+      (JNIEnv *env, jcharArray array, jsize start, jsize len, const jchar *buf);
+    void ( *SetShortArrayRegion)
+      (JNIEnv *env, jshortArray array, jsize start, jsize len,
+       const jshort *buf);
+    void ( *SetIntArrayRegion)
+      (JNIEnv *env, jintArray array, jsize start, jsize len, const jint *buf);
+    void ( *SetLongArrayRegion)
+      (JNIEnv *env, jlongArray array, jsize start, jsize len, const jlong *buf);
+    void ( *SetFloatArrayRegion)
+      (JNIEnv *env, jfloatArray array, jsize start, jsize len,
+       const jfloat *buf);
+    void ( *SetDoubleArrayRegion)
+      (JNIEnv *env, jdoubleArray array, jsize start, jsize len,
+       const jdouble *buf);
+    jint ( *RegisterNatives)
+      (JNIEnv *env, jclass clazz, const JNINativeMethod *methods,
+       jint nMethods);
+    jint ( *UnregisterNatives)
+      (JNIEnv *env, jclass clazz);
+    jint ( *MonitorEnter)
+      (JNIEnv *env, jobject obj);
+    jint ( *MonitorExit)
+      (JNIEnv *env, jobject obj);
+    jint ( *GetJavaVM)
+      (JNIEnv *env, JavaVM **vm);
+    void ( *GetStringRegion)
+      (JNIEnv *env, jstring str, jsize start, jsize len, jchar *buf);
+    void ( *GetStringUTFRegion)
+      (JNIEnv *env, jstring str, jsize start, jsize len, char *buf);
+    void * ( *GetPrimitiveArrayCritical)
+      (JNIEnv *env, jarray array, jboolean *isCopy);
+    void ( *ReleasePrimitiveArrayCritical)
+      (JNIEnv *env, jarray array, void *carray, jint mode);
+    const jchar * ( *GetStringCritical)
+      (JNIEnv *env, jstring string, jboolean *isCopy);
+    void ( *ReleaseStringCritical)
+      (JNIEnv *env, jstring string, const jchar *cstring);
+    jweak ( *NewWeakGlobalRef)
+       (JNIEnv *env, jobject obj);
+    void ( *DeleteWeakGlobalRef)
+       (JNIEnv *env, jweak ref);
+    jboolean ( *ExceptionCheck)
+       (JNIEnv *env);
+    jobject ( *NewDirectByteBuffer)
+       (JNIEnv* env, void* address, jlong capacity);
+    void* ( *GetDirectBufferAddress)
+       (JNIEnv* env, jobject buf);
+    jlong ( *GetDirectBufferCapacity)
+       (JNIEnv* env, jobject buf);
+};
+typedef struct JavaVMOption {
+    char *optionString;
+    void *extraInfo;
+} JavaVMOption;
+typedef struct JavaVMInitArgs {
+    jint version;
+    jint nOptions;
+    JavaVMOption *options;
+    jboolean ignoreUnrecognized;
+} JavaVMInitArgs;
+typedef struct JavaVMAttachArgs {
+    jint version;
+    char *name;
+    jobject group;
+} JavaVMAttachArgs;
+struct JNIInvokeInterface {
+    void *reserved0;
+    void *reserved1;
+    void *reserved2;
+    jint ( *DestroyJavaVM)(JavaVM *vm);
+    jint ( *AttachCurrentThread)(JavaVM *vm, void **penv, void *args);
+    jint ( *DetachCurrentThread)(JavaVM *vm);
+    jint ( *GetEnv)(JavaVM *vm, void **penv, jint version);
+    jint ( *AttachCurrentThreadAsDaemon)(JavaVM *vm, void **penv, void *args);
+};
+extern jint
+JNI_GetDefaultJavaVMInitArgs(void *args);
+extern jint
+JNI_CreateJavaVM(JavaVM **pvm, void **penv, void *args);
+extern jint
+JNI_GetCreatedJavaVMs(JavaVM **, jsize, jsize *);
+extern jint
+JNI_OnLoad(JavaVM *vm, void *reserved);
+extern void
+JNI_OnUnload(JavaVM *vm, void *reserved);
+union CVMConstantPoolEntry {
+    union {
+ struct {
+     CVMUint16 nameUtf8Idx;
+     CVMUint16 typeUtf8Idx;
+ } nameAndType;
+ struct {
+     CVMUint16 utf8Idx;
+ } clazz;
+ struct {
+     CVMUint16 utf8Idx;
+ } string;
+ CVMUtf8* utf8;
+    } intermediate;
+    union {
+ struct {
+     CVMUint16 classIdx;
+     CVMUint16 typeIDIdx;
+ } memberRef;
+ CVMMethodTypeID methodTypeID;
+ CVMFieldTypeID fieldTypeID;
+ CVMClassTypeID classTypeID;
+    } unresolved;
+    union {
+ CVMJavaVal32 val32;
+ CVMClassBlock* cb;
+ CVMFieldBlock* fb;
+ CVMMethodBlock* mb;
+ CVMStringObject* strObj;
+ CVMStringICell* strICell;
+    } resolved;
+};
+typedef CVMUint8 CVMConstantPoolEntryType;
+union CVMConstantPool {
+    CVMConstantPoolEntryType* cpTypesX;
+    CVMConstantPoolEntry entriesX[1];
+};
+struct CVMTransitionConstantPool {
+    CVMConstantPool cp;
+    CVMConstantPoolEntry entry1X;
+};
+enum CVMConstantPoolEntryTypeEnum {
+    CVM_CONSTANT_Utf8 = 1,
+    CVM_CONSTANT_Unicode = 2,
+    CVM_CONSTANT_Integer = 3,
+    CVM_CONSTANT_Float = 4,
+    CVM_CONSTANT_Long = 5,
+    CVM_CONSTANT_Double = 6,
+    CVM_CONSTANT_Class = 7,
+    CVM_CONSTANT_String = 8,
+    CVM_CONSTANT_Fieldref = 9,
+    CVM_CONSTANT_Methodref = 10,
+    CVM_CONSTANT_InterfaceMethodref = 11,
+    CVM_CONSTANT_NameAndType = 12,
+    CVM_CONSTANT_ClassTypeID = 13,
+    CVM_CONSTANT_MethodTypeID = 14,
+    CVM_CONSTANT_FieldTypeID = 15,
+    CVM_CONSTANT_ClassBlock = 19,
+    CVM_CONSTANT_FieldBlock = 20,
+    CVM_CONSTANT_MethodBlock = 21,
+    CVM_CONSTANT_StringObj = 22,
+    CVM_CONSTANT_StringICell = 23,
+    CVM_CONSTANT_Invalid = 24
+};
+typedef enum CVMConstantPoolEntryTypeEnum CVMConstantPoolEntryTypeEnum;
+extern CVMBool
+CVMprivate_cpExtractTypeIDFromUnresolvedEntry(CVMExecEnv* ee,
+           CVMClassBlock* currentCb,
+           CVMConstantPool* cp,
+           CVMUint16 cpIndex,
+           CVMTypeID* p_typeid);
+extern void
+CVMcpResolveCbEntriesWithoutClassLoading(CVMExecEnv* ee,
+                                         CVMClassBlock* cb);
+CVMBool
+CVMprivate_cpResolveEntryFromClass(CVMExecEnv* ee,
+       CVMClassBlock* currentCb,
+       CVMConstantPool* cp,
+       CVMUint16 cpIndex);
+CVMBool
+CVMprivate_cpResolveEntryWithoutClassLoading(CVMExecEnv* ee,
+          CVMClassBlock* currentCb,
+          CVMConstantPool* cp,
+          CVMUint16 cpIndex,
+          CVMTypeID* p_typeid);
+union CVMGCBitMap {
+    CVMAddr map;
+    CVMBigGCBitMap* bigmap;
+};
+struct CVMBigGCBitMap {
+    CVMUint16 maplen;
+    CVMAddr map[1];
+};
+struct CVMClassBlock {
+    CVMGCBitMap gcMapX;
+    CVMClassTypeID classNameX;
+    union {
+ CVMClassBlock* superclassCb;
+ CVMClassTypeID superclassTypeID;
+ CVMUint16 mirandaMethodCountX;
+    } superclassX;
+    union {
+ CVMConstantPool* constantpoolX;
+ CVMArrayInfo* arrayInfoX;
+    } cpX;
+    CVMInterfaces* interfacesX;
+    CVMMethodArray* methodsX;
+    CVMFieldArray* fieldsX;
+    union {
+ CVMJavaVal32* statics;
+ CVMClassBlock* freeClassLink;
+    } staticsX;
+    CVMUint16 constantpoolCountX;
+    CVMUint16 methodCountX;
+    CVMUint16 fieldCountX;
+    CVMUint16 methodTableCountX;
+    CVMUint16 accessFlagsX;
+    volatile CVMUint8 runtimeFlagsX;
+    CVMUint16 instanceSizeX;
+    CVMUint16 numStaticRefsX;
+    CVMClassICell* javaInstanceX;
+    char* theNameX;
+    CVMClassLoaderICell* classLoaderX;
+    CVMObjectICell* protectionDomainX;
+    union {
+ CVMExecEnv** eePtr;
+ CVMExecEnv* ee;
+ CVMClassBlock** classTableSlotPtr;
+    } clinitEEX;
+    CVMUint16* checkedExceptionsX;
+    char* sourceFileNameX;
+    CVMMethodBlock** methodTablePtrX;
+    CVMInnerClassesInfo* innerClassesInfoX;
+    CVMUint16 major_version;
+    CVMUint16 minor_version;
+};
+struct CVMInterfaceTable {
+    CVMClassBlock* interfaceCb;
+    union {
+ CVMUint16* methodTableIndicesX;
+ CVMClassTypeID interfaceTypeIDX;
+    } intfInfoX;
+};
+struct CVMInterfaces {
+    CVMUint16 interfaceCountX;
+    CVMUint16 implementsCountX;
+    CVMInterfaceTable itable[1];
+};
+struct CVMMethodBlockImmutable {
+    CVMMethodTypeID nameAndTypeIDX;
+    CVMUint16 methodTableIndexX;
+    CVMUint8 argsSizeX;
+    CVMUint8 methodIndexX;
+    CVMUint16 invokerAndAccessFlagsX;
+    CVMUint16 checkedExceptionsOffsetX;
+    union {
+ CVMJavaMethodDescriptor* jmd;
+ CVMUint8* nativeCode;
+ CVMAddr methodSlotIndex;
+ CVMMethodBlock* interfaceMb;
+    } codeX;
+};
+struct CVMMethodBlock {
+    CVMMethodBlockImmutable immutX;
+};
+struct CVMMethodRange {
+    CVMClassBlock* cb;
+    CVMMethodBlock mb[256];
+};
+struct CVMMethodArray {
+    CVMMethodRange ranges[1];
+};
+typedef CVMUint16 CVMCheckedException;
+struct CVMCheckedExceptions {
+    CVMUint16 numExceptions;
+    CVMCheckedException exceptions[1];
+};
+struct CVMJavaMethodDescriptor {
+    CVMUint16 maxLocalsX;
+    CVMUint16 flagsX;
+    CVMUint32 capacityX;
+    CVMUint16 exceptionTableLengthX;
+    CVMUint16 codeLengthX;
+    CVMUint16 lineNumberTableLengthX;
+    CVMUint16 localVariableTableLengthX;
+};
+struct CVMStackMapEntry {
+    CVMUint16 pc;
+    CVMUint16 state[1];
+};
+struct CVMStackMaps {
+    CVMStackMaps * next;
+    CVMStackMaps * prev;
+    CVMUint32 size;
+    CVMMethodBlock * mb;
+    CVMUint32 noGcPoints;
+    CVMStackMapEntry smEntries[1];
+};
+typedef struct CVMJavaMethodExtension {
+    CVMJavaMethodDescriptor* originalJmd;
+} CVMJavaMethodExtension;
+struct CVMExceptionHandler {
+    CVMUint16 startpc;
+    CVMUint16 endpc;
+    CVMUint16 handlerpc;
+    CVMUint16 catchtype;
+};
+struct CVMLineNumberEntry {
+    CVMUint16 startpc;
+    CVMUint16 lineNumber;
+};
+struct CVMLocalVariableEntry {
+    CVMUint16 startpc;
+    CVMUint16 length;
+    CVMUint16 index;
+    CVMTypeIDNamePart nameID;
+    CVMTypeIDTypePart typeID;
+};
+struct CVMFieldBlock {
+    CVMFieldTypeID nameAndTypeIDX;
+    CVMUint8 accessFlagsX;
+    CVMUint8 fbIndexX;
+    CVMUint16 offsetX;
+};
+struct CVMFieldRange {
+    CVMClassBlock* cb;
+    CVMFieldBlock fb[256];
+};
+struct CVMFieldArray {
+    CVMFieldRange ranges[1];
+};
+struct CVMInnerClassInfo {
+    CVMUint16 innerClassIndex;
+    CVMUint16 outerClassIndex;
+    CVMUint16 unused;
+    CVMUint16 innerClassAccessFlags;
+};
+struct CVMInnerClassesInfo {
+    CVMUint32 count;
+    CVMInnerClassInfo info[1];
+};
+enum {
+    CVM_INVOKE_JAVA_METHOD,
+    CVM_INVOKE_JAVA_SYNC_METHOD,
+    CVM_INVOKE_CNI_METHOD,
+    CVM_INVOKE_JNI_METHOD,
+    CVM_INVOKE_JNI_SYNC_METHOD,
+    CVM_INVOKE_ABSTRACT_METHOD,
+    CVM_INVOKE_NONPUBLIC_MIRANDA_METHOD,
+    CVM_INVOKE_MISSINGINTERFACE_MIRANDA_METHOD,
+    CVM_INVOKE_LAZY_JNI_METHOD,
+    CVM_NUM_INVOKER_TYPES
+};
+CVMClassBlock*
+CVMclassLookupClassWithoutLoading(CVMExecEnv* ee, CVMClassTypeID typeID,
+      CVMClassLoaderICell* loader);
+extern CVMClassBlock*
+CVMclassLookupByNameFromClass(CVMExecEnv* ee, const char* name,
+         CVMBool init, CVMClassBlock* fromClass);
+extern CVMClassBlock*
+CVMclassLookupByTypeFromClass(CVMExecEnv* ee, CVMClassTypeID typeID,
+         CVMBool init, CVMClassBlock* fromClass);
+extern CVMClassBlock*
+CVMclassLookupByNameFromClassLoader(CVMExecEnv* ee, const char* name,
+        CVMBool init,
+        CVMClassLoaderICell* loader,
+        CVMObjectICell* pd,
+        CVMBool throwError);
+extern CVMClassBlock*
+CVMclassLookupByTypeFromClassLoader(CVMExecEnv* ee, CVMClassTypeID typeID,
+        CVMBool init,
+        CVMClassLoaderICell* loader,
+        CVMObjectICell* pd,
+        CVMBool throwError);
+CVMClassBlock*
+CVMclassGetArrayOfWithNoClassCreation(CVMExecEnv* ee, CVMClassBlock* elemCb);
+extern CVMClassBlock*
+CVMclassGetArrayOf(CVMExecEnv* ee, CVMClassBlock* elemCb);
+extern CVMMethodBlock*
+CVMclassGetMethodBlock(const CVMClassBlock* cb, const CVMMethodTypeID tid,
+         CVMBool isStatic);
+CVMMethodBlock*
+CVMclassGetDeclaredMethodBlockFromTID(const CVMClassBlock* cb,
+          CVMMethodTypeID tid);
+extern CVMMethodBlock*
+CVMclassGetDeclaredMethodBlock(CVMExecEnv *ee,
+          const CVMClassBlock* cb,
+          const char *name,
+          const char *sig);
+extern CVMFieldBlock*
+CVMclassGetFieldBlock(const CVMClassBlock* cb, const CVMFieldTypeID tid,
+        CVMBool isStatic);
+extern CVMBool
+CVMclassLinkSuperClasses(CVMExecEnv* ee, CVMClassBlock* cb);
+extern CVMClassBlock*
+CVMclassLoadClass(CVMExecEnv* ee, CVMClassLoaderICell* loader,
+    const char* classname, CVMClassTypeID classTypeID);
+CVMClassICell*
+CVMclassLoadBootClass(CVMExecEnv* ee, const char* classname);
+extern CVMClassICell*
+CVMclassCreateInternalClass(CVMExecEnv* ee,
+       const CVMUint8* externalClass,
+       CVMUint32 classSize,
+       CVMClassLoaderICell* loader,
+       const char* classname,
+       const char* dirNameOrZipFileName,
+       CVMBool isRedefine);
+extern void
+CVMclassFree(CVMExecEnv* ee, CVMClassBlock* cb);
+extern void
+CVMclassFreeJavaMethods(CVMExecEnv* ee, CVMClassBlock* cb,
+   CVMBool isPreloaded);
+extern void
+CVMclassFreeLocalVariableTableFieldIDs(CVMExecEnv* ee, CVMMethodBlock* mb);
+extern void
+CVMclassDoClassUnloadingPass1(CVMExecEnv* ee,
+         CVMRefLivenessQueryFunc isLive,
+         void* isLiveData,
+         CVMRefCallbackFunc transitiveScanner,
+         void* transitiveScannerData,
+         CVMGCOptions* gcOpts);
+extern void
+CVMclassDoClassUnloadingPass2(CVMExecEnv* ee);
+extern CVMBool
+CVMclassVerify(CVMExecEnv* ee, CVMClassBlock* cb);
+enum { CVM_VERIFY_NONE = 0, CVM_VERIFY_REMOTE, CVM_VERIFY_ALL, CVM_VERIFY_UNRECOGNIZED };
+extern CVMInt32
+CVMclassVerificationSpecToEncoding(char* verifySpec);
+extern CVMBool
+CVMclassLink(CVMExecEnv* ee, CVMClassBlock* cb, CVMBool isRedefine);
+extern CVMBool
+CVMclassInit(CVMExecEnv* ee, CVMClassBlock* cb);
+extern int
+CVMclassInitNoCRecursion(CVMExecEnv* ee, CVMClassBlock* cb,
+    CVMMethodBlock **p_mb);
+extern CVMClassICell*
+CVMdefineClass(CVMExecEnv* ee, const char *name, CVMClassLoaderICell* loader,
+        const CVMUint8* buf, CVMUint32 bufLen, CVMObjectICell* pd,
+        CVMBool isRedefine);
+extern CVMClassBlock*
+CVMclassCreateMultiArrayClass(CVMExecEnv* ee, CVMClassTypeID arrayTypeId,
+         CVMClassLoaderICell* loader, CVMObjectICell* pd);
+typedef void (*CVMClassCallbackFunc)(CVMExecEnv* ee,
+         CVMClassBlock* cb,
+         void* data);
+typedef void (*CVMStackCallbackFunc)( CVMObject**, void*);
+extern void
+CVMclassIterateAllClasses(CVMExecEnv* ee,
+     CVMClassCallbackFunc callback,
+     void* data);
+extern void
+CVMclassIterateDynamicallyLoadedClasses(CVMExecEnv* ee,
+     CVMClassCallbackFunc callback,
+     void* data);
+extern void
+CVMclassTableFreeAllClasses(CVMExecEnv* ee);
+extern CVMClassBlock**
+CVMclassTableAllocateSlot(CVMExecEnv* ee);
+void
+CVMclassTableFreeSlot(CVMExecEnv* ee, CVMClassBlock** cbPtr);
+extern void
+CVMclassTableMarkUnscannedClasses(CVMExecEnv* ee,
+      CVMRefLivenessQueryFunc isLive,
+      void* isLiveData);
+extern void
+CVMclassTableIterate(CVMExecEnv* ee,
+       CVMClassCallbackFunc callback,
+       void* data);
+extern void
+CVMclassTableDump(CVMExecEnv* ee);
+extern CVMClassLoaderICell*
+CVMloaderCacheGetGlobalRootFromLoader(CVMExecEnv* ee,
+          CVMClassLoaderICell* loader);
+extern CVMBool
+CVMloaderCacheCheckPackageAccess(CVMExecEnv *ee, CVMClassLoaderICell* loader,
+     CVMClassBlock* cb, CVMObjectICell* pd);
+extern CVMClassBlock*
+CVMloaderCacheLookupWithProtectionDomain(CVMExecEnv* ee,
+      CVMClassTypeID classID,
+      CVMClassLoaderICell* loader,
+      CVMObjectICell* pd);
+extern CVMBool
+CVMloaderCacheAdd(CVMExecEnv* ee, CVMClassBlock* cb,
+    CVMClassLoaderICell* loader);
+extern void
+CVMloaderCacheMarkUnscannedClassesAndLoaders(CVMExecEnv* ee,
+           CVMRefLivenessQueryFunc isLive,
+           void* isLiveData);
+extern void
+CVMloaderCachePurgeUnscannedClassesAndLoaders(CVMExecEnv* ee);
+extern CVMBool
+CVMloaderCacheInit();
+extern void
+CVMloaderCacheDestroy(CVMExecEnv* ee);
+extern void
+CVMloaderCacheDump(CVMExecEnv* ee);
+typedef struct {
+    int index;
+    void *entry;
+} CVMLoaderCacheIterator;
+void
+CVMloaderCacheIterate(CVMExecEnv* ee, CVMLoaderCacheIterator *iter);
+CVMBool
+CVMloaderCacheIterateNext(CVMExecEnv* ee, CVMLoaderCacheIterator *iter);
+CVMObjectICell *
+CVMloaderCacheIterateGetLoader(CVMExecEnv* ee, CVMLoaderCacheIterator *iter);
+CVMClassBlock *
+CVMloaderCacheIterateGetCB(CVMExecEnv* ee, CVMLoaderCacheIterator *iter);
+CVMBool
+CVMloaderConstraintsCheckMethodSignatureLoaders(CVMExecEnv* ee,
+      CVMMethodTypeID methodID,
+      CVMClassLoaderICell* loader1,
+      CVMClassLoaderICell* loader2);
+CVMBool
+CVMloaderConstraintsCheckFieldSignatureLoaders(CVMExecEnv* ee,
+            CVMFieldTypeID fieldID,
+            CVMClassLoaderICell* loader1,
+            CVMClassLoaderICell* loader2);
+extern void
+CVMloaderConstraintsMarkUnscannedClassesAndLoaders(
+    CVMExecEnv* ee,
+    CVMRefLivenessQueryFunc isLive,
+    void* isLiveData);
+extern void
+CVMloaderConstraintsPurgeUnscannedClassesAndLoaders(CVMExecEnv* ee);
+extern void
+CVMloaderConstraintsDump(CVMExecEnv* ee);
+extern void
+CVMclassScan(CVMExecEnv* ee, CVMClassBlock* cb,
+      CVMRefCallbackFunc callback, void* data);
+extern CVMBool
+CVMclassModuleInit(CVMExecEnv* ee);
+extern void
+CVMclassModuleDestroy(CVMExecEnv* ee);
+extern CVMBool
+CVMclassBootClassPathInit(JNIEnv *env);
+extern CVMBool
+CVMclassClassPathInit(JNIEnv *env);
+extern void
+CVMclassBootClassPathDestroy(CVMExecEnv* ee);
+extern void
+CVMclassClassPathDestroy(CVMExecEnv* ee);
+extern jobject
+CVMclassFindContainer(JNIEnv *env, jobject tthis, jstring name);
+typedef struct {
+    CVMClassPathEntry* entries;
+    CVMUint16 numEntries;
+    char* pathString;
+    CVMBool initialized;
+} CVMClassPath;
+extern CVMBool
+CVMclassPathInit(JNIEnv* env, CVMClassPath* path, char* additionalPathString,
+       CVMBool doNotFailWhenPathNotFound, CVMBool initJavaSide);
+CVMClassLoaderICell*
+CVMclassGetSystemClassLoader(CVMExecEnv* ee);
+void
+CVMclassSetSystemClassLoader(CVMExecEnv* ee, jobject loader);
+CVMBool CVMclassIsValidClassBlock(CVMExecEnv *ee, CVMClassBlock *cb);
+typedef struct CVMGenSpace {
+    CVMUint32* allocPtr;
+    CVMUint32* allocBase;
+    CVMUint32* allocTop;
+} CVMGenSpace;
+typedef struct CVMGeneration {
+    CVMUint32* heapBase;
+    CVMUint32* heapTop;
+    CVMUint32* allocPtr;
+    CVMUint32* allocBase;
+    CVMUint32* allocTop;
+    CVMUint32* allocMark;
+    CVMUint32 generationNo;
+    struct CVMGeneration* nextGen;
+    struct CVMGeneration* prevGen;
+    CVMBool (*collect)(struct CVMGeneration* gen,
+     CVMExecEnv* ee,
+     CVMUint32 numBytes,
+     CVMGCOptions* gcOpts);
+    void (*scanOlderToYoungerPointers)(struct CVMGeneration* gen,
+          CVMExecEnv* ee,
+          CVMGCOptions* gcOpts,
+          CVMRefCallbackFunc callback,
+          void* callbackData);
+    CVMObject* (*promoteInto)(struct CVMGeneration* gen,
+         CVMObject* objectToPromote,
+         CVMUint32 objectSize);
+    void (*scanPromotedPointers)(struct CVMGeneration* gen,
+           CVMExecEnv* ee,
+           CVMGCOptions* gcOpts,
+           CVMRefCallbackFunc callback,
+           void* callbackData);
+    CVMGenSpace* (*getExtraSpace)(struct CVMGeneration* gen);
+    CVMUint32 (*totalMemory)(struct CVMGeneration* gen, CVMExecEnv* ee);
+    CVMUint32 (*freeMemory)(struct CVMGeneration* gen, CVMExecEnv* ee);
+} CVMGeneration;
+CVMBool
+CVMgenInGeneration(CVMGeneration *thisGen, CVMObject *ref);
+void
+CVMgenScanAllRoots(CVMGeneration* thisGen,
+     CVMExecEnv *ee, CVMGCOptions* gcOpts,
+     CVMRefCallbackFunc callback, void* data);
+void
+CVMgenBarrierObjectHeadersUpdate(CVMGeneration* gen, CVMExecEnv* ee,
+     CVMGCOptions* gcOpts,
+     CVMUint32* startRange,
+     CVMUint32* endRange);
+typedef union CVMGenSummaryTableEntry {
+    CVMUint8 offsets[4];
+    CVMUint32 intVersion;
+} CVMGenSummaryTableEntry;
+extern void
+CVMgenClearBarrierTable();
+extern void
+CVMgenBarrierPointersTraverse(CVMGeneration* gen, CVMExecEnv* ee,
+         CVMGCOptions* gcOpts,
+         CVMRefCallbackFunc callback,
+         void* callbackData);
+extern void CVMgenDumpSysInfo(CVMGCGlobalState* gc);
+struct CVMGCGlobalState {
+    CVMUint32 heapSize;
+    CVMGeneration* CVMgenGenerations[2];
+    CVMInt64 lastMajorGCTime;
+    CVMUint8* cardTable;
+    CVMUint8 volatile* cardTableVirtualBase;
+    CVMUint32 cardTableSize;
+    CVMUint8* cardTableEnd;
+    struct {
+ CVMUint32 youngGenSize;
+    } genGCAttributes;
+    CVMInt8* objectHeaderTable;
+    CVMGenSummaryTableEntry* summaryTable;
+    CVMUint32* heapBase;
+    CVMUint32* heapBaseMemoryArea;
+    CVMUint32 mappedTotalSize;
+    CVMUint32 memoryReserve;
+    CVMUint32 oldGenGrowThreshold;
+    CVMUint32 oldGenShrinkThreshold;
+    CVMUint32 oldGenLowWatermark;
+    CVMUint32 oldGenHighWatermark;
+    CVMUint32 heapMinSize;
+    CVMUint32 heapStartSize;
+    CVMUint32 heapMaxSize;
+    CVMUint32 heapCurrentSize;
+    CVMUint32 youngGenMinSize;
+    CVMUint32 youngGenStartSize;
+    CVMUint32 youngGenMaxSize;
+    CVMUint32 youngGenCurrentSize;
+    CVMUint32 oldGenMinSize;
+    CVMUint32 oldGenStartSize;
+    CVMUint32 oldGenMaxSize;
+    CVMUint32 oldGenCurrentSize;
+    CVMUint32 cardTableCurrentSize;
+    CVMUint32 objectHeaderTableCurrentSize;
+    CVMUint32 summaryTableCurrentSize;
+    CVMUint32* youngGenStart;
+    CVMUint32* oldGenStart;
+    CVMBool hasYoungGenInternedStrings;
+    CVMBool needToScanInternedStrings;
+    CVMBool hasYoungGenClassesOrLoaders;
+};
+extern void *memcpy (void *__restrict __dest,
+       __const void *__restrict __src, size_t __n)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern void *memmove (void *__dest, __const void *__src, size_t __n)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern void *memccpy (void *__restrict __dest, __const void *__restrict __src,
+        int __c, size_t __n)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int memcmp (__const void *__s1, __const void *__s2, size_t __n)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern void *memchr (__const void *__s, int __c, size_t __n)
+      __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+extern void *rawmemchr (__const void *__s, int __c)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+extern void *memrchr (__const void *__s, int __c, size_t __n)
+      __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+extern char *strcpy (char *__restrict __dest, __const char *__restrict __src)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern char *strncpy (char *__restrict __dest,
+        __const char *__restrict __src, size_t __n)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern char *strcat (char *__restrict __dest, __const char *__restrict __src)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern char *strncat (char *__restrict __dest, __const char *__restrict __src,
+        size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int strcmp (__const char *__s1, __const char *__s2)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int strncmp (__const char *__s1, __const char *__s2, size_t __n)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int strcoll (__const char *__s1, __const char *__s2)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern size_t strxfrm (char *__restrict __dest,
+         __const char *__restrict __src, size_t __n)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));
+extern int strcoll_l (__const char *__s1, __const char *__s2, __locale_t __l)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));
+extern size_t strxfrm_l (char *__dest, __const char *__src, size_t __n,
+    __locale_t __l) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 4)));
+extern char *strdup (__const char *__s)
+     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
+extern char *strndup (__const char *__string, size_t __n)
+     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
+extern char *strchr (__const char *__s, int __c)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+extern char *strrchr (__const char *__s, int __c)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+extern char *strchrnul (__const char *__s, int __c)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+extern size_t strcspn (__const char *__s, __const char *__reject)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern size_t strspn (__const char *__s, __const char *__accept)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern char *strpbrk (__const char *__s, __const char *__accept)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern char *strstr (__const char *__haystack, __const char *__needle)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern char *strtok (char *__restrict __s, __const char *__restrict __delim)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));
+extern char *__strtok_r (char *__restrict __s,
+    __const char *__restrict __delim,
+    char **__restrict __save_ptr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));
+extern char *strtok_r (char *__restrict __s, __const char *__restrict __delim,
+         char **__restrict __save_ptr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));
+extern char *strcasestr (__const char *__haystack, __const char *__needle)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern void *memmem (__const void *__haystack, size_t __haystacklen,
+       __const void *__needle, size_t __needlelen)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));
+extern void *__mempcpy (void *__restrict __dest,
+   __const void *__restrict __src, size_t __n)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern void *mempcpy (void *__restrict __dest,
+        __const void *__restrict __src, size_t __n)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern size_t strlen (__const char *__s)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+extern size_t strnlen (__const char *__string, size_t __maxlen)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+extern char *strerror (int __errnum) __attribute__ ((__nothrow__));
+extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));
+extern char *strerror_l (int __errnum, __locale_t __l) __attribute__ ((__nothrow__));
+extern void __bzero (void *__s, size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern void bcopy (__const void *__src, void *__dest, size_t __n)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int bcmp (__const void *__s1, __const void *__s2, size_t __n)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern char *index (__const char *__s, int __c)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+extern char *rindex (__const char *__s, int __c)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+extern int ffs (int __i) __attribute__ ((__nothrow__)) __attribute__ ((__const__));
+extern int ffsl (long int __l) __attribute__ ((__nothrow__)) __attribute__ ((__const__));
+__extension__ extern int ffsll (long long int __ll)
+     __attribute__ ((__nothrow__)) __attribute__ ((__const__));
+extern int strcasecmp (__const char *__s1, __const char *__s2)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int strncasecmp (__const char *__s1, __const char *__s2, size_t __n)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int strcasecmp_l (__const char *__s1, __const char *__s2,
+    __locale_t __loc)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));
+extern int strncasecmp_l (__const char *__s1, __const char *__s2,
+     size_t __n, __locale_t __loc)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));
+extern char *strsep (char **__restrict __stringp,
+       __const char *__restrict __delim)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern char *strsignal (int __sig) __attribute__ ((__nothrow__));
+extern char *__stpcpy (char *__restrict __dest, __const char *__restrict __src)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern char *stpcpy (char *__restrict __dest, __const char *__restrict __src)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern char *__stpncpy (char *__restrict __dest,
+   __const char *__restrict __src, size_t __n)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern char *stpncpy (char *__restrict __dest,
+        __const char *__restrict __src, size_t __n)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int strverscmp (__const char *__s1, __const char *__s2)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern char *strfry (char *__string) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern void *memfrob (void *__s, size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern char *basename (__const char *__filename) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+typedef struct { unsigned char __arr[2]; } __attribute__ ((__packed__)) __STRING2_COPY_ARR2;
+typedef struct { unsigned char __arr[3]; } __attribute__ ((__packed__)) __STRING2_COPY_ARR3;
+typedef struct { unsigned char __arr[4]; } __attribute__ ((__packed__)) __STRING2_COPY_ARR4;
+typedef struct { unsigned char __arr[5]; } __attribute__ ((__packed__)) __STRING2_COPY_ARR5;
+typedef struct { unsigned char __arr[6]; } __attribute__ ((__packed__)) __STRING2_COPY_ARR6;
+typedef struct { unsigned char __arr[7]; } __attribute__ ((__packed__)) __STRING2_COPY_ARR7;
+typedef struct { unsigned char __arr[8]; } __attribute__ ((__packed__)) __STRING2_COPY_ARR8;
+extern void *__rawmemchr (const void *__s, int __c);
+extern __inline size_t __strcspn_c1 (__const char *__s, int __reject);
+extern __inline size_t
+__strcspn_c1 (__const char *__s, int __reject)
+{
+  register size_t __result = 0;
+  while (__s[__result] != '\0' && __s[__result] != __reject)
+    ++__result;
+  return __result;
+}
+extern __inline size_t __strcspn_c2 (__const char *__s, int __reject1,
+         int __reject2);
+extern __inline size_t
+__strcspn_c2 (__const char *__s, int __reject1, int __reject2)
+{
+  register size_t __result = 0;
+  while (__s[__result] != '\0' && __s[__result] != __reject1
+  && __s[__result] != __reject2)
+    ++__result;
+  return __result;
+}
+extern __inline size_t __strcspn_c3 (__const char *__s, int __reject1,
+         int __reject2, int __reject3);
+extern __inline size_t
+__strcspn_c3 (__const char *__s, int __reject1, int __reject2,
+       int __reject3)
+{
+  register size_t __result = 0;
+  while (__s[__result] != '\0' && __s[__result] != __reject1
+  && __s[__result] != __reject2 && __s[__result] != __reject3)
+    ++__result;
+  return __result;
+}
+extern __inline size_t __strspn_c1 (__const char *__s, int __accept);
+extern __inline size_t
+__strspn_c1 (__const char *__s, int __accept)
+{
+  register size_t __result = 0;
+  while (__s[__result] == __accept)
+    ++__result;
+  return __result;
+}
+extern __inline size_t __strspn_c2 (__const char *__s, int __accept1,
+        int __accept2);
+extern __inline size_t
+__strspn_c2 (__const char *__s, int __accept1, int __accept2)
+{
+  register size_t __result = 0;
+  while (__s[__result] == __accept1 || __s[__result] == __accept2)
+    ++__result;
+  return __result;
+}
+extern __inline size_t __strspn_c3 (__const char *__s, int __accept1,
+        int __accept2, int __accept3);
+extern __inline size_t
+__strspn_c3 (__const char *__s, int __accept1, int __accept2, int __accept3)
+{
+  register size_t __result = 0;
+  while (__s[__result] == __accept1 || __s[__result] == __accept2
+  || __s[__result] == __accept3)
+    ++__result;
+  return __result;
+}
+extern __inline char *__strpbrk_c2 (__const char *__s, int __accept1,
+         int __accept2);
+extern __inline char *
+__strpbrk_c2 (__const char *__s, int __accept1, int __accept2)
+{
+  while (*__s != '\0' && *__s != __accept1 && *__s != __accept2)
+    ++__s;
+  return *__s == '\0' ? ((void *)0) : (char *) (size_t) __s;
+}
+extern __inline char *__strpbrk_c3 (__const char *__s, int __accept1,
+         int __accept2, int __accept3);
+extern __inline char *
+__strpbrk_c3 (__const char *__s, int __accept1, int __accept2,
+       int __accept3)
+{
+  while (*__s != '\0' && *__s != __accept1 && *__s != __accept2
+  && *__s != __accept3)
+    ++__s;
+  return *__s == '\0' ? ((void *)0) : (char *) (size_t) __s;
+}
+extern __inline char *__strtok_r_1c (char *__s, char __sep, char **__nextp);
+extern __inline char *
+__strtok_r_1c (char *__s, char __sep, char **__nextp)
+{
+  char *__result;
+  if (__s == ((void *)0))
+    __s = *__nextp;
+  while (*__s == __sep)
+    ++__s;
+  __result = ((void *)0);
+  if (*__s != '\0')
+    {
+      __result = __s++;
+      while (*__s != '\0')
+ if (*__s++ == __sep)
+   {
+     __s[-1] = '\0';
+     break;
+   }
+    }
+  *__nextp = __s;
+  return __result;
+}
+extern char *__strsep_g (char **__stringp, __const char *__delim);
+extern __inline char *__strsep_1c (char **__s, char __reject);
+extern __inline char *
+__strsep_1c (char **__s, char __reject)
+{
+  register char *__retval = *__s;
+  if (__retval != ((void *)0) && (*__s = (__extension__ (__builtin_constant_p (__reject) && !__builtin_constant_p (__retval) && (__reject) == '\0' ? (char *) __rawmemchr (__retval, __reject) : __builtin_strchr (__retval, __reject)))) != ((void *)0))
+    *(*__s)++ = '\0';
+  return __retval;
+}
+extern __inline char *__strsep_2c (char **__s, char __reject1, char __reject2);
+extern __inline char *
+__strsep_2c (char **__s, char __reject1, char __reject2)
+{
+  register char *__retval = *__s;
+  if (__retval != ((void *)0))
+    {
+      register char *__cp = __retval;
+      while (1)
+ {
+   if (*__cp == '\0')
+     {
+       __cp = ((void *)0);
+   break;
+     }
+   if (*__cp == __reject1 || *__cp == __reject2)
+     {
+       *__cp++ = '\0';
+       break;
+     }
+   ++__cp;
+ }
+      *__s = __cp;
+    }
+  return __retval;
+}
+extern __inline char *__strsep_3c (char **__s, char __reject1, char __reject2,
+       char __reject3);
+extern __inline char *
+__strsep_3c (char **__s, char __reject1, char __reject2, char __reject3)
+{
+  register char *__retval = *__s;
+  if (__retval != ((void *)0))
+    {
+      register char *__cp = __retval;
+      while (1)
+ {
+   if (*__cp == '\0')
+     {
+       __cp = ((void *)0);
+   break;
+     }
+   if (*__cp == __reject1 || *__cp == __reject2 || *__cp == __reject3)
+     {
+       *__cp++ = '\0';
+       break;
+     }
+   ++__cp;
+ }
+      *__s = __cp;
+    }
+  return __retval;
+}
+extern void *malloc (size_t __size) __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));
+extern void *calloc (size_t __nmemb, size_t __size)
+     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));
+extern char *__strdup (__const char *__string) __attribute__ ((__nothrow__)) __attribute__ ((__malloc__));
+extern char *__strndup (__const char *__string, size_t __n)
+     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__));
+extern void __warn_memset_zero_len (void) __attribute__((__warning__ ("memset used with constant zero length parameter; this could be due to transposed parameters")))
+                                                                                                   ;
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) void *
+__attribute__ ((__nothrow__)) memcpy (void *__restrict __dest, __const void *__restrict __src, size_t __len)
+{
+  return __builtin___memcpy_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) void *
+__attribute__ ((__nothrow__)) memmove (void *__restrict __dest, __const void *__restrict __src, size_t __len)
+{
+  return __builtin___memmove_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) void *
+__attribute__ ((__nothrow__)) mempcpy (void *__restrict __dest, __const void *__restrict __src, size_t __len)
+{
+  return __builtin___mempcpy_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) void *
+__attribute__ ((__nothrow__)) memset (void *__dest, int __ch, size_t __len)
+{
+  if (__builtin_constant_p (__len) && __len == 0)
+    {
+      __warn_memset_zero_len ();
+      return __dest;
+    }
+  return __builtin___memset_chk (__dest, __ch, __len, __builtin_object_size (__dest, 0));
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) void
+__attribute__ ((__nothrow__)) bcopy (__const void *__restrict __src, void *__restrict __dest, size_t __len)
+{
+  (void) __builtin___memmove_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) void
+__attribute__ ((__nothrow__)) bzero (void *__dest, size_t __len)
+{
+  (void) __builtin___memset_chk (__dest, '\0', __len, __builtin_object_size (__dest, 0));
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) char *
+__attribute__ ((__nothrow__)) strcpy (char *__restrict __dest, __const char *__restrict __src)
+{
+  return __builtin___strcpy_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1));
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) char *
+__attribute__ ((__nothrow__)) stpcpy (char *__restrict __dest, __const char *__restrict __src)
+{
+  return __builtin___stpcpy_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1));
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) char *
+__attribute__ ((__nothrow__)) strncpy (char *__restrict __dest, __const char *__restrict __src, size_t __len)
+{
+  return __builtin___strncpy_chk (__dest, __src, __len, __builtin_object_size (__dest, 2 > 1));
+}
+extern char *__stpncpy_chk (char *__dest, __const char *__src, size_t __n,
+       size_t __destlen) __attribute__ ((__nothrow__));
+extern char *__stpncpy_alias (char *__dest, __const char *__src, size_t __n) __asm__ ("" "stpncpy") __attribute__ ((__nothrow__))
+                                 ;
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) char *
+__attribute__ ((__nothrow__)) stpncpy (char *__dest, __const char *__src, size_t __n)
+{
+  if (__builtin_object_size (__dest, 2 > 1) != (size_t) -1
+      && (!__builtin_constant_p (__n) || __n <= __builtin_object_size (__dest, 2 > 1)))
+    return __stpncpy_chk (__dest, __src, __n, __builtin_object_size (__dest, 2 > 1));
+  return __stpncpy_alias (__dest, __src, __n);
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) char *
+__attribute__ ((__nothrow__)) strcat (char *__restrict __dest, __const char *__restrict __src)
+{
+  return __builtin___strcat_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1));
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) char *
+__attribute__ ((__nothrow__)) strncat (char *__restrict __dest, __const char *__restrict __src, size_t __len)
+{
+  return __builtin___strncat_chk (__dest, __src, __len, __builtin_object_size (__dest, 2 > 1));
+}
+union wait
+  {
+    int w_status;
+    struct
+      {
+ unsigned int __w_termsig:7;
+ unsigned int __w_coredump:1;
+ unsigned int __w_retcode:8;
+ unsigned int:16;
+      } __wait_terminated;
+    struct
+      {
+ unsigned int __w_stopval:8;
+ unsigned int __w_stopsig:8;
+ unsigned int:16;
+      } __wait_stopped;
+  };
+typedef union
+  {
+    union wait *__uptr;
+    int *__iptr;
+  } __WAIT_STATUS __attribute__ ((__transparent_union__));
+typedef struct
+  {
+    int quot;
+    int rem;
+  } div_t;
+typedef struct
+  {
+    long int quot;
+    long int rem;
+  } ldiv_t;
+__extension__ typedef struct
+  {
+    long long int quot;
+    long long int rem;
+  } lldiv_t;
+extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern double atof (__const char *__nptr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern int atoi (__const char *__nptr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern long int atol (__const char *__nptr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+__extension__ extern long long int atoll (__const char *__nptr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern double strtod (__const char *__restrict __nptr,
+        char **__restrict __endptr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern float strtof (__const char *__restrict __nptr,
+       char **__restrict __endptr) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern long double strtold (__const char *__restrict __nptr,
+       char **__restrict __endptr)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern long int strtol (__const char *__restrict __nptr,
+   char **__restrict __endptr, int __base)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern unsigned long int strtoul (__const char *__restrict __nptr,
+      char **__restrict __endptr, int __base)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+__extension__
+extern long long int strtoq (__const char *__restrict __nptr,
+        char **__restrict __endptr, int __base)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+__extension__
+extern unsigned long long int strtouq (__const char *__restrict __nptr,
+           char **__restrict __endptr, int __base)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+__extension__
+extern long long int strtoll (__const char *__restrict __nptr,
+         char **__restrict __endptr, int __base)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+__extension__
+extern unsigned long long int strtoull (__const char *__restrict __nptr,
+     char **__restrict __endptr, int __base)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern long int strtol_l (__const char *__restrict __nptr,
+     char **__restrict __endptr, int __base,
+     __locale_t __loc) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 4))) __attribute__ ((__warn_unused_result__));
+extern unsigned long int strtoul_l (__const char *__restrict __nptr,
+        char **__restrict __endptr,
+        int __base, __locale_t __loc)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 4))) __attribute__ ((__warn_unused_result__));
+__extension__
+extern long long int strtoll_l (__const char *__restrict __nptr,
+    char **__restrict __endptr, int __base,
+    __locale_t __loc)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 4))) __attribute__ ((__warn_unused_result__));
+__extension__
+extern unsigned long long int strtoull_l (__const char *__restrict __nptr,
+       char **__restrict __endptr,
+       int __base, __locale_t __loc)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 4))) __attribute__ ((__warn_unused_result__));
+extern double strtod_l (__const char *__restrict __nptr,
+   char **__restrict __endptr, __locale_t __loc)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3))) __attribute__ ((__warn_unused_result__));
+extern float strtof_l (__const char *__restrict __nptr,
+         char **__restrict __endptr, __locale_t __loc)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3))) __attribute__ ((__warn_unused_result__));
+extern long double strtold_l (__const char *__restrict __nptr,
+         char **__restrict __endptr,
+         __locale_t __loc)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3))) __attribute__ ((__warn_unused_result__));
+extern __inline double
+__attribute__ ((__nothrow__)) atof (__const char *__nptr)
+{
+  return strtod (__nptr, (char **) ((void *)0));
+}
+extern __inline int
+__attribute__ ((__nothrow__)) atoi (__const char *__nptr)
+{
+  return (int) strtol (__nptr, (char **) ((void *)0), 10);
+}
+extern __inline long int
+__attribute__ ((__nothrow__)) atol (__const char *__nptr)
+{
+  return strtol (__nptr, (char **) ((void *)0), 10);
+}
+__extension__ extern __inline long long int
+__attribute__ ((__nothrow__)) atoll (__const char *__nptr)
+{
+  return strtoll (__nptr, (char **) ((void *)0), 10);
+}
+extern char *l64a (long int __n) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern long int a64l (__const char *__s)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern long int random (void) __attribute__ ((__nothrow__));
+extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__));
+extern char *initstate (unsigned int __seed, char *__statebuf,
+   size_t __statelen) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));
+extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+struct random_data
+  {
+    int32_t *fptr;
+    int32_t *rptr;
+    int32_t *state;
+    int rand_type;
+    int rand_deg;
+    int rand_sep;
+    int32_t *end_ptr;
+  };
+extern int random_r (struct random_data *__restrict __buf,
+       int32_t *__restrict __result) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int srandom_r (unsigned int __seed, struct random_data *__buf)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));
+extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
+   size_t __statelen,
+   struct random_data *__restrict __buf)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 4)));
+extern int setstate_r (char *__restrict __statebuf,
+         struct random_data *__restrict __buf)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int rand (void) __attribute__ ((__nothrow__));
+extern void srand (unsigned int __seed) __attribute__ ((__nothrow__));
+extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__));
+extern double drand48 (void) __attribute__ ((__nothrow__));
+extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern long int lrand48 (void) __attribute__ ((__nothrow__));
+extern long int nrand48 (unsigned short int __xsubi[3])
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern long int mrand48 (void) __attribute__ ((__nothrow__));
+extern long int jrand48 (unsigned short int __xsubi[3])
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern void srand48 (long int __seedval) __attribute__ ((__nothrow__));
+extern unsigned short int *seed48 (unsigned short int __seed16v[3])
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+struct drand48_data
+  {
+    unsigned short int __x[3];
+    unsigned short int __old_x[3];
+    unsigned short int __c;
+    unsigned short int __init;
+    unsigned long long int __a;
+  };
+extern int drand48_r (struct drand48_data *__restrict __buffer,
+        double *__restrict __result) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int erand48_r (unsigned short int __xsubi[3],
+        struct drand48_data *__restrict __buffer,
+        double *__restrict __result) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int lrand48_r (struct drand48_data *__restrict __buffer,
+        long int *__restrict __result)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int nrand48_r (unsigned short int __xsubi[3],
+        struct drand48_data *__restrict __buffer,
+        long int *__restrict __result)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int mrand48_r (struct drand48_data *__restrict __buffer,
+        long int *__restrict __result)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int jrand48_r (unsigned short int __xsubi[3],
+        struct drand48_data *__restrict __buffer,
+        long int *__restrict __result)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));
+extern int seed48_r (unsigned short int __seed16v[3],
+       struct drand48_data *__buffer) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int lcong48_r (unsigned short int __param[7],
+        struct drand48_data *__buffer)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+extern void *realloc (void *__ptr, size_t __size)
+     __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern void free (void *__ptr) __attribute__ ((__nothrow__));
+extern void cfree (void *__ptr) __attribute__ ((__nothrow__));
+extern void *alloca (size_t __size) __attribute__ ((__nothrow__));
+extern void *valloc (size_t __size) __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));
+extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern void abort (void) __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));
+extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int at_quick_exit (void (*__func) (void)) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern void exit (int __status) __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));
+extern void quick_exit (int __status) __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));
+extern void _Exit (int __status) __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));
+extern char *getenv (__const char *__name) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern char *__secure_getenv (__const char *__name)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern int putenv (char *__string) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int setenv (__const char *__name, __const char *__value, int __replace)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));
+extern int unsetenv (__const char *__name) __attribute__ ((__nothrow__));
+extern int clearenv (void) __attribute__ ((__nothrow__));
+extern char *mktemp (char *__template) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern int system (__const char *__command) __attribute__ ((__warn_unused_result__));
+extern char *canonicalize_file_name (__const char *__name)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern char *realpath (__const char *__restrict __name,
+         char *__restrict __resolved) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+typedef int (*__compar_fn_t) (__const void *, __const void *);
+typedef __compar_fn_t comparison_fn_t;
+typedef int (*__compar_d_fn_t) (__const void *, __const void *, void *);
+extern void *bsearch (__const void *__key, __const void *__base,
+        size_t __nmemb, size_t __size, __compar_fn_t __compar)
+     __attribute__ ((__nonnull__ (1, 2, 5))) __attribute__ ((__warn_unused_result__));
+extern void qsort (void *__base, size_t __nmemb, size_t __size,
+     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));
+extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
+       __compar_d_fn_t __compar, void *__arg)
+  __attribute__ ((__nonnull__ (1, 4)));
+extern int abs (int __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
+extern long int labs (long int __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
+__extension__ extern long long int llabs (long long int __x)
+     __attribute__ ((__nothrow__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
+extern div_t div (int __numer, int __denom)
+     __attribute__ ((__nothrow__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
+extern ldiv_t ldiv (long int __numer, long int __denom)
+     __attribute__ ((__nothrow__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
+__extension__ extern lldiv_t lldiv (long long int __numer,
+        long long int __denom)
+     __attribute__ ((__nothrow__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
+extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
+     int *__restrict __sign) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));
+extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
+     int *__restrict __sign) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));
+extern char *gcvt (double __value, int __ndigit, char *__buf)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3))) __attribute__ ((__warn_unused_result__));
+extern char *qecvt (long double __value, int __ndigit,
+      int *__restrict __decpt, int *__restrict __sign)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));
+extern char *qfcvt (long double __value, int __ndigit,
+      int *__restrict __decpt, int *__restrict __sign)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));
+extern char *qgcvt (long double __value, int __ndigit, char *__buf)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3))) __attribute__ ((__warn_unused_result__));
+extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
+     int *__restrict __sign, char *__restrict __buf,
+     size_t __len) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4, 5)));
+extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
+     int *__restrict __sign, char *__restrict __buf,
+     size_t __len) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4, 5)));
+extern int qecvt_r (long double __value, int __ndigit,
+      int *__restrict __decpt, int *__restrict __sign,
+      char *__restrict __buf, size_t __len)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4, 5)));
+extern int qfcvt_r (long double __value, int __ndigit,
+      int *__restrict __decpt, int *__restrict __sign,
+      char *__restrict __buf, size_t __len)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4, 5)));
+extern int mblen (__const char *__s, size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern int mbtowc (wchar_t *__restrict __pwc,
+     __const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern size_t mbstowcs (wchar_t *__restrict __pwcs,
+   __const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__));
+extern size_t wcstombs (char *__restrict __s,
+   __const wchar_t *__restrict __pwcs, size_t __n)
+     __attribute__ ((__nothrow__));
+extern int rpmatch (__const char *__response) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
+extern int getsubopt (char **__restrict __optionp,
+        char *__const *__restrict __tokens,
+        char **__restrict __valuep)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2, 3))) __attribute__ ((__warn_unused_result__));
+extern void setkey (__const char *__key) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern int posix_openpt (int __oflag) __attribute__ ((__warn_unused_result__));
+extern int grantpt (int __fd) __attribute__ ((__nothrow__));
+extern int unlockpt (int __fd) __attribute__ ((__nothrow__));
+extern char *ptsname (int __fd) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));
+extern int getpt (void);
+extern int getloadavg (double __loadavg[], int __nelem)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
+extern char *__realpath_chk (__const char *__restrict __name,
+        char *__restrict __resolved,
+        size_t __resolvedlen) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern char *__realpath_alias (__const char *__restrict __name, char *__restrict __resolved) __asm__ ("" "realpath") __attribute__ ((__nothrow__))
+                                                 __attribute__ ((__warn_unused_result__));
+extern char *__realpath_chk_warn (__const char *__restrict __name, char *__restrict __resolved, size_t __resolvedlen) __asm__ ("" "__realpath_chk") __attribute__ ((__nothrow__))
+                                                __attribute__ ((__warn_unused_result__))
+     __attribute__((__warning__ ("second argument of realpath must be either NULL or at " "least PATH_MAX bytes long buffer")))
+                                      ;
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) char *
+__attribute__ ((__nothrow__)) realpath (__const char *__restrict __name, char *__restrict __resolved)
+{
+  if (__builtin_object_size (__resolved, 2 > 1) != (size_t) -1)
+    {
+      return __realpath_chk (__name, __resolved, __builtin_object_size (__resolved, 2 > 1));
+    }
+  return __realpath_alias (__name, __resolved);
+}
+extern int __ptsname_r_chk (int __fd, char *__buf, size_t __buflen,
+       size_t __nreal) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));
+extern int __ptsname_r_alias (int __fd, char *__buf, size_t __buflen) __asm__ ("" "ptsname_r") __attribute__ ((__nothrow__))
+     __attribute__ ((__nonnull__ (2)));
+extern int __ptsname_r_chk_warn (int __fd, char *__buf, size_t __buflen, size_t __nreal) __asm__ ("" "__ptsname_r_chk") __attribute__ ((__nothrow__))
+     __attribute__ ((__nonnull__ (2))) __attribute__((__warning__ ("ptsname_r called with buflen bigger than " "size of buf")))
+                   ;
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
+__attribute__ ((__nothrow__)) ptsname_r (int __fd, char *__buf, size_t __buflen)
+{
+  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__buflen))
+ return __ptsname_r_chk (__fd, __buf, __buflen, __builtin_object_size (__buf, 2 > 1));
+      if (__buflen > __builtin_object_size (__buf, 2 > 1))
+ return __ptsname_r_chk_warn (__fd, __buf, __buflen, __builtin_object_size (__buf, 2 > 1));
+    }
+  return __ptsname_r_alias (__fd, __buf, __buflen);
+}
+extern int __wctomb_chk (char *__s, wchar_t __wchar, size_t __buflen)
+  __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));
+extern int __wctomb_alias (char *__s, wchar_t __wchar) __asm__ ("" "wctomb") __attribute__ ((__nothrow__))
+              __attribute__ ((__warn_unused_result__));
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) int
+__attribute__ ((__nothrow__)) wctomb (char *__s, wchar_t __wchar)
+{
+  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1 && 16 > __builtin_object_size (__s, 2 > 1))
+    return __wctomb_chk (__s, __wchar, __builtin_object_size (__s, 2 > 1));
+  return __wctomb_alias (__s, __wchar);
+}
+extern size_t __mbstowcs_chk (wchar_t *__restrict __dst,
+         __const char *__restrict __src,
+         size_t __len, size_t __dstlen) __attribute__ ((__nothrow__));
+extern size_t __mbstowcs_alias (wchar_t *__restrict __dst, __const char *__restrict __src, size_t __len) __asm__ ("" "mbstowcs") __attribute__ ((__nothrow__))
+                                  ;
+extern size_t __mbstowcs_chk_warn (wchar_t *__restrict __dst, __const char *__restrict __src, size_t __len, size_t __dstlen) __asm__ ("" "__mbstowcs_chk") __attribute__ ((__nothrow__))
+     __attribute__((__warning__ ("mbstowcs called with dst buffer smaller than len " "* sizeof (wchar_t)")))
+                        ;
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) size_t
+__attribute__ ((__nothrow__)) mbstowcs (wchar_t *__restrict __dst, __const char *__restrict __src, size_t __len)
+{
+  if (__builtin_object_size (__dst, 2 > 1) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__len))
+ return __mbstowcs_chk (__dst, __src, __len,
+          __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t));
+      if (__len > __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t))
+ return __mbstowcs_chk_warn (__dst, __src, __len,
+         __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t));
+    }
+  return __mbstowcs_alias (__dst, __src, __len);
+}
+extern size_t __wcstombs_chk (char *__restrict __dst,
+         __const wchar_t *__restrict __src,
+         size_t __len, size_t __dstlen) __attribute__ ((__nothrow__));
+extern size_t __wcstombs_alias (char *__restrict __dst, __const wchar_t *__restrict __src, size_t __len) __asm__ ("" "wcstombs") __attribute__ ((__nothrow__))
+                                  ;
+extern size_t __wcstombs_chk_warn (char *__restrict __dst, __const wchar_t *__restrict __src, size_t __len, size_t __dstlen) __asm__ ("" "__wcstombs_chk") __attribute__ ((__nothrow__))
+     __attribute__((__warning__ ("wcstombs called with dst buffer smaller than len")));
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) size_t
+__attribute__ ((__nothrow__)) wcstombs (char *__restrict __dst, __const wchar_t *__restrict __src, size_t __len)
+{
+  if (__builtin_object_size (__dst, 2 > 1) != (size_t) -1)
+    {
+      if (!__builtin_constant_p (__len))
+ return __wcstombs_chk (__dst, __src, __len, __builtin_object_size (__dst, 2 > 1));
+      if (__len > __builtin_object_size (__dst, 2 > 1))
+ return __wcstombs_chk_warn (__dst, __src, __len, __builtin_object_size (__dst, 2 > 1));
+    }
+  return __wcstombs_alias (__dst, __src, __len);
+}
+enum
+{
+  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
+  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
+  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
+  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
+  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
+  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
+  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
+  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
+  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
+  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
+  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
+  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
+};
+extern __const unsigned short int **__ctype_b_loc (void)
+     __attribute__ ((__nothrow__)) __attribute__ ((__const));
+extern __const __int32_t **__ctype_tolower_loc (void)
+     __attribute__ ((__nothrow__)) __attribute__ ((__const));
+extern __const __int32_t **__ctype_toupper_loc (void)
+     __attribute__ ((__nothrow__)) __attribute__ ((__const));
+extern int isalnum (int) __attribute__ ((__nothrow__));
+extern int isalpha (int) __attribute__ ((__nothrow__));
+extern int iscntrl (int) __attribute__ ((__nothrow__));
+extern int isdigit (int) __attribute__ ((__nothrow__));
+extern int islower (int) __attribute__ ((__nothrow__));
+extern int isgraph (int) __attribute__ ((__nothrow__));
+extern int isprint (int) __attribute__ ((__nothrow__));
+extern int ispunct (int) __attribute__ ((__nothrow__));
+extern int isspace (int) __attribute__ ((__nothrow__));
+extern int isupper (int) __attribute__ ((__nothrow__));
+extern int isxdigit (int) __attribute__ ((__nothrow__));
+extern int tolower (int __c) __attribute__ ((__nothrow__));
+extern int toupper (int __c) __attribute__ ((__nothrow__));
+extern int isblank (int) __attribute__ ((__nothrow__));
+extern int isctype (int __c, int __mask) __attribute__ ((__nothrow__));
+extern int isascii (int __c) __attribute__ ((__nothrow__));
+extern int toascii (int __c) __attribute__ ((__nothrow__));
+extern int _toupper (int) __attribute__ ((__nothrow__));
+extern int _tolower (int) __attribute__ ((__nothrow__));
+extern __inline int
+__attribute__ ((__nothrow__)) tolower (int __c)
+{
+  return __c >= -128 && __c < 256 ? (*__ctype_tolower_loc ())[__c] : __c;
+}
+extern __inline int
+__attribute__ ((__nothrow__)) toupper (int __c)
+{
+  return __c >= -128 && __c < 256 ? (*__ctype_toupper_loc ())[__c] : __c;
+}
+extern int isalnum_l (int, __locale_t) __attribute__ ((__nothrow__));
+extern int isalpha_l (int, __locale_t) __attribute__ ((__nothrow__));
+extern int iscntrl_l (int, __locale_t) __attribute__ ((__nothrow__));
+extern int isdigit_l (int, __locale_t) __attribute__ ((__nothrow__));
+extern int islower_l (int, __locale_t) __attribute__ ((__nothrow__));
+extern int isgraph_l (int, __locale_t) __attribute__ ((__nothrow__));
+extern int isprint_l (int, __locale_t) __attribute__ ((__nothrow__));
+extern int ispunct_l (int, __locale_t) __attribute__ ((__nothrow__));
+extern int isspace_l (int, __locale_t) __attribute__ ((__nothrow__));
+extern int isupper_l (int, __locale_t) __attribute__ ((__nothrow__));
+extern int isxdigit_l (int, __locale_t) __attribute__ ((__nothrow__));
+extern int isblank_l (int, __locale_t) __attribute__ ((__nothrow__));
+extern int __tolower_l (int __c, __locale_t __l) __attribute__ ((__nothrow__));
+extern int tolower_l (int __c, __locale_t __l) __attribute__ ((__nothrow__));
+extern int __toupper_l (int __c, __locale_t __l) __attribute__ ((__nothrow__));
+extern int toupper_l (int __c, __locale_t __l) __attribute__ ((__nothrow__));
+extern int *__errno_location (void) __attribute__ ((__nothrow__)) __attribute__ ((__const__));
+extern char *program_invocation_name, *program_invocation_short_name;
+typedef int error_t;
+extern void __assert_fail (__const char *__assertion, __const char *__file,
+      unsigned int __line, __const char *__function)
+     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));
+extern void __assert_perror_fail (int __errnum, __const char *__file,
+      unsigned int __line,
+      __const char *__function)
+     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));
+extern void __assert (const char *__assertion, const char *__file, int __line)
+     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));
+void CVMhalt(CVMInt32 status);
+void CVMsystemPanic( const char * msg );
+int CVMassertHook(const char *filename, int lineno, const char *expr);
+extern void
+CVMgcimplInitGlobalState(CVMGCGlobalState* globalState);
+extern CVMBool
+CVMgcimplInitHeap(CVMGCGlobalState* globalState,
+    CVMUint32 startBytes,
+    CVMUint32 minBytes,
+    CVMUint32 maxBytes,
+    CVMBool startIsUnspecified,
+    CVMBool minIsUnspecified,
+    CVMBool maxIsUnspecified);
+extern CVMObject*
+CVMgcimplAllocObject(CVMExecEnv* ee, CVMUint32 numBytes);
+extern CVMObject*
+CVMgcimplRetryAllocationAfterGC(CVMExecEnv* ee, CVMUint32 numBytes);
+void
+CVMgcimplDoGC(CVMExecEnv* ee, CVMUint32 numBytes);
+CVMUint32
+CVMgcimplFreeMemory(CVMExecEnv* ee);
+CVMUint32
+CVMgcimplTotalMemory(CVMExecEnv* ee);
+extern void
+CVMgcimplDestroyGlobalState(CVMGCGlobalState* globalState);
+extern CVMBool
+CVMgcimplDestroyHeap(CVMGCGlobalState* globalState);
+extern CVMInt64
+CVMgcimplTimeOfLastMajorGC();
+extern CVMBool
+CVMgcimplIterateHeap(CVMExecEnv* ee, CVMObjectCallbackFunc cback, void* data);
+void CVMgcimplDumpSysInfo();
+extern const CVMClassBlock*
+CVMpreloaderLookup(const char* className);
+const char *
+CVMpreloaderGetClassLoaderNames(CVMExecEnv *ee);
+void
+CVMpreloaderRegisterClassLoaderUnsafe(CVMExecEnv *ee, CVMInt32 index,
+    CVMClassLoaderICell *loader);
+extern CVMClassBlock*
+CVMpreloaderLookupFromType(CVMExecEnv *ee,
+    CVMClassTypeID typeID, CVMObjectICell *loader);
+extern CVMClassBlock*
+CVMpreloaderLookupPrimitiveClassFromType(CVMClassTypeID classType);
+extern void
+CVMpreloaderInit();
+extern CVMBool
+CVMpreloaderReallyInROM(CVMObject* ref);
+extern void
+CVMpreloaderInitializeStringInterning(CVMExecEnv* ee);
+extern void
+CVMpreloaderDestroy();
+extern void
+CVMpreloaderCheckROMClassInitState(CVMExecEnv* ee);
+extern CVMBool
+CVMpreloaderDisambiguateAllMethods(CVMExecEnv* ee);
+extern void
+CVMpreloaderIterateAllClasses(CVMExecEnv* ee,
+         CVMClassCallbackFunc callback,
+         void* data);
+CVMBool CVMpreloaderIsPreloadedObject(CVMObject *obj);
+CVMBool
+CVMpreloaderIteratePreloadedObjects(CVMExecEnv *ee,
+                                    CVMObjectCallbackFunc callback,
+                                    void *callbackData);
+extern const CVMClassBlock sun_misc_CVM_Classblock;
+extern const CVMClassBlock sun_misc_Launcher_Classblock;
+extern const CVMClassBlock sun_misc_Launcher_AppClassLoader_Classblock;
+extern const CVMClassBlock sun_misc_Launcher_ClassContainer_Classblock;
+extern const CVMClassBlock sun_misc_ThreadRegistry_Classblock;
+extern const CVMClassBlock java_lang_Object_Classblock;
+extern const CVMClassBlock java_lang_AssertionStatusDirectives_Classblock;
+extern const CVMClassBlock java_lang_Class_Classblock;
+extern const CVMClassBlock java_lang_ClassLoader_Classblock;
+extern const CVMClassBlock java_lang_ClassLoader_NativeLibrary_Classblock;
+extern const CVMClassBlock java_lang_Math_Classblock;
+extern const CVMClassBlock java_lang_Shutdown_Classblock;
+extern const CVMClassBlock java_lang_String_Classblock;
+extern const CVMClassBlock java_lang_Thread_Classblock;
+extern const CVMClassBlock java_lang_ThreadGroup_Classblock;
+extern const CVMClassBlock java_lang_Throwable_Classblock;
+extern const CVMClassBlock java_lang_StackTraceElement_Classblock;
+extern const CVMClassBlock java_lang_Exception_Classblock;
+extern const CVMClassBlock java_lang_Error_Classblock;
+extern const CVMClassBlock java_lang_ThreadDeath_Classblock;
+extern const CVMClassBlock java_lang_Cloneable_Classblock;
+extern const CVMClassBlock java_lang_System_Classblock;
+extern const CVMClassBlock java_io_File_Classblock;
+extern const CVMClassBlock java_io_Serializable_Classblock;
+extern const CVMClassBlock java_net_URLConnection_Classblock;
+extern const CVMClassBlock java_lang_reflect_Field_Classblock;
+extern const CVMClassBlock java_lang_reflect_Method_Classblock;
+extern const CVMClassBlock java_lang_reflect_Constructor_Classblock;
+extern const CVMClassBlock java_lang_ref_SoftReference_Classblock;
+extern const CVMClassBlock java_lang_ref_WeakReference_Classblock;
+extern const CVMClassBlock java_lang_ref_PhantomReference_Classblock;
+extern const CVMClassBlock java_lang_ref_FinalReference_Classblock;
+extern const CVMClassBlock java_lang_ref_Finalizer_Classblock;
+extern const CVMClassBlock java_lang_ref_Reference_Classblock;
+extern const CVMClassBlock java_util_jar_JarFile_Classblock;
+extern const CVMClassBlock java_util_ResourceBundle_Classblock;
+extern const CVMClassBlock java_security_AccessController_Classblock;
+extern const CVMClassBlock java_security_CodeSource_Classblock;
+extern const CVMClassBlock java_security_SecureClassLoader_Classblock;
+extern const CVMClassBlock java_lang_ClassCircularityError_Classblock;
+extern const CVMClassBlock java_lang_ClassFormatError_Classblock;
+extern const CVMClassBlock java_lang_IllegalAccessError_Classblock;
+extern const CVMClassBlock java_lang_InstantiationError_Classblock;
+extern const CVMClassBlock java_lang_LinkageError_Classblock;
+extern const CVMClassBlock java_lang_UnsupportedClassVersionError_Classblock;
+extern const CVMClassBlock java_lang_VerifyError_Classblock;
+extern const CVMClassBlock java_lang_UnsatisfiedLinkError_Classblock;
+extern const CVMClassBlock java_lang_NegativeArraySizeException_Classblock;
+extern const CVMClassBlock java_lang_NoSuchFieldException_Classblock;
+extern const CVMClassBlock java_lang_NoSuchMethodException_Classblock;
+extern const CVMClassBlock java_lang_IncompatibleClassChangeError_Classblock;
+extern const CVMClassBlock java_lang_AbstractMethodError_Classblock;
+extern const CVMClassBlock java_lang_ArithmeticException_Classblock;
+extern const CVMClassBlock java_lang_ArrayIndexOutOfBoundsException_Classblock;
+extern const CVMClassBlock java_lang_ArrayStoreException_Classblock;
+extern const CVMClassBlock java_lang_ClassCastException_Classblock;
+extern const CVMClassBlock java_lang_ClassNotFoundException_Classblock;
+extern const CVMClassBlock java_lang_CloneNotSupportedException_Classblock;
+extern const CVMClassBlock java_lang_IllegalAccessException_Classblock;
+extern const CVMClassBlock java_lang_IllegalArgumentException_Classblock;
+extern const CVMClassBlock java_lang_IllegalMonitorStateException_Classblock;
+extern const CVMClassBlock java_lang_IllegalStateException_Classblock;
+extern const CVMClassBlock java_lang_InstantiationException_Classblock;
+extern const CVMClassBlock java_lang_InternalError_Classblock;
+extern const CVMClassBlock java_lang_InterruptedException_Classblock;
+extern const CVMClassBlock java_lang_NoClassDefFoundError_Classblock;
+extern const CVMClassBlock java_lang_NoSuchFieldError_Classblock;
+extern const CVMClassBlock java_lang_NoSuchMethodError_Classblock;
+extern const CVMClassBlock java_lang_NullPointerException_Classblock;
+extern const CVMClassBlock java_lang_OutOfMemoryError_Classblock;
+extern const CVMClassBlock java_lang_StackOverflowError_Classblock;
+extern const CVMClassBlock java_lang_StringIndexOutOfBoundsException_Classblock;
+extern const CVMClassBlock java_lang_UnsupportedOperationException_Classblock;
+extern const CVMClassBlock java_io_InvalidClassException_Classblock;
+extern const CVMClassBlock java_io_IOException_Classblock;
+extern const CVMClassBlock java_lang_reflect_Method_ArgumentException_Classblock;
+extern const CVMClassBlock java_lang_reflect_Method_AccessException_Classblock;
+extern const CVMClassBlock java_lang_reflect_Constructor_ArgumentException_Classblock;
+extern const CVMClassBlock java_lang_reflect_Constructor_AccessException_Classblock;
+extern const CVMClassBlock sun_io_ConversionBufferFullException_Classblock;
+extern const CVMClassBlock sun_io_UnknownCharacterException_Classblock;
+extern const CVMClassBlock sun_io_MalformedInputException_Classblock;
+extern const CVMClassBlock manufacturedArrayOfBoolean_Classblock;
+extern const CVMClassBlock manufacturedArrayOfChar_Classblock;
+extern const CVMClassBlock manufacturedArrayOfFloat_Classblock;
+extern const CVMClassBlock manufacturedArrayOfDouble_Classblock;
+extern const CVMClassBlock manufacturedArrayOfByte_Classblock;
+extern const CVMClassBlock manufacturedArrayOfShort_Classblock;
+extern const CVMClassBlock manufacturedArrayOfInt_Classblock;
+extern const CVMClassBlock manufacturedArrayOfLong_Classblock;
+extern const CVMClassBlock manufacturedArrayOfObject_Classblock;
+extern const CVMClassBlock primitiveClass_boolean_Classblock;
+extern const CVMClassBlock primitiveClass_char_Classblock;
+extern const CVMClassBlock primitiveClass_float_Classblock;
+extern const CVMClassBlock primitiveClass_double_Classblock;
+extern const CVMClassBlock primitiveClass_byte_Classblock;
+extern const CVMClassBlock primitiveClass_short_Classblock;
+extern const CVMClassBlock primitiveClass_int_Classblock;
+extern const CVMClassBlock primitiveClass_long_Classblock;
+extern const CVMClassBlock primitiveClass_void_Classblock;
+extern const CVMClassBlock java_lang_Boolean_Classblock;
+extern const CVMClassBlock java_lang_Character_Classblock;
+extern const CVMClassBlock java_lang_Float_Classblock;
+extern const CVMClassBlock java_lang_Double_Classblock;
+extern const CVMClassBlock java_lang_Byte_Classblock;
+extern const CVMClassBlock java_lang_Short_Classblock;
+extern const CVMClassBlock java_lang_Integer_Classblock;
+extern const CVMClassBlock java_lang_Long_Classblock;
+extern CVMAddr * const CVM_staticData;
+extern CVMUint32 CVM_nStaticData;
+extern CVMAddr CVM_StaticDataMaster[];
+extern const int CVM_nROMClasses;
+extern void
+CVMweakrefInit();
+extern void
+CVMweakrefDiscover(CVMExecEnv* ee, CVMObject* weakRef);
+extern void
+CVMweakrefProcessNonStrong(CVMExecEnv* ee,
+      CVMRefLivenessQueryFunc isLive,
+      void* isLiveData,
+      CVMRefCallbackFunc transitiveScanner,
+      void* transitiveScannerData,
+      CVMGCOptions* gcOpts);
+extern void
+CVMweakrefRollbackHandling(CVMExecEnv* ee,
+      CVMGCOptions* gcOpts,
+      CVMRefCallbackFunc rootRollbackFunction,
+      void* rootRollbackData);
+void
+CVMweakrefFinalizeProcessing(CVMExecEnv* ee,
+        CVMRefLivenessQueryFunc isLive, void* isLiveData,
+        CVMRefCallbackFunc transitiveScanner,
+        void* transitiveScannerData,
+        CVMGCOptions* gcOpts);
+extern void
+CVMweakrefUpdate(CVMExecEnv* ee,
+   CVMRefCallbackFunc refUpdate, void* updateData,
+   CVMGCOptions* gcOpts);
+extern void
+CVMweakrefCleanUpForGCAbort(CVMExecEnv* ee);
+extern CVMBool CVMinitVMTargetGlobalState();
+extern void CVMdestroyVMTargetGlobalState();
+typedef struct CVMpathInfo CVMpathInfo;
+struct CVMpathInfo {
+    char *basePath;
+    char *libPath;
+    char *dllPath;
+    char *preBootclasspath;
+    char *postBootclasspath;
+};
+extern CVMBool CVMinitStaticState(CVMpathInfo *);
+extern void CVMdestroyStaticState();
+typedef struct {
+    const char *library_path;
+    const char *dll_dir;
+    const char *java_home;
+    const char *ext_dirs;
+    const char *sysclasspath;
+} CVMProperties;
+extern const CVMProperties *CVMgetProperties(void);
+struct CVMTargetGlobalState {
+    int dummy;
+    CVMThreadID *io_queue;
+};
+extern CVMBool
+linuxSegvHandlerInit(void);
+extern CVMTargetGlobalState * const CVMtargetGlobals;
+extern CNINativeMethod CNIsun_misc_CVM_setSystemClassLoader;
+extern CNINativeMethod CNIsun_misc_CVM_checkDebugFlags;
+extern CNINativeMethod CNIsun_misc_CVM_setDebugFlags;
+extern CNINativeMethod CNIsun_misc_CVM_clearDebugFlags;
+extern CNINativeMethod CNIsun_misc_CVM_restoreDebugFlags;
+extern CNINativeMethod CNIsun_misc_CVM_checkDebugJITFlags;
+extern CNINativeMethod CNIsun_misc_CVM_setDebugJITFlags;
+extern CNINativeMethod CNIsun_misc_CVM_clearDebugJITFlags;
+extern CNINativeMethod CNIsun_misc_CVM_restoreDebugJITFlags;
+extern CNINativeMethod CNIsun_misc_CVM_copyBooleanArray;
+extern CNINativeMethod CNIsun_misc_CVM_copyByteArray;
+extern CNINativeMethod CNIsun_misc_CVM_copyCharArray;
+extern CNINativeMethod CNIsun_misc_CVM_copyShortArray;
+extern CNINativeMethod CNIsun_misc_CVM_copyIntArray;
+extern CNINativeMethod CNIsun_misc_CVM_copyFloatArray;
+extern CNINativeMethod CNIsun_misc_CVM_copyLongArray;
+extern CNINativeMethod CNIsun_misc_CVM_copyDoubleArray;
+extern CNINativeMethod CNIsun_misc_CVM_copyObjectArray;
+extern CNINativeMethod CNIsun_misc_CVM_executeClinit;
+extern CNINativeMethod CNIsun_misc_CVM_freeClinit;
+extern CNINativeMethod CNIsun_misc_CVM_executeLoadSuperClasses;
+extern CNINativeMethod CNIsun_misc_CVM_disableRemoteExceptions;
+extern CNINativeMethod CNIsun_misc_CVM_enableRemoteExceptions;
+extern CNINativeMethod CNIsun_misc_CVM_throwRemoteException;
+extern CNINativeMethod CNIsun_misc_CVM_maskInterrupts;
+extern CNINativeMethod CNIsun_misc_CVM_unmaskInterrupts;
+extern CNINativeMethod CNIsun_misc_CVM_throwLocalException;
+extern CNINativeMethod CNIsun_misc_CVM_setContextArtificial;
+extern CNINativeMethod CNIsun_misc_CVM_callerCLIsMIDCLs;
+extern CNINativeMethod CNIsun_misc_CVM_isMIDPContext;
+extern CNINativeMethod CNIsun_misc_CVM_inMainLVM;
+extern CNINativeMethod CNIsun_misc_CVM_gcDumpHeapSimple;
+extern CNINativeMethod CNIsun_misc_CVM_gcDumpHeapVerbose;
+extern CNINativeMethod CNIsun_misc_CVM_gcDumpHeapStats;
+extern CNINativeMethod CNIsun_misc_CVM_trace;
+extern CNINativeMethod CNIsun_misc_CVM_setDebugEvents;
+extern CNINativeMethod CNIsun_misc_CVM_postThreadExit;
+extern CNINativeMethod CNIsun_misc_CVM_objectInflatePermanently;
+extern CNINativeMethod CNIsun_misc_CVM_setThreadNoCompilationsFlag;
+extern CNINativeMethod CNIsun_misc_CVM_getCallerClass;
+extern CNINativeMethod CNIsun_misc_CVM_isCompilerSupported;
+extern CNINativeMethod CNIsun_misc_CVM_dumpCompilerProfileData;
+extern CNINativeMethod CNIsun_misc_CVM_dumpStats;
+extern CNINativeMethod CNIsun_misc_CVM_markCodeBuffer;
+extern CNINativeMethod CNIsun_misc_CVM_initializeJITPolicy;
+extern CNINativeMethod CNIsun_misc_CVM_initializeAOTCode;
+extern CNINativeMethod CNIsun_misc_CVM_parseVerifyOptions;
+extern CNINativeMethod CNIsun_misc_CVM_parseXoptOptions;
+extern CNINativeMethod CNIsun_misc_CVM_parseXgcOptions;
+extern CNINativeMethod CNIsun_misc_CVM_parseXssOption;
+extern CNINativeMethod CNIsun_misc_CVM_parseAssertionOptions;
+extern CNINativeMethod CNIsun_misc_CVM_agentlibSupported;
+extern CNINativeMethod CNIsun_misc_CVM_agentlibInitialize;
+extern CNINativeMethod CNIsun_misc_CVM_agentlibProcess;
+extern CNINativeMethod CNIsun_misc_CVM_xrunSupported;
+extern CNINativeMethod CNIsun_misc_CVM_xrunInitialize;
+extern CNINativeMethod CNIsun_misc_CVM_xrunProcess;
+extern CNINativeMethod CNIsun_misc_CVM_xdebugSet;
+extern CNINativeMethod CNIsun_misc_CVM_simpleLockGrab;
+extern CNINativeMethod CNIsun_misc_CVM_simpleLockRelease;
+extern CNINativeMethod CNIsun_misc_CVM_getBuildOptionString;
+extern CNINativeMethod CNIsun_misc_CVM_nanoTime;
+extern CNINativeMethod CNIsun_misc_CVM_setURLConnectionDefaultUseCaches;
+extern CNINativeMethod CNIsun_misc_CVM_clearURLClassLoaderUcpField;
+void CVMconsolePrintf(const char* format, ...);
+void
+CVMdumpException(CVMExecEnv* ee);
+extern CVMInt32
+CVMcheckDebugFlags(CVMInt32 flags);
+extern CVMInt32
+CVMsetDebugFlags(CVMInt32 flags);
+extern CVMInt32
+CVMclearDebugFlags(CVMInt32 flags);
+extern CVMInt32
+CVMrestoreDebugFlags(CVMInt32 flags, CVMInt32 oldvalue);
+extern void CVMlong2String(CVMInt64, char*, char*);
+void
+CVMdumpThread(JNIEnv* env);
+void
+CVMprintThreadName(JNIEnv* env, CVMObjectICell* threadICell);
+extern char*
+CVMclassname2String(CVMClassTypeID classTypeID, char *dst, int size);
+extern CVMSize
+CVMutfLength(const char *);
+extern int
+CVMutfCountedCopyIntoCharArray(
+    const char * utf8Bytes, CVMJavaChar* unicodeChars, CVMSize unicodeLength );
+extern void
+CVMutfCopyIntoCharArray(const char* utf8Bytes, CVMJavaChar* unicodeChars);
+extern char*
+CVMutfCopyFromCharArray(const CVMJavaChar* unicodeChars,
+   char* utf8Bytes, CVMInt32 count);
+extern CVMJavaChar
+CVMutfNextUnicodeChar(const char** utf8String_p);
+size_t
+CVMformatString(char *buf, size_t bufSize, const char *format, ...);
+size_t
+CVMformatStringVaList(char *buf, size_t bufSize,
+    const char *format, va_list ap);
+extern void
+CVMnewStringUTF(CVMExecEnv* ee, CVMStringICell* resultICell,
+  const char* utf8Bytes);
+extern void
+CVMnewString(CVMExecEnv* ee, CVMStringICell* resultICell,
+      const CVMJavaChar* unicodeChars, CVMUint32 len);
+CVMBool CVMisSameClassPackage(CVMExecEnv* ee,
+         CVMClassBlock* class1, CVMClassBlock* class2);
+extern CVMClassBlock*
+CVMgcSafeClassRef2ClassBlock(CVMExecEnv* ee, CVMClassICell *clazz);
+extern CVMClassBlock *
+CVMgcUnsafeClassRef2ClassBlock(CVMExecEnv *ee, CVMClassICell *clazz);
+extern void
+CVMrandomInit();
+extern CVMInt32
+CVMrandomNext();
+CVMBool
+CVMgcSafeJavaWrap(CVMExecEnv* ee, jvalue v,
+    CVMBasicType fromType,
+    CVMObjectICell* result);
+CVMBool
+CVMgcSafeJavaUnwrap(CVMExecEnv* ee, CVMObjectICell* obj,
+      jvalue* v, CVMBasicType* toType,
+      CVMClassBlock* exceptionCb);
+CVMBool
+CVMgcUnsafeJavaUnwrap(CVMExecEnv* ee, CVMObject* obj,
+        jvalue* v, CVMBasicType* toType,
+        CVMClassBlock* exceptionCb);
+CVMBool
+CVMputProp(JNIEnv* env, jmethodID putID,
+    jobject props, const char* key, const char* val);
+CVMBool
+CVMputPropForPlatformCString(JNIEnv* env, jmethodID putID,
+        jobject props, const char* key, const char* val);
+CVMUint32 CVMpackSizeBy(CVMUint32 sizeToPack, CVMUint32 packingIncrement);
+extern CVMInt32
+CVMoptionToInt32(const char* optionString);
+typedef struct {
+    CVMUint32 numOptions;
+    char** options;
+} CVMParsedSubOptions;
+extern CVMBool
+CVMinitParsedSubOptions(CVMParsedSubOptions* subOptions,
+   const char* subOptionsString);
+extern void
+CVMdestroyParsedSubOptions(CVMParsedSubOptions *opts);
+extern const char *
+CVMgetParsedSubOption(const CVMParsedSubOptions* subOptions,
+        const char* subOptionName);
+typedef enum {
+    CVM_NULL_OPTION = 0,
+    CVM_INTEGER_OPTION,
+    CVM_BOOLEAN_OPTION,
+    CVM_PERCENT_OPTION,
+    CVM_STRING_OPTION,
+    CVM_MULTI_STRING_OPTION,
+    CVM_ENUM_OPTION
+} CVMSubOptionKindEnum;
+typedef struct {
+    const char *name;
+    CVMUint32 value;
+} CVMSubOptionEnumData;
+typedef struct {
+    const char* name;
+    const char* description;
+    CVMSubOptionKindEnum kind;
+    union {
+ struct {
+     int minValue;
+     CVMAddr maxValue;
+     CVMAddr defaultValue;
+ } intData;
+ struct {
+     int ignored1;
+     const char* helpSyntax;
+     const char* defaultValue;
+ } strData;
+ struct {
+     int numPossibleValues;
+     const char** possibleValues;
+     CVMAddr defaultValue;
+ } multiStrData;
+        struct {
+            int numPossibleValues;
+            const CVMSubOptionEnumData* possibleValues;
+            CVMAddr defaultValue;
+        } enumData;
+    } data;
+    const void* valuePtr;
+} CVMSubOptionData;
+extern CVMBool
+CVMprocessSubOptions(const CVMSubOptionData* knownSubOptions,
+       const char* optionName,
+       CVMParsedSubOptions *parsedSubOptions);
+extern void
+CVMprintSubOptionValues(const CVMSubOptionData* knownSubOptions);
+extern void
+CVMprintSubOptionsUsageString(const CVMSubOptionData* knownSubOptions);
+extern CVMBool
+CVMinitPathValues(void *propsPtr, CVMpathInfo *pathInfo,
+                  char **userBootclasspath);
+extern void CVMdestroyPathInfo(CVMpathInfo *);
+extern void
+CVMdestroyPathValues(void *propsPtr);
+extern char*
+CVMconvertJavaStringToCString(CVMExecEnv* ee, jobject stringobj);
+typedef struct CVMGCCommonGlobalState CVMGCCommonGlobalState;
+struct CVMGCCommonGlobalState {
+    CVMParsedSubOptions gcOptions;
+    CVMUint32 maxStackMapsMemorySize;
+    CVMBool doClassCleanup;
+    CVMBool stringInternedSinceLastGC;
+    CVMBool classCreatedSinceLastGC;
+    CVMBool loaderCreatedSinceLastGC;
+    CVMStackMaps *firstStackMaps;
+    CVMStackMaps *lastStackMaps;
+    CVMUint32 stackMapsTotalMemoryUsed;
+};
+struct CVMGCOptions {
+    CVMBool isUpdatingObjectPointers;
+    CVMBool discoverWeakReferences;
+    CVMBool isProfilingPass;
+};
+enum CVMGCRefType {
+    CVMGCRefType_INVALID = 0,
+    CVMGCRefType_GLOBAL_ROOT,
+    CVMGCRefType_PRELOADER_STATICS,
+    CVMGCRefType_CLASS_STATICS,
+    CVMGCRefType_LOCAL_ROOTS,
+    CVMGCRefType_UNKNOWN_STACK_FRAME,
+    CVMGCRefType_JAVA_FRAME,
+    CVMGCRefType_JNI_FRAME,
+    CVMGCRefType_TRANSITION_FRAME,
+    CVMGCRefType_OBJECT_FIELD
+};
+typedef enum CVMGCRefType CVMGCRefType;
+typedef struct CVMGCProfilingInfo CVMGCProfilingInfo;
+struct CVMGCProfilingInfo {
+    CVMGCRefType type;
+    void *data;
+    union {
+        struct {
+            CVMClassBlock *cb;
+        } clazz;
+        struct {
+            CVMExecEnv *ee;
+            CVMInt32 frameNumber;
+        } frame;
+    } u;
+};
+typedef struct CVMGCLocker CVMGCLocker;
+struct CVMGCLocker
+{
+    volatile CVMUint32 lockCount;
+    volatile CVMBool wasContended;
+};
+void CVMgcLockerInit(CVMGCLocker *self);
+void CVMgcLockerLock(CVMGCLocker *self, CVMExecEnv *current_ee);
+void CVMgcLockerUnlock(CVMGCLocker *self, CVMExecEnv *current_ee);
+extern CVMBool
+CVMgcInitHeap(CVMOptions *options);
+extern char *
+CVMgcGetGCAttributeVal(char* attrName);
+extern CVMObject*
+CVMgcAllocNewInstance(CVMExecEnv* ee, CVMClassBlock* cb);
+extern CVMObject*
+CVMgcAllocNewClassInstance(CVMExecEnv* ee, CVMClassBlock* cbOfJavaLangClass);
+extern CVMArrayOfAnyType*
+CVMgcAllocNewArray(CVMExecEnv* ee, CVMBasicType typeCode,
+     CVMClassBlock* arrayCb, CVMJavaInt len);
+extern CVMArrayOfAnyType*
+CVMgcAllocNewArrayWithInstanceSize(CVMExecEnv* ee, CVMJavaInt instanceSize,
+       CVMClassBlock* arrayCb, CVMJavaInt len);
+extern CVMJavaLong
+CVMgcFreeMemory(CVMExecEnv* ee);
+extern CVMJavaLong
+CVMgcTotalMemory(CVMExecEnv* ee);
+extern CVMBool
+CVMgcStopTheWorldAndGC(CVMExecEnv* ee, CVMUint32 numBytes);
+extern CVMBool
+CVMgcStopTheWorldAndDoAction(CVMExecEnv *ee, void *data,
+                 CVMUint32 (*preActionCallback)(CVMExecEnv *ee, void *data),
+                 CVMBool (*actionCallback)(CVMExecEnv *ee, void *data),
+                 void (*postActionCallback)(CVMExecEnv *ee, void *data,
+                                            CVMBool actionSuccess,
+                                            CVMUint32 preActionStatus),
+   void (*retryAfterActionCallback)(CVMExecEnv *ee, void *data),
+   void* retryData);
+extern void
+CVMgcStartGC(CVMExecEnv* ee);
+extern void
+CVMgcClearClassMarks(CVMExecEnv* ee, CVMGCOptions* gcOpts);
+extern void
+CVMgcEndGC(CVMExecEnv* ee);
+extern void
+CVMgcRunGC(CVMExecEnv* ee);
+extern void
+CVMnullFrameScanner(CVMFrame* frame, CVMStackChunk* chunk,
+      CVMRefCallbackFunc callback, void* data);
+extern void
+CVMgcProcessSpecialWithLivenessInfo(CVMExecEnv* ee, CVMGCOptions* gcOpts,
+        CVMRefLivenessQueryFunc isLive,
+        void* isLiveData,
+                                    CVMRefCallbackFunc transitiveScanner,
+        void* transitiveScannerData);
+void
+CVMgcProcessWeakrefWithLivenessInfo(CVMExecEnv* ee,
+    CVMGCOptions* gcOpts, CVMRefLivenessQueryFunc isLive, void* isLiveData,
+    CVMRefCallbackFunc transitiveScanner, void* transitiveScannerData);
+void
+CVMgcProcessInternedStringsWithLivenessInfo(CVMExecEnv* ee,
+    CVMGCOptions* gcOpts, CVMRefLivenessQueryFunc isLive, void* isLiveData,
+    CVMRefCallbackFunc transitiveScanner, void* transitiveScannerData);
+extern void
+CVMgcProcessSpecialWithLivenessInfoWithoutWeakRefs(
+                                    CVMExecEnv* ee, CVMGCOptions* gcOpts,
+        CVMRefLivenessQueryFunc isLive,
+        void* isLiveData,
+                                    CVMRefCallbackFunc transitiveScanner,
+        void* transitiveScannerData);
+extern void
+CVMgcScanSpecial(CVMExecEnv* ee, CVMGCOptions* gcOpts,
+   CVMRefCallbackFunc callback, void* data);
+extern void
+CVMgcScanRoots(CVMExecEnv* ee, CVMGCOptions* gcOpts,
+        CVMRefCallbackFunc callback, void* data);
+extern CVMBool
+CVMgcEnsureStackmapsForRootScans(CVMExecEnv *ee);
+extern CVMBool
+CVMgcDestroyHeap();
+extern CVMBool
+CVMgcScanObjectRange(CVMExecEnv* ee, CVMUint32* base, CVMUint32* top,
+                     CVMObjectCallbackFunc callback, void* callbackData);
+struct CVMStackWalkContext {
+    CVMFrame* frame;
+    CVMStackChunk* chunk;
+};
+extern void
+CVMstackwalkInit(CVMStack* stack, CVMStackWalkContext* c);
+extern void
+CVMstackwalkDestroy(CVMStackWalkContext* c);
+extern void
+CVMstackwalkPrev(CVMStackWalkContext* c);
+typedef union CVMSlotVal32 {
+    CVMJavaVal32 j;
+    CVMUint8* a;
+} CVMSlotVal32;
+union CVMStackVal32 {
+    CVMJavaVal32 j;
+    CVMSlotVal32 s;
+    CVMObjectICell ref;
+    CVMStackVal32* next;
+};
+struct CVMStackChunk {
+    CVMStackChunk* prev;
+    CVMStackChunk* next;
+    CVMStackVal32* end_data;
+    CVMStackVal32 data[1];
+};
+struct CVMStack {
+    CVMStackChunk* firstStackChunk;
+    CVMStackChunk* currentStackChunk;
+    CVMUint32 minStackChunkSize;
+    CVMUint32 maxStackSize;
+    CVMUint32 stackSize;
+    CVMFrame* volatile currentFrame;
+    CVMStackVal32* stackChunkStart;
+    CVMStackVal32* stackChunkEnd;
+};
+typedef enum {
+    CVM_FRAMETYPE_NONE,
+    CVM_FRAMETYPE_JAVA,
+    CVM_FRAMETYPE_TRANSITION,
+    CVM_FRAMETYPE_FREELIST,
+    CVM_FRAMETYPE_LOCALROOT,
+    CVM_FRAMETYPE_GLOBALROOT,
+    CVM_FRAMETYPE_CLASSTABLE,
+    CVM_NUM_FRAMETYPES
+} CVMFrameType;
+typedef enum {
+    CVM_FRAMEFLAG_ARTIFICIAL = 0x1,
+    CVM_FRAMEFLAG_EXCEPTION = 0x2
+} CVMFrameFlags;
+extern CVMFrameGCScannerFunc * const CVMframeScanners[CVM_NUM_FRAMETYPES];
+struct CVMFrame {
+    CVMFrame* prevX;
+    CVMUint8 type;
+    CVMUint8 flags;
+    CVMStackVal32* volatile topOfStack;
+    CVMMethodBlock* volatile mb;
+};
+struct CVMFreelistFrame {
+    CVMFrame frame;
+    CVMUint32 inUse;
+    CVMStackVal32* freeList;
+    CVMStackVal32 vals[1];
+};
+extern
+CVMStackVal32* CVMexpandStack(CVMExecEnv* ee, CVMStack* s,
+         CVMUint32 capacity,
+         CVMBool throwException,
+         CVMBool justChecking);
+extern CVMBool
+CVMensureCapacity(CVMExecEnv* ee, CVMStack* stack, int capacity);
+extern CVMBool
+CVMstackDeleteLastChunk(CVMStack *stack, CVMStackChunk *chunk);
+extern void
+CVMstackEnableReserved(CVMStack *curStack);
+extern void
+CVMstackDisableReserved(CVMStack *curStack);
+extern CVMBool
+CVMinitStack(CVMExecEnv *ee, CVMStack* s,
+      CVMUint32 initialStackSize, CVMUint32 maxStackSize,
+      CVMUint32 minStackChunkSize, CVMUint32 initialFrameCapacity,
+      CVMFrameType frameType);
+extern void
+CVMdestroyStack(CVMStack* stack);
+extern CVMBool
+CVMinitGCRootStack(CVMExecEnv *ee, CVMStack* s, CVMUint32 initialStackSize,
+     CVMUint32 maxStackSize, CVMUint32 minStackChunkSize,
+     CVMFrameType frameType);
+extern void
+CVMdestroyGCRootStack(CVMStack* stack);
+extern void
+CVMdumpStack(CVMStack* s, CVMBool verbose, CVMBool includeData,
+      CVMInt32 frameLimit);
+extern CVMStackChunk*
+CVMdumpFrame(CVMFrame* frame, CVMStackChunk* startChunk,
+      CVMBool verbose, CVMBool includeData);
+extern CVMBool
+CVMCstackCheckSize(CVMExecEnv *ee, CVMUint32 redzone, char *func_name, CVMBool exceptionThrow);
+typedef void (*CVMFrameCallbackFunc)(CVMFrame *thisFrame);
+extern void
+CVMscanStack(CVMStack* stack, CVMFrameCallbackFunc frameCallback);
+extern void
+CVMscanStackForGC(CVMStack* stack);
+typedef CVMFreelistFrame CVMJNIFrame;
+extern CVMObjectICell *
+CVMjniCreateLocalRef(CVMExecEnv *);
+extern CVMObjectICell *
+CVMjniCreateLocalRef0(CVMExecEnv *, CVMExecEnv *targetEE);
+typedef struct {
+    JNIEnv vector;
+} CVMJNIEnv;
+extern void CVMinitJNIEnv(CVMJNIEnv *);
+extern void CVMdestroyJNIEnv(CVMJNIEnv *);
+struct JNIInvokeInterface;
+typedef struct {
+    const struct JNIInvokeInterface * vector;
+    volatile CVMBool directBufferSupportInitialized;
+    volatile CVMBool directBufferSupportInitializeFailed;
+    jclass bufferClass;
+    jclass directBufferClass;
+    jclass directByteBufferClass;
+    jmethodID directByteBufferLongConstructor;
+    jmethodID directByteBufferIntConstructor;
+    jfieldID directBufferAddressLongField;
+    jfieldID directBufferAddressIntField;
+    jfieldID bufferCapacityField;
+} CVMJNIJavaVM;
+extern void
+CVMinitJNIJavaVM(CVMJNIJavaVM *);
+extern void
+CVMdestroyJNIJavaVM(CVMJNIJavaVM *);
+extern struct JNINativeInterface *
+CVMjniGetInstrumentableJNINativeInterface();
+extern jint CVMjniGetVersion(JNIEnv *env);
+extern jclass CVMjniFindClass(JNIEnv *env, const char *name);
+extern jmethodID CVMjniFromReflectedMethod(JNIEnv* env,
+         jobject method);
+extern jfieldID CVMjniFromReflectedField(JNIEnv* env, jobject field);
+extern jobject CVMjniToReflectedMethod(JNIEnv *env, jclass clazz,
+            jmethodID methodID,
+            jboolean isStatic);
+extern jboolean CVMjniIsAssignableFrom(JNIEnv* env,
+            jclass clazz1, jclass clazz2);
+extern jobject CVMjniToReflectedField(JNIEnv *env, jclass clazz,
+           jfieldID fieldID,
+           jboolean isStatic);
+extern jint CVMjniThrow(JNIEnv *env, jthrowable obj);
+extern jint CVMjniThrowNew(JNIEnv *env,
+       jclass clazz, const char *message);
+extern jthrowable CVMjniExceptionOccurred(JNIEnv *env);
+extern void CVMjniExceptionDescribe(JNIEnv *env);
+extern void CVMjniExceptionClear(JNIEnv *env);
+extern void CVMjniFatalError(JNIEnv *env, const char *msg);
+extern jint CVMjniPushLocalFrame(JNIEnv *env, jint capacity);
+extern jobject CVMjniPopLocalFrame(JNIEnv *env, jobject resultArg);
+extern jobject CVMjniNewGlobalRef(JNIEnv *env, jobject ref);
+extern void CVMjniDeleteGlobalRef(JNIEnv *env, jobject ref);
+extern void CVMjniDeleteLocalRef(JNIEnv *env, jobject obj);
+extern jboolean CVMjniIsSameObject(JNIEnv *env,
+        jobject ref1, jobject ref2);
+extern jobject CVMjniNewLocalRef(JNIEnv *env, jobject obj);
+extern jint CVMjniEnsureLocalCapacity(JNIEnv *env, jint capacity);
+extern jobject CVMjniAllocObject(JNIEnv *env, jclass clazz);
+extern jobject CVMjniNewObject(JNIEnv *env, jclass clazz,
+           jmethodID methodID, ...);
+extern jobject CVMjniNewObjectV(JNIEnv *env, jclass clazz,
+     jmethodID methodID, va_list args);
+extern jobject CVMjniNewObjectA(JNIEnv *env, jclass clazz,
+     jmethodID methodID, const jvalue *args);
+extern jclass CVMjniGetObjectClass(JNIEnv *env, jobject obj);
+extern jboolean CVMjniIsInstanceOf(JNIEnv* env, jobject obj,
+        jclass clazz);
+extern jmethodID CVMjniGetMethodID(JNIEnv *env, jclass clazz,
+        const char *name, const char *sig);
+extern jobject CVMjniCallObjectMethod(JNIEnv *env, jobject obj,
+           jmethodID methodID, ...);
+extern jobject CVMjniCallObjectMethodV(JNIEnv *env, jobject obj,
+            jmethodID methodID,
+            va_list args);
+extern jobject CVMjniCallObjectMethodA(JNIEnv *env, jobject obj,
+            jmethodID methodID,
+            const jvalue *args);
+extern jboolean CVMjniCallBooleanMethod(JNIEnv *env, jobject obj,
+      jmethodID methodID, ...);
+extern jboolean CVMjniCallBooleanMethodV(JNIEnv *env, jobject obj,
+       jmethodID methodID,
+       va_list args);
+extern jboolean CVMjniCallBooleanMethodA(JNIEnv *env, jobject obj,
+       jmethodID methodID,
+       const jvalue *args);
+extern jbyte CVMjniCallByteMethod(JNIEnv *env, jobject obj,
+       jmethodID methodID, ...);
+extern jbyte CVMjniCallByteMethodV(JNIEnv *env, jobject obj,
+        jmethodID methodID,
+        va_list args);
+extern jbyte CVMjniCallByteMethodA(JNIEnv *env, jobject obj,
+        jmethodID methodID,
+        const jvalue *args);
+extern jchar CVMjniCallCharMethod(JNIEnv *env, jobject obj,
+       jmethodID methodID, ...);
+extern jchar CVMjniCallCharMethodV(JNIEnv *env, jobject obj,
+        jmethodID methodID,
+        va_list args);
+extern jchar CVMjniCallCharMethodA(JNIEnv *env, jobject obj,
+        jmethodID methodID,
+        const jvalue *args);
+extern jshort CVMjniCallShortMethod(JNIEnv *env, jobject obj,
+         jmethodID methodID, ...);
+extern jshort CVMjniCallShortMethodV(JNIEnv *env, jobject obj,
+          jmethodID methodID,
+          va_list args);
+extern jshort CVMjniCallShortMethodA(JNIEnv *env, jobject obj,
+          jmethodID methodID,
+          const jvalue *args);
+extern jint CVMjniCallIntMethod(JNIEnv *env, jobject obj,
+     jmethodID methodID, ...);
+extern jint CVMjniCallIntMethodV(JNIEnv *env, jobject obj,
+      jmethodID methodID,
+      va_list args);
+extern jint CVMjniCallIntMethodA(JNIEnv *env, jobject obj,
+      jmethodID methodID,
+      const jvalue *args);
+extern jlong CVMjniCallLongMethod(JNIEnv *env, jobject obj,
+       jmethodID methodID, ...);
+extern jlong CVMjniCallLongMethodV(JNIEnv *env, jobject obj,
+        jmethodID methodID,
+        va_list args);
+extern jlong CVMjniCallLongMethodA(JNIEnv *env, jobject obj,
+        jmethodID methodID,
+        const jvalue *args);
+extern jfloat CVMjniCallFloatMethod(JNIEnv *env, jobject obj,
+         jmethodID methodID, ...);
+extern jfloat CVMjniCallFloatMethodV(JNIEnv *env, jobject obj,
+          jmethodID methodID,
+          va_list args);
+extern jfloat CVMjniCallFloatMethodA(JNIEnv *env, jobject obj,
+          jmethodID methodID,
+          const jvalue *args);
+extern jdouble CVMjniCallDoubleMethod(JNIEnv *env, jobject obj,
+           jmethodID methodID, ...);
+extern jdouble CVMjniCallDoubleMethodV(JNIEnv *env, jobject obj,
+            jmethodID methodID,
+            va_list args);
+extern jdouble CVMjniCallDoubleMethodA(JNIEnv *env, jobject obj,
+            jmethodID methodID,
+            const jvalue *args);
+extern void CVMjniCallVoidMethod(JNIEnv *env, jobject obj,
+      jmethodID methodID, ...);
+extern void CVMjniCallVoidMethodV(JNIEnv *env, jobject obj,
+       jmethodID methodID,
+       va_list args);
+extern void CVMjniCallVoidMethodA(JNIEnv *env, jobject obj,
+       jmethodID methodID,
+       const jvalue *args);
+extern jobject CVMjniCallNonvirtualObjectMethod(JNIEnv *env,
+       jobject obj,
+       jclass clazz,
+       jmethodID methodID,
+       ...);
+extern jobject CVMjniCallNonvirtualObjectMethodV(JNIEnv *env,
+        jobject obj,
+        jclass clazz,
+        jmethodID methodID,
+        va_list args);
+extern jobject CVMjniCallNonvirtualObjectMethodA(JNIEnv *env,
+        jobject obj,
+        jclass clazz,
+        jmethodID methodID,
+        const jvalue *args);
+extern jboolean CVMjniCallNonvirtualBooleanMethod(JNIEnv *env,
+         jobject obj,
+         jclass clazz,
+         jmethodID methodID,
+         ...);
+extern jboolean CVMjniCallNonvirtualBooleanMethodV(JNIEnv *env,
+          jobject obj,
+          jclass clazz,
+          jmethodID methodID,
+          va_list args);
+extern jboolean CVMjniCallNonvirtualBooleanMethodA(JNIEnv *env,
+          jobject obj,
+          jclass clazz,
+          jmethodID methodID,
+          const jvalue *args);
+extern jbyte CVMjniCallNonvirtualByteMethod(JNIEnv *env,
+          jobject obj,
+          jclass clazz,
+          jmethodID methodID,
+          ...);
+extern jbyte CVMjniCallNonvirtualByteMethodV(JNIEnv *env,
+           jobject obj,
+           jclass clazz,
+           jmethodID methodID,
+           va_list args);
+extern jbyte CVMjniCallNonvirtualByteMethodA(JNIEnv *env,
+           jobject obj,
+           jclass clazz,
+           jmethodID methodID,
+           const jvalue *args);
+extern jchar CVMjniCallNonvirtualCharMethod(JNIEnv *env,
+          jobject obj,
+          jclass clazz,
+          jmethodID methodID,
+          ...);
+extern jchar CVMjniCallNonvirtualCharMethodV(JNIEnv *env,
+           jobject obj,
+           jclass clazz,
+           jmethodID methodID,
+           va_list args);
+extern jchar CVMjniCallNonvirtualCharMethodA(JNIEnv *env,
+           jobject obj,
+           jclass clazz,
+           jmethodID methodID,
+           const jvalue *args);
+extern jshort CVMjniCallNonvirtualShortMethod(JNIEnv *env,
+            jobject obj,
+            jclass clazz,
+            jmethodID methodID,
+            ...);
+extern jshort CVMjniCallNonvirtualShortMethodV(JNIEnv *env,
+             jobject obj,
+             jclass clazz,
+             jmethodID methodID,
+             va_list args);
+extern jshort CVMjniCallNonvirtualShortMethodA(JNIEnv *env,
+             jobject obj,
+             jclass clazz,
+             jmethodID methodID,
+             const jvalue *args);
+extern jint CVMjniCallNonvirtualIntMethod(JNIEnv *env,
+        jobject obj,
+        jclass clazz,
+        jmethodID methodID,
+        ...);
+extern jint CVMjniCallNonvirtualIntMethodV(JNIEnv *env,
+         jobject obj,
+         jclass clazz,
+         jmethodID methodID,
+         va_list args);
+extern jint CVMjniCallNonvirtualIntMethodA(JNIEnv *env,
+         jobject obj,
+         jclass clazz,
+         jmethodID methodID,
+         const jvalue *args);
+extern jlong CVMjniCallNonvirtualLongMethod(JNIEnv *env,
+          jobject obj,
+          jclass clazz,
+          jmethodID methodID,
+          ...);
+extern jlong CVMjniCallNonvirtualLongMethodV(JNIEnv *env,
+           jobject obj,
+           jclass clazz,
+           jmethodID methodID,
+           va_list args);
+extern jlong CVMjniCallNonvirtualLongMethodA(JNIEnv *env,
+           jobject obj,
+           jclass clazz,
+           jmethodID methodID,
+           const jvalue *args);
+extern jfloat CVMjniCallNonvirtualFloatMethod(JNIEnv *env,
+            jobject obj,
+            jclass clazz,
+            jmethodID methodID,
+            ...);
+extern jfloat CVMjniCallNonvirtualFloatMethodV(JNIEnv *env,
+             jobject obj,
+             jclass clazz,
+             jmethodID methodID,
+             va_list args);
+extern jfloat CVMjniCallNonvirtualFloatMethodA(JNIEnv *env,
+             jobject obj,
+             jclass clazz,
+             jmethodID methodID,
+             const jvalue *args);
+extern jdouble CVMjniCallNonvirtualDoubleMethod(JNIEnv *env,
+       jobject obj,
+       jclass clazz,
+       jmethodID methodID,
+       ...);
+extern jdouble CVMjniCallNonvirtualDoubleMethodV(JNIEnv *env,
+        jobject obj,
+        jclass clazz,
+        jmethodID methodID,
+        va_list args);
+extern jdouble CVMjniCallNonvirtualDoubleMethodA(JNIEnv *env,
+        jobject obj,
+        jclass clazz,
+        jmethodID methodID,
+        const jvalue *args);
+extern void CVMjniCallNonvirtualVoidMethod(JNIEnv *env,
+         jobject obj,
+         jclass clazz,
+         jmethodID methodID,
+         ...);
+extern void CVMjniCallNonvirtualVoidMethodV(JNIEnv *env,
+          jobject obj,
+          jclass clazz,
+          jmethodID methodID,
+          va_list args);
+extern void CVMjniCallNonvirtualVoidMethodA(JNIEnv *env,
+          jobject obj,
+          jclass clazz,
+          jmethodID methodID,
+          const jvalue *args);
+extern jfieldID CVMjniGetFieldID(JNIEnv *env, jclass clazz,
+      const char *name, const char *sig);
+extern jobject CVMjniGetObjectField(JNIEnv* env, jobject obj,
+         jfieldID fid);
+extern jboolean CVMjniGetBooleanField(JNIEnv* env, jobject obj,
+           jfieldID fid);
+extern jbyte CVMjniGetByteField(JNIEnv* env, jobject obj,
+     jfieldID fid);
+extern jchar CVMjniGetCharField(JNIEnv* env, jobject obj,
+     jfieldID fid);
+extern jshort CVMjniGetShortField(JNIEnv* env, jobject obj,
+       jfieldID fid);
+extern jint CVMjniGetIntField(JNIEnv* env, jobject obj,
+          jfieldID fid);
+extern jlong CVMjniGetLongField(JNIEnv* env, jobject obj,
+     jfieldID fid);
+extern jfloat CVMjniGetFloatField(JNIEnv* env, jobject obj,
+       jfieldID fid);
+extern jdouble CVMjniGetDoubleField(JNIEnv* env, jobject obj,
+         jfieldID fid);
+extern void CVMjniSetObjectField(JNIEnv* env, jobject obj,
+      jfieldID fid, jobject rhs);
+extern void CVMjniSetBooleanField(JNIEnv* env, jobject obj,
+       jfieldID fid, jboolean rhs);
+extern void CVMjniSetByteField(JNIEnv* env, jobject obj,
+           jfieldID fid, jbyte rhs);
+extern void CVMjniSetCharField(JNIEnv* env, jobject obj,
+           jfieldID fid, jchar rhs);
+extern void CVMjniSetShortField(JNIEnv* env, jobject obj,
+     jfieldID fid, jshort rhs);
+extern void CVMjniSetIntField(JNIEnv* env, jobject obj,
+          jfieldID fid, jint rhs);
+extern void CVMjniSetLongField(JNIEnv* env, jobject obj,
+           jfieldID fid, jlong rhs);
+extern void CVMjniSetFloatField(JNIEnv* env, jobject obj,
+     jfieldID fid, jfloat rhs);
+extern void CVMjniSetDoubleField(JNIEnv* env, jobject obj,
+      jfieldID fid, jdouble rhs);
+extern jmethodID CVMjniGetStaticMethodID(JNIEnv *env, jclass clazz,
+       const char *name,
+       const char *sig);
+extern jobject CVMjniCallStaticObjectMethod(JNIEnv *env, jclass clazz,
+          jmethodID methodID, ...);
+extern jobject CVMjniCallStaticObjectMethodV(JNIEnv *env, jclass clazz,
+           jmethodID methodID,
+           va_list args);
+extern jobject CVMjniCallStaticObjectMethodA(JNIEnv *env, jclass clazz,
+           jmethodID methodID,
+           const jvalue *args);
+extern jboolean CVMjniCallStaticBooleanMethod(JNIEnv *env,
+            jclass clazz,
+            jmethodID methodID,
+            ...);
+extern jboolean CVMjniCallStaticBooleanMethodV(JNIEnv *env,
+             jclass clazz,
+             jmethodID methodID,
+             va_list args);
+extern jboolean CVMjniCallStaticBooleanMethodA(JNIEnv *env,
+             jclass clazz,
+             jmethodID methodID,
+             const jvalue *args);
+extern jbyte CVMjniCallStaticByteMethod(JNIEnv *env, jclass clazz,
+      jmethodID methodID, ...);
+extern jbyte CVMjniCallStaticByteMethodV(JNIEnv *env, jclass clazz,
+       jmethodID methodID,
+       va_list args);
+extern jbyte CVMjniCallStaticByteMethodA(JNIEnv *env, jclass clazz,
+       jmethodID methodID,
+       const jvalue *args);
+extern jchar CVMjniCallStaticCharMethod(JNIEnv *env, jclass clazz,
+      jmethodID methodID, ...);
+extern jchar CVMjniCallStaticCharMethodV(JNIEnv *env, jclass clazz,
+       jmethodID methodID,
+       va_list args);
+extern jchar CVMjniCallStaticCharMethodA(JNIEnv *env, jclass clazz,
+       jmethodID methodID,
+       const jvalue *args);
+extern jshort CVMjniCallStaticShortMethod(JNIEnv *env, jclass clazz,
+        jmethodID methodID, ...);
+extern jshort CVMjniCallStaticShortMethodV(JNIEnv *env, jclass clazz,
+         jmethodID methodID,
+         va_list args);
+extern jshort CVMjniCallStaticShortMethodA(JNIEnv *env, jclass clazz,
+         jmethodID methodID,
+         const jvalue *args);
+extern jint CVMjniCallStaticIntMethod(JNIEnv *env, jclass clazz,
+           jmethodID methodID, ...);
+extern jint CVMjniCallStaticIntMethodV(JNIEnv *env, jclass clazz,
+            jmethodID methodID,
+            va_list args);
+extern jint CVMjniCallStaticIntMethodA(JNIEnv *env, jclass clazz,
+            jmethodID methodID,
+            const jvalue *args);
+extern jlong CVMjniCallStaticLongMethod(JNIEnv *env, jclass clazz,
+      jmethodID methodID, ...);
+extern jlong CVMjniCallStaticLongMethodV(JNIEnv *env, jclass clazz,
+       jmethodID methodID,
+       va_list args);
+extern jlong CVMjniCallStaticLongMethodA(JNIEnv *env, jclass clazz,
+       jmethodID methodID,
+       const jvalue *args);
+extern jfloat CVMjniCallStaticFloatMethod(JNIEnv *env, jclass clazz,
+        jmethodID methodID, ...);
+extern jfloat CVMjniCallStaticFloatMethodV(JNIEnv *env, jclass clazz,
+         jmethodID methodID,
+         va_list args);
+extern jfloat CVMjniCallStaticFloatMethodA(JNIEnv *env, jclass clazz,
+         jmethodID methodID,
+         const jvalue *args);
+extern jdouble CVMjniCallStaticDoubleMethod(JNIEnv *env, jclass clazz,
+          jmethodID methodID, ...);
+extern jdouble CVMjniCallStaticDoubleMethodV(JNIEnv *env, jclass clazz,
+           jmethodID methodID,
+           va_list args);
+extern jdouble CVMjniCallStaticDoubleMethodA(JNIEnv *env, jclass clazz,
+           jmethodID methodID,
+           const jvalue *args);
+extern void CVMjniCallStaticVoidMethod(JNIEnv *env, jclass clazz,
+            jmethodID methodID, ...);
+extern void CVMjniCallStaticVoidMethodV(JNIEnv *env, jclass clazz,
+      jmethodID methodID,
+      va_list args);
+extern void CVMjniCallStaticVoidMethodA(JNIEnv *env, jclass clazz,
+      jmethodID methodID,
+      const jvalue *args);
+extern jfieldID CVMjniGetStaticFieldID(JNIEnv *env,
+            jclass clazz,
+            const char *name,
+            const char *sig);
+extern jobject CVMjniGetStaticObjectField(JNIEnv* env,
+        jclass clazz, jfieldID fid);
+extern jboolean CVMjniGetStaticBooleanField(JNIEnv* env, jclass clazz,
+          jfieldID fid);
+extern jbyte CVMjniGetStaticByteField(JNIEnv* env, jclass clazz,
+           jfieldID fid);
+extern jchar CVMjniGetStaticCharField(JNIEnv* env, jclass clazz,
+           jfieldID fid);
+extern jshort CVMjniGetStaticShortField(JNIEnv* env, jclass clazz,
+      jfieldID fid);
+extern jint CVMjniGetStaticIntField(JNIEnv* env, jclass clazz,
+         jfieldID fid);
+extern jlong CVMjniGetStaticLongField(JNIEnv* env, jclass clazz,
+           jfieldID fid);
+extern jfloat CVMjniGetStaticFloatField(JNIEnv* env, jclass clazz,
+      jfieldID fid);
+extern jdouble CVMjniGetStaticDoubleField(JNIEnv* env, jclass clazz,
+        jfieldID fid);
+extern void CVMjniSetStaticObjectField(JNIEnv* env, jclass clazz,
+            jfieldID fid, jobject rhs);
+extern void CVMjniSetStaticBooleanField(JNIEnv* env, jclass clazz,
+      jfieldID fid, jboolean rhs);
+extern void CVMjniSetStaticByteField(JNIEnv* env, jclass clazz,
+          jfieldID fid, jbyte rhs);
+extern void CVMjniSetStaticCharField(JNIEnv* env, jclass clazz,
+          jfieldID fid, jchar rhs);
+extern void CVMjniSetStaticShortField(JNIEnv* env, jclass clazz,
+           jfieldID fid, jshort rhs);
+extern void CVMjniSetStaticIntField(JNIEnv* env, jclass clazz,
+         jfieldID fid, jint rhs);
+extern void CVMjniSetStaticLongField(JNIEnv* env, jclass clazz,
+          jfieldID fid, jlong rhs);
+extern void CVMjniSetStaticFloatField(JNIEnv* env, jclass clazz,
+           jfieldID fid, jfloat rhs);
+extern void CVMjniSetStaticDoubleField(JNIEnv* env, jclass clazz,
+            jfieldID fid, jdouble rhs);
+extern jstring CVMjniNewString(JNIEnv *env, const jchar* unicodeChars,
+           jsize len);
+extern jsize CVMjniGetStringLength(JNIEnv* env, jstring string);
+extern const jchar* CVMjniGetStringChars(JNIEnv *env, jstring string,
+       jboolean *isCopy);
+extern void CVMjniReleaseStringChars(JNIEnv *env, jstring str,
+          const jchar *chars);
+extern jstring CVMjniNewStringUTF(JNIEnv* env, const char* utf8Bytes);
+extern jsize CVMjniGetStringUTFLength(JNIEnv *env, jstring string);
+extern const char* CVMjniGetStringUTFChars(JNIEnv *env,
+         jstring string,
+         jboolean *isCopy);
+extern void CVMjniReleaseStringUTFChars(JNIEnv *env, jstring str,
+      const char *chars);
+extern jsize CVMjniGetArrayLength(JNIEnv* env, jarray arrArg);
+extern jarray CVMjniNewObjectArray(JNIEnv* env, jsize length,
+        jclass elementClass,
+        jobject initialElement);
+extern jobject CVMjniGetObjectArrayElement(JNIEnv* env,
+         jarray arrArg, jsize index);
+extern void CVMjniSetObjectArrayElement(JNIEnv* env, jarray arrArg,
+      jsize index, jobject value);
+extern jbooleanArray CVMjniNewBooleanArray(JNIEnv *env, jsize length);
+extern jbyteArray CVMjniNewByteArray(JNIEnv *env, jsize length);
+extern jcharArray CVMjniNewCharArray(JNIEnv *env, jsize length);
+extern jshortArray CVMjniNewShortArray(JNIEnv *env, jsize length);
+extern jintArray CVMjniNewIntArray(JNIEnv *env, jsize length);
+extern jlongArray CVMjniNewLongArray(JNIEnv *env, jsize length);
+extern jfloatArray CVMjniNewFloatArray(JNIEnv *env, jsize length);
+extern jdoubleArray CVMjniNewDoubleArray(JNIEnv *env, jsize length);
+extern jboolean * CVMjniGetBooleanArrayElements(JNIEnv *env,
+       jbooleanArray array,
+       jboolean *isCopy);
+extern jbyte * CVMjniGetByteArrayElements(JNIEnv *env,
+        jbyteArray array,
+        jboolean *isCopy);
+extern jchar * CVMjniGetCharArrayElements(JNIEnv *env,
+        jcharArray array,
+        jboolean *isCopy);
+extern jshort * CVMjniGetShortArrayElements(JNIEnv *env,
+          jshortArray array,
+          jboolean *isCopy);
+extern jint * CVMjniGetIntArrayElements(JNIEnv *env,
+      jintArray array,
+      jboolean *isCopy);
+extern jlong * CVMjniGetLongArrayElements(JNIEnv *env,
+        jlongArray array,
+        jboolean *isCopy);
+extern jfloat * CVMjniGetFloatArrayElements(JNIEnv *env,
+          jfloatArray array,
+          jboolean *isCopy);
+extern jdouble * CVMjniGetDoubleArrayElements(JNIEnv *env,
+            jdoubleArray array,
+            jboolean *isCopy);
+extern void CVMjniReleaseBooleanArrayElements(JNIEnv *env,
+            jbooleanArray array,
+            jboolean *elems,
+            jint mode);
+extern void CVMjniReleaseByteArrayElements(JNIEnv *env,
+         jbyteArray array,
+         jbyte *elems,
+         jint mode);
+extern void CVMjniReleaseCharArrayElements(JNIEnv *env,
+         jcharArray array,
+         jchar *elems,
+         jint mode);
+extern void CVMjniReleaseShortArrayElements(JNIEnv *env,
+          jshortArray array,
+          jshort *elems,
+          jint mode);
+extern void CVMjniReleaseIntArrayElements(JNIEnv *env,
+        jintArray array,
+        jint *elems,
+        jint mode);
+extern void CVMjniReleaseLongArrayElements(JNIEnv *env,
+         jlongArray array,
+         jlong *elems,
+         jint mode);
+extern void CVMjniReleaseFloatArrayElements(JNIEnv *env,
+          jfloatArray array,
+          jfloat *elems,
+          jint mode);
+extern void CVMjniReleaseDoubleArrayElements(JNIEnv *env,
+           jdoubleArray array,
+           jdouble *elems,
+           jint mode);
+extern void CVMjniGetBooleanArrayRegion(JNIEnv *env,
+      jbooleanArray array,
+      jsize start, jsize len,
+      jboolean *buf);
+extern void CVMjniGetByteArrayRegion(JNIEnv *env,
+          jbyteArray array,
+          jsize start, jsize len,
+          jbyte *buf);
+extern void CVMjniGetCharArrayRegion(JNIEnv *env,
+          jcharArray array,
+          jsize start, jsize len,
+          jchar *buf);
+extern void CVMjniGetShortArrayRegion(JNIEnv *env,
+           jshortArray array,
+           jsize start, jsize len,
+           jshort *buf);
+extern void CVMjniGetIntArrayRegion(JNIEnv *env,
+         jintArray array,
+         jsize start, jsize len,
+         jint *buf);
+extern void CVMjniGetLongArrayRegion(JNIEnv *env,
+          jlongArray array,
+          jsize start, jsize len,
+          jlong *buf);
+extern void CVMjniGetFloatArrayRegion(JNIEnv *env,
+           jfloatArray array,
+           jsize start, jsize len,
+           jfloat *buf);
+extern void CVMjniGetDoubleArrayRegion(JNIEnv *env,
+            jdoubleArray array,
+            jsize start, jsize len,
+            jdouble *buf);
+extern void CVMjniSetBooleanArrayRegion(JNIEnv *env,
+      jbooleanArray array,
+      jsize start, jsize len,
+      const jboolean *buf);
+extern void CVMjniSetByteArrayRegion(JNIEnv *env,
+          jbyteArray array,
+          jsize start, jsize len,
+          const jbyte *buf);
+extern void CVMjniSetCharArrayRegion(JNIEnv *env,
+          jcharArray array,
+          jsize start, jsize len,
+          const jchar *buf);
+extern void CVMjniSetShortArrayRegion(JNIEnv *env,
+           jshortArray array,
+           jsize start, jsize len,
+           const jshort *buf);
+extern void CVMjniSetIntArrayRegion(JNIEnv *env,
+         jintArray array,
+         jsize start, jsize len,
+         const jint *buf);
+extern void CVMjniSetLongArrayRegion(JNIEnv *env,
+          jlongArray array,
+          jsize start, jsize len,
+          const jlong *buf);
+extern void CVMjniSetFloatArrayRegion(JNIEnv *env,
+           jfloatArray array,
+           jsize start, jsize len,
+           const jfloat *buf);
+extern void CVMjniSetDoubleArrayRegion(JNIEnv *env,
+            jdoubleArray array,
+            jsize start, jsize len,
+            const jdouble *buf);
+extern jint CVMjniRegisterNatives(JNIEnv *env, jclass clazz,
+       const JNINativeMethod *methods,
+       jint nMethods);
+extern jint CVMjniUnregisterNatives(JNIEnv *env, jclass clazz);
+extern jint CVMjniMonitorEnter(JNIEnv *env, jobject obj);
+extern jint CVMjniMonitorExit(JNIEnv *env, jobject obj);
+extern jint CVMjniGetJavaVM(JNIEnv *env, JavaVM **p_jvm);
+extern void CVMjniGetStringRegion(JNIEnv *env,
+       jstring string, jsize start,
+       jsize len, jchar *buf);
+extern void CVMjniGetStringUTFRegion(JNIEnv *env,
+          jstring string, jsize start,
+          jsize len, char *buf);
+extern void* CVMjniGetPrimitiveArrayCritical(JNIEnv *env,
+           jarray array,
+           jboolean *isCopy);
+extern void CVMjniReleasePrimitiveArrayCritical(JNIEnv *env,
+       jarray array,
+       void* buf, jint mode);
+extern const jchar* CVMjniGetStringCritical(JNIEnv *env,
+          jstring string,
+          jboolean *isCopy);
+extern void CVMjniReleaseStringCritical(JNIEnv *env, jstring str,
+      const jchar *chars);
+extern jboolean CVMjniExceptionCheck(JNIEnv *env);
+extern jobject
+CVMjniNewDirectByteBuffer(JNIEnv *env, void* address, jlong capacity);
+extern void*
+CVMjniGetDirectBufferAddress(JNIEnv *env, jobject buf);
+extern jlong
+CVMjniGetDirectBufferCapacity(JNIEnv *env, jobject buf);
+extern CVMBool CVMthreadCreate(CVMThreadID *thread,
+    CVMSize stackSize, CVMInt32 priority,
+    void (*func)(void *), void *arg);
+extern void CVMthreadYield(void);
+extern void CVMthreadSetPriority(CVMThreadID *thread, CVMInt32 prio);
+extern void CVMthreadSuspend(CVMThreadID *thread);
+extern void CVMthreadResume(CVMThreadID *thread);
+extern CVMBool CVMthreadAttach(CVMThreadID *self, CVMBool orphan);
+extern void CVMthreadDetach(CVMThreadID *self);
+extern CVMThreadID * CVMthreadSelf(void);
+extern void CVMthreadInterruptWait(CVMThreadID *thread);
+extern CVMBool CVMthreadIsInterrupted(CVMThreadID *thread,
+    CVMBool clearInterrupted);
+extern CVMBool CVMthreadStackCheck(CVMThreadID *self, CVMUint32 redZone);
+extern CVMBool POSIXthreadInitStaticState();
+extern void POSIXthreadDestroyStaticState();
+extern CVMBool POSIXthreadCreate(CVMThreadID *tid,
+    CVMSize stackSize, CVMInt32 priority,
+    void (*func)(void *), void *arg);
+extern CVMThreadID * POSIXthreadGetSelf();
+extern CVMBool POSIXthreadAttach(CVMThreadID *self, CVMBool orphan);
+extern void POSIXthreadDetach(CVMThreadID *self);
+extern void POSIXthreadSetPriority(CVMThreadID *t, CVMInt32 priority);
+extern void POSIXthreadGetPriority(CVMThreadID *t, CVMInt32 *priority);
+typedef struct CVMThreadArchData {
+    int dummy;
+} CVMThreadArchData;
+struct __jmp_buf_tag
+  {
+    __jmp_buf __jmpbuf;
+    int __mask_was_saved;
+    __sigset_t __saved_mask;
+  };
+typedef struct __jmp_buf_tag jmp_buf[1];
+extern int setjmp (jmp_buf __env) __attribute__ ((__nothrow__));
+extern int __sigsetjmp (struct __jmp_buf_tag __env[1], int __savemask) __attribute__ ((__nothrow__));
+extern int _setjmp (struct __jmp_buf_tag __env[1]) __attribute__ ((__nothrow__));
+extern void longjmp (struct __jmp_buf_tag __env[1], int __val)
+     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));
+extern void _longjmp (struct __jmp_buf_tag __env[1], int __val)
+     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));
+typedef struct __jmp_buf_tag sigjmp_buf[1];
+extern void siglongjmp (sigjmp_buf __env, int __val)
+     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));
+struct CVMThreadID {
+    pthread_t pthreadCookie;
+    void *stackTop;
+    POSIXMutex locked;
+    volatile CVMBool isSuspended;
+    volatile CVMBool isInSuspendHandler;
+    volatile CVMBool isMutexBlocked;
+    volatile CVMBool isWaitBlocked;
+    CVMBool interrupted;
+    CVMBool notified;
+    pthread_mutex_t wait_mutex;
+    pthread_cond_t wait_cv;
+    int value;
+    int fd;
+    CVMThreadArchData archData;
+    CVMThreadID *next;
+    CVMThreadID **prev_p;
+};
+extern void linuxCaptureInitialStack();
+enum {
+    JVMTI_VERSION_1 = 0x30010000,
+    JVMTI_VERSION_1_0 = 0x30010000,
+    JVMTI_VERSION_1_1 = 0x30010100,
+    JVMTI_VERSION = 0x30000000 + (1 * 0x10000) + (1 * 0x100) + 102
+};
+extern jint
+Agent_OnLoad(JavaVM *vm, char *options, void *reserved);
+extern jint
+Agent_OnAttach(JavaVM* vm, char* options, void* reserved);
+extern void
+Agent_OnUnload(JavaVM *vm);
+struct _jvmtiEnv;
+struct jvmtiInterface_1_;
+typedef const struct jvmtiInterface_1_ *jvmtiEnv;
+typedef jobject jthread;
+typedef jobject jthreadGroup;
+typedef jlong jlocation;
+struct _jrawMonitorID;
+typedef struct _jrawMonitorID *jrawMonitorID;
+typedef struct JNINativeInterface jniNativeInterface;
+enum {
+    JVMTI_THREAD_STATE_ALIVE = 0x0001,
+    JVMTI_THREAD_STATE_TERMINATED = 0x0002,
+    JVMTI_THREAD_STATE_RUNNABLE = 0x0004,
+    JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER = 0x0400,
+    JVMTI_THREAD_STATE_WAITING = 0x0080,
+    JVMTI_THREAD_STATE_WAITING_INDEFINITELY = 0x0010,
+    JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT = 0x0020,
+    JVMTI_THREAD_STATE_SLEEPING = 0x0040,
+    JVMTI_THREAD_STATE_IN_OBJECT_WAIT = 0x0100,
+    JVMTI_THREAD_STATE_PARKED = 0x0200,
+    JVMTI_THREAD_STATE_SUSPENDED = 0x100000,
+    JVMTI_THREAD_STATE_INTERRUPTED = 0x200000,
+    JVMTI_THREAD_STATE_IN_NATIVE = 0x400000,
+    JVMTI_THREAD_STATE_VENDOR_1 = 0x10000000,
+    JVMTI_THREAD_STATE_VENDOR_2 = 0x20000000,
+    JVMTI_THREAD_STATE_VENDOR_3 = 0x40000000
+};
+enum {
+    JVMTI_JAVA_LANG_THREAD_STATE_MASK = JVMTI_THREAD_STATE_TERMINATED | JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_RUNNABLE | JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER | JVMTI_THREAD_STATE_WAITING | JVMTI_THREAD_STATE_WAITING_INDEFINITELY | JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT,
+    JVMTI_JAVA_LANG_THREAD_STATE_NEW = 0,
+    JVMTI_JAVA_LANG_THREAD_STATE_TERMINATED = JVMTI_THREAD_STATE_TERMINATED,
+    JVMTI_JAVA_LANG_THREAD_STATE_RUNNABLE = JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_RUNNABLE,
+    JVMTI_JAVA_LANG_THREAD_STATE_BLOCKED = JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER,
+    JVMTI_JAVA_LANG_THREAD_STATE_WAITING = JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_WAITING | JVMTI_THREAD_STATE_WAITING_INDEFINITELY,
+    JVMTI_JAVA_LANG_THREAD_STATE_TIMED_WAITING = JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_WAITING | JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT
+};
+enum {
+    JVMTI_THREAD_MIN_PRIORITY = 1,
+    JVMTI_THREAD_NORM_PRIORITY = 5,
+    JVMTI_THREAD_MAX_PRIORITY = 10
+};
+enum {
+    JVMTI_HEAP_FILTER_TAGGED = 0x4,
+    JVMTI_HEAP_FILTER_UNTAGGED = 0x8,
+    JVMTI_HEAP_FILTER_CLASS_TAGGED = 0x10,
+    JVMTI_HEAP_FILTER_CLASS_UNTAGGED = 0x20
+};
+enum {
+    JVMTI_VISIT_OBJECTS = 0x100,
+    JVMTI_VISIT_ABORT = 0x8000
+};
+typedef enum {
+    JVMTI_HEAP_REFERENCE_CLASS = 1,
+    JVMTI_HEAP_REFERENCE_FIELD = 2,
+    JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT = 3,
+    JVMTI_HEAP_REFERENCE_CLASS_LOADER = 4,
+    JVMTI_HEAP_REFERENCE_SIGNERS = 5,
+    JVMTI_HEAP_REFERENCE_PROTECTION_DOMAIN = 6,
+    JVMTI_HEAP_REFERENCE_INTERFACE = 7,
+    JVMTI_HEAP_REFERENCE_STATIC_FIELD = 8,
+    JVMTI_HEAP_REFERENCE_CONSTANT_POOL = 9,
+    JVMTI_HEAP_REFERENCE_SUPERCLASS = 10,
+    JVMTI_HEAP_REFERENCE_JNI_GLOBAL = 21,
+    JVMTI_HEAP_REFERENCE_SYSTEM_CLASS = 22,
+    JVMTI_HEAP_REFERENCE_MONITOR = 23,
+    JVMTI_HEAP_REFERENCE_STACK_LOCAL = 24,
+    JVMTI_HEAP_REFERENCE_JNI_LOCAL = 25,
+    JVMTI_HEAP_REFERENCE_THREAD = 26,
+    JVMTI_HEAP_REFERENCE_OTHER = 27
+} jvmtiHeapReferenceKind;
+typedef enum {
+    JVMTI_PRIMITIVE_TYPE_BOOLEAN = 90,
+    JVMTI_PRIMITIVE_TYPE_BYTE = 66,
+    JVMTI_PRIMITIVE_TYPE_CHAR = 67,
+    JVMTI_PRIMITIVE_TYPE_SHORT = 83,
+    JVMTI_PRIMITIVE_TYPE_INT = 73,
+    JVMTI_PRIMITIVE_TYPE_LONG = 74,
+    JVMTI_PRIMITIVE_TYPE_FLOAT = 70,
+    JVMTI_PRIMITIVE_TYPE_DOUBLE = 68
+} jvmtiPrimitiveType;
+typedef enum {
+    JVMTI_HEAP_OBJECT_TAGGED = 1,
+    JVMTI_HEAP_OBJECT_UNTAGGED = 2,
+    JVMTI_HEAP_OBJECT_EITHER = 3
+} jvmtiHeapObjectFilter;
+typedef enum {
+    JVMTI_HEAP_ROOT_JNI_GLOBAL = 1,
+    JVMTI_HEAP_ROOT_SYSTEM_CLASS = 2,
+    JVMTI_HEAP_ROOT_MONITOR = 3,
+    JVMTI_HEAP_ROOT_STACK_LOCAL = 4,
+    JVMTI_HEAP_ROOT_JNI_LOCAL = 5,
+    JVMTI_HEAP_ROOT_THREAD = 6,
+    JVMTI_HEAP_ROOT_OTHER = 7
+} jvmtiHeapRootKind;
+typedef enum {
+    JVMTI_REFERENCE_CLASS = 1,
+    JVMTI_REFERENCE_FIELD = 2,
+    JVMTI_REFERENCE_ARRAY_ELEMENT = 3,
+    JVMTI_REFERENCE_CLASS_LOADER = 4,
+    JVMTI_REFERENCE_SIGNERS = 5,
+    JVMTI_REFERENCE_PROTECTION_DOMAIN = 6,
+    JVMTI_REFERENCE_INTERFACE = 7,
+    JVMTI_REFERENCE_STATIC_FIELD = 8,
+    JVMTI_REFERENCE_CONSTANT_POOL = 9
+} jvmtiObjectReferenceKind;
+typedef enum {
+    JVMTI_ITERATION_CONTINUE = 1,
+    JVMTI_ITERATION_IGNORE = 2,
+    JVMTI_ITERATION_ABORT = 0
+} jvmtiIterationControl;
+enum {
+    JVMTI_CLASS_STATUS_VERIFIED = 1,
+    JVMTI_CLASS_STATUS_PREPARED = 2,
+    JVMTI_CLASS_STATUS_INITIALIZED = 4,
+    JVMTI_CLASS_STATUS_ERROR = 8,
+    JVMTI_CLASS_STATUS_ARRAY = 16,
+    JVMTI_CLASS_STATUS_PRIMITIVE = 32
+};
+typedef enum {
+    JVMTI_ENABLE = 1,
+    JVMTI_DISABLE = 0
+} jvmtiEventMode;
+typedef enum {
+    JVMTI_TYPE_JBYTE = 101,
+    JVMTI_TYPE_JCHAR = 102,
+    JVMTI_TYPE_JSHORT = 103,
+    JVMTI_TYPE_JINT = 104,
+    JVMTI_TYPE_JLONG = 105,
+    JVMTI_TYPE_JFLOAT = 106,
+    JVMTI_TYPE_JDOUBLE = 107,
+    JVMTI_TYPE_JBOOLEAN = 108,
+    JVMTI_TYPE_JOBJECT = 109,
+    JVMTI_TYPE_JTHREAD = 110,
+    JVMTI_TYPE_JCLASS = 111,
+    JVMTI_TYPE_JVALUE = 112,
+    JVMTI_TYPE_JFIELDID = 113,
+    JVMTI_TYPE_JMETHODID = 114,
+    JVMTI_TYPE_CCHAR = 115,
+    JVMTI_TYPE_CVOID = 116,
+    JVMTI_TYPE_JNIENV = 117
+} jvmtiParamTypes;
+typedef enum {
+    JVMTI_KIND_IN = 91,
+    JVMTI_KIND_IN_PTR = 92,
+    JVMTI_KIND_IN_BUF = 93,
+    JVMTI_KIND_ALLOC_BUF = 94,
+    JVMTI_KIND_ALLOC_ALLOC_BUF = 95,
+    JVMTI_KIND_OUT = 96,
+    JVMTI_KIND_OUT_BUF = 97
+} jvmtiParamKind;
+typedef enum {
+    JVMTI_TIMER_USER_CPU = 30,
+    JVMTI_TIMER_TOTAL_CPU = 31,
+    JVMTI_TIMER_ELAPSED = 32
+} jvmtiTimerKind;
+typedef enum {
+    JVMTI_PHASE_ONLOAD = 1,
+    JVMTI_PHASE_PRIMORDIAL = 2,
+    JVMTI_PHASE_START = 6,
+    JVMTI_PHASE_LIVE = 4,
+    JVMTI_PHASE_DEAD = 8
+} jvmtiPhase;
+enum {
+    JVMTI_VERSION_INTERFACE_JNI = 0x00000000,
+    JVMTI_VERSION_INTERFACE_JVMTI = 0x30000000
+};
+enum {
+    JVMTI_VERSION_MASK_INTERFACE_TYPE = 0x70000000,
+    JVMTI_VERSION_MASK_MAJOR = 0x0FFF0000,
+    JVMTI_VERSION_MASK_MINOR = 0x0000FF00,
+    JVMTI_VERSION_MASK_MICRO = 0x000000FF
+};
+enum {
+    JVMTI_VERSION_SHIFT_MAJOR = 16,
+    JVMTI_VERSION_SHIFT_MINOR = 8,
+    JVMTI_VERSION_SHIFT_MICRO = 0
+};
+typedef enum {
+    JVMTI_VERBOSE_OTHER = 0,
+    JVMTI_VERBOSE_GC = 1,
+    JVMTI_VERBOSE_CLASS = 2,
+    JVMTI_VERBOSE_JNI = 4
+} jvmtiVerboseFlag;
+typedef enum {
+    JVMTI_JLOCATION_JVMBCI = 1,
+    JVMTI_JLOCATION_MACHINEPC = 2,
+    JVMTI_JLOCATION_OTHER = 0
+} jvmtiJlocationFormat;
+enum {
+    JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR = 0x0001,
+    JVMTI_RESOURCE_EXHAUSTED_JAVA_HEAP = 0x0002,
+    JVMTI_RESOURCE_EXHAUSTED_THREADS = 0x0004
+};
+typedef enum {
+    JVMTI_ERROR_NONE = 0,
+    JVMTI_ERROR_INVALID_THREAD = 10,
+    JVMTI_ERROR_INVALID_THREAD_GROUP = 11,
+    JVMTI_ERROR_INVALID_PRIORITY = 12,
+    JVMTI_ERROR_THREAD_NOT_SUSPENDED = 13,
+    JVMTI_ERROR_THREAD_SUSPENDED = 14,
+    JVMTI_ERROR_THREAD_NOT_ALIVE = 15,
+    JVMTI_ERROR_INVALID_OBJECT = 20,
+    JVMTI_ERROR_INVALID_CLASS = 21,
+    JVMTI_ERROR_CLASS_NOT_PREPARED = 22,
+    JVMTI_ERROR_INVALID_METHODID = 23,
+    JVMTI_ERROR_INVALID_LOCATION = 24,
+    JVMTI_ERROR_INVALID_FIELDID = 25,
+    JVMTI_ERROR_NO_MORE_FRAMES = 31,
+    JVMTI_ERROR_OPAQUE_FRAME = 32,
+    JVMTI_ERROR_TYPE_MISMATCH = 34,
+    JVMTI_ERROR_INVALID_SLOT = 35,
+    JVMTI_ERROR_DUPLICATE = 40,
+    JVMTI_ERROR_NOT_FOUND = 41,
+    JVMTI_ERROR_INVALID_MONITOR = 50,
+    JVMTI_ERROR_NOT_MONITOR_OWNER = 51,
+    JVMTI_ERROR_INTERRUPT = 52,
+    JVMTI_ERROR_INVALID_CLASS_FORMAT = 60,
+    JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION = 61,
+    JVMTI_ERROR_FAILS_VERIFICATION = 62,
+    JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED = 63,
+    JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED = 64,
+    JVMTI_ERROR_INVALID_TYPESTATE = 65,
+    JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED = 66,
+    JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED = 67,
+    JVMTI_ERROR_UNSUPPORTED_VERSION = 68,
+    JVMTI_ERROR_NAMES_DONT_MATCH = 69,
+    JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED = 70,
+    JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED = 71,
+    JVMTI_ERROR_UNMODIFIABLE_CLASS = 79,
+    JVMTI_ERROR_NOT_AVAILABLE = 98,
+    JVMTI_ERROR_MUST_POSSESS_CAPABILITY = 99,
+    JVMTI_ERROR_NULL_POINTER = 100,
+    JVMTI_ERROR_ABSENT_INFORMATION = 101,
+    JVMTI_ERROR_INVALID_EVENT_TYPE = 102,
+    JVMTI_ERROR_ILLEGAL_ARGUMENT = 103,
+    JVMTI_ERROR_NATIVE_METHOD = 104,
+    JVMTI_ERROR_CLASS_LOADER_UNSUPPORTED = 106,
+    JVMTI_ERROR_OUT_OF_MEMORY = 110,
+    JVMTI_ERROR_ACCESS_DENIED = 111,
+    JVMTI_ERROR_WRONG_PHASE = 112,
+    JVMTI_ERROR_INTERNAL = 113,
+    JVMTI_ERROR_UNATTACHED_THREAD = 115,
+    JVMTI_ERROR_INVALID_ENVIRONMENT = 116,
+    JVMTI_ERROR_MAX = 116
+} jvmtiError;
+typedef enum {
+    JVMTI_MIN_EVENT_TYPE_VAL = 50,
+    JVMTI_EVENT_VM_INIT = 50,
+    JVMTI_EVENT_VM_DEATH = 51,
+    JVMTI_EVENT_THREAD_START = 52,
+    JVMTI_EVENT_THREAD_END = 53,
+    JVMTI_EVENT_CLASS_FILE_LOAD_HOOK = 54,
+    JVMTI_EVENT_CLASS_LOAD = 55,
+    JVMTI_EVENT_CLASS_PREPARE = 56,
+    JVMTI_EVENT_VM_START = 57,
+    JVMTI_EVENT_EXCEPTION = 58,
+    JVMTI_EVENT_EXCEPTION_CATCH = 59,
+    JVMTI_EVENT_SINGLE_STEP = 60,
+    JVMTI_EVENT_FRAME_POP = 61,
+    JVMTI_EVENT_BREAKPOINT = 62,
+    JVMTI_EVENT_FIELD_ACCESS = 63,
+    JVMTI_EVENT_FIELD_MODIFICATION = 64,
+    JVMTI_EVENT_METHOD_ENTRY = 65,
+    JVMTI_EVENT_METHOD_EXIT = 66,
+    JVMTI_EVENT_NATIVE_METHOD_BIND = 67,
+    JVMTI_EVENT_COMPILED_METHOD_LOAD = 68,
+    JVMTI_EVENT_COMPILED_METHOD_UNLOAD = 69,
+    JVMTI_EVENT_DYNAMIC_CODE_GENERATED = 70,
+    JVMTI_EVENT_DATA_DUMP_REQUEST = 71,
+    JVMTI_EVENT_MONITOR_WAIT = 73,
+    JVMTI_EVENT_MONITOR_WAITED = 74,
+    JVMTI_EVENT_MONITOR_CONTENDED_ENTER = 75,
+    JVMTI_EVENT_MONITOR_CONTENDED_ENTERED = 76,
+    JVMTI_EVENT_RESOURCE_EXHAUSTED = 80,
+    JVMTI_EVENT_GARBAGE_COLLECTION_START = 81,
+    JVMTI_EVENT_GARBAGE_COLLECTION_FINISH = 82,
+    JVMTI_EVENT_OBJECT_FREE = 83,
+    JVMTI_EVENT_VM_OBJECT_ALLOC = 84,
+    JVMTI_MAX_EVENT_TYPE_VAL = 84
+} jvmtiEvent;
+struct _jvmtiThreadInfo;
+typedef struct _jvmtiThreadInfo jvmtiThreadInfo;
+struct _jvmtiMonitorStackDepthInfo;
+typedef struct _jvmtiMonitorStackDepthInfo jvmtiMonitorStackDepthInfo;
+struct _jvmtiThreadGroupInfo;
+typedef struct _jvmtiThreadGroupInfo jvmtiThreadGroupInfo;
+struct _jvmtiFrameInfo;
+typedef struct _jvmtiFrameInfo jvmtiFrameInfo;
+struct _jvmtiStackInfo;
+typedef struct _jvmtiStackInfo jvmtiStackInfo;
+struct _jvmtiHeapReferenceInfoField;
+typedef struct _jvmtiHeapReferenceInfoField jvmtiHeapReferenceInfoField;
+struct _jvmtiHeapReferenceInfoArray;
+typedef struct _jvmtiHeapReferenceInfoArray jvmtiHeapReferenceInfoArray;
+struct _jvmtiHeapReferenceInfoConstantPool;
+typedef struct _jvmtiHeapReferenceInfoConstantPool jvmtiHeapReferenceInfoConstantPool;
+struct _jvmtiHeapReferenceInfoStackLocal;
+typedef struct _jvmtiHeapReferenceInfoStackLocal jvmtiHeapReferenceInfoStackLocal;
+struct _jvmtiHeapReferenceInfoJniLocal;
+typedef struct _jvmtiHeapReferenceInfoJniLocal jvmtiHeapReferenceInfoJniLocal;
+struct _jvmtiHeapReferenceInfoReserved;
+typedef struct _jvmtiHeapReferenceInfoReserved jvmtiHeapReferenceInfoReserved;
+union _jvmtiHeapReferenceInfo;
+typedef union _jvmtiHeapReferenceInfo jvmtiHeapReferenceInfo;
+struct _jvmtiHeapCallbacks;
+typedef struct _jvmtiHeapCallbacks jvmtiHeapCallbacks;
+struct _jvmtiClassDefinition;
+typedef struct _jvmtiClassDefinition jvmtiClassDefinition;
+struct _jvmtiMonitorUsage;
+typedef struct _jvmtiMonitorUsage jvmtiMonitorUsage;
+struct _jvmtiLineNumberEntry;
+typedef struct _jvmtiLineNumberEntry jvmtiLineNumberEntry;
+struct _jvmtiLocalVariableEntry;
+typedef struct _jvmtiLocalVariableEntry jvmtiLocalVariableEntry;
+struct _jvmtiParamInfo;
+typedef struct _jvmtiParamInfo jvmtiParamInfo;
+struct _jvmtiExtensionFunctionInfo;
+typedef struct _jvmtiExtensionFunctionInfo jvmtiExtensionFunctionInfo;
+struct _jvmtiExtensionEventInfo;
+typedef struct _jvmtiExtensionEventInfo jvmtiExtensionEventInfo;
+struct _jvmtiTimerInfo;
+typedef struct _jvmtiTimerInfo jvmtiTimerInfo;
+struct _jvmtiAddrLocationMap;
+typedef struct _jvmtiAddrLocationMap jvmtiAddrLocationMap;
+typedef void ( *jvmtiStartFunction)
+    (jvmtiEnv* jvmti_env, JNIEnv* jni_env, void* arg);
+typedef jint ( *jvmtiHeapIterationCallback)
+    (jlong class_tag, jlong size, jlong* tag_ptr, jint length, void* user_data);
+typedef jint ( *jvmtiHeapReferenceCallback)
+    (jvmtiHeapReferenceKind reference_kind, const jvmtiHeapReferenceInfo* reference_info, jlong class_tag, jlong referrer_class_tag, jlong size, jlong* tag_ptr, jlong* referrer_tag_ptr, jint length, void* user_data);
+typedef jint ( *jvmtiPrimitiveFieldCallback)
+    (jvmtiHeapReferenceKind kind, const jvmtiHeapReferenceInfo* info, jlong object_class_tag, jlong* object_tag_ptr, jvalue value, jvmtiPrimitiveType value_type, void* user_data);
+typedef jint ( *jvmtiArrayPrimitiveValueCallback)
+    (jlong class_tag, jlong size, jlong* tag_ptr, jint element_count, jvmtiPrimitiveType element_type, const void* elements, void* user_data);
+typedef jint ( *jvmtiStringPrimitiveValueCallback)
+    (jlong class_tag, jlong size, jlong* tag_ptr, const jchar* value, jint value_length, void* user_data);
+typedef jint ( *jvmtiReservedCallback)
+    ();
+typedef jvmtiIterationControl ( *jvmtiHeapObjectCallback)
+    (jlong class_tag, jlong size, jlong* tag_ptr, void* user_data);
+typedef jvmtiIterationControl ( *jvmtiHeapRootCallback)
+    (jvmtiHeapRootKind root_kind, jlong class_tag, jlong size, jlong* tag_ptr, void* user_data);
+typedef jvmtiIterationControl ( *jvmtiStackReferenceCallback)
+    (jvmtiHeapRootKind root_kind, jlong class_tag, jlong size, jlong* tag_ptr, jlong thread_tag, jint depth, jmethodID method, jint slot, void* user_data);
+typedef jvmtiIterationControl ( *jvmtiObjectReferenceCallback)
+    (jvmtiObjectReferenceKind reference_kind, jlong class_tag, jlong size, jlong* tag_ptr, jlong referrer_tag, jint referrer_index, void* user_data);
+typedef jvmtiError ( *jvmtiExtensionFunction)
+    (jvmtiEnv* jvmti_env, ...);
+typedef void ( *jvmtiExtensionEvent)
+    (jvmtiEnv* jvmti_env, ...);
+struct _jvmtiThreadInfo {
+    char* name;
+    jint priority;
+    jboolean is_daemon;
+    jthreadGroup thread_group;
+    jobject context_class_loader;
+};
+struct _jvmtiMonitorStackDepthInfo {
+    jobject monitor;
+    jint stack_depth;
+};
+struct _jvmtiThreadGroupInfo {
+    jthreadGroup parent;
+    char* name;
+    jint max_priority;
+    jboolean is_daemon;
+};
+struct _jvmtiFrameInfo {
+    jmethodID method;
+    jlocation location;
+};
+struct _jvmtiStackInfo {
+    jthread thread;
+    jint state;
+    jvmtiFrameInfo* frame_buffer;
+    jint frame_count;
+};
+struct _jvmtiHeapReferenceInfoField {
+    jint index;
+};
+struct _jvmtiHeapReferenceInfoArray {
+    jint index;
+};
+struct _jvmtiHeapReferenceInfoConstantPool {
+    jint index;
+};
+struct _jvmtiHeapReferenceInfoStackLocal {
+    jlong thread_tag;
+    jlong thread_id;
+    jint depth;
+    jmethodID method;
+    jlocation location;
+    jint slot;
+};
+struct _jvmtiHeapReferenceInfoJniLocal {
+    jlong thread_tag;
+    jlong thread_id;
+    jint depth;
+    jmethodID method;
+};
+struct _jvmtiHeapReferenceInfoReserved {
+    jlong reserved1;
+    jlong reserved2;
+    jlong reserved3;
+    jlong reserved4;
+    jlong reserved5;
+    jlong reserved6;
+    jlong reserved7;
+    jlong reserved8;
+};
+union _jvmtiHeapReferenceInfo {
+    jvmtiHeapReferenceInfoField field;
+    jvmtiHeapReferenceInfoArray array;
+    jvmtiHeapReferenceInfoConstantPool constant_pool;
+    jvmtiHeapReferenceInfoStackLocal stack_local;
+    jvmtiHeapReferenceInfoJniLocal jni_local;
+    jvmtiHeapReferenceInfoReserved other;
+};
+struct _jvmtiHeapCallbacks {
+    jvmtiHeapIterationCallback heap_iteration_callback;
+    jvmtiHeapReferenceCallback heap_reference_callback;
+    jvmtiPrimitiveFieldCallback primitive_field_callback;
+    jvmtiArrayPrimitiveValueCallback array_primitive_value_callback;
+    jvmtiStringPrimitiveValueCallback string_primitive_value_callback;
+    jvmtiReservedCallback reserved5;
+    jvmtiReservedCallback reserved6;
+    jvmtiReservedCallback reserved7;
+    jvmtiReservedCallback reserved8;
+    jvmtiReservedCallback reserved9;
+    jvmtiReservedCallback reserved10;
+    jvmtiReservedCallback reserved11;
+    jvmtiReservedCallback reserved12;
+    jvmtiReservedCallback reserved13;
+    jvmtiReservedCallback reserved14;
+    jvmtiReservedCallback reserved15;
+};
+struct _jvmtiClassDefinition {
+    jclass klass;
+    jint class_byte_count;
+    const unsigned char* class_bytes;
+};
+struct _jvmtiMonitorUsage {
+    jthread owner;
+    jint entry_count;
+    jint waiter_count;
+    jthread* waiters;
+    jint notify_waiter_count;
+    jthread* notify_waiters;
+};
+struct _jvmtiLineNumberEntry {
+    jlocation start_location;
+    jint line_number;
+};
+struct _jvmtiLocalVariableEntry {
+    jlocation start_location;
+    jint length;
+    char* name;
+    char* signature;
+    char* generic_signature;
+    jint slot;
+};
+struct _jvmtiParamInfo {
+    char* name;
+    jvmtiParamKind kind;
+    jvmtiParamTypes base_type;
+    jboolean null_ok;
+};
+struct _jvmtiExtensionFunctionInfo {
+    jvmtiExtensionFunction func;
+    char* id;
+    char* short_description;
+    jint param_count;
+    jvmtiParamInfo* params;
+    jint error_count;
+    jvmtiError* errors;
+};
+struct _jvmtiExtensionEventInfo {
+    jint extension_event_index;
+    char* id;
+    char* short_description;
+    jint param_count;
+    jvmtiParamInfo* params;
+};
+struct _jvmtiTimerInfo {
+    jlong max_value;
+    jboolean may_skip_forward;
+    jboolean may_skip_backward;
+    jvmtiTimerKind kind;
+    jlong reserved1;
+    jlong reserved2;
+};
+struct _jvmtiAddrLocationMap {
+    const void* start_address;
+    jlocation location;
+};
+typedef struct {
+    unsigned int can_tag_objects : 1;
+    unsigned int can_generate_field_modification_events : 1;
+    unsigned int can_generate_field_access_events : 1;
+    unsigned int can_get_bytecodes : 1;
+    unsigned int can_get_synthetic_attribute : 1;
+    unsigned int can_get_owned_monitor_info : 1;
+    unsigned int can_get_current_contended_monitor : 1;
+    unsigned int can_get_monitor_info : 1;
+    unsigned int can_pop_frame : 1;
+    unsigned int can_redefine_classes : 1;
+    unsigned int can_signal_thread : 1;
+    unsigned int can_get_source_file_name : 1;
+    unsigned int can_get_line_numbers : 1;
+    unsigned int can_get_source_debug_extension : 1;
+    unsigned int can_access_local_variables : 1;
+    unsigned int can_maintain_original_method_order : 1;
+    unsigned int can_generate_single_step_events : 1;
+    unsigned int can_generate_exception_events : 1;
+    unsigned int can_generate_frame_pop_events : 1;
+    unsigned int can_generate_breakpoint_events : 1;
+    unsigned int can_suspend : 1;
+    unsigned int can_redefine_any_class : 1;
+    unsigned int can_get_current_thread_cpu_time : 1;
+    unsigned int can_get_thread_cpu_time : 1;
+    unsigned int can_generate_method_entry_events : 1;
+    unsigned int can_generate_method_exit_events : 1;
+    unsigned int can_generate_all_class_hook_events : 1;
+    unsigned int can_generate_compiled_method_load_events : 1;
+    unsigned int can_generate_monitor_events : 1;
+    unsigned int can_generate_vm_object_alloc_events : 1;
+    unsigned int can_generate_native_method_bind_events : 1;
+    unsigned int can_generate_garbage_collection_events : 1;
+    unsigned int can_generate_object_free_events : 1;
+    unsigned int can_force_early_return : 1;
+    unsigned int can_get_owned_monitor_stack_depth_info : 1;
+    unsigned int can_get_constant_pool : 1;
+    unsigned int can_set_native_method_prefix : 1;
+    unsigned int can_retransform_classes : 1;
+    unsigned int can_retransform_any_class : 1;
+    unsigned int can_generate_resource_exhaustion_heap_events : 1;
+    unsigned int can_generate_resource_exhaustion_threads_events : 1;
+    unsigned int : 7;
+    unsigned int : 16;
+    unsigned int : 16;
+    unsigned int : 16;
+    unsigned int : 16;
+    unsigned int : 16;
+} jvmtiCapabilities;
+typedef void ( *jvmtiEventReserved)(void);
+typedef void ( *jvmtiEventBreakpoint)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread,
+     jmethodID method,
+     jlocation location);
+typedef void ( *jvmtiEventClassFileLoadHook)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jclass class_being_redefined,
+     jobject loader,
+     const char* name,
+     jobject protection_domain,
+     jint class_data_len,
+     const unsigned char* class_data,
+     jint* new_class_data_len,
+     unsigned char** new_class_data);
+typedef void ( *jvmtiEventClassLoad)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread,
+     jclass klass);
+typedef void ( *jvmtiEventClassPrepare)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread,
+     jclass klass);
+typedef void ( *jvmtiEventCompiledMethodLoad)
+    (jvmtiEnv *jvmti_env,
+     jmethodID method,
+     jint code_size,
+     const void* code_addr,
+     jint map_length,
+     const jvmtiAddrLocationMap* map,
+     const void* compile_info);
+typedef void ( *jvmtiEventCompiledMethodUnload)
+    (jvmtiEnv *jvmti_env,
+     jmethodID method,
+     const void* code_addr);
+typedef void ( *jvmtiEventDataDumpRequest)
+    (jvmtiEnv *jvmti_env);
+typedef void ( *jvmtiEventDynamicCodeGenerated)
+    (jvmtiEnv *jvmti_env,
+     const char* name,
+     const void* address,
+     jint length);
+typedef void ( *jvmtiEventException)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread,
+     jmethodID method,
+     jlocation location,
+     jobject exception,
+     jmethodID catch_method,
+     jlocation catch_location);
+typedef void ( *jvmtiEventExceptionCatch)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread,
+     jmethodID method,
+     jlocation location,
+     jobject exception);
+typedef void ( *jvmtiEventFieldAccess)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread,
+     jmethodID method,
+     jlocation location,
+     jclass field_klass,
+     jobject object,
+     jfieldID field);
+typedef void ( *jvmtiEventFieldModification)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread,
+     jmethodID method,
+     jlocation location,
+     jclass field_klass,
+     jobject object,
+     jfieldID field,
+     char signature_type,
+     jvalue new_value);
+typedef void ( *jvmtiEventFramePop)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread,
+     jmethodID method,
+     jboolean was_popped_by_exception);
+typedef void ( *jvmtiEventGarbageCollectionFinish)
+    (jvmtiEnv *jvmti_env);
+typedef void ( *jvmtiEventGarbageCollectionStart)
+    (jvmtiEnv *jvmti_env);
+typedef void ( *jvmtiEventMethodEntry)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread,
+     jmethodID method);
+typedef void ( *jvmtiEventMethodExit)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread,
+     jmethodID method,
+     jboolean was_popped_by_exception,
+     jvalue return_value);
+typedef void ( *jvmtiEventMonitorContendedEnter)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread,
+     jobject object);
+typedef void ( *jvmtiEventMonitorContendedEntered)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread,
+     jobject object);
+typedef void ( *jvmtiEventMonitorWait)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread,
+     jobject object,
+     jlong timeout);
+typedef void ( *jvmtiEventMonitorWaited)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread,
+     jobject object,
+     jboolean timed_out);
+typedef void ( *jvmtiEventNativeMethodBind)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread,
+     jmethodID method,
+     void* address,
+     void** new_address_ptr);
+typedef void ( *jvmtiEventObjectFree)
+    (jvmtiEnv *jvmti_env,
+     jlong tag);
+typedef void ( *jvmtiEventResourceExhausted)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jint flags,
+     const void* reserved,
+     const char* description);
+typedef void ( *jvmtiEventSingleStep)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread,
+     jmethodID method,
+     jlocation location);
+typedef void ( *jvmtiEventThreadEnd)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread);
+typedef void ( *jvmtiEventThreadStart)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread);
+typedef void ( *jvmtiEventVMDeath)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env);
+typedef void ( *jvmtiEventVMInit)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread);
+typedef void ( *jvmtiEventVMObjectAlloc)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env,
+     jthread thread,
+     jobject object,
+     jclass object_klass,
+     jlong size);
+typedef void ( *jvmtiEventVMStart)
+    (jvmtiEnv *jvmti_env,
+     JNIEnv* jni_env);
+typedef struct {
+    jvmtiEventVMInit VMInit;
+    jvmtiEventVMDeath VMDeath;
+    jvmtiEventThreadStart ThreadStart;
+    jvmtiEventThreadEnd ThreadEnd;
+    jvmtiEventClassFileLoadHook ClassFileLoadHook;
+    jvmtiEventClassLoad ClassLoad;
+    jvmtiEventClassPrepare ClassPrepare;
+    jvmtiEventVMStart VMStart;
+    jvmtiEventException Exception;
+    jvmtiEventExceptionCatch ExceptionCatch;
+    jvmtiEventSingleStep SingleStep;
+    jvmtiEventFramePop FramePop;
+    jvmtiEventBreakpoint Breakpoint;
+    jvmtiEventFieldAccess FieldAccess;
+    jvmtiEventFieldModification FieldModification;
+    jvmtiEventMethodEntry MethodEntry;
+    jvmtiEventMethodExit MethodExit;
+    jvmtiEventNativeMethodBind NativeMethodBind;
+    jvmtiEventCompiledMethodLoad CompiledMethodLoad;
+    jvmtiEventCompiledMethodUnload CompiledMethodUnload;
+    jvmtiEventDynamicCodeGenerated DynamicCodeGenerated;
+    jvmtiEventDataDumpRequest DataDumpRequest;
+    jvmtiEventReserved reserved72;
+    jvmtiEventMonitorWait MonitorWait;
+    jvmtiEventMonitorWaited MonitorWaited;
+    jvmtiEventMonitorContendedEnter MonitorContendedEnter;
+    jvmtiEventMonitorContendedEntered MonitorContendedEntered;
+    jvmtiEventReserved reserved77;
+    jvmtiEventReserved reserved78;
+    jvmtiEventReserved reserved79;
+    jvmtiEventResourceExhausted ResourceExhausted;
+    jvmtiEventGarbageCollectionStart GarbageCollectionStart;
+    jvmtiEventGarbageCollectionFinish GarbageCollectionFinish;
+    jvmtiEventObjectFree ObjectFree;
+    jvmtiEventVMObjectAlloc VMObjectAlloc;
+} jvmtiEventCallbacks;
+typedef struct jvmtiInterface_1_ {
+  void *reserved1;
+  jvmtiError ( *SetEventNotificationMode) (jvmtiEnv* env,
+    jvmtiEventMode mode,
+    jvmtiEvent event_type,
+    jthread event_thread,
+     ...);
+  void *reserved3;
+  jvmtiError ( *GetAllThreads) (jvmtiEnv* env,
+    jint* threads_count_ptr,
+    jthread** threads_ptr);
+  jvmtiError ( *SuspendThread) (jvmtiEnv* env,
+    jthread thread);
+  jvmtiError ( *ResumeThread) (jvmtiEnv* env,
+    jthread thread);
+  jvmtiError ( *StopThread) (jvmtiEnv* env,
+    jthread thread,
+    jobject exception);
+  jvmtiError ( *InterruptThread) (jvmtiEnv* env,
+    jthread thread);
+  jvmtiError ( *GetThreadInfo) (jvmtiEnv* env,
+    jthread thread,
+    jvmtiThreadInfo* info_ptr);
+  jvmtiError ( *GetOwnedMonitorInfo) (jvmtiEnv* env,
+    jthread thread,
+    jint* owned_monitor_count_ptr,
+    jobject** owned_monitors_ptr);
+  jvmtiError ( *GetCurrentContendedMonitor) (jvmtiEnv* env,
+    jthread thread,
+    jobject* monitor_ptr);
+  jvmtiError ( *RunAgentThread) (jvmtiEnv* env,
+    jthread thread,
+    jvmtiStartFunction proc,
+    const void* arg,
+    jint priority);
+  jvmtiError ( *GetTopThreadGroups) (jvmtiEnv* env,
+    jint* group_count_ptr,
+    jthreadGroup** groups_ptr);
+  jvmtiError ( *GetThreadGroupInfo) (jvmtiEnv* env,
+    jthreadGroup group,
+    jvmtiThreadGroupInfo* info_ptr);
+  jvmtiError ( *GetThreadGroupChildren) (jvmtiEnv* env,
+    jthreadGroup group,
+    jint* thread_count_ptr,
+    jthread** threads_ptr,
+    jint* group_count_ptr,
+    jthreadGroup** groups_ptr);
+  jvmtiError ( *GetFrameCount) (jvmtiEnv* env,
+    jthread thread,
+    jint* count_ptr);
+  jvmtiError ( *GetThreadState) (jvmtiEnv* env,
+    jthread thread,
+    jint* thread_state_ptr);
+  jvmtiError ( *GetCurrentThread) (jvmtiEnv* env,
+    jthread* thread_ptr);
+  jvmtiError ( *GetFrameLocation) (jvmtiEnv* env,
+    jthread thread,
+    jint depth,
+    jmethodID* method_ptr,
+    jlocation* location_ptr);
+  jvmtiError ( *NotifyFramePop) (jvmtiEnv* env,
+    jthread thread,
+    jint depth);
+  jvmtiError ( *GetLocalObject) (jvmtiEnv* env,
+    jthread thread,
+    jint depth,
+    jint slot,
+    jobject* value_ptr);
+  jvmtiError ( *GetLocalInt) (jvmtiEnv* env,
+    jthread thread,
+    jint depth,
+    jint slot,
+    jint* value_ptr);
+  jvmtiError ( *GetLocalLong) (jvmtiEnv* env,
+    jthread thread,
+    jint depth,
+    jint slot,
+    jlong* value_ptr);
+  jvmtiError ( *GetLocalFloat) (jvmtiEnv* env,
+    jthread thread,
+    jint depth,
+    jint slot,
+    jfloat* value_ptr);
+  jvmtiError ( *GetLocalDouble) (jvmtiEnv* env,
+    jthread thread,
+    jint depth,
+    jint slot,
+    jdouble* value_ptr);
+  jvmtiError ( *SetLocalObject) (jvmtiEnv* env,
+    jthread thread,
+    jint depth,
+    jint slot,
+    jobject value);
+  jvmtiError ( *SetLocalInt) (jvmtiEnv* env,
+    jthread thread,
+    jint depth,
+    jint slot,
+    jint value);
+  jvmtiError ( *SetLocalLong) (jvmtiEnv* env,
+    jthread thread,
+    jint depth,
+    jint slot,
+    jlong value);
+  jvmtiError ( *SetLocalFloat) (jvmtiEnv* env,
+    jthread thread,
+    jint depth,
+    jint slot,
+    jfloat value);
+  jvmtiError ( *SetLocalDouble) (jvmtiEnv* env,
+    jthread thread,
+    jint depth,
+    jint slot,
+    jdouble value);
+  jvmtiError ( *CreateRawMonitor) (jvmtiEnv* env,
+    const char* name,
+    jrawMonitorID* monitor_ptr);
+  jvmtiError ( *DestroyRawMonitor) (jvmtiEnv* env,
+    jrawMonitorID monitor);
+  jvmtiError ( *RawMonitorEnter) (jvmtiEnv* env,
+    jrawMonitorID monitor);
+  jvmtiError ( *RawMonitorExit) (jvmtiEnv* env,
+    jrawMonitorID monitor);
+  jvmtiError ( *RawMonitorWait) (jvmtiEnv* env,
+    jrawMonitorID monitor,
+    jlong millis);
+  jvmtiError ( *RawMonitorNotify) (jvmtiEnv* env,
+    jrawMonitorID monitor);
+  jvmtiError ( *RawMonitorNotifyAll) (jvmtiEnv* env,
+    jrawMonitorID monitor);
+  jvmtiError ( *SetBreakpoint) (jvmtiEnv* env,
+    jmethodID method,
+    jlocation location);
+  jvmtiError ( *ClearBreakpoint) (jvmtiEnv* env,
+    jmethodID method,
+    jlocation location);
+  void *reserved40;
+  jvmtiError ( *SetFieldAccessWatch) (jvmtiEnv* env,
+    jclass klass,
+    jfieldID field);
+  jvmtiError ( *ClearFieldAccessWatch) (jvmtiEnv* env,
+    jclass klass,
+    jfieldID field);
+  jvmtiError ( *SetFieldModificationWatch) (jvmtiEnv* env,
+    jclass klass,
+    jfieldID field);
+  jvmtiError ( *ClearFieldModificationWatch) (jvmtiEnv* env,
+    jclass klass,
+    jfieldID field);
+  jvmtiError ( *IsModifiableClass) (jvmtiEnv* env,
+    jclass klass,
+    jboolean* is_modifiable_class_ptr);
+  jvmtiError ( *Allocate) (jvmtiEnv* env,
+    jlong size,
+    unsigned char** mem_ptr);
+  jvmtiError ( *Deallocate) (jvmtiEnv* env,
+    unsigned char* mem);
+  jvmtiError ( *GetClassSignature) (jvmtiEnv* env,
+    jclass klass,
+    char** signature_ptr,
+    char** generic_ptr);
+  jvmtiError ( *GetClassStatus) (jvmtiEnv* env,
+    jclass klass,
+    jint* status_ptr);
+  jvmtiError ( *GetSourceFileName) (jvmtiEnv* env,
+    jclass klass,
+    char** source_name_ptr);
+  jvmtiError ( *GetClassModifiers) (jvmtiEnv* env,
+    jclass klass,
+    jint* modifiers_ptr);
+  jvmtiError ( *GetClassMethods) (jvmtiEnv* env,
+    jclass klass,
+    jint* method_count_ptr,
+    jmethodID** methods_ptr);
+  jvmtiError ( *GetClassFields) (jvmtiEnv* env,
+    jclass klass,
+    jint* field_count_ptr,
+    jfieldID** fields_ptr);
+  jvmtiError ( *GetImplementedInterfaces) (jvmtiEnv* env,
+    jclass klass,
+    jint* interface_count_ptr,
+    jclass** interfaces_ptr);
+  jvmtiError ( *IsInterface) (jvmtiEnv* env,
+    jclass klass,
+    jboolean* is_interface_ptr);
+  jvmtiError ( *IsArrayClass) (jvmtiEnv* env,
+    jclass klass,
+    jboolean* is_array_class_ptr);
+  jvmtiError ( *GetClassLoader) (jvmtiEnv* env,
+    jclass klass,
+    jobject* classloader_ptr);
+  jvmtiError ( *GetObjectHashCode) (jvmtiEnv* env,
+    jobject object,
+    jint* hash_code_ptr);
+  jvmtiError ( *GetObjectMonitorUsage) (jvmtiEnv* env,
+    jobject object,
+    jvmtiMonitorUsage* info_ptr);
+  jvmtiError ( *GetFieldName) (jvmtiEnv* env,
+    jclass klass,
+    jfieldID field,
+    char** name_ptr,
+    char** signature_ptr,
+    char** generic_ptr);
+  jvmtiError ( *GetFieldDeclaringClass) (jvmtiEnv* env,
+    jclass klass,
+    jfieldID field,
+    jclass* declaring_class_ptr);
+  jvmtiError ( *GetFieldModifiers) (jvmtiEnv* env,
+    jclass klass,
+    jfieldID field,
+    jint* modifiers_ptr);
+  jvmtiError ( *IsFieldSynthetic) (jvmtiEnv* env,
+    jclass klass,
+    jfieldID field,
+    jboolean* is_synthetic_ptr);
+  jvmtiError ( *GetMethodName) (jvmtiEnv* env,
+    jmethodID method,
+    char** name_ptr,
+    char** signature_ptr,
+    char** generic_ptr);
+  jvmtiError ( *GetMethodDeclaringClass) (jvmtiEnv* env,
+    jmethodID method,
+    jclass* declaring_class_ptr);
+  jvmtiError ( *GetMethodModifiers) (jvmtiEnv* env,
+    jmethodID method,
+    jint* modifiers_ptr);
+  void *reserved67;
+  jvmtiError ( *GetMaxLocals) (jvmtiEnv* env,
+    jmethodID method,
+    jint* max_ptr);
+  jvmtiError ( *GetArgumentsSize) (jvmtiEnv* env,
+    jmethodID method,
+    jint* size_ptr);
+  jvmtiError ( *GetLineNumberTable) (jvmtiEnv* env,
+    jmethodID method,
+    jint* entry_count_ptr,
+    jvmtiLineNumberEntry** table_ptr);
+  jvmtiError ( *GetMethodLocation) (jvmtiEnv* env,
+    jmethodID method,
+    jlocation* start_location_ptr,
+    jlocation* end_location_ptr);
+  jvmtiError ( *GetLocalVariableTable) (jvmtiEnv* env,
+    jmethodID method,
+    jint* entry_count_ptr,
+    jvmtiLocalVariableEntry** table_ptr);
+  jvmtiError ( *SetNativeMethodPrefix) (jvmtiEnv* env,
+    const char* prefix);
+  jvmtiError ( *SetNativeMethodPrefixes) (jvmtiEnv* env,
+    jint prefix_count,
+    char** prefixes);
+  jvmtiError ( *GetBytecodes) (jvmtiEnv* env,
+    jmethodID method,
+    jint* bytecode_count_ptr,
+    unsigned char** bytecodes_ptr);
+  jvmtiError ( *IsMethodNative) (jvmtiEnv* env,
+    jmethodID method,
+    jboolean* is_native_ptr);
+  jvmtiError ( *IsMethodSynthetic) (jvmtiEnv* env,
+    jmethodID method,
+    jboolean* is_synthetic_ptr);
+  jvmtiError ( *GetLoadedClasses) (jvmtiEnv* env,
+    jint* class_count_ptr,
+    jclass** classes_ptr);
+  jvmtiError ( *GetClassLoaderClasses) (jvmtiEnv* env,
+    jobject initiating_loader,
+    jint* class_count_ptr,
+    jclass** classes_ptr);
+  jvmtiError ( *PopFrame) (jvmtiEnv* env,
+    jthread thread);
+  jvmtiError ( *ForceEarlyReturnObject) (jvmtiEnv* env,
+    jthread thread,
+    jobject value);
+  jvmtiError ( *ForceEarlyReturnInt) (jvmtiEnv* env,
+    jthread thread,
+    jint value);
+  jvmtiError ( *ForceEarlyReturnLong) (jvmtiEnv* env,
+    jthread thread,
+    jlong value);
+  jvmtiError ( *ForceEarlyReturnFloat) (jvmtiEnv* env,
+    jthread thread,
+    jfloat value);
+  jvmtiError ( *ForceEarlyReturnDouble) (jvmtiEnv* env,
+    jthread thread,
+    jdouble value);
+  jvmtiError ( *ForceEarlyReturnVoid) (jvmtiEnv* env,
+    jthread thread);
+  jvmtiError ( *RedefineClasses) (jvmtiEnv* env,
+    jint class_count,
+    const jvmtiClassDefinition* class_definitions);
+  jvmtiError ( *GetVersionNumber) (jvmtiEnv* env,
+    jint* version_ptr);
+  jvmtiError ( *GetCapabilities) (jvmtiEnv* env,
+    jvmtiCapabilities* capabilities_ptr);
+  jvmtiError ( *GetSourceDebugExtension) (jvmtiEnv* env,
+    jclass klass,
+    char** source_debug_extension_ptr);
+  jvmtiError ( *IsMethodObsolete) (jvmtiEnv* env,
+    jmethodID method,
+    jboolean* is_obsolete_ptr);
+  jvmtiError ( *SuspendThreadList) (jvmtiEnv* env,
+    jint request_count,
+    const jthread* request_list,
+    jvmtiError* results);
+  jvmtiError ( *ResumeThreadList) (jvmtiEnv* env,
+    jint request_count,
+    const jthread* request_list,
+    jvmtiError* results);
+  void *reserved94;
+  void *reserved95;
+  void *reserved96;
+  void *reserved97;
+  void *reserved98;
+  void *reserved99;
+  jvmtiError ( *GetAllStackTraces) (jvmtiEnv* env,
+    jint max_frame_count,
+    jvmtiStackInfo** stack_info_ptr,
+    jint* thread_count_ptr);
+  jvmtiError ( *GetThreadListStackTraces) (jvmtiEnv* env,
+    jint thread_count,
+    const jthread* thread_list,
+    jint max_frame_count,
+    jvmtiStackInfo** stack_info_ptr);
+  jvmtiError ( *GetThreadLocalStorage) (jvmtiEnv* env,
+    jthread thread,
+    void** data_ptr);
+  jvmtiError ( *SetThreadLocalStorage) (jvmtiEnv* env,
+    jthread thread,
+    const void* data);
+  jvmtiError ( *GetStackTrace) (jvmtiEnv* env,
+    jthread thread,
+    jint start_depth,
+    jint max_frame_count,
+    jvmtiFrameInfo* frame_buffer,
+    jint* count_ptr);
+  void *reserved105;
+  jvmtiError ( *GetTag) (jvmtiEnv* env,
+    jobject object,
+    jlong* tag_ptr);
+  jvmtiError ( *SetTag) (jvmtiEnv* env,
+    jobject object,
+    jlong tag);
+  jvmtiError ( *ForceGarbageCollection) (jvmtiEnv* env);
+  jvmtiError ( *IterateOverObjectsReachableFromObject) (jvmtiEnv* env,
+    jobject object,
+    jvmtiObjectReferenceCallback object_reference_callback,
+    const void* user_data);
+  jvmtiError ( *IterateOverReachableObjects) (jvmtiEnv* env,
+    jvmtiHeapRootCallback heap_root_callback,
+    jvmtiStackReferenceCallback stack_ref_callback,
+    jvmtiObjectReferenceCallback object_ref_callback,
+    const void* user_data);
+  jvmtiError ( *IterateOverHeap) (jvmtiEnv* env,
+    jvmtiHeapObjectFilter object_filter,
+    jvmtiHeapObjectCallback heap_object_callback,
+    const void* user_data);
+  jvmtiError ( *IterateOverInstancesOfClass) (jvmtiEnv* env,
+    jclass klass,
+    jvmtiHeapObjectFilter object_filter,
+    jvmtiHeapObjectCallback heap_object_callback,
+    const void* user_data);
+  void *reserved113;
+  jvmtiError ( *GetObjectsWithTags) (jvmtiEnv* env,
+    jint tag_count,
+    const jlong* tags,
+    jint* count_ptr,
+    jobject** object_result_ptr,
+    jlong** tag_result_ptr);
+  jvmtiError ( *FollowReferences) (jvmtiEnv* env,
+    jint heap_filter,
+    jclass klass,
+    jobject initial_object,
+    const jvmtiHeapCallbacks* callbacks,
+    const void* user_data);
+  jvmtiError ( *IterateThroughHeap) (jvmtiEnv* env,
+    jint heap_filter,
+    jclass klass,
+    const jvmtiHeapCallbacks* callbacks,
+    const void* user_data);
+  void *reserved117;
+  void *reserved118;
+  void *reserved119;
+  jvmtiError ( *SetJNIFunctionTable) (jvmtiEnv* env,
+    const jniNativeInterface* function_table);
+  jvmtiError ( *GetJNIFunctionTable) (jvmtiEnv* env,
+    jniNativeInterface** function_table);
+  jvmtiError ( *SetEventCallbacks) (jvmtiEnv* env,
+    const jvmtiEventCallbacks* callbacks,
+    jint size_of_callbacks);
+  jvmtiError ( *GenerateEvents) (jvmtiEnv* env,
+    jvmtiEvent event_type);
+  jvmtiError ( *GetExtensionFunctions) (jvmtiEnv* env,
+    jint* extension_count_ptr,
+    jvmtiExtensionFunctionInfo** extensions);
+  jvmtiError ( *GetExtensionEvents) (jvmtiEnv* env,
+    jint* extension_count_ptr,
+    jvmtiExtensionEventInfo** extensions);
+  jvmtiError ( *SetExtensionEventCallback) (jvmtiEnv* env,
+    jint extension_event_index,
+    jvmtiExtensionEvent callback);
+  jvmtiError ( *DisposeEnvironment) (jvmtiEnv* env);
+  jvmtiError ( *GetErrorName) (jvmtiEnv* env,
+    jvmtiError error,
+    char** name_ptr);
+  jvmtiError ( *GetJLocationFormat) (jvmtiEnv* env,
+    jvmtiJlocationFormat* format_ptr);
+  jvmtiError ( *GetSystemProperties) (jvmtiEnv* env,
+    jint* count_ptr,
+    char*** property_ptr);
+  jvmtiError ( *GetSystemProperty) (jvmtiEnv* env,
+    const char* property,
+    char** value_ptr);
+  jvmtiError ( *SetSystemProperty) (jvmtiEnv* env,
+    const char* property,
+    const char* value);
+  jvmtiError ( *GetPhase) (jvmtiEnv* env,
+    jvmtiPhase* phase_ptr);
+  jvmtiError ( *GetCurrentThreadCpuTimerInfo) (jvmtiEnv* env,
+    jvmtiTimerInfo* info_ptr);
+  jvmtiError ( *GetCurrentThreadCpuTime) (jvmtiEnv* env,
+    jlong* nanos_ptr);
+  jvmtiError ( *GetThreadCpuTimerInfo) (jvmtiEnv* env,
+    jvmtiTimerInfo* info_ptr);
+  jvmtiError ( *GetThreadCpuTime) (jvmtiEnv* env,
+    jthread thread,
+    jlong* nanos_ptr);
+  jvmtiError ( *GetTimerInfo) (jvmtiEnv* env,
+    jvmtiTimerInfo* info_ptr);
+  jvmtiError ( *GetTime) (jvmtiEnv* env,
+    jlong* nanos_ptr);
+  jvmtiError ( *GetPotentialCapabilities) (jvmtiEnv* env,
+    jvmtiCapabilities* capabilities_ptr);
+  void *reserved141;
+  jvmtiError ( *AddCapabilities) (jvmtiEnv* env,
+    const jvmtiCapabilities* capabilities_ptr);
+  jvmtiError ( *RelinquishCapabilities) (jvmtiEnv* env,
+    const jvmtiCapabilities* capabilities_ptr);
+  jvmtiError ( *GetAvailableProcessors) (jvmtiEnv* env,
+    jint* processor_count_ptr);
+  jvmtiError ( *GetClassVersionNumbers) (jvmtiEnv* env,
+    jclass klass,
+    jint* minor_version_ptr,
+    jint* major_version_ptr);
+  jvmtiError ( *GetConstantPool) (jvmtiEnv* env,
+    jclass klass,
+    jint* constant_pool_count_ptr,
+    jint* constant_pool_byte_count_ptr,
+    unsigned char** constant_pool_bytes_ptr);
+  jvmtiError ( *GetEnvironmentLocalStorage) (jvmtiEnv* env,
+    void** data_ptr);
+  jvmtiError ( *SetEnvironmentLocalStorage) (jvmtiEnv* env,
+    const void* data);
+  jvmtiError ( *AddToBootstrapClassLoaderSearch) (jvmtiEnv* env,
+    const char* segment);
+  jvmtiError ( *SetVerboseFlag) (jvmtiEnv* env,
+    jvmtiVerboseFlag flag,
+    jboolean value);
+  jvmtiError ( *AddToSystemClassLoaderSearch) (jvmtiEnv* env,
+    const char* segment);
+  jvmtiError ( *RetransformClasses) (jvmtiEnv* env,
+    jint class_count,
+    const jclass* classes);
+  jvmtiError ( *GetOwnedMonitorStackDepthInfo) (jvmtiEnv* env,
+    jthread thread,
+    jint* monitor_info_count_ptr,
+    jvmtiMonitorStackDepthInfo** monitor_info_ptr);
+  jvmtiError ( *GetObjectSize) (jvmtiEnv* env,
+    jobject object,
+    jlong* size_ptr);
+} jvmtiInterface_1;
+struct _jvmtiEnv {
+    const struct jvmtiInterface_1_ *functions;
+};
+struct bkpt {
+    CVMUint8* pc;
+    CVMUint8 opcode;
+    jobject classRef;
+};
+struct fpop {
+    CVMFrame* frame;
+};
+struct fieldWatch {
+    CVMFieldBlock* fb;
+    jclass classRef;
+};
+enum {
+    JVMTI_INTERNAL_CAPABILITY_COUNT = 39
+};
+typedef struct CVMJvmtiMethodNode CVMJvmtiMethodNode;
+struct CVMJvmtiMethodNode {
+    CVMUint32 mid;
+    CVMMethodBlock *mb;
+    CVMBool isObsolete;
+    CVMConstantPool *cp;
+    CVMJvmtiMethodNode *next;
+};
+typedef struct CVMJvmtiTagNode CVMJvmtiTagNode;
+struct CVMJvmtiTagNode {
+    jlong tag;
+    jobject ref;
+    CVMJvmtiTagNode *next;
+};
+enum {
+    JVMTI_MAGIC = 0x71EE,
+    BAD_MAGIC = 0xDEAD
+};
+typedef struct CVMJvmtiEventEnabled CVMJvmtiEventEnabled;
+struct CVMJvmtiEventEnabled{
+    jlong enabledBits;
+};
+typedef struct CVMJvmtiVisitStack CVMJvmtiVisitStack;
+struct CVMJvmtiVisitStack {
+    CVMObject **stackBase;
+    CVMObject **stackPtr;
+    jvmtiEnv *env;
+    int stackSize;
+};
+typedef struct CVMJvmtiDumpContext CVMJvmtiDumpContext;
+struct CVMJvmtiDumpContext {
+    jint heapFilter;
+    jclass klass;
+    const jvmtiHeapCallbacks *callbacks;
+    const void *userData;
+    CVMExecEnv *ee;
+    JNIEnv *env;
+    CVMFrame *frame;
+    jint frameCount;
+    CVMObjectICell *icell;
+};
+typedef struct CVMJvmtiEnvEventEnable CVMJvmtiEnvEventEnable;
+struct CVMJvmtiEnvEventEnable {
+    CVMJvmtiEventEnabled eventUserEnabled;
+    CVMJvmtiEventEnabled eventCallbackEnabled;
+    CVMJvmtiEventEnabled eventEnabled;
+};
+typedef struct CVMJvmtiContext CVMJvmtiContext;
+struct CVMJvmtiContext {
+    jvmtiEnv jvmtiExternal;
+    const void *envLocalStorage;
+    jvmtiEventCallbacks eventCallbacks;
+    jboolean isValid;
+    jboolean threadEventsEnabled;
+    jint magic;
+    jint index;
+    CVMJvmtiEnvEventEnable envEventEnable;
+    jvmtiCapabilities currentCapabilities;
+    jvmtiCapabilities prohibitedCapabilities;
+    jboolean classFileLoadHookEverEnabled;
+    char** nativeMethodPrefixes;
+    int nativeMethodPrefixCount;
+};
+jvmtiError CVMjvmtiVisitStackPush(CVMObject *obj);
+CVMBool CVMjvmtiVisitStackEmpty();
+void CVMjvmtiCleanupMarked();
+void CVMjvmtiRecomputeEnabled(CVMJvmtiEnvEventEnable *);
+jlong CVMjvmtiRecomputeThreadEnabled(CVMExecEnv *ee, CVMJvmtiEnvEventEnable *);
+int CVMjvmtiDestroyContext(CVMJvmtiContext *context);
+CVMClassBlock *CVMjvmtiClassRef2ClassBlock(CVMExecEnv *ee, jclass clazz);
+CVMBool CVMjvmtiIsGCOwner();
+void CVMjvmtiSetGCOwner(CVMBool);
+typedef struct CVMJvmtiThreadNode CVMJvmtiThreadNode;
+struct CVMJvmtiThreadNode {
+    CVMObjectICell* thread;
+    jobject lastDetectedException;
+    jvmtiStartFunction startFunction;
+    const void *startFunctionArg;
+    CVMJvmtiContext *context;
+    void *jvmtiPrivateData;
+    CVMClassBlock *oldCb;
+    CVMClassBlock *redefineCb;
+    CVMBool startEventSent;
+    CVMJvmtiThreadNode *next;
+};
+typedef struct CVMJvmtiGlobals CVMJvmtiGlobals;
+struct CVMJvmtiGlobals {
+    struct {
+ int fieldAccessCount;
+ int fieldModificationCount;
+ jboolean canGetSourceDebugExtension;
+ jboolean canExamineOrDeoptAnywhere;
+ jboolean canMaintainOriginalMethodOrder;
+ jboolean canPostInterpreterEvents;
+ jboolean canHotswapOrPostBreakpoint;
+ jboolean canModifyAnyClass;
+ jboolean canWalkAnySpace;
+ jboolean canAccessLocalVariables;
+ jboolean canPostExceptions;
+ jboolean canPostBreakpoint;
+ jboolean canPostFieldAccess;
+ jboolean canPostFieldModification;
+ jboolean canPostMethodEntry;
+ jboolean canPostMethodExit;
+ jboolean canPopFrame;
+ jboolean canForceEarlyReturn;
+ jboolean shouldPostSingleStep;
+ jboolean shouldPostFieldAccess;
+ jboolean shouldPostFieldModification;
+ jboolean shouldPostClassLoad;
+ jboolean shouldPostClassPrepare;
+ jboolean shouldPostClassUnload;
+ jboolean shouldPostClassFileLoadHook;
+ jboolean shouldPostNativeMethodBind;
+ jboolean shouldPostCompiledMethodLoad;
+ jboolean shouldPostCompiledMethodUnload;
+ jboolean shouldPostDynamicCodeGenerated;
+ jboolean shouldPostMonitorContendedEnter;
+ jboolean shouldPostMonitorContendedEntered;
+ jboolean shouldPostMonitorWait;
+ jboolean shouldPostMonitorWaited;
+ jboolean shouldPostDataDump;
+ jboolean shouldPostGarbageCollectionStart;
+ jboolean shouldPostGarbageCollectionFinish;
+ jboolean shouldPostThreadLife;
+ jboolean shouldPostObjectFree;
+ jboolean shouldCleanUpHeapObjects;
+ jboolean shouldPostVmObjectAlloc;
+ jboolean hasRedefinedAClass;
+ jboolean allDependenciesAreRecorded;
+    } exports;
+    CVMBool dataDumpRequested;
+    CVMBool isEnabled;
+    CVMBool isInDebugMode;
+    CVMBool debugOptionSet;
+    CVMBool isWatchingFieldAccess;
+    CVMBool isWatchingFieldModification;
+    struct {
+ JavaVM* vm;
+ struct CVMBag* breakpoints;
+ struct CVMBag* framePops;
+ struct CVMBag* watchedFieldModifications;
+ struct CVMBag* watchedFieldAccesses;
+ volatile CVMJvmtiThreadNode *threadList;
+ CVMJvmtiContext *context;
+ jvmtiPhase currentPhase;
+ CVMJvmtiMethodNode *nodeByMB[1531];
+ jfieldID nameID;
+ jfieldID priorityID;
+ jfieldID daemonID;
+ jfieldID groupID;
+ jfieldID loaderID;
+ jfieldID tgParentID;
+ jfieldID tgNameID;
+ jfieldID tgMaxPriorityID;
+ jfieldID tgDaemonID;
+ jfieldID nthreadsID;
+ jfieldID threadsID;
+ jfieldID ngroupsID;
+ jfieldID groupsID;
+ CVMJvmtiVisitStack currentStack;
+ CVMJvmtiTagNode *romObjects[1531];
+ CVMJvmtiTagNode *objectsByRef[1531];
+    } statics;
+    struct {
+ jvmtiCapabilities always;
+ jvmtiCapabilities onload;
+ jvmtiCapabilities always_solo;
+ jvmtiCapabilities onload_solo;
+ jvmtiCapabilities always_solo_remaining;
+ jvmtiCapabilities onload_solo_remaining;
+ jvmtiCapabilities acquired;
+    } capabilities;
+};
+void CVMjvmtiSetCanGetSourceDebugExtension(jboolean on);
+void CVMjvmtiSetCanExamineOrDeoptAnywhere(jboolean on);
+void CVMjvmtiSetCanMaintainOriginalMethodOrder(jboolean on);
+void CVMjvmtiSetCanPostInterpreterEvents(jboolean on);
+void CVMjvmtiSetCanHotswapOrPostBreakpoint(jboolean on);
+void CVMjvmtiSetCanModifyAnyClass(jboolean on);
+void CVMjvmtiSetCanWalkAnySpace(jboolean on);
+void CVMjvmtiSetCanAccessLocalVariables(jboolean on);
+void CVMjvmtiSetCanPostExceptions(jboolean on);
+void CVMjvmtiSetCanPostBreakpoint(jboolean on);
+void CVMjvmtiSetCanPostFieldAccess(jboolean on);
+void CVMjvmtiSetCanPostFieldModification(jboolean on);
+void CVMjvmtiSetCanPostMethodEntry(jboolean on);
+void CVMjvmtiSetCanPostMethodExit(jboolean on);
+void CVMjvmtiSetCanPopFrame(jboolean on);
+void CVMjvmtiSetCanForceEarlyReturn(jboolean on);
+void CVMjvmtiSetShouldPostSingleStep(jboolean on);
+void CVMjvmtiSetShouldPostFieldAccess(jboolean on);
+void CVMjvmtiSetShouldPostFieldModification(jboolean on);
+void CVMjvmtiSetShouldPostClassLoad(jboolean on);
+void CVMjvmtiSetShouldPostClassPrepare(jboolean on);
+void CVMjvmtiSetShouldPostClassUnload(jboolean on);
+void CVMjvmtiSetShouldPostClassFileLoadHook(jboolean on);
+void CVMjvmtiSetShouldPostNativeMethodBind(jboolean on);
+void CVMjvmtiSetShouldPostCompiledMethodLoad(jboolean on);
+void CVMjvmtiSetShouldPostCompiledMethodUnload(jboolean on);
+void CVMjvmtiSetShouldPostDynamicCodeGenerated(jboolean on);
+void CVMjvmtiSetShouldPostMonitorContendedEnter(jboolean on);
+void CVMjvmtiSetShouldPostMonitorContendedEntered(jboolean on);
+void CVMjvmtiSetShouldPostMonitorWait(jboolean on);
+void CVMjvmtiSetShouldPostMonitorWaited(jboolean on);
+void CVMjvmtiSetShouldPostGarbageCollectionStart(jboolean on);
+void CVMjvmtiSetShouldPostGarbageCollectionFinish(jboolean on);
+void CVMjvmtiSetShouldPostDataDump(jboolean on);
+void CVMjvmtiSetShouldPostObjectFree(jboolean on);
+void CVMjvmtiSetShouldPostVmObjectAlloc(jboolean on);
+void CVMjvmtiSetShouldPostThreadLife(jboolean on);
+void CVMjvmtiSetShouldCleanUpHeapObjects(jboolean on);
+jlong CVMjvmtiGetThreadEventEnabled(CVMExecEnv *ee);
+void CVMjvmtiSetShouldPostAnyThreadEvent(CVMExecEnv *ee, jlong enabled);
+enum {
+    JVMTIVERSIONMASK = 0x70000000,
+    JVMTIVERSIONVALUE = 0x30000000,
+    JVMDIVERSIONVALUE = 0x20000000
+};
+void CVMjvmtiEnterPrimordialPhase();
+void CVMjvmtiEnterOnloadPhase();
+void CVMjvmtiEnterStartPhase();
+void CVMjvmtiEnterLivePhase();
+void CVMjvmtiEnterDeadPhase();
+jvmtiPhase CVMjvmtiGetPhase();
+jboolean CVMjvmtiCanGetSourceDebugExtension();
+jboolean CVMjvmtiCanExamineOrDeoptAnywhere();
+jboolean CVMjvmtiCanMaintainOriginalMethodOrder();
+jboolean CVMjvmtiCanPostInterpreterEvents();
+jboolean CVMjvmtiCanHotswapOrPostBreakpoint();
+jboolean CVMjvmtiCanModifyAnyClass();
+jboolean CVMjvmtiCanWalkAnySpace();
+jboolean CVMjvmtiCanAccessLocalVariables();
+jboolean CVMjvmtiCanPostExceptions();
+jboolean CVMjvmtiCanPostBreakpoint();
+jboolean CVMjvmtiCanPostFieldAccess();
+jboolean CVMjvmtiCanPostFieldModification();
+jboolean CVMjvmtiCanPostMethodEntry();
+jboolean CVMjvmtiCanPostMethodExit();
+jboolean CVMjvmtiCanPopFrame();
+jboolean CVMjvmtiCanForceEarlyReturn();
+jboolean CVMjvmtiShouldPostThreadLife();
+jboolean CVMjvmtiShouldPostSingleStep();
+jboolean CVMjvmtiShouldPostFieldAccess();
+jboolean CVMjvmtiShouldPostFieldModification();
+jboolean CVMjvmtiShouldPostClassLoad();
+jboolean CVMjvmtiShouldPostClassPrepare();
+jboolean CVMjvmtiShouldPostClassUnload();
+jboolean CVMjvmtiShouldPostClassFileLoadHook();
+jboolean CVMjvmtiShouldPostNativeMethodBind();
+jboolean CVMjvmtiShouldPostCompiledMethodLoad();
+jboolean CVMjvmtiShouldPostCompiledMethodUnload();
+jboolean CVMjvmtiShouldPostDynamicCodeGenerated();
+jboolean CVMjvmtiShouldPostMonitorContendedEnter();
+jboolean CVMjvmtiShouldPostMonitorContendedEntered();
+jboolean CVMjvmtiShouldPostMonitorWait();
+jboolean CVMjvmtiShouldPostMonitorWaited();
+jboolean CVMjvmtiShouldPostDataDump();
+jboolean CVMjvmtiShouldPostGarbageCollectionStart();
+jboolean CVMjvmtiShouldPostGarbageCollectionFinish();
+jboolean CVMjvmtiShouldPostObjectFree();
+jboolean CVMjvmtiShouldPostVmObjectAlloc();
+char** getAllNativeMethodPrefixes(int* countPtr);
+void cmsRefProcessingEpilogue();
+typedef struct AttachOperation_ {
+  char *args;
+} AttachOperation;
+typedef enum CVMJvmtiLoadKind CVMJvmtiLoadKind;
+enum CVMJvmtiLoadKind {
+  JVMTICLASSLOADKINDNORMAL = 0,
+  JVMTICLASSLOADKINDREDEFINE,
+  JVMDICLASSLOADKINDRETRANSFORM
+};
+typedef struct CVMJvmtiLockInfo CVMJvmtiLockInfo;
+struct CVMJvmtiLockInfo {
+    CVMJvmtiLockInfo *next;
+    CVMOwnedMonitor *lock;
+};
+typedef struct CVMJvmtiExecEnv CVMJvmtiExecEnv;
+struct CVMJvmtiExecEnv {
+    CVMBool debugEventsEnabled;
+    CVMBool jvmtiSingleStepping;
+    CVMBool jvmtiNeedFramePop;
+    CVMBool jvmtiNeedEarlyReturn;
+    CVMBool jvmtiDataDumpRequested;
+    CVMBool jvmtiNeedProcessing;
+    CVMJvmtiEventEnabled jvmtiUserEventEnabled;
+    CVMJvmtiEventEnabled jvmtiEventEnabled;
+    jvalue jvmtiEarlyReturnValue;
+    CVMUint32 jvmtiEarlyRetOpcode;
+    CVMJvmtiLockInfo *jvmtiLockInfoFreelist;
+    void *jvmtiProfilerData;
+};
+void CVMjvmtiPostExceptionEvent(CVMExecEnv* ee,
+    CVMUint8* pc,
+    CVMObjectICell* object);
+void CVMjvmtiPostExceptionCatchEvent(CVMExecEnv* ee,
+         CVMUint8* pc,
+         CVMObjectICell* object);
+void CVMjvmtiPostSingleStepEvent(CVMExecEnv* ee,
+     CVMUint8* pc);
+void CVMjvmtiPostFieldAccessEvent(CVMExecEnv* ee,
+      CVMObjectICell* obj,
+      CVMFieldBlock* fb);
+void CVMjvmtiPostFieldModificationEvent(CVMExecEnv* ee,
+     CVMObjectICell* obj,
+     CVMFieldBlock* fb,
+            jvalue jval);
+void CVMjvmtiPostThreadStartEvent(CVMExecEnv* ee,
+      CVMObjectICell* thread);
+void CVMjvmtiPostThreadEndEvent(CVMExecEnv* ee,
+    CVMObjectICell* thread);
+void CVMjvmtiPostFramePushEvent(CVMExecEnv* ee);
+void CVMjvmtiPostFramePopEvent(CVMExecEnv* ee, CVMBool isRef,
+          CVMBool isException, jvalue *retValue);
+void CVMjvmtiPostClassLoadEvent(CVMExecEnv* ee,
+    CVMObjectICell* clazz);
+void CVMjvmtiPostClassPrepareEvent(CVMExecEnv* ee,
+       CVMObjectICell* clazz);
+void CVMjvmtiPostClassUnloadEvent(CVMExecEnv* ee,
+      CVMObjectICell* clazz);
+void CVMjvmtiPostVmStartEvent(CVMExecEnv* ee);
+void CVMjvmtiPostVmInitEvent(CVMExecEnv* ee);
+void CVMjvmtiPostVmExitEvent(CVMExecEnv* ee);
+CVMUint8 CVMjvmtiGetBreakpointOpcode(CVMExecEnv* ee, CVMUint8* pc,
+         CVMBool notify);
+CVMBool CVMjvmtiSetBreakpointOpcode(CVMExecEnv* ee, CVMUint8* pc,
+        CVMUint8 opcode);
+void CVMjvmtiPostClassLoadHookEvent(jclass klass,
+        CVMClassLoaderICell *loader,
+        const char *className,
+        jobject protectionDomain,
+        CVMInt32 bufferLength,
+        CVMUint8 *buffer,
+        CVMInt32 *newBufferLength,
+        CVMUint8 **newBuffer);
+void CVMjvmtiPostCompiledMethodLoadEvent(CVMExecEnv *ee,
+      CVMMethodBlock *mb);
+void CVMjvmtiPostCompiledMethodUnloadEvent(CVMExecEnv *ee,
+        CVMMethodBlock* mb);
+void CVMjvmtiPostDataDumpRequest(void);
+void CVMjvmtiPostGCStartEvent(void);
+void CVMjvmtiPostGCFinishEvent(void);
+void CVMjvmtiPostStartUpEvents(CVMExecEnv *ee);
+void CVMjvmtiPostNativeMethodBind(CVMExecEnv *ee, CVMMethodBlock *mb,
+      CVMUint8 *nativeCode,
+      CVMUint8 **newNativeCode);
+void CVMjvmtiPostMonitorContendedEnterEvent(CVMExecEnv *ee,
+         CVMProfiledMonitor *pm);
+void CVMjvmtiPostMonitorContendedEnteredEvent(CVMExecEnv *ee,
+                                              CVMProfiledMonitor *pm);
+void CVMjvmtiPostMonitorWaitEvent(CVMExecEnv *ee,
+      jobject obj, jlong millis);
+void CVMjvmtiPostMonitorWaitedEvent(CVMExecEnv *ee,
+        jobject obj, CVMBool timedout);
+void CVMjvmtiPostObjectFreeEvent(CVMObject *obj);
+CVMBool CVMjvmtiDataDumpWasRequested(void);
+void CVMjvmtiResetDataDumpRequested(void);
+jint CVMjvmtiGetInterface(JavaVM *interfacesVm, void **penv);
+void CVMjvmtiInitializeGlobals(CVMJvmtiGlobals *globals);
+void CVMjvmtiDestroyGlobals(CVMJvmtiGlobals *globals);
+jvmtiError CVMjvmtiInitialize(JavaVM *vm);
+void CVMjvmtiDestroy(CVMJvmtiGlobals *globals);
+CVMJvmtiThreadNode *
+CVMjvmtiFindThread(CVMExecEnv* ee, CVMObjectICell* thread);
+CVMJvmtiThreadNode *
+CVMjvmtiInsertThread(CVMExecEnv* ee, CVMObjectICell* thread);
+jboolean CVMjvmtiRemoveThread(CVMExecEnv* ee, CVMObjectICell *thread);
+jvmtiError CVMjvmtiAllocate(jlong size, unsigned char **mem);
+jvmtiError CVMjvmtiDeallocate(unsigned char *mem);
+CVMBool CVMjvmtiClassBeingRedefined(CVMExecEnv *ee, CVMClassBlock *cb);
+CVMClassBlock *CVMjvmtiClassObject2ClassBlock(CVMExecEnv *ee, CVMObject *obj);
+void CVMjvmtiRehash(void);
+CVMUint32 CVMjvmtiUniqueID();
+void CVMjvmtiMarkAsObsolete(CVMMethodBlock *oldmb, CVMConstantPool *cp);
+CVMBool CVMjvmtiMbIsObsoleteX(CVMMethodBlock *mb);
+CVMConstantPool * CVMjvmtiMbConstantPool(CVMMethodBlock *mb);
+CVMBool CVMjvmtiCheckLockInfo(CVMExecEnv *ee);
+void CVMjvmtiAddLockInfo(CVMExecEnv *ee, CVMObjMonitor *mon,
+                                CVMOwnedMonitor *o,
+                                CVMBool okToBecomeGCSafe);
+void CVMjvmtiRemoveLockInfo(CVMExecEnv *ee, CVMObjMonitor *mon,
+                                   CVMOwnedMonitor *o);
+CVMClassBlock* CVMjvmtiGetCurrentRedefinedClass(CVMExecEnv *ee);
+void CVMjvmtiDestroyLockInfo(CVMExecEnv *ee);
+typedef enum {
+    CVM_THREAD_RUNNING = 0x0,
+    CVM_THREAD_TERMINATED = 0x2,
+    CVM_THREAD_WAITING_INDEFINITE = 0x10,
+    CVM_THREAD_WAITING_TIMEOUT = 0x20,
+    CVM_THREAD_SLEEPING = 0x40,
+    CVM_THREAD_WAITING = 0x80,
+    CVM_THREAD_OBJECT_WAIT = 0x100,
+    CVM_THREAD_BLOCKED_MONITOR_ENTER = 0x400,
+    CVM_THREAD_SUSPENDED = 0x100000,
+    CVM_THREAD_INTERRUPTED = 0x200000,
+    CVM_THREAD_IN_NATIVE = 0x400000,
+    CVM_THREAD_STACK_MUTATOR_LOCK = 0x800000
+} CVMThreadState;
+typedef enum {
+    CVM_EXCEPTION_NONE = 0,
+    CVM_EXCEPTION_TOP,
+    CVM_EXCEPTION_UNWINDING
+}CVMExceptionState;
+struct CVMExecEnv {
+    CVMTCState tcstate[CVM_NUM_CONSISTENT_STATES];
+    CVMUint8 isThrowingAnException;
+    CVMUint8 isHandlingAnException;
+    CVMUint16 remoteExceptionsDisabledCount;
+    CVMThrowableICell* localExceptionICell;
+    CVMThrowableICell* remoteExceptionICell;
+    CVMThrowableICell* currentExceptionICell;
+    union {
+ struct {
+     CVMUint8 remote;
+     CVMUint8 local;
+ } oneflag;
+ CVMUint16 bothflags;
+    } exceptionFlags;
+    CVMThreadICell* threadICell;
+    CVMObjectICell* miscICell;
+    CVMObjectICell* syncICell;
+    CVMObjectICell* finalizerRegisterICell;
+    CVMJNIEnv jniEnv;
+    CVMExecEnv **prevEEPtr;
+    CVMExecEnv *nextEE;
+    CVMStack interpreterStack;
+    CVMStack localRootsStack;
+    CVMBool cstackBufferFlag;
+    char *cstackBuffer;
+    void * nativeRunInfo;
+    CVMObjMonitor * volatile objLockCurrent;
+    CVMObjMonitor *objLocksFreeUnlocked;
+    CVMOwnedMonitor *objLocksOwned;
+    CVMOwnedMonitor *objLocksFreeOwned;
+    CVMBool threadExiting;
+    CVMOwnedMonitor *objLocksReservedOwned;
+    CVMObjMonitor *objLocksReservedUnlocked;
+    CVMThreadID threadInfo;
+    CVMThreadState threadState;
+    CVMUint32 threadID;
+    int nativeRunInfoType;
+    CVMSysMutex *sysLocks;
+    int microLock;
+    CVMBool userThread;
+    CVMObjectICell* allocationRetryICell;
+    CVMUint32 criticalCount;
+    CVMBool hasPostedExitEvents;
+    volatile CVMJvmtiExecEnv jvmtiEE;
+    CVMProfiledMonitor *blockingLockEntryMonitor;
+    CVMProfiledMonitor *blockingWaitMonitor;
+    CVMBool hasRun;
+    CVMBool interruptsMasked;
+    CVMBool maskedInterrupt;
+    CVMObjMonitor *objLocksPinned[16];
+    CVMSize objLocksPinnedCount;
+    CVMUint32 traceDepth;
+    CVMInt32 priority;
+    CVMUint32 tickCount;
+    CVMUint32 debugFlags;
+};
+typedef struct {
+    CVMThreadICell* threadICell;
+    void (*nativeFunc)(void *);
+    void* nativeFuncArg;
+    CVMBool isDaemon;
+    int started;
+    CVMMutex parentLock;
+    CVMCondVar parentCond;
+    CVMExecEnv *ee;
+    int priority;
+} CVMThreadStartInfo;
+extern CVMBool
+CVMinitExecEnv(CVMExecEnv* ee, CVMExecEnv *targetEE,
+        CVMThreadStartInfo* threadInfo);
+extern void
+CVMdestroyExecEnv(CVMExecEnv* ee);
+extern CVMBool
+CVMattachExecEnv(CVMExecEnv* ee, CVMBool orphan);
+extern void
+CVMdetachExecEnv(CVMExecEnv* ee);
+extern CVMExecEnv * CVMgetEE();
+extern void CVMaddThread(CVMExecEnv *ee, CVMBool userThread);
+extern void CVMremoveThread(CVMExecEnv *ee, CVMBool userThread);
+struct CVMInterpreterFrame {
+    CVMFrame frameX;
+    CVMUint8* pcX;
+    CVMConstantPool* cpX;
+    CVMSlotVal32* localsX;
+};
+struct CVMJavaFrame {
+    CVMInterpreterFrame frameX;
+    CVMJvmtiLockInfo *jvmtiLockInfo;
+    CVMObjectICell receiverObjX;
+    CVMStackVal32 opstackX[1];
+};
+struct CVMTransitionFrame {
+    CVMInterpreterFrame frameX;
+    CVMBool incrementPcFlagX;
+    CVMStackVal32 opstackX[1];
+};
+extern CVMInterpreterFrame *CVMDEBUGgetInterpreterFrame(CVMFrame *frame);
+extern void
+CVMgcUnsafeExecuteJavaMethod(CVMExecEnv* volatile ee, CVMMethodBlock* mb,
+        CVMBool isStatic, CVMBool isVirtual);
+extern void
+CVMgcUnsafeExecuteJavaMethodJVMTI(CVMExecEnv* volatile ee, CVMMethodBlock* mb,
+                                  CVMBool isStatic, CVMBool isVirtual);
+extern CVMUint8* CVMgcUnsafeExecuteJavaMethodQuick(CVMExecEnv* ee,
+    CVMUint8* pc, CVMStackVal32* topOfStack, CVMSlotVal32* locals,
+    CVMConstantPool* cp, CVMClassBlock** retCb);
+extern CVMInt32
+CVMpc2lineno(CVMMethodBlock *mb, CVMUint16 pc_offset);
+extern void
+CVMframe2string(CVMFrame* frame, char *buf, char* limit);
+extern void
+CVMframeIterate2string(CVMFrameIterator* frame, char *buf, char* limit);
+extern void
+CVMpc2string(CVMUint8* pc, CVMMethodBlock* mb,
+      CVMBool isTransition, CVMBool isCompiled, char *buf, char* limit);
+extern void
+CVMlineno2string(CVMInt32 lineno, CVMMethodBlock* mb,
+      CVMBool isTransition, CVMBool isCompiled, char *buf, char* limit);
+extern CVMUint8*
+CVMgcSafeFindPCForException(CVMExecEnv* ee, CVMFrameIterator* frame,
+       CVMClassBlock* exceptionClass, CVMUint8* pc);
+extern CVMFrame*
+CVMgcUnsafeHandleException(CVMExecEnv* ee, CVMFrame* frame,
+      CVMFrame* initialframe);
+extern void
+CVMsignalError(CVMExecEnv* ee, CVMClassBlock* exceptionCb,
+        const char *format, ...);
+extern void
+CVMsignalErrorVaList(CVMExecEnv* ee, CVMClassBlock* exceptionCb,
+       const char* format, va_list ap);
+extern CVMTransitionFrame*
+CVMpushTransitionFrame(CVMExecEnv* ee, CVMMethodBlock* mb);
+extern CVMBool
+CVMjavaFrameEnsureStackmaps(CVMExecEnv *ee, CVMExecEnv *frameEE,
+                            CVMFrame *frame);
+typedef struct {
+    CVMExecEnv *targetEE;
+    CVMFrame *prevFrame;
+    void *callbackData;
+} CVMInterpreterStackData;
+extern CVMStackMapEntry*
+CVMgetStackmapEntry(CVMExecEnv *frameEE, CVMFrame *frame,
+      CVMJavaMethodDescriptor *jmd, CVMStackMaps *stackmaps,
+      CVMBool *missingStackmapOK);
+CVMUint8*
+CVMfindInnermostHandlerFor(CVMJavaMethodDescriptor* jmd, CVMUint8* pc);
+CVMClassBlock* CVMgetCallerClass(CVMExecEnv* ee, int skip);
+CVMFrame*
+CVMgetCallerFrameSpecial(CVMFrame* frame, int n, CVMBool skipReflection);
+struct CVMFrameIterator {
+    CVMStack *stack;
+    CVMFrame *endFrame;
+    CVMFrame *frame;
+    CVMFrame *next;
+};
+void
+CVMframeIterateInitSpecial(CVMFrameIterator *iter, CVMStack *stack,
+      CVMFrame* firstFrame, CVMFrame *lastFrame);
+void
+CVMframeIterateInit(CVMFrameIterator *iter, CVMFrame* firstFrame);
+CVMBool
+CVMframeIterateSkipReflection(CVMFrameIterator *iter,
+    int skip, CVMBool skipReflection, CVMBool popFrame);
+CVMUint32
+CVMframeIterateCount(CVMFrameIterator *iter);
+CVMBool
+CVMframeIterateIsInlined(CVMFrameIterator *iter);
+CVMBool
+CVMframeIterateHandlesExceptions(CVMFrameIterator *iter);
+CVMBool
+CVMframeIterateCanHaveJavaCatchClause(CVMFrameIterator *iter);
+CVMFrameFlags
+CVMframeIterateGetFlags(CVMFrameIterator *iter);
+void
+CVMframeIterateSetFlags(CVMFrameIterator *iter, CVMFrameFlags flags);
+CVMFrame *
+CVMframeIterateGetFrame(CVMFrameIterator *iter);
+CVMMethodBlock *
+CVMframeIterateGetMb(CVMFrameIterator *iter);
+CVMUint8 *
+CVMframeIterateGetJavaPc(CVMFrameIterator *iter);
+void
+CVMframeIterateSetJavaPc(CVMFrameIterator *iter, CVMUint8 *pc);
+CVMStackVal32 *
+CVMframeIterateGetLocals(CVMFrameIterator *iter);
+CVMObjectICell *
+CVMframeIterateSyncObject(CVMFrameIterator *iter);
+CVMMethodBlock *
+CVMgetCallerMb(CVMFrame* frame, int skip);
+void
+CVMframeSetContextArtificial(CVMExecEnv *ee);
+extern CVMBool
+CVMisAssignable(CVMExecEnv* ee, CVMClassBlock* srcCb,
+  CVMClassBlock* dstCb);
+extern CVMBool
+CVMgcUnsafeIsInstanceOf(CVMExecEnv* ee, CVMObject* obj,
+   CVMClassBlock* cb);
+extern CVMBool
+CVMisSubclassOf(CVMExecEnv* ee, CVMClassBlock* subclasscb,
+  CVMClassBlock* cb);
+extern CVMBool
+CVMextendsClass(CVMExecEnv* ee, CVMClassBlock* subclasscb, CVMClassBlock* cb);
+extern CVMBool
+CVMimplementsInterface(CVMExecEnv* ee, CVMClassBlock* cb,
+         CVMClassBlock* interfacecb);
+CVMBool
+CVMverifyClassAccess(CVMExecEnv* ee,
+       CVMClassBlock* currentClass, CVMClassBlock* newClass,
+       CVMBool resolverAccess);
+extern CVMBool
+CVMverifyMemberAccess3(CVMExecEnv* ee,
+                       CVMClassBlock* currentClass,
+                       CVMClassBlock* resolvedClass,
+                       CVMClassBlock* memberClass,
+                       CVMUint32 access, CVMBool resolverAccess,
+                       CVMBool protectedRestriction);
+extern CVMBool
+CVMverifyMemberAccess2(CVMExecEnv* ee,
+         CVMClassBlock* currentClass,
+         CVMClassBlock* memberClass,
+         CVMUint32 access, CVMBool resolverAccess,
+         CVMBool protectedRestriction);
+CVMBool
+CVMverifyMemberAccess(CVMExecEnv* ee,
+        CVMClassBlock* currentClass,
+        CVMClassBlock* memberClass,
+        int access, CVMBool resolverAccess);
+extern CVMBool
+CVMisTrustedClassLoader(CVMExecEnv* ee, CVMClassLoaderICell* loader);
+extern void
+CVMmultiArrayAlloc(CVMExecEnv* ee,
+     CVMInt32 nDimensions,
+     CVMStackVal32* dimensions,
+     CVMClassBlock* arrayCb,
+     CVMObjectICell* resultCell);
+extern void
+CVMdisableRemoteExceptions(CVMExecEnv* ee);
+extern void
+CVMenableRemoteExceptions(CVMExecEnv* ee);
+extern CVMBool
+CVMremoteExceptionsDisabled(CVMExecEnv* ee);
+extern void
+CVMfillInStackTrace(CVMExecEnv *ee, CVMThrowableICell* objICell);
+extern void
+CVMprintStackTrace(CVMExecEnv *ee, CVMThrowableICell* throwableICell,
+     CVMObjectICell* printableICell);
+typedef enum {
+    CVM_QUICKEN_SUCCESS_OPCODE_ONLY,
+    CVM_QUICKEN_SUCCESS_OPCODE_AND_OPERANDS,
+    CVM_QUICKEN_NEED_TO_RUN_STATIC_INITIALIZERS,
+    CVM_QUICKEN_ALREADY_QUICKENED,
+    CVM_QUICKEN_ERROR
+} CVMQuickenReturnCode;
+extern CVMQuickenReturnCode
+CVMquickenOpcode(CVMExecEnv* ee, CVMUint8* pc,
+   CVMConstantPool* cp, CVMClassBlock** p_cb,
+   CVMBool clobbersCpIndex);
+extern CVMBool
+CVMisSpecialSuperCall(CVMClassBlock* currClass, CVMMethodBlock* mb);
+CVMMethodBlock*
+CVMlookupSpecialSuperMethod(CVMExecEnv* ee,
+       CVMClassBlock* currClass,
+       CVMMethodTypeID methodID);
+extern CVMBool
+CVMclassIsOKToInstantiate(CVMExecEnv *ee, CVMClassBlock *cb);
+extern CVMBool
+CVMfieldHasNotChangeStaticState(CVMExecEnv *ee, CVMFieldBlock *fb,
+                                CVMBool expectToBeStatic);
+extern CVMBool
+CVMfieldIsOKToWriteTo(CVMExecEnv *ee, CVMFieldBlock *fb,
+        CVMClassBlock *currentCb, CVMBool okToThrow);
+extern CVMBool
+CVMmethodHasNotChangeStaticState(CVMExecEnv *ee, CVMMethodBlock *mb,
+                                 CVMBool expectToBeStatic);
+extern void
+CVMinitStats();
+extern void
+CVMdumpStats();
+extern void
+CVMlocksForGCAcquire(CVMExecEnv* ee);
+extern void
+CVMlocksForGCRelease(CVMExecEnv* ee);
+extern CVMBool CVMsuspendCheckerInit();
+extern void CVMsuspendCheckerDestroy();
+extern CVMBool CVMsuspendCheckerIsOK(CVMExecEnv *ee, CVMExecEnv *targetEE);
+extern void
+CVMlocksForThreadSuspendAcquire(CVMExecEnv* ee);
+extern void
+CVMlocksForThreadSuspendRelease(CVMExecEnv* ee);
+extern void
+CVMthreadSuspendConsistentRequest(CVMExecEnv* ee);
+extern void
+CVMthreadSuspendConsistentRelease(CVMExecEnv* ee);
+typedef enum {
+    CVM_MangleMethodName_JNI_SHORT,
+    CVM_MangleMethodName_JNI_LONG,
+    CVM_MangleMethodName_CNI_SHORT
+} CVMMangleType;
+extern char*
+CVMmangleMethodName(CVMExecEnv* ee, CVMMethodBlock* mb,
+      CVMMangleType mangleType);
+extern CVMBool
+CVMlookupNativeMethodCode(CVMExecEnv* ee, CVMMethodBlock* mb);
+extern void CVMwaitForUserThreads(CVMExecEnv *ee);
+extern void CVMwaitForAllThreads(CVMExecEnv *ee);
+extern int CVMprepareToExit(void);
+extern int CVMatExit(void (*func)(void));
+extern void CVMexit(int);
+extern void CVMabort(void);
+extern CVMBool CVMsafeExit(CVMExecEnv *ee, CVMInt32 status);
+extern void
+CVMunloadApplicationclasses(CVMExecEnv* ee);
+extern void CVMtraceInit();
+extern void CVMtraceReset(CVMUint32 old, CVMUint32 nnew);
+extern void CVMtraceMethodCall(CVMExecEnv *ee,
+          CVMFrame* frame, CVMBool isJump);
+extern void CVMtraceMethodReturn(CVMExecEnv *ee, CVMFrame* frame);
+extern void CVMtraceFramelessMethodCall(CVMExecEnv *ee,
+            CVMFrame* frame, CVMMethodBlock *mb,
+     CVMBool isJump);
+extern void CVMtraceFramelessMethodReturn(CVMExecEnv *ee, CVMMethodBlock *mb,
+       CVMFrame* frame);
+CVMBool
+CVMsyncReturnHelper(CVMExecEnv *ee, CVMFrame *frame, CVMObjectICell *objICell,
+      CVMBool areturn);
+CVMUint32
+CVMregisterReturnEvent(CVMExecEnv *ee, CVMUint8* pc, CVMUint32 ret_opcode,
+         jvalue *retValue);
+CVMUint32
+CVMregisterReturnEventPC(CVMExecEnv *ee, CVMUint8* pc,
+    jvalue *retValue);
+CVMBool
+CVMinvokeJNIHelper(CVMExecEnv *ee, CVMMethodBlock *mb);
+void CVMpostThreadStartEvents(CVMExecEnv *ee);
+void CVMpostThreadExitEvents(CVMExecEnv *ee);
+void
+CVMcopyRefArrays(CVMExecEnv* ee,
+   CVMArrayOfRef* srcArr, jint src_pos,
+   CVMArrayOfRef* dstArr, jint dst_pos,
+   CVMClassBlock* dstElemCb, jint length);
+CVMBool CVMmaskInterrupts(CVMExecEnv *ee);
+void CVMunmaskInterrupts(CVMExecEnv *ee);
+typedef struct CVMPackage CVMPackage;
+struct CVMPackage {
+    char *packageName;
+    char *filename;
+    CVMPackage* next;
+};
+extern char*
+CVMpackagesGetEntry(const char* name);
+extern CVMBool
+CVMpackagesAddEntry(const char *name, const char *filename);
+extern void
+CVMpackagesDestroy();
+typedef jint ( *JVM_OnLoad_t)(JavaVM *, char *, void *);
+typedef void ( *JVM_OnUnload_t)(JavaVM *);
+typedef struct CVMXrunItem {
+    jobject shareLibRef;
+    JVM_OnUnload_t onUnloadFunc;
+} CVMXrunItem;
+typedef struct CVMXrunTable {
+    CVMInt32 elemIdx;
+    CVMInt32 elemCnt;
+    CVMXrunItem *table;
+} CVMXrunTable;
+extern CVMBool
+CVMXrunInitTable(CVMXrunTable *onUnloadTable, CVMInt32 numXrunArguments);
+extern void
+CVMXrunAppendToTable(CVMXrunTable *onUnloadTable, jobject libRef,
+       JVM_OnUnload_t fptr);
+extern void
+CVMXrunProcessTable(CVMXrunTable *onUnloadTable, JNIEnv *env, JavaVM *vm);
+extern CVMBool
+CVMXrunHandleArgument(CVMXrunTable *onUnloadTable, JNIEnv* env, char* arg);
+typedef jint ( *Agent_OnLoad_t)(JavaVM *, char *, void *);
+typedef void ( *Agent_OnUnload_t)(JavaVM *);
+typedef struct CVMAgentlibArg {
+  char *str;
+  CVMBool is_absolute;
+} CVMAgentlibArg_t;
+typedef struct CVMAgentItem {
+    void *libHandle;
+    Agent_OnUnload_t onUnloadFunc;
+} CVMAgentItem;
+typedef struct CVMAgentTable {
+    CVMInt32 elemIdx;
+    CVMInt32 elemCnt;
+    CVMAgentItem *table;
+} CVMAgentTable;
+extern CVMBool
+CVMAgentInitTable(CVMAgentTable *table, CVMInt32 numAgentArguments);
+extern void
+CVMAgentAppendToTable(CVMAgentTable *table, void *libHandle,
+        Agent_OnUnload_t fptr);
+extern void
+CVMAgentProcessTableUnload(CVMAgentTable *agentTable,
+      JNIEnv *env, JavaVM *vm);
+extern CVMBool
+CVMAgentHandleArgument(CVMAgentTable *agentTable, JNIEnv* env,
+         CVMAgentlibArg_t* arg);
+enum {
+    CVM_HEAPSTATEOBJ_INITIAL = 0,
+    CVM_HEAPSTATEOBJ_FREED
+};
+typedef struct CVMHeapStateObject CVMHeapStateObject;
+struct CVMHeapStateObject
+{
+    CVMObject *obj;
+    CVMUint32 size;
+};
+typedef struct CVMHeapState CVMHeapState;
+struct CVMHeapState
+{
+    CVMHeapState *next;
+    char *name;
+    CVMUint32 id;
+    CVMUint32 timeStamp;
+    CVMUint32 numberOfObjects;
+    CVMUint32 totalSize;
+    CVMHeapStateObject objects[1];
+};
+typedef struct CVMInspector CVMInspector;
+struct CVMInspector {
+    CVMBool keepAllObjectsAlive;
+    CVMBool hasCapturedState;
+    CVMUint32 lastHeapStateID;
+    CVMHeapState *heapStates;
+};
+void CVMinspectorGCLockerUnlock(CVMGCLocker *self, CVMExecEnv *current_ee);
+void CVMinspectorGCLockerWait(CVMGCLocker *self, CVMExecEnv *current_ee);
+extern CVMBool CVMgcIsValidObject(CVMExecEnv *ee, CVMObject *obj);
+CVMBool CVMgcDisableGC(void);
+CVMBool CVMgcEnableGC(void);
+CVMBool CVMgcIsDisabled(void);
+void CVMgcKeepAllObjectsAlive(CVMBool keepAlive);
+void CVMgcDumpObjectReferences(CVMObject *obj);
+void CVMgcDumpClassReferences(const char *clazzname);
+void CVMgcDumpClassBlocks(const char *clazzname);
+void CVMgcDumpObjectGCRoots(CVMObject *obj);
+extern void
+CVMgcDumpHeapSimple();
+extern void
+CVMgcDumpHeapVerbose();
+extern void
+CVMgcDumpHeapStats();
+enum {
+    CVM_HEAPSTATE_SORT_NONE = 0,
+    CVM_HEAPSTATE_SORT_BY_OBJ,
+    CVM_HEAPSTATE_SORT_BY_OBJCLASS
+};
+extern void
+CVMgcCaptureHeapState(const char *name);
+extern void
+CVMgcReleaseHeapState(CVMUint32 id);
+extern void
+CVMgcReleaseAllHeapState(void);
+extern void
+CVMgcListHeapStates(void);
+extern void
+CVMgcDumpHeapState(CVMUint32 id, int sortKey);
+extern void
+CVMgcCompareHeapState(CVMUint32 id1, CVMUint32 id2);
+extern void
+CVMgcHeapStateObjectMoved(CVMObject *oldObj, CVMObject *newObj);
+extern void
+CVMgcHeapStateObjectFreed(CVMObject *obj);
+extern void CVMdumpObject(CVMObject* directObj);
+extern void CVMdumpClassBlock(CVMClassBlock *cb);
+extern void CVMdumpString(CVMObject *string);
+extern void CVMdumpObjectReferences(CVMObject *obj);
+extern void CVMdumpClassReferences(const char *clazzname);
+extern void CVMdumpClassBlocks(const char *clazzname);
+extern void CVMdumpObjectGCRoots(CVMObject *obj);
+extern void CVMdumpSysInfo();
+typedef void (*pProc)(void);
+typedef struct exit_proc {
+    pProc proc;
+    struct exit_proc *next;
+} * exit_procPtr;
+typedef void (*loopProcPtr)(CVMExecEnv*, CVMMethodBlock *, CVMBool, CVMBool);
+struct CVMOptions {
+    void *vfprintfHook;
+    void *exitHook;
+    void *abortHook;
+    void *safeExitHook;
+    CVMBool timeStampEnabled;
+    const char *startHeapSizeStr;
+    const char *minHeapSizeStr;
+    const char *maxHeapSizeStr;
+    const char *nativeStackSizeStr;
+    const char *gcAttributesStr;
+    const char *optAttributesStr;
+    const char *traceFlagsStr;
+    CVMBool debugging;
+    CVMUint16 classVerificationLevel;
+    const char *bootclasspathStr;
+    const char *appclasspathStr;
+    CVMBool fullShutdownFlag;
+    CVMBool javaAssertionsUserDefault;
+    CVMBool javaAssertionsSysDefault;
+    CVMJavaAssertionsOptionList* javaAssertionsClasses;
+    CVMJavaAssertionsOptionList* javaAssertionsPackages;
+};
+struct CVMGlobalState {
+    CVMUint32** allocPtrPtr;
+    CVMUint32** allocTopPtr;
+    CVMAddr unused1;
+    CVMUint32 debugFlags;
+    CVMUint32 unused3;
+    CVMUint32 unused4;
+    CVMCState cstate[CVM_NUM_CONSISTENT_STATES];
+    CVMMutex objGlobalMicroLock;
+    CVMSysMutex globalRootsLock;
+    CVMStack globalRoots;
+    CVMSysMutex weakGlobalRootsLock;
+    CVMStack weakGlobalRoots;
+    CVMStack classGlobalRoots;
+    CVMStack classLoaderGlobalRoots;
+    CVMStack protectionDomainGlobalRoots;
+    CVMStack classTable;
+    CVMClassBlock* freeClassList;
+    CVMClassLoaderICell* freeClassLoaderList;
+    CVMSysMutex classTableLock;
+    CVMLoaderCacheEntry** loaderCache;
+    CVMLoaderConstraint** loaderConstraints;
+    CVMSysMutex loaderCacheLock;
+    CVMSysMutex heapLock;
+    CVMSysMutex nullClassLoaderLock;
+    CVMSysMutex jvmtiLock;
+    CVMSysMutex jvmtiLockInfoLock;
+    CVMTargetGlobalState target;
+    CVMUint32 maxHeapSize;
+    CVMGCLocker inspectorGCLocker;
+    CVMCondVar gcLockerCV;
+    CVMSysMutex gcLockerLock;
+    CVMGCCommonGlobalState gcCommon;
+    CVMGCGlobalState gc;
+    CVMJNIJavaVM javaVM;
+    CVMExecEnv mainEE;
+    CVMSysMutex threadLock;
+    CVMExecEnv *threadList;
+    CVMUint32 userThreadCount;
+    CVMUint32 threadCount;
+    CVMCondVar threadCountCV;
+    CVMUint32 threadIDCount;
+    CVMSysMutex syncLock;
+    CVMObjMonitor *objLocksBound;
+    CVMObjMonitor *objLocksUnbound;
+    CVMObjMonitor *objLocksFree;
+    CVMMutex sysMicroLock[CVM_NUM_SYS_MICROLOCKS];
+    CVMMethodTypeID initTid;
+    CVMMethodTypeID clinitTid;
+    CVMMethodTypeID finalizeTid;
+    CVMMethodTypeID cloneTid;
+    CVMMethodBlock *java_security_AccessController_doPrivilegedAction1;
+    CVMMethodBlock *java_security_AccessController_doPrivilegedExceptionAction1;
+    CVMMethodBlock *java_security_AccessController_doPrivilegedAction2;
+    CVMMethodBlock *java_security_AccessController_doPrivilegedExceptionAction2;
+    CVMMethodBlock* java_lang_ref_Finalizer_register;
+    CVMJavaVal32* java_lang_ref_Reference_lock;
+    CVMJavaVal32* java_lang_ref_Reference_pending;
+    CVMBool referenceWorkTODO;
+    CVMMethodBlock* java_lang_Class_runStaticInitializers;
+    CVMMethodBlock* java_lang_Class_newInstance;
+    CVMMethodBlock* java_lang_reflect_Constructor_newInstance;
+    CVMMethodBlock* java_lang_reflect_Method_invoke;
+    CVMMethodTypeID printlnTid;
+    CVMMethodBlock* java_lang_Throwable_fillInStackTrace;
+    CVMFieldBlock* java_lang_System_out;
+    CVMMethodBlock* java_lang_ClassLoader_NativeLibrary_getFromClass;
+    CVMMethodBlock* java_lang_ClassLoader_addClass;
+    CVMMethodBlock* java_lang_ClassLoader_loadClass;
+    CVMMethodBlock* java_lang_ClassLoader_findNative;
+    CVMMethodBlock* java_lang_ClassLoader_checkPackageAccess;
+    CVMMethodBlock* java_lang_ClassLoader_loadBootstrapClass;
+    CVMMethodBlock* java_lang_Class_loadSuperClasses;
+    CVMMethodBlock* java_lang_Shutdown_waitAllUserThreadsExitAndShutdown;
+    CVMMethodBlock* sun_misc_ThreadRegistry_waitAllSystemThreadsExit;
+    CVMMethodBlock* java_lang_Thread_exit;
+    CVMMethodBlock* java_lang_Thread_initMainThread;
+    CVMMethodBlock* java_lang_Thread_initAttachedThread;
+    CVMMethodBlock* java_lang_Thread_nextThreadNum;
+    CVMClassLoaderICell* systemClassLoader;
+    CVMClassPath bootClassPath;
+    CVMClassPath appClassPath;
+    CVMUint16 classVerificationLevel;
+    void* cvmDynHandle;
+    CVMMethodBlock* sun_misc_Launcher_AppClassLoader_setExtInfo;
+    CVMMethodBlock* sun_misc_Launcher_ClassContainer_init;
+    CVMMethodBlock* sun_misc_Launcher_ClassContainer_init_withClass;
+    CVMMethodBlock* sun_misc_Launcher_getFileURL;
+    CVMMethodBlock* java_io_File_init;
+    CVMMethodBlock* java_util_jar_JarFile_init;
+    CVMMethodBlock* java_security_CodeSource_init;
+    CVMMethodBlock* java_security_SecureClassLoader_getProtectionDomain;
+    CVMMethodBlock* java_lang_ClassLoader_checkCerts;
+    CVMPackage* packages[31];
+    CVMUint16 numPackages;
+    CVMJvmtiGlobals jvmti;
+    CVMSysMutex typeidLock;
+    CVMUint32 typeIDscalarSegmentSize;
+    CVMUint32 typeIDmethodTypeSegmentSize;
+    CVMUint32 typeIDmemberNameSegmentSize;
+    CVMSysMutex internLock;
+    CVMUint32 stringInternSegmentSizeIdx;
+    CVMInt32 lastRandom;
+    CVMThrowableICell* preallocatedOutOfMemoryError;
+    CVMThrowableICell* preallocatedStackOverflowError;
+    CVMParsedSubOptions parsedSubOptions;
+    struct {
+ CVMUint32 nativeStackSize;
+ CVMUint32 javaStackMinSize;
+ CVMUint32 javaStackMaxSize;
+ CVMUint32 javaStackChunkSize;
+    } config;
+    void *vfprintfHook;
+    void (*exitHook)(int);
+    void (*abortHook)();
+    void (*safeExitHook)(int);
+    CVMBool abort_entered;
+    CVMBool timeStampEnabled;
+    CVMSysMutex timestampListLock;
+    CVMInt64 firstWallclockTime;
+    CVMBool fullShutdown;
+    CVMXrunTable onUnloadTable;
+    CVMAgentTable agentTable;
+    exit_procPtr exit_procs;
+    CVMObject* discoveredSoftRefs;
+    CVMObject* discoveredWeakRefs;
+    CVMObject* discoveredFinalRefs;
+    CVMObject* discoveredPhantomRefs;
+    CVMObject* deferredWeakrefs;
+    CVMObject* deferredWeakrefsToClear;
+    CVMObject* deferredWeakrefsToAddToPending;
+    CVMBool suspendCheckerInitialized;
+    CVMThreadID suspendCheckerThreadInfo;
+    volatile CVMUint32 suspendCheckerState;
+    CVMMutex suspendCheckerLock;
+    CVMCondVar suspendCheckerCV;
+    CVMCondVar suspendCheckerAckCV;
+    CVMBool measureGC;
+    CVMInt64 totalGCTime;
+    CVMInt64 startGCTime;
+    CVMInt64 initFreeMemory;
+    CVMBool javaAssertionsUserDefault;
+    CVMBool javaAssertionsSysDefault;
+    CVMJavaAssertionsOptionList* javaAssertionsClasses;
+    CVMJavaAssertionsOptionList* javaAssertionsPackages;
+    CVMBool userHomePropSpecified;
+    CVMBool userNamePropSpecified;
+    CVMInspector inspector;
+    loopProcPtr CVMgcUnsafeExecuteJavaMethodProcPtr;
+};
+extern void
+CVMoptPrintUsage();
+extern CVMBool
+CVMoptParseXoptOptions(const char* optAttributesStr);
+extern CVMBool
+CVMoptParseXssOption(const char* optAttributesStr);
+extern void CVMdumpGlobalsSubOptionValues();
+extern CVMGlobalState CVMglobals;
+extern CVMBool
+CVMinitVMGlobalState(CVMGlobalState *, CVMOptions *options);
+extern void
+CVMdestroyVMGlobalState(CVMExecEnv *ee, CVMGlobalState *);
+extern void
+CVMglobalSysMutexesAcquire(CVMExecEnv* ee);
+extern void
+CVMglobalSysMutexesRelease(CVMExecEnv* ee);
+CVMJavaLong CVMjvm2Long(const CVMAddr location[2]);
+void CVMlong2Jvm(CVMAddr location[2], CVMJavaLong val);
+CVMJavaDouble CVMjvm2Double(const CVMAddr location[2]);
+void CVMdouble2Jvm(CVMAddr location[2], CVMJavaDouble val);
+void CVMmemCopy64(CVMUint32 *to, const CVMUint32 *from);
+extern CVMJavaDouble CVMlongBits2Double(CVMJavaLong val);
+extern CVMJavaLong CVMdouble2LongBits(CVMJavaDouble val);
+extern CVMJavaInt CVMlong2Int(CVMJavaLong val);
+extern CVMJavaFloat CVMlong2Float(CVMJavaLong val);
+extern CVMJavaDouble CVMlong2Double(CVMJavaLong val);
+extern void * CVMlong2VoidPtr(CVMJavaLong val);
+extern CVMJavaLong CVMvoidPtr2Long(void * val);
+extern CVMJavaLong CVMint2Long(CVMJavaInt val);
+extern CVMJavaLong CVMdouble2Long(CVMJavaDouble val);
+CVMJavaLong CVMlongAdd(CVMJavaLong op1, CVMJavaLong op2);
+CVMJavaLong CVMlongAnd(CVMJavaLong op1, CVMJavaLong op2);
+CVMJavaLong CVMlongDiv(CVMJavaLong op1, CVMJavaLong op2);
+CVMJavaLong CVMlongMul(CVMJavaLong op1, CVMJavaLong op2);
+CVMJavaLong CVMlongOr (CVMJavaLong op1, CVMJavaLong op2);
+CVMJavaLong CVMlongSub(CVMJavaLong op1, CVMJavaLong op2);
+CVMJavaLong CVMlongXor(CVMJavaLong op1, CVMJavaLong op2);
+CVMJavaLong CVMlongRem(CVMJavaLong op1, CVMJavaLong op2);
+CVMJavaLong CVMlongUshr(CVMJavaLong op1, CVMJavaInt op2);
+CVMJavaLong CVMlongShl (CVMJavaLong op1, CVMJavaInt op2);
+CVMJavaLong CVMlongShr (CVMJavaLong op1, CVMJavaInt op2);
+CVMJavaLong CVMlongNeg(CVMJavaLong op);
+CVMJavaLong CVMlongNot(CVMJavaLong op);
+CVMInt32 CVMlongLtz(CVMJavaLong op);
+CVMInt32 CVMlongGez(CVMJavaLong op);
+CVMInt32 CVMlongEqz(CVMJavaLong op);
+CVMInt32 CVMlongEq(CVMJavaLong op1, CVMJavaLong op2);
+CVMInt32 CVMlongNe(CVMJavaLong op1, CVMJavaLong op2);
+CVMInt32 CVMlongGe(CVMJavaLong op1, CVMJavaLong op2);
+CVMInt32 CVMlongLe(CVMJavaLong op1, CVMJavaLong op2);
+CVMInt32 CVMlongLt(CVMJavaLong op1, CVMJavaLong op2);
+CVMInt32 CVMlongGt(CVMJavaLong op1, CVMJavaLong op2);
+CVMInt32 CVMlongCompare(CVMJavaLong op1, CVMJavaLong op2);
+CVMJavaLong CVMlongConstZero();
+CVMJavaLong CVMlongConstOne();
+CVMJavaInt CVMdouble2Int(CVMJavaDouble val);
+CVMJavaFloat CVMdouble2Float(CVMJavaDouble val);
+CVMJavaDouble CVMint2Double(CVMJavaInt val);
+CVMJavaDouble CVMdoubleAdd(CVMJavaDouble op1, CVMJavaDouble op2);
+CVMJavaDouble CVMdoubleSub(CVMJavaDouble op1, CVMJavaDouble op2);
+CVMJavaDouble CVMdoubleDiv(CVMJavaDouble op1, CVMJavaDouble op2);
+CVMJavaDouble CVMdoubleMul(CVMJavaDouble op1, CVMJavaDouble op2);
+CVMJavaDouble CVMdoubleRem(CVMJavaDouble op1, CVMJavaDouble op2);
+CVMJavaDouble CVMdoubleNeg(CVMJavaDouble op);
+CVMInt32 CVMdoubleCompare(CVMJavaDouble op1, CVMJavaDouble op2,
+     CVMInt32 direction);
+CVMJavaDouble CVMdoubleConstZero();
+CVMJavaDouble CVMdoubleConstOne();
+extern CVMJavaInt double2Int(CVMJavaDouble d);
+extern CVMJavaLong double2Long(CVMJavaDouble d);
+void* memalign(size_t alignment, size_t size);
+void free(void* memalignAllocedSpace);
+CVMBool CVMmemInit();
+size_t CVMmemPageSize();
+void *CVMmemMap(size_t requestedSize, size_t *mappedSize);
+void *CVMmemUnmap(void *addr, size_t requestedSize, size_t *unmappedSize);
+void *CVMmemCommit(void *addr, size_t requestedSize, size_t *committedSize);
+void *CVMmemDecommit(void *addr, size_t requestedSize,
+       size_t *decommittedSize);
+extern const CVMObjectICell CVMID_nullICell;
+enum CVMOpcode {
+    opc_nop = 0,
+    opc_aconst_null = 1,
+    opc_iconst_m1 = 2,
+    opc_iconst_0 = 3,
+    opc_iconst_1 = 4,
+    opc_iconst_2 = 5,
+    opc_iconst_3 = 6,
+    opc_iconst_4 = 7,
+    opc_iconst_5 = 8,
+    opc_lconst_0 = 9,
+    opc_lconst_1 = 10,
+    opc_fconst_0 = 11,
+    opc_fconst_1 = 12,
+    opc_fconst_2 = 13,
+    opc_dconst_0 = 14,
+    opc_dconst_1 = 15,
+    opc_bipush = 16,
+    opc_sipush = 17,
+    opc_ldc = 18,
+    opc_ldc_w = 19,
+    opc_ldc2_w = 20,
+    opc_iload = 21,
+    opc_lload = 22,
+    opc_fload = 23,
+    opc_dload = 24,
+    opc_aload = 25,
+    opc_iload_0 = 26,
+    opc_iload_1 = 27,
+    opc_iload_2 = 28,
+    opc_iload_3 = 29,
+    opc_lload_0 = 30,
+    opc_lload_1 = 31,
+    opc_lload_2 = 32,
+    opc_lload_3 = 33,
+    opc_fload_0 = 34,
+    opc_fload_1 = 35,
+    opc_fload_2 = 36,
+    opc_fload_3 = 37,
+    opc_dload_0 = 38,
+    opc_dload_1 = 39,
+    opc_dload_2 = 40,
+    opc_dload_3 = 41,
+    opc_aload_0 = 42,
+    opc_aload_1 = 43,
+    opc_aload_2 = 44,
+    opc_aload_3 = 45,
+    opc_iaload = 46,
+    opc_laload = 47,
+    opc_faload = 48,
+    opc_daload = 49,
+    opc_aaload = 50,
+    opc_baload = 51,
+    opc_caload = 52,
+    opc_saload = 53,
+    opc_istore = 54,
+    opc_lstore = 55,
+    opc_fstore = 56,
+    opc_dstore = 57,
+    opc_astore = 58,
+    opc_istore_0 = 59,
+    opc_istore_1 = 60,
+    opc_istore_2 = 61,
+    opc_istore_3 = 62,
+    opc_lstore_0 = 63,
+    opc_lstore_1 = 64,
+    opc_lstore_2 = 65,
+    opc_lstore_3 = 66,
+    opc_fstore_0 = 67,
+    opc_fstore_1 = 68,
+    opc_fstore_2 = 69,
+    opc_fstore_3 = 70,
+    opc_dstore_0 = 71,
+    opc_dstore_1 = 72,
+    opc_dstore_2 = 73,
+    opc_dstore_3 = 74,
+    opc_astore_0 = 75,
+    opc_astore_1 = 76,
+    opc_astore_2 = 77,
+    opc_astore_3 = 78,
+    opc_iastore = 79,
+    opc_lastore = 80,
+    opc_fastore = 81,
+    opc_dastore = 82,
+    opc_aastore = 83,
+    opc_bastore = 84,
+    opc_castore = 85,
+    opc_sastore = 86,
+    opc_pop = 87,
+    opc_pop2 = 88,
+    opc_dup = 89,
+    opc_dup_x1 = 90,
+    opc_dup_x2 = 91,
+    opc_dup2 = 92,
+    opc_dup2_x1 = 93,
+    opc_dup2_x2 = 94,
+    opc_swap = 95,
+    opc_iadd = 96,
+    opc_ladd = 97,
+    opc_fadd = 98,
+    opc_dadd = 99,
+    opc_isub = 100,
+    opc_lsub = 101,
+    opc_fsub = 102,
+    opc_dsub = 103,
+    opc_imul = 104,
+    opc_lmul = 105,
+    opc_fmul = 106,
+    opc_dmul = 107,
+    opc_idiv = 108,
+    opc_ldiv = 109,
+    opc_fdiv = 110,
+    opc_ddiv = 111,
+    opc_irem = 112,
+    opc_lrem = 113,
+    opc_frem = 114,
+    opc_drem = 115,
+    opc_ineg = 116,
+    opc_lneg = 117,
+    opc_fneg = 118,
+    opc_dneg = 119,
+    opc_ishl = 120,
+    opc_lshl = 121,
+    opc_ishr = 122,
+    opc_lshr = 123,
+    opc_iushr = 124,
+    opc_lushr = 125,
+    opc_iand = 126,
+    opc_land = 127,
+    opc_ior = 128,
+    opc_lor = 129,
+    opc_ixor = 130,
+    opc_lxor = 131,
+    opc_iinc = 132,
+    opc_i2l = 133,
+    opc_i2f = 134,
+    opc_i2d = 135,
+    opc_l2i = 136,
+    opc_l2f = 137,
+    opc_l2d = 138,
+    opc_f2i = 139,
+    opc_f2l = 140,
+    opc_f2d = 141,
+    opc_d2i = 142,
+    opc_d2l = 143,
+    opc_d2f = 144,
+    opc_i2b = 145,
+    opc_i2c = 146,
+    opc_i2s = 147,
+    opc_lcmp = 148,
+    opc_fcmpl = 149,
+    opc_fcmpg = 150,
+    opc_dcmpl = 151,
+    opc_dcmpg = 152,
+    opc_ifeq = 153,
+    opc_ifne = 154,
+    opc_iflt = 155,
+    opc_ifge = 156,
+    opc_ifgt = 157,
+    opc_ifle = 158,
+    opc_if_icmpeq = 159,
+    opc_if_icmpne = 160,
+    opc_if_icmplt = 161,
+    opc_if_icmpge = 162,
+    opc_if_icmpgt = 163,
+    opc_if_icmple = 164,
+    opc_if_acmpeq = 165,
+    opc_if_acmpne = 166,
+    opc_goto = 167,
+    opc_jsr = 168,
+    opc_ret = 169,
+    opc_tableswitch = 170,
+    opc_lookupswitch = 171,
+    opc_ireturn = 172,
+    opc_lreturn = 173,
+    opc_freturn = 174,
+    opc_dreturn = 175,
+    opc_areturn = 176,
+    opc_return = 177,
+    opc_getstatic = 178,
+    opc_putstatic = 179,
+    opc_getfield = 180,
+    opc_putfield = 181,
+    opc_invokevirtual = 182,
+    opc_invokespecial = 183,
+    opc_invokestatic = 184,
+    opc_invokeinterface = 185,
+    opc_xxxunusedxxx = 186,
+    opc_new = 187,
+    opc_newarray = 188,
+    opc_anewarray = 189,
+    opc_arraylength = 190,
+    opc_athrow = 191,
+    opc_checkcast = 192,
+    opc_instanceof = 193,
+    opc_monitorenter = 194,
+    opc_monitorexit = 195,
+    opc_wide = 196,
+    opc_multianewarray = 197,
+    opc_ifnull = 198,
+    opc_ifnonnull = 199,
+    opc_goto_w = 200,
+    opc_jsr_w = 201,
+    opc_breakpoint = 202,
+    opc_aldc_ind_quick = 203,
+    opc_aldc_ind_w_quick = 204,
+    opc_invokestatic_quick = 205,
+    opc_invokestatic_checkinit_quick = 206,
+    opc_invokevirtual_quick = 207,
+    opc_getfield_quick = 208,
+    opc_agetfield_quick = 209,
+    opc_vinvokevirtual_quick = 210,
+    opc_invokevirtual_quick_w = 211,
+    opc_putfield_quick = 212,
+    opc_invokenonvirtual_quick = 213,
+    opc_invokesuper_quick = 214,
+    opc_invokeignored_quick = 215,
+    opc_getfield2_quick = 216,
+    opc_checkcast_quick = 217,
+    opc_instanceof_quick = 218,
+    opc_nonnull_quick = 219,
+    opc_putfield2_quick = 220,
+    opc_ainvokevirtual_quick = 221,
+    opc_invokevirtualobject_quick = 222,
+    opc_invokeinterface_quick = 223,
+    opc_aldc_quick = 224,
+    opc_ldc_quick = 225,
+    opc_exittransition = 226,
+    opc_dinvokevirtual_quick = 227,
+    opc_aldc_w_quick = 228,
+    opc_ldc_w_quick = 229,
+    opc_aputfield_quick = 230,
+    opc_getfield_quick_w = 231,
+    opc_ldc2_w_quick = 232,
+    opc_agetstatic_quick = 233,
+    opc_getstatic_quick = 234,
+    opc_getstatic2_quick = 235,
+    opc_aputstatic_quick = 236,
+    opc_putstatic_quick = 237,
+    opc_putstatic2_quick = 238,
+    opc_agetstatic_checkinit_quick = 239,
+    opc_getstatic_checkinit_quick = 240,
+    opc_getstatic2_checkinit_quick = 241,
+    opc_aputstatic_checkinit_quick = 242,
+    opc_putstatic_checkinit_quick = 243,
+    opc_putstatic2_checkinit_quick = 244,
+    opc_putfield_quick_w = 245,
+    opc_new_checkinit_quick = 246,
+    opc_new_quick = 247,
+    opc_anewarray_quick = 248,
+    opc_multianewarray_quick = 249,
+    opc_prefix = 250
+};
+extern const char* const CVMopnames[];
+extern const char CVMopcodeLengths[];
+extern CVMUint32 CVMopcodeGetLengthVariable(const CVMUint8* iStream);
+typedef enum CVMOpcode CVMOpcode;
+extern int
+CVMopcodeGetLengthWithBoundsCheckVariable(const unsigned char* iStream,
+       const unsigned char* iStream_end);
+typedef CVMFreelistFrame CVMGlobalRootsFrame;
+extern CVMObjectICell*
+CVMID_getGlobalRoot(CVMExecEnv* ee);
+extern CVMObjectICell*
+CVMID_getClassGlobalRoot(CVMExecEnv* ee);
+extern CVMObjectICell*
+CVMID_getClassLoaderGlobalRoot(CVMExecEnv* ee);
+extern CVMObjectICell*
+CVMID_getProtectionDomainGlobalRoot(CVMExecEnv* ee);
+extern CVMObjectICell*
+CVMID_getWeakGlobalRoot(CVMExecEnv* ee);
+extern void
+CVMID_freeGlobalRoot(CVMExecEnv* ee, CVMObjectICell* glRoot);
+extern void
+CVMID_freeClassGlobalRoot(CVMExecEnv* ee, CVMObjectICell* glRoot);
+extern void
+CVMID_freeClassLoaderGlobalRoot(CVMExecEnv* ee, CVMObjectICell* glRoot);
+extern void
+CVMID_freeProtectionDomainGlobalRoot(CVMExecEnv* ee, CVMObjectICell* glRoot);
+extern void
+CVMID_freeWeakGlobalRoot(CVMExecEnv* ee, CVMObjectICell* glRoot);
+extern CVMFrameGCScannerFunc CVMglobalrootFrameScanner;
+typedef void CVMThrowFunc(CVMExecEnv *, const char *format, ...);
+extern CVMThrowFunc CVMthrowClassCircularityError;
+extern CVMThrowFunc CVMthrowClassFormatError;
+extern CVMThrowFunc CVMthrowIllegalAccessError;
+extern CVMThrowFunc CVMthrowInstantiationError;
+extern CVMThrowFunc CVMthrowLinkageError;
+extern CVMThrowFunc CVMthrowUnsupportedClassVersionError;
+extern CVMThrowFunc CVMthrowVerifyError;
+extern CVMThrowFunc CVMthrowUnsatisfiedLinkError;
+extern CVMThrowFunc CVMthrowNegativeArraySizeException;
+extern CVMThrowFunc CVMthrowNoSuchFieldException;
+extern CVMThrowFunc CVMthrowNoSuchMethodException;
+extern CVMThrowFunc CVMthrowIncompatibleClassChangeError;
+extern CVMThrowFunc CVMthrowAbstractMethodError;
+extern CVMThrowFunc CVMthrowArithmeticException;
+extern CVMThrowFunc CVMthrowArrayIndexOutOfBoundsException;
+extern CVMThrowFunc CVMthrowArrayStoreException;
+extern CVMThrowFunc CVMthrowClassCastException;
+extern CVMThrowFunc CVMthrowClassNotFoundException;
+extern CVMThrowFunc CVMthrowCloneNotSupportedException;
+extern CVMThrowFunc CVMthrowIllegalAccessException;
+extern CVMThrowFunc CVMthrowIllegalArgumentException;
+extern CVMThrowFunc CVMthrowIllegalMonitorStateException;
+extern CVMThrowFunc CVMthrowIllegalStateException;
+extern CVMThrowFunc CVMthrowInstantiationException;
+extern CVMThrowFunc CVMthrowInternalError;
+extern CVMThrowFunc CVMthrowInterruptedException;
+extern CVMThrowFunc CVMthrowNoClassDefFoundError;
+extern CVMThrowFunc CVMthrowNoSuchFieldError;
+extern CVMThrowFunc CVMthrowNoSuchMethodError;
+extern CVMThrowFunc CVMthrowNullPointerException;
+extern CVMThrowFunc CVMthrowOutOfMemoryError;
+extern CVMThrowFunc CVMthrowStackOverflowError;
+extern CVMThrowFunc CVMthrowStringIndexOutOfBoundsException;
+extern CVMThrowFunc CVMthrowUnsupportedOperationException;
+extern CVMThrowFunc CVMthrowInvalidClassException;
+extern CVMThrowFunc CVMthrowIOException;
+extern CVMThrowFunc CVMthrowConversionBufferFullException;
+extern CVMThrowFunc CVMthrowUnknownCharacterException;
+extern CVMThrowFunc CVMthrowMalformedInputException;
+CVMJavaFloat CVMfloatAdd(CVMJavaFloat op1, CVMJavaFloat op2);
+CVMJavaFloat CVMfloatSub(CVMJavaFloat op1, CVMJavaFloat op2);
+CVMJavaFloat CVMfloatMul(CVMJavaFloat op1, CVMJavaFloat op2);
+CVMJavaFloat CVMfloatDiv(CVMJavaFloat op1, CVMJavaFloat op2);
+CVMJavaFloat CVMfloatRem(CVMJavaFloat op1, CVMJavaFloat op2);
+CVMJavaFloat CVMfloatNeg(CVMJavaFloat op);
+CVMInt32 CVMfloatCompare(CVMJavaFloat op1, CVMJavaFloat op2,
+    CVMInt32 direction);
+CVMJavaInt CVMfloat2Int(CVMJavaFloat op);
+CVMJavaDouble CVMfloat2Double(CVMJavaFloat op);
+extern CVMJavaLong CVMfloat2Long(CVMJavaFloat op);
+extern void setFPMode(void);
+extern CVMJavaInt float2Int(CVMJavaFloat d);
+extern CVMJavaLong float2Long(CVMJavaFloat d);
+CVMJavaInt CVMintAdd(CVMJavaInt op1, CVMJavaInt op2);
+CVMJavaInt CVMintSub(CVMJavaInt op1, CVMJavaInt op2);
+CVMJavaInt CVMintMul(CVMJavaInt op1, CVMJavaInt op2);
+CVMJavaInt CVMintDiv(CVMJavaInt op1, CVMJavaInt op2);
+CVMJavaInt CVMintRem(CVMJavaInt op1, CVMJavaInt op2);
+CVMJavaInt CVMintAnd(CVMJavaInt op1, CVMJavaInt op2);
+CVMJavaInt CVMintOr (CVMJavaInt op1, CVMJavaInt op2);
+CVMJavaInt CVMintXor(CVMJavaInt op1, CVMJavaInt op2);
+CVMJavaInt CVMintNeg(CVMJavaInt op);
+CVMJavaInt CVMintUshr(CVMJavaInt op, CVMJavaInt num);
+CVMJavaInt CVMintShl (CVMJavaInt op, CVMJavaInt num);
+CVMJavaInt CVMintShr (CVMJavaInt op, CVMJavaInt num);
+CVMJavaInt CVMintNeg(CVMJavaInt op);
+CVMJavaFloat CVMint2Float(CVMJavaInt val);
+CVMJavaByte CVMint2Byte(CVMJavaInt val);
+CVMJavaChar CVMint2Char(CVMJavaInt val);
+CVMJavaShort CVMint2Short(CVMJavaInt val);
+CVMUint16 CVMgetUint16(const CVMUint8 *ptr);
+CVMUint32 CVMgetUint32(const CVMUint8 *ptr);
+CVMInt16 CVMgetInt16(const CVMUint8 *ptr);
+CVMInt32 CVMgetInt32(const CVMUint8 *ptr);
+static void CVMdoubleAddHelper(CVMStackVal32* topOfStack) { CVMJavaDouble l1, l2, r; l1 = ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->d); }); l2 = ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); }); r = ((l1) + (l2)); { typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->d = r; }; }
+static void CVMdoubleSubHelper(CVMStackVal32* topOfStack) { CVMJavaDouble l1, l2, r; l1 = ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->d); }); l2 = ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); }); r = ((l1) - (l2)); { typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->d = r; }; }
+static void CVMdoubleMulHelper(CVMStackVal32* topOfStack) { CVMJavaDouble l1, l2, r; l1 = ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->d); }); l2 = ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); }); r = ((l1) * (l2)); { typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->d = r; }; }
+static void CVMdoubleDivHelper(CVMStackVal32* topOfStack) { CVMJavaDouble l1, l2, r; l1 = ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->d); }); l2 = ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); }); r = ((l1) / (l2)); { typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->d = r; }; }
+static void CVMdoubleRemHelper(CVMStackVal32* topOfStack) { CVMJavaDouble l1, l2, r; l1 = ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->d); }); l2 = ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); }); r = CVMdoubleRem(l1, l2); { typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->d = r; }; }
+static CVMBool CVMlongAddHelper(CVMStackVal32* topOfStack) { CVMJavaLong l1, l2, r1; l2 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); }); if (0 && ((l2) == 0LL)) { return (!(1 == 1)); } l1 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l); }); r1 = ((l1) + (l2)); { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l = r1; }; return (1 == 1); }
+static CVMBool CVMlongSubHelper(CVMStackVal32* topOfStack) { CVMJavaLong l1, l2, r1; l2 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); }); if (0 && ((l2) == 0LL)) { return (!(1 == 1)); } l1 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l); }); r1 = ((l1) - (l2)); { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l = r1; }; return (1 == 1); }
+static CVMBool CVMlongMulHelper(CVMStackVal32* topOfStack) { CVMJavaLong l1, l2, r1; l2 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); }); if (0 && ((l2) == 0LL)) { return (!(1 == 1)); } l1 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l); }); r1 = ((l1) * (l2)); { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l = r1; }; return (1 == 1); }
+static CVMBool CVMlongDivHelper(CVMStackVal32* topOfStack) { CVMJavaLong l1, l2, r1; l2 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); }); if (1 && ((l2) == 0LL)) { return (!(1 == 1)); } l1 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l); }); r1 = ((l1) / (l2)); { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l = r1; }; return (1 == 1); }
+static CVMBool CVMlongRemHelper(CVMStackVal32* topOfStack) { CVMJavaLong l1, l2, r1; l2 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); }); if (1 && ((l2) == 0LL)) { return (!(1 == 1)); } l1 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l); }); r1 = ((l1) % (l2)); { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l = r1; }; return (1 == 1); }
+static CVMBool CVMlongAndHelper(CVMStackVal32* topOfStack) { CVMJavaLong l1, l2, r1; l2 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); }); if (0 && ((l2) == 0LL)) { return (!(1 == 1)); } l1 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l); }); r1 = ((l1) & (l2)); { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l = r1; }; return (1 == 1); }
+static CVMBool CVMlongOrHelper(CVMStackVal32* topOfStack) { CVMJavaLong l1, l2, r1; l2 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); }); if (0 && ((l2) == 0LL)) { return (!(1 == 1)); } l1 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l); }); r1 = ((l1) | (l2)); { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l = r1; }; return (1 == 1); }
+static CVMBool CVMlongXorHelper(CVMStackVal32* topOfStack) { CVMJavaLong l1, l2, r1; l2 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); }); if (0 && ((l2) == 0LL)) { return (!(1 == 1)); } l1 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l); }); r1 = ((l1) ^ (l2)); { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l = r1; }; return (1 == 1); }
+static void CVMlongShlHelper(CVMStackVal32* topOfStack) { CVMJavaLong v, r; v = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-3].s).j).raw))->l); }); r = ((v) << (((((topOfStack[-1].s).j).i)) & 0x3F)); { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-3].s).j).raw))->l = r; }; }
+static void CVMlongShrHelper(CVMStackVal32* topOfStack) { CVMJavaLong v, r; v = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-3].s).j).raw))->l); }); r = ((v) >> (((((topOfStack[-1].s).j).i)) & 0x3F)); { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-3].s).j).raw))->l = r; }; }
+static void CVMlongUshrHelper(CVMStackVal32* topOfStack) { CVMJavaLong v, r; v = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-3].s).j).raw))->l); }); r = (((unsigned long long)(v)) >> (((((topOfStack[-1].s).j).i)) & 0x3F)); { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-3].s).j).raw))->l = r; }; }
+static void
+CVMlongNegHelper(CVMStackVal32* topOfStack)
+{
+    CVMJavaLong r;
+    r = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); });
+    r = (-(r));
+    { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l = r; };
+}
+static void
+CVMlongCmpHelper(CVMStackVal32* topOfStack)
+{
+    CVMJavaLong value1, value2;
+    value1 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l); });
+    value2 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); });
+    (((topOfStack[-4].s).j).i) = ((((value1)) < ((value2))) ? -1 : (((value1)) > ((value2))) ? 1 : 0);
+}
+static void
+CVMdoubleNegHelper(CVMStackVal32* topOfStack)
+{
+    CVMJavaDouble r;
+    r = ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); });
+    r = (-(r));
+    { typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d = r; };
+}
+static void
+CVMdoubleCmpHelper(CVMStackVal32* topOfStack, int direction)
+{
+    CVMJavaDouble value1, value2;
+    value1 = ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->d); });
+    value2 = ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); });
+    (((topOfStack[-4].s).j).i) = CVMdoubleCompare(value1, value2, direction);
+}
+static void
+CVMd2lHelper(CVMStackVal32* topOfStack)
+{
+    CVMJavaDouble r1;
+    CVMJavaLong r2;
+    r1 = ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); });
+    r2 = double2Long((r1));
+    { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l = r2; };
+}
+static void
+CVMd2iHelper(CVMStackVal32* topOfStack)
+{
+    CVMJavaDouble r1;
+    CVMJavaInt r2;
+    r1 = ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); });
+    r2 = (double2Int(r1));
+    (((topOfStack[-2].s).j).i) = r2;
+}
+static void
+CVMl2dHelper(CVMStackVal32* topOfStack)
+{
+    CVMJavaLong r1;
+    CVMJavaDouble r2;
+    r1 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); });
+    r2 = ((CVMJavaDouble)(r1));
+    { typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d = r2; };
+}
+static void
+CVMi2dHelper(CVMStackVal32* topOfStack)
+{
+    CVMJavaDouble r;
+    r = ((CVMJavaDouble)((((topOfStack[-1].s).j).i)));
+    { typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-1].s).j).raw))->d = r; };
+}
+static CVMInt32
+CVMtableswitchHelper(CVMExecEnv* ee, CVMStackVal32* topOfStack, CVMUint8* pc,
+       CVMFrame* frame)
+{
+    CVMInt32* lpc = (CVMInt32*)(((CVMAddr)(pc+1) + 3) & ~3);
+    CVMInt32 key = (((topOfStack[-1].s).j).i);
+    CVMInt32 low = (CVMInt32)((*((CVMInt32*)(&lpc[1])) << 24) | ((*((CVMInt32*)(&lpc[1])) & 0xff00) << 8) | ((*((CVMInt32*)(&lpc[1])) >> 8) & 0xff00) | (*((CVMUint32*)(&lpc[1])) >> 24));
+    CVMInt32 high = (CVMInt32)((*((CVMInt32*)(&lpc[2])) << 24) | ((*((CVMInt32*)(&lpc[2])) & 0xff00) << 8) | ((*((CVMInt32*)(&lpc[2])) >> 8) & 0xff00) | (*((CVMUint32*)(&lpc[2])) >> 24));
+    CVMInt32 skip;
+    (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\ttableswitch %d [%d-%d]\n", key, low, high) : (void)0);
+    key -= low;
+    ;
+    skip = ((CVMUint32) key > high - low)
+ ? (CVMInt32)((*((CVMInt32*)(&lpc[0])) << 24) | ((*((CVMInt32*)(&lpc[0])) & 0xff00) << 8) | ((*((CVMInt32*)(&lpc[0])) >> 8) & 0xff00) | (*((CVMUint32*)(&lpc[0])) >> 24))
+ : (CVMInt32)((*((CVMInt32*)(&lpc[key + 3])) << 24) | ((*((CVMInt32*)(&lpc[key + 3])) & 0xff00) << 8) | ((*((CVMInt32*)(&lpc[key + 3])) >> 8) & 0xff00) | (*((CVMUint32*)(&lpc[key + 3])) >> 24));
+    return skip;
+}
+static CVMInt32
+CVMlookupswitchHelper(CVMExecEnv* ee, CVMStackVal32* topOfStack, CVMUint8* pc,
+        CVMFrame* frame)
+{
+    CVMInt32* lpc = (CVMInt32*)(((CVMAddr)(pc+1) + 3) & ~3);
+    CVMInt32 key = (((topOfStack[-1].s).j).i);
+    CVMInt32 skip = (CVMInt32)((*((CVMInt32*)(lpc)) << 24) | ((*((CVMInt32*)(lpc)) & 0xff00) << 8) | ((*((CVMInt32*)(lpc)) >> 8) & 0xff00) | (*((CVMUint32*)(lpc)) >> 24));
+    CVMInt32 npairs = (CVMInt32)((*((CVMInt32*)(&lpc[1])) << 24) | ((*((CVMInt32*)(&lpc[1])) & 0xff00) << 8) | ((*((CVMInt32*)(&lpc[1])) >> 8) & 0xff00) | (*((CVMUint32*)(&lpc[1])) >> 24));
+    (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tlookupswitch %d\n", key) : (void)0);
+    while (--npairs >= 0) {
+ lpc += 2;
+ if (key == (CVMInt32)((*((CVMInt32*)(lpc)) << 24) | ((*((CVMInt32*)(lpc)) & 0xff00) << 8) | ((*((CVMInt32*)(lpc)) >> 8) & 0xff00) | (*((CVMUint32*)(lpc)) >> 24))) {
+     skip = (CVMInt32)((*((CVMInt32*)(&lpc[1])) << 24) | ((*((CVMInt32*)(&lpc[1])) & 0xff00) << 8) | ((*((CVMInt32*)(&lpc[1])) >> 8) & 0xff00) | (*((CVMUint32*)(&lpc[1])) >> 24));
+     break;
+ }
+    }
+    ;
+    return skip;
+}
+static CVMBool
+CVManewarrayHelper(CVMExecEnv* ee, CVMStackVal32* topOfStack,
+     CVMClassBlock* elemCb)
+{
+    CVMJavaInt arrLen;
+    CVMArrayOfRef* directArr;
+    CVMClassBlock* arrCb;
+    arrLen = (((topOfStack[-1].s).j).i);
+    if (arrLen < 0) {
+ CVMthrowNegativeArraySizeException(ee, ((void *)0));
+ return (!(1 == 1));
+    }
+    { ((void)0); ((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe\n") : (void)0); { ((void)((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+    ,
+ 1008
+    , "!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent") || (CVMsystemPanic("CVMassertHook returned"), 0))); ((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent = (1 == 1); ; };; if ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))) { CVMcsRendezvous((ee), (&CVMglobals.cstate[(CVM_GC_SAFE)]), (&((ee))->tcstate[(CVM_GC_SAFE)]), ((!(1 == 1))));; } { arrCb = CVMclassGetArrayOf(ee, elemCb); }; ((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-unsafe\n") : (void)0); { ((void)((((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+    ,
+ 1008
+    , "((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent") || (CVMsystemPanic("CVMassertHook returned"), 0))); ((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent = (!(1 == 1)); ; };; if ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))) { CVMcsRendezvous((ee), (&CVMglobals.cstate[(CVM_GC_SAFE)]), (&((ee))->tcstate[(CVM_GC_SAFE)]), ((1 == 1)));; } }
+      ;
+    if (arrCb == ((void *)0)) {
+ return (!(1 == 1));
+    }
+    directArr = (CVMArrayOfRef*)
+ CVMgcAllocNewArray(ee, CVM_T_CLASS, arrCb, arrLen);
+    if (directArr == ((void *)0)) {
+ CVMthrowOutOfMemoryError(ee, "%C", arrCb);
+ return (!(1 == 1));
+    }
+    (((void)(((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1019, "(!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY = ((CVMObject*)directArr));
+    (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tanewarray_quick %C => 0x%x\n", arrCb, directArr) : (void)0);
+    return (1 == 1);
+}
+static CVMBool
+CVMnewarrayHelper(CVMExecEnv* ee, CVMStackVal32* topOfStack,
+    CVMBasicType typeCode)
+{
+    CVMJavaInt arrLen;
+    CVMArrayOfAnyType* directArr;
+    CVMClassBlock* arrCb;
+    arrLen = (((topOfStack[-1].s).j).i);
+    if (arrLen < 0) {
+ CVMthrowNegativeArraySizeException(ee, ((void *)0));
+ return (!(1 == 1));
+    }
+    arrCb = (CVMClassBlock*)CVMbasicTypeArrayClassblocks[typeCode];
+    ((void)((arrCb != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1040, "arrCb != 0") || (CVMsystemPanic("CVMassertHook returned"), 0)));
+    directArr = (CVMArrayOfAnyType*)
+ CVMgcAllocNewArray(ee, typeCode, arrCb, arrLen);
+    (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tnewarray %C.%d => 0x%x\n", arrCb, arrLen, directArr) : (void)0);
+    ((void)((directArr == ((void *)0) || ((((((((CVMClassBlock*)(((CVMAddr)((directArr)->hdr.clas)) & ~3)))->classNameX))&0xc000) != 0 ) && (((((((((CVMClassBlock*)(((CVMAddr)((directArr)->hdr.clas)) & ~3)))->classNameX))&0xc000)==0xc000)? CVMtypeidGetArrayDepthX(((((CVMClassBlock*)(((CVMAddr)((directArr)->hdr.clas)) & ~3)))->classNameX)) : (((((((CVMClassBlock*)(((CVMAddr)((directArr)->hdr.clas)) & ~3)))->classNameX))&0xc000)>>14))==1) && (((((((((CVMClassBlock*)(((CVMAddr)((directArr)->hdr.clas)) & ~3)))->classNameX))&0xc000)==0xc000)? CVMtypeidGetArrayBasetypeX(((((CVMClassBlock*)(((CVMAddr)((directArr)->hdr.clas)) & ~3)))->classNameX)) : ((((((CVMClassBlock*)(((CVMAddr)((directArr)->hdr.clas)) & ~3)))->classNameX))&0x3fff)) == CVMbasicTypeID[typeCode]))) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+    ,
+ 1052
+    , "directArr == NULL || CVMisArrayClassOfBasicType(CVMobjectGetClass(directArr), CVMbasicTypeID[typeCode])") || (CVMsystemPanic("CVMassertHook returned"), 0)))
+                                ;
+    (((void)(((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1053, "(!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY = ((CVMObject*)directArr));
+    if (directArr == ((void *)0)) {
+ CVMthrowOutOfMemoryError(ee, "%C", arrCb);
+  return (!(1 == 1));
+    }
+    return (1 == 1);
+}
+static CVMBool
+CVMmultianewarrayHelper(CVMExecEnv* ee, CVMClassBlock* arrCb)
+{
+    CVMInt32 nDimensions;
+    CVMInt32 dimCount;
+    CVMInt32 effectiveNDimensions;
+    CVMObjectICell* resultCell;
+    CVMStack* stack = &ee->interpreterStack;
+    CVMFrame* frame;
+    CVMStackVal32* topOfStack;
+    CVMUint8* pc;
+    frame = stack->currentFrame;;
+    topOfStack = frame->topOfStack;;
+    pc = (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX);;
+    nDimensions = pc[3];
+    effectiveNDimensions = nDimensions;
+    topOfStack -= nDimensions;
+    frame->topOfStack = topOfStack;;
+    for (dimCount = 0; dimCount < nDimensions; dimCount++) {
+ CVMInt32 dim = (((topOfStack[dimCount].s).j).i);
+ if (dim <= 0) {
+     if ((dim == 0) && (effectiveNDimensions == nDimensions)) {
+  effectiveNDimensions = dimCount + 1;
+     } else if (dim < 0) {
+  { if ((1 == 1)) { (frame->topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1102, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1102, "CVMframeIsJava(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMJavaFrame*)(frame))->opstackX);; } else { (frame->topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1102, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_TRANSITION)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1102, "CVMframeIsTransition(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMTransitionFrame*)(frame))->opstackX);; } };
+  CVMthrowNegativeArraySizeException(ee, ((void *)0));
+  return (!(1 == 1));
+     }
+ }
+    }
+    resultCell = ((ee)->miscICell);
+    ((void)((((resultCell)->ref_DONT_ACCESS_DIRECTLY == 0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1116, "CVMID_icellIsNull(resultCell)") || (CVMsystemPanic("CVMassertHook returned"), 0)));
+    { ((void)0); ((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe\n") : (void)0); { ((void)((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+    ,
+ 1126
+    , "!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent") || (CVMsystemPanic("CVMassertHook returned"), 0))); ((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent = (1 == 1); ; };; if ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))) { CVMcsRendezvous((ee), (&CVMglobals.cstate[(CVM_GC_SAFE)]), (&((ee))->tcstate[(CVM_GC_SAFE)]), ((!(1 == 1))));; } { CVMmultiArrayAlloc(ee, effectiveNDimensions, topOfStack, arrCb, resultCell); }; ((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-unsafe\n") : (void)0); { ((void)((((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+    ,
+ 1126
+    , "((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent") || (CVMsystemPanic("CVMassertHook returned"), 0))); ((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent = (!(1 == 1)); ; };; if ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))) { CVMcsRendezvous((ee), (&CVMglobals.cstate[(CVM_GC_SAFE)]), (&((ee))->tcstate[(CVM_GC_SAFE)]), ((1 == 1)));; } }
+      ;
+    if (((resultCell)->ref_DONT_ACCESS_DIRECTLY == 0)) {
+ { if ((1 == 1)) { (frame->topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1133, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1133, "CVMframeIsJava(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMJavaFrame*)(frame))->opstackX);; } else { (frame->topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1133, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_TRANSITION)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1133, "CVMframeIsTransition(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMTransitionFrame*)(frame))->opstackX);; } };
+ CVMthrowOutOfMemoryError(ee, "%C", arrCb);
+ return (!(1 == 1));
+    }
+    (((void)(((!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1138, "(!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), ((&(((topOfStack[0].s).j).r)))->ref_DONT_ACCESS_DIRECTLY = ((*(((void)(((!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1138, "(!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &((resultCell))->ref_DONT_ACCESS_DIRECTLY))));
+    (resultCell)->ref_DONT_ACCESS_DIRECTLY = 0;;
+    (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tmultianewarray_quick %C " "(dimensions = %d, effective = %d) => 0x%x\n", arrCb, nDimensions, effectiveNDimensions, ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1148, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[0].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))) : (void)0)
+                                                               ;
+    return (1 == 1);
+}
+static CVMMethodBlock*
+CVMinvokeInterfaceHelper(CVMExecEnv* ee, CVMStackVal32* topOfStack,
+    CVMMethodBlock* imb )
+{
+    CVMObject* directObj;
+    CVMClassBlock* icb;
+    CVMClassBlock* ocb;
+    CVMUint32 interfaceCount;
+    CVMInterfaces* interfaces;
+    CVMInterfaceTable* itablePtr;
+    CVMUint16 methodTableIndex;
+    CVMMethodBlock* mb;
+    int guess;
+    CVMStack* stack = &ee->interpreterStack;
+    CVMFrame* frame;
+    CVMUint8* pc;
+    frame = stack->currentFrame;;
+    pc = (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX);;
+    guess = pc[4];
+    icb = (((CVMMethodRange*) ((CVMUint8 *)((imb) - ((imb)->immutX.methodIndexX)) - ((CVMAddr)(&(((CVMMethodRange *)0)->mb[0])) - (CVMAddr)(&(((CVMMethodRange *)0)->cb)))))->cb);
+    directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1175, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[0].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+    if (directObj == ((void *)0)) {
+        CVMthrowNullPointerException(ee, ((void *)0));
+ return ((void *)0);
+    }
+    ocb = ((CVMClassBlock*)(((CVMAddr)((directObj)->hdr.clas)) & ~3));
+    interfaces = ((ocb)->interfacesX);
+    interfaceCount = ((interfaces) == ((void *)0) ? 0 : (interfaces)->interfaceCountX);
+    itablePtr = ((interfaces)->itable);
+    if (guess < 0 || guess >= interfaceCount ||
+ ((itablePtr)[guess].interfaceCb) != icb) {
+ guess = interfaceCount - 1;
+ while ((guess >= 0) &&
+        (((itablePtr)[guess].interfaceCb) != icb)) {
+     guess--;
+ }
+ if (guess >= 0) {
+     ((void)((((itablePtr)[guess].interfaceCb) == icb) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+     ,
+ 1202
+     , "CVMcbInterfacecbGivenItable(itablePtr, guess) == icb") || (CVMsystemPanic("CVMassertHook returned"), 0)))
+               ;
+     if ((((ocb)->interfacesX)->itable[guess]. interfaceCb) == icb) {
+  if (!(((((((((CVMMethodRange*) ((CVMUint8 *)((frame->mb) - ((frame->mb)->immutX.methodIndexX)) - ((CVMAddr)(&(((CVMMethodRange *)0)->mb[0])) - (CVMAddr)(&(((CVMMethodRange *)0)->cb)))))->cb))->runtimeFlagsX) & 0x01) != 0))) &&
+      !((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1209, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_TRANSITION)) {
+      pc[4] = guess;
+  }
+     }
+ }
+    }
+    if (guess >= 0) {
+        methodTableIndex = (((interfaces)->itable[guess]. intfInfoX.methodTableIndicesX)[(*(((void)((((0x400 & (0x01 | 0x03 | 0x02)) ? ((((imb)->immutX.invokerAndAccessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x400) : ((((imb)->immutX.invokerAndAccessFlagsX) & 0x400) != 0)) && (((((((CVMMethodRange*) ((CVMUint8 *)((imb) - ((imb)->immutX.methodIndexX)) - ((CVMAddr)(&(((CVMMethodRange *)0)->mb[0])) - (CVMAddr)(&(((CVMMethodRange *)0)->cb)))))->cb))->accessFlagsX) & 0x200) != 0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1224, "CVMmbIs(imb, ABSTRACT) && CVMcbIs(CVMmbClassBlock(imb), INTERFACE)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(imb)->immutX.codeX.methodSlotIndex))])
+                                                      ;
+        mb = (((ocb)->methodTablePtrX)[methodTableIndex]);
+        return mb;
+    } else if (icb == ((CVMClassBlock*)(&java_lang_Object_Classblock))) {
+        methodTableIndex = ((imb)->immutX.methodTableIndexX);
+        mb = (((ocb)->methodTablePtrX)[methodTableIndex]);
+        return mb;
+    } else {
+        CVMthrowIncompatibleClassChangeError(
+     ee, "class %C does not implement interface %C", ocb, icb);
+ return ((void *)0);
+    }
+}
+static CVMBool
+CVMloadConstantHelper(CVMExecEnv *ee, CVMStackVal32* topOfStack,
+    CVMConstantPool* cp, CVMUint16 cpIndex, CVMUint8* pc)
+{
+    switch ((((cp)->cpTypesX)[cpIndex] & 0x3F)) {
+    case CVM_CONSTANT_ClassTypeID:
+    {
+ CVMBool resolved;
+ { ((void)0); ((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe\n") : (void)0); { ((void)((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+ ,
+ 1256
+ , "!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent") || (CVMsystemPanic("CVMassertHook returned"), 0))); ((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent = (1 == 1); ; };; if ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))) { CVMcsRendezvous((ee), (&CVMglobals.cstate[(CVM_GC_SAFE)]), (&((ee))->tcstate[(CVM_GC_SAFE)]), ((!(1 == 1))));; } { resolved = ((((cp)->cpTypesX) == ((void *)0) ? (1 == 1) : (((cp)->cpTypesX)[cpIndex] & 0x80) != 0) ? (1 == 1) : CVMprivate_cpResolveEntryFromClass(ee, (((CVMMethodRange*) ((CVMUint8 *)((((((ee))->interpreterStack.currentFrame)->mb)) - ((((((ee))->interpreterStack.currentFrame)->mb))->immutX.methodIndexX)) - ((CVMAddr)(&(((CVMMethodRange *)0)->mb[0])) - (CVMAddr)(&(((CVMMethodRange *)0)->cb)))))->cb), cp, cpIndex)); }; ((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-unsafe\n") : (void)0); { ((void)((((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+ ,
+ 1256
+ , "((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent") || (CVMsystemPanic("CVMassertHook returned"), 0))); ((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent = (!(1 == 1)); ; };; if ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))) { CVMcsRendezvous((ee), (&CVMglobals.cstate[(CVM_GC_SAFE)]), (&((ee))->tcstate[(CVM_GC_SAFE)]), ((1 == 1)));; } }
+   ;
+ if (!resolved) {
+     return (!(1 == 1));
+ }
+    }
+    case CVM_CONSTANT_ClassBlock: {
+ CVMClassBlock *cb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1262, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[cpIndex] & 0x3F) == CVM_CONSTANT_ClassBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1262, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, cpIndex, ClassBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[cpIndex].resolved.cb);
+ (((void)(((!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1263, "(!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), ((&(((topOfStack[0].s).j).r)))->ref_DONT_ACCESS_DIRECTLY = ((*(((void)(((!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1263, "(!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &((((cb)->javaInstanceX)))->ref_DONT_ACCESS_DIRECTLY))));
+ (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s #%d => %C\n", CVMopnames[pc[0]], cpIndex, cb) : (void)0)
+                     ;
+ return (1 == 1);
+    }
+    default:
+ return (!(1 == 1));
+    }
+}
+static CVMBool
+CVMldcHelper(CVMExecEnv *ee, CVMStackVal32* topOfStack,
+    CVMConstantPool* cp, CVMUint8* pc)
+{
+    return CVMloadConstantHelper(ee, topOfStack, cp, pc[1], pc);
+}
+static CVMBool
+CVMldc_wHelper(CVMExecEnv *ee, CVMStackVal32* topOfStack,
+    CVMConstantPool* cp, CVMUint8* pc)
+{
+    return CVMloadConstantHelper(ee, topOfStack, cp, ((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), pc);
+}
+static void
+CVMldc2_wHelper(CVMStackVal32* topOfStack, CVMConstantPool* cp, CVMUint8* pc)
+{
+    CVMJavaVal64 r;
+    ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(r.v))->l = ((fakeOutGCCStrictAliasing *)(&((cp)->entriesX[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))].resolved.val32.raw)))->l; });
+    { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->l = ((fakeOutGCCStrictAliasing *)(r.v))->l; };
+}
+static CVMStackVal32*
+CVMgetfield_quick_wHelper(CVMExecEnv* ee, CVMFrame* frame,
+     CVMStackVal32* topOfStack, CVMConstantPool* cp,
+     CVMUint8* pc)
+{
+    CVMFieldBlock* fb;
+    CVMObject* directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1301, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+    if (directObj == ((void *)0)) {
+ return ((void *)0);
+    }
+    fb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1305, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))] & 0x3F) == CVM_CONSTANT_FieldBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1305, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), FieldBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))].resolved.fb);
+    ;
+    if ((( ((((fb)->nameAndTypeIDX))&0xffff) == 6) || ( ((((fb)->nameAndTypeIDX))&0xffff) == 9))) {
+        if (((0x40 & (0x01 | 0x03 | 0x02)) ? ((((fb)->accessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x40) : ((((fb)->accessFlagsX) & 0x40) != 0))) {
+            CVMsysMicroLock(ee, CVM_ACCESS_VOLATILE_MICROLOCK);
+        }
+ { CVMJavaVal32 volatile* fieldLoc_ = ((CVMJavaVal32 volatile *)(directObj) + (((fb)->offsetX))); union {CVMUint32 x;} tmp_[2]; ; tmp_[0].x = (&(fieldLoc_)->raw)[0]; tmp_[1].x = (&(fieldLoc_)->raw)[1]; { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&(&((topOfStack[-1].s).j))->raw))->l = ((fakeOutGCCStrictAliasing *)(&tmp_[0].x))->l; }; };
+        if (((0x40 & (0x01 | 0x03 | 0x02)) ? ((((fb)->accessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x40) : ((((fb)->accessFlagsX) & 0x40) != 0))) {
+            CVMsysMicroUnlock(ee, CVM_ACCESS_VOLATILE_MICROLOCK);
+        }
+ (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %O[%d](0x%X, 0x%X) ==>\n", CVMopnames[pc[0]], directObj, ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), (((topOfStack[-1].s).j).i), (((topOfStack[0].s).j).i)) : (void)0)
+                                     ;
+ topOfStack++;
+    } else {
+ if (( ((((fb)->nameAndTypeIDX))&0xffff) > 10)) {
+     { CVMObject* volatile *fieldLoc_ = (CVMObject* volatile *)((CVMJavaVal32 volatile *)(directObj) + (((fb)->offsetX)));
+ ; (((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1323, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))) = *fieldLoc_; };
+ } else {
+     { CVMJavaVal32 volatile* fieldLoc_ = ((CVMJavaVal32 volatile *)(directObj) + (((fb)->offsetX))); ; (((((topOfStack[-1].s).j))) = (*fieldLoc_)); }
+                       ;
+ }
+ (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %O[%d](0x%X) ==>\n", CVMopnames[pc[0]], directObj, ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), (((topOfStack[-1].s).j).i)) : (void)0)
+                                                   ;
+    }
+    return topOfStack;
+}
+static CVMStackVal32*
+CVMputfield_quick_wHelper(CVMExecEnv* ee, CVMFrame* frame,
+     CVMStackVal32* topOfStack, CVMConstantPool* cp,
+     CVMUint8* pc)
+{
+    CVMObject* directObj;
+    CVMFieldBlock* fb;
+    fb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1341, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))] & 0x3F) == CVM_CONSTANT_FieldBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1341, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), FieldBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))].resolved.fb);
+    if ((( ((((fb)->nameAndTypeIDX))&0xffff) == 6) || ( ((((fb)->nameAndTypeIDX))&0xffff) == 9))) {
+ directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1343, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-3].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+ if (directObj == ((void *)0)) {
+     return ((void *)0);
+ }
+ ;
+        if (((0x40 & (0x01 | 0x03 | 0x02)) ? ((((fb)->accessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x40) : ((((fb)->accessFlagsX) & 0x40) != 0))) {
+            CVMsysMicroLock(ee, CVM_ACCESS_VOLATILE_MICROLOCK);
+        }
+ { CVMJavaVal32 volatile* fieldLoc_ = ((CVMJavaVal32 volatile *)(directObj) + (((fb)->offsetX))); union {CVMUint32 x;} tmp_[2]; ; { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&tmp_[0].x))->l = ((fakeOutGCCStrictAliasing *)(&(&((topOfStack[-2].s).j))->raw))->l; }; (&(fieldLoc_)->raw)[0] = tmp_[0].x; (&(fieldLoc_)->raw)[1] = tmp_[1].x; };
+        if (((0x40 & (0x01 | 0x03 | 0x02)) ? ((((fb)->accessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x40) : ((((fb)->accessFlagsX) & 0x40) != 0))) {
+            CVMsysMicroUnlock(ee, CVM_ACCESS_VOLATILE_MICROLOCK);
+        }
+ (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s (0x%X, 0x%X) ==> %O[%d]\n", CVMopnames[pc[0]], (((topOfStack[-1].s).j).i), (((topOfStack[0].s).j).i), directObj, ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))) : (void)0)
+                                    ;
+ topOfStack -= 3;
+    } else {
+ directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1361, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-2].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+ if (directObj == ((void *)0)) {
+     return ((void *)0);
+ }
+                                     ;
+ if (( ((((fb)->nameAndTypeIDX))&0xffff) > 10)) {
+     { CVMObject* volatile *fieldLoc_ = (CVMObject* volatile *)((CVMJavaVal32 volatile *)(directObj) + (((fb)->offsetX))); ((void)(((&(CVMglobals.gc.cardTableVirtualBase[(CVMAddr)((fieldLoc_)) / (1 << 9)])) >= CVMglobals.gc.cardTable) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1368, "CARD_TABLE_SLOT_ADDRESS_FOR((fieldLoc_)) >= CVMglobals.gc.cardTable") || (CVMsystemPanic("CVMassertHook returned"), 0))); ((void)(((&(CVMglobals.gc.cardTableVirtualBase[(CVMAddr)((fieldLoc_)) / (1 << 9)])) < CVMglobals.gc.cardTable + CVMglobals.gc.cardTableSize) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1368, "CARD_TABLE_SLOT_ADDRESS_FOR((fieldLoc_)) < CVMglobals.gc.cardTable + CVMglobals.gc.cardTableSize") || (CVMsystemPanic("CVMassertHook returned"), 0))); *(&(CVMglobals.gc.cardTableVirtualBase[(CVMAddr)((fieldLoc_)) / (1 << 9)])) = 1;; *fieldLoc_ = (((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1368, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))); };
+ } else {
+     { CVMJavaVal32 volatile* fieldLoc_ = ((CVMJavaVal32 volatile *)(directObj) + (((fb)->offsetX))); ; ((*fieldLoc_) = ((((topOfStack[-1].s).j)))); };
+ }
+ (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s (0x%X) ==> %O[%d]\n", CVMopnames[pc[0]], (((topOfStack[-1].s).j).i), directObj, ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))) : (void)0)
+                                                   ;
+ topOfStack -= 2;
+    }
+    return topOfStack;
+}
+static CVMBool
+CVMwideHelper(CVMExecEnv* ee, CVMSlotVal32* locals, CVMFrame* frame)
+{
+    CVMStackVal32* topOfStack;
+    CVMUint8* pc;
+    CVMUint16 reg;
+    CVMBool needRequestCheck = (!(1 == 1));
+    char trBuf[30];
+    pc = (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX);;
+    topOfStack = frame->topOfStack;;
+    reg = ((((*(CVMUint8*)((pc + 2)+(0))) << 8) | (*(CVMUint8*)((pc + 2)+(1)))));
+    ;
+    switch(pc[1]) {
+        case opc_aload:
+        case opc_iload:
+        case opc_fload:
+     (topOfStack[0].s) = locals[reg];
+     if (pc[1] == opc_iload) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tiload_w locals[%d](%d) =>\n", reg, (((topOfStack[0].s).j).i)) : (void)0); }
+                        ;
+     if (pc[1] == opc_aload) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\taload_w locals[%d](0x%x) =>\n", reg, ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1404, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[0].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))) : (void)0); }
+                           ;
+     if (pc[1] == opc_fload) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tfload_w locals[%d](%f) =>\n", reg, (((topOfStack[0].s).j).f)) : (void)0); }
+                          ;
+     { pc += 4; topOfStack += 1; ; };
+     break;
+        case opc_lload:
+        case opc_dload:
+     { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->l = ((fakeOutGCCStrictAliasing *)(&locals[reg].j.raw))->l; };
+     if (pc[1] == opc_lload) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tlload_w locals[%d](%s) =>\n", reg, (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0); }
+                                          ;
+     if (pc[1] == opc_dload) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tdload_w locals[%d](%f) =>\n", reg, ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->d); })) : (void)0); }
+                           ;
+     { pc += 4; topOfStack += 2; ; };
+     break;
+        case opc_istore:
+        case opc_astore:
+        case opc_fstore:
+     locals[reg] = (topOfStack[-1].s);
+     if (pc[1] == opc_istore) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tistore_w %d ==> locals[%d]\n", (((topOfStack[-1].s).j).i), reg) : (void)0); }
+                            ;
+     if (pc[1] == opc_astore) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tastore_w 0x%x => locals[%d]\n", ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1426, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY))), reg) : (void)0); }
+                             ;
+     if (pc[1] == opc_fstore) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tfstore_w %f ==> locals[%d]\n", (((topOfStack[-1].s).j).f), reg) : (void)0); }
+                              ;
+     { pc += 4; topOfStack += -1; ; };
+     break;
+        case opc_lstore:
+        case opc_dstore:
+     { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&locals[reg].j.raw))->l = ((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l; };
+     if (pc[1] == opc_lstore) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tlstore_w %s => locals[%d]\n", (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf), reg) : (void)0); }
+                                            ;
+     if (pc[1] == opc_dstore) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tdstore_w %f => locals[%d]\n", ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); }), reg) : (void)0); }
+                             ;
+     { pc += 4; topOfStack += -2; ; };
+     break;
+        case opc_iinc: {
+     CVMInt16 offset = ((CVMInt16) (((*(CVMUint8*)((pc+4)+(0))) << 8) | (*(CVMUint8*)((pc+4)+(1)))));
+     locals[reg].j.i += offset;
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tiinc_w locals[%d]+%d => %d\n", reg, offset, locals[reg].j.i) : (void)0)
+                              ;
+     { pc += 6; topOfStack += 0; ; };
+     break;
+ }
+        case opc_ret:
+     if (((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) {
+  needRequestCheck = (1 == 1);
+     }
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tret_w %d (%#x)\n", reg, locals[reg].a) : (void)0);
+     pc = locals[reg].a;
+     break;
+        default:
+     ((void)(((!(1 == 1))) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1458, "CVM_FALSE") || (CVMsystemPanic("CVMassertHook returned"), 0)));
+    }
+    (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+    frame->topOfStack = topOfStack;;
+    return needRequestCheck;
+}
+static void
+CVMmemCopy64Helper(CVMAddr* destination, CVMAddr* source) {
+    { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(destination))->l = ((fakeOutGCCStrictAliasing *)(source))->l; };
+}
+static CVMStackVal32*
+CVMreturn64Helper(CVMStackVal32* topOfStack, CVMFrame* frame)
+{
+    CVMJavaVal64 result;
+    { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(result.v))->l = ((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l; };
+    topOfStack = (((void)(((1 == 1)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1484, "CVMframeMaskBitsAreCorrect((frame))") || (CVMsystemPanic("CVMassertHook returned"), 0))), ((CVMFrame*)((CVMAddr)((frame)->prevX) & ~((1 << 2) - 1))))->topOfStack;;
+    { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->l = ((fakeOutGCCStrictAliasing *)(result.v))->l; };
+    return topOfStack;
+}
+static const CVMUint8 CVMinvokeStaticTransitionCode[] = {
+    opc_invokestatic_quick, 0, 1, opc_exittransition
+};
+static const CVMUint8 CVMinvokeVirtualTransitionCode[] = {
+    opc_invokevirtual_quick_w, 0, 1, opc_exittransition
+};
+static const CVMUint8 CVMinvokeNonVirtualTransitionCode[] = {
+    opc_invokenonvirtual_quick, 0, 1, opc_exittransition
+};
+static const CVMUint8 CVMinvokeInterfaceTransitionCode[] = {
+    opc_invokeinterface_quick, 0, 1, 0, 0, opc_exittransition
+};
+void
+CVMgcUnsafeExecuteJavaMethod(CVMExecEnv* volatile ee,
+                        CVMMethodBlock* mb,
+                        CVMBool isStatic, CVMBool isVirtual)
+{
+    CVMFrame* frame = ((void *)0);
+    CVMFrame* initialframe = ((void *)0);
+    CVMStack* stack = &ee->interpreterStack;
+    CVMStackVal32* topOfStack = ((void *)0);
+    CVMSlotVal32* locals = ((void *)0);
+    CVMUint8* pc = ((void *)0);
+    CVMConstantPool* cp = ((void *)0);
+    CVMTransitionConstantPool transitioncp;
+    CVMClassBlock* initCb = ((void *)0);
+    char trBuf[30];
+    static const void* const opclabels_data[256] = {
+ &&opc_nop, &&opc_aconst_null, &&opc_iconst_m1, &&opc_iconst_0, &&opc_iconst_1, &&opc_iconst_2,
+ &&opc_iconst_3, &&opc_iconst_4, &&opc_iconst_5, &&opc_lconst_0, &&opc_lconst_1, &&opc_fconst_0,
+ &&opc_fconst_1, &&opc_fconst_2, &&opc_dconst_0, &&opc_dconst_1, &&opc_bipush, &&opc_sipush,
+ &&opc_ldc, &&opc_ldc_w, &&opc_ldc2_w, &&opc_iload, &&opc_lload, &&opc_fload,
+ &&opc_dload, &&opc_aload, &&opc_iload_0, &&opc_iload_1, &&opc_iload_2, &&opc_iload_3,
+ &&opc_lload_0, &&opc_lload_1, &&opc_lload_2, &&opc_lload_3, &&opc_fload_0, &&opc_fload_1,
+ &&opc_fload_2, &&opc_fload_3, &&opc_dload_0, &&opc_dload_1, &&opc_dload_2, &&opc_dload_3,
+ &&opc_aload_0, &&opc_aload_1, &&opc_aload_2, &&opc_aload_3, &&opc_iaload, &&opc_laload,
+ &&opc_faload, &&opc_daload, &&opc_aaload, &&opc_baload, &&opc_caload, &&opc_saload,
+ &&opc_istore, &&opc_lstore, &&opc_fstore, &&opc_dstore, &&opc_astore, &&opc_istore_0,
+ &&opc_istore_1, &&opc_istore_2, &&opc_istore_3, &&opc_lstore_0, &&opc_lstore_1, &&opc_lstore_2,
+ &&opc_lstore_3, &&opc_fstore_0, &&opc_fstore_1, &&opc_fstore_2, &&opc_fstore_3, &&opc_dstore_0,
+ &&opc_dstore_1, &&opc_dstore_2, &&opc_dstore_3, &&opc_astore_0, &&opc_astore_1, &&opc_astore_2,
+ &&opc_astore_3, &&opc_iastore, &&opc_lastore, &&opc_fastore, &&opc_dastore, &&opc_aastore,
+ &&opc_bastore, &&opc_castore, &&opc_sastore, &&opc_pop, &&opc_pop2, &&opc_dup,
+ &&opc_dup_x1, &&opc_dup_x2, &&opc_dup2, &&opc_dup2_x1, &&opc_dup2_x2, &&opc_swap,
+ &&opc_iadd, &&opc_ladd, &&opc_fadd, &&opc_dadd, &&opc_isub, &&opc_lsub,
+ &&opc_fsub, &&opc_dsub, &&opc_imul, &&opc_lmul, &&opc_fmul, &&opc_dmul,
+ &&opc_idiv, &&opc_ldiv, &&opc_fdiv, &&opc_ddiv, &&opc_irem, &&opc_lrem,
+ &&opc_frem, &&opc_drem, &&opc_ineg, &&opc_lneg, &&opc_fneg, &&opc_dneg,
+ &&opc_ishl, &&opc_lshl, &&opc_ishr, &&opc_lshr, &&opc_iushr, &&opc_lushr,
+ &&opc_iand, &&opc_land, &&opc_ior, &&opc_lor, &&opc_ixor, &&opc_lxor,
+ &&opc_iinc, &&opc_i2l, &&opc_i2f, &&opc_i2d, &&opc_l2i, &&opc_l2f,
+ &&opc_l2d, &&opc_f2i, &&opc_f2l, &&opc_f2d, &&opc_d2i, &&opc_d2l,
+ &&opc_d2f, &&opc_i2b, &&opc_i2c, &&opc_i2s, &&opc_lcmp, &&opc_fcmpl,
+ &&opc_fcmpg, &&opc_dcmpl, &&opc_dcmpg, &&opc_ifeq, &&opc_ifne, &&opc_iflt,
+ &&opc_ifge, &&opc_ifgt, &&opc_ifle, &&opc_if_icmpeq, &&opc_if_icmpne, &&opc_if_icmplt,
+ &&opc_if_icmpge, &&opc_if_icmpgt, &&opc_if_icmple, &&opc_if_acmpeq, &&opc_if_acmpne, &&opc_goto,
+ &&opc_jsr, &&opc_ret, &&opc_tableswitch, &&opc_lookupswitch, &&opc_ireturn, &&opc_lreturn,
+ &&opc_freturn, &&opc_dreturn, &&opc_areturn, &&opc_return, &&opc_getstatic, &&opc_putstatic,
+ &&opc_getfield, &&opc_putfield, &&opc_invokevirtual, &&opc_invokespecial, &&opc_invokestatic, &&opc_invokeinterface,
+ &&opc_xxxunusedxxx, &&opc_new, &&opc_newarray, &&opc_anewarray, &&opc_arraylength, &&opc_athrow,
+ &&opc_checkcast, &&opc_instanceof, &&opc_monitorenter, &&opc_monitorexit, &&opc_wide, &&opc_multianewarray,
+ &&opc_ifnull, &&opc_ifnonnull, &&opc_goto_w, &&opc_jsr_w, &&opc_breakpoint, &&opc_aldc_ind_quick,
+ &&opc_aldc_ind_w_quick, &&opc_invokestatic_quick, &&opc_invokestatic_checkinit_quick, &&opc_invokevirtual_quick, &&opc_getfield_quick, &&opc_agetfield_quick,
+ &&opc_vinvokevirtual_quick, &&opc_invokevirtual_quick_w, &&opc_putfield_quick, &&opc_invokenonvirtual_quick, &&opc_invokesuper_quick, &&opc_invokeignored_quick,
+ &&opc_getfield2_quick, &&opc_checkcast_quick, &&opc_instanceof_quick, &&opc_nonnull_quick, &&opc_putfield2_quick, &&opc_ainvokevirtual_quick,
+ &&opc_invokevirtualobject_quick, &&opc_invokeinterface_quick, &&opc_aldc_quick, &&opc_ldc_quick, &&opc_exittransition, &&opc_dinvokevirtual_quick,
+ &&opc_aldc_w_quick, &&opc_ldc_w_quick, &&opc_aputfield_quick, &&opc_getfield_quick_w, &&opc_ldc2_w_quick, &&opc_agetstatic_quick,
+ &&opc_getstatic_quick, &&opc_getstatic2_quick, &&opc_aputstatic_quick, &&opc_putstatic_quick, &&opc_putstatic2_quick, &&opc_agetstatic_checkinit_quick,
+ &&opc_getstatic_checkinit_quick, &&opc_getstatic2_checkinit_quick, &&opc_aputstatic_checkinit_quick, &&opc_putstatic_checkinit_quick, &&opc_putstatic2_checkinit_quick, &&opc_putfield_quick_w,
+ &&opc_new_checkinit_quick, &&opc_new_quick, &&opc_anewarray_quick, &&opc_multianewarray_quick, &&opc_prefix, &&opc_DEFAULT,
+ &&opc_DEFAULT, &&opc_DEFAULT, &&opc_DEFAULT, &&opc_DEFAULT
+    };
+    const void* const *opclabels = &opclabels_data[0];
+    if (!CVMCstackCheckSize(ee, (5976 + (3 * 1024)),
+        "CVMgcUnsafeExecuteJavaMethod", (1 == 1))) {
+ goto return_from_executejava_branch_island;
+    }
+    ((void)(((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1625, "CVMD_isgcUnsafe(ee)") || (CVMsystemPanic("CVMassertHook returned"), 0)));
+    frame = stack->currentFrame;;
+    initialframe = frame;
+new_transition:
+    ;
+    ((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1640, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_TRANSITION)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1640, "CVMframeIsTransition(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0)));
+    topOfStack = frame->topOfStack;;
+    if (isStatic) {
+ pc = (CVMUint8*)CVMinvokeStaticTransitionCode;
+    } else {
+ if ((((((((CVMMethodRange*) ((CVMUint8 *)((mb) - ((mb)->immutX.methodIndexX)) - ((CVMAddr)(&(((CVMMethodRange *)0)->mb[0])) - (CVMAddr)(&(((CVMMethodRange *)0)->cb)))))->cb))->accessFlagsX) & 0x200) != 0)) {
+     pc = (CVMUint8*)CVMinvokeInterfaceTransitionCode;
+ } else if (isVirtual && !((0x03 & (0x01 | 0x03 | 0x02)) ? ((((mb)->immutX.invokerAndAccessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x03) : ((((mb)->immutX.invokerAndAccessFlagsX) & 0x03) != 0)) &&
+     !(((((((mb)->immutX.nameAndTypeIDX))&0xffff0000) == ((CVMglobals.initTid)&0xffff0000))))) {
+     pc = (CVMUint8*)CVMinvokeVirtualTransitionCode;
+ } else {
+     pc = (CVMUint8*)CVMinvokeNonVirtualTransitionCode;
+ }
+    }
+    isVirtual = (!(1 == 1));
+    (&transitioncp)->cp.cpTypesX = ((void *)0); (&transitioncp)->entry1X.resolved.mb = mb;;
+    cp = (CVMConstantPool*)&transitioncp;
+    (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+    if ((CVMglobals.debugFlags & ((2L)))) { CVMtraceMethodCall(ee, frame, (!(1 == 1))); };
+    ((CVMglobals.debugFlags & ((4L))) != 0 ? CVMconsolePrintf ("stack=0x%x frame=0x%x locals=0x%x tos=0x%x pc=0x%x\n", stack, frame, locals, topOfStack, pc) : (void)0);;
+    {
+ const void* nextLabel;;
+ nextLabel = opclabels[pc[0]];;
+ goto *nextLabel;;
+    }
+    {
+ {
+ opc_nop: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1705, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s\n", CVMopnames[pc[0]]) : (void)0);
+     { pc += 1; topOfStack += 0; ; }; ; goto *nextLabel;; };
+ opc_aconst_null: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1711, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     (&(((topOfStack[0].s).j).r))->ref_DONT_ACCESS_DIRECTLY = 0;;
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s\n", CVMopnames[pc[0]]) : (void)0);
+     { pc += 1; topOfStack += 1; ; }; ; goto *nextLabel;; };
+     opc_iconst_m1: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1730, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; ((topOfStack[0].s).j).i = -1; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s\n", CVMopnames[pc[0]]) : (void)0); { pc += 1; topOfStack += 1; ; }; ; goto *nextLabel;; };;
+     opc_iconst_0: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1731, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; ((topOfStack[0].s).j).i = 0; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s\n", CVMopnames[pc[0]]) : (void)0); { pc += 1; topOfStack += 1; ; }; ; goto *nextLabel;; };;
+     opc_iconst_1: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1732, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; ((topOfStack[0].s).j).i = 1; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s\n", CVMopnames[pc[0]]) : (void)0); { pc += 1; topOfStack += 1; ; }; ; goto *nextLabel;; };;
+     opc_iconst_2: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1733, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; ((topOfStack[0].s).j).i = 2; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s\n", CVMopnames[pc[0]]) : (void)0); { pc += 1; topOfStack += 1; ; }; ; goto *nextLabel;; };;
+     opc_iconst_3: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1734, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; ((topOfStack[0].s).j).i = 3; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s\n", CVMopnames[pc[0]]) : (void)0); { pc += 1; topOfStack += 1; ; }; ; goto *nextLabel;; };;
+     opc_iconst_4: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1735, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; ((topOfStack[0].s).j).i = 4; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s\n", CVMopnames[pc[0]]) : (void)0); { pc += 1; topOfStack += 1; ; }; ; goto *nextLabel;; };;
+     opc_iconst_5: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1736, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; ((topOfStack[0].s).j).i = 5; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s\n", CVMopnames[pc[0]]) : (void)0); { pc += 1; topOfStack += 1; ; }; ; goto *nextLabel;; };;
+     opc_lconst_0: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1738, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->l = (0LL); }; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s\n", CVMopnames[pc[0]]) : (void)0); { pc += 1; topOfStack += 2; ; }; ; goto *nextLabel;; };;
+     opc_lconst_1: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1739, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->l = (1LL); }; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s\n", CVMopnames[pc[0]]) : (void)0); { pc += 1; topOfStack += 2; ; }; ; goto *nextLabel;; };;
+     opc_fconst_0: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1741, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; ((topOfStack[0].s).j).f = 0.0; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s\n", CVMopnames[pc[0]]) : (void)0); { pc += 1; topOfStack += 1; ; }; ; goto *nextLabel;; };;
+     opc_fconst_1: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1742, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; ((topOfStack[0].s).j).f = 1.0; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s\n", CVMopnames[pc[0]]) : (void)0); { pc += 1; topOfStack += 1; ; }; ; goto *nextLabel;; };;
+     opc_fconst_2: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1743, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; ((topOfStack[0].s).j).f = 2.0; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s\n", CVMopnames[pc[0]]) : (void)0); { pc += 1; topOfStack += 1; ; }; ; goto *nextLabel;; };;
+     opc_dconst_0: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1745, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->d = (0.0); }; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s\n", CVMopnames[pc[0]]) : (void)0); { pc += 1; topOfStack += 2; ; }; ; goto *nextLabel;; };;
+     opc_dconst_1: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1746, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->d = (1.0); }; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s\n", CVMopnames[pc[0]]) : (void)0); { pc += 1; topOfStack += 2; ; }; ; goto *nextLabel;; };;
+ opc_bipush: { const void* nextLabel; ; ((void)((2 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1749, "2 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[2]];;
+     (((topOfStack[0].s).j).i) = (CVMInt8)(pc[1]);
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tbipush %d\n", (((topOfStack[0].s).j).i)) : (void)0);
+     { pc += 2; topOfStack += 1; ; }; ; goto *nextLabel;; };
+ opc_sipush: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1755, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];;
+     (((topOfStack[0].s).j).i) = ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))));
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tsipush %d\n", (((topOfStack[0].s).j).i)) : (void)0);
+     { pc += 3; topOfStack += 1; ; }; ; goto *nextLabel;; };
+ opc_aload: ;
+ opc_iload: ;
+ opc_fload: { const void* nextLabel; ; ((void)((2 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1764, "2 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[2]];; {
+     CVMUint32 localNo = pc[1];
+            CVMSlotVal32 l = locals[localNo];
+     topOfStack += 1;
+     (topOfStack[-1].s) = l;
+     if (pc[0] == opc_aload) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\taload locals[%d](0x%x) =>\n", pc[1], ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1770, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))) : (void)0); }
+                             ;
+     if (pc[0] == opc_iload) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tiload locals[%d](%d) =>\n", pc[1], (((topOfStack[-1].s).j).i)) : (void)0); }
+                          ;
+     if (pc[0] == opc_fload) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tfload locals[%d](%f) =>\n", pc[1], (((topOfStack[-1].s).j).f)) : (void)0); }
+                            ;
+     { pc += 2; topOfStack += 0; ; }; ; goto *nextLabel;; };
+ }
+        opc_lload: ;
+ opc_dload: { const void* nextLabel; ; ((void)((2 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1779, "2 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[2]];; {
+     { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->l = ((fakeOutGCCStrictAliasing *)(&locals[pc[1]].j.raw))->l; };
+     if (pc[0] == opc_dload) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tdload locals[%d](%f) =>\n", pc[1], ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->d); })) : (void)0); }
+                            ;
+     if (pc[0] == opc_lload) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tlload locals[%d](%s) =>\n", pc[1], (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0); }
+                                           ;
+     { pc += 2; topOfStack += 2; ; }; ; goto *nextLabel;; };
+ }
+ opc_iload_0: ; opc_aload_0: ; opc_fload_0: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1810, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { CVMSlotVal32 l; pc += 1; l = locals[0]; topOfStack += 1; (topOfStack[-1].s) = l; if (pc[0] == opc_iload_0) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](%d) =>\n", CVMopnames[pc[-1]], 0, (((topOfStack[-1].s).j).i)) : (void)0); }; if (pc[0] == opc_aload_0) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](0x%x) =>\n", CVMopnames[pc[-1]], 0, ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1810, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))) : (void)0); }; if (pc[0] == opc_fload_0) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](%f) =>\n", CVMopnames[pc[-1]], 0, (((topOfStack[-1].s).j).f)) : (void)0); }; { pc += 0; topOfStack += 0; ; }; ; goto *nextLabel;; }; };
+ opc_iload_1: ; opc_aload_1: ; opc_fload_1: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1811, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { CVMSlotVal32 l; pc += 1; l = locals[1]; topOfStack += 1; (topOfStack[-1].s) = l; if (pc[0] == opc_iload_1) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](%d) =>\n", CVMopnames[pc[-1]], 1, (((topOfStack[-1].s).j).i)) : (void)0); }; if (pc[0] == opc_aload_1) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](0x%x) =>\n", CVMopnames[pc[-1]], 1, ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1811, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))) : (void)0); }; if (pc[0] == opc_fload_1) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](%f) =>\n", CVMopnames[pc[-1]], 1, (((topOfStack[-1].s).j).f)) : (void)0); }; { pc += 0; topOfStack += 0; ; }; ; goto *nextLabel;; }; };
+ opc_iload_2: ; opc_aload_2: ; opc_fload_2: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1812, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { CVMSlotVal32 l; pc += 1; l = locals[2]; topOfStack += 1; (topOfStack[-1].s) = l; if (pc[0] == opc_iload_2) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](%d) =>\n", CVMopnames[pc[-1]], 2, (((topOfStack[-1].s).j).i)) : (void)0); }; if (pc[0] == opc_aload_2) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](0x%x) =>\n", CVMopnames[pc[-1]], 2, ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1812, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))) : (void)0); }; if (pc[0] == opc_fload_2) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](%f) =>\n", CVMopnames[pc[-1]], 2, (((topOfStack[-1].s).j).f)) : (void)0); }; { pc += 0; topOfStack += 0; ; }; ; goto *nextLabel;; }; };
+ opc_iload_3: ; opc_aload_3: ; opc_fload_3: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1813, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { CVMSlotVal32 l; pc += 1; l = locals[3]; topOfStack += 1; (topOfStack[-1].s) = l; if (pc[0] == opc_iload_3) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](%d) =>\n", CVMopnames[pc[-1]], 3, (((topOfStack[-1].s).j).i)) : (void)0); }; if (pc[0] == opc_aload_3) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](0x%x) =>\n", CVMopnames[pc[-1]], 3, ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1813, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))) : (void)0); }; if (pc[0] == opc_fload_3) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](%f) =>\n", CVMopnames[pc[-1]], 3, (((topOfStack[-1].s).j).f)) : (void)0); }; { pc += 0; topOfStack += 0; ; }; ; goto *nextLabel;; }; };
+ opc_lload_0: ; opc_dload_0: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1830, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->l = ((fakeOutGCCStrictAliasing *)(&locals[0].j.raw))->l; }; if (pc[0] == opc_lload_0) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](%s) =>\n", CVMopnames[pc[0]], 0, (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0); }; if (pc[0] == opc_dload_0) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](%f) =>\n", CVMopnames[pc[0]], 0, ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->d); })) : (void)0); }; { pc += 1; topOfStack += 2; ; }; ; goto *nextLabel;; }; };
+ opc_lload_1: ; opc_dload_1: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1831, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->l = ((fakeOutGCCStrictAliasing *)(&locals[1].j.raw))->l; }; if (pc[0] == opc_lload_1) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](%s) =>\n", CVMopnames[pc[0]], 1, (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0); }; if (pc[0] == opc_dload_1) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](%f) =>\n", CVMopnames[pc[0]], 1, ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->d); })) : (void)0); }; { pc += 1; topOfStack += 2; ; }; ; goto *nextLabel;; }; };
+ opc_lload_2: ; opc_dload_2: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1832, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->l = ((fakeOutGCCStrictAliasing *)(&locals[2].j.raw))->l; }; if (pc[0] == opc_lload_2) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](%s) =>\n", CVMopnames[pc[0]], 2, (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0); }; if (pc[0] == opc_dload_2) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](%f) =>\n", CVMopnames[pc[0]], 2, ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->d); })) : (void)0); }; { pc += 1; topOfStack += 2; ; }; ; goto *nextLabel;; }; };
+ opc_lload_3: ; opc_dload_3: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1833, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->l = ((fakeOutGCCStrictAliasing *)(&locals[3].j.raw))->l; }; if (pc[0] == opc_lload_3) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](%s) =>\n", CVMopnames[pc[0]], 3, (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0); }; if (pc[0] == opc_dload_3) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s locals[%d](%f) =>\n", CVMopnames[pc[0]], 3, ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->d); })) : (void)0); }; { pc += 1; topOfStack += 2; ; }; ; goto *nextLabel;; }; };
+        opc_iaload: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1872, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMArrayOfInt* arrObj = (CVMArrayOfInt*)((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1873, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-2].s).j).r))->ref_DONT_ACCESS_DIRECTLY))); CVMJavaInt index = (((topOfStack[-2 + 1].s).j).i); if ((arrObj) == 0) { goto null_pointer_exception; }; if ((CVMUint32)index >= ((arrObj)->length)) { goto array_index_out_of_bounds_exception; }; { CVMJavaInt volatile *elemLoc_ = (CVMJavaInt volatile *)(&((arrObj)->elems[(index)])); ((void)((index < ((arrObj)->length)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1873, "index < CVMD_arrayGetLength(arrObj)") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; ((((topOfStack[-2].s).j).i)) = *elemLoc_; }; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %O[%d](" "%d" ") ==>\n", CVMopnames[pc[0]], arrObj, index, (((topOfStack[-1].s).j).i)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; }; };
+        opc_laload: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1874, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMJavaLong temp64; CVMArrayOfLong* arrObj = (CVMArrayOfLong*)((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1875, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-2].s).j).r))->ref_DONT_ACCESS_DIRECTLY))); CVMJavaInt index = (((topOfStack[-2 + 1].s).j).i); if ((arrObj) == 0) { goto null_pointer_exception; }; if ((CVMUint32)index >= ((arrObj)->length)) { goto array_index_out_of_bounds_exception; }; { CVMJavaVal32 volatile *elemLoc_ = (CVMJavaVal32 volatile *)(&((arrObj)->elems[(index)])); ; *(CVMJavaLong volatile *)&(temp64) = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)((CVMUint32*)&(elemLoc_)->raw))->l); }); }; { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l = temp64; }; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %O[%d](0x%X, 0x%X) ==>\n", CVMopnames[pc[0]], arrObj, index, (((topOfStack[-2].s).j).i), (((topOfStack[-1].s).j).i)) : (void)0); { pc += 1; topOfStack += 0; ; }; ; goto *nextLabel;; }; };
+        opc_faload: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1876, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMArrayOfFloat* arrObj = (CVMArrayOfFloat*)((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1877, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-2].s).j).r))->ref_DONT_ACCESS_DIRECTLY))); CVMJavaInt index = (((topOfStack[-2 + 1].s).j).i); if ((arrObj) == 0) { goto null_pointer_exception; }; if ((CVMUint32)index >= ((arrObj)->length)) { goto array_index_out_of_bounds_exception; }; { CVMJavaFloat volatile *elemLoc_ = (CVMJavaFloat volatile *)(&((arrObj)->elems[(index)])); ((void)((index < ((arrObj)->length)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1877, "index < CVMD_arrayGetLength(arrObj)") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; ((((topOfStack[-2].s).j).f)) = *elemLoc_; }; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %O[%d](" "%f" ") ==>\n", CVMopnames[pc[0]], arrObj, index, (((topOfStack[-1].s).j).f)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; }; };
+        opc_daload: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1878, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMJavaDouble temp64; CVMArrayOfDouble* arrObj = (CVMArrayOfDouble*)((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1879, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-2].s).j).r))->ref_DONT_ACCESS_DIRECTLY))); CVMJavaInt index = (((topOfStack[-2 + 1].s).j).i); if ((arrObj) == 0) { goto null_pointer_exception; }; if ((CVMUint32)index >= ((arrObj)->length)) { goto array_index_out_of_bounds_exception; }; { CVMJavaVal32 volatile *elemLoc_ = (CVMJavaVal32 volatile *)(&((arrObj)->elems[(index)])); ; *(CVMJavaDouble volatile*)&(temp64) = ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)((CVMUint32*)&(elemLoc_)->raw))->d); }); }; { typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d = temp64; }; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %O[%d](0x%X, 0x%X) ==>\n", CVMopnames[pc[0]], arrObj, index, (((topOfStack[-2].s).j).i), (((topOfStack[-1].s).j).i)) : (void)0); { pc += 1; topOfStack += 0; ; }; ; goto *nextLabel;; }; };
+        opc_aaload: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1880, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMArrayOfRef* arrObj = (CVMArrayOfRef*)((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1881, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-2].s).j).r))->ref_DONT_ACCESS_DIRECTLY))); CVMJavaInt index = (((topOfStack[-2 + 1].s).j).i); if ((arrObj) == 0) { goto null_pointer_exception; }; if ((CVMUint32)index >= ((arrObj)->length)) { goto array_index_out_of_bounds_exception; }; { CVMObject* volatile *elemLoc_ = (CVMObject* volatile *)(&((arrObj)->elems[(index)])); ((void)((index < ((arrObj)->length)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1881, "index < CVMD_arrayGetLength(arrObj)") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; (((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1881, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-2].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))) = *elemLoc_; }; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %O[%d](" "0x%x" ") ==>\n", CVMopnames[pc[0]], arrObj, index, ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1881, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; }; };
+        opc_baload: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1882, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMArrayOfByte* arrObj = (CVMArrayOfByte*)((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1883, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-2].s).j).r))->ref_DONT_ACCESS_DIRECTLY))); CVMJavaInt index = (((topOfStack[-2 + 1].s).j).i); if ((arrObj) == 0) { goto null_pointer_exception; }; if ((CVMUint32)index >= ((arrObj)->length)) { goto array_index_out_of_bounds_exception; }; { CVMJavaByte volatile *elemLoc_ = (CVMJavaByte volatile *)(&((arrObj)->elems[(index)])); ((void)((index < ((arrObj)->length)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1883, "index < CVMD_arrayGetLength(arrObj)") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; ((((topOfStack[-2].s).j).i)) = *elemLoc_; }; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %O[%d](" "%d" ") ==>\n", CVMopnames[pc[0]], arrObj, index, (((topOfStack[-1].s).j).i)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; }; };
+        opc_caload: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1884, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMArrayOfChar* arrObj = (CVMArrayOfChar*)((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1885, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-2].s).j).r))->ref_DONT_ACCESS_DIRECTLY))); CVMJavaInt index = (((topOfStack[-2 + 1].s).j).i); if ((arrObj) == 0) { goto null_pointer_exception; }; if ((CVMUint32)index >= ((arrObj)->length)) { goto array_index_out_of_bounds_exception; }; { CVMJavaChar volatile *elemLoc_ = (CVMJavaChar volatile *)(&((arrObj)->elems[(index)])); ((void)((index < ((arrObj)->length)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1885, "index < CVMD_arrayGetLength(arrObj)") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; ((((topOfStack[-2].s).j).i)) = *elemLoc_; }; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %O[%d](" "%d" ") ==>\n", CVMopnames[pc[0]], arrObj, index, (((topOfStack[-1].s).j).i)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; }; };
+        opc_saload: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1886, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMArrayOfShort* arrObj = (CVMArrayOfShort*)((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1887, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-2].s).j).r))->ref_DONT_ACCESS_DIRECTLY))); CVMJavaInt index = (((topOfStack[-2 + 1].s).j).i); if ((arrObj) == 0) { goto null_pointer_exception; }; if ((CVMUint32)index >= ((arrObj)->length)) { goto array_index_out_of_bounds_exception; }; { CVMJavaShort volatile *elemLoc_ = (CVMJavaShort volatile *)(&((arrObj)->elems[(index)])); ((void)((index < ((arrObj)->length)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1887, "index < CVMD_arrayGetLength(arrObj)") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; ((((topOfStack[-2].s).j).i)) = *elemLoc_; }; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %O[%d](" "%d" ") ==>\n", CVMopnames[pc[0]], arrObj, index, (((topOfStack[-1].s).j).i)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; }; };
+ opc_istore: ;
+ opc_fstore: ;
+ opc_astore: { const void* nextLabel; ; ((void)((2 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1893, "2 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[2]];; {
+     locals[pc[1]] = (topOfStack[-1].s);
+     if (pc[0] == opc_istore) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tistore %d ==> locals[%d]\n", (((topOfStack[-1].s).j).i), pc[-1]) : (void)0); }
+                            ;
+     if (pc[0] == opc_astore) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tastore 0x%x => locals[%d]\n", ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1898, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY))), pc[-1]) : (void)0); }
+                               ;
+     if (pc[0] == opc_fstore) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tfstore %f ==> locals[%d]\n", (((topOfStack[-1].s).j).f), pc[-1]) : (void)0); }
+                              ;
+     { pc += 2; topOfStack += -1; ; }; ; goto *nextLabel;; };
+ }
+ opc_lstore: ;
+        opc_dstore: { const void* nextLabel; ; ((void)((2 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1906, "2 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[2]];; {
+     { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&locals[pc[1]].j.raw))->l = ((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l; };
+     if (pc[0] == opc_dstore) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tdstore %f => locals[%d]\n", ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); }), pc[1]) : (void)0); }
+                              ;
+     if (pc[0] == opc_lstore) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tlstore %s => locals[%d]\n", (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf), pc[1]) : (void)0); }
+                                             ;
+     { pc += 2; topOfStack += -2; ; }; ; goto *nextLabel;; };
+ }
+ opc_istore_0: ; opc_astore_0: ; opc_fstore_0: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1933, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { locals[0] = (topOfStack[-1].s); if (pc[0] == opc_istore_0) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %d => locals[%d]\n", CVMopnames[pc[0]], (((topOfStack[-1].s).j).i), 0) : (void)0); }; if (pc[0] == opc_astore_0) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s 0x%x => locals[%d]\n", CVMopnames[pc[0]], ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1933, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY))), 0) : (void)0); }; if (pc[0] == opc_fstore_0) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %f => locals[%d]\n", CVMopnames[pc[0]], (((topOfStack[-1].s).j).f), 0) : (void)0); }; { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; }; };
+ opc_istore_1: ; opc_astore_1: ; opc_fstore_1: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1934, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { locals[1] = (topOfStack[-1].s); if (pc[0] == opc_istore_1) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %d => locals[%d]\n", CVMopnames[pc[0]], (((topOfStack[-1].s).j).i), 1) : (void)0); }; if (pc[0] == opc_astore_1) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s 0x%x => locals[%d]\n", CVMopnames[pc[0]], ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1934, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY))), 1) : (void)0); }; if (pc[0] == opc_fstore_1) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %f => locals[%d]\n", CVMopnames[pc[0]], (((topOfStack[-1].s).j).f), 1) : (void)0); }; { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; }; };
+ opc_istore_2: ; opc_astore_2: ; opc_fstore_2: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1935, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { locals[2] = (topOfStack[-1].s); if (pc[0] == opc_istore_2) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %d => locals[%d]\n", CVMopnames[pc[0]], (((topOfStack[-1].s).j).i), 2) : (void)0); }; if (pc[0] == opc_astore_2) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s 0x%x => locals[%d]\n", CVMopnames[pc[0]], ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1935, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY))), 2) : (void)0); }; if (pc[0] == opc_fstore_2) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %f => locals[%d]\n", CVMopnames[pc[0]], (((topOfStack[-1].s).j).f), 2) : (void)0); }; { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; }; };
+ opc_istore_3: ; opc_astore_3: ; opc_fstore_3: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1936, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { locals[3] = (topOfStack[-1].s); if (pc[0] == opc_istore_3) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %d => locals[%d]\n", CVMopnames[pc[0]], (((topOfStack[-1].s).j).i), 3) : (void)0); }; if (pc[0] == opc_astore_3) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s 0x%x => locals[%d]\n", CVMopnames[pc[0]], ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1936, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY))), 3) : (void)0); }; if (pc[0] == opc_fstore_3) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %f => locals[%d]\n", CVMopnames[pc[0]], (((topOfStack[-1].s).j).f), 3) : (void)0); }; { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; }; };
+ opc_lstore_0: ; opc_dstore_0: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1953, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&locals[0].j.raw))->l = ((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l; }; if (pc[0] == opc_lstore_0) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %s => locals[%d]\n", CVMopnames[pc[0]], (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf), 0) : (void)0); }; if (pc[0] == opc_dstore_0) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %f => locals[%d]\n", CVMopnames[pc[0]], ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); }), 0) : (void)0); }; { pc += 1; topOfStack += -2; ; }; ; goto *nextLabel;; }; };
+ opc_lstore_1: ; opc_dstore_1: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1954, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&locals[1].j.raw))->l = ((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l; }; if (pc[0] == opc_lstore_1) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %s => locals[%d]\n", CVMopnames[pc[0]], (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf), 1) : (void)0); }; if (pc[0] == opc_dstore_1) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %f => locals[%d]\n", CVMopnames[pc[0]], ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); }), 1) : (void)0); }; { pc += 1; topOfStack += -2; ; }; ; goto *nextLabel;; }; };
+ opc_lstore_2: ; opc_dstore_2: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1955, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&locals[2].j.raw))->l = ((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l; }; if (pc[0] == opc_lstore_2) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %s => locals[%d]\n", CVMopnames[pc[0]], (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf), 2) : (void)0); }; if (pc[0] == opc_dstore_2) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %f => locals[%d]\n", CVMopnames[pc[0]], ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); }), 2) : (void)0); }; { pc += 1; topOfStack += -2; ; }; ; goto *nextLabel;; }; };
+ opc_lstore_3: ; opc_dstore_3: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1956, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&locals[3].j.raw))->l = ((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l; }; if (pc[0] == opc_lstore_3) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %s => locals[%d]\n", CVMopnames[pc[0]], (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf), 3) : (void)0); }; if (pc[0] == opc_dstore_3) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %f => locals[%d]\n", CVMopnames[pc[0]], ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); }), 3) : (void)0); }; { pc += 1; topOfStack += -2; ; }; ; goto *nextLabel;; }; };
+        opc_bastore: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1982, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMArrayOfByte* arrObj = (CVMArrayOfByte*)((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1983, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-3].s).j).r))->ref_DONT_ACCESS_DIRECTLY))); CVMJavaInt index = (((topOfStack[-3 + 1].s).j).i); if ((arrObj) == 0) { goto null_pointer_exception; }; if ((CVMUint32)index >= ((arrObj)->length)) { goto array_index_out_of_bounds_exception; }; { CVMJavaByte volatile *elemLoc_ = (CVMJavaByte volatile *)(&((arrObj)->elems[(index)])); ((void)((index < ((arrObj)->length)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1983, "index < CVMD_arrayGetLength(arrObj)") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; *elemLoc_ = ((((topOfStack[-1].s).j).i)); }; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s " "%d" " ==> %O[%d] ==>\n", CVMopnames[pc[0]], (((topOfStack[-1].s).j).i), arrObj, index) : (void)0); { pc += 1; topOfStack += -3; ; }; ; goto *nextLabel;; }; };
+        opc_castore: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1984, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMArrayOfChar* arrObj = (CVMArrayOfChar*)((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1985, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-3].s).j).r))->ref_DONT_ACCESS_DIRECTLY))); CVMJavaInt index = (((topOfStack[-3 + 1].s).j).i); if ((arrObj) == 0) { goto null_pointer_exception; }; if ((CVMUint32)index >= ((arrObj)->length)) { goto array_index_out_of_bounds_exception; }; { CVMJavaChar volatile *elemLoc_ = (CVMJavaChar volatile *)(&((arrObj)->elems[(index)])); ((void)((index < ((arrObj)->length)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1985, "index < CVMD_arrayGetLength(arrObj)") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; *elemLoc_ = ((((topOfStack[-1].s).j).i)); }; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s " "%d" " ==> %O[%d] ==>\n", CVMopnames[pc[0]], (((topOfStack[-1].s).j).i), arrObj, index) : (void)0); { pc += 1; topOfStack += -3; ; }; ; goto *nextLabel;; }; };
+        opc_sastore: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1986, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMArrayOfShort* arrObj = (CVMArrayOfShort*)((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1987, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-3].s).j).r))->ref_DONT_ACCESS_DIRECTLY))); CVMJavaInt index = (((topOfStack[-3 + 1].s).j).i); if ((arrObj) == 0) { goto null_pointer_exception; }; if ((CVMUint32)index >= ((arrObj)->length)) { goto array_index_out_of_bounds_exception; }; { CVMJavaShort volatile *elemLoc_ = (CVMJavaShort volatile *)(&((arrObj)->elems[(index)])); ((void)((index < ((arrObj)->length)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1987, "index < CVMD_arrayGetLength(arrObj)") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; *elemLoc_ = ((((topOfStack[-1].s).j).i)); }; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s " "%d" " ==> %O[%d] ==>\n", CVMopnames[pc[0]], (((topOfStack[-1].s).j).i), arrObj, index) : (void)0); { pc += 1; topOfStack += -3; ; }; ; goto *nextLabel;; }; };
+        opc_iastore: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1988, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMArrayOfInt* arrObj = (CVMArrayOfInt*)((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1989, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-3].s).j).r))->ref_DONT_ACCESS_DIRECTLY))); CVMJavaInt index = (((topOfStack[-3 + 1].s).j).i); if ((arrObj) == 0) { goto null_pointer_exception; }; if ((CVMUint32)index >= ((arrObj)->length)) { goto array_index_out_of_bounds_exception; }; { CVMJavaInt volatile *elemLoc_ = (CVMJavaInt volatile *)(&((arrObj)->elems[(index)])); ((void)((index < ((arrObj)->length)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1989, "index < CVMD_arrayGetLength(arrObj)") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; *elemLoc_ = ((((topOfStack[-1].s).j).i)); }; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s " "%d" " ==> %O[%d] ==>\n", CVMopnames[pc[0]], (((topOfStack[-1].s).j).i), arrObj, index) : (void)0); { pc += 1; topOfStack += -3; ; }; ; goto *nextLabel;; }; };
+        opc_fastore: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1990, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMArrayOfFloat* arrObj = (CVMArrayOfFloat*)((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1991, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-3].s).j).r))->ref_DONT_ACCESS_DIRECTLY))); CVMJavaInt index = (((topOfStack[-3 + 1].s).j).i); if ((arrObj) == 0) { goto null_pointer_exception; }; if ((CVMUint32)index >= ((arrObj)->length)) { goto array_index_out_of_bounds_exception; }; { CVMJavaFloat volatile *elemLoc_ = (CVMJavaFloat volatile *)(&((arrObj)->elems[(index)])); ((void)((index < ((arrObj)->length)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1991, "index < CVMD_arrayGetLength(arrObj)") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; *elemLoc_ = ((((topOfStack[-1].s).j).f)); }; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s " "%f" " ==> %O[%d] ==>\n", CVMopnames[pc[0]], (((topOfStack[-1].s).j).f), arrObj, index) : (void)0); { pc += 1; topOfStack += -3; ; }; ; goto *nextLabel;; }; };
+        opc_lastore: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1992, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMJavaLong temp64; CVMArrayOfLong* arrObj = (CVMArrayOfLong*)((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1993, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-4].s).j).r))->ref_DONT_ACCESS_DIRECTLY))); CVMJavaInt index = (((topOfStack[-4 + 1].s).j).i); if ((arrObj) == 0) { goto null_pointer_exception; }; if ((CVMUint32)index >= ((arrObj)->length)) { goto array_index_out_of_bounds_exception; }; temp64 = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); }); { CVMJavaVal32 volatile *elemLoc_ = (CVMJavaVal32 volatile*)(&((arrObj)->elems[(index)])); CVMUint32 tmp_[2]; ; { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(tmp_))->l = (temp64); }; (&(elemLoc_)->raw)[0] = tmp_[0]; (&(elemLoc_)->raw)[1] = tmp_[1]; }; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s (0x%X, 0x%X) ==> %O[%d]\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).i), (((topOfStack[-1].s).j).i), arrObj, index) : (void)0); { pc += 1; topOfStack += -4; ; }; ; goto *nextLabel;; }; };
+        opc_dastore: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1994, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMJavaDouble temp64; CVMArrayOfDouble* arrObj = (CVMArrayOfDouble*)((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 1995, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-4].s).j).r))->ref_DONT_ACCESS_DIRECTLY))); CVMJavaInt index = (((topOfStack[-4 + 1].s).j).i); if ((arrObj) == 0) { goto null_pointer_exception; }; if ((CVMUint32)index >= ((arrObj)->length)) { goto array_index_out_of_bounds_exception; }; temp64 = ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); }); { CVMJavaVal32 volatile *elemLoc_ = (CVMJavaVal32 volatile *)(&((arrObj)->elems[(index)])); CVMUint32 tmp_[2]; ; { typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(tmp_))->d = (temp64); }; (&(elemLoc_)->raw)[0] = tmp_[0]; (&(elemLoc_)->raw)[1] = tmp_[1]; }; (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s (0x%X, 0x%X) ==> %O[%d]\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).i), (((topOfStack[-1].s).j).i), arrObj, index) : (void)0); { pc += 1; topOfStack += -4; ; }; ; goto *nextLabel;; }; };
+        opc_aastore: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2000, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+ {
+     CVMObject* rhsObject = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2002, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+     CVMArrayOfRef* arrObj = (CVMArrayOfRef*)((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2003, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-3].s).j).r))->ref_DONT_ACCESS_DIRECTLY))); CVMJavaInt index = (((topOfStack[-3 + 1].s).j).i); if ((arrObj) == 0) { goto null_pointer_exception; }; if ((CVMUint32)index >= ((arrObj)->length)) { goto array_index_out_of_bounds_exception; };
+     if (rhsObject != 0) {
+  CVMClassBlock* elemType =
+      (*(((void)(((((((((CVMClassBlock*)(((CVMAddr)((arrObj)->hdr.clas)) & ~3)))->classNameX))&0xc000) != 0 )) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2007, "CVMisArrayClass(((CVMClassBlock*)(((CVMAddr)((arrObj)->hdr.clas)) & ~3)))") || (CVMsystemPanic("CVMassertHook returned"), 0))), &((((CVMClassBlock*)(((CVMAddr)((arrObj)->hdr.clas)) & ~3)))->cpX.arrayInfoX)->elementCb));
+  CVMClassBlock* rhsType = ((CVMClassBlock*)(((CVMAddr)((rhsObject)->hdr.clas)) & ~3));
+  if (rhsType != elemType) {
+      if (!CVMisAssignable(ee, rhsType, elemType)) {
+   if (!(((ee)->exceptionFlags.oneflag.local) != 0)) {
+       goto array_store_exception;
+   } else {
+       goto handle_exception;
+   }
+      }
+  }
+     }
+     { CVMObject* volatile *elemLoc_ = (CVMObject* volatile *)(&((arrObj)->elems[(index)])); ((void)((index < ((arrObj)->length)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2020, "index < CVMD_arrayGetLength(arrObj)") || (CVMsystemPanic("CVMassertHook returned"), 0))); ((void)(((&(CVMglobals.gc.cardTableVirtualBase[(CVMAddr)((elemLoc_)) / (1 << 9)])) >= CVMglobals.gc.cardTable) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2020, "CARD_TABLE_SLOT_ADDRESS_FOR((elemLoc_)) >= CVMglobals.gc.cardTable") || (CVMsystemPanic("CVMassertHook returned"), 0))); ((void)(((&(CVMglobals.gc.cardTableVirtualBase[(CVMAddr)((elemLoc_)) / (1 << 9)])) < CVMglobals.gc.cardTable + CVMglobals.gc.cardTableSize) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2020, "CARD_TABLE_SLOT_ADDRESS_FOR((elemLoc_)) < CVMglobals.gc.cardTable + CVMglobals.gc.cardTableSize") || (CVMsystemPanic("CVMassertHook returned"), 0))); *(&(CVMglobals.gc.cardTableVirtualBase[(CVMAddr)((elemLoc_)) / (1 << 9)])) = 1;; *elemLoc_ = (rhsObject); };
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s 0x%x ==> %O[%d] ==>\n", CVMopnames[pc[0]], rhsObject, arrObj, index) : (void)0)
+                                                  ;
+     { pc += 1; topOfStack += -3; ; }; ; goto *nextLabel;; };
+ }
+ opc_pop: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2028, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tpop\n") : (void)0);
+     { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };
+ opc_pop2: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2033, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tpop2\n") : (void)0);
+     { pc += 1; topOfStack += -2; ; }; ; goto *nextLabel;; };
+ opc_dup: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2037, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; {
+     CVMJavaVal32 rhs = ((topOfStack[-1].s).j);
+     topOfStack += 1;
+     pc += 1;
+     ((topOfStack[-1].s).j) = rhs;
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tdup\n") : (void)0);
+     { pc += 0; topOfStack += 0; ; }; ; goto *nextLabel;; };
+ }
+ opc_dup_x1: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2046, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     ((topOfStack[0].s).j) = ((topOfStack[-1].s).j);
+     ((topOfStack[-1].s).j) = ((topOfStack[-2].s).j);
+     ((topOfStack[-2].s).j) = ((topOfStack[0].s).j);
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tdup_x1\n") : (void)0);
+     { pc += 1; topOfStack += 1; ; }; ; goto *nextLabel;; };
+ opc_dup_x2: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2053, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     ((topOfStack[0].s).j) = ((topOfStack[-1].s).j);
+     ((topOfStack[-1].s).j) = ((topOfStack[-2].s).j);
+     ((topOfStack[-2].s).j) = ((topOfStack[-3].s).j);
+     ((topOfStack[-3].s).j) = ((topOfStack[0].s).j);
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tdup_x2\n") : (void)0);
+     { pc += 1; topOfStack += 1; ; }; ; goto *nextLabel;; };
+ opc_dup2: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2061, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     ((topOfStack[0].s).j) = ((topOfStack[-2].s).j);
+     ((topOfStack[1].s).j) = ((topOfStack[-1].s).j);
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tdup2\n") : (void)0);
+     { pc += 1; topOfStack += 2; ; }; ; goto *nextLabel;; };
+ opc_dup2_x1: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2067, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     ((topOfStack[1].s).j) = ((topOfStack[-1].s).j);
+     ((topOfStack[0].s).j) = ((topOfStack[-2].s).j);
+     ((topOfStack[-1].s).j) = ((topOfStack[-3].s).j);
+     ((topOfStack[-2].s).j) = ((topOfStack[1].s).j);
+     ((topOfStack[-3].s).j) = ((topOfStack[0].s).j);
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tdup2_x1\n") : (void)0);
+     { pc += 1; topOfStack += 2; ; }; ; goto *nextLabel;; };
+ opc_dup2_x2: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2076, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     ((topOfStack[1].s).j) = ((topOfStack[-1].s).j);
+     ((topOfStack[0].s).j) = ((topOfStack[-2].s).j);
+     ((topOfStack[-1].s).j) = ((topOfStack[-3].s).j);
+     ((topOfStack[-2].s).j) = ((topOfStack[-4].s).j);
+     ((topOfStack[-3].s).j) = ((topOfStack[1].s).j);
+     ((topOfStack[-4].s).j) = ((topOfStack[0].s).j);
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tdup2_x2\n") : (void)0);
+     { pc += 1; topOfStack += 2; ; }; ; goto *nextLabel;; };
+ opc_swap: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2086, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; {
+     CVMJavaVal32 j = ((topOfStack[-1].s).j);
+     ((topOfStack[-1].s).j) = ((topOfStack[-2].s).j);
+     ((topOfStack[-2].s).j) = j;
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tswap\n") : (void)0);
+     { pc += 1; topOfStack += 0; ; }; ; goto *nextLabel;; };
+ }
+ opc_iadd: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2133, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     if (0 && ((((topOfStack[-1].s).j).i) == 0)) { goto arithmetic_exception_divide_by_zero; } (((topOfStack[-2].s).j).i) = (((((topOfStack[-2].s).j).i)) + ((((topOfStack[-1].s).j).i))); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %d\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).i)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };;
+ opc_isub: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2135, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     if (0 && ((((topOfStack[-1].s).j).i) == 0)) { goto arithmetic_exception_divide_by_zero; } (((topOfStack[-2].s).j).i) = (((((topOfStack[-2].s).j).i)) - ((((topOfStack[-1].s).j).i))); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %d\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).i)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };;
+ opc_imul: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2137, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     if (0 && ((((topOfStack[-1].s).j).i) == 0)) { goto arithmetic_exception_divide_by_zero; } (((topOfStack[-2].s).j).i) = (((((topOfStack[-2].s).j).i)) * ((((topOfStack[-1].s).j).i))); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %d\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).i)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };;
+ opc_idiv: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2139, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     if (1 && ((((topOfStack[-1].s).j).i) == 0)) { goto arithmetic_exception_divide_by_zero; } (((topOfStack[-2].s).j).i) = ((((((topOfStack[-2].s).j).i)) == 0x80000000 && ((((topOfStack[-1].s).j).i)) == -1) ? (((((topOfStack[-2].s).j).i)) / 1) : (((((topOfStack[-2].s).j).i)) / ((((topOfStack[-1].s).j).i)))); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %d\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).i)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };;
+ opc_irem: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2141, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     if (1 && ((((topOfStack[-1].s).j).i) == 0)) { goto arithmetic_exception_divide_by_zero; } (((topOfStack[-2].s).j).i) = ((((((topOfStack[-2].s).j).i)) == 0x80000000 && ((((topOfStack[-1].s).j).i)) == -1) ? (((((topOfStack[-2].s).j).i)) % 1) : (((((topOfStack[-2].s).j).i)) % ((((topOfStack[-1].s).j).i)))); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %d\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).i)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };;
+ opc_iand: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2143, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     if (0 && ((((topOfStack[-1].s).j).i) == 0)) { goto arithmetic_exception_divide_by_zero; } (((topOfStack[-2].s).j).i) = (((((topOfStack[-2].s).j).i)) & ((((topOfStack[-1].s).j).i))); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %d\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).i)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };;
+ opc_ior: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2145, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     if (0 && ((((topOfStack[-1].s).j).i) == 0)) { goto arithmetic_exception_divide_by_zero; } (((topOfStack[-2].s).j).i) = (((((topOfStack[-2].s).j).i)) | ((((topOfStack[-1].s).j).i))); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %d\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).i)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };;
+ opc_ixor: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2147, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     if (0 && ((((topOfStack[-1].s).j).i) == 0)) { goto arithmetic_exception_divide_by_zero; } (((topOfStack[-2].s).j).i) = (((((topOfStack[-2].s).j).i)) ^ ((((topOfStack[-1].s).j).i))); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %d\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).i)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };;
+ opc_fadd: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2150, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     (((topOfStack[-2].s).j).f) = (((((topOfStack[-2].s).j).f)) + ((((topOfStack[-1].s).j).f))); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %f\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).f)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };;
+ opc_fsub: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2152, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     (((topOfStack[-2].s).j).f) = (((((topOfStack[-2].s).j).f)) - ((((topOfStack[-1].s).j).f))); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %f\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).f)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };;
+ opc_fmul: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2154, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     (((topOfStack[-2].s).j).f) = (((((topOfStack[-2].s).j).f)) * ((((topOfStack[-1].s).j).f))); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %f\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).f)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };;
+ opc_fdiv: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2156, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     (((topOfStack[-2].s).j).f) = (((((topOfStack[-2].s).j).f)) / ((((topOfStack[-1].s).j).f))); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %f\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).f)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };;
+ opc_frem: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2158, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     (((topOfStack[-2].s).j).f) = CVMfloatRem((((topOfStack[-2].s).j).f), (((topOfStack[-1].s).j).f)); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %f\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).f)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };;
+ opc_ladd: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2161, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMBool result = CVMlongAddHelper(topOfStack); if (0 && !result) { goto arithmetic_exception_divide_by_zero; } (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %s\n", CVMopnames[pc[0]], (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0); { pc += 1; topOfStack += -2; ; }; ; goto *nextLabel;; }; };
+ opc_lsub: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2163, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMBool result = CVMlongSubHelper(topOfStack); if (0 && !result) { goto arithmetic_exception_divide_by_zero; } (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %s\n", CVMopnames[pc[0]], (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0); { pc += 1; topOfStack += -2; ; }; ; goto *nextLabel;; }; };
+ opc_lmul: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2165, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMBool result = CVMlongMulHelper(topOfStack); if (0 && !result) { goto arithmetic_exception_divide_by_zero; } (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %s\n", CVMopnames[pc[0]], (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0); { pc += 1; topOfStack += -2; ; }; ; goto *nextLabel;; }; };
+ opc_ldiv: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2167, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMBool result = CVMlongDivHelper(topOfStack); if (1 && !result) { goto arithmetic_exception_divide_by_zero; } (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %s\n", CVMopnames[pc[0]], (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0); { pc += 1; topOfStack += -2; ; }; ; goto *nextLabel;; }; };
+ opc_lrem: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2169, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMBool result = CVMlongRemHelper(topOfStack); if (1 && !result) { goto arithmetic_exception_divide_by_zero; } (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %s\n", CVMopnames[pc[0]], (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0); { pc += 1; topOfStack += -2; ; }; ; goto *nextLabel;; }; };
+ opc_land: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2171, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMBool result = CVMlongAndHelper(topOfStack); if (0 && !result) { goto arithmetic_exception_divide_by_zero; } (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %s\n", CVMopnames[pc[0]], (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0); { pc += 1; topOfStack += -2; ; }; ; goto *nextLabel;; }; };
+ opc_lor: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2173, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMBool result = CVMlongOrHelper(topOfStack); if (0 && !result) { goto arithmetic_exception_divide_by_zero; } (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %s\n", CVMopnames[pc[0]], (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0); { pc += 1; topOfStack += -2; ; }; ; goto *nextLabel;; }; };
+ opc_lxor: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2175, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMBool result = CVMlongXorHelper(topOfStack); if (0 && !result) { goto arithmetic_exception_divide_by_zero; } (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %s\n", CVMopnames[pc[0]], (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0); { pc += 1; topOfStack += -2; ; }; ; goto *nextLabel;; }; };
+ opc_dadd: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2178, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMdoubleAddHelper(topOfStack); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %f\n", CVMopnames[pc[0]], ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->d); })) : (void)0); { pc += 1; topOfStack += -2; ; }; ; goto *nextLabel;; }; };
+ opc_dsub: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2180, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMdoubleSubHelper(topOfStack); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %f\n", CVMopnames[pc[0]], ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->d); })) : (void)0); { pc += 1; topOfStack += -2; ; }; ; goto *nextLabel;; }; };
+ opc_dmul: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2182, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMdoubleMulHelper(topOfStack); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %f\n", CVMopnames[pc[0]], ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->d); })) : (void)0); { pc += 1; topOfStack += -2; ; }; ; goto *nextLabel;; }; };
+ opc_ddiv: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2184, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMdoubleDivHelper(topOfStack); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %f\n", CVMopnames[pc[0]], ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->d); })) : (void)0); { pc += 1; topOfStack += -2; ; }; ; goto *nextLabel;; }; };
+ opc_drem: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2186, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     { CVMdoubleRemHelper(topOfStack); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %f\n", CVMopnames[pc[0]], ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-4].s).j).raw))->d); })) : (void)0); { pc += 1; topOfStack += -2; ; }; ; goto *nextLabel;; }; };
+ opc_ineg: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2191, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; {
+     (((topOfStack[-1].s).j).i) = (- (((((topOfStack[-1].s).j).i))));
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %d\n", CVMopnames[pc[0]], (((topOfStack[-1].s).j).i)) : (void)0);
+     { pc += 1; topOfStack += 0; ; }; ; goto *nextLabel;; };
+ }
+        opc_lneg: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2197, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+ {
+     CVMlongNegHelper(topOfStack);
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %s\n", CVMopnames[pc[0]], (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0)
+                                      ;
+     { pc += 1; topOfStack += 0; ; }; ; goto *nextLabel;; };
+ }
+        opc_fneg: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2205, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; {
+     (((topOfStack[-1].s).j).f) = (-((((topOfStack[-1].s).j).f)));
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %f\n", CVMopnames[pc[0]], (((topOfStack[-1].s).j).f)) : (void)0);
+     { pc += 1; topOfStack += 0; ; }; ; goto *nextLabel;; };
+ }
+        opc_dneg: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2211, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+ {
+     CVMdoubleNegHelper(topOfStack);
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %f\n", CVMopnames[pc[0]], ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); })) : (void)0);
+     { pc += 1; topOfStack += 0; ; }; ; goto *nextLabel;; };
+ }
+        opc_ishl: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2238, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; (((topOfStack[-2].s).j).i) = (((((topOfStack[-2].s).j).i)) << ((((topOfStack[-1].s).j).i) & 0x1F)); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %d\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).i)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; }; opc_lshl: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2238, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { CVMlongShlHelper(topOfStack); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %s\n", CVMopnames[pc[0]], (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-3].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; }; };
+ opc_ishr: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2239, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; (((topOfStack[-2].s).j).i) = (((((topOfStack[-2].s).j).i)) >> ((((topOfStack[-1].s).j).i) & 0x1F)); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %d\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).i)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; }; opc_lshr: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2239, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { CVMlongShrHelper(topOfStack); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %s\n", CVMopnames[pc[0]], (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-3].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; }; };
+ opc_iushr: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2240, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; (((topOfStack[-2].s).j).i) = (((unsigned int)((((topOfStack[-2].s).j).i))) >> ((((topOfStack[-1].s).j).i) & 0x1F)); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %d\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).i)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; }; opc_lushr: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2240, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; { CVMlongUshrHelper(topOfStack); (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %s\n", CVMopnames[pc[0]], (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-3].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0); { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; }; };
+        opc_iinc: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2244, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];;
+ {
+     CVMUint32 localNo = pc[1];
+     CVMInt32 incr = (CVMInt8)pc[2];
+     pc += 3;
+     locals[localNo].j.i += incr;
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tiinc locals[%d]+%d => %d\n", localNo, (CVMInt8)(incr), locals[localNo].j.i) : (void)0)
+                                           ;
+     { pc += 0; topOfStack += 0; ; }; ; goto *nextLabel;; };
+ }
+        opc_i2l: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2257, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+ {
+     CVMJavaLong r;
+     r = ((CVMJavaLong)((((topOfStack[-1].s).j).i)));
+     { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-1].s).j).raw))->l = r; };
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\ti2l => %s\n", (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-1].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0);
+            { pc += 1; topOfStack += 1; ; }; ; goto *nextLabel;; };
+ }
+        opc_i2f: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2266, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+    (((topOfStack[-1].s).j).f) = ((CVMJavaFloat)(((((topOfStack[-1].s).j).i))));
+           (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\ti2f => %f\n", (((topOfStack[-1].s).j).f)) : (void)0);
+           { pc += 1; topOfStack += 0; ; }; ; goto *nextLabel;; };
+        opc_l2i: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2271, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+ {
+        CVMJavaLong r;
+     r = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); });
+     (((topOfStack[-2].s).j).i) = ((CVMJavaInt)(r));
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tl2i => %d\n", (((topOfStack[-2].s).j).i)) : (void)0);
+            { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };
+ }
+        opc_l2f: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2280, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+ {
+        CVMJavaLong r;
+     r = ({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); });
+     (((topOfStack[-2].s).j).f) = ((CVMJavaFloat)(r));
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tl2f => %f\n", (((topOfStack[-2].s).j).f)) : (void)0);
+            { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };
+ }
+        opc_f2i: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2289, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+            (((topOfStack[-1].s).j).i) = (float2Int((((topOfStack[-1].s).j).f)));
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tf2i => %d\n", (((topOfStack[-1].s).j).i)) : (void)0);
+            { pc += 1; topOfStack += 0; ; }; ; goto *nextLabel;; };
+        opc_f2l: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2294, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+ {
+     CVMJavaLong r;
+      r = float2Long(((((topOfStack[-1].s).j).f)));
+     { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-1].s).j).raw))->l = r; };
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tf2l => %s\n", (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-1].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0);
+            { pc += 1; topOfStack += 1; ; }; ; goto *nextLabel;; };
+ }
+        opc_f2d: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2303, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+ {
+     CVMJavaDouble r;
+     r = ((CVMJavaDouble)((((topOfStack[-1].s).j).f)));
+     { typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&((topOfStack[-1].s).j).raw))->d = r; };
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tf2d => %f\n", ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-1].s).j).raw))->d); })) : (void)0);
+            { pc += 1; topOfStack += 1; ; }; ; goto *nextLabel;; };
+        }
+        opc_d2f: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2312, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+    {
+     CVMJavaDouble r;
+     r = ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); });
+     (((topOfStack[-2].s).j).f) = ((CVMJavaFloat)(r));
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\td2f => %f\n", (((topOfStack[-2].s).j).f)) : (void)0);
+            { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };
+ }
+        opc_i2b: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2321, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     (((topOfStack[-1].s).j).i) = ((signed char)((((topOfStack[-1].s).j).i)));
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\ti2b => %d\n", (((topOfStack[-1].s).j).i)) : (void)0);
+            { pc += 1; topOfStack += 0; ; }; ; goto *nextLabel;; };
+        opc_i2c: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2326, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     (((topOfStack[-1].s).j).i) = (((((topOfStack[-1].s).j).i)) & (0xffff));
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\ti2c => %d\n", (((topOfStack[-1].s).j).i)) : (void)0);
+            { pc += 1; topOfStack += 0; ; }; ; goto *nextLabel;; };
+        opc_i2s: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2331, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     (((topOfStack[-1].s).j).i) = ((signed short)((((topOfStack[-1].s).j).i)));
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\ti2s => %d\n", (((topOfStack[-1].s).j).i)) : (void)0);
+            { pc += 1; topOfStack += 0; ; }; ; goto *nextLabel;; };
+        opc_lcmp: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2338, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+ {
+     CVMlongCmpHelper(topOfStack);
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %d\n", CVMopnames[pc[0]], (((topOfStack[-4].s).j).i)) : (void)0)
+                      ;
+     { pc += 1; topOfStack += -3; ; }; ; goto *nextLabel;; };
+ }
+        opc_fcmpl: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2346, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+ {
+     (((topOfStack[-2].s).j).i) =
+  CVMfloatCompare((((topOfStack[-2].s).j).f), (((topOfStack[-1].s).j).f), -1);
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %d\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).i)) : (void)0);
+     { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };
+ }
+        opc_fcmpg: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2354, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+ {
+     (((topOfStack[-2].s).j).i) =
+  CVMfloatCompare((((topOfStack[-2].s).j).f), (((topOfStack[-1].s).j).f), 1);
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %d\n", CVMopnames[pc[0]], (((topOfStack[-2].s).j).i)) : (void)0);
+     { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };
+ }
+        opc_dcmpg: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2362, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+        {
+     CVMdoubleCmpHelper(topOfStack, 1);
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %d\n", CVMopnames[pc[0]], (((topOfStack[-4].s).j).i)) : (void)0);
+     { pc += 1; topOfStack += -3; ; }; ; goto *nextLabel;; };
+        }
+        opc_dcmpl: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2369, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+        {
+     CVMdoubleCmpHelper(topOfStack, -1);
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s => %d\n", CVMopnames[pc[0]], (((topOfStack[-4].s).j).i)) : (void)0);
+     { pc += 1; topOfStack += -3; ; }; ; goto *nextLabel;; };
+        }
+ opc_ifeq: ; { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s goto +%d (%staken)\n", CVMopnames[pc[0]], ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), ((((topOfStack[-1].s).j).i) == 0) ? "" : "not ") : (void)0); ; if (((((topOfStack[-1].s).j).i) == 0)) { int skip = ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))); ; { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += -1; ; }; ; goto *nextLabel;; }; } else { { const void* nextLabel;; nextLabel = opclabels[pc[3]];; if ((3) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += 3; topOfStack += -1; ; }; ; goto *nextLabel;; }; } };
+        opc_ifne: ; { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s goto +%d (%staken)\n", CVMopnames[pc[0]], ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), ((((topOfStack[-1].s).j).i) != 0) ? "" : "not ") : (void)0); ; if (((((topOfStack[-1].s).j).i) != 0)) { int skip = ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))); ; { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += -1; ; }; ; goto *nextLabel;; }; } else { { const void* nextLabel;; nextLabel = opclabels[pc[3]];; if ((3) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += 3; topOfStack += -1; ; }; ; goto *nextLabel;; }; } };
+ opc_iflt: ; { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s goto +%d (%staken)\n", CVMopnames[pc[0]], ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), ((((topOfStack[-1].s).j).i) < 0) ? "" : "not ") : (void)0); ; if (((((topOfStack[-1].s).j).i) < 0)) { int skip = ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))); ; { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += -1; ; }; ; goto *nextLabel;; }; } else { { const void* nextLabel;; nextLabel = opclabels[pc[3]];; if ((3) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += 3; topOfStack += -1; ; }; ; goto *nextLabel;; }; } };
+ opc_ifge: ; { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s goto +%d (%staken)\n", CVMopnames[pc[0]], ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), ((((topOfStack[-1].s).j).i) >= 0) ? "" : "not ") : (void)0); ; if (((((topOfStack[-1].s).j).i) >= 0)) { int skip = ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))); ; { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += -1; ; }; ; goto *nextLabel;; }; } else { { const void* nextLabel;; nextLabel = opclabels[pc[3]];; if ((3) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += 3; topOfStack += -1; ; }; ; goto *nextLabel;; }; } };
+ opc_ifgt: ; { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s goto +%d (%staken)\n", CVMopnames[pc[0]], ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), ((((topOfStack[-1].s).j).i) > 0) ? "" : "not ") : (void)0); ; if (((((topOfStack[-1].s).j).i) > 0)) { int skip = ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))); ; { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += -1; ; }; ; goto *nextLabel;; }; } else { { const void* nextLabel;; nextLabel = opclabels[pc[3]];; if ((3) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += 3; topOfStack += -1; ; }; ; goto *nextLabel;; }; } };
+ opc_ifle: ; { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s goto +%d (%staken)\n", CVMopnames[pc[0]], ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), ((((topOfStack[-1].s).j).i) <= 0) ? "" : "not ") : (void)0); ; if (((((topOfStack[-1].s).j).i) <= 0)) { int skip = ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))); ; { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += -1; ; }; ; goto *nextLabel;; }; } else { { const void* nextLabel;; nextLabel = opclabels[pc[3]];; if ((3) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += 3; topOfStack += -1; ; }; ; goto *nextLabel;; }; } };
+ opc_if_icmpeq: ; { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s goto +%d (%staken)\n", CVMopnames[pc[0]], ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), ((((topOfStack[-2].s).j).i) == (((topOfStack[-1].s).j).i)) ? "" : "not ") : (void)0); ; if ((((topOfStack[-2].s).j).i) == (((topOfStack[-1].s).j).i)) { int skip = ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))); ; { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += -2; ; }; ; goto *nextLabel;; }; } else { { const void* nextLabel;; nextLabel = opclabels[pc[3]];; if ((3) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += 3; topOfStack += -2; ; }; ; goto *nextLabel;; }; } };
+        opc_if_icmpne: ; { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s goto +%d (%staken)\n", CVMopnames[pc[0]], ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), ((((topOfStack[-2].s).j).i) != (((topOfStack[-1].s).j).i)) ? "" : "not ") : (void)0); ; if ((((topOfStack[-2].s).j).i) != (((topOfStack[-1].s).j).i)) { int skip = ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))); ; { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += -2; ; }; ; goto *nextLabel;; }; } else { { const void* nextLabel;; nextLabel = opclabels[pc[3]];; if ((3) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += 3; topOfStack += -2; ; }; ; goto *nextLabel;; }; } };
+ opc_if_icmplt: ; { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s goto +%d (%staken)\n", CVMopnames[pc[0]], ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), ((((topOfStack[-2].s).j).i) < (((topOfStack[-1].s).j).i)) ? "" : "not ") : (void)0); ; if ((((topOfStack[-2].s).j).i) < (((topOfStack[-1].s).j).i)) { int skip = ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))); ; { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += -2; ; }; ; goto *nextLabel;; }; } else { { const void* nextLabel;; nextLabel = opclabels[pc[3]];; if ((3) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += 3; topOfStack += -2; ; }; ; goto *nextLabel;; }; } };
+ opc_if_icmpge: ; { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s goto +%d (%staken)\n", CVMopnames[pc[0]], ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), ((((topOfStack[-2].s).j).i) >= (((topOfStack[-1].s).j).i)) ? "" : "not ") : (void)0); ; if ((((topOfStack[-2].s).j).i) >= (((topOfStack[-1].s).j).i)) { int skip = ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))); ; { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += -2; ; }; ; goto *nextLabel;; }; } else { { const void* nextLabel;; nextLabel = opclabels[pc[3]];; if ((3) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += 3; topOfStack += -2; ; }; ; goto *nextLabel;; }; } };
+ opc_if_icmpgt: ; { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s goto +%d (%staken)\n", CVMopnames[pc[0]], ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), ((((topOfStack[-2].s).j).i) > (((topOfStack[-1].s).j).i)) ? "" : "not ") : (void)0); ; if ((((topOfStack[-2].s).j).i) > (((topOfStack[-1].s).j).i)) { int skip = ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))); ; { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += -2; ; }; ; goto *nextLabel;; }; } else { { const void* nextLabel;; nextLabel = opclabels[pc[3]];; if ((3) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += 3; topOfStack += -2; ; }; ; goto *nextLabel;; }; } };
+ opc_if_icmple: ; { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s goto +%d (%staken)\n", CVMopnames[pc[0]], ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), ((((topOfStack[-2].s).j).i) <= (((topOfStack[-1].s).j).i)) ? "" : "not ") : (void)0); ; if ((((topOfStack[-2].s).j).i) <= (((topOfStack[-1].s).j).i)) { int skip = ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))); ; { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += -2; ; }; ; goto *nextLabel;; }; } else { { const void* nextLabel;; nextLabel = opclabels[pc[3]];; if ((3) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += 3; topOfStack += -2; ; }; ; goto *nextLabel;; }; } };
+ opc_if_acmpeq: ; { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s goto +%d (%staken)\n", CVMopnames[pc[0]], ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), (((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2441, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-2].s).j).r))->ref_DONT_ACCESS_DIRECTLY))) == ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2441, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))) ? "" : "not ") : (void)0); ; if (((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2441, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-2].s).j).r))->ref_DONT_ACCESS_DIRECTLY))) == ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2441, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))) { int skip = ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))); ; { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += -2; ; }; ; goto *nextLabel;; }; } else { { const void* nextLabel;; nextLabel = opclabels[pc[3]];; if ((3) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += 3; topOfStack += -2; ; }; ; goto *nextLabel;; }; } };
+        opc_if_acmpne: ; { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s goto +%d (%staken)\n", CVMopnames[pc[0]], ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), (((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2442, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-2].s).j).r))->ref_DONT_ACCESS_DIRECTLY))) != ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2442, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))) ? "" : "not ") : (void)0); ; if (((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2442, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-2].s).j).r))->ref_DONT_ACCESS_DIRECTLY))) != ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2442, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))) { int skip = ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))); ; { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += -2; ; }; ; goto *nextLabel;; }; } else { { const void* nextLabel;; nextLabel = opclabels[pc[3]];; if ((3) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += 3; topOfStack += -2; ; }; ; goto *nextLabel;; }; } };
+        opc_goto: ;
+ {
+     CVMInt16 skip = ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))));
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %#x (skip=%d)\n",CVMopnames[pc[0]], pc + skip, skip) : (void)0)
+                      ;
+            ;
+            ;
+     { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += 0; ; }; ; goto *nextLabel;; };
+ }
+        opc_jsr: ;
+        {
+     CVMInt16 skip = ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))));
+            ;
+     ((topOfStack[0].s).a) = pc + 3;
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %#x (skip=%d)\n",CVMopnames[pc[0]], pc + skip, skip) : (void)0)
+                      ;
+     { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += 1; ; }; ; goto *nextLabel;; };
+ }
+        opc_ret: ; {
+            ;
+     if (((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) {
+  goto handle_pending_request;
+     }
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tret %d (%#x)\n", pc[1], locals[pc[1]].a) : (void)0);
+     pc = locals[pc[1]].a;
+     { const void* nextLabel;; nextLabel = opclabels[pc[0]];; ; ; goto *nextLabel;; };
+ }
+ opc_tableswitch: ;
+ {
+     CVMInt32 skip = CVMtableswitchHelper(ee, topOfStack, pc, frame);
+     { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += -1; ; }; ; goto *nextLabel;; };
+ }
+ opc_lookupswitch: ;
+ {
+     CVMInt32 skip = CVMlookupswitchHelper(ee, topOfStack, pc, frame);
+     { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += -1; ; }; ; goto *nextLabel;; };
+ }
+ opc_lreturn: ;
+ opc_dreturn: ;
+        {
+            ;
+     if (((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) {
+  goto handle_pending_request;
+     }
+     topOfStack = CVMreturn64Helper(topOfStack, frame);
+     topOfStack += 2;
+     if (pc[0] == opc_dreturn) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tfreturn1 %f\n", ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); })) : (void)0); };
+     if (pc[0] == opc_lreturn) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tlreturn %s\n", (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0); }
+                                       ;
+     goto handle_return;
+        }
+ opc_return: ;
+        {
+            ;
+     if (((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) {
+  goto handle_pending_request;
+     }
+     topOfStack = (((void)(((1 == 1)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2574, "CVMframeMaskBitsAreCorrect((frame))") || (CVMsystemPanic("CVMassertHook returned"), 0))), ((CVMFrame*)((CVMAddr)((frame)->prevX) & ~((1 << 2) - 1))))->topOfStack;;
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\treturn\n") : (void)0);
+     goto handle_return;
+ }
+ opc_ireturn: ;
+ opc_areturn: ;
+ opc_freturn: ;
+        {
+     CVMJavaVal32 result;
+            ;
+     if (((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) {
+  goto handle_pending_request;
+     }
+     result = ((topOfStack[-1].s).j);
+     topOfStack = (((void)(((1 == 1)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2631, "CVMframeMaskBitsAreCorrect((frame))") || (CVMsystemPanic("CVMassertHook returned"), 0))), ((CVMFrame*)((CVMAddr)((frame)->prevX) & ~((1 << 2) - 1))))->topOfStack;;
+     ((topOfStack[0].s).j) = result;
+     topOfStack++;
+     if (pc[0] == opc_ireturn) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tireturn %d\n", (((topOfStack[-1].s).j).i)) : (void)0); };
+     if (pc[0] == opc_areturn) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tareturn 0x%x\n", ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2635, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))) : (void)0); };
+     if (pc[0] == opc_freturn) { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tfreturn %f\n", (((topOfStack[-1].s).j).f)) : (void)0); };
+     goto handle_return;
+        }
+    handle_return:
+ ;
+ {
+     if (((0x20 & (0x01 | 0x03 | 0x02)) ? ((((frame->mb)->immutX.invokerAndAccessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x20) : ((((frame->mb)->immutX.invokerAndAccessFlagsX) & 0x20) != 0))) {
+                CVMObjectICell *objICell = &((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2658, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2658, "CVMframeIsJava(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMJavaFrame*)(frame))->receiverObjX);
+                if (!CVMfastTryUnlock(ee, (*(((void)(((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2659, "(!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(objICell)->ref_DONT_ACCESS_DIRECTLY)))) {
+      ;
+      (frame->topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2662, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2662, "CVMframeIsJava(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMJavaFrame*)(frame))->opstackX);;
+      (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+      if (!CVMsyncReturnHelper(ee, frame, &(((topOfStack[-1].s).j).r),
+          pc[0] == opc_areturn))
+      {
+                        frame = stack->currentFrame;;
+   goto handle_exception;
+      }
+  }
+     }
+     ((CVMglobals.debugFlags & ((4L))) != 0 ? CVMconsolePrintf ("stack=0x%x frame=0x%x locals=0x%x tos=0x%x pc=0x%x\n", stack, frame, locals, topOfStack, pc) : (void)0);;
+     if ((CVMglobals.debugFlags & ((2L)))) { CVMtraceMethodReturn(ee, frame); };
+     { { CVMFrame* prev_ = (((frame)))->prevX; ((void)(((1 == 1)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2675, "CVMframeMaskBitsAreCorrect((((frame))))") || (CVMsystemPanic("CVMassertHook returned"), 0))); if ((((CVMAddr)(prev_) & (1 << 0)) != 0)) { CVMStackChunk* chunk_ = (((stack))->currentStackChunk); while(!(((CVMStackVal32*)((((frame)))) < (chunk_)->end_data) && ((CVMStackVal32*)((((frame)))) >= &(chunk_)->data[0]))) { chunk_ = chunk_->prev; } prev_ = ((CVMFrame*)((CVMAddr)(prev_) & ~((1 << 2) - 1))); if ((prev_ != ((void *)0)) && !(((CVMStackVal32*)(prev_->topOfStack) < (chunk_)->end_data) && ((CVMStackVal32*)(prev_->topOfStack) >= &(chunk_)->data[0]))) { chunk_ = chunk_->prev; } { { (((stack))->currentFrame) = ((prev_)); }; { CVMStackChunk * volatile *currentStackChunkPtr_; currentStackChunkPtr_ = &(((stack)))->currentStackChunk; *currentStackChunkPtr_ = chunk_; }; ((stack))->stackChunkStart = chunk_->data; ((stack))->stackChunkEnd = chunk_->end_data; { } }; } else { prev_ = ((CVMFrame*)((CVMAddr)(prev_) & ~((1 << 2) - 1))); } ((frame)) = prev_; }; ((stack))->currentFrame = ((frame)); };
+     pc = (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX);;
+     if (((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2698, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) {
+  locals = (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->localsX);
+  cp = (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->cpX);
+     }
+     pc += (*pc == opc_invokeinterface_quick ? 5 : 3);
+     ((CVMglobals.debugFlags & ((4L))) != 0 ? CVMconsolePrintf ("stack=0x%x frame=0x%x locals=0x%x tos=0x%x pc=0x%x\n", stack, frame, locals, topOfStack, pc) : (void)0);;
+     { const void* nextLabel;; nextLabel = opclabels[pc[0]];; ; ; goto *nextLabel;; };
+ }
+        opc_newarray: { const void* nextLabel; ; ((void)((2 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2726, "2 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[2]];; {
+     (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+     frame->topOfStack = topOfStack;;
+     if (!CVMnewarrayHelper(ee, topOfStack, (CVMBasicType)pc[1])) {
+  goto handle_exception;
+     }
+     { pc += 2; topOfStack += 0; ; }; ; goto *nextLabel;; };
+ }
+        opc_arraylength: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2741, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+ {
+     CVMArrayOfAnyType* arrObj = (CVMArrayOfAnyType*)((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2743, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+     if ((arrObj) == 0) { goto null_pointer_exception; };
+     (((topOfStack[-1].s).j).i) = ((arrObj)->length);
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %O.length(%d) ==>\n", CVMopnames[pc[0]], arrObj, (((topOfStack[-1].s).j).i)) : (void)0)
+                            ;
+     { pc += 1; topOfStack += 0; ; }; ; goto *nextLabel;; };
+ }
+ opc_athrow: ; {
+     CVMObject* directObj;
+            ;
+     directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2757, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+     if ((directObj) == 0) { goto null_pointer_exception; };
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tathrow => %O\n", directObj) : (void)0);
+     (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+     { ((void)((!(((ee)->exceptionFlags.oneflag.local) != 0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2761, "!CVMlocalExceptionOccurred(ee)") || (CVMsystemPanic("CVMassertHook returned"), 0))); (ee)->isThrowingAnException = (1 == 1); (((void)(((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2761, "(!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((ee)->localExceptionICell))->ref_DONT_ACCESS_DIRECTLY = (directObj));; ((ee)->exceptionFlags.oneflag.local) = 1; ((CVMglobals.debugFlags & ((16384L))) != 0 ? CVMconsolePrintf ("[<%d> Exception thrown: %O]\n", ee->threadID, directObj) : (void)0); if ((CVMglobals.debugFlags & ((16384L)))) { CVMdumpStack(&ee->interpreterStack, (!(1 == 1)), (!(1 == 1)), 100); } };
+     goto handle_exception;
+ }
+ opc_monitorenter: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2767, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; {
+     CVMObject* directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2768, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+     if ((directObj) == 0) { goto null_pointer_exception; };
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\topc_monitorenter(%O)\n", directObj) : (void)0);
+     if (!CVMfastTryLock(ee, directObj)) {
+  (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+  frame->topOfStack = topOfStack;;
+  if (!CVMsyncKinds[((((((((*(((void)(((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2776, "(!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))))->hdr.various32)) & ((1 << 2) - 1)) & 0x1)].lock(ee, &(((topOfStack[-1].s).j).r))) {
+      goto out_of_memory_error;
+  }
+     }
+     { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };
+ }
+        opc_monitorexit: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2783, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];; {
+     CVMObject* directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2784, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+     if ((directObj) == 0) { goto null_pointer_exception; };
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\topc_monitorexit(%O)\n", directObj) : (void)0);
+     if (!CVMfastTryUnlock(ee, directObj)){
+  (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+  frame->topOfStack = topOfStack;;
+  if (!CVMsyncKinds[((((((((*(((void)(((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2792, "(!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))))->hdr.various32)) & ((1 << 2) - 1)) & 0x1)].unlock(ee, &(((topOfStack[-1].s).j).r))) {
+      goto illegal_monitor_state_exception_thread_not_owner;
+  }
+     }
+     { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };
+ }
+ opc_ifnull: ; { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s goto +%d (%staken)\n", CVMopnames[pc[0]], ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), (!!(((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2818, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY))) == 0)) ? "" : "not ") : (void)0); ; if (!!(((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2818, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY))) == 0)) { int skip = ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))); ; { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += -1; ; }; ; goto *nextLabel;; }; } else { { const void* nextLabel;; nextLabel = opclabels[pc[3]];; if ((3) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += 3; topOfStack += -1; ; }; ; goto *nextLabel;; }; } };
+ opc_ifnonnull: ; { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s goto +%d (%staken)\n", CVMopnames[pc[0]], ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), (!(((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2819, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY))) == 0)) ? "" : "not ") : (void)0); ; if (!(((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2819, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY))) == 0)) { int skip = ((CVMInt16) (((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))); ; { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += -1; ; }; ; goto *nextLabel;; }; } else { { const void* nextLabel;; nextLabel = opclabels[pc[3]];; if ((3) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += 3; topOfStack += -1; ; }; ; goto *nextLabel;; }; } };
+        opc_breakpoint: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2850, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); nextLabel = opclabels[pc[1]];; {
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tbreakpoint\n") : (void)0);
+     { pc += 1; topOfStack += 0; ; }; ; goto *nextLabel;; };
+ }
+ opc_aldc_ind_quick: { const void* nextLabel; ; ((void)((2 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2858, "2 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[2]];; {
+     CVMObjectICell* strICell = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2859, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[pc[1]] & 0x3F) == CVM_CONSTANT_StringICell)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2859, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, pc[1], StringICell)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[pc[1]].resolved.strICell);
+     (((void)(((!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2860, "(!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), ((&(((topOfStack[0].s).j).r)))->ref_DONT_ACCESS_DIRECTLY = ((*(((void)(((!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2860, "(!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &((strICell))->ref_DONT_ACCESS_DIRECTLY))));
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s #%d => 0x%x\n", CVMopnames[pc[0]], pc[1], (((topOfStack[0].s).j).i)) : (void)0)
+                          ;
+     { pc += 2; topOfStack += 1; ; }; ; goto *nextLabel;; };
+ }
+        opc_aldc_quick: ;
+        opc_ldc_quick: { const void* nextLabel; ; ((void)((2 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2867, "2 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[2]];;
+     ((topOfStack[0].s).j) = ((cp)->entriesX[pc[1]].resolved.val32);
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s #%d => 0x%x\n", CVMopnames[pc[0]], pc[1], (((topOfStack[0].s).j).i)) : (void)0)
+                          ;
+     { pc += 2; topOfStack += 1; ; }; ; goto *nextLabel;; };
+        opc_checkcast_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2875, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];;
+ {
+     CVMObject* directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2877, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+     CVMClassBlock* castCb =
+  (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2879, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))] & 0x3F) == CVM_CONSTANT_ClassBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2879, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), ClassBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))].resolved.cb);
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %C\n", CVMopnames[pc[0]], castCb) : (void)0);
+     if (!CVMgcUnsafeIsInstanceOf(ee, directObj, castCb)) {
+  goto class_cast_exception;
+     }
+     { pc += 3; topOfStack += 0; ; }; ; goto *nextLabel;; };
+ }
+        opc_instanceof_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2889, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];;
+ {
+     CVMObject* directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2891, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+     (((topOfStack[-1].s).j).i) = (directObj != ((void *)0)) &&
+  CVMgcUnsafeIsInstanceOf(ee, directObj,
+     (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2894, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))] & 0x3F) == CVM_CONSTANT_ClassBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2894, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), ClassBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))].resolved.cb));
+     if ((((ee)->exceptionFlags.oneflag.local) != 0)) {
+  (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+  goto handle_exception;
+     }
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %C => %d\n", CVMopnames[pc[0]], (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2902, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))] & 0x3F) == CVM_CONSTANT_ClassBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2902, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), ClassBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))].resolved.cb), (((topOfStack[-1].s).j).i)) : (void)0)
+                    ;
+     { pc += 3; topOfStack += 0; ; }; ; goto *nextLabel;; };
+  }
+ opc_nonnull_quick: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2908, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tnonnull_quick\n") : (void)0);
+     if ((((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2910, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))) == 0) { goto null_pointer_exception; };
+     { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };
+ opc_exittransition: ; {
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\texittransition\n") : (void)0);
+     if (frame == initialframe) {
+                if ((CVMglobals.debugFlags & ((2L)))) { CVMtraceMethodReturn(ee, frame); };
+  goto finish;
+     } else {
+  goto opc_exittransition_overflow;
+     }
+ }
+ opc_agetstatic_quick: ;
+ opc_getstatic_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2933, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];; {
+     CVMFieldBlock* fb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2934, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))] & 0x3F) == CVM_CONSTANT_FieldBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2934, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), FieldBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))].resolved.fb);
+     ;
+     ((topOfStack[0].s).j) = (*((void)(ee), &((((((CVMFieldRange*) ((CVMUint8 *)((fb) - ((fb)->fbIndexX)) - ((CVMAddr)(&(((CVMFieldRange *)0)->fb[0])) - (CVMAddr)(&(((CVMFieldRange *)0)->cb)))))->cb))->staticsX.statics)[((fb)->offsetX)])));
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s #%d %C.%F[%d] (0x%X) ==>\n", CVMopnames[pc[0]], ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), (((CVMFieldRange*) ((CVMUint8 *)((fb) - ((fb)->fbIndexX)) - ((CVMAddr)(&(((CVMFieldRange *)0)->fb[0])) - (CVMAddr)(&(((CVMFieldRange *)0)->cb)))))->cb), fb, ((fb)->offsetX), (((topOfStack[0].s).j).i)) : (void)0)
+                                    ;
+     { pc += 3; topOfStack += 1; ; }; ; goto *nextLabel;; };
+ }
+ opc_getstatic2_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2944, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];; {
+     CVMFieldBlock* fb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2945, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))] & 0x3F) == CVM_CONSTANT_FieldBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2945, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), FieldBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))].resolved.fb);
+     ;
+            if (((0x40 & (0x01 | 0x03 | 0x02)) ? ((((fb)->accessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x40) : ((((fb)->accessFlagsX) & 0x40) != 0))) {
+                CVMsysMicroLock(ee, CVM_ACCESS_VOLATILE_MICROLOCK);
+            }
+     CVMmemCopy64Helper(&((topOfStack[0].s).j).raw,
+          &(*((void)(ee), &((((((CVMFieldRange*) ((CVMUint8 *)((fb) - ((fb)->fbIndexX)) - ((CVMAddr)(&(((CVMFieldRange *)0)->fb[0])) - (CVMAddr)(&(((CVMFieldRange *)0)->cb)))))->cb))->staticsX.statics)[((fb)->offsetX)]))).raw);
+            if (((0x40 & (0x01 | 0x03 | 0x02)) ? ((((fb)->accessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x40) : ((((fb)->accessFlagsX) & 0x40) != 0))) {
+                CVMsysMicroUnlock(ee, CVM_ACCESS_VOLATILE_MICROLOCK);
+            }
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s #%d %C.%F[%d] ((0x%X,0x%X) ==>\n", CVMopnames[pc[0]], ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), (((CVMFieldRange*) ((CVMUint8 *)((fb) - ((fb)->fbIndexX)) - ((CVMAddr)(&(((CVMFieldRange *)0)->fb[0])) - (CVMAddr)(&(((CVMFieldRange *)0)->cb)))))->cb), fb, ((fb)->offsetX), (((topOfStack[0].s).j).i), (((topOfStack[1].s).j).i)) : (void)0)
+                                                  ;
+     { pc += 3; topOfStack += 2; ; }; ; goto *nextLabel;; };
+ }
+ opc_aputstatic_quick: ;
+ opc_putstatic_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2963, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];; {
+     CVMFieldBlock* fb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2964, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))] & 0x3F) == CVM_CONSTANT_FieldBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2964, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), FieldBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))].resolved.fb);
+     ;
+     (*((void)(ee), &((((((CVMFieldRange*) ((CVMUint8 *)((fb) - ((fb)->fbIndexX)) - ((CVMAddr)(&(((CVMFieldRange *)0)->fb[0])) - (CVMAddr)(&(((CVMFieldRange *)0)->cb)))))->cb))->staticsX.statics)[((fb)->offsetX)]))) = ((topOfStack[-1].s).j);
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s #%d (0x%X) ==> %C.%F[%d]\n", CVMopnames[pc[0]], ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), (((topOfStack[-1].s).j).i), (((CVMFieldRange*) ((CVMUint8 *)((fb) - ((fb)->fbIndexX)) - ((CVMAddr)(&(((CVMFieldRange *)0)->fb[0])) - (CVMAddr)(&(((CVMFieldRange *)0)->cb)))))->cb), fb, ((fb)->offsetX)) : (void)0)
+                                               ;
+     { pc += 3; topOfStack += -1; ; }; ; goto *nextLabel;; };
+ }
+ opc_putstatic2_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2973, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];; {
+     CVMFieldBlock* fb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2974, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))] & 0x3F) == CVM_CONSTANT_FieldBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2974, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), FieldBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))].resolved.fb);
+     ;
+            if (((0x40 & (0x01 | 0x03 | 0x02)) ? ((((fb)->accessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x40) : ((((fb)->accessFlagsX) & 0x40) != 0))) {
+                CVMsysMicroLock(ee, CVM_ACCESS_VOLATILE_MICROLOCK);
+            }
+     CVMmemCopy64Helper(&(*((void)(ee), &((((((CVMFieldRange*) ((CVMUint8 *)((fb) - ((fb)->fbIndexX)) - ((CVMAddr)(&(((CVMFieldRange *)0)->fb[0])) - (CVMAddr)(&(((CVMFieldRange *)0)->cb)))))->cb))->staticsX.statics)[((fb)->offsetX)]))).raw,
+          &((topOfStack[-2].s).j).raw);
+            if (((0x40 & (0x01 | 0x03 | 0x02)) ? ((((fb)->accessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x40) : ((((fb)->accessFlagsX) & 0x40) != 0))) {
+                CVMsysMicroUnlock(ee, CVM_ACCESS_VOLATILE_MICROLOCK);
+            }
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s #%d (0x%X,0x%X) ==> %C.%F[%d]\n", CVMopnames[pc[0]], ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), (((topOfStack[-2].s).j).i), (((topOfStack[-1].s).j).i), (((CVMFieldRange*) ((CVMUint8 *)((fb) - ((fb)->fbIndexX)) - ((CVMAddr)(&(((CVMFieldRange *)0)->fb[0])) - (CVMAddr)(&(((CVMFieldRange *)0)->cb)))))->cb), fb, ((fb)->offsetX)) : (void)0)
+                                               ;
+     { pc += 3; topOfStack += -2; ; }; ; goto *nextLabel;; };
+ }
+ opc_agetstatic_checkinit_quick: ;
+ opc_getstatic_checkinit_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 2997, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); nextLabel = opclabels[pc[3]];;
+ {
+     CVMFieldBlock* fb;
+     CVMClassBlock* cb;
+     fb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3001, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))] & 0x3F) == CVM_CONSTANT_FieldBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3001, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), FieldBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))].resolved.fb);
+     cb = (((CVMFieldRange*) ((CVMUint8 *)((fb) - ((fb)->fbIndexX)) - ((CVMAddr)(&(((CVMFieldRange *)0)->fb[0])) - (CVMAddr)(&(((CVMFieldRange *)0)->cb)))))->cb);
+     if ((!(((CVMAddr)(*((void)(ee), ((((((cb)->runtimeFlagsX) & 0x01) != 0)) ? &((*(cb)->clinitEEX.eePtr)) : &((cb)->clinitEEX.ee)))) & 0x2) != 0) && ((CVMExecEnv*)((CVMAddr)((*((void)(ee), ((((((cb)->runtimeFlagsX) & 0x01) != 0)) ? &((*(cb)->clinitEEX.eePtr)) : &((cb)->clinitEEX.ee))))) & ~(0x1 | 0x2))) != ee)) { initCb = cb; goto init_class; } ;;
+     ;
+     ((topOfStack[0].s).j) = (*((void)(ee), &((((((CVMFieldRange*) ((CVMUint8 *)((fb) - ((fb)->fbIndexX)) - ((CVMAddr)(&(((CVMFieldRange *)0)->fb[0])) - (CVMAddr)(&(((CVMFieldRange *)0)->cb)))))->cb))->staticsX.statics)[((fb)->offsetX)])));
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s #%d %C.%F[%d] (0x%X) ==>\n", CVMopnames[pc[0]], ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), cb, fb, ((fb)->offsetX), (((topOfStack[0].s).j).i)) : (void)0)
+                                    ;
+     { pc += 3; topOfStack += 1; ; }; ; goto *nextLabel;; };
+ }
+ opc_getstatic2_checkinit_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3012, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); nextLabel = opclabels[pc[3]];;
+ {
+     CVMFieldBlock* fb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3014, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))] & 0x3F) == CVM_CONSTANT_FieldBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3014, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), FieldBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))].resolved.fb);
+     CVMClassBlock* cb = (((CVMFieldRange*) ((CVMUint8 *)((fb) - ((fb)->fbIndexX)) - ((CVMAddr)(&(((CVMFieldRange *)0)->fb[0])) - (CVMAddr)(&(((CVMFieldRange *)0)->cb)))))->cb);
+     if ((!(((CVMAddr)(*((void)(ee), ((((((cb)->runtimeFlagsX) & 0x01) != 0)) ? &((*(cb)->clinitEEX.eePtr)) : &((cb)->clinitEEX.ee)))) & 0x2) != 0) && ((CVMExecEnv*)((CVMAddr)((*((void)(ee), ((((((cb)->runtimeFlagsX) & 0x01) != 0)) ? &((*(cb)->clinitEEX.eePtr)) : &((cb)->clinitEEX.ee))))) & ~(0x1 | 0x2))) != ee)) { initCb = cb; goto init_class; } ;;
+     ;
+            if (((0x40 & (0x01 | 0x03 | 0x02)) ? ((((fb)->accessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x40) : ((((fb)->accessFlagsX) & 0x40) != 0))) {
+                CVMsysMicroLock(ee, CVM_ACCESS_VOLATILE_MICROLOCK);
+            }
+     CVMmemCopy64Helper(&((topOfStack[0].s).j).raw,
+          &(*((void)(ee), &((((((CVMFieldRange*) ((CVMUint8 *)((fb) - ((fb)->fbIndexX)) - ((CVMAddr)(&(((CVMFieldRange *)0)->fb[0])) - (CVMAddr)(&(((CVMFieldRange *)0)->cb)))))->cb))->staticsX.statics)[((fb)->offsetX)]))).raw);
+            if (((0x40 & (0x01 | 0x03 | 0x02)) ? ((((fb)->accessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x40) : ((((fb)->accessFlagsX) & 0x40) != 0))) {
+                CVMsysMicroUnlock(ee, CVM_ACCESS_VOLATILE_MICROLOCK);
+            }
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s #%d %C.%F[%d] ((0x%X,0x%X) ==>\n", CVMopnames[pc[0]], ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), cb, fb, ((fb)->offsetX), (((topOfStack[0].s).j).i), (((topOfStack[1].s).j).i)) : (void)0)
+                                                  ;
+     { pc += 3; topOfStack += 2; ; }; ; goto *nextLabel;; };
+ }
+ opc_aputstatic_checkinit_quick: ;
+ opc_putstatic_checkinit_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3034, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); nextLabel = opclabels[pc[3]];;
+        {
+     CVMFieldBlock* fb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3036, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))] & 0x3F) == CVM_CONSTANT_FieldBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3036, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), FieldBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))].resolved.fb);
+     CVMClassBlock* cb = (((CVMFieldRange*) ((CVMUint8 *)((fb) - ((fb)->fbIndexX)) - ((CVMAddr)(&(((CVMFieldRange *)0)->fb[0])) - (CVMAddr)(&(((CVMFieldRange *)0)->cb)))))->cb);
+     if ((!(((CVMAddr)(*((void)(ee), ((((((cb)->runtimeFlagsX) & 0x01) != 0)) ? &((*(cb)->clinitEEX.eePtr)) : &((cb)->clinitEEX.ee)))) & 0x2) != 0) && ((CVMExecEnv*)((CVMAddr)((*((void)(ee), ((((((cb)->runtimeFlagsX) & 0x01) != 0)) ? &((*(cb)->clinitEEX.eePtr)) : &((cb)->clinitEEX.ee))))) & ~(0x1 | 0x2))) != ee)) { initCb = cb; goto init_class; } ;;
+     ;
+     (*((void)(ee), &((((((CVMFieldRange*) ((CVMUint8 *)((fb) - ((fb)->fbIndexX)) - ((CVMAddr)(&(((CVMFieldRange *)0)->fb[0])) - (CVMAddr)(&(((CVMFieldRange *)0)->cb)))))->cb))->staticsX.statics)[((fb)->offsetX)]))) = ((topOfStack[-1].s).j);
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s #%d (0x%X) ==> %C.%F[%d]\n", CVMopnames[pc[0]], ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), (((topOfStack[-1].s).j).i), cb, fb, ((fb)->offsetX)) : (void)0)
+                              ;
+     { pc += 3; topOfStack += -1; ; }; ; goto *nextLabel;; };
+ }
+ opc_putstatic2_checkinit_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3047, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); nextLabel = opclabels[pc[3]];;
+ {
+     CVMFieldBlock* fb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3049, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))] & 0x3F) == CVM_CONSTANT_FieldBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3049, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), FieldBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1)))))].resolved.fb);
+     CVMClassBlock* cb = (((CVMFieldRange*) ((CVMUint8 *)((fb) - ((fb)->fbIndexX)) - ((CVMAddr)(&(((CVMFieldRange *)0)->fb[0])) - (CVMAddr)(&(((CVMFieldRange *)0)->cb)))))->cb);
+     if ((!(((CVMAddr)(*((void)(ee), ((((((cb)->runtimeFlagsX) & 0x01) != 0)) ? &((*(cb)->clinitEEX.eePtr)) : &((cb)->clinitEEX.ee)))) & 0x2) != 0) && ((CVMExecEnv*)((CVMAddr)((*((void)(ee), ((((((cb)->runtimeFlagsX) & 0x01) != 0)) ? &((*(cb)->clinitEEX.eePtr)) : &((cb)->clinitEEX.ee))))) & ~(0x1 | 0x2))) != ee)) { initCb = cb; goto init_class; } ;;
+     ;
+            if (((0x40 & (0x01 | 0x03 | 0x02)) ? ((((fb)->accessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x40) : ((((fb)->accessFlagsX) & 0x40) != 0))) {
+                CVMsysMicroLock(ee, CVM_ACCESS_VOLATILE_MICROLOCK);
+            }
+     CVMmemCopy64Helper(&(*((void)(ee), &((((((CVMFieldRange*) ((CVMUint8 *)((fb) - ((fb)->fbIndexX)) - ((CVMAddr)(&(((CVMFieldRange *)0)->fb[0])) - (CVMAddr)(&(((CVMFieldRange *)0)->cb)))))->cb))->staticsX.statics)[((fb)->offsetX)]))).raw,
+          &((topOfStack[-2].s).j).raw);
+            if (((0x40 & (0x01 | 0x03 | 0x02)) ? ((((fb)->accessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x40) : ((((fb)->accessFlagsX) & 0x40) != 0))) {
+                CVMsysMicroUnlock(ee, CVM_ACCESS_VOLATILE_MICROLOCK);
+            }
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s #%d (0x%X,0x%X) ==> %C.%F[%d]\n", CVMopnames[pc[0]], ((((*(CVMUint8*)((pc+1)+(0))) << 8) | (*(CVMUint8*)((pc+1)+(1))))), (((topOfStack[-2].s).j).i), (((topOfStack[-1].s).j).i), cb, fb, ((fb)->offsetX)) : (void)0)
+                              ;
+     { pc += 3; topOfStack += -2; ; }; ; goto *nextLabel;; };
+ }
+        opc_getfield_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3074, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];;
+ {
+     CVMObject* directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3076, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+     CVMUint32 slotIndex = pc[1];
+     if ((directObj) == 0) { goto null_pointer_exception; };
+     pc += 3;
+     { CVMJavaVal32 volatile* fieldLoc_ = ((CVMJavaVal32 volatile *)(directObj) + (slotIndex)); ; (((((topOfStack[-1].s).j))) = (*fieldLoc_)); };
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %O[%d](0x%X) ==>\n", CVMopnames[pc[-3]], directObj, slotIndex, (((topOfStack[-1].s).j).i)) : (void)0)
+                                          ;
+            { pc += 0; topOfStack += 0; ; }; ; goto *nextLabel;; };
+        }
+        opc_putfield_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3086, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];;
+ {
+     CVMObject* directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3088, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-2].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+     CVMUint32 slotIndex = pc[1];
+     if ((directObj) == 0) { goto null_pointer_exception; };
+     { CVMJavaVal32 volatile* fieldLoc_ = ((CVMJavaVal32 volatile *)(directObj) + (slotIndex)); ; ((*fieldLoc_) = ((((topOfStack[-1].s).j)))); };
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s (0x%X) ==> %O[%d]\n", CVMopnames[pc[0]], (((topOfStack[-1].s).j).i), directObj, slotIndex) : (void)0)
+                                          ;
+            { pc += 3; topOfStack += -2; ; }; ; goto *nextLabel;; };
+        }
+        opc_getfield2_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3097, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];;
+ {
+     CVMObject* directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3099, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+     if ((directObj) == 0) { goto null_pointer_exception; };
+     { CVMJavaVal32 volatile* fieldLoc_ = ((CVMJavaVal32 volatile *)(directObj) + (pc[1])); union {CVMUint32 x;} tmp_[2]; ; tmp_[0].x = (&(fieldLoc_)->raw)[0]; tmp_[1].x = (&(fieldLoc_)->raw)[1]; { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&(&((topOfStack[-1].s).j))->raw))->l = ((fakeOutGCCStrictAliasing *)(&tmp_[0].x))->l; }; };
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %O[%d](0x%X, 0x%X) ==>\n", CVMopnames[pc[0]], directObj, pc[1], (((topOfStack[-1].s).j).i), (((topOfStack[0].s).j).i)) : (void)0)
+                                                    ;
+            { pc += 3; topOfStack += 1; ; }; ; goto *nextLabel;; };
+        }
+        opc_putfield2_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3107, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];;
+ {
+     CVMObject* directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3109, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-3].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+     if ((directObj) == 0) { goto null_pointer_exception; };
+     { CVMJavaVal32 volatile* fieldLoc_ = ((CVMJavaVal32 volatile *)(directObj) + (pc[1])); union {CVMUint32 x;} tmp_[2]; ; { typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; ((fakeOutGCCStrictAliasing *)(&tmp_[0].x))->l = ((fakeOutGCCStrictAliasing *)(&(&((topOfStack[-2].s).j))->raw))->l; }; (&(fieldLoc_)->raw)[0] = tmp_[0].x; (&(fieldLoc_)->raw)[1] = tmp_[1].x; };
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s (0x%X, 0x%X) ==> %O[%d]\n", CVMopnames[pc[0]], (((topOfStack[-1].s).j).i), (((topOfStack[0].s).j).i), directObj, pc[1]) : (void)0)
+                                                    ;
+            { pc += 3; topOfStack += -3; ; }; ; goto *nextLabel;; };
+        }
+ opc_agetfield_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3117, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];;
+ {
+     CVMObject* fieldObj;
+     CVMObject* directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3120, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+     CVMUint32 slotIndex = pc[1];
+     if ((directObj) == 0) { goto null_pointer_exception; };
+     pc += 3;
+     { CVMObject* volatile *fieldLoc_ = (CVMObject* volatile *)((CVMJavaVal32 volatile *)(directObj) + (slotIndex)); ; (fieldObj) = *fieldLoc_; };
+     (((void)(((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3125, "(!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY = (fieldObj));
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %O[%d](0x%x) ==>\n", CVMopnames[pc[-3]], directObj, slotIndex, fieldObj) : (void)0)
+                                     ;
+            { pc += 0; topOfStack += 0; ; }; ; goto *nextLabel;; };
+        }
+ opc_aputfield_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3131, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];;
+ {
+     CVMObject* directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3133, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-2].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+     if ((directObj) == 0) { goto null_pointer_exception; };
+     { CVMObject* volatile *fieldLoc_ = (CVMObject* volatile *)((CVMJavaVal32 volatile *)(directObj) + (pc[1])); ((void)(((&(CVMglobals.gc.cardTableVirtualBase[(CVMAddr)((fieldLoc_)) / (1 << 9)])) >= CVMglobals.gc.cardTable) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3135, "CARD_TABLE_SLOT_ADDRESS_FOR((fieldLoc_)) >= CVMglobals.gc.cardTable") || (CVMsystemPanic("CVMassertHook returned"), 0))); ((void)(((&(CVMglobals.gc.cardTableVirtualBase[(CVMAddr)((fieldLoc_)) / (1 << 9)])) < CVMglobals.gc.cardTable + CVMglobals.gc.cardTableSize) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3135, "CARD_TABLE_SLOT_ADDRESS_FOR((fieldLoc_)) < CVMglobals.gc.cardTable + CVMglobals.gc.cardTableSize") || (CVMsystemPanic("CVMassertHook returned"), 0))); *(&(CVMglobals.gc.cardTableVirtualBase[(CVMAddr)((fieldLoc_)) / (1 << 9)])) = 1;; *fieldLoc_ = (((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3135, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)))); };
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s (0x%x) ==> %O[%d]\n", CVMopnames[pc[0]], ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3137, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY))), directObj, pc[1]) : (void)0)
+                                         ;
+            { pc += 3; topOfStack += -2; ; }; ; goto *nextLabel;; };
+        }
+ opc_new_checkinit_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3143, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); nextLabel = opclabels[pc[3]];; {
+     CVMClassBlock* newCb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3144, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))] & 0x3F) == CVM_CONSTANT_ClassBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3144, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), ClassBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))].resolved.cb);
+     CVMObject* directObj;
+     if ((!(((CVMAddr)(*((void)(ee), ((((((newCb)->runtimeFlagsX) & 0x01) != 0)) ? &((*(newCb)->clinitEEX.eePtr)) : &((newCb)->clinitEEX.ee)))) & 0x2) != 0) && ((CVMExecEnv*)((CVMAddr)((*((void)(ee), ((((((newCb)->runtimeFlagsX) & 0x01) != 0)) ? &((*(newCb)->clinitEEX.eePtr)) : &((newCb)->clinitEEX.ee))))) & ~(0x1 | 0x2))) != ee)) { initCb = newCb; goto init_class; } ;;
+     frame->topOfStack = topOfStack;;
+     (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+     directObj = CVMgcAllocNewInstance(ee, newCb);
+     if (directObj == 0) {
+  goto out_of_memory_error_for_new_quick;
+     }
+     (((void)(((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3159, "(!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (&(((topOfStack[0].s).j).r))->ref_DONT_ACCESS_DIRECTLY = (directObj));
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\topc_new_checkinit_quick %C => 0x%x\n", newCb, directObj) : (void)0)
+                       ;
+     { pc += 3; topOfStack += 1; ; }; ; goto *nextLabel;; };
+ }
+ opc_new_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3167, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];; {
+     CVMClassBlock* newCb;
+     CVMObject* directObj;
+     frame->topOfStack = topOfStack;;
+     (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+     newCb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3178, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))] & 0x3F) == CVM_CONSTANT_ClassBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3178, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), ClassBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))].resolved.cb);
+     directObj = CVMgcAllocNewInstance(ee, newCb);
+     if (directObj == ((void *)0)) {
+  goto out_of_memory_error_for_new_quick;
+     }
+     (((void)(((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3183, "(!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (&(((topOfStack[0].s).j).r))->ref_DONT_ACCESS_DIRECTLY = (directObj));
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tnew_quick %C => 0x%x\n", newCb, directObj) : (void)0)
+                       ;
+     { pc += 3; topOfStack += 1; ; }; ; goto *nextLabel;; };
+ }
+        opc_anewarray_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3191, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];;
+ {
+     CVMClassBlock* elemCb;
+     (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+     frame->topOfStack = topOfStack;;
+     elemCb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3207, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))] & 0x3F) == CVM_CONSTANT_ClassBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3207, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), ClassBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))].resolved.cb);
+     if (!CVManewarrayHelper(ee, topOfStack, elemCb)) {
+  goto handle_exception;
+     }
+     { pc += 3; topOfStack += 0; ; }; ; goto *nextLabel;; };
+ }
+        opc_invokeinterface_quick: ;
+ {
+     CVMMethodBlock* imb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3220, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))] & 0x3F) == CVM_CONSTANT_MethodBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3220, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), MethodBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))].resolved.mb);
+            ;
+     frame->topOfStack = topOfStack;;
+     (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+     topOfStack -= ((imb)->immutX.argsSizeX);
+     mb = CVMinvokeInterfaceHelper(ee, topOfStack, imb);
+     if (mb == ((void *)0)) {
+  goto handle_exception;
+     }
+            ;
+     goto callmethod;
+ }
+ opc_invokestatic_quick: ; {
+            ;
+     mb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3238, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))] & 0x3F) == CVM_CONSTANT_MethodBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3238, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), MethodBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))].resolved.mb);
+     frame->topOfStack = topOfStack;;
+     topOfStack -= ((mb)->immutX.argsSizeX);
+     goto callmethod;
+ }
+ opc_invokestatic_checkinit_quick: ;
+        {
+     CVMClassBlock* cb;
+     mb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3249, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))] & 0x3F) == CVM_CONSTANT_MethodBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3249, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), MethodBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))].resolved.mb);
+     cb = (((CVMMethodRange*) ((CVMUint8 *)((mb) - ((mb)->immutX.methodIndexX)) - ((CVMAddr)(&(((CVMMethodRange *)0)->mb[0])) - (CVMAddr)(&(((CVMMethodRange *)0)->cb)))))->cb);
+     if ((!(((CVMAddr)(*((void)(ee), ((((((cb)->runtimeFlagsX) & 0x01) != 0)) ? &((*(cb)->clinitEEX.eePtr)) : &((cb)->clinitEEX.ee)))) & 0x2) != 0) && ((CVMExecEnv*)((CVMAddr)((*((void)(ee), ((((((cb)->runtimeFlagsX) & 0x01) != 0)) ? &((*(cb)->clinitEEX.eePtr)) : &((cb)->clinitEEX.ee))))) & ~(0x1 | 0x2))) != ee)) { initCb = cb; goto init_class; } ;;
+     frame->topOfStack = topOfStack;;
+     topOfStack -= ((mb)->immutX.argsSizeX);
+     goto callmethod;
+ }
+ opc_invokevirtualobject_quick: ; {
+     CVMObject* directObj;
+            ;
+     frame->topOfStack = topOfStack;;
+     topOfStack -= pc[2];
+     directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3271, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[0].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+     if ((directObj) == 0) { goto null_pointer_exception; };
+     mb = ((((((CVMClassBlock*)(((CVMAddr)((directObj)->hdr.clas)) & ~3)))->methodTablePtrX)[pc[1]]));
+            ;
+     goto callmethod;
+ }
+ opc_invokenonvirtual_quick: ; {
+     CVMObject* directObj;
+            ;
+     mb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3283, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))] & 0x3F) == CVM_CONSTANT_MethodBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3283, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), MethodBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))].resolved.mb);
+     frame->topOfStack = topOfStack;;
+     topOfStack -= ((mb)->immutX.argsSizeX);
+     directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3286, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[0].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+     if ((directObj) == 0) { goto null_pointer_exception; };
+     goto callmethod;
+ }
+ opc_invokesuper_quick: ;
+        {
+     CVMObject* directObj;
+     CVMClassBlock* cb = (((CVMMethodRange*) ((CVMUint8 *)((frame->mb) - ((frame->mb)->immutX.methodIndexX)) - ((CVMAddr)(&(((CVMMethodRange *)0)->mb[0])) - (CVMAddr)(&(((CVMMethodRange *)0)->cb)))))->cb);
+            ;
+     mb = (((((cb)->superclassX.superclassCb))->methodTablePtrX)[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))]);
+     frame->topOfStack = topOfStack;;
+     topOfStack -= ((mb)->immutX.argsSizeX);
+     directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3301, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[0].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+     if ((directObj) == 0) { goto null_pointer_exception; };
+     goto callmethod;
+ }
+        opc_invokeignored_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3311, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];; {
+     CVMObject* directObj;
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tinvokeignored_quick\n") : (void)0);
+     topOfStack -= pc[1];
+     directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3315, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[0].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+     if (pc[2]) {
+  if ((directObj) == 0) { goto null_pointer_exception; };
+     }
+     { pc += 3; topOfStack += 0; ; }; ; goto *nextLabel;; };
+ }
+ opc_invokevirtual_quick_w: ;
+        {
+     CVMObject* directObj;
+            ;
+     mb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3332, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))] & 0x3F) == CVM_CONSTANT_MethodBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3332, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), MethodBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))].resolved.mb);
+     frame->topOfStack = topOfStack;;
+     topOfStack -= ((mb)->immutX.argsSizeX);
+     directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3335, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[0].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+     if ((directObj) == 0) { goto null_pointer_exception; };
+     mb = (((((CVMClassBlock*)(((CVMAddr)((directObj)->hdr.clas)) & ~3)))->methodTablePtrX)[((mb)->immutX.methodTableIndexX)])
+                                    ;
+            ;
+     goto callmethod;
+ }
+ opc_invokevirtual_quick: ;
+ opc_ainvokevirtual_quick: ;
+ opc_dinvokevirtual_quick: ;
+ opc_vinvokevirtual_quick: ;
+        {
+     CVMObject* directObj;
+            ;
+     frame->topOfStack = topOfStack;;
+     topOfStack -= pc[2];
+     directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3366, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[0].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+     if ((directObj) == 0) { goto null_pointer_exception; };
+     mb = (((((CVMClassBlock*)(((CVMAddr)((directObj)->hdr.clas)) & ~3)))->methodTablePtrX)[pc[1]]);
+            ;
+                       ;
+ }
+   callmethod:
+ ;
+ {
+     CVMFrame* prev;
+     int invokerIdx;
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %C.%M\n", CVMopnames[pc[0]], (((CVMMethodRange*) ((CVMUint8 *)((mb) - ((mb)->immutX.methodIndexX)) - ((CVMAddr)(&(((CVMMethodRange *)0)->mb[0])) - (CVMAddr)(&(((CVMMethodRange *)0)->cb)))))->cb), mb) : (void)0)
+                                                 ;
+     ((CVMglobals.debugFlags & ((4L))) != 0 ? CVMconsolePrintf ("stack=0x%x frame=0x%x locals=0x%x tos=0x%x pc=0x%x\n", stack, frame, locals, topOfStack, pc) : (void)0);;
+     (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+     prev = frame;
+    new_mb:
+     ;
+     invokerIdx = ((mb)->immutX.invokerAndAccessFlagsX >> 12);
+     if (invokerIdx < CVM_INVOKE_CNI_METHOD) {
+  CVMJavaMethodDescriptor* jmd = (*(((void)(((!((0x100 & (0x01 | 0x03 | 0x02)) ? ((((mb)->immutX.invokerAndAccessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x100) : ((((mb)->immutX.invokerAndAccessFlagsX) & 0x100) != 0)) && !((0x400 & (0x01 | 0x03 | 0x02)) ? ((((mb)->immutX.invokerAndAccessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x400) : ((((mb)->immutX.invokerAndAccessFlagsX) & 0x400) != 0)))) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3409, "CVMmbIsJava(mb)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(mb)->immutX.codeX.jmd));
+  CVMClassBlock* cb;
+  locals = &topOfStack->s;
+  { CVMFrame* cf_ = (CVMFrame*)(frame); ((void)(((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent) || (stack)->currentFrame == ((void *)0)) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+  ,
+ 3468
+  , "CVMD_isgcUnsafe(ee) || (stack)->currentFrame == NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))); if ((((CVMUint32)(((jmd)->capacityX))) <= (CVMUint32)(((stack))->stackChunkEnd - ((topOfStack))))) { (frame) = (CVMFrame*)&topOfStack[(((jmd)->maxLocalsX))]; ((frame)->prevX = (cf_)); (frame)->type = CVM_FRAMETYPE_JAVA; (frame)->mb = mb; (frame)->flags = 0; if (((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+  ,
+ 3468
+  , "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) { (((void)((((((void)((((CVMFrame*)(((frame))))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3468, "((CVMFrame*)(((frame))))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)(((frame))))->type)) == CVM_FRAMETYPE_JAVA)) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+  ,
+ 3468
+  , "CVMframeIsJava((frame))") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMJavaFrame*)((frame)))->jvmtiLockInfo = ((void *)0); }; if ((1 == 1)) { (stack)->currentFrame = (frame); } } else { CVMStackVal32* space_; space_ = CVMexpandStack(ee, stack, (((jmd)->capacityX)), (1 == 1), !(1 == 1)); if (space_ == 0) { (frame) = 0; { frame = stack->currentFrame;; locals = ((void *)0); goto handle_exception; }; } else { (cf_) = ((CVMFrame*)((CVMAddr)((cf_)) | ((1 << 0)))); (frame) = (CVMFrame*)&space_[(((jmd)->maxLocalsX))]; ((frame)->prevX = (cf_)); (frame)->type = CVM_FRAMETYPE_JAVA; (frame)->mb = mb; (frame)->flags = 0; if (((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+  ,
+ 3468
+  , "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) { (((void)((((((void)((((CVMFrame*)(((frame))))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3468, "((CVMFrame*)(((frame))))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)(((frame))))->type)) == CVM_FRAMETYPE_JAVA)) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+  ,
+ 3468
+  , "CVMframeIsJava((frame))") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMJavaFrame*)((frame)))->jvmtiLockInfo = ((void *)0); }; { (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("pushing JavaFrame caused stack expansion\n") : (void)0); locals = (CVMSlotVal32*)frame - ((jmd)->maxLocalsX); memcpy((void*)locals, (void*)topOfStack, ((mb)->immutX.argsSizeX) * sizeof(CVMSlotVal32)); }; if ((1 == 1)) { (stack)->currentFrame = (frame); } } } }
+    ;
+  prev->topOfStack = topOfStack;
+  (topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3479, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3479, "CVMframeIsJava(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMJavaFrame*)(frame))->opstackX);;
+  (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->localsX) = locals;
+  pc = ((CVMUint8*)jmd + (sizeof(CVMJavaMethodDescriptor)));
+  cb = (((CVMMethodRange*) ((CVMUint8 *)((mb) - ((mb)->immutX.methodIndexX)) - ((CVMAddr)(&(((CVMMethodRange *)0)->mb[0])) - (CVMAddr)(&(((CVMMethodRange *)0)->cb)))))->cb);
+  {
+      cp = ((cb)->cpX.constantpoolX);
+  }
+  (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->cpX) = cp;
+  (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+  if ((CVMglobals.debugFlags & ((2L)))) { CVMtraceMethodCall(ee, frame, (!(1 == 1))); };
+  ((CVMglobals.debugFlags & ((4L))) != 0 ? CVMconsolePrintf ("stack=0x%x frame=0x%x locals=0x%x tos=0x%x pc=0x%x\n", stack, frame, locals, topOfStack, pc) : (void)0);;
+  if (!((0x20 & (0x01 | 0x03 | 0x02)) ? ((((mb)->immutX.invokerAndAccessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x20) : ((((mb)->immutX.invokerAndAccessFlagsX) & 0x20) != 0))) {
+      (((void)(((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+      ,
+ 3515
+      , "(!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (&((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3515, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3515, "CVMframeIsJava(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMJavaFrame*)(frame))->receiverObjX))->ref_DONT_ACCESS_DIRECTLY = (((void *)0)))
+           ;
+  } else {
+      CVMObjectICell* receiverObjICell;
+      if (((0x08 & (0x01 | 0x03 | 0x02)) ? ((((mb)->immutX.invokerAndAccessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x08) : ((((mb)->immutX.invokerAndAccessFlagsX) & 0x08) != 0))) {
+   receiverObjICell = ((cb)->javaInstanceX);
+      } else {
+   receiverObjICell = &locals[0].j.r;
+      }
+      (((void)(((!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+      ,
+ 3525
+      , "(!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), ((&((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3525, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3525, "CVMframeIsJava(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMJavaFrame*)(frame))->receiverObjX)))->ref_DONT_ACCESS_DIRECTLY = ((*(((void)(((!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3525, "(!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &((receiverObjICell))->ref_DONT_ACCESS_DIRECTLY))))
+                          ;
+      receiverObjICell = &((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3527, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3527, "CVMframeIsJava(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMJavaFrame*)(frame))->receiverObjX);
+                    if (!CVMfastTryLock(
+       ee, (*(((void)(((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3531, "(!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(receiverObjICell)->ref_DONT_ACCESS_DIRECTLY)))) {
+                        (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+                        frame->topOfStack = topOfStack;;
+                        if (!CVMsyncKinds[((((((((*(((void)(((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3534, "(!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(receiverObjICell)->ref_DONT_ACCESS_DIRECTLY)))))->hdr.various32)) & ((1 << 2) - 1)) & 0x1)].lock(ee, receiverObjICell)) {
+       { { CVMFrame* prev_ = (((frame)))->prevX; ((void)(((1 == 1)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3535, "CVMframeMaskBitsAreCorrect((((frame))))") || (CVMsystemPanic("CVMassertHook returned"), 0))); if ((((CVMAddr)(prev_) & (1 << 0)) != 0)) { CVMStackChunk* chunk_ = (((stack))->currentStackChunk); while(!(((CVMStackVal32*)((((frame)))) < (chunk_)->end_data) && ((CVMStackVal32*)((((frame)))) >= &(chunk_)->data[0]))) { chunk_ = chunk_->prev; } prev_ = ((CVMFrame*)((CVMAddr)(prev_) & ~((1 << 2) - 1))); if ((prev_ != ((void *)0)) && !(((CVMStackVal32*)(prev_->topOfStack) < (chunk_)->end_data) && ((CVMStackVal32*)(prev_->topOfStack) >= &(chunk_)->data[0]))) { chunk_ = chunk_->prev; } { { (((stack))->currentFrame) = ((prev_)); }; { CVMStackChunk * volatile *currentStackChunkPtr_; currentStackChunkPtr_ = &(((stack)))->currentStackChunk; *currentStackChunkPtr_ = chunk_; }; ((stack))->stackChunkStart = chunk_->data; ((stack))->stackChunkEnd = chunk_->end_data; { } }; } else { prev_ = ((CVMFrame*)((CVMAddr)(prev_) & ~((1 << 2) - 1))); } ((frame)) = prev_; }; ((stack))->currentFrame = ((frame)); };
+       CVMthrowOutOfMemoryError(ee, ((void *)0));
+       goto handle_exception;
+   }
+                    }
+  }
+  { ((void)0); if ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))) { { (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;; frame->topOfStack = topOfStack;; }; CVMcsRendezvous((ee), (&CVMglobals.cstate[(CVM_GC_SAFE)]), (&((ee))->tcstate[(CVM_GC_SAFE)]), ((1 == 1)));; {}; } }
+        ;
+     } else if (invokerIdx < CVM_INVOKE_JNI_METHOD) {
+  CNIResultCode ret;
+  CVMMethodBlock *mb0 = mb;
+  CNINativeMethod *f = (CNINativeMethod *)(*(((void)((((0x100 & (0x01 | 0x03 | 0x02)) ? (((((mb))->immutX.invokerAndAccessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x100) : (((((mb))->immutX.invokerAndAccessFlagsX) & 0x100) != 0))) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3594, "CVMmbIs((mb), NATIVE)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(mb)->immutX.codeX.nativeCode));
+  if ((CVMglobals.debugFlags & ((2L)))) { CVMtraceFramelessMethodCall(ee, frame, mb0, (!(1 == 1))); };
+  ret = (*f)(ee, topOfStack, &mb);
+  if ((CVMglobals.debugFlags & ((2L)))) { CVMtraceFramelessMethodReturn(ee, mb0, frame); };
+  if ((int)ret >= 0) {
+                    ((void)(((int)ret <= CNI_DOUBLE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3617, "(int)ret <= CNI_DOUBLE") || (CVMsystemPanic("CVMassertHook returned"), 0)));
+      topOfStack += (int)ret;
+      pc += (*pc == opc_invokeinterface_quick ? 5 : 3);
+      { const void* nextLabel;; nextLabel = opclabels[pc[0]];; ; ; goto *nextLabel;; };
+  } else if (ret == CNI_NEW_TRANSITION_FRAME) {
+      frame->topOfStack = topOfStack;;
+      frame = stack->currentFrame;;
+      ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3635, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_TRANSITION)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3635, "CVMframeIsTransition(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMTransitionFrame*)(frame))->incrementPcFlagX) = (1 == 1);
+      isStatic = ((0x08 & (0x01 | 0x03 | 0x02)) ? ((((mb)->immutX.invokerAndAccessFlagsX) & (0x01 | 0x03 | 0x02)) == 0x08) : ((((mb)->immutX.invokerAndAccessFlagsX) & 0x08) != 0));
+      goto new_transition;
+  } else if (ret == CNI_NEW_MB) {
+      frame->topOfStack = topOfStack;;
+      frame->topOfStack += ((mb)->immutX.argsSizeX);
+      goto new_mb;
+  } else if (ret == CNI_EXCEPTION) {
+      goto handle_exception;
+  } else {
+      ((void)(((!(1 == 1))) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3684, "CVM_FALSE") || (CVMsystemPanic("CVMassertHook returned"), 0)));
+  }
+     } else if (invokerIdx < CVM_INVOKE_ABSTRACT_METHOD) {
+  if (!CVMinvokeJNIHelper(ee, mb)) {
+      goto handle_exception;
+  }
+  topOfStack = frame->topOfStack;;
+  pc += (*pc == opc_invokeinterface_quick ? 5 : 3);
+  { const void* nextLabel;; nextLabel = opclabels[pc[0]];; ; ; goto *nextLabel;; };
+     } else if (invokerIdx == CVM_INVOKE_ABSTRACT_METHOD) {
+  CVMthrowAbstractMethodError(ee, "%C.%M",
+         (((CVMMethodRange*) ((CVMUint8 *)((mb) - ((mb)->immutX.methodIndexX)) - ((CVMAddr)(&(((CVMMethodRange *)0)->mb[0])) - (CVMAddr)(&(((CVMMethodRange *)0)->cb)))))->cb), mb);
+  goto handle_exception;
+     } else if (invokerIdx == CVM_INVOKE_NONPUBLIC_MIRANDA_METHOD) {
+  CVMthrowIllegalAccessError(
+                    ee, "access non-public method %C.%M through an interface",
+      (((CVMMethodRange*) ((CVMUint8 *)((mb) - ((mb)->immutX.methodIndexX)) - ((CVMAddr)(&(((CVMMethodRange *)0)->mb[0])) - (CVMAddr)(&(((CVMMethodRange *)0)->cb)))))->cb), (*(((void)(((((mb)->immutX.invokerAndAccessFlagsX >> 12) == CVM_INVOKE_NONPUBLIC_MIRANDA_METHOD || ((mb)->immutX.invokerAndAccessFlagsX >> 12) == CVM_INVOKE_MISSINGINTERFACE_MIRANDA_METHOD)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3721, "CVMmbIsMiranda(mb)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(mb)->immutX.codeX.interfaceMb)));
+  goto handle_exception;
+     } else if (invokerIdx ==
+         CVM_INVOKE_MISSINGINTERFACE_MIRANDA_METHOD) {
+  CVMthrowAbstractMethodError(ee, "%C.%M",
+         (((CVMMethodRange*) ((CVMUint8 *)((mb) - ((mb)->immutX.methodIndexX)) - ((CVMAddr)(&(((CVMMethodRange *)0)->mb[0])) - (CVMAddr)(&(((CVMMethodRange *)0)->cb)))))->cb), mb);
+  goto handle_exception;
+     } else if (invokerIdx == CVM_INVOKE_LAZY_JNI_METHOD) {
+  CVMBool result;
+  { ((void)0); ((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe\n") : (void)0); { ((void)((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+  ,
+ 3740
+  , "!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent") || (CVMsystemPanic("CVMassertHook returned"), 0))); ((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent = (1 == 1); ; };; if ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))) { CVMcsRendezvous((ee), (&CVMglobals.cstate[(CVM_GC_SAFE)]), (&((ee))->tcstate[(CVM_GC_SAFE)]), ((!(1 == 1))));; } { result = CVMlookupNativeMethodCode(ee, mb); }; ((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-unsafe\n") : (void)0); { ((void)((((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+  ,
+ 3740
+  , "((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent") || (CVMsystemPanic("CVMassertHook returned"), 0))); ((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent = (!(1 == 1)); ; };; if ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))) { CVMcsRendezvous((ee), (&CVMglobals.cstate[(CVM_GC_SAFE)]), (&((ee))->tcstate[(CVM_GC_SAFE)]), ((1 == 1)));; } }
+    ;
+  if (!result) {
+      goto handle_exception;
+  } else {
+      goto new_mb;
+  }
+     } else {
+  CVMconsolePrintf ("Unkown method invoker: %d\n", invokerIdx);
+  ((void)(((!(1 == 1))) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3755, "CVM_FALSE") || (CVMsystemPanic("CVMassertHook returned"), 0)));
+     }
+ };
+ { const void* nextLabel;; nextLabel = opclabels[pc[0]];; ; ; goto *nextLabel;; };
+    return_from_executejava_branch_island: {
+        ;
+        pc = 0;
+        return;
+    }
+    handle_exception: {
+     ;
+     {
+  { if (((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3795, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) { (frame->topOfStack) = (
+ (((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3795, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3795, "CVMframeIsJava(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMJavaFrame*)(frame))->opstackX);; } else { (frame->topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3795, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_TRANSITION)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3795, "CVMframeIsTransition(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMTransitionFrame*)(frame))->opstackX);; } };
+     }
+    handle_exception_tos_already_reset:
+     ;
+     ((void)((((ee)->exceptionFlags.bothflags != 0 && ((((ee)->exceptionFlags.oneflag.local) != 0) || ((!(1 == 1)))))) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3800, "CVMexceptionOccurred(ee)") || (CVMsystemPanic("CVMassertHook returned"), 0)));
+     frame = CVMgcUnsafeHandleException(ee, frame, initialframe);
+     if (frame == initialframe) {
+                if ((CVMglobals.debugFlags & ((2L)))) { CVMtraceMethodReturn(ee, frame); };
+  goto finish;
+     }
+     {
+  pc = (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX);;
+  (topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3846, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3846, "CVMframeIsJava(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMJavaFrame*)(frame))->opstackX);;
+  locals = (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->localsX);
+  cp = (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->cpX);
+     }
+     (((void)(((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+     ,
+ 3853
+     , "(!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (&(((topOfStack[0].s).j).r))->ref_DONT_ACCESS_DIRECTLY = (((*(((void)(((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3853, "(!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(((ee)->currentExceptionICell))->ref_DONT_ACCESS_DIRECTLY)))))
+                                   ;
+     (((void)(((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3854, "(!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((ee)->currentExceptionICell))->ref_DONT_ACCESS_DIRECTLY = (((void *)0)));;
+     topOfStack++;
+     { const void* nextLabel;; nextLabel = opclabels[pc[0]];; ; ; goto *nextLabel;; };
+ }
+    init_class:
+ ;
+ {
+            int result;
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s ==> running static initializers...\n", CVMopnames[pc[0]]) : (void)0)
+                        ;
+     (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+     frame->topOfStack = topOfStack;;
+     { ((void)0); ((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe\n") : (void)0); { ((void)((!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+     ,
+ 3892
+     , "!((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent") || (CVMsystemPanic("CVMassertHook returned"), 0))); ((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent = (1 == 1); ; };; if ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))) { CVMcsRendezvous((ee), (&CVMglobals.cstate[(CVM_GC_SAFE)]), (&((ee))->tcstate[(CVM_GC_SAFE)]), ((!(1 == 1))));; } { result = CVMclassInitNoCRecursion(ee, initCb, &mb); }; ((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-unsafe\n") : (void)0); { ((void)((((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent) || CVMassertHook(
+ "../../src/share/javavm/runtime/executejava_standard.c"
+     ,
+ 3892
+     , "((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent") || (CVMsystemPanic("CVMassertHook returned"), 0))); ((&((ee))->tcstate[(CVM_GC_SAFE)]))->isConsistent = (!(1 == 1)); ; };; if ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))) { CVMcsRendezvous((ee), (&CVMglobals.cstate[(CVM_GC_SAFE)]), (&((ee))->tcstate[(CVM_GC_SAFE)]), ((1 == 1)));; } }
+       ;
+     if (result == 0) {
+  { const void* nextLabel;; nextLabel = opclabels[pc[0]];; ; ; goto *nextLabel;; };
+     } else if (result == 1) {
+  frame = stack->currentFrame;;
+  isStatic = (!(1 == 1));
+  goto new_transition;
+     } else {
+  goto handle_exception;
+     }
+        }
+    opc_exittransition_overflow:
+ ;
+        {
+     char retType;
+     CVMBool incrementPC;
+     if ((CVMglobals.debugFlags & ((2L)))) { CVMtraceMethodReturn(ee, frame); };
+     ((void)((!(((ee)->exceptionFlags.oneflag.local) != 0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3940, "!CVMlocalExceptionOccurred(ee)") || (CVMsystemPanic("CVMassertHook returned"), 0)));
+     retType =
+  CVMtypeidGetReturnType(((frame->mb)->immutX.nameAndTypeIDX));
+     if (retType == 2) {
+  topOfStack = (((void)(((1 == 1)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3957, "CVMframeMaskBitsAreCorrect((frame))") || (CVMsystemPanic("CVMassertHook returned"), 0))), ((CVMFrame*)((CVMAddr)((frame)->prevX) & ~((1 << 2) - 1))))->topOfStack;;
+     } else if ((retType == 6) ||
+         (retType == 9)) {
+  topOfStack = CVMreturn64Helper(topOfStack, frame);
+  topOfStack += 2;
+     } else {
+  CVMJavaVal32 result = ((topOfStack[-1].s).j);
+  topOfStack = (((void)(((1 == 1)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3973, "CVMframeMaskBitsAreCorrect((frame))") || (CVMsystemPanic("CVMassertHook returned"), 0))), ((CVMFrame*)((CVMAddr)((frame)->prevX) & ~((1 << 2) - 1))))->topOfStack;;
+  ((topOfStack[0].s).j) = result;
+  topOfStack++;
+     }
+     incrementPC = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3982, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_TRANSITION)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3982, "CVMframeIsTransition(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMTransitionFrame*)(frame))->incrementPcFlagX);
+     { { CVMFrame* prev_ = (((frame)))->prevX; ((void)(((1 == 1)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 3984, "CVMframeMaskBitsAreCorrect((((frame))))") || (CVMsystemPanic("CVMassertHook returned"), 0))); if ((((CVMAddr)(prev_) & (1 << 0)) != 0)) { CVMStackChunk* chunk_ = (((stack))->currentStackChunk); while(!(((CVMStackVal32*)((((frame)))) < (chunk_)->end_data) && ((CVMStackVal32*)((((frame)))) >= &(chunk_)->data[0]))) { chunk_ = chunk_->prev; } prev_ = ((CVMFrame*)((CVMAddr)(prev_) & ~((1 << 2) - 1))); if ((prev_ != ((void *)0)) && !(((CVMStackVal32*)(prev_->topOfStack) < (chunk_)->end_data) && ((CVMStackVal32*)(prev_->topOfStack) >= &(chunk_)->data[0]))) { chunk_ = chunk_->prev; } { { (((stack))->currentFrame) = ((prev_)); }; { CVMStackChunk * volatile *currentStackChunkPtr_; currentStackChunkPtr_ = &(((stack)))->currentStackChunk; *currentStackChunkPtr_ = chunk_; }; ((stack))->stackChunkStart = chunk_->data; ((stack))->stackChunkEnd = chunk_->end_data; { } }; } else { prev_ = ((CVMFrame*)((CVMAddr)(prev_) & ~((1 << 2) - 1))); } ((frame)) = prev_; }; ((stack))->currentFrame = ((frame)); };
+     pc = (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX);;
+     locals = (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->localsX);
+     cp = (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->cpX);
+     if (incrementPC) {
+  pc += (*pc == opc_invokeinterface_quick ? 5 : 3);
+  { const void* nextLabel;; nextLabel = opclabels[pc[0]];; ; ; goto *nextLabel;; };
+     } else {
+  {
+      const void* nextLabel;;
+      nextLabel = opclabels[pc[0]];;
+      ;
+      goto *nextLabel;;
+  }
+     }
+ }
+        opc_d2l: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4153, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+ {
+     CVMd2lHelper(topOfStack);
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\td2l => %s\n", (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf)) : (void)0);
+            { pc += 1; topOfStack += 0; ; }; ; goto *nextLabel;; };
+ }
+        opc_d2i: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4160, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+    {
+     CVMd2iHelper(topOfStack);
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\td2i => %d\n", (((topOfStack[-2].s).j).i)) : (void)0);
+            { pc += 1; topOfStack += -1; ; }; ; goto *nextLabel;; };
+ }
+        opc_l2d: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4167, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+ {
+     CVMl2dHelper(topOfStack);
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\tl2d => %f\n", ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-2].s).j).raw))->d); })) : (void)0);
+            { pc += 1; topOfStack += 0; ; }; ; goto *nextLabel;; };
+ }
+        opc_i2d: { const void* nextLabel; ; ((void)((1 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4174, "1 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[1]];;
+ {
+     CVMi2dHelper(topOfStack);
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\ti2d => %f\n", ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[-1].s).j).raw))->d); })) : (void)0);
+            { pc += 1; topOfStack += 1; ; }; ; goto *nextLabel;; };
+ }
+        opc_goto_w: ;
+ {
+     CVMInt32 skip = ((CVMInt32) (((*(CVMUint8*)((pc + 1)+(0))) << 24) | ((*(CVMUint8*)((pc + 1)+(1))) << 16) | ((*(CVMUint8*)((pc + 1)+(2))) << 8) | (*(CVMUint8*)((pc + 1)+(3)))));
+            ;
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %#x (skip=%d)\n", CVMopnames[pc[0]], pc + skip, skip) : (void)0)
+                      ;
+            ;
+     { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += 0; ; }; ; goto *nextLabel;; };
+ }
+        opc_jsr_w: ;
+        {
+     CVMInt32 skip = ((CVMInt32) (((*(CVMUint8*)((pc + 1)+(0))) << 24) | ((*(CVMUint8*)((pc + 1)+(1))) << 16) | ((*(CVMUint8*)((pc + 1)+(2))) << 8) | (*(CVMUint8*)((pc + 1)+(3)))));
+            ;
+     ((topOfStack[0].s).a) = pc + 5;
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s %#x (skip=%d)\n", CVMopnames[pc[0]], pc + skip, skip) : (void)0)
+                      ;
+     { const void* nextLabel;; nextLabel = opclabels[pc[skip]];; if ((skip) <= 0 && ((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) { goto handle_pending_request; } ; ; { pc += skip; topOfStack += 1; ; }; ; goto *nextLabel;; };
+ }
+ opc_aldc_ind_w_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4203, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];; {
+     CVMObjectICell* strICell =
+  (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4205, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))] & 0x3F) == CVM_CONSTANT_StringICell)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4205, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), StringICell)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))].resolved.strICell);
+     (((void)(((!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4206, "(!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), ((&(((topOfStack[0].s).j).r)))->ref_DONT_ACCESS_DIRECTLY = ((*(((void)(((!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4206, "(!((&(((ee)))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &((strICell))->ref_DONT_ACCESS_DIRECTLY))));
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s #%d => 0x%x\n", CVMopnames[pc[0]], pc[1], (((topOfStack[0].s).j).i)) : (void)0)
+                          ;
+     { pc += 3; topOfStack += 1; ; }; ; goto *nextLabel;; };
+ }
+        opc_aldc_w_quick: ;
+        opc_ldc_w_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4213, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];;
+            ((topOfStack[0].s).j) = ((cp)->entriesX[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))].resolved.val32);
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s #%d => 0x%x\n", CVMopnames[pc[0]], ((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), (((topOfStack[0].s).j).i)) : (void)0)
+                                      ;
+     { pc += 3; topOfStack += 1; ; }; ; goto *nextLabel;; };
+        opc_ldc2_w_quick: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4219, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];;
+  {
+     CVMldc2_wHelper(topOfStack, cp, pc);
+            (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\topc_ldc2_w_quick #%d => long=%s double=%g\n", ((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), (CVMlong2String(({ typedef union { CVMJavaLong l; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->l); }), trBuf, trBuf+sizeof(trBuf)), trBuf), ({ typedef union { CVMJavaDouble d; } fakeOutGCCStrictAliasing; (((fakeOutGCCStrictAliasing *)(&((topOfStack[0].s).j).raw))->d); })) : (void)0)
+                                                                    ;
+     { pc += 3; topOfStack += 2; ; }; ; goto *nextLabel;; };
+ }
+        opc_getfield_quick_w: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4228, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];;
+ {
+     topOfStack = CVMgetfield_quick_wHelper(ee, frame, topOfStack,
+         cp, pc);
+     if (topOfStack == ((void *)0)) {
+  goto null_pointer_exception;
+     }
+     { pc += 3; topOfStack += 0; ; }; ; goto *nextLabel;; };
+        }
+        opc_putfield_quick_w: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4238, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];;
+ {
+     topOfStack = CVMputfield_quick_wHelper(ee, frame, topOfStack,
+         cp, pc);
+     if (topOfStack == ((void *)0)) {
+  goto null_pointer_exception;
+     }
+     { pc += 3; topOfStack += 0; ; }; ; goto *nextLabel;; };
+        }
+        opc_wide: ;
+ {
+            ;
+     (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+     frame->topOfStack = topOfStack;;
+     if (CVMwideHelper(ee, locals, frame)) {
+  if (((((void)0)), ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))))) {
+      goto handle_pending_request;
+  }
+     }
+     pc = (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX);;
+     topOfStack = frame->topOfStack;;
+     { const void* nextLabel;; nextLabel = opclabels[pc[0]];; ; ; goto *nextLabel;; };
+        }
+ opc_prefix: ;
+ {
+     goto unimplemented_opcode;
+ }
+    handle_pending_request:
+ {
+     ;
+  {
+      { ((void)0); if ((((CVMglobals.debugFlags & ((4096L))) != 0 ? CVMconsolePrintf ("gc-safe?\n") : (void)0), (((ee)->tickCount++)), (((((&CVMglobals.cstate[(CVM_GC_SAFE)]))->request))))) { { (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;; frame->topOfStack = topOfStack;; }; CVMcsRendezvous((ee), (&CVMglobals.cstate[(CVM_GC_SAFE)]), (&((ee))->tcstate[(CVM_GC_SAFE)]), ((1 == 1)));; {}; } }
+            ;
+      { const void* nextLabel;; nextLabel = opclabels[pc[0]];; ; ; goto *nextLabel;; };
+                }
+ }
+ ;
+ opc_getfield: ;
+ opc_putfield: ;
+        opc_invokevirtual: ;
+        opc_invokespecial: ;
+     goto quicken_opcode_clobber;
+ opc_getstatic: ;
+        opc_putstatic: ;
+        opc_invokestatic: ;
+ opc_invokeinterface: ;
+ opc_new: ;
+ opc_ldc2_w: ;
+ opc_anewarray: ;
+ opc_checkcast: ;
+ opc_instanceof: ;
+ opc_multianewarray: ;
+     goto quicken_opcode_noclobber;
+        opc_ldc: { const void* nextLabel; ; ((void)((2 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4337, "2 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[2]];;
+ {
+     frame->topOfStack = topOfStack;;
+     (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+     if (!CVMldcHelper(ee, topOfStack, cp, pc)) {
+  if ((((ee)->exceptionFlags.oneflag.local) != 0)) {
+      goto handle_exception;
+  }
+  goto quicken_opcode_noclobber;
+     }
+     { pc += 2; topOfStack += 1; ; }; ; goto *nextLabel;; };
+ }
+        opc_ldc_w: { const void* nextLabel; ; ((void)((3 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4350, "3 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[3]];;
+ {
+     frame->topOfStack = topOfStack;;
+     (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+     if (!CVMldc_wHelper(ee, topOfStack, cp, pc)) {
+  if ((((ee)->exceptionFlags.oneflag.local) != 0)) {
+      goto handle_exception;
+  }
+  goto quicken_opcode_noclobber;
+     }
+     { pc += 3; topOfStack += 1; ; }; ; goto *nextLabel;; };
+ }
+ {
+     CVMQuickenReturnCode retCode;
+     CVMClassBlock *cb;
+     CVMBool clobbersCpIndex;
+    quicken_opcode_noclobber:
+     clobbersCpIndex = (!(1 == 1));
+     goto quicken_opcode;
+    quicken_opcode_clobber:
+     clobbersCpIndex = (1 == 1);
+    quicken_opcode:
+     frame->topOfStack = topOfStack;;
+     (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+     (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("\t%s ==> quickening...\n", CVMopnames[pc[0]]) : (void)0);
+     retCode = CVMquickenOpcode(ee, pc, cp, &cb, clobbersCpIndex);
+     switch (retCode) {
+         case CVM_QUICKEN_ALREADY_QUICKENED:
+      break;
+         case CVM_QUICKEN_NEED_TO_RUN_STATIC_INITIALIZERS:
+      initCb = cb;
+      goto init_class;
+         case CVM_QUICKEN_ERROR: {
+      ((void)((((ee)->exceptionFlags.bothflags != 0 && ((((ee)->exceptionFlags.oneflag.local) != 0) || ((!(1 == 1)))))) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4396, "CVMexceptionOccurred(ee)") || (CVMsystemPanic("CVMassertHook returned"), 0)));
+      goto handle_exception;
+  }
+         default:
+      ((void)(((!(1 == 1))) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4400, "CVM_FALSE") || (CVMsystemPanic("CVMassertHook returned"), 0)));
+     }
+     {
+  const void* nextLabel;;
+  nextLabel = opclabels[pc[0]];;
+  ;
+  goto *nextLabel;;
+     }
+ }
+        opc_multianewarray_quick: { const void* nextLabel; ; ((void)((4 != 0) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4421, "4 != 0") || (CVMsystemPanic("CVMassertHook returned"), 0))); ; nextLabel = opclabels[pc[4]];;
+ {
+     CVMClassBlock* arrCb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4423, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))] & 0x3F) == CVM_CONSTANT_ClassBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4423, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), ClassBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))].resolved.cb);
+     frame->topOfStack = topOfStack;;
+     (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+     if (!CVMmultianewarrayHelper(ee, arrCb)) {
+  goto handle_exception;
+     }
+     topOfStack = frame->topOfStack;;
+     { pc += 4; topOfStack += 1; ; }; ; goto *nextLabel;; };
+ }
+ opc_xxxunusedxxx: ;
+     goto unimplemented_opcode;
+ opc_DEFAULT: ;
+ unimplemented_opcode:
+     CVMconsolePrintf ("\t*** Unimplemented opcode: %d = %s\n", pc[0], CVMopnames[pc[0]])
+                               ;
+     goto finish;
+ }
+    }
+    null_pointer_exception:
+ ;
+ { (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;; { if (((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4574, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) { (frame->topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4574, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4574, "CVMframeIsJava(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMJavaFrame*)(frame))->opstackX);; } else { (frame->topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4574, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_TRANSITION)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4574, "CVMframeIsTransition(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMTransitionFrame*)(frame))->opstackX);; } }; CVMthrowNullPointerException(ee, ((void *)0)); goto handle_exception_tos_already_reset; };
+    out_of_memory_error:
+ ;
+ { (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;; { if (((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4578, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) { (frame->topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4578, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4578, "CVMframeIsJava(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMJavaFrame*)(frame))->opstackX);; } else { (frame->topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4578, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_TRANSITION)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4578, "CVMframeIsTransition(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMTransitionFrame*)(frame))->opstackX);; } }; CVMthrowOutOfMemoryError(ee, ((void *)0)); goto handle_exception_tos_already_reset; };
+    array_index_out_of_bounds_exception:
+ ;
+ { (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;; { if (((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4582, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) { (frame->topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4582, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4582, "CVMframeIsJava(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMJavaFrame*)(frame))->opstackX);; } else { (frame->topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4582, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_TRANSITION)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4582, "CVMframeIsTransition(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMTransitionFrame*)(frame))->opstackX);; } }; CVMthrowArrayIndexOutOfBoundsException(ee, ((void *)0)); goto handle_exception_tos_already_reset; };
+    array_store_exception:
+ ;
+ { (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;; { if (((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4586, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) { (frame->topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4586, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4586, "CVMframeIsJava(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMJavaFrame*)(frame))->opstackX);; } else { (frame->topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4586, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_TRANSITION)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4586, "CVMframeIsTransition(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMTransitionFrame*)(frame))->opstackX);; } }; CVMthrowArrayStoreException(ee, ((void *)0)); goto handle_exception_tos_already_reset; };
+    arithmetic_exception_divide_by_zero:
+ ;
+ { (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;; { if (((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4590, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) { (frame->topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4590, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4590, "CVMframeIsJava(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMJavaFrame*)(frame))->opstackX);; } else { (frame->topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4590, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_TRANSITION)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4590, "CVMframeIsTransition(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMTransitionFrame*)(frame))->opstackX);; } }; CVMthrowArithmeticException(ee, "/ by zero"); goto handle_exception_tos_already_reset; };
+    illegal_monitor_state_exception_thread_not_owner:
+ ;
+ { (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;; { if (((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4595, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) { (frame->topOfStack) = (
+ (((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4595, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4595, "CVMframeIsJava(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMJavaFrame*)(frame))->opstackX);; } else { (frame->topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4595, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_TRANSITION)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4595, "CVMframeIsTransition(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMTransitionFrame*)(frame))->opstackX);; } }; CVMthrowIllegalMonitorStateException(ee, "current thread not owner"); goto handle_exception_tos_already_reset; };
+    out_of_memory_error_for_new_quick:
+    ;
+    {
+ CVMClassBlock* newCb = (((void)((((cp)->cpTypesX) == ((void *)0) || (((void)((((cp)->cpTypesX) != ((void *)0)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4600, "CVMcpTypes(cp) != NULL") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((cp)->cpTypesX)[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))] & 0x3F) == CVM_CONSTANT_ClassBlock)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4600, "CVMcpTypes(cp) == NULL || CVMcpTypeIs(cp, ((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1))))), ClassBlock)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (cp)->entriesX[((((*(CVMUint8*)((pc + 1)+(0))) << 8) | (*(CVMUint8*)((pc + 1)+(1)))))].resolved.cb);
+ CVMthrowOutOfMemoryError(ee, "%C", newCb);
+ goto handle_exception_tos_already_reset;
+    }
+    class_cast_exception:
+    ;
+    {
+ CVMObject* directObj = ((*(((void)(((!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4608, "(!((&((CVMgetEE()))->tcstate[(CVM_GC_SAFE)]))->isConsistent)") || (CVMsystemPanic("CVMassertHook returned"), 0))), &(&(((topOfStack[-1].s).j).r))->ref_DONT_ACCESS_DIRECTLY)));
+ CVMClassBlock* cb = ((CVMClassBlock*)(((CVMAddr)((directObj)->hdr.clas)) & ~3));
+ (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+ (frame->topOfStack) = ((((void)((((((void)((((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4611, "((CVMFrame*)((frame)))->type != CVM_FRAMETYPE_NONE") || (CVMsystemPanic("CVMassertHook returned"), 0))), (((CVMFrame*)((frame)))->type)) == CVM_FRAMETYPE_JAVA)) || CVMassertHook("../../src/share/javavm/runtime/executejava_standard.c", 4611, "CVMframeIsJava(frame)") || (CVMsystemPanic("CVMassertHook returned"), 0))), (CVMJavaFrame*)(frame))->opstackX);;
+ if (!(((ee)->exceptionFlags.oneflag.local) != 0)) {
+     CVMthrowClassCastException(ee, "%C", cb);
+ }
+ goto handle_exception_tos_already_reset;
+    }
+ finish:
+    ;
+    (((ee)->debugFlags & ((1L))) != 0 ? CVMconsolePrintf ("Exiting interpreter\n") : (void)0);
+    frame->topOfStack = topOfStack;;
+    (CVMDEBUGgetInterpreterFrame((CVMFrame *)(frame))->pcX) = pc;;
+    return;
+}
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.target/sh/fpchg1.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.target/sh/fpchg1.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.target/sh/fpchg1.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.target/sh/fpchg1.c	2013-05-28 13:15:34.000000000 +0200
@@ -0,0 +1,24 @@
+/* { dg-do run } */
+/* { dg-options "-O1 -m4-300" } */
+
+/* Check that the fpchg instruction is not moved in a delay slot if the
+   fallthru block uses the mode.  */
+
+__attribute__ ((weak))
+void barrier(void)
+{
+}
+
+float f;
+int i;
+double d;
+
+int main()
+{
+  i = 4;
+
+  barrier();
+
+  i = (f + (i && f && d));
+  return i;
+}
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.target/sh/fpchg2.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.target/sh/fpchg2.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.target/sh/fpchg2.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.target/sh/fpchg2.c	2013-05-28 13:15:34.000000000 +0200
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -m4-300" } */
+
+/* Make sure that fpchg is preferred over lfd.s fpscr.  */
+/* { dg-final { scan-assembler "fpchg" } } */
+/* { dg-final { scan-assembler-not "fpscr" } } */
+
+extern float c;
+
+void
+foo(int j)
+{
+  while (j--)
+    c++;
+
+}
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.target/sh/jump_compact_1.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.target/sh/jump_compact_1.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.target/sh/jump_compact_1.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.target/sh/jump_compact_1.c	2013-05-28 13:15:34.000000000 +0200
@@ -0,0 +1,17 @@
+/* { dg-do compile { target "sh*-*-*" } } */
+/* { dg-options "-O2" } */
+/* { dg-final { scan-assembler-not "braf"} }  */
+
+/* Check that no braf instruction is used to emit a far jump.  */
+
+int main(int argc,char **argv)
+{
+  if( argc < 2 )
+    goto label;
+
+  asm(".fill 16383,2,0x09");
+
+ label:
+  puts("after label");
+  return 0;
+}
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.target/sh/jump_compact_2.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.target/sh/jump_compact_2.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.target/sh/jump_compact_2.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.target/sh/jump_compact_2.c	2013-05-28 13:15:34.000000000 +0200
@@ -0,0 +1,16 @@
+/* { dg-do run { target "sh*-*-*" } } */
+/* { dg-options "-O2" } */
+
+/* Check that a braf instruction is used to emit a medium jump.  */
+
+int main(int argc,char **argv)
+{
+  if( argc < 2 )
+    goto label;
+
+  asm(".fill 16382,2,0x09");
+
+ label:
+  puts("after label");
+  return 0;
+}
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.target/sh/mfmovd.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.target/sh/mfmovd.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.target/sh/mfmovd.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.target/sh/mfmovd.c	2013-05-28 13:15:34.000000000 +0200
@@ -1,8 +1,9 @@
 /* Verify that we generate fmov.d instructions to move doubles when -mfmovd 
    option is enabled.  */
 /* { dg-do compile { target "sh*-*-*" } } */
+/* { dg-require-effective-target hard_float } */
 /* { dg-options "-mfmovd" } */
-/* { dg-skip-if "" { "sh*-*-*" } { "*" } { "-m2a" "-m2a-single" "-m4" "-m4-single" "-m4-100" "-m4-100-single" "-m4-200" "-m4-200-single" "-m4-300" "-m4-300-single" "-m4a" "-m4a-single" } }  */
+/* { dg-skip-if "" { *-*-* }  { "*-single-only" } { "" } } */
 /* { dg-final { scan-assembler "fmov.d" } } */
 
 extern double g;
@@ -13,3 +14,10 @@
   g = d;
 }
 
+extern float h;
+
+void f2 ()
+{
+  h = g;
+}
+
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.target/sh/muladd.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.target/sh/muladd.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.target/sh/muladd.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.target/sh/muladd.c	2013-05-28 13:15:34.000000000 +0200
@@ -0,0 +1,20 @@
+/* Check that sequences of n r=r+b arecombined into r=r*nb
+   instructions.  */
+/* { dg-do compile { target "sh*-*-*" } } */
+/* { dg-options "-O2" } */
+/* { dg-final { scan-assembler-times "shl[dl]" 1 } } */
+
+int
+plus_9(int dest_y, int dc)
+{
+  dc+= dest_y;
+  dc+= dest_y;
+  dc+= dest_y;
+  dc+= dest_y;
+  dc+= dest_y;
+  dc+= dest_y;
+  dc+= dest_y;
+  dc+= dest_y;
+
+  return dc;
+}
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.target/sh/pr32163.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.target/sh/pr32163.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.target/sh/pr32163.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.target/sh/pr32163.c	2013-05-28 13:15:34.000000000 +0200
@@ -0,0 +1,25 @@
+/* PR target/32163 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fstack-protector-all" } */
+/* { dg-require-effective-target fstack_protector } */
+
+struct __graph_iterator_t
+{
+ int vertex;
+ int edge;
+};
+
+struct __graph_t
+{
+ int *edges;
+ int *first;
+
+};
+
+struct __graph_iterator_t graph_neighbors_it(struct __graph_t *g, int v)
+{
+ struct __graph_iterator_t it;
+ it.vertex = 2;
+ it.edge = g->first[v];
+ return it;
+}
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.target/sh/sh-trapa.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.target/sh/sh-trapa.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.target/sh/sh-trapa.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.target/sh/sh-trapa.c	2013-05-28 13:15:34.000000000 +0200
@@ -0,0 +1,8 @@
+/* { dg-do compile { target "sh-superh-elf" } } */
+/* { dg-final { scan-assembler "trapa\t#42" } } */
+
+main()
+{
+  __builtin_trap();
+}
+
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.target/sh/strlen.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.target/sh/strlen.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.target/sh/strlen.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.target/sh/strlen.c	2013-11-05 14:59:40.000000000 +0100
@@ -0,0 +1,19 @@
+/* Check that the __builtin_strlen function is inlined with cmp/str
+   when optimizing for speed.  */
+/* { dg-do compile { target "sh*-*-*" } } */
+/* { dg-options "-O2" } */
+/* { dg-skip-if "" { "sh*-*-*" } { "-m5*" } { "" } } */
+/* { dg-final { scan-assembler-not "jmp" } } */
+/* { dg-final { scan-assembler-times "cmp/str" 2 } } */
+/* { dg-final { scan-assembler-times "tst\t#3" 1 } } */
+
+test00 (const char *s1)
+{
+  return __builtin_strlen (s1);
+}
+
+/* Check that no test for alignment is needed.  */
+test03(const char *s1)
+{
+  return __builtin_strlen (__builtin_assume_aligned (s1, 4));
+}
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.target/sh/strncmp.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.target/sh/strncmp.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.target/sh/strncmp.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.target/sh/strncmp.c	2014-01-22 12:58:07.000000000 +0100
@@ -0,0 +1,21 @@
+/* { dg-do run } */
+
+extern void abort (void);
+
+const char *s="astc";
+const char *s1="-----BEGIN RSA PRIVATE KEY-----";
+const char *s2="atextaac";
+main()
+{
+  if (! strncmp ("astb", s, 4))
+    abort();
+
+  if (strncmp(s1, "-----BEGIN ", 11))
+    abort();
+
+  if (! strncmp ("atextaacb", s2, 9))
+    abort();
+
+  return 0;
+}
+
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.target/sh/torture/dce.C gcc-st40-4.8.2.140205/gcc/testsuite/gcc.target/sh/torture/dce.C
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.target/sh/torture/dce.C	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.target/sh/torture/dce.C	2014-01-28 09:59:31.000000000 +0100
@@ -0,0 +1,19036 @@
+/* { dg-do compile } */
+
+extern "C" {
+}
+typedef __builtin_va_list __gnuc_va_list;
+typedef __gnuc_va_list va_list;
+typedef int ptrdiff_t;
+typedef unsigned int size_t;
+extern "C" {
+typedef unsigned char __u_char;
+typedef unsigned short int __u_short;
+typedef unsigned int __u_int;
+typedef unsigned long int __u_long;
+typedef signed char __int8_t;
+typedef unsigned char __uint8_t;
+typedef signed short int __int16_t;
+typedef unsigned short int __uint16_t;
+typedef signed int __int32_t;
+typedef unsigned int __uint32_t;
+__extension__ typedef signed long long int __int64_t;
+__extension__ typedef unsigned long long int __uint64_t;
+__extension__ typedef long long int __quad_t;
+__extension__ typedef unsigned long long int __u_quad_t;
+__extension__ typedef __u_quad_t __dev_t;
+__extension__ typedef unsigned int __uid_t;
+__extension__ typedef unsigned int __gid_t;
+__extension__ typedef unsigned long int __ino_t;
+__extension__ typedef __u_quad_t __ino64_t;
+__extension__ typedef unsigned int __mode_t;
+__extension__ typedef unsigned int __nlink_t;
+__extension__ typedef long int __off_t;
+__extension__ typedef __quad_t __off64_t;
+__extension__ typedef int __pid_t;
+__extension__ typedef struct { int __val[2]; } __fsid_t;
+__extension__ typedef long int __clock_t;
+__extension__ typedef unsigned long int __rlim_t;
+__extension__ typedef __u_quad_t __rlim64_t;
+__extension__ typedef unsigned int __id_t;
+__extension__ typedef long int __time_t;
+__extension__ typedef unsigned int __useconds_t;
+__extension__ typedef long int __suseconds_t;
+__extension__ typedef int __daddr_t;
+__extension__ typedef long int __swblk_t;
+__extension__ typedef int __key_t;
+__extension__ typedef int __clockid_t;
+__extension__ typedef void * __timer_t;
+__extension__ typedef long int __blksize_t;
+__extension__ typedef long int __blkcnt_t;
+__extension__ typedef __quad_t __blkcnt64_t;
+__extension__ typedef unsigned long int __fsblkcnt_t;
+__extension__ typedef __u_quad_t __fsblkcnt64_t;
+__extension__ typedef unsigned long int __fsfilcnt_t;
+__extension__ typedef __u_quad_t __fsfilcnt64_t;
+__extension__ typedef int __ssize_t;
+typedef __off64_t __loff_t;
+typedef __quad_t *__qaddr_t;
+typedef char *__caddr_t;
+__extension__ typedef int __intptr_t;
+__extension__ typedef unsigned int __socklen_t;
+struct _IO_FILE;
+
+typedef struct _IO_FILE FILE;
+
+
+typedef struct _IO_FILE __FILE;
+typedef struct
+{
+  int __count;
+  union
+  {
+    unsigned int __wch;
+    char __wchb[4];
+  } __value;
+} __mbstate_t;
+typedef struct
+{
+  __off_t __pos;
+  __mbstate_t __state;
+} _G_fpos_t;
+typedef struct
+{
+  __off64_t __pos;
+  __mbstate_t __state;
+} _G_fpos64_t;
+typedef int _G_int16_t __attribute__ ((__mode__ (__HI__)));
+typedef int _G_int32_t __attribute__ ((__mode__ (__SI__)));
+typedef unsigned int _G_uint16_t __attribute__ ((__mode__ (__HI__)));
+typedef unsigned int _G_uint32_t __attribute__ ((__mode__ (__SI__)));
+struct _IO_jump_t; struct _IO_FILE;
+typedef void _IO_lock_t;
+struct _IO_marker {
+  struct _IO_marker *_next;
+  struct _IO_FILE *_sbuf;
+  int _pos;
+};
+enum __codecvt_result
+{
+  __codecvt_ok,
+  __codecvt_partial,
+  __codecvt_error,
+  __codecvt_noconv
+};
+struct _IO_FILE {
+  int _flags;
+  char* _IO_read_ptr;
+  char* _IO_read_end;
+  char* _IO_read_base;
+  char* _IO_write_base;
+  char* _IO_write_ptr;
+  char* _IO_write_end;
+  char* _IO_buf_base;
+  char* _IO_buf_end;
+  char *_IO_save_base;
+  char *_IO_backup_base;
+  char *_IO_save_end;
+  struct _IO_marker *_markers;
+  struct _IO_FILE *_chain;
+  int _fileno;
+  int _flags2;
+  __off_t _old_offset;
+  unsigned short _cur_column;
+  signed char _vtable_offset;
+  char _shortbuf[1];
+  _IO_lock_t *_lock;
+  __off64_t _offset;
+  void *__pad1;
+  void *__pad2;
+  void *__pad3;
+  void *__pad4;
+  size_t __pad5;
+  int _mode;
+  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
+};
+struct _IO_FILE_plus;
+extern struct _IO_FILE_plus _IO_2_1_stdin_;
+extern struct _IO_FILE_plus _IO_2_1_stdout_;
+extern struct _IO_FILE_plus _IO_2_1_stderr_;
+typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);
+typedef __ssize_t __io_write_fn (void *__cookie, __const char *__buf,
+     size_t __n);
+typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);
+typedef int __io_close_fn (void *__cookie);
+typedef __io_read_fn cookie_read_function_t;
+typedef __io_write_fn cookie_write_function_t;
+typedef __io_seek_fn cookie_seek_function_t;
+typedef __io_close_fn cookie_close_function_t;
+typedef struct
+{
+  __io_read_fn *read;
+  __io_write_fn *write;
+  __io_seek_fn *seek;
+  __io_close_fn *close;
+} _IO_cookie_io_functions_t;
+typedef _IO_cookie_io_functions_t cookie_io_functions_t;
+struct _IO_cookie_file;
+extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
+        void *__cookie, _IO_cookie_io_functions_t __fns);
+extern "C" {
+extern int __underflow (_IO_FILE *);
+extern int __uflow (_IO_FILE *);
+extern int __overflow (_IO_FILE *, int);
+extern int _IO_getc (_IO_FILE *__fp);
+extern int _IO_putc (int __c, _IO_FILE *__fp);
+extern int _IO_feof (_IO_FILE *__fp) throw ();
+extern int _IO_ferror (_IO_FILE *__fp) throw ();
+extern int _IO_peekc_locked (_IO_FILE *__fp);
+extern void _IO_flockfile (_IO_FILE *) throw ();
+extern void _IO_funlockfile (_IO_FILE *) throw ();
+extern int _IO_ftrylockfile (_IO_FILE *) throw ();
+extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
+   __gnuc_va_list, int *__restrict);
+extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
+    __gnuc_va_list);
+extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
+extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);
+extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
+extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);
+extern void _IO_free_backup_area (_IO_FILE *) throw ();
+}
+typedef __off64_t off_t;
+typedef __off64_t off64_t;
+typedef __ssize_t ssize_t;
+
+typedef _G_fpos64_t fpos_t;
+
+typedef _G_fpos64_t fpos64_t;
+extern struct _IO_FILE *stdin;
+extern struct _IO_FILE *stdout;
+extern struct _IO_FILE *stderr;
+
+extern int remove (__const char *__filename) throw ();
+extern int rename (__const char *__old, __const char *__new) throw ();
+
+extern int renameat (int __oldfd, __const char *__old, int __newfd,
+       __const char *__new) throw ();
+
+extern FILE *tmpfile (void) __asm__ ("" "tmpfile64") ;
+extern FILE *tmpfile64 (void) ;
+extern char *tmpnam (char *__s) throw () ;
+
+extern char *tmpnam_r (char *__s) throw () ;
+extern char *tempnam (__const char *__dir, __const char *__pfx)
+     throw () __attribute__ ((__malloc__)) ;
+
+extern int fclose (FILE *__stream);
+extern int fflush (FILE *__stream);
+
+extern int fflush_unlocked (FILE *__stream);
+extern int fcloseall (void);
+
+extern FILE *fopen (__const char *__restrict __filename, __const char *__restrict __modes) __asm__ ("" "fopen64")
+  ;
+extern FILE *freopen (__const char *__restrict __filename, __const char *__restrict __modes, FILE *__restrict __stream) __asm__ ("" "freopen64")
+  ;
+
+extern FILE *fopen64 (__const char *__restrict __filename,
+        __const char *__restrict __modes) ;
+extern FILE *freopen64 (__const char *__restrict __filename,
+   __const char *__restrict __modes,
+   FILE *__restrict __stream) ;
+extern FILE *fdopen (int __fd, __const char *__modes) throw () ;
+extern FILE *fopencookie (void *__restrict __magic_cookie,
+     __const char *__restrict __modes,
+     _IO_cookie_io_functions_t __io_funcs) throw () ;
+extern FILE *fmemopen (void *__s, size_t __len, __const char *__modes)
+  throw () ;
+extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw () ;
+
+extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();
+extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
+      int __modes, size_t __n) throw ();
+
+extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
+         size_t __size) throw ();
+extern void setlinebuf (FILE *__stream) throw ();
+
+extern int fprintf (FILE *__restrict __stream,
+      __const char *__restrict __format, ...);
+extern int printf (__const char *__restrict __format, ...);
+extern int sprintf (char *__restrict __s,
+      __const char *__restrict __format, ...) throw ();
+extern int vfprintf (FILE *__restrict __s, __const char *__restrict __format,
+       __gnuc_va_list __arg);
+extern int vprintf (__const char *__restrict __format, __gnuc_va_list __arg);
+extern int vsprintf (char *__restrict __s, __const char *__restrict __format,
+       __gnuc_va_list __arg) throw ();
+
+
+extern int snprintf (char *__restrict __s, size_t __maxlen,
+       __const char *__restrict __format, ...)
+     throw () __attribute__ ((__format__ (__printf__, 3, 4)));
+extern int vsnprintf (char *__restrict __s, size_t __maxlen,
+        __const char *__restrict __format, __gnuc_va_list __arg)
+     throw () __attribute__ ((__format__ (__printf__, 3, 0)));
+
+extern int vasprintf (char **__restrict __ptr, __const char *__restrict __f,
+        __gnuc_va_list __arg)
+     throw () __attribute__ ((__format__ (__printf__, 2, 0))) ;
+extern int __asprintf (char **__restrict __ptr,
+         __const char *__restrict __fmt, ...)
+     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
+extern int asprintf (char **__restrict __ptr,
+       __const char *__restrict __fmt, ...)
+     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
+extern int vdprintf (int __fd, __const char *__restrict __fmt,
+       __gnuc_va_list __arg)
+     __attribute__ ((__format__ (__printf__, 2, 0)));
+extern int dprintf (int __fd, __const char *__restrict __fmt, ...)
+     __attribute__ ((__format__ (__printf__, 2, 3)));
+
+extern int fscanf (FILE *__restrict __stream,
+     __const char *__restrict __format, ...) ;
+extern int scanf (__const char *__restrict __format, ...) ;
+extern int sscanf (__const char *__restrict __s,
+     __const char *__restrict __format, ...) throw ();
+
+
+extern int vfscanf (FILE *__restrict __s, __const char *__restrict __format,
+      __gnuc_va_list __arg)
+     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
+extern int vscanf (__const char *__restrict __format, __gnuc_va_list __arg)
+     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
+extern int vsscanf (__const char *__restrict __s,
+      __const char *__restrict __format, __gnuc_va_list __arg)
+     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));
+
+
+extern int fgetc (FILE *__stream);
+extern int getc (FILE *__stream);
+extern int getchar (void);
+
+extern int getc_unlocked (FILE *__stream);
+extern int getchar_unlocked (void);
+extern int fgetc_unlocked (FILE *__stream);
+
+extern int fputc (int __c, FILE *__stream);
+extern int putc (int __c, FILE *__stream);
+extern int putchar (int __c);
+
+extern int fputc_unlocked (int __c, FILE *__stream);
+extern int putc_unlocked (int __c, FILE *__stream);
+extern int putchar_unlocked (int __c);
+extern int getw (FILE *__stream);
+extern int putw (int __w, FILE *__stream);
+
+extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
+     ;
+extern char *gets (char *__s) ;
+
+extern char *fgets_unlocked (char *__restrict __s, int __n,
+        FILE *__restrict __stream) ;
+extern __ssize_t __getdelim (char **__restrict __lineptr,
+          size_t *__restrict __n, int __delimiter,
+          FILE *__restrict __stream) ;
+extern __ssize_t getdelim (char **__restrict __lineptr,
+        size_t *__restrict __n, int __delimiter,
+        FILE *__restrict __stream) ;
+extern __ssize_t getline (char **__restrict __lineptr,
+       size_t *__restrict __n,
+       FILE *__restrict __stream) ;
+
+extern int fputs (__const char *__restrict __s, FILE *__restrict __stream);
+extern int puts (__const char *__s);
+extern int ungetc (int __c, FILE *__stream);
+extern size_t fread (void *__restrict __ptr, size_t __size,
+       size_t __n, FILE *__restrict __stream) ;
+extern size_t fwrite (__const void *__restrict __ptr, size_t __size,
+        size_t __n, FILE *__restrict __s) ;
+
+extern int fputs_unlocked (__const char *__restrict __s,
+      FILE *__restrict __stream);
+extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
+         size_t __n, FILE *__restrict __stream) ;
+extern size_t fwrite_unlocked (__const void *__restrict __ptr, size_t __size,
+          size_t __n, FILE *__restrict __stream) ;
+
+extern int fseek (FILE *__stream, long int __off, int __whence);
+extern long int ftell (FILE *__stream) ;
+extern void rewind (FILE *__stream);
+
+extern int fseeko (FILE *__stream, __off64_t __off, int __whence) __asm__ ("" "fseeko64");
+extern __off64_t ftello (FILE *__stream) __asm__ ("" "ftello64");
+
+extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos) __asm__ ("" "fgetpos64");
+extern int fsetpos (FILE *__stream, __const fpos_t *__pos) __asm__ ("" "fsetpos64");
+
+extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
+extern __off64_t ftello64 (FILE *__stream) ;
+extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
+extern int fsetpos64 (FILE *__stream, __const fpos64_t *__pos);
+
+extern void clearerr (FILE *__stream) throw ();
+extern int feof (FILE *__stream) throw () ;
+extern int ferror (FILE *__stream) throw () ;
+
+extern void clearerr_unlocked (FILE *__stream) throw ();
+extern int feof_unlocked (FILE *__stream) throw () ;
+extern int ferror_unlocked (FILE *__stream) throw () ;
+
+extern void perror (__const char *__s);
+
+extern int sys_nerr;
+extern __const char *__const sys_errlist[];
+extern int _sys_nerr;
+extern __const char *__const _sys_errlist[];
+extern int fileno (FILE *__stream) throw () ;
+extern int fileno_unlocked (FILE *__stream) throw () ;
+extern FILE *popen (__const char *__command, __const char *__modes) ;
+extern int pclose (FILE *__stream);
+extern char *ctermid (char *__s) throw ();
+extern char *cuserid (char *__s);
+struct obstack;
+extern int obstack_printf (struct obstack *__restrict __obstack,
+      __const char *__restrict __format, ...)
+     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
+extern int obstack_vprintf (struct obstack *__restrict __obstack,
+       __const char *__restrict __format,
+       __gnuc_va_list __args)
+     throw () __attribute__ ((__format__ (__printf__, 2, 0)));
+extern void flockfile (FILE *__stream) throw ();
+extern int ftrylockfile (FILE *__stream) throw () ;
+extern void funlockfile (FILE *__stream) throw ();
+extern __inline __attribute__ ((__gnu_inline__)) int
+vprintf (__const char *__restrict __fmt, __gnuc_va_list __arg)
+{
+  return vfprintf (stdout, __fmt, __arg);
+}
+extern __inline __attribute__ ((__gnu_inline__)) int
+getchar (void)
+{
+  return _IO_getc (stdin);
+}
+extern __inline __attribute__ ((__gnu_inline__)) int
+fgetc_unlocked (FILE *__fp)
+{
+  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
+}
+extern __inline __attribute__ ((__gnu_inline__)) int
+getc_unlocked (FILE *__fp)
+{
+  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
+}
+extern __inline __attribute__ ((__gnu_inline__)) int
+getchar_unlocked (void)
+{
+  return (__builtin_expect (((stdin)->_IO_read_ptr >= (stdin)->_IO_read_end), 0) ? __uflow (stdin) : *(unsigned char *) (stdin)->_IO_read_ptr++);
+}
+extern __inline __attribute__ ((__gnu_inline__)) int
+putchar (int __c)
+{
+  return _IO_putc (__c, stdout);
+}
+extern __inline __attribute__ ((__gnu_inline__)) int
+fputc_unlocked (int __c, FILE *__stream)
+{
+  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
+}
+extern __inline __attribute__ ((__gnu_inline__)) int
+putc_unlocked (int __c, FILE *__stream)
+{
+  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
+}
+extern __inline __attribute__ ((__gnu_inline__)) int
+putchar_unlocked (int __c)
+{
+  return (__builtin_expect (((stdout)->_IO_write_ptr >= (stdout)->_IO_write_end), 0) ? __overflow (stdout, (unsigned char) (__c)) : (unsigned char) (*(stdout)->_IO_write_ptr++ = (__c)));
+}
+extern __inline __attribute__ ((__gnu_inline__)) __ssize_t
+getline (char **__lineptr, size_t *__n, FILE *__stream)
+{
+  return __getdelim (__lineptr, __n, '\n', __stream);
+}
+extern __inline __attribute__ ((__gnu_inline__)) int
+feof_unlocked (FILE *__stream) throw ()
+{
+  return (((__stream)->_flags & 0x10) != 0);
+}
+extern __inline __attribute__ ((__gnu_inline__)) int
+ferror_unlocked (FILE *__stream) throw ()
+{
+  return (((__stream)->_flags & 0x20) != 0);
+}
+}
+extern "C" {
+}
+enum {
+  _sch_isblank = 0x0001,
+  _sch_iscntrl = 0x0002,
+  _sch_isdigit = 0x0004,
+  _sch_islower = 0x0008,
+  _sch_isprint = 0x0010,
+  _sch_ispunct = 0x0020,
+  _sch_isspace = 0x0040,
+  _sch_isupper = 0x0080,
+  _sch_isxdigit = 0x0100,
+  _sch_isidst = 0x0200,
+  _sch_isvsp = 0x0400,
+  _sch_isnvsp = 0x0800,
+  _sch_isalpha = _sch_isupper|_sch_islower,
+  _sch_isalnum = _sch_isalpha|_sch_isdigit,
+  _sch_isidnum = _sch_isidst|_sch_isdigit,
+  _sch_isgraph = _sch_isalnum|_sch_ispunct,
+  _sch_iscppsp = _sch_isvsp|_sch_isnvsp,
+  _sch_isbasic = _sch_isprint|_sch_iscppsp
+};
+extern const unsigned short _sch_istable[256];
+extern const unsigned char _sch_toupper[256];
+extern const unsigned char _sch_tolower[256];
+extern "C" {
+enum
+{
+  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
+  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
+  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
+  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
+  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
+  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
+  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
+  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
+  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
+  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
+  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
+  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
+};
+extern __const unsigned short int **__ctype_b_loc (void)
+     throw () __attribute__ ((__const));
+extern __const __int32_t **__ctype_tolower_loc (void)
+     throw () __attribute__ ((__const));
+extern __const __int32_t **__ctype_toupper_loc (void)
+     throw () __attribute__ ((__const));
+
+extern int isalnum (int) throw ();
+extern int isalpha (int) throw ();
+extern int iscntrl (int) throw ();
+extern int isdigit (int) throw ();
+extern int islower (int) throw ();
+extern int isgraph (int) throw ();
+extern int isprint (int) throw ();
+extern int ispunct (int) throw ();
+extern int isspace (int) throw ();
+extern int isupper (int) throw ();
+extern int isxdigit (int) throw ();
+extern int tolower (int __c) throw ();
+extern int toupper (int __c) throw ();
+
+
+extern int isblank (int) throw ();
+
+extern int isctype (int __c, int __mask) throw ();
+extern int isascii (int __c) throw ();
+extern int toascii (int __c) throw ();
+extern int _toupper (int) throw ();
+extern int _tolower (int) throw ();
+typedef struct __locale_struct
+{
+  struct __locale_data *__locales[13];
+  const unsigned short int *__ctype_b;
+  const int *__ctype_tolower;
+  const int *__ctype_toupper;
+  const char *__names[13];
+} *__locale_t;
+typedef __locale_t locale_t;
+extern int isalnum_l (int, __locale_t) throw ();
+extern int isalpha_l (int, __locale_t) throw ();
+extern int iscntrl_l (int, __locale_t) throw ();
+extern int isdigit_l (int, __locale_t) throw ();
+extern int islower_l (int, __locale_t) throw ();
+extern int isgraph_l (int, __locale_t) throw ();
+extern int isprint_l (int, __locale_t) throw ();
+extern int ispunct_l (int, __locale_t) throw ();
+extern int isspace_l (int, __locale_t) throw ();
+extern int isupper_l (int, __locale_t) throw ();
+extern int isxdigit_l (int, __locale_t) throw ();
+extern int isblank_l (int, __locale_t) throw ();
+extern int __tolower_l (int __c, __locale_t __l) throw ();
+extern int tolower_l (int __c, __locale_t __l) throw ();
+extern int __toupper_l (int __c, __locale_t __l) throw ();
+extern int toupper_l (int __c, __locale_t __l) throw ();
+}
+extern "C" {
+typedef __u_char u_char;
+typedef __u_short u_short;
+typedef __u_int u_int;
+typedef __u_long u_long;
+typedef __quad_t quad_t;
+typedef __u_quad_t u_quad_t;
+typedef __fsid_t fsid_t;
+typedef __loff_t loff_t;
+typedef __ino64_t ino_t;
+typedef __ino64_t ino64_t;
+typedef __dev_t dev_t;
+typedef __gid_t gid_t;
+typedef __mode_t mode_t;
+typedef __nlink_t nlink_t;
+typedef __uid_t uid_t;
+typedef __pid_t pid_t;
+typedef __id_t id_t;
+typedef __daddr_t daddr_t;
+typedef __caddr_t caddr_t;
+typedef __key_t key_t;
+
+typedef __clock_t clock_t;
+
+
+
+typedef __time_t time_t;
+
+
+typedef __clockid_t clockid_t;
+typedef __timer_t timer_t;
+typedef __useconds_t useconds_t;
+typedef __suseconds_t suseconds_t;
+typedef unsigned long int ulong;
+typedef unsigned short int ushort;
+typedef unsigned int uint;
+typedef int int8_t __attribute__ ((__mode__ (__QI__)));
+typedef int int16_t __attribute__ ((__mode__ (__HI__)));
+typedef int int32_t __attribute__ ((__mode__ (__SI__)));
+typedef int int64_t __attribute__ ((__mode__ (__DI__)));
+typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
+typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
+typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
+typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));
+typedef int register_t __attribute__ ((__mode__ (__word__)));
+typedef int __sig_atomic_t;
+typedef struct
+  {
+    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
+  } __sigset_t;
+typedef __sigset_t sigset_t;
+struct timespec
+  {
+    __time_t tv_sec;
+    long int tv_nsec;
+  };
+struct timeval
+  {
+    __time_t tv_sec;
+    __suseconds_t tv_usec;
+  };
+typedef long int __fd_mask;
+typedef struct
+  {
+    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];
+  } fd_set;
+typedef __fd_mask fd_mask;
+extern "C" {
+extern int select (int __nfds, fd_set *__restrict __readfds,
+     fd_set *__restrict __writefds,
+     fd_set *__restrict __exceptfds,
+     struct timeval *__restrict __timeout);
+extern int pselect (int __nfds, fd_set *__restrict __readfds,
+      fd_set *__restrict __writefds,
+      fd_set *__restrict __exceptfds,
+      const struct timespec *__restrict __timeout,
+      const __sigset_t *__restrict __sigmask);
+}
+extern "C" {
+__extension__
+extern unsigned int gnu_dev_major (unsigned long long int __dev)
+     throw ();
+__extension__
+extern unsigned int gnu_dev_minor (unsigned long long int __dev)
+     throw ();
+__extension__
+extern unsigned long long int gnu_dev_makedev (unsigned int __major,
+            unsigned int __minor)
+     throw ();
+__extension__ extern __inline __attribute__ ((__gnu_inline__)) unsigned int
+gnu_dev_major (unsigned long long int __dev) throw ()
+{
+  return ((__dev >> 8) & 0xfff) | ((unsigned int) (__dev >> 32) & ~0xfff);
+}
+__extension__ extern __inline __attribute__ ((__gnu_inline__)) unsigned int
+gnu_dev_minor (unsigned long long int __dev) throw ()
+{
+  return (__dev & 0xff) | ((unsigned int) (__dev >> 12) & ~0xff);
+}
+__extension__ extern __inline __attribute__ ((__gnu_inline__)) unsigned long long int
+gnu_dev_makedev (unsigned int __major, unsigned int __minor) throw ()
+{
+  return ((__minor & 0xff) | ((__major & 0xfff) << 8)
+   | (((unsigned long long int) (__minor & ~0xff)) << 12)
+   | (((unsigned long long int) (__major & ~0xfff)) << 32));
+}
+}
+typedef __blksize_t blksize_t;
+typedef __blkcnt64_t blkcnt_t;
+typedef __fsblkcnt64_t fsblkcnt_t;
+typedef __fsfilcnt64_t fsfilcnt_t;
+typedef __blkcnt64_t blkcnt64_t;
+typedef __fsblkcnt64_t fsblkcnt64_t;
+typedef __fsfilcnt64_t fsfilcnt64_t;
+typedef unsigned long int pthread_t;
+typedef union
+{
+  char __size[36];
+  long int __align;
+} pthread_attr_t;
+typedef struct __pthread_internal_slist
+{
+  struct __pthread_internal_slist *__next;
+} __pthread_slist_t;
+typedef union
+{
+  struct __pthread_mutex_s
+  {
+    int __lock;
+    unsigned int __count;
+    int __owner;
+    int __kind;
+    unsigned int __nusers;
+    __extension__ union
+    {
+      int __spins;
+      __pthread_slist_t __list;
+    };
+  } __data;
+  char __size[24];
+  long int __align;
+} pthread_mutex_t;
+typedef union
+{
+  char __size[4];
+  long int __align;
+} pthread_mutexattr_t;
+typedef union
+{
+  struct
+  {
+    int __lock;
+    unsigned int __futex;
+    __extension__ unsigned long long int __total_seq;
+    __extension__ unsigned long long int __wakeup_seq;
+    __extension__ unsigned long long int __woken_seq;
+    void *__mutex;
+    unsigned int __nwaiters;
+    unsigned int __broadcast_seq;
+  } __data;
+  char __size[48];
+  __extension__ long long int __align;
+} pthread_cond_t;
+typedef union
+{
+  char __size[4];
+  long int __align;
+} pthread_condattr_t;
+typedef unsigned int pthread_key_t;
+typedef int pthread_once_t;
+typedef union
+{
+  struct
+  {
+    int __lock;
+    unsigned int __nr_readers;
+    unsigned int __readers_wakeup;
+    unsigned int __writer_wakeup;
+    unsigned int __nr_readers_queued;
+    unsigned int __nr_writers_queued;
+    unsigned char __flags;
+    unsigned char __shared;
+    unsigned char __pad1;
+    unsigned char __pad2;
+    pthread_t __writer;
+  } __data;
+  char __size[32];
+  long int __align;
+} pthread_rwlock_t;
+typedef union
+{
+  char __size[8];
+  long int __align;
+} pthread_rwlockattr_t;
+typedef volatile int pthread_spinlock_t;
+typedef union
+{
+  char __size[20];
+  long int __align;
+} pthread_barrier_t;
+typedef union
+{
+  char __size[4];
+  int __align;
+} pthread_barrierattr_t;
+}
+extern "C" {
+extern int *__errno_location (void) throw () __attribute__ ((__const__));
+extern char *program_invocation_name, *program_invocation_short_name;
+}
+typedef int error_t;
+       
+namespace std
+{
+  typedef unsigned int size_t;
+  typedef int ptrdiff_t;
+}
+extern "C" {
+
+extern void *memcpy (void *__restrict __dest,
+       __const void *__restrict __src, size_t __n)
+     throw () __attribute__ ((__nonnull__ (1, 2)));
+extern void *memmove (void *__dest, __const void *__src, size_t __n)
+     throw () __attribute__ ((__nonnull__ (1, 2)));
+
+extern void *memccpy (void *__restrict __dest, __const void *__restrict __src,
+        int __c, size_t __n)
+     throw () __attribute__ ((__nonnull__ (1, 2)));
+
+extern void *memset (void *__s, int __c, size_t __n) throw () __attribute__ ((__nonnull__ (1)));
+extern int memcmp (__const void *__s1, __const void *__s2, size_t __n)
+     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern "C++"
+{
+extern void *memchr (void *__s, int __c, size_t __n)
+      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+extern __const void *memchr (__const void *__s, int __c, size_t __n)
+      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) void *
+memchr (void *__s, int __c, size_t __n) throw ()
+{
+  return __builtin_memchr (__s, __c, __n);
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __const void *
+memchr (__const void *__s, int __c, size_t __n) throw ()
+{
+  return __builtin_memchr (__s, __c, __n);
+}
+}
+
+extern "C++" void *rawmemchr (void *__s, int __c)
+     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+extern "C++" __const void *rawmemchr (__const void *__s, int __c)
+     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+extern "C++" void *memrchr (void *__s, int __c, size_t __n)
+      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+extern "C++" __const void *memrchr (__const void *__s, int __c, size_t __n)
+      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+
+extern char *strcpy (char *__restrict __dest, __const char *__restrict __src)
+     throw () __attribute__ ((__nonnull__ (1, 2)));
+extern char *strncpy (char *__restrict __dest,
+        __const char *__restrict __src, size_t __n)
+     throw () __attribute__ ((__nonnull__ (1, 2)));
+extern char *strcat (char *__restrict __dest, __const char *__restrict __src)
+     throw () __attribute__ ((__nonnull__ (1, 2)));
+extern char *strncat (char *__restrict __dest, __const char *__restrict __src,
+        size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));
+extern int strcmp (__const char *__s1, __const char *__s2)
+     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int strncmp (__const char *__s1, __const char *__s2, size_t __n)
+     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int strcoll (__const char *__s1, __const char *__s2)
+     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern size_t strxfrm (char *__restrict __dest,
+         __const char *__restrict __src, size_t __n)
+     throw () __attribute__ ((__nonnull__ (2)));
+
+extern int strcoll_l (__const char *__s1, __const char *__s2, __locale_t __l)
+     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));
+extern size_t strxfrm_l (char *__dest, __const char *__src, size_t __n,
+    __locale_t __l) throw () __attribute__ ((__nonnull__ (2, 4)));
+extern char *strdup (__const char *__s)
+     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
+extern char *strndup (__const char *__string, size_t __n)
+     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
+
+extern "C++"
+{
+extern char *strchr (char *__s, int __c)
+     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+extern __const char *strchr (__const char *__s, int __c)
+     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) char *
+strchr (char *__s, int __c) throw ()
+{
+  return __builtin_strchr (__s, __c);
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __const char *
+strchr (__const char *__s, int __c) throw ()
+{
+  return __builtin_strchr (__s, __c);
+}
+}
+extern "C++"
+{
+extern char *strrchr (char *__s, int __c)
+     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+extern __const char *strrchr (__const char *__s, int __c)
+     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) char *
+strrchr (char *__s, int __c) throw ()
+{
+  return __builtin_strrchr (__s, __c);
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __const char *
+strrchr (__const char *__s, int __c) throw ()
+{
+  return __builtin_strrchr (__s, __c);
+}
+}
+
+extern "C++" char *strchrnul (char *__s, int __c)
+     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+extern "C++" __const char *strchrnul (__const char *__s, int __c)
+     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+
+extern size_t strcspn (__const char *__s, __const char *__reject)
+     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern size_t strspn (__const char *__s, __const char *__accept)
+     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern "C++"
+{
+extern char *strpbrk (char *__s, __const char *__accept)
+     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern __const char *strpbrk (__const char *__s, __const char *__accept)
+     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) char *
+strpbrk (char *__s, __const char *__accept) throw ()
+{
+  return __builtin_strpbrk (__s, __accept);
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __const char *
+strpbrk (__const char *__s, __const char *__accept) throw ()
+{
+  return __builtin_strpbrk (__s, __accept);
+}
+}
+extern "C++"
+{
+extern char *strstr (char *__haystack, __const char *__needle)
+     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern __const char *strstr (__const char *__haystack,
+        __const char *__needle)
+     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) char *
+strstr (char *__haystack, __const char *__needle) throw ()
+{
+  return __builtin_strstr (__haystack, __needle);
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __const char *
+strstr (__const char *__haystack, __const char *__needle) throw ()
+{
+  return __builtin_strstr (__haystack, __needle);
+}
+}
+extern char *strtok (char *__restrict __s, __const char *__restrict __delim)
+     throw () __attribute__ ((__nonnull__ (2)));
+
+extern char *__strtok_r (char *__restrict __s,
+    __const char *__restrict __delim,
+    char **__restrict __save_ptr)
+     throw () __attribute__ ((__nonnull__ (2, 3)));
+extern char *strtok_r (char *__restrict __s, __const char *__restrict __delim,
+         char **__restrict __save_ptr)
+     throw () __attribute__ ((__nonnull__ (2, 3)));
+extern "C++" char *strcasestr (char *__haystack, __const char *__needle)
+     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern "C++" __const char *strcasestr (__const char *__haystack,
+           __const char *__needle)
+     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern void *memmem (__const void *__haystack, size_t __haystacklen,
+       __const void *__needle, size_t __needlelen)
+     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));
+extern void *__mempcpy (void *__restrict __dest,
+   __const void *__restrict __src, size_t __n)
+     throw () __attribute__ ((__nonnull__ (1, 2)));
+extern void *mempcpy (void *__restrict __dest,
+        __const void *__restrict __src, size_t __n)
+     throw () __attribute__ ((__nonnull__ (1, 2)));
+
+extern size_t strlen (__const char *__s)
+     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+
+extern size_t strnlen (__const char *__string, size_t __maxlen)
+     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+
+extern char *strerror (int __errnum) throw ();
+
+extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
+     throw () __attribute__ ((__nonnull__ (2)));
+extern char *strerror_l (int __errnum, __locale_t __l) throw ();
+extern void __bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));
+extern void bcopy (__const void *__src, void *__dest, size_t __n)
+     throw () __attribute__ ((__nonnull__ (1, 2)));
+extern void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));
+extern int bcmp (__const void *__s1, __const void *__s2, size_t __n)
+     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern "C++"
+{
+extern char *index (char *__s, int __c)
+     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+extern __const char *index (__const char *__s, int __c)
+     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) char *
+index (char *__s, int __c) throw ()
+{
+  return __builtin_index (__s, __c);
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __const char *
+index (__const char *__s, int __c) throw ()
+{
+  return __builtin_index (__s, __c);
+}
+}
+extern "C++"
+{
+extern char *rindex (char *__s, int __c)
+     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+extern __const char *rindex (__const char *__s, int __c)
+     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) char *
+rindex (char *__s, int __c) throw ()
+{
+  return __builtin_rindex (__s, __c);
+}
+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__, __artificial__)) __const char *
+rindex (__const char *__s, int __c) throw ()
+{
+  return __builtin_rindex (__s, __c);
+}
+}
+extern int ffs (int __i) throw () __attribute__ ((__const__));
+extern int ffsl (long int __l) throw () __attribute__ ((__const__));
+__extension__ extern int ffsll (long long int __ll)
+     throw () __attribute__ ((__const__));
+extern int strcasecmp (__const char *__s1, __const char *__s2)
+     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int strncasecmp (__const char *__s1, __const char *__s2, size_t __n)
+     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern int strcasecmp_l (__const char *__s1, __const char *__s2,
+    __locale_t __loc)
+     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));
+extern int strncasecmp_l (__const char *__s1, __const char *__s2,
+     size_t __n, __locale_t __loc)
+     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));
+extern char *strsep (char **__restrict __stringp,
+       __const char *__restrict __delim)
+     throw () __attribute__ ((__nonnull__ (1, 2)));
+extern char *strsignal (int __sig) throw ();
+extern char *__stpcpy (char *__restrict __dest, __const char *__restrict __src)
+     throw () __attribute__ ((__nonnull__ (1, 2)));
+extern char *stpcpy (char *__restrict __dest, __const char *__restrict __src)
+     throw () __attribute__ ((__nonnull__ (1, 2)));
+extern char *__stpncpy (char *__restrict __dest,
+   __const char *__restrict __src, size_t __n)
+     throw () __attribute__ ((__nonnull__ (1, 2)));
+extern char *stpncpy (char *__restrict __dest,
+        __const char *__restrict __src, size_t __n)
+     throw () __attribute__ ((__nonnull__ (1, 2)));
+extern int strverscmp (__const char *__s1, __const char *__s2)
+     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
+extern char *strfry (char *__string) throw () __attribute__ ((__nonnull__ (1)));
+extern void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));
+extern "C++" char *basename (char *__filename)
+     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
+extern "C++" __const char *basename (__const char *__filename)
+     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
+}
+namespace std __attribute__ ((__visibility__ ("default")))
+{
+
+  using ::memchr;
+  using ::memcmp;
+  using ::memcpy;
+  using ::memmove;
+  using ::memset;
+  using ::strcat;
+  using ::strcmp;
+  using ::strcoll;
+  using ::strcpy;
+  using ::strcspn;
+  using ::strerror;
+  using ::strlen;
+  using ::strncat;
+  using ::strncmp;
+  using ::strncpy;
+  using ::strspn;
+  using ::strtok;
+  using ::strxfrm;
+  using ::strchr;
+  using ::strpbrk;
+  using ::strrchr;
+  using ::strstr;
+
+}
+extern "C" {
+union wait
+  {
+    int w_status;
+    struct
+      {
+ unsigned int __w_termsig:7;
+ unsigned int __w_coredump:1;
+ unsigned int __w_retcode:8;
+ unsigned int:16;
+      } __wait_terminated;
+    struct
+      {
+ unsigned int __w_stopval:8;
+ unsigned int __w_stopsig:8;
+ unsigned int:16;
+      } __wait_stopped;
+  };
+
+typedef struct
+  {
+    int quot;
+    int rem;
+  } div_t;
+typedef struct
+  {
+    long int quot;
+    long int rem;
+  } ldiv_t;
+
+
+__extension__ typedef struct
+  {
+    long long int quot;
+    long long int rem;
+  } lldiv_t;
+
+extern size_t __ctype_get_mb_cur_max (void) throw () ;
+
+extern double atof (__const char *__nptr)
+     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;
+extern int atoi (__const char *__nptr)
+     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;
+extern long int atol (__const char *__nptr)
+     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;
+
+
+__extension__ extern long long int atoll (__const char *__nptr)
+     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;
+
+
+extern double strtod (__const char *__restrict __nptr,
+        char **__restrict __endptr)
+     throw () __attribute__ ((__nonnull__ (1))) ;
+
+
+extern float strtof (__const char *__restrict __nptr,
+       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1))) ;
+extern long double strtold (__const char *__restrict __nptr,
+       char **__restrict __endptr)
+     throw () __attribute__ ((__nonnull__ (1))) ;
+
+
+extern long int strtol (__const char *__restrict __nptr,
+   char **__restrict __endptr, int __base)
+     throw () __attribute__ ((__nonnull__ (1))) ;
+extern unsigned long int strtoul (__const char *__restrict __nptr,
+      char **__restrict __endptr, int __base)
+     throw () __attribute__ ((__nonnull__ (1))) ;
+
+__extension__
+extern long long int strtoq (__const char *__restrict __nptr,
+        char **__restrict __endptr, int __base)
+     throw () __attribute__ ((__nonnull__ (1))) ;
+__extension__
+extern unsigned long long int strtouq (__const char *__restrict __nptr,
+           char **__restrict __endptr, int __base)
+     throw () __attribute__ ((__nonnull__ (1))) ;
+
+__extension__
+extern long long int strtoll (__const char *__restrict __nptr,
+         char **__restrict __endptr, int __base)
+     throw () __attribute__ ((__nonnull__ (1))) ;
+__extension__
+extern unsigned long long int strtoull (__const char *__restrict __nptr,
+     char **__restrict __endptr, int __base)
+     throw () __attribute__ ((__nonnull__ (1))) ;
+
+extern long int strtol_l (__const char *__restrict __nptr,
+     char **__restrict __endptr, int __base,
+     __locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4))) ;
+extern unsigned long int strtoul_l (__const char *__restrict __nptr,
+        char **__restrict __endptr,
+        int __base, __locale_t __loc)
+     throw () __attribute__ ((__nonnull__ (1, 4))) ;
+__extension__
+extern long long int strtoll_l (__const char *__restrict __nptr,
+    char **__restrict __endptr, int __base,
+    __locale_t __loc)
+     throw () __attribute__ ((__nonnull__ (1, 4))) ;
+__extension__
+extern unsigned long long int strtoull_l (__const char *__restrict __nptr,
+       char **__restrict __endptr,
+       int __base, __locale_t __loc)
+     throw () __attribute__ ((__nonnull__ (1, 4))) ;
+extern double strtod_l (__const char *__restrict __nptr,
+   char **__restrict __endptr, __locale_t __loc)
+     throw () __attribute__ ((__nonnull__ (1, 3))) ;
+extern float strtof_l (__const char *__restrict __nptr,
+         char **__restrict __endptr, __locale_t __loc)
+     throw () __attribute__ ((__nonnull__ (1, 3))) ;
+extern long double strtold_l (__const char *__restrict __nptr,
+         char **__restrict __endptr,
+         __locale_t __loc)
+     throw () __attribute__ ((__nonnull__ (1, 3))) ;
+
+extern __inline __attribute__ ((__gnu_inline__)) double
+atof (__const char *__nptr) throw ()
+{
+  return strtod (__nptr, (char **) __null);
+}
+extern __inline __attribute__ ((__gnu_inline__)) int
+atoi (__const char *__nptr) throw ()
+{
+  return (int) strtol (__nptr, (char **) __null, 10);
+}
+extern __inline __attribute__ ((__gnu_inline__)) long int
+atol (__const char *__nptr) throw ()
+{
+  return strtol (__nptr, (char **) __null, 10);
+}
+
+
+__extension__ extern __inline __attribute__ ((__gnu_inline__)) long long int
+atoll (__const char *__nptr) throw ()
+{
+  return strtoll (__nptr, (char **) __null, 10);
+}
+
+extern char *l64a (long int __n) throw () ;
+extern long int a64l (__const char *__s)
+     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;
+extern long int random (void) throw ();
+extern void srandom (unsigned int __seed) throw ();
+extern char *initstate (unsigned int __seed, char *__statebuf,
+   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));
+extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));
+struct random_data
+  {
+    int32_t *fptr;
+    int32_t *rptr;
+    int32_t *state;
+    int rand_type;
+    int rand_deg;
+    int rand_sep;
+    int32_t *end_ptr;
+  };
+extern int random_r (struct random_data *__restrict __buf,
+       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
+extern int srandom_r (unsigned int __seed, struct random_data *__buf)
+     throw () __attribute__ ((__nonnull__ (2)));
+extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
+   size_t __statelen,
+   struct random_data *__restrict __buf)
+     throw () __attribute__ ((__nonnull__ (2, 4)));
+extern int setstate_r (char *__restrict __statebuf,
+         struct random_data *__restrict __buf)
+     throw () __attribute__ ((__nonnull__ (1, 2)));
+
+extern int rand (void) throw ();
+extern void srand (unsigned int __seed) throw ();
+
+extern int rand_r (unsigned int *__seed) throw ();
+extern double drand48 (void) throw ();
+extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));
+extern long int lrand48 (void) throw ();
+extern long int nrand48 (unsigned short int __xsubi[3])
+     throw () __attribute__ ((__nonnull__ (1)));
+extern long int mrand48 (void) throw ();
+extern long int jrand48 (unsigned short int __xsubi[3])
+     throw () __attribute__ ((__nonnull__ (1)));
+extern void srand48 (long int __seedval) throw ();
+extern unsigned short int *seed48 (unsigned short int __seed16v[3])
+     throw () __attribute__ ((__nonnull__ (1)));
+extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));
+struct drand48_data
+  {
+    unsigned short int __x[3];
+    unsigned short int __old_x[3];
+    unsigned short int __c;
+    unsigned short int __init;
+    unsigned long long int __a;
+  };
+extern int drand48_r (struct drand48_data *__restrict __buffer,
+        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
+extern int erand48_r (unsigned short int __xsubi[3],
+        struct drand48_data *__restrict __buffer,
+        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
+extern int lrand48_r (struct drand48_data *__restrict __buffer,
+        long int *__restrict __result)
+     throw () __attribute__ ((__nonnull__ (1, 2)));
+extern int nrand48_r (unsigned short int __xsubi[3],
+        struct drand48_data *__restrict __buffer,
+        long int *__restrict __result)
+     throw () __attribute__ ((__nonnull__ (1, 2)));
+extern int mrand48_r (struct drand48_data *__restrict __buffer,
+        long int *__restrict __result)
+     throw () __attribute__ ((__nonnull__ (1, 2)));
+extern int jrand48_r (unsigned short int __xsubi[3],
+        struct drand48_data *__restrict __buffer,
+        long int *__restrict __result)
+     throw () __attribute__ ((__nonnull__ (1, 2)));
+extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
+     throw () __attribute__ ((__nonnull__ (2)));
+extern int seed48_r (unsigned short int __seed16v[3],
+       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));
+extern int lcong48_r (unsigned short int __param[7],
+        struct drand48_data *__buffer)
+     throw () __attribute__ ((__nonnull__ (1, 2)));
+
+extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) ;
+extern void *calloc (size_t __nmemb, size_t __size)
+     throw () __attribute__ ((__malloc__)) ;
+
+
+extern void *realloc (void *__ptr, size_t __size)
+     throw () __attribute__ ((__warn_unused_result__));
+extern void free (void *__ptr) throw ();
+
+extern void cfree (void *__ptr) throw ();
+extern "C" {
+extern void *alloca (size_t __size) throw ();
+}
+extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) ;
+extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
+     throw () __attribute__ ((__nonnull__ (1))) ;
+
+extern void abort (void) throw () __attribute__ ((__noreturn__));
+extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));
+extern "C++" int at_quick_exit (void (*__func) (void))
+     throw () __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));
+
+extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
+     throw () __attribute__ ((__nonnull__ (1)));
+
+extern void exit (int __status) throw () __attribute__ ((__noreturn__));
+extern void quick_exit (int __status) throw () __attribute__ ((__noreturn__));
+
+
+extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));
+
+
+extern char *getenv (__const char *__name) throw () __attribute__ ((__nonnull__ (1))) ;
+
+extern char *__secure_getenv (__const char *__name)
+     throw () __attribute__ ((__nonnull__ (1))) ;
+extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));
+extern int setenv (__const char *__name, __const char *__value, int __replace)
+     throw () __attribute__ ((__nonnull__ (2)));
+extern int unsetenv (__const char *__name) throw () __attribute__ ((__nonnull__ (1)));
+extern int clearenv (void) throw ();
+extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
+extern int mkstemp (char *__template) __asm__ ("" "mkstemp64")
+     __attribute__ ((__nonnull__ (1))) ;
+extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
+extern int mkstemps (char *__template, int __suffixlen) __asm__ ("" "mkstemps64") __attribute__ ((__nonnull__ (1))) ;
+extern int mkstemps64 (char *__template, int __suffixlen)
+     __attribute__ ((__nonnull__ (1))) ;
+extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
+extern int mkostemp (char *__template, int __flags) __asm__ ("" "mkostemp64")
+     __attribute__ ((__nonnull__ (1))) ;
+extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
+extern int mkostemps (char *__template, int __suffixlen, int __flags) __asm__ ("" "mkostemps64")
+     __attribute__ ((__nonnull__ (1))) ;
+extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
+     __attribute__ ((__nonnull__ (1))) ;
+
+extern int system (__const char *__command) ;
+
+extern char *canonicalize_file_name (__const char *__name)
+     throw () __attribute__ ((__nonnull__ (1))) ;
+extern char *realpath (__const char *__restrict __name,
+         char *__restrict __resolved) throw () ;
+typedef int (*__compar_fn_t) (__const void *, __const void *);
+typedef __compar_fn_t comparison_fn_t;
+typedef int (*__compar_d_fn_t) (__const void *, __const void *, void *);
+
+extern void *bsearch (__const void *__key, __const void *__base,
+        size_t __nmemb, size_t __size, __compar_fn_t __compar)
+     __attribute__ ((__nonnull__ (1, 2, 5))) ;
+extern void qsort (void *__base, size_t __nmemb, size_t __size,
+     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));
+extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
+       __compar_d_fn_t __compar, void *__arg)
+  __attribute__ ((__nonnull__ (1, 4)));
+extern int abs (int __x) throw () __attribute__ ((__const__)) ;
+extern long int labs (long int __x) throw () __attribute__ ((__const__)) ;
+
+__extension__ extern long long int llabs (long long int __x)
+     throw () __attribute__ ((__const__)) ;
+
+extern div_t div (int __numer, int __denom)
+     throw () __attribute__ ((__const__)) ;
+extern ldiv_t ldiv (long int __numer, long int __denom)
+     throw () __attribute__ ((__const__)) ;
+
+
+__extension__ extern lldiv_t lldiv (long long int __numer,
+        long long int __denom)
+     throw () __attribute__ ((__const__)) ;
+
+extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
+     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;
+extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
+     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;
+extern char *gcvt (double __value, int __ndigit, char *__buf)
+     throw () __attribute__ ((__nonnull__ (3))) ;
+extern char *qecvt (long double __value, int __ndigit,
+      int *__restrict __decpt, int *__restrict __sign)
+     throw () __attribute__ ((__nonnull__ (3, 4))) ;
+extern char *qfcvt (long double __value, int __ndigit,
+      int *__restrict __decpt, int *__restrict __sign)
+     throw () __attribute__ ((__nonnull__ (3, 4))) ;
+extern char *qgcvt (long double __value, int __ndigit, char *__buf)
+     throw () __attribute__ ((__nonnull__ (3))) ;
+extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
+     int *__restrict __sign, char *__restrict __buf,
+     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
+extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
+     int *__restrict __sign, char *__restrict __buf,
+     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
+extern int qecvt_r (long double __value, int __ndigit,
+      int *__restrict __decpt, int *__restrict __sign,
+      char *__restrict __buf, size_t __len)
+     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
+extern int qfcvt_r (long double __value, int __ndigit,
+      int *__restrict __decpt, int *__restrict __sign,
+      char *__restrict __buf, size_t __len)
+     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
+
+extern int mblen (__const char *__s, size_t __n) throw () ;
+extern int mbtowc (wchar_t *__restrict __pwc,
+     __const char *__restrict __s, size_t __n) throw () ;
+extern int wctomb (char *__s, wchar_t __wchar) throw () ;
+extern size_t mbstowcs (wchar_t *__restrict __pwcs,
+   __const char *__restrict __s, size_t __n) throw ();
+extern size_t wcstombs (char *__restrict __s,
+   __const wchar_t *__restrict __pwcs, size_t __n)
+     throw ();
+
+extern int rpmatch (__const char *__response) throw () __attribute__ ((__nonnull__ (1))) ;
+extern int getsubopt (char **__restrict __optionp,
+        char *__const *__restrict __tokens,
+        char **__restrict __valuep)
+     throw () __attribute__ ((__nonnull__ (1, 2, 3))) ;
+extern void setkey (__const char *__key) throw () __attribute__ ((__nonnull__ (1)));
+extern int posix_openpt (int __oflag) ;
+extern int grantpt (int __fd) throw ();
+extern int unlockpt (int __fd) throw ();
+extern char *ptsname (int __fd) throw () ;
+extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
+     throw () __attribute__ ((__nonnull__ (2)));
+extern int getpt (void);
+extern int getloadavg (double __loadavg[], int __nelem)
+     throw () __attribute__ ((__nonnull__ (1)));
+}
+extern "C" {
+typedef __intptr_t intptr_t;
+typedef __socklen_t socklen_t;
+extern int access (__const char *__name, int __type) throw () __attribute__ ((__nonnull__ (1)));
+extern int euidaccess (__const char *__name, int __type)
+     throw () __attribute__ ((__nonnull__ (1)));
+extern int eaccess (__const char *__name, int __type)
+     throw () __attribute__ ((__nonnull__ (1)));
+extern int faccessat (int __fd, __const char *__file, int __type, int __flag)
+     throw () __attribute__ ((__nonnull__ (2))) ;
+extern __off64_t lseek (int __fd, __off64_t __offset, int __whence) throw () __asm__ ("" "lseek64");
+extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
+     throw ();
+extern int close (int __fd);
+extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;
+extern ssize_t write (int __fd, __const void *__buf, size_t __n) ;
+extern ssize_t pread (int __fd, void *__buf, size_t __nbytes, __off64_t __offset) __asm__ ("" "pread64") ;
+extern ssize_t pwrite (int __fd, __const void *__buf, size_t __nbytes, __off64_t __offset) __asm__ ("" "pwrite64") ;
+extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
+   __off64_t __offset) ;
+extern ssize_t pwrite64 (int __fd, __const void *__buf, size_t __n,
+    __off64_t __offset) ;
+extern int pipe (int __pipedes[2]) throw () ;
+extern int pipe2 (int __pipedes[2], int __flags) throw () ;
+extern unsigned int alarm (unsigned int __seconds) throw ();
+extern unsigned int sleep (unsigned int __seconds);
+extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
+     throw ();
+extern int usleep (__useconds_t __useconds);
+extern int pause (void);
+extern int chown (__const char *__file, __uid_t __owner, __gid_t __group)
+     throw () __attribute__ ((__nonnull__ (1))) ;
+extern int fchown (int __fd, __uid_t __owner, __gid_t __group) throw () ;
+extern int lchown (__const char *__file, __uid_t __owner, __gid_t __group)
+     throw () __attribute__ ((__nonnull__ (1))) ;
+extern int fchownat (int __fd, __const char *__file, __uid_t __owner,
+       __gid_t __group, int __flag)
+     throw () __attribute__ ((__nonnull__ (2))) ;
+extern int chdir (__const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;
+extern int fchdir (int __fd) throw () ;
+extern char *getcwd (char *__buf, size_t __size) throw () ;
+extern char *get_current_dir_name (void) throw ();
+extern char *getwd (char *__buf)
+     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;
+extern int dup (int __fd) throw () ;
+extern int dup2 (int __fd, int __fd2) throw ();
+extern int dup3 (int __fd, int __fd2, int __flags) throw ();
+extern char **__environ;
+extern char **environ;
+extern int execve (__const char *__path, char *__const __argv[],
+     char *__const __envp[]) throw () __attribute__ ((__nonnull__ (1, 2)));
+extern int fexecve (int __fd, char *__const __argv[], char *__const __envp[])
+     throw () __attribute__ ((__nonnull__ (2)));
+extern int execv (__const char *__path, char *__const __argv[])
+     throw () __attribute__ ((__nonnull__ (1, 2)));
+extern int execle (__const char *__path, __const char *__arg, ...)
+     throw () __attribute__ ((__nonnull__ (1, 2)));
+extern int execl (__const char *__path, __const char *__arg, ...)
+     throw () __attribute__ ((__nonnull__ (1, 2)));
+extern int execvp (__const char *__file, char *__const __argv[])
+     throw () __attribute__ ((__nonnull__ (1, 2)));
+extern int execlp (__const char *__file, __const char *__arg, ...)
+     throw () __attribute__ ((__nonnull__ (1, 2)));
+extern int execvpe (__const char *__file, char *__const __argv[],
+      char *__const __envp[])
+     throw () __attribute__ ((__nonnull__ (1, 2)));
+extern int nice (int __inc) throw () ;
+extern void _exit (int __status) __attribute__ ((__noreturn__));
+enum
+  {
+    _PC_LINK_MAX,
+    _PC_MAX_CANON,
+    _PC_MAX_INPUT,
+    _PC_NAME_MAX,
+    _PC_PATH_MAX,
+    _PC_PIPE_BUF,
+    _PC_CHOWN_RESTRICTED,
+    _PC_NO_TRUNC,
+    _PC_VDISABLE,
+    _PC_SYNC_IO,
+    _PC_ASYNC_IO,
+    _PC_PRIO_IO,
+    _PC_SOCK_MAXBUF,
+    _PC_FILESIZEBITS,
+    _PC_REC_INCR_XFER_SIZE,
+    _PC_REC_MAX_XFER_SIZE,
+    _PC_REC_MIN_XFER_SIZE,
+    _PC_REC_XFER_ALIGN,
+    _PC_ALLOC_SIZE_MIN,
+    _PC_SYMLINK_MAX,
+    _PC_2_SYMLINKS
+  };
+enum
+  {
+    _SC_ARG_MAX,
+    _SC_CHILD_MAX,
+    _SC_CLK_TCK,
+    _SC_NGROUPS_MAX,
+    _SC_OPEN_MAX,
+    _SC_STREAM_MAX,
+    _SC_TZNAME_MAX,
+    _SC_JOB_CONTROL,
+    _SC_SAVED_IDS,
+    _SC_REALTIME_SIGNALS,
+    _SC_PRIORITY_SCHEDULING,
+    _SC_TIMERS,
+    _SC_ASYNCHRONOUS_IO,
+    _SC_PRIORITIZED_IO,
+    _SC_SYNCHRONIZED_IO,
+    _SC_FSYNC,
+    _SC_MAPPED_FILES,
+    _SC_MEMLOCK,
+    _SC_MEMLOCK_RANGE,
+    _SC_MEMORY_PROTECTION,
+    _SC_MESSAGE_PASSING,
+    _SC_SEMAPHORES,
+    _SC_SHARED_MEMORY_OBJECTS,
+    _SC_AIO_LISTIO_MAX,
+    _SC_AIO_MAX,
+    _SC_AIO_PRIO_DELTA_MAX,
+    _SC_DELAYTIMER_MAX,
+    _SC_MQ_OPEN_MAX,
+    _SC_MQ_PRIO_MAX,
+    _SC_VERSION,
+    _SC_PAGESIZE,
+    _SC_RTSIG_MAX,
+    _SC_SEM_NSEMS_MAX,
+    _SC_SEM_VALUE_MAX,
+    _SC_SIGQUEUE_MAX,
+    _SC_TIMER_MAX,
+    _SC_BC_BASE_MAX,
+    _SC_BC_DIM_MAX,
+    _SC_BC_SCALE_MAX,
+    _SC_BC_STRING_MAX,
+    _SC_COLL_WEIGHTS_MAX,
+    _SC_EQUIV_CLASS_MAX,
+    _SC_EXPR_NEST_MAX,
+    _SC_LINE_MAX,
+    _SC_RE_DUP_MAX,
+    _SC_CHARCLASS_NAME_MAX,
+    _SC_2_VERSION,
+    _SC_2_C_BIND,
+    _SC_2_C_DEV,
+    _SC_2_FORT_DEV,
+    _SC_2_FORT_RUN,
+    _SC_2_SW_DEV,
+    _SC_2_LOCALEDEF,
+    _SC_PII,
+    _SC_PII_XTI,
+    _SC_PII_SOCKET,
+    _SC_PII_INTERNET,
+    _SC_PII_OSI,
+    _SC_POLL,
+    _SC_SELECT,
+    _SC_UIO_MAXIOV,
+    _SC_IOV_MAX = _SC_UIO_MAXIOV,
+    _SC_PII_INTERNET_STREAM,
+    _SC_PII_INTERNET_DGRAM,
+    _SC_PII_OSI_COTS,
+    _SC_PII_OSI_CLTS,
+    _SC_PII_OSI_M,
+    _SC_T_IOV_MAX,
+    _SC_THREADS,
+    _SC_THREAD_SAFE_FUNCTIONS,
+    _SC_GETGR_R_SIZE_MAX,
+    _SC_GETPW_R_SIZE_MAX,
+    _SC_LOGIN_NAME_MAX,
+    _SC_TTY_NAME_MAX,
+    _SC_THREAD_DESTRUCTOR_ITERATIONS,
+    _SC_THREAD_KEYS_MAX,
+    _SC_THREAD_STACK_MIN,
+    _SC_THREAD_THREADS_MAX,
+    _SC_THREAD_ATTR_STACKADDR,
+    _SC_THREAD_ATTR_STACKSIZE,
+    _SC_THREAD_PRIORITY_SCHEDULING,
+    _SC_THREAD_PRIO_INHERIT,
+    _SC_THREAD_PRIO_PROTECT,
+    _SC_THREAD_PROCESS_SHARED,
+    _SC_NPROCESSORS_CONF,
+    _SC_NPROCESSORS_ONLN,
+    _SC_PHYS_PAGES,
+    _SC_AVPHYS_PAGES,
+    _SC_ATEXIT_MAX,
+    _SC_PASS_MAX,
+    _SC_XOPEN_VERSION,
+    _SC_XOPEN_XCU_VERSION,
+    _SC_XOPEN_UNIX,
+    _SC_XOPEN_CRYPT,
+    _SC_XOPEN_ENH_I18N,
+    _SC_XOPEN_SHM,
+    _SC_2_CHAR_TERM,
+    _SC_2_C_VERSION,
+    _SC_2_UPE,
+    _SC_XOPEN_XPG2,
+    _SC_XOPEN_XPG3,
+    _SC_XOPEN_XPG4,
+    _SC_CHAR_BIT,
+    _SC_CHAR_MAX,
+    _SC_CHAR_MIN,
+    _SC_INT_MAX,
+    _SC_INT_MIN,
+    _SC_LONG_BIT,
+    _SC_WORD_BIT,
+    _SC_MB_LEN_MAX,
+    _SC_NZERO,
+    _SC_SSIZE_MAX,
+    _SC_SCHAR_MAX,
+    _SC_SCHAR_MIN,
+    _SC_SHRT_MAX,
+    _SC_SHRT_MIN,
+    _SC_UCHAR_MAX,
+    _SC_UINT_MAX,
+    _SC_ULONG_MAX,
+    _SC_USHRT_MAX,
+    _SC_NL_ARGMAX,
+    _SC_NL_LANGMAX,
+    _SC_NL_MSGMAX,
+    _SC_NL_NMAX,
+    _SC_NL_SETMAX,
+    _SC_NL_TEXTMAX,
+    _SC_XBS5_ILP32_OFF32,
+    _SC_XBS5_ILP32_OFFBIG,
+    _SC_XBS5_LP64_OFF64,
+    _SC_XBS5_LPBIG_OFFBIG,
+    _SC_XOPEN_LEGACY,
+    _SC_XOPEN_REALTIME,
+    _SC_XOPEN_REALTIME_THREADS,
+    _SC_ADVISORY_INFO,
+    _SC_BARRIERS,
+    _SC_BASE,
+    _SC_C_LANG_SUPPORT,
+    _SC_C_LANG_SUPPORT_R,
+    _SC_CLOCK_SELECTION,
+    _SC_CPUTIME,
+    _SC_THREAD_CPUTIME,
+    _SC_DEVICE_IO,
+    _SC_DEVICE_SPECIFIC,
+    _SC_DEVICE_SPECIFIC_R,
+    _SC_FD_MGMT,
+    _SC_FIFO,
+    _SC_PIPE,
+    _SC_FILE_ATTRIBUTES,
+    _SC_FILE_LOCKING,
+    _SC_FILE_SYSTEM,
+    _SC_MONOTONIC_CLOCK,
+    _SC_MULTI_PROCESS,
+    _SC_SINGLE_PROCESS,
+    _SC_NETWORKING,
+    _SC_READER_WRITER_LOCKS,
+    _SC_SPIN_LOCKS,
+    _SC_REGEXP,
+    _SC_REGEX_VERSION,
+    _SC_SHELL,
+    _SC_SIGNALS,
+    _SC_SPAWN,
+    _SC_SPORADIC_SERVER,
+    _SC_THREAD_SPORADIC_SERVER,
+    _SC_SYSTEM_DATABASE,
+    _SC_SYSTEM_DATABASE_R,
+    _SC_TIMEOUTS,
+    _SC_TYPED_MEMORY_OBJECTS,
+    _SC_USER_GROUPS,
+    _SC_USER_GROUPS_R,
+    _SC_2_PBS,
+    _SC_2_PBS_ACCOUNTING,
+    _SC_2_PBS_LOCATE,
+    _SC_2_PBS_MESSAGE,
+    _SC_2_PBS_TRACK,
+    _SC_SYMLOOP_MAX,
+    _SC_STREAMS,
+    _SC_2_PBS_CHECKPOINT,
+    _SC_V6_ILP32_OFF32,
+    _SC_V6_ILP32_OFFBIG,
+    _SC_V6_LP64_OFF64,
+    _SC_V6_LPBIG_OFFBIG,
+    _SC_HOST_NAME_MAX,
+    _SC_TRACE,
+    _SC_TRACE_EVENT_FILTER,
+    _SC_TRACE_INHERIT,
+    _SC_TRACE_LOG,
+    _SC_LEVEL1_ICACHE_SIZE,
+    _SC_LEVEL1_ICACHE_ASSOC,
+    _SC_LEVEL1_ICACHE_LINESIZE,
+    _SC_LEVEL1_DCACHE_SIZE,
+    _SC_LEVEL1_DCACHE_ASSOC,
+    _SC_LEVEL1_DCACHE_LINESIZE,
+    _SC_LEVEL2_CACHE_SIZE,
+    _SC_LEVEL2_CACHE_ASSOC,
+    _SC_LEVEL2_CACHE_LINESIZE,
+    _SC_LEVEL3_CACHE_SIZE,
+    _SC_LEVEL3_CACHE_ASSOC,
+    _SC_LEVEL3_CACHE_LINESIZE,
+    _SC_LEVEL4_CACHE_SIZE,
+    _SC_LEVEL4_CACHE_ASSOC,
+    _SC_LEVEL4_CACHE_LINESIZE,
+    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,
+    _SC_RAW_SOCKETS,
+    _SC_V7_ILP32_OFF32,
+    _SC_V7_ILP32_OFFBIG,
+    _SC_V7_LP64_OFF64,
+    _SC_V7_LPBIG_OFFBIG,
+    _SC_SS_REPL_MAX,
+    _SC_TRACE_EVENT_NAME_MAX,
+    _SC_TRACE_NAME_MAX,
+    _SC_TRACE_SYS_MAX,
+    _SC_TRACE_USER_EVENT_MAX,
+    _SC_XOPEN_STREAMS,
+    _SC_THREAD_ROBUST_PRIO_INHERIT,
+    _SC_THREAD_ROBUST_PRIO_PROTECT
+  };
+enum
+  {
+    _CS_PATH,
+    _CS_V6_WIDTH_RESTRICTED_ENVS,
+    _CS_GNU_LIBC_VERSION,
+    _CS_GNU_LIBPTHREAD_VERSION,
+    _CS_V5_WIDTH_RESTRICTED_ENVS,
+    _CS_V7_WIDTH_RESTRICTED_ENVS,
+    _CS_LFS_CFLAGS = 1000,
+    _CS_LFS_LDFLAGS,
+    _CS_LFS_LIBS,
+    _CS_LFS_LINTFLAGS,
+    _CS_LFS64_CFLAGS,
+    _CS_LFS64_LDFLAGS,
+    _CS_LFS64_LIBS,
+    _CS_LFS64_LINTFLAGS,
+    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
+    _CS_XBS5_ILP32_OFF32_LDFLAGS,
+    _CS_XBS5_ILP32_OFF32_LIBS,
+    _CS_XBS5_ILP32_OFF32_LINTFLAGS,
+    _CS_XBS5_ILP32_OFFBIG_CFLAGS,
+    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,
+    _CS_XBS5_ILP32_OFFBIG_LIBS,
+    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,
+    _CS_XBS5_LP64_OFF64_CFLAGS,
+    _CS_XBS5_LP64_OFF64_LDFLAGS,
+    _CS_XBS5_LP64_OFF64_LIBS,
+    _CS_XBS5_LP64_OFF64_LINTFLAGS,
+    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,
+    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,
+    _CS_XBS5_LPBIG_OFFBIG_LIBS,
+    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,
+    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,
+    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,
+    _CS_POSIX_V6_ILP32_OFF32_LIBS,
+    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,
+    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,
+    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,
+    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,
+    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,
+    _CS_POSIX_V6_LP64_OFF64_CFLAGS,
+    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,
+    _CS_POSIX_V6_LP64_OFF64_LIBS,
+    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,
+    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,
+    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,
+    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,
+    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,
+    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,
+    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,
+    _CS_POSIX_V7_ILP32_OFF32_LIBS,
+    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,
+    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,
+    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,
+    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,
+    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,
+    _CS_POSIX_V7_LP64_OFF64_CFLAGS,
+    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,
+    _CS_POSIX_V7_LP64_OFF64_LIBS,
+    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,
+    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,
+    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,
+    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,
+    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,
+    _CS_V6_ENV,
+    _CS_V7_ENV
+  };
+extern long int pathconf (__const char *__path, int __name)
+     throw () __attribute__ ((__nonnull__ (1)));
+extern long int fpathconf (int __fd, int __name) throw ();
+extern long int sysconf (int __name) throw ();
+extern size_t confstr (int __name, char *__buf, size_t __len) throw ();
+extern __pid_t getpid (void) throw ();
+extern __pid_t getppid (void) throw ();
+extern __pid_t getpgrp (void) throw ();
+extern __pid_t __getpgid (__pid_t __pid) throw ();
+extern __pid_t getpgid (__pid_t __pid) throw ();
+extern int setpgid (__pid_t __pid, __pid_t __pgid) throw ();
+extern int setpgrp (void) throw ();
+extern __pid_t setsid (void) throw ();
+extern __pid_t getsid (__pid_t __pid) throw ();
+extern __uid_t getuid (void) throw ();
+extern __uid_t geteuid (void) throw ();
+extern __gid_t getgid (void) throw ();
+extern __gid_t getegid (void) throw ();
+extern int getgroups (int __size, __gid_t __list[]) throw () ;
+extern int group_member (__gid_t __gid) throw ();
+extern int setuid (__uid_t __uid) throw ();
+extern int setreuid (__uid_t __ruid, __uid_t __euid) throw ();
+extern int seteuid (__uid_t __uid) throw ();
+extern int setgid (__gid_t __gid) throw ();
+extern int setregid (__gid_t __rgid, __gid_t __egid) throw ();
+extern int setegid (__gid_t __gid) throw ();
+extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
+     throw ();
+extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
+     throw ();
+extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
+     throw ();
+extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
+     throw ();
+extern __pid_t fork (void) throw ();
+extern __pid_t vfork (void) throw ();
+extern char *ttyname (int __fd) throw ();
+extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
+     throw () __attribute__ ((__nonnull__ (2))) ;
+extern int isatty (int __fd) throw ();
+extern int ttyslot (void) throw ();
+extern int link (__const char *__from, __const char *__to)
+     throw () __attribute__ ((__nonnull__ (1, 2))) ;
+extern int linkat (int __fromfd, __const char *__from, int __tofd,
+     __const char *__to, int __flags)
+     throw () __attribute__ ((__nonnull__ (2, 4))) ;
+extern int symlink (__const char *__from, __const char *__to)
+     throw () __attribute__ ((__nonnull__ (1, 2))) ;
+extern ssize_t readlink (__const char *__restrict __path,
+    char *__restrict __buf, size_t __len)
+     throw () __attribute__ ((__nonnull__ (1, 2))) ;
+extern int symlinkat (__const char *__from, int __tofd,
+        __const char *__to) throw () __attribute__ ((__nonnull__ (1, 3))) ;
+extern ssize_t readlinkat (int __fd, __const char *__restrict __path,
+      char *__restrict __buf, size_t __len)
+     throw () __attribute__ ((__nonnull__ (2, 3))) ;
+extern int unlink (__const char *__name) throw () __attribute__ ((__nonnull__ (1)));
+extern int unlinkat (int __fd, __const char *__name, int __flag)
+     throw () __attribute__ ((__nonnull__ (2)));
+extern int rmdir (__const char *__path) throw () __attribute__ ((__nonnull__ (1)));
+extern __pid_t tcgetpgrp (int __fd) throw ();
+extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) throw ();
+extern char *getlogin (void);
+extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));
+extern int setlogin (__const char *__name) throw () __attribute__ ((__nonnull__ (1)));
+extern "C" {
+extern char *optarg;
+extern int optind;
+extern int opterr;
+extern int optopt;
+struct option
+{
+  const char *name;
+  int has_arg;
+  int *flag;
+  int val;
+};
+extern int getopt (int argc, char *const *argv, const char *shortopts);
+extern int getopt_long (int argc, char *const *argv, const char *shortopts,
+          const struct option *longopts, int *longind);
+extern int getopt_long_only (int argc, char *const *argv,
+        const char *shortopts,
+               const struct option *longopts, int *longind);
+extern int _getopt_internal (int argc, char *const *argv,
+        const char *shortopts,
+               const struct option *longopts, int *longind,
+        int long_only);
+}
+extern int gethostname (char *__name, size_t __len) throw () __attribute__ ((__nonnull__ (1)));
+extern int sethostname (__const char *__name, size_t __len)
+     throw () __attribute__ ((__nonnull__ (1))) ;
+extern int sethostid (long int __id) throw () ;
+extern int getdomainname (char *__name, size_t __len)
+     throw () __attribute__ ((__nonnull__ (1))) ;
+extern int setdomainname (__const char *__name, size_t __len)
+     throw () __attribute__ ((__nonnull__ (1))) ;
+extern int vhangup (void) throw ();
+extern int revoke (__const char *__file) throw () __attribute__ ((__nonnull__ (1))) ;
+extern int profil (unsigned short int *__sample_buffer, size_t __size,
+     size_t __offset, unsigned int __scale)
+     throw () __attribute__ ((__nonnull__ (1)));
+extern int acct (__const char *__name) throw ();
+extern char *getusershell (void) throw ();
+extern void endusershell (void) throw ();
+extern void setusershell (void) throw ();
+extern int daemon (int __nochdir, int __noclose) throw () ;
+extern int chroot (__const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;
+extern char *getpass (__const char *__prompt) __attribute__ ((__nonnull__ (1)));
+extern int fsync (int __fd);
+extern int syncfs (int __fd) throw ();
+extern long int gethostid (void);
+extern void sync (void) throw ();
+extern int getpagesize (void) throw () __attribute__ ((__const__));
+extern int getdtablesize (void) throw ();
+extern int truncate (__const char *__file, __off64_t __length) throw () __asm__ ("" "truncate64") __attribute__ ((__nonnull__ (1))) ;
+extern int truncate64 (__const char *__file, __off64_t __length)
+     throw () __attribute__ ((__nonnull__ (1))) ;
+extern int ftruncate (int __fd, __off64_t __length) throw () __asm__ ("" "ftruncate64") ;
+extern int ftruncate64 (int __fd, __off64_t __length) throw () ;
+extern int brk (void *__addr) throw () ;
+extern void *sbrk (intptr_t __delta) throw ();
+extern long int syscall (long int __sysno, ...) throw ();
+extern int lockf (int __fd, int __cmd, __off64_t __len) __asm__ ("" "lockf64") ;
+extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;
+extern int fdatasync (int __fildes);
+extern char *crypt (__const char *__key, __const char *__salt)
+     throw () __attribute__ ((__nonnull__ (1, 2)));
+extern void encrypt (char *__block, int __edflag) throw () __attribute__ ((__nonnull__ (1)));
+extern void swab (__const void *__restrict __from, void *__restrict __to,
+    ssize_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));
+extern char *ctermid (char *__s) throw ();
+}
+typedef long long __gcc_host_wide_int__;
+static inline int
+clz_hwi (unsigned long long x)
+{
+  if (x == 0)
+    return (8 * 8);
+  return __builtin_clzll (x);
+}
+static inline int
+ctz_hwi (unsigned long long x)
+{
+  if (x == 0)
+    return (8 * 8);
+  return __builtin_ctzll (x);
+}
+static inline int
+ffs_hwi (unsigned long long x)
+{
+  return __builtin_ffsll (x);
+}
+static inline int
+popcount_hwi (unsigned long long x)
+{
+  return __builtin_popcountll (x);
+}
+static inline int
+floor_log2 (unsigned long long x)
+{
+  return (8 * 8) - 1 - clz_hwi (x);
+}
+static inline int
+ceil_log2 (unsigned long long x)
+{
+  return floor_log2 (x - 1) + 1;
+}
+static inline int
+exact_log2 (unsigned long long x)
+{
+  return x == (x & -x) && x ? ctz_hwi (x) : -1;
+}
+extern long long abs_hwi (long long);
+extern unsigned long long absu_hwi (long long);
+extern long long gcd (long long, long long);
+extern long long pos_mul_hwi (long long, long long);
+extern long long mul_hwi (long long, long long);
+extern long long least_common_multiple (long long, long long);
+extern "C" {
+struct timezone
+  {
+    int tz_minuteswest;
+    int tz_dsttime;
+  };
+typedef struct timezone *__restrict __timezone_ptr_t;
+extern int gettimeofday (struct timeval *__restrict __tv,
+    __timezone_ptr_t __tz) throw () __attribute__ ((__nonnull__ (1)));
+extern int settimeofday (__const struct timeval *__tv,
+    __const struct timezone *__tz)
+     throw () __attribute__ ((__nonnull__ (1)));
+extern int adjtime (__const struct timeval *__delta,
+      struct timeval *__olddelta) throw ();
+enum __itimer_which
+  {
+    ITIMER_REAL = 0,
+    ITIMER_VIRTUAL = 1,
+    ITIMER_PROF = 2
+  };
+struct itimerval
+  {
+    struct timeval it_interval;
+    struct timeval it_value;
+  };
+typedef int __itimer_which_t;
+extern int getitimer (__itimer_which_t __which,
+        struct itimerval *__value) throw ();
+extern int setitimer (__itimer_which_t __which,
+        __const struct itimerval *__restrict __new,
+        struct itimerval *__restrict __old) throw ();
+extern int utimes (__const char *__file, __const struct timeval __tvp[2])
+     throw () __attribute__ ((__nonnull__ (1)));
+extern int lutimes (__const char *__file, __const struct timeval __tvp[2])
+     throw () __attribute__ ((__nonnull__ (1)));
+extern int futimes (int __fd, __const struct timeval __tvp[2]) throw ();
+extern int futimesat (int __fd, __const char *__file,
+        __const struct timeval __tvp[2]) throw ();
+}
+extern "C" {
+struct timex
+{
+  unsigned int modes;
+  long int offset;
+  long int freq;
+  long int maxerror;
+  long int esterror;
+  int status;
+  long int constant;
+  long int precision;
+  long int tolerance;
+  struct timeval time;
+  long int tick;
+  long int ppsfreq;
+  long int jitter;
+  int shift;
+  long int stabil;
+  long int jitcnt;
+  long int calcnt;
+  long int errcnt;
+  long int stbcnt;
+  int tai;
+  int :32; int :32; int :32; int :32;
+  int :32; int :32; int :32; int :32;
+  int :32; int :32; int :32;
+};
+extern "C" {
+extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) throw ();
+}
+
+struct tm
+{
+  int tm_sec;
+  int tm_min;
+  int tm_hour;
+  int tm_mday;
+  int tm_mon;
+  int tm_year;
+  int tm_wday;
+  int tm_yday;
+  int tm_isdst;
+  long int tm_gmtoff;
+  __const char *tm_zone;
+};
+
+
+struct itimerspec
+  {
+    struct timespec it_interval;
+    struct timespec it_value;
+  };
+struct sigevent;
+
+extern clock_t clock (void) throw ();
+extern time_t time (time_t *__timer) throw ();
+extern double difftime (time_t __time1, time_t __time0)
+     throw () __attribute__ ((__const__));
+extern time_t mktime (struct tm *__tp) throw ();
+extern size_t strftime (char *__restrict __s, size_t __maxsize,
+   __const char *__restrict __format,
+   __const struct tm *__restrict __tp) throw ();
+
+extern char *strptime (__const char *__restrict __s,
+         __const char *__restrict __fmt, struct tm *__tp)
+     throw ();
+extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
+     __const char *__restrict __format,
+     __const struct tm *__restrict __tp,
+     __locale_t __loc) throw ();
+extern char *strptime_l (__const char *__restrict __s,
+    __const char *__restrict __fmt, struct tm *__tp,
+    __locale_t __loc) throw ();
+
+extern struct tm *gmtime (__const time_t *__timer) throw ();
+extern struct tm *localtime (__const time_t *__timer) throw ();
+
+extern struct tm *gmtime_r (__const time_t *__restrict __timer,
+       struct tm *__restrict __tp) throw ();
+extern struct tm *localtime_r (__const time_t *__restrict __timer,
+          struct tm *__restrict __tp) throw ();
+
+extern char *asctime (__const struct tm *__tp) throw ();
+extern char *ctime (__const time_t *__timer) throw ();
+
+extern char *asctime_r (__const struct tm *__restrict __tp,
+   char *__restrict __buf) throw ();
+extern char *ctime_r (__const time_t *__restrict __timer,
+        char *__restrict __buf) throw ();
+extern char *__tzname[2];
+extern int __daylight;
+extern long int __timezone;
+extern char *tzname[2];
+extern void tzset (void) throw ();
+extern int daylight;
+extern long int timezone;
+extern int stime (__const time_t *__when) throw ();
+extern time_t timegm (struct tm *__tp) throw ();
+extern time_t timelocal (struct tm *__tp) throw ();
+extern int dysize (int __year) throw () __attribute__ ((__const__));
+extern int nanosleep (__const struct timespec *__requested_time,
+        struct timespec *__remaining);
+extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();
+extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();
+extern int clock_settime (clockid_t __clock_id, __const struct timespec *__tp)
+     throw ();
+extern int clock_nanosleep (clockid_t __clock_id, int __flags,
+       __const struct timespec *__req,
+       struct timespec *__rem);
+extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();
+extern int timer_create (clockid_t __clock_id,
+    struct sigevent *__restrict __evp,
+    timer_t *__restrict __timerid) throw ();
+extern int timer_delete (timer_t __timerid) throw ();
+extern int timer_settime (timer_t __timerid, int __flags,
+     __const struct itimerspec *__restrict __value,
+     struct itimerspec *__restrict __ovalue) throw ();
+extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
+     throw ();
+extern int timer_getoverrun (timer_t __timerid) throw ();
+extern int getdate_err;
+extern struct tm *getdate (__const char *__string);
+extern int getdate_r (__const char *__restrict __string,
+        struct tm *__restrict __resbufp);
+}
+extern "C" {
+struct iovec
+  {
+    void *iov_base;
+    size_t iov_len;
+  };
+struct flock
+  {
+    short int l_type;
+    short int l_whence;
+    __off64_t l_start;
+    __off64_t l_len;
+    __pid_t l_pid;
+  };
+struct flock64
+  {
+    short int l_type;
+    short int l_whence;
+    __off64_t l_start;
+    __off64_t l_len;
+    __pid_t l_pid;
+  };
+enum __pid_type
+  {
+    F_OWNER_TID = 0,
+    F_OWNER_PID,
+    F_OWNER_PGRP,
+    F_OWNER_GID = F_OWNER_PGRP
+  };
+struct f_owner_ex
+  {
+    enum __pid_type type;
+    __pid_t pid;
+  };
+struct file_handle
+{
+  unsigned int handle_bytes;
+  int handle_type;
+  unsigned char f_handle[0];
+};
+extern "C" {
+extern ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
+    throw ();
+extern int sync_file_range (int __fd, __off64_t __offset, __off64_t __count,
+       unsigned int __flags);
+extern ssize_t vmsplice (int __fdout, const struct iovec *__iov,
+    size_t __count, unsigned int __flags);
+extern ssize_t splice (int __fdin, __off64_t *__offin, int __fdout,
+         __off64_t *__offout, size_t __len,
+         unsigned int __flags);
+extern ssize_t tee (int __fdin, int __fdout, size_t __len,
+      unsigned int __flags);
+extern int fallocate (int __fd, int __mode, __off64_t __offset, __off64_t __len) __asm__ ("" "fallocate64");
+extern int fallocate64 (int __fd, int __mode, __off64_t __offset,
+   __off64_t __len);
+extern int name_to_handle_at (int __dfd, const char *__name,
+         struct file_handle *__handle, int *__mnt_id,
+         int __flags) throw ();
+extern int open_by_handle_at (int __mountdirfd, struct file_handle *__handle,
+         int __flags);
+}
+struct stat
+  {
+    __dev_t st_dev;
+    unsigned short int __pad1;
+    __ino_t __st_ino;
+    __mode_t st_mode;
+    __nlink_t st_nlink;
+    __uid_t st_uid;
+    __gid_t st_gid;
+    __dev_t st_rdev;
+    unsigned short int __pad2;
+    __off64_t st_size;
+    __blksize_t st_blksize;
+    __blkcnt64_t st_blocks;
+    struct timespec st_atim;
+    struct timespec st_mtim;
+    struct timespec st_ctim;
+    __ino64_t st_ino;
+  };
+struct stat64
+  {
+    __dev_t st_dev;
+    unsigned int __pad1;
+    __ino_t __st_ino;
+    __mode_t st_mode;
+    __nlink_t st_nlink;
+    __uid_t st_uid;
+    __gid_t st_gid;
+    __dev_t st_rdev;
+    unsigned int __pad2;
+    __off64_t st_size;
+    __blksize_t st_blksize;
+    __blkcnt64_t st_blocks;
+    struct timespec st_atim;
+    struct timespec st_mtim;
+    struct timespec st_ctim;
+    __ino64_t st_ino;
+  };
+extern int fcntl (int __fd, int __cmd, ...);
+extern int open (__const char *__file, int __oflag, ...) __asm__ ("" "open64")
+     __attribute__ ((__nonnull__ (1)));
+extern int open64 (__const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
+extern int openat (int __fd, __const char *__file, int __oflag, ...) __asm__ ("" "openat64") __attribute__ ((__nonnull__ (2)));
+extern int openat64 (int __fd, __const char *__file, int __oflag, ...)
+     __attribute__ ((__nonnull__ (2)));
+extern int creat (__const char *__file, __mode_t __mode) __asm__ ("" "creat64") __attribute__ ((__nonnull__ (1)));
+extern int creat64 (__const char *__file, __mode_t __mode) __attribute__ ((__nonnull__ (1)));
+extern int posix_fadvise (int __fd, __off64_t __offset, __off64_t __len, int __advise) throw () __asm__ ("" "posix_fadvise64");
+extern int posix_fadvise64 (int __fd, __off64_t __offset, __off64_t __len,
+       int __advise) throw ();
+extern int posix_fallocate (int __fd, __off64_t __offset, __off64_t __len) __asm__ ("" "posix_fallocate64");
+extern int posix_fallocate64 (int __fd, __off64_t __offset, __off64_t __len);
+}
+extern "C" {
+extern "C" {
+extern int __sigismember (__const __sigset_t *, int);
+extern int __sigaddset (__sigset_t *, int);
+extern int __sigdelset (__sigset_t *, int);
+extern __inline __attribute__ ((__gnu_inline__)) int __sigismember (__const __sigset_t *__set, int __sig) { unsigned long int __mask = (((unsigned long int) 1) << (((__sig) - 1) % (8 * sizeof (unsigned long int)))); unsigned long int __word = (((__sig) - 1) / (8 * sizeof (unsigned long int))); return (__set->__val[__word] & __mask) ? 1 : 0; }
+extern __inline __attribute__ ((__gnu_inline__)) int __sigaddset ( __sigset_t *__set, int __sig) { unsigned long int __mask = (((unsigned long int) 1) << (((__sig) - 1) % (8 * sizeof (unsigned long int)))); unsigned long int __word = (((__sig) - 1) / (8 * sizeof (unsigned long int))); return ((__set->__val[__word] |= __mask), 0); }
+extern __inline __attribute__ ((__gnu_inline__)) int __sigdelset ( __sigset_t *__set, int __sig) { unsigned long int __mask = (((unsigned long int) 1) << (((__sig) - 1) % (8 * sizeof (unsigned long int)))); unsigned long int __word = (((__sig) - 1) / (8 * sizeof (unsigned long int))); return ((__set->__val[__word] &= ~__mask), 0); }
+
+typedef __sig_atomic_t sig_atomic_t;
+
+typedef union sigval
+  {
+    int sival_int;
+    void *sival_ptr;
+  } sigval_t;
+typedef struct siginfo
+  {
+    int si_signo;
+    int si_errno;
+    int si_code;
+    union
+      {
+ int _pad[((128 / sizeof (int)) - 3)];
+ struct
+   {
+     __pid_t si_pid;
+     __uid_t si_uid;
+   } _kill;
+ struct
+   {
+     int si_tid;
+     int si_overrun;
+     sigval_t si_sigval;
+   } _timer;
+ struct
+   {
+     __pid_t si_pid;
+     __uid_t si_uid;
+     sigval_t si_sigval;
+   } _rt;
+ struct
+   {
+     __pid_t si_pid;
+     __uid_t si_uid;
+     int si_status;
+     __clock_t si_utime;
+     __clock_t si_stime;
+   } _sigchld;
+ struct
+   {
+     void *si_addr;
+   } _sigfault;
+ struct
+   {
+     long int si_band;
+     int si_fd;
+   } _sigpoll;
+      } _sifields;
+  } siginfo_t;
+enum
+{
+  SI_ASYNCNL = -60,
+  SI_TKILL = -6,
+  SI_SIGIO,
+  SI_ASYNCIO,
+  SI_MESGQ,
+  SI_TIMER,
+  SI_QUEUE,
+  SI_USER,
+  SI_KERNEL = 0x80
+};
+enum
+{
+  ILL_ILLOPC = 1,
+  ILL_ILLOPN,
+  ILL_ILLADR,
+  ILL_ILLTRP,
+  ILL_PRVOPC,
+  ILL_PRVREG,
+  ILL_COPROC,
+  ILL_BADSTK
+};
+enum
+{
+  FPE_INTDIV = 1,
+  FPE_INTOVF,
+  FPE_FLTDIV,
+  FPE_FLTOVF,
+  FPE_FLTUND,
+  FPE_FLTRES,
+  FPE_FLTINV,
+  FPE_FLTSUB
+};
+enum
+{
+  SEGV_MAPERR = 1,
+  SEGV_ACCERR
+};
+enum
+{
+  BUS_ADRALN = 1,
+  BUS_ADRERR,
+  BUS_OBJERR
+};
+enum
+{
+  TRAP_BRKPT = 1,
+  TRAP_TRACE
+};
+enum
+{
+  CLD_EXITED = 1,
+  CLD_KILLED,
+  CLD_DUMPED,
+  CLD_TRAPPED,
+  CLD_STOPPED,
+  CLD_CONTINUED
+};
+enum
+{
+  POLL_IN = 1,
+  POLL_OUT,
+  POLL_MSG,
+  POLL_ERR,
+  POLL_PRI,
+  POLL_HUP
+};
+typedef struct sigevent
+  {
+    sigval_t sigev_value;
+    int sigev_signo;
+    int sigev_notify;
+    union
+      {
+ int _pad[((64 / sizeof (int)) - 3)];
+ __pid_t _tid;
+ struct
+   {
+     void (*_function) (sigval_t);
+     void *_attribute;
+   } _sigev_thread;
+      } _sigev_un;
+  } sigevent_t;
+enum
+{
+  SIGEV_SIGNAL = 0,
+  SIGEV_NONE,
+  SIGEV_THREAD,
+  SIGEV_THREAD_ID = 4
+};
+typedef void (*__sighandler_t) (int);
+extern __sighandler_t __sysv_signal (int __sig, __sighandler_t __handler)
+     throw ();
+extern __sighandler_t sysv_signal (int __sig, __sighandler_t __handler)
+     throw ();
+
+extern __sighandler_t signal (int __sig, __sighandler_t __handler)
+     throw ();
+
+extern __sighandler_t bsd_signal (int __sig, __sighandler_t __handler)
+     throw ();
+extern int kill (__pid_t __pid, int __sig) throw ();
+extern int killpg (__pid_t __pgrp, int __sig) throw ();
+
+extern int raise (int __sig) throw ();
+
+extern __sighandler_t ssignal (int __sig, __sighandler_t __handler)
+     throw ();
+extern int gsignal (int __sig) throw ();
+extern void psignal (int __sig, __const char *__s);
+extern void psiginfo (__const siginfo_t *__pinfo, __const char *__s);
+extern int __sigpause (int __sig_or_mask, int __is_sig);
+extern int sigpause (int __sig) __asm__ ("__xpg_sigpause");
+extern int sigblock (int __mask) throw () __attribute__ ((__deprecated__));
+extern int sigsetmask (int __mask) throw () __attribute__ ((__deprecated__));
+extern int siggetmask (void) throw () __attribute__ ((__deprecated__));
+typedef __sighandler_t sighandler_t;
+typedef __sighandler_t sig_t;
+extern int sigemptyset (sigset_t *__set) throw () __attribute__ ((__nonnull__ (1)));
+extern int sigfillset (sigset_t *__set) throw () __attribute__ ((__nonnull__ (1)));
+extern int sigaddset (sigset_t *__set, int __signo) throw () __attribute__ ((__nonnull__ (1)));
+extern int sigdelset (sigset_t *__set, int __signo) throw () __attribute__ ((__nonnull__ (1)));
+extern int sigismember (__const sigset_t *__set, int __signo)
+     throw () __attribute__ ((__nonnull__ (1)));
+extern int sigisemptyset (__const sigset_t *__set) throw () __attribute__ ((__nonnull__ (1)));
+extern int sigandset (sigset_t *__set, __const sigset_t *__left,
+        __const sigset_t *__right) throw () __attribute__ ((__nonnull__ (1, 2, 3)));
+extern int sigorset (sigset_t *__set, __const sigset_t *__left,
+       __const sigset_t *__right) throw () __attribute__ ((__nonnull__ (1, 2, 3)));
+struct sigaction
+  {
+    union
+      {
+ __sighandler_t sa_handler;
+ void (*sa_sigaction) (int, siginfo_t *, void *);
+      }
+    __sigaction_handler;
+    __sigset_t sa_mask;
+    int sa_flags;
+    void (*sa_restorer) (void);
+  };
+extern int sigprocmask (int __how, __const sigset_t *__restrict __set,
+   sigset_t *__restrict __oset) throw ();
+extern int sigsuspend (__const sigset_t *__set) __attribute__ ((__nonnull__ (1)));
+extern int sigaction (int __sig, __const struct sigaction *__restrict __act,
+        struct sigaction *__restrict __oact) throw ();
+extern int sigpending (sigset_t *__set) throw () __attribute__ ((__nonnull__ (1)));
+extern int sigwait (__const sigset_t *__restrict __set, int *__restrict __sig)
+     __attribute__ ((__nonnull__ (1, 2)));
+extern int sigwaitinfo (__const sigset_t *__restrict __set,
+   siginfo_t *__restrict __info) __attribute__ ((__nonnull__ (1)));
+extern int sigtimedwait (__const sigset_t *__restrict __set,
+    siginfo_t *__restrict __info,
+    __const struct timespec *__restrict __timeout)
+     __attribute__ ((__nonnull__ (1)));
+extern int sigqueue (__pid_t __pid, int __sig, __const union sigval __val)
+     throw ();
+extern __const char *__const _sys_siglist[65];
+extern __const char *__const sys_siglist[65];
+struct sigvec
+  {
+    __sighandler_t sv_handler;
+    int sv_mask;
+    int sv_flags;
+  };
+extern int sigvec (int __sig, __const struct sigvec *__vec,
+     struct sigvec *__ovec) throw ();
+struct sigcontext {
+ unsigned long oldmask;
+ unsigned long sc_regs[16];
+ unsigned long sc_pc;
+ unsigned long sc_pr;
+ unsigned long sc_sr;
+ unsigned long sc_gbr;
+ unsigned long sc_mach;
+ unsigned long sc_macl;
+ unsigned long sc_fpregs[16];
+ unsigned long sc_xfpregs[16];
+ unsigned int sc_fpscr;
+ unsigned int sc_fpul;
+ unsigned int sc_ownedfp;
+};
+extern int sigreturn (struct sigcontext *__scp) throw ();
+extern int siginterrupt (int __sig, int __interrupt) throw ();
+struct sigstack
+  {
+    void *ss_sp;
+    int ss_onstack;
+  };
+enum
+{
+  SS_ONSTACK = 1,
+  SS_DISABLE
+};
+typedef struct sigaltstack
+  {
+    void *ss_sp;
+    int ss_flags;
+    size_t ss_size;
+  } stack_t;
+typedef int greg_t;
+typedef greg_t gregset_t[16];
+enum
+{
+  R0 = 0,
+  R1 = 1,
+  R2 = 2,
+  R3 = 3,
+  R4 = 4,
+  R5 = 5,
+  R6 = 6,
+  R7 = 7,
+  R8 = 8,
+  R9 = 9,
+  R10 = 10,
+  R11 = 11,
+  R12 = 12,
+  R13 = 13,
+  R14 = 14,
+  R15 = 15,
+};
+typedef int freg_t;
+typedef freg_t fpregset_t[16];
+typedef struct
+  {
+    unsigned int oldmask;
+    gregset_t gregs;
+    unsigned int pc;
+    unsigned int pr;
+    unsigned int sr;
+    unsigned int gbr;
+    unsigned int mach;
+    unsigned int macl;
+    fpregset_t fpregs;
+    fpregset_t xfpregs;
+    unsigned int fpscr;
+    unsigned int fpul;
+    unsigned int ownedfp;
+  } mcontext_t;
+typedef struct ucontext
+  {
+    unsigned long int uc_flags;
+    struct ucontext *uc_link;
+    stack_t uc_stack;
+    mcontext_t uc_mcontext;
+    __sigset_t uc_sigmask;
+  } ucontext_t;
+extern int sigstack (struct sigstack *__ss, struct sigstack *__oss)
+     throw () __attribute__ ((__deprecated__));
+extern int sigaltstack (__const struct sigaltstack *__restrict __ss,
+   struct sigaltstack *__restrict __oss) throw ();
+extern int sighold (int __sig) throw ();
+extern int sigrelse (int __sig) throw ();
+extern int sigignore (int __sig) throw ();
+extern __sighandler_t sigset (int __sig, __sighandler_t __disp) throw ();
+extern int pthread_sigmask (int __how,
+       __const __sigset_t *__restrict __newmask,
+       __sigset_t *__restrict __oldmask)throw ();
+extern int pthread_kill (pthread_t __threadid, int __signo) throw ();
+extern int pthread_sigqueue (pthread_t __threadid, int __signo,
+        const union sigval __value) throw ();
+extern int __libc_current_sigrtmin (void) throw ();
+extern int __libc_current_sigrtmax (void) throw ();
+}
+enum __rlimit_resource
+{
+  RLIMIT_CPU = 0,
+  RLIMIT_FSIZE = 1,
+  RLIMIT_DATA = 2,
+  RLIMIT_STACK = 3,
+  RLIMIT_CORE = 4,
+  __RLIMIT_RSS = 5,
+  RLIMIT_NOFILE = 7,
+  __RLIMIT_OFILE = RLIMIT_NOFILE,
+  RLIMIT_AS = 9,
+  __RLIMIT_NPROC = 6,
+  __RLIMIT_MEMLOCK = 8,
+  __RLIMIT_LOCKS = 10,
+  __RLIMIT_SIGPENDING = 11,
+  __RLIMIT_MSGQUEUE = 12,
+  __RLIMIT_NICE = 13,
+  __RLIMIT_RTPRIO = 14,
+  __RLIMIT_RTTIME = 15,
+  __RLIMIT_NLIMITS = 16,
+  __RLIM_NLIMITS = __RLIMIT_NLIMITS
+};
+typedef __rlim64_t rlim_t;
+typedef __rlim64_t rlim64_t;
+struct rlimit
+  {
+    rlim_t rlim_cur;
+    rlim_t rlim_max;
+  };
+struct rlimit64
+  {
+    rlim64_t rlim_cur;
+    rlim64_t rlim_max;
+ };
+enum __rusage_who
+{
+  RUSAGE_SELF = 0,
+  RUSAGE_CHILDREN = -1
+  ,
+  RUSAGE_THREAD = 1
+};
+struct rusage
+  {
+    struct timeval ru_utime;
+    struct timeval ru_stime;
+    long int ru_maxrss;
+    long int ru_ixrss;
+    long int ru_idrss;
+    long int ru_isrss;
+    long int ru_minflt;
+    long int ru_majflt;
+    long int ru_nswap;
+    long int ru_inblock;
+    long int ru_oublock;
+    long int ru_msgsnd;
+    long int ru_msgrcv;
+    long int ru_nsignals;
+    long int ru_nvcsw;
+    long int ru_nivcsw;
+  };
+enum __priority_which
+{
+  PRIO_PROCESS = 0,
+  PRIO_PGRP = 1,
+  PRIO_USER = 2
+};
+extern "C" {
+extern int prlimit (__pid_t __pid, enum __rlimit_resource __resource, __const struct rlimit *__new_limit, struct rlimit *__old_limit) throw () __asm__ ("" "prlimit64");
+extern int prlimit64 (__pid_t __pid, enum __rlimit_resource __resource,
+        __const struct rlimit64 *__new_limit,
+        struct rlimit64 *__old_limit) throw ();
+}
+extern "C" {
+typedef int __rlimit_resource_t;
+typedef int __rusage_who_t;
+typedef int __priority_which_t;
+extern int getrlimit (__rlimit_resource_t __resource, struct rlimit *__rlimits) throw () __asm__ ("" "getrlimit64");
+extern int getrlimit64 (__rlimit_resource_t __resource,
+   struct rlimit64 *__rlimits) throw ();
+extern int setrlimit (__rlimit_resource_t __resource, __const struct rlimit *__rlimits) throw () __asm__ ("" "setrlimit64");
+extern int setrlimit64 (__rlimit_resource_t __resource,
+   __const struct rlimit64 *__rlimits) throw ();
+extern int getrusage (__rusage_who_t __who, struct rusage *__usage) throw ();
+extern int getpriority (__priority_which_t __which, id_t __who) throw ();
+extern int setpriority (__priority_which_t __which, id_t __who, int __prio)
+     throw ();
+}
+typedef enum
+{
+  P_ALL,
+  P_PID,
+  P_PGID
+} idtype_t;
+extern __pid_t wait (void * __stat_loc);
+extern __pid_t waitpid (__pid_t __pid, int *__stat_loc, int __options);
+extern int waitid (idtype_t __idtype, __id_t __id, siginfo_t *__infop,
+     int __options);
+struct rusage;
+extern __pid_t wait3 (void * __stat_loc, int __options,
+        struct rusage * __usage) throw ();
+extern __pid_t wait4 (__pid_t __pid, void * __stat_loc, int __options,
+        struct rusage *__usage) throw ();
+}
+extern "C" {
+extern void * mmap (void *__addr, size_t __len, int __prot, int __flags, int __fd, __off64_t __offset) throw () __asm__ ("" "mmap64");
+extern void *mmap64 (void *__addr, size_t __len, int __prot,
+       int __flags, int __fd, __off64_t __offset) throw ();
+extern int munmap (void *__addr, size_t __len) throw ();
+extern int mprotect (void *__addr, size_t __len, int __prot) throw ();
+extern int msync (void *__addr, size_t __len, int __flags);
+extern int madvise (void *__addr, size_t __len, int __advice) throw ();
+extern int posix_madvise (void *__addr, size_t __len, int __advice) throw ();
+extern int mlock (__const void *__addr, size_t __len) throw ();
+extern int munlock (__const void *__addr, size_t __len) throw ();
+extern int mlockall (int __flags) throw ();
+extern int munlockall (void) throw ();
+extern int mincore (void *__start, size_t __len, unsigned char *__vec)
+     throw ();
+extern void *mremap (void *__addr, size_t __old_len, size_t __new_len,
+       int __flags, ...) throw ();
+extern int remap_file_pages (void *__start, size_t __size, int __prot,
+        size_t __pgoff, int __flags) throw ();
+extern int shm_open (__const char *__name, int __oflag, mode_t __mode);
+extern int shm_unlink (__const char *__name);
+}
+extern "C" {
+struct tms
+  {
+    clock_t tms_utime;
+    clock_t tms_stime;
+    clock_t tms_cutime;
+    clock_t tms_cstime;
+  };
+extern clock_t times (struct tms *__buffer) throw ();
+}
+extern "C" {
+extern int getopt (int, char * const *, const char *);
+}
+extern "C" {
+extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) ;
+extern void *calloc (size_t __nmemb, size_t __size)
+     throw () __attribute__ ((__malloc__)) ;
+extern void *realloc (void *__ptr, size_t __size)
+     throw () __attribute__ ((__warn_unused_result__));
+extern void free (void *__ptr) throw ();
+extern void cfree (void *__ptr) throw ();
+extern void *memalign (size_t __alignment, size_t __size)
+     throw () __attribute__ ((__malloc__)) ;
+extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) ;
+extern void * pvalloc (size_t __size) throw () __attribute__ ((__malloc__)) ;
+extern void *(*__morecore) (ptrdiff_t __size);
+extern void *__default_morecore (ptrdiff_t __size)
+     throw () __attribute__ ((__malloc__));
+struct mallinfo
+{
+  int arena;
+  int ordblks;
+  int smblks;
+  int hblks;
+  int hblkhd;
+  int usmblks;
+  int fsmblks;
+  int uordblks;
+  int fordblks;
+  int keepcost;
+};
+extern struct mallinfo mallinfo (void) throw ();
+extern int mallopt (int __param, int __val) throw ();
+extern int malloc_trim (size_t __pad) throw ();
+extern size_t malloc_usable_size (void *__ptr) throw ();
+extern void malloc_stats (void) throw ();
+extern int malloc_info (int __options, FILE *__fp) throw ();
+extern void *malloc_get_state (void) throw ();
+extern int malloc_set_state (void *__ptr) throw ();
+extern void (*__volatile __malloc_initialize_hook) (void)
+     __attribute__ ((__deprecated__));
+extern void (*__volatile __free_hook) (void *__ptr,
+         __const void *)
+     __attribute__ ((__deprecated__));
+extern void *(*__volatile __malloc_hook) (size_t __size,
+            __const void *)
+     __attribute__ ((__deprecated__));
+extern void *(*__volatile __realloc_hook) (void *__ptr,
+             size_t __size,
+             __const void *)
+     __attribute__ ((__deprecated__));
+extern void *(*__volatile __memalign_hook) (size_t __alignment,
+       size_t __size,
+       __const void *)
+     __attribute__ ((__deprecated__));
+extern void (*__volatile __after_morecore_hook) (void);
+extern void __malloc_check_init (void) throw () __attribute__ ((__deprecated__));
+}
+extern "C" {
+}
+typedef unsigned char uint8_t;
+typedef unsigned short int uint16_t;
+typedef unsigned int uint32_t;
+__extension__
+typedef unsigned long long int uint64_t;
+typedef signed char int_least8_t;
+typedef short int int_least16_t;
+typedef int int_least32_t;
+__extension__
+typedef long long int int_least64_t;
+typedef unsigned char uint_least8_t;
+typedef unsigned short int uint_least16_t;
+typedef unsigned int uint_least32_t;
+__extension__
+typedef unsigned long long int uint_least64_t;
+typedef signed char int_fast8_t;
+typedef int int_fast16_t;
+typedef int int_fast32_t;
+__extension__
+typedef long long int int_fast64_t;
+typedef unsigned char uint_fast8_t;
+typedef unsigned int uint_fast16_t;
+typedef unsigned int uint_fast32_t;
+__extension__
+typedef unsigned long long int uint_fast64_t;
+typedef unsigned int uintptr_t;
+__extension__
+typedef long long int intmax_t;
+__extension__
+typedef unsigned long long int uintmax_t;
+extern "C" {
+typedef struct
+  {
+    long long int quot;
+    long long int rem;
+  } imaxdiv_t;
+extern intmax_t imaxabs (intmax_t __n) throw () __attribute__ ((__const__));
+extern imaxdiv_t imaxdiv (intmax_t __numer, intmax_t __denom)
+      throw () __attribute__ ((__const__));
+extern intmax_t strtoimax (__const char *__restrict __nptr,
+      char **__restrict __endptr, int __base) throw ();
+extern uintmax_t strtoumax (__const char *__restrict __nptr,
+       char ** __restrict __endptr, int __base) throw ();
+extern intmax_t wcstoimax (__const wchar_t *__restrict __nptr,
+      wchar_t **__restrict __endptr, int __base)
+     throw ();
+extern uintmax_t wcstoumax (__const wchar_t *__restrict __nptr,
+       wchar_t ** __restrict __endptr, int __base)
+     throw ();
+__extension__
+extern long long int __strtoll_internal (__const char *__restrict __nptr,
+      char **__restrict __endptr,
+      int __base, int __group)
+  throw () __attribute__ ((__nonnull__ (1))) ;
+extern __inline __attribute__ ((__gnu_inline__)) intmax_t
+strtoimax (__const char *__restrict nptr, char **__restrict endptr, int base) throw ()
+{
+  return __strtoll_internal (nptr, endptr, base, 0);
+}
+__extension__
+extern unsigned long long int __strtoull_internal (__const char *
+         __restrict __nptr,
+         char **
+         __restrict __endptr,
+         int __base,
+         int __group)
+  throw () __attribute__ ((__nonnull__ (1))) ;
+extern __inline __attribute__ ((__gnu_inline__)) uintmax_t
+strtoumax (__const char *__restrict nptr, char **__restrict endptr, int base) throw ()
+{
+  return __strtoull_internal (nptr, endptr, base, 0);
+}
+__extension__
+extern long long int __wcstoll_internal (__const wchar_t *
+      __restrict __nptr,
+      wchar_t **__restrict __endptr,
+      int __base, int __group)
+  throw () __attribute__ ((__nonnull__ (1))) ;
+extern __inline __attribute__ ((__gnu_inline__)) intmax_t
+wcstoimax (__const wchar_t *__restrict nptr, wchar_t **__restrict endptr, int base) throw ()
+{
+  return __wcstoll_internal (nptr, endptr, base, 0);
+}
+__extension__
+extern unsigned long long int __wcstoull_internal (__const wchar_t *
+         __restrict __nptr,
+         wchar_t **
+         __restrict __endptr,
+         int __base,
+         int __group)
+  throw () __attribute__ ((__nonnull__ (1))) ;
+extern __inline __attribute__ ((__gnu_inline__)) uintmax_t
+wcstoumax (__const wchar_t *__restrict nptr, wchar_t **__restrict endptr, int base) throw ()
+{
+  return __wcstoull_internal (nptr, endptr, base, 0);
+}
+}
+extern "C" {
+}
+extern "C" {
+extern int stat (__const char *__restrict __file, struct stat *__restrict __buf) throw () __asm__ ("" "stat64")
+     __attribute__ ((__nonnull__ (1, 2)));
+extern int fstat (int __fd, struct stat *__buf) throw () __asm__ ("" "fstat64")
+     __attribute__ ((__nonnull__ (2)));
+extern int stat64 (__const char *__restrict __file,
+     struct stat64 *__restrict __buf) throw () __attribute__ ((__nonnull__ (1, 2)));
+extern int fstat64 (int __fd, struct stat64 *__buf) throw () __attribute__ ((__nonnull__ (2)));
+extern int fstatat (int __fd, __const char *__restrict __file, struct stat *__restrict __buf, int __flag) throw () __asm__ ("" "fstatat64") __attribute__ ((__nonnull__ (2, 3)));
+extern int fstatat64 (int __fd, __const char *__restrict __file,
+        struct stat64 *__restrict __buf, int __flag)
+     throw () __attribute__ ((__nonnull__ (2, 3)));
+extern int lstat (__const char *__restrict __file, struct stat *__restrict __buf) throw () __asm__ ("" "lstat64")
+     __attribute__ ((__nonnull__ (1, 2)));
+extern int lstat64 (__const char *__restrict __file,
+      struct stat64 *__restrict __buf)
+     throw () __attribute__ ((__nonnull__ (1, 2)));
+extern int chmod (__const char *__file, __mode_t __mode)
+     throw () __attribute__ ((__nonnull__ (1)));
+extern int lchmod (__const char *__file, __mode_t __mode)
+     throw () __attribute__ ((__nonnull__ (1)));
+extern int fchmod (int __fd, __mode_t __mode) throw ();
+extern int fchmodat (int __fd, __const char *__file, __mode_t __mode,
+       int __flag)
+     throw () __attribute__ ((__nonnull__ (2))) ;
+extern __mode_t umask (__mode_t __mask) throw ();
+extern __mode_t getumask (void) throw ();
+extern int mkdir (__const char *__path, __mode_t __mode)
+     throw () __attribute__ ((__nonnull__ (1)));
+extern int mkdirat (int __fd, __const char *__path, __mode_t __mode)
+     throw () __attribute__ ((__nonnull__ (2)));
+extern int mknod (__const char *__path, __mode_t __mode, __dev_t __dev)
+     throw () __attribute__ ((__nonnull__ (1)));
+extern int mknodat (int __fd, __const char *__path, __mode_t __mode,
+      __dev_t __dev) throw () __attribute__ ((__nonnull__ (2)));
+extern int mkfifo (__const char *__path, __mode_t __mode)
+     throw () __attribute__ ((__nonnull__ (1)));
+extern int mkfifoat (int __fd, __const char *__path, __mode_t __mode)
+     throw () __attribute__ ((__nonnull__ (2)));
+extern int utimensat (int __fd, __const char *__path,
+        __const struct timespec __times[2],
+        int __flags)
+     throw () __attribute__ ((__nonnull__ (2)));
+extern int futimens (int __fd, __const struct timespec __times[2]) throw ();
+extern int __fxstat (int __ver, int __fildes, struct stat *__stat_buf) throw () __asm__ ("" "__fxstat64")
+     __attribute__ ((__nonnull__ (3)));
+extern int __xstat (int __ver, __const char *__filename, struct stat *__stat_buf) throw () __asm__ ("" "__xstat64")
+     __attribute__ ((__nonnull__ (2, 3)));
+extern int __lxstat (int __ver, __const char *__filename, struct stat *__stat_buf) throw () __asm__ ("" "__lxstat64")
+     __attribute__ ((__nonnull__ (2, 3)));
+extern int __fxstatat (int __ver, int __fildes, __const char *__filename, struct stat *__stat_buf, int __flag) throw () __asm__ ("" "__fxstatat64") __attribute__ ((__nonnull__ (3, 4)));
+extern int __fxstat64 (int __ver, int __fildes, struct stat64 *__stat_buf)
+     throw () __attribute__ ((__nonnull__ (3)));
+extern int __xstat64 (int __ver, __const char *__filename,
+        struct stat64 *__stat_buf) throw () __attribute__ ((__nonnull__ (2, 3)));
+extern int __lxstat64 (int __ver, __const char *__filename,
+         struct stat64 *__stat_buf) throw () __attribute__ ((__nonnull__ (2, 3)));
+extern int __fxstatat64 (int __ver, int __fildes, __const char *__filename,
+    struct stat64 *__stat_buf, int __flag)
+     throw () __attribute__ ((__nonnull__ (3, 4)));
+extern int __xmknod (int __ver, __const char *__path, __mode_t __mode,
+       __dev_t *__dev) throw () __attribute__ ((__nonnull__ (2, 4)));
+extern int __xmknodat (int __ver, int __fd, __const char *__path,
+         __mode_t __mode, __dev_t *__dev)
+     throw () __attribute__ ((__nonnull__ (3, 5)));
+extern __inline __attribute__ ((__gnu_inline__)) int
+stat (__const char *__path, struct stat *__statbuf) throw ()
+{
+  return __xstat (3, __path, __statbuf);
+}
+extern __inline __attribute__ ((__gnu_inline__)) int
+lstat (__const char *__path, struct stat *__statbuf) throw ()
+{
+  return __lxstat (3, __path, __statbuf);
+}
+extern __inline __attribute__ ((__gnu_inline__)) int
+fstat (int __fd, struct stat *__statbuf) throw ()
+{
+  return __fxstat (3, __fd, __statbuf);
+}
+extern __inline __attribute__ ((__gnu_inline__)) int
+fstatat (int __fd, __const char *__filename, struct stat *__statbuf, int __flag) throw ()
+{
+  return __fxstatat (3, __fd, __filename, __statbuf, __flag);
+}
+extern __inline __attribute__ ((__gnu_inline__)) int
+mknod (__const char *__path, __mode_t __mode, __dev_t __dev) throw ()
+{
+  return __xmknod (1, __path, __mode, &__dev);
+}
+extern __inline __attribute__ ((__gnu_inline__)) int
+mknodat (int __fd, __const char *__path, __mode_t __mode, __dev_t __dev) throw ()
+{
+  return __xmknodat (1, __fd, __path, __mode, &__dev);
+}
+extern __inline __attribute__ ((__gnu_inline__)) int
+stat64 (__const char *__path, struct stat64 *__statbuf) throw ()
+{
+  return __xstat64 (3, __path, __statbuf);
+}
+extern __inline __attribute__ ((__gnu_inline__)) int
+lstat64 (__const char *__path, struct stat64 *__statbuf) throw ()
+{
+  return __lxstat64 (3, __path, __statbuf);
+}
+extern __inline __attribute__ ((__gnu_inline__)) int
+fstat64 (int __fd, struct stat64 *__statbuf) throw ()
+{
+  return __fxstat64 (3, __fd, __statbuf);
+}
+extern __inline __attribute__ ((__gnu_inline__)) int
+fstatat64 (int __fd, __const char *__filename, struct stat64 *__statbuf, int __flag) throw ()
+{
+  return __fxstatat64 (3, __fd, __filename, __statbuf, __flag);
+}
+}
+extern "C" {
+typedef unsigned int hashval_t;
+typedef hashval_t (*htab_hash) (const void *);
+typedef int (*htab_eq) (const void *, const void *);
+typedef void (*htab_del) (void *);
+typedef int (*htab_trav) (void **, void *);
+typedef void *(*htab_alloc) (size_t, size_t);
+typedef void (*htab_free) (void *);
+typedef void *(*htab_alloc_with_arg) (void *, size_t, size_t);
+typedef void (*htab_free_with_arg) (void *, void *);
+struct htab {
+  htab_hash hash_f;
+  htab_eq eq_f;
+  htab_del del_f;
+  void ** entries;
+  size_t size;
+  size_t n_elements;
+  size_t n_deleted;
+  unsigned int searches;
+  unsigned int collisions;
+  htab_alloc alloc_f;
+  htab_free free_f;
+  void * alloc_arg;
+  htab_alloc_with_arg alloc_with_arg_f;
+  htab_free_with_arg free_with_arg_f;
+  unsigned int size_prime_index;
+};
+typedef struct htab *htab_t;
+enum insert_option {NO_INSERT, INSERT};
+extern htab_t htab_create_alloc (size_t, htab_hash,
+                                    htab_eq, htab_del,
+                                    htab_alloc, htab_free);
+extern htab_t htab_create_alloc_ex (size_t, htab_hash,
+                                      htab_eq, htab_del,
+                                      void *, htab_alloc_with_arg,
+                                      htab_free_with_arg);
+extern htab_t htab_create_typed_alloc (size_t, htab_hash, htab_eq, htab_del,
+     htab_alloc, htab_alloc, htab_free);
+extern htab_t htab_create (size_t, htab_hash, htab_eq, htab_del);
+extern htab_t htab_try_create (size_t, htab_hash, htab_eq, htab_del);
+extern void htab_set_functions_ex (htab_t, htab_hash,
+                                       htab_eq, htab_del,
+                                       void *, htab_alloc_with_arg,
+                                       htab_free_with_arg);
+extern void htab_delete (htab_t);
+extern void htab_empty (htab_t);
+extern void * htab_find (htab_t, const void *);
+extern void ** htab_find_slot (htab_t, const void *, enum insert_option);
+extern void * htab_find_with_hash (htab_t, const void *, hashval_t);
+extern void ** htab_find_slot_with_hash (htab_t, const void *,
+       hashval_t, enum insert_option);
+extern void htab_clear_slot (htab_t, void **);
+extern void htab_remove_elt (htab_t, void *);
+extern void htab_remove_elt_with_hash (htab_t, void *, hashval_t);
+extern void htab_traverse (htab_t, htab_trav, void *);
+extern void htab_traverse_noresize (htab_t, htab_trav, void *);
+extern size_t htab_size (htab_t);
+extern size_t htab_elements (htab_t);
+extern double htab_collisions (htab_t);
+extern htab_hash htab_hash_pointer;
+extern htab_eq htab_eq_pointer;
+extern hashval_t htab_hash_string (const void *);
+extern hashval_t iterative_hash (const void *, size_t, hashval_t);
+}
+extern "C" {
+extern int filename_cmp (const char *s1, const char *s2);
+extern int filename_ncmp (const char *s1, const char *s2,
+     size_t n);
+extern hashval_t filename_hash (const void *s);
+extern int filename_eq (const void *s1, const void *s2);
+}
+extern "C" {
+extern void _dl_mcount_wrapper_check (void *__selfpc) throw ();
+}
+typedef long int Lmid_t;
+extern "C" {
+extern void *dlopen (__const char *__file, int __mode) throw ();
+extern int dlclose (void *__handle) throw () __attribute__ ((__nonnull__ (1)));
+extern void *dlsym (void *__restrict __handle,
+      __const char *__restrict __name) throw () __attribute__ ((__nonnull__ (2)));
+extern void *dlmopen (Lmid_t __nsid, __const char *__file, int __mode) throw ();
+extern void *dlvsym (void *__restrict __handle,
+       __const char *__restrict __name,
+       __const char *__restrict __version)
+     throw () __attribute__ ((__nonnull__ (2, 3)));
+extern char *dlerror (void) throw ();
+typedef struct
+{
+  __const char *dli_fname;
+  void *dli_fbase;
+  __const char *dli_sname;
+  void *dli_saddr;
+} Dl_info;
+extern int dladdr (__const void *__address, Dl_info *__info)
+     throw () __attribute__ ((__nonnull__ (2)));
+extern int dladdr1 (__const void *__address, Dl_info *__info,
+      void **__extra_info, int __flags) throw () __attribute__ ((__nonnull__ (2)));
+enum
+  {
+    RTLD_DL_SYMENT = 1,
+    RTLD_DL_LINKMAP = 2
+  };
+extern int dlinfo (void *__restrict __handle,
+     int __request, void *__restrict __arg)
+     throw () __attribute__ ((__nonnull__ (1, 3)));
+enum
+  {
+    RTLD_DI_LMID = 1,
+    RTLD_DI_LINKMAP = 2,
+    RTLD_DI_CONFIGADDR = 3,
+    RTLD_DI_SERINFO = 4,
+    RTLD_DI_SERINFOSIZE = 5,
+    RTLD_DI_ORIGIN = 6,
+    RTLD_DI_PROFILENAME = 7,
+    RTLD_DI_PROFILEOUT = 8,
+    RTLD_DI_TLS_MODID = 9,
+    RTLD_DI_TLS_DATA = 10,
+    RTLD_DI_MAX = 10
+  };
+typedef struct
+{
+  char *dls_name;
+  unsigned int dls_flags;
+} Dl_serpath;
+typedef struct
+{
+  size_t dls_size;
+  unsigned int dls_cnt;
+  Dl_serpath dls_serpath[1];
+} Dl_serinfo;
+}
+       
+       
+       
+namespace std __attribute__ ((__visibility__ ("default")))
+{
+
+  template<typename>
+    class allocator;
+  template<>
+    class allocator<void>;
+  template<typename, typename>
+    struct uses_allocator;
+
+}
+namespace std __attribute__ ((__visibility__ ("default")))
+{
+
+  template<class _CharT>
+    struct char_traits;
+  template<typename _CharT, typename _Traits = char_traits<_CharT>,
+           typename _Alloc = allocator<_CharT> >
+    class basic_string;
+  template<> struct char_traits<char>;
+  typedef basic_string<char> string;
+  template<> struct char_traits<wchar_t>;
+  typedef basic_string<wchar_t> wstring;
+
+}
+       
+       
+typedef unsigned int wint_t;
+
+typedef __mbstate_t mbstate_t;
+
+
+extern "C" {
+
+struct tm;
+
+
+
+extern wchar_t *wcscpy (wchar_t *__restrict __dest,
+   __const wchar_t *__restrict __src) throw ();
+extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
+    __const wchar_t *__restrict __src, size_t __n)
+     throw ();
+extern wchar_t *wcscat (wchar_t *__restrict __dest,
+   __const wchar_t *__restrict __src) throw ();
+extern wchar_t *wcsncat (wchar_t *__restrict __dest,
+    __const wchar_t *__restrict __src, size_t __n)
+     throw ();
+extern int wcscmp (__const wchar_t *__s1, __const wchar_t *__s2)
+     throw () __attribute__ ((__pure__));
+extern int wcsncmp (__const wchar_t *__s1, __const wchar_t *__s2, size_t __n)
+     throw () __attribute__ ((__pure__));
+
+extern int wcscasecmp (__const wchar_t *__s1, __const wchar_t *__s2) throw ();
+extern int wcsncasecmp (__const wchar_t *__s1, __const wchar_t *__s2,
+   size_t __n) throw ();
+extern int wcscasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
+    __locale_t __loc) throw ();
+extern int wcsncasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
+     size_t __n, __locale_t __loc) throw ();
+
+extern int wcscoll (__const wchar_t *__s1, __const wchar_t *__s2) throw ();
+extern size_t wcsxfrm (wchar_t *__restrict __s1,
+         __const wchar_t *__restrict __s2, size_t __n) throw ();
+
+extern int wcscoll_l (__const wchar_t *__s1, __const wchar_t *__s2,
+        __locale_t __loc) throw ();
+extern size_t wcsxfrm_l (wchar_t *__s1, __const wchar_t *__s2,
+    size_t __n, __locale_t __loc) throw ();
+extern wchar_t *wcsdup (__const wchar_t *__s) throw () __attribute__ ((__malloc__));
+
+extern "C++" wchar_t *wcschr (wchar_t *__wcs, wchar_t __wc)
+     throw () __asm ("wcschr") __attribute__ ((__pure__));
+extern "C++" __const wchar_t *wcschr (__const wchar_t *__wcs, wchar_t __wc)
+     throw () __asm ("wcschr") __attribute__ ((__pure__));
+extern "C++" wchar_t *wcsrchr (wchar_t *__wcs, wchar_t __wc)
+     throw () __asm ("wcsrchr") __attribute__ ((__pure__));
+extern "C++" __const wchar_t *wcsrchr (__const wchar_t *__wcs, wchar_t __wc)
+     throw () __asm ("wcsrchr") __attribute__ ((__pure__));
+
+extern wchar_t *wcschrnul (__const wchar_t *__s, wchar_t __wc)
+     throw () __attribute__ ((__pure__));
+
+extern size_t wcscspn (__const wchar_t *__wcs, __const wchar_t *__reject)
+     throw () __attribute__ ((__pure__));
+extern size_t wcsspn (__const wchar_t *__wcs, __const wchar_t *__accept)
+     throw () __attribute__ ((__pure__));
+extern "C++" wchar_t *wcspbrk (wchar_t *__wcs, __const wchar_t *__accept)
+     throw () __asm ("wcspbrk") __attribute__ ((__pure__));
+extern "C++" __const wchar_t *wcspbrk (__const wchar_t *__wcs,
+           __const wchar_t *__accept)
+     throw () __asm ("wcspbrk") __attribute__ ((__pure__));
+extern "C++" wchar_t *wcsstr (wchar_t *__haystack, __const wchar_t *__needle)
+     throw () __asm ("wcsstr") __attribute__ ((__pure__));
+extern "C++" __const wchar_t *wcsstr (__const wchar_t *__haystack,
+          __const wchar_t *__needle)
+     throw () __asm ("wcsstr") __attribute__ ((__pure__));
+extern wchar_t *wcstok (wchar_t *__restrict __s,
+   __const wchar_t *__restrict __delim,
+   wchar_t **__restrict __ptr) throw ();
+extern size_t wcslen (__const wchar_t *__s) throw () __attribute__ ((__pure__));
+
+extern "C++" wchar_t *wcswcs (wchar_t *__haystack, __const wchar_t *__needle)
+     throw () __asm ("wcswcs") __attribute__ ((__pure__));
+extern "C++" __const wchar_t *wcswcs (__const wchar_t *__haystack,
+          __const wchar_t *__needle)
+     throw () __asm ("wcswcs") __attribute__ ((__pure__));
+extern size_t wcsnlen (__const wchar_t *__s, size_t __maxlen)
+     throw () __attribute__ ((__pure__));
+
+extern "C++" wchar_t *wmemchr (wchar_t *__s, wchar_t __c, size_t __n)
+     throw () __asm ("wmemchr") __attribute__ ((__pure__));
+extern "C++" __const wchar_t *wmemchr (__const wchar_t *__s, wchar_t __c,
+           size_t __n)
+     throw () __asm ("wmemchr") __attribute__ ((__pure__));
+extern int wmemcmp (__const wchar_t *__s1, __const wchar_t *__s2, size_t __n)
+     throw () __attribute__ ((__pure__));
+extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
+    __const wchar_t *__restrict __s2, size_t __n) throw ();
+extern wchar_t *wmemmove (wchar_t *__s1, __const wchar_t *__s2, size_t __n)
+     throw ();
+extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) throw ();
+
+extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
+     __const wchar_t *__restrict __s2, size_t __n)
+     throw ();
+
+extern wint_t btowc (int __c) throw ();
+extern int wctob (wint_t __c) throw ();
+extern int mbsinit (__const mbstate_t *__ps) throw () __attribute__ ((__pure__));
+extern size_t mbrtowc (wchar_t *__restrict __pwc,
+         __const char *__restrict __s, size_t __n,
+         mbstate_t *__p) throw ();
+extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
+         mbstate_t *__restrict __ps) throw ();
+extern size_t __mbrlen (__const char *__restrict __s, size_t __n,
+   mbstate_t *__restrict __ps) throw ();
+extern size_t mbrlen (__const char *__restrict __s, size_t __n,
+        mbstate_t *__restrict __ps) throw ();
+
+extern wint_t __btowc_alias (int __c) __asm ("btowc");
+extern __inline __attribute__ ((__gnu_inline__)) wint_t
+btowc (int __c) throw ()
+{ return (__builtin_constant_p (__c) && __c >= '\0' && __c <= '\x7f'
+   ? (wint_t) __c : __btowc_alias (__c)); }
+extern int __wctob_alias (wint_t __c) __asm ("wctob");
+extern __inline __attribute__ ((__gnu_inline__)) int
+wctob (wint_t __wc) throw ()
+{ return (__builtin_constant_p (__wc) && __wc >= L'\0' && __wc <= L'\x7f'
+   ? (int) __wc : __wctob_alias (__wc)); }
+extern __inline __attribute__ ((__gnu_inline__)) size_t
+mbrlen (__const char *__restrict __s, size_t __n, mbstate_t *__restrict __ps) throw ()
+{ return (__ps != __null
+   ? mbrtowc (__null, __s, __n, __ps) : __mbrlen (__s, __n, __null)); }
+
+extern size_t mbsrtowcs (wchar_t *__restrict __dst,
+    __const char **__restrict __src, size_t __len,
+    mbstate_t *__restrict __ps) throw ();
+extern size_t wcsrtombs (char *__restrict __dst,
+    __const wchar_t **__restrict __src, size_t __len,
+    mbstate_t *__restrict __ps) throw ();
+
+extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
+     __const char **__restrict __src, size_t __nmc,
+     size_t __len, mbstate_t *__restrict __ps) throw ();
+extern size_t wcsnrtombs (char *__restrict __dst,
+     __const wchar_t **__restrict __src,
+     size_t __nwc, size_t __len,
+     mbstate_t *__restrict __ps) throw ();
+extern int wcwidth (wchar_t __c) throw ();
+extern int wcswidth (__const wchar_t *__s, size_t __n) throw ();
+
+extern double wcstod (__const wchar_t *__restrict __nptr,
+        wchar_t **__restrict __endptr) throw ();
+
+
+extern float wcstof (__const wchar_t *__restrict __nptr,
+       wchar_t **__restrict __endptr) throw ();
+extern long double wcstold (__const wchar_t *__restrict __nptr,
+       wchar_t **__restrict __endptr) throw ();
+
+
+extern long int wcstol (__const wchar_t *__restrict __nptr,
+   wchar_t **__restrict __endptr, int __base) throw ();
+extern unsigned long int wcstoul (__const wchar_t *__restrict __nptr,
+      wchar_t **__restrict __endptr, int __base)
+     throw ();
+
+
+__extension__
+extern long long int wcstoll (__const wchar_t *__restrict __nptr,
+         wchar_t **__restrict __endptr, int __base)
+     throw ();
+__extension__
+extern unsigned long long int wcstoull (__const wchar_t *__restrict __nptr,
+     wchar_t **__restrict __endptr,
+     int __base) throw ();
+
+__extension__
+extern long long int wcstoq (__const wchar_t *__restrict __nptr,
+        wchar_t **__restrict __endptr, int __base)
+     throw ();
+__extension__
+extern unsigned long long int wcstouq (__const wchar_t *__restrict __nptr,
+           wchar_t **__restrict __endptr,
+           int __base) throw ();
+extern long int wcstol_l (__const wchar_t *__restrict __nptr,
+     wchar_t **__restrict __endptr, int __base,
+     __locale_t __loc) throw ();
+extern unsigned long int wcstoul_l (__const wchar_t *__restrict __nptr,
+        wchar_t **__restrict __endptr,
+        int __base, __locale_t __loc) throw ();
+__extension__
+extern long long int wcstoll_l (__const wchar_t *__restrict __nptr,
+    wchar_t **__restrict __endptr,
+    int __base, __locale_t __loc) throw ();
+__extension__
+extern unsigned long long int wcstoull_l (__const wchar_t *__restrict __nptr,
+       wchar_t **__restrict __endptr,
+       int __base, __locale_t __loc)
+     throw ();
+extern double wcstod_l (__const wchar_t *__restrict __nptr,
+   wchar_t **__restrict __endptr, __locale_t __loc)
+     throw ();
+extern float wcstof_l (__const wchar_t *__restrict __nptr,
+         wchar_t **__restrict __endptr, __locale_t __loc)
+     throw ();
+extern long double wcstold_l (__const wchar_t *__restrict __nptr,
+         wchar_t **__restrict __endptr,
+         __locale_t __loc) throw ();
+extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
+   __const wchar_t *__restrict __src) throw ();
+extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
+    __const wchar_t *__restrict __src, size_t __n)
+     throw ();
+extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) throw ();
+
+extern int fwide (__FILE *__fp, int __mode) throw ();
+extern int fwprintf (__FILE *__restrict __stream,
+       __const wchar_t *__restrict __format, ...)
+                                                           ;
+extern int wprintf (__const wchar_t *__restrict __format, ...)
+                                                           ;
+extern int swprintf (wchar_t *__restrict __s, size_t __n,
+       __const wchar_t *__restrict __format, ...)
+     throw () ;
+extern int vfwprintf (__FILE *__restrict __s,
+        __const wchar_t *__restrict __format,
+        __gnuc_va_list __arg)
+                                                           ;
+extern int vwprintf (__const wchar_t *__restrict __format,
+       __gnuc_va_list __arg)
+                                                           ;
+extern int vswprintf (wchar_t *__restrict __s, size_t __n,
+        __const wchar_t *__restrict __format,
+        __gnuc_va_list __arg)
+     throw () ;
+extern int fwscanf (__FILE *__restrict __stream,
+      __const wchar_t *__restrict __format, ...)
+                                                          ;
+extern int wscanf (__const wchar_t *__restrict __format, ...)
+                                                          ;
+extern int swscanf (__const wchar_t *__restrict __s,
+      __const wchar_t *__restrict __format, ...)
+     throw () ;
+
+
+extern int vfwscanf (__FILE *__restrict __s,
+       __const wchar_t *__restrict __format,
+       __gnuc_va_list __arg)
+                                                          ;
+extern int vwscanf (__const wchar_t *__restrict __format,
+      __gnuc_va_list __arg)
+                                                          ;
+extern int vswscanf (__const wchar_t *__restrict __s,
+       __const wchar_t *__restrict __format,
+       __gnuc_va_list __arg)
+     throw () ;
+
+
+extern wint_t fgetwc (__FILE *__stream);
+extern wint_t getwc (__FILE *__stream);
+extern wint_t getwchar (void);
+extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
+extern wint_t putwc (wchar_t __wc, __FILE *__stream);
+extern wint_t putwchar (wchar_t __wc);
+extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
+   __FILE *__restrict __stream);
+extern int fputws (__const wchar_t *__restrict __ws,
+     __FILE *__restrict __stream);
+extern wint_t ungetwc (wint_t __wc, __FILE *__stream);
+
+extern wint_t getwc_unlocked (__FILE *__stream);
+extern wint_t getwchar_unlocked (void);
+extern wint_t fgetwc_unlocked (__FILE *__stream);
+extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
+extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
+extern wint_t putwchar_unlocked (wchar_t __wc);
+extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
+     __FILE *__restrict __stream);
+extern int fputws_unlocked (__const wchar_t *__restrict __ws,
+       __FILE *__restrict __stream);
+
+extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
+   __const wchar_t *__restrict __format,
+   __const struct tm *__restrict __tp) throw ();
+
+extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
+     __const wchar_t *__restrict __format,
+     __const struct tm *__restrict __tp,
+     __locale_t __loc) throw ();
+}
+namespace std
+{
+  using ::mbstate_t;
+}
+namespace std __attribute__ ((__visibility__ ("default")))
+{
+
+  using ::wint_t;
+  using ::btowc;
+  using ::fgetwc;
+  using ::fgetws;
+  using ::fputwc;
+  using ::fputws;
+  using ::fwide;
+  using ::fwprintf;
+  using ::fwscanf;
+  using ::getwc;
+  using ::getwchar;
+  using ::mbrlen;
+  using ::mbrtowc;
+  using ::mbsinit;
+  using ::mbsrtowcs;
+  using ::putwc;
+  using ::putwchar;
+  using ::swprintf;
+  using ::swscanf;
+  using ::ungetwc;
+  using ::vfwprintf;
+  using ::vfwscanf;
+  using ::vswprintf;
+  using ::vswscanf;
+  using ::vwprintf;
+  using ::vwscanf;
+  using ::wcrtomb;
+  using ::wcscat;
+  using ::wcscmp;
+  using ::wcscoll;
+  using ::wcscpy;
+  using ::wcscspn;
+  using ::wcsftime;
+  using ::wcslen;
+  using ::wcsncat;
+  using ::wcsncmp;
+  using ::wcsncpy;
+  using ::wcsrtombs;
+  using ::wcsspn;
+  using ::wcstod;
+  using ::wcstof;
+  using ::wcstok;
+  using ::wcstol;
+  using ::wcstoul;
+  using ::wcsxfrm;
+  using ::wctob;
+  using ::wmemcmp;
+  using ::wmemcpy;
+  using ::wmemmove;
+  using ::wmemset;
+  using ::wprintf;
+  using ::wscanf;
+  using ::wcschr;
+  using ::wcspbrk;
+  using ::wcsrchr;
+  using ::wcsstr;
+  using ::wmemchr;
+
+}
+namespace std __attribute__ ((__visibility__ ("default")))
+{
+
+  typedef long long streamoff;
+  typedef ptrdiff_t streamsize;
+  template<typename _StateT>
+    class fpos
+    {
+    private:
+      streamoff _M_off;
+      _StateT _M_state;
+    public:
+      fpos()
+      : _M_off(0), _M_state() { }
+      fpos(streamoff __off)
+      : _M_off(__off), _M_state() { }
+      operator streamoff() const { return _M_off; }
+      void
+      state(_StateT __st)
+      { _M_state = __st; }
+      _StateT
+      state() const
+      { return _M_state; }
+      fpos&
+      operator+=(streamoff __off)
+      {
+ _M_off += __off;
+ return *this;
+      }
+      fpos&
+      operator-=(streamoff __off)
+      {
+ _M_off -= __off;
+ return *this;
+      }
+      fpos
+      operator+(streamoff __off) const
+      {
+ fpos __pos(*this);
+ __pos += __off;
+ return __pos;
+      }
+      fpos
+      operator-(streamoff __off) const
+      {
+ fpos __pos(*this);
+ __pos -= __off;
+ return __pos;
+      }
+      streamoff
+      operator-(const fpos& __other) const
+      { return _M_off - __other._M_off; }
+    };
+  template<typename _StateT>
+    inline bool
+    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
+    { return streamoff(__lhs) == streamoff(__rhs); }
+  template<typename _StateT>
+    inline bool
+    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
+    { return streamoff(__lhs) != streamoff(__rhs); }
+  typedef fpos<mbstate_t> streampos;
+  typedef fpos<mbstate_t> wstreampos;
+
+}
+namespace std __attribute__ ((__visibility__ ("default")))
+{
+
+  class ios_base;
+  template<typename _CharT, typename _Traits = char_traits<_CharT> >
+    class basic_ios;
+  template<typename _CharT, typename _Traits = char_traits<_CharT> >
+    class basic_streambuf;
+  template<typename _CharT, typename _Traits = char_traits<_CharT> >
+    class basic_istream;
+  template<typename _CharT, typename _Traits = char_traits<_CharT> >
+    class basic_ostream;
+  template<typename _CharT, typename _Traits = char_traits<_CharT> >
+    class basic_iostream;
+  template<typename _CharT, typename _Traits = char_traits<_CharT>,
+     typename _Alloc = allocator<_CharT> >
+    class basic_stringbuf;
+  template<typename _CharT, typename _Traits = char_traits<_CharT>,
+    typename _Alloc = allocator<_CharT> >
+    class basic_istringstream;
+  template<typename _CharT, typename _Traits = char_traits<_CharT>,
+    typename _Alloc = allocator<_CharT> >
+    class basic_ostringstream;
+  template<typename _CharT, typename _Traits = char_traits<_CharT>,
+    typename _Alloc = allocator<_CharT> >
+    class basic_stringstream;
+  template<typename _CharT, typename _Traits = char_traits<_CharT> >
+    class basic_filebuf;
+  template<typename _CharT, typename _Traits = char_traits<_CharT> >
+    class basic_ifstream;
+  template<typename _CharT, typename _Traits = char_traits<_CharT> >
+    class basic_ofstream;
+  template<typename _CharT, typename _Traits = char_traits<_CharT> >
+    class basic_fstream;
+  template<typename _CharT, typename _Traits = char_traits<_CharT> >
+    class istreambuf_iterator;
+  template<typename _CharT, typename _Traits = char_traits<_CharT> >
+    class ostreambuf_iterator;
+  typedef basic_ios<char> ios;
+  typedef basic_streambuf<char> streambuf;
+  typedef basic_istream<char> istream;
+  typedef basic_ostream<char> ostream;
+  typedef basic_iostream<char> iostream;
+  typedef basic_stringbuf<char> stringbuf;
+  typedef basic_istringstream<char> istringstream;
+  typedef basic_ostringstream<char> ostringstream;
+  typedef basic_stringstream<char> stringstream;
+  typedef basic_filebuf<char> filebuf;
+  typedef basic_ifstream<char> ifstream;
+  typedef basic_ofstream<char> ofstream;
+  typedef basic_fstream<char> fstream;
+  typedef basic_ios<wchar_t> wios;
+  typedef basic_streambuf<wchar_t> wstreambuf;
+  typedef basic_istream<wchar_t> wistream;
+  typedef basic_ostream<wchar_t> wostream;
+  typedef basic_iostream<wchar_t> wiostream;
+  typedef basic_stringbuf<wchar_t> wstringbuf;
+  typedef basic_istringstream<wchar_t> wistringstream;
+  typedef basic_ostringstream<wchar_t> wostringstream;
+  typedef basic_stringstream<wchar_t> wstringstream;
+  typedef basic_filebuf<wchar_t> wfilebuf;
+  typedef basic_ifstream<wchar_t> wifstream;
+  typedef basic_ofstream<wchar_t> wofstream;
+  typedef basic_fstream<wchar_t> wfstream;
+
+}
+       
+namespace std
+{
+  using ::FILE;
+  using ::fpos_t;
+  using ::clearerr;
+  using ::fclose;
+  using ::feof;
+  using ::ferror;
+  using ::fflush;
+  using ::fgetc;
+  using ::fgetpos;
+  using ::fgets;
+  using ::fopen;
+  using ::fprintf;
+  using ::fputc;
+  using ::fputs;
+  using ::fread;
+  using ::freopen;
+  using ::fscanf;
+  using ::fseek;
+  using ::fsetpos;
+  using ::ftell;
+  using ::fwrite;
+  using ::getc;
+  using ::getchar;
+  using ::gets;
+  using ::perror;
+  using ::printf;
+  using ::putc;
+  using ::putchar;
+  using ::puts;
+  using ::remove;
+  using ::rename;
+  using ::rewind;
+  using ::scanf;
+  using ::setbuf;
+  using ::setvbuf;
+  using ::sprintf;
+  using ::sscanf;
+  using ::tmpfile;
+  using ::tmpnam;
+  using ::ungetc;
+  using ::vfprintf;
+  using ::vprintf;
+  using ::vsprintf;
+}
+       
+typedef unsigned long int mp_limb_t;
+typedef long int mp_limb_signed_t;
+typedef unsigned long int mp_bitcnt_t;
+typedef struct
+{
+  int _mp_alloc;
+  int _mp_size;
+  mp_limb_t *_mp_d;
+} __mpz_struct;
+typedef __mpz_struct MP_INT;
+typedef __mpz_struct mpz_t[1];
+typedef mp_limb_t * mp_ptr;
+typedef const mp_limb_t * mp_srcptr;
+typedef long int mp_size_t;
+typedef long int mp_exp_t;
+typedef struct
+{
+  __mpz_struct _mp_num;
+  __mpz_struct _mp_den;
+} __mpq_struct;
+typedef __mpq_struct MP_RAT;
+typedef __mpq_struct mpq_t[1];
+typedef struct
+{
+  int _mp_prec;
+  int _mp_size;
+  mp_exp_t _mp_exp;
+  mp_limb_t *_mp_d;
+} __mpf_struct;
+typedef __mpf_struct mpf_t[1];
+typedef enum
+{
+  GMP_RAND_ALG_DEFAULT = 0,
+  GMP_RAND_ALG_LC = GMP_RAND_ALG_DEFAULT
+} gmp_randalg_t;
+typedef struct
+{
+  mpz_t _mp_seed;
+  gmp_randalg_t _mp_alg;
+  union {
+    void *_mp_lc;
+  } _mp_algdata;
+} __gmp_randstate_struct;
+typedef __gmp_randstate_struct gmp_randstate_t[1];
+typedef const __mpz_struct *mpz_srcptr;
+typedef __mpz_struct *mpz_ptr;
+typedef const __mpf_struct *mpf_srcptr;
+typedef __mpf_struct *mpf_ptr;
+typedef const __mpq_struct *mpq_srcptr;
+typedef __mpq_struct *mpq_ptr;
+extern "C" {
+using std::FILE;
+ void __gmp_set_memory_functions (void *(*) (size_t),
+          void *(*) (void *, size_t, size_t),
+          void (*) (void *, size_t)) throw ();
+ void __gmp_get_memory_functions (void *(**) (size_t),
+                                      void *(**) (void *, size_t, size_t),
+                                      void (**) (void *, size_t)) throw ();
+ extern const int __gmp_bits_per_limb;
+ extern int __gmp_errno;
+ extern const char * const __gmp_version;
+ void __gmp_randinit (gmp_randstate_t, gmp_randalg_t, ...);
+ void __gmp_randinit_default (gmp_randstate_t);
+ void __gmp_randinit_lc_2exp (gmp_randstate_t, mpz_srcptr, unsigned long int, mp_bitcnt_t);
+ int __gmp_randinit_lc_2exp_size (gmp_randstate_t, mp_bitcnt_t);
+ void __gmp_randinit_mt (gmp_randstate_t);
+ void __gmp_randinit_set (gmp_randstate_t, const __gmp_randstate_struct *);
+ void __gmp_randseed (gmp_randstate_t, mpz_srcptr);
+ void __gmp_randseed_ui (gmp_randstate_t, unsigned long int);
+ void __gmp_randclear (gmp_randstate_t);
+ unsigned long __gmp_urandomb_ui (gmp_randstate_t, unsigned long);
+ unsigned long __gmp_urandomm_ui (gmp_randstate_t, unsigned long);
+ int __gmp_asprintf (char **, const char *, ...);
+ int __gmp_fprintf (FILE *, const char *, ...);
+ int __gmp_printf (const char *, ...);
+ int __gmp_snprintf (char *, size_t, const char *, ...);
+ int __gmp_sprintf (char *, const char *, ...);
+ int __gmp_vasprintf (char **, const char *, va_list);
+ int __gmp_vfprintf (FILE *, const char *, va_list);
+ int __gmp_vprintf (const char *, va_list);
+ int __gmp_vsnprintf (char *, size_t, const char *, va_list);
+ int __gmp_vsprintf (char *, const char *, va_list);
+ int __gmp_fscanf (FILE *, const char *, ...);
+ int __gmp_scanf (const char *, ...);
+ int __gmp_sscanf (const char *, const char *, ...);
+ int __gmp_vfscanf (FILE *, const char *, va_list);
+ int __gmp_vscanf (const char *, va_list);
+ int __gmp_vsscanf (const char *, const char *, va_list);
+ void *__gmpz_realloc (mpz_ptr, mp_size_t);
+ void __gmpz_abs (mpz_ptr, mpz_srcptr);
+ void __gmpz_add (mpz_ptr, mpz_srcptr, mpz_srcptr);
+ void __gmpz_add_ui (mpz_ptr, mpz_srcptr, unsigned long int);
+ void __gmpz_addmul (mpz_ptr, mpz_srcptr, mpz_srcptr);
+ void __gmpz_addmul_ui (mpz_ptr, mpz_srcptr, unsigned long int);
+ void __gmpz_and (mpz_ptr, mpz_srcptr, mpz_srcptr);
+ void __gmpz_array_init (mpz_ptr, mp_size_t, mp_size_t);
+ void __gmpz_bin_ui (mpz_ptr, mpz_srcptr, unsigned long int);
+ void __gmpz_bin_uiui (mpz_ptr, unsigned long int, unsigned long int);
+ void __gmpz_cdiv_q (mpz_ptr, mpz_srcptr, mpz_srcptr);
+ void __gmpz_cdiv_q_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);
+ unsigned long int __gmpz_cdiv_q_ui (mpz_ptr, mpz_srcptr, unsigned long int);
+ void __gmpz_cdiv_qr (mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr);
+ unsigned long int __gmpz_cdiv_qr_ui (mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long int);
+ void __gmpz_cdiv_r (mpz_ptr, mpz_srcptr, mpz_srcptr);
+ void __gmpz_cdiv_r_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);
+ unsigned long int __gmpz_cdiv_r_ui (mpz_ptr, mpz_srcptr, unsigned long int);
+ unsigned long int __gmpz_cdiv_ui (mpz_srcptr, unsigned long int) __attribute__ ((__pure__));
+ void __gmpz_clear (mpz_ptr);
+ void __gmpz_clears (mpz_ptr, ...);
+ void __gmpz_clrbit (mpz_ptr, mp_bitcnt_t);
+ int __gmpz_cmp (mpz_srcptr, mpz_srcptr) throw () __attribute__ ((__pure__));
+ int __gmpz_cmp_d (mpz_srcptr, double) __attribute__ ((__pure__));
+ int __gmpz_cmp_si (mpz_srcptr, signed long int) throw () __attribute__ ((__pure__));
+ int __gmpz_cmp_ui (mpz_srcptr, unsigned long int) throw () __attribute__ ((__pure__));
+ int __gmpz_cmpabs (mpz_srcptr, mpz_srcptr) throw () __attribute__ ((__pure__));
+ int __gmpz_cmpabs_d (mpz_srcptr, double) __attribute__ ((__pure__));
+ int __gmpz_cmpabs_ui (mpz_srcptr, unsigned long int) throw () __attribute__ ((__pure__));
+ void __gmpz_com (mpz_ptr, mpz_srcptr);
+ void __gmpz_combit (mpz_ptr, mp_bitcnt_t);
+ int __gmpz_congruent_p (mpz_srcptr, mpz_srcptr, mpz_srcptr) __attribute__ ((__pure__));
+ int __gmpz_congruent_2exp_p (mpz_srcptr, mpz_srcptr, mp_bitcnt_t) throw () __attribute__ ((__pure__));
+ int __gmpz_congruent_ui_p (mpz_srcptr, unsigned long, unsigned long) __attribute__ ((__pure__));
+ void __gmpz_divexact (mpz_ptr, mpz_srcptr, mpz_srcptr);
+ void __gmpz_divexact_ui (mpz_ptr, mpz_srcptr, unsigned long);
+ int __gmpz_divisible_p (mpz_srcptr, mpz_srcptr) __attribute__ ((__pure__));
+ int __gmpz_divisible_ui_p (mpz_srcptr, unsigned long) __attribute__ ((__pure__));
+ int __gmpz_divisible_2exp_p (mpz_srcptr, mp_bitcnt_t) throw () __attribute__ ((__pure__));
+ void __gmpz_dump (mpz_srcptr);
+ void *__gmpz_export (void *, size_t *, int, size_t, int, size_t, mpz_srcptr);
+ void __gmpz_fac_ui (mpz_ptr, unsigned long int);
+ void __gmpz_2fac_ui (mpz_ptr, unsigned long int);
+ void __gmpz_mfac_uiui (mpz_ptr, unsigned long int, unsigned long int);
+ void __gmpz_primorial_ui (mpz_ptr, unsigned long int);
+ void __gmpz_fdiv_q (mpz_ptr, mpz_srcptr, mpz_srcptr);
+ void __gmpz_fdiv_q_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);
+ unsigned long int __gmpz_fdiv_q_ui (mpz_ptr, mpz_srcptr, unsigned long int);
+ void __gmpz_fdiv_qr (mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr);
+ unsigned long int __gmpz_fdiv_qr_ui (mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long int);
+ void __gmpz_fdiv_r (mpz_ptr, mpz_srcptr, mpz_srcptr);
+ void __gmpz_fdiv_r_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);
+ unsigned long int __gmpz_fdiv_r_ui (mpz_ptr, mpz_srcptr, unsigned long int);
+ unsigned long int __gmpz_fdiv_ui (mpz_srcptr, unsigned long int) __attribute__ ((__pure__));
+ void __gmpz_fib_ui (mpz_ptr, unsigned long int);
+ void __gmpz_fib2_ui (mpz_ptr, mpz_ptr, unsigned long int);
+ int __gmpz_fits_sint_p (mpz_srcptr) throw () __attribute__ ((__pure__));
+ int __gmpz_fits_slong_p (mpz_srcptr) throw () __attribute__ ((__pure__));
+ int __gmpz_fits_sshort_p (mpz_srcptr) throw () __attribute__ ((__pure__));
+ int __gmpz_fits_uint_p (mpz_srcptr) throw () __attribute__ ((__pure__));
+ int __gmpz_fits_ulong_p (mpz_srcptr) throw () __attribute__ ((__pure__));
+ int __gmpz_fits_ushort_p (mpz_srcptr) throw () __attribute__ ((__pure__));
+ void __gmpz_gcd (mpz_ptr, mpz_srcptr, mpz_srcptr);
+ unsigned long int __gmpz_gcd_ui (mpz_ptr, mpz_srcptr, unsigned long int);
+ void __gmpz_gcdext (mpz_ptr, mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr);
+ double __gmpz_get_d (mpz_srcptr) __attribute__ ((__pure__));
+ double __gmpz_get_d_2exp (signed long int *, mpz_srcptr);
+ long int __gmpz_get_si (mpz_srcptr) throw () __attribute__ ((__pure__));
+ char *__gmpz_get_str (char *, int, mpz_srcptr);
+ unsigned long int __gmpz_get_ui (mpz_srcptr) throw () __attribute__ ((__pure__));
+ mp_limb_t __gmpz_getlimbn (mpz_srcptr, mp_size_t) throw () __attribute__ ((__pure__));
+ mp_bitcnt_t __gmpz_hamdist (mpz_srcptr, mpz_srcptr) throw () __attribute__ ((__pure__));
+ void __gmpz_import (mpz_ptr, size_t, int, size_t, int, size_t, const void *);
+ void __gmpz_init (mpz_ptr);
+ void __gmpz_init2 (mpz_ptr, mp_bitcnt_t);
+ void __gmpz_inits (mpz_ptr, ...);
+ void __gmpz_init_set (mpz_ptr, mpz_srcptr);
+ void __gmpz_init_set_d (mpz_ptr, double);
+ void __gmpz_init_set_si (mpz_ptr, signed long int);
+ int __gmpz_init_set_str (mpz_ptr, const char *, int);
+ void __gmpz_init_set_ui (mpz_ptr, unsigned long int);
+ size_t __gmpz_inp_raw (mpz_ptr, FILE *);
+ size_t __gmpz_inp_str (mpz_ptr, FILE *, int);
+ int __gmpz_invert (mpz_ptr, mpz_srcptr, mpz_srcptr);
+ void __gmpz_ior (mpz_ptr, mpz_srcptr, mpz_srcptr);
+ int __gmpz_jacobi (mpz_srcptr, mpz_srcptr) __attribute__ ((__pure__));
+ int __gmpz_kronecker_si (mpz_srcptr, long) __attribute__ ((__pure__));
+ int __gmpz_kronecker_ui (mpz_srcptr, unsigned long) __attribute__ ((__pure__));
+ int __gmpz_si_kronecker (long, mpz_srcptr) __attribute__ ((__pure__));
+ int __gmpz_ui_kronecker (unsigned long, mpz_srcptr) __attribute__ ((__pure__));
+ void __gmpz_lcm (mpz_ptr, mpz_srcptr, mpz_srcptr);
+ void __gmpz_lcm_ui (mpz_ptr, mpz_srcptr, unsigned long);
+ void __gmpz_lucnum_ui (mpz_ptr, unsigned long int);
+ void __gmpz_lucnum2_ui (mpz_ptr, mpz_ptr, unsigned long int);
+ int __gmpz_millerrabin (mpz_srcptr, int) __attribute__ ((__pure__));
+ void __gmpz_mod (mpz_ptr, mpz_srcptr, mpz_srcptr);
+ void __gmpz_mul (mpz_ptr, mpz_srcptr, mpz_srcptr);
+ void __gmpz_mul_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);
+ void __gmpz_mul_si (mpz_ptr, mpz_srcptr, long int);
+ void __gmpz_mul_ui (mpz_ptr, mpz_srcptr, unsigned long int);
+ void __gmpz_neg (mpz_ptr, mpz_srcptr);
+ void __gmpz_nextprime (mpz_ptr, mpz_srcptr);
+ size_t __gmpz_out_raw (FILE *, mpz_srcptr);
+ size_t __gmpz_out_str (FILE *, int, mpz_srcptr);
+ int __gmpz_perfect_power_p (mpz_srcptr) __attribute__ ((__pure__));
+ int __gmpz_perfect_square_p (mpz_srcptr) __attribute__ ((__pure__));
+ mp_bitcnt_t __gmpz_popcount (mpz_srcptr) throw () __attribute__ ((__pure__));
+ void __gmpz_pow_ui (mpz_ptr, mpz_srcptr, unsigned long int);
+ void __gmpz_powm (mpz_ptr, mpz_srcptr, mpz_srcptr, mpz_srcptr);
+ void __gmpz_powm_sec (mpz_ptr, mpz_srcptr, mpz_srcptr, mpz_srcptr);
+ void __gmpz_powm_ui (mpz_ptr, mpz_srcptr, unsigned long int, mpz_srcptr);
+ int __gmpz_probab_prime_p (mpz_srcptr, int) __attribute__ ((__pure__));
+ void __gmpz_random (mpz_ptr, mp_size_t);
+ void __gmpz_random2 (mpz_ptr, mp_size_t);
+ void __gmpz_realloc2 (mpz_ptr, mp_bitcnt_t);
+ mp_bitcnt_t __gmpz_remove (mpz_ptr, mpz_srcptr, mpz_srcptr);
+ int __gmpz_root (mpz_ptr, mpz_srcptr, unsigned long int);
+ void __gmpz_rootrem (mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long int);
+ void __gmpz_rrandomb (mpz_ptr, gmp_randstate_t, mp_bitcnt_t);
+ mp_bitcnt_t __gmpz_scan0 (mpz_srcptr, mp_bitcnt_t) throw () __attribute__ ((__pure__));
+ mp_bitcnt_t __gmpz_scan1 (mpz_srcptr, mp_bitcnt_t) throw () __attribute__ ((__pure__));
+ void __gmpz_set (mpz_ptr, mpz_srcptr);
+ void __gmpz_set_d (mpz_ptr, double);
+ void __gmpz_set_f (mpz_ptr, mpf_srcptr);
+ void __gmpz_set_q (mpz_ptr, mpq_srcptr);
+ void __gmpz_set_si (mpz_ptr, signed long int);
+ int __gmpz_set_str (mpz_ptr, const char *, int);
+ void __gmpz_set_ui (mpz_ptr, unsigned long int);
+ void __gmpz_setbit (mpz_ptr, mp_bitcnt_t);
+ size_t __gmpz_size (mpz_srcptr) throw () __attribute__ ((__pure__));
+ size_t __gmpz_sizeinbase (mpz_srcptr, int) throw () __attribute__ ((__pure__));
+ void __gmpz_sqrt (mpz_ptr, mpz_srcptr);
+ void __gmpz_sqrtrem (mpz_ptr, mpz_ptr, mpz_srcptr);
+ void __gmpz_sub (mpz_ptr, mpz_srcptr, mpz_srcptr);
+ void __gmpz_sub_ui (mpz_ptr, mpz_srcptr, unsigned long int);
+ void __gmpz_ui_sub (mpz_ptr, unsigned long int, mpz_srcptr);
+ void __gmpz_submul (mpz_ptr, mpz_srcptr, mpz_srcptr);
+ void __gmpz_submul_ui (mpz_ptr, mpz_srcptr, unsigned long int);
+ void __gmpz_swap (mpz_ptr, mpz_ptr) throw ();
+ unsigned long int __gmpz_tdiv_ui (mpz_srcptr, unsigned long int) __attribute__ ((__pure__));
+ void __gmpz_tdiv_q (mpz_ptr, mpz_srcptr, mpz_srcptr);
+ void __gmpz_tdiv_q_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);
+ unsigned long int __gmpz_tdiv_q_ui (mpz_ptr, mpz_srcptr, unsigned long int);
+ void __gmpz_tdiv_qr (mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr);
+ unsigned long int __gmpz_tdiv_qr_ui (mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long int);
+ void __gmpz_tdiv_r (mpz_ptr, mpz_srcptr, mpz_srcptr);
+ void __gmpz_tdiv_r_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);
+ unsigned long int __gmpz_tdiv_r_ui (mpz_ptr, mpz_srcptr, unsigned long int);
+ int __gmpz_tstbit (mpz_srcptr, mp_bitcnt_t) throw () __attribute__ ((__pure__));
+ void __gmpz_ui_pow_ui (mpz_ptr, unsigned long int, unsigned long int);
+ void __gmpz_urandomb (mpz_ptr, gmp_randstate_t, mp_bitcnt_t);
+ void __gmpz_urandomm (mpz_ptr, gmp_randstate_t, mpz_srcptr);
+ void __gmpz_xor (mpz_ptr, mpz_srcptr, mpz_srcptr);
+ void __gmpq_abs (mpq_ptr, mpq_srcptr);
+ void __gmpq_add (mpq_ptr, mpq_srcptr, mpq_srcptr);
+ void __gmpq_canonicalize (mpq_ptr);
+ void __gmpq_clear (mpq_ptr);
+ void __gmpq_clears (mpq_ptr, ...);
+ int __gmpq_cmp (mpq_srcptr, mpq_srcptr) __attribute__ ((__pure__));
+ int __gmpq_cmp_si (mpq_srcptr, long, unsigned long) __attribute__ ((__pure__));
+ int __gmpq_cmp_ui (mpq_srcptr, unsigned long int, unsigned long int) __attribute__ ((__pure__));
+ void __gmpq_div (mpq_ptr, mpq_srcptr, mpq_srcptr);
+ void __gmpq_div_2exp (mpq_ptr, mpq_srcptr, mp_bitcnt_t);
+ int __gmpq_equal (mpq_srcptr, mpq_srcptr) throw () __attribute__ ((__pure__));
+ void __gmpq_get_num (mpz_ptr, mpq_srcptr);
+ void __gmpq_get_den (mpz_ptr, mpq_srcptr);
+ double __gmpq_get_d (mpq_srcptr) __attribute__ ((__pure__));
+ char *__gmpq_get_str (char *, int, mpq_srcptr);
+ void __gmpq_init (mpq_ptr);
+ void __gmpq_inits (mpq_ptr, ...);
+ size_t __gmpq_inp_str (mpq_ptr, FILE *, int);
+ void __gmpq_inv (mpq_ptr, mpq_srcptr);
+ void __gmpq_mul (mpq_ptr, mpq_srcptr, mpq_srcptr);
+ void __gmpq_mul_2exp (mpq_ptr, mpq_srcptr, mp_bitcnt_t);
+ void __gmpq_neg (mpq_ptr, mpq_srcptr);
+ size_t __gmpq_out_str (FILE *, int, mpq_srcptr);
+ void __gmpq_set (mpq_ptr, mpq_srcptr);
+ void __gmpq_set_d (mpq_ptr, double);
+ void __gmpq_set_den (mpq_ptr, mpz_srcptr);
+ void __gmpq_set_f (mpq_ptr, mpf_srcptr);
+ void __gmpq_set_num (mpq_ptr, mpz_srcptr);
+ void __gmpq_set_si (mpq_ptr, signed long int, unsigned long int);
+ int __gmpq_set_str (mpq_ptr, const char *, int);
+ void __gmpq_set_ui (mpq_ptr, unsigned long int, unsigned long int);
+ void __gmpq_set_z (mpq_ptr, mpz_srcptr);
+ void __gmpq_sub (mpq_ptr, mpq_srcptr, mpq_srcptr);
+ void __gmpq_swap (mpq_ptr, mpq_ptr) throw ();
+ void __gmpf_abs (mpf_ptr, mpf_srcptr);
+ void __gmpf_add (mpf_ptr, mpf_srcptr, mpf_srcptr);
+ void __gmpf_add_ui (mpf_ptr, mpf_srcptr, unsigned long int);
+ void __gmpf_ceil (mpf_ptr, mpf_srcptr);
+ void __gmpf_clear (mpf_ptr);
+ void __gmpf_clears (mpf_ptr, ...);
+ int __gmpf_cmp (mpf_srcptr, mpf_srcptr) throw () __attribute__ ((__pure__));
+ int __gmpf_cmp_d (mpf_srcptr, double) __attribute__ ((__pure__));
+ int __gmpf_cmp_si (mpf_srcptr, signed long int) throw () __attribute__ ((__pure__));
+ int __gmpf_cmp_ui (mpf_srcptr, unsigned long int) throw () __attribute__ ((__pure__));
+ void __gmpf_div (mpf_ptr, mpf_srcptr, mpf_srcptr);
+ void __gmpf_div_2exp (mpf_ptr, mpf_srcptr, mp_bitcnt_t);
+ void __gmpf_div_ui (mpf_ptr, mpf_srcptr, unsigned long int);
+ void __gmpf_dump (mpf_srcptr);
+ int __gmpf_eq (mpf_srcptr, mpf_srcptr, mp_bitcnt_t) __attribute__ ((__pure__));
+ int __gmpf_fits_sint_p (mpf_srcptr) throw () __attribute__ ((__pure__));
+ int __gmpf_fits_slong_p (mpf_srcptr) throw () __attribute__ ((__pure__));
+ int __gmpf_fits_sshort_p (mpf_srcptr) throw () __attribute__ ((__pure__));
+ int __gmpf_fits_uint_p (mpf_srcptr) throw () __attribute__ ((__pure__));
+ int __gmpf_fits_ulong_p (mpf_srcptr) throw () __attribute__ ((__pure__));
+ int __gmpf_fits_ushort_p (mpf_srcptr) throw () __attribute__ ((__pure__));
+ void __gmpf_floor (mpf_ptr, mpf_srcptr);
+ double __gmpf_get_d (mpf_srcptr) __attribute__ ((__pure__));
+ double __gmpf_get_d_2exp (signed long int *, mpf_srcptr);
+ mp_bitcnt_t __gmpf_get_default_prec (void) throw () __attribute__ ((__pure__));
+ mp_bitcnt_t __gmpf_get_prec (mpf_srcptr) throw () __attribute__ ((__pure__));
+ long __gmpf_get_si (mpf_srcptr) throw () __attribute__ ((__pure__));
+ char *__gmpf_get_str (char *, mp_exp_t *, int, size_t, mpf_srcptr);
+ unsigned long __gmpf_get_ui (mpf_srcptr) throw () __attribute__ ((__pure__));
+ void __gmpf_init (mpf_ptr);
+ void __gmpf_init2 (mpf_ptr, mp_bitcnt_t);
+ void __gmpf_inits (mpf_ptr, ...);
+ void __gmpf_init_set (mpf_ptr, mpf_srcptr);
+ void __gmpf_init_set_d (mpf_ptr, double);
+ void __gmpf_init_set_si (mpf_ptr, signed long int);
+ int __gmpf_init_set_str (mpf_ptr, const char *, int);
+ void __gmpf_init_set_ui (mpf_ptr, unsigned long int);
+ size_t __gmpf_inp_str (mpf_ptr, FILE *, int);
+ int __gmpf_integer_p (mpf_srcptr) throw () __attribute__ ((__pure__));
+ void __gmpf_mul (mpf_ptr, mpf_srcptr, mpf_srcptr);
+ void __gmpf_mul_2exp (mpf_ptr, mpf_srcptr, mp_bitcnt_t);
+ void __gmpf_mul_ui (mpf_ptr, mpf_srcptr, unsigned long int);
+ void __gmpf_neg (mpf_ptr, mpf_srcptr);
+ size_t __gmpf_out_str (FILE *, int, size_t, mpf_srcptr);
+ void __gmpf_pow_ui (mpf_ptr, mpf_srcptr, unsigned long int);
+ void __gmpf_random2 (mpf_ptr, mp_size_t, mp_exp_t);
+ void __gmpf_reldiff (mpf_ptr, mpf_srcptr, mpf_srcptr);
+ void __gmpf_set (mpf_ptr, mpf_srcptr);
+ void __gmpf_set_d (mpf_ptr, double);
+ void __gmpf_set_default_prec (mp_bitcnt_t) throw ();
+ void __gmpf_set_prec (mpf_ptr, mp_bitcnt_t);
+ void __gmpf_set_prec_raw (mpf_ptr, mp_bitcnt_t) throw ();
+ void __gmpf_set_q (mpf_ptr, mpq_srcptr);
+ void __gmpf_set_si (mpf_ptr, signed long int);
+ int __gmpf_set_str (mpf_ptr, const char *, int);
+ void __gmpf_set_ui (mpf_ptr, unsigned long int);
+ void __gmpf_set_z (mpf_ptr, mpz_srcptr);
+ size_t __gmpf_size (mpf_srcptr) throw () __attribute__ ((__pure__));
+ void __gmpf_sqrt (mpf_ptr, mpf_srcptr);
+ void __gmpf_sqrt_ui (mpf_ptr, unsigned long int);
+ void __gmpf_sub (mpf_ptr, mpf_srcptr, mpf_srcptr);
+ void __gmpf_sub_ui (mpf_ptr, mpf_srcptr, unsigned long int);
+ void __gmpf_swap (mpf_ptr, mpf_ptr) throw ();
+ void __gmpf_trunc (mpf_ptr, mpf_srcptr);
+ void __gmpf_ui_div (mpf_ptr, unsigned long int, mpf_srcptr);
+ void __gmpf_ui_sub (mpf_ptr, unsigned long int, mpf_srcptr);
+ void __gmpf_urandomb (mpf_t, gmp_randstate_t, mp_bitcnt_t);
+ mp_limb_t __gmpn_add (mp_ptr, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t);
+ mp_limb_t __gmpn_add_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t) throw ();
+ mp_limb_t __gmpn_add_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);
+ mp_limb_t __gmpn_addmul_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t);
+ int __gmpn_cmp (mp_srcptr, mp_srcptr, mp_size_t) throw () __attribute__ ((__pure__));
+ mp_limb_t __gmpn_divexact_by3c (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t);
+ mp_limb_t __gmpn_divrem (mp_ptr, mp_size_t, mp_ptr, mp_size_t, mp_srcptr, mp_size_t);
+ mp_limb_t __gmpn_divrem_1 (mp_ptr, mp_size_t, mp_srcptr, mp_size_t, mp_limb_t);
+ mp_limb_t __gmpn_divrem_2 (mp_ptr, mp_size_t, mp_ptr, mp_size_t, mp_srcptr);
+ mp_limb_t __gmpn_div_qr_2 (mp_ptr, mp_ptr, mp_srcptr, mp_size_t, mp_srcptr);
+ mp_size_t __gmpn_gcd (mp_ptr, mp_ptr, mp_size_t, mp_ptr, mp_size_t);
+ mp_limb_t __gmpn_gcd_1 (mp_srcptr, mp_size_t, mp_limb_t) __attribute__ ((__pure__));
+ mp_limb_t __gmpn_gcdext_1 (mp_limb_signed_t *, mp_limb_signed_t *, mp_limb_t, mp_limb_t);
+ mp_size_t __gmpn_gcdext (mp_ptr, mp_ptr, mp_size_t *, mp_ptr, mp_size_t, mp_ptr, mp_size_t);
+ size_t __gmpn_get_str (unsigned char *, int, mp_ptr, mp_size_t);
+ mp_bitcnt_t __gmpn_hamdist (mp_srcptr, mp_srcptr, mp_size_t) throw () __attribute__ ((__pure__));
+ mp_limb_t __gmpn_lshift (mp_ptr, mp_srcptr, mp_size_t, unsigned int);
+ mp_limb_t __gmpn_mod_1 (mp_srcptr, mp_size_t, mp_limb_t) __attribute__ ((__pure__));
+ mp_limb_t __gmpn_mul (mp_ptr, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t);
+ mp_limb_t __gmpn_mul_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t);
+ void __gmpn_mul_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);
+ void __gmpn_sqr (mp_ptr, mp_srcptr, mp_size_t);
+ mp_limb_t __gmpn_neg (mp_ptr, mp_srcptr, mp_size_t);
+ void __gmpn_com (mp_ptr, mp_srcptr, mp_size_t);
+ int __gmpn_perfect_square_p (mp_srcptr, mp_size_t) __attribute__ ((__pure__));
+ int __gmpn_perfect_power_p (mp_srcptr, mp_size_t) __attribute__ ((__pure__));
+ mp_bitcnt_t __gmpn_popcount (mp_srcptr, mp_size_t) throw () __attribute__ ((__pure__));
+ mp_size_t __gmpn_pow_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t, mp_ptr);
+ mp_limb_t __gmpn_preinv_mod_1 (mp_srcptr, mp_size_t, mp_limb_t, mp_limb_t) __attribute__ ((__pure__));
+ void __gmpn_random (mp_ptr, mp_size_t);
+ void __gmpn_random2 (mp_ptr, mp_size_t);
+ mp_limb_t __gmpn_rshift (mp_ptr, mp_srcptr, mp_size_t, unsigned int);
+ mp_bitcnt_t __gmpn_scan0 (mp_srcptr, mp_bitcnt_t) __attribute__ ((__pure__));
+ mp_bitcnt_t __gmpn_scan1 (mp_srcptr, mp_bitcnt_t) __attribute__ ((__pure__));
+ mp_size_t __gmpn_set_str (mp_ptr, const unsigned char *, size_t, int);
+ mp_size_t __gmpn_sqrtrem (mp_ptr, mp_ptr, mp_srcptr, mp_size_t);
+ mp_limb_t __gmpn_sub (mp_ptr, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t);
+ mp_limb_t __gmpn_sub_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t) throw ();
+ mp_limb_t __gmpn_sub_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);
+ mp_limb_t __gmpn_submul_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t);
+ void __gmpn_tdiv_qr (mp_ptr, mp_ptr, mp_size_t, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t);
+ void __gmpn_and_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);
+ void __gmpn_andn_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);
+ void __gmpn_nand_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);
+ void __gmpn_ior_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);
+ void __gmpn_iorn_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);
+ void __gmpn_nior_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);
+ void __gmpn_xor_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);
+ void __gmpn_xnor_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);
+ void __gmpn_copyi (mp_ptr, mp_srcptr, mp_size_t);
+ void __gmpn_copyd (mp_ptr, mp_srcptr, mp_size_t);
+ void __gmpn_zero (mp_ptr, mp_size_t);
+extern __inline__ __attribute__ ((__gnu_inline__)) void
+__gmpz_abs (mpz_ptr __gmp_w, mpz_srcptr __gmp_u)
+{
+  if (__gmp_w != __gmp_u)
+    __gmpz_set (__gmp_w, __gmp_u);
+  __gmp_w->_mp_size = ((__gmp_w->_mp_size) >= 0 ? (__gmp_w->_mp_size) : -(__gmp_w->_mp_size));
+}
+extern __inline__ __attribute__ ((__gnu_inline__))
+int
+__gmpz_fits_uint_p (mpz_srcptr __gmp_z) throw ()
+{
+  mp_size_t __gmp_n = __gmp_z->_mp_size; mp_ptr __gmp_p = __gmp_z->_mp_d; return (__gmp_n == 0 || (__gmp_n == 1 && __gmp_p[0] <= (~ (unsigned) 0)));;
+}
+extern __inline__ __attribute__ ((__gnu_inline__))
+int
+__gmpz_fits_ulong_p (mpz_srcptr __gmp_z) throw ()
+{
+  mp_size_t __gmp_n = __gmp_z->_mp_size; mp_ptr __gmp_p = __gmp_z->_mp_d; return (__gmp_n == 0 || (__gmp_n == 1 && __gmp_p[0] <= (~ (unsigned long) 0)));;
+}
+extern __inline__ __attribute__ ((__gnu_inline__))
+int
+__gmpz_fits_ushort_p (mpz_srcptr __gmp_z) throw ()
+{
+  mp_size_t __gmp_n = __gmp_z->_mp_size; mp_ptr __gmp_p = __gmp_z->_mp_d; return (__gmp_n == 0 || (__gmp_n == 1 && __gmp_p[0] <= ((unsigned short) ~0)));;
+}
+extern __inline__ __attribute__ ((__gnu_inline__))
+unsigned long
+__gmpz_get_ui (mpz_srcptr __gmp_z) throw ()
+{
+  mp_ptr __gmp_p = __gmp_z->_mp_d;
+  mp_size_t __gmp_n = __gmp_z->_mp_size;
+  mp_limb_t __gmp_l = __gmp_p[0];
+  return (__gmp_n != 0 ? __gmp_l : 0);
+}
+extern __inline__ __attribute__ ((__gnu_inline__))
+mp_limb_t
+__gmpz_getlimbn (mpz_srcptr __gmp_z, mp_size_t __gmp_n) throw ()
+{
+  mp_limb_t __gmp_result = 0;
+  if (__builtin_expect ((__gmp_n >= 0 && __gmp_n < ((__gmp_z->_mp_size) >= 0 ? (__gmp_z->_mp_size) : -(__gmp_z->_mp_size))) != 0, 1))
+    __gmp_result = __gmp_z->_mp_d[__gmp_n];
+  return __gmp_result;
+}
+extern __inline__ __attribute__ ((__gnu_inline__)) void
+__gmpz_neg (mpz_ptr __gmp_w, mpz_srcptr __gmp_u)
+{
+  if (__gmp_w != __gmp_u)
+    __gmpz_set (__gmp_w, __gmp_u);
+  __gmp_w->_mp_size = - __gmp_w->_mp_size;
+}
+extern __inline__ __attribute__ ((__gnu_inline__))
+int
+__gmpz_perfect_square_p (mpz_srcptr __gmp_a)
+{
+  mp_size_t __gmp_asize;
+  int __gmp_result;
+  __gmp_asize = __gmp_a->_mp_size;
+  __gmp_result = (__gmp_asize >= 0);
+  if (__builtin_expect ((__gmp_asize > 0) != 0, 1))
+    __gmp_result = __gmpn_perfect_square_p (__gmp_a->_mp_d, __gmp_asize);
+  return __gmp_result;
+}
+extern __inline__ __attribute__ ((__gnu_inline__))
+mp_bitcnt_t
+__gmpz_popcount (mpz_srcptr __gmp_u) throw ()
+{
+  mp_size_t __gmp_usize;
+  mp_bitcnt_t __gmp_result;
+  __gmp_usize = __gmp_u->_mp_size;
+  __gmp_result = (__gmp_usize < 0 ? (~ (unsigned long) 0) : 0);
+  if (__builtin_expect ((__gmp_usize > 0) != 0, 1))
+    __gmp_result = __gmpn_popcount (__gmp_u->_mp_d, __gmp_usize);
+  return __gmp_result;
+}
+extern __inline__ __attribute__ ((__gnu_inline__))
+void
+__gmpz_set_q (mpz_ptr __gmp_w, mpq_srcptr __gmp_u)
+{
+  __gmpz_tdiv_q (__gmp_w, (&((__gmp_u)->_mp_num)), (&((__gmp_u)->_mp_den)));
+}
+extern __inline__ __attribute__ ((__gnu_inline__))
+size_t
+__gmpz_size (mpz_srcptr __gmp_z) throw ()
+{
+  return ((__gmp_z->_mp_size) >= 0 ? (__gmp_z->_mp_size) : -(__gmp_z->_mp_size));
+}
+extern __inline__ __attribute__ ((__gnu_inline__)) void
+__gmpq_abs (mpq_ptr __gmp_w, mpq_srcptr __gmp_u)
+{
+  if (__gmp_w != __gmp_u)
+    __gmpq_set (__gmp_w, __gmp_u);
+  __gmp_w->_mp_num._mp_size = ((__gmp_w->_mp_num._mp_size) >= 0 ? (__gmp_w->_mp_num._mp_size) : -(__gmp_w->_mp_num._mp_size));
+}
+extern __inline__ __attribute__ ((__gnu_inline__)) void
+__gmpq_neg (mpq_ptr __gmp_w, mpq_srcptr __gmp_u)
+{
+  if (__gmp_w != __gmp_u)
+    __gmpq_set (__gmp_w, __gmp_u);
+  __gmp_w->_mp_num._mp_size = - __gmp_w->_mp_num._mp_size;
+}
+extern __inline__ __attribute__ ((__gnu_inline__))
+mp_limb_t
+__gmpn_add (mp_ptr __gmp_wp, mp_srcptr __gmp_xp, mp_size_t __gmp_xsize, mp_srcptr __gmp_yp, mp_size_t __gmp_ysize)
+{
+  mp_limb_t __gmp_c;
+  do { mp_size_t __gmp_i; mp_limb_t __gmp_x; __gmp_i = (__gmp_ysize); if (__gmp_i != 0) { if (__gmpn_add_n (__gmp_wp, __gmp_xp, __gmp_yp, __gmp_i)) { do { if (__gmp_i >= (__gmp_xsize)) { (__gmp_c) = 1; goto __gmp_done; } __gmp_x = (__gmp_xp)[__gmp_i]; } while ((((__gmp_wp)[__gmp_i++] = (__gmp_x + 1) & ((~ (static_cast<mp_limb_t> (0))) >> 0)) == 0)); } } if ((__gmp_wp) != (__gmp_xp)) do { mp_size_t __gmp_j; ; for (__gmp_j = (__gmp_i); __gmp_j < (__gmp_xsize); __gmp_j++) (__gmp_wp)[__gmp_j] = (__gmp_xp)[__gmp_j]; } while (0); (__gmp_c) = 0; __gmp_done: ; } while (0);
+  return __gmp_c;
+}
+extern __inline__ __attribute__ ((__gnu_inline__))
+mp_limb_t
+__gmpn_add_1 (mp_ptr __gmp_dst, mp_srcptr __gmp_src, mp_size_t __gmp_size, mp_limb_t __gmp_n) throw ()
+{
+  mp_limb_t __gmp_c;
+  do { mp_size_t __gmp_i; mp_limb_t __gmp_x, __gmp_r; __gmp_x = (__gmp_src)[0]; __gmp_r = __gmp_x + (__gmp_n); (__gmp_dst)[0] = __gmp_r; if (((__gmp_r) < ((__gmp_n)))) { (__gmp_c) = 1; for (__gmp_i = 1; __gmp_i < (__gmp_size);) { __gmp_x = (__gmp_src)[__gmp_i]; __gmp_r = __gmp_x + 1; (__gmp_dst)[__gmp_i] = __gmp_r; ++__gmp_i; if (!((__gmp_r) < (1))) { if ((__gmp_src) != (__gmp_dst)) do { mp_size_t __gmp_j; ; for (__gmp_j = (__gmp_i); __gmp_j < (__gmp_size); __gmp_j++) (__gmp_dst)[__gmp_j] = (__gmp_src)[__gmp_j]; } while (0); (__gmp_c) = 0; break; } } } else { if ((__gmp_src) != (__gmp_dst)) do { mp_size_t __gmp_j; ; for (__gmp_j = (1); __gmp_j < (__gmp_size); __gmp_j++) (__gmp_dst)[__gmp_j] = (__gmp_src)[__gmp_j]; } while (0); (__gmp_c) = 0; } } while (0);
+  return __gmp_c;
+}
+extern __inline__ __attribute__ ((__gnu_inline__))
+int
+__gmpn_cmp (mp_srcptr __gmp_xp, mp_srcptr __gmp_yp, mp_size_t __gmp_size) throw ()
+{
+  int __gmp_result;
+  do { mp_size_t __gmp_i; mp_limb_t __gmp_x, __gmp_y; (__gmp_result) = 0; __gmp_i = (__gmp_size); while (--__gmp_i >= 0) { __gmp_x = (__gmp_xp)[__gmp_i]; __gmp_y = (__gmp_yp)[__gmp_i]; if (__gmp_x != __gmp_y) { (__gmp_result) = (__gmp_x > __gmp_y ? 1 : -1); break; } } } while (0);
+  return __gmp_result;
+}
+extern __inline__ __attribute__ ((__gnu_inline__))
+mp_limb_t
+__gmpn_sub (mp_ptr __gmp_wp, mp_srcptr __gmp_xp, mp_size_t __gmp_xsize, mp_srcptr __gmp_yp, mp_size_t __gmp_ysize)
+{
+  mp_limb_t __gmp_c;
+  do { mp_size_t __gmp_i; mp_limb_t __gmp_x; __gmp_i = (__gmp_ysize); if (__gmp_i != 0) { if (__gmpn_sub_n (__gmp_wp, __gmp_xp, __gmp_yp, __gmp_i)) { do { if (__gmp_i >= (__gmp_xsize)) { (__gmp_c) = 1; goto __gmp_done; } __gmp_x = (__gmp_xp)[__gmp_i]; } while ((((__gmp_wp)[__gmp_i++] = (__gmp_x - 1) & ((~ (static_cast<mp_limb_t> (0))) >> 0)), __gmp_x == 0)); } } if ((__gmp_wp) != (__gmp_xp)) do { mp_size_t __gmp_j; ; for (__gmp_j = (__gmp_i); __gmp_j < (__gmp_xsize); __gmp_j++) (__gmp_wp)[__gmp_j] = (__gmp_xp)[__gmp_j]; } while (0); (__gmp_c) = 0; __gmp_done: ; } while (0);
+  return __gmp_c;
+}
+extern __inline__ __attribute__ ((__gnu_inline__))
+mp_limb_t
+__gmpn_sub_1 (mp_ptr __gmp_dst, mp_srcptr __gmp_src, mp_size_t __gmp_size, mp_limb_t __gmp_n) throw ()
+{
+  mp_limb_t __gmp_c;
+  do { mp_size_t __gmp_i; mp_limb_t __gmp_x, __gmp_r; __gmp_x = (__gmp_src)[0]; __gmp_r = __gmp_x - (__gmp_n); (__gmp_dst)[0] = __gmp_r; if (((__gmp_x) < ((__gmp_n)))) { (__gmp_c) = 1; for (__gmp_i = 1; __gmp_i < (__gmp_size);) { __gmp_x = (__gmp_src)[__gmp_i]; __gmp_r = __gmp_x - 1; (__gmp_dst)[__gmp_i] = __gmp_r; ++__gmp_i; if (!((__gmp_x) < (1))) { if ((__gmp_src) != (__gmp_dst)) do { mp_size_t __gmp_j; ; for (__gmp_j = (__gmp_i); __gmp_j < (__gmp_size); __gmp_j++) (__gmp_dst)[__gmp_j] = (__gmp_src)[__gmp_j]; } while (0); (__gmp_c) = 0; break; } } } else { if ((__gmp_src) != (__gmp_dst)) do { mp_size_t __gmp_j; ; for (__gmp_j = (1); __gmp_j < (__gmp_size); __gmp_j++) (__gmp_dst)[__gmp_j] = (__gmp_src)[__gmp_j]; } while (0); (__gmp_c) = 0; } } while (0);
+  return __gmp_c;
+}
+extern __inline__ __attribute__ ((__gnu_inline__))
+mp_limb_t
+__gmpn_neg (mp_ptr __gmp_rp, mp_srcptr __gmp_up, mp_size_t __gmp_n)
+{
+  mp_limb_t __gmp_ul, __gmp_cy;
+  __gmp_cy = 0;
+  do {
+      __gmp_ul = *__gmp_up++;
+      *__gmp_rp++ = -__gmp_ul - __gmp_cy;
+      __gmp_cy |= __gmp_ul != 0;
+  } while (--__gmp_n != 0);
+  return __gmp_cy;
+}
+}
+ std::ostream& operator<< (std::ostream &, mpz_srcptr);
+ std::ostream& operator<< (std::ostream &, mpq_srcptr);
+ std::ostream& operator<< (std::ostream &, mpf_srcptr);
+ std::istream& operator>> (std::istream &, mpz_ptr);
+ std::istream& operator>> (std::istream &, mpq_ptr);
+ std::istream& operator>> (std::istream &, mpf_ptr);
+enum
+{
+  GMP_ERROR_NONE = 0,
+  GMP_ERROR_UNSUPPORTED_ARGUMENT = 1,
+  GMP_ERROR_DIVISION_BY_ZERO = 2,
+  GMP_ERROR_SQRT_OF_NEGATIVE = 4,
+  GMP_ERROR_INVALID_ARGUMENT = 8
+};
+extern "C" {
+extern void unlock_stream (FILE *);
+extern void unlock_std_streams (void);
+extern FILE *fopen_unlocked (const char *, const char *);
+extern FILE *fdopen_unlocked (int, const char *);
+extern FILE *freopen_unlocked (const char *, const char *, FILE *);
+extern char **buildargv (const char *) __attribute__ ((__malloc__));
+extern void freeargv (char **);
+extern char **dupargv (char **) __attribute__ ((__malloc__));
+extern void expandargv (int *, char ***);
+extern int writeargv (char **, FILE *);
+extern int countargv (char**);
+extern const char *lbasename (const char *);
+extern const char *dos_lbasename (const char *);
+extern const char *unix_lbasename (const char *);
+extern char *lrealpath (const char *);
+extern char *concat (const char *, ...) __attribute__ ((__malloc__)) __attribute__ ((__sentinel__));
+extern char *reconcat (char *, const char *, ...) __attribute__ ((__malloc__)) __attribute__ ((__sentinel__));
+extern unsigned long concat_length (const char *, ...) __attribute__ ((__sentinel__));
+extern char *concat_copy (char *, const char *, ...) __attribute__ ((__sentinel__));
+extern char *concat_copy2 (const char *, ...) __attribute__ ((__sentinel__));
+extern char *libiberty_concat_ptr;
+extern int fdmatch (int fd1, int fd2);
+extern char * getpwd (void);
+extern long get_run_time (void);
+extern char *make_relative_prefix (const char *, const char *,
+                                   const char *) __attribute__ ((__malloc__));
+extern char *make_relative_prefix_ignore_links (const char *, const char *,
+      const char *) __attribute__ ((__malloc__));
+extern char *choose_temp_base (void) __attribute__ ((__malloc__));
+extern char *make_temp_file (const char *) __attribute__ ((__malloc__));
+extern int unlink_if_ordinary (const char *);
+extern const char *spaces (int count);
+extern int errno_max (void);
+extern const char *strerrno (int);
+extern int strtoerrno (const char *);
+extern char *xstrerror (int);
+extern int signo_max (void);
+extern const char *strsigno (int);
+extern int strtosigno (const char *);
+extern int xatexit (void (*fn) (void));
+extern void xexit (int status) __attribute__ ((__noreturn__));
+extern void xmalloc_set_program_name (const char *);
+extern void xmalloc_failed (size_t) __attribute__ ((__noreturn__));
+extern void *xmalloc (size_t) __attribute__ ((__malloc__));
+extern void *xrealloc (void *, size_t);
+extern void *xcalloc (size_t, size_t) __attribute__ ((__malloc__));
+extern char *xstrdup (const char *) __attribute__ ((__malloc__));
+extern char *xstrndup (const char *, size_t) __attribute__ ((__malloc__));
+extern void *xmemdup (const void *, size_t, size_t) __attribute__ ((__malloc__));
+extern double physmem_total (void);
+extern double physmem_available (void);
+extern unsigned int xcrc32 (const unsigned char *, int, unsigned int);
+extern const unsigned char _hex_value[256];
+extern void hex_init (void);
+extern struct pex_obj *pex_init (int flags, const char *pname,
+     const char *tempbase);
+extern const char *pex_run (struct pex_obj *obj, int flags,
+       const char *executable, char * const *argv,
+       const char *outname, const char *errname,
+       int *err);
+extern const char *pex_run_in_environment (struct pex_obj *obj, int flags,
+                      const char *executable,
+                                           char * const *argv,
+                                           char * const *env,
+                              const char *outname,
+        const char *errname, int *err);
+extern FILE *pex_input_file (struct pex_obj *obj, int flags,
+                             const char *in_name);
+extern FILE *pex_input_pipe (struct pex_obj *obj, int binary);
+extern FILE *pex_read_output (struct pex_obj *, int binary);
+extern FILE *pex_read_err (struct pex_obj *, int binary);
+extern int pex_get_status (struct pex_obj *, int count, int *vector);
+struct pex_time
+{
+  unsigned long user_seconds;
+  unsigned long user_microseconds;
+  unsigned long system_seconds;
+  unsigned long system_microseconds;
+};
+extern int pex_get_times (struct pex_obj *, int count,
+     struct pex_time *vector);
+extern void pex_free (struct pex_obj *);
+extern const char *pex_one (int flags, const char *executable,
+       char * const *argv, const char *pname,
+       const char *outname, const char *errname,
+       int *status, int *err);
+extern int pexecute (const char *, char * const *, const char *,
+                     const char *, char **, char **, int);
+extern int pwait (int, int *, int);
+extern void setproctitle (const char *name, ...);
+extern void stack_limit_increase (unsigned long);
+extern void *C_alloca (size_t) __attribute__ ((__malloc__));
+}
+extern void fancy_abort (const char *, int, const char *) __attribute__ ((__noreturn__));
+        
+        
+        
+        
+        
+        
+        
+        
+        
+        
+        
+        
+        
+struct bitmap_head_def;
+typedef struct bitmap_head_def *bitmap;
+typedef const struct bitmap_head_def *const_bitmap;
+struct simple_bitmap_def;
+typedef struct simple_bitmap_def *sbitmap;
+typedef const struct simple_bitmap_def *const_sbitmap;
+struct rtx_def;
+typedef struct rtx_def *rtx;
+typedef const struct rtx_def *const_rtx;
+struct rtvec_def;
+typedef struct rtvec_def *rtvec;
+typedef const struct rtvec_def *const_rtvec;
+union tree_node;
+typedef union tree_node *tree;
+typedef const union tree_node *const_tree;
+union gimple_statement_d;
+typedef union gimple_statement_d *gimple;
+typedef const union gimple_statement_d *const_gimple;
+typedef gimple gimple_seq;
+union section;
+typedef union section section;
+struct gcc_options;
+struct cl_target_option;
+struct cl_optimization;
+struct cl_option;
+struct cl_decoded_option;
+struct cl_option_handlers;
+struct diagnostic_context;
+typedef struct diagnostic_context diagnostic_context;
+struct pretty_print_info;
+typedef struct pretty_print_info pretty_printer;
+typedef unsigned char addr_space_t;
+enum ir_type {
+  IR_GIMPLE,
+  IR_RTL_CFGRTL,
+  IR_RTL_CFGLAYOUT
+};
+struct cpp_reader;
+struct cpp_token;
+enum tls_model {
+  TLS_MODEL_NONE,
+  TLS_MODEL_EMULATED,
+  TLS_MODEL_REAL,
+  TLS_MODEL_GLOBAL_DYNAMIC = TLS_MODEL_REAL,
+  TLS_MODEL_LOCAL_DYNAMIC,
+  TLS_MODEL_INITIAL_EXEC,
+  TLS_MODEL_LOCAL_EXEC
+};
+enum unwind_info_type
+{
+  UI_NONE,
+  UI_SJLJ,
+  UI_DWARF2,
+  UI_TARGET,
+  UI_SEH
+};
+enum node_frequency {
+  NODE_FREQUENCY_UNLIKELY_EXECUTED,
+  NODE_FREQUENCY_EXECUTED_ONCE,
+  NODE_FREQUENCY_NORMAL,
+  NODE_FREQUENCY_HOT
+};
+enum var_init_status
+{
+  VAR_INIT_STATUS_UNKNOWN,
+  VAR_INIT_STATUS_UNINITIALIZED,
+  VAR_INIT_STATUS_INITIALIZED
+};
+struct edge_def;
+typedef struct edge_def *edge;
+typedef const struct edge_def *const_edge;
+struct basic_block_def;
+typedef struct basic_block_def *basic_block;
+typedef const struct basic_block_def *const_basic_block;
+typedef int reg_class_t;
+enum memmodel
+{
+  MEMMODEL_RELAXED = 0,
+  MEMMODEL_CONSUME = 1,
+  MEMMODEL_ACQUIRE = 2,
+  MEMMODEL_RELEASE = 3,
+  MEMMODEL_ACQ_REL = 4,
+  MEMMODEL_SEQ_CST = 5,
+  MEMMODEL_LAST = 6
+};
+typedef void (*gt_pointer_operator) (void *, void *);
+typedef unsigned char uchar;
+enum debug_info_type
+{
+  NO_DEBUG,
+  DBX_DEBUG,
+  SDB_DEBUG,
+  DWARF2_DEBUG,
+  XCOFF_DEBUG,
+  VMS_DEBUG,
+  VMS_AND_DWARF2_DEBUG
+};
+enum debug_info_levels
+{
+  DINFO_LEVEL_NONE,
+  DINFO_LEVEL_TERSE,
+  DINFO_LEVEL_NORMAL,
+  DINFO_LEVEL_VERBOSE
+};
+enum debug_info_usage
+{
+  DINFO_USAGE_DFN,
+  DINFO_USAGE_DIR_USE,
+  DINFO_USAGE_IND_USE,
+  DINFO_USAGE_NUM_ENUMS
+};
+enum debug_struct_file
+{
+  DINFO_STRUCT_FILE_NONE,
+  DINFO_STRUCT_FILE_BASE,
+  DINFO_STRUCT_FILE_SYS,
+  DINFO_STRUCT_FILE_ANY
+};
+enum symbol_visibility
+{
+  VISIBILITY_DEFAULT,
+  VISIBILITY_PROTECTED,
+  VISIBILITY_HIDDEN,
+  VISIBILITY_INTERNAL
+};
+enum stack_reuse_level
+{
+  SR_NONE,
+  SR_NAMED_VARS,
+  SR_ALL
+};
+enum ira_algorithm
+{
+  IRA_ALGORITHM_CB,
+  IRA_ALGORITHM_PRIORITY
+};
+enum ira_region
+{
+  IRA_REGION_ONE,
+  IRA_REGION_ALL,
+  IRA_REGION_MIXED,
+  IRA_REGION_AUTODETECT
+};
+enum excess_precision
+{
+  EXCESS_PRECISION_DEFAULT,
+  EXCESS_PRECISION_FAST,
+  EXCESS_PRECISION_STANDARD
+};
+enum stack_check_type
+{
+  NO_STACK_CHECK = 0,
+  GENERIC_STACK_CHECK,
+  STATIC_BUILTIN_STACK_CHECK,
+  FULL_BUILTIN_STACK_CHECK
+};
+enum warn_strict_overflow_code
+{
+  WARN_STRICT_OVERFLOW_ALL = 1,
+  WARN_STRICT_OVERFLOW_CONDITIONAL = 2,
+  WARN_STRICT_OVERFLOW_COMPARISON = 3,
+  WARN_STRICT_OVERFLOW_MISC = 4,
+  WARN_STRICT_OVERFLOW_MAGNITUDE = 5
+};
+enum fp_contract_mode {
+  FP_CONTRACT_OFF = 0,
+  FP_CONTRACT_ON = 1,
+  FP_CONTRACT_FAST = 2
+};
+struct gcc_options
+{
+  long long x_frame_larger_than_size;
+  long long x_larger_than_size;
+  bool x_exit_after_options;
+  bool x_flag_dump_all_passed;
+  bool x_flag_opts_finished;
+  bool x_flag_stack_usage_info;
+  bool x_flag_warn_unused_result;
+  bool x_in_lto_p;
+  bool x_use_gnu_debug_info_extensions;
+  bool x_warn_frame_larger_than;
+  bool x_warn_larger_than;
+  char * x_help_enum_printed;
+  char * x_help_printed;
+  const char * x_main_input_basename;
+  const char * x_main_input_filename;
+  enum debug_info_levels x_debug_info_level;
+  enum debug_info_type x_write_symbols;
+  enum debug_struct_file x_debug_struct_generic[DINFO_USAGE_NUM_ENUMS];
+  enum debug_struct_file x_debug_struct_ordinary[DINFO_USAGE_NUM_ENUMS];
+  enum stack_check_type x_flag_stack_check;
+  int * x_param_values;
+  int x_flag_complex_method;
+  int x_flag_debug_asm;
+  int x_flag_dump_rtl_in_asm;
+  int x_flag_evaluation_order;
+  int x_flag_gen_aux_info;
+  int x_flag_generate_lto;
+  int x_flag_print_asm_name;
+  int x_flag_shlib;
+  int x_main_input_baselength;
+  int x_optimize;
+  int x_optimize_debug;
+  int x_optimize_fast;
+  int x_optimize_size;
+  int x_rtl_dump_and_exit;
+  int x_target_flags;
+  unsigned int x_help_columns;
+  unsigned int x_initial_max_fld_align;
+  void * x_flag_instrument_functions_exclude_files;
+  void * x_flag_instrument_functions_exclude_functions;
+  int x_help_flag;
+  int x_no_sysroot_suffix;
+  int x_flag_preprocess_only;
+  int x_warn_abi;
+  int x_warn_abi_tag;
+  int x_warn_address;
+  int x_warn_aggregate_return;
+  int x_warn_aggressive_loop_optimizations;
+  int x_warn_array_bounds;
+  int x_warn_assign_intercept;
+  int x_warn_attributes;
+  int x_warn_bad_function_cast;
+  int x_warn_branch_probabilities_computation;
+  int x_warn_cxx_compat;
+  int x_warn_cxx0x_compat;
+  int x_warn_cast_align;
+  int x_warn_cast_qual;
+  int x_warn_char_subscripts;
+  int x_warn_clobbered;
+  int x_warn_conversion;
+  int x_warn_conversion_null;
+  int x_warn_coverage_mismatch;
+  int x_warn_cpp;
+  int x_warn_ctor_dtor_privacy;
+  int x_warn_declaration_after_statement;
+  int x_warn_delnonvdtor;
+  int x_warn_deprecated;
+  int x_warn_deprecated_decl;
+  int x_warn_disabled_optimization;
+  int x_warn_div_by_zero;
+  int x_warn_double_promotion;
+  int x_warn_ecpp;
+  int x_warn_empty_body;
+  int x_warn_enum_compare;
+  int x_warnings_are_errors;
+  int x_extra_warnings;
+  int x_flag_extraneous_semicolon;
+  int x_flag_fatal_errors;
+  int x_warn_float_equal;
+  int x_warn_format_contains_nul;
+  int x_warn_format_extra_args;
+  int x_warn_format_nonliteral;
+  int x_warn_format_security;
+  int x_warn_format_y2k;
+  int x_warn_format_zero_length;
+  int x_warn_format;
+  int x_warn_free_nonheap_object;
+  int x_warn_ignored_qualifiers;
+  int x_warn_implicit;
+  int x_warn_implicit_function_declaration;
+  int x_warn_implicit_int;
+  int x_warn_inh_var_ctor;
+  int x_warn_init_self;
+  int x_warn_inline;
+  int x_warn_int_to_pointer_cast;
+  int x_warn_invalid_memory_model;
+  int x_warn_invalid_offsetof;
+  int x_warn_jump_misses_init;
+  int x_warn_logical_op;
+  int x_warn_long_long;
+  int x_warn_main;
+  int x_warn_maybe_uninitialized;
+  int x_warn_missing_braces;
+  int x_warn_missing_declarations;
+  int x_warn_missing_field_initializers;
+  int x_warn_missing_parameter_type;
+  int x_warn_missing_prototypes;
+  int x_warn_mudflap;
+  int x_warn_narrowing;
+  int x_warn_nested_externs;
+  int x_warn_noexcept;
+  int x_warn_non_finite_math;
+  int x_warn_nontemplate_friend;
+  int x_warn_nonvdtor;
+  int x_warn_nonnull;
+  int x_warn_old_style_cast;
+  int x_warn_old_style_declaration;
+  int x_warn_old_style_definition;
+  int x_flag_newer;
+  int x_warn_overflow;
+  int x_warn_overlength_strings;
+  int x_warn_overloaded_virtual;
+  int x_warn_override_init;
+  int x_warn_packed;
+  int x_warn_packed_bitfield_compat;
+  int x_warn_padded;
+  int x_warn_parentheses;
+  int x_pedantic;
+  int x_warn_pmf2ptr;
+  int x_warn_pointer_arith;
+  int x_warn_pointer_sign;
+  int x_warn_pointer_to_int_cast;
+  int x_warn_pragmas;
+  int x_warn_property_assign_default;
+  int x_warn_protocol;
+  int x_warn_psabi;
+  int x_warn_redundant_decls;
+  int x_flag_redundant;
+  int x_warn_reorder;
+  int x_warn_return_local_addr;
+  int x_warn_return_type;
+  int x_warn_selector;
+  int x_warn_sequence_point;
+  int x_warn_shadow;
+  int x_warn_sign_compare;
+  int x_warn_sign_conversion;
+  int x_warn_sign_promo;
+  int x_warn_sizeof_pointer_memaccess;
+  int x_warn_stack_protect;
+  int x_warn_stack_usage;
+  int x_warn_strict_aliasing;
+  int x_warn_strict_null_sentinel;
+  int x_warn_strict_overflow;
+  int x_warn_strict_prototypes;
+  int x_warn_strict_selector_match;
+  int x_warn_suggest_attribute_const;
+  int x_warn_suggest_attribute_format;
+  int x_warn_suggest_attribute_noreturn;
+  int x_warn_suggest_attribute_pure;
+  int x_warn_switch;
+  int x_warn_switch_default;
+  int x_warn_switch_enum;
+  int x_warn_sync_nand;
+  int x_warn_synth;
+  int x_warn_system_headers;
+  int x_warn_traditional;
+  int x_warn_traditional_conversion;
+  int x_warn_trampolines;
+  int x_warn_type_limits;
+  int x_warn_undeclared_selector;
+  int x_warn_uninitialized;
+  int x_warn_unknown_pragmas;
+  int x_warn_unsafe_loop_optimizations;
+  int x_warn_unsuffixed_float_constants;
+  int x_warn_unused;
+  int x_warn_unused_but_set_parameter;
+  int x_warn_unused_but_set_variable;
+  int x_warn_unused_function;
+  int x_warn_unused_label;
+  int x_warn_unused_local_typedefs;
+  int x_cpp_warn_unused_macros;
+  int x_warn_unused_parameter;
+  int x_warn_unused_result;
+  int x_warn_unused_value;
+  int x_warn_unused_variable;
+  int x_warn_useless_cast;
+  int x_warn_varargs;
+  int x_cpp_warn_variadic_macros;
+  int x_warn_vector_operation_performance;
+  int x_warn_virtual_move_assign;
+  int x_warn_vla;
+  int x_warn_volatile_register_var;
+  int x_warn_write_strings;
+  int x_warn_zero_as_null_pointer_constant;
+  const char *x_aux_info_file_name;
+  const char *x_aux_base_name;
+  const char *x_dump_base_name;
+  const char *x_dump_dir_name;
+  int x_flag_pic;
+  int x_flag_pie;
+  int x_flag_abi_version;
+  int x_flag_access_control;
+  const char *x_ada_specs_parent;
+  int x_flag_aggressive_loop_optimizations;
+  int x_align_functions;
+  int x_align_jumps;
+  int x_align_labels;
+  int x_align_loops;
+  int x_flag_allow_parameterless_variadic_functions;
+  int x_flag_no_asm;
+  int x_flag_assert;
+  int x_flag_associative_math;
+  int x_flag_asynchronous_unwind_tables;
+  int x_flag_auto_inc_dec;
+  int x_flag_bootstrap_classes;
+  int x_flag_bounds_check;
+  int x_flag_branch_on_count_reg;
+  int x_flag_branch_probabilities;
+  int x_flag_branch_target_load_optimize;
+  int x_flag_branch_target_load_optimize2;
+  int x_flag_btr_bb_exclusive;
+  int x_flag_building_libgcc;
+  int x_flag_no_builtin;
+  void *x_common_deferred_options;
+  int x_flag_caller_saves;
+  int x_flag_check_data_deps;
+  int x_flag_check_new;
+  int x_flag_check_references;
+  int x_flag_combine_stack_adjustments;
+  int x_flag_no_common;
+  int x_flag_compare_debug;
+  const char *x_flag_compare_debug_opt;
+  int x_flag_compare_elim_after_reload;
+  int x_flag_conserve_space;
+  int x_flag_conserve_stack;
+  int x_max_constexpr_depth;
+  int x_flag_cprop_registers;
+  int x_flag_crossjumping;
+  int x_flag_cse_follow_jumps;
+  int x_flag_cse_sincos;
+  int x_flag_cx_fortran_rules;
+  int x_flag_cx_limited_range;
+  int x_flag_data_sections;
+  int x_flag_dce;
+  int x_flag_debug_types_section;
+  int x_flag_deduce_init_list;
+  int x_flag_defer_pop;
+  int x_flag_delayed_branch;
+  int x_flag_delete_dead_exceptions;
+  int x_flag_delete_null_pointer_checks;
+  int x_flag_devirtualize;
+  int x_flag_diagnostics_show_caret;
+  int x_flag_diagnostics_show_option;
+  int x_flag_dse;
+  int x_flag_dump_ada_spec;
+  int x_flag_dump_ada_spec_slim;
+  const char *x_flag_dump_final_insns;
+  const char *x_flag_dump_go_spec;
+  int x_flag_dump_noaddr;
+  int x_flag_dump_passes;
+  int x_flag_dump_unnumbered;
+  int x_flag_dump_unnumbered_links;
+  int x_flag_dwarf2_cfi_asm;
+  int x_flag_early_inlining;
+  int x_flag_elide_constructors;
+  int x_flag_eliminate_dwarf2_dups;
+  int x_flag_debug_only_used_symbols;
+  int x_flag_eliminate_unused_debug_types;
+  int x_flag_emit_class_debug_always;
+  int x_flag_emit_class_files;
+  int x_flag_enforce_eh_specs;
+  int x_flag_exceptions;
+  enum excess_precision x_flag_excess_precision_cmdline;
+  int x_flag_expensive_optimizations;
+  int x_flag_extern_tls_init;
+  int x_flag_fat_lto_objects;
+  int x_flag_filelist_file;
+  int x_flag_finite_math_only;
+  int x_flag_float_store;
+  int x_flag_new_for_scope;
+  int x_flag_force_classes_archive_check;
+  int x_flag_forward_propagate;
+  enum fp_contract_mode x_flag_fp_contract_mode;
+  int x_flag_friend_injection;
+  int x_flag_no_function_cse;
+  int x_flag_function_sections;
+  int x_flag_gcse;
+  int x_flag_gcse_after_reload;
+  int x_flag_gcse_las;
+  int x_flag_gcse_lm;
+  int x_flag_gcse_sm;
+  int x_flag_no_gnu_keywords;
+  int x_flag_next_runtime;
+  int x_flag_tm;
+  int x_flag_gnu89_inline;
+  int x_go_check_divide_overflow;
+  int x_go_check_divide_zero;
+  int x_flag_graphite;
+  int x_flag_graphite_identity;
+  int x_flag_guess_branch_prob;
+  int x_flag_hash_synchronization;
+  int x_flag_hoist_adjacent_loads;
+  int x_flag_no_ident;
+  int x_flag_if_conversion;
+  int x_flag_if_conversion2;
+  int x_flag_implement_inlines;
+  int x_flag_implicit_inline_templates;
+  int x_flag_implicit_templates;
+  int x_flag_indirect_classes;
+  int x_flag_indirect_dispatch;
+  int x_flag_indirect_inlining;
+  int x_flag_inhibit_size_directive;
+  int x_flag_no_inline;
+  int x_flag_inline_atomics;
+  int x_flag_inline_functions;
+  int x_flag_inline_functions_called_once;
+  int x_flag_inline_small_functions;
+  int x_flag_instrument_function_entry_exit;
+  int x_flag_ipa_cp;
+  int x_flag_ipa_cp_clone;
+  int x_flag_ipa_profile;
+  int x_flag_ipa_pta;
+  int x_flag_ipa_pure_const;
+  int x_flag_ipa_reference;
+  int x_flag_ipa_sra;
+  enum ira_algorithm x_flag_ira_algorithm;
+  int x_flag_ira_hoist_pressure;
+  int x_flag_ira_loop_pressure;
+  enum ira_region x_flag_ira_region;
+  int x_flag_ira_share_save_slots;
+  int x_flag_ira_share_spill_slots;
+  int x_flag_ira_verbose;
+  int x_flag_ivopts;
+  int x_flag_jni;
+  int x_flag_jump_tables;
+  int x_flag_keep_inline_dllexport;
+  int x_flag_keep_inline_functions;
+  int x_flag_keep_static_consts;
+  int x_flag_lax_vector_conversions;
+  int x_flag_leading_underscore;
+  int x_flag_loop_block;
+  int x_flag_loop_interchange;
+  int x_flag_loop_optimize_isl;
+  int x_flag_loop_parallelize_all;
+  int x_flag_loop_strip_mine;
+  int x_flag_lto_compression_level;
+  int x_flag_lto_partition_1to1;
+  int x_flag_lto_partition_balanced;
+  int x_flag_lto_partition_max;
+  int x_flag_lto_partition_none;
+  int x_flag_lto_report;
+  const char *x_flag_lto;
+  int x_flag_ltrans;
+  const char *x_ltrans_output_list;
+  int x_flag_errno_math;
+  int x_flag_max_errors;
+  int x_mem_report;
+  int x_mem_report_wpa;
+  int x_flag_merge_constants;
+  int x_flag_merge_debug_strings;
+  int x_flag_modulo_sched;
+  int x_flag_modulo_sched_allow_regmoves;
+  int x_flag_move_loop_invariants;
+  int x_flag_ms_extensions;
+  int x_flag_mudflap;
+  int x_flag_mudflap_ignore_reads;
+  int x_flag_nil_receivers;
+  int x_flag_non_call_exceptions;
+  int x_flag_no_nonansi_builtin;
+  int x_flag_nothrow_opt;
+  int x_flag_objc_abi;
+  int x_flag_objc_call_cxx_cdtors;
+  int x_flag_objc_direct_dispatch;
+  int x_flag_objc_exceptions;
+  int x_flag_objc_gc;
+  int x_flag_objc_nilcheck;
+  int x_flag_objc_sjlj_exceptions;
+  int x_flag_objc1_only;
+  int x_flag_omit_frame_pointer;
+  int x_flag_openmp;
+  int x_flag_opt_info;
+  int x_flag_regmove;
+  int x_flag_optimize_sibling_calls;
+  int x_flag_optimize_sci;
+  int x_flag_optimize_strlen;
+  int x_flag_pack_struct;
+  int x_flag_partial_inlining;
+  int x_flag_pcc_struct_return;
+  int x_flag_peel_loops;
+  int x_flag_no_peephole;
+  int x_flag_peephole2;
+  int x_flag_permissive;
+  int x_flag_plan9_extensions;
+  int x_post_ipa_mem_report;
+  int x_pre_ipa_mem_report;
+  int x_flag_predictive_commoning;
+  int x_flag_prefetch_loop_arrays;
+  int x_flag_pretty_templates;
+  int x_profile_flag;
+  int x_profile_arc_flag;
+  int x_flag_profile_correction;
+  const char *x_profile_data_prefix;
+  int x_profile_report;
+  int x_flag_profile_use;
+  int x_flag_profile_values;
+  int x_flag_reciprocal_math;
+  int x_flag_record_gcc_switches;
+  int x_flag_reduced_reflection;
+  int x_flag_ree;
+  int x_flag_rename_registers;
+  int x_flag_reorder_blocks;
+  int x_flag_reorder_blocks_and_partition;
+  int x_flag_reorder_functions;
+  int x_flag_replace_objc_classes;
+  int x_go_require_return_statement;
+  int x_flag_rerun_cse_after_loop;
+  int x_flag_resched_modulo_sched;
+  int x_flag_rounding_math;
+  int x_flag_rtti;
+  int x_flag_asan;
+  int x_flag_tsan;
+  int x_flag_sched_critical_path_heuristic;
+  int x_flag_sched_dep_count_heuristic;
+  int x_flag_sched_group_heuristic;
+  int x_flag_schedule_interblock;
+  int x_flag_sched_last_insn_heuristic;
+  int x_flag_sched_pressure;
+  int x_flag_sched_rank_heuristic;
+  int x_flag_schedule_speculative;
+  int x_flag_sched_spec_insn_heuristic;
+  int x_flag_schedule_speculative_load;
+  int x_flag_schedule_speculative_load_dangerous;
+  int x_flag_sched_stalled_insns;
+  int x_flag_sched_stalled_insns_dep;
+  int x_sched_verbose_param;
+  int x_flag_sched2_use_superblocks;
+  int x_flag_schedule_insns;
+  int x_flag_schedule_insns_after_reload;
+  int x_flag_section_anchors;
+  int x_flag_sel_sched_pipelining;
+  int x_flag_sel_sched_pipelining_outer_loops;
+  int x_flag_sel_sched_reschedule_pipelined;
+  int x_flag_selective_scheduling;
+  int x_flag_selective_scheduling2;
+  int x_flag_short_double;
+  int x_flag_short_enums;
+  int x_flag_short_wchar;
+  int x_flag_show_column;
+  int x_flag_shrink_wrap;
+  int x_flag_signaling_nans;
+  int x_flag_signed_bitfields;
+  int x_flag_signed_char;
+  int x_flag_signed_zeros;
+  int x_flag_single_precision_constant;
+  int x_flag_split_ivs_in_unroller;
+  int x_flag_split_stack;
+  int x_flag_split_wide_types;
+  int x_flag_stack_protect;
+  enum stack_reuse_level x_flag_stack_reuse;
+  int x_flag_stack_usage;
+  int x_flag_detailed_statistics;
+  int x_flag_store_check;
+  int x_flag_strict_aliasing;
+  int x_flag_strict_enums;
+  int x_flag_strict_overflow;
+  int x_flag_strict_volatile_bitfields;
+  int x_flag_sync_libcalls;
+  int x_flag_syntax_only;
+  int x_template_backtrace_limit;
+  int x_flag_test_coverage;
+  int x_flag_thread_jumps;
+  int x_flag_threadsafe_statics;
+  int x_time_report;
+  enum tls_model x_flag_tls_default;
+  int x_flag_toplevel_reorder;
+  int x_flag_tracer;
+  int x_flag_trapping_math;
+  int x_flag_trapv;
+  int x_flag_tree_bit_ccp;
+  int x_flag_tree_builtin_call_dce;
+  int x_flag_tree_ccp;
+  int x_flag_tree_ch;
+  int x_flag_ssa_coalesce_vars;
+  int x_flag_tree_copy_prop;
+  int x_flag_tree_copyrename;
+  int x_flag_tree_cselim;
+  int x_flag_tree_dce;
+  int x_flag_tree_dom;
+  int x_flag_tree_dse;
+  int x_flag_tree_forwprop;
+  int x_flag_tree_fre;
+  int x_flag_tree_loop_distribute_patterns;
+  int x_flag_tree_loop_distribution;
+  int x_flag_tree_loop_if_convert;
+  int x_flag_tree_loop_if_convert_stores;
+  int x_flag_tree_loop_im;
+  int x_flag_tree_loop_ivcanon;
+  int x_flag_tree_loop_optimize;
+  int x_flag_tree_live_range_split;
+  int x_flag_tree_parallelize_loops;
+  int x_flag_tree_partial_pre;
+  int x_flag_tree_phiprop;
+  int x_flag_tree_pre;
+  int x_flag_tree_pta;
+  int x_flag_tree_reassoc;
+  int x_flag_tree_scev_cprop;
+  int x_flag_tree_sink;
+  int x_flag_tree_slp_vectorize;
+  int x_flag_tree_slsr;
+  int x_flag_tree_sra;
+  int x_flag_tree_switch_conversion;
+  int x_flag_tree_tail_merge;
+  int x_flag_tree_ter;
+  int x_flag_tree_vect_loop_version;
+  int x_flag_tree_vectorize;
+  int x_flag_tree_vrp;
+  int x_flag_unit_at_a_time;
+  int x_flag_unroll_all_loops;
+  int x_flag_unroll_loops;
+  int x_flag_unsafe_loop_optimizations;
+  int x_flag_unsafe_math_optimizations;
+  int x_flag_unswitch_loops;
+  int x_flag_unwind_tables;
+  int x_flag_use_atomic_builtins;
+  int x_flag_use_boehm_gc;
+  int x_flag_use_cxa_atexit;
+  int x_flag_use_cxa_get_exception_ptr;
+  int x_flag_use_divide_subroutine;
+  int x_flag_var_tracking;
+  int x_flag_var_tracking_assignments;
+  int x_flag_var_tracking_assignments_toggle;
+  int x_flag_var_tracking_uninit;
+  int x_flag_variable_expansion_in_unroller;
+  int x_flag_vect_cost_model;
+  int x_flag_verbose_asm;
+  int x_flag_visibility_ms_compat;
+  enum symbol_visibility x_default_visibility;
+  int x_flag_value_profile_transformations;
+  int x_flag_weak;
+  int x_flag_web;
+  int x_flag_whole_program;
+  int x_flag_working_directory;
+  int x_flag_wpa;
+  int x_flag_wrapv;
+  int x_flag_zero_initialized_in_bss;
+  int x_flag_zero_link;
+  int x_dwarf_version;
+  int x_flag_gen_declaration;
+  int x_debug_generate_pub_sections;
+  int x_dwarf_record_gcc_switches;
+  int x_dwarf_split_debug_info;
+  int x_dwarf_strict;
+  int x_flag_gtoggle;
+  const char *x_imultiarch;
+  const char *x_plugindir_string;
+  int x_TARGET_SH4_300;
+  int x_TARGET_ACCUMULATE_OUTGOING_ARGS;
+  int x_sh_align_small_blocks;
+  int x_flag_android;
+  const char *x_sh_atomic_model_str;
+  int x_linux_libc;
+  int x_sh_branch_cost;
+  int x_TARGET_CBRANCHDI4;
+  int x_TARGET_CMPEQDI_T;
+  int x_TARGET_SH5_CUT2_WORKAROUND;
+  int x_TARGET_DBHWBUG;
+  const char *x_sh_div_str;
+  const char *x_sh_divsi3_libfunc;
+  const char *x_sh_fixed_range_str;
+  int x_TARGET_FLDI;
+  int x_TARGET_FSCA;
+  int x_TARGET_FSRRA;
+  int x_sh_gettrcost;
+  int x_TARGET_IEEE;
+  int x_TARGET_INLINE_IC_INVALIDATE;
+  int x_TARGET_R0R3_TO_REG_MUL;
+  int x_TARGET_PRETEND_CMOVE;
+  int x_TARGET_ENABLE_TAS;
+  int x_sh_multcost;
+  int x_TARGET_USERMODE;
+  int x_TARGET_ZDCBRANCH;
+  const char *x_asm_file_name;
+  int x_pass_exit_codes;
+  int x_flag_pedantic_errors;
+  int x_use_pipes;
+  const char *x_print_file_name;
+  int x_print_multi_directory;
+  int x_print_multi_lib;
+  int x_print_multi_os_directory;
+  int x_print_multiarch;
+  const char *x_print_prog_name;
+  int x_print_search_dirs;
+  int x_print_sysroot;
+  int x_print_sysroot_headers_suffix;
+  int x_quiet_flag;
+  int x_report_times;
+  int x_flag_undef;
+  int x_verbose_flag;
+  int x_version_flag;
+  int x_inhibit_warnings;
+  const char *x_wrapper_string;
+  int x_VAR_m2a;
+  int x_VAR_m2a_nofpu;
+  int x_VAR_m2a_single;
+  int x_VAR_m2a_single_only;
+  int x_VAR_m2e;
+  int x_VAR_m3e;
+  int x_VAR_m4_100;
+  int x_VAR_m4_100_nofpu;
+  int x_VAR_m4_100_single;
+  int x_VAR_m4_100_single_only;
+  int x_VAR_m4_200;
+  int x_VAR_m4_200_nofpu;
+  int x_VAR_m4_200_single;
+  int x_VAR_m4_200_single_only;
+  int x_VAR_m4_400;
+  int x_VAR_m4_500;
+  int x_VAR_m4_nofpu;
+  int x_VAR_m4_single;
+  int x_VAR_m4_single_only;
+  int x_VAR_m4a_nofpu;
+  int x_VAR_m4a_single;
+  int x_VAR_m4a_single_only;
+  int x_VAR_m4al;
+  int x_VAR_m5_32media;
+  int x_VAR_m5_32media_nofpu;
+  int x_VAR_m5_64media;
+  int x_VAR_m5_64media_nofpu;
+  int x_VAR_m5_compact;
+  int x_VAR_m5_compact_nofpu;
+  bool frontend_set_flag_associative_math;
+  bool frontend_set_flag_cx_limited_range;
+  bool frontend_set_flag_finite_math_only;
+  bool frontend_set_flag_errno_math;
+  bool frontend_set_flag_reciprocal_math;
+  bool frontend_set_flag_rounding_math;
+  bool frontend_set_flag_signaling_nans;
+  bool frontend_set_flag_signed_zeros;
+  bool frontend_set_flag_trapping_math;
+  bool frontend_set_flag_unsafe_math_optimizations;
+};
+extern struct gcc_options global_options;
+extern const struct gcc_options global_options_init;
+extern struct gcc_options global_options_set;
+struct cl_optimization
+{
+  int x_align_functions;
+  int x_align_jumps;
+  int x_align_labels;
+  int x_align_loops;
+  int x_flag_sched_stalled_insns;
+  int x_flag_sched_stalled_insns_dep;
+  enum fp_contract_mode x_flag_fp_contract_mode;
+  unsigned char x_optimize;
+  unsigned char x_optimize_size;
+  signed char x_flag_aggressive_loop_optimizations;
+  signed char x_flag_asynchronous_unwind_tables;
+  signed char x_flag_branch_on_count_reg;
+  signed char x_flag_branch_probabilities;
+  signed char x_flag_branch_target_load_optimize;
+  signed char x_flag_branch_target_load_optimize2;
+  signed char x_flag_btr_bb_exclusive;
+  signed char x_flag_caller_saves;
+  signed char x_flag_combine_stack_adjustments;
+  signed char x_flag_no_common;
+  signed char x_flag_compare_elim_after_reload;
+  signed char x_flag_conserve_stack;
+  signed char x_flag_cprop_registers;
+  signed char x_flag_crossjumping;
+  signed char x_flag_cse_follow_jumps;
+  signed char x_flag_cse_sincos;
+  signed char x_flag_cx_fortran_rules;
+  signed char x_flag_cx_limited_range;
+  signed char x_flag_data_sections;
+  signed char x_flag_dce;
+  signed char x_flag_defer_pop;
+  signed char x_flag_delayed_branch;
+  signed char x_flag_delete_null_pointer_checks;
+  signed char x_flag_devirtualize;
+  signed char x_flag_dse;
+  signed char x_flag_early_inlining;
+  signed char x_flag_exceptions;
+  signed char x_flag_expensive_optimizations;
+  signed char x_flag_finite_math_only;
+  signed char x_flag_float_store;
+  signed char x_flag_forward_propagate;
+  signed char x_flag_gcse;
+  signed char x_flag_gcse_after_reload;
+  signed char x_flag_gcse_las;
+  signed char x_flag_gcse_lm;
+  signed char x_flag_gcse_sm;
+  signed char x_flag_graphite_identity;
+  signed char x_flag_guess_branch_prob;
+  signed char x_flag_hoist_adjacent_loads;
+  signed char x_flag_if_conversion;
+  signed char x_flag_if_conversion2;
+  signed char x_flag_no_inline;
+  signed char x_flag_inline_atomics;
+  signed char x_flag_inline_functions;
+  signed char x_flag_inline_functions_called_once;
+  signed char x_flag_inline_small_functions;
+  signed char x_flag_ipa_cp;
+  signed char x_flag_ipa_cp_clone;
+  signed char x_flag_ipa_profile;
+  signed char x_flag_ipa_pta;
+  signed char x_flag_ipa_pure_const;
+  signed char x_flag_ipa_reference;
+  signed char x_flag_ipa_sra;
+  signed char x_flag_ira_hoist_pressure;
+  signed char x_flag_ivopts;
+  signed char x_flag_jump_tables;
+  signed char x_flag_loop_block;
+  signed char x_flag_loop_interchange;
+  signed char x_flag_loop_optimize_isl;
+  signed char x_flag_loop_parallelize_all;
+  signed char x_flag_loop_strip_mine;
+  signed char x_flag_errno_math;
+  signed char x_flag_merge_constants;
+  signed char x_flag_modulo_sched;
+  signed char x_flag_move_loop_invariants;
+  signed char x_flag_non_call_exceptions;
+  signed char x_flag_nothrow_opt;
+  signed char x_flag_omit_frame_pointer;
+  signed char x_flag_opt_info;
+  signed char x_flag_regmove;
+  signed char x_flag_optimize_sibling_calls;
+  signed char x_flag_optimize_strlen;
+  signed char x_flag_pack_struct;
+  signed char x_flag_peel_loops;
+  signed char x_flag_no_peephole;
+  signed char x_flag_peephole2;
+  signed char x_flag_predictive_commoning;
+  signed char x_flag_prefetch_loop_arrays;
+  signed char x_flag_pcc_struct_return;
+  signed char x_flag_rename_registers;
+  signed char x_flag_reorder_blocks;
+  signed char x_flag_reorder_blocks_and_partition;
+  signed char x_flag_reorder_functions;
+  signed char x_flag_rerun_cse_after_loop;
+  signed char x_flag_resched_modulo_sched;
+  signed char x_flag_rounding_math;
+  signed char x_flag_rtti;
+  signed char x_flag_sched_critical_path_heuristic;
+  signed char x_flag_sched_dep_count_heuristic;
+  signed char x_flag_sched_group_heuristic;
+  signed char x_flag_schedule_interblock;
+  signed char x_flag_sched_last_insn_heuristic;
+  signed char x_flag_sched_pressure;
+  signed char x_flag_sched_rank_heuristic;
+  signed char x_flag_schedule_speculative;
+  signed char x_flag_sched_spec_insn_heuristic;
+  signed char x_flag_schedule_speculative_load;
+  signed char x_flag_schedule_speculative_load_dangerous;
+  signed char x_flag_sched2_use_superblocks;
+  signed char x_flag_schedule_insns;
+  signed char x_flag_schedule_insns_after_reload;
+  signed char x_flag_section_anchors;
+  signed char x_flag_sel_sched_pipelining;
+  signed char x_flag_sel_sched_pipelining_outer_loops;
+  signed char x_flag_sel_sched_reschedule_pipelined;
+  signed char x_flag_selective_scheduling;
+  signed char x_flag_selective_scheduling2;
+  signed char x_flag_short_double;
+  signed char x_flag_short_enums;
+  signed char x_flag_short_wchar;
+  signed char x_flag_shrink_wrap;
+  signed char x_flag_signaling_nans;
+  signed char x_flag_signed_zeros;
+  signed char x_flag_single_precision_constant;
+  signed char x_flag_split_ivs_in_unroller;
+  signed char x_flag_split_wide_types;
+  signed char x_flag_strict_aliasing;
+  signed char x_flag_strict_enums;
+  signed char x_flag_thread_jumps;
+  signed char x_flag_threadsafe_statics;
+  signed char x_flag_toplevel_reorder;
+  signed char x_flag_trapping_math;
+  signed char x_flag_trapv;
+  signed char x_flag_tree_bit_ccp;
+  signed char x_flag_tree_builtin_call_dce;
+  signed char x_flag_tree_ccp;
+  signed char x_flag_tree_ch;
+  signed char x_flag_ssa_coalesce_vars;
+  signed char x_flag_tree_copy_prop;
+  signed char x_flag_tree_copyrename;
+  signed char x_flag_tree_cselim;
+  signed char x_flag_tree_dce;
+  signed char x_flag_tree_dom;
+  signed char x_flag_tree_dse;
+  signed char x_flag_tree_forwprop;
+  signed char x_flag_tree_fre;
+  signed char x_flag_tree_loop_distribute_patterns;
+  signed char x_flag_tree_loop_distribution;
+  signed char x_flag_tree_loop_if_convert;
+  signed char x_flag_tree_loop_if_convert_stores;
+  signed char x_flag_tree_loop_im;
+  signed char x_flag_tree_loop_ivcanon;
+  signed char x_flag_tree_loop_optimize;
+  signed char x_flag_tree_live_range_split;
+  signed char x_flag_tree_partial_pre;
+  signed char x_flag_tree_phiprop;
+  signed char x_flag_tree_pre;
+  signed char x_flag_tree_pta;
+  signed char x_flag_tree_reassoc;
+  signed char x_flag_tree_scev_cprop;
+  signed char x_flag_tree_sink;
+  signed char x_flag_tree_slp_vectorize;
+  signed char x_flag_tree_slsr;
+  signed char x_flag_tree_sra;
+  signed char x_flag_tree_switch_conversion;
+  signed char x_flag_tree_tail_merge;
+  signed char x_flag_tree_ter;
+  signed char x_flag_tree_vect_loop_version;
+  signed char x_flag_tree_vectorize;
+  signed char x_flag_tree_vrp;
+  signed char x_flag_unit_at_a_time;
+  signed char x_flag_unroll_all_loops;
+  signed char x_flag_unroll_loops;
+  signed char x_flag_unsafe_loop_optimizations;
+  signed char x_flag_unsafe_math_optimizations;
+  signed char x_flag_unswitch_loops;
+  signed char x_flag_unwind_tables;
+  signed char x_flag_var_tracking;
+  signed char x_flag_var_tracking_assignments;
+  signed char x_flag_var_tracking_assignments_toggle;
+  signed char x_flag_var_tracking_uninit;
+  signed char x_flag_variable_expansion_in_unroller;
+  signed char x_flag_vect_cost_model;
+  signed char x_flag_value_profile_transformations;
+  signed char x_flag_web;
+  signed char x_flag_whole_program;
+  signed char x_flag_wrapv;
+};
+struct cl_target_option
+{
+  int x_target_flags;
+};
+extern void cl_optimization_save (struct cl_optimization *, struct gcc_options *);
+extern void cl_optimization_restore (struct gcc_options *, struct cl_optimization *);
+extern void cl_optimization_print (FILE *, int, struct cl_optimization *);
+extern void cl_target_option_save (struct cl_target_option *, struct gcc_options *);
+extern void cl_target_option_restore (struct gcc_options *, struct cl_target_option *);
+extern void cl_target_option_print (FILE *, int, struct cl_target_option *);
+enum opt_code
+{
+  OPT____ = 0,
+  OPT__help = 32,
+  OPT__help_ = 33,
+  OPT__no_sysroot_suffix = 60,
+  OPT__output_pch_ = 66,
+  OPT__param = 68,
+  OPT__sysroot_ = 101,
+  OPT__target_help = 102,
+  OPT__version = 112,
+  OPT_A = 115,
+  OPT_B = 116,
+  OPT_C = 117,
+  OPT_CC = 118,
+  OPT_D = 120,
+  OPT_E = 121,
+  OPT_F = 122,
+  OPT_H = 123,
+  OPT_I = 124,
+  OPT_J = 125,
+  OPT_L = 126,
+  OPT_M = 127,
+  OPT_MD = 128,
+  OPT_MD_ = 129,
+  OPT_MF = 130,
+  OPT_MG = 131,
+  OPT_MM = 132,
+  OPT_MMD = 133,
+  OPT_MMD_ = 134,
+  OPT_MP = 135,
+  OPT_MQ = 136,
+  OPT_MT = 137,
+  OPT_N = 138,
+  OPT_O = 139,
+  OPT_Ofast = 140,
+  OPT_Og = 141,
+  OPT_Os = 142,
+  OPT_P = 143,
+  OPT_Q = 144,
+  OPT_Qn = 145,
+  OPT_Qy = 146,
+  OPT_R = 147,
+  OPT_S = 148,
+  OPT_T = 149,
+  OPT_Tbss = 150,
+  OPT_Tbss_ = 151,
+  OPT_Tdata = 152,
+  OPT_Tdata_ = 153,
+  OPT_Ttext = 154,
+  OPT_Ttext_ = 155,
+  OPT_U = 156,
+  OPT_Wa_ = 158,
+  OPT_Wabi = 159,
+  OPT_Wabi_tag = 160,
+  OPT_Waddress = 161,
+  OPT_Waggregate_return = 162,
+  OPT_Waggressive_loop_optimizations = 163,
+  OPT_Waliasing = 164,
+  OPT_Walign_commons = 165,
+  OPT_Wall = 166,
+  OPT_Wall_deprecation = 167,
+  OPT_Wall_javadoc = 168,
+  OPT_Wampersand = 169,
+  OPT_Warray_bounds = 170,
+  OPT_Warray_temporaries = 171,
+  OPT_Wassert_identifier = 172,
+  OPT_Wassign_intercept = 173,
+  OPT_Wattributes = 174,
+  OPT_Wbad_function_cast = 175,
+  OPT_Wboxing = 176,
+  OPT_Wbranch_probabilities_computation = 177,
+  OPT_Wbuiltin_macro_redefined = 178,
+  OPT_Wc___compat = 179,
+  OPT_Wc__0x_compat = 180,
+  OPT_Wc_binding_type = 182,
+  OPT_Wcast_align = 183,
+  OPT_Wcast_qual = 184,
+  OPT_Wchar_concat = 185,
+  OPT_Wchar_subscripts = 186,
+  OPT_Wcharacter_truncation = 187,
+  OPT_Wclobbered = 188,
+  OPT_Wcomment = 189,
+  OPT_Wcompare_reals = 191,
+  OPT_Wcondition_assign = 192,
+  OPT_Wconstructor_name = 193,
+  OPT_Wconversion = 194,
+  OPT_Wconversion_extra = 195,
+  OPT_Wconversion_null = 196,
+  OPT_Wcoverage_mismatch = 197,
+  OPT_Wcpp = 198,
+  OPT_Wctor_dtor_privacy = 199,
+  OPT_Wdeclaration_after_statement = 200,
+  OPT_Wdelete_non_virtual_dtor = 201,
+  OPT_Wdep_ann = 202,
+  OPT_Wdeprecated = 203,
+  OPT_Wdeprecated_declarations = 204,
+  OPT_Wdisabled_optimization = 205,
+  OPT_Wdiscouraged = 206,
+  OPT_Wdiv_by_zero = 207,
+  OPT_Wdouble_promotion = 208,
+  OPT_Weffc__ = 209,
+  OPT_Wempty_block = 210,
+  OPT_Wempty_body = 211,
+  OPT_Wendif_labels = 212,
+  OPT_Wenum_compare = 213,
+  OPT_Wenum_identifier = 214,
+  OPT_Wenum_switch = 215,
+  OPT_Werror = 216,
+  OPT_Werror_ = 218,
+  OPT_Wextra = 219,
+  OPT_Wextraneous_semicolon = 220,
+  OPT_Wfallthrough = 221,
+  OPT_Wfatal_errors = 222,
+  OPT_Wfield_hiding = 223,
+  OPT_Wfinal_bound = 224,
+  OPT_Wfinally = 225,
+  OPT_Wfloat_equal = 226,
+  OPT_Wforbidden = 227,
+  OPT_Wformat_contains_nul = 229,
+  OPT_Wformat_extra_args = 230,
+  OPT_Wformat_nonliteral = 231,
+  OPT_Wformat_security = 232,
+  OPT_Wformat_y2k = 233,
+  OPT_Wformat_zero_length = 234,
+  OPT_Wformat_ = 235,
+  OPT_Wframe_larger_than_ = 236,
+  OPT_Wfree_nonheap_object = 237,
+  OPT_Wfunction_elimination = 238,
+  OPT_Whiding = 239,
+  OPT_Wignored_qualifiers = 240,
+  OPT_Wimplicit = 241,
+  OPT_Wimplicit_function_declaration = 242,
+  OPT_Wimplicit_int = 243,
+  OPT_Wimplicit_interface = 244,
+  OPT_Wimplicit_procedure = 245,
+  OPT_Windirect_static = 247,
+  OPT_Winherited_variadic_ctor = 248,
+  OPT_Winit_self = 249,
+  OPT_Winline = 250,
+  OPT_Wint_to_pointer_cast = 251,
+  OPT_Wintf_annotation = 252,
+  OPT_Wintf_non_inherited = 253,
+  OPT_Wintrinsic_shadow = 254,
+  OPT_Wintrinsics_std = 255,
+  OPT_Winvalid_memory_model = 256,
+  OPT_Winvalid_offsetof = 257,
+  OPT_Winvalid_pch = 258,
+  OPT_Wjavadoc = 259,
+  OPT_Wjump_misses_init = 260,
+  OPT_Wl_ = 261,
+  OPT_Wlarger_than_ = 263,
+  OPT_Wline_truncation = 264,
+  OPT_Wliteral_suffix = 265,
+  OPT_Wlocal_hiding = 266,
+  OPT_Wlogical_op = 267,
+  OPT_Wlong_long = 268,
+  OPT_Wmain = 269,
+  OPT_Wmasked_catch_block = 270,
+  OPT_Wmaybe_uninitialized = 271,
+  OPT_Wmissing_braces = 272,
+  OPT_Wmissing_declarations = 273,
+  OPT_Wmissing_field_initializers = 274,
+  OPT_Wmissing_include_dirs = 276,
+  OPT_Wmissing_parameter_type = 278,
+  OPT_Wmissing_prototypes = 279,
+  OPT_Wmudflap = 280,
+  OPT_Wmultichar = 281,
+  OPT_Wnarrowing = 282,
+  OPT_Wnested_externs = 283,
+  OPT_Wnls = 284,
+  OPT_Wno_effect_assign = 285,
+  OPT_Wnoexcept = 286,
+  OPT_Wnon_finite_math = 287,
+  OPT_Wnon_template_friend = 288,
+  OPT_Wnon_virtual_dtor = 289,
+  OPT_Wnonnull = 290,
+  OPT_Wnormalized_ = 291,
+  OPT_Wnull = 292,
+  OPT_Wold_style_cast = 293,
+  OPT_Wold_style_declaration = 294,
+  OPT_Wold_style_definition = 295,
+  OPT_Wout_of_date = 296,
+  OPT_Wover_ann = 297,
+  OPT_Woverflow = 298,
+  OPT_Woverlength_strings = 299,
+  OPT_Woverloaded_virtual = 300,
+  OPT_Woverride_init = 301,
+  OPT_Wp_ = 302,
+  OPT_Wpacked = 303,
+  OPT_Wpacked_bitfield_compat = 304,
+  OPT_Wpadded = 305,
+  OPT_Wparam_assign = 306,
+  OPT_Wparentheses = 307,
+  OPT_Wpedantic = 308,
+  OPT_Wpkg_default_method = 309,
+  OPT_Wpmf_conversions = 310,
+  OPT_Wpointer_arith = 311,
+  OPT_Wpointer_sign = 312,
+  OPT_Wpointer_to_int_cast = 313,
+  OPT_Wpragmas = 314,
+  OPT_Wproperty_assign_default = 315,
+  OPT_Wprotocol = 316,
+  OPT_Wpsabi = 317,
+  OPT_Wraw = 318,
+  OPT_Wreal_q_constant = 319,
+  OPT_Wrealloc_lhs = 320,
+  OPT_Wrealloc_lhs_all = 321,
+  OPT_Wredundant_decls = 322,
+  OPT_Wredundant_modifiers = 323,
+  OPT_Wreorder = 324,
+  OPT_Wreturn_local_addr = 325,
+  OPT_Wreturn_type = 326,
+  OPT_Wselector = 327,
+  OPT_Wsequence_point = 328,
+  OPT_Wserial = 329,
+  OPT_Wshadow = 330,
+  OPT_Wsign_compare = 331,
+  OPT_Wsign_conversion = 332,
+  OPT_Wsign_promo = 333,
+  OPT_Wsizeof_pointer_memaccess = 334,
+  OPT_Wspecial_param_hiding = 335,
+  OPT_Wstack_protector = 336,
+  OPT_Wstack_usage_ = 337,
+  OPT_Wstatic_access = 338,
+  OPT_Wstatic_receiver = 339,
+  OPT_Wstrict_aliasing = 340,
+  OPT_Wstrict_aliasing_ = 341,
+  OPT_Wstrict_null_sentinel = 342,
+  OPT_Wstrict_overflow = 343,
+  OPT_Wstrict_overflow_ = 344,
+  OPT_Wstrict_prototypes = 345,
+  OPT_Wstrict_selector_match = 346,
+  OPT_Wsuggest_attribute_const = 347,
+  OPT_Wsuggest_attribute_format = 348,
+  OPT_Wsuggest_attribute_noreturn = 349,
+  OPT_Wsuggest_attribute_pure = 350,
+  OPT_Wsuppress = 351,
+  OPT_Wsurprising = 352,
+  OPT_Wswitch = 353,
+  OPT_Wswitch_default = 354,
+  OPT_Wswitch_enum = 355,
+  OPT_Wsync_nand = 356,
+  OPT_Wsynth = 357,
+  OPT_Wsynthetic_access = 358,
+  OPT_Wsystem_headers = 359,
+  OPT_Wtabs = 360,
+  OPT_Wtarget_lifetime = 361,
+  OPT_Wtasks = 362,
+  OPT_Wtraditional = 363,
+  OPT_Wtraditional_conversion = 364,
+  OPT_Wtrampolines = 365,
+  OPT_Wtrigraphs = 366,
+  OPT_Wtype_hiding = 367,
+  OPT_Wtype_limits = 368,
+  OPT_Wuncheck = 369,
+  OPT_Wundeclared_selector = 370,
+  OPT_Wundef = 371,
+  OPT_Wunderflow = 372,
+  OPT_Wuninitialized = 373,
+  OPT_Wunknown_pragmas = 374,
+  OPT_Wunnecessary_else = 375,
+  OPT_Wunqualified_field = 376,
+  OPT_Wunsafe_loop_optimizations = 378,
+  OPT_Wunsuffixed_float_constants = 379,
+  OPT_Wunused = 380,
+  OPT_Wunused_argument = 381,
+  OPT_Wunused_but_set_parameter = 382,
+  OPT_Wunused_but_set_variable = 383,
+  OPT_Wunused_dummy_argument = 384,
+  OPT_Wunused_function = 385,
+  OPT_Wunused_import = 386,
+  OPT_Wunused_label = 387,
+  OPT_Wunused_local = 388,
+  OPT_Wunused_local_typedefs = 389,
+  OPT_Wunused_macros = 390,
+  OPT_Wunused_parameter = 391,
+  OPT_Wunused_private = 392,
+  OPT_Wunused_result = 393,
+  OPT_Wunused_thrown = 394,
+  OPT_Wunused_value = 395,
+  OPT_Wunused_variable = 396,
+  OPT_Wuseless_cast = 397,
+  OPT_Wuseless_type_check = 398,
+  OPT_Wvarargs = 399,
+  OPT_Wvarargs_cast = 400,
+  OPT_Wvariadic_macros = 401,
+  OPT_Wvector_operation_performance = 402,
+  OPT_Wvirtual_move_assign = 403,
+  OPT_Wvla = 404,
+  OPT_Wvolatile_register_var = 405,
+  OPT_Wwarning_token = 406,
+  OPT_Wwrite_strings = 407,
+  OPT_Wzero_as_null_pointer_constant = 408,
+  OPT_Xassembler = 409,
+  OPT_Xlinker = 410,
+  OPT_Xpreprocessor = 411,
+  OPT_Z = 412,
+  OPT_ansi = 413,
+  OPT_aux_info = 414,
+  OPT_auxbase = 416,
+  OPT_auxbase_strip = 417,
+  OPT_c = 419,
+  OPT_coverage = 421,
+  OPT_cpp = 422,
+  OPT_cpp_ = 423,
+  OPT_d = 424,
+  OPT_dumpbase = 425,
+  OPT_dumpdir = 426,
+  OPT_dumpmachine = 427,
+  OPT_dumpspecs = 428,
+  OPT_dumpversion = 429,
+  OPT_e = 430,
+  OPT_export_dynamic = 432,
+  OPT_extdirs = 433,
+  OPT_fPIC = 435,
+  OPT_fPIE = 436,
+  OPT_fRTS_ = 437,
+  OPT_fabi_version_ = 438,
+  OPT_faccess_control = 439,
+  OPT_fada_spec_parent_ = 440,
+  OPT_faggressive_function_elimination = 441,
+  OPT_faggressive_loop_optimizations = 442,
+  OPT_falign_commons = 443,
+  OPT_falign_functions = 444,
+  OPT_falign_functions_ = 445,
+  OPT_falign_jumps = 446,
+  OPT_falign_jumps_ = 447,
+  OPT_falign_labels = 448,
+  OPT_falign_labels_ = 449,
+  OPT_falign_loops = 450,
+  OPT_falign_loops_ = 451,
+  OPT_fall_intrinsics = 452,
+  OPT_fallow_leading_underscore = 454,
+  OPT_fallow_parameterless_variadic_functions = 455,
+  OPT_fasm = 461,
+  OPT_fassert = 462,
+  OPT_fassociative_math = 463,
+  OPT_fassume_compiled = 464,
+  OPT_fassume_compiled_ = 465,
+  OPT_fasynchronous_unwind_tables = 466,
+  OPT_fauto_inc_dec = 467,
+  OPT_fautomatic = 468,
+  OPT_faux_classpath = 469,
+  OPT_fbackslash = 470,
+  OPT_fbacktrace = 471,
+  OPT_fblas_matmul_limit_ = 472,
+  OPT_fbootclasspath_ = 473,
+  OPT_fbootstrap_classes = 474,
+  OPT_fbounds_check = 475,
+  OPT_fbranch_count_reg = 476,
+  OPT_fbranch_probabilities = 477,
+  OPT_fbranch_target_load_optimize = 478,
+  OPT_fbranch_target_load_optimize2 = 479,
+  OPT_fbtr_bb_exclusive = 480,
+  OPT_fbuilding_libgcc = 481,
+  OPT_fbuiltin = 482,
+  OPT_fbuiltin_ = 483,
+  OPT_fcall_saved_ = 484,
+  OPT_fcall_used_ = 485,
+  OPT_fcaller_saves = 486,
+  OPT_fcanonical_system_headers = 487,
+  OPT_fcheck_array_temporaries = 488,
+  OPT_fcheck_data_deps = 489,
+  OPT_fcheck_new = 490,
+  OPT_fcheck_references = 491,
+  OPT_fcheck_ = 492,
+  OPT_fclasspath_ = 493,
+  OPT_fcoarray_ = 494,
+  OPT_fcombine_stack_adjustments = 495,
+  OPT_fcommon = 496,
+  OPT_fcompare_debug = 497,
+  OPT_fcompare_debug_second = 498,
+  OPT_fcompare_debug_ = 499,
+  OPT_fcompare_elim = 500,
+  OPT_fcompile_resource_ = 501,
+  OPT_fcond_mismatch = 502,
+  OPT_fconserve_space = 503,
+  OPT_fconserve_stack = 504,
+  OPT_fconstant_string_class_ = 505,
+  OPT_fconstexpr_depth_ = 506,
+  OPT_fconvert_big_endian = 507,
+  OPT_fconvert_little_endian = 508,
+  OPT_fconvert_native = 509,
+  OPT_fconvert_swap = 510,
+  OPT_fcprop_registers = 511,
+  OPT_fcray_pointer = 512,
+  OPT_fcrossjumping = 513,
+  OPT_fcse_follow_jumps = 514,
+  OPT_fcse_sincos = 515,
+  OPT_fcx_fortran_rules = 517,
+  OPT_fcx_limited_range = 518,
+  OPT_fd_lines_as_code = 519,
+  OPT_fd_lines_as_comments = 520,
+  OPT_fdata_sections = 521,
+  OPT_fdbg_cnt_list = 522,
+  OPT_fdbg_cnt_ = 523,
+  OPT_fdce = 524,
+  OPT_fdebug_cpp = 525,
+  OPT_fdebug_prefix_map_ = 526,
+  OPT_fdebug_types_section = 527,
+  OPT_fdeduce_init_list = 528,
+  OPT_fdefault_double_8 = 529,
+  OPT_fdefault_integer_8 = 531,
+  OPT_fdefault_real_8 = 532,
+  OPT_fdefer_pop = 533,
+  OPT_fdelayed_branch = 534,
+  OPT_fdelete_dead_exceptions = 535,
+  OPT_fdelete_null_pointer_checks = 536,
+  OPT_fdevirtualize = 537,
+  OPT_fdiagnostics_show_caret = 538,
+  OPT_fdiagnostics_show_location_ = 539,
+  OPT_fdiagnostics_show_option = 540,
+  OPT_fdirectives_only = 541,
+  OPT_fdisable_ = 542,
+  OPT_fdisable_assertions = 543,
+  OPT_fdisable_assertions_ = 544,
+  OPT_fdollar_ok = 545,
+  OPT_fdollars_in_identifiers = 546,
+  OPT_fdse = 547,
+  OPT_fdump_ = 548,
+  OPT_fdump_ada_spec = 549,
+  OPT_fdump_ada_spec_slim = 550,
+  OPT_fdump_final_insns = 552,
+  OPT_fdump_final_insns_ = 553,
+  OPT_fdump_fortran_optimized = 554,
+  OPT_fdump_fortran_original = 555,
+  OPT_fdump_go_spec_ = 556,
+  OPT_fdump_noaddr = 557,
+  OPT_fdump_parse_tree = 558,
+  OPT_fdump_passes = 559,
+  OPT_fdump_unnumbered = 560,
+  OPT_fdump_unnumbered_links = 561,
+  OPT_fdwarf2_cfi_asm = 562,
+  OPT_fearly_inlining = 563,
+  OPT_felide_constructors = 564,
+  OPT_feliminate_dwarf2_dups = 565,
+  OPT_feliminate_unused_debug_symbols = 566,
+  OPT_feliminate_unused_debug_types = 567,
+  OPT_femit_class_debug_always = 568,
+  OPT_femit_class_file = 569,
+  OPT_femit_class_files = 570,
+  OPT_femit_struct_debug_baseonly = 571,
+  OPT_femit_struct_debug_detailed_ = 572,
+  OPT_femit_struct_debug_reduced = 573,
+  OPT_fenable_ = 574,
+  OPT_fenable_assertions = 575,
+  OPT_fenable_assertions_ = 576,
+  OPT_fencoding_ = 577,
+  OPT_fenforce_eh_specs = 578,
+  OPT_fexceptions = 580,
+  OPT_fexcess_precision_ = 581,
+  OPT_fexec_charset_ = 582,
+  OPT_fexpensive_optimizations = 583,
+  OPT_fext_numeric_literals = 584,
+  OPT_fextdirs_ = 585,
+  OPT_fextended_identifiers = 586,
+  OPT_fextern_tls_init = 587,
+  OPT_fexternal_blas = 588,
+  OPT_ff2c = 590,
+  OPT_ffast_math = 591,
+  OPT_ffat_lto_objects = 592,
+  OPT_ffilelist_file = 593,
+  OPT_ffinite_math_only = 594,
+  OPT_ffixed_ = 595,
+  OPT_ffixed_form = 596,
+  OPT_ffixed_line_length_ = 597,
+  OPT_ffixed_line_length_none = 598,
+  OPT_ffloat_store = 599,
+  OPT_ffor_scope = 600,
+  OPT_fforce_classes_archive_check = 602,
+  OPT_fforward_propagate = 603,
+  OPT_ffp_contract_ = 604,
+  OPT_ffpe_trap_ = 605,
+  OPT_ffree_form = 606,
+  OPT_ffree_line_length_ = 607,
+  OPT_ffree_line_length_none = 608,
+  OPT_ffreestanding = 609,
+  OPT_ffriend_injection = 610,
+  OPT_ffrontend_optimize = 611,
+  OPT_ffunction_cse = 612,
+  OPT_ffunction_sections = 613,
+  OPT_fgcse = 614,
+  OPT_fgcse_after_reload = 615,
+  OPT_fgcse_las = 616,
+  OPT_fgcse_lm = 617,
+  OPT_fgcse_sm = 618,
+  OPT_fgnu_keywords = 619,
+  OPT_fgnu_runtime = 620,
+  OPT_fgnu_tm = 621,
+  OPT_fgnu89_inline = 622,
+  OPT_fgo_check_divide_overflow = 623,
+  OPT_fgo_check_divide_zero = 624,
+  OPT_fgo_dump_ = 625,
+  OPT_fgo_optimize_ = 626,
+  OPT_fgo_pkgpath_ = 627,
+  OPT_fgo_prefix_ = 628,
+  OPT_fgo_relative_import_path_ = 629,
+  OPT_fgraphite = 630,
+  OPT_fgraphite_identity = 631,
+  OPT_fguess_branch_probability = 632,
+  OPT_fhash_synchronization = 635,
+  OPT_fhoist_adjacent_loads = 638,
+  OPT_fhosted = 640,
+  OPT_fident = 642,
+  OPT_fif_conversion = 643,
+  OPT_fif_conversion2 = 644,
+  OPT_fimplement_inlines = 645,
+  OPT_fimplicit_inline_templates = 646,
+  OPT_fimplicit_none = 647,
+  OPT_fimplicit_templates = 648,
+  OPT_findirect_classes = 649,
+  OPT_findirect_dispatch = 650,
+  OPT_findirect_inlining = 651,
+  OPT_finhibit_size_directive = 652,
+  OPT_finit_character_ = 653,
+  OPT_finit_integer_ = 654,
+  OPT_finit_local_zero = 655,
+  OPT_finit_logical_ = 656,
+  OPT_finit_real_ = 657,
+  OPT_finline = 658,
+  OPT_finline_atomics = 659,
+  OPT_finline_functions = 660,
+  OPT_finline_functions_called_once = 661,
+  OPT_finline_limit_ = 663,
+  OPT_finline_small_functions = 664,
+  OPT_finput_charset_ = 665,
+  OPT_finstrument_functions = 666,
+  OPT_finstrument_functions_exclude_file_list_ = 667,
+  OPT_finstrument_functions_exclude_function_list_ = 668,
+  OPT_finteger_4_integer_8 = 669,
+  OPT_fintrinsic_modules_path = 670,
+  OPT_fintrinsic_modules_path_ = 671,
+  OPT_fipa_cp = 672,
+  OPT_fipa_cp_clone = 673,
+  OPT_fipa_profile = 675,
+  OPT_fipa_pta = 676,
+  OPT_fipa_pure_const = 677,
+  OPT_fipa_reference = 678,
+  OPT_fipa_sra = 679,
+  OPT_fira_algorithm_ = 681,
+  OPT_fira_hoist_pressure = 682,
+  OPT_fira_loop_pressure = 683,
+  OPT_fira_region_ = 684,
+  OPT_fira_share_save_slots = 685,
+  OPT_fira_share_spill_slots = 686,
+  OPT_fira_verbose_ = 687,
+  OPT_fivopts = 688,
+  OPT_fjni = 689,
+  OPT_fjump_tables = 690,
+  OPT_fkeep_inline_dllexport = 691,
+  OPT_fkeep_inline_functions = 692,
+  OPT_fkeep_static_consts = 693,
+  OPT_flax_vector_conversions = 695,
+  OPT_fleading_underscore = 696,
+  OPT_floop_block = 697,
+  OPT_floop_interchange = 699,
+  OPT_floop_nest_optimize = 700,
+  OPT_floop_parallelize_all = 702,
+  OPT_floop_strip_mine = 703,
+  OPT_flto = 704,
+  OPT_flto_compression_level_ = 705,
+  OPT_flto_partition_1to1 = 706,
+  OPT_flto_partition_balanced = 707,
+  OPT_flto_partition_max = 708,
+  OPT_flto_partition_none = 709,
+  OPT_flto_report = 710,
+  OPT_flto_ = 711,
+  OPT_fltrans = 712,
+  OPT_fltrans_output_list_ = 713,
+  OPT_fmain_ = 714,
+  OPT_fmath_errno = 715,
+  OPT_fmax_array_constructor_ = 716,
+  OPT_fmax_errors_ = 717,
+  OPT_fmax_identifier_length_ = 718,
+  OPT_fmax_stack_var_size_ = 719,
+  OPT_fmax_subrecord_length_ = 720,
+  OPT_fmem_report = 721,
+  OPT_fmem_report_wpa = 722,
+  OPT_fmerge_all_constants = 723,
+  OPT_fmerge_constants = 724,
+  OPT_fmerge_debug_strings = 725,
+  OPT_fmessage_length_ = 726,
+  OPT_fmodule_private = 727,
+  OPT_fmodulo_sched = 728,
+  OPT_fmodulo_sched_allow_regmoves = 729,
+  OPT_fmove_loop_invariants = 730,
+  OPT_fms_extensions = 731,
+  OPT_fmudflap = 732,
+  OPT_fmudflapir = 733,
+  OPT_fmudflapth = 734,
+  OPT_fnext_runtime = 737,
+  OPT_fnil_receivers = 738,
+  OPT_fnon_call_exceptions = 739,
+  OPT_fnonansi_builtins = 740,
+  OPT_fnothrow_opt = 742,
+  OPT_fobjc_abi_version_ = 743,
+  OPT_fobjc_call_cxx_cdtors = 744,
+  OPT_fobjc_direct_dispatch = 745,
+  OPT_fobjc_exceptions = 746,
+  OPT_fobjc_gc = 747,
+  OPT_fobjc_nilcheck = 748,
+  OPT_fobjc_sjlj_exceptions = 749,
+  OPT_fobjc_std_objc1 = 750,
+  OPT_fomit_frame_pointer = 751,
+  OPT_fopenmp = 752,
+  OPT_foperator_names = 753,
+  OPT_fopt_info = 754,
+  OPT_fopt_info_ = 755,
+  OPT_foptimize_register_move = 756,
+  OPT_foptimize_sibling_calls = 757,
+  OPT_foptimize_static_class_initialization = 758,
+  OPT_foptimize_strlen = 759,
+  OPT_foutput_class_dir_ = 761,
+  OPT_fpack_derived = 762,
+  OPT_fpack_struct = 763,
+  OPT_fpack_struct_ = 764,
+  OPT_fpartial_inlining = 765,
+  OPT_fpcc_struct_return = 766,
+  OPT_fpch_deps = 767,
+  OPT_fpch_preprocess = 768,
+  OPT_fpeel_loops = 769,
+  OPT_fpeephole = 770,
+  OPT_fpeephole2 = 771,
+  OPT_fpermissive = 772,
+  OPT_fpic = 773,
+  OPT_fpie = 774,
+  OPT_fplan9_extensions = 775,
+  OPT_fplugin_arg_ = 776,
+  OPT_fplugin_ = 777,
+  OPT_fpost_ipa_mem_report = 778,
+  OPT_fpre_ipa_mem_report = 779,
+  OPT_fpredictive_commoning = 780,
+  OPT_fprefetch_loop_arrays = 781,
+  OPT_fpreprocessed = 782,
+  OPT_fpretty_templates = 783,
+  OPT_fprofile = 784,
+  OPT_fprofile_arcs = 785,
+  OPT_fprofile_correction = 786,
+  OPT_fprofile_dir_ = 787,
+  OPT_fprofile_generate = 788,
+  OPT_fprofile_generate_ = 789,
+  OPT_fprofile_report = 790,
+  OPT_fprofile_use = 791,
+  OPT_fprofile_use_ = 792,
+  OPT_fprofile_values = 793,
+  OPT_fprotect_parens = 794,
+  OPT_frandom_seed = 795,
+  OPT_frandom_seed_ = 796,
+  OPT_frange_check = 797,
+  OPT_freal_4_real_10 = 798,
+  OPT_freal_4_real_16 = 799,
+  OPT_freal_4_real_8 = 800,
+  OPT_freal_8_real_10 = 801,
+  OPT_freal_8_real_16 = 802,
+  OPT_freal_8_real_4 = 803,
+  OPT_frealloc_lhs = 804,
+  OPT_freciprocal_math = 805,
+  OPT_frecord_gcc_switches = 806,
+  OPT_frecord_marker_4 = 807,
+  OPT_frecord_marker_8 = 808,
+  OPT_frecursive = 809,
+  OPT_freduced_reflection = 810,
+  OPT_free = 811,
+  OPT_freg_struct_return = 812,
+  OPT_fregmove = 813,
+  OPT_frename_registers = 814,
+  OPT_freorder_blocks = 815,
+  OPT_freorder_blocks_and_partition = 816,
+  OPT_freorder_functions = 817,
+  OPT_frepack_arrays = 818,
+  OPT_freplace_objc_classes = 819,
+  OPT_frepo = 820,
+  OPT_frequire_return_statement = 821,
+  OPT_frerun_cse_after_loop = 822,
+  OPT_freschedule_modulo_scheduled_loops = 824,
+  OPT_fresolution_ = 825,
+  OPT_frounding_math = 826,
+  OPT_frtti = 827,
+  OPT_fsanitize_address = 828,
+  OPT_fsanitize_thread = 829,
+  OPT_fsaw_java_file = 830,
+  OPT_fsched_critical_path_heuristic = 831,
+  OPT_fsched_dep_count_heuristic = 832,
+  OPT_fsched_group_heuristic = 833,
+  OPT_fsched_interblock = 834,
+  OPT_fsched_last_insn_heuristic = 835,
+  OPT_fsched_pressure = 836,
+  OPT_fsched_rank_heuristic = 837,
+  OPT_fsched_spec = 838,
+  OPT_fsched_spec_insn_heuristic = 839,
+  OPT_fsched_spec_load = 840,
+  OPT_fsched_spec_load_dangerous = 841,
+  OPT_fsched_stalled_insns = 842,
+  OPT_fsched_stalled_insns_dep = 843,
+  OPT_fsched_stalled_insns_dep_ = 844,
+  OPT_fsched_stalled_insns_ = 845,
+  OPT_fsched_verbose_ = 846,
+  OPT_fsched2_use_superblocks = 847,
+  OPT_fschedule_insns = 849,
+  OPT_fschedule_insns2 = 850,
+  OPT_fsecond_underscore = 851,
+  OPT_fsection_anchors = 852,
+  OPT_fsel_sched_pipelining = 854,
+  OPT_fsel_sched_pipelining_outer_loops = 855,
+  OPT_fsel_sched_reschedule_pipelined = 856,
+  OPT_fselective_scheduling = 857,
+  OPT_fselective_scheduling2 = 858,
+  OPT_fshort_double = 859,
+  OPT_fshort_enums = 860,
+  OPT_fshort_wchar = 861,
+  OPT_fshow_column = 862,
+  OPT_fshrink_wrap = 863,
+  OPT_fsign_zero = 864,
+  OPT_fsignaling_nans = 865,
+  OPT_fsigned_bitfields = 866,
+  OPT_fsigned_char = 867,
+  OPT_fsigned_zeros = 868,
+  OPT_fsingle_precision_constant = 869,
+  OPT_fsource_filename_ = 870,
+  OPT_fsource_ = 871,
+  OPT_fsplit_ivs_in_unroller = 872,
+  OPT_fsplit_stack = 873,
+  OPT_fsplit_wide_types = 874,
+  OPT_fstack_arrays = 876,
+  OPT_fstack_check_ = 878,
+  OPT_fstack_limit = 879,
+  OPT_fstack_limit_register_ = 880,
+  OPT_fstack_limit_symbol_ = 881,
+  OPT_fstack_protector = 882,
+  OPT_fstack_protector_all = 883,
+  OPT_fstack_protector_strong = 884,
+  OPT_fstack_reuse_ = 885,
+  OPT_fstack_usage = 886,
+  OPT_fstats = 887,
+  OPT_fstore_check = 888,
+  OPT_fstrict_aliasing = 890,
+  OPT_fstrict_enums = 891,
+  OPT_fstrict_overflow = 892,
+  OPT_fstrict_volatile_bitfields = 894,
+  OPT_fsync_libcalls = 895,
+  OPT_fsyntax_only = 896,
+  OPT_ftabstop_ = 897,
+  OPT_ftarget_ = 899,
+  OPT_ftemplate_backtrace_limit_ = 900,
+  OPT_ftemplate_depth_ = 902,
+  OPT_ftest_coverage = 903,
+  OPT_fthread_jumps = 905,
+  OPT_fthreadsafe_statics = 906,
+  OPT_ftime_report = 907,
+  OPT_ftls_model_ = 908,
+  OPT_ftoplevel_reorder = 909,
+  OPT_ftracer = 910,
+  OPT_ftrack_macro_expansion = 911,
+  OPT_ftrack_macro_expansion_ = 912,
+  OPT_ftrapping_math = 913,
+  OPT_ftrapv = 914,
+  OPT_ftree_bit_ccp = 915,
+  OPT_ftree_builtin_call_dce = 916,
+  OPT_ftree_ccp = 917,
+  OPT_ftree_ch = 918,
+  OPT_ftree_coalesce_inlined_vars = 919,
+  OPT_ftree_coalesce_vars = 920,
+  OPT_ftree_copy_prop = 921,
+  OPT_ftree_copyrename = 922,
+  OPT_ftree_cselim = 923,
+  OPT_ftree_dce = 924,
+  OPT_ftree_dominator_opts = 925,
+  OPT_ftree_dse = 926,
+  OPT_ftree_forwprop = 927,
+  OPT_ftree_fre = 928,
+  OPT_ftree_loop_distribute_patterns = 929,
+  OPT_ftree_loop_distribution = 930,
+  OPT_ftree_loop_if_convert = 931,
+  OPT_ftree_loop_if_convert_stores = 932,
+  OPT_ftree_loop_im = 933,
+  OPT_ftree_loop_ivcanon = 934,
+  OPT_ftree_loop_optimize = 936,
+  OPT_ftree_lrs = 937,
+  OPT_ftree_parallelize_loops_ = 938,
+  OPT_ftree_partial_pre = 939,
+  OPT_ftree_phiprop = 940,
+  OPT_ftree_pre = 941,
+  OPT_ftree_pta = 942,
+  OPT_ftree_reassoc = 943,
+  OPT_ftree_scev_cprop = 945,
+  OPT_ftree_sink = 946,
+  OPT_ftree_slp_vectorize = 947,
+  OPT_ftree_slsr = 948,
+  OPT_ftree_sra = 949,
+  OPT_ftree_switch_conversion = 952,
+  OPT_ftree_tail_merge = 953,
+  OPT_ftree_ter = 954,
+  OPT_ftree_vect_loop_version = 955,
+  OPT_ftree_vectorize = 956,
+  OPT_ftree_vectorizer_verbose_ = 957,
+  OPT_ftree_vrp = 958,
+  OPT_funderscoring = 959,
+  OPT_funit_at_a_time = 960,
+  OPT_funroll_all_loops = 961,
+  OPT_funroll_loops = 962,
+  OPT_funsafe_loop_optimizations = 963,
+  OPT_funsafe_math_optimizations = 964,
+  OPT_funsigned_bitfields = 965,
+  OPT_funsigned_char = 966,
+  OPT_funswitch_loops = 967,
+  OPT_funwind_tables = 968,
+  OPT_fuse_atomic_builtins = 969,
+  OPT_fuse_boehm_gc = 970,
+  OPT_fuse_cxa_atexit = 971,
+  OPT_fuse_cxa_get_exception_ptr = 972,
+  OPT_fuse_divide_subroutine = 973,
+  OPT_fuse_ld_bfd = 974,
+  OPT_fuse_ld_gold = 975,
+  OPT_fuse_linker_plugin = 976,
+  OPT_fvar_tracking = 977,
+  OPT_fvar_tracking_assignments = 978,
+  OPT_fvar_tracking_assignments_toggle = 979,
+  OPT_fvar_tracking_uninit = 980,
+  OPT_fvariable_expansion_in_unroller = 981,
+  OPT_fvect_cost_model = 982,
+  OPT_fverbose_asm = 983,
+  OPT_fvisibility_inlines_hidden = 985,
+  OPT_fvisibility_ms_compat = 986,
+  OPT_fvisibility_ = 987,
+  OPT_fvpt = 988,
+  OPT_fweak = 991,
+  OPT_fweb = 992,
+  OPT_fwhole_file = 993,
+  OPT_fwhole_program = 994,
+  OPT_fwide_exec_charset_ = 995,
+  OPT_fworking_directory = 996,
+  OPT_fwpa = 997,
+  OPT_fwrapv = 998,
+  OPT_fzero_initialized_in_bss = 1001,
+  OPT_fzero_link = 1002,
+  OPT_g = 1003,
+  OPT_gant = 1004,
+  OPT_gcoff = 1005,
+  OPT_gdwarf_ = 1006,
+  OPT_gen_decls = 1007,
+  OPT_ggdb = 1008,
+  OPT_gnat = 1009,
+  OPT_gnatO = 1010,
+  OPT_gno_pubnames = 1011,
+  OPT_gno_record_gcc_switches = 1012,
+  OPT_gno_split_dwarf = 1013,
+  OPT_gno_strict_dwarf = 1014,
+  OPT_gpubnames = 1015,
+  OPT_grecord_gcc_switches = 1016,
+  OPT_gsplit_dwarf = 1017,
+  OPT_gstabs = 1018,
+  OPT_gstabs_ = 1019,
+  OPT_gstrict_dwarf = 1020,
+  OPT_gtoggle = 1021,
+  OPT_gvms = 1022,
+  OPT_gxcoff = 1023,
+  OPT_gxcoff_ = 1024,
+  OPT_h = 1025,
+  OPT_idirafter = 1026,
+  OPT_imacros = 1027,
+  OPT_imultiarch = 1028,
+  OPT_imultilib = 1029,
+  OPT_include = 1030,
+  OPT_iplugindir_ = 1031,
+  OPT_iprefix = 1032,
+  OPT_iquote = 1033,
+  OPT_isysroot = 1034,
+  OPT_isystem = 1035,
+  OPT_iwithprefix = 1036,
+  OPT_iwithprefixbefore = 1037,
+  OPT_k8 = 1038,
+  OPT_l = 1039,
+  OPT_lang_asm = 1040,
+  OPT_m1 = 1041,
+  OPT_m2 = 1042,
+  OPT_m2a = 1043,
+  OPT_m2a_nofpu = 1044,
+  OPT_m2a_single = 1045,
+  OPT_m2a_single_only = 1046,
+  OPT_m2e = 1047,
+  OPT_m3 = 1048,
+  OPT_m3e = 1049,
+  OPT_m4 = 1050,
+  OPT_m4_100 = 1051,
+  OPT_m4_100_nofpu = 1052,
+  OPT_m4_100_single = 1053,
+  OPT_m4_100_single_only = 1054,
+  OPT_m4_200 = 1055,
+  OPT_m4_200_nofpu = 1056,
+  OPT_m4_200_single = 1057,
+  OPT_m4_200_single_only = 1058,
+  OPT_m4_300 = 1059,
+  OPT_m4_300_nofpu = 1060,
+  OPT_m4_300_single = 1061,
+  OPT_m4_300_single_only = 1062,
+  OPT_m4_340 = 1063,
+  OPT_m4_400 = 1064,
+  OPT_m4_500 = 1065,
+  OPT_m4_nofpu = 1066,
+  OPT_m4_single = 1067,
+  OPT_m4_single_only = 1068,
+  OPT_m4a = 1069,
+  OPT_m4a_nofpu = 1070,
+  OPT_m4a_single = 1071,
+  OPT_m4a_single_only = 1072,
+  OPT_m4al = 1073,
+  OPT_m5_32media = 1074,
+  OPT_m5_32media_nofpu = 1075,
+  OPT_m5_64media = 1076,
+  OPT_m5_64media_nofpu = 1077,
+  OPT_m5_compact = 1078,
+  OPT_m5_compact_nofpu = 1079,
+  OPT_maccumulate_outgoing_args = 1080,
+  OPT_malign_small_blocks_ = 1081,
+  OPT_mandroid = 1082,
+  OPT_matomic_model_ = 1083,
+  OPT_mb = 1084,
+  OPT_mbigtable = 1085,
+  OPT_mbionic = 1086,
+  OPT_mbitops = 1087,
+  OPT_mbranch_cost_ = 1088,
+  OPT_mcbranchdi = 1089,
+  OPT_mcmpeqdi = 1090,
+  OPT_mcut2_workaround = 1091,
+  OPT_mdalign = 1092,
+  OPT_mdb_page_bug = 1093,
+  OPT_mdead_delay = 1094,
+  OPT_mdiv_ = 1095,
+  OPT_mdivsi3_libfunc_ = 1096,
+  OPT_mfixed_range_ = 1097,
+  OPT_mfldi = 1098,
+  OPT_mfmovd = 1099,
+  OPT_mfsca = 1100,
+  OPT_mfsrra = 1101,
+  OPT_mgettrcost_ = 1103,
+  OPT_mglibc = 1104,
+  OPT_mhitachi = 1105,
+  OPT_mieee = 1106,
+  OPT_mindexed_addressing = 1107,
+  OPT_minline_ic_invalidate = 1108,
+  OPT_minvalid_symbols = 1109,
+  OPT_misize = 1110,
+  OPT_ml = 1111,
+  OPT_mlate_r0r3_to_reg_mul = 1112,
+  OPT_mnomacsave = 1113,
+  OPT_mpadstruct = 1114,
+  OPT_mprefergot = 1115,
+  OPT_mpretend_cmove = 1116,
+  OPT_mpt_fixed = 1117,
+  OPT_mr0r3_to_reg_mul = 1118,
+  OPT_mrelax = 1119,
+  OPT_mrenesas = 1120,
+  OPT_mtas = 1122,
+  OPT_muclibc = 1123,
+  OPT_multcost_ = 1124,
+  OPT_musermode = 1125,
+  OPT_mzdcbranch = 1126,
+  OPT_n = 1127,
+  OPT_no_canonical_prefixes = 1128,
+  OPT_no_integrated_cpp = 1129,
+  OPT_nocpp = 1130,
+  OPT_nodefaultlibs = 1131,
+  OPT_nostartfiles = 1132,
+  OPT_nostdinc = 1133,
+  OPT_nostdinc__ = 1134,
+  OPT_nostdlib = 1135,
+  OPT_o = 1136,
+  OPT_p = 1137,
+  OPT_pass_exit_codes = 1138,
+  OPT_pedantic_errors = 1140,
+  OPT_pg = 1141,
+  OPT_pie = 1142,
+  OPT_pipe = 1143,
+  OPT_posix = 1144,
+  OPT_print_file_name_ = 1145,
+  OPT_print_libgcc_file_name = 1146,
+  OPT_print_multi_directory = 1147,
+  OPT_print_multi_lib = 1148,
+  OPT_print_multi_os_directory = 1149,
+  OPT_print_multiarch = 1150,
+  OPT_print_objc_runtime_info = 1151,
+  OPT_print_prog_name_ = 1152,
+  OPT_print_search_dirs = 1153,
+  OPT_print_sysroot = 1154,
+  OPT_print_sysroot_headers_suffix = 1155,
+  OPT_profile = 1156,
+  OPT_pthread = 1157,
+  OPT_quiet = 1158,
+  OPT_r = 1159,
+  OPT_rdynamic = 1160,
+  OPT_remap = 1161,
+  OPT_s = 1162,
+  OPT_s_bc_abi = 1163,
+  OPT_save_temps = 1164,
+  OPT_save_temps_ = 1165,
+  OPT_shared = 1166,
+  OPT_shared_libgcc = 1167,
+  OPT_specs_ = 1169,
+  OPT_static = 1170,
+  OPT_static_libasan = 1171,
+  OPT_static_libgcc = 1172,
+  OPT_static_libgcj = 1173,
+  OPT_static_libgfortran = 1174,
+  OPT_static_libgo = 1175,
+  OPT_static_libstdc__ = 1176,
+  OPT_static_libtsan = 1177,
+  OPT_std_c__11 = 1180,
+  OPT_std_c__1y = 1181,
+  OPT_std_c__98 = 1182,
+  OPT_std_c11 = 1183,
+  OPT_std_c90 = 1186,
+  OPT_std_c99 = 1187,
+  OPT_std_f2003 = 1189,
+  OPT_std_f2008 = 1190,
+  OPT_std_f2008ts = 1191,
+  OPT_std_f95 = 1192,
+  OPT_std_gnu = 1193,
+  OPT_std_gnu__11 = 1196,
+  OPT_std_gnu__1y = 1197,
+  OPT_std_gnu__98 = 1198,
+  OPT_std_gnu11 = 1199,
+  OPT_std_gnu90 = 1202,
+  OPT_std_gnu99 = 1203,
+  OPT_std_iso9899_199409 = 1206,
+  OPT_std_legacy = 1210,
+  OPT_symbolic = 1211,
+  OPT_t = 1212,
+  OPT_time = 1213,
+  OPT_time_ = 1214,
+  OPT_tno_android_cc = 1215,
+  OPT_tno_android_ld = 1216,
+  OPT_traditional = 1217,
+  OPT_traditional_cpp = 1218,
+  OPT_trigraphs = 1219,
+  OPT_u = 1220,
+  OPT_undef = 1221,
+  OPT_v = 1222,
+  OPT_version = 1223,
+  OPT_w = 1224,
+  OPT_wrapper = 1225,
+  OPT_x = 1226,
+  OPT_z = 1227,
+  N_OPTS,
+  OPT_SPECIAL_unknown,
+  OPT_SPECIAL_ignore,
+  OPT_SPECIAL_program_name,
+  OPT_SPECIAL_input_file
+};
+enum unspec {
+  UNSPEC_ATOMIC = 0
+};
+extern const char *const unspec_strings[];
+enum unspecv {
+  UNSPECV_CMPXCHG_1 = 0,
+  UNSPECV_CMPXCHG_2 = 1,
+  UNSPECV_CMPXCHG_3 = 2
+};
+extern const char *const unspecv_strings[];
+extern int code_for_indirect_jump_scratch;
+extern int assembler_dialect;
+enum sh_divide_strategy_e {
+  SH_DIV_CALL,
+  SH_DIV_CALL2,
+  SH_DIV_FP,
+  SH_DIV_INV,
+  SH_DIV_INV_MINLAT,
+  SH_DIV_INV20U,
+  SH_DIV_INV20L,
+  SH_DIV_INV_CALL,
+  SH_DIV_INV_CALL2,
+  SH_DIV_INV_FP,
+  SH_DIV_CALL_DIV1,
+  SH_DIV_CALL_FP,
+  SH_DIV_CALL_TABLE,
+  SH_DIV_CALL_PRE1,
+  SH_DIV_INTRINSIC
+};
+extern enum sh_divide_strategy_e sh_div_strategy;
+extern char sh_register_names[][5 + 1];
+extern char sh_additional_register_names[32] [4 + 1];
+enum reg_class
+{
+  NO_REGS,
+  R0_REGS,
+  R0R3_REGS,
+  PR_REGS,
+  T_REGS,
+  MAC_REGS,
+  FPUL_REGS,
+  SIBCALL_REGS,
+  NON_SP_REGS,
+  GENERAL_REGS,
+  FP0_REGS,
+  FP_REGS,
+  DF_REGS,
+  FPSCR_REGS,
+  GENERAL_FP_REGS,
+  GENERAL_DF_REGS,
+  TARGET_REGS,
+  ALL_REGS,
+  LIM_REG_CLASSES
+};
+extern enum reg_class regno_reg_class[154];
+enum sh_arg_class { SH_ARG_INT = 0, SH_ARG_FLOAT = 1 };
+struct sh_args {
+    int arg_count[2];
+    int force_mem;
+    int prototype_p;
+    int free_single_fp_reg;
+    int outgoing;
+    int stack_regs;
+    int byref_regs;
+    int byref;
+    long call_cookie;
+    int renesas_abi;
+};
+extern rtx sh_compare_op0;
+extern rtx sh_compare_op1;
+enum processor_type {
+  PROCESSOR_SH1,
+  PROCESSOR_SH2,
+  PROCESSOR_SH2E,
+  PROCESSOR_SH2A,
+  PROCESSOR_SH3,
+  PROCESSOR_SH3E,
+  PROCESSOR_SH4,
+  PROCESSOR_SH4A,
+  PROCESSOR_SH5
+};
+extern enum processor_type sh_cpu;
+enum mdep_reorg_phase_e
+{
+  SH_BEFORE_MDEP_REORG,
+  SH_INSERT_USES_LABELS,
+  SH_SHORTEN_BRANCHES0,
+  SH_FIXUP_PCLOAD,
+  SH_SHORTEN_BRANCHES1,
+  SH_AFTER_MDEP_REORG
+};
+extern enum mdep_reorg_phase_e mdep_reorg_phase;
+extern tree sh_deferred_function_attributes;
+extern tree *sh_deferred_function_attributes_tail;
+extern int current_function_interrupt;
+extern rtx gen_tstsi_t (rtx, rtx);
+extern rtx gen_tsthi_t (rtx, rtx);
+extern rtx gen_tstqi_t (rtx, rtx);
+extern rtx gen_tstsi_t_and_not (rtx);
+extern rtx gen_tstqi_t_zero_extract_eq (rtx, rtx, rtx);
+extern rtx gen_tsthi_t_zero_extract_eq (rtx, rtx, rtx);
+extern rtx gen_tstsi_t_zero_extract_eq (rtx, rtx, rtx);
+extern rtx gen_tstdi_t_zero_extract_eq (rtx, rtx, rtx);
+extern rtx gen_tstsi_t_zero_extract_xor (rtx, rtx, rtx, rtx);
+extern rtx gen_tstsi_t_zero_extract_subreg_xor_little (rtx, rtx, rtx, rtx);
+extern rtx gen_tstsi_t_zero_extract_subreg_xor_big (rtx, rtx, rtx, rtx);
+extern rtx gen_cmpeqsi_t (rtx, rtx);
+extern rtx gen_fpcmp_i1 (rtx, rtx);
+extern rtx gen_cmpgtsi_t (rtx, rtx);
+extern rtx gen_cmpgesi_t (rtx, rtx);
+extern rtx gen_cmp_div0s_0 (rtx, rtx);
+extern rtx gen_cmp_div0s_1 (rtx, rtx);
+extern rtx gen_cmpgeusi_t (rtx, rtx);
+extern rtx gen_cmpgtusi_t (rtx, rtx);
+extern rtx gen_cbranchdi4_i (rtx, rtx, rtx, rtx);
+extern rtx gen_cmpeqdi_t (rtx, rtx);
+extern rtx gen_cmpgtdi_t (rtx, rtx);
+extern rtx gen_cmpgedi_t (rtx, rtx);
+extern rtx gen_cmpgeudi_t (rtx, rtx);
+extern rtx gen_cmpgtudi_t (rtx, rtx);
+extern rtx gen_cmpeqsi_media (rtx, rtx, rtx);
+extern rtx gen_cmpeqdi_media (rtx, rtx, rtx);
+extern rtx gen_cmpgtsi_media (rtx, rtx, rtx);
+extern rtx gen_cmpgtdi_media (rtx, rtx, rtx);
+extern rtx gen_cmpgtusi_media (rtx, rtx, rtx);
+extern rtx gen_cmpgtudi_media (rtx, rtx, rtx);
+extern rtx gen_movdicc_false (rtx, rtx, rtx, rtx);
+extern rtx gen_movdicc_true (rtx, rtx, rtx, rtx);
+extern rtx gen_movsicc_false (rtx, rtx, rtx, rtx);
+extern rtx gen_movsicc_true (rtx, rtx, rtx, rtx);
+extern rtx gen_adddi3z_media (rtx, rtx, rtx);
+extern rtx gen_adddi3_compact (rtx, rtx, rtx);
+extern rtx gen_addc (rtx, rtx, rtx);
+extern rtx gen_addsi3_media (rtx, rtx, rtx);
+extern rtx gen_addsidi3_media (rtx, rtx, rtx);
+extern rtx gen_subdisi3_media (rtx, rtx, rtx);
+extern rtx gen_subdi3_compact (rtx, rtx, rtx);
+extern rtx gen_subc (rtx, rtx, rtx);
+extern rtx gen_use_sfunc_addr (rtx);
+extern rtx gen_udivsi3_sh2a (rtx, rtx, rtx);
+extern rtx gen_udivsi3_i1 (rtx, rtx);
+extern rtx gen_udivsi3_i1_media (rtx, rtx);
+extern rtx gen_udivsi3_i4 (rtx, rtx);
+extern rtx gen_udivsi3_i4_single (rtx, rtx);
+extern rtx gen_udivsi3_i4_int (rtx, rtx);
+extern rtx gen_divsi3_sh2a (rtx, rtx, rtx);
+extern rtx gen_divsi3_i1 (rtx, rtx);
+extern rtx gen_divsi3_i1_media (rtx, rtx);
+extern rtx gen_divsi3_media_2 (rtx, rtx);
+extern rtx gen_divsi_inv_call (rtx, rtx, rtx, rtx);
+extern rtx gen_divsi3_i4 (rtx, rtx);
+extern rtx gen_divsi3_i4_single (rtx, rtx);
+extern rtx gen_divsi3_i4_int (rtx, rtx);
+extern rtx gen_divsi_inv_qitable (rtx, rtx, rtx);
+extern rtx gen_divsi_inv_hitable (rtx, rtx, rtx);
+extern rtx gen_divsi_inv_m1 (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);
+extern rtx gen_divsi_inv_m2 (rtx, rtx, rtx, rtx, rtx);
+extern rtx gen_divsi_inv_m3 (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);
+extern rtx gen_divsi_inv_m1_3 (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);
+extern rtx gen_divsi_inv20 (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);
+extern rtx gen_divsi_inv_fp (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);
+extern rtx gen_umulhisi3_i (rtx, rtx);
+extern rtx gen_mulhisi3_i (rtx, rtx);
+extern rtx gen_mul_r (rtx, rtx, rtx);
+extern rtx gen_mul_l (rtx, rtx);
+extern rtx gen_mulr03 (rtx, rtx, rtx);
+extern rtx gen_mulsidi3_i (rtx, rtx);
+extern rtx gen_mulsidi3_media (rtx, rtx, rtx);
+extern rtx gen_mulsidi3_compact (rtx, rtx, rtx);
+extern rtx gen_umulsidi3_i (rtx, rtx);
+extern rtx gen_umulsidi3_media (rtx, rtx, rtx);
+extern rtx gen_umulsidi3_compact (rtx, rtx, rtx);
+extern rtx gen_smulsi3_highpart_i (rtx, rtx);
+extern rtx gen_umulsi3_highpart_i (rtx, rtx);
+extern rtx gen_muldi3 (rtx, rtx, rtx);
+extern rtx gen_anddi3 (rtx, rtx, rtx);
+extern rtx gen_andcsi3 (rtx, rtx, rtx);
+extern rtx gen_andcdi3 (rtx, rtx, rtx);
+extern rtx gen_iordi3 (rtx, rtx, rtx);
+extern rtx gen_xordi3 (rtx, rtx, rtx);
+extern rtx gen_rotldi3_mextr (rtx, rtx, rtx);
+extern rtx gen_rotrdi3_mextr (rtx, rtx, rtx);
+extern rtx gen_rotrsi3_1 (rtx, rtx);
+extern rtx gen_rotlsi3_1 (rtx, rtx);
+extern rtx gen_rotlsi3_31 (rtx, rtx);
+extern rtx gen_rotlsi3_16 (rtx, rtx);
+extern rtx gen_rotlhi3_8 (rtx, rtx);
+extern rtx gen_rotcr (rtx, rtx, rtx);
+extern rtx gen_rotcl (rtx, rtx, rtx);
+extern rtx gen_ashlsi3_k (rtx, rtx, rtx);
+extern rtx gen_ashlsi3_d (rtx, rtx, rtx);
+extern rtx gen_ashlsi3_d_call (rtx, rtx, rtx);
+extern rtx gen_ashlsi3_n (rtx, rtx, rtx);
+extern rtx gen_ashlsi3_n_clobbers_t (rtx, rtx, rtx);
+extern rtx gen_shll (rtx, rtx);
+extern rtx gen_ashlsi3_media (rtx, rtx, rtx);
+extern rtx gen_ashlhi3_k (rtx, rtx, rtx);
+extern rtx gen_ashldi3_k (rtx, rtx);
+extern rtx gen_ashldi3_media (rtx, rtx, rtx);
+extern rtx gen_shar (rtx, rtx);
+extern rtx gen_ashrsi3_k (rtx, rtx, rtx);
+extern rtx gen_ashrsi2_16 (rtx, rtx);
+extern rtx gen_ashrsi2_31 (rtx, rtx);
+extern rtx gen_ashrsi3_d (rtx, rtx, rtx);
+extern rtx gen_ashrsi3_n (rtx, rtx);
+extern rtx gen_ashrsi3_media (rtx, rtx, rtx);
+extern rtx gen_ashrdi3_k (rtx, rtx);
+extern rtx gen_ashrdi3_media (rtx, rtx, rtx);
+extern rtx gen_ashrdisi3_media_high (rtx, rtx, rtx);
+extern rtx gen_ashrdisi3_media_opaque (rtx, rtx, rtx);
+extern rtx gen_lshrsi3_k (rtx, rtx, rtx);
+extern rtx gen_lshrsi3_d (rtx, rtx, rtx);
+extern rtx gen_lshrsi3_d_call (rtx, rtx, rtx);
+extern rtx gen_lshrsi3_n (rtx, rtx, rtx);
+extern rtx gen_lshrsi3_n_clobbers_t (rtx, rtx, rtx);
+extern rtx gen_shlr (rtx, rtx);
+extern rtx gen_lshrsi3_media (rtx, rtx, rtx);
+extern rtx gen_lshrdi3_k (rtx, rtx);
+extern rtx gen_lshrdi3_media (rtx, rtx, rtx);
+extern rtx gen_and_shl_scratch (rtx, rtx, rtx, rtx, rtx, rtx);
+extern rtx gen_shl_sext_ext (rtx, rtx, rtx, rtx);
+extern rtx gen_shl_sext_sub (rtx, rtx, rtx, rtx);
+extern rtx gen_xtrct_left (rtx, rtx, rtx);
+extern rtx gen_xtrct_right (rtx, rtx, rtx);
+extern rtx gen_negc (rtx, rtx);
+extern rtx gen_negsi2 (rtx, rtx);
+extern rtx gen_one_cmplsi2 (rtx, rtx);
+extern rtx gen_negsi_cond (rtx, rtx, rtx, rtx);
+extern rtx gen_negdi_cond (rtx, rtx, rtx, rtx);
+extern rtx gen_swapbsi2 (rtx, rtx);
+extern rtx gen_zero_extendsidi2 (rtx, rtx);
+extern rtx gen_zero_extendhidi2 (rtx, rtx);
+extern rtx gen_zero_extendqidi2 (rtx, rtx);
+extern rtx gen_zero_extendqihi2 (rtx, rtx);
+extern rtx gen_extendsidi2 (rtx, rtx);
+extern rtx gen_extendhidi2 (rtx, rtx);
+extern rtx gen_extendqidi2 (rtx, rtx);
+extern rtx gen_truncdisi2 (rtx, rtx);
+extern rtx gen_truncdihi2 (rtx, rtx);
+extern rtx gen_truncdiqi2 (rtx, rtx);
+extern rtx gen_push_fpul (void);
+extern rtx gen_pop_fpul (void);
+extern rtx gen_clrt (void);
+extern rtx gen_sett (void);
+extern rtx gen_movsi_i (rtx, rtx);
+extern rtx gen_movsi_ie (rtx, rtx);
+extern rtx gen_movsi_i_lowpart (rtx, rtx);
+extern rtx gen_load_ra (rtx, rtx);
+extern rtx gen_ic_invalidate_line_i (rtx, rtx);
+extern rtx gen_ic_invalidate_line_sh4a (rtx);
+extern rtx gen_ic_invalidate_line_media (rtx);
+extern rtx gen_ic_invalidate_line_compact (rtx, rtx);
+extern rtx gen_initialize_trampoline_compact (rtx, rtx);
+extern rtx gen_shori_media (rtx, rtx, rtx);
+extern rtx gen_movdf_media (rtx, rtx);
+extern rtx gen_movdf_media_nofpu (rtx, rtx);
+extern rtx gen_movdf_k (rtx, rtx);
+extern rtx gen_movdf_i4 (rtx, rtx, rtx);
+extern rtx gen_movv2sf_i (rtx, rtx);
+extern rtx gen_movsf_media (rtx, rtx);
+extern rtx gen_movsf_media_nofpu (rtx, rtx);
+extern rtx gen_movsf_i (rtx, rtx);
+extern rtx gen_movsf_ie (rtx, rtx, rtx);
+extern rtx gen_mov_nop (rtx);
+extern rtx gen_block_branch_redirect (rtx);
+extern rtx gen_indirect_jump_scratch (rtx, rtx);
+extern rtx gen_stuff_delay_slot (rtx, rtx);
+extern rtx gen_doloop_end_split (rtx, rtx, rtx);
+extern rtx gen_jump_compact (rtx);
+extern rtx gen_jump_media (rtx);
+extern rtx gen_force_mode_for_call (void);
+extern rtx gen_calli (rtx, rtx);
+extern rtx gen_calli_tbr_rel (rtx, rtx);
+extern rtx gen_calli_pcrel (rtx, rtx, rtx);
+extern rtx gen_call_pcrel (rtx, rtx);
+extern rtx gen_call_compact (rtx, rtx, rtx);
+extern rtx gen_call_compact_rettramp (rtx, rtx, rtx);
+extern rtx gen_call_media (rtx, rtx);
+extern rtx gen_call_valuei (rtx, rtx, rtx);
+extern rtx gen_call_valuei_tbr_rel (rtx, rtx, rtx);
+extern rtx gen_call_valuei_pcrel (rtx, rtx, rtx, rtx);
+extern rtx gen_call_value_pcrel (rtx, rtx, rtx);
+extern rtx gen_call_value_compact (rtx, rtx, rtx, rtx);
+extern rtx gen_call_value_compact_rettramp (rtx, rtx, rtx, rtx);
+extern rtx gen_call_value_media (rtx, rtx, rtx);
+extern rtx gen_call_pop_compact (rtx, rtx, rtx, rtx);
+extern rtx gen_call_pop_compact_rettramp (rtx, rtx, rtx, rtx);
+extern rtx gen_sibcalli (rtx, rtx);
+extern rtx gen_sibcalli_pcrel (rtx, rtx, rtx);
+extern rtx gen_sibcalli_thunk (rtx, rtx);
+extern rtx gen_sibcall_pcrel (rtx, rtx);
+extern rtx gen_sibcall_compact (rtx, rtx, rtx);
+extern rtx gen_sibcall_media (rtx, rtx);
+extern rtx gen_sibcall_valuei (rtx, rtx, rtx);
+extern rtx gen_sibcall_valuei_pcrel (rtx, rtx, rtx, rtx);
+extern rtx gen_sibcall_value_pcrel (rtx, rtx, rtx);
+extern rtx gen_sibcall_value_compact (rtx, rtx, rtx, rtx);
+extern rtx gen_sibcall_value_media (rtx, rtx, rtx);
+extern rtx gen_call_value_pop_compact (rtx, rtx, rtx, rtx, rtx);
+extern rtx gen_call_value_pop_compact_rettramp (rtx, rtx, rtx, rtx, rtx);
+extern rtx gen_indirect_jump_compact (rtx);
+extern rtx gen_casesi_jump_1 (rtx, rtx);
+extern rtx gen_casesi_jump_2 (rtx, rtx, rtx);
+extern rtx gen_casesi_jump_media (rtx, rtx);
+extern rtx gen_dup_db_insn (void);
+extern rtx gen_dect (rtx, rtx);
+extern rtx gen_nop (void);
+extern rtx gen_mova (rtx);
+extern rtx gen_mova_const (rtx);
+extern rtx gen_ptrel_si (rtx, rtx, rtx);
+extern rtx gen_ptrel_di (rtx, rtx, rtx);
+extern rtx gen_tls_global_dynamic (rtx, rtx);
+extern rtx gen_tls_local_dynamic (rtx, rtx);
+extern rtx gen_tls_initial_exec (rtx, rtx);
+extern rtx gen_store_gbr (rtx);
+extern rtx gen_load_gbr (rtx);
+extern rtx gen_casesi_worker_0 (rtx, rtx, rtx);
+extern rtx gen_casesi_worker_1 (rtx, rtx, rtx);
+extern rtx gen_casesi_worker_2 (rtx, rtx, rtx, rtx, rtx);
+extern rtx gen_casesi_shift_media (rtx, rtx, rtx);
+extern rtx gen_casesi_load_media (rtx, rtx, rtx, rtx);
+static inline rtx gen_trap (void);
+static inline rtx
+gen_trap(void)
+{
+  return 0;
+}
+extern rtx gen_shcompact_return_tramp_i (void);
+extern rtx gen_return_media_i (rtx);
+extern rtx gen_return_media_rte (void);
+extern rtx gen_shcompact_preserve_incoming_args (rtx);
+extern rtx gen_shcompact_incoming_args (void);
+extern rtx gen_shmedia_save_restore_regs_compact (rtx);
+extern rtx gen_eh_set_ra_si (rtx);
+extern rtx gen_eh_set_ra_di (rtx);
+extern rtx gen_blockage (void);
+extern rtx gen_movml_push_banked (rtx);
+extern rtx gen_movml_pop_banked (rtx);
+extern rtx gen_movt (rtx, rtx);
+extern rtx gen_movrt (rtx, rtx);
+extern rtx gen_movrt_negc (rtx, rtx, rtx);
+extern rtx gen_movrt_xor (rtx, rtx);
+extern rtx gen_mov_neg_si_t (rtx, rtx);
+extern rtx gen_nott (rtx);
+extern rtx gen_consttable_2 (rtx, rtx);
+extern rtx gen_consttable_4 (rtx, rtx);
+extern rtx gen_consttable_8 (rtx, rtx);
+extern rtx gen_consttable_sf (rtx, rtx);
+extern rtx gen_consttable_df (rtx, rtx);
+extern rtx gen_align_log (rtx);
+extern rtx gen_consttable_end (void);
+extern rtx gen_consttable_window_end (rtx);
+extern rtx gen_block_move_real (rtx);
+extern rtx gen_block_lump_real (rtx);
+extern rtx gen_block_move_real_i4 (rtx);
+extern rtx gen_block_lump_real_i4 (rtx);
+extern rtx gen_cmpstr_t (rtx, rtx);
+extern rtx gen_fpu_switch (rtx, rtx);
+extern rtx gen_toggle_sz (void);
+extern rtx gen_toggle_pr (void);
+extern rtx gen_unary_sf_op (rtx, rtx, rtx, rtx, rtx);
+extern rtx gen_binary_sf_op0 (rtx, rtx, rtx, rtx);
+extern rtx gen_binary_sf_op1 (rtx, rtx, rtx, rtx);
+static inline rtx gen_addsf3_i3 (rtx, rtx);
+static inline rtx
+gen_addsf3_i3(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)))
+{
+  return 0;
+}
+extern rtx gen_addsf3_i (rtx, rtx, rtx, rtx);
+static inline rtx gen_subsf3_i3 (rtx, rtx);
+static inline rtx
+gen_subsf3_i3(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)))
+{
+  return 0;
+}
+extern rtx gen_subsf3_i (rtx, rtx, rtx, rtx);
+static inline rtx gen_mulsf3_i3 (rtx, rtx);
+static inline rtx
+gen_mulsf3_i3(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)))
+{
+  return 0;
+}
+extern rtx gen_mulsf3_i (rtx, rtx, rtx, rtx);
+extern rtx gen_fmasf4_i (rtx, rtx, rtx, rtx, rtx);
+extern rtx gen_fmasf4_media (rtx, rtx, rtx, rtx);
+extern rtx gen_divsf3_i (rtx, rtx, rtx, rtx);
+extern rtx gen_floatdisf2 (rtx, rtx);
+extern rtx gen_floatsisf2_i4 (rtx, rtx, rtx);
+extern rtx gen_fix_truncsfdi2 (rtx, rtx);
+extern rtx gen_fix_truncsfsi2_i4 (rtx, rtx, rtx);
+extern rtx gen_cmpnedf_i1 (rtx, rtx);
+extern rtx gen_cmpgtdf_i1 (rtx, rtx);
+extern rtx gen_cmpunltdf_i1 (rtx, rtx);
+extern rtx gen_cmpeqdf_i1_finite (rtx, rtx);
+extern rtx gen_cmpundf_i1 (rtx, rtx, rtx);
+extern rtx gen_cmpuneqdf_i1 (rtx, rtx, rtx);
+extern rtx gen_cmpgtsf_t (rtx, rtx);
+extern rtx gen_cmpeqsf_t (rtx, rtx);
+extern rtx gen_ieee_ccmpeqsf_t (rtx, rtx);
+extern rtx gen_cmpgtsf_t_i4 (rtx, rtx, rtx);
+extern rtx gen_cmpeqsf_t_i4 (rtx, rtx, rtx);
+extern rtx gen_cmpeqsf_media (rtx, rtx, rtx);
+extern rtx gen_cmpgtsf_media (rtx, rtx, rtx);
+extern rtx gen_cmpgesf_media (rtx, rtx, rtx);
+extern rtx gen_cmpunsf_media (rtx, rtx, rtx);
+extern rtx gen_negsf2_i (rtx, rtx, rtx);
+extern rtx gen_sqrtsf2_i (rtx, rtx, rtx);
+extern rtx gen_rsqrtsf2 (rtx, rtx, rtx, rtx);
+extern rtx gen_fsca (rtx, rtx, rtx, rtx);
+extern rtx gen_abssf2_i (rtx, rtx, rtx);
+static inline rtx gen_abssc2_i3 (rtx, rtx);
+static inline rtx
+gen_abssc2_i3(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)))
+{
+  return 0;
+}
+extern rtx gen_adddf3_i (rtx, rtx, rtx, rtx);
+extern rtx gen_adddf3_i3 (rtx);
+extern rtx gen_subdf3_i (rtx, rtx, rtx, rtx);
+extern rtx gen_muldf3_i (rtx, rtx, rtx, rtx);
+extern rtx gen_muldf3_i3 (rtx);
+extern rtx gen_divdf3_i (rtx, rtx, rtx, rtx);
+extern rtx gen_floatdidf2 (rtx, rtx);
+extern rtx gen_floatsidf2_i (rtx, rtx, rtx);
+extern rtx gen_fix_truncdfdi2 (rtx, rtx);
+extern rtx gen_fix_truncdfsi2_i (rtx, rtx, rtx);
+extern rtx gen_cmpgtdf_t (rtx, rtx, rtx);
+extern rtx gen_cmpeqdf_t (rtx, rtx, rtx);
+extern rtx gen_cmpeqdf_media (rtx, rtx, rtx);
+extern rtx gen_cmpgtdf_media (rtx, rtx, rtx);
+extern rtx gen_cmpgedf_media (rtx, rtx, rtx);
+extern rtx gen_cmpundf_media (rtx, rtx, rtx);
+extern rtx gen_negdf2_i (rtx, rtx, rtx);
+extern rtx gen_sqrtdf2_i (rtx, rtx, rtx);
+extern rtx gen_absdf2_i (rtx, rtx, rtx);
+extern rtx gen_extendsfdf2_i4 (rtx, rtx, rtx);
+extern rtx gen_extendsfdf2_i1 (rtx, rtx);
+extern rtx gen_extendsfdf2_i1_r0 (rtx);
+extern rtx gen_extendsfdf2_i2e (rtx, rtx);
+extern rtx gen_extendsfdf2_i2e_r0 (rtx);
+extern rtx gen_truncdfsf2_i4 (rtx, rtx, rtx);
+extern rtx gen_truncdfsf2_i1 (rtx, rtx);
+extern rtx gen_truncdfsf2_i2e (rtx, rtx);
+extern rtx gen_movua (rtx, rtx);
+extern rtx gen_bclr_m2a (rtx, rtx);
+extern rtx gen_bclrmem_m2a (rtx, rtx);
+extern rtx gen_bset_m2a (rtx, rtx);
+extern rtx gen_bsetmem_m2a (rtx, rtx);
+extern rtx gen_bst_m2a (rtx, rtx);
+extern rtx gen_bld_m2a (rtx, rtx);
+extern rtx gen_bldsign_m2a (rtx, rtx);
+extern rtx gen_bld_reg (rtx, rtx);
+extern rtx gen_band_m2a (rtx, rtx);
+extern rtx gen_bandreg_m2a (rtx, rtx, rtx, rtx);
+extern rtx gen_bor_m2a (rtx, rtx);
+extern rtx gen_borreg_m2a (rtx, rtx, rtx, rtx);
+extern rtx gen_bxor_m2a (rtx, rtx);
+extern rtx gen_bxorreg_m2a (rtx, rtx, rtx, rtx);
+extern rtx gen_sp_switch_1 (rtx);
+extern rtx gen_sp_switch_2 (void);
+extern rtx gen_movv8qi_i (rtx, rtx);
+extern rtx gen_movv2hi_i (rtx, rtx);
+extern rtx gen_movv4hi_i (rtx, rtx);
+extern rtx gen_movv2si_i (rtx, rtx);
+extern rtx gen_absv2si2 (rtx, rtx);
+extern rtx gen_absv4hi2 (rtx, rtx);
+extern rtx gen_addv2si3 (rtx, rtx, rtx);
+extern rtx gen_addv4hi3 (rtx, rtx, rtx);
+extern rtx gen_addv2hi3 (rtx, rtx, rtx);
+extern rtx gen_ssaddv2si3 (rtx, rtx, rtx);
+extern rtx gen_usaddv8qi3 (rtx, rtx, rtx);
+extern rtx gen_ssaddv4hi3 (rtx, rtx, rtx);
+extern rtx gen_negcmpeqv8qi (rtx, rtx, rtx);
+extern rtx gen_negcmpeqv2si (rtx, rtx, rtx);
+extern rtx gen_negcmpeqv4hi (rtx, rtx, rtx);
+extern rtx gen_negcmpgtuv8qi (rtx, rtx, rtx);
+extern rtx gen_negcmpgtv2si (rtx, rtx, rtx);
+extern rtx gen_negcmpgtv4hi (rtx, rtx, rtx);
+extern rtx gen_mcmv (rtx, rtx, rtx, rtx);
+extern rtx gen_mcnvs_lw (rtx, rtx, rtx);
+extern rtx gen_mcnvs_wb (rtx, rtx, rtx);
+extern rtx gen_mcnvs_wub (rtx, rtx, rtx);
+extern rtx gen_mextr_rl (rtx, rtx, rtx, rtx, rtx);
+extern rtx gen_mmacfx_wl_i (rtx, rtx, rtx, rtx);
+extern rtx gen_mmacnfx_wl_i (rtx, rtx, rtx, rtx);
+extern rtx gen_mulv2si3 (rtx, rtx, rtx);
+extern rtx gen_mulv4hi3 (rtx, rtx, rtx);
+extern rtx gen_mmulfx_l (rtx, rtx, rtx);
+extern rtx gen_mmulfx_w (rtx, rtx, rtx);
+extern rtx gen_mmulfxrp_w (rtx, rtx, rtx);
+extern rtx gen_mmul23_wl (rtx, rtx, rtx);
+extern rtx gen_mmul01_wl (rtx, rtx, rtx);
+extern rtx gen_mmulsum_wq_i (rtx, rtx, rtx, rtx);
+extern rtx gen_mperm_w_little (rtx, rtx, rtx);
+extern rtx gen_mperm_w_big (rtx, rtx, rtx);
+extern rtx gen_mperm_w0 (rtx, rtx);
+extern rtx gen_msad_ubq_i (rtx, rtx, rtx, rtx);
+extern rtx gen_mshalds_l (rtx, rtx, rtx);
+extern rtx gen_mshalds_w (rtx, rtx, rtx);
+extern rtx gen_ashrv2si3 (rtx, rtx, rtx);
+extern rtx gen_ashrv4hi3 (rtx, rtx, rtx);
+extern rtx gen_mshards_q (rtx, rtx, rtx);
+extern rtx gen_mshf4_b (rtx, rtx, rtx);
+extern rtx gen_mshf0_b (rtx, rtx, rtx);
+extern rtx gen_mshf4_l (rtx, rtx, rtx);
+extern rtx gen_mshf0_l (rtx, rtx, rtx);
+extern rtx gen_mshf4_w (rtx, rtx, rtx);
+extern rtx gen_mshf0_w (rtx, rtx, rtx);
+extern rtx gen_mshflo_w_x (rtx, rtx, rtx);
+extern rtx gen_mshfhi_l_di (rtx, rtx, rtx);
+extern rtx gen_mshflo_l_di (rtx, rtx, rtx);
+extern rtx gen_concat_v2sf (rtx, rtx, rtx);
+extern rtx gen_ashlv2si3 (rtx, rtx, rtx);
+extern rtx gen_ashlv4hi3 (rtx, rtx, rtx);
+extern rtx gen_lshrv2si3 (rtx, rtx, rtx);
+extern rtx gen_lshrv4hi3 (rtx, rtx, rtx);
+extern rtx gen_subv2si3 (rtx, rtx, rtx);
+extern rtx gen_subv4hi3 (rtx, rtx, rtx);
+extern rtx gen_subv2hi3 (rtx, rtx, rtx);
+extern rtx gen_sssubv2si3 (rtx, rtx, rtx);
+extern rtx gen_ussubv8qi3 (rtx, rtx, rtx);
+extern rtx gen_sssubv4hi3 (rtx, rtx, rtx);
+extern rtx gen_fcosa_s (rtx, rtx);
+extern rtx gen_fsina_s (rtx, rtx);
+extern rtx gen_fipr (rtx, rtx, rtx);
+extern rtx gen_fsrra_s (rtx, rtx);
+extern rtx gen_ftrv (rtx, rtx, rtx);
+extern rtx gen_ldhi_l (rtx, rtx);
+extern rtx gen_ldhi_q (rtx, rtx);
+extern rtx gen_ldlo_l (rtx, rtx);
+extern rtx gen_ldlo_q (rtx, rtx);
+extern rtx gen_sthi_l (rtx, rtx);
+extern rtx gen_sthi_q (rtx, rtx);
+extern rtx gen_stlo_l (rtx, rtx);
+extern rtx gen_stlo_q (rtx, rtx);
+extern rtx gen_ldhi_l64 (rtx, rtx);
+extern rtx gen_ldhi_q64 (rtx, rtx);
+extern rtx gen_ldlo_l64 (rtx, rtx);
+extern rtx gen_ldlo_q64 (rtx, rtx);
+extern rtx gen_sthi_l64 (rtx, rtx);
+extern rtx gen_sthi_q64 (rtx, rtx);
+extern rtx gen_stlo_l64 (rtx, rtx);
+extern rtx gen_stlo_q64 (rtx, rtx);
+extern rtx gen_nsb (rtx, rtx);
+extern rtx gen_nsbsi (rtx, rtx);
+extern rtx gen_nsbdi (rtx, rtx);
+extern rtx gen_byterev (rtx, rtx);
+extern rtx gen_alloco_i (rtx);
+extern rtx gen_stack_protect_set_si (rtx, rtx);
+extern rtx gen_stack_protect_set_si_media (rtx, rtx);
+extern rtx gen_stack_protect_set_di_media (rtx, rtx);
+extern rtx gen_stack_protect_test_si (rtx, rtx);
+extern rtx gen_stack_protect_test_si_media (rtx, rtx, rtx);
+extern rtx gen_stack_protect_test_di_media (rtx, rtx, rtx);
+extern rtx gen_atomic_compare_and_swapsi_hard (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_compare_and_swapqi_hard (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_compare_and_swaphi_hard (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_compare_and_swapqi_soft_gusa (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_compare_and_swaphi_soft_gusa (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_compare_and_swapsi_soft_gusa (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_compare_and_swapqi_soft_tcb (rtx, rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_compare_and_swaphi_soft_tcb (rtx, rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_compare_and_swapsi_soft_tcb (rtx, rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_compare_and_swapqi_soft_imask (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_compare_and_swaphi_soft_imask (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_compare_and_swapsi_soft_imask (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_exchangesi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_exchangeqi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_exchangehi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_exchangeqi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_exchangehi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_exchangesi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_exchangeqi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_exchangehi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_exchangesi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_exchangeqi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_atomic_exchangehi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_atomic_exchangesi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_addsi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_subsi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_orsi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_xorsi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_andsi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_addqi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_subqi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_orqi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_xorqi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_andqi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_addhi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_subhi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_orhi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_xorhi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_andhi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_addqi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_subqi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_orqi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_xorqi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_andqi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_addhi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_subhi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_orhi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_xorhi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_andhi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_addsi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_subsi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_orsi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_xorsi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_andsi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_addqi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_subqi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_orqi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_xorqi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_andqi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_addhi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_subhi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_orhi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_xorhi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_andhi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_addsi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_subsi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_orsi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_xorsi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_andsi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_addqi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_subqi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_orqi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_xorqi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_andqi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_addhi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_subhi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_orhi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_xorhi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_andhi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_addsi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_subsi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_orsi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_xorsi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_andsi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_nandsi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_nandqi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_nandhi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_nandqi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_nandhi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_nandsi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_nandqi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_nandhi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_nandsi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_nandqi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_nandhi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_nandsi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_atomic_add_fetchsi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_sub_fetchsi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_or_fetchsi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_xor_fetchsi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_and_fetchsi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_add_fetchqi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_sub_fetchqi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_or_fetchqi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_xor_fetchqi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_and_fetchqi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_add_fetchhi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_sub_fetchhi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_or_fetchhi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_xor_fetchhi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_and_fetchhi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_add_fetchqi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_sub_fetchqi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_or_fetchqi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_xor_fetchqi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_and_fetchqi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_add_fetchhi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_sub_fetchhi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_or_fetchhi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_xor_fetchhi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_and_fetchhi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_add_fetchsi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_sub_fetchsi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_or_fetchsi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_xor_fetchsi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_and_fetchsi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_add_fetchqi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_sub_fetchqi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_or_fetchqi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_xor_fetchqi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_and_fetchqi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_add_fetchhi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_sub_fetchhi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_or_fetchhi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_xor_fetchhi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_and_fetchhi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_add_fetchsi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_sub_fetchsi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_or_fetchsi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_xor_fetchsi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_and_fetchsi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_add_fetchqi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_atomic_sub_fetchqi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_atomic_or_fetchqi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_atomic_xor_fetchqi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_atomic_and_fetchqi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_atomic_add_fetchhi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_atomic_sub_fetchhi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_atomic_or_fetchhi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_atomic_xor_fetchhi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_atomic_and_fetchhi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_atomic_add_fetchsi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_atomic_sub_fetchsi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_atomic_or_fetchsi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_atomic_xor_fetchsi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_atomic_and_fetchsi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_atomic_nand_fetchsi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_nand_fetchqi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_nand_fetchhi_hard (rtx, rtx, rtx);
+extern rtx gen_atomic_nand_fetchqi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_nand_fetchhi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_nand_fetchsi_soft_gusa (rtx, rtx, rtx);
+extern rtx gen_atomic_nand_fetchqi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_nand_fetchhi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_nand_fetchsi_soft_tcb (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_nand_fetchqi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_atomic_nand_fetchhi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_atomic_nand_fetchsi_soft_imask (rtx, rtx, rtx);
+extern rtx gen_tasb (rtx);
+extern rtx gen_atomic_test_and_set_soft_gusa (rtx, rtx);
+extern rtx gen_atomic_test_and_set_soft_tcb (rtx, rtx, rtx);
+extern rtx gen_atomic_test_and_set_soft_imask (rtx, rtx);
+extern rtx gen_atomic_test_and_set_hard (rtx, rtx);
+extern rtx gen_cbranchsi4 (rtx, rtx, rtx, rtx);
+extern rtx gen_cbranchdi4 (rtx, rtx, rtx, rtx);
+extern rtx gen_movdicc (rtx, rtx, rtx, rtx);
+extern rtx gen_movsicc (rtx, rtx, rtx, rtx);
+extern rtx gen_movqicc (rtx, rtx, rtx, rtx);
+extern rtx gen_adddi3 (rtx, rtx, rtx);
+extern rtx gen_addsi3 (rtx, rtx, rtx);
+extern rtx gen_subdi3 (rtx, rtx, rtx);
+extern rtx gen_subsi3 (rtx, rtx, rtx);
+extern rtx gen_udivsi3_i4_media (rtx, rtx, rtx);
+extern rtx gen_udivsi3 (rtx, rtx, rtx);
+extern rtx gen_divsi3_i4_media (rtx, rtx, rtx);
+extern rtx gen_divsi3 (rtx, rtx, rtx);
+extern rtx gen_divsi_inv_m0 (rtx, rtx, rtx, rtx, rtx, rtx);
+extern rtx gen_mulhisi3 (rtx, rtx, rtx);
+extern rtx gen_umulhisi3 (rtx, rtx, rtx);
+extern rtx gen_mulsi3_call (rtx, rtx, rtx, rtx);
+extern rtx gen_mulsi3 (rtx, rtx, rtx);
+extern rtx gen_mulsidi3 (rtx, rtx, rtx);
+extern rtx gen_umulsidi3 (rtx, rtx, rtx);
+extern rtx gen_smulsi3_highpart (rtx, rtx, rtx);
+extern rtx gen_umulsi3_highpart (rtx, rtx, rtx);
+extern rtx gen_andsi3 (rtx, rtx, rtx);
+extern rtx gen_iorsi3 (rtx, rtx, rtx);
+extern rtx gen_xorsi3 (rtx, rtx, rtx);
+extern rtx gen_rotldi3 (rtx, rtx, rtx);
+extern rtx gen_rotrdi3 (rtx, rtx, rtx);
+extern rtx gen_rotrsi3 (rtx, rtx, rtx);
+extern rtx gen_rotlsi3 (rtx, rtx, rtx);
+extern rtx gen_rotlhi3 (rtx, rtx, rtx);
+extern rtx gen_ashlsi3 (rtx, rtx, rtx);
+extern rtx gen_ashlhi3 (rtx, rtx, rtx);
+extern rtx gen_ashldi3 (rtx, rtx, rtx);
+extern rtx gen_ashldi3_std (rtx, rtx, rtx);
+extern rtx gen_ashrsi3 (rtx, rtx, rtx);
+extern rtx gen_ashrdi3 (rtx, rtx, rtx);
+extern rtx gen_lshrsi3 (rtx, rtx, rtx);
+extern rtx gen_lshrdi3 (rtx, rtx, rtx);
+extern rtx gen_negdi2 (rtx, rtx);
+extern rtx gen_one_cmpldi2 (rtx, rtx);
+extern rtx gen_abssi2 (rtx, rtx);
+extern rtx gen_absdi2 (rtx, rtx);
+extern rtx gen_bswapsi2 (rtx, rtx);
+extern rtx gen_zero_extendqisi2 (rtx, rtx);
+extern rtx gen_zero_extendhisi2 (rtx, rtx);
+extern rtx gen_extendqisi2 (rtx, rtx);
+extern rtx gen_extendhisi2 (rtx, rtx);
+extern rtx gen_extendqihi2 (rtx, rtx);
+extern rtx gen_push (rtx);
+extern rtx gen_pop (rtx);
+extern rtx gen_push_e (rtx);
+extern rtx gen_push_4 (rtx);
+extern rtx gen_pop_e (rtx);
+extern rtx gen_pop_4 (rtx);
+extern rtx gen_push_fpscr (void);
+extern rtx gen_pop_fpscr (void);
+extern rtx gen_movsi_const (rtx, rtx);
+extern rtx gen_movsi_const_16bit (rtx, rtx);
+extern rtx gen_movsi (rtx, rtx);
+extern rtx gen_ic_invalidate_line (rtx);
+extern rtx gen_initialize_trampoline (rtx, rtx, rtx);
+extern rtx gen_movhi (rtx, rtx);
+extern rtx gen_movqi (rtx, rtx);
+extern rtx gen_reload_inqi (rtx, rtx, rtx);
+extern rtx gen_reload_inhi (rtx, rtx, rtx);
+extern rtx gen_movdi_const (rtx, rtx);
+extern rtx gen_movdi_const_32bit (rtx, rtx);
+extern rtx gen_movdi_const_16bit (rtx, rtx);
+extern rtx gen_movdi (rtx, rtx);
+extern rtx gen_reload_indf__frn (rtx, rtx, rtx);
+extern rtx gen_reload_outdf__RnFRm (rtx, rtx, rtx);
+extern rtx gen_movdf (rtx, rtx);
+extern rtx gen_movv2sf (rtx, rtx);
+extern rtx gen_addv2sf3 (rtx, rtx, rtx);
+extern rtx gen_subv2sf3 (rtx, rtx, rtx);
+extern rtx gen_mulv2sf3 (rtx, rtx, rtx);
+extern rtx gen_divv2sf3 (rtx, rtx, rtx);
+extern rtx gen_movv4sf (rtx, rtx);
+extern rtx gen_movv16sf (rtx, rtx);
+extern rtx gen_movsf (rtx, rtx);
+extern rtx gen_reload_insf__frn (rtx, rtx, rtx);
+extern rtx gen_reload_insi__i_fpul (rtx, rtx, rtx);
+extern rtx gen_ptabs (rtx, rtx);
+extern rtx gen_branch_true (rtx);
+extern rtx gen_branch_false (rtx);
+extern rtx gen_cbranchint4_media (rtx, rtx, rtx, rtx);
+extern rtx gen_cbranchfp4_media (rtx, rtx, rtx, rtx);
+extern rtx gen_doloop_end (rtx, rtx, rtx, rtx, rtx, rtx);
+extern rtx gen_jump (rtx);
+extern rtx gen_call (rtx, rtx, rtx);
+extern rtx gen_call_pop (rtx, rtx, rtx, rtx);
+extern rtx gen_call_value (rtx, rtx, rtx, rtx);
+extern rtx gen_sibcall (rtx, rtx, rtx);
+extern rtx gen_sibcall_value (rtx, rtx, rtx, rtx);
+extern rtx gen_call_value_pop (rtx, rtx, rtx, rtx, rtx);
+extern rtx gen_sibcall_epilogue (void);
+extern rtx gen_indirect_jump (rtx);
+extern rtx gen_untyped_call (rtx, rtx, rtx);
+extern rtx gen_GOTaddr2picreg (void);
+static inline rtx gen_vxworks_picreg (rtx, rtx);
+static inline rtx
+gen_vxworks_picreg(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)))
+{
+  return 0;
+}
+extern rtx gen_builtin_setjmp_receiver (rtx);
+extern rtx gen_call_site (void);
+extern rtx gen_sym_label2reg (rtx, rtx, rtx);
+extern rtx gen_symGOT_load (rtx, rtx);
+extern rtx gen_sym2GOT (rtx);
+extern rtx gen_symGOT2reg (rtx, rtx);
+extern rtx gen_symGOTPLT2reg (rtx, rtx);
+extern rtx gen_sym2GOTOFF (rtx);
+extern rtx gen_symGOTOFF2reg (rtx, rtx);
+extern rtx gen_symPLT_label2reg (rtx, rtx, rtx);
+extern rtx gen_sym2PIC (rtx);
+extern rtx gen_sym2DTPOFF (rtx);
+extern rtx gen_symDTPOFF2reg (rtx, rtx, rtx);
+extern rtx gen_sym2GOTTPOFF (rtx);
+extern rtx gen_sym2TPOFF (rtx);
+extern rtx gen_symTPOFF2reg (rtx, rtx);
+extern rtx gen_get_thread_pointersi (rtx);
+extern rtx gen_set_thread_pointersi (rtx);
+extern rtx gen_casesi (rtx, rtx, rtx, rtx, rtx);
+extern rtx gen_casesi_0 (rtx, rtx, rtx, rtx, rtx);
+extern rtx gen_simple_return (void);
+extern rtx gen_return (void);
+extern rtx gen_shcompact_return_tramp (void);
+extern rtx gen_return_media (void);
+extern rtx gen_prologue (void);
+extern rtx gen_epilogue (void);
+extern rtx gen_eh_return (rtx);
+extern rtx gen_cstore4_media (rtx, rtx, rtx, rtx);
+extern rtx gen_cstoresi4 (rtx, rtx, rtx, rtx);
+extern rtx gen_cstoredi4 (rtx, rtx, rtx, rtx);
+extern rtx gen_sunle (rtx);
+extern rtx gen_movnegt (rtx, rtx);
+extern rtx gen_cstoresf4 (rtx, rtx, rtx, rtx);
+extern rtx gen_cstoredf4 (rtx, rtx, rtx, rtx);
+extern rtx gen_align_2 (void);
+extern rtx gen_align_4 (void);
+extern rtx gen_movmemsi (rtx, rtx, rtx, rtx);
+extern rtx gen_cmpstrsi (rtx, rtx, rtx, rtx);
+extern rtx gen_cmpstrnsi (rtx, rtx, rtx, rtx, rtx);
+extern rtx gen_strlensi (rtx, rtx, rtx, rtx);
+extern rtx gen_movpsi (rtx, rtx);
+extern rtx gen_addsf3 (rtx, rtx, rtx);
+extern rtx gen_subsf3 (rtx, rtx, rtx);
+extern rtx gen_mulsf3 (rtx, rtx, rtx);
+extern rtx gen_fmasf4 (rtx, rtx, rtx, rtx);
+extern rtx gen_divsf3 (rtx, rtx, rtx);
+extern rtx gen_floatsisf2 (rtx, rtx);
+extern rtx gen_fix_truncsfsi2 (rtx, rtx);
+extern rtx gen_cbranchsf4 (rtx, rtx, rtx, rtx);
+extern rtx gen_negsf2 (rtx, rtx);
+extern rtx gen_sqrtsf2 (rtx, rtx);
+extern rtx gen_sincossf3 (rtx, rtx, rtx);
+extern rtx gen_abssf2 (rtx, rtx);
+static inline rtx gen_abssc2 (rtx, rtx);
+static inline rtx
+gen_abssc2(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)))
+{
+  return 0;
+}
+extern rtx gen_adddf3 (rtx, rtx, rtx);
+extern rtx gen_adddf3_i3_wrap (rtx, rtx);
+extern rtx gen_subdf3 (rtx, rtx, rtx);
+extern rtx gen_muldf3 (rtx, rtx, rtx);
+extern rtx gen_muldf3_i3_wrap (rtx, rtx);
+extern rtx gen_divdf3 (rtx, rtx, rtx);
+extern rtx gen_floatsidf2 (rtx, rtx);
+extern rtx gen_fix_truncdfsi2 (rtx, rtx);
+extern rtx gen_cbranchdf4 (rtx, rtx, rtx, rtx);
+extern rtx gen_negdf2 (rtx, rtx);
+extern rtx gen_sqrtdf2 (rtx, rtx);
+extern rtx gen_absdf2 (rtx, rtx);
+extern rtx gen_extendsfdf2 (rtx, rtx);
+extern rtx gen_truncdfsf2 (rtx, rtx);
+extern rtx gen_insv (rtx, rtx, rtx, rtx);
+extern rtx gen_extv (rtx, rtx, rtx, rtx);
+extern rtx gen_extzv (rtx, rtx, rtx, rtx);
+extern rtx gen_lrintsfsi2 (rtx, rtx);
+extern rtx gen_lroundsfsi2 (rtx, rtx);
+extern rtx gen_movv8qi (rtx, rtx);
+extern rtx gen_movv2hi (rtx, rtx);
+extern rtx gen_movv4hi (rtx, rtx);
+extern rtx gen_movv2si (rtx, rtx);
+extern rtx gen_mextr1 (rtx, rtx, rtx);
+extern rtx gen_mextr2 (rtx, rtx, rtx);
+extern rtx gen_mextr3 (rtx, rtx, rtx);
+extern rtx gen_mextr4 (rtx, rtx, rtx);
+extern rtx gen_mextr5 (rtx, rtx, rtx);
+extern rtx gen_mextr6 (rtx, rtx, rtx);
+extern rtx gen_mextr7 (rtx, rtx, rtx);
+extern rtx gen_mmacfx_wl (rtx, rtx, rtx, rtx);
+extern rtx gen_mmacnfx_wl (rtx, rtx, rtx, rtx);
+extern rtx gen_mmulhi_wl (rtx, rtx, rtx);
+extern rtx gen_mmullo_wl (rtx, rtx, rtx);
+extern rtx gen_mmulsum_wq (rtx, rtx, rtx, rtx);
+extern rtx gen_mperm_w (rtx, rtx, rtx);
+extern rtx gen_msad_ubq (rtx, rtx, rtx, rtx);
+extern rtx gen_mshfhi_b (rtx, rtx, rtx);
+extern rtx gen_mshflo_b (rtx, rtx, rtx);
+extern rtx gen_mshfhi_l (rtx, rtx, rtx);
+extern rtx gen_mshflo_l (rtx, rtx, rtx);
+extern rtx gen_mshfhi_w (rtx, rtx, rtx);
+extern rtx gen_mshflo_w (rtx, rtx, rtx);
+extern rtx gen_ffsdi2 (rtx, rtx);
+extern rtx gen_ffssi2 (rtx, rtx);
+extern rtx gen_prefetch (rtx, rtx, rtx);
+extern rtx gen_stack_protect_set (rtx, rtx);
+extern rtx gen_stack_protect_test (rtx, rtx, rtx);
+extern rtx gen_atomic_compare_and_swapqi (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_compare_and_swaphi (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_compare_and_swapsi (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_exchangeqi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_exchangehi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_exchangesi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_addqi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_subqi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_orqi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_xorqi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_andqi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_addhi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_subhi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_orhi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_xorhi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_andhi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_addsi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_subsi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_orsi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_xorsi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_andsi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_nandqi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_nandhi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_fetch_nandsi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_add_fetchqi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_sub_fetchqi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_or_fetchqi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_xor_fetchqi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_and_fetchqi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_add_fetchhi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_sub_fetchhi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_or_fetchhi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_xor_fetchhi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_and_fetchhi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_add_fetchsi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_sub_fetchsi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_or_fetchsi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_xor_fetchsi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_and_fetchsi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_nand_fetchqi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_nand_fetchhi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_nand_fetchsi (rtx, rtx, rtx, rtx);
+extern rtx gen_atomic_test_and_set (rtx, rtx, rtx);
+       
+struct function;
+extern void statistics_early_init (void);
+extern void statistics_init (void);
+extern void statistics_fini (void);
+extern void statistics_fini_pass (void);
+extern void statistics_counter_event (struct function *, const char *, int);
+extern void statistics_histogram_event (struct function *, const char *, int);
+enum machine_mode
+{
+  VOIDmode,
+  BLKmode,
+  CCmode,
+  CC_FP_NEmode,
+  CC_FP_GTmode,
+  CC_FP_UNLTmode,
+  BImode,
+  QImode,
+  HImode,
+  SImode,
+  DImode,
+  TImode,
+  PSImode,
+  PDImode,
+  QQmode,
+  HQmode,
+  SQmode,
+  DQmode,
+  TQmode,
+  UQQmode,
+  UHQmode,
+  USQmode,
+  UDQmode,
+  UTQmode,
+  HAmode,
+  SAmode,
+  DAmode,
+  TAmode,
+  UHAmode,
+  USAmode,
+  UDAmode,
+  UTAmode,
+  SFmode,
+  DFmode,
+  SDmode,
+  DDmode,
+  TDmode,
+  CQImode,
+  CHImode,
+  CSImode,
+  CDImode,
+  CTImode,
+  SCmode,
+  DCmode,
+  V2QImode,
+  V4QImode,
+  V2HImode,
+  V8QImode,
+  V4HImode,
+  V2SImode,
+  V16QImode,
+  V8HImode,
+  V4SImode,
+  V2DImode,
+  V4DImode,
+  V8DImode,
+  V2SFmode,
+  V4SFmode,
+  V2DFmode,
+  V16SFmode,
+  MAX_MACHINE_MODE,
+  MIN_MODE_RANDOM = VOIDmode,
+  MAX_MODE_RANDOM = BLKmode,
+  MIN_MODE_CC = CCmode,
+  MAX_MODE_CC = CC_FP_UNLTmode,
+  MIN_MODE_INT = QImode,
+  MAX_MODE_INT = TImode,
+  MIN_MODE_PARTIAL_INT = PSImode,
+  MAX_MODE_PARTIAL_INT = PDImode,
+  MIN_MODE_FRACT = QQmode,
+  MAX_MODE_FRACT = TQmode,
+  MIN_MODE_UFRACT = UQQmode,
+  MAX_MODE_UFRACT = UTQmode,
+  MIN_MODE_ACCUM = HAmode,
+  MAX_MODE_ACCUM = TAmode,
+  MIN_MODE_UACCUM = UHAmode,
+  MAX_MODE_UACCUM = UTAmode,
+  MIN_MODE_FLOAT = SFmode,
+  MAX_MODE_FLOAT = DFmode,
+  MIN_MODE_DECIMAL_FLOAT = SDmode,
+  MAX_MODE_DECIMAL_FLOAT = TDmode,
+  MIN_MODE_COMPLEX_INT = CQImode,
+  MAX_MODE_COMPLEX_INT = CTImode,
+  MIN_MODE_COMPLEX_FLOAT = SCmode,
+  MAX_MODE_COMPLEX_FLOAT = DCmode,
+  MIN_MODE_VECTOR_INT = V2QImode,
+  MAX_MODE_VECTOR_INT = V8DImode,
+  MIN_MODE_VECTOR_FRACT = VOIDmode,
+  MAX_MODE_VECTOR_FRACT = VOIDmode,
+  MIN_MODE_VECTOR_UFRACT = VOIDmode,
+  MAX_MODE_VECTOR_UFRACT = VOIDmode,
+  MIN_MODE_VECTOR_ACCUM = VOIDmode,
+  MAX_MODE_VECTOR_ACCUM = VOIDmode,
+  MIN_MODE_VECTOR_UACCUM = VOIDmode,
+  MAX_MODE_VECTOR_UACCUM = VOIDmode,
+  MIN_MODE_VECTOR_FLOAT = V2SFmode,
+  MAX_MODE_VECTOR_FLOAT = V16SFmode,
+  NUM_MACHINE_MODES = MAX_MACHINE_MODE
+};
+extern const char * const mode_name[NUM_MACHINE_MODES];
+enum mode_class { MODE_RANDOM, MODE_CC, MODE_INT, MODE_PARTIAL_INT, MODE_FRACT, MODE_UFRACT, MODE_ACCUM, MODE_UACCUM, MODE_FLOAT, MODE_DECIMAL_FLOAT, MODE_COMPLEX_INT, MODE_COMPLEX_FLOAT, MODE_VECTOR_INT, MODE_VECTOR_FRACT, MODE_VECTOR_UFRACT, MODE_VECTOR_ACCUM, MODE_VECTOR_UACCUM, MODE_VECTOR_FLOAT, MAX_MODE_CLASS };
+extern const unsigned char mode_class[NUM_MACHINE_MODES];
+extern const unsigned char mode_size[NUM_MACHINE_MODES];
+extern const unsigned short mode_precision[NUM_MACHINE_MODES];
+extern const unsigned char mode_ibit[NUM_MACHINE_MODES];
+extern const unsigned char mode_fbit[NUM_MACHINE_MODES];
+extern const unsigned long long mode_mask_array[NUM_MACHINE_MODES];
+extern const unsigned char mode_inner[NUM_MACHINE_MODES];
+extern const unsigned char mode_nunits[NUM_MACHINE_MODES];
+extern const unsigned char mode_wider[NUM_MACHINE_MODES];
+extern const unsigned char mode_2xwider[NUM_MACHINE_MODES];
+extern enum machine_mode mode_for_size (unsigned int, enum mode_class, int);
+extern enum machine_mode smallest_mode_for_size (unsigned int,
+       enum mode_class);
+extern enum machine_mode int_mode_for_mode (enum machine_mode);
+extern enum machine_mode mode_for_vector (enum machine_mode, unsigned);
+class bit_field_mode_iterator
+{
+public:
+  bit_field_mode_iterator (long long, long long,
+      long long, long long,
+      unsigned int, bool);
+  bool next_mode (enum machine_mode *);
+  bool prefer_smaller_modes ();
+private:
+  enum machine_mode mode_;
+  long long bitsize_;
+  long long bitpos_;
+  long long bitregion_start_;
+  long long bitregion_end_;
+  unsigned int align_;
+  bool volatilep_;
+  int count_;
+};
+extern enum machine_mode get_best_mode (int, int,
+     unsigned long long,
+     unsigned long long,
+     unsigned int,
+     enum machine_mode, bool);
+extern const unsigned char mode_base_align[NUM_MACHINE_MODES];
+extern unsigned get_mode_alignment (enum machine_mode);
+extern const unsigned char class_narrowest_mode[MAX_MODE_CLASS];
+extern enum machine_mode byte_mode;
+extern enum machine_mode word_mode;
+extern enum machine_mode ptr_mode;
+extern void init_adjust_machine_modes (void);
+enum lc_reason
+{
+  LC_ENTER = 0,
+  LC_LEAVE,
+  LC_RENAME,
+  LC_RENAME_VERBATIM,
+  LC_ENTER_MACRO
+};
+typedef unsigned int linenum_type;
+typedef unsigned int source_location;
+typedef void *(*line_map_realloc) (void *, size_t);
+typedef size_t (*line_map_round_alloc_size_func) (size_t);
+struct line_map_ordinary {
+  const char *to_file;
+  linenum_type to_line;
+  int included_from;
+  unsigned char sysp;
+  unsigned int column_bits : 8;
+};
+struct cpp_hashnode;
+struct line_map_macro {
+  struct cpp_hashnode *
+    macro;
+  unsigned int n_tokens;
+  source_location * macro_locations;
+  source_location expansion;
+};
+struct line_map {
+  source_location start_location;
+  enum lc_reason reason : 8;
+  union map_u {
+    struct line_map_ordinary ordinary;
+    struct line_map_macro macro;
+  } d;
+};
+struct maps_info {
+  struct line_map * maps;
+  unsigned int allocated;
+  unsigned int used;
+  unsigned int cache;
+};
+struct location_adhoc_data {
+  source_location locus;
+  void * data;
+};
+struct htab;
+struct location_adhoc_data_map {
+  struct htab * htab;
+  source_location curr_loc;
+  unsigned int allocated;
+  struct location_adhoc_data *data;
+};
+struct line_maps {
+  struct maps_info info_ordinary;
+  struct maps_info info_macro;
+  unsigned int depth;
+  bool trace_includes;
+  source_location highest_location;
+  source_location highest_line;
+  unsigned int max_column_hint;
+  line_map_realloc reallocator;
+  line_map_round_alloc_size_func round_alloc_size;
+  struct location_adhoc_data_map location_adhoc_data_map;
+};
+extern void location_adhoc_data_fini (struct line_maps *);
+extern source_location get_combined_adhoc_loc (struct line_maps *,
+            source_location, void *);
+extern void *get_data_from_adhoc_loc (struct line_maps *, source_location);
+extern source_location get_location_from_adhoc_loc (struct line_maps *,
+          source_location);
+extern void rebuild_location_adhoc_htab (struct line_maps *);
+extern void linemap_init (struct line_maps *);
+extern void linemap_check_files_exited (struct line_maps *);
+extern source_location linemap_line_start
+(struct line_maps *set, linenum_type to_line, unsigned int max_column_hint);
+extern const struct line_map *linemap_add
+  (struct line_maps *, enum lc_reason, unsigned int sysp,
+   const char *to_file, linenum_type to_line);
+extern const struct line_map *linemap_lookup
+  (struct line_maps *, source_location);
+bool linemap_tracks_macro_expansion_locs_p (struct line_maps *);
+bool linemap_macro_expansion_map_p (const struct line_map *);
+const char* linemap_map_get_macro_name (const struct line_map*);
+int linemap_location_in_system_header_p (struct line_maps *,
+      source_location);
+bool linemap_location_from_macro_expansion_p (struct line_maps *,
+           source_location);
+extern source_location
+linemap_position_for_column (struct line_maps *, unsigned int);
+source_location linemap_position_for_line_and_column (struct line_map *,
+            linenum_type,
+            unsigned int);
+int linemap_compare_locations (struct line_maps *set,
+          source_location pre,
+          source_location post);
+typedef struct
+{
+  const char *file;
+  int line;
+  int column;
+  void *data;
+  bool sysp;
+} expanded_location;
+enum location_resolution_kind
+{
+  LRK_MACRO_EXPANSION_POINT,
+  LRK_SPELLING_LOCATION,
+  LRK_MACRO_DEFINITION_LOCATION
+};
+source_location linemap_resolve_location (struct line_maps *,
+       source_location loc,
+       enum location_resolution_kind lrk,
+       const struct line_map **loc_map);
+source_location linemap_unwind_toward_expansion (struct line_maps *,
+       source_location loc,
+       const struct line_map **loc_map);
+source_location linemap_unwind_to_first_non_reserved_loc (struct line_maps *,
+         source_location loc,
+         const struct line_map **map);
+expanded_location linemap_expand_location (struct line_maps *,
+        const struct line_map *,
+        source_location loc);
+struct linemap_stats
+{
+  long num_ordinary_maps_allocated;
+  long num_ordinary_maps_used;
+  long ordinary_maps_allocated_size;
+  long ordinary_maps_used_size;
+  long num_expanded_macros;
+  long num_macro_tokens;
+  long num_macro_maps_used;
+  long macro_maps_allocated_size;
+  long macro_maps_used_size;
+  long macro_maps_locations_size;
+  long duplicated_macro_maps_locations_size;
+};
+void linemap_get_statistics (struct line_maps *, struct linemap_stats *);
+void linemap_dump_location (struct line_maps *, source_location, FILE *);
+void linemap_dump (FILE *, struct line_maps *, unsigned, bool);
+void line_table_dump (FILE *, struct line_maps *, unsigned int, unsigned int);
+extern struct line_maps *line_table;
+extern char builtins_location_check[(((source_location) 1)
+         < 2) ? 1 : -1];
+extern expanded_location expand_location (source_location);
+extern const char * location_get_source_line(expanded_location xloc);
+extern expanded_location expand_location_to_spelling_point (source_location);
+extern source_location expansion_point_location_if_in_system_header (source_location);
+typedef source_location location_t;
+extern location_t input_location;
+void dump_line_table_statistics (void);
+enum real_value_class {
+  rvc_zero,
+  rvc_normal,
+  rvc_inf,
+  rvc_nan
+};
+struct real_value {
+  unsigned int cl : 2;
+  unsigned int decimal : 1;
+  unsigned int sign : 1;
+  unsigned int signalling : 1;
+  unsigned int canonical : 1;
+  unsigned int uexp : (32 - 6);
+  unsigned long sig[((128 + (8 * 4)) / (8 * 4))];
+};
+extern char test_real_width
+  [sizeof(struct real_value) <= (((128 + (8 * 4)) + 32)/(8 * 8) + (((128 + (8 * 4)) + 32)%(8 * 8) ? 1 : 0))*sizeof(long long) ? 1 : -1];
+struct real_format
+{
+  void (*encode) (const struct real_format *, long *,
+    const struct real_value *);
+  void (*decode) (const struct real_format *, struct real_value *,
+    const long *);
+  int b;
+  int p;
+  int pnan;
+  int emin;
+  int emax;
+  int signbit_ro;
+  int signbit_rw;
+  bool round_towards_zero;
+  bool has_sign_dependent_rounding;
+  bool has_nans;
+  bool has_inf;
+  bool has_denorm;
+  bool has_signed_zero;
+  bool qnan_msb_set;
+  bool canonical_nan_lsbs_set;
+};
+extern const struct real_format *
+  real_format_for_mode[MAX_MODE_FLOAT - MIN_MODE_FLOAT + 1
+         + MAX_MODE_DECIMAL_FLOAT - MIN_MODE_DECIMAL_FLOAT + 1];
+extern bool real_arithmetic (struct real_value *, int, const struct real_value *,
+        const struct real_value *);
+extern bool real_compare (int, const struct real_value *, const struct real_value *);
+extern bool real_isinf (const struct real_value *);
+extern bool real_isnan (const struct real_value *);
+extern bool real_isfinite (const struct real_value *);
+extern bool real_isneg (const struct real_value *);
+extern bool real_isnegzero (const struct real_value *);
+extern bool real_identical (const struct real_value *, const struct real_value *);
+extern void real_convert (struct real_value *, enum machine_mode,
+     const struct real_value *);
+extern bool exact_real_truncate (enum machine_mode, const struct real_value *);
+extern void real_to_decimal (char *, const struct real_value *, size_t,
+        size_t, int);
+extern void real_to_decimal_for_mode (char *, const struct real_value *, size_t,
+          size_t, int, enum machine_mode);
+extern void real_to_hexadecimal (char *, const struct real_value *,
+     size_t, size_t, int);
+extern long long real_to_integer (const struct real_value *);
+extern void real_to_integer2 (long long *, long long *,
+         const struct real_value *);
+extern int real_from_string (struct real_value *, const char *);
+extern void real_from_string3 (struct real_value *, const char *, enum machine_mode);
+extern void real_from_integer (struct real_value *, enum machine_mode,
+          unsigned long long, long long, int);
+extern long real_to_target_fmt (long *, const struct real_value *,
+    const struct real_format *);
+extern long real_to_target (long *, const struct real_value *, enum machine_mode);
+extern void real_from_target_fmt (struct real_value *, const long *,
+      const struct real_format *);
+extern void real_from_target (struct real_value *, const long *,
+         enum machine_mode);
+extern void real_inf (struct real_value *);
+extern bool real_nan (struct real_value *, const char *, int, enum machine_mode);
+extern void real_maxval (struct real_value *, int, enum machine_mode);
+extern void real_2expN (struct real_value *, int, enum machine_mode);
+extern unsigned int real_hash (const struct real_value *);
+extern const struct real_format ieee_single_format;
+extern const struct real_format mips_single_format;
+extern const struct real_format motorola_single_format;
+extern const struct real_format spu_single_format;
+extern const struct real_format ieee_double_format;
+extern const struct real_format mips_double_format;
+extern const struct real_format motorola_double_format;
+extern const struct real_format ieee_extended_motorola_format;
+extern const struct real_format ieee_extended_intel_96_format;
+extern const struct real_format ieee_extended_intel_96_round_53_format;
+extern const struct real_format ieee_extended_intel_128_format;
+extern const struct real_format ibm_extended_format;
+extern const struct real_format mips_extended_format;
+extern const struct real_format ieee_quad_format;
+extern const struct real_format mips_quad_format;
+extern const struct real_format vax_f_format;
+extern const struct real_format vax_d_format;
+extern const struct real_format vax_g_format;
+extern const struct real_format real_internal_format;
+extern const struct real_format decimal_single_format;
+extern const struct real_format decimal_double_format;
+extern const struct real_format decimal_quad_format;
+extern const struct real_format ieee_half_format;
+extern const struct real_format arm_half_format;
+extern struct real_value real_value_truncate (enum machine_mode,
+         struct real_value);
+extern struct real_value real_value_negate (const struct real_value *);
+extern struct real_value real_value_abs (const struct real_value *);
+extern int significand_size (enum machine_mode);
+extern struct real_value real_from_string2 (const char *, enum machine_mode);
+extern int real_exponent (const struct real_value *);
+extern void real_ldexp (struct real_value *, const struct real_value *, int);
+extern struct real_value dconst0;
+extern struct real_value dconst1;
+extern struct real_value dconst2;
+extern struct real_value dconstm1;
+extern struct real_value dconsthalf;
+extern const struct real_value * dconst_e_ptr (void);
+extern const struct real_value * dconst_third_ptr (void);
+extern const struct real_value * dconst_sqrt2_ptr (void);
+struct real_value real_value_from_int_cst (const_tree, const_tree);
+extern rtx const_double_from_real_value (struct real_value, enum machine_mode);
+extern bool exact_real_inverse (enum machine_mode, struct real_value *);
+bool real_can_shorten_arithmetic (enum machine_mode, enum machine_mode);
+extern tree build_real (tree, struct real_value);
+extern bool real_sqrt (struct real_value *, enum machine_mode,
+         const struct real_value *);
+extern bool real_powi (struct real_value *, enum machine_mode,
+         const struct real_value *, long long);
+extern void real_trunc (struct real_value *, enum machine_mode,
+   const struct real_value *);
+extern void real_floor (struct real_value *, enum machine_mode,
+   const struct real_value *);
+extern void real_ceil (struct real_value *, enum machine_mode,
+         const struct real_value *);
+extern void real_round (struct real_value *, enum machine_mode,
+   const struct real_value *);
+extern void real_copysign (struct real_value *, const struct real_value *);
+extern bool real_isinteger (const struct real_value *c, enum machine_mode mode);
+extern void get_max_float (const struct real_format *, char *, size_t);
+extern const char empty_string[];
+extern void gt_ggc_mx_vec_ivarref_entry_va_gc_ (void *);
+extern void gt_ggc_mx_vec_prot_list_entry_va_gc_ (void *);
+extern void gt_ggc_mx_vec_msgref_entry_va_gc_ (void *);
+extern void gt_ggc_mx_vec_ident_data_tuple_va_gc_ (void *);
+extern void gt_ggc_mx_string_descriptor (void *);
+extern void gt_ggc_mx_imp_entry (void *);
+extern void gt_ggc_mx_hashed_attribute (void *);
+extern void gt_ggc_mx_hashed_entry (void *);
+extern void gt_ggc_mx_objc_map_private (void *);
+extern void gt_ggc_mx_gimple_type_leader_entry_s (void *);
+extern void gt_ggc_mx_vec_method_entry_va_gc_ (void *);
+extern void gt_ggc_mx_type_assertion (void *);
+extern void gt_ggc_mx_treetreehash_entry (void *);
+extern void gt_ggc_mx_CPool (void *);
+extern void gt_ggc_mx_JCF (void *);
+extern void gt_ggc_mx_module_htab_entry (void *);
+extern void gt_ggc_mx_binding_level (void *);
+extern void gt_ggc_mx_vec_pending_noexcept_va_gc_ (void *);
+extern void gt_ggc_mx_pending_abstract_type (void *);
+extern void gt_ggc_mx_vec_tree_int_va_gc_ (void *);
+extern void gt_ggc_mx_cp_parser (void *);
+extern void gt_ggc_mx_vec_cp_unparsed_functions_entry_va_gc_ (void *);
+extern void gt_ggc_mx_cp_parser_context (void *);
+extern void gt_ggc_mx_vec_cp_default_arg_entry_va_gc_ (void *);
+extern void gt_ggc_mx_cp_lexer (void *);
+extern void gt_ggc_mx_vec_cp_token_va_gc_ (void *);
+extern void gt_ggc_mx_tree_check (void *);
+extern void gt_ggc_mx_constexpr_call (void *);
+extern void gt_ggc_mx_constexpr_fundef (void *);
+extern void gt_ggc_mx_vec_deferred_access_va_gc_ (void *);
+extern void gt_ggc_mx_vec_deferred_access_check_va_gc_ (void *);
+extern void gt_ggc_mx_spec_entry (void *);
+extern void gt_ggc_mx_pending_template (void *);
+extern void gt_ggc_mx_vec_incomplete_var_va_gc_ (void *);
+extern void gt_ggc_mx_named_label_use_entry (void *);
+extern void gt_ggc_mx_vec_tree_pair_s_va_gc_ (void *);
+extern void gt_ggc_mx_named_label_entry (void *);
+extern void gt_ggc_mx_vec_cxx_saved_binding_va_gc_ (void *);
+extern void gt_ggc_mx_vec_qualified_typedef_usage_t_va_gc_ (void *);
+extern void gt_ggc_mx_cp_token_cache (void *);
+extern void gt_ggc_mx_saved_scope (void *);
+extern void gt_ggc_mx_cxx_int_tree_map (void *);
+extern void gt_ggc_mx_vec_cp_label_binding_va_gc_ (void *);
+extern void gt_ggc_mx_vec_cp_class_binding_va_gc_ (void *);
+extern void gt_ggc_mx_cp_binding_level (void *);
+extern void gt_ggc_mx_cxx_binding (void *);
+extern void gt_ggc_mx_binding_entry_s (void *);
+extern void gt_ggc_mx_binding_table_s (void *);
+extern void gt_ggc_mx_tinst_level (void *);
+extern void gt_ggc_mx_vec_tinfo_s_va_gc_ (void *);
+extern void gt_ggc_mx_c_parser (void *);
+extern void gt_ggc_mx_opt_stack (void *);
+extern void gt_ggc_mx_vec_pending_redefinition_va_gc_ (void *);
+extern void gt_ggc_mx_vec_pending_weak_va_gc_ (void *);
+extern void gt_ggc_mx_align_stack (void *);
+extern void gt_ggc_mx_vec_tree_gc_vec_va_gc_ (void *);
+extern void gt_ggc_mx_vec_const_char_p_va_gc_ (void *);
+extern void gt_ggc_mx_sorted_fields_type (void *);
+extern void gt_ggc_mx_c_inline_static (void *);
+extern void gt_ggc_mx_vec_c_goto_bindings_p_va_gc_ (void *);
+extern void gt_ggc_mx_c_goto_bindings (void *);
+extern void gt_ggc_mx_c_scope (void *);
+extern void gt_ggc_mx_c_binding (void *);
+extern void gt_ggc_mx_c_label_vars (void *);
+extern void gt_ggc_mx_pad_type_hash (void *);
+extern void gt_ggc_mx_gnat_binding_level (void *);
+extern void gt_ggc_mx_vec_loop_info_va_gc_ (void *);
+extern void gt_ggc_mx_loop_info_d (void *);
+extern void gt_ggc_mx_vec_range_check_info_va_gc_ (void *);
+extern void gt_ggc_mx_range_check_info_d (void *);
+extern void gt_ggc_mx_elab_info (void *);
+extern void gt_ggc_mx_stmt_group (void *);
+extern void gt_ggc_mx_vec_parm_attr_va_gc_ (void *);
+extern void gt_ggc_mx_parm_attr_d (void *);
+extern void gt_ggc_mx_vec_inline_summary_t_va_gc_ (void *);
+extern void gt_ggc_mx_vec_size_time_entry_va_gc_ (void *);
+extern void gt_ggc_mx_vec_condition_va_gc_ (void *);
+extern void gt_ggc_mx_lto_in_decl_state (void *);
+extern void gt_ggc_mx_vec_ipa_edge_args_t_va_gc_ (void *);
+extern void gt_ggc_mx_vec_ipa_agg_replacement_value_p_va_gc_ (void *);
+extern void gt_ggc_mx_vec_ipa_jump_func_t_va_gc_ (void *);
+extern void gt_ggc_mx_vec_ipa_agg_jf_item_t_va_gc_ (void *);
+extern void gt_ggc_mx_ssa_operand_memory_d (void *);
+extern void gt_ggc_mx_scev_info_str (void *);
+extern void gt_ggc_mx_vec_mem_addr_template_va_gc_ (void *);
+extern void gt_ggc_mx_vec_gimple_va_gc_ (void *);
+extern void gt_ggc_mx_tm_restart_node (void *);
+extern void gt_ggc_mx_type_hash (void *);
+extern void gt_ggc_mx_string_pool_data (void *);
+extern void gt_ggc_mx_temp_slot_address_entry (void *);
+extern void gt_ggc_mx_throw_stmt_node (void *);
+extern void gt_ggc_mx_vec_eh_landing_pad_va_gc_ (void *);
+extern void gt_ggc_mx_vec_eh_region_va_gc_ (void *);
+extern void gt_ggc_mx_eh_catch_d (void *);
+extern void gt_ggc_mx_eh_landing_pad_d (void *);
+extern void gt_ggc_mx_eh_region_d (void *);
+extern void gt_ggc_mx_vec_die_arg_entry_va_gc_ (void *);
+extern void gt_ggc_mx_vec_macinfo_entry_va_gc_ (void *);
+extern void gt_ggc_mx_vec_pubname_entry_va_gc_ (void *);
+extern void gt_ggc_mx_vec_dw_line_info_table_p_va_gc_ (void *);
+extern void gt_ggc_mx_cached_dw_loc_list_def (void *);
+extern void gt_ggc_mx_call_arg_loc_node (void *);
+extern void gt_ggc_mx_var_loc_list_def (void *);
+extern void gt_ggc_mx_var_loc_node (void *);
+extern void gt_ggc_mx_limbo_die_struct (void *);
+extern void gt_ggc_mx_vec_dw_attr_node_va_gc_ (void *);
+extern void gt_ggc_mx_dw_line_info_table_struct (void *);
+extern void gt_ggc_mx_vec_dw_line_info_entry_va_gc_ (void *);
+extern void gt_ggc_mx_comdat_type_struct (void *);
+extern void gt_ggc_mx_dw_ranges_by_label_struct (void *);
+extern void gt_ggc_mx_dw_ranges_struct (void *);
+extern void gt_ggc_mx_vec_deferred_locations_va_gc_ (void *);
+extern void gt_ggc_mx_vec_dw_fde_ref_va_gc_ (void *);
+extern void gt_ggc_mx_reg_saved_in_data_struct (void *);
+extern void gt_ggc_mx_dw_cfi_row_struct (void *);
+extern void gt_ggc_mx_dwarf_file_data (void *);
+extern void gt_ggc_mx_indirect_string_node (void *);
+extern void gt_ggc_mx_addr_table_entry_struct (void *);
+extern void gt_ggc_mx_vec_dw_cfi_ref_va_gc_ (void *);
+extern void gt_ggc_mx_dw_loc_list_struct (void *);
+extern void gt_ggc_mx_dw_loc_descr_struct (void *);
+extern void gt_ggc_mx_dw_cfi_struct (void *);
+extern void gt_ggc_mx_typeinfo (void *);
+extern void gt_ggc_mx_ipa_agg_replacement_value (void *);
+extern void gt_ggc_mx_vec_alias_set_entry_va_gc_ (void *);
+extern void gt_ggc_mx_alias_set_entry_d (void *);
+extern void gt_ggc_mx_constant_descriptor_tree (void *);
+extern void gt_ggc_mx_asm_node (void *);
+extern void gt_ggc_mx_cgraph_indirect_call_info (void *);
+extern void gt_ggc_mx_cgraph_function_version_info (void *);
+extern void gt_ggc_mx_cgraph_edge (void *);
+extern void gt_ggc_mx_vec_ipa_replace_map_p_va_gc_ (void *);
+extern void gt_ggc_mx_ipa_replace_map (void *);
+extern void gt_ggc_mx_lto_file_decl_data (void *);
+extern void gt_ggc_mx_vec_ipa_ref_t_va_gc_ (void *);
+extern void gt_ggc_mx_symtab_node_def (void *);
+extern void gt_ggc_mx_cgraph_node (void *);
+extern void gt_ggc_mx_vec_basic_block_va_gc_ (void *);
+extern void gt_ggc_mx_vec_edge_va_gc_ (void *);
+extern void gt_ggc_mx_rtl_bb_info (void *);
+extern void gt_ggc_mx_vec_loop_p_va_gc_ (void *);
+extern void gt_ggc_mx_loop (void *);
+extern void gt_ggc_mx_loop_exit (void *);
+extern void gt_ggc_mx_nb_iter_bound (void *);
+extern void gt_ggc_mx_types_used_by_vars_entry (void *);
+extern void gt_ggc_mx_language_function (void *);
+extern void gt_ggc_mx_loops (void *);
+extern void gt_ggc_mx_control_flow_graph (void *);
+extern void gt_ggc_mx_eh_status (void *);
+extern void gt_ggc_mx_stack_usage (void *);
+extern void gt_ggc_mx_vec_temp_slot_p_va_gc_ (void *);
+extern void gt_ggc_mx_initial_value_struct (void *);
+extern void gt_ggc_mx_frame_space (void *);
+extern void gt_ggc_mx_rtx_constant_pool (void *);
+extern void gt_ggc_mx_dw_fde_struct (void *);
+extern void gt_ggc_mx_temp_slot (void *);
+extern void gt_ggc_mx_gimple_df (void *);
+extern void gt_ggc_mx_vec_call_site_record_va_gc_ (void *);
+extern void gt_ggc_mx_vec_uchar_va_gc_ (void *);
+extern void gt_ggc_mx_call_site_record_d (void *);
+extern void gt_ggc_mx_sequence_stack (void *);
+extern void gt_ggc_mx_libfunc_entry (void *);
+extern void gt_ggc_mx_tree_vec_map (void *);
+extern void gt_ggc_mx_tree_priority_map (void *);
+extern void gt_ggc_mx_tree_int_map (void *);
+extern void gt_ggc_mx_tree_decl_map (void *);
+extern void gt_ggc_mx_tree_map (void *);
+extern void gt_ggc_mx_lang_tree_node (void *);
+extern void gt_ggc_mx_tree_statement_list_node (void *);
+extern void gt_ggc_mx_lang_decl (void *);
+extern void gt_ggc_mx_lang_type (void *);
+extern void gt_ggc_mx_die_struct (void *);
+extern void gt_ggc_mx_vec_tree_va_gc_ (void *);
+extern void gt_ggc_mx_ptr_info_def (void *);
+extern void gt_ggc_mx_vec_constructor_elt_va_gc_ (void *);
+extern void gt_ggc_mx_vec_alias_pair_va_gc_ (void *);
+extern void gt_ggc_mx_function (void *);
+extern void gt_ggc_mx_constant_descriptor_rtx (void *);
+extern void gt_ggc_mx_fixed_value (void *);
+extern void gt_ggc_mx_real_value (void *);
+extern void gt_ggc_mx_vec_rtx_va_gc_ (void *);
+extern void gt_ggc_mx_object_block (void *);
+extern void gt_ggc_mx_reg_attrs (void *);
+extern void gt_ggc_mx_mem_attrs (void *);
+extern void gt_ggc_mx_coverage_data (void *);
+extern void gt_ggc_mx_bitmap_obstack (void *);
+extern void gt_ggc_mx_bitmap_element_def (void *);
+extern void gt_ggc_mx_basic_block_def (void *);
+extern void gt_ggc_mx_edge_def (void *);
+extern void gt_ggc_mx_section (void *);
+extern void gt_ggc_mx_gimple_statement_d (void *);
+extern void gt_ggc_mx_rtvec_def (void *);
+extern void gt_ggc_mx_rtx_def (void *);
+extern void gt_ggc_mx_bitmap_head_def (void *);
+extern void gt_ggc_mx_answer (void *);
+extern void gt_ggc_mx_cpp_macro (void *);
+extern void gt_ggc_mx_cpp_token (void *);
+extern void gt_ggc_mx_line_maps (void *);
+extern void gt_ggc_m_II17splay_tree_node_s (void *);
+extern void gt_ggc_m_SP9tree_node17splay_tree_node_s (void *);
+extern void gt_ggc_m_P9tree_nodeP9tree_node17splay_tree_node_s (void *);
+extern void gt_ggc_m_P17string_descriptor4htab (void *);
+extern void gt_ggc_m_P14type_assertion4htab (void *);
+extern void gt_ggc_m_P18treetreehash_entry4htab (void *);
+extern void gt_ggc_m_P17module_htab_entry4htab (void *);
+extern void gt_ggc_m_P21pending_abstract_type4htab (void *);
+extern void gt_ggc_m_P14constexpr_call4htab (void *);
+extern void gt_ggc_m_P16constexpr_fundef4htab (void *);
+extern void gt_ggc_m_P10spec_entry4htab (void *);
+extern void gt_ggc_m_P16cxx_int_tree_map4htab (void *);
+extern void gt_ggc_m_P17named_label_entry4htab (void *);
+extern void gt_ggc_m_P13pad_type_hash4htab (void *);
+extern void gt_ggc_m_P17lto_in_decl_state4htab (void *);
+extern void gt_ggc_m_P9tree_nodeP9tree_node12splay_tree_s (void *);
+extern void gt_ggc_m_P13scev_info_str4htab (void *);
+extern void gt_ggc_m_P15tm_restart_node4htab (void *);
+extern void gt_ggc_m_P12tree_int_map4htab (void *);
+extern void gt_ggc_m_P8tree_map4htab (void *);
+extern void gt_ggc_m_P23constant_descriptor_rtx4htab (void *);
+extern void gt_ggc_m_P24constant_descriptor_tree4htab (void *);
+extern void gt_ggc_m_P12object_block4htab (void *);
+extern void gt_ggc_m_P7section4htab (void *);
+extern void gt_ggc_m_P17tree_priority_map4htab (void *);
+extern void gt_ggc_m_P12tree_vec_map4htab (void *);
+extern void gt_ggc_m_P13tree_decl_map4htab (void *);
+extern void gt_ggc_m_P9type_hash4htab (void *);
+extern void gt_ggc_m_P23temp_slot_address_entry4htab (void *);
+extern void gt_ggc_m_P15throw_stmt_node4htab (void *);
+extern void gt_ggc_m_P9reg_attrs4htab (void *);
+extern void gt_ggc_m_P9mem_attrs4htab (void *);
+extern void gt_ggc_m_P7rtx_def4htab (void *);
+extern void gt_ggc_m_P23addr_table_entry_struct4htab (void *);
+extern void gt_ggc_m_P22cached_dw_loc_list_def4htab (void *);
+extern void gt_ggc_m_P16var_loc_list_def4htab (void *);
+extern void gt_ggc_m_P10die_struct4htab (void *);
+extern void gt_ggc_m_P15dwarf_file_data4htab (void *);
+extern void gt_ggc_m_P20indirect_string_node4htab (void *);
+extern void gt_ggc_m_SP9tree_node12splay_tree_s (void *);
+extern void gt_ggc_m_II12splay_tree_s (void *);
+extern void gt_ggc_m_P15symtab_node_def4htab (void *);
+extern void gt_ggc_m_P11cgraph_edge4htab (void *);
+extern void gt_ggc_m_P9loop_exit4htab (void *);
+extern void gt_ggc_m_P24types_used_by_vars_entry4htab (void *);
+extern void gt_ggc_m_P9tree_node4htab (void *);
+extern void gt_ggc_m_P13libfunc_entry4htab (void *);
+extern void gt_pch_nx_vec_ivarref_entry_va_gc_ (void *);
+extern void gt_pch_nx_vec_prot_list_entry_va_gc_ (void *);
+extern void gt_pch_nx_vec_msgref_entry_va_gc_ (void *);
+extern void gt_pch_nx_vec_ident_data_tuple_va_gc_ (void *);
+extern void gt_pch_nx_string_descriptor (void *);
+extern void gt_pch_nx_imp_entry (void *);
+extern void gt_pch_nx_hashed_attribute (void *);
+extern void gt_pch_nx_hashed_entry (void *);
+extern void gt_pch_nx_objc_map_private (void *);
+extern void gt_pch_nx_gimple_type_leader_entry_s (void *);
+extern void gt_pch_nx_vec_method_entry_va_gc_ (void *);
+extern void gt_pch_nx_type_assertion (void *);
+extern void gt_pch_nx_treetreehash_entry (void *);
+extern void gt_pch_nx_CPool (void *);
+extern void gt_pch_nx_JCF (void *);
+extern void gt_pch_nx_module_htab_entry (void *);
+extern void gt_pch_nx_binding_level (void *);
+extern void gt_pch_nx_vec_pending_noexcept_va_gc_ (void *);
+extern void gt_pch_nx_pending_abstract_type (void *);
+extern void gt_pch_nx_vec_tree_int_va_gc_ (void *);
+extern void gt_pch_nx_cp_parser (void *);
+extern void gt_pch_nx_vec_cp_unparsed_functions_entry_va_gc_ (void *);
+extern void gt_pch_nx_cp_parser_context (void *);
+extern void gt_pch_nx_vec_cp_default_arg_entry_va_gc_ (void *);
+extern void gt_pch_nx_cp_lexer (void *);
+extern void gt_pch_nx_vec_cp_token_va_gc_ (void *);
+extern void gt_pch_nx_tree_check (void *);
+extern void gt_pch_nx_constexpr_call (void *);
+extern void gt_pch_nx_constexpr_fundef (void *);
+extern void gt_pch_nx_vec_deferred_access_va_gc_ (void *);
+extern void gt_pch_nx_vec_deferred_access_check_va_gc_ (void *);
+extern void gt_pch_nx_spec_entry (void *);
+extern void gt_pch_nx_pending_template (void *);
+extern void gt_pch_nx_vec_incomplete_var_va_gc_ (void *);
+extern void gt_pch_nx_named_label_use_entry (void *);
+extern void gt_pch_nx_vec_tree_pair_s_va_gc_ (void *);
+extern void gt_pch_nx_named_label_entry (void *);
+extern void gt_pch_nx_vec_cxx_saved_binding_va_gc_ (void *);
+extern void gt_pch_nx_vec_qualified_typedef_usage_t_va_gc_ (void *);
+extern void gt_pch_nx_cp_token_cache (void *);
+extern void gt_pch_nx_saved_scope (void *);
+extern void gt_pch_nx_cxx_int_tree_map (void *);
+extern void gt_pch_nx_vec_cp_label_binding_va_gc_ (void *);
+extern void gt_pch_nx_vec_cp_class_binding_va_gc_ (void *);
+extern void gt_pch_nx_cp_binding_level (void *);
+extern void gt_pch_nx_cxx_binding (void *);
+extern void gt_pch_nx_binding_entry_s (void *);
+extern void gt_pch_nx_binding_table_s (void *);
+extern void gt_pch_nx_tinst_level (void *);
+extern void gt_pch_nx_vec_tinfo_s_va_gc_ (void *);
+extern void gt_pch_nx_c_parser (void *);
+extern void gt_pch_nx_opt_stack (void *);
+extern void gt_pch_nx_vec_pending_redefinition_va_gc_ (void *);
+extern void gt_pch_nx_vec_pending_weak_va_gc_ (void *);
+extern void gt_pch_nx_align_stack (void *);
+extern void gt_pch_nx_vec_tree_gc_vec_va_gc_ (void *);
+extern void gt_pch_nx_vec_const_char_p_va_gc_ (void *);
+extern void gt_pch_nx_sorted_fields_type (void *);
+extern void gt_pch_nx_c_inline_static (void *);
+extern void gt_pch_nx_vec_c_goto_bindings_p_va_gc_ (void *);
+extern void gt_pch_nx_c_goto_bindings (void *);
+extern void gt_pch_nx_c_scope (void *);
+extern void gt_pch_nx_c_binding (void *);
+extern void gt_pch_nx_c_label_vars (void *);
+extern void gt_pch_nx_pad_type_hash (void *);
+extern void gt_pch_nx_gnat_binding_level (void *);
+extern void gt_pch_nx_vec_loop_info_va_gc_ (void *);
+extern void gt_pch_nx_loop_info_d (void *);
+extern void gt_pch_nx_vec_range_check_info_va_gc_ (void *);
+extern void gt_pch_nx_range_check_info_d (void *);
+extern void gt_pch_nx_elab_info (void *);
+extern void gt_pch_nx_stmt_group (void *);
+extern void gt_pch_nx_vec_parm_attr_va_gc_ (void *);
+extern void gt_pch_nx_parm_attr_d (void *);
+extern void gt_pch_nx_vec_inline_summary_t_va_gc_ (void *);
+extern void gt_pch_nx_vec_size_time_entry_va_gc_ (void *);
+extern void gt_pch_nx_vec_condition_va_gc_ (void *);
+extern void gt_pch_nx_lto_in_decl_state (void *);
+extern void gt_pch_nx_vec_ipa_edge_args_t_va_gc_ (void *);
+extern void gt_pch_nx_vec_ipa_agg_replacement_value_p_va_gc_ (void *);
+extern void gt_pch_nx_vec_ipa_jump_func_t_va_gc_ (void *);
+extern void gt_pch_nx_vec_ipa_agg_jf_item_t_va_gc_ (void *);
+extern void gt_pch_nx_ssa_operand_memory_d (void *);
+extern void gt_pch_nx_scev_info_str (void *);
+extern void gt_pch_nx_vec_mem_addr_template_va_gc_ (void *);
+extern void gt_pch_nx_vec_gimple_va_gc_ (void *);
+extern void gt_pch_nx_tm_restart_node (void *);
+extern void gt_pch_nx_type_hash (void *);
+extern void gt_pch_nx_string_pool_data (void *);
+extern void gt_pch_nx_temp_slot_address_entry (void *);
+extern void gt_pch_nx_throw_stmt_node (void *);
+extern void gt_pch_nx_vec_eh_landing_pad_va_gc_ (void *);
+extern void gt_pch_nx_vec_eh_region_va_gc_ (void *);
+extern void gt_pch_nx_eh_catch_d (void *);
+extern void gt_pch_nx_eh_landing_pad_d (void *);
+extern void gt_pch_nx_eh_region_d (void *);
+extern void gt_pch_nx_vec_die_arg_entry_va_gc_ (void *);
+extern void gt_pch_nx_vec_macinfo_entry_va_gc_ (void *);
+extern void gt_pch_nx_vec_pubname_entry_va_gc_ (void *);
+extern void gt_pch_nx_vec_dw_line_info_table_p_va_gc_ (void *);
+extern void gt_pch_nx_cached_dw_loc_list_def (void *);
+extern void gt_pch_nx_call_arg_loc_node (void *);
+extern void gt_pch_nx_var_loc_list_def (void *);
+extern void gt_pch_nx_var_loc_node (void *);
+extern void gt_pch_nx_limbo_die_struct (void *);
+extern void gt_pch_nx_vec_dw_attr_node_va_gc_ (void *);
+extern void gt_pch_nx_dw_line_info_table_struct (void *);
+extern void gt_pch_nx_vec_dw_line_info_entry_va_gc_ (void *);
+extern void gt_pch_nx_comdat_type_struct (void *);
+extern void gt_pch_nx_dw_ranges_by_label_struct (void *);
+extern void gt_pch_nx_dw_ranges_struct (void *);
+extern void gt_pch_nx_vec_deferred_locations_va_gc_ (void *);
+extern void gt_pch_nx_vec_dw_fde_ref_va_gc_ (void *);
+extern void gt_pch_nx_reg_saved_in_data_struct (void *);
+extern void gt_pch_nx_dw_cfi_row_struct (void *);
+extern void gt_pch_nx_dwarf_file_data (void *);
+extern void gt_pch_nx_indirect_string_node (void *);
+extern void gt_pch_nx_addr_table_entry_struct (void *);
+extern void gt_pch_nx_vec_dw_cfi_ref_va_gc_ (void *);
+extern void gt_pch_nx_dw_loc_list_struct (void *);
+extern void gt_pch_nx_dw_loc_descr_struct (void *);
+extern void gt_pch_nx_dw_cfi_struct (void *);
+extern void gt_pch_nx_typeinfo (void *);
+extern void gt_pch_nx_ipa_agg_replacement_value (void *);
+extern void gt_pch_nx_vec_alias_set_entry_va_gc_ (void *);
+extern void gt_pch_nx_alias_set_entry_d (void *);
+extern void gt_pch_nx_constant_descriptor_tree (void *);
+extern void gt_pch_nx_asm_node (void *);
+extern void gt_pch_nx_cgraph_indirect_call_info (void *);
+extern void gt_pch_nx_cgraph_function_version_info (void *);
+extern void gt_pch_nx_cgraph_edge (void *);
+extern void gt_pch_nx_vec_ipa_replace_map_p_va_gc_ (void *);
+extern void gt_pch_nx_ipa_replace_map (void *);
+extern void gt_pch_nx_lto_file_decl_data (void *);
+extern void gt_pch_nx_vec_ipa_ref_t_va_gc_ (void *);
+extern void gt_pch_nx_symtab_node_def (void *);
+extern void gt_pch_nx_cgraph_node (void *);
+extern void gt_pch_nx_vec_basic_block_va_gc_ (void *);
+extern void gt_pch_nx_vec_edge_va_gc_ (void *);
+extern void gt_pch_nx_rtl_bb_info (void *);
+extern void gt_pch_nx_vec_loop_p_va_gc_ (void *);
+extern void gt_pch_nx_loop (void *);
+extern void gt_pch_nx_loop_exit (void *);
+extern void gt_pch_nx_nb_iter_bound (void *);
+extern void gt_pch_nx_types_used_by_vars_entry (void *);
+extern void gt_pch_nx_language_function (void *);
+extern void gt_pch_nx_loops (void *);
+extern void gt_pch_nx_control_flow_graph (void *);
+extern void gt_pch_nx_eh_status (void *);
+extern void gt_pch_nx_stack_usage (void *);
+extern void gt_pch_nx_vec_temp_slot_p_va_gc_ (void *);
+extern void gt_pch_nx_initial_value_struct (void *);
+extern void gt_pch_nx_frame_space (void *);
+extern void gt_pch_nx_rtx_constant_pool (void *);
+extern void gt_pch_nx_dw_fde_struct (void *);
+extern void gt_pch_nx_temp_slot (void *);
+extern void gt_pch_nx_gimple_df (void *);
+extern void gt_pch_nx_vec_call_site_record_va_gc_ (void *);
+extern void gt_pch_nx_vec_uchar_va_gc_ (void *);
+extern void gt_pch_nx_call_site_record_d (void *);
+extern void gt_pch_nx_sequence_stack (void *);
+extern void gt_pch_nx_libfunc_entry (void *);
+extern void gt_pch_nx_tree_vec_map (void *);
+extern void gt_pch_nx_tree_priority_map (void *);
+extern void gt_pch_nx_tree_int_map (void *);
+extern void gt_pch_nx_tree_decl_map (void *);
+extern void gt_pch_nx_tree_map (void *);
+extern void gt_pch_nx_lang_tree_node (void *);
+extern void gt_pch_nx_tree_statement_list_node (void *);
+extern void gt_pch_nx_lang_decl (void *);
+extern void gt_pch_nx_lang_type (void *);
+extern void gt_pch_nx_die_struct (void *);
+extern void gt_pch_nx_vec_tree_va_gc_ (void *);
+extern void gt_pch_nx_ptr_info_def (void *);
+extern void gt_pch_nx_vec_constructor_elt_va_gc_ (void *);
+extern void gt_pch_nx_vec_alias_pair_va_gc_ (void *);
+extern void gt_pch_nx_function (void *);
+extern void gt_pch_nx_constant_descriptor_rtx (void *);
+extern void gt_pch_nx_fixed_value (void *);
+extern void gt_pch_nx_real_value (void *);
+extern void gt_pch_nx_vec_rtx_va_gc_ (void *);
+extern void gt_pch_nx_object_block (void *);
+extern void gt_pch_nx_reg_attrs (void *);
+extern void gt_pch_nx_mem_attrs (void *);
+extern void gt_pch_nx_coverage_data (void *);
+extern void gt_pch_nx_bitmap_obstack (void *);
+extern void gt_pch_nx_bitmap_element_def (void *);
+extern void gt_pch_nx_basic_block_def (void *);
+extern void gt_pch_nx_edge_def (void *);
+extern void gt_pch_nx_section (void *);
+extern void gt_pch_nx_gimple_statement_d (void *);
+extern void gt_pch_nx_rtvec_def (void *);
+extern void gt_pch_nx_rtx_def (void *);
+extern void gt_pch_nx_bitmap_head_def (void *);
+extern void gt_pch_nx_answer (void *);
+extern void gt_pch_nx_cpp_macro (void *);
+extern void gt_pch_nx_cpp_token (void *);
+extern void gt_pch_nx_line_maps (void *);
+extern void gt_pch_n_II17splay_tree_node_s (void *);
+extern void gt_pch_n_SP9tree_node17splay_tree_node_s (void *);
+extern void gt_pch_n_P9tree_nodeP9tree_node17splay_tree_node_s (void *);
+extern void gt_pch_n_P17string_descriptor4htab (void *);
+extern void gt_pch_n_P14type_assertion4htab (void *);
+extern void gt_pch_n_P18treetreehash_entry4htab (void *);
+extern void gt_pch_n_P17module_htab_entry4htab (void *);
+extern void gt_pch_n_P21pending_abstract_type4htab (void *);
+extern void gt_pch_n_P14constexpr_call4htab (void *);
+extern void gt_pch_n_P16constexpr_fundef4htab (void *);
+extern void gt_pch_n_P10spec_entry4htab (void *);
+extern void gt_pch_n_P16cxx_int_tree_map4htab (void *);
+extern void gt_pch_n_P17named_label_entry4htab (void *);
+extern void gt_pch_n_P13pad_type_hash4htab (void *);
+extern void gt_pch_n_P17lto_in_decl_state4htab (void *);
+extern void gt_pch_n_P9tree_nodeP9tree_node12splay_tree_s (void *);
+extern void gt_pch_n_P13scev_info_str4htab (void *);
+extern void gt_pch_n_P15tm_restart_node4htab (void *);
+extern void gt_pch_n_P12tree_int_map4htab (void *);
+extern void gt_pch_n_P8tree_map4htab (void *);
+extern void gt_pch_n_P23constant_descriptor_rtx4htab (void *);
+extern void gt_pch_n_P24constant_descriptor_tree4htab (void *);
+extern void gt_pch_n_P12object_block4htab (void *);
+extern void gt_pch_n_P7section4htab (void *);
+extern void gt_pch_n_P17tree_priority_map4htab (void *);
+extern void gt_pch_n_P12tree_vec_map4htab (void *);
+extern void gt_pch_n_P13tree_decl_map4htab (void *);
+extern void gt_pch_n_P9type_hash4htab (void *);
+extern void gt_pch_n_P23temp_slot_address_entry4htab (void *);
+extern void gt_pch_n_P15throw_stmt_node4htab (void *);
+extern void gt_pch_n_P9reg_attrs4htab (void *);
+extern void gt_pch_n_P9mem_attrs4htab (void *);
+extern void gt_pch_n_P7rtx_def4htab (void *);
+extern void gt_pch_n_P23addr_table_entry_struct4htab (void *);
+extern void gt_pch_n_P22cached_dw_loc_list_def4htab (void *);
+extern void gt_pch_n_P16var_loc_list_def4htab (void *);
+extern void gt_pch_n_P10die_struct4htab (void *);
+extern void gt_pch_n_P15dwarf_file_data4htab (void *);
+extern void gt_pch_n_P20indirect_string_node4htab (void *);
+extern void gt_pch_n_SP9tree_node12splay_tree_s (void *);
+extern void gt_pch_n_II12splay_tree_s (void *);
+extern void gt_pch_n_P15symtab_node_def4htab (void *);
+extern void gt_pch_n_P11cgraph_edge4htab (void *);
+extern void gt_pch_n_P9loop_exit4htab (void *);
+extern void gt_pch_n_P24types_used_by_vars_entry4htab (void *);
+extern void gt_pch_n_P9tree_node4htab (void *);
+extern void gt_pch_n_P13libfunc_entry4htab (void *);
+extern void gt_pch_p_24vec_ivarref_entry_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_26vec_prot_list_entry_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_23vec_msgref_entry_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_27vec_ident_data_tuple_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_17string_descriptor
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_9imp_entry
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_16hashed_attribute
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_12hashed_entry
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_16objc_map_private
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_26gimple_type_leader_entry_s
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_23vec_method_entry_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_14type_assertion
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_18treetreehash_entry
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_5CPool
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_3JCF
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_17module_htab_entry
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_13binding_level
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_27vec_pending_noexcept_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_21pending_abstract_type
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_19vec_tree_int_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_9cp_parser
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_38vec_cp_unparsed_functions_entry_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_17cp_parser_context
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_31vec_cp_default_arg_entry_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_8cp_lexer
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_19vec_cp_token_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_10tree_check
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_14constexpr_call
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_16constexpr_fundef
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_26vec_deferred_access_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_32vec_deferred_access_check_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_10spec_entry
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_16pending_template
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_25vec_incomplete_var_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_21named_label_use_entry
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_22vec_tree_pair_s_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_17named_label_entry
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_28vec_cxx_saved_binding_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_36vec_qualified_typedef_usage_t_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_14cp_token_cache
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_11saved_scope
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_16cxx_int_tree_map
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_27vec_cp_label_binding_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_27vec_cp_class_binding_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_16cp_binding_level
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_11cxx_binding
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_15binding_entry_s
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_15binding_table_s
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_11tinst_level
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_18vec_tinfo_s_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_8c_parser
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_9opt_stack
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_31vec_pending_redefinition_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_23vec_pending_weak_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_11align_stack
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_22vec_tree_gc_vec_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_23vec_const_char_p_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_18sorted_fields_type
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_15c_inline_static
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_28vec_c_goto_bindings_p_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_15c_goto_bindings
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_7c_scope
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_9c_binding
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_12c_label_vars
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_13pad_type_hash
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_18gnat_binding_level
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_20vec_loop_info_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_11loop_info_d
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_27vec_range_check_info_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_18range_check_info_d
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_9elab_info
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_10stmt_group
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_20vec_parm_attr_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_11parm_attr_d
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_27vec_inline_summary_t_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_26vec_size_time_entry_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_20vec_condition_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_17lto_in_decl_state
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_26vec_ipa_edge_args_t_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_38vec_ipa_agg_replacement_value_p_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_26vec_ipa_jump_func_t_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_28vec_ipa_agg_jf_item_t_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_20ssa_operand_memory_d
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_13scev_info_str
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_28vec_mem_addr_template_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_17vec_gimple_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_15tm_restart_node
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_9type_hash
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_16string_pool_data
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_23temp_slot_address_entry
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_15throw_stmt_node
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_25vec_eh_landing_pad_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_20vec_eh_region_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_10eh_catch_d
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_16eh_landing_pad_d
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_11eh_region_d
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_24vec_die_arg_entry_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_24vec_macinfo_entry_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_24vec_pubname_entry_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_31vec_dw_line_info_table_p_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_22cached_dw_loc_list_def
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_17call_arg_loc_node
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_16var_loc_list_def
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_12var_loc_node
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_16limbo_die_struct
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_23vec_dw_attr_node_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_25dw_line_info_table_struct
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_29vec_dw_line_info_entry_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_18comdat_type_struct
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_25dw_ranges_by_label_struct
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_16dw_ranges_struct
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_29vec_deferred_locations_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_21vec_dw_fde_ref_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_24reg_saved_in_data_struct
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_17dw_cfi_row_struct
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_15dwarf_file_data
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_20indirect_string_node
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_23addr_table_entry_struct
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_21vec_dw_cfi_ref_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_18dw_loc_list_struct
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_19dw_loc_descr_struct
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_13dw_cfi_struct
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_8typeinfo
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_25ipa_agg_replacement_value
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_26vec_alias_set_entry_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_17alias_set_entry_d
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_24constant_descriptor_tree
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_8asm_node
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_25cgraph_indirect_call_info
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_28cgraph_function_version_info
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_11cgraph_edge
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_28vec_ipa_replace_map_p_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_15ipa_replace_map
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_18lto_file_decl_data
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_20vec_ipa_ref_t_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_15symtab_node_def
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_11cgraph_node
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_22vec_basic_block_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_15vec_edge_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_11rtl_bb_info
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_17vec_loop_p_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_4loop
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_9loop_exit
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_13nb_iter_bound
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_24types_used_by_vars_entry
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_17language_function
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_5loops
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_18control_flow_graph
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_9eh_status
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_11stack_usage
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_22vec_temp_slot_p_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_20initial_value_struct
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_11frame_space
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_17rtx_constant_pool
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_13dw_fde_struct
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_9temp_slot
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_9gimple_df
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_27vec_call_site_record_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_16vec_uchar_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_18call_site_record_d
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_14sequence_stack
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_13libfunc_entry
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_12tree_vec_map
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_17tree_priority_map
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_12tree_int_map
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_13tree_decl_map
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_8tree_map
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_14lang_tree_node
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_24tree_statement_list_node
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_9lang_decl
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_9lang_type
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_10die_struct
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_15vec_tree_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_12ptr_info_def
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_26vec_constructor_elt_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_21vec_alias_pair_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_8function
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_23constant_descriptor_rtx
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_11fixed_value
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_10real_value
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_14vec_rtx_va_gc_
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_12object_block
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_9reg_attrs
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_9mem_attrs
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_13coverage_data
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_14bitmap_obstack
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_18bitmap_element_def
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_15basic_block_def
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_8edge_def
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_7section
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_18gimple_statement_d
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_9rtvec_def
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_7rtx_def
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_15bitmap_head_def
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_6answer
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_9cpp_macro
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_9cpp_token
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_9line_maps
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_II17splay_tree_node_s
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_SP9tree_node17splay_tree_node_s
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P9tree_nodeP9tree_node17splay_tree_node_s
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P17string_descriptor4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P14type_assertion4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P18treetreehash_entry4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P17module_htab_entry4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P21pending_abstract_type4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P14constexpr_call4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P16constexpr_fundef4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P10spec_entry4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P16cxx_int_tree_map4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P17named_label_entry4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P13pad_type_hash4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P17lto_in_decl_state4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P9tree_nodeP9tree_node12splay_tree_s
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P13scev_info_str4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P15tm_restart_node4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P12tree_int_map4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P8tree_map4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P23constant_descriptor_rtx4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P24constant_descriptor_tree4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P12object_block4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P7section4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P17tree_priority_map4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P12tree_vec_map4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P13tree_decl_map4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P9type_hash4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P23temp_slot_address_entry4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P15throw_stmt_node4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P9reg_attrs4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P9mem_attrs4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P7rtx_def4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P23addr_table_entry_struct4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P22cached_dw_loc_list_def4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P16var_loc_list_def4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P10die_struct4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P15dwarf_file_data4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P20indirect_string_node4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_SP9tree_node12splay_tree_s
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_II12splay_tree_s
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P15symtab_node_def4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P11cgraph_edge4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P9loop_exit4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P24types_used_by_vars_entry4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P9tree_node4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void gt_pch_p_P13libfunc_entry4htab
+    (void *, void *, gt_pointer_operator, void *);
+extern void * ggc_alloc_splay_tree_scalar_scalar_splay_tree_node_s (int, void *);
+extern void * ggc_alloc_splay_tree_str_tree_node_splay_tree_node_s (int, void *);
+extern void * ggc_alloc_splay_tree_tree_node_tree_node_splay_tree_node_s (int, void *);
+extern void * ggc_alloc_splay_tree_string_descriptor_htab (int, void *);
+extern void * ggc_alloc_splay_tree_type_assertion_htab (int, void *);
+extern void * ggc_alloc_splay_tree_treetreehash_entry_htab (int, void *);
+extern void * ggc_alloc_splay_tree_module_htab_entry_htab (int, void *);
+extern void * ggc_alloc_splay_tree_pending_abstract_type_htab (int, void *);
+extern void * ggc_alloc_splay_tree_constexpr_call_htab (int, void *);
+extern void * ggc_alloc_splay_tree_constexpr_fundef_htab (int, void *);
+extern void * ggc_alloc_splay_tree_spec_entry_htab (int, void *);
+extern void * ggc_alloc_splay_tree_cxx_int_tree_map_htab (int, void *);
+extern void * ggc_alloc_splay_tree_named_label_entry_htab (int, void *);
+extern void * ggc_alloc_splay_tree_pad_type_hash_htab (int, void *);
+extern void * ggc_alloc_splay_tree_lto_in_decl_state_htab (int, void *);
+extern void * ggc_alloc_splay_tree_tree_node_tree_node_splay_tree_s (int, void *);
+extern void * ggc_alloc_splay_tree_scev_info_str_htab (int, void *);
+extern void * ggc_alloc_splay_tree_tm_restart_node_htab (int, void *);
+extern void * ggc_alloc_splay_tree_tree_int_map_htab (int, void *);
+extern void * ggc_alloc_splay_tree_tree_map_htab (int, void *);
+extern void * ggc_alloc_splay_tree_constant_descriptor_rtx_htab (int, void *);
+extern void * ggc_alloc_splay_tree_constant_descriptor_tree_htab (int, void *);
+extern void * ggc_alloc_splay_tree_object_block_htab (int, void *);
+extern void * ggc_alloc_splay_tree_section_htab (int, void *);
+extern void * ggc_alloc_splay_tree_tree_priority_map_htab (int, void *);
+extern void * ggc_alloc_splay_tree_tree_vec_map_htab (int, void *);
+extern void * ggc_alloc_splay_tree_tree_decl_map_htab (int, void *);
+extern void * ggc_alloc_splay_tree_type_hash_htab (int, void *);
+extern void * ggc_alloc_splay_tree_temp_slot_address_entry_htab (int, void *);
+extern void * ggc_alloc_splay_tree_throw_stmt_node_htab (int, void *);
+extern void * ggc_alloc_splay_tree_reg_attrs_htab (int, void *);
+extern void * ggc_alloc_splay_tree_mem_attrs_htab (int, void *);
+extern void * ggc_alloc_splay_tree_rtx_def_htab (int, void *);
+extern void * ggc_alloc_splay_tree_addr_table_entry_struct_htab (int, void *);
+extern void * ggc_alloc_splay_tree_cached_dw_loc_list_def_htab (int, void *);
+extern void * ggc_alloc_splay_tree_var_loc_list_def_htab (int, void *);
+extern void * ggc_alloc_splay_tree_die_struct_htab (int, void *);
+extern void * ggc_alloc_splay_tree_dwarf_file_data_htab (int, void *);
+extern void * ggc_alloc_splay_tree_indirect_string_node_htab (int, void *);
+extern void * ggc_alloc_splay_tree_str_tree_node_splay_tree_s (int, void *);
+extern void * ggc_alloc_splay_tree_scalar_scalar_splay_tree_s (int, void *);
+extern void * ggc_alloc_splay_tree_symtab_node_def_htab (int, void *);
+extern void * ggc_alloc_splay_tree_cgraph_edge_htab (int, void *);
+extern void * ggc_alloc_splay_tree_loop_exit_htab (int, void *);
+extern void * ggc_alloc_splay_tree_types_used_by_vars_entry_htab (int, void *);
+extern void * ggc_alloc_splay_tree_tree_node_htab (int, void *);
+extern void * ggc_alloc_splay_tree_libfunc_entry_htab (int, void *);
+typedef void (*gt_note_pointers) (void *, void *, gt_pointer_operator,
+      void *);
+typedef void (*gt_handle_reorder) (void *, void *, gt_pointer_operator,
+       void *);
+extern int gt_pch_note_object (void *, void *, gt_note_pointers);
+extern void gt_pch_note_reorder (void *, void *, gt_handle_reorder);
+typedef void (*gt_pointer_walker) (void *);
+struct ggc_root_tab {
+  void *base;
+  size_t nelt;
+  size_t stride;
+  gt_pointer_walker cb;
+  gt_pointer_walker pchw;
+};
+extern const struct ggc_root_tab * const gt_ggc_rtab[];
+extern const struct ggc_root_tab * const gt_ggc_deletable_rtab[];
+extern const struct ggc_root_tab * const gt_pch_cache_rtab[];
+extern const struct ggc_root_tab * const gt_pch_scalar_rtab[];
+struct htab;
+struct ggc_cache_tab {
+  struct htab * *base;
+  size_t nelt;
+  size_t stride;
+  gt_pointer_walker cb;
+  gt_pointer_walker pchw;
+  int (*marked_p) (const void *);
+};
+extern const struct ggc_cache_tab * const gt_ggc_cache_rtab[];
+extern int ggc_set_mark (const void *);
+extern int ggc_marked_p (const void *);
+extern void gt_pch_n_S (const void *);
+extern void gt_ggc_m_S (const void *);
+extern void init_stringpool (void);
+extern void init_ggc (void);
+extern bool ggc_protect_identifiers;
+extern void gt_pch_save (FILE *f);
+extern void *ggc_internal_alloc_stat (size_t )
+  __attribute__ ((__malloc__));
+extern size_t ggc_round_alloc_size (size_t requested_size);
+extern void *ggc_internal_cleared_alloc_stat (size_t )
+  __attribute__ ((__malloc__));
+extern void *ggc_realloc_stat (void *, size_t );
+extern void ggc_free (void *);
+extern void dump_ggc_loc_statistics (bool);
+static inline void *
+ggc_internal_vec_alloc_stat (size_t s, size_t c )
+{
+    return ggc_internal_alloc_stat (c * s );
+}
+static inline void *
+ggc_internal_cleared_vec_alloc_stat (size_t s, size_t c )
+{
+    return ggc_internal_cleared_alloc_stat (c * s );
+}
+static inline void *
+ggc_alloc_atomic_stat (size_t s )
+{
+    return ggc_internal_alloc_stat (s );
+}
+extern void *ggc_cleared_alloc_htab_ignore_args (size_t, size_t)
+  __attribute__ ((__malloc__));
+extern void *ggc_cleared_alloc_ptr_array_two_args (size_t, size_t)
+  __attribute__ ((__malloc__));
+extern void *ggc_splay_alloc (int, void *)
+  __attribute__ ((__malloc__));
+extern void ggc_splay_dont_free (void *, void *);
+extern const char *ggc_alloc_string_stat (const char *contents, int length
+                                          );
+extern void ggc_collect (void);
+extern void ggc_register_root_tab (const struct ggc_root_tab *);
+extern void ggc_register_cache_tab (const struct ggc_cache_tab *);
+extern void gt_pch_restore (FILE *f);
+extern void ggc_print_statistics (void);
+extern void stringpool_statistics (void);
+extern void init_ggc_heuristics (void);
+static inline struct rtx_def *
+ggc_alloc_rtx_def_stat (size_t s )
+{
+  return (struct rtx_def *) ggc_internal_alloc_stat (s );
+}
+static inline union tree_node *
+ggc_alloc_tree_node_stat (size_t s )
+{
+  return (union tree_node *) ggc_internal_alloc_stat (s );
+}
+static inline union tree_node *
+ggc_alloc_cleared_tree_node_stat (size_t s )
+{
+  return (union tree_node *) ggc_internal_cleared_alloc_stat (s );
+}
+static inline union gimple_statement_d *
+ggc_alloc_cleared_gimple_statement_d_stat (size_t s )
+{
+  return (union gimple_statement_d *)
+    ggc_internal_cleared_alloc_stat (s );
+}
+extern void dump_vec_loc_statistics (void);
+struct vec_prefix
+{
+  void register_overhead (size_t, const char *, int, const char *);
+  void release_overhead (void);
+  static unsigned calculate_allocation (vec_prefix *, unsigned, bool);
+  template <typename, typename, typename> friend struct vec;
+  friend struct va_gc;
+  friend struct va_gc_atomic;
+  friend struct va_heap;
+  friend struct va_stack;
+  unsigned alloc_;
+  unsigned num_;
+};
+template<typename, typename, typename> struct vec;
+struct vl_embed { };
+struct vl_ptr { };
+struct va_heap
+{
+  typedef vl_ptr default_layout;
+  template<typename T>
+  static void reserve (vec<T, va_heap, vl_embed> *&, unsigned, bool
+         );
+  template<typename T>
+  static void release (vec<T, va_heap, vl_embed> *&);
+};
+template<typename T>
+inline void
+va_heap::reserve (vec<T, va_heap, vl_embed> *&v, unsigned reserve, bool exact
+    )
+{
+  unsigned alloc
+    = vec_prefix::calculate_allocation (v ? &v->vecpfx_ : 0, reserve, exact);
+  if (!alloc)
+    {
+      release (v);
+      return;
+    }
+  if (0 && v)
+    v->vecpfx_.release_overhead ();
+  size_t size = vec<T, va_heap, vl_embed>::embedded_size (alloc);
+  unsigned nelem = v ? v->length () : 0;
+  v = static_cast <vec<T, va_heap, vl_embed> *> (xrealloc (v, size));
+  v->embedded_init (alloc, nelem);
+  if (0)
+    v->vecpfx_.register_overhead (size , 0,0,0);
+}
+template<typename T>
+void
+va_heap::release (vec<T, va_heap, vl_embed> *&v)
+{
+  if (v == __null)
+    return;
+  if (0)
+    v->vecpfx_.release_overhead ();
+  ::free (v);
+  v = __null;
+}
+struct va_gc
+{
+  typedef vl_embed default_layout;
+  template<typename T, typename A>
+  static void reserve (vec<T, A, vl_embed> *&, unsigned, bool
+         );
+  template<typename T, typename A>
+  static void release (vec<T, A, vl_embed> *&v) { v = __null; }
+};
+template<typename T, typename A>
+void
+va_gc::reserve (vec<T, A, vl_embed> *&v, unsigned reserve, bool exact
+  )
+{
+  unsigned alloc
+    = vec_prefix::calculate_allocation (v ? &v->vecpfx_ : 0, reserve, exact);
+  if (!alloc)
+    {
+      ::ggc_free (v);
+      v = __null;
+      return;
+    }
+  size_t size = vec<T, A, vl_embed>::embedded_size (alloc);
+  size = ::ggc_round_alloc_size (size);
+  size_t vec_offset = sizeof (vec_prefix);
+  size_t elt_size = sizeof (T);
+  alloc = (size - vec_offset) / elt_size;
+  size = vec_offset + alloc * elt_size;
+  unsigned nelem = v ? v->length () : 0;
+  v = static_cast <vec<T, A, vl_embed> *> (::ggc_realloc_stat (v, size
+              ));
+  v->embedded_init (alloc, nelem);
+}
+struct va_gc_atomic : va_gc
+{
+};
+struct va_stack
+{
+  typedef vl_ptr default_layout;
+  template<typename T>
+  static void alloc (vec<T, va_stack, vl_ptr>&, unsigned,
+       vec<T, va_stack, vl_embed> *);
+  template <typename T>
+  static void reserve (vec<T, va_stack, vl_embed> *&, unsigned, bool
+         );
+  template <typename T>
+  static void release (vec<T, va_stack, vl_embed> *&);
+};
+void register_stack_vec (void *);
+int stack_vec_register_index (void *);
+void unregister_stack_vec (unsigned);
+template<typename T>
+void
+va_stack::alloc (vec<T, va_stack, vl_ptr> &v, unsigned nelems,
+   vec<T, va_stack, vl_embed> *space)
+{
+  v.vec_ = space;
+  register_stack_vec (static_cast<void *> (v.vec_));
+  v.vec_->embedded_init (nelems, 0);
+}
+template<typename T>
+void
+va_stack::reserve (vec<T, va_stack, vl_embed> *&v, unsigned nelems, bool exact
+     )
+{
+  int ix = stack_vec_register_index (static_cast<void *> (v));
+  if (ix >= 0)
+    unregister_stack_vec (ix);
+  else
+    {
+      va_heap::reserve (reinterpret_cast<vec<T, va_heap, vl_embed> *&> (v),
+   nelems, exact );
+      return;
+    }
+  nelems += v->vecpfx_.num_;
+  vec<T, va_stack, vl_embed> *oldvec = v;
+  v = __null;
+  va_heap::reserve (reinterpret_cast<vec<T, va_heap, vl_embed> *&>(v), nelems,
+      exact );
+  if (v && oldvec)
+    {
+      v->vecpfx_.num_ = oldvec->length ();
+      memcpy (v->vecdata_,
+       oldvec->vecdata_,
+       oldvec->length () * sizeof (T));
+    }
+}
+template<typename T>
+void
+va_stack::release (vec<T, va_stack, vl_embed> *&v)
+{
+  if (v == __null)
+    return;
+  int ix = stack_vec_register_index (static_cast<void *> (v));
+  if (ix >= 0)
+    {
+      unregister_stack_vec (ix);
+      v = __null;
+    }
+  else
+    {
+      va_heap::release (reinterpret_cast<vec<T, va_heap, vl_embed> *&> (v));
+    }
+}
+template<typename T,
+         typename A = va_heap,
+         typename L = typename A::default_layout>
+struct vec
+{
+};
+struct vnull
+{
+  template <typename T, typename A, typename L>
+  operator vec<T, A, L> () { return vec<T, A, L>(); }
+};
+extern vnull vNULL;
+template<typename T, typename A>
+struct vec<T, A, vl_embed>
+{
+public:
+  unsigned allocated (void) const { return vecpfx_.alloc_; }
+  unsigned length (void) const { return vecpfx_.num_; }
+  bool is_empty (void) const { return vecpfx_.num_ == 0; }
+  T *address (void) { return vecdata_; }
+  const T *address (void) const { return vecdata_; }
+  const T &operator[] (unsigned) const;
+  T &operator[] (unsigned);
+  T &last (void);
+  bool space (unsigned) const;
+  bool iterate (unsigned, T *) const;
+  bool iterate (unsigned, T **) const;
+  vec *copy () const;
+  void splice (vec &);
+  void splice (vec *src);
+  T *quick_push (const T &);
+  T &pop (void);
+  void truncate (unsigned);
+  void quick_insert (unsigned, const T &);
+  void ordered_remove (unsigned);
+  void unordered_remove (unsigned);
+  void block_remove (unsigned, unsigned);
+  void qsort (int (*) (const void *, const void *));
+  unsigned lower_bound (T, bool (*)(const T &, const T &)) const;
+  static size_t embedded_size (unsigned);
+  void embedded_init (unsigned, unsigned = 0);
+  void quick_grow (unsigned len);
+  void quick_grow_cleared (unsigned len);
+  template <typename, typename, typename> friend struct vec;
+  friend struct va_gc;
+  friend struct va_gc_atomic;
+  friend struct va_heap;
+  friend struct va_stack;
+  vec_prefix vecpfx_;
+  T vecdata_[1];
+};
+template<typename T, typename A>
+inline bool
+vec_safe_space (const vec<T, A, vl_embed> *v, unsigned nelems)
+{
+  return v ? v->space (nelems) : nelems == 0;
+}
+template<typename T, typename A>
+inline unsigned
+vec_safe_length (const vec<T, A, vl_embed> *v)
+{
+  return v ? v->length () : 0;
+}
+template<typename T, typename A>
+inline T *
+vec_safe_address (vec<T, A, vl_embed> *v)
+{
+  return v ? v->address () : __null;
+}
+template<typename T, typename A>
+inline bool
+vec_safe_is_empty (vec<T, A, vl_embed> *v)
+{
+  return v ? v->is_empty () : true;
+}
+template<typename T, typename A>
+inline bool
+vec_safe_reserve (vec<T, A, vl_embed> *&v, unsigned nelems, bool exact = false
+    )
+{
+  bool extend = nelems ? !vec_safe_space (v, nelems) : false;
+  if (extend)
+    A::reserve (v, nelems, exact );
+  return extend;
+}
+template<typename T, typename A>
+inline bool
+vec_safe_reserve_exact (vec<T, A, vl_embed> *&v, unsigned nelems
+   )
+{
+  return vec_safe_reserve (v, nelems, true );
+}
+template<typename T, typename A>
+inline void
+vec_alloc (vec<T, A, vl_embed> *&v, unsigned nelems )
+{
+  v = __null;
+  vec_safe_reserve (v, nelems, false );
+}
+template<typename T, typename A>
+inline void
+vec_free (vec<T, A, vl_embed> *&v)
+{
+  A::release (v);
+}
+template<typename T, typename A>
+inline void
+vec_safe_grow (vec<T, A, vl_embed> *&v, unsigned len )
+{
+  unsigned oldlen = vec_safe_length (v);
+  ((void)(0 && (len >= oldlen)));
+  vec_safe_reserve_exact (v, len - oldlen );
+  v->quick_grow (len);
+}
+template<typename T, typename A>
+inline void
+vec_safe_grow_cleared (vec<T, A, vl_embed> *&v, unsigned len )
+{
+  unsigned oldlen = vec_safe_length (v);
+  vec_safe_grow (v, len );
+  memset (&(v->address()[oldlen]), 0, sizeof (T) * (len - oldlen));
+}
+template<typename T, typename A>
+inline bool
+vec_safe_iterate (const vec<T, A, vl_embed> *v, unsigned ix, T **ptr)
+{
+  if (v)
+    return v->iterate (ix, ptr);
+  else
+    {
+      *ptr = 0;
+      return false;
+    }
+}
+template<typename T, typename A>
+inline bool
+vec_safe_iterate (const vec<T, A, vl_embed> *v, unsigned ix, T *ptr)
+{
+  if (v)
+    return v->iterate (ix, ptr);
+  else
+    {
+      *ptr = 0;
+      return false;
+    }
+}
+template<typename T, typename A>
+inline T *
+vec_safe_push (vec<T, A, vl_embed> *&v, const T &obj )
+{
+  vec_safe_reserve (v, 1, false );
+  return v->quick_push (obj);
+}
+template<typename T, typename A>
+inline void
+vec_safe_insert (vec<T, A, vl_embed> *&v, unsigned ix, const T &obj
+   )
+{
+  vec_safe_reserve (v, 1, false );
+  v->quick_insert (ix, obj);
+}
+template<typename T, typename A>
+inline void
+vec_safe_truncate (vec<T, A, vl_embed> *v, unsigned size)
+{
+  if (v)
+    v->truncate (size);
+}
+template<typename T, typename A>
+inline vec<T, A, vl_embed> *
+vec_safe_copy (vec<T, A, vl_embed> *src)
+{
+  return src ? src->copy () : __null;
+}
+template<typename T, typename A>
+inline void
+vec_safe_splice (vec<T, A, vl_embed> *&dst, vec<T, A, vl_embed> *src
+   )
+{
+  unsigned src_len = vec_safe_length (src);
+  if (src_len)
+    {
+      vec_safe_reserve_exact (dst, vec_safe_length (dst) + src_len
+         );
+      dst->splice (*src);
+    }
+}
+template<typename T, typename A>
+inline const T &
+vec<T, A, vl_embed>::operator[] (unsigned ix) const
+{
+  ((void)(0 && (ix < vecpfx_.num_)));
+  return vecdata_[ix];
+}
+template<typename T, typename A>
+inline T &
+vec<T, A, vl_embed>::operator[] (unsigned ix)
+{
+  ((void)(0 && (ix < vecpfx_.num_)));
+  return vecdata_[ix];
+}
+template<typename T, typename A>
+inline T &
+vec<T, A, vl_embed>::last (void)
+{
+  ((void)(0 && (vecpfx_.num_ > 0)));
+  return (*this)[vecpfx_.num_ - 1];
+}
+template<typename T, typename A>
+inline bool
+vec<T, A, vl_embed>::space (unsigned nelems) const
+{
+  return vecpfx_.alloc_ - vecpfx_.num_ >= nelems;
+}
+template<typename T, typename A>
+inline bool
+vec<T, A, vl_embed>::iterate (unsigned ix, T *ptr) const
+{
+  if (ix < vecpfx_.num_)
+    {
+      *ptr = vecdata_[ix];
+      return true;
+    }
+  else
+    {
+      *ptr = 0;
+      return false;
+    }
+}
+template<typename T, typename A>
+inline bool
+vec<T, A, vl_embed>::iterate (unsigned ix, T **ptr) const
+{
+  if (ix < vecpfx_.num_)
+    {
+      *ptr = (const_cast<T *> ((&vecdata_[ix])));
+      return true;
+    }
+  else
+    {
+      *ptr = 0;
+      return false;
+    }
+}
+template<typename T, typename A>
+inline vec<T, A, vl_embed> *
+vec<T, A, vl_embed>::copy (void) const
+{
+  vec<T, A, vl_embed> *new_vec = __null;
+  unsigned len = length ();
+  if (len)
+    {
+      vec_alloc (new_vec, len );
+      new_vec->embedded_init (len, len);
+      memcpy (new_vec->address(), vecdata_, sizeof (T) * len);
+    }
+  return new_vec;
+}
+template<typename T, typename A>
+inline void
+vec<T, A, vl_embed>::splice (vec<T, A, vl_embed> &src)
+{
+  unsigned len = src.length();
+  if (len)
+    {
+      ((void)(0 && (space (len))));
+      memcpy (address() + length(), src.address(), len * sizeof (T));
+      vecpfx_.num_ += len;
+    }
+}
+template<typename T, typename A>
+inline void
+vec<T, A, vl_embed>::splice (vec<T, A, vl_embed> *src)
+{
+  if (src)
+    splice (*src);
+}
+template<typename T, typename A>
+inline T *
+vec<T, A, vl_embed>::quick_push (const T &obj)
+{
+  ((void)(0 && (space (1))));
+  T *slot = &vecdata_[vecpfx_.num_++];
+  *slot = obj;
+  return slot;
+}
+template<typename T, typename A>
+inline T &
+vec<T, A, vl_embed>::pop (void)
+{
+  ((void)(0 && (length () > 0)));
+  return vecdata_[--vecpfx_.num_];
+}
+template<typename T, typename A>
+inline void
+vec<T, A, vl_embed>::truncate (unsigned size)
+{
+  ((void)(0 && (length () >= size)));
+  vecpfx_.num_ = size;
+}
+template<typename T, typename A>
+inline void
+vec<T, A, vl_embed>::quick_insert (unsigned ix, const T &obj)
+{
+  ((void)(0 && (length () < allocated ())));
+  ((void)(0 && (ix <= length ())));
+  T *slot = &vecdata_[ix];
+  memmove (slot + 1, slot, (vecpfx_.num_++ - ix) * sizeof (T));
+  *slot = obj;
+}
+template<typename T, typename A>
+inline void
+vec<T, A, vl_embed>::ordered_remove (unsigned ix)
+{
+  ((void)(0 && (ix < length())));
+  T *slot = &vecdata_[ix];
+  memmove (slot, slot + 1, (--vecpfx_.num_ - ix) * sizeof (T));
+}
+template<typename T, typename A>
+inline void
+vec<T, A, vl_embed>::unordered_remove (unsigned ix)
+{
+  ((void)(0 && (ix < length())));
+  vecdata_[ix] = vecdata_[--vecpfx_.num_];
+}
+template<typename T, typename A>
+inline void
+vec<T, A, vl_embed>::block_remove (unsigned ix, unsigned len)
+{
+  ((void)(0 && (ix + len <= length())));
+  T *slot = &vecdata_[ix];
+  vecpfx_.num_ -= len;
+  memmove (slot, slot + len, (vecpfx_.num_ - ix) * sizeof (T));
+}
+template<typename T, typename A>
+inline void
+vec<T, A, vl_embed>::qsort (int (*cmp) (const void *, const void *))
+{
+  ::qsort (address(), length(), sizeof (T), cmp);
+}
+template<typename T, typename A>
+unsigned
+vec<T, A, vl_embed>::lower_bound (T obj, bool (*lessthan)(const T &, const T &))
+  const
+{
+  unsigned int len = length ();
+  unsigned int half, middle;
+  unsigned int first = 0;
+  while (len > 0)
+    {
+      half = len / 2;
+      middle = first;
+      middle += half;
+      T middle_elem = (*this)[middle];
+      if (lessthan (middle_elem, obj))
+ {
+   first = middle;
+   ++first;
+   len = len - half - 1;
+ }
+      else
+ len = half;
+    }
+  return first;
+}
+template<typename T, typename A>
+inline size_t
+vec<T, A, vl_embed>::embedded_size (unsigned alloc)
+{
+  typedef vec<T, A, vl_embed> vec_embedded;
+  return __builtin_offsetof (vec_embedded, vecdata_) + alloc * sizeof (T);
+}
+template<typename T, typename A>
+inline void
+vec<T, A, vl_embed>::embedded_init (unsigned alloc, unsigned num)
+{
+  vecpfx_.alloc_ = alloc;
+  vecpfx_.num_ = num;
+}
+template<typename T, typename A>
+inline void
+vec<T, A, vl_embed>::quick_grow (unsigned len)
+{
+  ((void)(0 && (length () <= len && len <= vecpfx_.alloc_)));
+  vecpfx_.num_ = len;
+}
+template<typename T, typename A>
+inline void
+vec<T, A, vl_embed>::quick_grow_cleared (unsigned len)
+{
+  unsigned oldlen = length ();
+  quick_grow (len);
+  memset (&(address()[oldlen]), 0, sizeof (T) * (len - oldlen));
+}
+template<typename T>
+void
+gt_ggc_mx (vec<T, va_gc> *v)
+{
+  extern void gt_ggc_mx (T &);
+  for (unsigned i = 0; i < v->length (); i++)
+    gt_ggc_mx ((*v)[i]);
+}
+template<typename T>
+void
+gt_ggc_mx (vec<T, va_gc_atomic, vl_embed> *v __attribute__ ((__unused__)))
+{
+}
+template<typename T, typename A>
+void
+gt_pch_nx (vec<T, A, vl_embed> *v)
+{
+  extern void gt_pch_nx (T &);
+  for (unsigned i = 0; i < v->length (); i++)
+    gt_pch_nx ((*v)[i]);
+}
+template<typename T, typename A>
+void
+gt_pch_nx (vec<T *, A, vl_embed> *v, gt_pointer_operator op, void *cookie)
+{
+  for (unsigned i = 0; i < v->length (); i++)
+    op (&((*v)[i]), cookie);
+}
+template<typename T, typename A>
+void
+gt_pch_nx (vec<T, A, vl_embed> *v, gt_pointer_operator op, void *cookie)
+{
+  extern void gt_pch_nx (T *, gt_pointer_operator, void *);
+  for (unsigned i = 0; i < v->length (); i++)
+    gt_pch_nx (&((*v)[i]), op, cookie);
+}
+template<typename T, typename A>
+struct vec<T, A, vl_ptr>
+{
+public:
+  void create (unsigned nelems );
+  void release (void);
+  bool exists (void) const
+  { return vec_ != __null; }
+  bool is_empty (void) const
+  { return vec_ ? vec_->is_empty() : true; }
+  unsigned length (void) const
+  { return vec_ ? vec_->length() : 0; }
+  T *address (void)
+  { return vec_ ? vec_->vecdata_ : __null; }
+  const T *address (void) const
+  { return vec_ ? vec_->vecdata_ : __null; }
+  const T &operator[] (unsigned ix) const
+  { return (*vec_)[ix]; }
+  bool operator!=(const vec &other) const
+  { return !(*this == other); }
+  bool operator==(const vec &other) const
+  { return address() == other.address(); }
+  T &operator[] (unsigned ix)
+  { return (*vec_)[ix]; }
+  T &last (void)
+  { return vec_->last(); }
+  bool space (int nelems) const
+  { return vec_ ? vec_->space (nelems) : nelems == 0; }
+  bool iterate (unsigned ix, T *p) const;
+  bool iterate (unsigned ix, T **p) const;
+  vec copy () const;
+  bool reserve (unsigned, bool = false );
+  bool reserve_exact (unsigned );
+  void splice (vec &);
+  void safe_splice (vec & );
+  T *quick_push (const T &);
+  T *safe_push (const T &);
+  T &pop (void);
+  void truncate (unsigned);
+  void safe_grow (unsigned );
+  void safe_grow_cleared (unsigned );
+  void quick_grow (unsigned);
+  void quick_grow_cleared (unsigned);
+  void quick_insert (unsigned, const T &);
+  void safe_insert (unsigned, const T & );
+  void ordered_remove (unsigned);
+  void unordered_remove (unsigned);
+  void block_remove (unsigned, unsigned);
+  void qsort (int (*) (const void *, const void *));
+  unsigned lower_bound (T, bool (*)(const T &, const T &)) const;
+  template<typename T1>
+  friend void va_stack::alloc(vec<T1, va_stack, vl_ptr>&, unsigned,
+         vec<T1, va_stack, vl_embed> *);
+  vec<T, A, vl_embed> *vec_;
+};
+template<typename T>
+struct vec<T, va_gc, vl_ptr>
+{
+};
+template<typename T>
+inline void
+vec_alloc (vec<T> *&v, unsigned nelems )
+{
+  v = new vec<T>;
+  v->create (nelems );
+}
+template<typename T>
+inline void
+vec_check_alloc (vec<T, va_heap> *&vec, unsigned nelems )
+{
+  if (!vec)
+    vec_alloc (vec, nelems );
+}
+template<typename T>
+inline void
+vec_free (vec<T> *&v)
+{
+  if (v == __null)
+    return;
+  v->release ();
+  delete v;
+  v = __null;
+}
+template<typename T, typename A>
+inline bool
+vec<T, A, vl_ptr>::iterate (unsigned ix, T *ptr) const
+{
+  if (vec_)
+    return vec_->iterate (ix, ptr);
+  else
+    {
+      *ptr = 0;
+      return false;
+    }
+}
+template<typename T, typename A>
+inline bool
+vec<T, A, vl_ptr>::iterate (unsigned ix, T **ptr) const
+{
+  if (vec_)
+    return vec_->iterate (ix, ptr);
+  else
+    {
+      *ptr = 0;
+      return false;
+    }
+}
+template<typename T, typename A>
+inline vec<T, A, vl_ptr>
+vec<T, A, vl_ptr>::copy (void) const
+{
+  vec<T, A, vl_ptr> new_vec = vNULL;
+  if (length ())
+    new_vec.vec_ = vec_->copy ();
+  return new_vec;
+}
+template<typename T, typename A>
+inline bool
+vec<T, A, vl_ptr>::reserve (unsigned nelems, bool exact )
+{
+  bool extend = nelems ? !space (nelems) : false;
+  if (extend)
+    A::reserve (vec_, nelems, exact );
+  return extend;
+}
+template<typename T, typename A>
+inline bool
+vec<T, A, vl_ptr>::reserve_exact (unsigned nelems )
+{
+  return reserve (nelems, true );
+}
+template<typename T, typename A>
+inline void
+vec<T, A, vl_ptr>::create (unsigned nelems )
+{
+  vec_ = __null;
+  if (nelems > 0)
+    reserve_exact (nelems );
+}
+template<typename T, typename A>
+inline void
+vec<T, A, vl_ptr>::release (void)
+{
+  if (vec_)
+    A::release (vec_);
+}
+template<typename T, typename A>
+inline void
+vec<T, A, vl_ptr>::splice (vec<T, A, vl_ptr> &src)
+{
+  if (src.vec_)
+    vec_->splice (*(src.vec_));
+}
+template<typename T, typename A>
+inline void
+vec<T, A, vl_ptr>::safe_splice (vec<T, A, vl_ptr> &src )
+{
+  if (src.length())
+    {
+      reserve_exact (src.length());
+      splice (src);
+    }
+}
+template<typename T, typename A>
+inline T *
+vec<T, A, vl_ptr>::quick_push (const T &obj)
+{
+  return vec_->quick_push (obj);
+}
+template<typename T, typename A>
+inline T *
+vec<T, A, vl_ptr>::safe_push (const T &obj )
+{
+  reserve (1, false );
+  return quick_push (obj);
+}
+template<typename T, typename A>
+inline T &
+vec<T, A, vl_ptr>::pop (void)
+{
+  return vec_->pop ();
+}
+template<typename T, typename A>
+inline void
+vec<T, A, vl_ptr>::truncate (unsigned size)
+{
+  if (vec_)
+    vec_->truncate (size);
+  else
+    ((void)(0 && (size == 0)));
+}
+template<typename T, typename A>
+inline void
+vec<T, A, vl_ptr>::safe_grow (unsigned len )
+{
+  unsigned oldlen = length ();
+  ((void)(0 && (oldlen <= len)));
+  reserve_exact (len - oldlen );
+  vec_->quick_grow (len);
+}
+template<typename T, typename A>
+inline void
+vec<T, A, vl_ptr>::safe_grow_cleared (unsigned len )
+{
+  unsigned oldlen = length ();
+  safe_grow (len );
+  memset (&(address()[oldlen]), 0, sizeof (T) * (len - oldlen));
+}
+template<typename T, typename A>
+inline void
+vec<T, A, vl_ptr>::quick_grow (unsigned len)
+{
+  ((void)(0 && (vec_)));
+  vec_->quick_grow (len);
+}
+template<typename T, typename A>
+inline void
+vec<T, A, vl_ptr>::quick_grow_cleared (unsigned len)
+{
+  ((void)(0 && (vec_)));
+  vec_->quick_grow_cleared (len);
+}
+template<typename T, typename A>
+inline void
+vec<T, A, vl_ptr>::quick_insert (unsigned ix, const T &obj)
+{
+  vec_->quick_insert (ix, obj);
+}
+template<typename T, typename A>
+inline void
+vec<T, A, vl_ptr>::safe_insert (unsigned ix, const T &obj )
+{
+  reserve (1, false );
+  quick_insert (ix, obj);
+}
+template<typename T, typename A>
+inline void
+vec<T, A, vl_ptr>::ordered_remove (unsigned ix)
+{
+  vec_->ordered_remove (ix);
+}
+template<typename T, typename A>
+inline void
+vec<T, A, vl_ptr>::unordered_remove (unsigned ix)
+{
+  vec_->unordered_remove (ix);
+}
+template<typename T, typename A>
+inline void
+vec<T, A, vl_ptr>::block_remove (unsigned ix, unsigned len)
+{
+  vec_->block_remove (ix, len);
+}
+template<typename T, typename A>
+inline void
+vec<T, A, vl_ptr>::qsort (int (*cmp) (const void *, const void *))
+{
+  if (vec_)
+    vec_->qsort (cmp);
+}
+template<typename T, typename A>
+inline unsigned
+vec<T, A, vl_ptr>::lower_bound (T obj, bool (*lessthan)(const T &, const T &))
+    const
+{
+  return vec_ ? vec_->lower_bound (obj, lessthan) : 0;
+}
+        
+struct double_int
+{
+  static double_int from_uhwi (unsigned long long cst);
+  static double_int from_shwi (long long cst);
+  static double_int from_pair (long long high, unsigned long long low);
+  static double_int from_buffer (const unsigned char *buffer, int len);
+  static double_int mask (unsigned prec);
+  static double_int max_value (unsigned int prec, bool uns);
+  static double_int min_value (unsigned int prec, bool uns);
+  double_int &operator ++ ();
+  double_int &operator -- ();
+  double_int &operator *= (double_int);
+  double_int &operator += (double_int);
+  double_int &operator -= (double_int);
+  double_int &operator &= (double_int);
+  double_int &operator ^= (double_int);
+  double_int &operator |= (double_int);
+  long long to_shwi () const;
+  unsigned long long to_uhwi () const;
+  bool fits_uhwi () const;
+  bool fits_shwi () const;
+  bool fits_hwi (bool uns) const;
+  int trailing_zeros () const;
+  int popcount () const;
+  bool multiple_of (double_int, bool, double_int *) const;
+  double_int set_bit (unsigned) const;
+  double_int mul_with_sign (double_int, bool unsigned_p, bool *overflow) const;
+  double_int wide_mul_with_sign (double_int, bool unsigned_p,
+     double_int *higher, bool *overflow) const;
+  double_int add_with_sign (double_int, bool unsigned_p, bool *overflow) const;
+  double_int sub_with_overflow (double_int, bool *overflow) const;
+  double_int neg_with_overflow (bool *overflow) const;
+  double_int operator * (double_int) const;
+  double_int operator + (double_int) const;
+  double_int operator - (double_int) const;
+  double_int operator - () const;
+  double_int operator ~ () const;
+  double_int operator & (double_int) const;
+  double_int operator | (double_int) const;
+  double_int operator ^ (double_int) const;
+  double_int and_not (double_int) const;
+  double_int lshift (long long count, unsigned int prec, bool arith) const;
+  double_int rshift (long long count, unsigned int prec, bool arith) const;
+  double_int alshift (long long count, unsigned int prec) const;
+  double_int arshift (long long count, unsigned int prec) const;
+  double_int llshift (long long count, unsigned int prec) const;
+  double_int lrshift (long long count, unsigned int prec) const;
+  double_int lrotate (long long count, unsigned int prec) const;
+  double_int rrotate (long long count, unsigned int prec) const;
+  double_int div (double_int, bool, unsigned) const;
+  double_int sdiv (double_int, unsigned) const;
+  double_int udiv (double_int, unsigned) const;
+  double_int mod (double_int, bool, unsigned) const;
+  double_int smod (double_int, unsigned) const;
+  double_int umod (double_int, unsigned) const;
+  double_int divmod_with_overflow (double_int, bool, unsigned,
+       double_int *, bool *) const;
+  double_int divmod (double_int, bool, unsigned, double_int *) const;
+  double_int sdivmod (double_int, unsigned, double_int *) const;
+  double_int udivmod (double_int, unsigned, double_int *) const;
+  double_int ext (unsigned prec, bool uns) const;
+  double_int zext (unsigned prec) const;
+  double_int sext (unsigned prec) const;
+  bool is_zero () const;
+  bool is_one () const;
+  bool is_minus_one () const;
+  bool is_negative () const;
+  int cmp (double_int b, bool uns) const;
+  int ucmp (double_int b) const;
+  int scmp (double_int b) const;
+  bool ult (double_int b) const;
+  bool ule (double_int b) const;
+  bool ugt (double_int b) const;
+  bool slt (double_int b) const;
+  bool sle (double_int b) const;
+  bool sgt (double_int b) const;
+  double_int max (double_int b, bool uns);
+  double_int smax (double_int b);
+  double_int umax (double_int b);
+  double_int min (double_int b, bool uns);
+  double_int smin (double_int b);
+  double_int umin (double_int b);
+  bool operator == (double_int cst2) const;
+  bool operator != (double_int cst2) const;
+  unsigned long long low;
+  long long high;
+};
+inline double_int
+double_int::from_shwi (long long cst)
+{
+  double_int r;
+  r.low = (unsigned long long) cst;
+  r.high = cst < 0 ? -1 : 0;
+  return r;
+}
+inline double_int
+double_int::from_uhwi (unsigned long long cst)
+{
+  double_int r;
+  r.low = cst;
+  r.high = 0;
+  return r;
+}
+inline double_int
+double_int::from_pair (long long high, unsigned long long low)
+{
+  double_int r;
+  r.low = low;
+  r.high = high;
+  return r;
+}
+inline double_int &
+double_int::operator ++ ()
+{
+  *this += (double_int::from_shwi (1));
+  return *this;
+}
+inline double_int &
+double_int::operator -- ()
+{
+  *this -= (double_int::from_shwi (1));
+  return *this;
+}
+inline double_int &
+double_int::operator *= (double_int b)
+{
+  *this = *this * b;
+  return *this;
+}
+inline double_int &
+double_int::operator += (double_int b)
+{
+  *this = *this + b;
+  return *this;
+}
+inline double_int &
+double_int::operator -= (double_int b)
+{
+  *this = *this - b;
+  return *this;
+}
+inline double_int &
+double_int::operator &= (double_int b)
+{
+  *this = *this & b;
+  return *this;
+}
+inline double_int &
+double_int::operator ^= (double_int b)
+{
+  *this = *this ^ b;
+  return *this;
+}
+inline double_int &
+double_int::operator |= (double_int b)
+{
+  *this = *this | b;
+  return *this;
+}
+inline long long
+double_int::to_shwi () const
+{
+  return (long long) low;
+}
+inline unsigned long long
+double_int::to_uhwi () const
+{
+  return low;
+}
+inline bool
+double_int::fits_uhwi () const
+{
+  return high == 0;
+}
+inline double_int
+double_int::operator ~ () const
+{
+  double_int result;
+  result.low = ~low;
+  result.high = ~high;
+  return result;
+}
+inline double_int
+double_int::operator | (double_int b) const
+{
+  double_int result;
+  result.low = low | b.low;
+  result.high = high | b.high;
+  return result;
+}
+inline double_int
+double_int::operator & (double_int b) const
+{
+  double_int result;
+  result.low = low & b.low;
+  result.high = high & b.high;
+  return result;
+}
+inline double_int
+double_int::and_not (double_int b) const
+{
+  double_int result;
+  result.low = low & ~b.low;
+  result.high = high & ~b.high;
+  return result;
+}
+inline double_int
+double_int::operator ^ (double_int b) const
+{
+  double_int result;
+  result.low = low ^ b.low;
+  result.high = high ^ b.high;
+  return result;
+}
+void dump_double_int (FILE *, double_int, bool);
+inline bool
+double_int::is_zero () const
+{
+  return low == 0 && high == 0;
+}
+inline bool
+double_int::is_one () const
+{
+  return low == 1 && high == 0;
+}
+inline bool
+double_int::is_minus_one () const
+{
+  return low == (~((unsigned long long) 0)) && high == -1;
+}
+inline bool
+double_int::is_negative () const
+{
+  return high < 0;
+}
+inline bool
+double_int::operator == (double_int cst2) const
+{
+  return low == cst2.low && high == cst2.high;
+}
+inline bool
+double_int::operator != (double_int cst2) const
+{
+  return low != cst2.low || high != cst2.high;
+}
+inline int
+double_int::popcount () const
+{
+  return popcount_hwi (high) + popcount_hwi (low);
+}
+void mpz_set_double_int (mpz_t, double_int, bool);
+double_int mpz_get_double_int (const_tree, mpz_t, bool);
+struct fixed_value
+{
+  double_int data;
+  enum machine_mode mode;
+};
+extern struct fixed_value fconst0[18];
+extern struct fixed_value fconst1[8];
+extern rtx const_fixed_from_fixed_value (struct fixed_value, enum machine_mode);
+extern struct fixed_value fixed_from_double_int (double_int,
+           enum machine_mode);
+static inline rtx
+const_fixed_from_double_int (double_int payload,
+                             enum machine_mode mode)
+{
+  return
+    const_fixed_from_fixed_value (fixed_from_double_int (payload, mode),
+                                  mode);
+}
+extern void fixed_from_string (struct fixed_value *, const char *,
+          enum machine_mode);
+extern tree build_fixed (tree, struct fixed_value);
+extern bool fixed_convert (struct fixed_value *, enum machine_mode,
+      const struct fixed_value *, bool);
+extern bool fixed_convert_from_int (struct fixed_value *, enum machine_mode,
+        double_int, bool, bool);
+extern bool fixed_convert_from_real (struct fixed_value *, enum machine_mode,
+         const struct real_value *, bool);
+extern void real_convert_from_fixed (struct real_value *, enum machine_mode,
+         const struct fixed_value *);
+extern bool fixed_identical (const struct fixed_value *, const struct fixed_value *);
+extern unsigned int fixed_hash (const struct fixed_value *);
+extern void fixed_to_decimal (char *str, const struct fixed_value *, size_t);
+extern bool fixed_arithmetic (struct fixed_value *, int, const struct fixed_value *,
+         const struct fixed_value *, bool);
+extern bool fixed_compare (int, const struct fixed_value *,
+      const struct fixed_value *);
+extern bool fixed_isneg (const struct fixed_value *);
+typedef int alias_set_type;
+extern alias_set_type new_alias_set (void);
+extern alias_set_type get_alias_set (tree);
+extern alias_set_type get_deref_alias_set (tree);
+extern alias_set_type get_varargs_alias_set (void);
+extern alias_set_type get_frame_alias_set (void);
+extern bool component_uses_parent_alias_set (const_tree);
+extern bool alias_set_subset_of (alias_set_type, alias_set_type);
+extern void record_alias_subset (alias_set_type, alias_set_type);
+extern void record_component_aliases (tree);
+extern int alias_sets_conflict_p (alias_set_type, alias_set_type);
+extern int alias_sets_must_conflict_p (alias_set_type, alias_set_type);
+extern int objects_must_conflict_p (tree, tree);
+extern int nonoverlapping_memrefs_p (const_rtx, const_rtx, bool);
+extern const char *const debug_type_names[];
+extern void strip_off_ending (char *, int);
+extern int base_of_path (const char *path, const char **base_out);
+extern bool fast_math_flags_set_p (const struct gcc_options *);
+extern bool fast_math_flags_struct_set_p (struct cl_optimization *);
+extern bool final_insns_dump_p;
+struct target_flag_state {
+  int x_align_loops_log;
+  int x_align_loops_max_skip;
+  int x_align_jumps_log;
+  int x_align_jumps_max_skip;
+  int x_align_labels_log;
+  int x_align_labels_max_skip;
+  int x_align_functions_log;
+  enum excess_precision x_flag_excess_precision;
+};
+extern struct target_flag_state default_target_flag_state;
+enum rtx_code {
+UNKNOWN ,
+VALUE ,
+DEBUG_EXPR ,
+EXPR_LIST ,
+INSN_LIST ,
+SEQUENCE ,
+ADDRESS ,
+DEBUG_INSN ,
+INSN ,
+JUMP_INSN ,
+CALL_INSN ,
+BARRIER ,
+CODE_LABEL ,
+NOTE ,
+COND_EXEC ,
+PARALLEL ,
+ASM_INPUT ,
+ASM_OPERANDS ,
+UNSPEC ,
+UNSPEC_VOLATILE ,
+ADDR_VEC ,
+ADDR_DIFF_VEC ,
+PREFETCH ,
+SET ,
+USE ,
+CLOBBER ,
+CALL ,
+RETURN ,
+SIMPLE_RETURN ,
+EH_RETURN ,
+TRAP_IF ,
+CONST_INT ,
+CONST_FIXED ,
+CONST_DOUBLE ,
+CONST_VECTOR ,
+CONST_STRING ,
+CONST ,
+PC ,
+REG ,
+SCRATCH ,
+SUBREG ,
+STRICT_LOW_PART ,
+CONCAT ,
+CONCATN ,
+MEM ,
+LABEL_REF ,
+SYMBOL_REF ,
+CC0 ,
+IF_THEN_ELSE ,
+COMPARE ,
+PLUS ,
+MINUS ,
+NEG ,
+MULT ,
+SS_MULT ,
+US_MULT ,
+DIV ,
+SS_DIV ,
+US_DIV ,
+MOD ,
+UDIV ,
+UMOD ,
+AND ,
+IOR ,
+XOR ,
+NOT ,
+ASHIFT ,
+ROTATE ,
+ASHIFTRT ,
+LSHIFTRT ,
+ROTATERT ,
+SMIN ,
+SMAX ,
+UMIN ,
+UMAX ,
+PRE_DEC ,
+PRE_INC ,
+POST_DEC ,
+POST_INC ,
+PRE_MODIFY ,
+POST_MODIFY ,
+NE ,
+EQ ,
+GE ,
+GT ,
+LE ,
+LT ,
+GEU ,
+GTU ,
+LEU ,
+LTU ,
+UNORDERED ,
+ORDERED ,
+UNEQ ,
+UNGE ,
+UNGT ,
+UNLE ,
+UNLT ,
+LTGT ,
+SIGN_EXTEND ,
+ZERO_EXTEND ,
+TRUNCATE ,
+FLOAT_EXTEND ,
+FLOAT_TRUNCATE ,
+FLOAT ,
+FIX ,
+UNSIGNED_FLOAT ,
+UNSIGNED_FIX ,
+FRACT_CONVERT ,
+UNSIGNED_FRACT_CONVERT ,
+SAT_FRACT ,
+UNSIGNED_SAT_FRACT ,
+ABS ,
+SQRT ,
+BSWAP ,
+FFS ,
+CLRSB ,
+CLZ ,
+CTZ ,
+POPCOUNT ,
+PARITY ,
+SIGN_EXTRACT ,
+ZERO_EXTRACT ,
+HIGH ,
+LO_SUM ,
+VEC_MERGE ,
+VEC_SELECT ,
+VEC_CONCAT ,
+VEC_DUPLICATE ,
+SS_PLUS ,
+US_PLUS ,
+SS_MINUS ,
+SS_NEG ,
+US_NEG ,
+SS_ABS ,
+SS_ASHIFT ,
+US_ASHIFT ,
+US_MINUS ,
+SS_TRUNCATE ,
+US_TRUNCATE ,
+FMA ,
+VAR_LOCATION ,
+DEBUG_IMPLICIT_PTR ,
+ENTRY_VALUE ,
+DEBUG_PARAMETER_REF ,
+  LAST_AND_UNUSED_RTX_CODE};
+enum rtx_class {
+  RTX_COMPARE,
+  RTX_COMM_COMPARE,
+  RTX_BIN_ARITH,
+  RTX_COMM_ARITH,
+  RTX_UNARY,
+  RTX_EXTRA,
+  RTX_MATCH,
+  RTX_INSN,
+  RTX_OBJ,
+  RTX_CONST_OBJ,
+  RTX_TERNARY,
+  RTX_BITFIELD_OPS,
+  RTX_AUTOINC
+};
+extern const unsigned char rtx_length[((int) LAST_AND_UNUSED_RTX_CODE)];
+extern const char * const rtx_name[((int) LAST_AND_UNUSED_RTX_CODE)];
+extern const char * const rtx_format[((int) LAST_AND_UNUSED_RTX_CODE)];
+extern const enum rtx_class rtx_class[((int) LAST_AND_UNUSED_RTX_CODE)];
+extern const unsigned char rtx_code_size[((int) LAST_AND_UNUSED_RTX_CODE)];
+extern const unsigned char rtx_next[((int) LAST_AND_UNUSED_RTX_CODE)];
+typedef struct
+{
+  unsigned min_align: 8;
+  unsigned base_after_vec: 1;
+  unsigned min_after_vec: 1;
+  unsigned max_after_vec: 1;
+  unsigned min_after_base: 1;
+  unsigned max_after_base: 1;
+  unsigned offset_unsigned: 1;
+  unsigned : 2;
+  unsigned scale : 8;
+} addr_diff_vec_flags;
+typedef struct mem_attrs
+{
+  tree expr;
+  long long offset;
+  long long size;
+  alias_set_type alias;
+  unsigned int align;
+  unsigned char addrspace;
+  bool offset_known_p;
+  bool size_known_p;
+} mem_attrs;
+typedef struct reg_attrs {
+  tree decl;
+  long long offset;
+} reg_attrs;
+union rtunion_def
+{
+  int rt_int;
+  unsigned int rt_uint;
+  const char *rt_str;
+  rtx rt_rtx;
+  rtvec rt_rtvec;
+  enum machine_mode rt_type;
+  addr_diff_vec_flags rt_addr_diff_vec_flags;
+  struct cselib_val_struct *rt_cselib;
+  tree rt_tree;
+  basic_block rt_bb;
+  mem_attrs *rt_mem;
+  reg_attrs *rt_reg;
+  struct constant_descriptor_rtx *rt_constant;
+  struct dw_cfi_struct *rt_cfi;
+};
+typedef union rtunion_def rtunion;
+struct block_symbol {
+  rtunion fld[3];
+  struct object_block *block;
+  long long offset;
+};
+struct object_block {
+  section *sect;
+  unsigned int alignment;
+  long long size;
+  vec<rtx, va_gc> *objects;
+  vec<rtx, va_gc> *anchors;
+};
+struct rtx_def {
+  enum rtx_code code: 16;
+  enum machine_mode mode : 8;
+  unsigned int jump : 1;
+  unsigned int call : 1;
+  unsigned int unchanging : 1;
+  unsigned int volatil : 1;
+  unsigned int in_struct : 1;
+  unsigned int used : 1;
+  unsigned frame_related : 1;
+  unsigned return_val : 1;
+  union u {
+    rtunion fld[1];
+    long long hwint[1];
+    struct block_symbol block_sym;
+    struct real_value rv;
+    struct fixed_value fv;
+  } u;
+};
+struct rtvec_def {
+  int num_elem;
+  rtx elem[1];
+};
+enum reg_note
+{
+REG_DEP_TRUE,
+REG_DEAD,
+REG_INC,
+REG_EQUIV,
+REG_EQUAL,
+REG_NONNEG,
+REG_UNUSED,
+REG_CC_SETTER,
+REG_CC_USER,
+REG_LABEL_TARGET,
+REG_LABEL_OPERAND,
+REG_DEP_OUTPUT,
+REG_DEP_ANTI,
+REG_DEP_CONTROL,
+REG_BR_PROB,
+REG_NOALIAS,
+REG_BR_PRED,
+REG_FRAME_RELATED_EXPR,
+REG_CFA_DEF_CFA,
+REG_CFA_ADJUST_CFA,
+REG_CFA_OFFSET,
+REG_CFA_REGISTER,
+REG_CFA_EXPRESSION,
+REG_CFA_RESTORE,
+REG_CFA_SET_VDRAP,
+REG_CFA_WINDOW_SAVE,
+REG_CFA_FLUSH_QUEUE,
+REG_EH_CONTEXT,
+REG_EH_REGION,
+REG_SAVE_NOTE,
+REG_NORETURN,
+REG_NON_LOCAL_GOTO,
+REG_CROSSING_JUMP,
+REG_SETJMP,
+REG_TM,
+REG_ARGS_SIZE,
+REG_RETURNED,
+  REG_NOTE_MAX
+};
+extern const char * const reg_note_name[];
+enum insn_note
+{
+NOTE_INSN_DELETED,
+NOTE_INSN_DELETED_LABEL,
+NOTE_INSN_DELETED_DEBUG_LABEL,
+NOTE_INSN_BLOCK_BEG,
+NOTE_INSN_BLOCK_END,
+NOTE_INSN_FUNCTION_BEG,
+NOTE_INSN_PROLOGUE_END,
+NOTE_INSN_EPILOGUE_BEG,
+NOTE_INSN_EH_REGION_BEG,
+NOTE_INSN_EH_REGION_END,
+NOTE_INSN_VAR_LOCATION,
+NOTE_INSN_CALL_ARG_LOCATION,
+NOTE_INSN_BASIC_BLOCK,
+NOTE_INSN_SWITCH_TEXT_SECTIONS,
+NOTE_INSN_CFI,
+NOTE_INSN_CFI_LABEL,
+  NOTE_INSN_MAX
+};
+extern const char * const note_insn_name[NOTE_INSN_MAX];
+enum label_kind
+{
+  LABEL_NORMAL = 0,
+  LABEL_STATIC_ENTRY,
+  LABEL_GLOBAL_ENTRY,
+  LABEL_WEAK_ENTRY
+};
+static inline unsigned int
+rhs_regno (const_rtx x)
+{
+  return (((x)->u.fld[0]).rt_uint);
+}
+struct full_rtx_costs
+{
+  int speed;
+  int size;
+};
+static inline void
+init_costs_to_max (struct full_rtx_costs *c)
+{
+  c->speed = 2147483647;
+  c->size = 2147483647;
+}
+static inline void
+init_costs_to_zero (struct full_rtx_costs *c)
+{
+  c->speed = 0;
+  c->size = 0;
+}
+static inline bool
+costs_lt_p (struct full_rtx_costs *a, struct full_rtx_costs *b,
+     bool speed)
+{
+  if (speed)
+    return (a->speed < b->speed
+     || (a->speed == b->speed && a->size < b->size));
+  else
+    return (a->size < b->size
+     || (a->size == b->size && a->speed < b->speed));
+}
+static inline void
+costs_add_n_insns (struct full_rtx_costs *c, int n)
+{
+  c->speed += ((n) * 4);
+  c->size += ((n) * 4);
+}
+struct address_info {
+  enum machine_mode mode;
+  addr_space_t as;
+  rtx *outer;
+  rtx *inner;
+  rtx *segment;
+  rtx *base;
+  rtx *index;
+  rtx *disp;
+  rtx *segment_term;
+  rtx *base_term;
+  rtx *index_term;
+  rtx *disp_term;
+  rtx *base_term2;
+  enum rtx_code addr_outer_code;
+  enum rtx_code base_outer_code;
+  bool autoinc_p;
+};
+extern void init_rtlanal (void);
+extern int rtx_cost (rtx, enum rtx_code, int, bool);
+extern int address_cost (rtx, enum machine_mode, addr_space_t, bool);
+extern void get_full_rtx_cost (rtx, enum rtx_code, int,
+          struct full_rtx_costs *);
+extern unsigned int subreg_lsb (const_rtx);
+extern unsigned int subreg_lsb_1 (enum machine_mode, enum machine_mode,
+      unsigned int);
+extern unsigned int subreg_regno_offset (unsigned int, enum machine_mode,
+      unsigned int, enum machine_mode);
+extern bool subreg_offset_representable_p (unsigned int, enum machine_mode,
+        unsigned int, enum machine_mode);
+extern unsigned int subreg_regno (const_rtx);
+extern int simplify_subreg_regno (unsigned int, enum machine_mode,
+      unsigned int, enum machine_mode);
+extern unsigned int subreg_nregs (const_rtx);
+extern unsigned int subreg_nregs_with_regno (unsigned int, const_rtx);
+extern unsigned long long nonzero_bits (const_rtx, enum machine_mode);
+extern unsigned int num_sign_bit_copies (const_rtx, enum machine_mode);
+extern bool constant_pool_constant_p (rtx);
+extern bool truncated_to_mode (enum machine_mode, const_rtx);
+extern int low_bitmask_len (enum machine_mode, unsigned long long);
+extern void split_double (rtx, rtx *, rtx *);
+extern rtx *strip_address_mutations (rtx *, enum rtx_code * = 0);
+extern void decompose_address (struct address_info *, rtx *,
+          enum machine_mode, addr_space_t, enum rtx_code);
+extern void decompose_lea_address (struct address_info *, rtx *);
+extern void decompose_mem_address (struct address_info *, rtx);
+extern void update_address (struct address_info *);
+extern long long get_index_scale (const struct address_info *);
+extern enum rtx_code get_index_code (const struct address_info *);
+static inline int
+set_rtx_cost (rtx x, bool speed_p)
+{
+  return rtx_cost (x, INSN, 4, speed_p);
+}
+static inline void
+get_full_set_rtx_cost (rtx x, struct full_rtx_costs *c)
+{
+  get_full_rtx_cost (x, INSN, 4, c);
+}
+static inline int
+set_src_cost (rtx x, bool speed_p)
+{
+  return rtx_cost (x, SET, 1, speed_p);
+}
+static inline void
+get_full_set_src_cost (rtx x, struct full_rtx_costs *c)
+{
+  get_full_rtx_cost (x, SET, 1, c);
+}
+extern int generating_concat_p;
+extern int currently_expanding_to_rtl;
+extern long long trunc_int_for_mode (long long, enum machine_mode);
+extern rtx plus_constant (enum machine_mode, rtx, long long);
+extern rtx rtx_alloc_stat (enum rtx_code );
+extern rtvec rtvec_alloc (int);
+extern rtvec shallow_copy_rtvec (rtvec);
+extern bool shared_const_p (const_rtx);
+extern rtx copy_rtx (rtx);
+extern void dump_rtx_statistics (void);
+extern rtx copy_rtx_if_shared (rtx);
+extern unsigned int rtx_size (const_rtx);
+extern rtx shallow_copy_rtx_stat (const_rtx );
+extern int rtx_equal_p (const_rtx, const_rtx);
+extern hashval_t iterative_hash_rtx (const_rtx, hashval_t);
+extern rtvec gen_rtvec_v (int, rtx *);
+extern rtx gen_reg_rtx (enum machine_mode);
+extern rtx gen_rtx_REG_offset (rtx, enum machine_mode, unsigned int, int);
+extern rtx gen_reg_rtx_offset (rtx, enum machine_mode, int);
+extern rtx gen_reg_rtx_and_attrs (rtx);
+extern rtx gen_label_rtx (void);
+extern rtx gen_lowpart_common (enum machine_mode, rtx);
+extern rtx gen_lowpart_if_possible (enum machine_mode, rtx);
+extern rtx gen_highpart (enum machine_mode, rtx);
+extern rtx gen_highpart_mode (enum machine_mode, enum machine_mode, rtx);
+extern rtx operand_subword (rtx, unsigned int, int, enum machine_mode);
+extern rtx operand_subword_force (rtx, unsigned int, enum machine_mode);
+extern bool paradoxical_subreg_p (const_rtx);
+extern int subreg_lowpart_p (const_rtx);
+extern unsigned int subreg_lowpart_offset (enum machine_mode,
+        enum machine_mode);
+extern unsigned int subreg_highpart_offset (enum machine_mode,
+         enum machine_mode);
+extern int byte_lowpart_offset (enum machine_mode, enum machine_mode);
+extern rtx make_safe_from (rtx, rtx);
+extern rtx convert_memory_address_addr_space (enum machine_mode, rtx,
+           addr_space_t);
+extern const char *get_insn_name (int);
+extern rtx get_last_insn_anywhere (void);
+extern rtx get_first_nonnote_insn (void);
+extern rtx get_last_nonnote_insn (void);
+extern void start_sequence (void);
+extern void push_to_sequence (rtx);
+extern void push_to_sequence2 (rtx, rtx);
+extern void end_sequence (void);
+extern double_int rtx_to_double_int (const_rtx);
+extern rtx immed_double_int_const (double_int, enum machine_mode);
+extern rtx immed_double_const (long long, long long,
+          enum machine_mode);
+extern rtx lowpart_subreg (enum machine_mode, rtx, enum machine_mode);
+extern rtx force_const_mem (enum machine_mode, rtx);
+struct function;
+extern rtx get_pool_constant (rtx);
+extern rtx get_pool_constant_mark (rtx, bool *);
+extern enum machine_mode get_pool_mode (const_rtx);
+extern rtx simplify_subtraction (rtx);
+extern void decide_function_section (tree);
+extern rtx assign_stack_local (enum machine_mode, long long, int);
+extern rtx assign_stack_local_1 (enum machine_mode, long long, int, int);
+extern rtx assign_stack_temp (enum machine_mode, long long);
+extern rtx assign_stack_temp_for_type (enum machine_mode, long long, tree);
+extern rtx assign_temp (tree, int, int);
+extern rtx emit_insn_before (rtx, rtx);
+extern rtx emit_insn_before_noloc (rtx, rtx, basic_block);
+extern rtx emit_insn_before_setloc (rtx, rtx, int);
+extern rtx emit_jump_insn_before (rtx, rtx);
+extern rtx emit_jump_insn_before_noloc (rtx, rtx);
+extern rtx emit_jump_insn_before_setloc (rtx, rtx, int);
+extern rtx emit_call_insn_before (rtx, rtx);
+extern rtx emit_call_insn_before_noloc (rtx, rtx);
+extern rtx emit_call_insn_before_setloc (rtx, rtx, int);
+extern rtx emit_debug_insn_before (rtx, rtx);
+extern rtx emit_debug_insn_before_noloc (rtx, rtx);
+extern rtx emit_debug_insn_before_setloc (rtx, rtx, int);
+extern rtx emit_barrier_before (rtx);
+extern rtx emit_label_before (rtx, rtx);
+extern rtx emit_note_before (enum insn_note, rtx);
+extern rtx emit_insn_after (rtx, rtx);
+extern rtx emit_insn_after_noloc (rtx, rtx, basic_block);
+extern rtx emit_insn_after_setloc (rtx, rtx, int);
+extern rtx emit_jump_insn_after (rtx, rtx);
+extern rtx emit_jump_insn_after_noloc (rtx, rtx);
+extern rtx emit_jump_insn_after_setloc (rtx, rtx, int);
+extern rtx emit_call_insn_after (rtx, rtx);
+extern rtx emit_call_insn_after_noloc (rtx, rtx);
+extern rtx emit_call_insn_after_setloc (rtx, rtx, int);
+extern rtx emit_debug_insn_after (rtx, rtx);
+extern rtx emit_debug_insn_after_noloc (rtx, rtx);
+extern rtx emit_debug_insn_after_setloc (rtx, rtx, int);
+extern rtx emit_barrier_after (rtx);
+extern rtx emit_label_after (rtx, rtx);
+extern rtx emit_note_after (enum insn_note, rtx);
+extern rtx emit_insn (rtx);
+extern rtx emit_debug_insn (rtx);
+extern rtx emit_jump_insn (rtx);
+extern rtx emit_call_insn (rtx);
+extern rtx emit_label (rtx);
+extern rtx emit_barrier (void);
+extern rtx emit_note (enum insn_note);
+extern rtx emit_note_copy (rtx);
+extern rtx gen_clobber (rtx);
+extern rtx emit_clobber (rtx);
+extern rtx gen_use (rtx);
+extern rtx emit_use (rtx);
+extern rtx make_insn_raw (rtx);
+extern void add_function_usage_to (rtx, rtx);
+extern rtx last_call_insn (void);
+extern rtx previous_insn (rtx);
+extern rtx next_insn (rtx);
+extern rtx prev_nonnote_insn (rtx);
+extern rtx prev_nonnote_insn_bb (rtx);
+extern rtx next_nonnote_insn (rtx);
+extern rtx next_nonnote_insn_bb (rtx);
+extern rtx prev_nondebug_insn (rtx);
+extern rtx next_nondebug_insn (rtx);
+extern rtx prev_nonnote_nondebug_insn (rtx);
+extern rtx next_nonnote_nondebug_insn (rtx);
+extern rtx prev_real_insn (rtx);
+extern rtx next_real_insn (rtx);
+extern rtx prev_active_insn (rtx);
+extern rtx next_active_insn (rtx);
+extern int active_insn_p (const_rtx);
+extern rtx next_label (rtx);
+extern rtx skip_consecutive_labels (rtx);
+extern rtx next_cc0_user (rtx);
+extern rtx prev_cc0_setter (rtx);
+extern int insn_line (const_rtx);
+extern const char * insn_file (const_rtx);
+extern tree insn_scope (const_rtx);
+extern location_t prologue_location, epilogue_location;
+extern enum rtx_code reverse_condition (enum rtx_code);
+extern enum rtx_code reverse_condition_maybe_unordered (enum rtx_code);
+extern enum rtx_code swap_condition (enum rtx_code);
+extern enum rtx_code unsigned_condition (enum rtx_code);
+extern enum rtx_code signed_condition (enum rtx_code);
+extern void mark_jump_label (rtx, rtx, int);
+extern unsigned int cleanup_barriers (void);
+extern rtx delete_related_insns (rtx);
+extern rtx *find_constant_term_loc (rtx *);
+extern rtx try_split (rtx, rtx, int);
+extern int split_branch_probability;
+extern rtx split_insns (rtx, rtx);
+extern rtx simplify_const_unary_operation (enum rtx_code, enum machine_mode,
+        rtx, enum machine_mode);
+extern rtx simplify_unary_operation (enum rtx_code, enum machine_mode, rtx,
+         enum machine_mode);
+extern rtx simplify_const_binary_operation (enum rtx_code, enum machine_mode,
+         rtx, rtx);
+extern rtx simplify_binary_operation (enum rtx_code, enum machine_mode, rtx,
+          rtx);
+extern rtx simplify_ternary_operation (enum rtx_code, enum machine_mode,
+           enum machine_mode, rtx, rtx, rtx);
+extern rtx simplify_const_relational_operation (enum rtx_code,
+      enum machine_mode, rtx, rtx);
+extern rtx simplify_relational_operation (enum rtx_code, enum machine_mode,
+       enum machine_mode, rtx, rtx);
+extern rtx simplify_gen_binary (enum rtx_code, enum machine_mode, rtx, rtx);
+extern rtx simplify_gen_unary (enum rtx_code, enum machine_mode, rtx,
+          enum machine_mode);
+extern rtx simplify_gen_ternary (enum rtx_code, enum machine_mode,
+     enum machine_mode, rtx, rtx, rtx);
+extern rtx simplify_gen_relational (enum rtx_code, enum machine_mode,
+        enum machine_mode, rtx, rtx);
+extern rtx simplify_subreg (enum machine_mode, rtx, enum machine_mode,
+       unsigned int);
+extern rtx simplify_gen_subreg (enum machine_mode, rtx, enum machine_mode,
+    unsigned int);
+extern rtx simplify_replace_fn_rtx (rtx, const_rtx,
+        rtx (*fn) (rtx, const_rtx, void *), void *);
+extern rtx simplify_replace_rtx (rtx, const_rtx, rtx);
+extern rtx simplify_rtx (const_rtx);
+extern rtx avoid_constant_pool_reference (rtx);
+extern rtx delegitimize_mem_from_attrs (rtx);
+extern bool mode_signbit_p (enum machine_mode, const_rtx);
+extern bool val_signbit_p (enum machine_mode, unsigned long long);
+extern bool val_signbit_known_set_p (enum machine_mode,
+         unsigned long long);
+extern bool val_signbit_known_clear_p (enum machine_mode,
+           unsigned long long);
+extern enum machine_mode choose_hard_reg_mode (unsigned int, unsigned int,
+            bool);
+extern rtx set_unique_reg_note (rtx, enum reg_note, rtx);
+extern rtx set_dst_reg_note (rtx, enum reg_note, rtx, rtx);
+extern void set_insn_deleted (rtx);
+typedef struct replace_label_data
+{
+  rtx r1;
+  rtx r2;
+  bool update_label_nuses;
+} replace_label_data;
+extern enum machine_mode get_address_mode (rtx mem);
+extern int rtx_addr_can_trap_p (const_rtx);
+extern bool nonzero_address_p (const_rtx);
+extern int rtx_unstable_p (const_rtx);
+extern bool rtx_varies_p (const_rtx, bool);
+extern bool rtx_addr_varies_p (const_rtx, bool);
+extern rtx get_call_rtx_from (rtx);
+extern long long get_integer_term (const_rtx);
+extern rtx get_related_value (const_rtx);
+extern bool offset_within_block_p (const_rtx, long long);
+extern void split_const (rtx, rtx *, rtx *);
+extern bool unsigned_reg_p (rtx);
+extern int reg_mentioned_p (const_rtx, const_rtx);
+extern int count_occurrences (const_rtx, const_rtx, int);
+extern int reg_referenced_p (const_rtx, const_rtx);
+extern int reg_used_between_p (const_rtx, const_rtx, const_rtx);
+extern int reg_set_between_p (const_rtx, const_rtx, const_rtx);
+extern int commutative_operand_precedence (rtx);
+extern bool swap_commutative_operands_p (rtx, rtx);
+extern int modified_between_p (const_rtx, const_rtx, const_rtx);
+extern int no_labels_between_p (const_rtx, const_rtx);
+extern int modified_in_p (const_rtx, const_rtx);
+extern int reg_set_p (const_rtx, const_rtx);
+extern rtx single_set_2 (const_rtx, const_rtx);
+extern int multiple_sets (const_rtx);
+extern int set_noop_p (const_rtx);
+extern int noop_move_p (const_rtx);
+extern rtx find_last_value (rtx, rtx *, rtx, int);
+extern int refers_to_regno_p (unsigned int, unsigned int, const_rtx, rtx *);
+extern int reg_overlap_mentioned_p (const_rtx, const_rtx);
+extern const_rtx set_of (const_rtx, const_rtx);
+extern void record_hard_reg_sets (rtx, const_rtx, void *);
+extern void record_hard_reg_uses (rtx *, void *);
+extern void note_stores (const_rtx, void (*) (rtx, const_rtx, void *), void *);
+extern void note_uses (rtx *, void (*) (rtx *, void *), void *);
+extern int dead_or_set_p (const_rtx, const_rtx);
+extern int dead_or_set_regno_p (const_rtx, unsigned int);
+extern rtx find_reg_note (const_rtx, enum reg_note, const_rtx);
+extern rtx find_regno_note (const_rtx, enum reg_note, unsigned int);
+extern rtx find_reg_equal_equiv_note (const_rtx);
+extern rtx find_constant_src (const_rtx);
+extern int find_reg_fusage (const_rtx, enum rtx_code, const_rtx);
+extern int find_regno_fusage (const_rtx, enum rtx_code, unsigned int);
+extern rtx alloc_reg_note (enum reg_note, rtx, rtx);
+extern void add_reg_note (rtx, enum reg_note, rtx);
+extern void remove_note (rtx, const_rtx);
+extern void remove_reg_equal_equiv_notes (rtx);
+extern void remove_reg_equal_equiv_notes_for_regno (unsigned int);
+extern int side_effects_p (const_rtx);
+extern int volatile_refs_p (const_rtx);
+extern int volatile_insn_p (const_rtx);
+extern int may_trap_p_1 (const_rtx, unsigned);
+extern int may_trap_p (const_rtx);
+extern int may_trap_or_fault_p (const_rtx);
+extern bool can_throw_internal (const_rtx);
+extern bool can_throw_external (const_rtx);
+extern bool insn_could_throw_p (const_rtx);
+extern bool insn_nothrow_p (const_rtx);
+extern bool can_nonlocal_goto (const_rtx);
+extern void copy_reg_eh_region_note_forward (rtx, rtx, rtx);
+extern void copy_reg_eh_region_note_backward(rtx, rtx, rtx);
+extern int inequality_comparisons_p (const_rtx);
+extern rtx replace_rtx (rtx, rtx, rtx);
+extern int replace_label (rtx *, void *);
+extern int rtx_referenced_p (rtx, rtx);
+extern bool tablejump_p (const_rtx, rtx *, rtx *);
+extern int computed_jump_p (const_rtx);
+typedef int (*rtx_function) (rtx *, void *);
+extern int for_each_rtx (rtx *, rtx_function, void *);
+typedef int (*for_each_inc_dec_fn) (rtx mem, rtx op, rtx dest, rtx src,
+        rtx srcoff, void *arg);
+extern int for_each_inc_dec (rtx *, for_each_inc_dec_fn, void *arg);
+typedef int (*rtx_equal_p_callback_function) (const_rtx *, const_rtx *,
+                                              rtx *, rtx *);
+extern int rtx_equal_p_cb (const_rtx, const_rtx,
+                           rtx_equal_p_callback_function);
+typedef int (*hash_rtx_callback_function) (const_rtx, enum machine_mode, rtx *,
+                                           enum machine_mode *);
+extern unsigned hash_rtx_cb (const_rtx, enum machine_mode, int *, int *,
+                             bool, hash_rtx_callback_function);
+extern rtx regno_use_in (unsigned int, rtx);
+extern int auto_inc_p (const_rtx);
+extern int in_expr_list_p (const_rtx, const_rtx);
+extern void remove_node_from_expr_list (const_rtx, rtx *);
+extern int loc_mentioned_in_p (rtx *, const_rtx);
+extern rtx find_first_parameter_load (rtx, rtx);
+extern bool keep_with_call_p (const_rtx);
+extern bool label_is_jump_target_p (const_rtx, const_rtx);
+extern int insn_rtx_cost (rtx, bool);
+extern rtx canonicalize_condition (rtx, rtx, int, rtx *, rtx, int, int);
+extern rtx get_condition (rtx, rtx *, int, int);
+struct subreg_info
+{
+  int offset;
+  int nregs;
+  bool representable_p;
+};
+extern void subreg_get_info (unsigned int, enum machine_mode,
+        unsigned int, enum machine_mode,
+        struct subreg_info *);
+extern void free_EXPR_LIST_list (rtx *);
+extern void free_INSN_LIST_list (rtx *);
+extern void free_EXPR_LIST_node (rtx);
+extern void free_INSN_LIST_node (rtx);
+extern rtx alloc_INSN_LIST (rtx, rtx);
+extern rtx copy_INSN_LIST (rtx);
+extern rtx concat_INSN_LIST (rtx, rtx);
+extern rtx alloc_EXPR_LIST (int, rtx, rtx);
+extern void remove_free_INSN_LIST_elem (rtx, rtx *);
+extern rtx remove_list_elem (rtx, rtx *);
+extern rtx remove_free_INSN_LIST_node (rtx *);
+extern rtx remove_free_EXPR_LIST_node (rtx *);
+extern bool resize_reg_info (void);
+extern void free_reg_info (void);
+extern void init_subregs_of_mode (void);
+extern void finish_subregs_of_mode (void);
+extern rtx extract_asm_operands (rtx);
+extern int asm_noperands (const_rtx);
+extern const char *decode_asm_operands (rtx, rtx *, rtx **, const char **,
+     enum machine_mode *, location_t *);
+extern enum reg_class reg_preferred_class (int);
+extern enum reg_class reg_alternate_class (int);
+extern enum reg_class reg_allocno_class (int);
+extern void setup_reg_classes (int, enum reg_class, enum reg_class,
+          enum reg_class);
+extern void split_all_insns (void);
+extern unsigned int split_all_insns_noflow (void);
+extern rtx const_int_rtx[64 * 2 + 1];
+extern rtx const_true_rtx;
+extern rtx const_tiny_rtx[4][(int) MAX_MACHINE_MODE];
+extern rtx pc_rtx;
+extern rtx cc0_rtx;
+extern rtx ret_rtx;
+extern rtx simple_return_rtx;
+enum global_rtl_index
+{
+  GR_STACK_POINTER,
+  GR_FRAME_POINTER,
+  GR_HARD_FRAME_POINTER,
+  GR_ARG_POINTER,
+  GR_VIRTUAL_INCOMING_ARGS,
+  GR_VIRTUAL_STACK_ARGS,
+  GR_VIRTUAL_STACK_DYNAMIC,
+  GR_VIRTUAL_OUTGOING_ARGS,
+  GR_VIRTUAL_CFA,
+  GR_VIRTUAL_PREFERRED_STACK_BOUNDARY,
+  GR_MAX
+};
+struct target_rtl {
+  rtx x_global_rtl[GR_MAX];
+  rtx x_pic_offset_table_rtx;
+  rtx x_return_address_pointer_rtx;
+  rtx x_initial_regno_reg_rtx[154];
+  rtx x_top_of_stack[MAX_MACHINE_MODE];
+  rtx x_static_reg_base_value[154];
+  struct mem_attrs *x_mode_mem_attrs[(int) MAX_MACHINE_MODE];
+};
+extern struct target_rtl default_target_rtl;
+static inline struct mem_attrs *
+get_mem_attrs (const_rtx x)
+{
+  struct mem_attrs *attrs;
+  attrs = (((x)->u.fld[1]).rt_mem);
+  if (!attrs)
+    attrs = ((&default_target_rtl)->x_mode_mem_attrs)[(int) ((enum machine_mode) (x)->mode)];
+  return attrs;
+}
+static inline rtx
+gen_rtx_fmt_0_stat (enum rtx_code code, enum machine_mode mode )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_rtx) = (rtx) 0;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_ee_stat (enum rtx_code code, enum machine_mode mode,
+ rtx arg0,
+ rtx arg1 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_rtx) = arg0;
+  (((rt)->u.fld[1]).rt_rtx) = arg1;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_ue_stat (enum rtx_code code, enum machine_mode mode,
+ rtx arg0,
+ rtx arg1 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_rtx) = arg0;
+  (((rt)->u.fld[1]).rt_rtx) = arg1;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_E_stat (enum rtx_code code, enum machine_mode mode,
+ rtvec arg0 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_rtvec) = arg0;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_i_stat (enum rtx_code code, enum machine_mode mode,
+ int arg0 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_int) = arg0;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_iuuBeiie_stat (enum rtx_code code, enum machine_mode mode,
+ int arg0,
+ rtx arg1,
+ rtx arg2,
+ basic_block arg3,
+ rtx arg4,
+ int arg5,
+ int arg6,
+ rtx arg7 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_int) = arg0;
+  (((rt)->u.fld[1]).rt_rtx) = arg1;
+  (((rt)->u.fld[2]).rt_rtx) = arg2;
+  (((rt)->u.fld[3]).rt_bb) = arg3;
+  (((rt)->u.fld[4]).rt_rtx) = arg4;
+  (((rt)->u.fld[5]).rt_int) = arg5;
+  (((rt)->u.fld[6]).rt_int) = arg6;
+  (((rt)->u.fld[7]).rt_rtx) = arg7;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_iuuBeiie0_stat (enum rtx_code code, enum machine_mode mode,
+ int arg0,
+ rtx arg1,
+ rtx arg2,
+ basic_block arg3,
+ rtx arg4,
+ int arg5,
+ int arg6,
+ rtx arg7 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_int) = arg0;
+  (((rt)->u.fld[1]).rt_rtx) = arg1;
+  (((rt)->u.fld[2]).rt_rtx) = arg2;
+  (((rt)->u.fld[3]).rt_bb) = arg3;
+  (((rt)->u.fld[4]).rt_rtx) = arg4;
+  (((rt)->u.fld[5]).rt_int) = arg5;
+  (((rt)->u.fld[6]).rt_int) = arg6;
+  (((rt)->u.fld[7]).rt_rtx) = arg7;
+  (((rt)->u.fld[8]).rt_rtx) = (rtx) 0;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_iuuBeiiee_stat (enum rtx_code code, enum machine_mode mode,
+ int arg0,
+ rtx arg1,
+ rtx arg2,
+ basic_block arg3,
+ rtx arg4,
+ int arg5,
+ int arg6,
+ rtx arg7,
+ rtx arg8 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_int) = arg0;
+  (((rt)->u.fld[1]).rt_rtx) = arg1;
+  (((rt)->u.fld[2]).rt_rtx) = arg2;
+  (((rt)->u.fld[3]).rt_bb) = arg3;
+  (((rt)->u.fld[4]).rt_rtx) = arg4;
+  (((rt)->u.fld[5]).rt_int) = arg5;
+  (((rt)->u.fld[6]).rt_int) = arg6;
+  (((rt)->u.fld[7]).rt_rtx) = arg7;
+  (((rt)->u.fld[8]).rt_rtx) = arg8;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_iuu00000_stat (enum rtx_code code, enum machine_mode mode,
+ int arg0,
+ rtx arg1,
+ rtx arg2 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_int) = arg0;
+  (((rt)->u.fld[1]).rt_rtx) = arg1;
+  (((rt)->u.fld[2]).rt_rtx) = arg2;
+  (((rt)->u.fld[3]).rt_rtx) = (rtx) 0;
+  (((rt)->u.fld[4]).rt_rtx) = (rtx) 0;
+  (((rt)->u.fld[5]).rt_rtx) = (rtx) 0;
+  (((rt)->u.fld[6]).rt_rtx) = (rtx) 0;
+  (((rt)->u.fld[7]).rt_rtx) = (rtx) 0;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_iuuB00is_stat (enum rtx_code code, enum machine_mode mode,
+ int arg0,
+ rtx arg1,
+ rtx arg2,
+ basic_block arg3,
+ int arg4,
+ const char *arg5 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_int) = arg0;
+  (((rt)->u.fld[1]).rt_rtx) = arg1;
+  (((rt)->u.fld[2]).rt_rtx) = arg2;
+  (((rt)->u.fld[3]).rt_bb) = arg3;
+  (((rt)->u.fld[4]).rt_rtx) = (rtx) 0;
+  (((rt)->u.fld[5]).rt_rtx) = (rtx) 0;
+  (((rt)->u.fld[6]).rt_int) = arg4;
+  (((rt)->u.fld[7]).rt_str) = arg5;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_si_stat (enum rtx_code code, enum machine_mode mode,
+ const char *arg0,
+ int arg1 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_str) = arg0;
+  (((rt)->u.fld[1]).rt_int) = arg1;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_ssiEEEi_stat (enum rtx_code code, enum machine_mode mode,
+ const char *arg0,
+ const char *arg1,
+ int arg2,
+ rtvec arg3,
+ rtvec arg4,
+ rtvec arg5,
+ int arg6 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_str) = arg0;
+  (((rt)->u.fld[1]).rt_str) = arg1;
+  (((rt)->u.fld[2]).rt_int) = arg2;
+  (((rt)->u.fld[3]).rt_rtvec) = arg3;
+  (((rt)->u.fld[4]).rt_rtvec) = arg4;
+  (((rt)->u.fld[5]).rt_rtvec) = arg5;
+  (((rt)->u.fld[6]).rt_int) = arg6;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_Ei_stat (enum rtx_code code, enum machine_mode mode,
+ rtvec arg0,
+ int arg1 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_rtvec) = arg0;
+  (((rt)->u.fld[1]).rt_int) = arg1;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_eEee0_stat (enum rtx_code code, enum machine_mode mode,
+ rtx arg0,
+ rtvec arg1,
+ rtx arg2,
+ rtx arg3 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_rtx) = arg0;
+  (((rt)->u.fld[1]).rt_rtvec) = arg1;
+  (((rt)->u.fld[2]).rt_rtx) = arg2;
+  (((rt)->u.fld[3]).rt_rtx) = arg3;
+  (((rt)->u.fld[4]).rt_rtx) = (rtx) 0;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_eee_stat (enum rtx_code code, enum machine_mode mode,
+ rtx arg0,
+ rtx arg1,
+ rtx arg2 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_rtx) = arg0;
+  (((rt)->u.fld[1]).rt_rtx) = arg1;
+  (((rt)->u.fld[2]).rt_rtx) = arg2;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_e_stat (enum rtx_code code, enum machine_mode mode,
+ rtx arg0 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_rtx) = arg0;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt__stat (enum rtx_code code, enum machine_mode mode )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_w_stat (enum rtx_code code, enum machine_mode mode,
+ long long arg0 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  ((rt)->u.hwint[0]) = arg0;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_www_stat (enum rtx_code code, enum machine_mode mode,
+ long long arg0,
+ long long arg1,
+ long long arg2 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  ((rt)->u.hwint[0]) = arg0;
+  ((rt)->u.hwint[1]) = arg1;
+  ((rt)->u.hwint[2]) = arg2;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_s_stat (enum rtx_code code, enum machine_mode mode,
+ const char *arg0 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_str) = arg0;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_i00_stat (enum rtx_code code, enum machine_mode mode,
+ int arg0 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_int) = arg0;
+  (((rt)->u.fld[1]).rt_rtx) = (rtx) 0;
+  (((rt)->u.fld[2]).rt_rtx) = (rtx) 0;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_ei_stat (enum rtx_code code, enum machine_mode mode,
+ rtx arg0,
+ int arg1 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_rtx) = arg0;
+  (((rt)->u.fld[1]).rt_int) = arg1;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_e0_stat (enum rtx_code code, enum machine_mode mode,
+ rtx arg0 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_rtx) = arg0;
+  (((rt)->u.fld[1]).rt_rtx) = (rtx) 0;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_u_stat (enum rtx_code code, enum machine_mode mode,
+ rtx arg0 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_rtx) = arg0;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_s00_stat (enum rtx_code code, enum machine_mode mode,
+ const char *arg0 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_str) = arg0;
+  (((rt)->u.fld[1]).rt_rtx) = (rtx) 0;
+  (((rt)->u.fld[2]).rt_rtx) = (rtx) 0;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_tei_stat (enum rtx_code code, enum machine_mode mode,
+ tree arg0,
+ rtx arg1,
+ int arg2 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_tree) = arg0;
+  (((rt)->u.fld[1]).rt_rtx) = arg1;
+  (((rt)->u.fld[2]).rt_int) = arg2;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_t_stat (enum rtx_code code, enum machine_mode mode,
+ tree arg0 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_tree) = arg0;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_iss_stat (enum rtx_code code, enum machine_mode mode,
+ int arg0,
+ const char *arg1,
+ const char *arg2 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_int) = arg0;
+  (((rt)->u.fld[1]).rt_str) = arg1;
+  (((rt)->u.fld[2]).rt_str) = arg2;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_is_stat (enum rtx_code code, enum machine_mode mode,
+ int arg0,
+ const char *arg1 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_int) = arg0;
+  (((rt)->u.fld[1]).rt_str) = arg1;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_isE_stat (enum rtx_code code, enum machine_mode mode,
+ int arg0,
+ const char *arg1,
+ rtvec arg2 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_int) = arg0;
+  (((rt)->u.fld[1]).rt_str) = arg1;
+  (((rt)->u.fld[2]).rt_rtvec) = arg2;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_iE_stat (enum rtx_code code, enum machine_mode mode,
+ int arg0,
+ rtvec arg1 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_int) = arg0;
+  (((rt)->u.fld[1]).rt_rtvec) = arg1;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_ss_stat (enum rtx_code code, enum machine_mode mode,
+ const char *arg0,
+ const char *arg1 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_str) = arg0;
+  (((rt)->u.fld[1]).rt_str) = arg1;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_eE_stat (enum rtx_code code, enum machine_mode mode,
+ rtx arg0,
+ rtvec arg1 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_rtx) = arg0;
+  (((rt)->u.fld[1]).rt_rtvec) = arg1;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_Ess_stat (enum rtx_code code, enum machine_mode mode,
+ rtvec arg0,
+ const char *arg1,
+ const char *arg2 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_rtvec) = arg0;
+  (((rt)->u.fld[1]).rt_str) = arg1;
+  (((rt)->u.fld[2]).rt_str) = arg2;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_ses_stat (enum rtx_code code, enum machine_mode mode,
+ const char *arg0,
+ rtx arg1,
+ const char *arg2 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_str) = arg0;
+  (((rt)->u.fld[1]).rt_rtx) = arg1;
+  (((rt)->u.fld[2]).rt_str) = arg2;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_sss_stat (enum rtx_code code, enum machine_mode mode,
+ const char *arg0,
+ const char *arg1,
+ const char *arg2 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_str) = arg0;
+  (((rt)->u.fld[1]).rt_str) = arg1;
+  (((rt)->u.fld[2]).rt_str) = arg2;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_sse_stat (enum rtx_code code, enum machine_mode mode,
+ const char *arg0,
+ const char *arg1,
+ rtx arg2 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_str) = arg0;
+  (((rt)->u.fld[1]).rt_str) = arg1;
+  (((rt)->u.fld[2]).rt_rtx) = arg2;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_sies_stat (enum rtx_code code, enum machine_mode mode,
+ const char *arg0,
+ int arg1,
+ rtx arg2,
+ const char *arg3 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_str) = arg0;
+  (((rt)->u.fld[1]).rt_int) = arg1;
+  (((rt)->u.fld[2]).rt_rtx) = arg2;
+  (((rt)->u.fld[3]).rt_str) = arg3;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_sE_stat (enum rtx_code code, enum machine_mode mode,
+ const char *arg0,
+ rtvec arg1 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_str) = arg0;
+  (((rt)->u.fld[1]).rt_rtvec) = arg1;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_ii_stat (enum rtx_code code, enum machine_mode mode,
+ int arg0,
+ int arg1 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_int) = arg0;
+  (((rt)->u.fld[1]).rt_int) = arg1;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_Ee_stat (enum rtx_code code, enum machine_mode mode,
+ rtvec arg0,
+ rtx arg1 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_rtvec) = arg0;
+  (((rt)->u.fld[1]).rt_rtx) = arg1;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_sEsE_stat (enum rtx_code code, enum machine_mode mode,
+ const char *arg0,
+ rtvec arg1,
+ const char *arg2,
+ rtvec arg3 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_str) = arg0;
+  (((rt)->u.fld[1]).rt_rtvec) = arg1;
+  (((rt)->u.fld[2]).rt_str) = arg2;
+  (((rt)->u.fld[3]).rt_rtvec) = arg3;
+  return rt;
+}
+static inline rtx
+gen_rtx_fmt_ssss_stat (enum rtx_code code, enum machine_mode mode,
+ const char *arg0,
+ const char *arg1,
+ const char *arg2,
+ const char *arg3 )
+{
+  rtx rt;
+  rt = rtx_alloc_stat (code );
+  ((rt)->mode = (mode));
+  (((rt)->u.fld[0]).rt_str) = arg0;
+  (((rt)->u.fld[1]).rt_str) = arg1;
+  (((rt)->u.fld[2]).rt_str) = arg2;
+  (((rt)->u.fld[3]).rt_str) = arg3;
+  return rt;
+}
+extern rtx gen_rtx_CONST_INT (enum machine_mode, long long);
+extern rtx gen_rtx_CONST_VECTOR (enum machine_mode, rtvec);
+extern rtx gen_raw_REG (enum machine_mode, int);
+extern rtx gen_rtx_REG (enum machine_mode, unsigned);
+extern rtx gen_rtx_SUBREG (enum machine_mode, rtx, int);
+extern rtx gen_rtx_MEM (enum machine_mode, rtx);
+extern rtx output_constant_def (tree, int);
+extern rtx lookup_constant_def (tree);
+extern int reload_completed;
+extern int epilogue_completed;
+extern int reload_in_progress;
+extern int lra_in_progress;
+extern int cse_not_expected;
+extern int rtx_to_tree_code (enum rtx_code);
+extern int delete_trivially_dead_insns (rtx, int);
+extern int exp_equiv_p (const_rtx, const_rtx, int, bool);
+extern unsigned hash_rtx (const_rtx x, enum machine_mode, int *, int *, bool);
+extern bool check_for_inc_dec (rtx insn);
+extern int comparison_dominates_p (enum rtx_code, enum rtx_code);
+extern bool jump_to_label_p (rtx);
+extern int condjump_p (const_rtx);
+extern int any_condjump_p (const_rtx);
+extern int any_uncondjump_p (const_rtx);
+extern rtx pc_set (const_rtx);
+extern rtx condjump_label (const_rtx);
+extern int simplejump_p (const_rtx);
+extern int returnjump_p (rtx);
+extern int eh_returnjump_p (rtx);
+extern int onlyjump_p (const_rtx);
+extern int only_sets_cc0_p (const_rtx);
+extern int sets_cc0_p (const_rtx);
+extern int invert_jump_1 (rtx, rtx);
+extern int invert_jump (rtx, rtx, int);
+extern int rtx_renumbered_equal_p (const_rtx, const_rtx);
+extern int true_regnum (const_rtx);
+extern unsigned int reg_or_subregno (const_rtx);
+extern int redirect_jump_1 (rtx, rtx);
+extern void redirect_jump_2 (rtx, rtx, rtx, int, int);
+extern int redirect_jump (rtx, rtx, int);
+extern void rebuild_jump_labels (rtx);
+extern void rebuild_jump_labels_chain (rtx);
+extern rtx reversed_comparison (const_rtx, enum machine_mode);
+extern enum rtx_code reversed_comparison_code (const_rtx, const_rtx);
+extern enum rtx_code reversed_comparison_code_parts (enum rtx_code, const_rtx,
+           const_rtx, const_rtx);
+extern void delete_for_peephole (rtx, rtx);
+extern int condjump_in_parallel_p (const_rtx);
+extern int max_reg_num (void);
+extern int max_label_num (void);
+extern int get_first_label_num (void);
+extern void maybe_set_first_label_num (rtx);
+extern void delete_insns_since (rtx);
+extern void mark_reg_pointer (rtx, int);
+extern void mark_user_reg (rtx);
+extern void reset_used_flags (rtx);
+extern void set_used_flags (rtx);
+extern void reorder_insns (rtx, rtx, rtx);
+extern void reorder_insns_nobb (rtx, rtx, rtx);
+extern int get_max_insn_count (void);
+extern int in_sequence_p (void);
+extern void init_emit (void);
+extern void init_emit_regs (void);
+extern void init_emit_once (void);
+extern void push_topmost_sequence (void);
+extern void pop_topmost_sequence (void);
+extern void set_new_first_and_last_insn (rtx, rtx);
+extern unsigned int unshare_all_rtl (void);
+extern void unshare_all_rtl_again (rtx);
+extern void unshare_all_rtl_in_chain (rtx);
+extern void verify_rtl_sharing (void);
+extern void link_cc0_insns (rtx);
+extern void add_insn (rtx);
+extern void add_insn_before (rtx, rtx, basic_block);
+extern void add_insn_after (rtx, rtx, basic_block);
+extern void remove_insn (rtx);
+extern rtx emit (rtx);
+extern void delete_insn (rtx);
+extern rtx entry_of_function (void);
+extern void emit_insn_at_entry (rtx);
+extern void delete_insn_chain (rtx, rtx, bool);
+extern rtx unlink_insn_chain (rtx, rtx);
+extern void delete_insn_and_edges (rtx);
+extern rtx gen_lowpart_SUBREG (enum machine_mode, rtx);
+extern rtx gen_const_mem (enum machine_mode, rtx);
+extern rtx gen_frame_mem (enum machine_mode, rtx);
+extern rtx gen_tmp_stack_mem (enum machine_mode, rtx);
+extern bool validate_subreg (enum machine_mode, enum machine_mode,
+        const_rtx, unsigned int);
+extern unsigned int extended_count (const_rtx, enum machine_mode, int);
+extern rtx remove_death (unsigned int, rtx);
+extern void dump_combine_stats (FILE *);
+extern void dump_combine_total_stats (FILE *);
+extern rtx make_compound_operation (rtx, enum rtx_code);
+extern void delete_dead_jumptables (void);
+extern void schedule_insns (void);
+extern void schedule_ebbs (void);
+extern void sel_sched_fix_param (const char *param, const char *val);
+extern const char *print_rtx_head;
+extern void debug_rtx (const_rtx);
+extern void debug_rtx_list (const_rtx, int);
+extern void debug_rtx_range (const_rtx, const_rtx);
+extern const_rtx debug_rtx_find (const_rtx, int);
+extern void print_mem_expr (FILE *, const_tree);
+extern void print_rtl (FILE *, const_rtx);
+extern void print_simple_rtl (FILE *, const_rtx);
+extern int print_rtl_single (FILE *, const_rtx);
+extern int print_rtl_single_with_indent (FILE *, const_rtx, int);
+extern void print_inline_rtx (FILE *, const_rtx, int);
+extern void dump_value_slim (FILE *, const_rtx, int);
+extern void dump_insn_slim (FILE *, const_rtx);
+extern void dump_rtl_slim (FILE *, const_rtx, const_rtx, int, int);
+extern void print_value (pretty_printer *, const_rtx, int);
+extern void print_pattern (pretty_printer *, const_rtx, int);
+extern void print_insn (pretty_printer *, const_rtx, int);
+extern void rtl_dump_bb_for_graph (pretty_printer *, basic_block);
+extern const char *str_pattern_slim (const_rtx);
+extern void reposition_prologue_and_epilogue_notes (void);
+extern int prologue_epilogue_contains (const_rtx);
+extern int sibcall_epilogue_contains (const_rtx);
+extern void update_temp_slot_address (rtx, rtx);
+extern void maybe_copy_prologue_epilogue_insn (rtx, rtx);
+extern void set_return_jump_label (rtx);
+extern void expand_null_return (void);
+extern void expand_naked_return (void);
+extern void emit_jump (rtx);
+extern rtx move_by_pieces (rtx, rtx, unsigned long long,
+      unsigned int, int);
+extern long long find_args_size_adjust (rtx);
+extern int fixup_args_size_notes (rtx, rtx, int);
+extern void print_rtl_with_bb (FILE *, const_rtx, int);
+extern rtx duplicate_insn_chain (rtx, rtx);
+extern void init_expmed (void);
+extern void expand_inc (rtx, rtx);
+extern void expand_dec (rtx, rtx);
+extern void init_lower_subreg (void);
+extern bool can_copy_p (enum machine_mode);
+extern bool can_assign_to_reg_without_clobbers_p (rtx);
+extern rtx fis_get_condition (rtx);
+extern void mark_elimination (int, int);
+extern int reg_classes_intersect_p (reg_class_t, reg_class_t);
+extern int reg_class_subset_p (reg_class_t, reg_class_t);
+extern void globalize_reg (tree, int);
+extern void init_reg_modes_target (void);
+extern void init_regs (void);
+extern void reinit_regs (void);
+extern void init_fake_stack_mems (void);
+extern void save_register_info (void);
+extern void init_reg_sets (void);
+extern void regclass (rtx, int);
+extern void reg_scan (rtx, unsigned int);
+extern void fix_register (const char *, int, int);
+extern bool invalid_mode_change_p (unsigned int, enum reg_class);
+extern void dbr_schedule (rtx);
+extern int function_invariant_p (const_rtx);
+enum libcall_type
+{
+  LCT_NORMAL = 0,
+  LCT_CONST = 1,
+  LCT_PURE = 2,
+  LCT_NORETURN = 3,
+  LCT_THROW = 4,
+  LCT_RETURNS_TWICE = 5
+};
+extern void emit_library_call (rtx, enum libcall_type, enum machine_mode, int,
+          ...);
+extern rtx emit_library_call_value (rtx, rtx, enum libcall_type,
+        enum machine_mode, int, ...);
+extern void init_varasm_once (void);
+extern rtx make_debug_expr_from_rtl (const_rtx);
+extern bool read_rtx (const char *, rtx *);
+extern rtx canon_rtx (rtx);
+extern int true_dependence (const_rtx, enum machine_mode, const_rtx);
+extern rtx get_addr (rtx);
+extern int canon_true_dependence (const_rtx, enum machine_mode, rtx,
+      const_rtx, rtx);
+extern int read_dependence (const_rtx, const_rtx);
+extern int anti_dependence (const_rtx, const_rtx);
+extern int output_dependence (const_rtx, const_rtx);
+extern int may_alias_p (const_rtx, const_rtx);
+extern void init_alias_target (void);
+extern void init_alias_analysis (void);
+extern void end_alias_analysis (void);
+extern void vt_equate_reg_base_value (const_rtx, const_rtx);
+extern bool memory_modified_in_insn_p (const_rtx, const_rtx);
+extern bool memory_must_be_modified_in_insn_p (const_rtx, const_rtx);
+extern bool may_be_sp_based_p (rtx);
+extern rtx gen_hard_reg_clobber (enum machine_mode, unsigned int);
+extern rtx get_reg_known_value (unsigned int);
+extern bool get_reg_known_equiv_p (unsigned int);
+extern rtx get_reg_base_value (unsigned int);
+extern rtx stack_limit_rtx;
+extern void invert_br_probabilities (rtx);
+extern bool expensive_function_p (int);
+extern unsigned int variable_tracking_main (void);
+extern void get_mode_bounds (enum machine_mode, int, enum machine_mode,
+        rtx *, rtx *);
+extern rtx reversed_condition (rtx);
+extern rtx compare_and_jump_seq (rtx, rtx, enum rtx_code, rtx, int, rtx);
+extern rtx canon_condition (rtx);
+extern void simplify_using_condition (rtx, rtx *, bitmap);
+extern unsigned int compute_alignments (void);
+extern int asm_str_count (const char *templ);
+struct rtl_hooks
+{
+  rtx (*gen_lowpart) (enum machine_mode, rtx);
+  rtx (*gen_lowpart_no_emit) (enum machine_mode, rtx);
+  rtx (*reg_nonzero_bits) (const_rtx, enum machine_mode, const_rtx, enum machine_mode,
+      unsigned long long, unsigned long long *);
+  rtx (*reg_num_sign_bit_copies) (const_rtx, enum machine_mode, const_rtx, enum machine_mode,
+      unsigned int, unsigned int *);
+  bool (*reg_truncated_to_mode) (enum machine_mode, const_rtx);
+};
+extern struct rtl_hooks rtl_hooks;
+extern const struct rtl_hooks general_rtl_hooks;
+extern void insn_locations_init (void);
+extern void insn_locations_finalize (void);
+extern void set_curr_insn_location (location_t);
+extern location_t curr_insn_location (void);
+extern bool optimize_insn_for_size_p (void);
+extern bool optimize_insn_for_speed_p (void);
+extern void _fatal_insn_not_found (const_rtx, const char *, int, const char *)
+     __attribute__ ((__noreturn__));
+extern void _fatal_insn (const char *, const_rtx, const char *, int, const char *)
+     __attribute__ ((__noreturn__));
+enum tree_code {
+ERROR_MARK,
+IDENTIFIER_NODE,
+TREE_LIST,
+TREE_VEC,
+BLOCK,
+OFFSET_TYPE,
+ENUMERAL_TYPE,
+BOOLEAN_TYPE,
+INTEGER_TYPE,
+REAL_TYPE,
+POINTER_TYPE,
+REFERENCE_TYPE,
+NULLPTR_TYPE,
+FIXED_POINT_TYPE,
+COMPLEX_TYPE,
+VECTOR_TYPE,
+ARRAY_TYPE,
+RECORD_TYPE,
+UNION_TYPE,
+QUAL_UNION_TYPE,
+VOID_TYPE,
+FUNCTION_TYPE,
+METHOD_TYPE,
+LANG_TYPE,
+INTEGER_CST,
+REAL_CST,
+FIXED_CST,
+COMPLEX_CST,
+VECTOR_CST,
+STRING_CST,
+FUNCTION_DECL,
+LABEL_DECL,
+FIELD_DECL,
+VAR_DECL,
+CONST_DECL,
+PARM_DECL,
+TYPE_DECL,
+RESULT_DECL,
+DEBUG_EXPR_DECL,
+NAMESPACE_DECL,
+IMPORTED_DECL,
+TRANSLATION_UNIT_DECL,
+COMPONENT_REF,
+BIT_FIELD_REF,
+ARRAY_REF,
+ARRAY_RANGE_REF,
+REALPART_EXPR,
+IMAGPART_EXPR,
+VIEW_CONVERT_EXPR,
+INDIRECT_REF,
+OBJ_TYPE_REF,
+CONSTRUCTOR,
+COMPOUND_EXPR,
+MODIFY_EXPR,
+INIT_EXPR,
+TARGET_EXPR,
+COND_EXPR,
+VEC_COND_EXPR,
+VEC_PERM_EXPR,
+BIND_EXPR,
+CALL_EXPR,
+WITH_CLEANUP_EXPR,
+CLEANUP_POINT_EXPR,
+PLACEHOLDER_EXPR,
+PLUS_EXPR,
+MINUS_EXPR,
+MULT_EXPR,
+POINTER_PLUS_EXPR,
+MULT_HIGHPART_EXPR,
+TRUNC_DIV_EXPR,
+CEIL_DIV_EXPR,
+FLOOR_DIV_EXPR,
+ROUND_DIV_EXPR,
+TRUNC_MOD_EXPR,
+CEIL_MOD_EXPR,
+FLOOR_MOD_EXPR,
+ROUND_MOD_EXPR,
+RDIV_EXPR,
+EXACT_DIV_EXPR,
+FIX_TRUNC_EXPR,
+FLOAT_EXPR,
+NEGATE_EXPR,
+MIN_EXPR,
+MAX_EXPR,
+ABS_EXPR,
+LSHIFT_EXPR,
+RSHIFT_EXPR,
+LROTATE_EXPR,
+RROTATE_EXPR,
+BIT_IOR_EXPR,
+BIT_XOR_EXPR,
+BIT_AND_EXPR,
+BIT_NOT_EXPR,
+TRUTH_ANDIF_EXPR,
+TRUTH_ORIF_EXPR,
+TRUTH_AND_EXPR,
+TRUTH_OR_EXPR,
+TRUTH_XOR_EXPR,
+TRUTH_NOT_EXPR,
+LT_EXPR,
+LE_EXPR,
+GT_EXPR,
+GE_EXPR,
+EQ_EXPR,
+NE_EXPR,
+UNORDERED_EXPR,
+ORDERED_EXPR,
+UNLT_EXPR,
+UNLE_EXPR,
+UNGT_EXPR,
+UNGE_EXPR,
+UNEQ_EXPR,
+LTGT_EXPR,
+RANGE_EXPR,
+PAREN_EXPR,
+CONVERT_EXPR,
+ADDR_SPACE_CONVERT_EXPR,
+FIXED_CONVERT_EXPR,
+NOP_EXPR,
+NON_LVALUE_EXPR,
+COMPOUND_LITERAL_EXPR,
+SAVE_EXPR,
+ADDR_EXPR,
+FDESC_EXPR,
+COMPLEX_EXPR,
+CONJ_EXPR,
+PREDECREMENT_EXPR,
+PREINCREMENT_EXPR,
+POSTDECREMENT_EXPR,
+POSTINCREMENT_EXPR,
+VA_ARG_EXPR,
+TRY_CATCH_EXPR,
+TRY_FINALLY_EXPR,
+DECL_EXPR,
+LABEL_EXPR,
+GOTO_EXPR,
+RETURN_EXPR,
+EXIT_EXPR,
+LOOP_EXPR,
+SWITCH_EXPR,
+CASE_LABEL_EXPR,
+ASM_EXPR,
+SSA_NAME,
+CATCH_EXPR,
+EH_FILTER_EXPR,
+SCEV_KNOWN,
+SCEV_NOT_KNOWN,
+POLYNOMIAL_CHREC,
+STATEMENT_LIST,
+ASSERT_EXPR,
+TREE_BINFO,
+WITH_SIZE_EXPR,
+REALIGN_LOAD_EXPR,
+TARGET_MEM_REF,
+MEM_REF,
+OMP_PARALLEL,
+OMP_TASK,
+OMP_FOR,
+OMP_SECTIONS,
+OMP_SINGLE,
+OMP_SECTION,
+OMP_MASTER,
+OMP_ORDERED,
+OMP_CRITICAL,
+OMP_ATOMIC,
+OMP_ATOMIC_READ,
+OMP_ATOMIC_CAPTURE_OLD,
+OMP_ATOMIC_CAPTURE_NEW,
+OMP_CLAUSE,
+TRANSACTION_EXPR,
+REDUC_MAX_EXPR,
+REDUC_MIN_EXPR,
+REDUC_PLUS_EXPR,
+DOT_PROD_EXPR,
+WIDEN_SUM_EXPR,
+WIDEN_MULT_EXPR,
+WIDEN_MULT_PLUS_EXPR,
+WIDEN_MULT_MINUS_EXPR,
+WIDEN_LSHIFT_EXPR,
+FMA_EXPR,
+VEC_LSHIFT_EXPR,
+VEC_RSHIFT_EXPR,
+VEC_WIDEN_MULT_HI_EXPR,
+VEC_WIDEN_MULT_LO_EXPR,
+VEC_WIDEN_MULT_EVEN_EXPR,
+VEC_WIDEN_MULT_ODD_EXPR,
+VEC_UNPACK_HI_EXPR,
+VEC_UNPACK_LO_EXPR,
+VEC_UNPACK_FLOAT_HI_EXPR,
+VEC_UNPACK_FLOAT_LO_EXPR,
+VEC_PACK_TRUNC_EXPR,
+VEC_PACK_SAT_EXPR,
+VEC_PACK_FIX_TRUNC_EXPR,
+VEC_WIDEN_LSHIFT_HI_EXPR,
+VEC_WIDEN_LSHIFT_LO_EXPR,
+PREDICT_EXPR,
+OPTIMIZATION_NODE,
+TARGET_OPTION_NODE,
+LAST_AND_UNUSED_TREE_CODE,
+C_MAYBE_CONST_EXPR,
+EXCESS_PRECISION_EXPR,
+USERDEF_LITERAL,
+SIZEOF_EXPR,
+UNCONSTRAINED_ARRAY_TYPE,
+UNCONSTRAINED_ARRAY_REF,
+NULL_EXPR,
+PLUS_NOMOD_EXPR,
+MINUS_NOMOD_EXPR,
+ATTR_ADDR_EXPR,
+STMT_STMT,
+LOOP_STMT,
+EXIT_STMT,
+OFFSET_REF,
+PTRMEM_CST,
+NEW_EXPR,
+VEC_NEW_EXPR,
+DELETE_EXPR,
+VEC_DELETE_EXPR,
+SCOPE_REF,
+MEMBER_REF,
+TYPE_EXPR,
+AGGR_INIT_EXPR,
+VEC_INIT_EXPR,
+THROW_EXPR,
+EMPTY_CLASS_EXPR,
+BASELINK,
+TEMPLATE_DECL,
+TEMPLATE_PARM_INDEX,
+TEMPLATE_TEMPLATE_PARM,
+TEMPLATE_TYPE_PARM,
+TYPENAME_TYPE,
+TYPEOF_TYPE,
+BOUND_TEMPLATE_TEMPLATE_PARM,
+UNBOUND_CLASS_TEMPLATE,
+USING_DECL,
+USING_STMT,
+DEFAULT_ARG,
+DEFERRED_NOEXCEPT,
+TEMPLATE_ID_EXPR,
+OVERLOAD,
+PSEUDO_DTOR_EXPR,
+MODOP_EXPR,
+CAST_EXPR,
+REINTERPRET_CAST_EXPR,
+CONST_CAST_EXPR,
+STATIC_CAST_EXPR,
+DYNAMIC_CAST_EXPR,
+IMPLICIT_CONV_EXPR,
+DOTSTAR_EXPR,
+TYPEID_EXPR,
+NOEXCEPT_EXPR,
+NON_DEPENDENT_EXPR,
+CTOR_INITIALIZER,
+TRY_BLOCK,
+EH_SPEC_BLOCK,
+HANDLER,
+MUST_NOT_THROW_EXPR,
+CLEANUP_STMT,
+IF_STMT,
+FOR_STMT,
+RANGE_FOR_STMT,
+WHILE_STMT,
+DO_STMT,
+BREAK_STMT,
+CONTINUE_STMT,
+SWITCH_STMT,
+EXPR_STMT,
+TAG_DEFN,
+OFFSETOF_EXPR,
+ARROW_EXPR,
+ALIGNOF_EXPR,
+AT_ENCODE_EXPR,
+STMT_EXPR,
+UNARY_PLUS_EXPR,
+STATIC_ASSERT,
+TYPE_ARGUMENT_PACK,
+NONTYPE_ARGUMENT_PACK,
+TYPE_PACK_EXPANSION,
+EXPR_PACK_EXPANSION,
+ARGUMENT_PACK_SELECT,
+TRAIT_EXPR,
+LAMBDA_EXPR,
+DECLTYPE_TYPE,
+UNDERLYING_TYPE,
+BASES,
+TEMPLATE_INFO,
+URSHIFT_EXPR,
+COMPARE_EXPR,
+COMPARE_L_EXPR,
+COMPARE_G_EXPR,
+CLASS_INTERFACE_TYPE,
+CLASS_IMPLEMENTATION_TYPE,
+CATEGORY_INTERFACE_TYPE,
+CATEGORY_IMPLEMENTATION_TYPE,
+PROTOCOL_INTERFACE_TYPE,
+KEYWORD_DECL,
+INSTANCE_METHOD_DECL,
+CLASS_METHOD_DECL,
+PROPERTY_DECL,
+MESSAGE_SEND_EXPR,
+CLASS_REFERENCE_EXPR,
+PROPERTY_REF,
+MAX_TREE_CODES
+};
+extern unsigned char tree_contains_struct[MAX_TREE_CODES][64];
+enum tree_code_class {
+  tcc_exceptional,
+  tcc_constant,
+  tcc_type,
+  tcc_declaration,
+  tcc_reference,
+  tcc_comparison,
+  tcc_unary,
+  tcc_binary,
+  tcc_statement,
+  tcc_vl_exp,
+  tcc_expression
+};
+extern const char *const tree_code_class_strings[];
+extern const enum tree_code_class tree_code_type[];
+extern const unsigned char tree_code_length[];
+extern const char *const tree_code_name[];
+typedef struct alias_pair
+{
+  tree decl;
+  tree target;
+} alias_pair;
+extern vec<alias_pair, va_gc> *alias_pairs;
+enum built_in_class
+{
+  NOT_BUILT_IN = 0,
+  BUILT_IN_FRONTEND,
+  BUILT_IN_MD,
+  BUILT_IN_NORMAL
+};
+extern const char *const built_in_class_names[4];
+enum built_in_function
+{
+BUILT_IN_NONE,
+BUILT_IN_ACOS,
+BUILT_IN_ACOSF,
+BUILT_IN_ACOSH,
+BUILT_IN_ACOSHF,
+BUILT_IN_ACOSHL,
+BUILT_IN_ACOSL,
+BUILT_IN_ASIN,
+BUILT_IN_ASINF,
+BUILT_IN_ASINH,
+BUILT_IN_ASINHF,
+BUILT_IN_ASINHL,
+BUILT_IN_ASINL,
+BUILT_IN_ATAN,
+BUILT_IN_ATAN2,
+BUILT_IN_ATAN2F,
+BUILT_IN_ATAN2L,
+BUILT_IN_ATANF,
+BUILT_IN_ATANH,
+BUILT_IN_ATANHF,
+BUILT_IN_ATANHL,
+BUILT_IN_ATANL,
+BUILT_IN_CBRT,
+BUILT_IN_CBRTF,
+BUILT_IN_CBRTL,
+BUILT_IN_CEIL,
+BUILT_IN_CEILF,
+BUILT_IN_CEILL,
+BUILT_IN_COPYSIGN,
+BUILT_IN_COPYSIGNF,
+BUILT_IN_COPYSIGNL,
+BUILT_IN_COS,
+BUILT_IN_COSF,
+BUILT_IN_COSH,
+BUILT_IN_COSHF,
+BUILT_IN_COSHL,
+BUILT_IN_COSL,
+BUILT_IN_DREM,
+BUILT_IN_DREMF,
+BUILT_IN_DREML,
+BUILT_IN_ERF,
+BUILT_IN_ERFC,
+BUILT_IN_ERFCF,
+BUILT_IN_ERFCL,
+BUILT_IN_ERFF,
+BUILT_IN_ERFL,
+BUILT_IN_EXP,
+BUILT_IN_EXP10,
+BUILT_IN_EXP10F,
+BUILT_IN_EXP10L,
+BUILT_IN_EXP2,
+BUILT_IN_EXP2F,
+BUILT_IN_EXP2L,
+BUILT_IN_EXPF,
+BUILT_IN_EXPL,
+BUILT_IN_EXPM1,
+BUILT_IN_EXPM1F,
+BUILT_IN_EXPM1L,
+BUILT_IN_FABS,
+BUILT_IN_FABSF,
+BUILT_IN_FABSL,
+BUILT_IN_FDIM,
+BUILT_IN_FDIMF,
+BUILT_IN_FDIML,
+BUILT_IN_FLOOR,
+BUILT_IN_FLOORF,
+BUILT_IN_FLOORL,
+BUILT_IN_FMA,
+BUILT_IN_FMAF,
+BUILT_IN_FMAL,
+BUILT_IN_FMAX,
+BUILT_IN_FMAXF,
+BUILT_IN_FMAXL,
+BUILT_IN_FMIN,
+BUILT_IN_FMINF,
+BUILT_IN_FMINL,
+BUILT_IN_FMOD,
+BUILT_IN_FMODF,
+BUILT_IN_FMODL,
+BUILT_IN_FREXP,
+BUILT_IN_FREXPF,
+BUILT_IN_FREXPL,
+BUILT_IN_GAMMA,
+BUILT_IN_GAMMAF,
+BUILT_IN_GAMMAL,
+BUILT_IN_GAMMA_R,
+BUILT_IN_GAMMAF_R,
+BUILT_IN_GAMMAL_R,
+BUILT_IN_HUGE_VAL,
+BUILT_IN_HUGE_VALF,
+BUILT_IN_HUGE_VALL,
+BUILT_IN_HYPOT,
+BUILT_IN_HYPOTF,
+BUILT_IN_HYPOTL,
+BUILT_IN_ICEIL,
+BUILT_IN_ICEILF,
+BUILT_IN_ICEILL,
+BUILT_IN_IFLOOR,
+BUILT_IN_IFLOORF,
+BUILT_IN_IFLOORL,
+BUILT_IN_ILOGB,
+BUILT_IN_ILOGBF,
+BUILT_IN_ILOGBL,
+BUILT_IN_INF,
+BUILT_IN_INFF,
+BUILT_IN_INFL,
+BUILT_IN_INFD32,
+BUILT_IN_INFD64,
+BUILT_IN_INFD128,
+BUILT_IN_IRINT,
+BUILT_IN_IRINTF,
+BUILT_IN_IRINTL,
+BUILT_IN_IROUND,
+BUILT_IN_IROUNDF,
+BUILT_IN_IROUNDL,
+BUILT_IN_J0,
+BUILT_IN_J0F,
+BUILT_IN_J0L,
+BUILT_IN_J1,
+BUILT_IN_J1F,
+BUILT_IN_J1L,
+BUILT_IN_JN,
+BUILT_IN_JNF,
+BUILT_IN_JNL,
+BUILT_IN_LCEIL,
+BUILT_IN_LCEILF,
+BUILT_IN_LCEILL,
+BUILT_IN_LDEXP,
+BUILT_IN_LDEXPF,
+BUILT_IN_LDEXPL,
+BUILT_IN_LFLOOR,
+BUILT_IN_LFLOORF,
+BUILT_IN_LFLOORL,
+BUILT_IN_LGAMMA,
+BUILT_IN_LGAMMAF,
+BUILT_IN_LGAMMAL,
+BUILT_IN_LGAMMA_R,
+BUILT_IN_LGAMMAF_R,
+BUILT_IN_LGAMMAL_R,
+BUILT_IN_LLCEIL,
+BUILT_IN_LLCEILF,
+BUILT_IN_LLCEILL,
+BUILT_IN_LLFLOOR,
+BUILT_IN_LLFLOORF,
+BUILT_IN_LLFLOORL,
+BUILT_IN_LLRINT,
+BUILT_IN_LLRINTF,
+BUILT_IN_LLRINTL,
+BUILT_IN_LLROUND,
+BUILT_IN_LLROUNDF,
+BUILT_IN_LLROUNDL,
+BUILT_IN_LOG,
+BUILT_IN_LOG10,
+BUILT_IN_LOG10F,
+BUILT_IN_LOG10L,
+BUILT_IN_LOG1P,
+BUILT_IN_LOG1PF,
+BUILT_IN_LOG1PL,
+BUILT_IN_LOG2,
+BUILT_IN_LOG2F,
+BUILT_IN_LOG2L,
+BUILT_IN_LOGB,
+BUILT_IN_LOGBF,
+BUILT_IN_LOGBL,
+BUILT_IN_LOGF,
+BUILT_IN_LOGL,
+BUILT_IN_LRINT,
+BUILT_IN_LRINTF,
+BUILT_IN_LRINTL,
+BUILT_IN_LROUND,
+BUILT_IN_LROUNDF,
+BUILT_IN_LROUNDL,
+BUILT_IN_MODF,
+BUILT_IN_MODFF,
+BUILT_IN_MODFL,
+BUILT_IN_NAN,
+BUILT_IN_NANF,
+BUILT_IN_NANL,
+BUILT_IN_NAND32,
+BUILT_IN_NAND64,
+BUILT_IN_NAND128,
+BUILT_IN_NANS,
+BUILT_IN_NANSF,
+BUILT_IN_NANSL,
+BUILT_IN_NEARBYINT,
+BUILT_IN_NEARBYINTF,
+BUILT_IN_NEARBYINTL,
+BUILT_IN_NEXTAFTER,
+BUILT_IN_NEXTAFTERF,
+BUILT_IN_NEXTAFTERL,
+BUILT_IN_NEXTTOWARD,
+BUILT_IN_NEXTTOWARDF,
+BUILT_IN_NEXTTOWARDL,
+BUILT_IN_POW,
+BUILT_IN_POW10,
+BUILT_IN_POW10F,
+BUILT_IN_POW10L,
+BUILT_IN_POWF,
+BUILT_IN_POWI,
+BUILT_IN_POWIF,
+BUILT_IN_POWIL,
+BUILT_IN_POWL,
+BUILT_IN_REMAINDER,
+BUILT_IN_REMAINDERF,
+BUILT_IN_REMAINDERL,
+BUILT_IN_REMQUO,
+BUILT_IN_REMQUOF,
+BUILT_IN_REMQUOL,
+BUILT_IN_RINT,
+BUILT_IN_RINTF,
+BUILT_IN_RINTL,
+BUILT_IN_ROUND,
+BUILT_IN_ROUNDF,
+BUILT_IN_ROUNDL,
+BUILT_IN_SCALB,
+BUILT_IN_SCALBF,
+BUILT_IN_SCALBL,
+BUILT_IN_SCALBLN,
+BUILT_IN_SCALBLNF,
+BUILT_IN_SCALBLNL,
+BUILT_IN_SCALBN,
+BUILT_IN_SCALBNF,
+BUILT_IN_SCALBNL,
+BUILT_IN_SIGNBIT,
+BUILT_IN_SIGNBITF,
+BUILT_IN_SIGNBITL,
+BUILT_IN_SIGNBITD32,
+BUILT_IN_SIGNBITD64,
+BUILT_IN_SIGNBITD128,
+BUILT_IN_SIGNIFICAND,
+BUILT_IN_SIGNIFICANDF,
+BUILT_IN_SIGNIFICANDL,
+BUILT_IN_SIN,
+BUILT_IN_SINCOS,
+BUILT_IN_SINCOSF,
+BUILT_IN_SINCOSL,
+BUILT_IN_SINF,
+BUILT_IN_SINH,
+BUILT_IN_SINHF,
+BUILT_IN_SINHL,
+BUILT_IN_SINL,
+BUILT_IN_SQRT,
+BUILT_IN_SQRTF,
+BUILT_IN_SQRTL,
+BUILT_IN_TAN,
+BUILT_IN_TANF,
+BUILT_IN_TANH,
+BUILT_IN_TANHF,
+BUILT_IN_TANHL,
+BUILT_IN_TANL,
+BUILT_IN_TGAMMA,
+BUILT_IN_TGAMMAF,
+BUILT_IN_TGAMMAL,
+BUILT_IN_TRUNC,
+BUILT_IN_TRUNCF,
+BUILT_IN_TRUNCL,
+BUILT_IN_Y0,
+BUILT_IN_Y0F,
+BUILT_IN_Y0L,
+BUILT_IN_Y1,
+BUILT_IN_Y1F,
+BUILT_IN_Y1L,
+BUILT_IN_YN,
+BUILT_IN_YNF,
+BUILT_IN_YNL,
+BUILT_IN_CABS,
+BUILT_IN_CABSF,
+BUILT_IN_CABSL,
+BUILT_IN_CACOS,
+BUILT_IN_CACOSF,
+BUILT_IN_CACOSH,
+BUILT_IN_CACOSHF,
+BUILT_IN_CACOSHL,
+BUILT_IN_CACOSL,
+BUILT_IN_CARG,
+BUILT_IN_CARGF,
+BUILT_IN_CARGL,
+BUILT_IN_CASIN,
+BUILT_IN_CASINF,
+BUILT_IN_CASINH,
+BUILT_IN_CASINHF,
+BUILT_IN_CASINHL,
+BUILT_IN_CASINL,
+BUILT_IN_CATAN,
+BUILT_IN_CATANF,
+BUILT_IN_CATANH,
+BUILT_IN_CATANHF,
+BUILT_IN_CATANHL,
+BUILT_IN_CATANL,
+BUILT_IN_CCOS,
+BUILT_IN_CCOSF,
+BUILT_IN_CCOSH,
+BUILT_IN_CCOSHF,
+BUILT_IN_CCOSHL,
+BUILT_IN_CCOSL,
+BUILT_IN_CEXP,
+BUILT_IN_CEXPF,
+BUILT_IN_CEXPL,
+BUILT_IN_CEXPI,
+BUILT_IN_CEXPIF,
+BUILT_IN_CEXPIL,
+BUILT_IN_CIMAG,
+BUILT_IN_CIMAGF,
+BUILT_IN_CIMAGL,
+BUILT_IN_CLOG,
+BUILT_IN_CLOGF,
+BUILT_IN_CLOGL,
+BUILT_IN_CLOG10,
+BUILT_IN_CLOG10F,
+BUILT_IN_CLOG10L,
+BUILT_IN_CONJ,
+BUILT_IN_CONJF,
+BUILT_IN_CONJL,
+BUILT_IN_CPOW,
+BUILT_IN_CPOWF,
+BUILT_IN_CPOWL,
+BUILT_IN_CPROJ,
+BUILT_IN_CPROJF,
+BUILT_IN_CPROJL,
+BUILT_IN_CREAL,
+BUILT_IN_CREALF,
+BUILT_IN_CREALL,
+BUILT_IN_CSIN,
+BUILT_IN_CSINF,
+BUILT_IN_CSINH,
+BUILT_IN_CSINHF,
+BUILT_IN_CSINHL,
+BUILT_IN_CSINL,
+BUILT_IN_CSQRT,
+BUILT_IN_CSQRTF,
+BUILT_IN_CSQRTL,
+BUILT_IN_CTAN,
+BUILT_IN_CTANF,
+BUILT_IN_CTANH,
+BUILT_IN_CTANHF,
+BUILT_IN_CTANHL,
+BUILT_IN_CTANL,
+BUILT_IN_BCMP,
+BUILT_IN_BCOPY,
+BUILT_IN_BZERO,
+BUILT_IN_INDEX,
+BUILT_IN_MEMCHR,
+BUILT_IN_MEMCMP,
+BUILT_IN_MEMCPY,
+BUILT_IN_MEMMOVE,
+BUILT_IN_MEMPCPY,
+BUILT_IN_MEMSET,
+BUILT_IN_RINDEX,
+BUILT_IN_STPCPY,
+BUILT_IN_STPNCPY,
+BUILT_IN_STRCASECMP,
+BUILT_IN_STRCAT,
+BUILT_IN_STRCHR,
+BUILT_IN_STRCMP,
+BUILT_IN_STRCPY,
+BUILT_IN_STRCSPN,
+BUILT_IN_STRDUP,
+BUILT_IN_STRNDUP,
+BUILT_IN_STRLEN,
+BUILT_IN_STRNCASECMP,
+BUILT_IN_STRNCAT,
+BUILT_IN_STRNCMP,
+BUILT_IN_STRNCPY,
+BUILT_IN_STRPBRK,
+BUILT_IN_STRRCHR,
+BUILT_IN_STRSPN,
+BUILT_IN_STRSTR,
+BUILT_IN_FPRINTF,
+BUILT_IN_FPRINTF_UNLOCKED,
+BUILT_IN_PUTC,
+BUILT_IN_PUTC_UNLOCKED,
+BUILT_IN_FPUTC,
+BUILT_IN_FPUTC_UNLOCKED,
+BUILT_IN_FPUTS,
+BUILT_IN_FPUTS_UNLOCKED,
+BUILT_IN_FSCANF,
+BUILT_IN_FWRITE,
+BUILT_IN_FWRITE_UNLOCKED,
+BUILT_IN_PRINTF,
+BUILT_IN_PRINTF_UNLOCKED,
+BUILT_IN_PUTCHAR,
+BUILT_IN_PUTCHAR_UNLOCKED,
+BUILT_IN_PUTS,
+BUILT_IN_PUTS_UNLOCKED,
+BUILT_IN_SCANF,
+BUILT_IN_SNPRINTF,
+BUILT_IN_SPRINTF,
+BUILT_IN_SSCANF,
+BUILT_IN_VFPRINTF,
+BUILT_IN_VFSCANF,
+BUILT_IN_VPRINTF,
+BUILT_IN_VSCANF,
+BUILT_IN_VSNPRINTF,
+BUILT_IN_VSPRINTF,
+BUILT_IN_VSSCANF,
+BUILT_IN_ISALNUM,
+BUILT_IN_ISALPHA,
+BUILT_IN_ISASCII,
+BUILT_IN_ISBLANK,
+BUILT_IN_ISCNTRL,
+BUILT_IN_ISDIGIT,
+BUILT_IN_ISGRAPH,
+BUILT_IN_ISLOWER,
+BUILT_IN_ISPRINT,
+BUILT_IN_ISPUNCT,
+BUILT_IN_ISSPACE,
+BUILT_IN_ISUPPER,
+BUILT_IN_ISXDIGIT,
+BUILT_IN_TOASCII,
+BUILT_IN_TOLOWER,
+BUILT_IN_TOUPPER,
+BUILT_IN_ISWALNUM,
+BUILT_IN_ISWALPHA,
+BUILT_IN_ISWBLANK,
+BUILT_IN_ISWCNTRL,
+BUILT_IN_ISWDIGIT,
+BUILT_IN_ISWGRAPH,
+BUILT_IN_ISWLOWER,
+BUILT_IN_ISWPRINT,
+BUILT_IN_ISWPUNCT,
+BUILT_IN_ISWSPACE,
+BUILT_IN_ISWUPPER,
+BUILT_IN_ISWXDIGIT,
+BUILT_IN_TOWLOWER,
+BUILT_IN_TOWUPPER,
+BUILT_IN_ABORT,
+BUILT_IN_ABS,
+BUILT_IN_AGGREGATE_INCOMING_ADDRESS,
+BUILT_IN_ALLOCA,
+BUILT_IN_APPLY,
+BUILT_IN_APPLY_ARGS,
+BUILT_IN_BSWAP16,
+BUILT_IN_BSWAP32,
+BUILT_IN_BSWAP64,
+BUILT_IN_CLEAR_CACHE,
+BUILT_IN_CALLOC,
+BUILT_IN_CLASSIFY_TYPE,
+BUILT_IN_CLZ,
+BUILT_IN_CLZIMAX,
+BUILT_IN_CLZL,
+BUILT_IN_CLZLL,
+BUILT_IN_CONSTANT_P,
+BUILT_IN_CTZ,
+BUILT_IN_CTZIMAX,
+BUILT_IN_CTZL,
+BUILT_IN_CTZLL,
+BUILT_IN_CLRSB,
+BUILT_IN_CLRSBIMAX,
+BUILT_IN_CLRSBL,
+BUILT_IN_CLRSBLL,
+BUILT_IN_DCGETTEXT,
+BUILT_IN_DGETTEXT,
+BUILT_IN_DWARF_CFA,
+BUILT_IN_DWARF_SP_COLUMN,
+BUILT_IN_EH_RETURN,
+BUILT_IN_EH_RETURN_DATA_REGNO,
+BUILT_IN_EXECL,
+BUILT_IN_EXECLP,
+BUILT_IN_EXECLE,
+BUILT_IN_EXECV,
+BUILT_IN_EXECVP,
+BUILT_IN_EXECVE,
+BUILT_IN_EXIT,
+BUILT_IN_EXPECT,
+BUILT_IN_ASSUME_ALIGNED,
+BUILT_IN_EXTEND_POINTER,
+BUILT_IN_EXTRACT_RETURN_ADDR,
+BUILT_IN_FFS,
+BUILT_IN_FFSIMAX,
+BUILT_IN_FFSL,
+BUILT_IN_FFSLL,
+BUILT_IN_FORK,
+BUILT_IN_FRAME_ADDRESS,
+BUILT_IN_FREE,
+BUILT_IN_FROB_RETURN_ADDR,
+BUILT_IN_GETTEXT,
+BUILT_IN_IMAXABS,
+BUILT_IN_INIT_DWARF_REG_SIZES,
+BUILT_IN_FINITE,
+BUILT_IN_FINITEF,
+BUILT_IN_FINITEL,
+BUILT_IN_FINITED32,
+BUILT_IN_FINITED64,
+BUILT_IN_FINITED128,
+BUILT_IN_FPCLASSIFY,
+BUILT_IN_ISFINITE,
+BUILT_IN_ISINF_SIGN,
+BUILT_IN_ISINF,
+BUILT_IN_ISINFF,
+BUILT_IN_ISINFL,
+BUILT_IN_ISINFD32,
+BUILT_IN_ISINFD64,
+BUILT_IN_ISINFD128,
+BUILT_IN_ISNAN,
+BUILT_IN_ISNANF,
+BUILT_IN_ISNANL,
+BUILT_IN_ISNAND32,
+BUILT_IN_ISNAND64,
+BUILT_IN_ISNAND128,
+BUILT_IN_ISNORMAL,
+BUILT_IN_ISGREATER,
+BUILT_IN_ISGREATEREQUAL,
+BUILT_IN_ISLESS,
+BUILT_IN_ISLESSEQUAL,
+BUILT_IN_ISLESSGREATER,
+BUILT_IN_ISUNORDERED,
+BUILT_IN_LABS,
+BUILT_IN_LLABS,
+BUILT_IN_LONGJMP,
+BUILT_IN_MALLOC,
+BUILT_IN_NEXT_ARG,
+BUILT_IN_PARITY,
+BUILT_IN_PARITYIMAX,
+BUILT_IN_PARITYL,
+BUILT_IN_PARITYLL,
+BUILT_IN_POPCOUNT,
+BUILT_IN_POPCOUNTIMAX,
+BUILT_IN_POPCOUNTL,
+BUILT_IN_POPCOUNTLL,
+BUILT_IN_PREFETCH,
+BUILT_IN_REALLOC,
+BUILT_IN_RETURN,
+BUILT_IN_RETURN_ADDRESS,
+BUILT_IN_SAVEREGS,
+BUILT_IN_SETJMP,
+BUILT_IN_STRFMON,
+BUILT_IN_STRFTIME,
+BUILT_IN_TRAP,
+BUILT_IN_UNREACHABLE,
+BUILT_IN_UNWIND_INIT,
+BUILT_IN_UPDATE_SETJMP_BUF,
+BUILT_IN_VA_COPY,
+BUILT_IN_VA_END,
+BUILT_IN_VA_START,
+BUILT_IN_VA_ARG_PACK,
+BUILT_IN_VA_ARG_PACK_LEN,
+BUILT_IN__EXIT,
+BUILT_IN__EXIT2,
+BUILT_IN_INIT_TRAMPOLINE,
+BUILT_IN_INIT_HEAP_TRAMPOLINE,
+BUILT_IN_ADJUST_TRAMPOLINE,
+BUILT_IN_NONLOCAL_GOTO,
+BUILT_IN_SETJMP_SETUP,
+BUILT_IN_SETJMP_DISPATCHER,
+BUILT_IN_SETJMP_RECEIVER,
+BUILT_IN_STACK_SAVE,
+BUILT_IN_STACK_RESTORE,
+BUILT_IN_ALLOCA_WITH_ALIGN,
+BUILT_IN_OBJECT_SIZE,
+BUILT_IN_MEMCPY_CHK,
+BUILT_IN_MEMMOVE_CHK,
+BUILT_IN_MEMPCPY_CHK,
+BUILT_IN_MEMSET_CHK,
+BUILT_IN_STPCPY_CHK,
+BUILT_IN_STPNCPY_CHK,
+BUILT_IN_STRCAT_CHK,
+BUILT_IN_STRCPY_CHK,
+BUILT_IN_STRNCAT_CHK,
+BUILT_IN_STRNCPY_CHK,
+BUILT_IN_SNPRINTF_CHK,
+BUILT_IN_SPRINTF_CHK,
+BUILT_IN_VSNPRINTF_CHK,
+BUILT_IN_VSPRINTF_CHK,
+BUILT_IN_FPRINTF_CHK,
+BUILT_IN_PRINTF_CHK,
+BUILT_IN_VFPRINTF_CHK,
+BUILT_IN_VPRINTF_CHK,
+BUILT_IN_PROFILE_FUNC_ENTER,
+BUILT_IN_PROFILE_FUNC_EXIT,
+BUILT_IN_THREAD_POINTER,
+BUILT_IN_SET_THREAD_POINTER,
+BUILT_IN_EMUTLS_GET_ADDRESS,
+BUILT_IN_EMUTLS_REGISTER_COMMON,
+BUILT_IN_UNWIND_RESUME,
+BUILT_IN_CXA_END_CLEANUP,
+BUILT_IN_EH_POINTER,
+BUILT_IN_EH_FILTER,
+BUILT_IN_EH_COPY_VALUES,
+BUILT_IN_FILE,
+BUILT_IN_FUNCTION,
+BUILT_IN_LINE,
+BUILT_IN_SYNC_FETCH_AND_ADD_N,
+BUILT_IN_SYNC_FETCH_AND_ADD_1,
+BUILT_IN_SYNC_FETCH_AND_ADD_2,
+BUILT_IN_SYNC_FETCH_AND_ADD_4,
+BUILT_IN_SYNC_FETCH_AND_ADD_8,
+BUILT_IN_SYNC_FETCH_AND_ADD_16,
+BUILT_IN_SYNC_FETCH_AND_SUB_N,
+BUILT_IN_SYNC_FETCH_AND_SUB_1,
+BUILT_IN_SYNC_FETCH_AND_SUB_2,
+BUILT_IN_SYNC_FETCH_AND_SUB_4,
+BUILT_IN_SYNC_FETCH_AND_SUB_8,
+BUILT_IN_SYNC_FETCH_AND_SUB_16,
+BUILT_IN_SYNC_FETCH_AND_OR_N,
+BUILT_IN_SYNC_FETCH_AND_OR_1,
+BUILT_IN_SYNC_FETCH_AND_OR_2,
+BUILT_IN_SYNC_FETCH_AND_OR_4,
+BUILT_IN_SYNC_FETCH_AND_OR_8,
+BUILT_IN_SYNC_FETCH_AND_OR_16,
+BUILT_IN_SYNC_FETCH_AND_AND_N,
+BUILT_IN_SYNC_FETCH_AND_AND_1,
+BUILT_IN_SYNC_FETCH_AND_AND_2,
+BUILT_IN_SYNC_FETCH_AND_AND_4,
+BUILT_IN_SYNC_FETCH_AND_AND_8,
+BUILT_IN_SYNC_FETCH_AND_AND_16,
+BUILT_IN_SYNC_FETCH_AND_XOR_N,
+BUILT_IN_SYNC_FETCH_AND_XOR_1,
+BUILT_IN_SYNC_FETCH_AND_XOR_2,
+BUILT_IN_SYNC_FETCH_AND_XOR_4,
+BUILT_IN_SYNC_FETCH_AND_XOR_8,
+BUILT_IN_SYNC_FETCH_AND_XOR_16,
+BUILT_IN_SYNC_FETCH_AND_NAND_N,
+BUILT_IN_SYNC_FETCH_AND_NAND_1,
+BUILT_IN_SYNC_FETCH_AND_NAND_2,
+BUILT_IN_SYNC_FETCH_AND_NAND_4,
+BUILT_IN_SYNC_FETCH_AND_NAND_8,
+BUILT_IN_SYNC_FETCH_AND_NAND_16,
+BUILT_IN_SYNC_ADD_AND_FETCH_N,
+BUILT_IN_SYNC_ADD_AND_FETCH_1,
+BUILT_IN_SYNC_ADD_AND_FETCH_2,
+BUILT_IN_SYNC_ADD_AND_FETCH_4,
+BUILT_IN_SYNC_ADD_AND_FETCH_8,
+BUILT_IN_SYNC_ADD_AND_FETCH_16,
+BUILT_IN_SYNC_SUB_AND_FETCH_N,
+BUILT_IN_SYNC_SUB_AND_FETCH_1,
+BUILT_IN_SYNC_SUB_AND_FETCH_2,
+BUILT_IN_SYNC_SUB_AND_FETCH_4,
+BUILT_IN_SYNC_SUB_AND_FETCH_8,
+BUILT_IN_SYNC_SUB_AND_FETCH_16,
+BUILT_IN_SYNC_OR_AND_FETCH_N,
+BUILT_IN_SYNC_OR_AND_FETCH_1,
+BUILT_IN_SYNC_OR_AND_FETCH_2,
+BUILT_IN_SYNC_OR_AND_FETCH_4,
+BUILT_IN_SYNC_OR_AND_FETCH_8,
+BUILT_IN_SYNC_OR_AND_FETCH_16,
+BUILT_IN_SYNC_AND_AND_FETCH_N,
+BUILT_IN_SYNC_AND_AND_FETCH_1,
+BUILT_IN_SYNC_AND_AND_FETCH_2,
+BUILT_IN_SYNC_AND_AND_FETCH_4,
+BUILT_IN_SYNC_AND_AND_FETCH_8,
+BUILT_IN_SYNC_AND_AND_FETCH_16,
+BUILT_IN_SYNC_XOR_AND_FETCH_N,
+BUILT_IN_SYNC_XOR_AND_FETCH_1,
+BUILT_IN_SYNC_XOR_AND_FETCH_2,
+BUILT_IN_SYNC_XOR_AND_FETCH_4,
+BUILT_IN_SYNC_XOR_AND_FETCH_8,
+BUILT_IN_SYNC_XOR_AND_FETCH_16,
+BUILT_IN_SYNC_NAND_AND_FETCH_N,
+BUILT_IN_SYNC_NAND_AND_FETCH_1,
+BUILT_IN_SYNC_NAND_AND_FETCH_2,
+BUILT_IN_SYNC_NAND_AND_FETCH_4,
+BUILT_IN_SYNC_NAND_AND_FETCH_8,
+BUILT_IN_SYNC_NAND_AND_FETCH_16,
+BUILT_IN_SYNC_BOOL_COMPARE_AND_SWAP_N,
+BUILT_IN_SYNC_BOOL_COMPARE_AND_SWAP_1,
+BUILT_IN_SYNC_BOOL_COMPARE_AND_SWAP_2,
+BUILT_IN_SYNC_BOOL_COMPARE_AND_SWAP_4,
+BUILT_IN_SYNC_BOOL_COMPARE_AND_SWAP_8,
+BUILT_IN_SYNC_BOOL_COMPARE_AND_SWAP_16,
+BUILT_IN_SYNC_VAL_COMPARE_AND_SWAP_N,
+BUILT_IN_SYNC_VAL_COMPARE_AND_SWAP_1,
+BUILT_IN_SYNC_VAL_COMPARE_AND_SWAP_2,
+BUILT_IN_SYNC_VAL_COMPARE_AND_SWAP_4,
+BUILT_IN_SYNC_VAL_COMPARE_AND_SWAP_8,
+BUILT_IN_SYNC_VAL_COMPARE_AND_SWAP_16,
+BUILT_IN_SYNC_LOCK_TEST_AND_SET_N,
+BUILT_IN_SYNC_LOCK_TEST_AND_SET_1,
+BUILT_IN_SYNC_LOCK_TEST_AND_SET_2,
+BUILT_IN_SYNC_LOCK_TEST_AND_SET_4,
+BUILT_IN_SYNC_LOCK_TEST_AND_SET_8,
+BUILT_IN_SYNC_LOCK_TEST_AND_SET_16,
+BUILT_IN_SYNC_LOCK_RELEASE_N,
+BUILT_IN_SYNC_LOCK_RELEASE_1,
+BUILT_IN_SYNC_LOCK_RELEASE_2,
+BUILT_IN_SYNC_LOCK_RELEASE_4,
+BUILT_IN_SYNC_LOCK_RELEASE_8,
+BUILT_IN_SYNC_LOCK_RELEASE_16,
+BUILT_IN_SYNC_SYNCHRONIZE,
+BUILT_IN_ATOMIC_TEST_AND_SET,
+BUILT_IN_ATOMIC_CLEAR,
+BUILT_IN_ATOMIC_EXCHANGE,
+BUILT_IN_ATOMIC_EXCHANGE_N,
+BUILT_IN_ATOMIC_EXCHANGE_1,
+BUILT_IN_ATOMIC_EXCHANGE_2,
+BUILT_IN_ATOMIC_EXCHANGE_4,
+BUILT_IN_ATOMIC_EXCHANGE_8,
+BUILT_IN_ATOMIC_EXCHANGE_16,
+BUILT_IN_ATOMIC_LOAD,
+BUILT_IN_ATOMIC_LOAD_N,
+BUILT_IN_ATOMIC_LOAD_1,
+BUILT_IN_ATOMIC_LOAD_2,
+BUILT_IN_ATOMIC_LOAD_4,
+BUILT_IN_ATOMIC_LOAD_8,
+BUILT_IN_ATOMIC_LOAD_16,
+BUILT_IN_ATOMIC_COMPARE_EXCHANGE,
+BUILT_IN_ATOMIC_COMPARE_EXCHANGE_N,
+BUILT_IN_ATOMIC_COMPARE_EXCHANGE_1,
+BUILT_IN_ATOMIC_COMPARE_EXCHANGE_2,
+BUILT_IN_ATOMIC_COMPARE_EXCHANGE_4,
+BUILT_IN_ATOMIC_COMPARE_EXCHANGE_8,
+BUILT_IN_ATOMIC_COMPARE_EXCHANGE_16,
+BUILT_IN_ATOMIC_STORE,
+BUILT_IN_ATOMIC_STORE_N,
+BUILT_IN_ATOMIC_STORE_1,
+BUILT_IN_ATOMIC_STORE_2,
+BUILT_IN_ATOMIC_STORE_4,
+BUILT_IN_ATOMIC_STORE_8,
+BUILT_IN_ATOMIC_STORE_16,
+BUILT_IN_ATOMIC_ADD_FETCH_N,
+BUILT_IN_ATOMIC_ADD_FETCH_1,
+BUILT_IN_ATOMIC_ADD_FETCH_2,
+BUILT_IN_ATOMIC_ADD_FETCH_4,
+BUILT_IN_ATOMIC_ADD_FETCH_8,
+BUILT_IN_ATOMIC_ADD_FETCH_16,
+BUILT_IN_ATOMIC_SUB_FETCH_N,
+BUILT_IN_ATOMIC_SUB_FETCH_1,
+BUILT_IN_ATOMIC_SUB_FETCH_2,
+BUILT_IN_ATOMIC_SUB_FETCH_4,
+BUILT_IN_ATOMIC_SUB_FETCH_8,
+BUILT_IN_ATOMIC_SUB_FETCH_16,
+BUILT_IN_ATOMIC_AND_FETCH_N,
+BUILT_IN_ATOMIC_AND_FETCH_1,
+BUILT_IN_ATOMIC_AND_FETCH_2,
+BUILT_IN_ATOMIC_AND_FETCH_4,
+BUILT_IN_ATOMIC_AND_FETCH_8,
+BUILT_IN_ATOMIC_AND_FETCH_16,
+BUILT_IN_ATOMIC_NAND_FETCH_N,
+BUILT_IN_ATOMIC_NAND_FETCH_1,
+BUILT_IN_ATOMIC_NAND_FETCH_2,
+BUILT_IN_ATOMIC_NAND_FETCH_4,
+BUILT_IN_ATOMIC_NAND_FETCH_8,
+BUILT_IN_ATOMIC_NAND_FETCH_16,
+BUILT_IN_ATOMIC_XOR_FETCH_N,
+BUILT_IN_ATOMIC_XOR_FETCH_1,
+BUILT_IN_ATOMIC_XOR_FETCH_2,
+BUILT_IN_ATOMIC_XOR_FETCH_4,
+BUILT_IN_ATOMIC_XOR_FETCH_8,
+BUILT_IN_ATOMIC_XOR_FETCH_16,
+BUILT_IN_ATOMIC_OR_FETCH_N,
+BUILT_IN_ATOMIC_OR_FETCH_1,
+BUILT_IN_ATOMIC_OR_FETCH_2,
+BUILT_IN_ATOMIC_OR_FETCH_4,
+BUILT_IN_ATOMIC_OR_FETCH_8,
+BUILT_IN_ATOMIC_OR_FETCH_16,
+BUILT_IN_ATOMIC_FETCH_ADD_N,
+BUILT_IN_ATOMIC_FETCH_ADD_1,
+BUILT_IN_ATOMIC_FETCH_ADD_2,
+BUILT_IN_ATOMIC_FETCH_ADD_4,
+BUILT_IN_ATOMIC_FETCH_ADD_8,
+BUILT_IN_ATOMIC_FETCH_ADD_16,
+BUILT_IN_ATOMIC_FETCH_SUB_N,
+BUILT_IN_ATOMIC_FETCH_SUB_1,
+BUILT_IN_ATOMIC_FETCH_SUB_2,
+BUILT_IN_ATOMIC_FETCH_SUB_4,
+BUILT_IN_ATOMIC_FETCH_SUB_8,
+BUILT_IN_ATOMIC_FETCH_SUB_16,
+BUILT_IN_ATOMIC_FETCH_AND_N,
+BUILT_IN_ATOMIC_FETCH_AND_1,
+BUILT_IN_ATOMIC_FETCH_AND_2,
+BUILT_IN_ATOMIC_FETCH_AND_4,
+BUILT_IN_ATOMIC_FETCH_AND_8,
+BUILT_IN_ATOMIC_FETCH_AND_16,
+BUILT_IN_ATOMIC_FETCH_NAND_N,
+BUILT_IN_ATOMIC_FETCH_NAND_1,
+BUILT_IN_ATOMIC_FETCH_NAND_2,
+BUILT_IN_ATOMIC_FETCH_NAND_4,
+BUILT_IN_ATOMIC_FETCH_NAND_8,
+BUILT_IN_ATOMIC_FETCH_NAND_16,
+BUILT_IN_ATOMIC_FETCH_XOR_N,
+BUILT_IN_ATOMIC_FETCH_XOR_1,
+BUILT_IN_ATOMIC_FETCH_XOR_2,
+BUILT_IN_ATOMIC_FETCH_XOR_4,
+BUILT_IN_ATOMIC_FETCH_XOR_8,
+BUILT_IN_ATOMIC_FETCH_XOR_16,
+BUILT_IN_ATOMIC_FETCH_OR_N,
+BUILT_IN_ATOMIC_FETCH_OR_1,
+BUILT_IN_ATOMIC_FETCH_OR_2,
+BUILT_IN_ATOMIC_FETCH_OR_4,
+BUILT_IN_ATOMIC_FETCH_OR_8,
+BUILT_IN_ATOMIC_FETCH_OR_16,
+BUILT_IN_ATOMIC_ALWAYS_LOCK_FREE,
+BUILT_IN_ATOMIC_IS_LOCK_FREE,
+BUILT_IN_ATOMIC_THREAD_FENCE,
+BUILT_IN_ATOMIC_SIGNAL_FENCE,
+BUILT_IN_OMP_GET_THREAD_NUM,
+BUILT_IN_OMP_GET_NUM_THREADS,
+BUILT_IN_GOMP_ATOMIC_START,
+BUILT_IN_GOMP_ATOMIC_END,
+BUILT_IN_GOMP_BARRIER,
+BUILT_IN_GOMP_TASKWAIT,
+BUILT_IN_GOMP_TASKYIELD,
+BUILT_IN_GOMP_CRITICAL_START,
+BUILT_IN_GOMP_CRITICAL_END,
+BUILT_IN_GOMP_CRITICAL_NAME_START,
+BUILT_IN_GOMP_CRITICAL_NAME_END,
+BUILT_IN_GOMP_LOOP_STATIC_START,
+BUILT_IN_GOMP_LOOP_DYNAMIC_START,
+BUILT_IN_GOMP_LOOP_GUIDED_START,
+BUILT_IN_GOMP_LOOP_RUNTIME_START,
+BUILT_IN_GOMP_LOOP_ORDERED_STATIC_START,
+BUILT_IN_GOMP_LOOP_ORDERED_DYNAMIC_START,
+BUILT_IN_GOMP_LOOP_ORDERED_GUIDED_START,
+BUILT_IN_GOMP_LOOP_ORDERED_RUNTIME_START,
+BUILT_IN_GOMP_LOOP_STATIC_NEXT,
+BUILT_IN_GOMP_LOOP_DYNAMIC_NEXT,
+BUILT_IN_GOMP_LOOP_GUIDED_NEXT,
+BUILT_IN_GOMP_LOOP_RUNTIME_NEXT,
+BUILT_IN_GOMP_LOOP_ORDERED_STATIC_NEXT,
+BUILT_IN_GOMP_LOOP_ORDERED_DYNAMIC_NEXT,
+BUILT_IN_GOMP_LOOP_ORDERED_GUIDED_NEXT,
+BUILT_IN_GOMP_LOOP_ORDERED_RUNTIME_NEXT,
+BUILT_IN_GOMP_LOOP_ULL_STATIC_START,
+BUILT_IN_GOMP_LOOP_ULL_DYNAMIC_START,
+BUILT_IN_GOMP_LOOP_ULL_GUIDED_START,
+BUILT_IN_GOMP_LOOP_ULL_RUNTIME_START,
+BUILT_IN_GOMP_LOOP_ULL_ORDERED_STATIC_START,
+BUILT_IN_GOMP_LOOP_ULL_ORDERED_DYNAMIC_START,
+BUILT_IN_GOMP_LOOP_ULL_ORDERED_GUIDED_START,
+BUILT_IN_GOMP_LOOP_ULL_ORDERED_RUNTIME_START,
+BUILT_IN_GOMP_LOOP_ULL_STATIC_NEXT,
+BUILT_IN_GOMP_LOOP_ULL_DYNAMIC_NEXT,
+BUILT_IN_GOMP_LOOP_ULL_GUIDED_NEXT,
+BUILT_IN_GOMP_LOOP_ULL_RUNTIME_NEXT,
+BUILT_IN_GOMP_LOOP_ULL_ORDERED_STATIC_NEXT,
+BUILT_IN_GOMP_LOOP_ULL_ORDERED_DYNAMIC_NEXT,
+BUILT_IN_GOMP_LOOP_ULL_ORDERED_GUIDED_NEXT,
+BUILT_IN_GOMP_LOOP_ULL_ORDERED_RUNTIME_NEXT,
+BUILT_IN_GOMP_PARALLEL_LOOP_STATIC_START,
+BUILT_IN_GOMP_PARALLEL_LOOP_DYNAMIC_START,
+BUILT_IN_GOMP_PARALLEL_LOOP_GUIDED_START,
+BUILT_IN_GOMP_PARALLEL_LOOP_RUNTIME_START,
+BUILT_IN_GOMP_LOOP_END,
+BUILT_IN_GOMP_LOOP_END_NOWAIT,
+BUILT_IN_GOMP_ORDERED_START,
+BUILT_IN_GOMP_ORDERED_END,
+BUILT_IN_GOMP_PARALLEL_START,
+BUILT_IN_GOMP_PARALLEL_END,
+BUILT_IN_GOMP_TASK,
+BUILT_IN_GOMP_SECTIONS_START,
+BUILT_IN_GOMP_SECTIONS_NEXT,
+BUILT_IN_GOMP_PARALLEL_SECTIONS_START,
+BUILT_IN_GOMP_SECTIONS_END,
+BUILT_IN_GOMP_SECTIONS_END_NOWAIT,
+BUILT_IN_GOMP_SINGLE_START,
+BUILT_IN_GOMP_SINGLE_COPY_START,
+BUILT_IN_GOMP_SINGLE_COPY_END,
+BUILT_IN_TM_START,
+BUILT_IN_TM_COMMIT,
+BUILT_IN_TM_COMMIT_EH,
+BUILT_IN_TM_ABORT,
+BUILT_IN_TM_IRREVOCABLE,
+BUILT_IN_TM_MEMCPY,
+BUILT_IN_TM_MEMMOVE,
+BUILT_IN_TM_MEMSET,
+BUILT_IN_TM_GETTMCLONE_IRR,
+BUILT_IN_TM_GETTMCLONE_SAFE,
+BUILT_IN_TM_MALLOC,
+BUILT_IN_TM_CALLOC,
+BUILT_IN_TM_FREE,
+BUILT_IN_TM_LOG_1,
+BUILT_IN_TM_LOG_2,
+BUILT_IN_TM_LOG_4,
+BUILT_IN_TM_LOG_8,
+BUILT_IN_TM_LOG_FLOAT,
+BUILT_IN_TM_LOG_DOUBLE,
+BUILT_IN_TM_LOG_LDOUBLE,
+BUILT_IN_TM_LOG,
+BUILT_IN_TM_LOG_M64,
+BUILT_IN_TM_LOG_M128,
+BUILT_IN_TM_LOG_M256,
+BUILT_IN_TM_STORE_1,
+BUILT_IN_TM_STORE_WAR_1,
+BUILT_IN_TM_STORE_WAW_1,
+BUILT_IN_TM_STORE_2,
+BUILT_IN_TM_STORE_WAR_2,
+BUILT_IN_TM_STORE_WAW_2,
+BUILT_IN_TM_STORE_4,
+BUILT_IN_TM_STORE_WAR_4,
+BUILT_IN_TM_STORE_WAW_4,
+BUILT_IN_TM_STORE_8,
+BUILT_IN_TM_STORE_WAR_8,
+BUILT_IN_TM_STORE_WAW_8,
+BUILT_IN_TM_STORE_FLOAT,
+BUILT_IN_TM_STORE_WAR_FLOAT,
+BUILT_IN_TM_STORE_WAW_FLOAT,
+BUILT_IN_TM_STORE_DOUBLE,
+BUILT_IN_TM_STORE_WAR_DOUBLE,
+BUILT_IN_TM_STORE_WAW_DOUBLE,
+BUILT_IN_TM_STORE_M64,
+BUILT_IN_TM_STORE_WAR_M64,
+BUILT_IN_TM_STORE_WAW_M64,
+BUILT_IN_TM_STORE_M128,
+BUILT_IN_TM_STORE_WAR_M128,
+BUILT_IN_TM_STORE_WAW_M128,
+BUILT_IN_TM_STORE_M256,
+BUILT_IN_TM_STORE_WAR_M256,
+BUILT_IN_TM_STORE_WAW_M256,
+BUILT_IN_TM_STORE_LDOUBLE,
+BUILT_IN_TM_STORE_WAR_LDOUBLE,
+BUILT_IN_TM_STORE_WAW_LDOUBLE,
+BUILT_IN_TM_LOAD_1,
+BUILT_IN_TM_LOAD_RAR_1,
+BUILT_IN_TM_LOAD_RAW_1,
+BUILT_IN_TM_LOAD_RFW_1,
+BUILT_IN_TM_LOAD_2,
+BUILT_IN_TM_LOAD_RAR_2,
+BUILT_IN_TM_LOAD_RAW_2,
+BUILT_IN_TM_LOAD_RFW_2,
+BUILT_IN_TM_LOAD_4,
+BUILT_IN_TM_LOAD_RAR_4,
+BUILT_IN_TM_LOAD_RAW_4,
+BUILT_IN_TM_LOAD_RFW_4,
+BUILT_IN_TM_LOAD_8,
+BUILT_IN_TM_LOAD_RAR_8,
+BUILT_IN_TM_LOAD_RAW_8,
+BUILT_IN_TM_LOAD_RFW_8,
+BUILT_IN_TM_LOAD_FLOAT,
+BUILT_IN_TM_LOAD_RAR_FLOAT,
+BUILT_IN_TM_LOAD_RAW_FLOAT,
+BUILT_IN_TM_LOAD_RFW_FLOAT,
+BUILT_IN_TM_LOAD_DOUBLE,
+BUILT_IN_TM_LOAD_RAR_DOUBLE,
+BUILT_IN_TM_LOAD_RAW_DOUBLE,
+BUILT_IN_TM_LOAD_RFW_DOUBLE,
+BUILT_IN_TM_LOAD_M64,
+BUILT_IN_TM_LOAD_RAR_M64,
+BUILT_IN_TM_LOAD_RAW_M64,
+BUILT_IN_TM_LOAD_RFW_M64,
+BUILT_IN_TM_LOAD_M128,
+BUILT_IN_TM_LOAD_RAR_M128,
+BUILT_IN_TM_LOAD_RAW_M128,
+BUILT_IN_TM_LOAD_RFW_M128,
+BUILT_IN_TM_LOAD_M256,
+BUILT_IN_TM_LOAD_RAR_M256,
+BUILT_IN_TM_LOAD_RAW_M256,
+BUILT_IN_TM_LOAD_RFW_M256,
+BUILT_IN_TM_LOAD_LDOUBLE,
+BUILT_IN_TM_LOAD_RAR_LDOUBLE,
+BUILT_IN_TM_LOAD_RAW_LDOUBLE,
+BUILT_IN_TM_LOAD_RFW_LDOUBLE,
+BUILT_IN_ASAN_INIT,
+BUILT_IN_ASAN_REPORT_LOAD1,
+BUILT_IN_ASAN_REPORT_LOAD2,
+BUILT_IN_ASAN_REPORT_LOAD4,
+BUILT_IN_ASAN_REPORT_LOAD8,
+BUILT_IN_ASAN_REPORT_LOAD16,
+BUILT_IN_ASAN_REPORT_STORE1,
+BUILT_IN_ASAN_REPORT_STORE2,
+BUILT_IN_ASAN_REPORT_STORE4,
+BUILT_IN_ASAN_REPORT_STORE8,
+BUILT_IN_ASAN_REPORT_STORE16,
+BUILT_IN_ASAN_REGISTER_GLOBALS,
+BUILT_IN_ASAN_UNREGISTER_GLOBALS,
+BUILT_IN_ASAN_HANDLE_NO_RETURN,
+BUILT_IN_TSAN_INIT,
+BUILT_IN_TSAN_FUNC_ENTRY,
+BUILT_IN_TSAN_FUNC_EXIT,
+BUILT_IN_TSAN_VPTR_UPDATE,
+BUILT_IN_TSAN_READ1,
+BUILT_IN_TSAN_READ2,
+BUILT_IN_TSAN_READ4,
+BUILT_IN_TSAN_READ8,
+BUILT_IN_TSAN_READ16,
+BUILT_IN_TSAN_WRITE1,
+BUILT_IN_TSAN_WRITE2,
+BUILT_IN_TSAN_WRITE4,
+BUILT_IN_TSAN_WRITE8,
+BUILT_IN_TSAN_WRITE16,
+BUILT_IN_TSAN_ATOMIC8_LOAD,
+BUILT_IN_TSAN_ATOMIC16_LOAD,
+BUILT_IN_TSAN_ATOMIC32_LOAD,
+BUILT_IN_TSAN_ATOMIC64_LOAD,
+BUILT_IN_TSAN_ATOMIC128_LOAD,
+BUILT_IN_TSAN_ATOMIC8_STORE,
+BUILT_IN_TSAN_ATOMIC16_STORE,
+BUILT_IN_TSAN_ATOMIC32_STORE,
+BUILT_IN_TSAN_ATOMIC64_STORE,
+BUILT_IN_TSAN_ATOMIC128_STORE,
+BUILT_IN_TSAN_ATOMIC8_EXCHANGE,
+BUILT_IN_TSAN_ATOMIC16_EXCHANGE,
+BUILT_IN_TSAN_ATOMIC32_EXCHANGE,
+BUILT_IN_TSAN_ATOMIC64_EXCHANGE,
+BUILT_IN_TSAN_ATOMIC128_EXCHANGE,
+BUILT_IN_TSAN_ATOMIC8_FETCH_ADD,
+BUILT_IN_TSAN_ATOMIC16_FETCH_ADD,
+BUILT_IN_TSAN_ATOMIC32_FETCH_ADD,
+BUILT_IN_TSAN_ATOMIC64_FETCH_ADD,
+BUILT_IN_TSAN_ATOMIC128_FETCH_ADD,
+BUILT_IN_TSAN_ATOMIC8_FETCH_SUB,
+BUILT_IN_TSAN_ATOMIC16_FETCH_SUB,
+BUILT_IN_TSAN_ATOMIC32_FETCH_SUB,
+BUILT_IN_TSAN_ATOMIC64_FETCH_SUB,
+BUILT_IN_TSAN_ATOMIC128_FETCH_SUB,
+BUILT_IN_TSAN_ATOMIC8_FETCH_AND,
+BUILT_IN_TSAN_ATOMIC16_FETCH_AND,
+BUILT_IN_TSAN_ATOMIC32_FETCH_AND,
+BUILT_IN_TSAN_ATOMIC64_FETCH_AND,
+BUILT_IN_TSAN_ATOMIC128_FETCH_AND,
+BUILT_IN_TSAN_ATOMIC8_FETCH_OR,
+BUILT_IN_TSAN_ATOMIC16_FETCH_OR,
+BUILT_IN_TSAN_ATOMIC32_FETCH_OR,
+BUILT_IN_TSAN_ATOMIC64_FETCH_OR,
+BUILT_IN_TSAN_ATOMIC128_FETCH_OR,
+BUILT_IN_TSAN_ATOMIC8_FETCH_XOR,
+BUILT_IN_TSAN_ATOMIC16_FETCH_XOR,
+BUILT_IN_TSAN_ATOMIC32_FETCH_XOR,
+BUILT_IN_TSAN_ATOMIC64_FETCH_XOR,
+BUILT_IN_TSAN_ATOMIC128_FETCH_XOR,
+BUILT_IN_TSAN_ATOMIC8_FETCH_NAND,
+BUILT_IN_TSAN_ATOMIC16_FETCH_NAND,
+BUILT_IN_TSAN_ATOMIC32_FETCH_NAND,
+BUILT_IN_TSAN_ATOMIC64_FETCH_NAND,
+BUILT_IN_TSAN_ATOMIC128_FETCH_NAND,
+BUILT_IN_TSAN_ATOMIC8_COMPARE_EXCHANGE_STRONG,
+BUILT_IN_TSAN_ATOMIC16_COMPARE_EXCHANGE_STRONG,
+BUILT_IN_TSAN_ATOMIC32_COMPARE_EXCHANGE_STRONG,
+BUILT_IN_TSAN_ATOMIC64_COMPARE_EXCHANGE_STRONG,
+BUILT_IN_TSAN_ATOMIC128_COMPARE_EXCHANGE_STRONG,
+BUILT_IN_TSAN_ATOMIC8_COMPARE_EXCHANGE_WEAK,
+BUILT_IN_TSAN_ATOMIC16_COMPARE_EXCHANGE_WEAK,
+BUILT_IN_TSAN_ATOMIC32_COMPARE_EXCHANGE_WEAK,
+BUILT_IN_TSAN_ATOMIC64_COMPARE_EXCHANGE_WEAK,
+BUILT_IN_TSAN_ATOMIC128_COMPARE_EXCHANGE_WEAK,
+BUILT_IN_TSAN_ATOMIC_THREAD_FENCE,
+BUILT_IN_TSAN_ATOMIC_SIGNAL_FENCE,
+  BUILT_IN_COMPLEX_MUL_MIN,
+  BUILT_IN_COMPLEX_MUL_MAX
+    = BUILT_IN_COMPLEX_MUL_MIN
+      + MAX_MODE_COMPLEX_FLOAT
+      - MIN_MODE_COMPLEX_FLOAT,
+  BUILT_IN_COMPLEX_DIV_MIN,
+  BUILT_IN_COMPLEX_DIV_MAX
+    = BUILT_IN_COMPLEX_DIV_MIN
+      + MAX_MODE_COMPLEX_FLOAT
+      - MIN_MODE_COMPLEX_FLOAT,
+  END_BUILTINS
+};
+extern const char * built_in_names[(int) END_BUILTINS];
+extern unsigned const char omp_clause_num_ops[];
+extern const char * const omp_clause_code_name[];
+enum omp_clause_code
+{
+  OMP_CLAUSE_ERROR = 0,
+  OMP_CLAUSE_PRIVATE,
+  OMP_CLAUSE_SHARED,
+  OMP_CLAUSE_FIRSTPRIVATE,
+  OMP_CLAUSE_LASTPRIVATE,
+  OMP_CLAUSE_REDUCTION,
+  OMP_CLAUSE_COPYIN,
+  OMP_CLAUSE_COPYPRIVATE,
+  OMP_CLAUSE_IF,
+  OMP_CLAUSE_NUM_THREADS,
+  OMP_CLAUSE_SCHEDULE,
+  OMP_CLAUSE_NOWAIT,
+  OMP_CLAUSE_ORDERED,
+  OMP_CLAUSE_DEFAULT,
+  OMP_CLAUSE_COLLAPSE,
+  OMP_CLAUSE_UNTIED,
+  OMP_CLAUSE_FINAL,
+  OMP_CLAUSE_MERGEABLE
+};
+struct tree_base {
+  enum tree_code code : 16;
+  unsigned side_effects_flag : 1;
+  unsigned constant_flag : 1;
+  unsigned addressable_flag : 1;
+  unsigned volatile_flag : 1;
+  unsigned readonly_flag : 1;
+  unsigned asm_written_flag: 1;
+  unsigned nowarning_flag : 1;
+  unsigned visited : 1;
+  unsigned used_flag : 1;
+  unsigned nothrow_flag : 1;
+  unsigned static_flag : 1;
+  unsigned public_flag : 1;
+  unsigned private_flag : 1;
+  unsigned protected_flag : 1;
+  unsigned deprecated_flag : 1;
+  unsigned default_def_flag : 1;
+  union {
+    struct {
+      unsigned lang_flag_0 : 1;
+      unsigned lang_flag_1 : 1;
+      unsigned lang_flag_2 : 1;
+      unsigned lang_flag_3 : 1;
+      unsigned lang_flag_4 : 1;
+      unsigned lang_flag_5 : 1;
+      unsigned lang_flag_6 : 1;
+      unsigned saturating_flag : 1;
+      unsigned unsigned_flag : 1;
+      unsigned packed_flag : 1;
+      unsigned user_align : 1;
+      unsigned nameless_flag : 1;
+      unsigned spare0 : 4;
+      unsigned spare1 : 8;
+      unsigned address_space : 8;
+    } bits;
+    int length;
+    unsigned int version;
+  } u;
+};
+struct tree_typed {
+  struct tree_base base;
+  tree type;
+};
+struct tree_common {
+  struct tree_typed typed;
+  tree chain;
+};
+enum tree_node_structure_enum {
+TS_BASE,
+TS_TYPED,
+TS_COMMON,
+TS_INT_CST,
+TS_REAL_CST,
+TS_FIXED_CST,
+TS_VECTOR,
+TS_STRING,
+TS_COMPLEX,
+TS_IDENTIFIER,
+TS_DECL_MINIMAL,
+TS_DECL_COMMON,
+TS_DECL_WRTL,
+TS_DECL_NON_COMMON,
+TS_DECL_WITH_VIS,
+TS_FIELD_DECL,
+TS_VAR_DECL,
+TS_PARM_DECL,
+TS_LABEL_DECL,
+TS_RESULT_DECL,
+TS_CONST_DECL,
+TS_TYPE_DECL,
+TS_FUNCTION_DECL,
+TS_TRANSLATION_UNIT_DECL,
+TS_TYPE_COMMON,
+TS_TYPE_WITH_LANG_SPECIFIC,
+TS_TYPE_NON_COMMON,
+TS_LIST,
+TS_VEC,
+TS_EXP,
+TS_SSA_NAME,
+TS_BLOCK,
+TS_BINFO,
+TS_STATEMENT_LIST,
+TS_CONSTRUCTOR,
+TS_OMP_CLAUSE,
+TS_OPTIMIZATION,
+TS_TARGET_OPTION,
+  LAST_TS_ENUM
+};
+struct tree_int_cst {
+  struct tree_typed typed;
+  double_int int_cst;
+};
+struct real_value;
+struct tree_real_cst {
+  struct tree_typed typed;
+  struct real_value * real_cst_ptr;
+};
+struct fixed_value;
+struct tree_fixed_cst {
+  struct tree_typed typed;
+  struct fixed_value * fixed_cst_ptr;
+};
+struct tree_string {
+  struct tree_typed typed;
+  int length;
+  char str[1];
+};
+struct tree_complex {
+  struct tree_typed typed;
+  tree real;
+  tree imag;
+};
+struct tree_vector {
+  struct tree_typed typed;
+  tree elts[1];
+};
+extern "C" {
+struct _obstack_chunk
+{
+  char *limit;
+  struct _obstack_chunk *prev;
+  char contents[4];
+};
+struct obstack
+{
+  long chunk_size;
+  struct _obstack_chunk *chunk;
+  char *object_base;
+  char *next_free;
+  char *chunk_limit;
+  int temp;
+  int alignment_mask;
+  struct _obstack_chunk *(*chunkfun) (void *, long);
+  void (*freefun) (void *, struct _obstack_chunk *);
+  void *extra_arg;
+  unsigned use_extra_arg:1;
+  unsigned maybe_empty_object:1;
+  unsigned alloc_failed:1;
+};
+extern void _obstack_newchunk (struct obstack *, int);
+extern void _obstack_free (struct obstack *, void *);
+extern int _obstack_begin (struct obstack *, int, int,
+       void *(*) (long), void (*) (void *));
+extern int _obstack_begin_1 (struct obstack *, int, int,
+        void *(*) (void *, long),
+        void (*) (void *, void *), void *);
+extern int _obstack_memory_used (struct obstack *);
+void obstack_init (struct obstack *obstack);
+void * obstack_alloc (struct obstack *obstack, int size);
+void * obstack_copy (struct obstack *obstack, void *address, int size);
+void * obstack_copy0 (struct obstack *obstack, void *address, int size);
+void obstack_free (struct obstack *obstack, void *block);
+void obstack_blank (struct obstack *obstack, int size);
+void obstack_grow (struct obstack *obstack, void *data, int size);
+void obstack_grow0 (struct obstack *obstack, void *data, int size);
+void obstack_1grow (struct obstack *obstack, int data_char);
+void obstack_ptr_grow (struct obstack *obstack, void *data);
+void obstack_int_grow (struct obstack *obstack, int data);
+void * obstack_finish (struct obstack *obstack);
+int obstack_object_size (struct obstack *obstack);
+int obstack_room (struct obstack *obstack);
+void obstack_make_room (struct obstack *obstack, int size);
+void obstack_1grow_fast (struct obstack *obstack, int data_char);
+void obstack_ptr_grow_fast (struct obstack *obstack, void *data);
+void obstack_int_grow_fast (struct obstack *obstack, int data);
+void obstack_blank_fast (struct obstack *obstack, int size);
+void * obstack_base (struct obstack *obstack);
+void * obstack_next_free (struct obstack *obstack);
+int obstack_alignment_mask (struct obstack *obstack);
+int obstack_chunk_size (struct obstack *obstack);
+int obstack_memory_used (struct obstack *obstack);
+extern void (*obstack_alloc_failed_handler) (void);
+extern int obstack_exit_failure;
+}
+typedef struct ht_identifier ht_identifier;
+typedef struct ht_identifier *ht_identifier_ptr;
+struct ht_identifier {
+  const unsigned char *str;
+  unsigned int len;
+  unsigned int hash_value;
+};
+typedef struct ht cpp_hash_table;
+typedef struct ht_identifier *hashnode;
+enum ht_lookup_option {HT_NO_INSERT = 0, HT_ALLOC};
+struct ht
+{
+  struct obstack stack;
+  hashnode *entries;
+  hashnode (*alloc_node) (cpp_hash_table *);
+  void * (*alloc_subobject) (size_t);
+  unsigned int nslots;
+  unsigned int nelements;
+  struct cpp_reader *pfile;
+  unsigned int searches;
+  unsigned int collisions;
+  bool entries_owned;
+};
+extern cpp_hash_table *ht_create (unsigned int order);
+extern void ht_destroy (cpp_hash_table *);
+extern hashnode ht_lookup (cpp_hash_table *, const unsigned char *,
+      size_t, enum ht_lookup_option);
+extern hashnode ht_lookup_with_hash (cpp_hash_table *, const unsigned char *,
+                                     size_t, unsigned int,
+                                     enum ht_lookup_option);
+typedef int (*ht_cb) (struct cpp_reader *, hashnode, const void *);
+extern void ht_forall (cpp_hash_table *, ht_cb, const void *);
+extern void ht_purge (cpp_hash_table *, ht_cb, const void *);
+extern void ht_load (cpp_hash_table *ht, hashnode *entries,
+       unsigned int nslots, unsigned int nelements, bool own);
+extern void ht_dump_statistics (cpp_hash_table *);
+struct tree_identifier {
+  struct tree_common common;
+  struct ht_identifier id;
+};
+struct tree_list {
+  struct tree_common common;
+  tree purpose;
+  tree value;
+};
+struct tree_vec {
+  struct tree_common common;
+  tree a[1];
+};
+typedef struct constructor_elt_d {
+  tree index;
+  tree value;
+} constructor_elt;
+struct tree_constructor {
+  struct tree_typed typed;
+  vec<constructor_elt, va_gc> *elts;
+};
+extern void protected_set_expr_location (tree, location_t);
+enum omp_clause_schedule_kind
+{
+  OMP_CLAUSE_SCHEDULE_STATIC,
+  OMP_CLAUSE_SCHEDULE_DYNAMIC,
+  OMP_CLAUSE_SCHEDULE_GUIDED,
+  OMP_CLAUSE_SCHEDULE_AUTO,
+  OMP_CLAUSE_SCHEDULE_RUNTIME
+};
+enum omp_clause_default_kind
+{
+  OMP_CLAUSE_DEFAULT_UNSPECIFIED,
+  OMP_CLAUSE_DEFAULT_SHARED,
+  OMP_CLAUSE_DEFAULT_NONE,
+  OMP_CLAUSE_DEFAULT_PRIVATE,
+  OMP_CLAUSE_DEFAULT_FIRSTPRIVATE
+};
+struct tree_exp {
+  struct tree_typed typed;
+  location_t locus;
+  tree
+    operands[1];
+};
+struct ptr_info_def;
+typedef struct ssa_use_operand_d {
+  struct ssa_use_operand_d* prev;
+  struct ssa_use_operand_d* next;
+  union { gimple stmt; tree ssa_name; } loc;
+  tree * use;
+} ssa_use_operand_t;
+struct tree_ssa_name {
+  struct tree_typed typed;
+  tree var;
+  gimple def_stmt;
+  struct ptr_info_def *ptr_info;
+  struct ssa_use_operand_d imm_uses;
+};
+struct phi_arg_d {
+  struct ssa_use_operand_d imm_use;
+  tree def;
+  location_t locus;
+};
+struct tree_omp_clause {
+  struct tree_common common;
+  location_t locus;
+  enum omp_clause_code code;
+  union omp_clause_subcode {
+    enum omp_clause_default_kind default_kind;
+    enum omp_clause_schedule_kind schedule_kind;
+    enum tree_code reduction_code;
+  } subcode;
+  gimple_seq gimple_reduction_init;
+  gimple_seq gimple_reduction_merge;
+  tree ops[1];
+};
+struct tree_block {
+  struct tree_base base;
+  tree chain;
+  unsigned abstract_flag : 1;
+  unsigned block_num : 31;
+  location_t locus;
+  tree vars;
+  vec<tree, va_gc> *nonlocalized_vars;
+  tree subblocks;
+  tree supercontext;
+  tree abstract_origin;
+  tree fragment_origin;
+  tree fragment_chain;
+};
+extern enum machine_mode vector_type_mode (const_tree);
+enum cv_qualifier
+  {
+    TYPE_UNQUALIFIED = 0x0,
+    TYPE_QUAL_CONST = 0x1,
+    TYPE_QUAL_VOLATILE = 0x2,
+    TYPE_QUAL_RESTRICT = 0x4
+  };
+struct die_struct;
+struct tree_type_common {
+  struct tree_common common;
+  tree size;
+  tree size_unit;
+  tree attributes;
+  unsigned int uid;
+  unsigned int precision : 10;
+  unsigned no_force_blk_flag : 1;
+  unsigned needs_constructing_flag : 1;
+  unsigned transparent_aggr_flag : 1;
+  unsigned restrict_flag : 1;
+  unsigned contains_placeholder_bits : 2;
+  enum machine_mode mode : 8;
+  unsigned string_flag : 1;
+  unsigned lang_flag_0 : 1;
+  unsigned lang_flag_1 : 1;
+  unsigned lang_flag_2 : 1;
+  unsigned lang_flag_3 : 1;
+  unsigned lang_flag_4 : 1;
+  unsigned lang_flag_5 : 1;
+  unsigned lang_flag_6 : 1;
+  unsigned int align;
+  alias_set_type alias_set;
+  tree pointer_to;
+  tree reference_to;
+  union tree_type_symtab {
+    int address;
+    const char * pointer;
+    struct die_struct * die;
+  } symtab;
+  tree name;
+  tree next_variant;
+  tree main_variant;
+  tree context;
+  tree canonical;
+};
+struct tree_type_with_lang_specific {
+  struct tree_type_common common;
+  struct lang_type *lang_specific;
+};
+struct tree_type_non_common {
+  struct tree_type_with_lang_specific with_lang_specific;
+  tree values;
+  tree minval;
+  tree maxval;
+  tree binfo;
+};
+struct tree_binfo {
+  struct tree_common common;
+  tree offset;
+  tree vtable;
+  tree virtuals;
+  tree vptr_field;
+  vec<tree, va_gc> *base_accesses;
+  tree inheritance;
+  tree vtt_subvtt;
+  tree vtt_vptr;
+  vec<tree, va_gc> base_binfos;
+};
+struct function;
+struct tree_decl_minimal {
+  struct tree_common common;
+  location_t locus;
+  unsigned int uid;
+  tree name;
+  tree context;
+};
+struct tree_decl_common {
+  struct tree_decl_minimal common;
+  tree size;
+  enum machine_mode mode : 8;
+  unsigned nonlocal_flag : 1;
+  unsigned virtual_flag : 1;
+  unsigned ignored_flag : 1;
+  unsigned abstract_flag : 1;
+  unsigned artificial_flag : 1;
+  unsigned preserve_flag: 1;
+  unsigned debug_expr_is_from : 1;
+  unsigned lang_flag_0 : 1;
+  unsigned lang_flag_1 : 1;
+  unsigned lang_flag_2 : 1;
+  unsigned lang_flag_3 : 1;
+  unsigned lang_flag_4 : 1;
+  unsigned lang_flag_5 : 1;
+  unsigned lang_flag_6 : 1;
+  unsigned lang_flag_7 : 1;
+  unsigned lang_flag_8 : 1;
+  unsigned decl_flag_0 : 1;
+  unsigned decl_flag_1 : 1;
+  unsigned decl_flag_2 : 1;
+  unsigned decl_flag_3 : 1;
+  unsigned gimple_reg_flag : 1;
+  unsigned decl_by_reference_flag : 1;
+  unsigned decl_read_flag : 1;
+  unsigned decl_nonshareable_flag : 1;
+  unsigned int off_align : 8;
+  unsigned int align;
+  unsigned int pt_uid;
+  tree size_unit;
+  tree initial;
+  tree attributes;
+  tree abstract_origin;
+  struct lang_decl *lang_specific;
+};
+extern tree decl_value_expr_lookup (tree);
+extern void decl_value_expr_insert (tree, tree);
+struct tree_decl_with_rtl {
+  struct tree_decl_common common;
+  rtx rtl;
+};
+struct tree_field_decl {
+  struct tree_decl_common common;
+  tree offset;
+  tree bit_field_type;
+  tree qualifier;
+  tree bit_offset;
+  tree fcontext;
+};
+struct tree_label_decl {
+  struct tree_decl_with_rtl common;
+  int label_decl_uid;
+  int eh_landing_pad_nr;
+};
+struct tree_result_decl {
+  struct tree_decl_with_rtl common;
+};
+struct tree_const_decl {
+  struct tree_decl_common common;
+};
+struct tree_parm_decl {
+  struct tree_decl_with_rtl common;
+  rtx incoming_rtl;
+};
+struct tree_decl_with_vis {
+ struct tree_decl_with_rtl common;
+ tree assembler_name;
+ tree section_name;
+ tree comdat_group;
+ unsigned defer_output : 1;
+ unsigned hard_register : 1;
+ unsigned common_flag : 1;
+ unsigned in_text_section : 1;
+ unsigned in_constant_pool : 1;
+ unsigned dllimport_flag : 1;
+ unsigned weak_flag : 1;
+ unsigned implicit_section_name_p : 1;
+ unsigned seen_in_bind_expr : 1;
+ unsigned comdat_flag : 1;
+ enum symbol_visibility visibility : 2;
+ unsigned visibility_specified : 1;
+ enum tls_model tls_model : 3;
+ unsigned init_priority_p : 1;
+ unsigned shadowed_for_var_p : 1;
+};
+extern tree decl_debug_expr_lookup (tree);
+extern void decl_debug_expr_insert (tree, tree);
+typedef unsigned short priority_type;
+extern priority_type decl_init_priority_lookup (tree);
+extern priority_type decl_fini_priority_lookup (tree);
+extern void decl_init_priority_insert (tree, priority_type);
+extern void decl_fini_priority_insert (tree, priority_type);
+struct tree_var_decl {
+  struct tree_decl_with_vis common;
+};
+struct
+ tree_decl_non_common {
+  struct tree_decl_with_vis common;
+  tree saved_tree;
+  tree arguments;
+  tree result;
+  tree vindex;
+};
+extern vec<tree, va_gc> **decl_debug_args_lookup (tree);
+extern vec<tree, va_gc> **decl_debug_args_insert (tree);
+struct tree_function_decl {
+  struct tree_decl_non_common common;
+  struct function *f;
+  tree personality;
+  tree function_specific_target;
+  tree function_specific_optimization;
+  enum built_in_function function_code : 11;
+  enum built_in_class built_in_class : 2;
+  unsigned static_ctor_flag : 1;
+  unsigned static_dtor_flag : 1;
+  unsigned uninlinable : 1;
+  unsigned possibly_inlined : 1;
+  unsigned novops_flag : 1;
+  unsigned returns_twice_flag : 1;
+  unsigned malloc_flag : 1;
+  unsigned operator_new_flag : 1;
+  unsigned declared_inline_flag : 1;
+  unsigned regdecl_flag : 1;
+  unsigned no_inline_warning_flag : 1;
+  unsigned no_instrument_function_entry_exit : 1;
+  unsigned no_limit_stack : 1;
+  unsigned disregard_inline_limits : 1;
+  unsigned pure_flag : 1;
+  unsigned looping_const_or_pure_flag : 1;
+  unsigned has_debug_args_flag : 1;
+  unsigned tm_clone_flag : 1;
+  unsigned versioned_function : 1;
+};
+struct tree_translation_unit_decl {
+  struct tree_decl_common common;
+  const char * language;
+};
+extern vec<tree, va_gc> *all_translation_units;
+struct tree_type_decl {
+  struct tree_decl_non_common common;
+};
+struct tree_statement_list_node
+ {
+  struct tree_statement_list_node *prev;
+  struct tree_statement_list_node *next;
+  tree stmt;
+};
+struct tree_statement_list
+ {
+  struct tree_typed typed;
+  struct tree_statement_list_node *head;
+  struct tree_statement_list_node *tail;
+};
+struct tree_optimization_option {
+  struct tree_common common;
+  struct cl_optimization opts;
+  unsigned char * optabs;
+  struct target_optabs * base_optabs;
+};
+extern tree build_optimization_node (void);
+extern void init_tree_optimization_optabs (tree);
+struct tree_target_option {
+  struct tree_common common;
+  struct cl_target_option opts;
+};
+extern tree build_target_option_node (void);
+union tree_node {
+  struct tree_base base;
+  struct tree_typed typed;
+  struct tree_common common;
+  struct tree_int_cst int_cst;
+  struct tree_real_cst real_cst;
+  struct tree_fixed_cst fixed_cst;
+  struct tree_vector vector;
+  struct tree_string string;
+  struct tree_complex complex;
+  struct tree_identifier identifier;
+  struct tree_decl_minimal decl_minimal;
+  struct tree_decl_common decl_common;
+  struct tree_decl_with_rtl decl_with_rtl;
+  struct tree_decl_non_common decl_non_common;
+  struct tree_parm_decl parm_decl;
+  struct tree_decl_with_vis decl_with_vis;
+  struct tree_var_decl var_decl;
+  struct tree_field_decl field_decl;
+  struct tree_label_decl label_decl;
+  struct tree_result_decl result_decl;
+  struct tree_const_decl const_decl;
+  struct tree_type_decl type_decl;
+  struct tree_function_decl function_decl;
+  struct tree_translation_unit_decl
+    translation_unit_decl;
+  struct tree_type_common type_common;
+  struct tree_type_with_lang_specific
+    type_with_lang_specific;
+  struct tree_type_non_common
+    type_non_common;
+  struct tree_list list;
+  struct tree_vec vec;
+  struct tree_exp exp;
+  struct tree_ssa_name ssa_name;
+  struct tree_block block;
+  struct tree_binfo binfo;
+  struct tree_statement_list stmt_list;
+  struct tree_constructor constructor;
+  struct tree_omp_clause omp_clause;
+  struct tree_optimization_option optimization;
+  struct tree_target_option target_option;
+};
+static inline int
+tree_operand_length (const_tree node)
+{
+  if ((tree_code_type[(int) (((enum tree_code) (node)->base.code))] == tcc_vl_exp))
+    return ((int)((((node)->exp.operands[0])->int_cst.int_cst).low));
+  else
+    return tree_code_length[(int) (((enum tree_code) (node)->base.code))];
+}
+enum tree_index
+{
+  TI_ERROR_MARK,
+  TI_INTQI_TYPE,
+  TI_INTHI_TYPE,
+  TI_INTSI_TYPE,
+  TI_INTDI_TYPE,
+  TI_INTTI_TYPE,
+  TI_UINTQI_TYPE,
+  TI_UINTHI_TYPE,
+  TI_UINTSI_TYPE,
+  TI_UINTDI_TYPE,
+  TI_UINTTI_TYPE,
+  TI_UINT16_TYPE,
+  TI_UINT32_TYPE,
+  TI_UINT64_TYPE,
+  TI_INTEGER_ZERO,
+  TI_INTEGER_ONE,
+  TI_INTEGER_THREE,
+  TI_INTEGER_MINUS_ONE,
+  TI_NULL_POINTER,
+  TI_SIZE_ZERO,
+  TI_SIZE_ONE,
+  TI_BITSIZE_ZERO,
+  TI_BITSIZE_ONE,
+  TI_BITSIZE_UNIT,
+  TI_PUBLIC,
+  TI_PROTECTED,
+  TI_PRIVATE,
+  TI_BOOLEAN_FALSE,
+  TI_BOOLEAN_TRUE,
+  TI_COMPLEX_INTEGER_TYPE,
+  TI_COMPLEX_FLOAT_TYPE,
+  TI_COMPLEX_DOUBLE_TYPE,
+  TI_COMPLEX_LONG_DOUBLE_TYPE,
+  TI_FLOAT_TYPE,
+  TI_DOUBLE_TYPE,
+  TI_LONG_DOUBLE_TYPE,
+  TI_FLOAT_PTR_TYPE,
+  TI_DOUBLE_PTR_TYPE,
+  TI_LONG_DOUBLE_PTR_TYPE,
+  TI_INTEGER_PTR_TYPE,
+  TI_VOID_TYPE,
+  TI_PTR_TYPE,
+  TI_CONST_PTR_TYPE,
+  TI_SIZE_TYPE,
+  TI_PID_TYPE,
+  TI_PTRDIFF_TYPE,
+  TI_VA_LIST_TYPE,
+  TI_VA_LIST_GPR_COUNTER_FIELD,
+  TI_VA_LIST_FPR_COUNTER_FIELD,
+  TI_BOOLEAN_TYPE,
+  TI_FILEPTR_TYPE,
+  TI_DFLOAT32_TYPE,
+  TI_DFLOAT64_TYPE,
+  TI_DFLOAT128_TYPE,
+  TI_DFLOAT32_PTR_TYPE,
+  TI_DFLOAT64_PTR_TYPE,
+  TI_DFLOAT128_PTR_TYPE,
+  TI_VOID_LIST_NODE,
+  TI_MAIN_IDENTIFIER,
+  TI_SAT_SFRACT_TYPE,
+  TI_SAT_FRACT_TYPE,
+  TI_SAT_LFRACT_TYPE,
+  TI_SAT_LLFRACT_TYPE,
+  TI_SAT_USFRACT_TYPE,
+  TI_SAT_UFRACT_TYPE,
+  TI_SAT_ULFRACT_TYPE,
+  TI_SAT_ULLFRACT_TYPE,
+  TI_SFRACT_TYPE,
+  TI_FRACT_TYPE,
+  TI_LFRACT_TYPE,
+  TI_LLFRACT_TYPE,
+  TI_USFRACT_TYPE,
+  TI_UFRACT_TYPE,
+  TI_ULFRACT_TYPE,
+  TI_ULLFRACT_TYPE,
+  TI_SAT_SACCUM_TYPE,
+  TI_SAT_ACCUM_TYPE,
+  TI_SAT_LACCUM_TYPE,
+  TI_SAT_LLACCUM_TYPE,
+  TI_SAT_USACCUM_TYPE,
+  TI_SAT_UACCUM_TYPE,
+  TI_SAT_ULACCUM_TYPE,
+  TI_SAT_ULLACCUM_TYPE,
+  TI_SACCUM_TYPE,
+  TI_ACCUM_TYPE,
+  TI_LACCUM_TYPE,
+  TI_LLACCUM_TYPE,
+  TI_USACCUM_TYPE,
+  TI_UACCUM_TYPE,
+  TI_ULACCUM_TYPE,
+  TI_ULLACCUM_TYPE,
+  TI_QQ_TYPE,
+  TI_HQ_TYPE,
+  TI_SQ_TYPE,
+  TI_DQ_TYPE,
+  TI_TQ_TYPE,
+  TI_UQQ_TYPE,
+  TI_UHQ_TYPE,
+  TI_USQ_TYPE,
+  TI_UDQ_TYPE,
+  TI_UTQ_TYPE,
+  TI_SAT_QQ_TYPE,
+  TI_SAT_HQ_TYPE,
+  TI_SAT_SQ_TYPE,
+  TI_SAT_DQ_TYPE,
+  TI_SAT_TQ_TYPE,
+  TI_SAT_UQQ_TYPE,
+  TI_SAT_UHQ_TYPE,
+  TI_SAT_USQ_TYPE,
+  TI_SAT_UDQ_TYPE,
+  TI_SAT_UTQ_TYPE,
+  TI_HA_TYPE,
+  TI_SA_TYPE,
+  TI_DA_TYPE,
+  TI_TA_TYPE,
+  TI_UHA_TYPE,
+  TI_USA_TYPE,
+  TI_UDA_TYPE,
+  TI_UTA_TYPE,
+  TI_SAT_HA_TYPE,
+  TI_SAT_SA_TYPE,
+  TI_SAT_DA_TYPE,
+  TI_SAT_TA_TYPE,
+  TI_SAT_UHA_TYPE,
+  TI_SAT_USA_TYPE,
+  TI_SAT_UDA_TYPE,
+  TI_SAT_UTA_TYPE,
+  TI_OPTIMIZATION_DEFAULT,
+  TI_OPTIMIZATION_CURRENT,
+  TI_TARGET_OPTION_DEFAULT,
+  TI_TARGET_OPTION_CURRENT,
+  TI_CURRENT_TARGET_PRAGMA,
+  TI_CURRENT_OPTIMIZE_PRAGMA,
+  TI_MAX
+};
+extern tree global_trees[TI_MAX];
+enum integer_type_kind
+{
+  itk_char,
+  itk_signed_char,
+  itk_unsigned_char,
+  itk_short,
+  itk_unsigned_short,
+  itk_int,
+  itk_unsigned_int,
+  itk_long,
+  itk_unsigned_long,
+  itk_long_long,
+  itk_unsigned_long_long,
+  itk_int128,
+  itk_unsigned_int128,
+  itk_none
+};
+typedef enum integer_type_kind integer_type_kind;
+extern tree integer_types[itk_none];
+enum ptrmemfunc_vbit_where_t
+{
+  ptrmemfunc_vbit_in_pfn,
+  ptrmemfunc_vbit_in_delta
+};
+extern tree decl_assembler_name (tree);
+extern bool decl_assembler_name_equal (tree decl, const_tree asmname);
+extern hashval_t decl_assembler_name_hash (const_tree asmname);
+extern size_t tree_size (const_tree);
+extern size_t tree_code_size (enum tree_code);
+extern int allocate_decl_uid (void);
+extern tree make_node_stat (enum tree_code );
+extern tree copy_node_stat (tree );
+extern tree copy_list (tree);
+extern tree build_case_label (tree, tree, tree);
+extern tree make_tree_binfo_stat (unsigned );
+extern tree make_tree_vec_stat (int );
+extern tree get_identifier (const char *);
+extern tree get_identifier_with_length (const char *, size_t);
+extern tree maybe_get_identifier (const char *);
+extern tree build_nt (enum tree_code, ...);
+extern tree build_nt_call_vec (tree, vec<tree, va_gc> *);
+extern tree build0_stat (enum tree_code, tree );
+extern tree build1_stat (enum tree_code, tree, tree );
+extern tree build2_stat (enum tree_code, tree, tree, tree );
+extern tree build3_stat (enum tree_code, tree, tree, tree, tree );
+extern tree build4_stat (enum tree_code, tree, tree, tree, tree,
+    tree );
+extern tree build5_stat (enum tree_code, tree, tree, tree, tree, tree,
+    tree );
+static inline tree
+build1_stat_loc (location_t loc, enum tree_code code, tree type,
+   tree arg1 )
+{
+  tree t = build1_stat (code, type, arg1 );
+  if (((t) && ((tree_code_type[(int) (((enum tree_code) (t)->base.code))]) >= tcc_reference && (tree_code_type[(int) (((enum tree_code) (t)->base.code))]) <= tcc_expression)))
+    ((t))->exp.locus = (loc);
+  return t;
+}
+static inline tree
+build2_stat_loc (location_t loc, enum tree_code code, tree type, tree arg0,
+   tree arg1 )
+{
+  tree t = build2_stat (code, type, arg0, arg1 );
+  if (((t) && ((tree_code_type[(int) (((enum tree_code) (t)->base.code))]) >= tcc_reference && (tree_code_type[(int) (((enum tree_code) (t)->base.code))]) <= tcc_expression)))
+    ((t))->exp.locus = (loc);
+  return t;
+}
+static inline tree
+build3_stat_loc (location_t loc, enum tree_code code, tree type, tree arg0,
+   tree arg1, tree arg2 )
+{
+  tree t = build3_stat (code, type, arg0, arg1, arg2 );
+  if (((t) && ((tree_code_type[(int) (((enum tree_code) (t)->base.code))]) >= tcc_reference && (tree_code_type[(int) (((enum tree_code) (t)->base.code))]) <= tcc_expression)))
+    ((t))->exp.locus = (loc);
+  return t;
+}
+static inline tree
+build4_stat_loc (location_t loc, enum tree_code code, tree type, tree arg0,
+   tree arg1, tree arg2, tree arg3 )
+{
+  tree t = build4_stat (code, type, arg0, arg1, arg2, arg3 );
+  if (((t) && ((tree_code_type[(int) (((enum tree_code) (t)->base.code))]) >= tcc_reference && (tree_code_type[(int) (((enum tree_code) (t)->base.code))]) <= tcc_expression)))
+    ((t))->exp.locus = (loc);
+  return t;
+}
+static inline tree
+build5_stat_loc (location_t loc, enum tree_code code, tree type, tree arg0,
+   tree arg1, tree arg2, tree arg3, tree arg4 )
+{
+  tree t = build5_stat (code, type, arg0, arg1, arg2, arg3,
+   arg4 );
+  if (((t) && ((tree_code_type[(int) (((enum tree_code) (t)->base.code))]) >= tcc_reference && (tree_code_type[(int) (((enum tree_code) (t)->base.code))]) <= tcc_expression)))
+    ((t))->exp.locus = (loc);
+  return t;
+}
+extern tree build_var_debug_value_stat (tree, tree );
+static inline double_int
+tree_to_double_int (const_tree cst)
+{
+  return ((cst)->int_cst.int_cst);
+}
+extern tree double_int_to_tree (tree, double_int);
+extern bool double_int_fits_to_tree_p (const_tree, double_int);
+extern tree force_fit_type_double (tree, double_int, int, bool);
+static inline tree
+build_int_cstu (tree type, unsigned long long cst)
+{
+  return double_int_to_tree (type, double_int::from_uhwi (cst));
+}
+extern tree build_int_cst (tree, long long);
+extern tree build_int_cst_type (tree, long long);
+extern tree build_int_cst_wide (tree, unsigned long long, long long);
+extern tree make_vector_stat (unsigned );
+extern tree build_vector_stat (tree, tree * );
+extern tree build_vector_from_ctor (tree, vec<constructor_elt, va_gc> *);
+extern tree build_vector_from_val (tree, tree);
+extern tree build_constructor (tree, vec<constructor_elt, va_gc> *);
+extern tree build_constructor_single (tree, tree, tree);
+extern tree build_constructor_from_list (tree, tree);
+extern tree build_real_from_int_cst (tree, const_tree);
+extern tree build_complex (tree, tree, tree);
+extern tree build_one_cst (tree);
+extern tree build_zero_cst (tree);
+extern tree build_string (int, const char *);
+extern tree build_tree_list_stat (tree, tree );
+extern tree build_tree_list_vec_stat (const vec<tree, va_gc> *);
+extern tree build_decl_stat (location_t, enum tree_code,
+        tree, tree );
+extern tree build_fn_decl (const char *, tree);
+extern tree build_translation_unit_decl (tree);
+extern tree build_block (tree, tree, tree, tree);
+extern tree build_empty_stmt (location_t);
+extern tree build_omp_clause (location_t, enum omp_clause_code);
+extern tree build_vl_exp_stat (enum tree_code, int );
+extern tree build_call_nary (tree, tree, int, ...);
+extern tree build_call_valist (tree, tree, int, va_list);
+extern tree build_call_array_loc (location_t, tree, tree, int, const tree *);
+extern tree build_call_vec (tree, tree, vec<tree, va_gc> *);
+extern tree make_signed_type (int);
+extern tree make_unsigned_type (int);
+extern tree signed_or_unsigned_type_for (int, tree);
+extern tree signed_type_for (tree);
+extern tree unsigned_type_for (tree);
+extern tree truth_type_for (tree);
+extern void initialize_sizetypes (void);
+extern void fixup_unsigned_type (tree);
+extern tree build_pointer_type_for_mode (tree, enum machine_mode, bool);
+extern tree build_pointer_type (tree);
+extern tree build_reference_type_for_mode (tree, enum machine_mode, bool);
+extern tree build_reference_type (tree);
+extern tree build_vector_type_for_mode (tree, enum machine_mode);
+extern tree build_vector_type (tree innertype, int nunits);
+extern tree build_opaque_vector_type (tree innertype, int nunits);
+extern tree build_type_no_quals (tree);
+extern tree build_index_type (tree);
+extern tree build_array_type (tree, tree);
+extern tree build_nonshared_array_type (tree, tree);
+extern tree build_array_type_nelts (tree, unsigned long long);
+extern tree build_function_type (tree, tree);
+extern tree build_function_type_list (tree, ...);
+extern tree build_function_decl_skip_args (tree, bitmap, bool);
+extern tree build_varargs_function_type_list (tree, ...);
+extern tree build_function_type_array (tree, int, tree *);
+extern tree build_varargs_function_type_array (tree, int, tree *);
+extern tree build_method_type_directly (tree, tree, tree);
+extern tree build_method_type (tree, tree);
+extern tree build_offset_type (tree, tree);
+extern tree build_complex_type (tree);
+extern tree array_type_nelts (const_tree);
+extern bool in_array_bounds_p (tree);
+extern bool range_in_array_bounds_p (tree);
+extern tree value_member (tree, tree);
+extern tree purpose_member (const_tree, tree);
+extern bool vec_member (const_tree, vec<tree, va_gc> *);
+extern tree chain_index (int, tree);
+extern int attribute_list_equal (const_tree, const_tree);
+extern int attribute_list_contained (const_tree, const_tree);
+extern int tree_int_cst_equal (const_tree, const_tree);
+extern int tree_int_cst_lt (const_tree, const_tree);
+extern int tree_int_cst_compare (const_tree, const_tree);
+extern int host_integerp (const_tree, int)
+  __attribute__ ((__pure__))
+  ;
+extern long long tree_low_cst (const_tree, int);
+extern inline __attribute__ ((__gnu_inline__)) long long
+tree_low_cst (const_tree t, int pos)
+{
+  ((void)(!(host_integerp (t, pos)) ? fancy_abort ("../../gcc/tree.h", 4849, __FUNCTION__), 0 : 0));
+  return (((t)->int_cst.int_cst).low);
+}
+extern long long size_low_cst (const_tree);
+extern int tree_int_cst_sgn (const_tree);
+extern int tree_int_cst_sign_bit (const_tree);
+extern unsigned int tree_int_cst_min_precision (tree, bool);
+extern bool tree_expr_nonnegative_p (tree);
+extern bool tree_expr_nonnegative_warnv_p (tree, bool *);
+extern bool may_negate_without_overflow_p (const_tree);
+extern tree strip_array_types (tree);
+extern tree excess_precision_type (tree);
+extern bool valid_constant_size_p (const_tree);
+extern tree make_fract_type (int, int, int);
+extern tree make_accum_type (int, int, int);
+extern tree make_tree (tree, rtx);
+extern tree build_type_attribute_variant (tree, tree);
+extern tree build_decl_attribute_variant (tree, tree);
+extern tree build_type_attribute_qual_variant (tree, tree, int);
+extern int comp_type_attributes (const_tree, const_tree);
+struct attribute_spec
+{
+  const char *name;
+  int min_length;
+  int max_length;
+  bool decl_required;
+  bool type_required;
+  bool function_type_required;
+  tree (*handler) (tree *node, tree name, tree args,
+     int flags, bool *no_add_attrs);
+  bool affects_type_identity;
+};
+enum attribute_flags
+{
+  ATTR_FLAG_DECL_NEXT = 1,
+  ATTR_FLAG_FUNCTION_NEXT = 2,
+  ATTR_FLAG_ARRAY_NEXT = 4,
+  ATTR_FLAG_TYPE_IN_PLACE = 8,
+  ATTR_FLAG_BUILT_IN = 16,
+  ATTR_FLAG_CXX11 = 32
+};
+extern tree merge_decl_attributes (tree, tree);
+extern tree merge_type_attributes (tree, tree);
+extern tree private_lookup_attribute (const char *, size_t, tree);
+static inline tree
+lookup_attribute (const char *attr_name, tree list)
+{
+  ((void)(0 && (attr_name[0] != '_')));
+  if (list == (tree) __null)
+    return (tree) __null;
+  else
+    return private_lookup_attribute (attr_name, strlen (attr_name), list);
+}
+extern bool private_is_attribute_p (const char *, size_t, const_tree);
+static inline bool
+is_attribute_p (const char *attr_name, const_tree ident)
+{
+  ((void)(0 && (attr_name[0] != '_')));
+  return private_is_attribute_p (attr_name, strlen (attr_name), ident);
+}
+extern tree remove_attribute (const char *, tree);
+extern tree merge_attributes (tree, tree);
+extern bool check_qualified_type (const_tree, const_tree, int);
+extern tree get_qualified_type (tree, int);
+extern tree build_qualified_type (tree, int);
+extern tree build_aligned_type (tree, unsigned int);
+extern tree build_distinct_type_copy (tree);
+extern tree build_variant_type_copy (tree);
+extern void finish_builtin_struct (tree, const char *,
+        tree, tree);
+extern void layout_type (tree);
+typedef struct record_layout_info_s
+{
+  tree t;
+  tree offset;
+  unsigned int offset_align;
+  tree bitpos;
+  unsigned int record_align;
+  unsigned int unpacked_align;
+  tree prev_field;
+  vec<tree, va_gc> *pending_statics;
+  int remaining_in_alignment;
+  int packed_maybe_necessary;
+} *record_layout_info;
+extern record_layout_info start_record_layout (tree);
+extern tree bit_from_pos (tree, tree);
+extern tree byte_from_pos (tree, tree);
+extern void pos_from_bit (tree *, tree *, unsigned int, tree);
+extern void normalize_offset (tree *, tree *, unsigned int);
+extern tree rli_size_unit_so_far (record_layout_info);
+extern tree rli_size_so_far (record_layout_info);
+extern void normalize_rli (record_layout_info);
+extern void place_field (record_layout_info, tree);
+extern void compute_record_mode (tree);
+extern void finish_record_layout (record_layout_info, int);
+extern tree type_hash_canon (unsigned int, tree);
+extern void layout_decl (tree, unsigned);
+extern void relayout_decl (tree);
+extern enum machine_mode mode_for_size_tree (const_tree, enum mode_class, int);
+extern tree non_lvalue_loc (location_t, tree);
+extern tree convert (tree, tree);
+extern unsigned int expr_align (const_tree);
+extern tree expr_first (tree);
+extern tree expr_last (tree);
+extern tree size_in_bytes (const_tree);
+extern long long int_size_in_bytes (const_tree);
+extern long long max_int_size_in_bytes (const_tree);
+extern tree tree_expr_size (const_tree);
+extern tree bit_position (const_tree);
+extern long long int_bit_position (const_tree);
+extern tree byte_position (const_tree);
+extern long long int_byte_position (const_tree);
+enum size_type_kind
+{
+  stk_sizetype,
+  stk_ssizetype,
+  stk_bitsizetype,
+  stk_sbitsizetype,
+  stk_type_kind_last
+};
+extern tree sizetype_tab[(int) stk_type_kind_last];
+extern tree size_int_kind (long long, enum size_type_kind);
+extern tree size_binop_loc (location_t, enum tree_code, tree, tree);
+extern tree size_diffop_loc (location_t, tree, tree);
+extern tree round_up_loc (location_t, tree, int);
+extern tree round_down_loc (location_t, tree, int);
+extern void finalize_size_functions (void);
+extern unsigned int maximum_field_alignment;
+extern tree chainon (tree, tree);
+extern tree tree_cons_stat (tree, tree, tree );
+extern tree tree_last (tree);
+extern tree nreverse (tree);
+extern int list_length (const_tree);
+extern int fields_length (const_tree);
+extern tree first_field (const_tree);
+extern bool initializer_zerop (const_tree);
+extern vec<tree, va_gc> *ctor_to_vec (tree);
+extern bool categorize_ctor_elements (const_tree, long long *,
+          long long *, bool *);
+extern bool complete_ctor_at_level_p (const_tree, long long, const_tree);
+extern int integer_zerop (const_tree);
+extern int integer_onep (const_tree);
+extern int integer_all_onesp (const_tree);
+extern int integer_pow2p (const_tree);
+extern int integer_nonzerop (const_tree);
+extern bool cst_and_fits_in_hwi (const_tree);
+extern tree num_ending_zeros (const_tree);
+extern int fixed_zerop (const_tree);
+extern tree staticp (tree);
+extern tree save_expr (tree);
+extern tree skip_simple_arithmetic (tree);
+enum tree_node_structure_enum tree_node_structure (const_tree);
+extern bool contains_placeholder_p (const_tree);
+extern bool type_contains_placeholder_p (tree);
+extern void find_placeholder_in_expr (tree, vec<tree> *);
+extern tree substitute_in_expr (tree, tree, tree);
+extern tree substitute_placeholder_in_expr (tree, tree);
+extern tree variable_size (tree);
+extern tree stabilize_reference (tree);
+extern tree stabilize_reference_1 (tree);
+extern tree get_unwidened (tree, tree);
+extern tree get_narrower (tree, int *);
+static inline bool
+handled_component_p (const_tree t)
+{
+  switch (((enum tree_code) (t)->base.code))
+    {
+    case COMPONENT_REF:
+    case BIT_FIELD_REF:
+    case ARRAY_REF:
+    case ARRAY_RANGE_REF:
+    case REALPART_EXPR:
+    case IMAGPART_EXPR:
+    case VIEW_CONVERT_EXPR:
+      return true;
+    default:
+      return false;
+    }
+}
+extern tree get_inner_reference (tree, long long *, long long *,
+     tree *, enum machine_mode *, int *, int *,
+     bool);
+extern tree array_ref_element_size (tree);
+bool array_at_struct_end_p (tree);
+extern tree array_ref_low_bound (tree);
+extern tree array_ref_up_bound (tree);
+extern tree component_ref_field_offset (tree);
+extern tree get_containing_scope (const_tree);
+extern tree decl_function_context (const_tree);
+extern tree decl_type_context (const_tree);
+extern int real_zerop (const_tree);
+extern int pedantic_lvalues;
+extern tree current_function_decl;
+extern const char * current_function_func_begin_label;
+typedef struct {
+  tree next;
+} function_args_iterator;
+static inline void
+function_args_iter_init (function_args_iterator *i, const_tree fntype)
+{
+  i->next = ((fntype)->type_non_common.values);
+}
+static inline tree *
+function_args_iter_cond_ptr (function_args_iterator *i)
+{
+  return (i->next) ? &((i->next)->list.value) : __null;
+}
+static inline tree
+function_args_iter_cond (function_args_iterator *i)
+{
+  return (i->next) ? ((i->next)->list.value) : (tree) __null;
+}
+static inline void
+function_args_iter_next (function_args_iterator *i)
+{
+  ((void)(!(i->next != (tree) __null) ? fancy_abort ("../../gcc/tree.h", 5557, __FUNCTION__), 0 : 0));
+  i->next = ((i->next)->common.chain);
+}
+static inline bool
+inlined_function_outer_scope_p (const_tree block)
+{
+ return (((((((block)->block.locus)) & 0x7FFFFFFF) != (((block)->block.locus)))) ? get_location_from_adhoc_loc (line_table, ((block)->block.locus)) : (((block)->block.locus))) != ((source_location) 0);
+}
+extern unsigned crc32_string (unsigned, const char *);
+extern unsigned crc32_byte (unsigned, char);
+extern unsigned crc32_unsigned (unsigned, unsigned);
+extern void clean_symbol_name (char *);
+extern tree get_file_function_name (const char *);
+extern tree get_callee_fndecl (const_tree);
+extern int type_num_arguments (const_tree);
+extern bool associative_tree_code (enum tree_code);
+extern bool commutative_tree_code (enum tree_code);
+extern bool commutative_ternary_tree_code (enum tree_code);
+extern tree upper_bound_in_type (tree, tree);
+extern tree lower_bound_in_type (tree, tree);
+extern int operand_equal_for_phi_arg_p (const_tree, const_tree);
+extern tree create_artificial_label (location_t);
+extern const char *get_name (tree);
+extern bool stdarg_p (const_tree);
+extern bool prototype_p (tree);
+extern bool is_typedef_decl (tree x);
+extern bool typedef_variant_p (tree);
+extern bool auto_var_in_fn_p (const_tree, const_tree);
+extern tree build_low_bits_mask (tree, unsigned);
+extern tree tree_strip_nop_conversions (tree);
+extern tree tree_strip_sign_nop_conversions (tree);
+extern const_tree strip_invariant_refs (const_tree);
+extern tree lhd_gcc_personality (void);
+extern void assign_assembler_name_if_neeeded (tree);
+extern void warn_deprecated_use (tree, tree);
+extern void change_decl_assembler_name (tree, tree);
+extern tree unshare_expr (tree);
+extern tree unshare_expr_without_location (tree);
+extern void expand_label (tree);
+extern void expand_goto (tree);
+extern rtx expand_stack_save (void);
+extern void expand_stack_restore (tree);
+extern void expand_return (tree);
+extern void using_eh_for_cleanups (void);
+extern bool tree_could_trap_p (tree);
+extern bool operation_could_trap_helper_p (enum tree_code, bool, bool, bool,
+        bool, tree, bool *);
+extern bool operation_could_trap_p (enum tree_code, bool, bool, tree);
+extern bool tree_could_throw_p (tree);
+static inline int
+struct_ptr_eq (const void *a, const void *b)
+{
+  const void * const * x = (const void * const *) a;
+  const void * const * y = (const void * const *) b;
+  return *x == *y;
+}
+static inline hashval_t
+struct_ptr_hash (const void *a)
+{
+  const void * const * x = (const void * const *) a;
+  return (intptr_t)*x >> 4;
+}
+extern int folding_initializer;
+extern int native_encode_expr (const_tree, unsigned char *, int);
+extern tree native_interpret_expr (tree, const unsigned char *, int);
+extern tree fold (tree);
+extern tree fold_unary_loc (location_t, enum tree_code, tree, tree);
+extern tree fold_unary_ignore_overflow_loc (location_t, enum tree_code, tree, tree);
+extern tree fold_binary_loc (location_t, enum tree_code, tree, tree, tree);
+extern tree fold_ternary_loc (location_t, enum tree_code, tree, tree, tree, tree);
+extern tree fold_build1_stat_loc (location_t, enum tree_code, tree,
+      tree );
+extern tree fold_build2_stat_loc (location_t, enum tree_code, tree, tree,
+      tree );
+extern tree fold_build3_stat_loc (location_t, enum tree_code, tree, tree, tree,
+      tree );
+extern tree fold_build1_initializer_loc (location_t, enum tree_code, tree, tree);
+extern tree fold_build2_initializer_loc (location_t, enum tree_code, tree, tree, tree);
+extern tree fold_build3_initializer_loc (location_t, enum tree_code, tree, tree, tree, tree);
+extern tree fold_build_call_array_loc (location_t, tree, tree, int, tree *);
+extern tree fold_build_call_array_initializer_loc (location_t, tree, tree, int, tree *);
+extern bool fold_convertible_p (const_tree, const_tree);
+extern tree fold_convert_loc (location_t, tree, tree);
+extern tree fold_single_bit_test (location_t, enum tree_code, tree, tree, tree);
+extern tree fold_ignored_result (tree);
+extern tree fold_abs_const (tree, tree);
+extern tree fold_indirect_ref_1 (location_t, tree, tree);
+extern void fold_defer_overflow_warnings (void);
+extern void fold_undefer_overflow_warnings (bool, const_gimple, int);
+extern void fold_undefer_and_ignore_overflow_warnings (void);
+extern bool fold_deferring_overflow_warnings_p (void);
+extern tree fold_fma (location_t, tree, tree, tree, tree);
+enum operand_equal_flag
+{
+  OEP_ONLY_CONST = 1,
+  OEP_PURE_SAME = 2,
+  OEP_CONSTANT_ADDRESS_OF = 4
+};
+extern int operand_equal_p (const_tree, const_tree, unsigned int);
+extern int multiple_of_p (tree, const_tree, const_tree);
+extern tree omit_one_operand_loc (location_t, tree, tree, tree);
+extern tree omit_two_operands_loc (location_t, tree, tree, tree, tree);
+extern tree invert_truthvalue_loc (location_t, tree);
+extern tree fold_truth_not_expr (location_t, tree);
+extern tree fold_unary_to_constant (enum tree_code, tree, tree);
+extern tree fold_binary_to_constant (enum tree_code, tree, tree, tree);
+extern tree fold_read_from_constant_string (tree);
+extern tree int_const_binop (enum tree_code, const_tree, const_tree);
+extern tree build_fold_addr_expr_loc (location_t, tree);
+extern tree build_fold_addr_expr_with_type_loc (location_t, tree, tree);
+extern tree fold_build_cleanup_point_expr (tree type, tree expr);
+extern tree fold_strip_sign_ops (tree);
+extern tree build_fold_indirect_ref_loc (location_t, tree);
+extern tree fold_indirect_ref_loc (location_t, tree);
+extern tree build_simple_mem_ref_loc (location_t, tree);
+extern double_int mem_ref_offset (const_tree);
+extern tree reference_alias_ptr_type (const_tree);
+extern tree build_invariant_address (tree, tree, long long);
+extern tree constant_boolean_node (bool, tree);
+extern tree div_if_zero_remainder (enum tree_code, const_tree, const_tree);
+extern bool tree_swap_operands_p (const_tree, const_tree, bool);
+extern enum tree_code swap_tree_comparison (enum tree_code);
+extern bool ptr_difference_const (tree, tree, long long *);
+extern enum tree_code invert_tree_comparison (enum tree_code, bool);
+extern bool tree_expr_nonzero_p (tree);
+extern bool tree_unary_nonzero_warnv_p (enum tree_code, tree, tree, bool *);
+extern bool tree_binary_nonzero_warnv_p (enum tree_code, tree, tree, tree op1,
+                                         bool *);
+extern bool tree_single_nonzero_warnv_p (tree, bool *);
+extern bool tree_unary_nonnegative_warnv_p (enum tree_code, tree, tree, bool *);
+extern bool tree_binary_nonnegative_warnv_p (enum tree_code, tree, tree, tree,
+                                             bool *);
+extern bool tree_single_nonnegative_warnv_p (tree t, bool *strict_overflow_p);
+extern bool tree_invalid_nonnegative_warnv_p (tree t, bool *strict_overflow_p);
+extern bool tree_call_nonnegative_warnv_p (tree, tree, tree, tree, bool *);
+extern bool tree_expr_nonzero_warnv_p (tree, bool *);
+extern bool fold_real_zero_addition_p (const_tree, const_tree, int);
+extern tree combine_comparisons (location_t, enum tree_code, enum tree_code,
+     enum tree_code, tree, tree, tree);
+extern void debug_fold_checksum (const_tree);
+static inline bool
+truth_value_p (enum tree_code code)
+{
+  return (tree_code_type[(int) (code)] == tcc_comparison
+   || code == TRUTH_AND_EXPR || code == TRUTH_ANDIF_EXPR
+   || code == TRUTH_OR_EXPR || code == TRUTH_ORIF_EXPR
+   || code == TRUTH_XOR_EXPR || code == TRUTH_NOT_EXPR);
+}
+static inline bool
+ptrofftype_p (tree type)
+{
+  return ((((enum tree_code) (type)->base.code) == ENUMERAL_TYPE || ((enum tree_code) (type)->base.code) == BOOLEAN_TYPE || ((enum tree_code) (type)->base.code) == INTEGER_TYPE)
+   && ((type)->type_common.precision) == ((sizetype_tab[(int) stk_sizetype])->type_common.precision)
+   && ((type)->base.u.bits.unsigned_flag) == ((sizetype_tab[(int) stk_sizetype])->base.u.bits.unsigned_flag));
+}
+static inline tree
+convert_to_ptrofftype_loc (location_t loc, tree off)
+{
+  return fold_convert_loc (loc, sizetype_tab[(int) stk_sizetype], off);
+}
+static inline tree
+fold_build_pointer_plus_loc (location_t loc, tree ptr, tree off)
+{
+  return fold_build2_stat_loc (loc, POINTER_PLUS_EXPR, ((ptr)->typed.type), ptr, fold_convert_loc (loc, sizetype_tab[(int) stk_sizetype], off) );
+}
+static inline tree
+fold_build_pointer_plus_hwi_loc (location_t loc, tree ptr, long long off)
+{
+  return fold_build2_stat_loc (loc, POINTER_PLUS_EXPR, ((ptr)->typed.type), ptr, size_int_kind (off, stk_sizetype) );
+}
+extern bool avoid_folding_inline_builtin (tree);
+extern tree fold_call_expr (location_t, tree, bool);
+extern tree fold_builtin_fputs (location_t, tree, tree, bool, bool, tree);
+extern tree fold_builtin_strcpy (location_t, tree, tree, tree, tree);
+extern tree fold_builtin_strncpy (location_t, tree, tree, tree, tree, tree);
+extern tree fold_builtin_memory_chk (location_t, tree, tree, tree, tree, tree, tree, bool,
+         enum built_in_function);
+extern tree fold_builtin_stxcpy_chk (location_t, tree, tree, tree, tree, tree, bool,
+         enum built_in_function);
+extern tree fold_builtin_stxncpy_chk (location_t, tree, tree, tree, tree, tree, bool,
+          enum built_in_function);
+extern tree fold_builtin_snprintf_chk (location_t, tree, tree, enum built_in_function);
+extern bool fold_builtin_next_arg (tree, bool);
+extern enum built_in_function builtin_mathfn_code (const_tree);
+extern tree fold_builtin_call_array (location_t, tree, tree, int, tree *);
+extern tree build_call_expr_loc_array (location_t, tree, int, tree *);
+extern tree build_call_expr_loc_vec (location_t, tree, vec<tree, va_gc> *);
+extern tree build_call_expr_loc (location_t, tree, int, ...);
+extern tree build_call_expr (tree, int, ...);
+extern tree mathfn_built_in (tree, enum built_in_function fn);
+extern tree c_strlen (tree, int);
+extern tree std_gimplify_va_arg_expr (tree, tree, gimple_seq *, gimple_seq *);
+extern tree build_va_arg_indirect_ref (tree);
+extern tree build_string_literal (int, const char *);
+extern bool validate_arglist (const_tree, ...);
+extern rtx builtin_memset_read_str (void *, long long, enum machine_mode);
+extern bool is_builtin_fn (tree);
+extern bool get_object_alignment_1 (tree, unsigned int *,
+        unsigned long long *);
+extern unsigned int get_object_alignment (tree);
+extern bool get_pointer_alignment_1 (tree, unsigned int *,
+         unsigned long long *);
+extern unsigned int get_pointer_alignment (tree);
+extern tree fold_call_stmt (gimple, bool);
+extern tree gimple_fold_builtin_snprintf_chk (gimple, tree, enum built_in_function);
+extern tree make_range (tree, int *, tree *, tree *, bool *);
+extern tree make_range_step (location_t, enum tree_code, tree, tree, tree,
+        tree *, tree *, int *, bool *);
+extern tree build_range_check (location_t, tree, tree, int, tree, tree);
+extern bool merge_ranges (int *, tree *, tree *, int, tree, tree, int,
+     tree, tree);
+extern void set_builtin_user_assembler_name (tree decl, const char *asmspec);
+extern bool is_simple_builtin (tree);
+extern bool is_inexpensive_builtin (tree);
+extern tree strip_float_extensions (tree);
+extern int really_constant_p (const_tree);
+extern bool decl_address_invariant_p (const_tree);
+extern bool decl_address_ip_invariant_p (const_tree);
+extern bool int_fits_type_p (const_tree, const_tree);
+extern void get_type_static_bounds (const_tree, mpz_t, mpz_t);
+extern bool variably_modified_type_p (tree, tree);
+extern int tree_log2 (const_tree);
+extern int tree_floor_log2 (const_tree);
+extern int simple_cst_equal (const_tree, const_tree);
+extern hashval_t iterative_hash_expr (const_tree, hashval_t);
+extern hashval_t iterative_hash_exprs_commutative (const_tree,
+                                                   const_tree, hashval_t);
+extern hashval_t iterative_hash_host_wide_int (long long, hashval_t);
+extern hashval_t iterative_hash_hashval_t (hashval_t, hashval_t);
+extern hashval_t iterative_hash_host_wide_int (long long, hashval_t);
+extern int compare_tree_int (const_tree, unsigned long long);
+extern int type_list_equal (const_tree, const_tree);
+extern int chain_member (const_tree, const_tree);
+extern tree type_hash_lookup (unsigned int, tree);
+extern void type_hash_add (unsigned int, tree);
+extern int simple_cst_list_equal (const_tree, const_tree);
+extern void dump_tree_statistics (void);
+extern void recompute_tree_invariant_for_addr_expr (tree);
+extern bool needs_to_live_in_memory (const_tree);
+extern tree reconstruct_complex_type (tree, tree);
+extern int real_onep (const_tree);
+extern int real_twop (const_tree);
+extern int real_minus_onep (const_tree);
+extern void init_ttree (void);
+extern void build_common_tree_nodes (bool, bool);
+extern void build_common_builtin_nodes (void);
+extern tree build_nonstandard_integer_type (unsigned long long, int);
+extern tree build_range_type (tree, tree, tree);
+extern tree build_nonshared_range_type (tree, tree, tree);
+extern bool subrange_type_for_debug_p (const_tree, tree *, tree *);
+extern long long int_cst_value (const_tree);
+extern long long widest_int_cst_value (const_tree);
+extern tree tree_block (tree);
+extern void tree_set_block (tree, tree);
+extern location_t *block_nonartificial_location (tree);
+extern location_t tree_nonartificial_location (tree);
+extern tree block_ultimate_origin (const_tree);
+extern tree get_binfo_at_offset (tree, long long, tree);
+extern tree get_ref_base_and_extent (tree, long long *,
+         long long *, long long *);
+extern bool contains_bitfld_component_ref_p (const_tree);
+extern tree build_addr (tree, tree);
+extern void expand_main_function (void);
+extern void expand_function_end (void);
+extern void expand_function_start (tree);
+extern void stack_protect_prologue (void);
+extern void stack_protect_epilogue (void);
+extern void init_dummy_function_start (void);
+extern void expand_dummy_function_end (void);
+extern void allocate_struct_function (tree, bool);
+extern void push_struct_function (tree fndecl);
+extern void init_function_start (tree);
+extern bool use_register_for_decl (const_tree);
+extern void generate_setjmp_warnings (void);
+extern void init_temp_slots (void);
+extern void free_temp_slots (void);
+extern void pop_temp_slots (void);
+extern void push_temp_slots (void);
+extern void preserve_temp_slots (rtx);
+extern int aggregate_value_p (const_tree, const_tree);
+extern void push_function_context (void);
+extern void pop_function_context (void);
+extern gimple_seq gimplify_parameters (void);
+extern void print_rtl (FILE *, const_rtx);
+extern void debug_tree (tree);
+extern void debug_vec_tree (vec<tree, va_gc> *);
+extern void dump_addr (FILE*, const char *, const void *);
+extern void print_node (FILE *, const char *, tree, int);
+extern void print_vec_tree (FILE *, const char *, vec<tree, va_gc> *, int);
+extern void print_node_brief (FILE *, const char *, const_tree, int);
+extern void indent_to (FILE *, int);
+extern bool debug_find_tree (tree, tree);
+extern tree unsave_expr_now (tree);
+extern tree build_duplicate_type (tree);
+extern int flags_from_decl_or_type (const_tree);
+extern int call_expr_flags (const_tree);
+extern void set_call_expr_flags (tree, int);
+extern int setjmp_call_p (const_tree);
+extern bool gimple_alloca_call_p (const_gimple);
+extern bool alloca_call_p (const_tree);
+extern bool must_pass_in_stack_var_size (enum machine_mode, const_tree);
+extern bool must_pass_in_stack_var_size_or_pad (enum machine_mode, const_tree);
+extern const struct attribute_spec *lookup_attribute_spec (const_tree);
+extern const struct attribute_spec *lookup_scoped_attribute_spec (const_tree,
+          const_tree);
+extern void init_attributes (void);
+extern tree decl_attributes (tree *, tree, int);
+extern bool cxx11_attribute_p (const_tree);
+extern tree get_attribute_name (const_tree);
+extern tree get_attribute_namespace (const_tree);
+extern void apply_tm_attr (tree, tree);
+extern void set_min_and_max_values_for_integral_type (tree, int, bool);
+extern void fixup_signed_type (tree);
+extern void internal_reference_types (void);
+extern unsigned int update_alignment_for_field (record_layout_info, tree,
+                                                unsigned int);
+extern tree tree_output_constant_def (tree);
+extern void make_decl_rtl (tree);
+extern rtx make_decl_rtl_for_debug (tree);
+extern void make_decl_one_only (tree, tree);
+extern int supports_one_only (void);
+extern void resolve_unique_section (tree, int, int);
+extern void mark_referenced (tree);
+extern void mark_decl_referenced (tree);
+extern void notice_global_symbol (tree);
+extern void set_user_assembler_name (tree, const char *);
+extern void process_pending_assemble_externals (void);
+extern bool decl_replaceable_p (tree);
+extern bool decl_binds_to_current_def_p (tree);
+extern enum tls_model decl_default_tls_model (const_tree);
+extern void declare_weak (tree);
+extern void merge_weak (tree, tree);
+extern void assemble_alias (tree, tree);
+extern tree initializer_constant_valid_p (tree, tree);
+extern bool initializer_constant_valid_for_bitfield_p (tree);
+extern bool constructor_static_from_elts_p (const_tree);
+extern void expand_computed_goto (tree);
+extern bool parse_output_constraint (const char **, int, int, int,
+         bool *, bool *, bool *);
+extern bool parse_input_constraint (const char **, int, int, int, int,
+        const char * const *, bool *, bool *);
+extern void expand_asm_stmt (gimple);
+extern tree resolve_asm_operand_names (tree, tree, tree, tree);
+struct pointer_set_t;
+typedef tree (*walk_tree_fn) (tree *, int *, void *);
+typedef tree (*walk_tree_lh) (tree *, int *, tree (*) (tree *, int *, void *),
+         void *, struct pointer_set_t*);
+extern tree walk_tree_1 (tree*, walk_tree_fn, void*, struct pointer_set_t*,
+    walk_tree_lh);
+extern tree walk_tree_without_duplicates_1 (tree*, walk_tree_fn, void*,
+         walk_tree_lh);
+extern void set_decl_rtl (tree, rtx);
+extern void set_decl_incoming_rtl (tree, rtx, bool);
+typedef enum
+{
+  d_kind,
+  t_kind,
+  b_kind,
+  s_kind,
+  r_kind,
+  e_kind,
+  c_kind,
+  id_kind,
+  vec_kind,
+  binfo_kind,
+  ssa_name_kind,
+  constr_kind,
+  x_kind,
+  lang_decl,
+  lang_type,
+  omp_clause_kind,
+  all_kinds
+} tree_node_kind;
+extern int tree_node_counts[];
+extern int tree_node_sizes[];
+extern bool in_gimple_form;
+extern tree get_base_address (tree t);
+extern void mark_addressable (tree);
+struct tree_map_base {
+  tree from;
+};
+extern int tree_map_base_eq (const void *, const void *);
+extern unsigned int tree_map_base_hash (const void *);
+extern int tree_map_base_marked_p (const void *);
+extern bool list_equal_p (const_tree, const_tree);
+struct tree_map {
+  struct tree_map_base base;
+  unsigned int hash;
+  tree to;
+};
+extern unsigned int tree_map_hash (const void *);
+struct tree_decl_map {
+  struct tree_map_base base;
+  tree to;
+};
+extern unsigned int tree_decl_map_hash (const void *);
+struct tree_int_map {
+  struct tree_map_base base;
+  unsigned int to;
+};
+struct tree_priority_map {
+  struct tree_map_base base;
+  priority_type init;
+  priority_type fini;
+};
+struct tree_vec_map {
+  struct tree_map_base base;
+  vec<tree, va_gc> *to;
+};
+tree target_for_debug_bind (tree);
+extern tree tree_mem_ref_addr (tree, tree);
+extern void copy_ref_info (tree, tree);
+extern bool ssa_name_nonnegative_p (const_tree);
+extern void init_object_sizes (void);
+extern void fini_object_sizes (void);
+extern unsigned long long compute_builtin_object_size (tree, int);
+extern int can_move_by_pieces (unsigned long long, unsigned int);
+extern bool addr_expr_of_non_mem_decl_p (tree);
+extern unsigned long long highest_pow2_factor (const_tree);
+extern tree build_personality_function (const char *);
+extern tree build_tm_abort_call (location_t, bool);
+extern bool is_tm_safe (const_tree);
+extern bool is_tm_pure (const_tree);
+extern bool is_tm_may_cancel_outer (tree);
+extern bool is_tm_ending_fndecl (tree);
+extern void record_tm_replacement (tree, tree);
+extern void tm_malloc_replacement (tree);
+static inline bool
+is_tm_safe_or_pure (const_tree x)
+{
+  return is_tm_safe (x) || is_tm_pure (x);
+}
+void init_inline_once (void);
+typedef struct call_expr_arg_iterator_d {
+  tree t;
+  int n;
+  int i;
+} call_expr_arg_iterator;
+typedef struct const_call_expr_arg_iterator_d {
+  const_tree t;
+  int n;
+  int i;
+} const_call_expr_arg_iterator;
+static inline void
+init_call_expr_arg_iterator (tree exp, call_expr_arg_iterator *iter)
+{
+  iter->t = exp;
+  iter->n = (((int)((((exp)->exp.operands[0])->int_cst.int_cst).low)) - 3);
+  iter->i = 0;
+}
+static inline void
+init_const_call_expr_arg_iterator (const_tree exp, const_call_expr_arg_iterator *iter)
+{
+  iter->t = exp;
+  iter->n = (((int)((((exp)->exp.operands[0])->int_cst.int_cst).low)) - 3);
+  iter->i = 0;
+}
+static inline tree
+next_call_expr_arg (call_expr_arg_iterator *iter)
+{
+  tree result;
+  if (iter->i >= iter->n)
+    return (tree) __null;
+  result = (((iter->t))->exp.operands[(iter->i) + 3]);
+  iter->i++;
+  return result;
+}
+static inline const_tree
+next_const_call_expr_arg (const_call_expr_arg_iterator *iter)
+{
+  const_tree result;
+  if (iter->i >= iter->n)
+    return (tree) __null;
+  result = (((iter->t))->exp.operands[(iter->i) + 3]);
+  iter->i++;
+  return result;
+}
+static inline tree
+first_call_expr_arg (tree exp, call_expr_arg_iterator *iter)
+{
+  init_call_expr_arg_iterator (exp, iter);
+  return next_call_expr_arg (iter);
+}
+static inline const_tree
+first_const_call_expr_arg (const_tree exp, const_call_expr_arg_iterator *iter)
+{
+  init_const_call_expr_arg_iterator (exp, iter);
+  return next_const_call_expr_arg (iter);
+}
+static inline bool
+more_call_expr_args_p (const call_expr_arg_iterator *iter)
+{
+  return (iter->i < iter->n);
+}
+static inline bool
+more_const_call_expr_args_p (const const_call_expr_arg_iterator *iter)
+{
+  return (iter->i < iter->n);
+}
+static inline bool
+is_lang_specific (tree t)
+{
+  return ((enum tree_code) (t)->base.code) == LANG_TYPE || ((enum tree_code) (t)->base.code) >= ((int) LAST_AND_UNUSED_TREE_CODE);
+}
+extern bool block_may_fallthru (const_tree);
+typedef struct builtin_info_type_d {
+  tree decl[(int)END_BUILTINS];
+  bool implicit_p[(int)END_BUILTINS];
+} builtin_info_type;
+extern builtin_info_type builtin_info;
+static inline tree
+builtin_decl_explicit (enum built_in_function fncode)
+{
+  ((void)(0 && ((((unsigned long long) ((int)fncode) - (unsigned long long) (((int)BUILT_IN_NONE) + 1) <= (unsigned long long) (((int) END_BUILTINS) - 1) - (unsigned long long) (((int)BUILT_IN_NONE) + 1))))));
+  return builtin_info.decl[(size_t)fncode];
+}
+static inline tree
+builtin_decl_implicit (enum built_in_function fncode)
+{
+  size_t uns_fncode = (size_t)fncode;
+  ((void)(0 && ((((unsigned long long) ((int)fncode) - (unsigned long long) (((int)BUILT_IN_NONE) + 1) <= (unsigned long long) (((int) END_BUILTINS) - 1) - (unsigned long long) (((int)BUILT_IN_NONE) + 1))))));
+  if (!builtin_info.implicit_p[uns_fncode])
+    return (tree) __null;
+  return builtin_info.decl[uns_fncode];
+}
+static inline void
+set_builtin_decl (enum built_in_function fncode, tree decl, bool implicit_p)
+{
+  size_t ufncode = (size_t)fncode;
+  ((void)(0 && ((((unsigned long long) ((int)fncode) - (unsigned long long) (((int)BUILT_IN_NONE) + 1) <= (unsigned long long) (((int) END_BUILTINS) - 1) - (unsigned long long) (((int)BUILT_IN_NONE) + 1))) && (decl != (tree) __null || !implicit_p))));
+  builtin_info.decl[ufncode] = decl;
+  builtin_info.implicit_p[ufncode] = implicit_p;
+}
+static inline void
+set_builtin_decl_implicit_p (enum built_in_function fncode, bool implicit_p)
+{
+  size_t uns_fncode = (size_t)fncode;
+  ((void)(0 && ((((unsigned long long) ((int)fncode) - (unsigned long long) (((int)BUILT_IN_NONE) + 1) <= (unsigned long long) (((int) END_BUILTINS) - 1) - (unsigned long long) (((int)BUILT_IN_NONE) + 1))) && builtin_info.decl[uns_fncode] != (tree) __null)));
+  builtin_info.implicit_p[uns_fncode] = implicit_p;
+}
+static inline bool
+builtin_decl_explicit_p (enum built_in_function fncode)
+{
+  ((void)(0 && ((((unsigned long long) ((int)fncode) - (unsigned long long) (((int)BUILT_IN_NONE) + 1) <= (unsigned long long) (((int) END_BUILTINS) - 1) - (unsigned long long) (((int)BUILT_IN_NONE) + 1))))));
+  return (builtin_info.decl[(size_t)fncode] != (tree) __null);
+}
+static inline bool
+builtin_decl_implicit_p (enum built_in_function fncode)
+{
+  size_t uns_fncode = (size_t)fncode;
+  ((void)(0 && ((((unsigned long long) ((int)fncode) - (unsigned long long) (((int)BUILT_IN_NONE) + 1) <= (unsigned long long) (((int) END_BUILTINS) - 1) - (unsigned long long) (((int)BUILT_IN_NONE) + 1))))));
+  return (builtin_info.decl[uns_fncode] != (tree) __null
+   && builtin_info.implicit_p[uns_fncode]);
+}
+typedef unsigned long HARD_REG_ELT_TYPE;
+typedef HARD_REG_ELT_TYPE HARD_REG_SET[((154 + (8 * 4) - 1) / (8 * 4))];
+struct hard_reg_set_container
+{
+  HARD_REG_SET set;
+};
+static inline bool
+hard_reg_set_subset_p (const HARD_REG_SET x, const HARD_REG_SET y)
+{
+  int i;
+  for (i = 0; i < ((154 + (8 * 4) - 1) / (8 * 4)); i++)
+    if ((x[i] & ~y[i]) != 0)
+      return false;
+  return true;
+}
+static inline bool
+hard_reg_set_equal_p (const HARD_REG_SET x, const HARD_REG_SET y)
+{
+  int i;
+  for (i = 0; i < ((154 + (8 * 4) - 1) / (8 * 4)); i++)
+    if (x[i] != y[i])
+      return false;
+  return true;
+}
+static inline bool
+hard_reg_set_intersect_p (const HARD_REG_SET x, const HARD_REG_SET y)
+{
+  int i;
+  for (i = 0; i < ((154 + (8 * 4) - 1) / (8 * 4)); i++)
+    if ((x[i] & y[i]) != 0)
+      return true;
+  return false;
+}
+static inline bool
+hard_reg_set_empty_p (const HARD_REG_SET x)
+{
+  int i;
+  for (i = 0; i < ((154 + (8 * 4) - 1) / (8 * 4)); i++)
+    if (x[i] != 0)
+      return false;
+  return true;
+}
+typedef struct
+{
+  HARD_REG_ELT_TYPE *pelt;
+  unsigned short length;
+  unsigned short word_no;
+  HARD_REG_ELT_TYPE bits;
+} hard_reg_set_iterator;
+static inline void
+hard_reg_set_iter_init (hard_reg_set_iterator *iter, HARD_REG_SET set,
+                        unsigned min, unsigned *regno)
+{
+  iter->pelt = set;
+  iter->length = ((154 + (8 * 4) - 1) / (8 * 4));
+  iter->word_no = min / ((unsigned) (8 * 4));
+  if (iter->word_no < iter->length)
+    {
+      iter->bits = iter->pelt[iter->word_no];
+      iter->bits >>= min % ((unsigned) (8 * 4));
+      min += !iter->bits;
+    }
+  *regno = min;
+}
+static inline bool
+hard_reg_set_iter_set (hard_reg_set_iterator *iter, unsigned *regno)
+{
+  while (1)
+    {
+      if (iter->word_no >= iter->length)
+        return false;
+      if (iter->bits)
+        {
+          while (!(iter->bits & 1))
+            {
+              iter->bits >>= 1;
+              *regno += 1;
+            }
+          return (*regno < 154);
+        }
+      *regno = (*regno + ((unsigned) (8 * 4)) - 1);
+      *regno -= *regno % ((unsigned) (8 * 4));
+      while (++iter->word_no < iter->length)
+        {
+          iter->bits = iter->pelt[iter->word_no];
+          if (iter->bits)
+            break;
+          *regno += ((unsigned) (8 * 4));
+        }
+    }
+}
+static inline void
+hard_reg_set_iter_next (hard_reg_set_iterator *iter, unsigned *regno)
+{
+  iter->bits >>= 1;
+  *regno += 1;
+}
+extern char global_regs[154];
+struct target_hard_regs {
+  HARD_REG_SET x_accessible_reg_set;
+  HARD_REG_SET x_operand_reg_set;
+  char x_fixed_regs[154];
+  HARD_REG_SET x_fixed_reg_set;
+  char x_call_used_regs[154];
+  char x_call_really_used_regs[154];
+  HARD_REG_SET x_call_used_reg_set;
+  HARD_REG_SET x_call_fixed_reg_set;
+  HARD_REG_SET x_regs_invalidated_by_call;
+  HARD_REG_SET x_no_caller_save_reg_set;
+  int x_reg_alloc_order[154];
+  int x_inv_reg_alloc_order[154];
+  HARD_REG_SET x_reg_class_contents[(int) LIM_REG_CLASSES];
+  bool x_class_only_fixed_regs[(int) LIM_REG_CLASSES];
+  unsigned int x_reg_class_size[(int) LIM_REG_CLASSES];
+  enum reg_class x_reg_class_subclasses[(int) LIM_REG_CLASSES][(int) LIM_REG_CLASSES];
+  enum reg_class x_reg_class_subunion[(int) LIM_REG_CLASSES][(int) LIM_REG_CLASSES];
+  enum reg_class x_reg_class_superunion[(int) LIM_REG_CLASSES][(int) LIM_REG_CLASSES];
+  const char *x_reg_names[154];
+};
+extern struct target_hard_regs default_target_hard_regs;
+extern const char * reg_class_names[];
+extern int max_regno;
+struct regstat_n_sets_and_refs_t
+{
+  int sets;
+  int refs;
+};
+extern struct regstat_n_sets_and_refs_t *regstat_n_sets_and_refs;
+static inline int
+REG_N_REFS(int regno)
+{
+  return regstat_n_sets_and_refs[regno].refs;
+}
+static inline int
+REG_N_SETS (int regno)
+{
+  return regstat_n_sets_and_refs[regno].sets;
+}
+extern bool reg_is_parm_p (rtx);
+extern void regstat_init_n_sets_and_refs (void);
+extern void regstat_free_n_sets_and_refs (void);
+extern void regstat_compute_ri (void);
+extern void regstat_free_ri (void);
+extern bitmap regstat_get_setjmp_crosses (void);
+extern void regstat_compute_calls_crossed (void);
+extern void regstat_free_calls_crossed (void);
+extern void dump_reg_info (FILE *);
+struct reg_info_t
+{
+  int freq;
+  int deaths;
+  int live_length;
+  int calls_crossed;
+  int freq_calls_crossed;
+  int throw_calls_crossed;
+  int basic_block;
+};
+extern struct reg_info_t *reg_info_p;
+extern size_t reg_info_p_size;
+extern short *reg_renumber;
+extern int caller_save_needed;
+struct target_regs {
+  unsigned char x_hard_regno_nregs[154][MAX_MACHINE_MODE];
+  enum machine_mode x_reg_raw_mode[154];
+  bool x_have_regs_of_mode[MAX_MACHINE_MODE];
+  char x_contains_reg_of_mode[(int) LIM_REG_CLASSES][MAX_MACHINE_MODE];
+  char x_direct_load[NUM_MACHINE_MODES];
+  char x_direct_store[NUM_MACHINE_MODES];
+  bool x_float_extend_from_mem[NUM_MACHINE_MODES][NUM_MACHINE_MODES];
+};
+extern struct target_regs default_target_regs;
+static inline unsigned int
+end_hard_regno (enum machine_mode mode, unsigned int regno)
+{
+  return regno + ((&default_target_regs)->x_hard_regno_nregs)[regno][(int) mode];
+}
+static inline void
+add_to_hard_reg_set (HARD_REG_SET *regs, enum machine_mode mode,
+       unsigned int regno)
+{
+  unsigned int end_regno;
+  end_regno = end_hard_regno (mode, regno);
+  do
+    ((*regs)[(regno) / ((unsigned) (8 * 4))] |= ((HARD_REG_ELT_TYPE) (1)) << ((regno) % ((unsigned) (8 * 4))));
+  while (++regno < end_regno);
+}
+static inline void
+remove_from_hard_reg_set (HARD_REG_SET *regs, enum machine_mode mode,
+     unsigned int regno)
+{
+  unsigned int end_regno;
+  end_regno = end_hard_regno (mode, regno);
+  do
+    ((*regs)[(regno) / ((unsigned) (8 * 4))] &= ~(((HARD_REG_ELT_TYPE) (1)) << ((regno) % ((unsigned) (8 * 4)))));
+  while (++regno < end_regno);
+}
+static inline bool
+in_hard_reg_set_p (const HARD_REG_SET regs, enum machine_mode mode,
+     unsigned int regno)
+{
+  unsigned int end_regno;
+  ((void)(!(((regno) < 154)) ? fancy_abort ("../../gcc/regs.h", 344, __FUNCTION__), 0 : 0));
+  if (!(!!((regs)[(regno) / ((unsigned) (8 * 4))] & (((HARD_REG_ELT_TYPE) (1)) << ((regno) % ((unsigned) (8 * 4)))))))
+    return false;
+  end_regno = end_hard_regno (mode, regno);
+  if (!((end_regno - 1) < 154))
+    return false;
+  while (++regno < end_regno)
+    if (!(!!((regs)[(regno) / ((unsigned) (8 * 4))] & (((HARD_REG_ELT_TYPE) (1)) << ((regno) % ((unsigned) (8 * 4)))))))
+      return false;
+  return true;
+}
+static inline bool
+overlaps_hard_reg_set_p (const HARD_REG_SET regs, enum machine_mode mode,
+    unsigned int regno)
+{
+  unsigned int end_regno;
+  if ((!!((regs)[(regno) / ((unsigned) (8 * 4))] & (((HARD_REG_ELT_TYPE) (1)) << ((regno) % ((unsigned) (8 * 4)))))))
+    return true;
+  end_regno = end_hard_regno (mode, regno);
+  while (++regno < end_regno)
+    if ((!!((regs)[(regno) / ((unsigned) (8 * 4))] & (((HARD_REG_ELT_TYPE) (1)) << ((regno) % ((unsigned) (8 * 4)))))))
+      return true;
+  return false;
+}
+static inline void
+add_range_to_hard_reg_set (HARD_REG_SET *regs, unsigned int regno,
+      int nregs)
+{
+  while (nregs-- > 0)
+    ((*regs)[(regno + nregs) / ((unsigned) (8 * 4))] |= ((HARD_REG_ELT_TYPE) (1)) << ((regno + nregs) % ((unsigned) (8 * 4))));
+}
+static inline void
+remove_range_from_hard_reg_set (HARD_REG_SET *regs, unsigned int regno,
+    int nregs)
+{
+  while (nregs-- > 0)
+    ((*regs)[(regno + nregs) / ((unsigned) (8 * 4))] &= ~(((HARD_REG_ELT_TYPE) (1)) << ((regno + nregs) % ((unsigned) (8 * 4)))));
+}
+static inline bool
+range_overlaps_hard_reg_set_p (const HARD_REG_SET set, unsigned regno,
+          int nregs)
+{
+  while (nregs-- > 0)
+    if ((!!((set)[(regno + nregs) / ((unsigned) (8 * 4))] & (((HARD_REG_ELT_TYPE) (1)) << ((regno + nregs) % ((unsigned) (8 * 4)))))))
+      return true;
+  return false;
+}
+static inline bool
+range_in_hard_reg_set_p (const HARD_REG_SET set, unsigned regno, int nregs)
+{
+  while (nregs-- > 0)
+    if (!(!!((set)[(regno + nregs) / ((unsigned) (8 * 4))] & (((HARD_REG_ELT_TYPE) (1)) << ((regno + nregs) % ((unsigned) (8 * 4)))))))
+      return false;
+  return true;
+}
+struct function;
+struct eh_region_d;
+struct pointer_map_t;
+enum eh_region_type
+{
+  ERT_CLEANUP,
+  ERT_TRY,
+  ERT_ALLOWED_EXCEPTIONS,
+  ERT_MUST_NOT_THROW
+};
+struct eh_landing_pad_d
+{
+  struct eh_landing_pad_d *next_lp;
+  struct eh_region_d *region;
+  tree post_landing_pad;
+  rtx landing_pad;
+  int index;
+};
+struct eh_catch_d
+{
+  struct eh_catch_d *next_catch;
+  struct eh_catch_d *prev_catch;
+  tree type_list;
+  tree filter_list;
+  tree label;
+};
+struct eh_region_d
+{
+  struct eh_region_d *outer;
+  struct eh_region_d *inner;
+  struct eh_region_d *next_peer;
+  int index;
+  enum eh_region_type type;
+  union eh_region_u {
+    struct eh_region_u_try {
+      struct eh_catch_d *first_catch;
+      struct eh_catch_d *last_catch;
+    } eh_try;
+    struct eh_region_u_allowed {
+      tree type_list;
+      tree label;
+      int filter;
+    } allowed;
+    struct eh_region_u_must_not_throw {
+      tree failure_decl;
+      location_t failure_loc;
+    } must_not_throw;
+  } u;
+  struct eh_landing_pad_d *landing_pads;
+  rtx exc_ptr_reg, filter_reg;
+  bool use_cxa_end_cleanup;
+};
+typedef struct eh_landing_pad_d *eh_landing_pad;
+typedef struct eh_catch_d *eh_catch;
+typedef struct eh_region_d *eh_region;
+struct eh_status
+{
+  eh_region region_tree;
+  vec<eh_region, va_gc> *region_array;
+  vec<eh_landing_pad, va_gc> *lp_array;
+  htab_t throw_stmt_table;
+  vec<tree, va_gc> *ttype_data;
+  union eh_status_u {
+    vec<tree, va_gc> * arm_eabi;
+    vec<uchar, va_gc> * other;
+  } ehspec_data;
+};
+extern void for_each_eh_label (void (*) (rtx, void*), void*);
+extern void init_eh_for_function (void);
+extern void remove_eh_landing_pad (eh_landing_pad);
+extern void remove_eh_handler (eh_region);
+extern void remove_unreachable_eh_regions (sbitmap);
+extern bool current_function_has_exception_handlers (void);
+extern void output_function_exception_table (const char *);
+extern rtx expand_builtin_eh_pointer (tree);
+extern rtx expand_builtin_eh_filter (tree);
+extern rtx expand_builtin_eh_copy_values (tree);
+extern void expand_builtin_unwind_init (void);
+extern rtx expand_builtin_eh_return_data_regno (tree);
+extern rtx expand_builtin_extract_return_addr (tree);
+extern void expand_builtin_init_dwarf_reg_sizes (tree);
+extern rtx expand_builtin_frob_return_addr (tree);
+extern rtx expand_builtin_dwarf_sp_column (void);
+extern void expand_builtin_eh_return (tree, tree);
+extern void expand_eh_return (void);
+extern rtx expand_builtin_extend_pointer (tree);
+extern void expand_dw2_landing_pad_for_region (eh_region);
+typedef tree (*duplicate_eh_regions_map) (tree, void *);
+extern struct pointer_map_t *duplicate_eh_regions
+  (struct function *, eh_region, int, duplicate_eh_regions_map, void *);
+extern void sjlj_emit_function_exit_after (rtx);
+extern eh_region gen_eh_region_cleanup (eh_region);
+extern eh_region gen_eh_region_try (eh_region);
+extern eh_region gen_eh_region_allowed (eh_region, tree);
+extern eh_region gen_eh_region_must_not_throw (eh_region);
+extern eh_catch gen_eh_region_catch (eh_region, tree);
+extern eh_landing_pad gen_eh_landing_pad (eh_region);
+extern eh_region get_eh_region_from_number_fn (struct function *, int);
+extern eh_region get_eh_region_from_number (int);
+extern eh_landing_pad get_eh_landing_pad_from_number_fn (struct function*,int);
+extern eh_landing_pad get_eh_landing_pad_from_number (int);
+extern eh_region get_eh_region_from_lp_number_fn (struct function *, int);
+extern eh_region get_eh_region_from_lp_number (int);
+extern eh_region eh_region_outermost (struct function *, eh_region, eh_region);
+extern void make_reg_eh_region_note (rtx insn, int ecf_flags, int lp_nr);
+extern void make_reg_eh_region_note_nothrow_nononlocal (rtx);
+extern void verify_eh_tree (struct function *);
+extern void dump_eh_tree (FILE *, struct function *);
+void debug_eh_tree (struct function *);
+extern void add_type_for_runtime (tree);
+extern tree lookup_type_for_runtime (tree);
+extern void assign_filter_values (void);
+extern eh_region get_eh_region_from_rtx (const_rtx);
+extern eh_landing_pad get_eh_landing_pad_from_rtx (const_rtx);
+extern void finish_eh_generation (void);
+struct throw_stmt_node {
+  gimple stmt;
+  int lp_nr;
+};
+extern struct htab *get_eh_throw_stmt_table (struct function *);
+extern void set_eh_throw_stmt_table (struct function *, struct htab *);
+enum eh_personality_kind {
+  eh_personality_none,
+  eh_personality_any,
+  eh_personality_lang
+};
+extern enum eh_personality_kind
+function_needs_eh_personality (struct function *);
+static inline eh_region
+ehr_next (eh_region r, eh_region start)
+{
+  if (r->inner)
+    r = r->inner;
+  else if (r->next_peer && r != start)
+    r = r->next_peer;
+  else
+    {
+      do
+ {
+   r = r->outer;
+   if (r == start)
+     return __null;
+ }
+      while (r->next_peer == __null);
+      r = r->next_peer;
+    }
+  return r;
+}
+typedef unsigned long BITMAP_WORD;
+typedef struct bitmap_obstack {
+  struct bitmap_element_def *elements;
+  struct bitmap_head_def *heads;
+  struct obstack obstack;
+} bitmap_obstack;
+typedef struct bitmap_element_def {
+  struct bitmap_element_def *next;
+  struct bitmap_element_def *prev;
+  unsigned int indx;
+  BITMAP_WORD bits[((128 + (8 * 4 * 1u) - 1) / (8 * 4 * 1u))];
+} bitmap_element;
+typedef struct bitmap_head_def {
+  unsigned int indx;
+  unsigned int descriptor_id;
+  bitmap_element *first;
+  bitmap_element * current;
+  bitmap_obstack *obstack;
+} bitmap_head;
+extern bitmap_element bitmap_zero_bits;
+extern bitmap_obstack bitmap_default_obstack;
+extern void bitmap_clear (bitmap);
+extern void bitmap_copy (bitmap, const_bitmap);
+extern bool bitmap_equal_p (const_bitmap, const_bitmap);
+extern bool bitmap_intersect_p (const_bitmap, const_bitmap);
+extern bool bitmap_intersect_compl_p (const_bitmap, const_bitmap);
+inline bool bitmap_empty_p (const_bitmap map)
+{
+  return !map->first;
+}
+extern bool bitmap_single_bit_set_p (const_bitmap);
+extern unsigned long bitmap_count_bits (const_bitmap);
+extern void bitmap_and (bitmap, const_bitmap, const_bitmap);
+extern bool bitmap_and_into (bitmap, const_bitmap);
+extern bool bitmap_and_compl (bitmap, const_bitmap, const_bitmap);
+extern bool bitmap_and_compl_into (bitmap, const_bitmap);
+extern void bitmap_compl_and_into (bitmap, const_bitmap);
+extern void bitmap_clear_range (bitmap, unsigned int, unsigned int);
+extern void bitmap_set_range (bitmap, unsigned int, unsigned int);
+extern bool bitmap_ior (bitmap, const_bitmap, const_bitmap);
+extern bool bitmap_ior_into (bitmap, const_bitmap);
+extern void bitmap_xor (bitmap, const_bitmap, const_bitmap);
+extern void bitmap_xor_into (bitmap, const_bitmap);
+extern bool bitmap_ior_and_into (bitmap DST, const_bitmap B, const_bitmap C);
+extern bool bitmap_ior_and_compl (bitmap DST, const_bitmap A,
+      const_bitmap B, const_bitmap C);
+extern bool bitmap_ior_and_compl_into (bitmap A,
+           const_bitmap B, const_bitmap C);
+extern bool bitmap_clear_bit (bitmap, int);
+extern bool bitmap_set_bit (bitmap, int);
+extern int bitmap_bit_p (bitmap, int);
+extern void debug_bitmap (const_bitmap);
+extern void debug_bitmap_file (FILE *, const_bitmap);
+extern void bitmap_print (FILE *, const_bitmap, const char *, const char *);
+extern void bitmap_obstack_initialize (bitmap_obstack *);
+extern void bitmap_obstack_release (bitmap_obstack *);
+extern void bitmap_register (bitmap );
+extern void dump_bitmap_statistics (void);
+static inline void
+bitmap_initialize_stat (bitmap head, bitmap_obstack *obstack )
+{
+  head->first = head->current = __null;
+  head->obstack = obstack;
+  if (0)
+    bitmap_register (head );
+}
+extern bitmap bitmap_obstack_alloc_stat (bitmap_obstack *obstack );
+extern bitmap bitmap_gc_alloc_stat (void);
+extern void bitmap_obstack_free (bitmap);
+inline void dump_bitmap (FILE *file, const_bitmap map)
+{
+  bitmap_print (file, map, "", "\n");
+}
+extern unsigned bitmap_first_set_bit (const_bitmap);
+extern unsigned bitmap_last_set_bit (const_bitmap);
+extern hashval_t bitmap_hash(const_bitmap);
+typedef struct
+{
+  bitmap_element *elt1;
+  bitmap_element *elt2;
+  unsigned word_no;
+  BITMAP_WORD bits;
+} bitmap_iterator;
+static inline void
+bmp_iter_set_init (bitmap_iterator *bi, const_bitmap map,
+     unsigned start_bit, unsigned *bit_no)
+{
+  bi->elt1 = map->first;
+  bi->elt2 = __null;
+  while (1)
+    {
+      if (!bi->elt1)
+ {
+   bi->elt1 = &bitmap_zero_bits;
+   break;
+ }
+      if (bi->elt1->indx >= start_bit / (((128 + (8 * 4 * 1u) - 1) / (8 * 4 * 1u)) * (8 * 4 * 1u)))
+ break;
+      bi->elt1 = bi->elt1->next;
+    }
+  if (bi->elt1->indx != start_bit / (((128 + (8 * 4 * 1u) - 1) / (8 * 4 * 1u)) * (8 * 4 * 1u)))
+    start_bit = bi->elt1->indx * (((128 + (8 * 4 * 1u) - 1) / (8 * 4 * 1u)) * (8 * 4 * 1u));
+  bi->word_no = start_bit / (8 * 4 * 1u) % ((128 + (8 * 4 * 1u) - 1) / (8 * 4 * 1u));
+  bi->bits = bi->elt1->bits[bi->word_no];
+  bi->bits >>= start_bit % (8 * 4 * 1u);
+  start_bit += !bi->bits;
+  *bit_no = start_bit;
+}
+static inline void
+bmp_iter_and_init (bitmap_iterator *bi, const_bitmap map1, const_bitmap map2,
+     unsigned start_bit, unsigned *bit_no)
+{
+  bi->elt1 = map1->first;
+  bi->elt2 = map2->first;
+  while (1)
+    {
+      if (!bi->elt1)
+ {
+   bi->elt2 = __null;
+   break;
+ }
+      if (bi->elt1->indx >= start_bit / (((128 + (8 * 4 * 1u) - 1) / (8 * 4 * 1u)) * (8 * 4 * 1u)))
+ break;
+      bi->elt1 = bi->elt1->next;
+    }
+  while (1)
+    {
+      if (!bi->elt2)
+ {
+   bi->elt1 = bi->elt2 = &bitmap_zero_bits;
+   break;
+ }
+      if (bi->elt2->indx >= bi->elt1->indx)
+ break;
+      bi->elt2 = bi->elt2->next;
+    }
+  if (bi->elt1->indx == bi->elt2->indx)
+    {
+      if (bi->elt1->indx != start_bit / (((128 + (8 * 4 * 1u) - 1) / (8 * 4 * 1u)) * (8 * 4 * 1u)))
+ start_bit = bi->elt1->indx * (((128 + (8 * 4 * 1u) - 1) / (8 * 4 * 1u)) * (8 * 4 * 1u));
+      bi->word_no = start_bit / (8 * 4 * 1u) % ((128 + (8 * 4 * 1u) - 1) / (8 * 4 * 1u));
+      bi->bits = bi->elt1->bits[bi->word_no] & bi->elt2->bits[bi->word_no];
+      bi->bits >>= start_bit % (8 * 4 * 1u);
+    }
+  else
+    {
+      bi->word_no = ((128 + (8 * 4 * 1u) - 1) / (8 * 4 * 1u)) - 1;
+      bi->bits = 0;
+    }
+  start_bit += !bi->bits;
+  *bit_no = start_bit;
+}
+static inline void
+bmp_iter_and_compl_init (bitmap_iterator *bi,
+    const_bitmap map1, const_bitmap map2,
+    unsigned start_bit, unsigned *bit_no)
+{
+  bi->elt1 = map1->first;
+  bi->elt2 = map2->first;
+  while (1)
+    {
+      if (!bi->elt1)
+ {
+   bi->elt1 = &bitmap_zero_bits;
+   break;
+ }
+      if (bi->elt1->indx >= start_bit / (((128 + (8 * 4 * 1u) - 1) / (8 * 4 * 1u)) * (8 * 4 * 1u)))
+ break;
+      bi->elt1 = bi->elt1->next;
+    }
+  while (bi->elt2 && bi->elt2->indx < bi->elt1->indx)
+    bi->elt2 = bi->elt2->next;
+  if (bi->elt1->indx != start_bit / (((128 + (8 * 4 * 1u) - 1) / (8 * 4 * 1u)) * (8 * 4 * 1u)))
+    start_bit = bi->elt1->indx * (((128 + (8 * 4 * 1u) - 1) / (8 * 4 * 1u)) * (8 * 4 * 1u));
+  bi->word_no = start_bit / (8 * 4 * 1u) % ((128 + (8 * 4 * 1u) - 1) / (8 * 4 * 1u));
+  bi->bits = bi->elt1->bits[bi->word_no];
+  if (bi->elt2 && bi->elt1->indx == bi->elt2->indx)
+    bi->bits &= ~bi->elt2->bits[bi->word_no];
+  bi->bits >>= start_bit % (8 * 4 * 1u);
+  start_bit += !bi->bits;
+  *bit_no = start_bit;
+}
+static inline void
+bmp_iter_next (bitmap_iterator *bi, unsigned *bit_no)
+{
+  bi->bits >>= 1;
+  *bit_no += 1;
+}
+static inline void
+bmp_iter_next_bit (bitmap_iterator * bi, unsigned *bit_no)
+{
+  {
+    unsigned int n = __builtin_ctzl (bi->bits);
+    ((void)(!(sizeof (unsigned long) == sizeof (BITMAP_WORD)) ? fancy_abort ("../../gcc/bitmap.h", 509, __FUNCTION__), 0 : 0));
+    bi->bits >>= n;
+    *bit_no += n;
+  }
+}
+static inline bool
+bmp_iter_set (bitmap_iterator *bi, unsigned *bit_no)
+{
+  if (bi->bits)
+    {
+    next_bit:
+      bmp_iter_next_bit (bi, bit_no);
+      return true;
+    }
+  *bit_no = ((*bit_no + (8 * 4 * 1u) - 1)
+      / (8 * 4 * 1u) * (8 * 4 * 1u));
+  bi->word_no++;
+  while (1)
+    {
+      while (bi->word_no != ((128 + (8 * 4 * 1u) - 1) / (8 * 4 * 1u)))
+ {
+   bi->bits = bi->elt1->bits[bi->word_no];
+   if (bi->bits)
+     goto next_bit;
+   *bit_no += (8 * 4 * 1u);
+   bi->word_no++;
+ }
+      bi->elt1 = bi->elt1->next;
+      if (!bi->elt1)
+ return false;
+      *bit_no = bi->elt1->indx * (((128 + (8 * 4 * 1u) - 1) / (8 * 4 * 1u)) * (8 * 4 * 1u));
+      bi->word_no = 0;
+    }
+}
+static inline bool
+bmp_iter_and (bitmap_iterator *bi, unsigned *bit_no)
+{
+  if (bi->bits)
+    {
+    next_bit:
+      bmp_iter_next_bit (bi, bit_no);
+      return true;
+    }
+  *bit_no = ((*bit_no + (8 * 4 * 1u) - 1)
+      / (8 * 4 * 1u) * (8 * 4 * 1u));
+  bi->word_no++;
+  while (1)
+    {
+      while (bi->word_no != ((128 + (8 * 4 * 1u) - 1) / (8 * 4 * 1u)))
+ {
+   bi->bits = bi->elt1->bits[bi->word_no] & bi->elt2->bits[bi->word_no];
+   if (bi->bits)
+     goto next_bit;
+   *bit_no += (8 * 4 * 1u);
+   bi->word_no++;
+ }
+      do
+ {
+   do
+     {
+       bi->elt1 = bi->elt1->next;
+       if (!bi->elt1)
+  return false;
+     }
+   while (bi->elt1->indx < bi->elt2->indx);
+   while (bi->elt2->indx < bi->elt1->indx)
+     {
+       bi->elt2 = bi->elt2->next;
+       if (!bi->elt2)
+  return false;
+     }
+ }
+      while (bi->elt1->indx != bi->elt2->indx);
+      *bit_no = bi->elt1->indx * (((128 + (8 * 4 * 1u) - 1) / (8 * 4 * 1u)) * (8 * 4 * 1u));
+      bi->word_no = 0;
+    }
+}
+static inline bool
+bmp_iter_and_compl (bitmap_iterator *bi, unsigned *bit_no)
+{
+  if (bi->bits)
+    {
+    next_bit:
+      bmp_iter_next_bit (bi, bit_no);
+      return true;
+    }
+  *bit_no = ((*bit_no + (8 * 4 * 1u) - 1)
+      / (8 * 4 * 1u) * (8 * 4 * 1u));
+  bi->word_no++;
+  while (1)
+    {
+      while (bi->word_no != ((128 + (8 * 4 * 1u) - 1) / (8 * 4 * 1u)))
+ {
+   bi->bits = bi->elt1->bits[bi->word_no];
+   if (bi->elt2 && bi->elt2->indx == bi->elt1->indx)
+     bi->bits &= ~bi->elt2->bits[bi->word_no];
+   if (bi->bits)
+     goto next_bit;
+   *bit_no += (8 * 4 * 1u);
+   bi->word_no++;
+ }
+      bi->elt1 = bi->elt1->next;
+      if (!bi->elt1)
+ return false;
+      while (bi->elt2 && bi->elt2->indx < bi->elt1->indx)
+ bi->elt2 = bi->elt2->next;
+      *bit_no = bi->elt1->indx * (((128 + (8 * 4 * 1u) - 1) / (8 * 4 * 1u)) * (8 * 4 * 1u));
+      bi->word_no = 0;
+    }
+}
+typedef bitmap_head regset_head;
+typedef bitmap regset;
+extern void reg_set_to_hard_reg_set (HARD_REG_SET *, const_bitmap);
+typedef bitmap_iterator reg_set_iterator;
+extern regset regs_invalidated_by_call_regset;
+extern regset fixed_reg_set_regset;
+extern bitmap_obstack reg_obstack;
+extern void dump_regset (regset, FILE *);
+struct simple_bitmap_def
+{
+  unsigned char *popcount;
+  unsigned int n_bits;
+  unsigned int size;
+  unsigned long elms[1];
+};
+static inline unsigned long
+bitmap_bit_p (const_sbitmap map, int bitno)
+{
+  size_t i = bitno / ((8 * 4) * 1u);
+  unsigned int s = bitno % ((8 * 4) * 1u);
+  return (map->elms[i] >> s) & (unsigned long) 1;
+}
+static inline void
+bitmap_set_bit (sbitmap map, int bitno)
+{
+  ((void)(0 && (! map->popcount)));
+  map->elms[bitno / ((8 * 4) * 1u)]
+    |= (unsigned long) 1 << (bitno) % ((8 * 4) * 1u);
+}
+static inline void
+bitmap_clear_bit (sbitmap map, int bitno)
+{
+  ((void)(0 && (! map->popcount)));
+  map->elms[bitno / ((8 * 4) * 1u)]
+    &= ~((unsigned long) 1 << (bitno) % ((8 * 4) * 1u));
+}
+typedef struct {
+  const unsigned long *ptr;
+  unsigned int size;
+  unsigned int word_num;
+  unsigned int bit_num;
+  unsigned long word;
+} sbitmap_iterator;
+static inline void
+bmp_iter_set_init (sbitmap_iterator *i, const_sbitmap bmp,
+     unsigned int min, unsigned *bit_no __attribute__ ((__unused__)))
+{
+  i->word_num = min / (unsigned int) ((8 * 4) * 1u);
+  i->bit_num = min;
+  i->size = bmp->size;
+  i->ptr = bmp->elms;
+  if (i->word_num >= i->size)
+    i->word = 0;
+  else
+    i->word = (i->ptr[i->word_num]
+        >> (i->bit_num % (unsigned int) ((8 * 4) * 1u)));
+}
+static inline bool
+bmp_iter_set (sbitmap_iterator *i, unsigned int *n)
+{
+  for (; i->word == 0; i->word = i->ptr[i->word_num])
+    {
+      i->word_num++;
+      if (i->word_num >= i->size)
+ return false;
+      i->bit_num = i->word_num * ((8 * 4) * 1u);
+    }
+  for (; (i->word & 1) == 0; i->word >>= 1)
+    i->bit_num++;
+  *n = i->bit_num;
+  return true;
+}
+static inline void
+bmp_iter_next (sbitmap_iterator *i, unsigned *bit_no __attribute__ ((__unused__)))
+{
+  i->word >>= 1;
+  i->bit_num++;
+}
+inline void sbitmap_free (sbitmap map)
+{
+  free (map->popcount);
+  free (map);
+}
+inline void sbitmap_vector_free (sbitmap * vec)
+{
+  free (vec);
+}
+extern void dump_bitmap (FILE *, const_sbitmap);
+extern void dump_bitmap_file (FILE *, const_sbitmap);
+extern void dump_bitmap_vector (FILE *, const char *, const char *, sbitmap *,
+     int);
+extern sbitmap sbitmap_alloc (unsigned int);
+extern sbitmap sbitmap_alloc_with_popcount (unsigned int);
+extern sbitmap *sbitmap_vector_alloc (unsigned int, unsigned int);
+extern sbitmap sbitmap_resize (sbitmap, unsigned int, int);
+extern void bitmap_copy (sbitmap, const_sbitmap);
+extern int bitmap_equal_p (const_sbitmap, const_sbitmap);
+extern bool bitmap_empty_p (const_sbitmap);
+extern void bitmap_clear (sbitmap);
+extern void bitmap_ones (sbitmap);
+extern void bitmap_vector_clear (sbitmap *, unsigned int);
+extern void bitmap_vector_ones (sbitmap *, unsigned int);
+extern bool bitmap_ior_and_compl (sbitmap, const_sbitmap,
+          const_sbitmap, const_sbitmap);
+extern void bitmap_and_compl (sbitmap, const_sbitmap, const_sbitmap);
+extern void bitmap_not (sbitmap, const_sbitmap);
+extern bool bitmap_or_and (sbitmap, const_sbitmap,
+         const_sbitmap, const_sbitmap);
+extern bool bitmap_and_or (sbitmap, const_sbitmap,
+         const_sbitmap, const_sbitmap);
+extern bool bitmap_intersect_p (const_sbitmap, const_sbitmap);
+extern bool bitmap_and (sbitmap, const_sbitmap, const_sbitmap);
+extern bool bitmap_ior (sbitmap, const_sbitmap, const_sbitmap);
+extern bool bitmap_xor (sbitmap, const_sbitmap, const_sbitmap);
+extern bool bitmap_subset_p (const_sbitmap, const_sbitmap);
+extern int bitmap_first_set_bit (const_sbitmap);
+extern int bitmap_last_set_bit (const_sbitmap);
+extern void debug_bitmap (const_sbitmap);
+extern sbitmap sbitmap_realloc (sbitmap, unsigned int);
+extern unsigned long sbitmap_popcount (const_sbitmap, unsigned long);
+enum br_predictor
+{
+PRED_COMBINED,
+PRED_DS_THEORY,
+PRED_FIRST_MATCH,
+PRED_NO_PREDICTION,
+PRED_UNCONDITIONAL,
+PRED_LOOP_ITERATIONS,
+PRED_BUILTIN_EXPECT,
+PRED_LOOP_ITERATIONS_GUESSED,
+PRED_CONTINUE,
+PRED_NORETURN,
+PRED_COLD_FUNCTION,
+PRED_LOOP_BRANCH,
+PRED_LOOP_EXIT,
+PRED_POINTER,
+PRED_TREE_POINTER,
+PRED_OPCODE_POSITIVE,
+PRED_OPCODE_NONEQUAL,
+PRED_FPOPCODE,
+PRED_TREE_OPCODE_POSITIVE,
+PRED_TREE_OPCODE_NONEQUAL,
+PRED_TREE_FPOPCODE,
+PRED_CALL,
+PRED_TREE_EARLY_RETURN,
+PRED_GOTO,
+PRED_CONST_RETURN,
+PRED_NEGATIVE_RETURN,
+PRED_NULL_RETURN,
+PRED_MUDFLAP,
+PRED_LOOP_IV_COMPARE_GUESS,
+PRED_LOOP_IV_COMPARE,
+PRED_HOT_LABEL,
+PRED_COLD_LABEL,
+  END_PREDICTORS
+};
+enum prediction
+{
+   NOT_TAKEN,
+   TAKEN
+};
+extern void predict_insn_def (rtx, enum br_predictor, enum prediction);
+extern int counts_to_freqs (void);
+extern void estimate_bb_frequencies (void);
+extern const char *predictor_name (enum br_predictor);
+extern tree build_predict_expr (enum br_predictor, enum prediction);
+extern void tree_estimate_probability (void);
+extern void compute_function_frequency (void);
+extern void rebuild_frequencies (void);
+struct sequence_stack {
+  rtx first;
+  rtx last;
+  struct sequence_stack *next;
+};
+struct emit_status {
+  int x_reg_rtx_no;
+  int x_first_label_num;
+  rtx x_first_insn;
+  rtx x_last_insn;
+  struct sequence_stack *sequence_stack;
+  int x_cur_insn_uid;
+  int x_cur_debug_insn_uid;
+  int regno_pointer_align_length;
+  unsigned char * regno_pointer_align;
+};
+extern rtx * regno_reg_rtx;
+struct expr_status {
+  int x_pending_stack_adjust;
+  int x_inhibit_defer_pop;
+  int x_stack_pointer_delta;
+  rtx x_saveregs_value;
+  rtx x_apply_args_value;
+  rtx x_forced_labels;
+};
+typedef struct call_site_record_d *call_site_record;
+struct rtl_eh {
+  rtx ehr_stackadj;
+  rtx ehr_handler;
+  rtx ehr_label;
+  rtx sjlj_fc;
+  rtx sjlj_exit_after;
+  vec<uchar, va_gc> *action_record_data;
+  vec<call_site_record, va_gc> *call_site_record_v[2];
+};
+struct gimple_df;
+struct temp_slot;
+typedef struct temp_slot *temp_slot_p;
+struct call_site_record_d;
+struct dw_fde_struct;
+struct ipa_opt_pass_d;
+typedef struct ipa_opt_pass_d *ipa_opt_pass;
+struct varasm_status {
+  struct rtx_constant_pool *pool;
+  unsigned int deferred_constants;
+};
+struct incoming_args {
+  int pops_args;
+  int size;
+  int pretend_args_size;
+  rtx arg_offset_rtx;
+  struct sh_args info;
+  rtx internal_arg_pointer;
+};
+struct function_subsections {
+  const char *hot_section_label;
+  const char *cold_section_label;
+  const char *hot_section_end_label;
+  const char *cold_section_end_label;
+};
+struct frame_space
+{
+  struct frame_space *next;
+  long long start;
+  long long length;
+};
+struct rtl_data {
+  struct expr_status expr;
+  struct emit_status emit;
+  struct varasm_status varasm;
+  struct incoming_args args;
+  struct function_subsections subsections;
+  struct rtl_eh eh;
+  int outgoing_args_size;
+  rtx return_rtx;
+  struct initial_value_struct *hard_reg_initial_vals;
+  tree stack_protect_guard;
+  rtx x_nonlocal_goto_handler_labels;
+  rtx x_return_label;
+  rtx x_naked_return_label;
+  rtx x_stack_slot_list;
+  struct frame_space *frame_space_list;
+  rtx x_stack_check_probe_note;
+  rtx x_arg_pointer_save_area;
+  rtx drap_reg;
+  long long x_frame_offset;
+  rtx x_parm_birth_insn;
+  vec<temp_slot_p, va_gc> *x_used_temp_slots;
+  struct temp_slot *x_avail_temp_slots;
+  int x_temp_slot_level;
+  unsigned int stack_alignment_needed;
+  unsigned int preferred_stack_boundary;
+  unsigned int parm_stack_boundary;
+  unsigned int max_used_stack_slot_alignment;
+  unsigned int stack_alignment_estimated;
+  bool accesses_prior_frames;
+  bool calls_eh_return;
+  bool saves_all_registers;
+  bool has_nonlocal_goto;
+  bool has_asm_statement;
+  bool all_throwers_are_sibcalls;
+  bool limit_stack;
+  bool profile;
+  bool uses_const_pool;
+  bool uses_pic_offset_table;
+  bool uses_eh_lsda;
+  bool tail_call_emit;
+  bool arg_pointer_save_area_init;
+  bool frame_pointer_needed;
+  bool maybe_hot_insn_p;
+  bool stack_realign_needed;
+  bool stack_realign_tried;
+  bool need_drap;
+  bool stack_realign_processed;
+  bool stack_realign_finalized;
+  bool dbr_scheduled_p;
+  bool nothrow;
+  bool shrink_wrapped;
+  bool sp_is_unchanging;
+  bool is_leaf;
+  bool uses_only_leaf_regs;
+  HARD_REG_SET asm_clobbers;
+};
+extern struct rtl_data x_rtl;
+struct stack_usage
+{
+  long long static_stack_size;
+  long long dynamic_stack_size;
+  int pushed_stack_size;
+  unsigned int has_unbounded_dynamic_stack_size : 1;
+};
+struct function {
+  struct eh_status *eh;
+  struct control_flow_graph *cfg;
+  gimple_seq gimple_body;
+  struct gimple_df *gimple_df;
+  struct loops *x_current_loops;
+  struct stack_usage *su;
+  htab_t value_histograms;
+  tree decl;
+  tree static_chain_decl;
+  tree nonlocal_goto_save_area;
+  vec<tree, va_gc> *local_decls;
+  struct machine_function * machine;
+  struct language_function * language;
+  htab_t used_types_hash;
+  struct dw_fde_struct *fde;
+  int last_stmt_uid;
+  int funcdef_no;
+  location_t function_start_locus;
+  location_t function_end_locus;
+  unsigned int curr_properties;
+  unsigned int last_verified;
+  const char * cannot_be_copied_reason;
+  unsigned int va_list_gpr_size : 8;
+  unsigned int va_list_fpr_size : 8;
+  unsigned int calls_setjmp : 1;
+  unsigned int calls_alloca : 1;
+  unsigned int has_nonlocal_label : 1;
+  unsigned int cannot_be_copied_set : 1;
+  unsigned int stdarg : 1;
+  unsigned int after_inlining : 1;
+  unsigned int always_inline_functions_inlined : 1;
+  unsigned int can_throw_non_call_exceptions : 1;
+  unsigned int can_delete_dead_exceptions : 1;
+  unsigned int returns_struct : 1;
+  unsigned int returns_pcc_struct : 1;
+  unsigned int has_local_explicit_reg_vars : 1;
+  unsigned int is_thunk : 1;
+};
+static inline void
+add_local_decl (struct function *fun, tree d)
+{
+  vec_safe_push (fun->local_decls, d);
+}
+extern struct function *cfun;
+extern int virtuals_instantiated;
+extern int trampolines_created;
+struct types_used_by_vars_entry {
+  tree type;
+  tree var_decl;
+};
+extern htab_t
+  types_used_by_vars_hash;
+hashval_t types_used_by_vars_do_hash (const void*);
+int types_used_by_vars_eq (const void *, const void *);
+void types_used_by_var_decl_insert (tree type, tree var_decl);
+extern vec<tree, va_gc> *types_used_by_cur_var_decl;
+extern void set_cfun (struct function *new_cfun);
+extern void push_cfun (struct function *new_cfun);
+extern void pop_cfun (void);
+extern void instantiate_decl_rtl (rtx x);
+extern void reorder_blocks (void);
+extern void number_blocks (tree);
+extern void clear_block_marks (tree);
+extern tree blocks_nreverse (tree);
+extern tree block_chainon (tree, tree);
+extern long long get_frame_size (void);
+extern bool frame_offset_overflow (long long, tree);
+extern struct machine_function * (*init_machine_status) (void);
+extern void free_after_parsing (struct function *);
+extern void free_after_compilation (struct function *);
+extern void init_varasm_status (void);
+extern void diddle_return_value (void (*)(rtx, void*), void*);
+extern void clobber_return_register (void);
+extern rtx get_arg_pointer_save_area (void);
+extern const char *fndecl_name (tree);
+extern const char *function_name (struct function *);
+extern const char *current_function_name (void);
+extern void do_warn_unused_parameter (tree);
+extern bool pass_by_reference (struct sh_args *, enum machine_mode,
+          tree, bool);
+extern bool reference_callee_copied (struct sh_args *, enum machine_mode,
+         tree, bool);
+extern void used_types_insert (tree);
+extern int get_next_funcdef_no (void);
+extern int get_last_funcdef_no (void);
+extern bool requires_stack_frame_p (rtx, HARD_REG_SET, HARD_REG_SET);
+extern rtx get_hard_reg_initial_val (enum machine_mode, unsigned int);
+extern rtx has_hard_reg_initial_val (enum machine_mode, unsigned int);
+extern rtx get_hard_reg_initial_reg (rtx);
+extern bool initial_value_entry (int i, rtx *, rtx *);
+extern unsigned int emit_initial_value_sets (void);
+extern bool optimize_function_for_size_p (struct function *);
+extern bool optimize_function_for_speed_p (struct function *);
+typedef long long gcov_type;
+typedef unsigned long long gcov_type_unsigned;
+struct edge_def {
+  basic_block src;
+  basic_block dest;
+  union edge_def_insns {
+    gimple_seq g;
+    rtx r;
+  } insns;
+  void * aux;
+  location_t goto_locus;
+  unsigned int dest_idx;
+  int flags;
+  int probability;
+  gcov_type count;
+};
+extern void gt_ggc_mx (edge_def *e);
+extern void gt_pch_nx (edge_def *e);
+extern void gt_pch_nx (edge_def *e, gt_pointer_operator, void *);
+enum cfg_edge_flags {
+EDGE_FALLTHRU = 1 << 0 ,
+EDGE_ABNORMAL = 1 << 1 ,
+EDGE_ABNORMAL_CALL = 1 << 2 ,
+EDGE_EH = 1 << 3 ,
+EDGE_PRESERVE = 1 << 4 ,
+EDGE_FAKE = 1 << 5 ,
+EDGE_DFS_BACK = 1 << 6 ,
+EDGE_IRREDUCIBLE_LOOP = 1 << 7 ,
+EDGE_TRUE_VALUE = 1 << 8 ,
+EDGE_FALSE_VALUE = 1 << 9 ,
+EDGE_EXECUTABLE = 1 << 10 ,
+EDGE_CROSSING = 1 << 11 ,
+EDGE_SIBCALL = 1 << 12 ,
+EDGE_CAN_FALLTHRU = 1 << 13 ,
+EDGE_LOOP_EXIT = 1 << 14 ,
+EDGE_TM_UNINSTRUMENTED = 1 << 15 ,
+EDGE_TM_ABORT = 1 << 16 ,
+  LAST_CFG_EDGE_FLAG
+};
+extern const struct gcov_ctr_summary *profile_info;
+typedef struct gcov_working_set_info
+{
+  unsigned num_counters;
+  gcov_type min_counter;
+} gcov_working_set_t;
+struct profile_record
+{
+  int num_mismatched_freq_in[2];
+  int num_mismatched_freq_out[2];
+  int num_mismatched_count_in[2];
+  int num_mismatched_count_out[2];
+  gcov_type time[2];
+  int size[2];
+  bool run;
+};
+struct loop;
+struct rtl_bb_info {
+  rtx end_;
+  rtx header_;
+  rtx footer_;
+};
+struct gimple_bb_info {
+  gimple_seq seq;
+  gimple_seq phi_nodes;
+};
+struct basic_block_def {
+  vec<edge, va_gc> *preds;
+  vec<edge, va_gc> *succs;
+  void * aux;
+  struct loop *loop_father;
+  struct et_node * dom[2];
+  basic_block prev_bb;
+  basic_block next_bb;
+  union basic_block_il_dependent {
+      struct gimple_bb_info gimple;
+      struct {
+        rtx head_;
+        struct rtl_bb_info * rtl;
+      } x;
+    } il;
+  int flags;
+  int index;
+  gcov_type count;
+  int frequency;
+  int discriminator;
+};
+typedef int __assert_gimple_bb_smaller_rtl_bb
+              [(int)sizeof(struct rtl_bb_info)
+               - (int)sizeof (struct gimple_bb_info)];
+enum cfg_bb_flags
+{
+BB_NEW = 1 << 0 ,
+BB_REACHABLE = 1 << 1 ,
+BB_IRREDUCIBLE_LOOP = 1 << 2 ,
+BB_SUPERBLOCK = 1 << 3 ,
+BB_DISABLE_SCHEDULE = 1 << 4 ,
+BB_HOT_PARTITION = 1 << 5 ,
+BB_COLD_PARTITION = 1 << 6 ,
+BB_DUPLICATED = 1 << 7 ,
+BB_NON_LOCAL_GOTO_TARGET = 1 << 8 ,
+BB_RTL = 1 << 9 ,
+BB_FORWARDER_BLOCK = 1 << 10 ,
+BB_NONTHREADABLE_BLOCK = 1 << 11 ,
+BB_MODIFIED = 1 << 12 ,
+BB_VISITED = 1 << 13 ,
+BB_IN_TRANSACTION = 1 << 14 ,
+  LAST_CFG_BB_FLAG
+};
+enum dom_state
+{
+  DOM_NONE,
+  DOM_NO_FAST_QUERY,
+  DOM_OK
+};
+enum profile_status_d
+{
+  PROFILE_ABSENT,
+  PROFILE_GUESSED,
+  PROFILE_READ,
+  PROFILE_LAST
+};
+struct control_flow_graph {
+  basic_block x_entry_block_ptr;
+  basic_block x_exit_block_ptr;
+  vec<basic_block, va_gc> *x_basic_block_info;
+  int x_n_basic_blocks;
+  int x_n_edges;
+  int x_last_basic_block;
+  int last_label_uid;
+  vec<basic_block, va_gc> *x_label_to_block_map;
+  enum profile_status_d x_profile_status;
+  enum dom_state x_dom_computed[2];
+  unsigned x_n_bbs_in_dom_tree[2];
+  int max_jumptable_ents;
+};
+extern void compute_bb_for_insn (void);
+extern unsigned int free_bb_for_insn (void);
+extern void update_bb_for_insn (basic_block);
+extern void insert_insn_on_edge (rtx, edge);
+basic_block split_edge_and_insert (edge, rtx);
+extern void commit_one_edge_insertion (edge e);
+extern void commit_edge_insertions (void);
+extern edge unchecked_make_edge (basic_block, basic_block, int);
+extern edge cached_make_edge (sbitmap, basic_block, basic_block, int);
+extern edge make_edge (basic_block, basic_block, int);
+extern edge make_single_succ_edge (basic_block, basic_block, int);
+extern void remove_edge_raw (edge);
+extern void redirect_edge_succ (edge, basic_block);
+extern edge redirect_edge_succ_nodup (edge, basic_block);
+extern void redirect_edge_pred (edge, basic_block);
+extern basic_block create_basic_block_structure (rtx, rtx, rtx, basic_block);
+extern void clear_bb_flags (void);
+extern void dump_bb_info (FILE *, basic_block, int, int, bool, bool);
+extern void dump_edge_info (FILE *, edge, int, int);
+extern void brief_dump_cfg (FILE *, int);
+extern void clear_edges (void);
+extern void scale_bbs_frequencies_int (basic_block *, int, int, int);
+extern void scale_bbs_frequencies_gcov_type (basic_block *, int, gcov_type,
+          gcov_type);
+typedef struct ce_if_block
+{
+  basic_block test_bb;
+  basic_block then_bb;
+  basic_block else_bb;
+  basic_block join_bb;
+  basic_block last_test_bb;
+  int num_multiple_test_blocks;
+  int num_and_and_blocks;
+  int num_or_or_blocks;
+  int num_multiple_test_insns;
+  int and_and_p;
+  int num_then_insns;
+  int num_else_insns;
+  int pass;
+} ce_if_block_t;
+struct edge_list
+{
+  int num_edges;
+  edge *index_to_edge;
+};
+static inline bool
+single_succ_p (const_basic_block bb)
+{
+  return vec_safe_length (bb->succs) == 1;
+}
+static inline bool
+single_pred_p (const_basic_block bb)
+{
+  return vec_safe_length (bb->preds) == 1;
+}
+static inline edge
+single_succ_edge (const_basic_block bb)
+{
+  ((void)(0 && (single_succ_p (bb))));
+  return (*(bb)->succs)[(0)];
+}
+static inline edge
+single_pred_edge (const_basic_block bb)
+{
+  ((void)(0 && (single_pred_p (bb))));
+  return (*(bb)->preds)[(0)];
+}
+static inline basic_block
+single_succ (const_basic_block bb)
+{
+  return single_succ_edge (bb)->dest;
+}
+static inline basic_block
+single_pred (const_basic_block bb)
+{
+  return single_pred_edge (bb)->src;
+}
+typedef struct {
+  unsigned index;
+  vec<edge, va_gc> **container;
+} edge_iterator;
+static inline vec<edge, va_gc> *
+ei_container (edge_iterator i)
+{
+  ((void)(0 && (i.container)));
+  return *i.container;
+}
+static inline edge_iterator
+ei_start_1 (vec<edge, va_gc> **ev)
+{
+  edge_iterator i;
+  i.index = 0;
+  i.container = ev;
+  return i;
+}
+static inline edge_iterator
+ei_last_1 (vec<edge, va_gc> **ev)
+{
+  edge_iterator i;
+  i.index = vec_safe_length (*ev) - 1;
+  i.container = ev;
+  return i;
+}
+static inline bool
+ei_end_p (edge_iterator i)
+{
+  return (i.index == vec_safe_length (ei_container (i)));
+}
+static inline bool
+ei_one_before_end_p (edge_iterator i)
+{
+  return (i.index + 1 == vec_safe_length (ei_container (i)));
+}
+static inline void
+ei_next (edge_iterator *i)
+{
+  ((void)(0 && (i->index < vec_safe_length (ei_container (*i)))));
+  i->index++;
+}
+static inline void
+ei_prev (edge_iterator *i)
+{
+  ((void)(0 && (i->index > 0)));
+  i->index--;
+}
+static inline edge
+ei_edge (edge_iterator i)
+{
+  return (*ei_container (i))[(i.index)];
+}
+static inline edge
+ei_safe_edge (edge_iterator i)
+{
+  return !ei_end_p (i) ? ei_edge (i) : __null;
+}
+static inline bool
+ei_cond (edge_iterator ei, edge *p)
+{
+  if (!ei_end_p (ei))
+    {
+      *p = ei_edge (ei);
+      return 1;
+    }
+  else
+    {
+      *p = __null;
+      return 0;
+    }
+}
+extern void bitmap_intersection_of_succs (sbitmap, sbitmap *, basic_block);
+extern void bitmap_intersection_of_preds (sbitmap, sbitmap *, basic_block);
+extern void bitmap_union_of_succs (sbitmap, sbitmap *, basic_block);
+extern void bitmap_union_of_preds (sbitmap, sbitmap *, basic_block);
+extern struct edge_list *pre_edge_lcm (int, sbitmap *, sbitmap *,
+           sbitmap *, sbitmap *, sbitmap **,
+           sbitmap **);
+extern struct edge_list *pre_edge_lcm_avs (int, sbitmap *, sbitmap *,
+        sbitmap *, sbitmap *, sbitmap *,
+        sbitmap *, sbitmap **, sbitmap **);
+extern struct edge_list *pre_edge_rev_lcm (int, sbitmap *,
+        sbitmap *, sbitmap *,
+        sbitmap *, sbitmap **,
+        sbitmap **);
+extern void compute_available (sbitmap *, sbitmap *, sbitmap *, sbitmap *);
+extern bool maybe_hot_bb_p (struct function *, const_basic_block);
+extern bool maybe_hot_edge_p (edge);
+extern bool probably_never_executed_bb_p (struct function *, const_basic_block);
+extern bool optimize_bb_for_size_p (const_basic_block);
+extern bool optimize_bb_for_speed_p (const_basic_block);
+extern bool optimize_edge_for_size_p (edge);
+extern bool optimize_edge_for_speed_p (edge);
+extern bool optimize_loop_for_size_p (struct loop *);
+extern bool optimize_loop_for_speed_p (struct loop *);
+extern bool optimize_loop_nest_for_size_p (struct loop *);
+extern bool optimize_loop_nest_for_speed_p (struct loop *);
+extern bool gimple_predicted_by_p (const_basic_block, enum br_predictor);
+extern bool rtl_predicted_by_p (const_basic_block, enum br_predictor);
+extern void gimple_predict_edge (edge, enum br_predictor, int);
+extern void rtl_predict_edge (edge, enum br_predictor, int);
+extern void predict_edge_def (edge, enum br_predictor, enum prediction);
+extern void guess_outgoing_edge_probabilities (basic_block);
+extern void remove_predictions_associated_with_edge (edge);
+extern bool edge_probability_reliable_p (const_edge);
+extern bool br_prob_note_reliable_p (const_rtx);
+extern bool predictable_edge_p (edge);
+extern void init_flow (struct function *);
+extern void debug_bb (basic_block);
+extern basic_block debug_bb_n (int);
+extern void dump_flow_info (FILE *, int);
+extern void expunge_block (basic_block);
+extern void link_block (basic_block, basic_block);
+extern void unlink_block (basic_block);
+extern void compact_blocks (void);
+extern basic_block alloc_block (void);
+extern void alloc_aux_for_blocks (int);
+extern void clear_aux_for_blocks (void);
+extern void free_aux_for_blocks (void);
+extern void alloc_aux_for_edge (edge, int);
+extern void alloc_aux_for_edges (int);
+extern void clear_aux_for_edges (void);
+extern void free_aux_for_edges (void);
+extern void find_unreachable_blocks (void);
+extern bool mark_dfs_back_edges (void);
+struct edge_list * create_edge_list (void);
+void free_edge_list (struct edge_list *);
+void print_edge_list (FILE *, struct edge_list *);
+void verify_edge_list (FILE *, struct edge_list *);
+int find_edge_index (struct edge_list *, basic_block, basic_block);
+edge find_edge (basic_block, basic_block);
+extern void remove_fake_edges (void);
+extern void remove_fake_exit_edges (void);
+extern void add_noreturn_fake_exit_edges (void);
+extern void connect_infinite_loops_to_exit (void);
+extern int post_order_compute (int *, bool, bool);
+extern basic_block dfs_find_deadend (basic_block);
+extern int inverted_post_order_compute (int *);
+extern int pre_and_rev_post_order_compute (int *, int *, bool);
+extern int dfs_enumerate_from (basic_block, int,
+          bool (*)(const_basic_block, const void *),
+          basic_block *, int, const void *);
+extern void compute_dominance_frontiers (struct bitmap_head_def *);
+extern bitmap compute_idf (bitmap, struct bitmap_head_def *);
+extern rtx block_label (basic_block);
+extern rtx bb_note (basic_block);
+extern bool purge_all_dead_edges (void);
+extern bool purge_dead_edges (basic_block);
+extern bool fixup_abnormal_edges (void);
+extern basic_block force_nonfallthru_and_redirect (edge, basic_block, rtx);
+extern bool contains_no_active_insn_p (const_basic_block);
+extern bool forwarder_block_p (const_basic_block);
+extern bool can_fallthru (basic_block, basic_block);
+extern void find_many_sub_basic_blocks (sbitmap);
+extern void rtl_make_eh_edge (sbitmap, basic_block, rtx);
+enum replace_direction { dir_none, dir_forward, dir_backward, dir_both };
+extern bool cleanup_cfg (int);
+extern int flow_find_cross_jump (basic_block, basic_block, rtx *, rtx *,
+                                 enum replace_direction*);
+extern int flow_find_head_matching_sequence (basic_block, basic_block,
+          rtx *, rtx *, int);
+extern bool delete_unreachable_blocks (void);
+extern void update_br_prob_note (basic_block);
+extern bool inside_basic_block_p (const_rtx);
+extern bool control_flow_insn_p (const_rtx);
+extern rtx get_last_bb_insn (basic_block);
+enum cdi_direction
+{
+  CDI_DOMINATORS = 1,
+  CDI_POST_DOMINATORS = 2
+};
+extern enum dom_state dom_info_state (enum cdi_direction);
+extern void set_dom_info_availability (enum cdi_direction, enum dom_state);
+extern bool dom_info_available_p (enum cdi_direction);
+extern void calculate_dominance_info (enum cdi_direction);
+extern void free_dominance_info (enum cdi_direction);
+extern basic_block nearest_common_dominator (enum cdi_direction,
+          basic_block, basic_block);
+extern basic_block nearest_common_dominator_for_set (enum cdi_direction,
+           bitmap);
+extern void set_immediate_dominator (enum cdi_direction, basic_block,
+         basic_block);
+extern basic_block get_immediate_dominator (enum cdi_direction, basic_block);
+extern bool dominated_by_p (enum cdi_direction, const_basic_block, const_basic_block);
+extern vec<basic_block> get_dominated_by (enum cdi_direction, basic_block);
+extern vec<basic_block> get_dominated_by_region (enum cdi_direction,
+        basic_block *,
+        unsigned);
+extern vec<basic_block> get_dominated_to_depth (enum cdi_direction,
+       basic_block, int);
+extern vec<basic_block> get_all_dominated_blocks (enum cdi_direction,
+         basic_block);
+extern void add_to_dominance_info (enum cdi_direction, basic_block);
+extern void delete_from_dominance_info (enum cdi_direction, basic_block);
+basic_block recompute_dominator (enum cdi_direction, basic_block);
+extern void redirect_immediate_dominators (enum cdi_direction, basic_block,
+        basic_block);
+extern void iterate_fix_dominators (enum cdi_direction,
+        vec<basic_block> , bool);
+extern void verify_dominators (enum cdi_direction);
+extern basic_block first_dom_son (enum cdi_direction, basic_block);
+extern basic_block next_dom_son (enum cdi_direction, basic_block);
+unsigned bb_dom_dfs_in (enum cdi_direction, basic_block);
+unsigned bb_dom_dfs_out (enum cdi_direction, basic_block);
+extern edge try_redirect_by_replacing_jump (edge, basic_block, bool);
+extern void break_superblocks (void);
+extern void relink_block_chain (bool);
+extern void update_bb_profile_for_threading (basic_block, int, gcov_type, edge);
+extern void init_rtl_bb_info (basic_block);
+extern void initialize_original_copy_tables (void);
+extern void free_original_copy_tables (void);
+extern void set_bb_original (basic_block, basic_block);
+extern basic_block get_bb_original (basic_block);
+extern void set_bb_copy (basic_block, basic_block);
+extern basic_block get_bb_copy (basic_block);
+void set_loop_copy (struct loop *, struct loop *);
+struct loop *get_loop_copy (struct loop *);
+struct cfg_hooks
+{
+  const char *name;
+  int (*verify_flow_info) (void);
+  void (*dump_bb) (FILE *, basic_block, int, int);
+  void (*dump_bb_for_graph) (pretty_printer *, basic_block);
+  basic_block (*create_basic_block) (void *head, void *end, basic_block after);
+  edge (*redirect_edge_and_branch) (edge e, basic_block b);
+  basic_block (*redirect_edge_and_branch_force) (edge, basic_block);
+  bool (*can_remove_branch_p) (const_edge);
+  void (*delete_basic_block) (basic_block);
+  basic_block (*split_block) (basic_block b, void * i);
+  bool (*move_block_after) (basic_block b, basic_block a);
+  bool (*can_merge_blocks_p) (basic_block a, basic_block b);
+  void (*merge_blocks) (basic_block a, basic_block b);
+  void (*predict_edge) (edge e, enum br_predictor predictor, int probability);
+  bool (*predicted_by_p) (const_basic_block bb, enum br_predictor predictor);
+  bool (*can_duplicate_block_p) (const_basic_block a);
+  basic_block (*duplicate_block) (basic_block a);
+  basic_block (*split_edge) (edge);
+  void (*make_forwarder_block) (edge);
+  void (*tidy_fallthru_edge) (edge);
+  basic_block (*force_nonfallthru) (edge);
+  bool (*block_ends_with_call_p) (basic_block);
+  bool (*block_ends_with_condjump_p) (const_basic_block);
+  int (*flow_call_edges_add) (sbitmap);
+  void (*execute_on_growing_pred) (edge);
+  void (*execute_on_shrinking_pred) (edge);
+  bool (*cfg_hook_duplicate_loop_to_header_edge) (struct loop *, edge,
+        unsigned, sbitmap,
+        edge, vec<edge> *,
+        int);
+  void (*lv_add_condition_to_bb) (basic_block, basic_block, basic_block,
+      void *);
+  void (*lv_adjust_loop_header_phi) (basic_block, basic_block,
+         basic_block, edge);
+  void (*extract_cond_bb_edges) (basic_block, edge *, edge *);
+  void (*flush_pending_stmts) (edge);
+  bool (*empty_block_p) (basic_block);
+  basic_block (*split_block_before_cond_jump) (basic_block);
+  void (*account_profile_record) (basic_block, int, struct profile_record *);
+};
+extern void verify_flow_info (void);
+extern void dump_bb (FILE *, basic_block, int, int);
+extern void dump_bb_for_graph (pretty_printer *, basic_block);
+extern edge redirect_edge_and_branch (edge, basic_block);
+extern basic_block redirect_edge_and_branch_force (edge, basic_block);
+extern bool can_remove_branch_p (const_edge);
+extern void remove_branch (edge);
+extern void remove_edge (edge);
+extern edge split_block (basic_block, void *);
+extern edge split_block_after_labels (basic_block);
+extern bool move_block_after (basic_block, basic_block);
+extern void delete_basic_block (basic_block);
+extern basic_block split_edge (edge);
+extern basic_block create_basic_block (void *, void *, basic_block);
+extern basic_block create_empty_bb (basic_block);
+extern bool can_merge_blocks_p (basic_block, basic_block);
+extern void merge_blocks (basic_block, basic_block);
+extern edge make_forwarder_block (basic_block, bool (*)(edge),
+      void (*) (basic_block));
+extern basic_block force_nonfallthru (edge);
+extern void tidy_fallthru_edge (edge);
+extern void tidy_fallthru_edges (void);
+extern void predict_edge (edge e, enum br_predictor predictor, int probability);
+extern bool predicted_by_p (const_basic_block bb, enum br_predictor predictor);
+extern bool can_duplicate_block_p (const_basic_block);
+extern basic_block duplicate_block (basic_block, edge, basic_block);
+extern bool block_ends_with_call_p (basic_block bb);
+extern bool empty_block_p (basic_block);
+extern basic_block split_block_before_cond_jump (basic_block);
+extern bool block_ends_with_condjump_p (const_basic_block bb);
+extern int flow_call_edges_add (sbitmap);
+extern void execute_on_growing_pred (edge);
+extern void execute_on_shrinking_pred (edge);
+extern bool cfg_hook_duplicate_loop_to_header_edge (struct loop *loop, edge,
+          unsigned int ndupl,
+          sbitmap wont_exit,
+          edge orig,
+          vec<edge> *to_remove,
+          int flags);
+extern void lv_flush_pending_stmts (edge);
+extern void extract_cond_bb_edges (basic_block, edge *, edge*);
+extern void lv_adjust_loop_header_phi (basic_block, basic_block, basic_block,
+           edge);
+extern void lv_add_condition_to_bb (basic_block, basic_block, basic_block,
+        void *);
+extern bool can_copy_bbs_p (basic_block *, unsigned);
+extern void copy_bbs (basic_block *, unsigned, basic_block *,
+        edge *, unsigned, edge *, struct loop *,
+        basic_block);
+void account_profile_record (struct profile_record *, int);
+extern void cfg_layout_initialize (unsigned int);
+extern void cfg_layout_finalize (void);
+extern struct cfg_hooks gimple_cfg_hooks;
+extern struct cfg_hooks rtl_cfg_hooks;
+extern struct cfg_hooks cfg_layout_rtl_cfg_hooks;
+extern enum ir_type current_ir_type (void);
+extern void rtl_register_cfg_hooks (void);
+extern void cfg_layout_rtl_register_cfg_hooks (void);
+extern void gimple_register_cfg_hooks (void);
+extern struct cfg_hooks get_cfg_hooks (void);
+extern void set_cfg_hooks (struct cfg_hooks);
+static inline bool
+bb_has_eh_pred (basic_block bb)
+{
+  edge e;
+  edge_iterator ei;
+  for ((ei) = ei_start_1 (&((bb->preds))); ei_cond ((ei), &(e)); ei_next (&(ei)))
+    {
+      if (e->flags & EDGE_EH)
+ return true;
+    }
+  return false;
+}
+static inline bool
+bb_has_abnormal_pred (basic_block bb)
+{
+  edge e;
+  edge_iterator ei;
+  for ((ei) = ei_start_1 (&((bb->preds))); ei_cond ((ei), &(e)); ei_next (&(ei)))
+    {
+      if (e->flags & EDGE_ABNORMAL)
+ return true;
+    }
+  return false;
+}
+static inline edge
+find_fallthru_edge (vec<edge, va_gc> *edges)
+{
+  edge e;
+  edge_iterator ei;
+  for ((ei) = ei_start_1 (&((edges))); ei_cond ((ei), &(e)); ei_next (&(ei)))
+    if (e->flags & EDGE_FALLTHRU)
+      break;
+  return e;
+}
+extern edge mfb_kj_edge;
+extern bool mfb_keep_just (edge);
+extern void rtl_profile_for_bb (basic_block);
+extern void rtl_profile_for_edge (edge);
+extern void default_rtl_profile (void);
+extern gcov_working_set_t *find_working_set(unsigned pct_times_10);
+static inline void
+check_probability (int prob)
+{
+  ((void)(0 && (prob >= 0 && prob <= 10000)));
+}
+static inline int
+combine_probabilities (int prob1, int prob2)
+{
+  check_probability (prob1);
+  check_probability (prob2);
+  return (((prob1 * prob2) + (10000) / 2) / (10000));
+}
+static inline gcov_type
+apply_probability (gcov_type freq, int prob)
+{
+  check_probability (prob);
+  return (((freq * prob) + (10000) / 2) / (10000));
+}
+static inline int
+inverse_probability (int prob1)
+{
+  check_probability (prob1);
+  return 10000 - prob1;
+}
+typedef unsigned long ALLOC_POOL_ID_TYPE;
+typedef struct alloc_pool_list_def
+{
+  struct alloc_pool_list_def *next;
+}
+ *alloc_pool_list;
+typedef struct alloc_pool_def
+{
+  const char *name;
+  size_t elts_per_block;
+  alloc_pool_list returned_free_list;
+  char* virgin_free_list;
+  size_t virgin_elts_remaining;
+  size_t elts_allocated;
+  size_t elts_free;
+  size_t blocks_allocated;
+  alloc_pool_list block_list;
+  size_t block_size;
+  size_t elt_size;
+}
+ *alloc_pool;
+extern alloc_pool create_alloc_pool (const char *, size_t, size_t);
+extern void free_alloc_pool (alloc_pool);
+extern void empty_alloc_pool (alloc_pool);
+extern void free_alloc_pool_if_empty (alloc_pool *);
+extern void *pool_alloc (alloc_pool) __attribute__ ((__malloc__));
+extern void pool_free (alloc_pool, void *);
+extern void dump_alloc_pool_statistics (void);
+struct timevar_time_def
+{
+  double user;
+  double sys;
+  double wall;
+  unsigned ggc_mem;
+};
+typedef enum
+{
+  TV_NONE,
+TV_TOTAL,
+TV_PHASE_SETUP,
+TV_PHASE_PARSING,
+TV_PHASE_DEFERRED,
+TV_PHASE_OPT_GEN,
+TV_PHASE_DBGINFO,
+TV_PHASE_CHECK_DBGINFO,
+TV_PHASE_LATE_ASM,
+TV_PHASE_STREAM_IN,
+TV_PHASE_STREAM_OUT,
+TV_PHASE_FINALIZE,
+TV_NAME_LOOKUP,
+TV_OVERLOAD,
+TV_GC,
+TV_DUMP,
+TV_PCH_SAVE,
+TV_PCH_CPP_SAVE,
+TV_PCH_PTR_REALLOC,
+TV_PCH_PTR_SORT,
+TV_PCH_RESTORE,
+TV_PCH_CPP_RESTORE,
+TV_CGRAPH,
+TV_CGRAPHOPT,
+TV_IPA_CONSTANT_PROP,
+TV_IPA_INLINING,
+TV_IPA_FNSPLIT,
+TV_IPA_OPT,
+TV_IPA_LTO_GIMPLE_IN,
+TV_IPA_LTO_GIMPLE_OUT,
+TV_IPA_LTO_DECL_IN,
+TV_IPA_LTO_DECL_OUT,
+TV_IPA_LTO_DECL_INIT_IO,
+TV_IPA_LTO_CGRAPH_IO,
+TV_IPA_LTO_DECL_MERGE,
+TV_IPA_LTO_CGRAPH_MERGE,
+TV_LTO,
+TV_WHOPR_WPA,
+TV_WHOPR_WPA_IO,
+TV_WHOPR_PARTITIONING,
+TV_WHOPR_LTRANS,
+TV_IPA_REFERENCE,
+TV_IPA_PROFILE,
+TV_IPA_PURE_CONST,
+TV_IPA_PTA,
+TV_IPA_SRA,
+TV_IPA_FREE_LANG_DATA,
+TV_IPA_FREE_INLINE_SUMMARY,
+TV_CFG,
+TV_CLEANUP_CFG,
+TV_CFG_VERIFY,
+TV_DELETE_TRIVIALLY_DEAD,
+TV_DF_SCAN,
+TV_DF_MD,
+TV_DF_RD,
+TV_DF_LR,
+TV_DF_LIVE,
+TV_DF_CHAIN,
+TV_DF_WORD_LR,
+TV_DF_NOTE,
+TV_REG_STATS,
+TV_ALIAS_ANALYSIS,
+TV_ALIAS_STMT_WALK,
+TV_REG_SCAN,
+TV_REBUILD_JUMP,
+TV_CPP,
+TV_LEX,
+TV_PARSE_GLOBAL,
+TV_PARSE_STRUCT,
+TV_PARSE_ENUM,
+TV_PARSE_FUNC,
+TV_PARSE_INLINE,
+TV_PARSE_INMETH,
+TV_TEMPLATE_INST,
+TV_FLATTEN_INLINING,
+TV_EARLY_INLINING,
+TV_INLINE_PARAMETERS,
+TV_INTEGRATION,
+TV_TREE_GIMPLIFY,
+TV_TREE_EH,
+TV_TREE_CFG,
+TV_TREE_CLEANUP_CFG,
+TV_TREE_TAIL_MERGE,
+TV_TREE_VRP,
+TV_TREE_COPY_PROP,
+TV_FIND_REFERENCED_VARS,
+TV_TREE_PTA,
+TV_TREE_INSERT_PHI_NODES,
+TV_TREE_SSA_REWRITE_BLOCKS,
+TV_TREE_SSA_OTHER,
+TV_TREE_SSA_INCREMENTAL,
+TV_TREE_OPS,
+TV_TREE_SSA_DOMINATOR_OPTS,
+TV_TREE_SRA,
+TV_TREE_CCP,
+TV_TREE_PHI_CPROP,
+TV_TREE_SPLIT_EDGES,
+TV_TREE_REASSOC,
+TV_TREE_PRE,
+TV_TREE_FRE,
+TV_TREE_SINK,
+TV_TREE_PHIOPT,
+TV_TREE_FORWPROP,
+TV_TREE_PHIPROP,
+TV_TREE_DCE,
+TV_TREE_CD_DCE,
+TV_TREE_CALL_CDCE,
+TV_TREE_DSE,
+TV_TREE_MERGE_PHI,
+TV_TREE_LOOP,
+TV_TREE_LOOP_BOUNDS,
+TV_LIM,
+TV_TREE_LOOP_IVCANON,
+TV_SCEV_CONST,
+TV_TREE_LOOP_UNSWITCH,
+TV_COMPLETE_UNROLL,
+TV_TREE_PARALLELIZE_LOOPS,
+TV_TREE_VECTORIZATION,
+TV_TREE_SLP_VECTORIZATION,
+TV_GRAPHITE,
+TV_GRAPHITE_TRANSFORMS,
+TV_GRAPHITE_DATA_DEPS,
+TV_GRAPHITE_CODE_GEN,
+TV_TREE_LOOP_DISTRIBUTION,
+TV_CHECK_DATA_DEPS,
+TV_TREE_PREFETCH,
+TV_TREE_LOOP_IVOPTS,
+TV_PREDCOM,
+TV_TREE_CH,
+TV_TREE_SSA_UNCPROP,
+TV_TREE_NRV,
+TV_TREE_COPY_RENAME,
+TV_TREE_SSA_VERIFY,
+TV_TREE_STMT_VERIFY,
+TV_TREE_SWITCH_CONVERSION,
+TV_TRANS_MEM,
+TV_TREE_STRLEN,
+TV_CGRAPH_VERIFY,
+TV_DOM_FRONTIERS,
+TV_DOMINANCE,
+TV_CONTROL_DEPENDENCES,
+TV_OUT_OF_SSA,
+TV_VAR_EXPAND,
+TV_EXPAND,
+TV_POST_EXPAND,
+TV_VARCONST,
+TV_LOWER_SUBREG,
+TV_JUMP,
+TV_FWPROP,
+TV_CSE,
+TV_DCE,
+TV_DSE1,
+TV_DSE2,
+TV_LOOP,
+TV_LOOP_INIT,
+TV_LOOP_MOVE_INVARIANTS,
+TV_LOOP_UNSWITCH,
+TV_LOOP_UNROLL,
+TV_LOOP_DOLOOP,
+TV_LOOP_FINI,
+TV_CPROP,
+TV_PRE,
+TV_HOIST,
+TV_LSM,
+TV_TRACER,
+TV_WEB,
+TV_AUTO_INC_DEC,
+TV_CSE2,
+TV_BRANCH_PROB,
+TV_COMBINE,
+TV_IFCVT,
+TV_REGMOVE,
+TV_MODE_SWITCH,
+TV_SMS,
+TV_SCHED,
+TV_IRA,
+TV_LRA,
+TV_LRA_ELIMINATE,
+TV_LRA_INHERITANCE,
+TV_LRA_CREATE_LIVE_RANGES,
+TV_LRA_ASSIGN,
+TV_LRA_COALESCE,
+TV_RELOAD,
+TV_RELOAD_CSE_REGS,
+TV_GCSE_AFTER_RELOAD,
+TV_REE,
+TV_THREAD_PROLOGUE_AND_EPILOGUE,
+TV_IFCVT2,
+TV_COMBINE_STACK_ADJUST,
+TV_PEEPHOLE2,
+TV_RENAME_REGISTERS,
+TV_CPROP_REGISTERS,
+TV_SCHED2,
+TV_MACH_DEP,
+TV_DBR_SCHED,
+TV_REORDER_BLOCKS,
+TV_SHORTEN_BRANCH,
+TV_REG_STACK,
+TV_FINAL,
+TV_VAROUT,
+TV_SYMOUT,
+TV_VAR_TRACKING,
+TV_VAR_TRACKING_DATAFLOW,
+TV_VAR_TRACKING_EMIT,
+TV_TREE_IFCOMBINE,
+TV_TREE_UNINIT,
+TV_PLUGIN_INIT,
+TV_PLUGIN_RUN,
+TV_GIMPLE_SLSR,
+TV_EARLY_LOCAL,
+TV_OPTIMIZE,
+TV_REST_OF_COMPILATION,
+TV_POSTRELOAD,
+TV_REMOVE_UNUSED,
+TV_ADDRESS_TAKEN,
+TV_TODO,
+TV_VERIFY_LOOP_CLOSED,
+TV_VERIFY_RTL_SHARING,
+TV_REBUILD_FREQUENCIES,
+TV_REPAIR_LOOPS,
+  TIMEVAR_LAST
+}
+timevar_id_t;
+extern bool timevar_enable;
+extern size_t timevar_ggc_mem_total;
+extern void timevar_init (void);
+extern void timevar_push_1 (timevar_id_t);
+extern void timevar_pop_1 (timevar_id_t);
+extern void timevar_start (timevar_id_t);
+extern void timevar_stop (timevar_id_t);
+extern bool timevar_cond_start (timevar_id_t);
+extern void timevar_cond_stop (timevar_id_t, bool);
+extern void timevar_print (FILE *);
+static inline void
+timevar_push (timevar_id_t tv)
+{
+  if (timevar_enable)
+    timevar_push_1 (tv);
+}
+static inline void
+timevar_pop (timevar_id_t tv)
+{
+  if (timevar_enable)
+    timevar_pop_1 (tv);
+}
+extern void print_time (const char *, long);
+struct dataflow;
+struct df_d;
+struct df_problem;
+struct df_link;
+struct df_insn_info;
+union df_ref_d;
+enum df_flow_dir
+  {
+    DF_NONE,
+    DF_FORWARD,
+    DF_BACKWARD
+  };
+enum df_ref_class {DF_REF_BASE, DF_REF_ARTIFICIAL, DF_REF_REGULAR};
+enum df_ref_type {DF_REF_REG_DEF, DF_REF_REG_USE,
+    DF_REF_REG_MEM_LOAD, DF_REF_REG_MEM_STORE};
+enum df_ref_flags
+  {
+    DF_REF_CONDITIONAL = 1 << 0,
+    DF_REF_AT_TOP = 1 << 1,
+    DF_REF_IN_NOTE = 1 << 2,
+    DF_HARD_REG_LIVE = 1 << 3,
+    DF_REF_PARTIAL = 1 << 4,
+    DF_REF_READ_WRITE = 1 << 5,
+    DF_REF_MAY_CLOBBER = 1 << 6,
+    DF_REF_MUST_CLOBBER = 1 << 7,
+    DF_REF_SIGN_EXTRACT = 1 << 8,
+    DF_REF_ZERO_EXTRACT = 1 << 9,
+    DF_REF_STRICT_LOW_PART = 1 << 10,
+    DF_REF_SUBREG = 1 << 11,
+    DF_REF_MW_HARDREG = 1 << 12,
+    DF_REF_CALL_STACK_USAGE = 1 << 13,
+    DF_REF_REG_MARKER = 1 << 14,
+    DF_REF_PRE_POST_MODIFY = 1 << 15
+  };
+enum df_ref_order
+  {
+    DF_REF_ORDER_NO_TABLE,
+    DF_REF_ORDER_UNORDERED,
+    DF_REF_ORDER_UNORDERED_WITH_NOTES,
+    DF_REF_ORDER_BY_REG,
+    DF_REF_ORDER_BY_REG_WITH_NOTES,
+    DF_REF_ORDER_BY_INSN,
+    DF_REF_ORDER_BY_INSN_WITH_NOTES
+  };
+typedef void (*df_alloc_function) (bitmap);
+typedef void (*df_reset_function) (bitmap);
+typedef void (*df_free_bb_function) (basic_block, void *);
+typedef void (*df_local_compute_function) (bitmap);
+typedef void (*df_init_function) (bitmap);
+typedef void (*df_dataflow_function) (struct dataflow *, bitmap, int *, int);
+typedef void (*df_confluence_function_0) (basic_block);
+typedef bool (*df_confluence_function_n) (edge);
+typedef bool (*df_transfer_function) (int);
+typedef void (*df_finalizer_function) (bitmap);
+typedef void (*df_free_function) (void);
+typedef void (*df_remove_problem_function) (void);
+typedef void (*df_dump_problem_function) (FILE *);
+typedef void (*df_dump_bb_problem_function) (basic_block, FILE *);
+typedef void (*df_dump_insn_problem_function) (const_rtx, FILE *);
+typedef void (*df_verify_solution_start) (void);
+typedef void (*df_verify_solution_end) (void);
+struct df_problem {
+  unsigned int id;
+  enum df_flow_dir dir;
+  df_alloc_function alloc_fun;
+  df_reset_function reset_fun;
+  df_free_bb_function free_bb_fun;
+  df_local_compute_function local_compute_fun;
+  df_init_function init_fun;
+  df_dataflow_function dataflow_fun;
+  df_confluence_function_0 con_fun_0;
+  df_confluence_function_n con_fun_n;
+  df_transfer_function trans_fun;
+  df_finalizer_function finalize_fun;
+  df_free_function free_fun;
+  df_remove_problem_function remove_problem_fun;
+  df_dump_problem_function dump_start_fun;
+  df_dump_bb_problem_function dump_top_fun;
+  df_dump_bb_problem_function dump_bottom_fun;
+  df_dump_insn_problem_function dump_insn_top_fun;
+  df_dump_insn_problem_function dump_insn_bottom_fun;
+  df_verify_solution_start verify_start_fun;
+  df_verify_solution_end verify_end_fun;
+  struct df_problem *dependent_problem;
+  unsigned int block_info_elt_size;
+  timevar_id_t tv_id;
+  bool free_blocks_on_set_blocks;
+};
+struct dataflow
+{
+  struct df_problem *problem;
+  void *block_info;
+  unsigned int block_info_size;
+  alloc_pool block_pool;
+  bitmap out_of_date_transfer_functions;
+  void *problem_data;
+  unsigned int local_flags;
+  bool computed;
+  bool solutions_dirty;
+  bool optional_p;
+};
+struct df_mw_hardreg
+{
+  rtx mw_reg;
+  enum df_ref_type type : 16;
+  int flags : 16;
+  unsigned int start_regno;
+  unsigned int end_regno;
+  unsigned int mw_order;
+};
+struct df_base_ref
+{
+  enum df_ref_class cl : 8;
+  enum df_ref_type type : 8;
+  int flags : 16;
+  unsigned int regno;
+  rtx reg;
+  struct df_link *chain;
+  struct df_insn_info *insn_info;
+  union df_ref_d *next_reg;
+  union df_ref_d *prev_reg;
+  int id;
+  unsigned int ref_order;
+};
+struct df_artificial_ref
+{
+  struct df_base_ref base;
+  basic_block bb;
+};
+struct df_regular_ref
+{
+  struct df_base_ref base;
+  rtx *loc;
+};
+union df_ref_d
+{
+  struct df_base_ref base;
+  struct df_regular_ref regular_ref;
+  struct df_artificial_ref artificial_ref;
+};
+typedef union df_ref_d *df_ref;
+struct df_insn_info
+{
+  rtx insn;
+  df_ref *defs;
+  df_ref *uses;
+  df_ref *eq_uses;
+  struct df_mw_hardreg **mw_hardregs;
+  int luid;
+};
+struct df_link
+{
+  df_ref ref;
+  struct df_link *next;
+};
+enum df_chain_flags
+{
+  DF_DU_CHAIN = 1,
+  DF_UD_CHAIN = 2
+};
+enum df_changeable_flags
+{
+  DF_LR_RUN_DCE = 1 << 0,
+  DF_NO_HARD_REGS = 1 << 1,
+  DF_EQ_NOTES = 1 << 2,
+  DF_NO_REGS_EVER_LIVE = 1 << 3,
+  DF_NO_INSN_RESCAN = 1 << 4,
+  DF_DEFER_INSN_RESCAN = 1 << 5,
+  DF_RD_PRUNE_DEAD_DEFS = 1 << 6,
+  DF_VERIFY_SCHEDULED = 1 << 7
+};
+struct df_ref_info
+{
+  df_ref *refs;
+  unsigned int *begin;
+  unsigned int *count;
+  unsigned int refs_size;
+  unsigned int table_size;
+  unsigned int total_size;
+  enum df_ref_order ref_order;
+};
+struct df_reg_info
+{
+  df_ref reg_chain;
+  unsigned int n_refs;
+};
+struct df_d
+{
+  struct dataflow *problems_in_order[(7 + 1)];
+  struct dataflow *problems_by_index[(7 + 1)];
+  bitmap blocks_to_analyze;
+  struct df_ref_info def_info;
+  struct df_ref_info use_info;
+  struct df_reg_info **def_regs;
+  struct df_reg_info **use_regs;
+  struct df_reg_info **eq_use_regs;
+  unsigned int regs_size;
+  unsigned int regs_inited;
+  struct df_insn_info **insns;
+  unsigned int insns_size;
+  int num_problems_defined;
+  bitmap_head hardware_regs_used;
+  bitmap_head regular_block_artificial_uses;
+  bitmap_head eh_block_artificial_uses;
+  bitmap entry_block_defs;
+  bitmap exit_block_uses;
+  bitmap_head insns_to_delete;
+  bitmap_head insns_to_rescan;
+  bitmap_head insns_to_notes_rescan;
+  int *postorder;
+  int *postorder_inverted;
+  int n_blocks;
+  int n_blocks_inverted;
+  unsigned int *hard_regs_live_count;
+  unsigned int ref_order;
+  int changeable_flags : 8;
+  bool analyze_subset;
+  bool redo_entry_and_exit;
+};
+extern bitmap_obstack df_bitmap_obstack;
+struct df_scan_bb_info
+{
+  df_ref *artificial_defs;
+  df_ref *artificial_uses;
+};
+struct df_rd_bb_info
+{
+  bitmap_head kill;
+  bitmap_head sparse_kill;
+  bitmap_head gen;
+  bitmap_head in;
+  bitmap_head out;
+};
+struct df_md_bb_info
+{
+  bitmap_head gen;
+  bitmap_head kill;
+  bitmap_head init;
+  bitmap_head in;
+  bitmap_head out;
+};
+struct df_lr_bb_info
+{
+  bitmap_head def;
+  bitmap_head use;
+  bitmap_head in;
+  bitmap_head out;
+};
+struct df_live_bb_info
+{
+  bitmap_head kill;
+  bitmap_head gen;
+  bitmap_head in;
+  bitmap_head out;
+};
+struct df_word_lr_bb_info
+{
+  bitmap_head def;
+  bitmap_head use;
+  bitmap_head in;
+  bitmap_head out;
+};
+extern struct df_d *df;
+extern void df_add_problem (struct df_problem *);
+extern int df_set_flags (int);
+extern int df_clear_flags (int);
+extern void df_set_blocks (bitmap);
+extern void df_remove_problem (struct dataflow *);
+extern void df_finish_pass (bool);
+extern void df_analyze_problem (struct dataflow *, bitmap, int *, int);
+extern void df_analyze (void);
+extern int df_get_n_blocks (enum df_flow_dir);
+extern int *df_get_postorder (enum df_flow_dir);
+extern void df_simple_dataflow (enum df_flow_dir, df_init_function,
+    df_confluence_function_0, df_confluence_function_n,
+    df_transfer_function, bitmap, int *, int);
+extern void df_mark_solutions_dirty (void);
+extern bool df_get_bb_dirty (basic_block);
+extern void df_set_bb_dirty (basic_block);
+extern void df_compact_blocks (void);
+extern void df_bb_replace (int, basic_block);
+extern void df_bb_delete (int);
+extern void df_verify (void);
+extern df_ref df_bb_regno_first_def_find (basic_block, unsigned int);
+extern df_ref df_bb_regno_last_def_find (basic_block, unsigned int);
+extern df_ref df_find_def (rtx, rtx);
+extern bool df_reg_defined (rtx, rtx);
+extern df_ref df_find_use (rtx, rtx);
+extern bool df_reg_used (rtx, rtx);
+extern void df_worklist_dataflow (struct dataflow *,bitmap, int *, int);
+extern void df_print_regset (FILE *file, bitmap r);
+extern void df_print_word_regset (FILE *file, bitmap r);
+extern void df_dump (FILE *);
+extern void df_dump_region (FILE *);
+extern void df_dump_start (FILE *);
+extern void df_dump_top (basic_block, FILE *);
+extern void df_dump_bottom (basic_block, FILE *);
+extern void df_dump_insn_top (const_rtx, FILE *);
+extern void df_dump_insn_bottom (const_rtx, FILE *);
+extern void df_refs_chain_dump (df_ref *, bool, FILE *);
+extern void df_regs_chain_dump (df_ref, FILE *);
+extern void df_insn_debug (rtx, bool, FILE *);
+extern void df_insn_debug_regno (rtx, FILE *);
+extern void df_regno_debug (unsigned int, FILE *);
+extern void df_ref_debug (df_ref, FILE *);
+extern void debug_df_insn (rtx);
+extern void debug_df_regno (unsigned int);
+extern void debug_df_reg (rtx);
+extern void debug_df_defno (unsigned int);
+extern void debug_df_useno (unsigned int);
+extern void debug_df_ref (df_ref);
+extern void debug_df_chain (struct df_link *);
+extern struct df_link *df_chain_create (df_ref, df_ref);
+extern void df_chain_unlink (df_ref);
+extern void df_chain_copy (df_ref, struct df_link *);
+extern void df_grow_bb_info (struct dataflow *);
+extern void df_chain_dump (struct df_link *, FILE *);
+extern void df_print_bb_index (basic_block bb, FILE *file);
+extern void df_rd_add_problem (void);
+extern void df_rd_simulate_artificial_defs_at_top (basic_block, bitmap);
+extern void df_rd_simulate_one_insn (basic_block, rtx, bitmap);
+extern void df_lr_add_problem (void);
+extern void df_lr_verify_transfer_functions (void);
+extern void df_live_verify_transfer_functions (void);
+extern void df_live_add_problem (void);
+extern void df_live_set_all_dirty (void);
+extern void df_chain_add_problem (unsigned int);
+extern void df_word_lr_add_problem (void);
+extern bool df_word_lr_mark_ref (df_ref, bool, bitmap);
+extern bool df_word_lr_simulate_defs (rtx, bitmap);
+extern void df_word_lr_simulate_uses (rtx, bitmap);
+extern void df_word_lr_simulate_artificial_refs_at_top (basic_block, bitmap);
+extern void df_word_lr_simulate_artificial_refs_at_end (basic_block, bitmap);
+extern void df_note_add_problem (void);
+extern void df_md_add_problem (void);
+extern void df_md_simulate_artificial_defs_at_top (basic_block, bitmap);
+extern void df_md_simulate_one_insn (basic_block, rtx, bitmap);
+extern void df_simulate_find_noclobber_defs (rtx, bitmap);
+extern void df_simulate_find_defs (rtx, bitmap);
+extern void df_simulate_defs (rtx, bitmap);
+extern void df_simulate_uses (rtx, bitmap);
+extern void df_simulate_initialize_backwards (basic_block, bitmap);
+extern void df_simulate_one_insn_backwards (basic_block, rtx, bitmap);
+extern void df_simulate_finalize_backwards (basic_block, bitmap);
+extern void df_simulate_initialize_forwards (basic_block, bitmap);
+extern void df_simulate_one_insn_forwards (basic_block, rtx, bitmap);
+extern void simulate_backwards_to_point (basic_block, regset, rtx);
+extern bool can_move_insns_across (rtx, rtx, rtx, rtx, basic_block, regset,
+       regset, rtx *);
+extern void df_scan_alloc (bitmap);
+extern void df_scan_add_problem (void);
+extern void df_grow_reg_info (void);
+extern void df_grow_insn_info (void);
+extern void df_scan_blocks (void);
+extern df_ref df_ref_create (rtx, rtx *, rtx,basic_block,
+        enum df_ref_type, int ref_flags);
+extern void df_uses_create (rtx *, rtx, int);
+extern void df_ref_remove (df_ref);
+extern struct df_insn_info * df_insn_create_insn_record (rtx);
+extern void df_insn_delete (basic_block, unsigned int);
+extern void df_bb_refs_record (int, bool);
+extern bool df_insn_rescan (rtx);
+extern bool df_insn_rescan_debug_internal (rtx);
+extern void df_insn_rescan_all (void);
+extern void df_process_deferred_rescans (void);
+extern void df_recompute_luids (basic_block);
+extern void df_insn_change_bb (rtx, basic_block);
+extern void df_maybe_reorganize_use_refs (enum df_ref_order);
+extern void df_maybe_reorganize_def_refs (enum df_ref_order);
+extern void df_ref_change_reg_with_loc (int, int, rtx);
+extern void df_notes_rescan (rtx);
+extern void df_hard_reg_init (void);
+extern void df_update_entry_block_defs (void);
+extern void df_update_exit_block_uses (void);
+extern void df_update_entry_exit_and_calls (void);
+extern bool df_hard_reg_used_p (unsigned int);
+extern unsigned int df_hard_reg_used_count (unsigned int);
+extern bool df_regs_ever_live_p (unsigned int);
+extern void df_set_regs_ever_live (unsigned int, bool);
+extern void df_compute_regs_ever_live (bool);
+extern bool df_read_modify_subreg_p (rtx);
+extern void df_scan_verify (void);
+static inline struct df_scan_bb_info *
+df_scan_get_bb_info (unsigned int index)
+{
+  if (index < (df->problems_by_index[0])->block_info_size)
+    return &((struct df_scan_bb_info *) (df->problems_by_index[0])->block_info)[index];
+  else
+    return __null;
+}
+static inline struct df_rd_bb_info *
+df_rd_get_bb_info (unsigned int index)
+{
+  if (index < (df->problems_by_index[3])->block_info_size)
+    return &((struct df_rd_bb_info *) (df->problems_by_index[3])->block_info)[index];
+  else
+    return __null;
+}
+static inline struct df_lr_bb_info *
+df_lr_get_bb_info (unsigned int index)
+{
+  if (index < (df->problems_by_index[1])->block_info_size)
+    return &((struct df_lr_bb_info *) (df->problems_by_index[1])->block_info)[index];
+  else
+    return __null;
+}
+static inline struct df_md_bb_info *
+df_md_get_bb_info (unsigned int index)
+{
+  if (index < (df->problems_by_index[7])->block_info_size)
+    return &((struct df_md_bb_info *) (df->problems_by_index[7])->block_info)[index];
+  else
+    return __null;
+}
+static inline struct df_live_bb_info *
+df_live_get_bb_info (unsigned int index)
+{
+  if (index < (df->problems_by_index[2])->block_info_size)
+    return &((struct df_live_bb_info *) (df->problems_by_index[2])->block_info)[index];
+  else
+    return __null;
+}
+static inline struct df_word_lr_bb_info *
+df_word_lr_get_bb_info (unsigned int index)
+{
+  if (index < (df->problems_by_index[5])->block_info_size)
+    return &((struct df_word_lr_bb_info *) (df->problems_by_index[5])->block_info)[index];
+  else
+    return __null;
+}
+static inline bitmap
+df_get_live_out (basic_block bb)
+{
+  ((void)(0 && ((df->problems_by_index[1]))));
+  if ((df->problems_by_index[2]))
+    return (&(df_live_get_bb_info((bb)->index))->out);
+  else
+    return (&(df_lr_get_bb_info((bb)->index))->out);
+}
+static inline bitmap
+df_get_live_in (basic_block bb)
+{
+  ((void)(0 && ((df->problems_by_index[1]))));
+  if ((df->problems_by_index[2]))
+    return (&(df_live_get_bb_info((bb)->index))->in);
+  else
+    return (&(df_lr_get_bb_info((bb)->index))->in);
+}
+static inline df_ref *
+df_get_artificial_defs (unsigned int bb_index)
+{
+  return df_scan_get_bb_info (bb_index)->artificial_defs;
+}
+static inline df_ref *
+df_get_artificial_uses (unsigned int bb_index)
+{
+  return df_scan_get_bb_info (bb_index)->artificial_uses;
+}
+struct web_entry
+{
+  struct web_entry *pred;
+  rtx reg;
+  void* extra_info;
+};
+extern struct web_entry *unionfind_root (struct web_entry *);
+extern bool unionfind_union (struct web_entry *, struct web_entry *);
+extern void union_defs (df_ref, struct web_entry *,
+   unsigned int *used, struct web_entry *,
+   bool (*fun) (struct web_entry *, struct web_entry *));
+typedef struct cselib_val_struct {
+  unsigned int hash;
+  int uid;
+  rtx val_rtx;
+  struct elt_loc_list *locs;
+  struct elt_list *addr_list;
+  struct cselib_val_struct *next_containing_mem;
+} cselib_val;
+struct elt_loc_list {
+  struct elt_loc_list *next;
+  rtx loc;
+  rtx setting_insn;
+};
+struct cselib_set
+{
+  rtx src;
+  rtx dest;
+  cselib_val *src_elt;
+  cselib_val *dest_addr_elt;
+};
+enum cselib_record_what
+{
+  CSELIB_RECORD_MEMORY = 1,
+  CSELIB_PRESERVE_CONSTANTS = 2
+};
+extern void (*cselib_discard_hook) (cselib_val *);
+extern void (*cselib_record_sets_hook) (rtx insn, struct cselib_set *sets,
+     int n_sets);
+extern cselib_val *cselib_lookup (rtx, enum machine_mode,
+      int, enum machine_mode);
+extern cselib_val *cselib_lookup_from_insn (rtx, enum machine_mode,
+         int, enum machine_mode, rtx);
+extern void cselib_init (int);
+extern void cselib_clear_table (void);
+extern void cselib_finish (void);
+extern void cselib_process_insn (rtx);
+extern bool fp_setter_insn (rtx);
+extern enum machine_mode cselib_reg_set_mode (const_rtx);
+extern int rtx_equal_for_cselib_p (rtx, rtx);
+extern int references_value_p (const_rtx, int);
+extern rtx cselib_expand_value_rtx (rtx, bitmap, int);
+typedef rtx (*cselib_expand_callback)(rtx, bitmap, int, void *);
+extern rtx cselib_expand_value_rtx_cb (rtx, bitmap, int,
+           cselib_expand_callback, void *);
+extern bool cselib_dummy_expand_value_rtx_cb (rtx, bitmap, int,
+           cselib_expand_callback, void *);
+extern rtx cselib_subst_to_values (rtx, enum machine_mode);
+extern rtx cselib_subst_to_values_from_insn (rtx, enum machine_mode, rtx);
+extern void cselib_invalidate_rtx (rtx);
+extern void cselib_reset_table (unsigned int);
+extern unsigned int cselib_get_next_uid (void);
+extern void cselib_preserve_value (cselib_val *);
+extern bool cselib_preserved_value_p (cselib_val *);
+extern void cselib_preserve_only_values (void);
+extern void cselib_preserve_cfa_base_value (cselib_val *, unsigned int);
+extern void cselib_add_permanent_equiv (cselib_val *, rtx, rtx);
+extern bool cselib_have_permanent_equivalences (void);
+extern void cselib_set_value_sp_based (cselib_val *);
+extern bool cselib_sp_based_value_p (cselib_val *);
+extern void dump_cselib_table (FILE *);
+static inline cselib_val *
+canonical_cselib_val (cselib_val *val)
+{
+  cselib_val *canon;
+  if (!val->locs || val->locs->next
+      || !val->locs->loc || ((enum rtx_code) (val->locs->loc)->code) != VALUE
+      || val->uid < (((val->locs->loc)->u.fld[0]).rt_cselib)->uid)
+    return val;
+  canon = (((val->locs->loc)->u.fld[0]).rt_cselib);
+  ((void)(0 && (canonical_cselib_val (canon) == canon)));
+  return canon;
+}
+extern void run_word_dce (void);
+extern void run_fast_dce (void);
+extern void run_fast_df_dce (void);
+template <typename Type>
+struct xcallocator
+{
+  static Type *control_alloc (size_t count);
+  static Type *data_alloc (size_t count);
+  static void control_free (Type *memory);
+  static void data_free (Type *memory);
+};
+template <typename Type>
+inline Type *
+xcallocator <Type>::control_alloc (size_t count)
+{
+  return static_cast <Type *> (xcalloc (count, sizeof (Type)));
+}
+template <typename Type>
+inline Type *
+xcallocator <Type>::data_alloc (size_t count)
+{
+  return static_cast <Type *> (xcalloc (count, sizeof (Type)));
+}
+template <typename Type>
+inline void
+xcallocator <Type>::control_free (Type *memory)
+{
+  return ::free (memory);
+}
+template <typename Type>
+inline void
+xcallocator <Type>::data_free (Type *memory)
+{
+  return ::free (memory);
+}
+template <typename Type>
+struct typed_free_remove
+{
+  static inline void remove (Type *p);
+};
+template <typename Type>
+inline void
+typed_free_remove <Type>::remove (Type *p)
+{
+  free (p);
+}
+template <typename Type>
+struct typed_noop_remove
+{
+  static inline void remove (Type *p);
+};
+template <typename Type>
+inline void
+typed_noop_remove <Type>::remove (Type *p __attribute__ ((__unused__)))
+{
+}
+template <typename Type>
+struct pointer_hash : typed_noop_remove <Type>
+{
+  typedef Type value_type;
+  typedef Type compare_type;
+  static inline hashval_t
+  hash (const value_type *);
+  static inline int
+  equal (const value_type *existing, const compare_type *candidate);
+};
+template <typename Type>
+inline hashval_t
+pointer_hash <Type>::hash (const value_type *candidate)
+{
+  return (hashval_t) ((intptr_t)candidate >> 3);
+}
+template <typename Type>
+inline int
+pointer_hash <Type>::equal (const value_type *existing,
+      const compare_type *candidate)
+{
+  return existing == candidate;
+}
+struct prime_ent
+{
+  hashval_t prime;
+  hashval_t inv;
+  hashval_t inv_m2;
+  hashval_t shift;
+};
+extern struct prime_ent const prime_tab[];
+extern unsigned int hash_table_higher_prime_index (unsigned long n);
+extern hashval_t hash_table_mod1 (hashval_t hash, unsigned int index);
+extern hashval_t hash_table_mod2 (hashval_t hash, unsigned int index);
+template <typename T>
+struct hash_table_control
+{
+  T **entries;
+  size_t size;
+  size_t n_elements;
+  size_t n_deleted;
+  unsigned int searches;
+  unsigned int collisions;
+  unsigned int size_prime_index;
+};
+template <typename Descriptor,
+   template <typename Type> class Allocator = xcallocator>
+class hash_table
+{
+public:
+  typedef typename Descriptor::value_type value_type;
+  typedef typename Descriptor::compare_type compare_type;
+private:
+  hash_table_control <value_type> *htab;
+  value_type **find_empty_slot_for_expand (hashval_t hash);
+  void expand ();
+public:
+  hash_table ();
+  void create (size_t initial_slots);
+  bool is_created ();
+  void dispose ();
+  value_type *find (const compare_type *comparable);
+  value_type *find_with_hash (const compare_type *comparable, hashval_t hash);
+  value_type **find_slot (const compare_type *comparable,
+     enum insert_option insert);
+  value_type **find_slot_with_hash (const compare_type *comparable,
+        hashval_t hash, enum insert_option insert);
+  void empty ();
+  void clear_slot (value_type **slot);
+  void remove_elt (const compare_type *comparable);
+  void remove_elt_with_hash (const compare_type *comparable, hashval_t hash);
+  size_t size();
+  size_t elements();
+  double collisions();
+  template <typename Argument,
+     int (*Callback) (value_type **slot, Argument argument)>
+  void traverse_noresize (Argument argument);
+  template <typename Argument,
+     int (*Callback) (value_type **slot, Argument argument)>
+  void traverse (Argument argument);
+};
+template <typename Descriptor,
+   template <typename Type> class Allocator>
+inline
+hash_table <Descriptor, Allocator>::hash_table ()
+: htab (__null)
+{
+}
+template <typename Descriptor,
+   template <typename Type> class Allocator>
+inline bool
+hash_table <Descriptor, Allocator>::is_created ()
+{
+  return htab != __null;
+}
+template <typename Descriptor,
+   template <typename Type> class Allocator>
+inline typename Descriptor::value_type *
+hash_table <Descriptor, Allocator>::find (const compare_type *comparable)
+{
+  return find_with_hash (comparable, Descriptor::hash (comparable));
+}
+template <typename Descriptor,
+   template <typename Type> class Allocator>
+inline typename Descriptor::value_type **
+hash_table <Descriptor, Allocator>
+::find_slot (const compare_type *comparable, enum insert_option insert)
+{
+  return find_slot_with_hash (comparable, Descriptor::hash (comparable), insert);
+}
+template <typename Descriptor,
+   template <typename Type> class Allocator>
+inline void
+hash_table <Descriptor, Allocator>::remove_elt (const compare_type *comparable)
+{
+  remove_elt_with_hash (comparable, Descriptor::hash (comparable));
+}
+template <typename Descriptor,
+   template <typename Type> class Allocator>
+inline size_t
+hash_table <Descriptor, Allocator>::size()
+{
+  return htab->size;
+}
+template <typename Descriptor,
+   template <typename Type> class Allocator>
+inline size_t
+hash_table <Descriptor, Allocator>::elements()
+{
+  return htab->n_elements - htab->n_deleted;
+}
+template <typename Descriptor,
+   template <typename Type> class Allocator>
+inline double
+hash_table <Descriptor, Allocator>::collisions()
+{
+  if (htab->searches == 0)
+    return 0.0;
+  return static_cast <double> (htab->collisions) / htab->searches;
+}
+template <typename Descriptor,
+   template <typename Type> class Allocator>
+void
+hash_table <Descriptor, Allocator>::create (size_t size)
+{
+  unsigned int size_prime_index;
+  size_prime_index = hash_table_higher_prime_index (size);
+  size = prime_tab[size_prime_index].prime;
+  htab = Allocator <hash_table_control <value_type> > ::control_alloc (1);
+  ((void)(!(htab != __null) ? fancy_abort ("../../gcc/hash-table.h", 512, __FUNCTION__), 0 : 0));
+  htab->entries = Allocator <value_type*> ::data_alloc (size);
+  ((void)(!(htab->entries != __null) ? fancy_abort ("../../gcc/hash-table.h", 514, __FUNCTION__), 0 : 0));
+  htab->size = size;
+  htab->size_prime_index = size_prime_index;
+}
+template <typename Descriptor,
+   template <typename Type> class Allocator>
+void
+hash_table <Descriptor, Allocator>::dispose ()
+{
+  size_t size = htab->size;
+  value_type **entries = htab->entries;
+  for (int i = size - 1; i >= 0; i--)
+    if (entries[i] != ((void *) 0) && entries[i] != ((void *) 1))
+      Descriptor::remove (entries[i]);
+  Allocator <value_type *> ::data_free (entries);
+  Allocator <hash_table_control <value_type> > ::control_free (htab);
+  htab = __null;
+}
+template <typename Descriptor,
+   template <typename Type> class Allocator>
+typename Descriptor::value_type **
+hash_table <Descriptor, Allocator>::find_empty_slot_for_expand (hashval_t hash)
+{
+  hashval_t index = hash_table_mod1 (hash, htab->size_prime_index);
+  size_t size = htab->size;
+  value_type **slot = htab->entries + index;
+  hashval_t hash2;
+  if (*slot == ((void *) 0))
+    return slot;
+  else if (*slot == ((void *) 1))
+    fancy_abort ("../../gcc/hash-table.h", 561, __FUNCTION__);
+  hash2 = hash_table_mod2 (hash, htab->size_prime_index);
+  for (;;)
+    {
+      index += hash2;
+      if (index >= size)
+        index -= size;
+      slot = htab->entries + index;
+      if (*slot == ((void *) 0))
+        return slot;
+      else if (*slot == ((void *) 1))
+        fancy_abort ("../../gcc/hash-table.h", 574, __FUNCTION__);
+    }
+}
+template <typename Descriptor,
+   template <typename Type> class Allocator>
+void
+hash_table <Descriptor, Allocator>::expand ()
+{
+  value_type **oentries;
+  value_type **olimit;
+  value_type **p;
+  value_type **nentries;
+  size_t nsize, osize, elts;
+  unsigned int oindex, nindex;
+  oentries = htab->entries;
+  oindex = htab->size_prime_index;
+  osize = htab->size;
+  olimit = oentries + osize;
+  elts = elements ();
+  if (elts * 2 > osize || (elts * 8 < osize && osize > 32))
+    {
+      nindex = hash_table_higher_prime_index (elts * 2);
+      nsize = prime_tab[nindex].prime;
+    }
+  else
+    {
+      nindex = oindex;
+      nsize = osize;
+    }
+  nentries = Allocator <value_type *> ::data_alloc (nsize);
+  ((void)(!(nentries != __null) ? fancy_abort ("../../gcc/hash-table.h", 618, __FUNCTION__), 0 : 0));
+  htab->entries = nentries;
+  htab->size = nsize;
+  htab->size_prime_index = nindex;
+  htab->n_elements -= htab->n_deleted;
+  htab->n_deleted = 0;
+  p = oentries;
+  do
+    {
+      value_type *x = *p;
+      if (x != ((void *) 0) && x != ((void *) 1))
+        {
+          value_type **q = find_empty_slot_for_expand (Descriptor::hash (x));
+          *q = x;
+        }
+      p++;
+    }
+  while (p < olimit);
+  Allocator <value_type *> ::data_free (oentries);
+}
+template <typename Descriptor,
+   template <typename Type> class Allocator>
+typename Descriptor::value_type *
+hash_table <Descriptor, Allocator>
+::find_with_hash (const compare_type *comparable, hashval_t hash)
+{
+  hashval_t index, hash2;
+  size_t size;
+  value_type *entry;
+  htab->searches++;
+  size = htab->size;
+  index = hash_table_mod1 (hash, htab->size_prime_index);
+  entry = htab->entries[index];
+  if (entry == ((void *) 0)
+      || (entry != ((void *) 1) && Descriptor::equal (entry, comparable)))
+    return entry;
+  hash2 = hash_table_mod2 (hash, htab->size_prime_index);
+  for (;;)
+    {
+      htab->collisions++;
+      index += hash2;
+      if (index >= size)
+        index -= size;
+      entry = htab->entries[index];
+      if (entry == ((void *) 0)
+          || (entry != ((void *) 1)
+       && Descriptor::equal (entry, comparable)))
+        return entry;
+    }
+}
+template <typename Descriptor,
+   template <typename Type> class Allocator>
+typename Descriptor::value_type **
+hash_table <Descriptor, Allocator>
+::find_slot_with_hash (const compare_type *comparable, hashval_t hash,
+         enum insert_option insert)
+{
+  value_type **first_deleted_slot;
+  hashval_t index, hash2;
+  size_t size;
+  value_type *entry;
+  size = htab->size;
+  if (insert == INSERT && size * 3 <= htab->n_elements * 4)
+    {
+      expand ();
+      size = htab->size;
+    }
+  index = hash_table_mod1 (hash, htab->size_prime_index);
+  htab->searches++;
+  first_deleted_slot = __null;
+  entry = htab->entries[index];
+  if (entry == ((void *) 0))
+    goto empty_entry;
+  else if (entry == ((void *) 1))
+    first_deleted_slot = &htab->entries[index];
+  else if (Descriptor::equal (entry, comparable))
+    return &htab->entries[index];
+  hash2 = hash_table_mod2 (hash, htab->size_prime_index);
+  for (;;)
+    {
+      htab->collisions++;
+      index += hash2;
+      if (index >= size)
+ index -= size;
+      entry = htab->entries[index];
+      if (entry == ((void *) 0))
+ goto empty_entry;
+      else if (entry == ((void *) 1))
+ {
+   if (!first_deleted_slot)
+     first_deleted_slot = &htab->entries[index];
+ }
+      else if (Descriptor::equal (entry, comparable))
+ return &htab->entries[index];
+    }
+ empty_entry:
+  if (insert == NO_INSERT)
+    return __null;
+  if (first_deleted_slot)
+    {
+      htab->n_deleted--;
+      *first_deleted_slot = static_cast <value_type *> (((void *) 0));
+      return first_deleted_slot;
+    }
+  htab->n_elements++;
+  return &htab->entries[index];
+}
+template <typename Descriptor,
+   template <typename Type> class Allocator>
+void
+hash_table <Descriptor, Allocator>::empty ()
+{
+  size_t size = htab->size;
+  value_type **entries = htab->entries;
+  int i;
+  for (i = size - 1; i >= 0; i--)
+    if (entries[i] != ((void *) 0) && entries[i] != ((void *) 1))
+      Descriptor::remove (entries[i]);
+  if (size > 1024*1024 / sizeof (void *))
+    {
+      int nindex = hash_table_higher_prime_index (1024 / sizeof (void *));
+      int nsize = prime_tab[nindex].prime;
+      Allocator <value_type *> ::data_free (htab->entries);
+      htab->entries = Allocator <value_type *> ::data_alloc (nsize);
+      htab->size = nsize;
+      htab->size_prime_index = nindex;
+    }
+  else
+    memset (entries, 0, size * sizeof (value_type *));
+  htab->n_deleted = 0;
+  htab->n_elements = 0;
+}
+template <typename Descriptor,
+   template <typename Type> class Allocator>
+void
+hash_table <Descriptor, Allocator>::clear_slot (value_type **slot)
+{
+  if (slot < htab->entries || slot >= htab->entries + htab->size
+      || *slot == ((void *) 0) || *slot == ((void *) 1))
+    fancy_abort ("../../gcc/hash-table.h", 805, __FUNCTION__);
+  Descriptor::remove (*slot);
+  *slot = static_cast <value_type *> (((void *) 1));
+  htab->n_deleted++;
+}
+template <typename Descriptor,
+   template <typename Type> class Allocator>
+void
+hash_table <Descriptor, Allocator>
+::remove_elt_with_hash (const compare_type *comparable, hashval_t hash)
+{
+  value_type **slot;
+  slot = find_slot_with_hash (comparable, hash, NO_INSERT);
+  if (*slot == ((void *) 0))
+    return;
+  Descriptor::remove (*slot);
+  *slot = static_cast <value_type *> (((void *) 1));
+  htab->n_deleted++;
+}
+template <typename Descriptor,
+   template <typename Type> class Allocator>
+template <typename Argument,
+   int (*Callback) (typename Descriptor::value_type **slot, Argument argument)>
+void
+hash_table <Descriptor, Allocator>::traverse_noresize (Argument argument)
+{
+  value_type **slot;
+  value_type **limit;
+  slot = htab->entries;
+  limit = slot + htab->size;
+  do
+    {
+      value_type *x = *slot;
+      if (x != ((void *) 0) && x != ((void *) 1))
+        if (! Callback (slot, argument))
+          break;
+    }
+  while (++slot < limit);
+}
+template <typename Descriptor,
+   template <typename Type> class Allocator>
+template <typename Argument,
+   int (*Callback) (typename Descriptor::value_type **slot,
+      Argument argument)>
+void
+hash_table <Descriptor, Allocator>::traverse (Argument argument)
+{
+  size_t size = htab->size;
+  if (elements () * 8 < size && size > 32)
+    expand ();
+  traverse_noresize <Argument, Callback> (argument);
+}
+struct dead_debug_global_entry
+{
+  rtx reg;
+  rtx dtemp;
+};
+struct dead_debug_hash_descr
+{
+  typedef struct dead_debug_global_entry value_type;
+  typedef struct dead_debug_global_entry compare_type;
+  static inline hashval_t hash (const value_type *my);
+  static inline bool equal (const value_type *my, const compare_type *other);
+  static inline void remove (value_type *p);
+};
+inline hashval_t
+dead_debug_hash_descr::hash (const value_type *my)
+{
+  return (rhs_regno(my->reg));
+}
+inline bool
+dead_debug_hash_descr::equal (const value_type *my, const compare_type *other)
+{
+  return my->reg == other->reg;
+}
+inline void
+dead_debug_hash_descr::remove (value_type *p)
+{
+  free ((void*) (p));
+}
+struct dead_debug_global
+{
+  hash_table <dead_debug_hash_descr> htab;
+  bitmap used;
+};
+struct dead_debug_use
+{
+  df_ref use;
+  struct dead_debug_use *next;
+};
+struct dead_debug_local
+{
+  struct dead_debug_use *head;
+  struct dead_debug_global *global;
+  bitmap used;
+  bitmap to_rescan;
+};
+enum debug_temp_where
+  {
+    DEBUG_TEMP_BEFORE_WITH_REG = -1,
+    DEBUG_TEMP_BEFORE_WITH_VALUE = 0,
+    DEBUG_TEMP_AFTER_WITH_REG = 1,
+    DEBUG_TEMP_AFTER_WITH_REG_FORCE = 2
+  };
+extern void dead_debug_global_init (struct dead_debug_global *, bitmap);
+extern void dead_debug_global_finish (struct dead_debug_global *, bitmap);
+extern void dead_debug_local_init (struct dead_debug_local *, bitmap,
+       struct dead_debug_global *);
+extern void dead_debug_local_finish (struct dead_debug_local *, bitmap);
+extern void dead_debug_add (struct dead_debug_local *, df_ref, unsigned int);
+extern int dead_debug_insert_temp (struct dead_debug_local *,
+       unsigned int uregno, rtx insn,
+       enum debug_temp_where);
+extern void propagate_for_debug (rtx, rtx, rtx, rtx, basic_block);
+enum tree_dump_index
+{
+  TDI_none,
+  TDI_cgraph,
+  TDI_tu,
+  TDI_class,
+  TDI_original,
+  TDI_generic,
+  TDI_nested,
+  TDI_tree_all,
+  TDI_rtl_all,
+  TDI_ipa_all,
+  TDI_end
+};
+struct dump_file_info
+{
+  const char *suffix;
+  const char *swtch;
+  const char *glob;
+  const char *pfilename;
+  const char *alt_filename;
+  FILE *pstream;
+  FILE *alt_stream;
+  int pflags;
+  int optgroup_flags;
+  int alt_flags;
+  int pstate;
+  int alt_state;
+  int num;
+};
+extern char *get_dump_file_name (int);
+extern int dump_initialized_p (int);
+extern FILE *dump_begin (int, int *);
+extern void dump_end (int, FILE *);
+extern int dump_start (int, int *);
+extern void dump_finish (int);
+extern void dump_node (const_tree, int, FILE *);
+extern int dump_switch_p (const char *);
+extern int opt_info_switch_p (const char *);
+extern const char *dump_flag_name (int);
+extern void dump_printf (int, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3))) __attribute__ ((__nonnull__ (2)));
+extern void dump_printf_loc (int, source_location,
+                             const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4))) __attribute__ ((__nonnull__ (3)));
+extern void dump_basic_block (int, basic_block, int);
+extern void dump_generic_expr_loc (int, source_location, int, tree);
+extern void dump_generic_expr (int, int, tree);
+extern void dump_gimple_stmt_loc (int, source_location, int, gimple, int);
+extern void dump_gimple_stmt (int, int, gimple, int);
+extern void print_combine_total_stats (void);
+extern unsigned int dump_register (const char *, const char *, const char *,
+                                   int, int);
+extern bool enable_rtl_dump_file (void);
+extern void dump_combine_total_stats (FILE *);
+extern void dump_bb (FILE *, basic_block, int, int);
+extern FILE *dump_file;
+extern FILE *alt_dump_file;
+extern int dump_flags;
+extern const char *dump_file_name;
+extern struct dump_file_info *get_dump_file_info (int);
+static inline bool
+dump_enabled_p (void)
+{
+  return (dump_file || alt_dump_file);
+}
+enum opt_pass_type
+{
+  GIMPLE_PASS,
+  RTL_PASS,
+  SIMPLE_IPA_PASS,
+  IPA_PASS
+};
+struct opt_pass
+{
+  enum opt_pass_type type;
+  const char *name;
+  unsigned int optinfo_flags;
+  bool (*gate) (void);
+  unsigned int (*execute) (void);
+  struct opt_pass *sub;
+  struct opt_pass *next;
+  int static_pass_number;
+  timevar_id_t tv_id;
+  unsigned int properties_required;
+  unsigned int properties_provided;
+  unsigned int properties_destroyed;
+  unsigned int todo_flags_start;
+  unsigned int todo_flags_finish;
+};
+struct gimple_opt_pass
+{
+  struct opt_pass pass;
+};
+struct rtl_opt_pass
+{
+  struct opt_pass pass;
+};
+struct varpool_node;
+struct cgraph_node;
+struct lto_symtab_encoder_d;
+struct ipa_opt_pass_d
+{
+  struct opt_pass pass;
+  void (*generate_summary) (void);
+  void (*write_summary) (void);
+  void (*read_summary) (void);
+  void (*write_optimization_summary) (void);
+  void (*read_optimization_summary) (void);
+  void (*stmt_fixup) (struct cgraph_node *, gimple *);
+  unsigned int function_transform_todo_flags_start;
+  unsigned int (*function_transform) (struct cgraph_node *);
+  void (*variable_transform) (struct varpool_node *);
+};
+struct simple_ipa_opt_pass
+{
+  struct opt_pass pass;
+};
+enum pass_positioning_ops
+{
+  PASS_POS_INSERT_AFTER,
+  PASS_POS_INSERT_BEFORE,
+  PASS_POS_REPLACE
+};
+struct register_pass_info
+{
+  struct opt_pass *pass;
+  const char *reference_pass_name;
+  int ref_pass_instance_number;
+  enum pass_positioning_ops pos_op;
+};
+extern struct gimple_opt_pass pass_mudflap_1;
+extern struct gimple_opt_pass pass_mudflap_2;
+extern struct gimple_opt_pass pass_asan;
+extern struct gimple_opt_pass pass_asan_O0;
+extern struct gimple_opt_pass pass_tsan;
+extern struct gimple_opt_pass pass_tsan_O0;
+extern struct gimple_opt_pass pass_lower_cf;
+extern struct gimple_opt_pass pass_refactor_eh;
+extern struct gimple_opt_pass pass_lower_eh;
+extern struct gimple_opt_pass pass_lower_eh_dispatch;
+extern struct gimple_opt_pass pass_lower_resx;
+extern struct gimple_opt_pass pass_build_cfg;
+extern struct gimple_opt_pass pass_early_tree_profile;
+extern struct gimple_opt_pass pass_cleanup_eh;
+extern struct gimple_opt_pass pass_sra;
+extern struct gimple_opt_pass pass_sra_early;
+extern struct gimple_opt_pass pass_early_ipa_sra;
+extern struct gimple_opt_pass pass_tail_recursion;
+extern struct gimple_opt_pass pass_tail_calls;
+extern struct gimple_opt_pass pass_tree_loop;
+extern struct gimple_opt_pass pass_tree_loop_init;
+extern struct gimple_opt_pass pass_lim;
+extern struct gimple_opt_pass pass_tree_unswitch;
+extern struct gimple_opt_pass pass_predcom;
+extern struct gimple_opt_pass pass_iv_canon;
+extern struct gimple_opt_pass pass_scev_cprop;
+extern struct gimple_opt_pass pass_empty_loop;
+extern struct gimple_opt_pass pass_record_bounds;
+extern struct gimple_opt_pass pass_graphite;
+extern struct gimple_opt_pass pass_graphite_transforms;
+extern struct gimple_opt_pass pass_if_conversion;
+extern struct gimple_opt_pass pass_loop_distribution;
+extern struct gimple_opt_pass pass_vectorize;
+extern struct gimple_opt_pass pass_slp_vectorize;
+extern struct gimple_opt_pass pass_complete_unroll;
+extern struct gimple_opt_pass pass_complete_unrolli;
+extern struct gimple_opt_pass pass_parallelize_loops;
+extern struct gimple_opt_pass pass_loop_prefetch;
+extern struct gimple_opt_pass pass_iv_optimize;
+extern struct gimple_opt_pass pass_tree_loop_done;
+extern struct gimple_opt_pass pass_ch;
+extern struct gimple_opt_pass pass_ccp;
+extern struct gimple_opt_pass pass_phi_only_cprop;
+extern struct gimple_opt_pass pass_build_ssa;
+extern struct gimple_opt_pass pass_build_alias;
+extern struct gimple_opt_pass pass_build_ealias;
+extern struct gimple_opt_pass pass_dominator;
+extern struct gimple_opt_pass pass_dce;
+extern struct gimple_opt_pass pass_dce_loop;
+extern struct gimple_opt_pass pass_cd_dce;
+extern struct gimple_opt_pass pass_call_cdce;
+extern struct gimple_opt_pass pass_merge_phi;
+extern struct gimple_opt_pass pass_split_crit_edges;
+extern struct gimple_opt_pass pass_pre;
+extern unsigned int tail_merge_optimize (unsigned int);
+extern struct gimple_opt_pass pass_profile;
+extern struct gimple_opt_pass pass_strip_predict_hints;
+extern struct gimple_opt_pass pass_lower_complex_O0;
+extern struct gimple_opt_pass pass_lower_complex;
+extern struct gimple_opt_pass pass_lower_vector;
+extern struct gimple_opt_pass pass_lower_vector_ssa;
+extern struct gimple_opt_pass pass_lower_omp;
+extern struct gimple_opt_pass pass_diagnose_omp_blocks;
+extern struct gimple_opt_pass pass_expand_omp;
+extern struct gimple_opt_pass pass_expand_omp_ssa;
+extern struct gimple_opt_pass pass_object_sizes;
+extern struct gimple_opt_pass pass_strlen;
+extern struct gimple_opt_pass pass_fold_builtins;
+extern struct gimple_opt_pass pass_stdarg;
+extern struct gimple_opt_pass pass_early_warn_uninitialized;
+extern struct gimple_opt_pass pass_late_warn_uninitialized;
+extern struct gimple_opt_pass pass_cse_reciprocals;
+extern struct gimple_opt_pass pass_cse_sincos;
+extern struct gimple_opt_pass pass_optimize_bswap;
+extern struct gimple_opt_pass pass_optimize_widening_mul;
+extern struct gimple_opt_pass pass_warn_function_return;
+extern struct gimple_opt_pass pass_warn_function_noreturn;
+extern struct gimple_opt_pass pass_cselim;
+extern struct gimple_opt_pass pass_phiopt;
+extern struct gimple_opt_pass pass_forwprop;
+extern struct gimple_opt_pass pass_phiprop;
+extern struct gimple_opt_pass pass_tree_ifcombine;
+extern struct gimple_opt_pass pass_dse;
+extern struct gimple_opt_pass pass_nrv;
+extern struct gimple_opt_pass pass_rename_ssa_copies;
+extern struct gimple_opt_pass pass_sink_code;
+extern struct gimple_opt_pass pass_fre;
+extern struct gimple_opt_pass pass_check_data_deps;
+extern struct gimple_opt_pass pass_copy_prop;
+extern struct gimple_opt_pass pass_vrp;
+extern struct gimple_opt_pass pass_uncprop;
+extern struct gimple_opt_pass pass_return_slot;
+extern struct gimple_opt_pass pass_reassoc;
+extern struct gimple_opt_pass pass_rebuild_cgraph_edges;
+extern struct gimple_opt_pass pass_remove_cgraph_callee_edges;
+extern struct gimple_opt_pass pass_build_cgraph_edges;
+extern struct gimple_opt_pass pass_local_pure_const;
+extern struct gimple_opt_pass pass_tracer;
+extern struct gimple_opt_pass pass_warn_unused_result;
+extern struct gimple_opt_pass pass_diagnose_tm_blocks;
+extern struct gimple_opt_pass pass_lower_tm;
+extern struct gimple_opt_pass pass_tm_init;
+extern struct gimple_opt_pass pass_tm_mark;
+extern struct gimple_opt_pass pass_tm_memopt;
+extern struct gimple_opt_pass pass_tm_edges;
+extern struct gimple_opt_pass pass_split_functions;
+extern struct gimple_opt_pass pass_feedback_split_functions;
+extern struct gimple_opt_pass pass_strength_reduction;
+extern struct simple_ipa_opt_pass pass_ipa_lower_emutls;
+extern struct simple_ipa_opt_pass pass_ipa_function_and_variable_visibility;
+extern struct simple_ipa_opt_pass pass_ipa_tree_profile;
+extern struct simple_ipa_opt_pass pass_early_local_passes;
+extern struct ipa_opt_pass_d pass_ipa_whole_program_visibility;
+extern struct ipa_opt_pass_d pass_ipa_lto_gimple_out;
+extern struct simple_ipa_opt_pass pass_ipa_increase_alignment;
+extern struct ipa_opt_pass_d pass_ipa_inline;
+extern struct simple_ipa_opt_pass pass_ipa_free_lang_data;
+extern struct simple_ipa_opt_pass pass_ipa_free_inline_summary;
+extern struct ipa_opt_pass_d pass_ipa_cp;
+extern struct ipa_opt_pass_d pass_ipa_reference;
+extern struct ipa_opt_pass_d pass_ipa_pure_const;
+extern struct simple_ipa_opt_pass pass_ipa_pta;
+extern struct ipa_opt_pass_d pass_ipa_lto_wpa_fixup;
+extern struct ipa_opt_pass_d pass_ipa_lto_finish_out;
+extern struct simple_ipa_opt_pass pass_ipa_tm;
+extern struct ipa_opt_pass_d pass_ipa_profile;
+extern struct ipa_opt_pass_d pass_ipa_cdtor_merge;
+extern struct gimple_opt_pass pass_cleanup_cfg_post_optimizing;
+extern struct gimple_opt_pass pass_init_datastructures;
+extern struct gimple_opt_pass pass_fixup_cfg;
+extern struct rtl_opt_pass pass_expand;
+extern struct rtl_opt_pass pass_instantiate_virtual_regs;
+extern struct rtl_opt_pass pass_rtl_fwprop;
+extern struct rtl_opt_pass pass_rtl_fwprop_addr;
+extern struct rtl_opt_pass pass_jump;
+extern struct rtl_opt_pass pass_jump2;
+extern struct rtl_opt_pass pass_lower_subreg;
+extern struct rtl_opt_pass pass_cse;
+extern struct rtl_opt_pass pass_fast_rtl_dce;
+extern struct rtl_opt_pass pass_ud_rtl_dce;
+extern struct rtl_opt_pass pass_rtl_dce;
+extern struct rtl_opt_pass pass_rtl_dse1;
+extern struct rtl_opt_pass pass_rtl_dse2;
+extern struct rtl_opt_pass pass_rtl_dse3;
+extern struct rtl_opt_pass pass_rtl_cprop;
+extern struct rtl_opt_pass pass_rtl_pre;
+extern struct rtl_opt_pass pass_rtl_hoist;
+extern struct rtl_opt_pass pass_rtl_store_motion;
+extern struct rtl_opt_pass pass_cse_after_global_opts;
+extern struct rtl_opt_pass pass_rtl_ifcvt;
+extern struct rtl_opt_pass pass_into_cfg_layout_mode;
+extern struct rtl_opt_pass pass_outof_cfg_layout_mode;
+extern struct rtl_opt_pass pass_loop2;
+extern struct rtl_opt_pass pass_rtl_loop_init;
+extern struct rtl_opt_pass pass_rtl_move_loop_invariants;
+extern struct rtl_opt_pass pass_rtl_unswitch;
+extern struct rtl_opt_pass pass_rtl_unroll_and_peel_loops;
+extern struct rtl_opt_pass pass_rtl_doloop;
+extern struct rtl_opt_pass pass_rtl_loop_done;
+extern struct rtl_opt_pass pass_web;
+extern struct rtl_opt_pass pass_cse2;
+extern struct rtl_opt_pass pass_df_initialize_opt;
+extern struct rtl_opt_pass pass_df_initialize_no_opt;
+extern struct rtl_opt_pass pass_reginfo_init;
+extern struct rtl_opt_pass pass_inc_dec;
+extern struct rtl_opt_pass pass_stack_ptr_mod;
+extern struct rtl_opt_pass pass_initialize_regs;
+extern struct rtl_opt_pass pass_combine;
+extern struct rtl_opt_pass pass_if_after_combine;
+extern struct rtl_opt_pass pass_ree;
+extern struct rtl_opt_pass pass_partition_blocks;
+extern struct rtl_opt_pass pass_match_asm_constraints;
+extern struct rtl_opt_pass pass_regmove;
+extern struct rtl_opt_pass pass_split_all_insns;
+extern struct rtl_opt_pass pass_fast_rtl_byte_dce;
+extern struct rtl_opt_pass pass_lower_subreg2;
+extern struct rtl_opt_pass pass_mode_switching;
+extern struct rtl_opt_pass pass_sms;
+extern struct rtl_opt_pass pass_sched;
+extern struct rtl_opt_pass pass_ira;
+extern struct rtl_opt_pass pass_reload;
+extern struct rtl_opt_pass pass_clean_state;
+extern struct rtl_opt_pass pass_branch_prob;
+extern struct rtl_opt_pass pass_value_profile_transformations;
+extern struct rtl_opt_pass pass_postreload_cse;
+extern struct rtl_opt_pass pass_gcse2;
+extern struct rtl_opt_pass pass_split_after_reload;
+extern struct rtl_opt_pass pass_branch_target_load_optimize1;
+extern struct rtl_opt_pass pass_thread_prologue_and_epilogue;
+extern struct rtl_opt_pass pass_stack_adjustments;
+extern struct rtl_opt_pass pass_peephole2;
+extern struct rtl_opt_pass pass_if_after_reload;
+extern struct rtl_opt_pass pass_regrename;
+extern struct rtl_opt_pass pass_cprop_hardreg;
+extern struct rtl_opt_pass pass_reorder_blocks;
+extern struct rtl_opt_pass pass_branch_target_load_optimize2;
+extern struct rtl_opt_pass pass_leaf_regs;
+extern struct rtl_opt_pass pass_split_before_sched2;
+extern struct rtl_opt_pass pass_compare_elim_after_reload;
+extern struct rtl_opt_pass pass_sched2;
+extern struct rtl_opt_pass pass_stack_regs;
+extern struct rtl_opt_pass pass_stack_regs_run;
+extern struct rtl_opt_pass pass_df_finish;
+extern struct rtl_opt_pass pass_compute_alignments;
+extern struct rtl_opt_pass pass_duplicate_computed_gotos;
+extern struct rtl_opt_pass pass_variable_tracking;
+extern struct rtl_opt_pass pass_free_cfg;
+extern struct rtl_opt_pass pass_machine_reorg;
+extern struct rtl_opt_pass pass_cleanup_barriers;
+extern struct rtl_opt_pass pass_delay_slots;
+extern struct rtl_opt_pass pass_split_for_shorten_branches;
+extern struct rtl_opt_pass pass_split_before_regstack;
+extern struct rtl_opt_pass pass_convert_to_eh_region_ranges;
+extern struct rtl_opt_pass pass_shorten_branches;
+extern struct rtl_opt_pass pass_set_nothrow_function_flags;
+extern struct rtl_opt_pass pass_dwarf2_frame;
+extern struct rtl_opt_pass pass_final;
+extern struct rtl_opt_pass pass_rtl_seqabstr;
+extern struct gimple_opt_pass pass_release_ssa_names;
+extern struct gimple_opt_pass pass_early_inline;
+extern struct gimple_opt_pass pass_inline_parameters;
+extern struct gimple_opt_pass pass_update_address_taken;
+extern struct gimple_opt_pass pass_convert_switch;
+extern struct opt_pass *all_passes, *all_small_ipa_passes, *all_lowering_passes,
+                       *all_regular_ipa_passes, *all_lto_gen_passes, *all_late_ipa_passes;
+enum
+{
+  PASS_LIST_NO_all_lowering_passes, PASS_LIST_NO_all_small_ipa_passes, PASS_LIST_NO_all_regular_ipa_passes, PASS_LIST_NO_all_lto_gen_passes, PASS_LIST_NO_all_passes,
+  PASS_LIST_NUM
+};
+extern struct opt_pass **gcc_pass_lists[];
+extern struct opt_pass *current_pass;
+extern struct opt_pass * get_pass_for_id (int);
+extern bool execute_one_pass (struct opt_pass *);
+extern void execute_pass_list (struct opt_pass *);
+extern void execute_ipa_pass_list (struct opt_pass *);
+extern void execute_ipa_summary_passes (struct ipa_opt_pass_d *);
+extern void execute_all_ipa_transforms (void);
+extern void execute_all_ipa_stmt_fixups (struct cgraph_node *, gimple *);
+extern bool pass_init_dump_file (struct opt_pass *);
+extern void pass_fini_dump_file (struct opt_pass *);
+extern const char *get_current_pass_name (void);
+extern void print_current_pass (FILE *);
+extern void debug_pass (void);
+extern void ipa_write_summaries (void);
+extern void ipa_write_optimization_summaries (struct lto_symtab_encoder_d *);
+extern void ipa_read_summaries (void);
+extern void ipa_read_optimization_summaries (void);
+extern void register_one_dump_file (struct opt_pass *);
+extern bool function_called_by_processed_nodes_p (void);
+extern void register_pass (struct register_pass_info *);
+extern bool first_pass_instance;
+extern struct opt_pass **passes_by_id;
+extern int passes_by_id_size;
+extern void do_per_function_toporder (void (*) (void *), void *);
+extern void disable_pass (const char *);
+extern void enable_pass (const char *);
+extern void dump_passes (void);
+enum debug_counter {
+auto_inc_dec,
+ccp,
+cfg_cleanup,
+cse2_move2add,
+cprop,
+dce,
+dce_fast,
+dce_ud,
+delete_trivial_dead,
+df_byte_scan,
+dse,
+dse1,
+dse2,
+gcse2_delete,
+global_alloc_at_func,
+global_alloc_at_reg,
+graphite_scop,
+hoist,
+hoist_insn,
+ia64_sched2,
+if_conversion,
+if_conversion_tree,
+if_after_combine,
+if_after_reload,
+local_alloc_for_sched,
+postreload_cse,
+pre,
+pre_insn,
+treepre_insert,
+tree_sra,
+eipa_sra,
+sched2_func,
+sched_block,
+sched_func,
+sched_insn,
+sched_breakdep,
+sched_region,
+sel_sched_cnt,
+sel_sched_region_cnt,
+sel_sched_insn_cnt,
+sms_sched_loop,
+store_motion,
+split_for_sched2,
+tail_call,
+ira_move,
+   debug_counter_number_of_counters
+};
+extern bool dbg_cnt_is_enabled (enum debug_counter index);
+extern bool dbg_cnt (enum debug_counter index);
+extern void dbg_cnt_process_opt (const char *arg);
+extern void dbg_cnt_list_all_counters (void);
+enum sh_function_kind {
+  FUNCTION_ORDINARY,
+  SFUNC_FREQUENT,
+  SFUNC_GOT,
+  SFUNC_STATIC
+};
+struct sh_atomic_model
+{
+  enum enum_type
+  {
+    none = 0,
+    soft_gusa,
+    hard_llcs,
+    soft_tcb,
+    soft_imask,
+    num_models
+  };
+  bool strict;
+  enum_type type;
+  const char* name;
+  const char* cdef_name;
+  int tcb_gbr_offset;
+};
+extern const sh_atomic_model& selected_atomic_model (void);
+extern rtx sh_fsca_sf2int (void);
+extern rtx sh_fsca_int2sf (void);
+extern const char *output_branch (int, rtx, rtx *);
+extern const char *output_ieee_ccmpeq (rtx, rtx *);
+extern const char *output_branchy_insn (enum rtx_code, const char *, rtx, rtx *);
+extern const char *output_movedouble (rtx, rtx[], enum machine_mode);
+extern const char *output_movepcrel (rtx, rtx[], enum machine_mode);
+extern const char *output_far_jump (rtx, rtx);
+extern rtx sfunc_uses_reg (rtx);
+extern int sh_jump_align (rtx);
+extern int barrier_align (rtx);
+extern int sh_loop_align (rtx);
+extern bool fp_zero_operand (rtx);
+extern bool fp_one_operand (rtx);
+extern rtx get_fpscr_rtx (void);
+extern bool sh_legitimate_index_p (enum machine_mode, rtx, bool, bool);
+extern bool sh_legitimize_reload_address (rtx *, enum machine_mode, int, int);
+extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);
+extern bool nonpic_symbol_mentioned_p (rtx);
+extern void emit_sf_insn (rtx);
+extern void emit_df_insn (rtx);
+extern void output_pic_addr_const (FILE *, rtx);
+extern bool expand_block_move (rtx *);
+extern void prepare_move_operands (rtx[], enum machine_mode mode);
+extern bool sh_expand_cmpstr (rtx *);
+extern bool sh_expand_cmpnstr (rtx *);
+extern bool sh_expand_strlen (rtx *);
+extern enum rtx_code prepare_cbranch_operands (rtx *, enum machine_mode mode,
+            enum rtx_code comparison);
+extern void expand_cbranchsi4 (rtx *operands, enum rtx_code comparison, int);
+extern bool expand_cbranchdi4 (rtx *operands, enum rtx_code comparison);
+extern void sh_emit_scc_to_t (enum rtx_code, rtx, rtx);
+extern rtx sh_emit_cheap_store_flag (enum machine_mode, enum rtx_code, rtx, rtx);
+extern void sh_emit_compare_and_branch (rtx *, enum machine_mode);
+extern void sh_emit_compare_and_set (rtx *, enum machine_mode);
+extern bool sh_ashlsi_clobbers_t_reg_p (rtx);
+extern bool sh_lshrsi_clobbers_t_reg_p (rtx);
+extern void gen_shifty_op (int, rtx *);
+extern void gen_shifty_hi_op (int, rtx *);
+extern bool expand_ashiftrt (rtx *);
+extern bool sh_dynamicalize_shift_p (rtx);
+extern int shl_and_kind (rtx, rtx, int *);
+extern int shl_and_length (rtx);
+extern int shl_and_scr_length (rtx);
+extern bool gen_shl_and (rtx, rtx, rtx, rtx);
+extern int shl_sext_kind (rtx, rtx, int *);
+extern int shl_sext_length (rtx);
+extern bool gen_shl_sext (rtx, rtx, rtx, rtx);
+extern rtx gen_datalabel_ref (rtx);
+extern int regs_used (rtx, int);
+extern void fixup_addr_diff_vecs (rtx);
+extern int get_dest_uid (rtx, int);
+extern void final_prescan_insn (rtx, rtx *, int);
+extern enum tls_model tls_symbolic_operand (rtx, enum machine_mode);
+extern bool system_reg_operand (rtx, enum machine_mode);
+extern bool reg_unused_after (rtx, rtx);
+extern void expand_sf_unop (rtx (*)(rtx, rtx, rtx), rtx *);
+extern void expand_sf_binop (rtx (*)(rtx, rtx, rtx, rtx), rtx *);
+extern void expand_df_unop (rtx (*)(rtx, rtx, rtx), rtx *);
+extern void expand_df_binop (rtx (*)(rtx, rtx, rtx, rtx), rtx *);
+extern void expand_sfunc_unop (enum machine_mode, rtx (*) (rtx, rtx),
+          const char *, enum rtx_code code, rtx *);
+extern void expand_sfunc_binop (enum machine_mode, rtx (*) (rtx, rtx),
+    const char *, enum rtx_code code, rtx *);
+extern int sh_insn_length_adjustment (rtx, const int);
+extern int sh_insn_length_alignment (rtx);
+extern bool sh_can_redirect_branch (rtx, rtx);
+extern void sh_expand_unop_v2sf (enum rtx_code, rtx, rtx);
+extern void sh_expand_binop_v2sf (enum rtx_code, rtx, rtx, rtx);
+extern bool sh_expand_t_scc (rtx *);
+extern void sh_expand_lround (rtx, rtx, bool);
+extern rtx sh_gen_truncate (enum machine_mode, rtx, int);
+extern bool sh_vector_mode_supported_p (enum machine_mode);
+extern bool stack_protector_block (rtx, rtx);
+extern bool sh_cfun_trap_exit_p (void);
+extern rtx sh_find_equiv_gbr_addr (rtx cur_insn, rtx mem);
+extern int sh_eval_treg_value (rtx op);
+extern long long sh_disp_addr_displacement (rtx mem_op);
+extern int sh_max_mov_insn_displacement (machine_mode mode, bool consider_sh2a);
+struct set_of_reg
+{
+  rtx insn;
+  const_rtx set_rtx;
+  rtx set_src;
+};
+extern set_of_reg sh_find_set_of_reg (rtx reg, rtx insn, rtx(*stepfunc)(rtx));
+extern bool sh_is_logical_t_store_expr (rtx op, rtx insn);
+extern rtx sh_try_omit_signzero_extend (rtx extended_op, rtx insn);
+extern void sh_cpu_cpp_builtins (cpp_reader* pfile);
+extern const char *output_jump_label_table (void);
+extern rtx get_t_reg_rtx (void);
+extern rtx get_fpscr_rtx (void);
+extern int sh_media_register_for_return (void);
+extern void sh_expand_prologue (void);
+extern void sh_expand_epilogue (bool);
+extern void sh_set_return_address (rtx, rtx);
+extern int initial_elimination_offset (int, int);
+extern bool fldi_ok (void);
+extern bool sh_hard_regno_rename_ok (unsigned int, unsigned int);
+extern bool sh_cfun_interrupt_handler_p (void);
+extern bool sh_cfun_resbank_handler_p (void);
+extern bool sh_attr_renesas_p (const_tree);
+extern bool sh_cfun_attr_renesas_p (void);
+extern bool sh_cannot_change_mode_class
+       (enum machine_mode, enum machine_mode, enum reg_class);
+extern bool sh_small_register_classes_for_mode_p (enum machine_mode);
+extern void sh_mark_label (rtx, int);
+extern bool check_use_sfunc_addr (rtx, rtx);
+extern void fpscr_set_from_mem (int, HARD_REG_SET);
+extern void emit_fpu_flip (void);
+extern void sh_pr_interrupt (struct cpp_reader *);
+extern void sh_pr_trapa (struct cpp_reader *);
+extern void sh_pr_nosave_low_regs (struct cpp_reader *);
+extern rtx function_symbol (rtx, const char *, enum sh_function_kind);
+extern rtx sh_get_pr_initial_val (void);
+extern void sh_init_cumulative_args (struct sh_args *, tree, rtx, tree,
+         signed int, enum machine_mode);
+extern rtx sh_dwarf_register_span (rtx);
+extern rtx replace_n_hard_rtx (rtx, rtx *, int , int);
+extern int shmedia_cleanup_truncate (rtx *, void *);
+extern bool sh_contains_memref_p (rtx);
+extern bool sh_loads_bankedreg_p (rtx);
+extern rtx shmedia_prepare_call_address (rtx fnaddr, int is_sibcall);
+extern int sh2a_get_function_vector_number (rtx);
+extern bool sh2a_is_function_vector_call (rtx);
+extern void sh_fix_range (const char *);
+extern bool sh_hard_regno_mode_ok (unsigned int, enum machine_mode);
+extern bool sh_can_use_simple_return_p (void);
+extern int sh_asm_count (const char *, int *);
+extern int sh_align_function_log (tree);
+extern bool sh_can_use_simple_return_p (void);
+extern bool short_cbranch_p (rtx insn);
+extern bool med_cbranch_p (rtx insn);
+extern bool braf_cbranch_p (rtx insn);
+extern bool med_branch_p (rtx insn);
+extern bool braf_branch_p (rtx insn);
+extern int general_operand (rtx, enum machine_mode);
+extern int address_operand (rtx, enum machine_mode);
+extern int register_operand (rtx, enum machine_mode);
+extern int pmode_register_operand (rtx, enum machine_mode);
+extern int scratch_operand (rtx, enum machine_mode);
+extern int immediate_operand (rtx, enum machine_mode);
+extern int const_int_operand (rtx, enum machine_mode);
+extern int const_double_operand (rtx, enum machine_mode);
+extern int nonimmediate_operand (rtx, enum machine_mode);
+extern int nonmemory_operand (rtx, enum machine_mode);
+extern int push_operand (rtx, enum machine_mode);
+extern int pop_operand (rtx, enum machine_mode);
+extern int memory_operand (rtx, enum machine_mode);
+extern int indirect_operand (rtx, enum machine_mode);
+extern int ordered_comparison_operator (rtx, enum machine_mode);
+extern int comparison_operator (rtx, enum machine_mode);
+extern int trapping_target_operand (rtx, enum machine_mode);
+extern int and_operand (rtx, enum machine_mode);
+extern int any_arith_reg_dest (rtx, enum machine_mode);
+extern int any_register_operand (rtx, enum machine_mode);
+extern int arith_operand (rtx, enum machine_mode);
+extern int arith_reg_dest (rtx, enum machine_mode);
+extern int arith_reg_operand (rtx, enum machine_mode);
+extern int arith_reg_or_0_operand (rtx, enum machine_mode);
+extern int binary_float_operator (rtx, enum machine_mode);
+extern int binary_logical_operator (rtx, enum machine_mode);
+extern int cache_address_operand (rtx, enum machine_mode);
+extern int cmp_operand (rtx, enum machine_mode);
+extern int cmpsi_operand (rtx, enum machine_mode);
+extern int equality_comparison_operator (rtx, enum machine_mode);
+extern int extend_reg_operand (rtx, enum machine_mode);
+extern int extend_reg_or_0_operand (rtx, enum machine_mode);
+extern int ext_dest_operand (rtx, enum machine_mode);
+extern int fp_arith_reg_dest (rtx, enum machine_mode);
+extern int fp_arith_reg_operand (rtx, enum machine_mode);
+extern int fpscr_operand (rtx, enum machine_mode);
+extern int fpul_operand (rtx, enum machine_mode);
+extern int fpul_fsca_operand (rtx, enum machine_mode);
+extern int fsca_scale_factor (rtx, enum machine_mode);
+extern int general_extend_operand (rtx, enum machine_mode);
+extern int simple_mem_operand (rtx, enum machine_mode);
+extern int displacement_mem_operand (rtx, enum machine_mode);
+extern int short_displacement_mem_operand (rtx, enum machine_mode);
+extern int zero_extend_movu_operand (rtx, enum machine_mode);
+extern int zero_extend_operand (rtx, enum machine_mode);
+extern int general_movsrc_operand (rtx, enum machine_mode);
+extern int movsrc_no_disp_mem_operand (rtx, enum machine_mode);
+extern int general_movdst_operand (rtx, enum machine_mode);
+extern int sh_no_delay_pop_operand (rtx, enum machine_mode);
+extern int unaligned_load_operand (rtx, enum machine_mode);
+extern int mem_index_disp_operand (rtx, enum machine_mode);
+extern int greater_comparison_operator (rtx, enum machine_mode);
+extern int inqhi_operand (rtx, enum machine_mode);
+extern int less_comparison_operator (rtx, enum machine_mode);
+extern int logical_operand (rtx, enum machine_mode);
+extern int logical_and_operand (rtx, enum machine_mode);
+extern int logical_operator (rtx, enum machine_mode);
+extern int logical_reg_operand (rtx, enum machine_mode);
+extern int mextr_bit_offset (rtx, enum machine_mode);
+extern int minuend_operand (rtx, enum machine_mode);
+extern int sh_float_comparison_operator (rtx, enum machine_mode);
+extern int shmedia_cbranch_comparison_operator (rtx, enum machine_mode);
+extern int sh_const_vec (rtx, enum machine_mode);
+extern int sh_1el_vec (rtx, enum machine_mode);
+extern int sh_register_operand (rtx, enum machine_mode);
+extern int sh_rep_vec (rtx, enum machine_mode);
+extern int shift_count_operand (rtx, enum machine_mode);
+extern int shift_count_reg_operand (rtx, enum machine_mode);
+extern int p27_shift_count_operand (rtx, enum machine_mode);
+extern int not_p27_shift_count_operand (rtx, enum machine_mode);
+extern int p27_rshift_count_operand (rtx, enum machine_mode);
+extern int not_p27_rshift_count_operand (rtx, enum machine_mode);
+extern int shift_operator (rtx, enum machine_mode);
+extern int symbol_ref_operand (rtx, enum machine_mode);
+extern int soft_fp_comparison_operand (rtx, enum machine_mode);
+extern int soft_fp_comparison_operator (rtx, enum machine_mode);
+extern int target_operand (rtx, enum machine_mode);
+extern int target_reg_operand (rtx, enum machine_mode);
+extern int trunc_hi_operand (rtx, enum machine_mode);
+extern int ua_address_operand (rtx, enum machine_mode);
+extern int ua_offset (rtx, enum machine_mode);
+extern int unary_float_operator (rtx, enum machine_mode);
+extern int xor_operand (rtx, enum machine_mode);
+extern int bitwise_memory_operand (rtx, enum machine_mode);
+extern int atomic_arith_operand (rtx, enum machine_mode);
+extern int atomic_logical_operand (rtx, enum machine_mode);
+extern int t_reg_operand (rtx, enum machine_mode);
+extern int negt_reg_operand (rtx, enum machine_mode);
+extern int cbranch_treg_value (rtx, enum machine_mode);
+extern int arith_reg_or_t_reg_operand (rtx, enum machine_mode);
+extern int negt_reg_shl31_operand (rtx, enum machine_mode);
+extern int gbr_displacement (rtx, enum machine_mode);
+extern int gbr_address_mem (rtx, enum machine_mode);
+enum constraint_num
+{
+  CONSTRAINT__UNKNOWN = 0,
+  CONSTRAINT_a,
+  CONSTRAINT_b,
+  CONSTRAINT_c,
+  CONSTRAINT_d,
+  CONSTRAINT_e,
+  CONSTRAINT_f,
+  CONSTRAINT_k,
+  CONSTRAINT_l,
+  CONSTRAINT_t,
+  CONSTRAINT_u,
+  CONSTRAINT_w,
+  CONSTRAINT_x,
+  CONSTRAINT_y,
+  CONSTRAINT_z,
+  CONSTRAINT_R03,
+  CONSTRAINT_I06,
+  CONSTRAINT_I08,
+  CONSTRAINT_I10,
+  CONSTRAINT_I16,
+  CONSTRAINT_I20,
+  CONSTRAINT_I28,
+  CONSTRAINT_J16,
+  CONSTRAINT_Jmb,
+  CONSTRAINT_Jmw,
+  CONSTRAINT_Jhb,
+  CONSTRAINT_K03,
+  CONSTRAINT_K04,
+  CONSTRAINT_K05,
+  CONSTRAINT_K08,
+  CONSTRAINT_K12,
+  CONSTRAINT_K13,
+  CONSTRAINT_K16,
+  CONSTRAINT_P27,
+  CONSTRAINT_M,
+  CONSTRAINT_N,
+  CONSTRAINT_G,
+  CONSTRAINT_H,
+  CONSTRAINT_Q,
+  CONSTRAINT_Bsc,
+  CONSTRAINT_Css,
+  CONSTRAINT_Csu,
+  CONSTRAINT_Csy,
+  CONSTRAINT_Z,
+  CONSTRAINT_W,
+  CONSTRAINT_Cpg,
+  CONSTRAINT_Pso,
+  CONSTRAINT_Psz,
+  CONSTRAINT_Sua,
+  CONSTRAINT_Sdd,
+  CONSTRAINT_Snd,
+  CONSTRAINT_Sbv,
+  CONSTRAINT_Sbw,
+  CONSTRAINT_Sra,
+  CONSTRAINT__LIMIT
+};
+extern enum constraint_num lookup_constraint (const char *);
+extern bool constraint_satisfied_p (rtx, enum constraint_num);
+static inline size_t
+insn_constraint_len (char fc, const char *str __attribute__ ((__unused__)))
+{
+  switch (fc)
+    {
+    case 'B': return 3;
+    case 'C': return 3;
+    case 'I': return 3;
+    case 'J': return 3;
+    case 'K': return 3;
+    case 'P': return 3;
+    case 'R': return 3;
+    case 'S': return 3;
+    default: break;
+    }
+  return 1;
+}
+extern enum reg_class regclass_for_constraint (enum constraint_num);
+extern bool insn_const_int_ok_for_constraint (long long, enum constraint_num);
+extern bool insn_extra_memory_constraint (enum constraint_num);
+extern void set_mem_alias_set (rtx, alias_set_type);
+extern void set_mem_align (rtx, unsigned int);
+extern void set_mem_addr_space (rtx, addr_space_t);
+extern void set_mem_expr (rtx, tree);
+extern void set_mem_offset (rtx, long long);
+extern void clear_mem_offset (rtx);
+extern void set_mem_size (rtx, long long);
+extern void clear_mem_size (rtx);
+extern void set_mem_attrs_for_spill (rtx);
+extern tree get_spill_slot_decl (bool);
+extern rtx replace_equiv_address (rtx, rtx);
+extern rtx replace_equiv_address_nv (rtx, rtx);
+extern rtx gen_blockage (void);
+extern rtvec gen_rtvec (int, ...);
+extern rtx copy_insn_1 (rtx);
+extern rtx copy_insn (rtx);
+extern rtx copy_delay_slot_insn (rtx);
+extern rtx gen_int_mode (long long, enum machine_mode);
+extern rtx emit_copy_of_insn_after (rtx, rtx);
+extern void set_reg_attrs_from_value (rtx, rtx);
+extern void set_reg_attrs_for_parm (rtx, rtx);
+extern void set_reg_attrs_for_decl_rtl (tree t, rtx x);
+extern void adjust_reg_mode (rtx, enum machine_mode);
+extern int mem_expr_equal_p (const_tree, const_tree);
+extern bool need_atomic_barrier_p (enum memmodel, bool);
+static inline rtx
+get_insns (void)
+{
+  return (&x_rtl)->emit.x_first_insn;
+}
+static inline void
+set_first_insn (rtx insn)
+{
+  ((void)(0 && (!insn || !(((insn)->u.fld[1]).rt_rtx))));
+  (&x_rtl)->emit.x_first_insn = insn;
+}
+static inline rtx
+get_last_insn (void)
+{
+  return (&x_rtl)->emit.x_last_insn;
+}
+static inline void
+set_last_insn (rtx insn)
+{
+  ((void)(0 && (!insn || !(((insn)->u.fld[2]).rt_rtx))));
+  (&x_rtl)->emit.x_last_insn = insn;
+}
+static inline int
+get_max_uid (void)
+{
+  return (&x_rtl)->emit.x_cur_insn_uid;
+}
+static bool df_in_progress = false;
+static bool can_alter_cfg = false;
+static vec<rtx> worklist;
+static sbitmap marked;
+static bitmap_obstack dce_blocks_bitmap_obstack;
+static bitmap_obstack dce_tmp_bitmap_obstack;
+static bool find_call_stack_args (rtx, bool, bool, bitmap);
+static bool
+deletable_insn_p_1 (rtx body)
+{
+  switch (((enum rtx_code) (body)->code))
+    {
+    case PREFETCH:
+    case TRAP_IF:
+    case UNSPEC:
+      return false;
+    default:
+      return !volatile_refs_p (body);
+    }
+}
+static bool
+deletable_insn_p (rtx insn, bool fast, bitmap arg_stores)
+{
+  rtx body, x;
+  int i;
+  if ((((enum rtx_code) (insn)->code) == CALL_INSN)
+      && (!df_in_progress)
+      && (!(((insn))->jump))
+      && (((((insn))->unchanging) || (((insn))->return_val))
+   && !(((insn))->call)))
+    return find_call_stack_args (insn, false, fast, arg_stores);
+  if (!(((enum rtx_code) (insn)->code) == INSN))
+    return false;
+  if (!((cfun + 0)->can_delete_dead_exceptions && can_alter_cfg)
+      && !insn_nothrow_p (insn))
+    return false;
+  for (df_ref *def_rec = ((((df->insns[((((insn)->u.fld[0]).rt_int))]))->defs)); *def_rec; def_rec++)
+    if (((((*def_rec)->base.regno)) < 154)
+ && global_regs[((*def_rec)->base.regno)])
+      return false;
+  body = (((insn)->u.fld[4]).rt_rtx);
+  switch (((enum rtx_code) (body)->code))
+    {
+    case USE:
+    case VAR_LOCATION:
+      return false;
+    case CLOBBER:
+      if (fast)
+ {
+   x = (((body)->u.fld[0]).rt_rtx);
+   return (((enum rtx_code) (x)->code) == REG) && (!((((rhs_regno(x))) < 154)) || reload_completed);
+ }
+      else
+ return false;
+    case PARALLEL:
+      for (i = (((((body)->u.fld[0]).rt_rtvec))->num_elem) - 1; i >= 0; i--)
+ if (!deletable_insn_p_1 ((((((body)->u.fld[0]).rt_rtvec))->elem[i])))
+   return false;
+      return true;
+    default:
+      return deletable_insn_p_1 (body);
+    }
+}
+static inline int
+marked_insn_p (rtx insn)
+{
+  ((void)(!(insn) ? fancy_abort ("../../gcc/dce.c", 170, __FUNCTION__), 0 : 0));
+  return bitmap_bit_p (marked, (((insn)->u.fld[0]).rt_int));
+}
+static void
+mark_insn (rtx insn, bool fast)
+{
+  if (!marked_insn_p (insn))
+    {
+      if (!fast)
+ worklist.safe_push (insn);
+      bitmap_set_bit (marked, (((insn)->u.fld[0]).rt_int));
+      if (dump_file)
+ fprintf (dump_file, "  Adding insn %d to worklist\n", (((insn)->u.fld[0]).rt_int));
+      if ((((enum rtx_code) (insn)->code) == CALL_INSN)
+   && !df_in_progress
+   && !(((insn))->jump)
+   && (((((insn))->unchanging) || (((insn))->return_val))
+       && !(((insn))->call)))
+ find_call_stack_args (insn, true, fast, __null);
+    }
+}
+static void
+mark_nonreg_stores_1 (rtx dest, const_rtx pattern, void *data)
+{
+  if (((enum rtx_code) (pattern)->code) != CLOBBER && !(((enum rtx_code) (dest)->code) == REG))
+    mark_insn ((rtx) data, true);
+}
+
+static void
+mark_nonreg_stores_2 (rtx dest, const_rtx pattern, void *data)
+{
+  if (((enum rtx_code) (pattern)->code) != CLOBBER && !(((enum rtx_code) (dest)->code) == REG))
+    mark_insn ((rtx) data, false);
+}
+static void
+mark_nonreg_stores (rtx body, rtx insn, bool fast)
+{
+  if (fast)
+    note_stores (body, mark_nonreg_stores_1, insn);
+  else
+    note_stores (body, mark_nonreg_stores_2, insn);
+}
+static bool
+check_argument_store (rtx mem, long long off, long long min_sp_off,
+        long long max_sp_off, bitmap sp_bytes)
+{
+  long long byte;
+  for (byte = off; byte < off + ((unsigned short) mode_size[((enum machine_mode) (mem)->mode)]); byte++)
+    {
+      if (byte < min_sp_off
+   || byte >= max_sp_off
+   || !bitmap_clear_bit (sp_bytes, byte - min_sp_off))
+ return false;
+    }
+  return true;
+}
+
+ bool
+find_call_stack_args (rtx call_insn, bool do_mark, bool fast,
+        bitmap arg_stores)
+{
+  rtx p, insn, prev_insn;
+  bool ret;
+  long long min_sp_off, max_sp_off;
+  bitmap sp_bytes;
+  ((void)(!((((enum rtx_code) (call_insn)->code) == CALL_INSN)) ? fancy_abort ("../../gcc/dce.c", 268, __FUNCTION__), 0 : 0));
+  if (!global_options.x_TARGET_ACCUMULATE_OUTGOING_ARGS)
+    return true;
+  if (!do_mark)
+    {
+      ((void)(!(arg_stores) ? fancy_abort ("../../gcc/dce.c", 274, __FUNCTION__), 0 : 0));
+      bitmap_clear (arg_stores);
+    }
+  min_sp_off = ((long long) (~ (long long) 0 - ((long long) ((! ((long long) 0 < (long long) -1)) ? ~ (long long) 0 << (sizeof(long long) * 8 - 1) : (long long) 0))));
+  max_sp_off = 0;
+  for (p = (((call_insn)->u.fld[8]).rt_rtx); p; p = (((p)->u.fld[1]).rt_rtx))
+    if (((enum rtx_code) ((((p)->u.fld[0]).rt_rtx))->code) == USE
+ && (((enum rtx_code) (((((((p)->u.fld[0]).rt_rtx))->u.fld[0]).rt_rtx))->code) == MEM))
+      {
+ rtx mem = ((((((p)->u.fld[0]).rt_rtx))->u.fld[0]).rt_rtx), addr;
+ long long off = 0, size;
+ if (!(get_mem_attrs (mem)->size_known_p))
+   return false;
+ size = (get_mem_attrs (mem)->size);
+ addr = (((mem)->u.fld[0]).rt_rtx);
+ if (((enum rtx_code) (addr)->code) == PLUS
+     && (((enum rtx_code) ((((addr)->u.fld[0]).rt_rtx))->code) == REG)
+     && (((enum rtx_code) ((((addr)->u.fld[1]).rt_rtx))->code) == CONST_INT))
+   {
+     off = (((((addr)->u.fld[1]).rt_rtx))->u.hwint[0]);
+     addr = (((addr)->u.fld[0]).rt_rtx);
+   }
+ if (addr != (((&default_target_rtl)->x_global_rtl)[GR_STACK_POINTER]))
+   {
+     if (!(((enum rtx_code) (addr)->code) == REG))
+       return false;
+     if (!fast)
+       {
+  df_ref *use_rec;
+  struct df_link *defs;
+  rtx set;
+  for (use_rec = ((((df->insns[((((call_insn)->u.fld[0]).rt_int))]))->uses)); *use_rec; use_rec++)
+    if (rtx_equal_p (addr, ((*use_rec)->base.reg)))
+      break;
+  if (*use_rec == __null)
+    return false;
+  for (defs = ((*use_rec)->base.chain); defs; defs = defs->next)
+    if (! (((defs->ref)->base.cl) == DF_REF_ARTIFICIAL))
+      break;
+  if (defs == __null)
+    return false;
+  set = (((((enum rtx_code) (((defs->ref)->base.insn_info->insn))->code) == INSN) || (((enum rtx_code) (((defs->ref)->base.insn_info->insn))->code) == DEBUG_INSN) || (((enum rtx_code) (((defs->ref)->base.insn_info->insn))->code) == JUMP_INSN) || (((enum rtx_code) (((defs->ref)->base.insn_info->insn))->code) == CALL_INSN)) ? (((enum rtx_code) ((((((defs->ref)->base.insn_info->insn))->u.fld[4]).rt_rtx))->code) == SET ? (((((defs->ref)->base.insn_info->insn))->u.fld[4]).rt_rtx) : single_set_2 (((defs->ref)->base.insn_info->insn), (((((defs->ref)->base.insn_info->insn))->u.fld[4]).rt_rtx))) : (rtx) 0);
+  if (!set)
+    return false;
+  if (((enum rtx_code) ((((set)->u.fld[1]).rt_rtx))->code) != PLUS
+      || ((((((set)->u.fld[1]).rt_rtx))->u.fld[0]).rt_rtx) != (((&default_target_rtl)->x_global_rtl)[GR_STACK_POINTER])
+      || !(((enum rtx_code) (((((((set)->u.fld[1]).rt_rtx))->u.fld[1]).rt_rtx))->code) == CONST_INT))
+    return false;
+  off += ((((((((set)->u.fld[1]).rt_rtx))->u.fld[1]).rt_rtx))->u.hwint[0]);
+       }
+     else
+       return false;
+   }
+ min_sp_off = ((min_sp_off) < (off) ? (min_sp_off) : (off));
+ max_sp_off = ((max_sp_off) > (off + size) ? (max_sp_off) : (off + size));
+      }
+  if (min_sp_off >= max_sp_off)
+    return true;
+  sp_bytes = bitmap_obstack_alloc_stat (__null );
+  for (p = (((call_insn)->u.fld[8]).rt_rtx); p; p = (((p)->u.fld[1]).rt_rtx))
+    if (((enum rtx_code) ((((p)->u.fld[0]).rt_rtx))->code) == USE
+ && (((enum rtx_code) (((((((p)->u.fld[0]).rt_rtx))->u.fld[0]).rt_rtx))->code) == MEM))
+      {
+ rtx mem = ((((((p)->u.fld[0]).rt_rtx))->u.fld[0]).rt_rtx), addr;
+ long long off = 0, byte;
+ addr = (((mem)->u.fld[0]).rt_rtx);
+ if (((enum rtx_code) (addr)->code) == PLUS
+     && (((enum rtx_code) ((((addr)->u.fld[0]).rt_rtx))->code) == REG)
+     && (((enum rtx_code) ((((addr)->u.fld[1]).rt_rtx))->code) == CONST_INT))
+   {
+     off = (((((addr)->u.fld[1]).rt_rtx))->u.hwint[0]);
+     addr = (((addr)->u.fld[0]).rt_rtx);
+   }
+ if (addr != (((&default_target_rtl)->x_global_rtl)[GR_STACK_POINTER]))
+   {
+     df_ref *use_rec;
+     struct df_link *defs;
+     rtx set;
+     for (use_rec = ((((df->insns[((((call_insn)->u.fld[0]).rt_int))]))->uses)); *use_rec; use_rec++)
+       if (rtx_equal_p (addr, ((*use_rec)->base.reg)))
+  break;
+     for (defs = ((*use_rec)->base.chain); defs; defs = defs->next)
+       if (! (((defs->ref)->base.cl) == DF_REF_ARTIFICIAL))
+  break;
+     set = (((((enum rtx_code) (((defs->ref)->base.insn_info->insn))->code) == INSN) || (((enum rtx_code) (((defs->ref)->base.insn_info->insn))->code) == DEBUG_INSN) || (((enum rtx_code) (((defs->ref)->base.insn_info->insn))->code) == JUMP_INSN) || (((enum rtx_code) (((defs->ref)->base.insn_info->insn))->code) == CALL_INSN)) ? (((enum rtx_code) ((((((defs->ref)->base.insn_info->insn))->u.fld[4]).rt_rtx))->code) == SET ? (((((defs->ref)->base.insn_info->insn))->u.fld[4]).rt_rtx) : single_set_2 (((defs->ref)->base.insn_info->insn), (((((defs->ref)->base.insn_info->insn))->u.fld[4]).rt_rtx))) : (rtx) 0);
+     off += ((((((((set)->u.fld[1]).rt_rtx))->u.fld[1]).rt_rtx))->u.hwint[0]);
+   }
+ for (byte = off; byte < off + (get_mem_attrs (mem)->size); byte++)
+   {
+     if (!bitmap_set_bit (sp_bytes, byte - min_sp_off))
+       (fancy_abort ("../../gcc/dce.c", 385, __FUNCTION__));
+   }
+      }
+  ret = false;
+  for (insn = (((call_insn)->u.fld[1]).rt_rtx); insn; insn = prev_insn)
+    {
+      rtx set, mem, addr;
+      long long off;
+      if (insn == ((((call_insn)->u.fld[3]).rt_bb))->il.x.head_)
+ prev_insn = (rtx) 0;
+      else
+ prev_insn = (((insn)->u.fld[1]).rt_rtx);
+      if ((((enum rtx_code) (insn)->code) == CALL_INSN))
+ break;
+      if (!(((((enum rtx_code) (insn)->code) == INSN) || (((enum rtx_code) (insn)->code) == DEBUG_INSN) || (((enum rtx_code) (insn)->code) == JUMP_INSN) || (((enum rtx_code) (insn)->code) == CALL_INSN)) && !(((enum rtx_code) (insn)->code) == DEBUG_INSN)))
+ continue;
+      set = (((((enum rtx_code) (insn)->code) == INSN) || (((enum rtx_code) (insn)->code) == DEBUG_INSN) || (((enum rtx_code) (insn)->code) == JUMP_INSN) || (((enum rtx_code) (insn)->code) == CALL_INSN)) ? (((enum rtx_code) ((((insn)->u.fld[4]).rt_rtx))->code) == SET ? (((insn)->u.fld[4]).rt_rtx) : single_set_2 (insn, (((insn)->u.fld[4]).rt_rtx))) : (rtx) 0);
+      if (!set || (((set)->u.fld[0]).rt_rtx) == (((&default_target_rtl)->x_global_rtl)[GR_STACK_POINTER]))
+ break;
+      if (!(((enum rtx_code) ((((set)->u.fld[0]).rt_rtx))->code) == MEM))
+ continue;
+      mem = (((set)->u.fld[0]).rt_rtx);
+      addr = (((mem)->u.fld[0]).rt_rtx);
+      off = 0;
+      if (((enum rtx_code) (addr)->code) == PLUS
+   && (((enum rtx_code) ((((addr)->u.fld[0]).rt_rtx))->code) == REG)
+   && (((enum rtx_code) ((((addr)->u.fld[1]).rt_rtx))->code) == CONST_INT))
+ {
+   off = (((((addr)->u.fld[1]).rt_rtx))->u.hwint[0]);
+   addr = (((addr)->u.fld[0]).rt_rtx);
+ }
+      if (addr != (((&default_target_rtl)->x_global_rtl)[GR_STACK_POINTER]))
+ {
+   if (!(((enum rtx_code) (addr)->code) == REG))
+     break;
+   if (!fast)
+     {
+       df_ref *use_rec;
+       struct df_link *defs;
+       rtx set;
+       for (use_rec = ((((df->insns[((((insn)->u.fld[0]).rt_int))]))->uses)); *use_rec; use_rec++)
+  if (rtx_equal_p (addr, ((*use_rec)->base.reg)))
+    break;
+       if (*use_rec == __null)
+  break;
+       for (defs = ((*use_rec)->base.chain); defs; defs = defs->next)
+  if (! (((defs->ref)->base.cl) == DF_REF_ARTIFICIAL))
+    break;
+       if (defs == __null)
+  break;
+       set = (((((enum rtx_code) (((defs->ref)->base.insn_info->insn))->code) == INSN) || (((enum rtx_code) (((defs->ref)->base.insn_info->insn))->code) == DEBUG_INSN) || (((enum rtx_code) (((defs->ref)->base.insn_info->insn))->code) == JUMP_INSN) || (((enum rtx_code) (((defs->ref)->base.insn_info->insn))->code) == CALL_INSN)) ? (((enum rtx_code) ((((((defs->ref)->base.insn_info->insn))->u.fld[4]).rt_rtx))->code) == SET ? (((((defs->ref)->base.insn_info->insn))->u.fld[4]).rt_rtx) : single_set_2 (((defs->ref)->base.insn_info->insn), (((((defs->ref)->base.insn_info->insn))->u.fld[4]).rt_rtx))) : (rtx) 0);
+       if (!set)
+  break;
+       if (((enum rtx_code) ((((set)->u.fld[1]).rt_rtx))->code) != PLUS
+    || ((((((set)->u.fld[1]).rt_rtx))->u.fld[0]).rt_rtx) != (((&default_target_rtl)->x_global_rtl)[GR_STACK_POINTER])
+    || !(((enum rtx_code) (((((((set)->u.fld[1]).rt_rtx))->u.fld[1]).rt_rtx))->code) == CONST_INT))
+  break;
+       off += ((((((((set)->u.fld[1]).rt_rtx))->u.fld[1]).rt_rtx))->u.hwint[0]);
+     }
+   else
+     break;
+ }
+      if (((unsigned short) mode_size[((enum machine_mode) (mem)->mode)]) == 0
+   || !check_argument_store (mem, off, min_sp_off,
+        max_sp_off, sp_bytes))
+ break;
+      if (!deletable_insn_p (insn, fast, __null))
+ break;
+      if (do_mark)
+ mark_insn (insn, fast);
+      else
+ bitmap_set_bit (arg_stores, (((insn)->u.fld[0]).rt_int));
+      if (bitmap_empty_p (sp_bytes))
+ {
+   ret = true;
+   break;
+ }
+    }
+  ((void) (bitmap_obstack_free ((bitmap) sp_bytes), (sp_bytes) = (bitmap) __null));
+  if (!ret && arg_stores)
+    bitmap_clear (arg_stores);
+  return ret;
+}
+
+  basic_block bb;
+
+void
+prescan_insns_for_dce (bool fast)
+{
+
+  rtx insn, prev;
+  bitmap arg_stores = __null;
+
+  if (!df_in_progress && global_options.x_TARGET_ACCUMULATE_OUTGOING_ARGS)
+    arg_stores = bitmap_obstack_alloc_stat (__null );
+
+  for (;bb ; bb = bb->next_bb)
+    {
+     if (deletable_insn_p (insn, fast, arg_stores))
+       mark_nonreg_stores ((((insn)->u.fld[4]).rt_rtx), insn, fast);
+
+
+    }
+
+
+}
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.target/sh/torture/keywords.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.target/sh/torture/keywords.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.target/sh/torture/keywords.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.target/sh/torture/keywords.c	2014-01-24 10:24:17.000000000 +0100
@@ -0,0 +1,4562 @@
+
+typedef unsigned char __u_char;
+typedef unsigned short int __u_short;
+typedef unsigned int __u_int;
+typedef unsigned long int __u_long;
+typedef signed char __int8_t;
+typedef unsigned char __uint8_t;
+typedef signed short int __int16_t;
+typedef unsigned short int __uint16_t;
+typedef signed int __int32_t;
+typedef unsigned int __uint32_t;
+
+__extension__ typedef signed long long int __int64_t;
+__extension__ typedef unsigned long long int __uint64_t;
+__extension__ typedef long long int __quad_t;
+__extension__ typedef unsigned long long int __u_quad_t;
+__extension__ typedef __u_quad_t __dev_t;
+__extension__ typedef unsigned int __uid_t;
+__extension__ typedef unsigned int __gid_t;
+__extension__ typedef unsigned long int __ino_t;
+__extension__ typedef __u_quad_t __ino64_t;
+__extension__ typedef unsigned int __mode_t;
+__extension__ typedef unsigned int __nlink_t;
+__extension__ typedef long int __off_t;
+__extension__ typedef __quad_t __off64_t;
+__extension__ typedef int __pid_t;
+__extension__ typedef struct { int __val[2]; } __fsid_t;
+__extension__ typedef long int __clock_t;
+__extension__ typedef unsigned long int __rlim_t;
+__extension__ typedef __u_quad_t __rlim64_t;
+__extension__ typedef unsigned int __id_t;
+__extension__ typedef long int __time_t;
+__extension__ typedef unsigned int __useconds_t;
+__extension__ typedef long int __suseconds_t;
+__extension__ typedef int __daddr_t;
+__extension__ typedef long int __swblk_t;
+__extension__ typedef int __key_t;
+__extension__ typedef int __clockid_t;
+__extension__ typedef void * __timer_t;
+__extension__ typedef long int __blksize_t;
+__extension__ typedef long int __blkcnt_t;
+__extension__ typedef __quad_t __blkcnt64_t;
+__extension__ typedef unsigned long int __fsblkcnt_t;
+__extension__ typedef __u_quad_t __fsblkcnt64_t;
+__extension__ typedef unsigned long int __fsfilcnt_t;
+__extension__ typedef __u_quad_t __fsfilcnt64_t;
+__extension__ typedef int __ssize_t;
+typedef __off64_t __loff_t;
+typedef __quad_t *__qaddr_t;
+typedef char *__caddr_t;
+__extension__ typedef int __intptr_t;
+__extension__ typedef unsigned int __socklen_t;
+typedef __u_char u_char;
+typedef __u_short u_short;
+typedef __u_int u_int;
+typedef __u_long u_long;
+typedef __quad_t quad_t;
+typedef __u_quad_t u_quad_t;
+typedef __fsid_t fsid_t;
+typedef __loff_t loff_t;
+typedef __ino64_t ino_t;
+typedef __ino64_t ino64_t;
+typedef __dev_t dev_t;
+typedef __gid_t gid_t;
+typedef __mode_t mode_t;
+typedef __nlink_t nlink_t;
+typedef __uid_t uid_t;
+typedef __off64_t off_t;
+typedef __off64_t off64_t;
+typedef __pid_t pid_t;
+typedef __id_t id_t;
+typedef __ssize_t ssize_t;
+typedef __daddr_t daddr_t;
+typedef __caddr_t caddr_t;
+typedef __key_t key_t;
+
+typedef __clock_t clock_t;
+
+
+
+typedef __time_t time_t;
+
+
+typedef __clockid_t clockid_t;
+typedef __timer_t timer_t;
+typedef __useconds_t useconds_t;
+typedef __suseconds_t suseconds_t;
+typedef unsigned int size_t;
+typedef unsigned long int ulong;
+typedef unsigned short int ushort;
+typedef unsigned int uint;
+
+typedef int int8_t __attribute__ ((__mode__ (__QI__)));
+typedef int int16_t __attribute__ ((__mode__ (__HI__)));
+typedef int int32_t __attribute__ ((__mode__ (__SI__)));
+typedef int int64_t __attribute__ ((__mode__ (__DI__)));
+typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
+typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
+typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
+typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));
+
+typedef int __sig_atomic_t;
+typedef struct
+  {
+    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
+  } __sigset_t;
+typedef __sigset_t sigset_t;
+struct timespec
+  {
+    __time_t tv_sec;
+    long int tv_nsec;
+  };
+struct timeval
+  {
+    __time_t tv_sec;
+    __suseconds_t tv_usec;
+  };
+typedef long int __fd_mask;
+typedef struct
+  {
+    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];
+  } fd_set;
+typedef __fd_mask fd_mask;
+
+extern int select (int __nfds, fd_set *__restrict __readfds,
+     fd_set *__restrict __writefds,
+     fd_set *__restrict __exceptfds,
+     struct timeval *__restrict __timeout);
+extern int pselect (int __nfds, fd_set *__restrict __readfds,
+      fd_set *__restrict __writefds,
+      fd_set *__restrict __exceptfds,
+      const struct timespec *__restrict __timeout,
+      const __sigset_t *__restrict __sigmask);
+
+
+typedef __blksize_t blksize_t;
+typedef __blkcnt64_t blkcnt_t;
+typedef __fsblkcnt64_t fsblkcnt_t;
+typedef __fsfilcnt64_t fsfilcnt_t;
+typedef __blkcnt64_t blkcnt64_t;
+typedef __fsblkcnt64_t fsblkcnt64_t;
+typedef __fsfilcnt64_t fsfilcnt64_t;
+typedef unsigned long int pthread_t;
+typedef union
+{
+  char __size[36];
+  long int __align;
+} pthread_attr_t;
+typedef struct __pthread_internal_slist
+{
+  struct __pthread_internal_slist *__next;
+} __pthread_slist_t;
+typedef union
+{
+  struct __pthread_mutex_s
+  {
+    int __lock;
+    unsigned int __count;
+    int __owner;
+    int __kind;
+    unsigned int __nusers;
+    __extension__ union
+    {
+      int __spins;
+      __pthread_slist_t __list;
+    };
+  } __data;
+  char __size[24];
+  long int __align;
+} pthread_mutex_t;
+typedef union
+{
+  char __size[4];
+  long int __align;
+} pthread_mutexattr_t;
+typedef union
+{
+  struct
+  {
+    int __lock;
+    unsigned int __futex;
+    __extension__ unsigned long long int __total_seq;
+    __extension__ unsigned long long int __wakeup_seq;
+    __extension__ unsigned long long int __woken_seq;
+    void *__mutex;
+    unsigned int __nwaiters;
+    unsigned int __broadcast_seq;
+  } __data;
+  char __size[48];
+  __extension__ long long int __align;
+} pthread_cond_t;
+typedef union
+{
+  char __size[4];
+  long int __align;
+} pthread_condattr_t;
+typedef unsigned int pthread_key_t;
+typedef int pthread_once_t;
+typedef union
+{
+  struct
+  {
+    int __lock;
+    unsigned int __nr_readers;
+    unsigned int __readers_wakeup;
+    unsigned int __writer_wakeup;
+    unsigned int __nr_readers_queued;
+    unsigned int __nr_writers_queued;
+    unsigned char __flags;
+    unsigned char __shared;
+    unsigned char __pad1;
+    unsigned char __pad2;
+    pthread_t __writer;
+  } __data;
+  char __size[32];
+  long int __align;
+} pthread_rwlock_t;
+typedef union
+{
+  char __size[8];
+  long int __align;
+} pthread_rwlockattr_t;
+typedef volatile int pthread_spinlock_t;
+typedef union
+{
+  char __size[20];
+  long int __align;
+} pthread_barrier_t;
+typedef union
+{
+  char __size[4];
+  int __align;
+} pthread_barrierattr_t;
+
+typedef __builtin_va_list __gnuc_va_list;
+typedef __gnuc_va_list va_list;
+
+typedef struct __locale_struct
+{
+  struct __locale_data *__locales[13];
+  const unsigned short int *__ctype_b;
+  const int *__ctype_tolower;
+  const int *__ctype_toupper;
+  const char *__names[13];
+} *__locale_t;
+typedef __locale_t locale_t;
+
+enum
+{
+  __LC_CTYPE = 0,
+  __LC_NUMERIC = 1,
+  __LC_TIME = 2,
+  __LC_COLLATE = 3,
+  __LC_MONETARY = 4,
+  __LC_MESSAGES = 5,
+  __LC_ALL = 6,
+  __LC_PAPER = 7,
+  __LC_NAME = 8,
+  __LC_ADDRESS = 9,
+  __LC_TELEPHONE = 10,
+  __LC_MEASUREMENT = 11,
+  __LC_IDENTIFICATION = 12
+};
+
+
+struct lconv
+{
+  char *decimal_point;
+  char *thousands_sep;
+  char *grouping;
+  char *int_curr_symbol;
+  char *currency_symbol;
+  char *mon_decimal_point;
+  char *mon_thousands_sep;
+  char *mon_grouping;
+  char *positive_sign;
+  char *negative_sign;
+  char int_frac_digits;
+  char frac_digits;
+  char p_cs_precedes;
+  char p_sep_by_space;
+  char n_cs_precedes;
+  char n_sep_by_space;
+  char p_sign_posn;
+  char n_sign_posn;
+  char int_p_cs_precedes;
+  char int_p_sep_by_space;
+  char int_n_cs_precedes;
+  char int_n_sep_by_space;
+  char int_p_sign_posn;
+  char int_n_sign_posn;
+};
+
+typedef struct __jmp_buf_internal_tag
+  {
+    int __regs[8];
+    void * __pc;
+    void * __gbr;
+    int __fpscr;
+    int __fpregs[4];
+  } __jmp_buf[1];
+struct __jmp_buf_tag
+  {
+    __jmp_buf __jmpbuf;
+    int __mask_was_saved;
+    __sigset_t __saved_mask;
+  };
+
+typedef struct __jmp_buf_tag jmp_buf[1];
+
+typedef struct __jmp_buf_tag sigjmp_buf[1];
+
+
+typedef long int wchar_t;
+
+union wait
+  {
+    int w_status;
+    struct
+      {
+ unsigned int __w_termsig:7;
+ unsigned int __w_coredump:1;
+ unsigned int __w_retcode:8;
+ unsigned int:16;
+      } __wait_terminated;
+    struct
+      {
+ unsigned int __w_stopval:8;
+ unsigned int __w_stopsig:8;
+ unsigned int:16;
+      } __wait_stopped;
+  };
+
+
+typedef struct
+  {
+    int quot;
+    int rem;
+  } div_t;
+typedef struct
+  {
+    long int quot;
+    long int rem;
+  } ldiv_t;
+
+
+typedef __intptr_t intptr_t;
+typedef __socklen_t socklen_t;
+
+extern char **__environ;
+extern char **environ;
+
+enum
+  {
+    _PC_LINK_MAX,
+    _PC_MAX_CANON,
+    _PC_MAX_INPUT,
+    _PC_NAME_MAX,
+    _PC_PATH_MAX,
+    _PC_PIPE_BUF,
+    _PC_CHOWN_RESTRICTED,
+    _PC_NO_TRUNC,
+    _PC_VDISABLE,
+    _PC_SYNC_IO,
+    _PC_ASYNC_IO,
+    _PC_PRIO_IO,
+    _PC_SOCK_MAXBUF,
+    _PC_FILESIZEBITS,
+    _PC_REC_INCR_XFER_SIZE,
+    _PC_REC_MAX_XFER_SIZE,
+    _PC_REC_MIN_XFER_SIZE,
+    _PC_REC_XFER_ALIGN,
+    _PC_ALLOC_SIZE_MIN,
+    _PC_SYMLINK_MAX,
+    _PC_2_SYMLINKS
+  };
+enum
+  {
+    _SC_ARG_MAX,
+    _SC_CHILD_MAX,
+    _SC_CLK_TCK,
+    _SC_NGROUPS_MAX,
+    _SC_OPEN_MAX,
+    _SC_STREAM_MAX,
+    _SC_TZNAME_MAX,
+    _SC_JOB_CONTROL,
+    _SC_SAVED_IDS,
+    _SC_REALTIME_SIGNALS,
+    _SC_PRIORITY_SCHEDULING,
+    _SC_TIMERS,
+    _SC_ASYNCHRONOUS_IO,
+    _SC_PRIORITIZED_IO,
+    _SC_SYNCHRONIZED_IO,
+    _SC_FSYNC,
+    _SC_MAPPED_FILES,
+    _SC_MEMLOCK,
+    _SC_MEMLOCK_RANGE,
+    _SC_MEMORY_PROTECTION,
+    _SC_MESSAGE_PASSING,
+    _SC_SEMAPHORES,
+    _SC_SHARED_MEMORY_OBJECTS,
+    _SC_AIO_LISTIO_MAX,
+    _SC_AIO_MAX,
+    _SC_AIO_PRIO_DELTA_MAX,
+    _SC_DELAYTIMER_MAX,
+    _SC_MQ_OPEN_MAX,
+    _SC_MQ_PRIO_MAX,
+    _SC_VERSION,
+    _SC_PAGESIZE,
+    _SC_RTSIG_MAX,
+    _SC_SEM_NSEMS_MAX,
+    _SC_SEM_VALUE_MAX,
+    _SC_SIGQUEUE_MAX,
+    _SC_TIMER_MAX,
+    _SC_BC_BASE_MAX,
+    _SC_BC_DIM_MAX,
+    _SC_BC_SCALE_MAX,
+    _SC_BC_STRING_MAX,
+    _SC_COLL_WEIGHTS_MAX,
+    _SC_EQUIV_CLASS_MAX,
+    _SC_EXPR_NEST_MAX,
+    _SC_LINE_MAX,
+    _SC_RE_DUP_MAX,
+    _SC_CHARCLASS_NAME_MAX,
+    _SC_2_VERSION,
+    _SC_2_C_BIND,
+    _SC_2_C_DEV,
+    _SC_2_FORT_DEV,
+    _SC_2_FORT_RUN,
+    _SC_2_SW_DEV,
+    _SC_2_LOCALEDEF,
+    _SC_PII,
+    _SC_PII_XTI,
+    _SC_PII_SOCKET,
+    _SC_PII_INTERNET,
+    _SC_PII_OSI,
+    _SC_POLL,
+    _SC_SELECT,
+    _SC_UIO_MAXIOV,
+    _SC_IOV_MAX = _SC_UIO_MAXIOV,
+    _SC_PII_INTERNET_STREAM,
+    _SC_PII_INTERNET_DGRAM,
+    _SC_PII_OSI_COTS,
+    _SC_PII_OSI_CLTS,
+    _SC_PII_OSI_M,
+    _SC_T_IOV_MAX,
+    _SC_THREADS,
+    _SC_THREAD_SAFE_FUNCTIONS,
+    _SC_GETGR_R_SIZE_MAX,
+    _SC_GETPW_R_SIZE_MAX,
+    _SC_LOGIN_NAME_MAX,
+    _SC_TTY_NAME_MAX,
+    _SC_THREAD_DESTRUCTOR_ITERATIONS,
+    _SC_THREAD_KEYS_MAX,
+    _SC_THREAD_STACK_MIN,
+    _SC_THREAD_THREADS_MAX,
+    _SC_THREAD_ATTR_STACKADDR,
+    _SC_THREAD_ATTR_STACKSIZE,
+    _SC_THREAD_PRIORITY_SCHEDULING,
+    _SC_THREAD_PRIO_INHERIT,
+    _SC_THREAD_PRIO_PROTECT,
+    _SC_THREAD_PROCESS_SHARED,
+    _SC_NPROCESSORS_CONF,
+    _SC_NPROCESSORS_ONLN,
+    _SC_PHYS_PAGES,
+    _SC_AVPHYS_PAGES,
+    _SC_ATEXIT_MAX,
+    _SC_PASS_MAX,
+    _SC_XOPEN_VERSION,
+    _SC_XOPEN_XCU_VERSION,
+    _SC_XOPEN_UNIX,
+    _SC_XOPEN_CRYPT,
+    _SC_XOPEN_ENH_I18N,
+    _SC_XOPEN_SHM,
+    _SC_2_CHAR_TERM,
+    _SC_2_C_VERSION,
+    _SC_2_UPE,
+    _SC_XOPEN_XPG2,
+    _SC_XOPEN_XPG3,
+    _SC_XOPEN_XPG4,
+    _SC_CHAR_BIT,
+    _SC_CHAR_MAX,
+    _SC_CHAR_MIN,
+    _SC_INT_MAX,
+    _SC_INT_MIN,
+    _SC_LONG_BIT,
+    _SC_WORD_BIT,
+    _SC_MB_LEN_MAX,
+    _SC_NZERO,
+    _SC_SSIZE_MAX,
+    _SC_SCHAR_MAX,
+    _SC_SCHAR_MIN,
+    _SC_SHRT_MAX,
+    _SC_SHRT_MIN,
+    _SC_UCHAR_MAX,
+    _SC_UINT_MAX,
+    _SC_ULONG_MAX,
+    _SC_USHRT_MAX,
+    _SC_NL_ARGMAX,
+    _SC_NL_LANGMAX,
+    _SC_NL_MSGMAX,
+    _SC_NL_NMAX,
+    _SC_NL_SETMAX,
+    _SC_NL_TEXTMAX,
+    _SC_XBS5_ILP32_OFF32,
+    _SC_XBS5_ILP32_OFFBIG,
+    _SC_XBS5_LP64_OFF64,
+    _SC_XBS5_LPBIG_OFFBIG,
+    _SC_XOPEN_LEGACY,
+    _SC_XOPEN_REALTIME,
+    _SC_XOPEN_REALTIME_THREADS,
+    _SC_ADVISORY_INFO,
+    _SC_BARRIERS,
+    _SC_BASE,
+    _SC_C_LANG_SUPPORT,
+    _SC_C_LANG_SUPPORT_R,
+    _SC_CLOCK_SELECTION,
+    _SC_CPUTIME,
+    _SC_THREAD_CPUTIME,
+    _SC_DEVICE_IO,
+    _SC_DEVICE_SPECIFIC,
+    _SC_DEVICE_SPECIFIC_R,
+    _SC_FD_MGMT,
+    _SC_FIFO,
+    _SC_PIPE,
+    _SC_FILE_ATTRIBUTES,
+    _SC_FILE_LOCKING,
+    _SC_FILE_SYSTEM,
+    _SC_MONOTONIC_CLOCK,
+    _SC_MULTI_PROCESS,
+    _SC_SINGLE_PROCESS,
+    _SC_NETWORKING,
+    _SC_READER_WRITER_LOCKS,
+    _SC_SPIN_LOCKS,
+    _SC_REGEXP,
+    _SC_REGEX_VERSION,
+    _SC_SHELL,
+    _SC_SIGNALS,
+    _SC_SPAWN,
+    _SC_SPORADIC_SERVER,
+    _SC_THREAD_SPORADIC_SERVER,
+    _SC_SYSTEM_DATABASE,
+    _SC_SYSTEM_DATABASE_R,
+    _SC_TIMEOUTS,
+    _SC_TYPED_MEMORY_OBJECTS,
+    _SC_USER_GROUPS,
+    _SC_USER_GROUPS_R,
+    _SC_2_PBS,
+    _SC_2_PBS_ACCOUNTING,
+    _SC_2_PBS_LOCATE,
+    _SC_2_PBS_MESSAGE,
+    _SC_2_PBS_TRACK,
+    _SC_SYMLOOP_MAX,
+    _SC_STREAMS,
+    _SC_2_PBS_CHECKPOINT,
+    _SC_V6_ILP32_OFF32,
+    _SC_V6_ILP32_OFFBIG,
+    _SC_V6_LP64_OFF64,
+    _SC_V6_LPBIG_OFFBIG,
+    _SC_HOST_NAME_MAX,
+    _SC_TRACE,
+    _SC_TRACE_EVENT_FILTER,
+    _SC_TRACE_INHERIT,
+    _SC_TRACE_LOG,
+    _SC_LEVEL1_ICACHE_SIZE,
+    _SC_LEVEL1_ICACHE_ASSOC,
+    _SC_LEVEL1_ICACHE_LINESIZE,
+    _SC_LEVEL1_DCACHE_SIZE,
+    _SC_LEVEL1_DCACHE_ASSOC,
+    _SC_LEVEL1_DCACHE_LINESIZE,
+    _SC_LEVEL2_CACHE_SIZE,
+    _SC_LEVEL2_CACHE_ASSOC,
+    _SC_LEVEL2_CACHE_LINESIZE,
+    _SC_LEVEL3_CACHE_SIZE,
+    _SC_LEVEL3_CACHE_ASSOC,
+    _SC_LEVEL3_CACHE_LINESIZE,
+    _SC_LEVEL4_CACHE_SIZE,
+    _SC_LEVEL4_CACHE_ASSOC,
+    _SC_LEVEL4_CACHE_LINESIZE,
+    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,
+    _SC_RAW_SOCKETS,
+    _SC_V7_ILP32_OFF32,
+    _SC_V7_ILP32_OFFBIG,
+    _SC_V7_LP64_OFF64,
+    _SC_V7_LPBIG_OFFBIG,
+    _SC_SS_REPL_MAX,
+    _SC_TRACE_EVENT_NAME_MAX,
+    _SC_TRACE_NAME_MAX,
+    _SC_TRACE_SYS_MAX,
+    _SC_TRACE_USER_EVENT_MAX,
+    _SC_XOPEN_STREAMS,
+    _SC_THREAD_ROBUST_PRIO_INHERIT,
+    _SC_THREAD_ROBUST_PRIO_PROTECT
+  };
+enum
+  {
+    _CS_PATH,
+    _CS_V6_WIDTH_RESTRICTED_ENVS,
+    _CS_GNU_LIBC_VERSION,
+    _CS_GNU_LIBPTHREAD_VERSION,
+    _CS_V5_WIDTH_RESTRICTED_ENVS,
+    _CS_V7_WIDTH_RESTRICTED_ENVS,
+    _CS_LFS_CFLAGS = 1000,
+    _CS_LFS_LDFLAGS,
+    _CS_LFS_LIBS,
+    _CS_LFS_LINTFLAGS,
+    _CS_LFS64_CFLAGS,
+    _CS_LFS64_LDFLAGS,
+    _CS_LFS64_LIBS,
+    _CS_LFS64_LINTFLAGS,
+    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
+    _CS_XBS5_ILP32_OFF32_LDFLAGS,
+    _CS_XBS5_ILP32_OFF32_LIBS,
+    _CS_XBS5_ILP32_OFF32_LINTFLAGS,
+    _CS_XBS5_ILP32_OFFBIG_CFLAGS,
+    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,
+    _CS_XBS5_ILP32_OFFBIG_LIBS,
+    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,
+    _CS_XBS5_LP64_OFF64_CFLAGS,
+    _CS_XBS5_LP64_OFF64_LDFLAGS,
+    _CS_XBS5_LP64_OFF64_LIBS,
+    _CS_XBS5_LP64_OFF64_LINTFLAGS,
+    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,
+    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,
+    _CS_XBS5_LPBIG_OFFBIG_LIBS,
+    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,
+    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,
+    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,
+    _CS_POSIX_V6_ILP32_OFF32_LIBS,
+    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,
+    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,
+    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,
+    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,
+    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,
+    _CS_POSIX_V6_LP64_OFF64_CFLAGS,
+    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,
+    _CS_POSIX_V6_LP64_OFF64_LIBS,
+    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,
+    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,
+    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,
+    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,
+    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,
+    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,
+    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,
+    _CS_POSIX_V7_ILP32_OFF32_LIBS,
+    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,
+    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,
+    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,
+    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,
+    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,
+    _CS_POSIX_V7_LP64_OFF64_CFLAGS,
+    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,
+    _CS_POSIX_V7_LP64_OFF64_LIBS,
+    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,
+    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,
+    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,
+    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,
+    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,
+    _CS_V6_ENV,
+    _CS_V7_ENV
+  };
+
+
+
+
+typedef __sig_atomic_t sig_atomic_t;
+
+typedef union sigval
+  {
+    int sival_int;
+    void *sival_ptr;
+  } sigval_t;
+typedef struct siginfo
+  {
+    int si_signo;
+    int si_errno;
+    int si_code;
+    union
+      {
+ int _pad[((128 / sizeof (int)) - 3)];
+ struct
+   {
+     __pid_t si_pid;
+     __uid_t si_uid;
+   } _kill;
+ struct
+   {
+     int si_tid;
+     int si_overrun;
+     sigval_t si_sigval;
+   } _timer;
+ struct
+   {
+     __pid_t si_pid;
+     __uid_t si_uid;
+     sigval_t si_sigval;
+   } _rt;
+ struct
+   {
+     __pid_t si_pid;
+     __uid_t si_uid;
+     int si_status;
+     __clock_t si_utime;
+     __clock_t si_stime;
+   } _sigchld;
+ struct
+   {
+     void *si_addr;
+   } _sigfault;
+ struct
+   {
+     long int si_band;
+     int si_fd;
+   } _sigpoll;
+      } _sifields;
+  } siginfo_t;
+enum
+{
+  SI_ASYNCNL = -60,
+  SI_TKILL = -6,
+  SI_SIGIO,
+  SI_ASYNCIO,
+  SI_MESGQ,
+  SI_TIMER,
+  SI_QUEUE,
+  SI_USER,
+  SI_KERNEL = 0x80
+};
+enum
+{
+  ILL_ILLOPC = 1,
+  ILL_ILLOPN,
+  ILL_ILLADR,
+  ILL_ILLTRP,
+  ILL_PRVOPC,
+  ILL_PRVREG,
+  ILL_COPROC,
+  ILL_BADSTK
+};
+enum
+{
+  FPE_INTDIV = 1,
+  FPE_INTOVF,
+  FPE_FLTDIV,
+  FPE_FLTOVF,
+  FPE_FLTUND,
+  FPE_FLTRES,
+  FPE_FLTINV,
+  FPE_FLTSUB
+};
+enum
+{
+  SEGV_MAPERR = 1,
+  SEGV_ACCERR
+};
+enum
+{
+  BUS_ADRALN = 1,
+  BUS_ADRERR,
+  BUS_OBJERR
+};
+enum
+{
+  TRAP_BRKPT = 1,
+  TRAP_TRACE
+};
+enum
+{
+  CLD_EXITED = 1,
+  CLD_KILLED,
+  CLD_DUMPED,
+  CLD_TRAPPED,
+  CLD_STOPPED,
+  CLD_CONTINUED
+};
+enum
+{
+  POLL_IN = 1,
+  POLL_OUT,
+  POLL_MSG,
+  POLL_ERR,
+  POLL_PRI,
+  POLL_HUP
+};
+typedef struct sigevent
+  {
+    sigval_t sigev_value;
+    int sigev_signo;
+    int sigev_notify;
+    union
+      {
+ int _pad[((64 / sizeof (int)) - 3)];
+ __pid_t _tid;
+ struct
+   {
+     void (*_function) (sigval_t);
+     void *_attribute;
+   } _sigev_thread;
+      } _sigev_un;
+  } sigevent_t;
+enum
+{
+  SIGEV_SIGNAL = 0,
+  SIGEV_NONE,
+  SIGEV_THREAD,
+  SIGEV_THREAD_ID = 4
+};
+typedef void (*__sighandler_t) (int);
+
+struct sigaction
+  {
+    union
+      {
+ __sighandler_t sa_handler;
+ void (*sa_sigaction) (int, siginfo_t *, void *);
+      }
+    __sigaction_handler;
+    __sigset_t sa_mask;
+    int sa_flags;
+    void (*sa_restorer) (void);
+  };
+
+extern __const char *__const _sys_siglist[65];
+extern __const char *__const sys_siglist[65];
+struct sigvec
+  {
+    __sighandler_t sv_handler;
+    int sv_mask;
+    int sv_flags;
+  };
+
+struct sigcontext {
+ unsigned long oldmask;
+ unsigned long sc_regs[16];
+ unsigned long sc_pc;
+ unsigned long sc_pr;
+ unsigned long sc_sr;
+ unsigned long sc_gbr;
+ unsigned long sc_mach;
+ unsigned long sc_macl;
+ unsigned long sc_fpregs[16];
+ unsigned long sc_xfpregs[16];
+ unsigned int sc_fpscr;
+ unsigned int sc_fpul;
+ unsigned int sc_ownedfp;
+};
+
+struct sigstack
+  {
+    void *ss_sp;
+    int ss_onstack;
+  };
+enum
+{
+  SS_ONSTACK = 1,
+  SS_DISABLE
+};
+typedef struct sigaltstack
+  {
+    void *ss_sp;
+    int ss_flags;
+    size_t ss_size;
+  } stack_t;
+typedef int greg_t;
+typedef greg_t gregset_t[16];
+typedef int freg_t;
+typedef freg_t fpregset_t[16];
+typedef struct
+  {
+    unsigned int oldmask;
+    gregset_t gregs;
+    unsigned int pc;
+    unsigned int pr;
+    unsigned int sr;
+    unsigned int gbr;
+    unsigned int mach;
+    unsigned int macl;
+    fpregset_t fpregs;
+    fpregset_t xfpregs;
+    unsigned int fpscr;
+    unsigned int fpul;
+    unsigned int ownedfp;
+  } mcontext_t;
+typedef struct ucontext
+  {
+    unsigned long int uc_flags;
+    struct ucontext *uc_link;
+    stack_t uc_stack;
+    mcontext_t uc_mcontext;
+    __sigset_t uc_sigmask;
+  } ucontext_t;
+
+enum __rlimit_resource
+{
+  RLIMIT_CPU = 0,
+  RLIMIT_FSIZE = 1,
+  RLIMIT_DATA = 2,
+  RLIMIT_STACK = 3,
+  RLIMIT_CORE = 4,
+  __RLIMIT_RSS = 5,
+  RLIMIT_NOFILE = 7,
+  __RLIMIT_OFILE = RLIMIT_NOFILE,
+  RLIMIT_AS = 9,
+  __RLIMIT_NPROC = 6,
+  __RLIMIT_MEMLOCK = 8,
+  __RLIMIT_LOCKS = 10,
+  __RLIMIT_SIGPENDING = 11,
+  __RLIMIT_MSGQUEUE = 12,
+  __RLIMIT_NICE = 13,
+  __RLIMIT_RTPRIO = 14,
+  __RLIMIT_RTTIME = 15,
+  __RLIMIT_NLIMITS = 16,
+  __RLIM_NLIMITS = __RLIMIT_NLIMITS
+};
+typedef __rlim64_t rlim_t;
+typedef __rlim64_t rlim64_t;
+struct rlimit
+  {
+    rlim_t rlim_cur;
+    rlim_t rlim_max;
+  };
+struct rlimit64
+  {
+    rlim64_t rlim_cur;
+    rlim64_t rlim_max;
+ };
+enum __rusage_who
+{
+  RUSAGE_SELF = 0,
+  RUSAGE_CHILDREN = -1
+  ,
+  RUSAGE_THREAD = 1
+};
+struct rusage
+  {
+    struct timeval ru_utime;
+    struct timeval ru_stime;
+    long int ru_maxrss;
+    long int ru_ixrss;
+    long int ru_idrss;
+    long int ru_isrss;
+    long int ru_minflt;
+    long int ru_majflt;
+    long int ru_nswap;
+    long int ru_inblock;
+    long int ru_oublock;
+    long int ru_msgsnd;
+    long int ru_msgrcv;
+    long int ru_nsignals;
+    long int ru_nvcsw;
+    long int ru_nivcsw;
+  };
+enum __priority_which
+{
+  PRIO_PROCESS = 0,
+  PRIO_PGRP = 1,
+  PRIO_USER = 2
+};
+
+
+
+typedef enum __rlimit_resource __rlimit_resource_t;
+typedef enum __rusage_who __rusage_who_t;
+typedef enum __priority_which __priority_which_t;
+
+typedef enum
+{
+  P_ALL,
+  P_PID,
+  P_PGID
+} idtype_t;
+
+typedef unsigned char uint8_t;
+typedef unsigned short int uint16_t;
+typedef unsigned int uint32_t;
+__extension__
+typedef unsigned long long int uint64_t;
+typedef signed char int_least8_t;
+typedef short int int_least16_t;
+typedef int int_least32_t;
+__extension__
+typedef long long int int_least64_t;
+typedef unsigned char uint_least8_t;
+typedef unsigned short int uint_least16_t;
+typedef unsigned int uint_least32_t;
+__extension__
+typedef unsigned long long int uint_least64_t;
+typedef signed char int_fast8_t;
+typedef int int_fast16_t;
+typedef int int_fast32_t;
+__extension__
+typedef long long int int_fast64_t;
+typedef unsigned char uint_fast8_t;
+typedef unsigned int uint_fast16_t;
+typedef unsigned int uint_fast32_t;
+__extension__
+typedef unsigned long long int uint_fast64_t;
+typedef unsigned int uintptr_t;
+__extension__
+typedef long long int intmax_t;
+__extension__
+typedef unsigned long long int uintmax_t;
+
+
+struct iovec
+  {
+    void *iov_base;
+    size_t iov_len;
+  };
+extern ssize_t readv (int __fd, __const struct iovec *__iovec, int __count)
+  ;
+extern ssize_t writev (int __fd, __const struct iovec *__iovec, int __count)
+  ;
+extern ssize_t preadv (int __fd, __const struct iovec *__iovec, int __count, __off64_t __offset) __asm__ ("" "preadv64") ;
+extern ssize_t pwritev (int __fd, __const struct iovec *__iovec, int __count, __off64_t __offset) __asm__ ("" "pwritev64") ;
+extern ssize_t preadv64 (int __fd, __const struct iovec *__iovec, int __count,
+    __off64_t __offset) ;
+extern ssize_t pwritev64 (int __fd, __const struct iovec *__iovec, int __count,
+     __off64_t __offset) ;
+
+enum __socket_type
+{
+  SOCK_STREAM = 1,
+  SOCK_DGRAM = 2,
+  SOCK_RAW = 3,
+  SOCK_RDM = 4,
+  SOCK_SEQPACKET = 5,
+  SOCK_DCCP = 6,
+  SOCK_PACKET = 10,
+  SOCK_CLOEXEC = 02000000,
+  SOCK_NONBLOCK = 04000
+};
+typedef unsigned short int sa_family_t;
+struct sockaddr
+  {
+    sa_family_t sa_family;
+    char sa_data[14];
+  };
+struct sockaddr_storage
+  {
+    sa_family_t ss_family;
+    unsigned long int __ss_align;
+    char __ss_padding[(128 - (2 * sizeof (unsigned long int)))];
+  };
+enum
+  {
+    MSG_OOB = 0x01,
+    MSG_PEEK = 0x02,
+    MSG_DONTROUTE = 0x04,
+    MSG_TRYHARD = MSG_DONTROUTE,
+    MSG_CTRUNC = 0x08,
+    MSG_PROXY = 0x10,
+    MSG_TRUNC = 0x20,
+    MSG_DONTWAIT = 0x40,
+    MSG_EOR = 0x80,
+    MSG_WAITALL = 0x100,
+    MSG_FIN = 0x200,
+    MSG_SYN = 0x400,
+    MSG_CONFIRM = 0x800,
+    MSG_RST = 0x1000,
+    MSG_ERRQUEUE = 0x2000,
+    MSG_NOSIGNAL = 0x4000,
+    MSG_MORE = 0x8000,
+    MSG_WAITFORONE = 0x10000,
+    MSG_CMSG_CLOEXEC = 0x40000000
+  };
+struct msghdr
+  {
+    void *msg_name;
+    socklen_t msg_namelen;
+    struct iovec *msg_iov;
+    size_t msg_iovlen;
+    void *msg_control;
+    size_t msg_controllen;
+    int msg_flags;
+  };
+struct mmsghdr
+  {
+    struct msghdr msg_hdr;
+    unsigned int msg_len;
+  };
+struct cmsghdr
+  {
+    size_t cmsg_len;
+    int cmsg_level;
+    int cmsg_type;
+  };
+
+enum
+  {
+    SCM_RIGHTS = 0x01
+    , SCM_CREDENTIALS = 0x02
+  };
+struct ucred
+{
+  pid_t pid;
+  uid_t uid;
+  gid_t gid;
+};
+struct linger
+  {
+    int l_onoff;
+    int l_linger;
+  };
+
+extern int recvmmsg (int __fd, struct mmsghdr *__vmessages,
+       unsigned int __vlen, int __flags,
+       __const struct timespec *__tmo);
+extern int sendmmsg (int __fd, struct mmsghdr *__vmessages,
+       unsigned int __vlen, int __flags);
+
+struct osockaddr
+  {
+    unsigned short int sa_family;
+    unsigned char sa_data[14];
+  };
+enum
+{
+  SHUT_RD = 0,
+  SHUT_WR,
+  SHUT_RDWR
+};
+
+
+enum
+  {
+    IPPROTO_IP = 0,
+    IPPROTO_HOPOPTS = 0,
+    IPPROTO_ICMP = 1,
+    IPPROTO_IGMP = 2,
+    IPPROTO_IPIP = 4,
+    IPPROTO_TCP = 6,
+    IPPROTO_EGP = 8,
+    IPPROTO_PUP = 12,
+    IPPROTO_UDP = 17,
+    IPPROTO_IDP = 22,
+    IPPROTO_TP = 29,
+    IPPROTO_DCCP = 33,
+    IPPROTO_IPV6 = 41,
+    IPPROTO_ROUTING = 43,
+    IPPROTO_FRAGMENT = 44,
+    IPPROTO_RSVP = 46,
+    IPPROTO_GRE = 47,
+    IPPROTO_ESP = 50,
+    IPPROTO_AH = 51,
+    IPPROTO_ICMPV6 = 58,
+    IPPROTO_NONE = 59,
+    IPPROTO_DSTOPTS = 60,
+    IPPROTO_MTP = 92,
+    IPPROTO_ENCAP = 98,
+    IPPROTO_PIM = 103,
+    IPPROTO_COMP = 108,
+    IPPROTO_SCTP = 132,
+    IPPROTO_UDPLITE = 136,
+    IPPROTO_RAW = 255,
+    IPPROTO_MAX
+  };
+typedef uint16_t in_port_t;
+enum
+  {
+    IPPORT_ECHO = 7,
+    IPPORT_DISCARD = 9,
+    IPPORT_SYSTAT = 11,
+    IPPORT_DAYTIME = 13,
+    IPPORT_NETSTAT = 15,
+    IPPORT_FTP = 21,
+    IPPORT_TELNET = 23,
+    IPPORT_SMTP = 25,
+    IPPORT_TIMESERVER = 37,
+    IPPORT_NAMESERVER = 42,
+    IPPORT_WHOIS = 43,
+    IPPORT_MTP = 57,
+    IPPORT_TFTP = 69,
+    IPPORT_RJE = 77,
+    IPPORT_FINGER = 79,
+    IPPORT_TTYLINK = 87,
+    IPPORT_SUPDUP = 95,
+    IPPORT_EXECSERVER = 512,
+    IPPORT_LOGINSERVER = 513,
+    IPPORT_CMDSERVER = 514,
+    IPPORT_EFSSERVER = 520,
+    IPPORT_BIFFUDP = 512,
+    IPPORT_WHOSERVER = 513,
+    IPPORT_ROUTESERVER = 520,
+    IPPORT_RESERVED = 1024,
+    IPPORT_USERRESERVED = 5000
+  };
+typedef uint32_t in_addr_t;
+struct in_addr
+  {
+    in_addr_t s_addr;
+  };
+struct in6_addr
+  {
+    union
+      {
+ uint8_t __u6_addr8[16];
+ uint16_t __u6_addr16[8];
+ uint32_t __u6_addr32[4];
+      } __in6_u;
+  };
+extern const struct in6_addr in6addr_any;
+extern const struct in6_addr in6addr_loopback;
+struct sockaddr_in
+  {
+    sa_family_t sin_family;
+    in_port_t sin_port;
+    struct in_addr sin_addr;
+    unsigned char sin_zero[sizeof (struct sockaddr) -
+      (sizeof (unsigned short int)) -
+      sizeof (in_port_t) -
+      sizeof (struct in_addr)];
+  };
+struct sockaddr_in6
+  {
+    sa_family_t sin6_family;
+    in_port_t sin6_port;
+    uint32_t sin6_flowinfo;
+    struct in6_addr sin6_addr;
+    uint32_t sin6_scope_id;
+  };
+struct ip_mreq
+  {
+    struct in_addr imr_multiaddr;
+    struct in_addr imr_interface;
+  };
+struct ip_mreq_source
+  {
+    struct in_addr imr_multiaddr;
+    struct in_addr imr_interface;
+    struct in_addr imr_sourceaddr;
+  };
+struct ipv6_mreq
+  {
+    struct in6_addr ipv6mr_multiaddr;
+    unsigned int ipv6mr_interface;
+  };
+struct group_req
+  {
+    uint32_t gr_interface;
+    struct sockaddr_storage gr_group;
+  };
+struct group_source_req
+  {
+    uint32_t gsr_interface;
+    struct sockaddr_storage gsr_group;
+    struct sockaddr_storage gsr_source;
+  };
+struct ip_msfilter
+  {
+    struct in_addr imsf_multiaddr;
+    struct in_addr imsf_interface;
+    uint32_t imsf_fmode;
+    uint32_t imsf_numsrc;
+    struct in_addr imsf_slist[1];
+  };
+struct group_filter
+  {
+    uint32_t gf_interface;
+    struct sockaddr_storage gf_group;
+    uint32_t gf_fmode;
+    uint32_t gf_numsrc;
+    struct sockaddr_storage gf_slist[1];
+};
+struct ip_opts
+  {
+    struct in_addr ip_dst;
+    char ip_opts[40];
+  };
+struct ip_mreqn
+  {
+    struct in_addr imr_multiaddr;
+    struct in_addr imr_address;
+    int imr_ifindex;
+  };
+struct in_pktinfo
+  {
+    int ipi_ifindex;
+    struct in_addr ipi_spec_dst;
+    struct in_addr ipi_addr;
+  };
+
+struct in6_pktinfo
+  {
+    struct in6_addr ipi6_addr;
+    unsigned int ipi6_ifindex;
+  };
+struct ip6_mtuinfo
+  {
+    struct sockaddr_in6 ip6m_addr;
+    uint32_t ip6m_mtu;
+  };
+
+struct stat
+  {
+    __dev_t st_dev;
+    unsigned short int __pad1;
+    __ino_t __st_ino;
+    __mode_t st_mode;
+    __nlink_t st_nlink;
+    __uid_t st_uid;
+    __gid_t st_gid;
+    __dev_t st_rdev;
+    unsigned short int __pad2;
+    __off64_t st_size;
+    __blksize_t st_blksize;
+    __blkcnt64_t st_blocks;
+    struct timespec st_atim;
+    struct timespec st_mtim;
+    struct timespec st_ctim;
+    __ino64_t st_ino;
+  };
+struct stat64
+  {
+    __dev_t st_dev;
+    unsigned int __pad1;
+    __ino_t __st_ino;
+    __mode_t st_mode;
+    __nlink_t st_nlink;
+    __uid_t st_uid;
+    __gid_t st_gid;
+    __dev_t st_rdev;
+    unsigned int __pad2;
+    __off64_t st_size;
+    __blksize_t st_blksize;
+    __blkcnt64_t st_blocks;
+    struct timespec st_atim;
+    struct timespec st_mtim;
+    struct timespec st_ctim;
+    __ino64_t st_ino;
+  };
+
+struct timex
+{
+  unsigned int modes;
+  long int offset;
+  long int freq;
+  long int maxerror;
+  long int esterror;
+  int status;
+  long int constant;
+  long int precision;
+  long int tolerance;
+  struct timeval time;
+  long int tick;
+  long int ppsfreq;
+  long int jitter;
+  int shift;
+  long int stabil;
+  long int jitcnt;
+  long int calcnt;
+  long int errcnt;
+  long int stbcnt;
+  int tai;
+  int :32; int :32; int :32; int :32;
+  int :32; int :32; int :32; int :32;
+  int :32; int :32; int :32;
+};
+
+
+struct tm
+{
+  int tm_sec;
+  int tm_min;
+  int tm_hour;
+  int tm_mday;
+  int tm_mon;
+  int tm_year;
+  int tm_wday;
+  int tm_yday;
+  int tm_isdst;
+  long int tm_gmtoff;
+  __const char *tm_zone;
+};
+
+
+struct itimerspec
+  {
+    struct timespec it_interval;
+    struct timespec it_value;
+  };
+struct sigevent;
+
+struct timezone
+  {
+    int tz_minuteswest;
+    int tz_dsttime;
+  };
+typedef struct timezone *__restrict __timezone_ptr_t;
+enum __itimer_which
+  {
+    ITIMER_REAL = 0,
+    ITIMER_VIRTUAL = 1,
+    ITIMER_PROF = 2
+  };
+struct itimerval
+  {
+    struct timeval it_interval;
+    struct timeval it_value;
+  };
+typedef enum __itimer_which __itimer_which_t;
+
+struct tms
+  {
+    clock_t tms_utime;
+    clock_t tms_stime;
+    clock_t tms_cutime;
+    clock_t tms_cstime;
+  };
+
+typedef int error_t;
+
+struct rpcent
+{
+  char *r_name;
+  char **r_aliases;
+  int r_number;
+};
+
+struct netent
+{
+  char *n_name;
+  char **n_aliases;
+  int n_addrtype;
+  uint32_t n_net;
+};
+
+struct hostent
+{
+  char *h_name;
+  char **h_aliases;
+  int h_addrtype;
+  int h_length;
+  char **h_addr_list;
+};
+
+extern void sethostent (int __stay_open);
+
+extern void endhostent (void);
+extern struct hostent *gethostent (void);
+extern struct hostent *gethostbyaddr (__const void *__addr, __socklen_t __len,
+          int __type);
+extern struct hostent *gethostbyname (__const char *__name);
+extern struct hostent *gethostbyname2 (__const char *__name, int __af);
+extern int gethostent_r (struct hostent *__restrict __result_buf,
+    char *__restrict __buf, size_t __buflen,
+    struct hostent **__restrict __result,
+    int *__restrict __h_errnop);
+extern int gethostbyaddr_r (__const void *__restrict __addr, __socklen_t __len,
+       int __type,
+       struct hostent *__restrict __result_buf,
+       char *__restrict __buf, size_t __buflen,
+       struct hostent **__restrict __result,
+       int *__restrict __h_errnop);
+extern int gethostbyname_r (__const char *__restrict __name,
+       struct hostent *__restrict __result_buf,
+       char *__restrict __buf, size_t __buflen,
+       struct hostent **__restrict __result,
+       int *__restrict __h_errnop);
+extern int gethostbyname2_r (__const char *__restrict __name, int __af,
+        struct hostent *__restrict __result_buf,
+        char *__restrict __buf, size_t __buflen,
+        struct hostent **__restrict __result,
+        int *__restrict __h_errnop);
+extern void setnetent (int __stay_open);
+extern void endnetent (void);
+extern struct netent *getnetent (void);
+extern struct netent *getnetbyaddr (uint32_t __net, int __type);
+extern struct netent *getnetbyname (__const char *__name);
+extern int getnetent_r (struct netent *__restrict __result_buf,
+   char *__restrict __buf, size_t __buflen,
+   struct netent **__restrict __result,
+   int *__restrict __h_errnop);
+extern int getnetbyaddr_r (uint32_t __net, int __type,
+      struct netent *__restrict __result_buf,
+      char *__restrict __buf, size_t __buflen,
+      struct netent **__restrict __result,
+      int *__restrict __h_errnop);
+extern int getnetbyname_r (__const char *__restrict __name,
+      struct netent *__restrict __result_buf,
+      char *__restrict __buf, size_t __buflen,
+      struct netent **__restrict __result,
+      int *__restrict __h_errnop);
+struct servent
+{
+  char *s_name;
+  char **s_aliases;
+  int s_port;
+  char *s_proto;
+};
+extern void setservent (int __stay_open);
+extern void endservent (void);
+extern struct servent *getservent (void);
+extern struct servent *getservbyname (__const char *__name,
+          __const char *__proto);
+extern struct servent *getservbyport (int __port, __const char *__proto);
+extern int getservent_r (struct servent *__restrict __result_buf,
+    char *__restrict __buf, size_t __buflen,
+    struct servent **__restrict __result);
+extern int getservbyname_r (__const char *__restrict __name,
+       __const char *__restrict __proto,
+       struct servent *__restrict __result_buf,
+       char *__restrict __buf, size_t __buflen,
+       struct servent **__restrict __result);
+extern int getservbyport_r (int __port, __const char *__restrict __proto,
+       struct servent *__restrict __result_buf,
+       char *__restrict __buf, size_t __buflen,
+       struct servent **__restrict __result);
+struct protoent
+{
+  char *p_name;
+  char **p_aliases;
+  int p_proto;
+};
+extern void setprotoent (int __stay_open);
+extern void endprotoent (void);
+extern struct protoent *getprotoent (void);
+extern struct protoent *getprotobyname (__const char *__name);
+extern struct protoent *getprotobynumber (int __proto);
+extern int getprotoent_r (struct protoent *__restrict __result_buf,
+     char *__restrict __buf, size_t __buflen,
+     struct protoent **__restrict __result);
+extern int getprotobyname_r (__const char *__restrict __name,
+        struct protoent *__restrict __result_buf,
+        char *__restrict __buf, size_t __buflen,
+        struct protoent **__restrict __result);
+extern int getprotobynumber_r (int __proto,
+          struct protoent *__restrict __result_buf,
+          char *__restrict __buf, size_t __buflen,
+          struct protoent **__restrict __result);
+extern int setnetgrent (__const char *__netgroup);
+extern void endnetgrent (void);
+extern int getnetgrent (char **__restrict __hostp,
+   char **__restrict __userp,
+   char **__restrict __domainp);
+extern int innetgr (__const char *__netgroup, __const char *__host,
+      __const char *__user, __const char *__domain);
+extern int getnetgrent_r (char **__restrict __hostp,
+     char **__restrict __userp,
+     char **__restrict __domainp,
+     char *__restrict __buffer, size_t __buflen);
+extern int rcmd (char **__restrict __ahost, unsigned short int __rport,
+   __const char *__restrict __locuser,
+   __const char *__restrict __remuser,
+   __const char *__restrict __cmd, int *__restrict __fd2p);
+extern int rcmd_af (char **__restrict __ahost, unsigned short int __rport,
+      __const char *__restrict __locuser,
+      __const char *__restrict __remuser,
+      __const char *__restrict __cmd, int *__restrict __fd2p,
+      sa_family_t __af);
+extern int rexec (char **__restrict __ahost, int __rport,
+    __const char *__restrict __name,
+    __const char *__restrict __pass,
+    __const char *__restrict __cmd, int *__restrict __fd2p);
+extern int rexec_af (char **__restrict __ahost, int __rport,
+       __const char *__restrict __name,
+       __const char *__restrict __pass,
+       __const char *__restrict __cmd, int *__restrict __fd2p,
+       sa_family_t __af);
+extern int ruserok (__const char *__rhost, int __suser,
+      __const char *__remuser, __const char *__locuser);
+extern int ruserok_af (__const char *__rhost, int __suser,
+         __const char *__remuser, __const char *__locuser,
+         sa_family_t __af);
+extern int iruserok (uint32_t __raddr, int __suser,
+       __const char *__remuser, __const char *__locuser);
+extern int iruserok_af (__const void *__raddr, int __suser,
+   __const char *__remuser, __const char *__locuser,
+   sa_family_t __af);
+extern int rresvport (int *__alport);
+extern int rresvport_af (int *__alport, sa_family_t __af);
+struct addrinfo
+{
+  int ai_flags;
+  int ai_family;
+  int ai_socktype;
+  int ai_protocol;
+  socklen_t ai_addrlen;
+  struct sockaddr *ai_addr;
+  char *ai_canonname;
+  struct addrinfo *ai_next;
+};
+struct gaicb
+{
+  const char *ar_name;
+  const char *ar_service;
+  const struct addrinfo *ar_request;
+  struct addrinfo *ar_result;
+  int __return;
+  int __unused[5];
+};
+
+struct winsize
+  {
+    unsigned short int ws_row;
+    unsigned short int ws_col;
+    unsigned short int ws_xpixel;
+    unsigned short int ws_ypixel;
+  };
+struct termio
+  {
+    unsigned short int c_iflag;
+    unsigned short int c_oflag;
+    unsigned short int c_cflag;
+    unsigned short int c_lflag;
+    unsigned char c_line;
+    unsigned char c_cc[8];
+};
+
+
+
+struct dirent
+  {
+    __ino64_t d_ino;
+    __off64_t d_off;
+    unsigned short int d_reclen;
+    unsigned char d_type;
+    char d_name[256];
+  };
+struct dirent64
+  {
+    __ino64_t d_ino;
+    __off64_t d_off;
+    unsigned short int d_reclen;
+    unsigned char d_type;
+    char d_name[256];
+  };
+enum
+  {
+    DT_UNKNOWN = 0,
+    DT_FIFO = 1,
+    DT_CHR = 2,
+    DT_DIR = 4,
+    DT_BLK = 6,
+    DT_REG = 8,
+    DT_LNK = 10,
+    DT_SOCK = 12,
+    DT_WHT = 14
+  };
+typedef struct __dirstream DIR;
+
+typedef long IV;
+typedef unsigned long UV;
+typedef double NV;
+struct RExC_state_t;
+struct _reg_trie_data;
+typedef size_t STRLEN;
+typedef struct op OP;
+typedef struct cop COP;
+typedef struct unop UNOP;
+typedef struct binop BINOP;
+typedef struct listop LISTOP;
+typedef struct logop LOGOP;
+typedef struct pmop PMOP;
+typedef struct svop SVOP;
+typedef struct padop PADOP;
+typedef struct pvop PVOP;
+typedef struct loop LOOP;
+typedef struct opslab OPSLAB;
+typedef struct opslot OPSLOT;
+typedef struct block_hooks BHK;
+typedef struct custom_op XOP;
+typedef struct interpreter PerlInterpreter;
+typedef struct sv SV;
+typedef struct av AV;
+typedef struct hv HV;
+typedef struct cv CV;
+typedef struct p5rx REGEXP;
+typedef struct gp GP;
+typedef struct gv GV;
+typedef struct io IO;
+typedef struct context PERL_CONTEXT;
+typedef struct block BLOCK;
+typedef struct magic MAGIC;
+typedef struct xpv XPV;
+typedef struct xpviv XPVIV;
+typedef struct xpvuv XPVUV;
+typedef struct xpvnv XPVNV;
+typedef struct xpvmg XPVMG;
+typedef struct xpvlv XPVLV;
+typedef struct xpvav XPVAV;
+typedef struct xpvhv XPVHV;
+typedef struct xpvgv XPVGV;
+typedef struct xpvcv XPVCV;
+typedef struct xpvbm XPVBM;
+typedef struct xpvfm XPVFM;
+typedef struct xpvio XPVIO;
+typedef struct mgvtbl MGVTBL;
+typedef union any ANY;
+typedef struct ptr_tbl_ent PTR_TBL_ENT_t;
+typedef struct ptr_tbl PTR_TBL_t;
+typedef struct clone_params CLONE_PARAMS;
+typedef struct padlist PADLIST;
+typedef AV PAD;
+typedef AV PADNAMELIST;
+typedef SV PADNAME;
+typedef long int __gwchar_t;
+
+typedef signed char I8;
+typedef unsigned char U8;
+typedef short I16;
+typedef unsigned short U16;
+typedef long I32;
+typedef unsigned long U32;
+typedef enum {
+    _CC_ENUM_ALPHA = 2,
+    _CC_ENUM_ALPHANUMERIC = 7,
+    _CC_ENUM_ASCII = 15,
+    _CC_ENUM_BLANK = 11,
+    _CC_ENUM_CASED = 9,
+    _CC_ENUM_CNTRL = 14,
+    _CC_ENUM_DIGIT = 1,
+    _CC_ENUM_GRAPH = 8,
+    _CC_ENUM_LOWER = 3,
+    _CC_ENUM_PRINT = 6,
+    _CC_ENUM_PSXSPC = 13,
+    _CC_ENUM_PUNCT = 5,
+    _CC_ENUM_SPACE = 10,
+    _CC_ENUM_UPPER = 4,
+    _CC_ENUM_VERTSPACE = 16,
+    _CC_ENUM_WORDCHAR = 0,
+    _CC_ENUM_XDIGIT = 12
+} _char_class_number;
+extern const U32 PL_charclass[];
+typedef U32 line_t;
+union any {
+    void* any_ptr;
+    I32 any_i32;
+    IV any_iv;
+    UV any_uv;
+    long any_long;
+    _Bool any_bool;
+    void (*any_dptr) (void*);
+    void (*any_dxptr) ( void*);
+};
+
+struct cop {
+    U32 cop_hints;
+};
+
+extern COP * PL_curcop;
+extern U32 PL_hints;
+extern COP PL_compiling;
+I32
+Perl_keyword ( const char *name, I32 len, _Bool all_keywords)
+{
+  extern int Perl___notused(void);
+  ;
+  switch (len)
+  {
+    case 1:
+      switch (name[0])
+      {
+        case 'm':
+          {
+            return 127;
+          }
+        case 'q':
+          {
+            return 154;
+          }
+        case 's':
+          {
+            return 177;
+          }
+        case 'x':
+          {
+            return -253;
+          }
+        case 'y':
+          {
+            return 255;
+          }
+        default:
+          goto unknown;
+      }
+    case 2:
+      switch (name[0])
+      {
+        case 'd':
+          if (name[1] == 'o')
+          {
+            return 45;
+          }
+          goto unknown;
+        case 'e':
+          if (name[1] == 'q')
+          {
+            return -57;
+          }
+          goto unknown;
+        case 'f':
+          if (name[1] == 'c')
+          {
+            return (all_keywords || ( (((PL_curcop == &PL_compiling ? PL_hints : PL_curcop->cop_hints) & 0x1c000000) >> 26) == 3 || ((((PL_curcop == &PL_compiling ? PL_hints : PL_curcop->cop_hints) & 0x1c000000) >> 26) == (0x1c000000 >> 26) && (((PL_curcop == &PL_compiling ? PL_hints : PL_curcop->cop_hints) & 0x00020000) ? Perl_feature_is_enabled( ("" "fc" ""), (sizeof("fc")-1)) : (0))) ) ? -64 : 0);
+          }
+          goto unknown;
+        case 'g':
+          switch (name[1])
+          {
+            case 'e':
+              {
+                return -73;
+              }
+            case 't':
+              {
+                return -105;
+              }
+            default:
+              goto unknown;
+          }
+        case 'i':
+          if (name[1] == 'f')
+          {
+            return 107;
+          }
+          goto unknown;
+        case 'l':
+          switch (name[1])
+          {
+            case 'c':
+              {
+                return -115;
+              }
+            case 'e':
+              {
+                return -117;
+              }
+            case 't':
+              {
+                return -126;
+              }
+            default:
+              goto unknown;
+          }
+        case 'm':
+          if (name[1] == 'y')
+          {
+            return 134;
+          }
+          goto unknown;
+        case 'n':
+          switch (name[1])
+          {
+            case 'e':
+              {
+                return -135;
+              }
+            case 'o':
+              {
+                return 137;
+              }
+            default:
+              goto unknown;
+          }
+        case 'o':
+          if (name[1] == 'r')
+          {
+            return -142;
+          }
+          goto unknown;
+        case 'q':
+          switch (name[1])
+          {
+            case 'q':
+              {
+                return 155;
+              }
+            case 'r':
+              {
+                return 156;
+              }
+            case 'w':
+              {
+                return 158;
+              }
+            case 'x':
+              {
+                return 159;
+              }
+            default:
+              goto unknown;
+          }
+        case 't':
+          if (name[1] == 'r')
+          {
+            return 230;
+          }
+          goto unknown;
+        case 'u':
+          if (name[1] == 'c')
+          {
+            return -232;
+          }
+          goto unknown;
+        default:
+          goto unknown;
+      }
+    case 3:
+      switch (name[0])
+      {
+        case 'E':
+          if (name[1] == 'N' &&
+              name[2] == 'D')
+          {
+            return 12;
+          }
+          goto unknown;
+        case 'a':
+          switch (name[1])
+          {
+            case 'b':
+              if (name[2] == 's')
+              {
+                return -15;
+              }
+              goto unknown;
+            case 'n':
+              if (name[2] == 'd')
+              {
+                return -18;
+              }
+              goto unknown;
+            default:
+              goto unknown;
+          }
+        case 'c':
+          switch (name[1])
+          {
+            case 'h':
+              if (name[2] == 'r')
+              {
+                return -30;
+              }
+              goto unknown;
+            case 'm':
+              if (name[2] == 'p')
+              {
+                return -34;
+              }
+              goto unknown;
+            case 'o':
+              if (name[2] == 's')
+              {
+                return -37;
+              }
+              goto unknown;
+            default:
+              goto unknown;
+          }
+        case 'd':
+          if (name[1] == 'i' &&
+              name[2] == 'e')
+          {
+            return -44;
+          }
+          goto unknown;
+        case 'e':
+          switch (name[1])
+          {
+            case 'o':
+              if (name[2] == 'f')
+              {
+                return -56;
+              }
+              goto unknown;
+            case 'x':
+              if (name[2] == 'p')
+              {
+                return -63;
+              }
+              goto unknown;
+            default:
+              goto unknown;
+          }
+        case 'f':
+          if (name[1] == 'o' &&
+              name[2] == 'r')
+          {
+            return 68;
+          }
+          goto unknown;
+        case 'h':
+          if (name[1] == 'e' &&
+              name[2] == 'x')
+          {
+            return -106;
+          }
+          goto unknown;
+        case 'i':
+          if (name[1] == 'n' &&
+              name[2] == 't')
+          {
+            return -109;
+          }
+          goto unknown;
+        case 'l':
+          if (name[1] == 'o' &&
+              name[2] == 'g')
+          {
+            return -124;
+          }
+          goto unknown;
+        case 'm':
+          if (name[1] == 'a' &&
+              name[2] == 'p')
+          {
+            return 128;
+          }
+          goto unknown;
+        case 'n':
+          if (name[1] == 'o' &&
+              name[2] == 't')
+          {
+            return -138;
+          }
+          goto unknown;
+        case 'o':
+          switch (name[1])
+          {
+            case 'c':
+              if (name[2] == 't')
+              {
+                return -139;
+              }
+              goto unknown;
+            case 'r':
+              if (name[2] == 'd')
+              {
+                return -143;
+              }
+              goto unknown;
+            case 'u':
+              if (name[2] == 'r')
+              {
+                return 144;
+              }
+              goto unknown;
+            default:
+              goto unknown;
+          }
+        case 'p':
+          if (name[1] == 'o')
+          {
+            switch (name[2])
+            {
+              case 'p':
+                {
+                  return -148;
+                }
+              case 's':
+                {
+                  return 149;
+                }
+              default:
+                goto unknown;
+            }
+          }
+          goto unknown;
+        case 'r':
+          if (name[1] == 'e' &&
+              name[2] == 'f')
+          {
+            return -168;
+          }
+          goto unknown;
+        case 's':
+          switch (name[1])
+          {
+            case 'a':
+              if (name[2] == 'y')
+              {
+                return (all_keywords || ( ((((PL_curcop == &PL_compiling ? PL_hints : PL_curcop->cop_hints) & 0x1c000000) >> 26) >= 1 && (((PL_curcop == &PL_compiling ? PL_hints : PL_curcop->cop_hints) & 0x1c000000) >> 26) <= 3) || ((((PL_curcop == &PL_compiling ? PL_hints : PL_curcop->cop_hints) & 0x1c000000) >> 26) == (0x1c000000 >> 26) && (((PL_curcop == &PL_compiling ? PL_hints : PL_curcop->cop_hints) & 0x00020000) ? Perl_feature_is_enabled( ("" "say" ""), (sizeof("say")-1)) : (0))) ) ? 178 : 0);
+              }
+              goto unknown;
+            case 'i':
+              if (name[2] == 'n')
+              {
+                return -202;
+              }
+              goto unknown;
+            case 'u':
+              if (name[2] == 'b')
+              {
+                return 215;
+              }
+              goto unknown;
+            default:
+              goto unknown;
+          }
+        case 't':
+          if (name[1] == 'i' &&
+              name[2] == 'e')
+          {
+            return -226;
+          }
+          goto unknown;
+        case 'u':
+          if (name[1] == 's' &&
+              name[2] == 'e')
+          {
+            return 242;
+          }
+          goto unknown;
+        case 'v':
+          if (name[1] == 'e' &&
+              name[2] == 'c')
+          {
+            return -245;
+          }
+          goto unknown;
+        case 'x':
+          if (name[1] == 'o' &&
+              name[2] == 'r')
+          {
+            return -254;
+          }
+          goto unknown;
+        default:
+          goto unknown;
+      }
+    case 4:
+      switch (name[0])
+      {
+        case 'C':
+          if (name[1] == 'O' &&
+              name[2] == 'R' &&
+              name[3] == 'E')
+          {
+            return -10;
+          }
+          goto unknown;
+        case 'I':
+          if (name[1] == 'N' &&
+              name[2] == 'I' &&
+              name[3] == 'T')
+          {
+            return 13;
+          }
+          goto unknown;
+        case 'b':
+          if (name[1] == 'i' &&
+              name[2] == 'n' &&
+              name[3] == 'd')
+          {
+            return -20;
+          }
+          goto unknown;
+        case 'c':
+          if (name[1] == 'h' &&
+              name[2] == 'o' &&
+              name[3] == 'p')
+          {
+            return -28;
+          }
+          goto unknown;
+        case 'd':
+          if (name[1] == 'u' &&
+              name[2] == 'm' &&
+              name[3] == 'p')
+          {
+            return -46;
+          }
+          goto unknown;
+        case 'e':
+          switch (name[1])
+          {
+            case 'a':
+              if (name[2] == 'c' &&
+                  name[3] == 'h')
+              {
+                return -47;
+              }
+              goto unknown;
+            case 'l':
+              if (name[2] == 's' &&
+                  name[3] == 'e')
+              {
+                return 48;
+              }
+              goto unknown;
+            case 'v':
+              if (name[2] == 'a' &&
+                  name[3] == 'l')
+              {
+                return 58;
+              }
+              goto unknown;
+            case 'x':
+              switch (name[2])
+              {
+                case 'e':
+                  if (name[3] == 'c')
+                  {
+                    return -60;
+                  }
+                  goto unknown;
+                case 'i':
+                  if (name[3] == 't')
+                  {
+                    return -62;
+                  }
+                  goto unknown;
+                default:
+                  goto unknown;
+              }
+            default:
+              goto unknown;
+          }
+        case 'f':
+          if (name[1] == 'o' &&
+              name[2] == 'r' &&
+              name[3] == 'k')
+          {
+            return -70;
+          }
+          goto unknown;
+        case 'g':
+          switch (name[1])
+          {
+            case 'e':
+              if (name[2] == 't' &&
+                  name[3] == 'c')
+              {
+                return -74;
+              }
+              goto unknown;
+            case 'l':
+              if (name[2] == 'o' &&
+                  name[3] == 'b')
+              {
+                return 101;
+              }
+              goto unknown;
+            case 'o':
+              if (name[2] == 't' &&
+                  name[3] == 'o')
+              {
+                return 103;
+              }
+              goto unknown;
+            case 'r':
+              if (name[2] == 'e' &&
+                  name[3] == 'p')
+              {
+                return 104;
+              }
+              goto unknown;
+            default:
+              goto unknown;
+          }
+        case 'j':
+          if (name[1] == 'o' &&
+              name[2] == 'i' &&
+              name[3] == 'n')
+          {
+            return -111;
+          }
+          goto unknown;
+        case 'k':
+          switch (name[1])
+          {
+            case 'e':
+              if (name[2] == 'y' &&
+                  name[3] == 's')
+              {
+                return -112;
+              }
+              goto unknown;
+            case 'i':
+              if (name[2] == 'l' &&
+                  name[3] == 'l')
+              {
+                return -113;
+              }
+              goto unknown;
+            default:
+              goto unknown;
+          }
+        case 'l':
+          switch (name[1])
+          {
+            case 'a':
+              if (name[2] == 's' &&
+                  name[3] == 't')
+              {
+                return 114;
+              }
+              goto unknown;
+            case 'i':
+              if (name[2] == 'n' &&
+                  name[3] == 'k')
+              {
+                return -119;
+              }
+              goto unknown;
+            case 'o':
+              if (name[2] == 'c' &&
+                  name[3] == 'k')
+              {
+                return -123;
+              }
+              goto unknown;
+            default:
+              goto unknown;
+          }
+        case 'n':
+          if (name[1] == 'e' &&
+              name[2] == 'x' &&
+              name[3] == 't')
+          {
+            return 136;
+          }
+          goto unknown;
+        case 'o':
+          if (name[1] == 'p' &&
+              name[2] == 'e' &&
+              name[3] == 'n')
+          {
+            return -140;
+          }
+          goto unknown;
+        case 'p':
+          switch (name[1])
+          {
+            case 'a':
+              if (name[2] == 'c' &&
+                  name[3] == 'k')
+              {
+                return -145;
+              }
+              goto unknown;
+            case 'i':
+              if (name[2] == 'p' &&
+                  name[3] == 'e')
+              {
+                return -147;
+              }
+              goto unknown;
+            case 'u':
+              if (name[2] == 's' &&
+                  name[3] == 'h')
+              {
+                return -153;
+              }
+              goto unknown;
+            default:
+              goto unknown;
+          }
+        case 'r':
+          switch (name[1])
+          {
+            case 'a':
+              if (name[2] == 'n' &&
+                  name[3] == 'd')
+              {
+                return -160;
+              }
+              goto unknown;
+            case 'e':
+              switch (name[2])
+              {
+                case 'a':
+                  if (name[3] == 'd')
+                  {
+                    return -161;
+                  }
+                  goto unknown;
+                case 'c':
+                  if (name[3] == 'v')
+                  {
+                    return -166;
+                  }
+                  goto unknown;
+                case 'd':
+                  if (name[3] == 'o')
+                  {
+                    return 167;
+                  }
+                  goto unknown;
+                default:
+                  goto unknown;
+              }
+            default:
+              goto unknown;
+          }
+        case 's':
+          switch (name[1])
+          {
+            case 'e':
+              switch (name[2])
+              {
+                case 'e':
+                  if (name[3] == 'k')
+                  {
+                    return -180;
+                  }
+                  goto unknown;
+                case 'n':
+                  if (name[3] == 'd')
+                  {
+                    return -186;
+                  }
+                  goto unknown;
+                default:
+                  goto unknown;
+              }
+            case 'o':
+              if (name[2] == 'r' &&
+                  name[3] == 't')
+              {
+                return 206;
+              }
+              goto unknown;
+            case 'q':
+              if (name[2] == 'r' &&
+                  name[3] == 't')
+              {
+                return -210;
+              }
+              goto unknown;
+            case 't':
+              if (name[2] == 'a' &&
+                  name[3] == 't')
+              {
+                return -212;
+              }
+              goto unknown;
+            default:
+              goto unknown;
+          }
+        case 't':
+          switch (name[1])
+          {
+            case 'e':
+              if (name[2] == 'l' &&
+                  name[3] == 'l')
+              {
+                return -224;
+              }
+              goto unknown;
+            case 'i':
+              switch (name[2])
+              {
+                case 'e':
+                  if (name[3] == 'd')
+                  {
+                    return -227;
+                  }
+                  goto unknown;
+                case 'm':
+                  if (name[3] == 'e')
+                  {
+                    return -228;
+                  }
+                  goto unknown;
+                default:
+                  goto unknown;
+              }
+            default:
+              goto unknown;
+          }
+        case 'w':
+          switch (name[1])
+          {
+            case 'a':
+              switch (name[2])
+              {
+                case 'i':
+                  if (name[3] == 't')
+                  {
+                    return -246;
+                  }
+                  goto unknown;
+                case 'r':
+                  if (name[3] == 'n')
+                  {
+                    return -249;
+                  }
+                  goto unknown;
+                default:
+                  goto unknown;
+              }
+            case 'h':
+              if (name[2] == 'e' &&
+                  name[3] == 'n')
+              {
+                return (all_keywords || ( ((((PL_curcop == &PL_compiling ? PL_hints : PL_curcop->cop_hints) & 0x1c000000) >> 26) >= 1 && (((PL_curcop == &PL_compiling ? PL_hints : PL_curcop->cop_hints) & 0x1c000000) >> 26) <= 3) || ((((PL_curcop == &PL_compiling ? PL_hints : PL_curcop->cop_hints) & 0x1c000000) >> 26) == (0x1c000000 >> 26) && (((PL_curcop == &PL_compiling ? PL_hints : PL_curcop->cop_hints) & 0x00020000) ? Perl_feature_is_enabled( ("" "switch" ""), (sizeof("switch")-1)) : (0))) ) ? 250 : 0);
+              }
+              goto unknown;
+            default:
+              goto unknown;
+          }
+        default:
+          goto unknown;
+      }
+    case 5:
+      switch (name[0])
+      {
+        case 'B':
+          if (name[1] == 'E' &&
+              name[2] == 'G' &&
+              name[3] == 'I' &&
+              name[4] == 'N')
+          {
+            return 8;
+          }
+          goto unknown;
+        case 'C':
+          if (name[1] == 'H' &&
+              name[2] == 'E' &&
+              name[3] == 'C' &&
+              name[4] == 'K')
+          {
+            return 14;
+          }
+          goto unknown;
+        case 'a':
+          switch (name[1])
+          {
+            case 'l':
+              if (name[2] == 'a' &&
+                  name[3] == 'r' &&
+                  name[4] == 'm')
+              {
+                return -17;
+              }
+              goto unknown;
+            case 't':
+              if (name[2] == 'a' &&
+                  name[3] == 'n' &&
+                  name[4] == '2')
+              {
+                return -19;
+              }
+              goto unknown;
+            default:
+              goto unknown;
+          }
+        case 'b':
+          switch (name[1])
+          {
+            case 'l':
+              if (name[2] == 'e' &&
+                  name[3] == 's' &&
+                  name[4] == 's')
+              {
+                return -22;
+              }
+              goto unknown;
+            case 'r':
+              if (name[2] == 'e' &&
+                  name[3] == 'a' &&
+                  name[4] == 'k')
+              {
+                return (all_keywords || ( ((((PL_curcop == &PL_compiling ? PL_hints : PL_curcop->cop_hints) & 0x1c000000) >> 26) >= 1 && (((PL_curcop == &PL_compiling ? PL_hints : PL_curcop->cop_hints) & 0x1c000000) >> 26) <= 3) || ((((PL_curcop == &PL_compiling ? PL_hints : PL_curcop->cop_hints) & 0x1c000000) >> 26) == (0x1c000000 >> 26) && (((PL_curcop == &PL_compiling ? PL_hints : PL_curcop->cop_hints) & 0x00020000) ? Perl_feature_is_enabled( ("" "switch" ""), (sizeof("switch")-1)) : (0))) ) ? -23 : 0);
+              }
+              goto unknown;
+            default:
+              goto unknown;
+          }
+        case 'c':
+          switch (name[1])
+          {
+            case 'h':
+              switch (name[2])
+              {
+                case 'd':
+                  if (name[3] == 'i' &&
+                      name[4] == 'r')
+                  {
+                    return -25;
+                  }
+                  goto unknown;
+                case 'm':
+                  if (name[3] == 'o' &&
+                      name[4] == 'd')
+                  {
+                    return -26;
+                  }
+                  goto unknown;
+                case 'o':
+                  switch (name[3])
+                  {
+                    case 'm':
+                      if (name[4] == 'p')
+                      {
+                        return -27;
+                      }
+                      goto unknown;
+                    case 'w':
+                      if (name[4] == 'n')
+                      {
+                        return -29;
+                      }
+                      goto unknown;
+                    default:
+                      goto unknown;
+                  }
+                default:
+                  goto unknown;
+              }
+            case 'l':
+              if (name[2] == 'o' &&
+                  name[3] == 's' &&
+                  name[4] == 'e')
+              {
+                return -32;
+              }
+              goto unknown;
+            case 'r':
+              if (name[2] == 'y' &&
+                  name[3] == 'p' &&
+                  name[4] == 't')
+              {
+                return -38;
+              }
+              goto unknown;
+            default:
+              goto unknown;
+          }
+        case 'e':
+          if (name[1] == 'l' &&
+              name[2] == 's' &&
+              name[3] == 'i' &&
+              name[4] == 'f')
+          {
+            return 49;
+          }
+          goto unknown;
+        case 'f':
+          switch (name[1])
+          {
+            case 'c':
+              if (name[2] == 'n' &&
+                  name[3] == 't' &&
+                  name[4] == 'l')
+              {
+                return -65;
+              }
+              goto unknown;
+            case 'l':
+              if (name[2] == 'o' &&
+                  name[3] == 'c' &&
+                  name[4] == 'k')
+              {
+                return -67;
+              }
+              goto unknown;
+            default:
+              goto unknown;
+          }
+        case 'g':
+          if (name[1] == 'i' &&
+              name[2] == 'v' &&
+              name[3] == 'e' &&
+              name[4] == 'n')
+          {
+            return (all_keywords || ( ((((PL_curcop == &PL_compiling ? PL_hints : PL_curcop->cop_hints) & 0x1c000000) >> 26) >= 1 && (((PL_curcop == &PL_compiling ? PL_hints : PL_curcop->cop_hints) & 0x1c000000) >> 26) <= 3) || ((((PL_curcop == &PL_compiling ? PL_hints : PL_curcop->cop_hints) & 0x1c000000) >> 26) == (0x1c000000 >> 26) && (((PL_curcop == &PL_compiling ? PL_hints : PL_curcop->cop_hints) & 0x00020000) ? Perl_feature_is_enabled( ("" "switch" ""), (sizeof("switch")-1)) : (0))) ) ? 100 : 0);
+          }
+          goto unknown;
+        case 'i':
+          switch (name[1])
+          {
+            case 'n':
+              if (name[2] == 'd' &&
+                  name[3] == 'e' &&
+                  name[4] == 'x')
+              {
+                return -108;
+              }
+              goto unknown;
+            case 'o':
+              if (name[2] == 'c' &&
+                  name[3] == 't' &&
+                  name[4] == 'l')
+              {
+                return -110;
+              }
+              goto unknown;
+            default:
+              goto unknown;
+          }
+        case 'l':
+          switch (name[1])
+          {
+            case 'o':
+              if (name[2] == 'c' &&
+                  name[3] == 'a' &&
+                  name[4] == 'l')
+              {
+                return 121;
+              }
+              goto unknown;
+            case 's':
+              if (name[2] == 't' &&
+                  name[3] == 'a' &&
+                  name[4] == 't')
+              {
+                return -125;
+              }
+              goto unknown;
+            default:
+              goto unknown;
+          }
+        case 'm':
+          if (name[1] == 'k' &&
+              name[2] == 'd' &&
+              name[3] == 'i' &&
+              name[4] == 'r')
+          {
+            return -129;
+          }
+          goto unknown;
+        case 'p':
+          if (name[1] == 'r' &&
+              name[2] == 'i' &&
+              name[3] == 'n' &&
+              name[4] == 't')
+          {
+            return 150;
+          }
+          goto unknown;
+        case 'r':
+          switch (name[1])
+          {
+            case 'e':
+              if (name[2] == 's' &&
+                  name[3] == 'e' &&
+                  name[4] == 't')
+              {
+                return -171;
+              }
+              goto unknown;
+            case 'm':
+              if (name[2] == 'd' &&
+                  name[3] == 'i' &&
+                  name[4] == 'r')
+              {
+                return -176;
+              }
+              goto unknown;
+            default:
+              goto unknown;
+          }
+        case 's':
+          switch (name[1])
+          {
+            case 'e':
+              if (name[2] == 'm' &&
+                  name[3] == 'o' &&
+                  name[4] == 'p')
+              {
+                return -185;
+              }
+              goto unknown;
+            case 'h':
+              if (name[2] == 'i' &&
+                  name[3] == 'f' &&
+                  name[4] == 't')
+              {
+                return -196;
+              }
+              goto unknown;
+            case 'l':
+              if (name[2] == 'e' &&
+                  name[3] == 'e' &&
+                  name[4] == 'p')
+              {
+                return -203;
+              }
+              goto unknown;
+            case 'p':
+              if (name[2] == 'l' &&
+                  name[3] == 'i' &&
+                  name[4] == 't')
+              {
+                return 208;
+              }
+              goto unknown;
+            case 'r':
+              if (name[2] == 'a' &&
+                  name[3] == 'n' &&
+                  name[4] == 'd')
+              {
+                return -211;
+              }
+              goto unknown;
+            case 't':
+              switch (name[2])
+              {
+                case 'a':
+                  if (name[3] == 't' &&
+                      name[4] == 'e')
+                  {
+                    return (all_keywords || ( ((((PL_curcop == &PL_compiling ? PL_hints : PL_curcop->cop_hints) & 0x1c000000) >> 26) >= 1 && (((PL_curcop == &PL_compiling ? PL_hints : PL_curcop->cop_hints) & 0x1c000000) >> 26) <= 3) || ((((PL_curcop == &PL_compiling ? PL_hints : PL_curcop->cop_hints) & 0x1c000000) >> 26) == (0x1c000000 >> 26) && (((PL_curcop == &PL_compiling ? PL_hints : PL_curcop->cop_hints) & 0x00020000) ? Perl_feature_is_enabled( ("" "state" ""), (sizeof("state")-1)) : (0))) ) ? 213 : 0);
+                  }
+                  goto unknown;
+                case 'u':
+                  if (name[3] == 'd' &&
+                      name[4] == 'y')
+                  {
+                    return 214;
+                  }
+                  goto unknown;
+                default:
+                  goto unknown;
+              }
+            default:
+              goto unknown;
+          }
+        case 't':
+          if (name[1] == 'i' &&
+              name[2] == 'm' &&
+              name[3] == 'e' &&
+              name[4] == 's')
+          {
+            return -229;
+          }
+          goto unknown;
+        case 'u':
+          switch (name[1])
+          {
+            case 'm':
+              if (name[2] == 'a' &&
+                  name[3] == 's' &&
+                  name[4] == 'k')
+              {
+                return -234;
+              }
+              goto unknown;
+            case 'n':
+              switch (name[2])
+              {
+                case 'd':
+                  if (name[3] == 'e' &&
+                      name[4] == 'f')
+                  {
+                    return 235;
+                  }
+                  goto unknown;
+                case 't':
+                  if (name[3] == 'i')
+                  {
+                    switch (name[4])
+                    {
+                      case 'e':
+                        {
+                          return -240;
+                        }
+                      case 'l':
+                        {
+                          return 241;
+                        }
+                      default:
+                        goto unknown;
+                    }
+                  }
+                  goto unknown;
+                default:
+                  goto unknown;
+              }
+            case 't':
+              if (name[2] == 'i' &&
+                  name[3] == 'm' &&
+                  name[4] == 'e')
+              {
+                return -243;
+              }
+              goto unknown;
+            default:
+              goto unknown;
+          }
+        case 'w':
+          switch (name[1])
+          {
+            case 'h':
+              if (name[2] == 'i' &&
+                  name[3] == 'l' &&
+                  name[4] == 'e')
+              {
+                return 251;
+              }
+              goto unknown;
+            case 'r':
+              if (name[2] == 'i' &&
+                  name[3] == 't' &&
+                  name[4] == 'e')
+              {
+                return -252;
+              }
+              goto unknown;
+            default:
+              goto unknown;
+          }
+        default:
+          goto unknown;
+      }
+    case 6:
+      switch (name[0])
+      {
+        case 'a':
+          if (name[1] == 'c' &&
+              name[2] == 'c' &&
+              name[3] == 'e' &&
+              name[4] == 'p' &&
+              name[5] == 't')
+          {
+            return -16;
+          }
+          goto unknown;
+        case 'c':
+          switch (name[1])
+          {
+            case 'a':
+              if (name[2] == 'l' &&
+                  name[3] == 'l' &&
+                  name[4] == 'e' &&
+                  name[5] == 'r')
+              {
+                return -24;
+              }
+              goto unknown;
+            case 'h':
+              if (name[2] == 'r' &&
+                  name[3] == 'o' &&
+                  name[4] == 'o' &&
+                  name[5] == 't')
+              {
+                return -31;
+              }
+              goto unknown;
+            default:
+              goto unknown;
+          }
+        case 'd':
+          if (name[1] == 'e' &&
+              name[2] == 'l' &&
+              name[3] == 'e' &&
+              name[4] == 't' &&
+              name[5] == 'e')
+          {
+            return 43;
+          }
+          goto unknown;
+        case 'e':
+          switch (name[1])
+          {
+            case 'l':
+              if (name[2] == 's' &&
+                  name[3] == 'e' &&
+                  name[4] == 'i' &&
+                  name[5] == 'f')
+              {
+                Perl_ck_warner_d( (28 ), "elseif should be elsif");
+              }
+              goto unknown;
+            case 'x':
+              if (name[2] == 'i' &&
+                  name[3] == 's' &&
+                  name[4] == 't' &&
+                  name[5] == 's')
+              {
+                return 61;
+              }
+              goto unknown;
+            default:
+              goto unknown;
+          }
+        case 'f':
+          switch (name[1])
+          {
+            case 'i':
+              if (name[2] == 'l' &&
+                  name[3] == 'e' &&
+                  name[4] == 'n' &&
+                  name[5] == 'o')
+              {
+                return -66;
+              }
+              goto unknown;
+            case 'o':
+              if (name[2] == 'r' &&
+                  name[3] == 'm' &&
+                  name[4] == 'a' &&
+                  name[5] == 't')
+              {
+                return 71;
+              }
+              goto unknown;
+            default:
+              goto unknown;
+          }
+        case 'g':
+          if (name[1] == 'm' &&
+              name[2] == 't' &&
+              name[3] == 'i' &&
+              name[4] == 'm' &&
+              name[5] == 'e')
+          {
+            return -102;
+          }
+          goto unknown;
+        case 'l':
+          switch (name[1])
+          {
+            case 'e':
+              if (name[2] == 'n' &&
+                  name[3] == 'g' &&
+                  name[4] == 't' &&
+                  name[5] == 'h')
+              {
+                return -118;
+              }
+              goto unknown;
+            case 'i':
+              if (name[2] == 's' &&
+                  name[3] == 't' &&
+                  name[4] == 'e' &&
+                  name[5] == 'n')
+              {
+                return -120;
+              }
+              goto unknown;
+            default:
+              goto unknown;
+          }
+        case 'm':
+          if (name[1] == 's' &&
+              name[2] == 'g')
+          {
+            switch (name[3])
+            {
+              case 'c':
+                if (name[4] == 't' &&
+                    name[5] == 'l')
+                {
+                  return -130;
+                }
+                goto unknown;
+              case 'g':
+                if (name[4] == 'e' &&
+                    name[5] == 't')
+                {
+                  return -131;
+                }
+                goto unknown;
+              case 'r':
+                if (name[4] == 'c' &&
+                    name[5] == 'v')
+                {
+                  return -132;
+                }
+                goto unknown;
+              case 's':
+                if (name[4] == 'n' &&
+                    name[5] == 'd')
+                {
+                  return -133;
+                }
+                goto unknown;
+              default:
+                goto unknown;
+            }
+          }
+          goto unknown;
+        case 'p':
+          if (name[1] == 'r' &&
+              name[2] == 'i' &&
+              name[3] == 'n' &&
+              name[4] == 't' &&
+              name[5] == 'f')
+          {
+            return 151;
+          }
+          goto unknown;
+        case 'r':
+          switch (name[1])
+          {
+            case 'e':
+              switch (name[2])
+              {
+                case 'n':
+                  if (name[3] == 'a' &&
+                      name[4] == 'm' &&
+                      name[5] == 'e')
+                  {
+                    return -169;
+                  }
+                  goto unknown;
+                case 't':
+                  if (name[3] == 'u' &&
+                      name[4] == 'r' &&
+                      name[5] == 'n')
+                  {
+                    return 172;
+                  }
+                  goto unknown;
+                default:
+                  goto unknown;
+              }
+            case 'i':
+              if (name[2] == 'n' &&
+                  name[3] == 'd' &&
+                  name[4] == 'e' &&
+                  name[5] == 'x')
+              {
+                return -175;
+              }
+              goto unknown;
+            default:
+              goto unknown;
+          }
+        case 's':
+          switch (name[1])
+          {
+            case 'c':
+              if (name[2] == 'a' &&
+                  name[3] == 'l' &&
+                  name[4] == 'a' &&
+                  name[5] == 'r')
+              {
+                return 179;
+              }
+              goto unknown;
+            case 'e':
+              switch (name[2])
+              {
+                case 'l':
+                  if (name[3] == 'e' &&
+                      name[4] == 'c' &&
+                      name[5] == 't')
+                  {
+                    return -182;
+                  }
+                  goto unknown;
+                case 'm':
+                  switch (name[3])
+                  {
+                    case 'c':
+                      if (name[4] == 't' &&
+                          name[5] == 'l')
+                      {
+                        return -183;
+                      }
+                      goto unknown;
+                    case 'g':
+                      if (name[4] == 'e' &&
+                          name[5] == 't')
+                      {
+                        return -184;
+                      }
+                      goto unknown;
+                    default:
+                      goto unknown;
+                  }
+                default:
+                  goto unknown;
+              }
+            case 'h':
+              if (name[2] == 'm')
+              {
+                switch (name[3])
+                {
+                  case 'c':
+                    if (name[4] == 't' &&
+                        name[5] == 'l')
+                    {
+                      return -197;
+                    }
+                    goto unknown;
+                  case 'g':
+                    if (name[4] == 'e' &&
+                        name[5] == 't')
+                    {
+                      return -198;
+                    }
+                    goto unknown;
+                  default:
+                    goto unknown;
+                }
+              }
+              goto unknown;
+            case 'o':
+              if (name[2] == 'c' &&
+                  name[3] == 'k' &&
+                  name[4] == 'e' &&
+                  name[5] == 't')
+              {
+                return -204;
+              }
+              goto unknown;
+            case 'p':
+              if (name[2] == 'l' &&
+                  name[3] == 'i' &&
+                  name[4] == 'c' &&
+                  name[5] == 'e')
+              {
+                return -207;
+              }
+              goto unknown;
+            case 'u':
+              if (name[2] == 'b' &&
+                  name[3] == 's' &&
+                  name[4] == 't' &&
+                  name[5] == 'r')
+              {
+                return -216;
+              }
+              goto unknown;
+            case 'y':
+              if (name[2] == 's' &&
+                  name[3] == 't' &&
+                  name[4] == 'e' &&
+                  name[5] == 'm')
+              {
+                return -222;
+              }
+              goto unknown;
+            default:
+              goto unknown;
+          }
+        case 'u':
+          if (name[1] == 'n')
+          {
+            switch (name[2])
+            {
+              case 'l':
+                switch (name[3])
+                {
+                  case 'e':
+                    if (name[4] == 's' &&
+                        name[5] == 's')
+                    {
+                      return 236;
+                    }
+                    goto unknown;
+                  case 'i':
+                    if (name[4] == 'n' &&
+                        name[5] == 'k')
+                    {
+                      return -237;
+                    }
+                    goto unknown;
+                  default:
+                    goto unknown;
+                }
+              case 'p':
+                if (name[3] == 'a' &&
+                    name[4] == 'c' &&
+                    name[5] == 'k')
+                {
+                  return -238;
+                }
+                goto unknown;
+              default:
+                goto unknown;
+            }
+          }
+          goto unknown;
+        case 'v':
+          if (name[1] == 'a' &&
+              name[2] == 'l' &&
+              name[3] == 'u' &&
+              name[4] == 'e' &&
+              name[5] == 's')
+          {
+            return -244;
+          }
+          goto unknown;
+        default:
+          goto unknown;
+      }
+    case 7:
+      switch (name[0])
+      {
+        case 'D':
+          if (name[1] == 'E' &&
+              name[2] == 'S' &&
+              name[3] == 'T' &&
+              name[4] == 'R' &&
+              name[5] == 'O' &&
+              name[6] == 'Y')
+          {
+            return 11;
+          }
+          goto unknown;
+        case '_':
+          if (name[1] == '_')
+          {
+            switch (name[2])
+            {
+              case 'E':
+                if (name[3] == 'N' &&
+                    name[4] == 'D' &&
+                    name[5] == '_' &&
+                    name[6] == '_')
+                {
+                  return 5;
+                }
+                goto unknown;
+              case 'S':
+                if (name[3] == 'U' &&
+                    name[4] == 'B' &&
+                    name[5] == '_' &&
+                    name[6] == '_')
+                {
+                  return (all_keywords || ( (((PL_curcop == &PL_compiling ? PL_hints : PL_curcop->cop_hints) & 0x1c000000) >> 26) == 3 || ((((PL_curcop == &PL_compiling ? PL_hints : PL_curcop->cop_hints) & 0x1c000000) >> 26) == (0x1c000000 >> 26) && (((PL_curcop == &PL_compiling ? PL_hints : PL_curcop->cop_hints) & 0x00020000) ? Perl_feature_is_enabled( ("" "__SUB__" ""), (sizeof("__SUB__")-1)) : (0))) ) ? -6 : 0);
+                }
+                goto unknown;
+              default:
+                goto unknown;
+            }
+          }
+          goto unknown;
+        case 'b':
+          if (name[1] == 'i' &&
+              name[2] == 'n' &&
+              name[3] == 'm' &&
+              name[4] == 'o' &&
+              name[5] == 'd' &&
+              name[6] == 'e')
+          {
+            return -21;
+          }
+          goto unknown;
+        case 'c':
+          if (name[1] == 'o' &&
+              name[2] == 'n' &&
+              name[3] == 'n' &&
+              name[4] == 'e' &&
+              name[5] == 'c' &&
+              name[6] == 't')
+          {
+            return -35;
+          }
+          goto unknown;
+        case 'd':
+          switch (name[1])
+          {
+            case 'b':
+              if (name[2] == 'm' &&
+                  name[3] == 'o' &&
+                  name[4] == 'p' &&
+                  name[5] == 'e' &&
+                  name[6] == 'n')
+              {
+                return -40;
+              }
+              goto unknown;
+            case 'e':
+              if (name[2] == 'f')
+              {
+                switch (name[3])
+                {
+                  case 'a':
+                    if (name[4] == 'u' &&
+                        name[5] == 'l' &&
+                        name[6] == 't')
+                    {
+                      return (all_keywords || ( ((((PL_curcop == &PL_compiling ? PL_hints : PL_curcop->cop_hints) & 0x1c000000) >> 26) >= 1 && (((PL_curcop == &PL_compiling ? PL_hints : PL_curcop->cop_hints) & 0x1c000000) >> 26) <= 3) || ((((PL_curcop == &PL_compiling ? PL_hints : PL_curcop->cop_hints) & 0x1c000000) >> 26) == (0x1c000000 >> 26) && (((PL_curcop == &PL_compiling ? PL_hints : PL_curcop->cop_hints) & 0x00020000) ? Perl_feature_is_enabled( ("" "switch" ""), (sizeof("switch")-1)) : (0))) ) ? 41 : 0);
+                    }
+                    goto unknown;
+                  case 'i':
+                    if (name[4] == 'n' &&
+                        name[5] == 'e' &&
+                        name[6] == 'd')
+                    {
+                      return 42;
+                    }
+                    goto unknown;
+                  default:
+                    goto unknown;
+                }
+              }
+              goto unknown;
+            default:
+              goto unknown;
+          }
+        case 'f':
+          if (name[1] == 'o' &&
+              name[2] == 'r' &&
+              name[3] == 'e' &&
+              name[4] == 'a' &&
+              name[5] == 'c' &&
+              name[6] == 'h')
+          {
+            return 69;
+          }
+          goto unknown;
+        case 'g':
+          if (name[1] == 'e' &&
+              name[2] == 't' &&
+              name[3] == 'p')
+          {
+            switch (name[4])
+            {
+              case 'g':
+                if (name[5] == 'r' &&
+                    name[6] == 'p')
+                {
+                  return -86;
+                }
+                goto unknown;
+              case 'p':
+                if (name[5] == 'i' &&
+                    name[6] == 'd')
+                {
+                  return -87;
+                }
+                goto unknown;
+              default:
+                goto unknown;
+            }
+          }
+          goto unknown;
+        case 'l':
+          if (name[1] == 'c' &&
+              name[2] == 'f' &&
+              name[3] == 'i' &&
+              name[4] == 'r' &&
+              name[5] == 's' &&
+              name[6] == 't')
+          {
+            return -116;
+          }
+          goto unknown;
+        case 'o':
+          if (name[1] == 'p' &&
+              name[2] == 'e' &&
+              name[3] == 'n' &&
+              name[4] == 'd' &&
+              name[5] == 'i' &&
+              name[6] == 'r')
+          {
+            return -141;
+          }
+          goto unknown;
+        case 'p':
+          if (name[1] == 'a' &&
+              name[2] == 'c' &&
+              name[3] == 'k' &&
+              name[4] == 'a' &&
+              name[5] == 'g' &&
+              name[6] == 'e')
+          {
+            return 146;
+          }
+          goto unknown;
+        case 'r':
+          if (name[1] == 'e')
+          {
+            switch (name[2])
+            {
+              case 'a':
+                if (name[3] == 'd' &&
+                    name[4] == 'd' &&
+                    name[5] == 'i' &&
+                    name[6] == 'r')
+                {
+                  return -162;
+                }
+                goto unknown;
+              case 'q':
+                if (name[3] == 'u' &&
+                    name[4] == 'i' &&
+                    name[5] == 'r' &&
+                    name[6] == 'e')
+                {
+                  return 170;
+                }
+                goto unknown;
+              case 'v':
+                if (name[3] == 'e' &&
+                    name[4] == 'r' &&
+                    name[5] == 's' &&
+                    name[6] == 'e')
+                {
+                  return -173;
+                }
+                goto unknown;
+              default:
+                goto unknown;
+            }
+          }
+          goto unknown;
+        case 's':
+          switch (name[1])
+          {
+            case 'e':
+              switch (name[2])
+              {
+                case 'e':
+                  if (name[3] == 'k' &&
+                      name[4] == 'd' &&
+                      name[5] == 'i' &&
+                      name[6] == 'r')
+                  {
+                    return -181;
+                  }
+                  goto unknown;
+                case 't':
+                  if (name[3] == 'p' &&
+                      name[4] == 'g' &&
+                      name[5] == 'r' &&
+                      name[6] == 'p')
+                  {
+                    return -190;
+                  }
+                  goto unknown;
+                default:
+                  goto unknown;
+              }
+            case 'h':
+              if (name[2] == 'm' &&
+                  name[3] == 'r' &&
+                  name[4] == 'e' &&
+                  name[5] == 'a' &&
+                  name[6] == 'd')
+              {
+                return -199;
+              }
+              goto unknown;
+            case 'p':
+              if (name[2] == 'r' &&
+                  name[3] == 'i' &&
+                  name[4] == 'n' &&
+                  name[5] == 't' &&
+                  name[6] == 'f')
+              {
+                return -209;
+              }
+              goto unknown;
+            case 'y':
+              switch (name[2])
+              {
+                case 'm':
+                  if (name[3] == 'l' &&
+                      name[4] == 'i' &&
+                      name[5] == 'n' &&
+                      name[6] == 'k')
+                  {
+                    return -217;
+                  }
+                  goto unknown;
+                case 's':
+                  switch (name[3])
+                  {
+                    case 'c':
+                      if (name[4] == 'a' &&
+                          name[5] == 'l' &&
+                          name[6] == 'l')
+                      {
+                        return -218;
+                      }
+                      goto unknown;
+                    case 'o':
+                      if (name[4] == 'p' &&
+                          name[5] == 'e' &&
+                          name[6] == 'n')
+                      {
+                        return -219;
+                      }
+                      goto unknown;
+                    case 'r':
+                      if (name[4] == 'e' &&
+                          name[5] == 'a' &&
+                          name[6] == 'd')
+                      {
+                        return -220;
+                      }
+                      goto unknown;
+                    case 's':
+                      if (name[4] == 'e' &&
+                          name[5] == 'e' &&
+                          name[6] == 'k')
+                      {
+                        return -221;
+                      }
+                      goto unknown;
+                    default:
+                      goto unknown;
+                  }
+                default:
+                  goto unknown;
+              }
+            default:
+              goto unknown;
+          }
+        case 't':
+          if (name[1] == 'e' &&
+              name[2] == 'l' &&
+              name[3] == 'l' &&
+              name[4] == 'd' &&
+              name[5] == 'i' &&
+              name[6] == 'r')
+          {
+            return -225;
+          }
+          goto unknown;
+        case 'u':
+          switch (name[1])
+          {
+            case 'c':
+              if (name[2] == 'f' &&
+                  name[3] == 'i' &&
+                  name[4] == 'r' &&
+                  name[5] == 's' &&
+                  name[6] == 't')
+              {
+                return -233;
+              }
+              goto unknown;
+            case 'n':
+              if (name[2] == 's' &&
+                  name[3] == 'h' &&
+                  name[4] == 'i' &&
+                  name[5] == 'f' &&
+                  name[6] == 't')
+              {
+                return -239;
+              }
+              goto unknown;
+            default:
+              goto unknown;
+          }
+        case 'w':
+          if (name[1] == 'a' &&
+              name[2] == 'i' &&
+              name[3] == 't' &&
+              name[4] == 'p' &&
+              name[5] == 'i' &&
+              name[6] == 'd')
+          {
+            return -247;
+          }
+          goto unknown;
+        default:
+          goto unknown;
+      }
+    case 8:
+      switch (name[0])
+      {
+        case 'A':
+          if (name[1] == 'U' &&
+              name[2] == 'T' &&
+              name[3] == 'O' &&
+              name[4] == 'L' &&
+              name[5] == 'O' &&
+              name[6] == 'A' &&
+              name[7] == 'D')
+          {
+            return 7;
+          }
+          goto unknown;
+        case '_':
+          if (name[1] == '_')
+          {
+            switch (name[2])
+            {
+              case 'D':
+                if (name[3] == 'A' &&
+                    name[4] == 'T' &&
+                    name[5] == 'A' &&
+                    name[6] == '_' &&
+                    name[7] == '_')
+                {
+                  return 4;
+                }
+                goto unknown;
+              case 'F':
+                if (name[3] == 'I' &&
+                    name[4] == 'L' &&
+                    name[5] == 'E' &&
+                    name[6] == '_' &&
+                    name[7] == '_')
+                {
+                  return -1;
+                }
+                goto unknown;
+              case 'L':
+                if (name[3] == 'I' &&
+                    name[4] == 'N' &&
+                    name[5] == 'E' &&
+                    name[6] == '_' &&
+                    name[7] == '_')
+                {
+                  return -2;
+                }
+                goto unknown;
+              default:
+                goto unknown;
+            }
+          }
+          goto unknown;
+        case 'c':
+          switch (name[1])
+          {
+            case 'l':
+              if (name[2] == 'o' &&
+                  name[3] == 's' &&
+                  name[4] == 'e' &&
+                  name[5] == 'd' &&
+                  name[6] == 'i' &&
+                  name[7] == 'r')
+              {
+                return -33;
+              }
+              goto unknown;
+            case 'o':
+              if (name[2] == 'n' &&
+                  name[3] == 't' &&
+                  name[4] == 'i' &&
+                  name[5] == 'n' &&
+                  name[6] == 'u' &&
+                  name[7] == 'e')
+              {
+                return -36;
+              }
+              goto unknown;
+            default:
+              goto unknown;
+          }
+        case 'd':
+          if (name[1] == 'b' &&
+              name[2] == 'm' &&
+              name[3] == 'c' &&
+              name[4] == 'l' &&
+              name[5] == 'o' &&
+              name[6] == 's' &&
+              name[7] == 'e')
+          {
+            return -39;
+          }
+          goto unknown;
+        case 'e':
+          if (name[1] == 'n' &&
+              name[2] == 'd')
+          {
+            switch (name[3])
+            {
+              case 'g':
+                if (name[4] == 'r' &&
+                    name[5] == 'e' &&
+                    name[6] == 'n' &&
+                    name[7] == 't')
+                {
+                  return -50;
+                }
+                goto unknown;
+              case 'p':
+                if (name[4] == 'w' &&
+                    name[5] == 'e' &&
+                    name[6] == 'n' &&
+                    name[7] == 't')
+                {
+                  return -54;
+                }
+                goto unknown;
+              default:
+                goto unknown;
+            }
+          }
+          goto unknown;
+        case 'f':
+          if (name[1] == 'o' &&
+              name[2] == 'r' &&
+              name[3] == 'm' &&
+              name[4] == 'l' &&
+              name[5] == 'i' &&
+              name[6] == 'n' &&
+              name[7] == 'e')
+          {
+            return -72;
+          }
+          goto unknown;
+        case 'g':
+          if (name[1] == 'e' &&
+              name[2] == 't')
+          {
+            switch (name[3])
+            {
+              case 'g':
+                if (name[4] == 'r')
+                {
+                  switch (name[5])
+                  {
+                    case 'e':
+                      if (name[6] == 'n' &&
+                          name[7] == 't')
+                      {
+                        return -75;
+                      }
+                      goto unknown;
+                    case 'g':
+                      if (name[6] == 'i' &&
+                          name[7] == 'd')
+                      {
+                        return -76;
+                      }
+                      goto unknown;
+                    case 'n':
+                      if (name[6] == 'a' &&
+                          name[7] == 'm')
+                      {
+                        return -77;
+                      }
+                      goto unknown;
+                    default:
+                      goto unknown;
+                  }
+                }
+                goto unknown;
+              case 'l':
+                if (name[4] == 'o' &&
+                    name[5] == 'g' &&
+                    name[6] == 'i' &&
+                    name[7] == 'n')
+                {
+                  return -81;
+                }
+                goto unknown;
+              case 'p':
+                if (name[4] == 'w')
+                {
+                  switch (name[5])
+                  {
+                    case 'e':
+                      if (name[6] == 'n' &&
+                          name[7] == 't')
+                      {
+                        return -92;
+                      }
+                      goto unknown;
+                    case 'n':
+                      if (name[6] == 'a' &&
+                          name[7] == 'm')
+                      {
+                        return -93;
+                      }
+                      goto unknown;
+                    case 'u':
+                      if (name[6] == 'i' &&
+                          name[7] == 'd')
+                      {
+                        return -94;
+                      }
+                      goto unknown;
+                    default:
+                      goto unknown;
+                  }
+                }
+                goto unknown;
+              default:
+                goto unknown;
+            }
+          }
+          goto unknown;
+        case 'r':
+          if (name[1] == 'e' &&
+              name[2] == 'a' &&
+              name[3] == 'd')
+          {
+            switch (name[4])
+            {
+              case 'l':
+                if (name[5] == 'i' &&
+                    name[6] == 'n')
+                {
+                  switch (name[7])
+                  {
+                    case 'e':
+                      {
+                        return -163;
+                      }
+                    case 'k':
+                      {
+                        return -164;
+                      }
+                    default:
+                      goto unknown;
+                  }
+                }
+                goto unknown;
+              case 'p':
+                if (name[5] == 'i' &&
+                    name[6] == 'p' &&
+                    name[7] == 'e')
+                {
+                  return -165;
+                }
+                goto unknown;
+              default:
+                goto unknown;
+            }
+          }
+          goto unknown;
+        case 's':
+          switch (name[1])
+          {
+            case 'e':
+              if (name[2] == 't')
+              {
+                switch (name[3])
+                {
+                  case 'g':
+                    if (name[4] == 'r' &&
+                        name[5] == 'e' &&
+                        name[6] == 'n' &&
+                        name[7] == 't')
+                    {
+                      return -187;
+                    }
+                    goto unknown;
+                  case 'p':
+                    if (name[4] == 'w' &&
+                        name[5] == 'e' &&
+                        name[6] == 'n' &&
+                        name[7] == 't')
+                    {
+                      return -193;
+                    }
+                    goto unknown;
+                  default:
+                    goto unknown;
+                }
+              }
+              goto unknown;
+            case 'h':
+              switch (name[2])
+              {
+                case 'm':
+                  if (name[3] == 'w' &&
+                      name[4] == 'r' &&
+                      name[5] == 'i' &&
+                      name[6] == 't' &&
+                      name[7] == 'e')
+                  {
+                    return -200;
+                  }
+                  goto unknown;
+                case 'u':
+                  if (name[3] == 't' &&
+                      name[4] == 'd' &&
+                      name[5] == 'o' &&
+                      name[6] == 'w' &&
+                      name[7] == 'n')
+                  {
+                    return -201;
+                  }
+                  goto unknown;
+                default:
+                  goto unknown;
+              }
+            case 'y':
+              if (name[2] == 's' &&
+                  name[3] == 'w' &&
+                  name[4] == 'r' &&
+                  name[5] == 'i' &&
+                  name[6] == 't' &&
+                  name[7] == 'e')
+              {
+                return -223;
+              }
+              goto unknown;
+            default:
+              goto unknown;
+          }
+        case 't':
+          if (name[1] == 'r' &&
+              name[2] == 'u' &&
+              name[3] == 'n' &&
+              name[4] == 'c' &&
+              name[5] == 'a' &&
+              name[6] == 't' &&
+              name[7] == 'e')
+          {
+            return -231;
+          }
+          goto unknown;
+        default:
+          goto unknown;
+      }
+    case 9:
+      switch (name[0])
+      {
+        case 'U':
+          if (name[1] == 'N' &&
+              name[2] == 'I' &&
+              name[3] == 'T' &&
+              name[4] == 'C' &&
+              name[5] == 'H' &&
+              name[6] == 'E' &&
+              name[7] == 'C' &&
+              name[8] == 'K')
+          {
+            return 9;
+          }
+          goto unknown;
+        case 'e':
+          switch (name[1])
+          {
+            case 'n':
+              if (name[2] == 'd' &&
+                  name[3] == 'n' &&
+                  name[4] == 'e' &&
+                  name[5] == 't' &&
+                  name[6] == 'e' &&
+                  name[7] == 'n' &&
+                  name[8] == 't')
+              {
+                return -52;
+              }
+              goto unknown;
+            case 'v':
+              if (name[2] == 'a' &&
+                  name[3] == 'l' &&
+                  name[4] == 'b' &&
+                  name[5] == 'y' &&
+                  name[6] == 't' &&
+                  name[7] == 'e' &&
+                  name[8] == 's')
+              {
+                return (all_keywords || ( (((PL_curcop == &PL_compiling ? PL_hints : PL_curcop->cop_hints) & 0x1c000000) >> 26) == 3 || ((((PL_curcop == &PL_compiling ? PL_hints : PL_curcop->cop_hints) & 0x1c000000) >> 26) == (0x1c000000 >> 26) && (((PL_curcop == &PL_compiling ? PL_hints : PL_curcop->cop_hints) & 0x00020000) ? Perl_feature_is_enabled( ("" "evalbytes" ""), (sizeof("evalbytes")-1)) : (0))) ) ? -59 : 0);
+              }
+              goto unknown;
+            default:
+              goto unknown;
+          }
+        case 'g':
+          if (name[1] == 'e' &&
+              name[2] == 't' &&
+              name[3] == 'n' &&
+              name[4] == 'e' &&
+              name[5] == 't' &&
+              name[6] == 'e' &&
+              name[7] == 'n' &&
+              name[8] == 't')
+          {
+            return -84;
+          }
+          goto unknown;
+        case 'l':
+          if (name[1] == 'o' &&
+              name[2] == 'c' &&
+              name[3] == 'a' &&
+              name[4] == 'l' &&
+              name[5] == 't' &&
+              name[6] == 'i' &&
+              name[7] == 'm' &&
+              name[8] == 'e')
+          {
+            return -122;
+          }
+          goto unknown;
+        case 'p':
+          if (name[1] == 'r' &&
+              name[2] == 'o' &&
+              name[3] == 't' &&
+              name[4] == 'o' &&
+              name[5] == 't' &&
+              name[6] == 'y' &&
+              name[7] == 'p' &&
+              name[8] == 'e')
+          {
+            return 152;
+          }
+          goto unknown;
+        case 'q':
+          if (name[1] == 'u' &&
+              name[2] == 'o' &&
+              name[3] == 't' &&
+              name[4] == 'e' &&
+              name[5] == 'm' &&
+              name[6] == 'e' &&
+              name[7] == 't' &&
+              name[8] == 'a')
+          {
+            return -157;
+          }
+          goto unknown;
+        case 'r':
+          if (name[1] == 'e' &&
+              name[2] == 'w' &&
+              name[3] == 'i' &&
+              name[4] == 'n' &&
+              name[5] == 'd' &&
+              name[6] == 'd' &&
+              name[7] == 'i' &&
+              name[8] == 'r')
+          {
+            return -174;
+          }
+          goto unknown;
+        case 's':
+          if (name[1] == 'e' &&
+              name[2] == 't' &&
+              name[3] == 'n' &&
+              name[4] == 'e' &&
+              name[5] == 't' &&
+              name[6] == 'e' &&
+              name[7] == 'n' &&
+              name[8] == 't')
+          {
+            return -189;
+          }
+          goto unknown;
+        case 'w':
+          if (name[1] == 'a' &&
+              name[2] == 'n' &&
+              name[3] == 't' &&
+              name[4] == 'a' &&
+              name[5] == 'r' &&
+              name[6] == 'r' &&
+              name[7] == 'a' &&
+              name[8] == 'y')
+          {
+            return -248;
+          }
+          goto unknown;
+        default:
+          goto unknown;
+      }
+    case 10:
+      switch (name[0])
+      {
+        case 'e':
+          if (name[1] == 'n' &&
+              name[2] == 'd')
+          {
+            switch (name[3])
+            {
+              case 'h':
+                if (name[4] == 'o' &&
+                    name[5] == 's' &&
+                    name[6] == 't' &&
+                    name[7] == 'e' &&
+                    name[8] == 'n' &&
+                    name[9] == 't')
+                {
+                  return -51;
+                }
+                goto unknown;
+              case 's':
+                if (name[4] == 'e' &&
+                    name[5] == 'r' &&
+                    name[6] == 'v' &&
+                    name[7] == 'e' &&
+                    name[8] == 'n' &&
+                    name[9] == 't')
+                {
+                  return -55;
+                }
+                goto unknown;
+              default:
+                goto unknown;
+            }
+          }
+          goto unknown;
+        case 'g':
+          if (name[1] == 'e' &&
+              name[2] == 't')
+          {
+            switch (name[3])
+            {
+              case 'h':
+                if (name[4] == 'o' &&
+                    name[5] == 's' &&
+                    name[6] == 't' &&
+                    name[7] == 'e' &&
+                    name[8] == 'n' &&
+                    name[9] == 't')
+                {
+                  return -80;
+                }
+                goto unknown;
+              case 's':
+                switch (name[4])
+                {
+                  case 'e':
+                    if (name[5] == 'r' &&
+                        name[6] == 'v' &&
+                        name[7] == 'e' &&
+                        name[8] == 'n' &&
+                        name[9] == 't')
+                    {
+                      return -97;
+                    }
+                    goto unknown;
+                  case 'o':
+                    if (name[5] == 'c' &&
+                        name[6] == 'k' &&
+                        name[7] == 'o' &&
+                        name[8] == 'p' &&
+                        name[9] == 't')
+                    {
+                      return -99;
+                    }
+                    goto unknown;
+                  default:
+                    goto unknown;
+                }
+              default:
+                goto unknown;
+            }
+          }
+          goto unknown;
+        case 's':
+          switch (name[1])
+          {
+            case 'e':
+              if (name[2] == 't')
+              {
+                switch (name[3])
+                {
+                  case 'h':
+                    if (name[4] == 'o' &&
+                        name[5] == 's' &&
+                        name[6] == 't' &&
+                        name[7] == 'e' &&
+                        name[8] == 'n' &&
+                        name[9] == 't')
+                    {
+                      return -188;
+                    }
+                    goto unknown;
+                  case 's':
+                    switch (name[4])
+                    {
+                      case 'e':
+                        if (name[5] == 'r' &&
+                            name[6] == 'v' &&
+                            name[7] == 'e' &&
+                            name[8] == 'n' &&
+                            name[9] == 't')
+                        {
+                          return -194;
+                        }
+                        goto unknown;
+                      case 'o':
+                        if (name[5] == 'c' &&
+                            name[6] == 'k' &&
+                            name[7] == 'o' &&
+                            name[8] == 'p' &&
+                            name[9] == 't')
+                        {
+                          return -195;
+                        }
+                        goto unknown;
+                      default:
+                        goto unknown;
+                    }
+                  default:
+                    goto unknown;
+                }
+              }
+              goto unknown;
+            case 'o':
+              if (name[2] == 'c' &&
+                  name[3] == 'k' &&
+                  name[4] == 'e' &&
+                  name[5] == 't' &&
+                  name[6] == 'p' &&
+                  name[7] == 'a' &&
+                  name[8] == 'i' &&
+                  name[9] == 'r')
+              {
+                return -205;
+              }
+              goto unknown;
+            default:
+              goto unknown;
+          }
+        default:
+          goto unknown;
+      }
+    case 11:
+      switch (name[0])
+      {
+        case '_':
+          if (name[1] == '_' &&
+              name[2] == 'P' &&
+              name[3] == 'A' &&
+              name[4] == 'C' &&
+              name[5] == 'K' &&
+              name[6] == 'A' &&
+              name[7] == 'G' &&
+              name[8] == 'E' &&
+              name[9] == '_' &&
+              name[10] == '_')
+          {
+            return -3;
+          }
+          goto unknown;
+        case 'e':
+          if (name[1] == 'n' &&
+              name[2] == 'd' &&
+              name[3] == 'p' &&
+              name[4] == 'r' &&
+              name[5] == 'o' &&
+              name[6] == 't' &&
+              name[7] == 'o' &&
+              name[8] == 'e' &&
+              name[9] == 'n' &&
+              name[10] == 't')
+          {
+            return -53;
+          }
+          goto unknown;
+        case 'g':
+          if (name[1] == 'e' &&
+              name[2] == 't')
+          {
+            switch (name[3])
+            {
+              case 'p':
+                switch (name[4])
+                {
+                  case 'e':
+                    if (name[5] == 'e' &&
+                        name[6] == 'r' &&
+                        name[7] == 'n' &&
+                        name[8] == 'a' &&
+                        name[9] == 'm' &&
+                        name[10] == 'e')
+                    {
+                      return -85;
+                    }
+                    goto unknown;
+                  case 'r':
+                    switch (name[5])
+                    {
+                      case 'i':
+                        if (name[6] == 'o' &&
+                            name[7] == 'r' &&
+                            name[8] == 'i' &&
+                            name[9] == 't' &&
+                            name[10] == 'y')
+                        {
+                          return -88;
+                        }
+                        goto unknown;
+                      case 'o':
+                        if (name[6] == 't' &&
+                            name[7] == 'o' &&
+                            name[8] == 'e' &&
+                            name[9] == 'n' &&
+                            name[10] == 't')
+                        {
+                          return -91;
+                        }
+                        goto unknown;
+                      default:
+                        goto unknown;
+                    }
+                  default:
+                    goto unknown;
+                }
+              case 's':
+                if (name[4] == 'o' &&
+                    name[5] == 'c' &&
+                    name[6] == 'k' &&
+                    name[7] == 'n' &&
+                    name[8] == 'a' &&
+                    name[9] == 'm' &&
+                    name[10] == 'e')
+                {
+                  return -98;
+                }
+                goto unknown;
+              default:
+                goto unknown;
+            }
+          }
+          goto unknown;
+        case 's':
+          if (name[1] == 'e' &&
+              name[2] == 't' &&
+              name[3] == 'p' &&
+              name[4] == 'r')
+          {
+            switch (name[5])
+            {
+              case 'i':
+                if (name[6] == 'o' &&
+                    name[7] == 'r' &&
+                    name[8] == 'i' &&
+                    name[9] == 't' &&
+                    name[10] == 'y')
+                {
+                  return -191;
+                }
+                goto unknown;
+              case 'o':
+                if (name[6] == 't' &&
+                    name[7] == 'o' &&
+                    name[8] == 'e' &&
+                    name[9] == 'n' &&
+                    name[10] == 't')
+                {
+                  return -192;
+                }
+                goto unknown;
+              default:
+                goto unknown;
+            }
+          }
+          goto unknown;
+        default:
+          goto unknown;
+      }
+    case 12:
+      if (name[0] == 'g' &&
+          name[1] == 'e' &&
+          name[2] == 't' &&
+          name[3] == 'n' &&
+          name[4] == 'e' &&
+          name[5] == 't' &&
+          name[6] == 'b' &&
+          name[7] == 'y')
+      {
+        switch (name[8])
+        {
+          case 'a':
+            if (name[9] == 'd' &&
+                name[10] == 'd' &&
+                name[11] == 'r')
+            {
+              return -82;
+            }
+            goto unknown;
+          case 'n':
+            if (name[9] == 'a' &&
+                name[10] == 'm' &&
+                name[11] == 'e')
+            {
+              return -83;
+            }
+            goto unknown;
+          default:
+            goto unknown;
+        }
+      }
+      goto unknown;
+    case 13:
+      if (name[0] == 'g' &&
+          name[1] == 'e' &&
+          name[2] == 't')
+      {
+        switch (name[3])
+        {
+          case 'h':
+            if (name[4] == 'o' &&
+                name[5] == 's' &&
+                name[6] == 't' &&
+                name[7] == 'b' &&
+                name[8] == 'y')
+            {
+              switch (name[9])
+              {
+                case 'a':
+                  if (name[10] == 'd' &&
+                      name[11] == 'd' &&
+                      name[12] == 'r')
+                  {
+                    return -78;
+                  }
+                  goto unknown;
+                case 'n':
+                  if (name[10] == 'a' &&
+                      name[11] == 'm' &&
+                      name[12] == 'e')
+                  {
+                    return -79;
+                  }
+                  goto unknown;
+                default:
+                  goto unknown;
+              }
+            }
+            goto unknown;
+          case 's':
+            if (name[4] == 'e' &&
+                name[5] == 'r' &&
+                name[6] == 'v' &&
+                name[7] == 'b' &&
+                name[8] == 'y')
+            {
+              switch (name[9])
+              {
+                case 'n':
+                  if (name[10] == 'a' &&
+                      name[11] == 'm' &&
+                      name[12] == 'e')
+                  {
+                    return -95;
+                  }
+                  goto unknown;
+                case 'p':
+                  if (name[10] == 'o' &&
+                      name[11] == 'r' &&
+                      name[12] == 't')
+                  {
+                    return -96;
+                  }
+                  goto unknown;
+                default:
+                  goto unknown;
+              }
+            }
+            goto unknown;
+          default:
+            goto unknown;
+        }
+      }
+      goto unknown;
+    case 14:
+      if (name[0] == 'g' &&
+          name[1] == 'e' &&
+          name[2] == 't' &&
+          name[3] == 'p' &&
+          name[4] == 'r' &&
+          name[5] == 'o' &&
+          name[6] == 't' &&
+          name[7] == 'o' &&
+          name[8] == 'b' &&
+          name[9] == 'y' &&
+          name[10] == 'n' &&
+          name[11] == 'a' &&
+          name[12] == 'm' &&
+          name[13] == 'e')
+      {
+        return -89;
+      }
+      goto unknown;
+    case 16:
+      if (name[0] == 'g' &&
+          name[1] == 'e' &&
+          name[2] == 't' &&
+          name[3] == 'p' &&
+          name[4] == 'r' &&
+          name[5] == 'o' &&
+          name[6] == 't' &&
+          name[7] == 'o' &&
+          name[8] == 'b' &&
+          name[9] == 'y' &&
+          name[10] == 'n' &&
+          name[11] == 'u' &&
+          name[12] == 'm' &&
+          name[13] == 'b' &&
+          name[14] == 'e' &&
+          name[15] == 'r')
+      {
+        return -90;
+      }
+      goto unknown;
+    default:
+      goto unknown;
+  }
+unknown:
+  return 0;
+}
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.target/sh/torture/pr245080.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.target/sh/torture/pr245080.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.target/sh/torture/pr245080.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.target/sh/torture/pr245080.c	2014-01-29 12:57:17.000000000 +0100
@@ -0,0 +1,28105 @@
+/* { dg-options "" } */
+
+typedef unsigned char U8;
+typedef unsigned short U16;
+typedef unsigned int U32;
+typedef signed char S8;
+typedef signed short S16;
+typedef signed int S32;
+struct ftrace_branch_data {
+ const char *func;
+ const char *file;
+ unsigned line;
+ union {
+  struct {
+   unsigned long correct;
+   unsigned long incorrect;
+  };
+  struct {
+   unsigned long miss;
+   unsigned long hit;
+  };
+  unsigned long miss_hit[2];
+ };
+};
+enum {
+ false = 0,
+ true = 1
+};
+typedef __signed__ char __s8;
+typedef unsigned char __u8;
+typedef __signed__ short __s16;
+typedef unsigned short __u16;
+typedef __signed__ int __s32;
+typedef unsigned int __u32;
+__extension__ typedef __signed__ long long __s64;
+__extension__ typedef unsigned long long __u64;
+typedef signed char s8;
+typedef unsigned char u8;
+typedef signed short s16;
+typedef unsigned short u16;
+typedef signed int s32;
+typedef unsigned int u32;
+typedef signed long long s64;
+typedef unsigned long long u64;
+typedef unsigned short umode_t;
+typedef u32 dma_addr_t;
+typedef u16 insn_size_t;
+typedef u32 reg_size_t;
+typedef struct {
+ unsigned long fds_bits [(1024/(8 * sizeof(unsigned long)))];
+} __kernel_fd_set;
+typedef void (*__kernel_sighandler_t)(int);
+typedef int __kernel_key_t;
+typedef int __kernel_mqd_t;
+typedef unsigned short __kernel_mode_t;
+typedef unsigned short __kernel_nlink_t;
+typedef unsigned short __kernel_ipc_pid_t;
+typedef unsigned short __kernel_uid_t;
+typedef unsigned short __kernel_gid_t;
+typedef unsigned int __kernel_uid32_t;
+typedef unsigned int __kernel_gid32_t;
+typedef unsigned short __kernel_old_uid_t;
+typedef unsigned short __kernel_old_gid_t;
+typedef unsigned short __kernel_old_dev_t;
+typedef unsigned long __kernel_ino_t;
+typedef int __kernel_pid_t;
+typedef long __kernel_suseconds_t;
+typedef int __kernel_daddr_t;
+typedef unsigned int __kernel_size_t;
+typedef int __kernel_ssize_t;
+typedef int __kernel_ptrdiff_t;
+typedef long __kernel_off_t;
+typedef long long __kernel_loff_t;
+typedef long __kernel_time_t;
+typedef long __kernel_clock_t;
+typedef int __kernel_timer_t;
+typedef int __kernel_clockid_t;
+typedef char * __kernel_caddr_t;
+typedef unsigned short __kernel_uid16_t;
+typedef unsigned short __kernel_gid16_t;
+typedef struct {
+ int val[2];
+} __kernel_fsid_t;
+static inline __attribute__((always_inline)) void __FD_SET(unsigned long __fd, __kernel_fd_set *__fdsetp)
+{
+ unsigned long __tmp = __fd / (8 * sizeof(unsigned long));
+ unsigned long __rem = __fd % (8 * sizeof(unsigned long));
+ __fdsetp->fds_bits[__tmp] |= (1UL<<__rem);
+}
+static inline __attribute__((always_inline)) void __FD_CLR(unsigned long __fd, __kernel_fd_set *__fdsetp)
+{
+ unsigned long __tmp = __fd / (8 * sizeof(unsigned long));
+ unsigned long __rem = __fd % (8 * sizeof(unsigned long));
+ __fdsetp->fds_bits[__tmp] &= ~(1UL<<__rem);
+}
+static inline __attribute__((always_inline)) int __FD_ISSET(unsigned long __fd, const __kernel_fd_set *__p)
+{
+ unsigned long __tmp = __fd / (8 * sizeof(unsigned long));
+ unsigned long __rem = __fd % (8 * sizeof(unsigned long));
+ return (__p->fds_bits[__tmp] & (1UL<<__rem)) != 0;
+}
+static inline __attribute__((always_inline)) void __FD_ZERO(__kernel_fd_set *__p)
+{
+ unsigned long *__tmp = __p->fds_bits;
+ int __i;
+ if (__builtin_constant_p((1024/(8 * sizeof(unsigned long))))) {
+  switch ((1024/(8 * sizeof(unsigned long)))) {
+  case 16:
+   __tmp[ 0] = 0; __tmp[ 1] = 0;
+   __tmp[ 2] = 0; __tmp[ 3] = 0;
+   __tmp[ 4] = 0; __tmp[ 5] = 0;
+   __tmp[ 6] = 0; __tmp[ 7] = 0;
+   __tmp[ 8] = 0; __tmp[ 9] = 0;
+   __tmp[10] = 0; __tmp[11] = 0;
+   __tmp[12] = 0; __tmp[13] = 0;
+   __tmp[14] = 0; __tmp[15] = 0;
+   return;
+  case 8:
+   __tmp[ 0] = 0; __tmp[ 1] = 0;
+   __tmp[ 2] = 0; __tmp[ 3] = 0;
+   __tmp[ 4] = 0; __tmp[ 5] = 0;
+   __tmp[ 6] = 0; __tmp[ 7] = 0;
+   return;
+  case 4:
+   __tmp[ 0] = 0; __tmp[ 1] = 0;
+   __tmp[ 2] = 0; __tmp[ 3] = 0;
+   return;
+  }
+ }
+ __i = (1024/(8 * sizeof(unsigned long)));
+ while (__i) {
+  __i--;
+  *__tmp = 0;
+  __tmp++;
+ }
+}
+typedef __u32 __kernel_dev_t;
+typedef __kernel_fd_set fd_set;
+typedef __kernel_dev_t dev_t;
+typedef __kernel_ino_t ino_t;
+typedef __kernel_mode_t mode_t;
+typedef __kernel_nlink_t nlink_t;
+typedef __kernel_off_t off_t;
+typedef __kernel_pid_t pid_t;
+typedef __kernel_daddr_t daddr_t;
+typedef __kernel_key_t key_t;
+typedef __kernel_suseconds_t suseconds_t;
+typedef __kernel_timer_t timer_t;
+typedef __kernel_clockid_t clockid_t;
+typedef __kernel_mqd_t mqd_t;
+typedef _Bool bool;
+typedef __kernel_uid32_t uid_t;
+typedef __kernel_gid32_t gid_t;
+typedef __kernel_uid16_t uid16_t;
+typedef __kernel_gid16_t gid16_t;
+typedef unsigned long uintptr_t;
+typedef __kernel_old_uid_t old_uid_t;
+typedef __kernel_old_gid_t old_gid_t;
+typedef __kernel_loff_t loff_t;
+typedef __kernel_size_t size_t;
+typedef __kernel_ssize_t ssize_t;
+typedef __kernel_ptrdiff_t ptrdiff_t;
+typedef __kernel_time_t time_t;
+typedef __kernel_clock_t clock_t;
+typedef __kernel_caddr_t caddr_t;
+typedef unsigned char u_char;
+typedef unsigned short u_short;
+typedef unsigned int u_int;
+typedef unsigned long u_long;
+typedef unsigned char unchar;
+typedef unsigned short ushort;
+typedef unsigned int uint;
+typedef unsigned long ulong;
+typedef __u8 u_int8_t;
+typedef __s8 int8_t;
+typedef __u16 u_int16_t;
+typedef __s16 int16_t;
+typedef __u32 u_int32_t;
+typedef __s32 int32_t;
+typedef __u8 uint8_t;
+typedef __u16 uint16_t;
+typedef __u32 uint32_t;
+typedef __u64 uint64_t;
+typedef __u64 u_int64_t;
+typedef __s64 int64_t;
+typedef u64 sector_t;
+typedef u64 blkcnt_t;
+typedef __u16 __le16;
+typedef __u16 __be16;
+typedef __u32 __le32;
+typedef __u32 __be32;
+typedef __u64 __le64;
+typedef __u64 __be64;
+typedef __u16 __sum16;
+typedef __u32 __wsum;
+typedef unsigned gfp_t;
+typedef unsigned fmode_t;
+typedef u32 phys_addr_t;
+typedef phys_addr_t resource_size_t;
+typedef struct {
+ volatile int counter;
+} atomic_t;
+struct ustat {
+ __kernel_daddr_t f_tfree;
+ __kernel_ino_t f_tinode;
+ char f_fname[6];
+ char f_fpack[6];
+};
+typedef struct {
+ unsigned long seg;
+} mm_segment_t;
+typedef int (*initcall_t)(void);
+typedef void (*exitcall_t)(void);
+extern initcall_t __con_initcall_start[], __con_initcall_end[];
+extern initcall_t __security_initcall_start[], __security_initcall_end[];
+typedef void (*ctor_fn_t)(void);
+extern int do_one_initcall(initcall_t fn);
+extern char __attribute__ ((__section__(".init.data"))) boot_command_line[];
+extern char *saved_command_line;
+extern unsigned int reset_devices;
+void setup_arch(char **);
+void prepare_namespace(void);
+extern void (*late_time_init)(void);
+struct cache_info {
+ unsigned int ways;
+ unsigned int sets;
+ unsigned int linesz;
+ unsigned int way_size;
+ unsigned int way_incr;
+ unsigned int entry_shift;
+ unsigned int entry_mask;
+ unsigned int alias_mask;
+ unsigned int n_aliases;
+ unsigned long flags;
+};
+int __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) __attribute__((no_instrument_function)) detect_cpu_and_cache_system(void);
+enum cpu_type {
+ CPU_SH7619,
+ CPU_SH7201, CPU_SH7203, CPU_SH7206, CPU_SH7263, CPU_MXG,
+ CPU_SH7705, CPU_SH7706, CPU_SH7707,
+ CPU_SH7708, CPU_SH7708S, CPU_SH7708R,
+ CPU_SH7709, CPU_SH7709A, CPU_SH7710, CPU_SH7712,
+ CPU_SH7720, CPU_SH7721, CPU_SH7729,
+ CPU_SH7750, CPU_SH7750S, CPU_SH7750R, CPU_SH7751, CPU_SH7751R,
+ CPU_SH7760, CPU_SH4_202, CPU_SH4_501,
+ CPU_FLI7510, CPU_FLI7520, CPU_FLI7530, CPU_FLI7540,
+ CPU_ST40RA, CPU_ST40GX1,
+ CPU_STX5197, CPU_STX5206,
+ CPU_STI5528, CPU_STM8000,
+ CPU_STX7100, CPU_STX7105, CPU_STX7106, CPU_STX7108, CPU_STX7109,
+ CPU_STX7111, CPU_STX7141, CPU_STX7200,
+ CPU_SH7763, CPU_SH7770, CPU_SH7780, CPU_SH7781, CPU_SH7785, CPU_SH7786,
+ CPU_SH7723, CPU_SH7724, CPU_SH7757, CPU_SHX3,
+ CPU_SH7343, CPU_SH7722, CPU_SH7366,
+        CPU_SH5_101, CPU_SH5_103,
+ CPU_SH_NONE
+};
+enum cpu_family {
+ CPU_FAMILY_SH2,
+ CPU_FAMILY_SH2A,
+ CPU_FAMILY_SH3,
+ CPU_FAMILY_SH4,
+ CPU_FAMILY_SH4A,
+ CPU_FAMILY_SH4AL_DSP,
+ CPU_FAMILY_SH5,
+ CPU_FAMILY_UNKNOWN,
+};
+struct tlb_info {
+ unsigned long long next;
+ unsigned long long first;
+ unsigned long long last;
+ unsigned int entries;
+ unsigned int step;
+ unsigned long flags;
+};
+struct sh_cpuinfo {
+ unsigned int type, family;
+ int cut_major, cut_minor;
+ unsigned long loops_per_jiffy;
+ unsigned long asid_cache;
+ struct cache_info icache;
+ struct cache_info dcache;
+ struct cache_info scache;
+ struct tlb_info itlb;
+ struct tlb_info dtlb;
+ unsigned long flags;
+} __attribute__ ((aligned((1 << 5))));
+extern struct sh_cpuinfo cpu_data[];
+struct seq_operations;
+extern struct pt_regs fake_swapper_regs;
+const char *get_cpu_subtype(struct sh_cpuinfo *c);
+extern const struct seq_operations cpuinfo_op;
+int generic_mode_pins(void);
+int test_mode_pin(int pin);
+extern unsigned long shm_align_mask;
+extern unsigned long max_low_pfn, min_low_pfn;
+extern unsigned long memory_start, memory_end;
+static inline __attribute__((always_inline)) unsigned long
+pages_do_alias(unsigned long addr1, unsigned long addr2)
+{
+ return (addr1 ^ addr2) & shm_align_mask;
+}
+extern void copy_page(void *to, void *from);
+struct page;
+struct vm_area_struct;
+extern void copy_user_highpage(struct page *to, struct page *from,
+          unsigned long vaddr, struct vm_area_struct *vma);
+extern void clear_user_highpage(struct page *page, unsigned long vaddr);
+typedef struct { unsigned long pte_low; } pte_t;
+typedef struct { unsigned long pgprot; } pgprot_t;
+typedef struct { unsigned long pgd; } pgd_t;
+typedef struct page *pgtable_t;
+static inline __attribute__((always_inline)) __attribute__((__const__)) int get_order(unsigned long size)
+{
+ int order;
+ size = (size - 1) >> (12 - 1);
+ order = -1;
+ do {
+  size >>= 1;
+  order++;
+ } while (size);
+ return order;
+}
+struct pt_regs {
+ unsigned long regs[16];
+ unsigned long pc;
+ unsigned long pr;
+ unsigned long sr;
+ unsigned long gbr;
+ unsigned long mach;
+ unsigned long macl;
+ long tra;
+};
+struct pt_dspregs {
+ unsigned long a1;
+ unsigned long a0g;
+ unsigned long a1g;
+ unsigned long m0;
+ unsigned long m1;
+ unsigned long a0;
+ unsigned long x0;
+ unsigned long x1;
+ unsigned long y0;
+ unsigned long y1;
+ unsigned long dsr;
+ unsigned long rs;
+ unsigned long re;
+ unsigned long mod;
+};
+extern void show_regs(struct pt_regs *);
+struct task_struct;
+extern void user_enable_single_step(struct task_struct *);
+extern void user_disable_single_step(struct task_struct *);
+static inline __attribute__((always_inline)) unsigned long profile_pc(struct pt_regs *regs)
+{
+ unsigned long pc = ((unsigned long)(regs)->pc);
+ if (pc >= 0xa0000000 && pc < 0xc0000000)
+  pc -= 0x20000000;
+ return pc;
+}
+ void __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) __attribute__((no_instrument_function)) sh_cpu_init(void);
+struct sh_dsp_struct {
+ unsigned long dsp_regs[14];
+ long status;
+};
+struct sh_fpu_hard_struct {
+ unsigned long fp_regs[16];
+ unsigned long xfp_regs[16];
+ unsigned long fpscr;
+ unsigned long fpul;
+ long status;
+};
+struct sh_fpu_soft_struct {
+ unsigned long fp_regs[16];
+ unsigned long xfp_regs[16];
+ unsigned long fpscr;
+ unsigned long fpul;
+ unsigned char lookahead;
+ unsigned long entry_pc;
+};
+union sh_fpu_union {
+ struct sh_fpu_hard_struct hard;
+ struct sh_fpu_soft_struct soft;
+};
+struct thread_struct {
+ unsigned long sp;
+ unsigned long pc;
+ unsigned long ubc_pc;
+ union sh_fpu_union fpu;
+};
+extern int ubc_usercnt;
+struct task_struct;
+struct mm_struct;
+extern void release_thread(struct task_struct *);
+void prepare_to_copy(struct task_struct *tsk);
+extern int kernel_thread(int (*fn)(void *), void * arg, unsigned long flags);
+static __inline__ __attribute__((always_inline)) void disable_fpu(void)
+{
+ unsigned long __dummy;
+ __asm__ __volatile__("stc	sr, %0\n\t"
+        "or	%1, %0\n\t"
+        "ldc	%0, sr"
+        : "=&r" (__dummy)
+        : "r" (0x00008000));
+}
+static __inline__ __attribute__((always_inline)) void enable_fpu(void)
+{
+ unsigned long __dummy;
+ __asm__ __volatile__("stc	sr, %0\n\t"
+        "and	%1, %0\n\t"
+        "ldc	%0, sr"
+        : "=&r" (__dummy)
+        : "r" (~0x00008000));
+}
+void show_trace(struct task_struct *tsk, unsigned long *sp,
+  struct pt_regs *regs);
+static inline __attribute__((always_inline)) void show_code(struct pt_regs *regs)
+{
+}
+extern unsigned long get_wchan(struct task_struct *p);
+static inline __attribute__((always_inline)) void prefetch(void *x)
+{
+ __builtin_prefetch(x, 0, 3);
+}
+static inline __attribute__((always_inline)) void prefetchw(void *x)
+{
+ __builtin_prefetch(x, 1, 3);
+}
+static inline __attribute__((always_inline)) void prefetch_range(void *addr, size_t len)
+{
+ char *cp;
+ char *end = addr + len;
+ for (cp = addr; cp < end; cp += (1 << 5))
+  prefetch(cp);
+}
+static inline __attribute__((always_inline)) void raw_local_irq_enable(void)
+{
+ unsigned long __dummy0, __dummy1;
+ __asm__ __volatile__ (
+  "stc	sr, %0\n\t"
+  "and	%1, %0\n\t"
+  "stc	r6_bank, %1\n\t"
+  "or	%1, %0\n\t"
+  "ldc	%0, sr\n\t"
+  : "=&r" (__dummy0), "=r" (__dummy1)
+  : "1" (~0x000000f0)
+  : "memory"
+ );
+}
+static inline __attribute__((always_inline)) void raw_local_irq_disable(void)
+{
+ unsigned long flags;
+ __asm__ __volatile__ (
+  "stc	sr, %0\n\t"
+  "or	#0xf0, %0\n\t"
+  "ldc	%0, sr\n\t"
+  : "=&z" (flags)
+  :
+  : "memory"
+ );
+}
+static inline __attribute__((always_inline)) void set_bl_bit(void)
+{
+ unsigned long __dummy0, __dummy1;
+ __asm__ __volatile__ (
+  "stc	sr, %0\n\t"
+  "or	%2, %0\n\t"
+  "and	%3, %0\n\t"
+  "ldc	%0, sr\n\t"
+  : "=&r" (__dummy0), "=r" (__dummy1)
+  : "r" (0x10000000), "r" (0xffffff0f)
+  : "memory"
+ );
+}
+static inline __attribute__((always_inline)) void clear_bl_bit(void)
+{
+ unsigned long __dummy0, __dummy1;
+ __asm__ __volatile__ (
+  "stc	sr, %0\n\t"
+  "and	%2, %0\n\t"
+  "ldc	%0, sr\n\t"
+  : "=&r" (__dummy0), "=r" (__dummy1)
+  : "1" (~0x10000000)
+  : "memory"
+ );
+}
+static inline __attribute__((always_inline)) unsigned long __raw_local_save_flags(void)
+{
+ unsigned long flags;
+ __asm__ __volatile__ (
+  "stc	sr, %0\n\t"
+  "and	#0xf0, %0\n\t"
+  : "=&z" (flags)
+  :
+  : "memory"
+ );
+ return flags;
+}
+static inline __attribute__((always_inline)) unsigned long __raw_local_irq_save(void)
+{
+ unsigned long flags, __dummy;
+ __asm__ __volatile__ (
+  "stc	sr, %1\n\t"
+  "mov	%1, %0\n\t"
+  "or	#0xf0, %0\n\t"
+  "ldc	%0, sr\n\t"
+  "mov	%1, %0\n\t"
+  "and	#0xf0, %0\n\t"
+  : "=&z" (flags), "=&r" (__dummy)
+  :
+  : "memory"
+ );
+ return flags;
+}
+static inline __attribute__((always_inline)) int raw_irqs_disabled_flags(unsigned long flags)
+{
+ return (flags != 0);
+}
+static inline __attribute__((always_inline)) int raw_irqs_disabled(void)
+{
+ unsigned long flags = __raw_local_save_flags();
+ return raw_irqs_disabled_flags(flags);
+}
+static inline __attribute__((always_inline)) void raw_local_irq_restore(unsigned long flags)
+{
+ if ((flags & 0xf0) != 0xf0)
+  raw_local_irq_enable();
+}
+static inline __attribute__((always_inline)) unsigned long xchg_u32(volatile u32 *m, unsigned long val)
+{
+ unsigned long flags, retval;
+ do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); do { (flags) = __raw_local_irq_save(); } while (0); do { } while (0); } while (0);
+ retval = *m;
+ *m = val;
+ do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); if (raw_irqs_disabled_flags(flags)) { raw_local_irq_restore(flags); do { } while (0); } else { do { } while (0); raw_local_irq_restore(flags); } } while (0);
+ return retval;
+}
+static inline __attribute__((always_inline)) unsigned long xchg_u8(volatile u8 *m, unsigned long val)
+{
+ unsigned long flags, retval;
+ do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); do { (flags) = __raw_local_irq_save(); } while (0); do { } while (0); } while (0);
+ retval = *m;
+ *m = val & 0xff;
+ do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); if (raw_irqs_disabled_flags(flags)) { raw_local_irq_restore(flags); do { } while (0); } else { do { } while (0); raw_local_irq_restore(flags); } } while (0);
+ return retval;
+}
+static inline __attribute__((always_inline)) unsigned long __cmpxchg_u32(volatile int *m, unsigned long old,
+ unsigned long new)
+{
+ __u32 retval;
+ unsigned long flags;
+ do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); do { (flags) = __raw_local_irq_save(); } while (0); do { } while (0); } while (0);
+ retval = *m;
+ if (retval == old)
+  *m = new;
+ do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); if (raw_irqs_disabled_flags(flags)) { raw_local_irq_restore(flags); do { } while (0); } else { do { } while (0); raw_local_irq_restore(flags); } } while (0);
+ return retval;
+}
+extern void __xchg_called_with_bad_pointer(void);
+extern void __cmpxchg_called_with_bad_pointer(void);
+static inline __attribute__((always_inline)) unsigned long __cmpxchg(volatile void * ptr, unsigned long old,
+  unsigned long new, int size)
+{
+ switch (size) {
+ case 4:
+  return __cmpxchg_u32(ptr, old, new);
+ }
+ __cmpxchg_called_with_bad_pointer();
+ return old;
+}
+extern void die(const char *str, struct pt_regs *regs, long err) __attribute__ ((noreturn));
+void free_initmem(void);
+void free_initrd_mem(unsigned long start, unsigned long end);
+extern void *set_exception_table_vec(unsigned int vec, void *handler);
+static inline __attribute__((always_inline)) void *set_exception_table_evt(unsigned int evt, void *handler)
+{
+ return set_exception_table_vec(evt >> 5, handler);
+}
+extern unsigned long cached_to_uncached;
+extern struct dentry *sh_debugfs_root;
+void disable_hlt(void);
+void enable_hlt(void);
+void per_cpu_trap_init(void);
+void default_idle(void);
+void cpu_idle_wait(void);
+ void break_point_trap(void);
+ void address_error_trap_handler(unsigned long r4, unsigned long r5, unsigned long r6, unsigned long r7, struct pt_regs __regs);
+ void debug_trap_handler(unsigned long r4, unsigned long r5, unsigned long r6, unsigned long r7, struct pt_regs __regs);
+ void bug_trap_handler(unsigned long r4, unsigned long r5, unsigned long r6, unsigned long r7, struct pt_regs __regs);
+ void breakpoint_trap_handler(unsigned long r4, unsigned long r5, unsigned long r6, unsigned long r7, struct pt_regs __regs);
+ void singlestep_trap_handler(unsigned long r4, unsigned long r5, unsigned long r6, unsigned long r7, struct pt_regs __regs);
+ void fpu_error_trap_handler(unsigned long r4, unsigned long r5, unsigned long r6, unsigned long r7, struct pt_regs __regs);
+ void fpu_state_restore_trap_handler(unsigned long r4, unsigned long r5, unsigned long r6, unsigned long r7, struct pt_regs __regs);
+ void nmi_trap_handler(unsigned long r4, unsigned long r5, unsigned long r6, unsigned long r7, struct pt_regs __regs);
+extern void handle_BUG(struct pt_regs *);
+struct mem_access {
+ unsigned long (*from)(void *dst, const void *src, unsigned long cnt);
+ unsigned long (*to)(void *dst, const void *src, unsigned long cnt);
+};
+struct task_struct *__switch_to(struct task_struct *prev,
+    struct task_struct *next);
+static inline __attribute__((always_inline)) reg_size_t register_align(void *val)
+{
+ return (unsigned long)(signed long)val;
+}
+int handle_unaligned_access(insn_size_t instruction, struct pt_regs *regs,
+       struct mem_access *ma, int);
+ void do_address_error(struct pt_regs *regs,
+     unsigned long writeaccess,
+     unsigned long address);
+ void do_divide_error(unsigned long r4, unsigned long r5,
+    unsigned long r6, unsigned long r7,
+    struct pt_regs __regs);
+ void do_reserved_inst(unsigned long r4, unsigned long r5,
+    unsigned long r6, unsigned long r7,
+    struct pt_regs __regs);
+ void do_illegal_slot_inst(unsigned long r4, unsigned long r5,
+    unsigned long r6, unsigned long r7,
+    struct pt_regs __regs);
+ void do_exception_error(unsigned long r4, unsigned long r5,
+       unsigned long r6, unsigned long r7,
+       struct pt_regs __regs);
+struct list_head {
+ struct list_head *next, *prev;
+};
+static inline __attribute__((always_inline)) void INIT_LIST_HEAD(struct list_head *list)
+{
+ list->next = list;
+ list->prev = list;
+}
+static inline __attribute__((always_inline)) void __list_add(struct list_head *new,
+         struct list_head *prev,
+         struct list_head *next)
+{
+ next->prev = new;
+ new->next = next;
+ new->prev = prev;
+ prev->next = new;
+}
+static inline __attribute__((always_inline)) void list_add(struct list_head *new, struct list_head *head)
+{
+ __list_add(new, head, head->next);
+}
+static inline __attribute__((always_inline)) void list_add_tail(struct list_head *new, struct list_head *head)
+{
+ __list_add(new, head->prev, head);
+}
+static inline __attribute__((always_inline)) void __list_del(struct list_head * prev, struct list_head * next)
+{
+ next->prev = prev;
+ prev->next = next;
+}
+static inline __attribute__((always_inline)) void list_del(struct list_head *entry)
+{
+ __list_del(entry->prev, entry->next);
+ entry->next = ((void *) 0x00100100 + 0);
+ entry->prev = ((void *) 0x00200200 + 0);
+}
+static inline __attribute__((always_inline)) void list_replace(struct list_head *old,
+    struct list_head *new)
+{
+ new->next = old->next;
+ new->next->prev = new;
+ new->prev = old->prev;
+ new->prev->next = new;
+}
+static inline __attribute__((always_inline)) void list_replace_init(struct list_head *old,
+     struct list_head *new)
+{
+ list_replace(old, new);
+ INIT_LIST_HEAD(old);
+}
+static inline __attribute__((always_inline)) void list_del_init(struct list_head *entry)
+{
+ __list_del(entry->prev, entry->next);
+ INIT_LIST_HEAD(entry);
+}
+static inline __attribute__((always_inline)) void list_move(struct list_head *list, struct list_head *head)
+{
+ __list_del(list->prev, list->next);
+ list_add(list, head);
+}
+static inline __attribute__((always_inline)) void list_move_tail(struct list_head *list,
+      struct list_head *head)
+{
+ __list_del(list->prev, list->next);
+ list_add_tail(list, head);
+}
+static inline __attribute__((always_inline)) int list_is_last(const struct list_head *list,
+    const struct list_head *head)
+{
+ return list->next == head;
+}
+static inline __attribute__((always_inline)) int list_empty(const struct list_head *head)
+{
+ return head->next == head;
+}
+static inline __attribute__((always_inline)) int list_empty_careful(const struct list_head *head)
+{
+ struct list_head *next = head->next;
+ return (next == head) && (next == head->prev);
+}
+static inline __attribute__((always_inline)) int list_is_singular(const struct list_head *head)
+{
+ return !list_empty(head) && (head->next == head->prev);
+}
+static inline __attribute__((always_inline)) void __list_cut_position(struct list_head *list,
+  struct list_head *head, struct list_head *entry)
+{
+ struct list_head *new_first = entry->next;
+ list->next = head->next;
+ list->next->prev = list;
+ list->prev = entry;
+ entry->next = list;
+ head->next = new_first;
+ new_first->prev = head;
+}
+static inline __attribute__((always_inline)) void list_cut_position(struct list_head *list,
+  struct list_head *head, struct list_head *entry)
+{
+ if (list_empty(head))
+  return;
+ if (list_is_singular(head) &&
+  (head->next != entry && head != entry))
+  return;
+ if (entry == head)
+  INIT_LIST_HEAD(list);
+ else
+  __list_cut_position(list, head, entry);
+}
+static inline __attribute__((always_inline)) void __list_splice(const struct list_head *list,
+     struct list_head *prev,
+     struct list_head *next)
+{
+ struct list_head *first = list->next;
+ struct list_head *last = list->prev;
+ first->prev = prev;
+ prev->next = first;
+ last->next = next;
+ next->prev = last;
+}
+static inline __attribute__((always_inline)) void list_splice(const struct list_head *list,
+    struct list_head *head)
+{
+ if (!list_empty(list))
+  __list_splice(list, head, head->next);
+}
+static inline __attribute__((always_inline)) void list_splice_tail(struct list_head *list,
+    struct list_head *head)
+{
+ if (!list_empty(list))
+  __list_splice(list, head->prev, head);
+}
+static inline __attribute__((always_inline)) void list_splice_init(struct list_head *list,
+        struct list_head *head)
+{
+ if (!list_empty(list)) {
+  __list_splice(list, head, head->next);
+  INIT_LIST_HEAD(list);
+ }
+}
+static inline __attribute__((always_inline)) void list_splice_tail_init(struct list_head *list,
+      struct list_head *head)
+{
+ if (!list_empty(list)) {
+  __list_splice(list, head->prev, head);
+  INIT_LIST_HEAD(list);
+ }
+}
+struct hlist_head {
+ struct hlist_node *first;
+};
+struct hlist_node {
+ struct hlist_node *next, **pprev;
+};
+static inline __attribute__((always_inline)) void INIT_HLIST_NODE(struct hlist_node *h)
+{
+ h->next = ((void *)0);
+ h->pprev = ((void *)0);
+}
+static inline __attribute__((always_inline)) int hlist_unhashed(const struct hlist_node *h)
+{
+ return !h->pprev;
+}
+static inline __attribute__((always_inline)) int hlist_empty(const struct hlist_head *h)
+{
+ return !h->first;
+}
+static inline __attribute__((always_inline)) void __hlist_del(struct hlist_node *n)
+{
+ struct hlist_node *next = n->next;
+ struct hlist_node **pprev = n->pprev;
+ *pprev = next;
+ if (next)
+  next->pprev = pprev;
+}
+static inline __attribute__((always_inline)) void hlist_del(struct hlist_node *n)
+{
+ __hlist_del(n);
+ n->next = ((void *) 0x00100100 + 0);
+ n->pprev = ((void *) 0x00200200 + 0);
+}
+static inline __attribute__((always_inline)) void hlist_del_init(struct hlist_node *n)
+{
+ if (!hlist_unhashed(n)) {
+  __hlist_del(n);
+  INIT_HLIST_NODE(n);
+ }
+}
+static inline __attribute__((always_inline)) void hlist_add_head(struct hlist_node *n, struct hlist_head *h)
+{
+ struct hlist_node *first = h->first;
+ n->next = first;
+ if (first)
+  first->pprev = &n->next;
+ h->first = n;
+ n->pprev = &h->first;
+}
+static inline __attribute__((always_inline)) void hlist_add_before(struct hlist_node *n,
+     struct hlist_node *next)
+{
+ n->pprev = next->pprev;
+ n->next = next;
+ next->pprev = &n->next;
+ *(n->pprev) = n;
+}
+static inline __attribute__((always_inline)) void hlist_add_after(struct hlist_node *n,
+     struct hlist_node *next)
+{
+ next->next = n->next;
+ n->next = next;
+ next->pprev = &n->next;
+ if(next->next)
+  next->next->pprev = &next->next;
+}
+static inline __attribute__((always_inline)) void hlist_move_list(struct hlist_head *old,
+       struct hlist_head *new)
+{
+ new->first = old->first;
+ if (new->first)
+  new->first->pprev = &new->first;
+ old->first = ((void *)0);
+}
+struct __old_kernel_stat {
+ unsigned short st_dev;
+ unsigned short st_ino;
+ unsigned short st_mode;
+ unsigned short st_nlink;
+ unsigned short st_uid;
+ unsigned short st_gid;
+ unsigned short st_rdev;
+ unsigned long st_size;
+ unsigned long st_atime;
+ unsigned long st_mtime;
+ unsigned long st_ctime;
+};
+struct stat {
+ unsigned long st_dev;
+ unsigned long st_ino;
+ unsigned short st_mode;
+ unsigned short st_nlink;
+ unsigned short st_uid;
+ unsigned short st_gid;
+ unsigned long st_rdev;
+ unsigned long st_size;
+ unsigned long st_blksize;
+ unsigned long st_blocks;
+ unsigned long st_atime;
+ unsigned long st_atime_nsec;
+ unsigned long st_mtime;
+ unsigned long st_mtime_nsec;
+ unsigned long st_ctime;
+ unsigned long st_ctime_nsec;
+ unsigned long __unused4;
+ unsigned long __unused5;
+};
+struct stat64 {
+ unsigned long long st_dev;
+ unsigned char __pad0[4];
+ unsigned long __st_ino;
+ unsigned int st_mode;
+ unsigned int st_nlink;
+ unsigned long st_uid;
+ unsigned long st_gid;
+ unsigned long long st_rdev;
+ unsigned char __pad3[4];
+ long long st_size;
+ unsigned long st_blksize;
+ unsigned long long st_blocks;
+ unsigned long st_atime;
+ unsigned long st_atime_nsec;
+ unsigned long st_mtime;
+ unsigned long st_mtime_nsec;
+ unsigned long st_ctime;
+ unsigned long st_ctime_nsec;
+ unsigned long long st_ino;
+};
+typedef __builtin_va_list __gnuc_va_list;
+typedef __gnuc_va_list va_list;
+static inline __attribute__((always_inline)) __attribute__((__const__)) __u32 __arch_swab32(__u32 x)
+{
+ __asm__(
+  "swap.b		%1, %0\n\t"
+  "swap.w		%0, %0\n\t"
+  "swap.b		%0, %0"
+  : "=r" (x)
+  : "r" (x));
+ return x;
+}
+static inline __attribute__((always_inline)) __attribute__((__const__)) __u16 __arch_swab16(__u16 x)
+{
+ __asm__(
+  "swap.b		%1, %0"
+  : "=r" (x)
+  : "r" (x));
+ return x;
+}
+static inline __attribute__((always_inline)) __u64 __arch_swab64(__u64 val)
+{
+ union {
+  struct { __u32 a,b; } s;
+  __u64 u;
+ } v, w;
+ v.u = val;
+ w.s.b = __arch_swab32(v.s.a);
+ w.s.a = __arch_swab32(v.s.b);
+ return w.u;
+}
+static inline __attribute__((always_inline)) __attribute__((__const__)) __u16 __fswab16(__u16 val)
+{
+ return __arch_swab16(val);
+}
+static inline __attribute__((always_inline)) __attribute__((__const__)) __u32 __fswab32(__u32 val)
+{
+ return __arch_swab32(val);
+}
+static inline __attribute__((always_inline)) __attribute__((__const__)) __u64 __fswab64(__u64 val)
+{
+ return __arch_swab64(val);
+}
+static inline __attribute__((always_inline)) __attribute__((__const__)) __u32 __fswahw32(__u32 val)
+{
+ return ((__u32)( (((__u32)(val) & (__u32)0x0000ffffUL) << 16) | (((__u32)(val) & (__u32)0xffff0000UL) >> 16)));
+}
+static inline __attribute__((always_inline)) __attribute__((__const__)) __u32 __fswahb32(__u32 val)
+{
+ return ((__u32)( (((__u32)(val) & (__u32)0x00ff00ffUL) << 8) | (((__u32)(val) & (__u32)0xff00ff00UL) >> 8)));
+}
+static inline __attribute__((always_inline)) __u16 __swab16p(const __u16 *p)
+{
+ return (__builtin_constant_p((__u16)(*p)) ? ((__u16)( (((__u16)(*p) & (__u16)0x00ffU) << 8) | (((__u16)(*p) & (__u16)0xff00U) >> 8))) : __fswab16(*p));
+}
+static inline __attribute__((always_inline)) __u32 __swab32p(const __u32 *p)
+{
+ return (__builtin_constant_p((__u32)(*p)) ? ((__u32)( (((__u32)(*p) & (__u32)0x000000ffUL) << 24) | (((__u32)(*p) & (__u32)0x0000ff00UL) << 8) | (((__u32)(*p) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(*p) & (__u32)0xff000000UL) >> 24))) : __fswab32(*p));
+}
+static inline __attribute__((always_inline)) __u64 __swab64p(const __u64 *p)
+{
+ return (__builtin_constant_p((__u64)(*p)) ? ((__u64)( (((__u64)(*p) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(*p) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(*p) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(*p) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(*p) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(*p) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(*p) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(*p) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(*p));
+}
+static inline __attribute__((always_inline)) __u32 __swahw32p(const __u32 *p)
+{
+ return (__builtin_constant_p((__u32)(*p)) ? ((__u32)( (((__u32)(*p) & (__u32)0x0000ffffUL) << 16) | (((__u32)(*p) & (__u32)0xffff0000UL) >> 16))) : __fswahw32(*p));
+}
+static inline __attribute__((always_inline)) __u32 __swahb32p(const __u32 *p)
+{
+ return (__builtin_constant_p((__u32)(*p)) ? ((__u32)( (((__u32)(*p) & (__u32)0x00ff00ffUL) << 8) | (((__u32)(*p) & (__u32)0xff00ff00UL) >> 8))) : __fswahb32(*p));
+}
+static inline __attribute__((always_inline)) void __swab16s(__u16 *p)
+{
+ *p = __swab16p(p);
+}
+static inline __attribute__((always_inline)) void __swab32s(__u32 *p)
+{
+ *p = __swab32p(p);
+}
+static inline __attribute__((always_inline)) void __swab64s(__u64 *p)
+{
+ *p = __swab64p(p);
+}
+static inline __attribute__((always_inline)) void __swahw32s(__u32 *p)
+{
+ *p = __swahw32p(p);
+}
+static inline __attribute__((always_inline)) void __swahb32s(__u32 *p)
+{
+ *p = __swahb32p(p);
+}
+static inline __attribute__((always_inline)) __le64 __cpu_to_le64p(const __u64 *p)
+{
+ return ( __le64)*p;
+}
+static inline __attribute__((always_inline)) __u64 __le64_to_cpup(const __le64 *p)
+{
+ return ( __u64)*p;
+}
+static inline __attribute__((always_inline)) __le32 __cpu_to_le32p(const __u32 *p)
+{
+ return ( __le32)*p;
+}
+static inline __attribute__((always_inline)) __u32 __le32_to_cpup(const __le32 *p)
+{
+ return ( __u32)*p;
+}
+static inline __attribute__((always_inline)) __le16 __cpu_to_le16p(const __u16 *p)
+{
+ return ( __le16)*p;
+}
+static inline __attribute__((always_inline)) __u16 __le16_to_cpup(const __le16 *p)
+{
+ return ( __u16)*p;
+}
+static inline __attribute__((always_inline)) __be64 __cpu_to_be64p(const __u64 *p)
+{
+ return ( __be64)__swab64p(p);
+}
+static inline __attribute__((always_inline)) __u64 __be64_to_cpup(const __be64 *p)
+{
+ return __swab64p((__u64 *)p);
+}
+static inline __attribute__((always_inline)) __be32 __cpu_to_be32p(const __u32 *p)
+{
+ return ( __be32)__swab32p(p);
+}
+static inline __attribute__((always_inline)) __u32 __be32_to_cpup(const __be32 *p)
+{
+ return __swab32p((__u32 *)p);
+}
+static inline __attribute__((always_inline)) __be16 __cpu_to_be16p(const __u16 *p)
+{
+ return ( __be16)__swab16p(p);
+}
+static inline __attribute__((always_inline)) __u16 __be16_to_cpup(const __be16 *p)
+{
+ return __swab16p((__u16 *)p);
+}
+static inline __attribute__((always_inline)) void le16_add_cpu(__le16 *var, u16 val)
+{
+ *var = (( __le16)(__u16)((( __u16)(__le16)(*var)) + val));
+}
+static inline __attribute__((always_inline)) void le32_add_cpu(__le32 *var, u32 val)
+{
+ *var = (( __le32)(__u32)((( __u32)(__le32)(*var)) + val));
+}
+static inline __attribute__((always_inline)) void le64_add_cpu(__le64 *var, u64 val)
+{
+ *var = (( __le64)(__u64)((( __u64)(__le64)(*var)) + val));
+}
+static inline __attribute__((always_inline)) void be16_add_cpu(__be16 *var, u16 val)
+{
+ *var = (( __be16)(__builtin_constant_p((__u16)(((__builtin_constant_p((__u16)(( __u16)(__be16)(*var))) ? ((__u16)( (((__u16)(( __u16)(__be16)(*var)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__be16)(*var)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__be16)(*var))) + val))) ? ((__u16)( (((__u16)(((__builtin_constant_p((__u16)(( __u16)(__be16)(*var))) ? ((__u16)( (((__u16)(( __u16)(__be16)(*var)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__be16)(*var)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__be16)(*var))) + val)) & (__u16)0x00ffU) << 8) | (((__u16)(((__builtin_constant_p((__u16)(( __u16)(__be16)(*var))) ? ((__u16)( (((__u16)(( __u16)(__be16)(*var)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__be16)(*var)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__be16)(*var))) + val)) & (__u16)0xff00U) >> 8))) : __fswab16(((__builtin_constant_p((__u16)(( __u16)(__be16)(*var))) ? ((__u16)( (((__u16)(( __u16)(__be16)(*var)) & (__u16)0x00ffU) << 8) | (((__u16)(( __u16)(__be16)(*var)) & (__u16)0xff00U) >> 8))) : __fswab16(( __u16)(__be16)(*var))) + val))));
+}
+static inline __attribute__((always_inline)) void be32_add_cpu(__be32 *var, u32 val)
+{
+ *var = (( __be32)(__builtin_constant_p((__u32)(((__builtin_constant_p((__u32)(( __u32)(__be32)(*var))) ? ((__u32)( (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__be32)(*var))) + val))) ? ((__u32)( (((__u32)(((__builtin_constant_p((__u32)(( __u32)(__be32)(*var))) ? ((__u32)( (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__be32)(*var))) + val)) & (__u32)0x000000ffUL) << 24) | (((__u32)(((__builtin_constant_p((__u32)(( __u32)(__be32)(*var))) ? ((__u32)( (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__be32)(*var))) + val)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(((__builtin_constant_p((__u32)(( __u32)(__be32)(*var))) ? ((__u32)( (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__be32)(*var))) + val)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(((__builtin_constant_p((__u32)(( __u32)(__be32)(*var))) ? ((__u32)( (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__be32)(*var))) + val)) & (__u32)0xff000000UL) >> 24))) : __fswab32(((__builtin_constant_p((__u32)(( __u32)(__be32)(*var))) ? ((__u32)( (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x000000ffUL) << 24) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x0000ff00UL) << 8) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(( __u32)(__be32)(*var)) & (__u32)0xff000000UL) >> 24))) : __fswab32(( __u32)(__be32)(*var))) + val))));
+}
+static inline __attribute__((always_inline)) void be64_add_cpu(__be64 *var, u64 val)
+{
+ *var = (( __be64)(__builtin_constant_p((__u64)(((__builtin_constant_p((__u64)(( __u64)(__be64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(*var))) + val))) ? ((__u64)( (((__u64)(((__builtin_constant_p((__u64)(( __u64)(__be64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(*var))) + val)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(((__builtin_constant_p((__u64)(( __u64)(__be64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(*var))) + val)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(((__builtin_constant_p((__u64)(( __u64)(__be64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(*var))) + val)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(((__builtin_constant_p((__u64)(( __u64)(__be64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(*var))) + val)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(((__builtin_constant_p((__u64)(( __u64)(__be64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(*var))) + val)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(((__builtin_constant_p((__u64)(( __u64)(__be64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(*var))) + val)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(((__builtin_constant_p((__u64)(( __u64)(__be64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(*var))) + val)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(((__builtin_constant_p((__u64)(( __u64)(__be64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(*var))) + val)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(((__builtin_constant_p((__u64)(( __u64)(__be64)(*var))) ? ((__u64)( (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(( __u64)(__be64)(*var)) & (__u64)0xff00000000000000ULL) >> 56))) : __fswab64(( __u64)(__be64)(*var))) + val))));
+}
+static inline __attribute__((always_inline)) void set_bit(int nr, volatile unsigned long *addr)
+{
+ unsigned long mask = (1UL << ((nr) % 32));
+ unsigned long *p = ((unsigned long *)addr) + ((nr) / 32);
+ unsigned long flags;
+ do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); do { (flags) = __raw_local_irq_save(); } while (0); do { } while (0); } while (0); } while (0);
+ *p |= mask;
+ do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); if (raw_irqs_disabled_flags(flags)) { raw_local_irq_restore(flags); do { } while (0); } else { do { } while (0); raw_local_irq_restore(flags); } } while (0); } while (0);
+}
+static inline __attribute__((always_inline)) void clear_bit(int nr, volatile unsigned long *addr)
+{
+ unsigned long mask = (1UL << ((nr) % 32));
+ unsigned long *p = ((unsigned long *)addr) + ((nr) / 32);
+ unsigned long flags;
+ do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); do { (flags) = __raw_local_irq_save(); } while (0); do { } while (0); } while (0); } while (0);
+ *p &= ~mask;
+ do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); if (raw_irqs_disabled_flags(flags)) { raw_local_irq_restore(flags); do { } while (0); } else { do { } while (0); raw_local_irq_restore(flags); } } while (0); } while (0);
+}
+static inline __attribute__((always_inline)) void change_bit(int nr, volatile unsigned long *addr)
+{
+ unsigned long mask = (1UL << ((nr) % 32));
+ unsigned long *p = ((unsigned long *)addr) + ((nr) / 32);
+ unsigned long flags;
+ do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); do { (flags) = __raw_local_irq_save(); } while (0); do { } while (0); } while (0); } while (0);
+ *p ^= mask;
+ do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); if (raw_irqs_disabled_flags(flags)) { raw_local_irq_restore(flags); do { } while (0); } else { do { } while (0); raw_local_irq_restore(flags); } } while (0); } while (0);
+}
+static inline __attribute__((always_inline)) int test_and_set_bit(int nr, volatile unsigned long *addr)
+{
+ unsigned long mask = (1UL << ((nr) % 32));
+ unsigned long *p = ((unsigned long *)addr) + ((nr) / 32);
+ unsigned long old;
+ unsigned long flags;
+ do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); do { (flags) = __raw_local_irq_save(); } while (0); do { } while (0); } while (0); } while (0);
+ old = *p;
+ *p = old | mask;
+ do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); if (raw_irqs_disabled_flags(flags)) { raw_local_irq_restore(flags); do { } while (0); } else { do { } while (0); raw_local_irq_restore(flags); } } while (0); } while (0);
+ return (old & mask) != 0;
+}
+static inline __attribute__((always_inline)) int test_and_clear_bit(int nr, volatile unsigned long *addr)
+{
+ unsigned long mask = (1UL << ((nr) % 32));
+ unsigned long *p = ((unsigned long *)addr) + ((nr) / 32);
+ unsigned long old;
+ unsigned long flags;
+ do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); do { (flags) = __raw_local_irq_save(); } while (0); do { } while (0); } while (0); } while (0);
+ old = *p;
+ *p = old & ~mask;
+ do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); if (raw_irqs_disabled_flags(flags)) { raw_local_irq_restore(flags); do { } while (0); } else { do { } while (0); raw_local_irq_restore(flags); } } while (0); } while (0);
+ return (old & mask) != 0;
+}
+static inline __attribute__((always_inline)) int test_and_change_bit(int nr, volatile unsigned long *addr)
+{
+ unsigned long mask = (1UL << ((nr) % 32));
+ unsigned long *p = ((unsigned long *)addr) + ((nr) / 32);
+ unsigned long old;
+ unsigned long flags;
+ do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); do { (flags) = __raw_local_irq_save(); } while (0); do { } while (0); } while (0); } while (0);
+ old = *p;
+ *p = old ^ mask;
+ do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); if (raw_irqs_disabled_flags(flags)) { raw_local_irq_restore(flags); do { } while (0); } else { do { } while (0); raw_local_irq_restore(flags); } } while (0); } while (0);
+ return (old & mask) != 0;
+}
+static inline __attribute__((always_inline)) void __set_bit(int nr, volatile unsigned long *addr)
+{
+ unsigned long mask = (1UL << ((nr) % 32));
+ unsigned long *p = ((unsigned long *)addr) + ((nr) / 32);
+ *p |= mask;
+}
+static inline __attribute__((always_inline)) void __clear_bit(int nr, volatile unsigned long *addr)
+{
+ unsigned long mask = (1UL << ((nr) % 32));
+ unsigned long *p = ((unsigned long *)addr) + ((nr) / 32);
+ *p &= ~mask;
+}
+static inline __attribute__((always_inline)) void __change_bit(int nr, volatile unsigned long *addr)
+{
+ unsigned long mask = (1UL << ((nr) % 32));
+ unsigned long *p = ((unsigned long *)addr) + ((nr) / 32);
+ *p ^= mask;
+}
+static inline __attribute__((always_inline)) int __test_and_set_bit(int nr, volatile unsigned long *addr)
+{
+ unsigned long mask = (1UL << ((nr) % 32));
+ unsigned long *p = ((unsigned long *)addr) + ((nr) / 32);
+ unsigned long old = *p;
+ *p = old | mask;
+ return (old & mask) != 0;
+}
+static inline __attribute__((always_inline)) int __test_and_clear_bit(int nr, volatile unsigned long *addr)
+{
+ unsigned long mask = (1UL << ((nr) % 32));
+ unsigned long *p = ((unsigned long *)addr) + ((nr) / 32);
+ unsigned long old = *p;
+ *p = old & ~mask;
+ return (old & mask) != 0;
+}
+static inline __attribute__((always_inline)) int __test_and_change_bit(int nr,
+         volatile unsigned long *addr)
+{
+ unsigned long mask = (1UL << ((nr) % 32));
+ unsigned long *p = ((unsigned long *)addr) + ((nr) / 32);
+ unsigned long old = *p;
+ *p = old ^ mask;
+ return (old & mask) != 0;
+}
+static inline __attribute__((always_inline)) int test_bit(int nr, const volatile unsigned long *addr)
+{
+ return 1UL & (addr[((nr) / 32)] >> (nr & (32 -1)));
+}
+static inline __attribute__((always_inline)) unsigned long ffz(unsigned long word)
+{
+ unsigned long result;
+ __asm__("1:\n\t"
+  "shlr	%1\n\t"
+  "bt/s	1b\n\t"
+  " add	#1, %0"
+  : "=r" (result), "=r" (word)
+  : "0" (~0L), "1" (word)
+  : "t");
+ return result;
+}
+static inline __attribute__((always_inline)) unsigned long __ffs(unsigned long word)
+{
+ unsigned long result;
+ __asm__("1:\n\t"
+  "shlr	%1\n\t"
+  "bf/s	1b\n\t"
+  " add	#1, %0"
+  : "=r" (result), "=r" (word)
+  : "0" (~0L), "1" (word)
+  : "t");
+ return result;
+}
+static inline __attribute__((always_inline)) int ffs(int x)
+{
+ int r = 1;
+ if (!x)
+  return 0;
+ if (!(x & 0xffff)) {
+  x >>= 16;
+  r += 16;
+ }
+ if (!(x & 0xff)) {
+  x >>= 8;
+  r += 8;
+ }
+ if (!(x & 0xf)) {
+  x >>= 4;
+  r += 4;
+ }
+ if (!(x & 3)) {
+  x >>= 2;
+  r += 2;
+ }
+ if (!(x & 1)) {
+  x >>= 1;
+  r += 1;
+ }
+ return r;
+}
+extern unsigned int hweight32(unsigned int w);
+extern unsigned int hweight16(unsigned int w);
+extern unsigned int hweight8(unsigned int w);
+extern unsigned long hweight64(__u64 w);
+static inline __attribute__((always_inline)) int sched_find_first_bit(const unsigned long *b)
+{
+ if (b[0])
+  return __ffs(b[0]);
+ if (b[1])
+  return __ffs(b[1]) + 32;
+ if (b[2])
+  return __ffs(b[2]) + 64;
+ return __ffs(b[3]) + 96;
+}
+static inline __attribute__((always_inline)) __attribute__((always_inline)) int fls(int x)
+{
+ int r = 32;
+ if (!x)
+  return 0;
+ if (!(x & 0xffff0000u)) {
+  x <<= 16;
+  r -= 16;
+ }
+ if (!(x & 0xff000000u)) {
+  x <<= 8;
+  r -= 8;
+ }
+ if (!(x & 0xf0000000u)) {
+  x <<= 4;
+  r -= 4;
+ }
+ if (!(x & 0xc0000000u)) {
+  x <<= 2;
+  r -= 2;
+ }
+ if (!(x & 0x80000000u)) {
+  x <<= 1;
+  r -= 1;
+ }
+ return r;
+}
+static inline __attribute__((always_inline)) __attribute__((always_inline)) unsigned long __fls(unsigned long word)
+{
+ int num = 32 - 1;
+ if (!(word & (~0ul << (32 -16)))) {
+  num -= 16;
+  word <<= 16;
+ }
+ if (!(word & (~0ul << (32 -8)))) {
+  num -= 8;
+  word <<= 8;
+ }
+ if (!(word & (~0ul << (32 -4)))) {
+  num -= 4;
+  word <<= 4;
+ }
+ if (!(word & (~0ul << (32 -2)))) {
+  num -= 2;
+  word <<= 2;
+ }
+ if (!(word & (~0ul << (32 -1))))
+  num -= 1;
+ return num;
+}
+static inline __attribute__((always_inline)) __attribute__((always_inline)) int fls64(__u64 x)
+{
+ __u32 h = x >> 32;
+ if (h)
+  return fls(h) + 32;
+ return fls(x);
+}
+static __inline__ __attribute__((always_inline)) int get_bitmask_order(unsigned int count)
+{
+ int order;
+ order = fls(count);
+ return order;
+}
+static __inline__ __attribute__((always_inline)) int get_count_order(unsigned int count)
+{
+ int order;
+ order = fls(count) - 1;
+ if (count & (count - 1))
+  order++;
+ return order;
+}
+static inline __attribute__((always_inline)) unsigned long hweight_long(unsigned long w)
+{
+ return sizeof(w) == 4 ? hweight32(w) : hweight64(w);
+}
+static inline __attribute__((always_inline)) __u32 rol32(__u32 word, unsigned int shift)
+{
+ return (word << shift) | (word >> (32 - shift));
+}
+static inline __attribute__((always_inline)) __u32 ror32(__u32 word, unsigned int shift)
+{
+ return (word >> shift) | (word << (32 - shift));
+}
+static inline __attribute__((always_inline)) __u16 rol16(__u16 word, unsigned int shift)
+{
+ return (word << shift) | (word >> (16 - shift));
+}
+static inline __attribute__((always_inline)) __u16 ror16(__u16 word, unsigned int shift)
+{
+ return (word >> shift) | (word << (16 - shift));
+}
+static inline __attribute__((always_inline)) __u8 rol8(__u8 word, unsigned int shift)
+{
+ return (word << shift) | (word >> (8 - shift));
+}
+static inline __attribute__((always_inline)) __u8 ror8(__u8 word, unsigned int shift)
+{
+ return (word >> shift) | (word << (8 - shift));
+}
+static inline __attribute__((always_inline)) unsigned fls_long(unsigned long l)
+{
+ if (sizeof(l) == 4)
+  return fls(l);
+ return fls64(l);
+}
+static inline __attribute__((always_inline)) unsigned long __ffs64(u64 word)
+{
+ if (((u32)word) == 0UL)
+  return __ffs((u32)(word >> 32)) + 32;
+ return __ffs((unsigned long)word);
+}
+extern unsigned long find_last_bit(const unsigned long *addr,
+       unsigned long size);
+extern unsigned long find_next_bit(const unsigned long *addr,
+       unsigned long size, unsigned long offset);
+extern unsigned long find_next_zero_bit(const unsigned long *addr,
+     unsigned long size,
+     unsigned long offset);
+extern __attribute__((const, noreturn))
+int ____ilog2_NaN(void);
+static inline __attribute__((always_inline)) __attribute__((const))
+int __ilog2_u32(u32 n)
+{
+ return fls(n) - 1;
+}
+static inline __attribute__((always_inline)) __attribute__((const))
+int __ilog2_u64(u64 n)
+{
+ return fls64(n) - 1;
+}
+static inline __attribute__((always_inline)) __attribute__((const))
+bool is_power_of_2(unsigned long n)
+{
+ return (n != 0 && ((n & (n - 1)) == 0));
+}
+static inline __attribute__((always_inline)) __attribute__((const))
+unsigned long __roundup_pow_of_two(unsigned long n)
+{
+ return 1UL << fls_long(n - 1);
+}
+static inline __attribute__((always_inline)) __attribute__((const))
+unsigned long __rounddown_pow_of_two(unsigned long n)
+{
+ return 1UL << (fls_long(n) - 1);
+}
+struct ratelimit_state {
+ int interval;
+ int burst;
+ int printed;
+ int missed;
+ unsigned long begin;
+};
+extern int __ratelimit(struct ratelimit_state *rs);
+extern long long dynamic_debug_enabled;
+extern long long dynamic_debug_enabled2;
+struct _ddebug {
+ const char *modname;
+ const char *function;
+ const char *filename;
+ const char *format;
+ char primary_hash;
+ char secondary_hash;
+ unsigned int lineno:24;
+ unsigned int flags:8;
+} __attribute__((aligned(8)));
+int ddebug_add_module(struct _ddebug *tab, unsigned int n,
+    const char *modname);
+static inline __attribute__((always_inline)) int ddebug_remove_module(char *mod)
+{
+ return 0;
+}
+struct bug_entry {
+ unsigned long bug_addr;
+ unsigned short flags;
+};
+extern const char linux_banner[];
+extern const char linux_proc_banner[];
+extern uint32_t __div64_32(uint64_t *dividend, uint32_t divisor);
+extern int console_printk[];
+struct completion;
+struct pt_regs;
+struct user;
+  static inline __attribute__((always_inline)) void __might_sleep(char *file, int line, int preempt_offset) { }
+static inline __attribute__((always_inline)) void might_fault(void)
+{
+ do { do { } while (0); } while (0);
+}
+extern struct atomic_notifier_head panic_notifier_list;
+extern long (*panic_blink)(long time);
+ void panic(const char * fmt, ...)
+ __attribute__ ((noreturn, format (printf, 1, 2))) __attribute__((__cold__));
+extern void oops_enter(void);
+extern void oops_exit(void);
+extern int oops_may_print(void);
+ void do_exit(long error_code)
+ __attribute__((noreturn));
+ void complete_and_exit(struct completion *, long)
+ __attribute__((noreturn));
+extern unsigned long simple_strtoul(const char *,char **,unsigned int);
+extern long simple_strtol(const char *,char **,unsigned int);
+extern unsigned long long simple_strtoull(const char *,char **,unsigned int);
+extern long long simple_strtoll(const char *,char **,unsigned int);
+extern int strict_strtoul(const char *, unsigned int, unsigned long *);
+extern int strict_strtol(const char *, unsigned int, long *);
+extern int strict_strtoull(const char *, unsigned int, unsigned long long *);
+extern int strict_strtoll(const char *, unsigned int, long long *);
+extern int sprintf(char * buf, const char * fmt, ...)
+ __attribute__ ((format (printf, 2, 3)));
+extern int vsprintf(char *buf, const char *, va_list)
+ __attribute__ ((format (printf, 2, 0)));
+extern int snprintf(char * buf, size_t size, const char * fmt, ...)
+ __attribute__ ((format (printf, 3, 4)));
+extern int vsnprintf(char *buf, size_t size, const char *fmt, va_list args)
+ __attribute__ ((format (printf, 3, 0)));
+extern int scnprintf(char * buf, size_t size, const char * fmt, ...)
+ __attribute__ ((format (printf, 3, 4)));
+extern int vscnprintf(char *buf, size_t size, const char *fmt, va_list args)
+ __attribute__ ((format (printf, 3, 0)));
+extern char *kasprintf(gfp_t gfp, const char *fmt, ...)
+ __attribute__ ((format (printf, 2, 3)));
+extern char *kvasprintf(gfp_t gfp, const char *fmt, va_list args);
+extern int sscanf(const char *, const char *, ...)
+ __attribute__ ((format (scanf, 2, 3)));
+extern int vsscanf(const char *, const char *, va_list)
+ __attribute__ ((format (scanf, 2, 0)));
+extern int get_option(char **str, int *pint);
+extern char *get_options(const char *str, int nints, int *ints);
+extern unsigned long long memparse(const char *ptr, char **retptr);
+extern int core_kernel_text(unsigned long addr);
+extern int __kernel_text_address(unsigned long addr);
+extern int kernel_text_address(unsigned long addr);
+extern int func_ptr_is_kernel_text(void *ptr);
+struct pid;
+extern struct pid *session_of_pgrp(struct pid *pgrp);
+ int vprintk(const char *fmt, va_list args)
+ __attribute__ ((format (printf, 1, 0)));
+ int printk(const char * fmt, ...)
+ __attribute__ ((format (printf, 1, 2))) __attribute__((__cold__));
+extern struct ratelimit_state printk_ratelimit_state;
+extern int printk_ratelimit(void);
+extern bool printk_timed_ratelimit(unsigned long *caller_jiffies,
+       unsigned int interval_msec);
+extern int printk_delay_msec;
+void log_buf_kexec_setup(void);
+extern int printk_needs_cpu(int cpu);
+extern void printk_tick(void);
+extern void __attribute__((format(printf, 1, 2)))
+ early_printk(const char *fmt, ...);
+unsigned long int_sqrt(unsigned long);
+static inline __attribute__((always_inline)) void console_silent(void)
+{
+ (console_printk[0]) = 0;
+}
+static inline __attribute__((always_inline)) void console_verbose(void)
+{
+ if ((console_printk[0]))
+  (console_printk[0]) = 15;
+}
+extern void bust_spinlocks(int yes);
+extern void wake_up_klogd(void);
+extern int oops_in_progress;
+extern int panic_timeout;
+extern int panic_on_oops;
+extern int panic_on_unrecovered_nmi;
+extern int panic_on_io_nmi;
+extern const char *print_tainted(void);
+extern void add_taint(unsigned flag);
+extern int test_taint(unsigned flag);
+extern unsigned long get_taint(void);
+extern int root_mountflags;
+extern enum system_states {
+ SYSTEM_BOOTING,
+ SYSTEM_RUNNING,
+ SYSTEM_HALT,
+ SYSTEM_POWER_OFF,
+ SYSTEM_RESTART,
+ SYSTEM_SUSPEND_DISK,
+} system_state;
+extern void dump_stack(void) __attribute__((__cold__));
+enum {
+ DUMP_PREFIX_NONE,
+ DUMP_PREFIX_ADDRESS,
+ DUMP_PREFIX_OFFSET
+};
+extern void hex_dump_to_buffer(const void *buf, size_t len,
+    int rowsize, int groupsize,
+    char *linebuf, size_t linebuflen, bool ascii);
+extern void print_hex_dump(const char *level, const char *prefix_str,
+    int prefix_type, int rowsize, int groupsize,
+    const void *buf, size_t len, bool ascii);
+extern void print_hex_dump_bytes(const char *prefix_str, int prefix_type,
+   const void *buf, size_t len);
+extern const char hex_asc[];
+static inline __attribute__((always_inline)) char *pack_hex_byte(char *buf, u8 byte)
+{
+ *buf++ = hex_asc[((byte) & 0xf0) >> 4];
+ *buf++ = hex_asc[((byte) & 0x0f)];
+ return buf;
+}
+static inline __attribute__((always_inline)) void tracing_on(void) { }
+static inline __attribute__((always_inline)) void tracing_off(void) { }
+static inline __attribute__((always_inline)) void tracing_off_permanent(void) { }
+static inline __attribute__((always_inline)) int tracing_is_on(void) { return 0; }
+static inline __attribute__((always_inline)) void
+ftrace_special(unsigned long arg1, unsigned long arg2, unsigned long arg3) { }
+static inline __attribute__((always_inline)) int
+trace_printk(const char *fmt, ...) __attribute__ ((format (printf, 1, 2)));
+static inline __attribute__((always_inline)) void tracing_start(void) { }
+static inline __attribute__((always_inline)) void tracing_stop(void) { }
+static inline __attribute__((always_inline)) void ftrace_off_permanent(void) { }
+static inline __attribute__((always_inline)) int
+trace_printk(const char *fmt, ...)
+{
+ return 0;
+}
+static inline __attribute__((always_inline)) int
+ftrace_vprintk(const char *fmt, va_list ap)
+{
+ return 0;
+}
+static inline __attribute__((always_inline)) void ftrace_dump(void) { }
+struct sysinfo;
+extern int do_sysinfo(struct sysinfo *info);
+struct sysinfo {
+ long uptime;
+ unsigned long loads[3];
+ unsigned long totalram;
+ unsigned long freeram;
+ unsigned long sharedram;
+ unsigned long bufferram;
+ unsigned long totalswap;
+ unsigned long freeswap;
+ unsigned short procs;
+ unsigned short pad;
+ unsigned long totalhigh;
+ unsigned long freehigh;
+ unsigned int mem_unit;
+ char _f[20-2*sizeof(long)-sizeof(int)];
+};
+struct timespec;
+struct compat_timespec;
+struct restart_block {
+ long (*fn)(struct restart_block *);
+ union {
+  struct {
+   unsigned long arg0, arg1, arg2, arg3;
+  };
+  struct {
+   u32 *uaddr;
+   u32 val;
+   u32 flags;
+   u32 bitset;
+   u64 time;
+   u32 *uaddr2;
+  } futex;
+  struct {
+   clockid_t index;
+   struct timespec *rmtp;
+   u64 expires;
+  } nanosleep;
+  struct {
+   struct pollfd *ufds;
+   int nfds;
+   int has_timeout;
+   unsigned long tv_sec;
+   unsigned long tv_nsec;
+  } poll;
+ };
+};
+extern long do_no_restart_syscall(struct restart_block *parm);
+struct thread_info {
+ struct task_struct *task;
+ struct exec_domain *exec_domain;
+ unsigned long flags;
+ __u32 status;
+ __u32 cpu;
+ int preempt_count;
+ mm_segment_t addr_limit;
+ struct restart_block restart_block;
+ unsigned long previous_sp;
+ __u8 supervisor_stack[0];
+};
+register unsigned long current_stack_pointer asm("r15") __attribute__((__used__));
+static inline __attribute__((always_inline)) struct thread_info *current_thread_info(void)
+{
+ struct thread_info *ti;
+ __asm__ __volatile__ ("stc	r7_bank, %0" : "=r" (ti));
+ return ti;
+}
+static inline __attribute__((always_inline)) void set_ti_thread_flag(struct thread_info *ti, int flag)
+{
+ set_bit(flag, (unsigned long *)&ti->flags);
+}
+static inline __attribute__((always_inline)) void clear_ti_thread_flag(struct thread_info *ti, int flag)
+{
+ clear_bit(flag, (unsigned long *)&ti->flags);
+}
+static inline __attribute__((always_inline)) int test_and_set_ti_thread_flag(struct thread_info *ti, int flag)
+{
+ return test_and_set_bit(flag, (unsigned long *)&ti->flags);
+}
+static inline __attribute__((always_inline)) int test_and_clear_ti_thread_flag(struct thread_info *ti, int flag)
+{
+ return test_and_clear_bit(flag, (unsigned long *)&ti->flags);
+}
+static inline __attribute__((always_inline)) int test_ti_thread_flag(struct thread_info *ti, int flag)
+{
+ return test_bit(flag, (unsigned long *)&ti->flags);
+}
+static inline __attribute__((always_inline)) void set_restore_sigmask(void)
+{
+ set_ti_thread_flag(current_thread_info(), 3);
+ set_ti_thread_flag(current_thread_info(), 1);
+}
+ void preempt_schedule(void);
+extern void local_bh_disable(void);
+extern void _local_bh_enable(void);
+extern void local_bh_enable(void);
+extern void local_bh_enable_ip(unsigned long ip);
+typedef struct { } raw_spinlock_t;
+typedef struct {
+} raw_rwlock_t;
+struct task_struct;
+struct lockdep_map;
+static inline __attribute__((always_inline)) void lockdep_off(void)
+{
+}
+static inline __attribute__((always_inline)) void lockdep_on(void)
+{
+}
+struct lock_class_key { };
+extern void early_init_irq_lock_class(void);
+static inline __attribute__((always_inline)) void early_boot_irqs_off(void)
+{
+}
+static inline __attribute__((always_inline)) void early_boot_irqs_on(void)
+{
+}
+static inline __attribute__((always_inline)) void print_irqtrace_events(struct task_struct *curr)
+{
+}
+typedef struct {
+ raw_spinlock_t raw_lock;
+} spinlock_t;
+typedef struct {
+ raw_rwlock_t raw_lock;
+} rwlock_t;
+extern int __attribute__((section(".spinlock.text"))) generic__raw_read_trylock(raw_rwlock_t *lock);
+static inline __attribute__((always_inline)) void smp_mb__after_lock(void) { __asm__ __volatile__("": : :"memory"); }
+static inline __attribute__((always_inline)) void atomic_add(int i, atomic_t *v)
+{
+ unsigned long flags;
+ do { (flags) = __raw_local_irq_save(); } while (0);
+ v->counter += i;
+ raw_local_irq_restore(flags);
+}
+static inline __attribute__((always_inline)) void atomic_sub(int i, atomic_t *v)
+{
+ unsigned long flags;
+ do { (flags) = __raw_local_irq_save(); } while (0);
+ v->counter -= i;
+ raw_local_irq_restore(flags);
+}
+static inline __attribute__((always_inline)) int atomic_add_return(int i, atomic_t *v)
+{
+ unsigned long temp, flags;
+ do { (flags) = __raw_local_irq_save(); } while (0);
+ temp = v->counter;
+ temp += i;
+ v->counter = temp;
+ raw_local_irq_restore(flags);
+ return temp;
+}
+static inline __attribute__((always_inline)) int atomic_sub_return(int i, atomic_t *v)
+{
+ unsigned long temp, flags;
+ do { (flags) = __raw_local_irq_save(); } while (0);
+ temp = v->counter;
+ temp -= i;
+ v->counter = temp;
+ raw_local_irq_restore(flags);
+ return temp;
+}
+static inline __attribute__((always_inline)) void atomic_clear_mask(unsigned int mask, atomic_t *v)
+{
+ unsigned long flags;
+ do { (flags) = __raw_local_irq_save(); } while (0);
+ v->counter &= ~mask;
+ raw_local_irq_restore(flags);
+}
+static inline __attribute__((always_inline)) void atomic_set_mask(unsigned int mask, atomic_t *v)
+{
+ unsigned long flags;
+ do { (flags) = __raw_local_irq_save(); } while (0);
+ v->counter |= mask;
+ raw_local_irq_restore(flags);
+}
+static inline __attribute__((always_inline)) int atomic_cmpxchg(atomic_t *v, int old, int new)
+{
+ int ret;
+ unsigned long flags;
+ do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); do { (flags) = __raw_local_irq_save(); } while (0); do { } while (0); } while (0);
+ ret = v->counter;
+ if (__builtin_expect(!!(ret == old), 1))
+  v->counter = new;
+ do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); if (raw_irqs_disabled_flags(flags)) { raw_local_irq_restore(flags); do { } while (0); } else { do { } while (0); raw_local_irq_restore(flags); } } while (0);
+ return ret;
+}
+static inline __attribute__((always_inline)) int atomic_add_unless(atomic_t *v, int a, int u)
+{
+ int ret;
+ unsigned long flags;
+ do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); do { (flags) = __raw_local_irq_save(); } while (0); do { } while (0); } while (0);
+ ret = v->counter;
+ if (ret != u)
+  v->counter += a;
+ do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); if (raw_irqs_disabled_flags(flags)) { raw_local_irq_restore(flags); do { } while (0); } else { do { } while (0); raw_local_irq_restore(flags); } } while (0);
+ return ret != u;
+}
+typedef atomic_t atomic_long_t;
+static inline __attribute__((always_inline)) long atomic_long_read(atomic_long_t *l)
+{
+ atomic_t *v = (atomic_t *)l;
+ return (long)((v)->counter);
+}
+static inline __attribute__((always_inline)) void atomic_long_set(atomic_long_t *l, long i)
+{
+ atomic_t *v = (atomic_t *)l;
+ ((v)->counter = (i));
+}
+static inline __attribute__((always_inline)) void atomic_long_inc(atomic_long_t *l)
+{
+ atomic_t *v = (atomic_t *)l;
+ atomic_add(1,(v));
+}
+static inline __attribute__((always_inline)) void atomic_long_dec(atomic_long_t *l)
+{
+ atomic_t *v = (atomic_t *)l;
+ atomic_sub(1,(v));
+}
+static inline __attribute__((always_inline)) void atomic_long_add(long i, atomic_long_t *l)
+{
+ atomic_t *v = (atomic_t *)l;
+ atomic_add(i, v);
+}
+static inline __attribute__((always_inline)) void atomic_long_sub(long i, atomic_long_t *l)
+{
+ atomic_t *v = (atomic_t *)l;
+ atomic_sub(i, v);
+}
+static inline __attribute__((always_inline)) int atomic_long_sub_and_test(long i, atomic_long_t *l)
+{
+ atomic_t *v = (atomic_t *)l;
+ return (atomic_sub_return((i), (v)) == 0);
+}
+static inline __attribute__((always_inline)) int atomic_long_dec_and_test(atomic_long_t *l)
+{
+ atomic_t *v = (atomic_t *)l;
+ return (atomic_sub_return(1, (v)) == 0);
+}
+static inline __attribute__((always_inline)) int atomic_long_inc_and_test(atomic_long_t *l)
+{
+ atomic_t *v = (atomic_t *)l;
+ return (atomic_add_return(1,(v)) == 0);
+}
+static inline __attribute__((always_inline)) int atomic_long_add_negative(long i, atomic_long_t *l)
+{
+ atomic_t *v = (atomic_t *)l;
+ return (atomic_add_return((i), (v)) < 0);
+}
+static inline __attribute__((always_inline)) long atomic_long_add_return(long i, atomic_long_t *l)
+{
+ atomic_t *v = (atomic_t *)l;
+ return (long)atomic_add_return(i, v);
+}
+static inline __attribute__((always_inline)) long atomic_long_sub_return(long i, atomic_long_t *l)
+{
+ atomic_t *v = (atomic_t *)l;
+ return (long)atomic_sub_return(i, v);
+}
+static inline __attribute__((always_inline)) long atomic_long_inc_return(atomic_long_t *l)
+{
+ atomic_t *v = (atomic_t *)l;
+ return (long)atomic_add_return(1,(v));
+}
+static inline __attribute__((always_inline)) long atomic_long_dec_return(atomic_long_t *l)
+{
+ atomic_t *v = (atomic_t *)l;
+ return (long)atomic_sub_return(1,(v));
+}
+static inline __attribute__((always_inline)) long atomic_long_add_unless(atomic_long_t *l, long a, long u)
+{
+ atomic_t *v = (atomic_t *)l;
+ return (long)atomic_add_unless(v, a, u);
+}
+typedef struct {
+ long long counter;
+} atomic64_t;
+extern long long atomic64_read(const atomic64_t *v);
+extern void atomic64_set(atomic64_t *v, long long i);
+extern void atomic64_add(long long a, atomic64_t *v);
+extern long long atomic64_add_return(long long a, atomic64_t *v);
+extern void atomic64_sub(long long a, atomic64_t *v);
+extern long long atomic64_sub_return(long long a, atomic64_t *v);
+extern long long atomic64_dec_if_positive(atomic64_t *v);
+extern long long atomic64_cmpxchg(atomic64_t *v, long long o, long long n);
+extern long long atomic64_xchg(atomic64_t *v, long long new);
+extern int atomic64_add_unless(atomic64_t *v, long long a, long long u);
+extern int _atomic_dec_and_lock(atomic_t *atomic, spinlock_t *lock);
+typedef struct {
+ unsigned sequence;
+ spinlock_t lock;
+} seqlock_t;
+static inline __attribute__((always_inline)) void write_seqlock(seqlock_t *sl)
+{
+ do { do { do { (current_thread_info()->preempt_count) += (1); } while (0); __asm__ __volatile__("": : :"memory"); } while (0); (void)0; (void)(&sl->lock); } while (0);
+ ++sl->sequence;
+ __asm__ __volatile__("": : :"memory");
+}
+static inline __attribute__((always_inline)) void write_sequnlock(seqlock_t *sl)
+{
+ __asm__ __volatile__("": : :"memory");
+ sl->sequence++;
+ do { do { do { __asm__ __volatile__("": : :"memory"); do { (current_thread_info()->preempt_count) -= (1); } while (0); } while (0); __asm__ __volatile__("": : :"memory"); do { if (__builtin_expect(!!(test_ti_thread_flag(current_thread_info(), 2)), 0)) preempt_schedule(); } while (0); } while (0); (void)0; (void)(&sl->lock); } while (0);
+}
+static inline __attribute__((always_inline)) int write_tryseqlock(seqlock_t *sl)
+{
+ int ret = (({ do { do { do { (current_thread_info()->preempt_count) += (1); } while (0); __asm__ __volatile__("": : :"memory"); } while (0); (void)0; (void)(&sl->lock); } while (0); 1; }));
+ if (ret) {
+  ++sl->sequence;
+  __asm__ __volatile__("": : :"memory");
+ }
+ return ret;
+}
+static inline __attribute__((always_inline)) __attribute__((always_inline)) unsigned read_seqbegin(const seqlock_t *sl)
+{
+ unsigned ret;
+repeat:
+ ret = sl->sequence;
+ __asm__ __volatile__("": : :"memory");
+ if (__builtin_expect(!!(ret & 1), 0)) {
+  __asm__ __volatile__("": : :"memory");
+  goto repeat;
+ }
+ return ret;
+}
+static inline __attribute__((always_inline)) __attribute__((always_inline)) int read_seqretry(const seqlock_t *sl, unsigned start)
+{
+ __asm__ __volatile__("": : :"memory");
+ return (sl->sequence != start);
+}
+typedef struct seqcount {
+ unsigned sequence;
+} seqcount_t;
+static inline __attribute__((always_inline)) unsigned read_seqcount_begin(const seqcount_t *s)
+{
+ unsigned ret;
+repeat:
+ ret = s->sequence;
+ __asm__ __volatile__("": : :"memory");
+ if (__builtin_expect(!!(ret & 1), 0)) {
+  __asm__ __volatile__("": : :"memory");
+  goto repeat;
+ }
+ return ret;
+}
+static inline __attribute__((always_inline)) int read_seqcount_retry(const seqcount_t *s, unsigned start)
+{
+ __asm__ __volatile__("": : :"memory");
+ return s->sequence != start;
+}
+static inline __attribute__((always_inline)) void write_seqcount_begin(seqcount_t *s)
+{
+ s->sequence++;
+ __asm__ __volatile__("": : :"memory");
+}
+static inline __attribute__((always_inline)) void write_seqcount_end(seqcount_t *s)
+{
+ __asm__ __volatile__("": : :"memory");
+ s->sequence++;
+}
+static inline __attribute__((always_inline)) u64 div_u64_rem(u64 dividend, u32 divisor, u32 *remainder)
+{
+ *remainder = ({ uint32_t __base = (divisor); uint32_t __rem; (void)(((typeof((dividend)) *)0) == ((uint64_t *)0)); if (__builtin_expect(!!(((dividend) >> 32) == 0), 1)) { __rem = (uint32_t)(dividend) % __base; (dividend) = (uint32_t)(dividend) / __base; } else __rem = __div64_32(&(dividend), __base); __rem; });
+ return dividend;
+}
+extern s64 div_s64_rem(s64 dividend, s32 divisor, s32 *remainder);
+extern u64 div64_u64(u64 dividend, u64 divisor);
+static inline __attribute__((always_inline)) u64 div_u64(u64 dividend, u32 divisor)
+{
+ u32 remainder;
+ return div_u64_rem(dividend, divisor, &remainder);
+}
+static inline __attribute__((always_inline)) s64 div_s64(s64 dividend, s32 divisor)
+{
+ s32 remainder;
+ return div_s64_rem(dividend, divisor, &remainder);
+}
+u32 iter_div_u64_rem(u64 dividend, u32 divisor, u64 *remainder);
+static inline __attribute__((always_inline)) __attribute__((always_inline)) u32
+__iter_div_u64_rem(u64 dividend, u32 divisor, u64 *remainder)
+{
+ u32 ret = 0;
+ while (dividend >= divisor) {
+  asm("" : "+rm"(dividend));
+  dividend -= divisor;
+  ret++;
+ }
+ *remainder = dividend;
+ return ret;
+}
+struct timespec {
+ __kernel_time_t tv_sec;
+ long tv_nsec;
+};
+struct timeval {
+ __kernel_time_t tv_sec;
+ __kernel_suseconds_t tv_usec;
+};
+struct timezone {
+ int tz_minuteswest;
+ int tz_dsttime;
+};
+extern struct timezone sys_tz;
+static inline __attribute__((always_inline)) int timespec_equal(const struct timespec *a,
+                                 const struct timespec *b)
+{
+ return (a->tv_sec == b->tv_sec) && (a->tv_nsec == b->tv_nsec);
+}
+static inline __attribute__((always_inline)) int timespec_compare(const struct timespec *lhs, const struct timespec *rhs)
+{
+ if (lhs->tv_sec < rhs->tv_sec)
+  return -1;
+ if (lhs->tv_sec > rhs->tv_sec)
+  return 1;
+ return lhs->tv_nsec - rhs->tv_nsec;
+}
+static inline __attribute__((always_inline)) int timeval_compare(const struct timeval *lhs, const struct timeval *rhs)
+{
+ if (lhs->tv_sec < rhs->tv_sec)
+  return -1;
+ if (lhs->tv_sec > rhs->tv_sec)
+  return 1;
+ return lhs->tv_usec - rhs->tv_usec;
+}
+extern unsigned long mktime(const unsigned int year, const unsigned int mon,
+       const unsigned int day, const unsigned int hour,
+       const unsigned int min, const unsigned int sec);
+extern void set_normalized_timespec(struct timespec *ts, time_t sec, s64 nsec);
+extern struct timespec timespec_add_safe(const struct timespec lhs,
+      const struct timespec rhs);
+static inline __attribute__((always_inline)) struct timespec timespec_sub(struct timespec lhs,
+      struct timespec rhs)
+{
+ struct timespec ts_delta;
+ set_normalized_timespec(&ts_delta, lhs.tv_sec - rhs.tv_sec,
+    lhs.tv_nsec - rhs.tv_nsec);
+ return ts_delta;
+}
+extern struct timespec xtime;
+extern struct timespec wall_to_monotonic;
+extern seqlock_t xtime_lock;
+extern void read_persistent_clock(struct timespec *ts);
+extern void read_boot_clock(struct timespec *ts);
+extern int update_persistent_clock(struct timespec now);
+extern int no_sync_cmos_clock __attribute__((__section__(".data.read_mostly")));
+void timekeeping_init(void);
+extern int timekeeping_suspended;
+unsigned long get_seconds(void);
+struct timespec current_kernel_time(void);
+struct timespec __current_kernel_time(void);
+struct timespec get_monotonic_coarse(void);
+static inline __attribute__((always_inline)) u32 arch_gettimeoffset(void) { return 0; }
+extern void do_gettimeofday(struct timeval *tv);
+extern int do_settimeofday(struct timespec *tv);
+extern int do_sys_settimeofday(struct timespec *tv, struct timezone *tz);
+extern long do_utimes(int dfd, char *filename, struct timespec *times, int flags);
+struct itimerval;
+extern int do_setitimer(int which, struct itimerval *value,
+   struct itimerval *ovalue);
+extern unsigned int alarm_setitimer(unsigned int seconds);
+extern int do_getitimer(int which, struct itimerval *value);
+extern void getnstimeofday(struct timespec *tv);
+extern void getrawmonotonic(struct timespec *ts);
+extern void getboottime(struct timespec *ts);
+extern void monotonic_to_bootbased(struct timespec *ts);
+extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
+extern int timekeeping_valid_for_hres(void);
+extern u64 timekeeping_max_deferment(void);
+extern void update_wall_time(void);
+extern void update_xtime_cache(u64 nsec);
+extern void timekeeping_leap_insert(int leapsecond);
+struct tms;
+extern void do_sys_times(struct tms *);
+struct tm {
+ int tm_sec;
+ int tm_min;
+ int tm_hour;
+ int tm_mday;
+ int tm_mon;
+ long tm_year;
+ int tm_wday;
+ int tm_yday;
+};
+void time_to_tm(time_t totalsecs, int offset, struct tm *result);
+static inline __attribute__((always_inline)) s64 timespec_to_ns(const struct timespec *ts)
+{
+ return ((s64) ts->tv_sec * 1000000000L) + ts->tv_nsec;
+}
+static inline __attribute__((always_inline)) s64 timeval_to_ns(const struct timeval *tv)
+{
+ return ((s64) tv->tv_sec * 1000000000L) +
+  tv->tv_usec * 1000L;
+}
+extern struct timespec ns_to_timespec(const s64 nsec);
+extern struct timeval ns_to_timeval(const s64 nsec);
+static inline __attribute__((always_inline)) __attribute__((always_inline)) void timespec_add_ns(struct timespec *a, u64 ns)
+{
+ a->tv_sec += __iter_div_u64_rem(a->tv_nsec + ns, 1000000000L, &ns);
+ a->tv_nsec = ns;
+}
+struct itimerspec {
+ struct timespec it_interval;
+ struct timespec it_value;
+};
+struct itimerval {
+ struct timeval it_interval;
+ struct timeval it_value;
+};
+struct kstat {
+ u64 ino;
+ dev_t dev;
+ umode_t mode;
+ unsigned int nlink;
+ uid_t uid;
+ gid_t gid;
+ dev_t rdev;
+ loff_t size;
+ struct timespec atime;
+ struct timespec mtime;
+ struct timespec ctime;
+ unsigned long blksize;
+ unsigned long long blocks;
+};
+typedef struct __wait_queue wait_queue_t;
+typedef int (*wait_queue_func_t)(wait_queue_t *wait, unsigned mode, int flags, void *key);
+int default_wake_function(wait_queue_t *wait, unsigned mode, int flags, void *key);
+struct __wait_queue {
+ unsigned int flags;
+ void *private;
+ wait_queue_func_t func;
+ struct list_head task_list;
+};
+struct wait_bit_key {
+ void *flags;
+ int bit_nr;
+};
+struct wait_bit_queue {
+ struct wait_bit_key key;
+ wait_queue_t wait;
+};
+struct __wait_queue_head {
+ spinlock_t lock;
+ struct list_head task_list;
+};
+typedef struct __wait_queue_head wait_queue_head_t;
+struct task_struct;
+extern void __init_waitqueue_head(wait_queue_head_t *q, struct lock_class_key *);
+static inline __attribute__((always_inline)) void init_waitqueue_entry(wait_queue_t *q, struct task_struct *p)
+{
+ q->flags = 0;
+ q->private = p;
+ q->func = default_wake_function;
+}
+static inline __attribute__((always_inline)) void init_waitqueue_func_entry(wait_queue_t *q,
+     wait_queue_func_t func)
+{
+ q->flags = 0;
+ q->private = ((void *)0);
+ q->func = func;
+}
+static inline __attribute__((always_inline)) int waitqueue_active(wait_queue_head_t *q)
+{
+ return !list_empty(&q->task_list);
+}
+extern void add_wait_queue(wait_queue_head_t *q, wait_queue_t *wait);
+extern void add_wait_queue_exclusive(wait_queue_head_t *q, wait_queue_t *wait);
+extern void remove_wait_queue(wait_queue_head_t *q, wait_queue_t *wait);
+static inline __attribute__((always_inline)) void __add_wait_queue(wait_queue_head_t *head, wait_queue_t *new)
+{
+ list_add(&new->task_list, &head->task_list);
+}
+static inline __attribute__((always_inline)) void __add_wait_queue_tail(wait_queue_head_t *head,
+      wait_queue_t *new)
+{
+ list_add_tail(&new->task_list, &head->task_list);
+}
+static inline __attribute__((always_inline)) void __remove_wait_queue(wait_queue_head_t *head,
+       wait_queue_t *old)
+{
+ list_del(&old->task_list);
+}
+void __wake_up(wait_queue_head_t *q, unsigned int mode, int nr, void *key);
+void __wake_up_locked_key(wait_queue_head_t *q, unsigned int mode, void *key);
+void __wake_up_sync_key(wait_queue_head_t *q, unsigned int mode, int nr,
+   void *key);
+void __wake_up_locked(wait_queue_head_t *q, unsigned int mode);
+void __wake_up_sync(wait_queue_head_t *q, unsigned int mode, int nr);
+void __wake_up_bit(wait_queue_head_t *, void *, int);
+int __wait_on_bit(wait_queue_head_t *, struct wait_bit_queue *, int (*)(void *), unsigned);
+int __wait_on_bit_lock(wait_queue_head_t *, struct wait_bit_queue *, int (*)(void *), unsigned);
+void wake_up_bit(void *, int);
+int out_of_line_wait_on_bit(void *, int, int (*)(void *), unsigned);
+int out_of_line_wait_on_bit_lock(void *, int, int (*)(void *), unsigned);
+wait_queue_head_t *bit_waitqueue(void *, int);
+static inline __attribute__((always_inline)) void add_wait_queue_exclusive_locked(wait_queue_head_t *q,
+         wait_queue_t * wait)
+{
+ wait->flags |= 0x01;
+ __add_wait_queue_tail(q, wait);
+}
+static inline __attribute__((always_inline)) void remove_wait_queue_locked(wait_queue_head_t *q,
+         wait_queue_t * wait)
+{
+ __remove_wait_queue(q, wait);
+}
+extern void sleep_on(wait_queue_head_t *q);
+extern long sleep_on_timeout(wait_queue_head_t *q,
+          signed long timeout);
+extern void interruptible_sleep_on(wait_queue_head_t *q);
+extern long interruptible_sleep_on_timeout(wait_queue_head_t *q,
+        signed long timeout);
+void prepare_to_wait(wait_queue_head_t *q, wait_queue_t *wait, int state);
+void prepare_to_wait_exclusive(wait_queue_head_t *q, wait_queue_t *wait, int state);
+void finish_wait(wait_queue_head_t *q, wait_queue_t *wait);
+void abort_exclusive_wait(wait_queue_head_t *q, wait_queue_t *wait,
+   unsigned int mode, void *key);
+int autoremove_wake_function(wait_queue_t *wait, unsigned mode, int sync, void *key);
+int wake_bit_function(wait_queue_t *wait, unsigned mode, int sync, void *key);
+static inline __attribute__((always_inline)) int wait_on_bit(void *word, int bit,
+    int (*action)(void *), unsigned mode)
+{
+ if (!test_bit(bit, word))
+  return 0;
+ return out_of_line_wait_on_bit(word, bit, action, mode);
+}
+static inline __attribute__((always_inline)) int wait_on_bit_lock(void *word, int bit,
+    int (*action)(void *), unsigned mode)
+{
+ if (!test_and_set_bit(bit, word))
+  return 0;
+ return out_of_line_wait_on_bit_lock(word, bit, action, mode);
+}
+extern char *strndup_user(const char *, long);
+extern void *memdup_user(const void *, size_t);
+static inline __attribute__((always_inline)) char *strcpy(char *__dest, const char *__src)
+{
+ register char *__xdest = __dest;
+ unsigned long __dummy;
+ __asm__ __volatile__("1:\n\t"
+        "mov.b	@%1+, %2\n\t"
+        "mov.b	%2, @%0\n\t"
+        "cmp/eq	#0, %2\n\t"
+        "bf/s	1b\n\t"
+        " add	#1, %0\n\t"
+        : "=r" (__dest), "=r" (__src), "=&z" (__dummy)
+        : "0" (__dest), "1" (__src)
+        : "memory", "t");
+ return __xdest;
+}
+static inline __attribute__((always_inline)) char *strncpy(char *__dest, const char *__src, size_t __n)
+{
+ register char *__xdest = __dest;
+ unsigned long __dummy;
+ if (__n == 0)
+  return __xdest;
+ __asm__ __volatile__(
+  "1:\n"
+  "mov.b	@%1+, %2\n\t"
+  "mov.b	%2, @%0\n\t"
+  "cmp/eq	#0, %2\n\t"
+  "bt/s	2f\n\t"
+  " cmp/eq	%5,%1\n\t"
+  "bf/s	1b\n\t"
+  " add	#1, %0\n"
+  "2:"
+  : "=r" (__dest), "=r" (__src), "=&z" (__dummy)
+  : "0" (__dest), "1" (__src), "r" (__src+__n)
+  : "memory", "t");
+ return __xdest;
+}
+static inline __attribute__((always_inline)) int strcmp(const char *__cs, const char *__ct)
+{
+ register int __res;
+ unsigned long __dummy;
+ __asm__ __volatile__(
+  "mov.b	@%1+, %3\n"
+  "1:\n\t"
+  "mov.b	@%0+, %2\n\t"
+  "cmp/eq #0, %3\n\t"
+  "bt	2f\n\t"
+  "cmp/eq %2, %3\n\t"
+  "bt/s	1b\n\t"
+  " mov.b	@%1+, %3\n\t"
+  "add	#-2, %1\n\t"
+  "mov.b	@%1, %3\n\t"
+  "sub	%3, %2\n"
+  "2:"
+  : "=r" (__cs), "=r" (__ct), "=&r" (__res), "=&z" (__dummy)
+  : "0" (__cs), "1" (__ct)
+  : "t");
+ return __res;
+}
+static inline __attribute__((always_inline)) int strncmp(const char *__cs, const char *__ct, size_t __n)
+{
+ register int __res;
+ unsigned long __dummy;
+ if (__n == 0)
+  return 0;
+ __asm__ __volatile__(
+  "mov.b	@%1+, %3\n"
+  "1:\n\t"
+  "mov.b	@%0+, %2\n\t"
+  "cmp/eq %6, %0\n\t"
+  "bt/s	2f\n\t"
+  " cmp/eq #0, %3\n\t"
+  "bt/s	3f\n\t"
+  " cmp/eq %3, %2\n\t"
+  "bt/s	1b\n\t"
+  " mov.b	@%1+, %3\n\t"
+  "add	#-2, %1\n\t"
+  "mov.b	@%1, %3\n"
+  "2:\n\t"
+  "sub	%3, %2\n"
+  "3:"
+  :"=r" (__cs), "=r" (__ct), "=&r" (__res), "=&z" (__dummy)
+  : "0" (__cs), "1" (__ct), "r" (__cs+__n)
+  : "t");
+ return __res;
+}
+extern void *memset(void *__s, int __c, size_t __count);
+extern void *memcpy(void *__to, __const__ void *__from, size_t __n);
+extern void *memmove(void *__dest, __const__ void *__src, size_t __n);
+extern void *memchr(const void *__s, int __c, size_t __n);
+extern size_t strlen(const char *);
+size_t strlcpy(char *, const char *, size_t);
+extern char * strcat(char *, const char *);
+extern char * strncat(char *, const char *, __kernel_size_t);
+extern size_t strlcat(char *, const char *, __kernel_size_t);
+extern int strnicmp(const char *, const char *, __kernel_size_t);
+extern int strcasecmp(const char *s1, const char *s2);
+extern int strncasecmp(const char *s1, const char *s2, size_t n);
+extern char * strchr(const char *,int);
+extern char * strnchr(const char *, size_t, int);
+extern char * strrchr(const char *,int);
+extern char * strstrip(char *);
+extern char * strstr(const char *,const char *);
+extern __kernel_size_t strnlen(const char *,__kernel_size_t);
+extern char * strpbrk(const char *,const char *);
+extern char * strsep(char **,const char *);
+extern __kernel_size_t strspn(const char *,const char *);
+extern __kernel_size_t strcspn(const char *,const char *);
+extern void * memscan(void *,int,__kernel_size_t);
+extern int memcmp(const void *,const void *,__kernel_size_t);
+extern char *kstrdup(const char *s, gfp_t gfp);
+extern char *kstrndup(const char *s, size_t len, gfp_t gfp);
+extern void *kmemdup(const void *src, size_t len, gfp_t gfp);
+extern char **argv_split(gfp_t gfp, const char *str, int *argcp);
+extern void argv_free(char **argv);
+extern bool sysfs_streq(const char *s1, const char *s2);
+extern ssize_t memory_read_from_buffer(void *to, size_t count, loff_t *ppos,
+   const void *from, size_t available);
+static inline __attribute__((always_inline)) bool strstarts(const char *str, const char *prefix)
+{
+ return strncmp(str, prefix, strlen(prefix)) == 0;
+}
+extern int __bitmap_empty(const unsigned long *bitmap, int bits);
+extern int __bitmap_full(const unsigned long *bitmap, int bits);
+extern int __bitmap_equal(const unsigned long *bitmap1,
+                 const unsigned long *bitmap2, int bits);
+extern void __bitmap_complement(unsigned long *dst, const unsigned long *src,
+   int bits);
+extern void __bitmap_shift_right(unsigned long *dst,
+                        const unsigned long *src, int shift, int bits);
+extern void __bitmap_shift_left(unsigned long *dst,
+                        const unsigned long *src, int shift, int bits);
+extern int __bitmap_and(unsigned long *dst, const unsigned long *bitmap1,
+   const unsigned long *bitmap2, int bits);
+extern void __bitmap_or(unsigned long *dst, const unsigned long *bitmap1,
+   const unsigned long *bitmap2, int bits);
+extern void __bitmap_xor(unsigned long *dst, const unsigned long *bitmap1,
+   const unsigned long *bitmap2, int bits);
+extern int __bitmap_andnot(unsigned long *dst, const unsigned long *bitmap1,
+   const unsigned long *bitmap2, int bits);
+extern int __bitmap_intersects(const unsigned long *bitmap1,
+   const unsigned long *bitmap2, int bits);
+extern int __bitmap_subset(const unsigned long *bitmap1,
+   const unsigned long *bitmap2, int bits);
+extern int __bitmap_weight(const unsigned long *bitmap, int bits);
+extern int bitmap_scnprintf(char *buf, unsigned int len,
+   const unsigned long *src, int nbits);
+extern int __bitmap_parse(const char *buf, unsigned int buflen, int is_user,
+   unsigned long *dst, int nbits);
+extern int bitmap_parse_user(const char *ubuf, unsigned int ulen,
+   unsigned long *dst, int nbits);
+extern int bitmap_scnlistprintf(char *buf, unsigned int len,
+   const unsigned long *src, int nbits);
+extern int bitmap_parselist(const char *buf, unsigned long *maskp,
+   int nmaskbits);
+extern void bitmap_remap(unsigned long *dst, const unsigned long *src,
+  const unsigned long *old, const unsigned long *new, int bits);
+extern int bitmap_bitremap(int oldbit,
+  const unsigned long *old, const unsigned long *new, int bits);
+extern void bitmap_onto(unsigned long *dst, const unsigned long *orig,
+  const unsigned long *relmap, int bits);
+extern void bitmap_fold(unsigned long *dst, const unsigned long *orig,
+  int sz, int bits);
+extern int bitmap_find_free_region(unsigned long *bitmap, int bits, int order);
+extern void bitmap_release_region(unsigned long *bitmap, int pos, int order);
+extern int bitmap_allocate_region(unsigned long *bitmap, int pos, int order);
+extern void bitmap_copy_le(void *dst, const unsigned long *src, int nbits);
+static inline __attribute__((always_inline)) void bitmap_zero(unsigned long *dst, int nbits)
+{
+ if ((__builtin_constant_p(nbits) && (nbits) <= 32))
+  *dst = 0UL;
+ else {
+  int len = (((nbits) + (8 * sizeof(long)) - 1) / (8 * sizeof(long))) * sizeof(unsigned long);
+  memset(dst, 0, len);
+ }
+}
+static inline __attribute__((always_inline)) void bitmap_fill(unsigned long *dst, int nbits)
+{
+ size_t nlongs = (((nbits) + (8 * sizeof(long)) - 1) / (8 * sizeof(long)));
+ if (!(__builtin_constant_p(nbits) && (nbits) <= 32)) {
+  int len = (nlongs - 1) * sizeof(unsigned long);
+  memset(dst, 0xff, len);
+ }
+ dst[nlongs - 1] = ( ((nbits) % 32) ? (1UL<<((nbits) % 32))-1 : ~0UL );
+}
+static inline __attribute__((always_inline)) void bitmap_copy(unsigned long *dst, const unsigned long *src,
+   int nbits)
+{
+ if ((__builtin_constant_p(nbits) && (nbits) <= 32))
+  *dst = *src;
+ else {
+  int len = (((nbits) + (8 * sizeof(long)) - 1) / (8 * sizeof(long))) * sizeof(unsigned long);
+  memcpy(dst, src, len);
+ }
+}
+static inline __attribute__((always_inline)) int bitmap_and(unsigned long *dst, const unsigned long *src1,
+   const unsigned long *src2, int nbits)
+{
+ if ((__builtin_constant_p(nbits) && (nbits) <= 32))
+  return (*dst = *src1 & *src2) != 0;
+ return __bitmap_and(dst, src1, src2, nbits);
+}
+static inline __attribute__((always_inline)) void bitmap_or(unsigned long *dst, const unsigned long *src1,
+   const unsigned long *src2, int nbits)
+{
+ if ((__builtin_constant_p(nbits) && (nbits) <= 32))
+  *dst = *src1 | *src2;
+ else
+  __bitmap_or(dst, src1, src2, nbits);
+}
+static inline __attribute__((always_inline)) void bitmap_xor(unsigned long *dst, const unsigned long *src1,
+   const unsigned long *src2, int nbits)
+{
+ if ((__builtin_constant_p(nbits) && (nbits) <= 32))
+  *dst = *src1 ^ *src2;
+ else
+  __bitmap_xor(dst, src1, src2, nbits);
+}
+static inline __attribute__((always_inline)) int bitmap_andnot(unsigned long *dst, const unsigned long *src1,
+   const unsigned long *src2, int nbits)
+{
+ if ((__builtin_constant_p(nbits) && (nbits) <= 32))
+  return (*dst = *src1 & ~(*src2)) != 0;
+ return __bitmap_andnot(dst, src1, src2, nbits);
+}
+static inline __attribute__((always_inline)) void bitmap_complement(unsigned long *dst, const unsigned long *src,
+   int nbits)
+{
+ if ((__builtin_constant_p(nbits) && (nbits) <= 32))
+  *dst = ~(*src) & ( ((nbits) % 32) ? (1UL<<((nbits) % 32))-1 : ~0UL );
+ else
+  __bitmap_complement(dst, src, nbits);
+}
+static inline __attribute__((always_inline)) int bitmap_equal(const unsigned long *src1,
+   const unsigned long *src2, int nbits)
+{
+ if ((__builtin_constant_p(nbits) && (nbits) <= 32))
+  return ! ((*src1 ^ *src2) & ( ((nbits) % 32) ? (1UL<<((nbits) % 32))-1 : ~0UL ));
+ else
+  return __bitmap_equal(src1, src2, nbits);
+}
+static inline __attribute__((always_inline)) int bitmap_intersects(const unsigned long *src1,
+   const unsigned long *src2, int nbits)
+{
+ if ((__builtin_constant_p(nbits) && (nbits) <= 32))
+  return ((*src1 & *src2) & ( ((nbits) % 32) ? (1UL<<((nbits) % 32))-1 : ~0UL )) != 0;
+ else
+  return __bitmap_intersects(src1, src2, nbits);
+}
+static inline __attribute__((always_inline)) int bitmap_subset(const unsigned long *src1,
+   const unsigned long *src2, int nbits)
+{
+ if ((__builtin_constant_p(nbits) && (nbits) <= 32))
+  return ! ((*src1 & ~(*src2)) & ( ((nbits) % 32) ? (1UL<<((nbits) % 32))-1 : ~0UL ));
+ else
+  return __bitmap_subset(src1, src2, nbits);
+}
+static inline __attribute__((always_inline)) int bitmap_empty(const unsigned long *src, int nbits)
+{
+ if ((__builtin_constant_p(nbits) && (nbits) <= 32))
+  return ! (*src & ( ((nbits) % 32) ? (1UL<<((nbits) % 32))-1 : ~0UL ));
+ else
+  return __bitmap_empty(src, nbits);
+}
+static inline __attribute__((always_inline)) int bitmap_full(const unsigned long *src, int nbits)
+{
+ if ((__builtin_constant_p(nbits) && (nbits) <= 32))
+  return ! (~(*src) & ( ((nbits) % 32) ? (1UL<<((nbits) % 32))-1 : ~0UL ));
+ else
+  return __bitmap_full(src, nbits);
+}
+static inline __attribute__((always_inline)) int bitmap_weight(const unsigned long *src, int nbits)
+{
+ if ((__builtin_constant_p(nbits) && (nbits) <= 32))
+  return hweight_long(*src & ( ((nbits) % 32) ? (1UL<<((nbits) % 32))-1 : ~0UL ));
+ return __bitmap_weight(src, nbits);
+}
+static inline __attribute__((always_inline)) void bitmap_shift_right(unsigned long *dst,
+   const unsigned long *src, int n, int nbits)
+{
+ if ((__builtin_constant_p(nbits) && (nbits) <= 32))
+  *dst = *src >> n;
+ else
+  __bitmap_shift_right(dst, src, n, nbits);
+}
+static inline __attribute__((always_inline)) void bitmap_shift_left(unsigned long *dst,
+   const unsigned long *src, int n, int nbits)
+{
+ if ((__builtin_constant_p(nbits) && (nbits) <= 32))
+  *dst = (*src << n) & ( ((nbits) % 32) ? (1UL<<((nbits) % 32))-1 : ~0UL );
+ else
+  __bitmap_shift_left(dst, src, n, nbits);
+}
+static inline __attribute__((always_inline)) int bitmap_parse(const char *buf, unsigned int buflen,
+   unsigned long *maskp, int nmaskbits)
+{
+ return __bitmap_parse(buf, buflen, 0, maskp, nmaskbits);
+}
+typedef struct { unsigned long bits[((((1 << 0)) + (8 * sizeof(long)) - 1) / (8 * sizeof(long)))]; } nodemask_t;
+extern nodemask_t _unused_nodemask_arg_;
+static inline __attribute__((always_inline)) void __node_set(int node, volatile nodemask_t *dstp)
+{
+ set_bit(node, dstp->bits);
+}
+static inline __attribute__((always_inline)) void __node_clear(int node, volatile nodemask_t *dstp)
+{
+ clear_bit(node, dstp->bits);
+}
+static inline __attribute__((always_inline)) void __nodes_setall(nodemask_t *dstp, int nbits)
+{
+ bitmap_fill(dstp->bits, nbits);
+}
+static inline __attribute__((always_inline)) void __nodes_clear(nodemask_t *dstp, int nbits)
+{
+ bitmap_zero(dstp->bits, nbits);
+}
+static inline __attribute__((always_inline)) int __node_test_and_set(int node, nodemask_t *addr)
+{
+ return test_and_set_bit(node, addr->bits);
+}
+static inline __attribute__((always_inline)) void __nodes_and(nodemask_t *dstp, const nodemask_t *src1p,
+     const nodemask_t *src2p, int nbits)
+{
+ bitmap_and(dstp->bits, src1p->bits, src2p->bits, nbits);
+}
+static inline __attribute__((always_inline)) void __nodes_or(nodemask_t *dstp, const nodemask_t *src1p,
+     const nodemask_t *src2p, int nbits)
+{
+ bitmap_or(dstp->bits, src1p->bits, src2p->bits, nbits);
+}
+static inline __attribute__((always_inline)) void __nodes_xor(nodemask_t *dstp, const nodemask_t *src1p,
+     const nodemask_t *src2p, int nbits)
+{
+ bitmap_xor(dstp->bits, src1p->bits, src2p->bits, nbits);
+}
+static inline __attribute__((always_inline)) void __nodes_andnot(nodemask_t *dstp, const nodemask_t *src1p,
+     const nodemask_t *src2p, int nbits)
+{
+ bitmap_andnot(dstp->bits, src1p->bits, src2p->bits, nbits);
+}
+static inline __attribute__((always_inline)) void __nodes_complement(nodemask_t *dstp,
+     const nodemask_t *srcp, int nbits)
+{
+ bitmap_complement(dstp->bits, srcp->bits, nbits);
+}
+static inline __attribute__((always_inline)) int __nodes_equal(const nodemask_t *src1p,
+     const nodemask_t *src2p, int nbits)
+{
+ return bitmap_equal(src1p->bits, src2p->bits, nbits);
+}
+static inline __attribute__((always_inline)) int __nodes_intersects(const nodemask_t *src1p,
+     const nodemask_t *src2p, int nbits)
+{
+ return bitmap_intersects(src1p->bits, src2p->bits, nbits);
+}
+static inline __attribute__((always_inline)) int __nodes_subset(const nodemask_t *src1p,
+     const nodemask_t *src2p, int nbits)
+{
+ return bitmap_subset(src1p->bits, src2p->bits, nbits);
+}
+static inline __attribute__((always_inline)) int __nodes_empty(const nodemask_t *srcp, int nbits)
+{
+ return bitmap_empty(srcp->bits, nbits);
+}
+static inline __attribute__((always_inline)) int __nodes_full(const nodemask_t *srcp, int nbits)
+{
+ return bitmap_full(srcp->bits, nbits);
+}
+static inline __attribute__((always_inline)) int __nodes_weight(const nodemask_t *srcp, int nbits)
+{
+ return bitmap_weight(srcp->bits, nbits);
+}
+static inline __attribute__((always_inline)) void __nodes_shift_right(nodemask_t *dstp,
+     const nodemask_t *srcp, int n, int nbits)
+{
+ bitmap_shift_right(dstp->bits, srcp->bits, n, nbits);
+}
+static inline __attribute__((always_inline)) void __nodes_shift_left(nodemask_t *dstp,
+     const nodemask_t *srcp, int n, int nbits)
+{
+ bitmap_shift_left(dstp->bits, srcp->bits, n, nbits);
+}
+static inline __attribute__((always_inline)) int __first_node(const nodemask_t *srcp)
+{
+ return ({ int __min1 = ((1 << 0)); int __min2 = (find_next_bit((srcp->bits), ((1 << 0)), 0)); __min1 < __min2 ? __min1: __min2; });
+}
+static inline __attribute__((always_inline)) int __next_node(int n, const nodemask_t *srcp)
+{
+ return ({ int __min1 = ((1 << 0)); int __min2 = (find_next_bit(srcp->bits, (1 << 0), n+1)); __min1 < __min2 ? __min1: __min2; });
+}
+static inline __attribute__((always_inline)) int __first_unset_node(const nodemask_t *maskp)
+{
+ return ({ int __min1 = ((1 << 0)); int __min2 = (find_next_zero_bit((maskp->bits), ((1 << 0)), 0)); __min1 < __min2 ? __min1: __min2; })
+                                                  ;
+}
+static inline __attribute__((always_inline)) int __nodemask_scnprintf(char *buf, int len,
+     const nodemask_t *srcp, int nbits)
+{
+ return bitmap_scnprintf(buf, len, srcp->bits, nbits);
+}
+static inline __attribute__((always_inline)) int __nodemask_parse_user(const char *buf, int len,
+     nodemask_t *dstp, int nbits)
+{
+ return bitmap_parse_user(buf, len, dstp->bits, nbits);
+}
+static inline __attribute__((always_inline)) int __nodelist_scnprintf(char *buf, int len,
+     const nodemask_t *srcp, int nbits)
+{
+ return bitmap_scnlistprintf(buf, len, srcp->bits, nbits);
+}
+static inline __attribute__((always_inline)) int __nodelist_parse(const char *buf, nodemask_t *dstp, int nbits)
+{
+ return bitmap_parselist(buf, dstp->bits, nbits);
+}
+static inline __attribute__((always_inline)) int __node_remap(int oldbit,
+  const nodemask_t *oldp, const nodemask_t *newp, int nbits)
+{
+ return bitmap_bitremap(oldbit, oldp->bits, newp->bits, nbits);
+}
+static inline __attribute__((always_inline)) void __nodes_remap(nodemask_t *dstp, const nodemask_t *srcp,
+  const nodemask_t *oldp, const nodemask_t *newp, int nbits)
+{
+ bitmap_remap(dstp->bits, srcp->bits, oldp->bits, newp->bits, nbits);
+}
+static inline __attribute__((always_inline)) void __nodes_onto(nodemask_t *dstp, const nodemask_t *origp,
+  const nodemask_t *relmapp, int nbits)
+{
+ bitmap_onto(dstp->bits, origp->bits, relmapp->bits, nbits);
+}
+static inline __attribute__((always_inline)) void __nodes_fold(nodemask_t *dstp, const nodemask_t *origp,
+  int sz, int nbits)
+{
+ bitmap_fold(dstp->bits, origp->bits, sz, nbits);
+}
+enum node_states {
+ N_POSSIBLE,
+ N_ONLINE,
+ N_NORMAL_MEMORY,
+ N_HIGH_MEMORY = N_NORMAL_MEMORY,
+ N_CPU,
+ NR_NODE_STATES
+};
+extern nodemask_t node_states[NR_NODE_STATES];
+static inline __attribute__((always_inline)) int node_state(int node, enum node_states state)
+{
+ return node == 0;
+}
+static inline __attribute__((always_inline)) void node_set_state(int node, enum node_states state)
+{
+}
+static inline __attribute__((always_inline)) void node_clear_state(int node, enum node_states state)
+{
+}
+static inline __attribute__((always_inline)) int num_node_state(enum node_states state)
+{
+ return 1;
+}
+struct nodemask_scratch {
+ nodemask_t mask1;
+ nodemask_t mask2;
+};
+enum pageblock_bits {
+ PB_migrate,
+ PB_migrate_end = PB_migrate + 3 - 1,
+ NR_PAGEBLOCK_BITS
+};
+struct page;
+unsigned long get_pageblock_flags_group(struct page *page,
+     int start_bitidx, int end_bitidx);
+void set_pageblock_flags_group(struct page *page, unsigned long flags,
+     int start_bitidx, int end_bitidx);
+extern int page_group_by_mobility_disabled;
+static inline __attribute__((always_inline)) int get_pageblock_migratetype(struct page *page)
+{
+ return get_pageblock_flags_group(page, PB_migrate, PB_migrate_end);
+}
+struct free_area {
+ struct list_head free_list[5];
+ unsigned long nr_free;
+};
+struct pglist_data;
+enum zone_stat_item {
+ NR_FREE_PAGES,
+ NR_LRU_BASE,
+ NR_INACTIVE_ANON = NR_LRU_BASE,
+ NR_ACTIVE_ANON,
+ NR_INACTIVE_FILE,
+ NR_ACTIVE_FILE,
+ NR_UNEVICTABLE,
+ NR_MLOCK,
+ NR_ANON_PAGES,
+ NR_FILE_MAPPED,
+ NR_FILE_PAGES,
+ NR_FILE_DIRTY,
+ NR_WRITEBACK,
+ NR_SLAB_RECLAIMABLE,
+ NR_SLAB_UNRECLAIMABLE,
+ NR_PAGETABLE,
+ NR_KERNEL_STACK,
+ NR_UNSTABLE_NFS,
+ NR_BOUNCE,
+ NR_VMSCAN_WRITE,
+ NR_WRITEBACK_TEMP,
+ NR_ISOLATED_ANON,
+ NR_ISOLATED_FILE,
+ NR_SHMEM,
+ NR_VM_ZONE_STAT_ITEMS };
+enum lru_list {
+ LRU_INACTIVE_ANON = 0,
+ LRU_ACTIVE_ANON = 0 + 1,
+ LRU_INACTIVE_FILE = 0 + 2,
+ LRU_ACTIVE_FILE = 0 + 2 + 1,
+ LRU_UNEVICTABLE,
+ NR_LRU_LISTS
+};
+static inline __attribute__((always_inline)) int is_file_lru(enum lru_list l)
+{
+ return (l == LRU_INACTIVE_FILE || l == LRU_ACTIVE_FILE);
+}
+static inline __attribute__((always_inline)) int is_active_lru(enum lru_list l)
+{
+ return (l == LRU_ACTIVE_ANON || l == LRU_ACTIVE_FILE);
+}
+static inline __attribute__((always_inline)) int is_unevictable_lru(enum lru_list l)
+{
+ return (l == LRU_UNEVICTABLE);
+}
+enum zone_watermarks {
+ WMARK_MIN,
+ WMARK_LOW,
+ WMARK_HIGH,
+ NR_WMARK
+};
+struct per_cpu_pages {
+ int count;
+ int high;
+ int batch;
+ struct list_head lists[3];
+};
+struct per_cpu_pageset {
+ struct per_cpu_pages pcp;
+} ;
+enum zone_type {
+ ZONE_NORMAL,
+ ZONE_MOVABLE,
+ __MAX_NR_ZONES
+};
+struct zone_reclaim_stat {
+ unsigned long recent_rotated[2];
+ unsigned long recent_scanned[2];
+ unsigned long nr_saved_scan[NR_LRU_LISTS];
+};
+struct zone {
+ unsigned long watermark[NR_WMARK];
+ unsigned long lowmem_reserve[2];
+ struct per_cpu_pageset pageset[1];
+ spinlock_t lock;
+ struct free_area free_area[11];
+ unsigned long *pageblock_flags;
+ spinlock_t lru_lock;
+ struct zone_lru {
+  struct list_head list;
+ } lru[NR_LRU_LISTS];
+ struct zone_reclaim_stat reclaim_stat;
+ unsigned long pages_scanned;
+ unsigned long flags;
+ atomic_long_t vm_stat[NR_VM_ZONE_STAT_ITEMS];
+ int prev_priority;
+ unsigned int inactive_ratio;
+ wait_queue_head_t * wait_table;
+ unsigned long wait_table_hash_nr_entries;
+ unsigned long wait_table_bits;
+ struct pglist_data *zone_pgdat;
+ unsigned long zone_start_pfn;
+ unsigned long spanned_pages;
+ unsigned long present_pages;
+ const char *name;
+} ;
+typedef enum {
+ ZONE_ALL_UNRECLAIMABLE,
+ ZONE_RECLAIM_LOCKED,
+ ZONE_OOM_LOCKED,
+} zone_flags_t;
+static inline __attribute__((always_inline)) void zone_set_flag(struct zone *zone, zone_flags_t flag)
+{
+ set_bit(flag, &zone->flags);
+}
+static inline __attribute__((always_inline)) int zone_test_and_set_flag(struct zone *zone, zone_flags_t flag)
+{
+ return test_and_set_bit(flag, &zone->flags);
+}
+static inline __attribute__((always_inline)) void zone_clear_flag(struct zone *zone, zone_flags_t flag)
+{
+ clear_bit(flag, &zone->flags);
+}
+static inline __attribute__((always_inline)) int zone_is_all_unreclaimable(const struct zone *zone)
+{
+ return test_bit(ZONE_ALL_UNRECLAIMABLE, &zone->flags);
+}
+static inline __attribute__((always_inline)) int zone_is_reclaim_locked(const struct zone *zone)
+{
+ return test_bit(ZONE_RECLAIM_LOCKED, &zone->flags);
+}
+static inline __attribute__((always_inline)) int zone_is_oom_locked(const struct zone *zone)
+{
+ return test_bit(ZONE_OOM_LOCKED, &zone->flags);
+}
+struct zonelist_cache;
+struct zoneref {
+ struct zone *zone;
+ int zone_idx;
+};
+struct zonelist {
+ struct zonelist_cache *zlcache_ptr;
+ struct zoneref _zonerefs[((1 << 0) * 2) + 1];
+};
+struct node_active_region {
+ unsigned long start_pfn;
+ unsigned long end_pfn;
+ int nid;
+};
+extern struct page *mem_map;
+struct bootmem_data;
+typedef struct pglist_data {
+ struct zone node_zones[2];
+ struct zonelist node_zonelists[1];
+ int nr_zones;
+ struct page *node_mem_map;
+ struct bootmem_data *bdata;
+ unsigned long node_start_pfn;
+ unsigned long node_present_pages;
+ unsigned long node_spanned_pages;
+ int node_id;
+ wait_queue_head_t kswapd_wait;
+ struct task_struct *kswapd;
+ int kswapd_max_order;
+} pg_data_t;
+struct mutex {
+ atomic_t count;
+ spinlock_t wait_lock;
+ struct list_head wait_list;
+};
+struct mutex_waiter {
+ struct list_head list;
+ struct task_struct *task;
+};
+extern void __mutex_init(struct mutex *lock, const char *name,
+    struct lock_class_key *key);
+static inline __attribute__((always_inline)) int mutex_is_locked(struct mutex *lock)
+{
+ return ((&lock->count)->counter) != 1;
+}
+extern void mutex_lock(struct mutex *lock);
+extern int mutex_lock_interruptible(struct mutex *lock);
+extern int mutex_lock_killable(struct mutex *lock);
+extern int mutex_trylock(struct mutex *lock);
+extern void mutex_unlock(struct mutex *lock);
+extern int atomic_dec_and_mutex_lock(atomic_t *cnt, struct mutex *lock);
+struct rw_semaphore;
+struct rwsem_waiter;
+struct rw_semaphore {
+ __s32 activity;
+ spinlock_t wait_lock;
+ struct list_head wait_list;
+};
+extern void __init_rwsem(struct rw_semaphore *sem, const char *name,
+    struct lock_class_key *key);
+extern void __down_read(struct rw_semaphore *sem);
+extern int __down_read_trylock(struct rw_semaphore *sem);
+extern void __down_write(struct rw_semaphore *sem);
+extern void __down_write_nested(struct rw_semaphore *sem, int subclass);
+extern int __down_write_trylock(struct rw_semaphore *sem);
+extern void __up_read(struct rw_semaphore *sem);
+extern void __up_write(struct rw_semaphore *sem);
+extern void __downgrade_write(struct rw_semaphore *sem);
+static inline __attribute__((always_inline)) int rwsem_is_locked(struct rw_semaphore *sem)
+{
+ return (sem->activity != 0);
+}
+extern void down_read(struct rw_semaphore *sem);
+extern int down_read_trylock(struct rw_semaphore *sem);
+extern void down_write(struct rw_semaphore *sem);
+extern int down_write_trylock(struct rw_semaphore *sem);
+extern void up_read(struct rw_semaphore *sem);
+extern void up_write(struct rw_semaphore *sem);
+extern void downgrade_write(struct rw_semaphore *sem);
+struct srcu_struct_array {
+ int c[2];
+};
+struct srcu_struct {
+ int completed;
+ struct srcu_struct_array *per_cpu_ref;
+ struct mutex mutex;
+};
+int init_srcu_struct(struct srcu_struct *sp);
+void cleanup_srcu_struct(struct srcu_struct *sp);
+int srcu_read_lock(struct srcu_struct *sp) ;
+void srcu_read_unlock(struct srcu_struct *sp, int idx) ;
+void synchronize_srcu(struct srcu_struct *sp);
+long srcu_batches_completed(struct srcu_struct *sp);
+struct notifier_block {
+ int (*notifier_call)(struct notifier_block *, unsigned long, void *);
+ struct notifier_block *next;
+ int priority;
+};
+struct atomic_notifier_head {
+ spinlock_t lock;
+ struct notifier_block *head;
+};
+struct blocking_notifier_head {
+ struct rw_semaphore rwsem;
+ struct notifier_block *head;
+};
+struct raw_notifier_head {
+ struct notifier_block *head;
+};
+struct srcu_notifier_head {
+ struct mutex mutex;
+ struct srcu_struct srcu;
+ struct notifier_block *head;
+};
+extern void srcu_init_notifier_head(struct srcu_notifier_head *nh);
+extern int atomic_notifier_chain_register(struct atomic_notifier_head *nh,
+  struct notifier_block *nb);
+extern int blocking_notifier_chain_register(struct blocking_notifier_head *nh,
+  struct notifier_block *nb);
+extern int raw_notifier_chain_register(struct raw_notifier_head *nh,
+  struct notifier_block *nb);
+extern int srcu_notifier_chain_register(struct srcu_notifier_head *nh,
+  struct notifier_block *nb);
+extern int blocking_notifier_chain_cond_register(
+  struct blocking_notifier_head *nh,
+  struct notifier_block *nb);
+extern int atomic_notifier_chain_unregister(struct atomic_notifier_head *nh,
+  struct notifier_block *nb);
+extern int blocking_notifier_chain_unregister(struct blocking_notifier_head *nh,
+  struct notifier_block *nb);
+extern int raw_notifier_chain_unregister(struct raw_notifier_head *nh,
+  struct notifier_block *nb);
+extern int srcu_notifier_chain_unregister(struct srcu_notifier_head *nh,
+  struct notifier_block *nb);
+extern int atomic_notifier_call_chain(struct atomic_notifier_head *nh,
+  unsigned long val, void *v);
+extern int __atomic_notifier_call_chain(struct atomic_notifier_head *nh,
+ unsigned long val, void *v, int nr_to_call, int *nr_calls);
+extern int blocking_notifier_call_chain(struct blocking_notifier_head *nh,
+  unsigned long val, void *v);
+extern int __blocking_notifier_call_chain(struct blocking_notifier_head *nh,
+ unsigned long val, void *v, int nr_to_call, int *nr_calls);
+extern int raw_notifier_call_chain(struct raw_notifier_head *nh,
+  unsigned long val, void *v);
+extern int __raw_notifier_call_chain(struct raw_notifier_head *nh,
+ unsigned long val, void *v, int nr_to_call, int *nr_calls);
+extern int srcu_notifier_call_chain(struct srcu_notifier_head *nh,
+  unsigned long val, void *v);
+extern int __srcu_notifier_call_chain(struct srcu_notifier_head *nh,
+ unsigned long val, void *v, int nr_to_call, int *nr_calls);
+static inline __attribute__((always_inline)) int notifier_from_errno(int err)
+{
+ return 0x8000 | (0x0001 - err);
+}
+static inline __attribute__((always_inline)) int notifier_to_errno(int ret)
+{
+ ret &= ~0x8000;
+ return ret > 0x0001 ? 0x0001 - ret : 0;
+}
+extern struct blocking_notifier_head reboot_notifier_list;
+struct page;
+struct zone;
+struct pglist_data;
+struct mem_section;
+static inline __attribute__((always_inline)) void pgdat_resize_lock(struct pglist_data *p, unsigned long *f) {}
+static inline __attribute__((always_inline)) void pgdat_resize_unlock(struct pglist_data *p, unsigned long *f) {}
+static inline __attribute__((always_inline)) void pgdat_resize_init(struct pglist_data *pgdat) {}
+static inline __attribute__((always_inline)) unsigned zone_span_seqbegin(struct zone *zone)
+{
+ return 0;
+}
+static inline __attribute__((always_inline)) int zone_span_seqretry(struct zone *zone, unsigned iv)
+{
+ return 0;
+}
+static inline __attribute__((always_inline)) void zone_span_writelock(struct zone *zone) {}
+static inline __attribute__((always_inline)) void zone_span_writeunlock(struct zone *zone) {}
+static inline __attribute__((always_inline)) void zone_seqlock_init(struct zone *zone) {}
+static inline __attribute__((always_inline)) int mhp_notimplemented(const char *func)
+{
+ printk("<4>" "%s() called, with CONFIG_MEMORY_HOTPLUG disabled\n", func);
+ dump_stack();
+ return -38;
+}
+static inline __attribute__((always_inline)) void register_page_bootmem_info_node(struct pglist_data *pgdat)
+{
+}
+static inline __attribute__((always_inline)) int is_mem_section_removable(unsigned long pfn,
+     unsigned long nr_pages)
+{
+ return 0;
+}
+extern int add_memory(int nid, u64 start, u64 size);
+extern int arch_add_memory(int nid, u64 start, u64 size);
+extern int remove_memory(u64 start, u64 size);
+extern int sparse_add_one_section(struct zone *zone, unsigned long start_pfn,
+        int nr_pages);
+extern void sparse_remove_one_section(struct zone *zone, struct mem_section *ms);
+extern struct page *sparse_decode_mem_map(unsigned long coded_mem_map,
+       unsigned long pnum);
+void get_zone_counts(unsigned long *active, unsigned long *inactive,
+   unsigned long *free);
+void build_all_zonelists(void);
+void wakeup_kswapd(struct zone *zone, int order);
+int zone_watermark_ok(struct zone *z, int order, unsigned long mark,
+  int classzone_idx, int alloc_flags);
+enum memmap_context {
+ MEMMAP_EARLY,
+ MEMMAP_HOTPLUG,
+};
+extern int init_currently_empty_zone(struct zone *zone, unsigned long start_pfn,
+         unsigned long size,
+         enum memmap_context context);
+static inline __attribute__((always_inline)) void memory_present(int nid, unsigned long start, unsigned long end) {}
+static inline __attribute__((always_inline)) int populated_zone(struct zone *zone)
+{
+ return (!!zone->present_pages);
+}
+extern int movable_zone;
+static inline __attribute__((always_inline)) int zone_movable_is_highmem(void)
+{
+ return 0;
+}
+static inline __attribute__((always_inline)) int is_highmem_idx(enum zone_type idx)
+{
+ return 0;
+}
+static inline __attribute__((always_inline)) int is_normal_idx(enum zone_type idx)
+{
+ return (idx == ZONE_NORMAL);
+}
+static inline __attribute__((always_inline)) int is_highmem(struct zone *zone)
+{
+ return 0;
+}
+static inline __attribute__((always_inline)) int is_normal(struct zone *zone)
+{
+ return zone == zone->zone_pgdat->node_zones + ZONE_NORMAL;
+}
+static inline __attribute__((always_inline)) int is_dma32(struct zone *zone)
+{
+ return 0;
+}
+static inline __attribute__((always_inline)) int is_dma(struct zone *zone)
+{
+ return 0;
+}
+struct ctl_table;
+int min_free_kbytes_sysctl_handler(struct ctl_table *, int,
+     void *, size_t *, loff_t *);
+extern int sysctl_lowmem_reserve_ratio[2 -1];
+int lowmem_reserve_ratio_sysctl_handler(struct ctl_table *, int,
+     void *, size_t *, loff_t *);
+int percpu_pagelist_fraction_sysctl_handler(struct ctl_table *, int,
+     void *, size_t *, loff_t *);
+int sysctl_min_unmapped_ratio_sysctl_handler(struct ctl_table *, int,
+   void *, size_t *, loff_t *);
+int sysctl_min_slab_ratio_sysctl_handler(struct ctl_table *, int,
+   void *, size_t *, loff_t *);
+extern int numa_zonelist_order_handler(struct ctl_table *, int,
+   void *, size_t *, loff_t *);
+extern char numa_zonelist_order[];
+extern struct pglist_data contig_page_data;
+extern struct pglist_data *first_online_pgdat(void);
+extern struct pglist_data *next_online_pgdat(struct pglist_data *pgdat);
+extern struct zone *next_zone(struct zone *zone);
+static inline __attribute__((always_inline)) struct zone *zonelist_zone(struct zoneref *zoneref)
+{
+ return zoneref->zone;
+}
+static inline __attribute__((always_inline)) int zonelist_zone_idx(struct zoneref *zoneref)
+{
+ return zoneref->zone_idx;
+}
+static inline __attribute__((always_inline)) int zonelist_node_idx(struct zoneref *zoneref)
+{
+ return 0;
+}
+struct zoneref *next_zones_zonelist(struct zoneref *z,
+     enum zone_type highest_zoneidx,
+     nodemask_t *nodes,
+     struct zone **zone);
+static inline __attribute__((always_inline)) struct zoneref *first_zones_zonelist(struct zonelist *zonelist,
+     enum zone_type highest_zoneidx,
+     nodemask_t *nodes,
+     struct zone **zone)
+{
+ return next_zones_zonelist(zonelist->_zonerefs, highest_zoneidx, nodes,
+        zone);
+}
+void memory_present(int nid, unsigned long start, unsigned long end);
+unsigned long __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) __attribute__((no_instrument_function)) node_memmap_size_bytes(int, unsigned long, unsigned long);
+static inline __attribute__((always_inline)) int memmap_valid_within(unsigned long pfn,
+     struct page *page, struct zone *zone)
+{
+ return 1;
+}
+typedef struct cpumask { unsigned long bits[(((1) + (8 * sizeof(long)) - 1) / (8 * sizeof(long)))]; } cpumask_t;
+extern const struct cpumask *const cpu_possible_mask;
+extern const struct cpumask *const cpu_online_mask;
+extern const struct cpumask *const cpu_present_mask;
+extern const struct cpumask *const cpu_active_mask;
+static inline __attribute__((always_inline)) unsigned int cpumask_check(unsigned int cpu)
+{
+ return cpu;
+}
+static inline __attribute__((always_inline)) unsigned int cpumask_first(const struct cpumask *srcp)
+{
+ return 0;
+}
+static inline __attribute__((always_inline)) unsigned int cpumask_next(int n, const struct cpumask *srcp)
+{
+ return n+1;
+}
+static inline __attribute__((always_inline)) unsigned int cpumask_next_zero(int n, const struct cpumask *srcp)
+{
+ return n+1;
+}
+static inline __attribute__((always_inline)) unsigned int cpumask_next_and(int n,
+         const struct cpumask *srcp,
+         const struct cpumask *andp)
+{
+ return n+1;
+}
+static inline __attribute__((always_inline)) unsigned int cpumask_any_but(const struct cpumask *mask,
+        unsigned int cpu)
+{
+ return 1;
+}
+static inline __attribute__((always_inline)) void cpumask_set_cpu(unsigned int cpu, struct cpumask *dstp)
+{
+ set_bit(cpumask_check(cpu), ((dstp)->bits));
+}
+static inline __attribute__((always_inline)) void cpumask_clear_cpu(int cpu, struct cpumask *dstp)
+{
+ clear_bit(cpumask_check(cpu), ((dstp)->bits));
+}
+static inline __attribute__((always_inline)) int cpumask_test_and_set_cpu(int cpu, struct cpumask *cpumask)
+{
+ return test_and_set_bit(cpumask_check(cpu), ((cpumask)->bits));
+}
+static inline __attribute__((always_inline)) int cpumask_test_and_clear_cpu(int cpu, struct cpumask *cpumask)
+{
+ return test_and_clear_bit(cpumask_check(cpu), ((cpumask)->bits));
+}
+static inline __attribute__((always_inline)) void cpumask_setall(struct cpumask *dstp)
+{
+ bitmap_fill(((dstp)->bits), 1);
+}
+static inline __attribute__((always_inline)) void cpumask_clear(struct cpumask *dstp)
+{
+ bitmap_zero(((dstp)->bits), 1);
+}
+static inline __attribute__((always_inline)) int cpumask_and(struct cpumask *dstp,
+          const struct cpumask *src1p,
+          const struct cpumask *src2p)
+{
+ return bitmap_and(((dstp)->bits), ((src1p)->bits),
+           ((src2p)->bits), 1);
+}
+static inline __attribute__((always_inline)) void cpumask_or(struct cpumask *dstp, const struct cpumask *src1p,
+         const struct cpumask *src2p)
+{
+ bitmap_or(((dstp)->bits), ((src1p)->bits),
+          ((src2p)->bits), 1);
+}
+static inline __attribute__((always_inline)) void cpumask_xor(struct cpumask *dstp,
+          const struct cpumask *src1p,
+          const struct cpumask *src2p)
+{
+ bitmap_xor(((dstp)->bits), ((src1p)->bits),
+           ((src2p)->bits), 1);
+}
+static inline __attribute__((always_inline)) int cpumask_andnot(struct cpumask *dstp,
+      const struct cpumask *src1p,
+      const struct cpumask *src2p)
+{
+ return bitmap_andnot(((dstp)->bits), ((src1p)->bits),
+       ((src2p)->bits), 1);
+}
+static inline __attribute__((always_inline)) void cpumask_complement(struct cpumask *dstp,
+          const struct cpumask *srcp)
+{
+ bitmap_complement(((dstp)->bits), ((srcp)->bits),
+           1);
+}
+static inline __attribute__((always_inline)) bool cpumask_equal(const struct cpumask *src1p,
+    const struct cpumask *src2p)
+{
+ return bitmap_equal(((src1p)->bits), ((src2p)->bits),
+       1);
+}
+static inline __attribute__((always_inline)) bool cpumask_intersects(const struct cpumask *src1p,
+         const struct cpumask *src2p)
+{
+ return bitmap_intersects(((src1p)->bits), ((src2p)->bits),
+            1);
+}
+static inline __attribute__((always_inline)) int cpumask_subset(const struct cpumask *src1p,
+     const struct cpumask *src2p)
+{
+ return bitmap_subset(((src1p)->bits), ((src2p)->bits),
+        1);
+}
+static inline __attribute__((always_inline)) bool cpumask_empty(const struct cpumask *srcp)
+{
+ return bitmap_empty(((srcp)->bits), 1);
+}
+static inline __attribute__((always_inline)) bool cpumask_full(const struct cpumask *srcp)
+{
+ return bitmap_full(((srcp)->bits), 1);
+}
+static inline __attribute__((always_inline)) unsigned int cpumask_weight(const struct cpumask *srcp)
+{
+ return bitmap_weight(((srcp)->bits), 1);
+}
+static inline __attribute__((always_inline)) void cpumask_shift_right(struct cpumask *dstp,
+           const struct cpumask *srcp, int n)
+{
+ bitmap_shift_right(((dstp)->bits), ((srcp)->bits), n,
+            1);
+}
+static inline __attribute__((always_inline)) void cpumask_shift_left(struct cpumask *dstp,
+          const struct cpumask *srcp, int n)
+{
+ bitmap_shift_left(((dstp)->bits), ((srcp)->bits), n,
+           1);
+}
+static inline __attribute__((always_inline)) void cpumask_copy(struct cpumask *dstp,
+    const struct cpumask *srcp)
+{
+ bitmap_copy(((dstp)->bits), ((srcp)->bits), 1);
+}
+static inline __attribute__((always_inline)) int cpumask_scnprintf(char *buf, int len,
+        const struct cpumask *srcp)
+{
+ return bitmap_scnprintf(buf, len, ((srcp)->bits), 1);
+}
+static inline __attribute__((always_inline)) int cpumask_parse_user(const char *buf, int len,
+         struct cpumask *dstp)
+{
+ return bitmap_parse_user(buf, len, ((dstp)->bits), 1);
+}
+static inline __attribute__((always_inline)) int cpulist_scnprintf(char *buf, int len,
+        const struct cpumask *srcp)
+{
+ return bitmap_scnlistprintf(buf, len, ((srcp)->bits),
+        1);
+}
+static inline __attribute__((always_inline)) int cpulist_parse(const char *buf, struct cpumask *dstp)
+{
+ return bitmap_parselist(buf, ((dstp)->bits), 1);
+}
+static inline __attribute__((always_inline)) size_t cpumask_size(void)
+{
+ return (((1) + (8 * sizeof(long)) - 1) / (8 * sizeof(long))) * sizeof(long);
+}
+typedef struct cpumask cpumask_var_t[1];
+static inline __attribute__((always_inline)) bool alloc_cpumask_var(cpumask_var_t *mask, gfp_t flags)
+{
+ return true;
+}
+static inline __attribute__((always_inline)) bool alloc_cpumask_var_node(cpumask_var_t *mask, gfp_t flags,
+       int node)
+{
+ return true;
+}
+static inline __attribute__((always_inline)) bool zalloc_cpumask_var(cpumask_var_t *mask, gfp_t flags)
+{
+ cpumask_clear(*mask);
+ return true;
+}
+static inline __attribute__((always_inline)) bool zalloc_cpumask_var_node(cpumask_var_t *mask, gfp_t flags,
+       int node)
+{
+ cpumask_clear(*mask);
+ return true;
+}
+static inline __attribute__((always_inline)) void alloc_bootmem_cpumask_var(cpumask_var_t *mask)
+{
+}
+static inline __attribute__((always_inline)) void free_cpumask_var(cpumask_var_t mask)
+{
+}
+static inline __attribute__((always_inline)) void free_bootmem_cpumask_var(cpumask_var_t mask)
+{
+}
+extern const unsigned long cpu_all_bits[(((1) + (8 * sizeof(long)) - 1) / (8 * sizeof(long)))];
+void set_cpu_possible(unsigned int cpu, bool possible);
+void set_cpu_present(unsigned int cpu, bool present);
+void set_cpu_online(unsigned int cpu, bool online);
+void set_cpu_active(unsigned int cpu, bool active);
+void init_cpu_present(const struct cpumask *src);
+void init_cpu_possible(const struct cpumask *src);
+void init_cpu_online(const struct cpumask *src);
+static inline __attribute__((always_inline)) int __check_is_bitmap(const unsigned long *bitmap)
+{
+ return 1;
+}
+extern const unsigned long
+ cpu_bit_bitmap[32 +1][(((1) + (8 * sizeof(long)) - 1) / (8 * sizeof(long)))];
+static inline __attribute__((always_inline)) const struct cpumask *get_cpu_mask(unsigned int cpu)
+{
+ const unsigned long *p = cpu_bit_bitmap[1 + cpu % 32];
+ p -= cpu / 32;
+ return ((struct cpumask *)(1 ? (p) : (void *)sizeof(__check_is_bitmap(p))));
+}
+static inline __attribute__((always_inline)) void __cpu_set(int cpu, volatile cpumask_t *dstp)
+{
+ set_bit(cpu, dstp->bits);
+}
+static inline __attribute__((always_inline)) void __cpu_clear(int cpu, volatile cpumask_t *dstp)
+{
+ clear_bit(cpu, dstp->bits);
+}
+static inline __attribute__((always_inline)) void __cpus_setall(cpumask_t *dstp, int nbits)
+{
+ bitmap_fill(dstp->bits, nbits);
+}
+static inline __attribute__((always_inline)) void __cpus_clear(cpumask_t *dstp, int nbits)
+{
+ bitmap_zero(dstp->bits, nbits);
+}
+static inline __attribute__((always_inline)) int __cpu_test_and_set(int cpu, cpumask_t *addr)
+{
+ return test_and_set_bit(cpu, addr->bits);
+}
+static inline __attribute__((always_inline)) int __cpus_and(cpumask_t *dstp, const cpumask_t *src1p,
+     const cpumask_t *src2p, int nbits)
+{
+ return bitmap_and(dstp->bits, src1p->bits, src2p->bits, nbits);
+}
+static inline __attribute__((always_inline)) void __cpus_or(cpumask_t *dstp, const cpumask_t *src1p,
+     const cpumask_t *src2p, int nbits)
+{
+ bitmap_or(dstp->bits, src1p->bits, src2p->bits, nbits);
+}
+static inline __attribute__((always_inline)) void __cpus_xor(cpumask_t *dstp, const cpumask_t *src1p,
+     const cpumask_t *src2p, int nbits)
+{
+ bitmap_xor(dstp->bits, src1p->bits, src2p->bits, nbits);
+}
+static inline __attribute__((always_inline)) int __cpus_andnot(cpumask_t *dstp, const cpumask_t *src1p,
+     const cpumask_t *src2p, int nbits)
+{
+ return bitmap_andnot(dstp->bits, src1p->bits, src2p->bits, nbits);
+}
+static inline __attribute__((always_inline)) int __cpus_equal(const cpumask_t *src1p,
+     const cpumask_t *src2p, int nbits)
+{
+ return bitmap_equal(src1p->bits, src2p->bits, nbits);
+}
+static inline __attribute__((always_inline)) int __cpus_intersects(const cpumask_t *src1p,
+     const cpumask_t *src2p, int nbits)
+{
+ return bitmap_intersects(src1p->bits, src2p->bits, nbits);
+}
+static inline __attribute__((always_inline)) int __cpus_subset(const cpumask_t *src1p,
+     const cpumask_t *src2p, int nbits)
+{
+ return bitmap_subset(src1p->bits, src2p->bits, nbits);
+}
+static inline __attribute__((always_inline)) int __cpus_empty(const cpumask_t *srcp, int nbits)
+{
+ return bitmap_empty(srcp->bits, nbits);
+}
+static inline __attribute__((always_inline)) int __cpus_weight(const cpumask_t *srcp, int nbits)
+{
+ return bitmap_weight(srcp->bits, nbits);
+}
+static inline __attribute__((always_inline)) void __cpus_shift_left(cpumask_t *dstp,
+     const cpumask_t *srcp, int n, int nbits)
+{
+ bitmap_shift_left(dstp->bits, srcp->bits, n, nbits);
+}
+extern void cpu_idle(void);
+struct call_single_data {
+ struct list_head list;
+ void (*func) (void *info);
+ void *info;
+ u16 flags;
+ u16 priv;
+};
+extern unsigned int total_cpus;
+int smp_call_function_single(int cpuid, void (*func) (void *info), void *info,
+    int wait);
+static inline __attribute__((always_inline)) void smp_send_stop(void) { }
+static inline __attribute__((always_inline)) int up_smp_call_function(void (*func)(void *), void *info)
+{
+ return 0;
+}
+static inline __attribute__((always_inline)) void smp_send_reschedule(int cpu) { }
+static inline __attribute__((always_inline)) void init_call_single_data(void)
+{
+}
+extern void arch_disable_smp_support(void);
+void smp_setup_processor_id(void);
+int arch_update_cpu_topology(void);
+struct vm_area_struct;
+static inline __attribute__((always_inline)) int allocflags_to_migratetype(gfp_t gfp_flags)
+{
+ ({ int __ret_warn_on = !!((gfp_flags & ((( gfp_t)0x80000u)|(( gfp_t)0x08u))) == ((( gfp_t)0x80000u)|(( gfp_t)0x08u))); if (__builtin_constant_p(__ret_warn_on)) { if (__ret_warn_on) do { __asm__ __volatile__ ( "1:\t.short %O0\n" "\t.pushsection __bug_table,\"a\"\n" "2:\t.long 1b\n" "\t.short %O3\n" "\t.org 2b+%O4\n" "\t.popsection\n" : : "n" (0xc33e), "i" ("include/linux/gfp.h"), "i" (121), "i" ((1<<0)), "i" (sizeof(struct bug_entry))); } while (0); } else { if (__builtin_expect(!!(__ret_warn_on), 0)) do { __asm__ __volatile__ ( "1:\t.short %O0\n" "\t.pushsection __bug_table,\"a\"\n" "2:\t.long 1b\n" "\t.short %O3\n" "\t.org 2b+%O4\n" "\t.popsection\n" : : "n" (0xc33e), "i" ("include/linux/gfp.h"), "i" (121), "i" ((1<<0)), "i" (sizeof(struct bug_entry))); } while (0); } __builtin_expect(!!(__ret_warn_on), 0); });
+ if (__builtin_expect(!!(page_group_by_mobility_disabled), 0))
+  return 0;
+ return (((gfp_flags & (( gfp_t)0x08u)) != 0) << 1) |
+  ((gfp_flags & (( gfp_t)0x80000u)) != 0);
+}
+static inline __attribute__((always_inline)) enum zone_type gfp_zone(gfp_t flags)
+{
+ enum zone_type z;
+ int bit = flags & ((( gfp_t)0x01u)|(( gfp_t)0x02u)|(( gfp_t)0x04u)|(( gfp_t)0x08u));
+ z = (( (ZONE_NORMAL << 0 * 1) | (ZONE_NORMAL << (( gfp_t)0x01u) * 1) | (ZONE_NORMAL << (( gfp_t)0x02u) * 1) | (ZONE_NORMAL << (( gfp_t)0x04u) * 1) | (ZONE_NORMAL << (( gfp_t)0x08u) * 1) | (ZONE_NORMAL << ((( gfp_t)0x08u) | (( gfp_t)0x01u)) * 1) | (ZONE_MOVABLE << ((( gfp_t)0x08u) | (( gfp_t)0x02u)) * 1) | (ZONE_NORMAL << ((( gfp_t)0x08u) | (( gfp_t)0x04u)) * 1)) >> (bit * 1)) &
+      ((1 << 1) - 1);
+ if (__builtin_constant_p(bit))
+  ((void)sizeof(char[1 - 2 * !!((( 1 << ((( gfp_t)0x01u) | (( gfp_t)0x02u)) | 1 << ((( gfp_t)0x01u) | (( gfp_t)0x04u)) | 1 << ((( gfp_t)0x04u) | (( gfp_t)0x02u)) | 1 << ((( gfp_t)0x01u) | (( gfp_t)0x04u) | (( gfp_t)0x02u)) | 1 << ((( gfp_t)0x08u) | (( gfp_t)0x02u) | (( gfp_t)0x01u)) | 1 << ((( gfp_t)0x08u) | (( gfp_t)0x04u) | (( gfp_t)0x01u)) | 1 << ((( gfp_t)0x08u) | (( gfp_t)0x04u) | (( gfp_t)0x02u)) | 1 << ((( gfp_t)0x08u) | (( gfp_t)0x04u) | (( gfp_t)0x01u) | (( gfp_t)0x02u))) >> bit) & 1)]));
+ else {
+ }
+ return z;
+}
+static inline __attribute__((always_inline)) int gfp_zonelist(gfp_t flags)
+{
+ if (0 && __builtin_expect(!!(flags & (( gfp_t)0x40000u)), 0))
+  return 1;
+ return 0;
+}
+static inline __attribute__((always_inline)) struct zonelist *node_zonelist(int nid, gfp_t flags)
+{
+ return (&contig_page_data)->node_zonelists + gfp_zonelist(flags);
+}
+static inline __attribute__((always_inline)) void arch_free_page(struct page *page, int order) { }
+static inline __attribute__((always_inline)) void arch_alloc_page(struct page *page, int order) { }
+struct page *
+__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order,
+         struct zonelist *zonelist, nodemask_t *nodemask);
+static inline __attribute__((always_inline)) struct page *
+__alloc_pages(gfp_t gfp_mask, unsigned int order,
+  struct zonelist *zonelist)
+{
+ return __alloc_pages_nodemask(gfp_mask, order, zonelist, ((void *)0));
+}
+static inline __attribute__((always_inline)) struct page *alloc_pages_node(int nid, gfp_t gfp_mask,
+      unsigned int order)
+{
+ if (nid < 0)
+  nid = (((void)(0),0));
+ return __alloc_pages(gfp_mask, order, node_zonelist(nid, gfp_mask));
+}
+static inline __attribute__((always_inline)) struct page *alloc_pages_exact_node(int nid, gfp_t gfp_mask,
+      unsigned int order)
+{
+ do { } while (0);
+ return __alloc_pages(gfp_mask, order, node_zonelist(nid, gfp_mask));
+}
+extern unsigned long __get_free_pages(gfp_t gfp_mask, unsigned int order);
+extern unsigned long get_zeroed_page(gfp_t gfp_mask);
+void *alloc_pages_exact(size_t size, gfp_t gfp_mask);
+void free_pages_exact(void *virt, size_t size);
+extern void __free_pages(struct page *page, unsigned int order);
+extern void free_pages(unsigned long addr, unsigned int order);
+extern void free_hot_page(struct page *page);
+void page_alloc_init(void);
+void drain_zone_pages(struct zone *zone, struct per_cpu_pages *pcp);
+void drain_all_pages(void);
+void drain_local_pages(void *dummy);
+extern gfp_t gfp_allowed_mask;
+static inline __attribute__((always_inline)) void set_gfp_allowed_mask(gfp_t mask)
+{
+ gfp_allowed_mask = mask;
+}
+extern int __request_module(bool wait, const char *name, ...)
+ __attribute__((format(printf, 2, 3)));
+struct key;
+struct file;
+struct subprocess_info;
+struct subprocess_info *call_usermodehelper_setup(char *path, char **argv,
+        char **envp, gfp_t gfp_mask);
+void call_usermodehelper_setkeys(struct subprocess_info *info,
+     struct key *session_keyring);
+int call_usermodehelper_stdinpipe(struct subprocess_info *sub_info,
+      struct file **filp);
+void call_usermodehelper_setcleanup(struct subprocess_info *info,
+        void (*cleanup)(char **argv, char **envp));
+enum umh_wait {
+ UMH_NO_WAIT = -1,
+ UMH_WAIT_EXEC = 0,
+ UMH_WAIT_PROC = 1,
+};
+int call_usermodehelper_exec(struct subprocess_info *info, enum umh_wait wait);
+void call_usermodehelper_freeinfo(struct subprocess_info *info);
+static inline __attribute__((always_inline)) int
+call_usermodehelper(char *path, char **argv, char **envp, enum umh_wait wait)
+{
+ struct subprocess_info *info;
+ gfp_t gfp_mask = (wait == UMH_NO_WAIT) ? ((( gfp_t)0x20u)) : ((( gfp_t)0x10u) | (( gfp_t)0x40u) | (( gfp_t)0x80u));
+ info = call_usermodehelper_setup(path, argv, envp, gfp_mask);
+ if (info == ((void *)0))
+  return -12;
+ return call_usermodehelper_exec(info, wait);
+}
+static inline __attribute__((always_inline)) int
+call_usermodehelper_keys(char *path, char **argv, char **envp,
+    struct key *session_keyring, enum umh_wait wait)
+{
+ struct subprocess_info *info;
+ gfp_t gfp_mask = (wait == UMH_NO_WAIT) ? ((( gfp_t)0x20u)) : ((( gfp_t)0x10u) | (( gfp_t)0x40u) | (( gfp_t)0x80u));
+ info = call_usermodehelper_setup(path, argv, envp, gfp_mask);
+ if (info == ((void *)0))
+  return -12;
+ call_usermodehelper_setkeys(info, session_keyring);
+ return call_usermodehelper_exec(info, wait);
+}
+extern void usermodehelper_init(void);
+struct file;
+extern int call_usermodehelper_pipe(char *path, char *argv[], char *envp[],
+        struct file **filp);
+extern int usermodehelper_disable(void);
+extern void usermodehelper_enable(void);
+struct oldold_utsname {
+ char sysname[9];
+ char nodename[9];
+ char release[9];
+ char version[9];
+ char machine[9];
+};
+struct old_utsname {
+ char sysname[65];
+ char nodename[65];
+ char release[65];
+ char version[65];
+ char machine[65];
+};
+struct new_utsname {
+ char sysname[64 + 1];
+ char nodename[64 + 1];
+ char release[64 + 1];
+ char version[64 + 1];
+ char machine[64 + 1];
+ char domainname[64 + 1];
+};
+struct sched_param {
+ int sched_priority;
+};
+struct task_struct;
+typedef struct __user_cap_header_struct {
+ __u32 version;
+ int pid;
+} *cap_user_header_t;
+typedef struct __user_cap_data_struct {
+        __u32 effective;
+        __u32 permitted;
+        __u32 inheritable;
+} *cap_user_data_t;
+struct vfs_cap_data {
+ __le32 magic_etc;
+ struct {
+  __le32 permitted;
+  __le32 inheritable;
+ } data[2];
+};
+typedef struct kernel_cap_struct {
+ __u32 cap[2];
+} kernel_cap_t;
+struct cpu_vfs_cap_data {
+ __u32 magic_etc;
+ kernel_cap_t permitted;
+ kernel_cap_t inheritable;
+};
+static inline __attribute__((always_inline)) kernel_cap_t cap_combine(const kernel_cap_t a,
+           const kernel_cap_t b)
+{
+ kernel_cap_t dest;
+ do { unsigned __capi; for (__capi = 0; __capi < 2; ++__capi) { dest.cap[__capi] = a.cap[__capi] | b.cap[__capi]; } } while (0);
+ return dest;
+}
+static inline __attribute__((always_inline)) kernel_cap_t cap_intersect(const kernel_cap_t a,
+      const kernel_cap_t b)
+{
+ kernel_cap_t dest;
+ do { unsigned __capi; for (__capi = 0; __capi < 2; ++__capi) { dest.cap[__capi] = a.cap[__capi] & b.cap[__capi]; } } while (0);
+ return dest;
+}
+static inline __attribute__((always_inline)) kernel_cap_t cap_drop(const kernel_cap_t a,
+        const kernel_cap_t drop)
+{
+ kernel_cap_t dest;
+ do { unsigned __capi; for (__capi = 0; __capi < 2; ++__capi) { dest.cap[__capi] = a.cap[__capi] &~ drop.cap[__capi]; } } while (0);
+ return dest;
+}
+static inline __attribute__((always_inline)) kernel_cap_t cap_invert(const kernel_cap_t c)
+{
+ kernel_cap_t dest;
+ do { unsigned __capi; for (__capi = 0; __capi < 2; ++__capi) { dest.cap[__capi] = ~ c.cap[__capi]; } } while (0);
+ return dest;
+}
+static inline __attribute__((always_inline)) int cap_isclear(const kernel_cap_t a)
+{
+ unsigned __capi;
+ for (__capi = 0; __capi < 2; ++__capi) {
+  if (a.cap[__capi] != 0)
+   return 0;
+ }
+ return 1;
+}
+static inline __attribute__((always_inline)) int cap_issubset(const kernel_cap_t a, const kernel_cap_t set)
+{
+ kernel_cap_t dest;
+ dest = cap_drop(a, set);
+ return cap_isclear(dest);
+}
+static inline __attribute__((always_inline)) int cap_is_fs_cap(int cap)
+{
+ const kernel_cap_t __cap_fs_set = ((kernel_cap_t){{ ((1 << ((0) & 31)) | (1 << ((27) & 31)) | (1 << ((1) & 31)) | (1 << ((2) & 31)) | (1 << ((3) & 31)) | (1 << ((4) & 31))) | (1 << ((9) & 31)), ((1 << ((32) & 31))) } });
+ return !!((1 << ((cap) & 31)) & __cap_fs_set.cap[((cap) >> 5)]);
+}
+static inline __attribute__((always_inline)) kernel_cap_t cap_drop_fs_set(const kernel_cap_t a)
+{
+ const kernel_cap_t __cap_fs_set = ((kernel_cap_t){{ ((1 << ((0) & 31)) | (1 << ((27) & 31)) | (1 << ((1) & 31)) | (1 << ((2) & 31)) | (1 << ((3) & 31)) | (1 << ((4) & 31))) | (1 << ((9) & 31)), ((1 << ((32) & 31))) } });
+ return cap_drop(a, __cap_fs_set);
+}
+static inline __attribute__((always_inline)) kernel_cap_t cap_raise_fs_set(const kernel_cap_t a,
+         const kernel_cap_t permitted)
+{
+ const kernel_cap_t __cap_fs_set = ((kernel_cap_t){{ ((1 << ((0) & 31)) | (1 << ((27) & 31)) | (1 << ((1) & 31)) | (1 << ((2) & 31)) | (1 << ((3) & 31)) | (1 << ((4) & 31))) | (1 << ((9) & 31)), ((1 << ((32) & 31))) } });
+ return cap_combine(a,
+      cap_intersect(permitted, __cap_fs_set));
+}
+static inline __attribute__((always_inline)) kernel_cap_t cap_drop_nfsd_set(const kernel_cap_t a)
+{
+ const kernel_cap_t __cap_fs_set = ((kernel_cap_t){{ ((1 << ((0) & 31)) | (1 << ((27) & 31)) | (1 << ((1) & 31)) | (1 << ((2) & 31)) | (1 << ((3) & 31)) | (1 << ((4) & 31))) | (1 << ((24) & 31)), ((1 << ((32) & 31))) } });
+ return cap_drop(a, __cap_fs_set);
+}
+static inline __attribute__((always_inline)) kernel_cap_t cap_raise_nfsd_set(const kernel_cap_t a,
+           const kernel_cap_t permitted)
+{
+ const kernel_cap_t __cap_nfsd_set = ((kernel_cap_t){{ ((1 << ((0) & 31)) | (1 << ((27) & 31)) | (1 << ((1) & 31)) | (1 << ((2) & 31)) | (1 << ((3) & 31)) | (1 << ((4) & 31))) | (1 << ((24) & 31)), ((1 << ((32) & 31))) } });
+ return cap_combine(a,
+      cap_intersect(permitted, __cap_nfsd_set));
+}
+extern const kernel_cap_t __cap_empty_set;
+extern const kernel_cap_t __cap_full_set;
+extern const kernel_cap_t __cap_init_eff_set;
+extern int capable(int cap);
+struct dentry;
+extern int get_vfs_caps_from_disk(const struct dentry *dentry, struct cpu_vfs_cap_data *cpu_caps);
+struct timex {
+ unsigned int modes;
+ long offset;
+ long freq;
+ long maxerror;
+ long esterror;
+ int status;
+ long constant;
+ long precision;
+ long tolerance;
+ struct timeval time;
+ long tick;
+ long ppsfreq;
+ long jitter;
+ int shift;
+ long stabil;
+ long jitcnt;
+ long calcnt;
+ long errcnt;
+ long stbcnt;
+ int tai;
+ int :32; int :32; int :32; int :32;
+ int :32; int :32; int :32; int :32;
+ int :32; int :32; int :32;
+};
+typedef unsigned long cycles_t;
+static inline __attribute__((always_inline)) cycles_t get_cycles(void)
+{
+ return 0;
+}
+extern unsigned long tick_usec;
+extern unsigned long tick_nsec;
+extern int tickadj;
+extern int time_status;
+extern long time_maxerror;
+extern long time_esterror;
+extern long time_adjust;
+extern void ntp_init(void);
+extern void ntp_clear(void);
+static inline __attribute__((always_inline)) int ntp_synced(void)
+{
+ return !(time_status & 0x0040);
+}
+extern u64 tick_length;
+extern void second_overflow(void);
+extern void update_ntp_one_tick(void);
+extern int do_adjtimex(struct timex *);
+int read_current_timer(unsigned long *timer_val);
+extern u64 __attribute__((section(".data"))) jiffies_64;
+extern unsigned long volatile __attribute__((section(".data"))) jiffies;
+u64 get_jiffies_64(void);
+extern unsigned long preset_lpj;
+extern unsigned int jiffies_to_msecs(const unsigned long j);
+extern unsigned int jiffies_to_usecs(const unsigned long j);
+extern unsigned long msecs_to_jiffies(const unsigned int m);
+extern unsigned long usecs_to_jiffies(const unsigned int u);
+extern unsigned long timespec_to_jiffies(const struct timespec *value);
+extern void jiffies_to_timespec(const unsigned long jiffies,
+    struct timespec *value);
+extern unsigned long timeval_to_jiffies(const struct timeval *value);
+extern void jiffies_to_timeval(const unsigned long jiffies,
+          struct timeval *value);
+extern clock_t jiffies_to_clock_t(long x);
+extern unsigned long clock_t_to_jiffies(unsigned long x);
+extern u64 jiffies_64_to_clock_t(u64 x);
+extern u64 nsec_to_clock_t(u64 x);
+struct rb_node
+{
+ unsigned long rb_parent_color;
+ struct rb_node *rb_right;
+ struct rb_node *rb_left;
+} __attribute__((aligned(sizeof(long))));
+struct rb_root
+{
+ struct rb_node *rb_node;
+};
+static inline __attribute__((always_inline)) void rb_set_parent(struct rb_node *rb, struct rb_node *p)
+{
+ rb->rb_parent_color = (rb->rb_parent_color & 3) | (unsigned long)p;
+}
+static inline __attribute__((always_inline)) void rb_set_color(struct rb_node *rb, int color)
+{
+ rb->rb_parent_color = (rb->rb_parent_color & ~1) | color;
+}
+extern void rb_insert_color(struct rb_node *, struct rb_root *);
+extern void rb_erase(struct rb_node *, struct rb_root *);
+extern struct rb_node *rb_next(const struct rb_node *);
+extern struct rb_node *rb_prev(const struct rb_node *);
+extern struct rb_node *rb_first(const struct rb_root *);
+extern struct rb_node *rb_last(const struct rb_root *);
+extern void rb_replace_node(struct rb_node *victim, struct rb_node *new,
+       struct rb_root *root);
+static inline __attribute__((always_inline)) void rb_link_node(struct rb_node * node, struct rb_node * parent,
+    struct rb_node ** rb_link)
+{
+ node->rb_parent_color = (unsigned long )parent;
+ node->rb_left = node->rb_right = ((void *)0);
+ *rb_link = node;
+}
+struct raw_prio_tree_node {
+ struct prio_tree_node *left;
+ struct prio_tree_node *right;
+ struct prio_tree_node *parent;
+};
+struct prio_tree_node {
+ struct prio_tree_node *left;
+ struct prio_tree_node *right;
+ struct prio_tree_node *parent;
+ unsigned long start;
+ unsigned long last;
+};
+struct prio_tree_root {
+ struct prio_tree_node *prio_tree_node;
+ unsigned short index_bits;
+ unsigned short raw;
+};
+struct prio_tree_iter {
+ struct prio_tree_node *cur;
+ unsigned long mask;
+ unsigned long value;
+ int size_level;
+ struct prio_tree_root *root;
+ unsigned long r_index;
+ unsigned long h_index;
+};
+static inline __attribute__((always_inline)) void prio_tree_iter_init(struct prio_tree_iter *iter,
+  struct prio_tree_root *root, unsigned long r_index, unsigned long h_index)
+{
+ iter->root = root;
+ iter->r_index = r_index;
+ iter->h_index = h_index;
+ iter->cur = ((void *)0);
+}
+static inline __attribute__((always_inline)) int prio_tree_empty(const struct prio_tree_root *root)
+{
+ return root->prio_tree_node == ((void *)0);
+}
+static inline __attribute__((always_inline)) int prio_tree_root(const struct prio_tree_node *node)
+{
+ return node->parent == node;
+}
+static inline __attribute__((always_inline)) int prio_tree_left_empty(const struct prio_tree_node *node)
+{
+ return node->left == node;
+}
+static inline __attribute__((always_inline)) int prio_tree_right_empty(const struct prio_tree_node *node)
+{
+ return node->right == node;
+}
+struct prio_tree_node *prio_tree_replace(struct prio_tree_root *root,
+                struct prio_tree_node *old, struct prio_tree_node *node);
+struct prio_tree_node *prio_tree_insert(struct prio_tree_root *root,
+                struct prio_tree_node *node);
+void prio_tree_remove(struct prio_tree_root *root, struct prio_tree_node *node);
+struct prio_tree_node *prio_tree_next(struct prio_tree_iter *iter);
+struct completion {
+ unsigned int done;
+ wait_queue_head_t wait;
+};
+static inline __attribute__((always_inline)) void init_completion(struct completion *x)
+{
+ x->done = 0;
+ do { static struct lock_class_key __key; __init_waitqueue_head((&x->wait), &__key); } while (0);
+}
+extern void wait_for_completion(struct completion *);
+extern int wait_for_completion_interruptible(struct completion *x);
+extern int wait_for_completion_killable(struct completion *x);
+extern unsigned long wait_for_completion_timeout(struct completion *x,
+         unsigned long timeout);
+extern unsigned long wait_for_completion_interruptible_timeout(
+   struct completion *x, unsigned long timeout);
+extern bool try_wait_for_completion(struct completion *x);
+extern bool completion_done(struct completion *x);
+extern void complete(struct completion *);
+extern void complete_all(struct completion *);
+enum page_debug_flags {
+ PAGE_DEBUG_FLAG_POISON,
+};
+typedef unsigned long mm_context_id_t[1];
+typedef struct {
+ mm_context_id_t id;
+ void *vdso;
+} mm_context_t;
+long pmb_remap(unsigned long phys, unsigned long size, unsigned long flags);
+int pmb_unmap(unsigned long addr);
+void pmb_init(void);
+int pmb_virt_to_phys(void *addr, unsigned long *phys, unsigned long *flags);
+struct address_space;
+typedef unsigned long mm_counter_t;
+struct page {
+ unsigned long flags;
+ atomic_t _count;
+ union {
+  atomic_t _mapcount;
+  struct {
+   u16 inuse;
+   u16 objects;
+  };
+ };
+ union {
+     struct {
+  unsigned long private;
+  struct address_space *mapping;
+     };
+     struct kmem_cache *slab;
+     struct page *first_page;
+ };
+ union {
+  unsigned long index;
+  void *freelist;
+ };
+ struct list_head lru;
+};
+struct vm_region {
+ struct rb_node vm_rb;
+ unsigned long vm_flags;
+ unsigned long vm_start;
+ unsigned long vm_end;
+ unsigned long vm_top;
+ unsigned long vm_pgoff;
+ struct file *vm_file;
+ atomic_t vm_usage;
+};
+struct vm_area_struct {
+ struct mm_struct * vm_mm;
+ unsigned long vm_start;
+ unsigned long vm_end;
+ struct vm_area_struct *vm_next;
+ pgprot_t vm_page_prot;
+ unsigned long vm_flags;
+ struct rb_node vm_rb;
+ union {
+  struct {
+   struct list_head list;
+   void *parent;
+   struct vm_area_struct *head;
+  } vm_set;
+  struct raw_prio_tree_node prio_tree_node;
+ } shared;
+ struct list_head anon_vma_node;
+ struct anon_vma *anon_vma;
+ const struct vm_operations_struct *vm_ops;
+ unsigned long vm_pgoff;
+ struct file * vm_file;
+ void * vm_private_data;
+ unsigned long vm_truncate_count;
+};
+struct core_thread {
+ struct task_struct *task;
+ struct core_thread *next;
+};
+struct core_state {
+ atomic_t nr_threads;
+ struct core_thread dumper;
+ struct completion startup;
+};
+struct mm_struct {
+ struct vm_area_struct * mmap;
+ struct rb_root mm_rb;
+ struct vm_area_struct * mmap_cache;
+ unsigned long (*get_unmapped_area) (struct file *filp,
+    unsigned long addr, unsigned long len,
+    unsigned long pgoff, unsigned long flags);
+ void (*unmap_area) (struct mm_struct *mm, unsigned long addr);
+ unsigned long mmap_base;
+ unsigned long task_size;
+ unsigned long cached_hole_size;
+ unsigned long free_area_cache;
+ pgd_t * pgd;
+ atomic_t mm_users;
+ atomic_t mm_count;
+ int map_count;
+ struct rw_semaphore mmap_sem;
+ spinlock_t page_table_lock;
+ struct list_head mmlist;
+ mm_counter_t _file_rss;
+ mm_counter_t _anon_rss;
+ unsigned long hiwater_rss;
+ unsigned long hiwater_vm;
+ unsigned long total_vm, locked_vm, shared_vm, exec_vm;
+ unsigned long stack_vm, reserved_vm, def_flags, nr_ptes;
+ unsigned long start_code, end_code, start_data, end_data;
+ unsigned long start_brk, brk, start_stack;
+ unsigned long arg_start, arg_end, env_start, env_end;
+ unsigned long saved_auxv[(2*(5 + 19 + 1))];
+ struct linux_binfmt *binfmt;
+ cpumask_t cpu_vm_mask;
+ mm_context_t context;
+ unsigned int faultstamp;
+ unsigned int token_priority;
+ unsigned int last_interval;
+ unsigned long flags;
+ struct core_state *core_state;
+ spinlock_t ioctx_lock;
+ struct hlist_head ioctx_list;
+ struct file *exe_file;
+ unsigned long num_exe_file_vmas;
+};
+typedef unsigned long cputime_t;
+typedef u64 cputime64_t;
+struct ipc_perm
+{
+ __kernel_key_t key;
+ __kernel_uid_t uid;
+ __kernel_gid_t gid;
+ __kernel_uid_t cuid;
+ __kernel_gid_t cgid;
+ __kernel_mode_t mode;
+ unsigned short seq;
+};
+struct ipc64_perm {
+ __kernel_key_t key;
+ __kernel_uid32_t uid;
+ __kernel_gid32_t gid;
+ __kernel_uid32_t cuid;
+ __kernel_gid32_t cgid;
+ __kernel_mode_t mode;
+ unsigned char __pad1[4 - sizeof(__kernel_mode_t)];
+ unsigned short seq;
+ unsigned short __pad2;
+ unsigned long __unused1;
+ unsigned long __unused2;
+};
+struct ipc_kludge {
+ struct msgbuf *msgp;
+ long msgtyp;
+};
+struct kern_ipc_perm
+{
+ spinlock_t lock;
+ int deleted;
+ int id;
+ key_t key;
+ uid_t uid;
+ gid_t gid;
+ uid_t cuid;
+ gid_t cgid;
+ mode_t mode;
+ unsigned long seq;
+ void *security;
+};
+struct semid_ds {
+ struct ipc_perm sem_perm;
+ __kernel_time_t sem_otime;
+ __kernel_time_t sem_ctime;
+ struct sem *sem_base;
+ struct sem_queue *sem_pending;
+ struct sem_queue **sem_pending_last;
+ struct sem_undo *undo;
+ unsigned short sem_nsems;
+};
+struct semid64_ds {
+ struct ipc64_perm sem_perm;
+ __kernel_time_t sem_otime;
+ unsigned long __unused1;
+ __kernel_time_t sem_ctime;
+ unsigned long __unused2;
+ unsigned long sem_nsems;
+ unsigned long __unused3;
+ unsigned long __unused4;
+};
+struct sembuf {
+ unsigned short sem_num;
+ short sem_op;
+ short sem_flg;
+};
+union semun {
+ int val;
+ struct semid_ds *buf;
+ unsigned short *array;
+ struct seminfo *__buf;
+ void *__pad;
+};
+struct seminfo {
+ int semmap;
+ int semmni;
+ int semmns;
+ int semmnu;
+ int semmsl;
+ int semopm;
+ int semume;
+ int semusz;
+ int semvmx;
+ int semaem;
+};
+struct rcu_head {
+ struct rcu_head *next;
+ void (*func)(struct rcu_head *head);
+};
+extern void synchronize_rcu_bh(void);
+extern void synchronize_sched(void);
+extern void rcu_barrier(void);
+extern void rcu_barrier_bh(void);
+extern void rcu_barrier_sched(void);
+extern void synchronize_sched_expedited(void);
+extern int sched_expedited_torture_stats(char *page);
+extern void rcu_init(void);
+extern void rcu_scheduler_starting(void);
+extern int rcu_needs_cpu(int cpu);
+extern int rcu_scheduler_active;
+struct notifier_block;
+extern void rcu_sched_qs(int cpu);
+extern void rcu_bh_qs(int cpu);
+extern int rcu_cpu_notify(struct notifier_block *self,
+     unsigned long action, void *hcpu);
+extern int rcu_needs_cpu(int cpu);
+extern int rcu_expedited_torture_stats(char *page);
+static inline __attribute__((always_inline)) void __rcu_read_lock(void)
+{
+ do { do { (current_thread_info()->preempt_count) += (1); } while (0); __asm__ __volatile__("": : :"memory"); } while (0);
+}
+static inline __attribute__((always_inline)) void __rcu_read_unlock(void)
+{
+ do { do { __asm__ __volatile__("": : :"memory"); do { (current_thread_info()->preempt_count) -= (1); } while (0); } while (0); __asm__ __volatile__("": : :"memory"); do { if (__builtin_expect(!!(test_ti_thread_flag(current_thread_info(), 2)), 0)) preempt_schedule(); } while (0); } while (0);
+}
+static inline __attribute__((always_inline)) void exit_rcu(void)
+{
+}
+static inline __attribute__((always_inline)) void __rcu_read_lock_bh(void)
+{
+ local_bh_disable();
+}
+static inline __attribute__((always_inline)) void __rcu_read_unlock_bh(void)
+{
+ local_bh_enable();
+}
+extern void call_rcu_sched(struct rcu_head *head,
+      void (*func)(struct rcu_head *rcu));
+extern void synchronize_rcu_expedited(void);
+static inline __attribute__((always_inline)) void synchronize_rcu_bh_expedited(void)
+{
+ synchronize_sched_expedited();
+}
+extern void __rcu_init(void);
+extern void rcu_check_callbacks(int cpu, int user);
+extern long rcu_batches_completed(void);
+extern long rcu_batches_completed_bh(void);
+extern long rcu_batches_completed_sched(void);
+static inline __attribute__((always_inline)) void rcu_enter_nohz(void)
+{
+}
+static inline __attribute__((always_inline)) void rcu_exit_nohz(void)
+{
+}
+static inline __attribute__((always_inline)) int rcu_blocking_is_gp(void)
+{
+ return 1 == 1;
+}
+static inline __attribute__((always_inline)) void rcu_read_lock(void)
+{
+ __rcu_read_lock();
+ (void)0;
+ do { } while (0);
+}
+static inline __attribute__((always_inline)) void rcu_read_unlock(void)
+{
+ do { } while (0);
+ (void)0;
+ __rcu_read_unlock();
+}
+static inline __attribute__((always_inline)) void rcu_read_lock_bh(void)
+{
+ __rcu_read_lock_bh();
+ (void)0;
+ do { } while (0);
+}
+static inline __attribute__((always_inline)) void rcu_read_unlock_bh(void)
+{
+ do { } while (0);
+ (void)0;
+ __rcu_read_unlock_bh();
+}
+static inline __attribute__((always_inline)) void rcu_read_lock_sched(void)
+{
+ do { do { (current_thread_info()->preempt_count) += (1); } while (0); __asm__ __volatile__("": : :"memory"); } while (0);
+ (void)0;
+ do { } while (0);
+}
+static inline __attribute__((always_inline)) __attribute__((no_instrument_function)) void rcu_read_lock_sched_notrace(void)
+{
+ do { do { (current_thread_info()->preempt_count) += (1); } while (0); __asm__ __volatile__("": : :"memory"); } while (0);
+ (void)0;
+}
+static inline __attribute__((always_inline)) void rcu_read_unlock_sched(void)
+{
+ do { } while (0);
+ (void)0;
+ do { do { __asm__ __volatile__("": : :"memory"); do { (current_thread_info()->preempt_count) -= (1); } while (0); } while (0); __asm__ __volatile__("": : :"memory"); do { if (__builtin_expect(!!(test_ti_thread_flag(current_thread_info(), 2)), 0)) preempt_schedule(); } while (0); } while (0);
+}
+static inline __attribute__((always_inline)) __attribute__((no_instrument_function)) void rcu_read_unlock_sched_notrace(void)
+{
+ (void)0;
+ do { do { __asm__ __volatile__("": : :"memory"); do { (current_thread_info()->preempt_count) -= (1); } while (0); } while (0); __asm__ __volatile__("": : :"memory"); do { if (__builtin_expect(!!(test_ti_thread_flag(current_thread_info(), 2)), 0)) preempt_schedule(); } while (0); } while (0);
+}
+struct rcu_synchronize {
+ struct rcu_head head;
+ struct completion completion;
+};
+extern void wakeme_after_rcu(struct rcu_head *head);
+extern void call_rcu(struct rcu_head *head,
+         void (*func)(struct rcu_head *head));
+extern void call_rcu_bh(struct rcu_head *head,
+   void (*func)(struct rcu_head *head));
+struct task_struct;
+struct sem {
+ int semval;
+ int sempid;
+};
+struct sem_array {
+ struct kern_ipc_perm sem_perm;
+ time_t sem_otime;
+ time_t sem_ctime;
+ struct sem *sem_base;
+ struct list_head sem_pending;
+ struct list_head list_id;
+ unsigned long sem_nsems;
+};
+struct sem_queue {
+ struct list_head list;
+ struct task_struct *sleeper;
+ struct sem_undo *undo;
+ int pid;
+ int status;
+ struct sembuf *sops;
+ int nsops;
+ int alter;
+};
+struct sem_undo {
+ struct list_head list_proc;
+ struct rcu_head rcu;
+ struct sem_undo_list *ulp;
+ struct list_head list_id;
+ int semid;
+ short * semadj;
+};
+struct sem_undo_list {
+ atomic_t refcnt;
+ spinlock_t lock;
+ struct list_head list_proc;
+};
+struct sysv_sem {
+ struct sem_undo_list *undo_list;
+};
+extern int copy_semundo(unsigned long clone_flags, struct task_struct *tsk);
+extern void exit_sem(struct task_struct *tsk);
+typedef struct {
+ unsigned long sig[(64 / 32)];
+} sigset_t;
+typedef unsigned long old_sigset_t;
+typedef void __signalfn_t(int);
+typedef __signalfn_t *__sighandler_t;
+typedef void __restorefn_t(void);
+typedef __restorefn_t *__sigrestore_t;
+struct sigaction {
+ __sighandler_t sa_handler;
+ unsigned long sa_flags;
+ __sigrestore_t sa_restorer;
+ sigset_t sa_mask;
+};
+struct k_sigaction {
+ struct sigaction sa;
+};
+typedef struct sigaltstack {
+ void *ss_sp;
+ int ss_flags;
+ size_t ss_size;
+} stack_t;
+struct sigcontext {
+ unsigned long oldmask;
+ unsigned long sc_regs[16];
+ unsigned long sc_pc;
+ unsigned long sc_pr;
+ unsigned long sc_sr;
+ unsigned long sc_gbr;
+ unsigned long sc_mach;
+ unsigned long sc_macl;
+ unsigned long sc_fpregs[16];
+ unsigned long sc_xfpregs[16];
+ unsigned int sc_fpscr;
+ unsigned int sc_fpul;
+ unsigned int sc_ownedfp;
+};
+struct old_sigaction {
+ __sighandler_t sa_handler;
+ old_sigset_t sa_mask;
+ unsigned long sa_flags;
+ void (*sa_restorer)(void);
+};
+typedef union sigval {
+ int sival_int;
+ void *sival_ptr;
+} sigval_t;
+typedef struct siginfo {
+ int si_signo;
+ int si_errno;
+ int si_code;
+ union {
+  int _pad[((128 - (3 * sizeof(int))) / sizeof(int))];
+  struct {
+   __kernel_pid_t _pid;
+   __kernel_uid32_t _uid;
+  } _kill;
+  struct {
+   __kernel_timer_t _tid;
+   int _overrun;
+   char _pad[sizeof( __kernel_uid32_t) - sizeof(int)];
+   sigval_t _sigval;
+   int _sys_private;
+  } _timer;
+  struct {
+   __kernel_pid_t _pid;
+   __kernel_uid32_t _uid;
+   sigval_t _sigval;
+  } _rt;
+  struct {
+   __kernel_pid_t _pid;
+   __kernel_uid32_t _uid;
+   int _status;
+   __kernel_clock_t _utime;
+   __kernel_clock_t _stime;
+  } _sigchld;
+  struct {
+   void *_addr;
+   short _addr_lsb;
+  } _sigfault;
+  struct {
+   long _band;
+   int _fd;
+  } _sigpoll;
+ } _sifields;
+} siginfo_t;
+typedef struct sigevent {
+ sigval_t sigev_value;
+ int sigev_signo;
+ int sigev_notify;
+ union {
+  int _pad[((64 - (sizeof(int) * 2 + sizeof(sigval_t))) / sizeof(int))];
+   int _tid;
+  struct {
+   void (*_function)(sigval_t);
+   void *_attribute;
+  } _sigev_thread;
+ } _sigev_un;
+} sigevent_t;
+struct siginfo;
+void do_schedule_next_timer(struct siginfo *info);
+static inline __attribute__((always_inline)) void copy_siginfo(struct siginfo *to, struct siginfo *from)
+{
+ if (from->si_code < 0)
+  memcpy(to, from, sizeof(*to));
+ else
+  memcpy(to, from, (3 * sizeof(int)) + sizeof(from->_sifields._sigchld));
+}
+extern int copy_siginfo_to_user(struct siginfo *to, struct siginfo *from);
+struct sigqueue {
+ struct list_head list;
+ int flags;
+ siginfo_t info;
+ struct user_struct *user;
+};
+struct sigpending {
+ struct list_head list;
+ sigset_t signal;
+};
+static inline __attribute__((always_inline)) void sigaddset(sigset_t *set, int _sig)
+{
+ unsigned long sig = _sig - 1;
+ if ((64 / 32) == 1)
+  set->sig[0] |= 1UL << sig;
+ else
+  set->sig[sig / 32] |= 1UL << (sig % 32);
+}
+static inline __attribute__((always_inline)) void sigdelset(sigset_t *set, int _sig)
+{
+ unsigned long sig = _sig - 1;
+ if ((64 / 32) == 1)
+  set->sig[0] &= ~(1UL << sig);
+ else
+  set->sig[sig / 32] &= ~(1UL << (sig % 32));
+}
+static inline __attribute__((always_inline)) int sigismember(sigset_t *set, int _sig)
+{
+ unsigned long sig = _sig - 1;
+ if ((64 / 32) == 1)
+  return 1 & (set->sig[0] >> sig);
+ else
+  return 1 & (set->sig[sig / 32] >> (sig % 32));
+}
+static inline __attribute__((always_inline)) int sigfindinword(unsigned long word)
+{
+ return ffz(~word);
+}
+static inline __attribute__((always_inline)) int sigisemptyset(sigset_t *set)
+{
+ extern void _NSIG_WORDS_is_unsupported_size(void);
+ switch ((64 / 32)) {
+ case 4:
+  return (set->sig[3] | set->sig[2] |
+   set->sig[1] | set->sig[0]) == 0;
+ case 2:
+  return (set->sig[1] | set->sig[0]) == 0;
+ case 1:
+  return set->sig[0] == 0;
+ default:
+  _NSIG_WORDS_is_unsupported_size();
+  return 0;
+ }
+}
+static inline __attribute__((always_inline)) void sigorsets(sigset_t *r, const sigset_t *a, const sigset_t *b) { extern void _NSIG_WORDS_is_unsupported_size(void); unsigned long a0, a1, a2, a3, b0, b1, b2, b3; switch ((64 / 32)) { case 4: a3 = a->sig[3]; a2 = a->sig[2]; b3 = b->sig[3]; b2 = b->sig[2]; r->sig[3] = ((a3) | (b3)); r->sig[2] = ((a2) | (b2)); case 2: a1 = a->sig[1]; b1 = b->sig[1]; r->sig[1] = ((a1) | (b1)); case 1: a0 = a->sig[0]; b0 = b->sig[0]; r->sig[0] = ((a0) | (b0)); break; default: _NSIG_WORDS_is_unsupported_size(); } }
+static inline __attribute__((always_inline)) void sigandsets(sigset_t *r, const sigset_t *a, const sigset_t *b) { extern void _NSIG_WORDS_is_unsupported_size(void); unsigned long a0, a1, a2, a3, b0, b1, b2, b3; switch ((64 / 32)) { case 4: a3 = a->sig[3]; a2 = a->sig[2]; b3 = b->sig[3]; b2 = b->sig[2]; r->sig[3] = ((a3) & (b3)); r->sig[2] = ((a2) & (b2)); case 2: a1 = a->sig[1]; b1 = b->sig[1]; r->sig[1] = ((a1) & (b1)); case 1: a0 = a->sig[0]; b0 = b->sig[0]; r->sig[0] = ((a0) & (b0)); break; default: _NSIG_WORDS_is_unsupported_size(); } }
+static inline __attribute__((always_inline)) void signandsets(sigset_t *r, const sigset_t *a, const sigset_t *b) { extern void _NSIG_WORDS_is_unsupported_size(void); unsigned long a0, a1, a2, a3, b0, b1, b2, b3; switch ((64 / 32)) { case 4: a3 = a->sig[3]; a2 = a->sig[2]; b3 = b->sig[3]; b2 = b->sig[2]; r->sig[3] = ((a3) & ~(b3)); r->sig[2] = ((a2) & ~(b2)); case 2: a1 = a->sig[1]; b1 = b->sig[1]; r->sig[1] = ((a1) & ~(b1)); case 1: a0 = a->sig[0]; b0 = b->sig[0]; r->sig[0] = ((a0) & ~(b0)); break; default: _NSIG_WORDS_is_unsupported_size(); } }
+static inline __attribute__((always_inline)) void signotset(sigset_t *set) { extern void _NSIG_WORDS_is_unsupported_size(void); switch ((64 / 32)) { case 4: set->sig[3] = (~(set->sig[3])); set->sig[2] = (~(set->sig[2])); case 2: set->sig[1] = (~(set->sig[1])); case 1: set->sig[0] = (~(set->sig[0])); break; default: _NSIG_WORDS_is_unsupported_size(); } }
+static inline __attribute__((always_inline)) void sigemptyset(sigset_t *set)
+{
+ switch ((64 / 32)) {
+ default:
+  memset(set, 0, sizeof(sigset_t));
+  break;
+ case 2: set->sig[1] = 0;
+ case 1: set->sig[0] = 0;
+  break;
+ }
+}
+static inline __attribute__((always_inline)) void sigfillset(sigset_t *set)
+{
+ switch ((64 / 32)) {
+ default:
+  memset(set, -1, sizeof(sigset_t));
+  break;
+ case 2: set->sig[1] = -1;
+ case 1: set->sig[0] = -1;
+  break;
+ }
+}
+static inline __attribute__((always_inline)) void sigaddsetmask(sigset_t *set, unsigned long mask)
+{
+ set->sig[0] |= mask;
+}
+static inline __attribute__((always_inline)) void sigdelsetmask(sigset_t *set, unsigned long mask)
+{
+ set->sig[0] &= ~mask;
+}
+static inline __attribute__((always_inline)) int sigtestsetmask(sigset_t *set, unsigned long mask)
+{
+ return (set->sig[0] & mask) != 0;
+}
+static inline __attribute__((always_inline)) void siginitset(sigset_t *set, unsigned long mask)
+{
+ set->sig[0] = mask;
+ switch ((64 / 32)) {
+ default:
+  memset(&set->sig[1], 0, sizeof(long)*((64 / 32)-1));
+  break;
+ case 2: set->sig[1] = 0;
+ case 1: ;
+ }
+}
+static inline __attribute__((always_inline)) void siginitsetinv(sigset_t *set, unsigned long mask)
+{
+ set->sig[0] = ~mask;
+ switch ((64 / 32)) {
+ default:
+  memset(&set->sig[1], -1, sizeof(long)*((64 / 32)-1));
+  break;
+ case 2: set->sig[1] = -1;
+ case 1: ;
+ }
+}
+static inline __attribute__((always_inline)) void init_sigpending(struct sigpending *sig)
+{
+ sigemptyset(&sig->signal);
+ INIT_LIST_HEAD(&sig->list);
+}
+extern void flush_sigqueue(struct sigpending *queue);
+static inline __attribute__((always_inline)) int valid_signal(unsigned long sig)
+{
+ return sig <= 64 ? 1 : 0;
+}
+extern int next_signal(struct sigpending *pending, sigset_t *mask);
+extern int do_send_sig_info(int sig, struct siginfo *info,
+    struct task_struct *p, bool group);
+extern int group_send_sig_info(int sig, struct siginfo *info, struct task_struct *p);
+extern int __group_send_sig_info(int, struct siginfo *, struct task_struct *);
+extern long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig,
+     siginfo_t *info);
+extern long do_sigpending(void *, unsigned long);
+extern int sigprocmask(int, sigset_t *, sigset_t *);
+extern int show_unhandled_signals;
+struct pt_regs;
+extern int get_signal_to_deliver(siginfo_t *info, struct k_sigaction *return_ka, struct pt_regs *regs, void *cookie);
+extern void exit_signals(struct task_struct *tsk);
+extern struct kmem_cache *sighand_cachep;
+int unhandled_signal(struct task_struct *tsk, int sig);
+void signals_init(void);
+struct dentry;
+struct vfsmount;
+struct path {
+ struct vfsmount *mnt;
+ struct dentry *dentry;
+};
+extern void path_get(struct path *);
+extern void path_put(struct path *);
+enum pid_type
+{
+ PIDTYPE_PID,
+ PIDTYPE_PGID,
+ PIDTYPE_SID,
+ PIDTYPE_MAX
+};
+struct upid {
+ int nr;
+ struct pid_namespace *ns;
+ struct hlist_node pid_chain;
+};
+struct pid
+{
+ atomic_t count;
+ unsigned int level;
+ struct hlist_head tasks[PIDTYPE_MAX];
+ struct rcu_head rcu;
+ struct upid numbers[1];
+};
+extern struct pid init_struct_pid;
+struct pid_link
+{
+ struct hlist_node node;
+ struct pid *pid;
+};
+static inline __attribute__((always_inline)) struct pid *get_pid(struct pid *pid)
+{
+ if (pid)
+  atomic_add(1,(&pid->count));
+ return pid;
+}
+extern void put_pid(struct pid *pid);
+extern struct task_struct *pid_task(struct pid *pid, enum pid_type);
+extern struct task_struct *get_pid_task(struct pid *pid, enum pid_type);
+extern struct pid *get_task_pid(struct task_struct *task, enum pid_type type);
+extern void attach_pid(struct task_struct *task, enum pid_type type,
+   struct pid *pid);
+extern void detach_pid(struct task_struct *task, enum pid_type);
+extern void change_pid(struct task_struct *task, enum pid_type,
+   struct pid *pid);
+extern void transfer_pid(struct task_struct *old, struct task_struct *new,
+    enum pid_type);
+struct pid_namespace;
+extern struct pid_namespace init_pid_ns;
+extern struct pid *find_pid_ns(int nr, struct pid_namespace *ns);
+extern struct pid *find_vpid(int nr);
+extern struct pid *find_get_pid(int nr);
+extern struct pid *find_ge_pid(int nr, struct pid_namespace *);
+int next_pidmap(struct pid_namespace *pid_ns, int last);
+extern struct pid *alloc_pid(struct pid_namespace *ns);
+extern void free_pid(struct pid *pid);
+static inline __attribute__((always_inline)) struct pid_namespace *ns_of_pid(struct pid *pid)
+{
+ struct pid_namespace *ns = ((void *)0);
+ if (pid)
+  ns = pid->numbers[pid->level].ns;
+ return ns;
+}
+static inline __attribute__((always_inline)) pid_t pid_nr(struct pid *pid)
+{
+ pid_t nr = 0;
+ if (pid)
+  nr = pid->numbers[0].nr;
+ return nr;
+}
+pid_t pid_nr_ns(struct pid *pid, struct pid_namespace *ns);
+pid_t pid_vnr(struct pid *pid);
+void __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) __attribute__((no_instrument_function)) kmem_cache_init(void);
+int slab_is_available(void);
+struct kmem_cache *kmem_cache_create(const char *, size_t, size_t,
+   unsigned long,
+   void (*)(void *));
+void kmem_cache_destroy(struct kmem_cache *);
+int kmem_cache_shrink(struct kmem_cache *);
+void kmem_cache_free(struct kmem_cache *, void *);
+unsigned int kmem_cache_size(struct kmem_cache *);
+const char *kmem_cache_name(struct kmem_cache *);
+int kmem_ptr_validate(struct kmem_cache *cachep, const void *ptr);
+void * __krealloc(const void *, size_t, gfp_t);
+void * krealloc(const void *, size_t, gfp_t);
+void kfree(const void *);
+void kzfree(const void *);
+size_t ksize(const void *);
+struct module;
+struct tracepoint;
+struct tracepoint {
+ const char *name;
+ int state;
+ void (*regfunc)(void);
+ void (*unregfunc)(void);
+ void **funcs;
+} __attribute__((aligned(32)));
+static inline __attribute__((always_inline)) void tracepoint_update_probe_range(struct tracepoint *begin,
+ struct tracepoint *end)
+{ }
+extern int tracepoint_probe_register(const char *name, void *probe);
+extern int tracepoint_probe_unregister(const char *name, void *probe);
+extern int tracepoint_probe_register_noupdate(const char *name, void *probe);
+extern int tracepoint_probe_unregister_noupdate(const char *name, void *probe);
+extern void tracepoint_probe_update_all(void);
+struct tracepoint_iter {
+ struct module *module;
+ struct tracepoint *tracepoint;
+};
+extern void tracepoint_iter_start(struct tracepoint_iter *iter);
+extern void tracepoint_iter_next(struct tracepoint_iter *iter);
+extern void tracepoint_iter_stop(struct tracepoint_iter *iter);
+extern void tracepoint_iter_reset(struct tracepoint_iter *iter);
+extern int tracepoint_get_iter_range(struct tracepoint **tracepoint,
+ struct tracepoint *begin, struct tracepoint *end);
+static inline __attribute__((always_inline)) void tracepoint_synchronize_unregister(void)
+{
+ synchronize_sched();
+}
+static inline __attribute__((always_inline)) void
+ _do_trace_kmalloc
+ (struct tracepoint *tp, unsigned long call_site, const void *ptr, size_t bytes_req, size_t bytes_alloc, gfp_t gfp_flags) { } static inline __attribute__((always_inline)) void
+ trace_kmalloc
+ (unsigned long call_site, const void *ptr, size_t bytes_req, size_t bytes_alloc, gfp_t gfp_flags) { } static inline __attribute__((always_inline)) int
+ register_trace_kmalloc
+ (void (*probe)(unsigned long call_site, const void *ptr, size_t bytes_req, size_t bytes_alloc, gfp_t gfp_flags)) { return -38; } static inline __attribute__((always_inline)) int
+ unregister_trace_kmalloc
+ (void (*probe)(unsigned long call_site, const void *ptr, size_t bytes_req, size_t bytes_alloc, gfp_t gfp_flags)) { return -38; }
+ ;
+static inline __attribute__((always_inline)) void
+ _do_trace_kmem_cache_alloc
+ (struct tracepoint *tp, unsigned long call_site, const void *ptr, size_t bytes_req, size_t bytes_alloc, gfp_t gfp_flags) { } static inline __attribute__((always_inline)) void
+ trace_kmem_cache_alloc
+ (unsigned long call_site, const void *ptr, size_t bytes_req, size_t bytes_alloc, gfp_t gfp_flags) { } static inline __attribute__((always_inline)) int
+ register_trace_kmem_cache_alloc
+ (void (*probe)(unsigned long call_site, const void *ptr, size_t bytes_req, size_t bytes_alloc, gfp_t gfp_flags)) { return -38; } static inline __attribute__((always_inline)) int
+ unregister_trace_kmem_cache_alloc
+ (void (*probe)(unsigned long call_site, const void *ptr, size_t bytes_req, size_t bytes_alloc, gfp_t gfp_flags)) { return -38; }
+ ;
+static inline __attribute__((always_inline)) void
+ _do_trace_kmalloc_node
+ (struct tracepoint *tp, unsigned long call_site, const void *ptr, size_t bytes_req, size_t bytes_alloc, gfp_t gfp_flags, int node) { } static inline __attribute__((always_inline)) void
+ trace_kmalloc_node
+ (unsigned long call_site, const void *ptr, size_t bytes_req, size_t bytes_alloc, gfp_t gfp_flags, int node) { } static inline __attribute__((always_inline)) int
+ register_trace_kmalloc_node
+ (void (*probe)(unsigned long call_site, const void *ptr, size_t bytes_req, size_t bytes_alloc, gfp_t gfp_flags, int node)) { return -38; } static inline __attribute__((always_inline)) int
+ unregister_trace_kmalloc_node
+ (void (*probe)(unsigned long call_site, const void *ptr, size_t bytes_req, size_t bytes_alloc, gfp_t gfp_flags, int node)) { return -38; }
+ ;
+static inline __attribute__((always_inline)) void
+ _do_trace_kmem_cache_alloc_node
+ (struct tracepoint *tp, unsigned long call_site, const void *ptr, size_t bytes_req, size_t bytes_alloc, gfp_t gfp_flags, int node) { } static inline __attribute__((always_inline)) void
+ trace_kmem_cache_alloc_node
+ (unsigned long call_site, const void *ptr, size_t bytes_req, size_t bytes_alloc, gfp_t gfp_flags, int node) { } static inline __attribute__((always_inline)) int
+ register_trace_kmem_cache_alloc_node
+ (void (*probe)(unsigned long call_site, const void *ptr, size_t bytes_req, size_t bytes_alloc, gfp_t gfp_flags, int node)) { return -38; } static inline __attribute__((always_inline)) int
+ unregister_trace_kmem_cache_alloc_node
+ (void (*probe)(unsigned long call_site, const void *ptr, size_t bytes_req, size_t bytes_alloc, gfp_t gfp_flags, int node)) { return -38; }
+ ;
+static inline __attribute__((always_inline)) void
+ _do_trace_kfree
+ (struct tracepoint *tp, unsigned long call_site, const void *ptr) { } static inline __attribute__((always_inline)) void
+ trace_kfree
+ (unsigned long call_site, const void *ptr) { } static inline __attribute__((always_inline)) int
+ register_trace_kfree
+ (void (*probe)(unsigned long call_site, const void *ptr)) { return -38; } static inline __attribute__((always_inline)) int
+ unregister_trace_kfree
+ (void (*probe)(unsigned long call_site, const void *ptr)) { return -38; }
+ ;
+static inline __attribute__((always_inline)) void
+ _do_trace_kmem_cache_free
+ (struct tracepoint *tp, unsigned long call_site, const void *ptr) { } static inline __attribute__((always_inline)) void
+ trace_kmem_cache_free
+ (unsigned long call_site, const void *ptr) { } static inline __attribute__((always_inline)) int
+ register_trace_kmem_cache_free
+ (void (*probe)(unsigned long call_site, const void *ptr)) { return -38; } static inline __attribute__((always_inline)) int
+ unregister_trace_kmem_cache_free
+ (void (*probe)(unsigned long call_site, const void *ptr)) { return -38; }
+ ;
+static inline __attribute__((always_inline)) void
+ _do_trace_mm_page_free_direct
+ (struct tracepoint *tp, struct page *page, unsigned int order) { } static inline __attribute__((always_inline)) void
+ trace_mm_page_free_direct
+ (struct page *page, unsigned int order) { } static inline __attribute__((always_inline)) int
+ register_trace_mm_page_free_direct
+ (void (*probe)(struct page *page, unsigned int order)) { return -38; } static inline __attribute__((always_inline)) int
+ unregister_trace_mm_page_free_direct
+ (void (*probe)(struct page *page, unsigned int order)) { return -38; }
+ ;
+static inline __attribute__((always_inline)) void
+ _do_trace_mm_pagevec_free
+ (struct tracepoint *tp, struct page *page, int cold) { } static inline __attribute__((always_inline)) void
+ trace_mm_pagevec_free
+ (struct page *page, int cold) { } static inline __attribute__((always_inline)) int
+ register_trace_mm_pagevec_free
+ (void (*probe)(struct page *page, int cold)) { return -38; } static inline __attribute__((always_inline)) int
+ unregister_trace_mm_pagevec_free
+ (void (*probe)(struct page *page, int cold)) { return -38; }
+ ;
+static inline __attribute__((always_inline)) void
+ _do_trace_mm_page_alloc
+ (struct tracepoint *tp, struct page *page, unsigned int order, gfp_t gfp_flags, int migratetype) { } static inline __attribute__((always_inline)) void
+ trace_mm_page_alloc
+ (struct page *page, unsigned int order, gfp_t gfp_flags, int migratetype) { } static inline __attribute__((always_inline)) int
+ register_trace_mm_page_alloc
+ (void (*probe)(struct page *page, unsigned int order, gfp_t gfp_flags, int migratetype)) { return -38; } static inline __attribute__((always_inline)) int
+ unregister_trace_mm_page_alloc
+ (void (*probe)(struct page *page, unsigned int order, gfp_t gfp_flags, int migratetype)) { return -38; }
+ ;
+static inline __attribute__((always_inline)) void
+ _do_trace_mm_page_alloc_zone_locked
+ (struct tracepoint *tp, struct page *page, unsigned int order, int migratetype) { } static inline __attribute__((always_inline)) void
+ trace_mm_page_alloc_zone_locked
+ (struct page *page, unsigned int order, int migratetype) { } static inline __attribute__((always_inline)) int
+ register_trace_mm_page_alloc_zone_locked
+ (void (*probe)(struct page *page, unsigned int order, int migratetype)) { return -38; } static inline __attribute__((always_inline)) int
+ unregister_trace_mm_page_alloc_zone_locked
+ (void (*probe)(struct page *page, unsigned int order, int migratetype)) { return -38; }
+ ;
+static inline __attribute__((always_inline)) void
+ _do_trace_mm_page_pcpu_drain
+ (struct tracepoint *tp, struct page *page, int order, int migratetype) { } static inline __attribute__((always_inline)) void
+ trace_mm_page_pcpu_drain
+ (struct page *page, int order, int migratetype) { } static inline __attribute__((always_inline)) int
+ register_trace_mm_page_pcpu_drain
+ (void (*probe)(struct page *page, int order, int migratetype)) { return -38; } static inline __attribute__((always_inline)) int
+ unregister_trace_mm_page_pcpu_drain
+ (void (*probe)(struct page *page, int order, int migratetype)) { return -38; }
+ ;
+static inline __attribute__((always_inline)) void
+ _do_trace_mm_page_alloc_extfrag
+ (struct tracepoint *tp, struct page *page, int alloc_order, int fallback_order, int alloc_migratetype, int fallback_migratetype) { } static inline __attribute__((always_inline)) void
+ trace_mm_page_alloc_extfrag
+ (struct page *page, int alloc_order, int fallback_order, int alloc_migratetype, int fallback_migratetype) { } static inline __attribute__((always_inline)) int
+ register_trace_mm_page_alloc_extfrag
+ (void (*probe)(struct page *page, int alloc_order, int fallback_order, int alloc_migratetype, int fallback_migratetype)) { return -38; } static inline __attribute__((always_inline)) int
+ unregister_trace_mm_page_alloc_extfrag
+ (void (*probe)(struct page *page, int alloc_order, int fallback_order, int alloc_migratetype, int fallback_migratetype)) { return -38; }
+ ;
+static inline __attribute__((always_inline)) void kmemtrace_init(void)
+{
+}
+struct kmem_cache {
+ struct array_cache *array[1];
+ unsigned int batchcount;
+ unsigned int limit;
+ unsigned int shared;
+ unsigned int buffer_size;
+ u32 reciprocal_buffer_size;
+ unsigned int flags;
+ unsigned int num;
+ unsigned int gfporder;
+ gfp_t gfpflags;
+ size_t colour;
+ unsigned int colour_off;
+ struct kmem_cache *slabp_cache;
+ unsigned int slab_size;
+ unsigned int dflags;
+ void (*ctor)(void *obj);
+ const char *name;
+ struct list_head next;
+ struct kmem_list3 *nodelists[(1 << 0)];
+};
+struct cache_sizes {
+ size_t cs_size;
+ struct kmem_cache *cs_cachep;
+};
+extern struct cache_sizes malloc_sizes[];
+void *kmem_cache_alloc(struct kmem_cache *, gfp_t);
+void *__kmalloc(size_t size, gfp_t flags);
+static inline __attribute__((always_inline)) __attribute__((always_inline)) void *
+kmem_cache_alloc_notrace(struct kmem_cache *cachep, gfp_t flags)
+{
+ return kmem_cache_alloc(cachep, flags);
+}
+static inline __attribute__((always_inline)) size_t slab_buffer_size(struct kmem_cache *cachep)
+{
+ return 0;
+}
+static inline __attribute__((always_inline)) __attribute__((always_inline)) void *kmalloc(size_t size, gfp_t flags)
+{
+ struct kmem_cache *cachep;
+ void *ret;
+ if (__builtin_constant_p(size)) {
+  int i = 0;
+  if (!size)
+   return ((void *)16);
+ if (size <= 32) goto found; else i++;
+ if (size <= 64) goto found; else i++;
+ if (size <= 96) goto found; else i++;
+ if (size <= 128) goto found; else i++;
+ if (size <= 192) goto found; else i++;
+ if (size <= 256) goto found; else i++;
+ if (size <= 512) goto found; else i++;
+ if (size <= 1024) goto found; else i++;
+ if (size <= 2048) goto found; else i++;
+ if (size <= 4096) goto found; else i++;
+ if (size <= 8192) goto found; else i++;
+ if (size <= 16384) goto found; else i++;
+ if (size <= 32768) goto found; else i++;
+ if (size <= 65536) goto found; else i++;
+ if (size <= 131072) goto found; else i++;
+ if (size <= 262144) goto found; else i++;
+ if (size <= 524288) goto found; else i++;
+ if (size <= 1048576) goto found; else i++;
+ if (size <= 2097152) goto found; else i++;
+ if (size <= 4194304) goto found; else i++;
+  return ((void *)0);
+found:
+   cachep = malloc_sizes[i].cs_cachep;
+  ret = kmem_cache_alloc_notrace(cachep, flags);
+  trace_kmalloc(({ __label__ __here; __here: (unsigned long)&&__here; }), ret,
+         size, slab_buffer_size(cachep), flags);
+  return ret;
+ }
+ return __kmalloc(size, flags);
+}
+static inline __attribute__((always_inline)) void *kcalloc(size_t n, size_t size, gfp_t flags)
+{
+ if (size != 0 && n > (~0UL) / size)
+  return ((void *)0);
+ return __kmalloc(n * size, flags | (( gfp_t)0x8000u));
+}
+static inline __attribute__((always_inline)) void *kmalloc_node(size_t size, gfp_t flags, int node)
+{
+ return kmalloc(size, flags);
+}
+static inline __attribute__((always_inline)) void *__kmalloc_node(size_t size, gfp_t flags, int node)
+{
+ return __kmalloc(size, flags);
+}
+void *kmem_cache_alloc(struct kmem_cache *, gfp_t);
+static inline __attribute__((always_inline)) void *kmem_cache_alloc_node(struct kmem_cache *cachep,
+     gfp_t flags, int node)
+{
+ return kmem_cache_alloc(cachep, flags);
+}
+static inline __attribute__((always_inline)) void *kmem_cache_zalloc(struct kmem_cache *k, gfp_t flags)
+{
+ return kmem_cache_alloc(k, flags | (( gfp_t)0x8000u));
+}
+static inline __attribute__((always_inline)) void *kzalloc(size_t size, gfp_t flags)
+{
+ return kmalloc(size, flags | (( gfp_t)0x8000u));
+}
+static inline __attribute__((always_inline)) void *kzalloc_node(size_t size, gfp_t flags, int node)
+{
+ return kmalloc_node(size, flags | (( gfp_t)0x8000u), node);
+}
+void __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) __attribute__((no_instrument_function)) kmem_cache_init_late(void);
+static inline __attribute__((always_inline)) void *__alloc_percpu(size_t size, size_t align)
+{
+ ({ static int __warned; int __ret_warn_once = !!(align > (1 << 5)); if (__builtin_expect(!!(__ret_warn_once), 0)) if (({ int __ret_warn_on = !!(!__warned); if (__builtin_constant_p(__ret_warn_on)) { if (__ret_warn_on) do { __asm__ __volatile__ ( "1:\t.short %O0\n" "\t.pushsection __bug_table,\"a\"\n" "2:\t.long 1b\n" "\t.short %O3\n" "\t.org 2b+%O4\n" "\t.popsection\n" : : "n" (0xc33e), "i" ("include/linux/percpu.h"), "i" (173), "i" ((1<<0)), "i" (sizeof(struct bug_entry))); } while (0); } else { if (__builtin_expect(!!(__ret_warn_on), 0)) do { __asm__ __volatile__ ( "1:\t.short %O0\n" "\t.pushsection __bug_table,\"a\"\n" "2:\t.long 1b\n" "\t.short %O3\n" "\t.org 2b+%O4\n" "\t.popsection\n" : : "n" (0xc33e), "i" ("include/linux/percpu.h"), "i" (173), "i" ((1<<0)), "i" (sizeof(struct bug_entry))); } while (0); } __builtin_expect(!!(__ret_warn_on), 0); })) __warned = 1; __builtin_expect(!!(__ret_warn_once), 0); });
+ return kzalloc(size, ((( gfp_t)0x10u) | (( gfp_t)0x40u) | (( gfp_t)0x80u)));
+}
+static inline __attribute__((always_inline)) void free_percpu(void *p)
+{
+ kfree(p);
+}
+static inline __attribute__((always_inline)) void __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) __attribute__((no_instrument_function)) setup_per_cpu_areas(void) { }
+static inline __attribute__((always_inline)) void *pcpu_lpage_remapped(void *kaddr)
+{
+ return ((void *)0);
+}
+struct percpu_counter {
+ s64 count;
+};
+static inline __attribute__((always_inline)) int percpu_counter_init(struct percpu_counter *fbc, s64 amount)
+{
+ fbc->count = amount;
+ return 0;
+}
+static inline __attribute__((always_inline)) void percpu_counter_destroy(struct percpu_counter *fbc)
+{
+}
+static inline __attribute__((always_inline)) void percpu_counter_set(struct percpu_counter *fbc, s64 amount)
+{
+ fbc->count = amount;
+}
+static inline __attribute__((always_inline)) void
+percpu_counter_add(struct percpu_counter *fbc, s64 amount)
+{
+ do { do { (current_thread_info()->preempt_count) += (1); } while (0); __asm__ __volatile__("": : :"memory"); } while (0);
+ fbc->count += amount;
+ do { do { __asm__ __volatile__("": : :"memory"); do { (current_thread_info()->preempt_count) -= (1); } while (0); } while (0); __asm__ __volatile__("": : :"memory"); do { if (__builtin_expect(!!(test_ti_thread_flag(current_thread_info(), 2)), 0)) preempt_schedule(); } while (0); } while (0);
+}
+static inline __attribute__((always_inline)) s64 percpu_counter_read(struct percpu_counter *fbc)
+{
+ return fbc->count;
+}
+static inline __attribute__((always_inline)) s64 percpu_counter_read_positive(struct percpu_counter *fbc)
+{
+ return fbc->count;
+}
+static inline __attribute__((always_inline)) s64 percpu_counter_sum_positive(struct percpu_counter *fbc)
+{
+ return percpu_counter_read_positive(fbc);
+}
+static inline __attribute__((always_inline)) s64 percpu_counter_sum(struct percpu_counter *fbc)
+{
+ return percpu_counter_read(fbc);
+}
+static inline __attribute__((always_inline)) void percpu_counter_inc(struct percpu_counter *fbc)
+{
+ percpu_counter_add(fbc, 1);
+}
+static inline __attribute__((always_inline)) void percpu_counter_dec(struct percpu_counter *fbc)
+{
+ percpu_counter_add(fbc, -1);
+}
+static inline __attribute__((always_inline)) void percpu_counter_sub(struct percpu_counter *fbc, s64 amount)
+{
+ percpu_counter_add(fbc, -amount);
+}
+struct prop_global {
+ int shift;
+ struct percpu_counter events;
+};
+struct prop_descriptor {
+ int index;
+ struct prop_global pg[2];
+ struct mutex mutex;
+};
+int prop_descriptor_init(struct prop_descriptor *pd, int shift);
+void prop_change_shift(struct prop_descriptor *pd, int new_shift);
+struct prop_local_percpu {
+ struct percpu_counter events;
+ int shift;
+ unsigned long period;
+ spinlock_t lock;
+};
+int prop_local_init_percpu(struct prop_local_percpu *pl);
+void prop_local_destroy_percpu(struct prop_local_percpu *pl);
+void __prop_inc_percpu(struct prop_descriptor *pd, struct prop_local_percpu *pl);
+void prop_fraction_percpu(struct prop_descriptor *pd, struct prop_local_percpu *pl,
+  long *numerator, long *denominator);
+static inline __attribute__((always_inline))
+void prop_inc_percpu(struct prop_descriptor *pd, struct prop_local_percpu *pl)
+{
+ unsigned long flags;
+ do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); do { (flags) = __raw_local_irq_save(); } while (0); do { } while (0); } while (0);
+ __prop_inc_percpu(pd, pl);
+ do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); if (raw_irqs_disabled_flags(flags)) { raw_local_irq_restore(flags); do { } while (0); } else { do { } while (0); raw_local_irq_restore(flags); } } while (0);
+}
+void __prop_inc_percpu_max(struct prop_descriptor *pd,
+      struct prop_local_percpu *pl, long frac);
+struct prop_local_single {
+ unsigned long events;
+ unsigned long period;
+ int shift;
+ spinlock_t lock;
+};
+int prop_local_init_single(struct prop_local_single *pl);
+void prop_local_destroy_single(struct prop_local_single *pl);
+void __prop_inc_single(struct prop_descriptor *pd, struct prop_local_single *pl);
+void prop_fraction_single(struct prop_descriptor *pd, struct prop_local_single *pl,
+  long *numerator, long *denominator);
+static inline __attribute__((always_inline))
+void prop_inc_single(struct prop_descriptor *pd, struct prop_local_single *pl)
+{
+ unsigned long flags;
+ do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); do { (flags) = __raw_local_irq_save(); } while (0); do { } while (0); } while (0);
+ __prop_inc_single(pd, pl);
+ do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); if (raw_irqs_disabled_flags(flags)) { raw_local_irq_restore(flags); do { } while (0); } else { do { } while (0); raw_local_irq_restore(flags); } } while (0);
+}
+typedef struct { } seccomp_t;
+static inline __attribute__((always_inline)) long prctl_get_seccomp(void)
+{
+ return -22;
+}
+static inline __attribute__((always_inline)) long prctl_set_seccomp(unsigned long arg2)
+{
+ return -22;
+}
+static inline __attribute__((always_inline)) void __list_add_rcu(struct list_head *new,
+  struct list_head *prev, struct list_head *next)
+{
+ new->next = next;
+ new->prev = prev;
+ ({ if (!__builtin_constant_p(new) || ((new) != ((void *)0))) __asm__ __volatile__("": : :"memory"); (prev->next) = (new); });
+ next->prev = new;
+}
+static inline __attribute__((always_inline)) void list_add_rcu(struct list_head *new, struct list_head *head)
+{
+ __list_add_rcu(new, head, head->next);
+}
+static inline __attribute__((always_inline)) void list_add_tail_rcu(struct list_head *new,
+     struct list_head *head)
+{
+ __list_add_rcu(new, head->prev, head);
+}
+static inline __attribute__((always_inline)) void list_del_rcu(struct list_head *entry)
+{
+ __list_del(entry->prev, entry->next);
+ entry->prev = ((void *) 0x00200200 + 0);
+}
+static inline __attribute__((always_inline)) void hlist_del_init_rcu(struct hlist_node *n)
+{
+ if (!hlist_unhashed(n)) {
+  __hlist_del(n);
+  n->pprev = ((void *)0);
+ }
+}
+static inline __attribute__((always_inline)) void list_replace_rcu(struct list_head *old,
+    struct list_head *new)
+{
+ new->next = old->next;
+ new->prev = old->prev;
+ ({ if (!__builtin_constant_p(new) || ((new) != ((void *)0))) __asm__ __volatile__("": : :"memory"); (new->prev->next) = (new); });
+ new->next->prev = new;
+ old->prev = ((void *) 0x00200200 + 0);
+}
+static inline __attribute__((always_inline)) void list_splice_init_rcu(struct list_head *list,
+     struct list_head *head,
+     void (*sync)(void))
+{
+ struct list_head *first = list->next;
+ struct list_head *last = list->prev;
+ struct list_head *at = head->next;
+ if (list_empty(head))
+  return;
+ INIT_LIST_HEAD(list);
+ sync();
+ last->next = at;
+ ({ if (!__builtin_constant_p(first) || ((first) != ((void *)0))) __asm__ __volatile__("": : :"memory"); (head->next) = (first); });
+ first->prev = head;
+ at->prev = last;
+}
+static inline __attribute__((always_inline)) void hlist_del_rcu(struct hlist_node *n)
+{
+ __hlist_del(n);
+ n->pprev = ((void *) 0x00200200 + 0);
+}
+static inline __attribute__((always_inline)) void hlist_replace_rcu(struct hlist_node *old,
+     struct hlist_node *new)
+{
+ struct hlist_node *next = old->next;
+ new->next = next;
+ new->pprev = old->pprev;
+ ({ if (!__builtin_constant_p(new) || ((new) != ((void *)0))) __asm__ __volatile__("": : :"memory"); (*new->pprev) = (new); });
+ if (next)
+  new->next->pprev = &new->next;
+ old->pprev = ((void *) 0x00200200 + 0);
+}
+static inline __attribute__((always_inline)) void hlist_add_head_rcu(struct hlist_node *n,
+     struct hlist_head *h)
+{
+ struct hlist_node *first = h->first;
+ n->next = first;
+ n->pprev = &h->first;
+ ({ if (!__builtin_constant_p(n) || ((n) != ((void *)0))) __asm__ __volatile__("": : :"memory"); (h->first) = (n); });
+ if (first)
+  first->pprev = &n->next;
+}
+static inline __attribute__((always_inline)) void hlist_add_before_rcu(struct hlist_node *n,
+     struct hlist_node *next)
+{
+ n->pprev = next->pprev;
+ n->next = next;
+ ({ if (!__builtin_constant_p(n) || ((n) != ((void *)0))) __asm__ __volatile__("": : :"memory"); (*(n->pprev)) = (n); });
+ next->pprev = &n->next;
+}
+static inline __attribute__((always_inline)) void hlist_add_after_rcu(struct hlist_node *prev,
+           struct hlist_node *n)
+{
+ n->next = prev->next;
+ n->pprev = &prev->next;
+ ({ if (!__builtin_constant_p(n) || ((n) != ((void *)0))) __asm__ __volatile__("": : :"memory"); (prev->next) = (n); });
+ if (n->next)
+  n->next->pprev = &n->next;
+}
+struct plist_head {
+ struct list_head prio_list;
+ struct list_head node_list;
+};
+struct plist_node {
+ int prio;
+ struct plist_head plist;
+};
+static inline __attribute__((always_inline)) void
+plist_head_init(struct plist_head *head, spinlock_t *lock)
+{
+ INIT_LIST_HEAD(&head->prio_list);
+ INIT_LIST_HEAD(&head->node_list);
+}
+static inline __attribute__((always_inline)) void plist_node_init(struct plist_node *node, int prio)
+{
+ node->prio = prio;
+ plist_head_init(&node->plist, ((void *)0));
+}
+extern void plist_add(struct plist_node *node, struct plist_head *head);
+extern void plist_del(struct plist_node *node, struct plist_head *head);
+static inline __attribute__((always_inline)) int plist_head_empty(const struct plist_head *head)
+{
+ return list_empty(&head->node_list);
+}
+static inline __attribute__((always_inline)) int plist_node_empty(const struct plist_node *node)
+{
+ return plist_head_empty(&node->plist);
+}
+static inline __attribute__((always_inline)) struct plist_node* plist_first(const struct plist_head *head)
+{
+ return ({ const typeof( ((struct plist_node *)0)->plist.node_list ) *__mptr = (head->node_list.next); (struct plist_node *)( (char *)__mptr - __builtin_offsetof(struct plist_node,plist.node_list) );})
+                                        ;
+}
+struct rt_mutex {
+ spinlock_t wait_lock;
+ struct plist_head wait_list;
+ struct task_struct *owner;
+};
+struct rt_mutex_waiter;
+struct hrtimer_sleeper;
+ static inline __attribute__((always_inline)) int rt_mutex_debug_check_no_locks_freed(const void *from,
+             unsigned long len)
+ {
+ return 0;
+ }
+static inline __attribute__((always_inline)) int rt_mutex_is_locked(struct rt_mutex *lock)
+{
+ return lock->owner != ((void *)0);
+}
+extern void __rt_mutex_init(struct rt_mutex *lock, const char *name);
+extern void rt_mutex_destroy(struct rt_mutex *lock);
+extern void rt_mutex_lock(struct rt_mutex *lock);
+extern int rt_mutex_lock_interruptible(struct rt_mutex *lock,
+      int detect_deadlock);
+extern int rt_mutex_timed_lock(struct rt_mutex *lock,
+     struct hrtimer_sleeper *timeout,
+     int detect_deadlock);
+extern int rt_mutex_trylock(struct rt_mutex *lock);
+extern void rt_mutex_unlock(struct rt_mutex *lock);
+struct rusage {
+ struct timeval ru_utime;
+ struct timeval ru_stime;
+ long ru_maxrss;
+ long ru_ixrss;
+ long ru_idrss;
+ long ru_isrss;
+ long ru_minflt;
+ long ru_majflt;
+ long ru_nswap;
+ long ru_inblock;
+ long ru_oublock;
+ long ru_msgsnd;
+ long ru_msgrcv;
+ long ru_nsignals;
+ long ru_nvcsw;
+ long ru_nivcsw;
+};
+struct rlimit {
+ unsigned long rlim_cur;
+ unsigned long rlim_max;
+};
+struct task_struct;
+int getrusage(struct task_struct *p, int who, struct rusage *ru);
+union ktime {
+ s64 tv64;
+ struct {
+ s32 nsec, sec;
+ } tv;
+};
+typedef union ktime ktime_t;
+static inline __attribute__((always_inline)) ktime_t ktime_set(const long secs, const unsigned long nsecs)
+{
+ return (ktime_t) { .tv = { .sec = secs, .nsec = nsecs } };
+}
+static inline __attribute__((always_inline)) ktime_t ktime_sub(const ktime_t lhs, const ktime_t rhs)
+{
+ ktime_t res;
+ res.tv64 = lhs.tv64 - rhs.tv64;
+ if (res.tv.nsec < 0)
+  res.tv.nsec += 1000000000L;
+ return res;
+}
+static inline __attribute__((always_inline)) ktime_t ktime_add(const ktime_t add1, const ktime_t add2)
+{
+ ktime_t res;
+ res.tv64 = add1.tv64 + add2.tv64;
+ if (res.tv.nsec >= 1000000000L)
+  res.tv64 += (u32)-1000000000L;
+ return res;
+}
+extern ktime_t ktime_add_ns(const ktime_t kt, u64 nsec);
+extern ktime_t ktime_sub_ns(const ktime_t kt, u64 nsec);
+static inline __attribute__((always_inline)) ktime_t timespec_to_ktime(const struct timespec ts)
+{
+ return (ktime_t) { .tv = { .sec = (s32)ts.tv_sec,
+          .nsec = (s32)ts.tv_nsec } };
+}
+static inline __attribute__((always_inline)) ktime_t timeval_to_ktime(const struct timeval tv)
+{
+ return (ktime_t) { .tv = { .sec = (s32)tv.tv_sec,
+       .nsec = (s32)tv.tv_usec * 1000 } };
+}
+static inline __attribute__((always_inline)) struct timespec ktime_to_timespec(const ktime_t kt)
+{
+ return (struct timespec) { .tv_sec = (time_t) kt.tv.sec,
+       .tv_nsec = (long) kt.tv.nsec };
+}
+static inline __attribute__((always_inline)) struct timeval ktime_to_timeval(const ktime_t kt)
+{
+ return (struct timeval) {
+  .tv_sec = (time_t) kt.tv.sec,
+  .tv_usec = (suseconds_t) (kt.tv.nsec / 1000L) };
+}
+static inline __attribute__((always_inline)) s64 ktime_to_ns(const ktime_t kt)
+{
+ return (s64) kt.tv.sec * 1000000000L + kt.tv.nsec;
+}
+static inline __attribute__((always_inline)) int ktime_equal(const ktime_t cmp1, const ktime_t cmp2)
+{
+ return cmp1.tv64 == cmp2.tv64;
+}
+static inline __attribute__((always_inline)) s64 ktime_to_us(const ktime_t kt)
+{
+ struct timeval tv = ktime_to_timeval(kt);
+ return (s64) tv.tv_sec * 1000000L + tv.tv_usec;
+}
+static inline __attribute__((always_inline)) s64 ktime_us_delta(const ktime_t later, const ktime_t earlier)
+{
+       return ktime_to_us(ktime_sub(later, earlier));
+}
+static inline __attribute__((always_inline)) ktime_t ktime_add_us(const ktime_t kt, const u64 usec)
+{
+ return ktime_add_ns(kt, usec * 1000);
+}
+static inline __attribute__((always_inline)) ktime_t ktime_sub_us(const ktime_t kt, const u64 usec)
+{
+ return ktime_sub_ns(kt, usec * 1000);
+}
+extern ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs);
+extern void ktime_get_ts(struct timespec *ts);
+static inline __attribute__((always_inline)) ktime_t ns_to_ktime(u64 ns)
+{
+ static const ktime_t ktime_zero = { .tv64 = 0 };
+ return ktime_add_ns(ktime_zero, ns);
+}
+enum debug_obj_state {
+ ODEBUG_STATE_NONE,
+ ODEBUG_STATE_INIT,
+ ODEBUG_STATE_INACTIVE,
+ ODEBUG_STATE_ACTIVE,
+ ODEBUG_STATE_DESTROYED,
+ ODEBUG_STATE_NOTAVAILABLE,
+ ODEBUG_STATE_MAX,
+};
+struct debug_obj_descr;
+struct debug_obj {
+ struct hlist_node node;
+ enum debug_obj_state state;
+ void *object;
+ struct debug_obj_descr *descr;
+};
+struct debug_obj_descr {
+ const char *name;
+ int (*fixup_init) (void *addr, enum debug_obj_state state);
+ int (*fixup_activate) (void *addr, enum debug_obj_state state);
+ int (*fixup_destroy) (void *addr, enum debug_obj_state state);
+ int (*fixup_free) (void *addr, enum debug_obj_state state);
+};
+static inline __attribute__((always_inline)) void
+debug_object_init (void *addr, struct debug_obj_descr *descr) { }
+static inline __attribute__((always_inline)) void
+debug_object_init_on_stack(void *addr, struct debug_obj_descr *descr) { }
+static inline __attribute__((always_inline)) void
+debug_object_activate (void *addr, struct debug_obj_descr *descr) { }
+static inline __attribute__((always_inline)) void
+debug_object_deactivate(void *addr, struct debug_obj_descr *descr) { }
+static inline __attribute__((always_inline)) void
+debug_object_destroy (void *addr, struct debug_obj_descr *descr) { }
+static inline __attribute__((always_inline)) void
+debug_object_free (void *addr, struct debug_obj_descr *descr) { }
+static inline __attribute__((always_inline)) void debug_objects_early_init(void) { }
+static inline __attribute__((always_inline)) void debug_objects_mem_init(void) { }
+static inline __attribute__((always_inline)) void
+debug_check_no_obj_freed(const void *address, unsigned long size) { }
+struct tvec_base;
+struct timer_list {
+ struct list_head entry;
+ unsigned long expires;
+ void (*function)(unsigned long);
+ unsigned long data;
+ struct tvec_base *base;
+};
+extern struct tvec_base boot_tvec_bases;
+void init_timer_key(struct timer_list *timer,
+      const char *name,
+      struct lock_class_key *key);
+void init_timer_deferrable_key(struct timer_list *timer,
+          const char *name,
+          struct lock_class_key *key);
+static inline __attribute__((always_inline)) void destroy_timer_on_stack(struct timer_list *timer) { }
+static inline __attribute__((always_inline)) void init_timer_on_stack_key(struct timer_list *timer,
+        const char *name,
+        struct lock_class_key *key)
+{
+ init_timer_key(timer, name, key);
+}
+static inline __attribute__((always_inline)) void setup_timer_key(struct timer_list * timer,
+    const char *name,
+    struct lock_class_key *key,
+    void (*function)(unsigned long),
+    unsigned long data)
+{
+ timer->function = function;
+ timer->data = data;
+ init_timer_key(timer, name, key);
+}
+static inline __attribute__((always_inline)) void setup_timer_on_stack_key(struct timer_list *timer,
+     const char *name,
+     struct lock_class_key *key,
+     void (*function)(unsigned long),
+     unsigned long data)
+{
+ timer->function = function;
+ timer->data = data;
+ init_timer_on_stack_key(timer, name, key);
+}
+static inline __attribute__((always_inline)) int timer_pending(const struct timer_list * timer)
+{
+ return timer->entry.next != ((void *)0);
+}
+extern void add_timer_on(struct timer_list *timer, int cpu);
+extern int del_timer(struct timer_list * timer);
+extern int mod_timer(struct timer_list *timer, unsigned long expires);
+extern int mod_timer_pending(struct timer_list *timer, unsigned long expires);
+extern int mod_timer_pinned(struct timer_list *timer, unsigned long expires);
+extern unsigned long get_next_timer_interrupt(unsigned long now);
+static inline __attribute__((always_inline)) void init_timer_stats(void)
+{
+}
+static inline __attribute__((always_inline)) void timer_stats_timer_set_start_info(struct timer_list *timer)
+{
+}
+static inline __attribute__((always_inline)) void timer_stats_timer_clear_start_info(struct timer_list *timer)
+{
+}
+extern void add_timer(struct timer_list *timer);
+extern void init_timers(void);
+extern void run_local_timers(void);
+struct hrtimer;
+extern enum hrtimer_restart it_real_fn(struct hrtimer *);
+unsigned long __round_jiffies(unsigned long j, int cpu);
+unsigned long __round_jiffies_relative(unsigned long j, int cpu);
+unsigned long round_jiffies(unsigned long j);
+unsigned long round_jiffies_relative(unsigned long j);
+unsigned long __round_jiffies_up(unsigned long j, int cpu);
+unsigned long __round_jiffies_up_relative(unsigned long j, int cpu);
+unsigned long round_jiffies_up(unsigned long j);
+unsigned long round_jiffies_up_relative(unsigned long j);
+struct hrtimer_clock_base;
+struct hrtimer_cpu_base;
+enum hrtimer_mode {
+ HRTIMER_MODE_ABS = 0x0,
+ HRTIMER_MODE_REL = 0x1,
+ HRTIMER_MODE_PINNED = 0x02,
+ HRTIMER_MODE_ABS_PINNED = 0x02,
+ HRTIMER_MODE_REL_PINNED = 0x03,
+};
+enum hrtimer_restart {
+ HRTIMER_NORESTART,
+ HRTIMER_RESTART,
+};
+struct hrtimer {
+ struct rb_node node;
+ ktime_t _expires;
+ ktime_t _softexpires;
+ enum hrtimer_restart (*function)(struct hrtimer *);
+ struct hrtimer_clock_base *base;
+ unsigned long state;
+};
+struct hrtimer_sleeper {
+ struct hrtimer timer;
+ struct task_struct *task;
+};
+struct hrtimer_clock_base {
+ struct hrtimer_cpu_base *cpu_base;
+ clockid_t index;
+ struct rb_root active;
+ struct rb_node *first;
+ ktime_t resolution;
+ ktime_t (*get_time)(void);
+ ktime_t softirq_time;
+};
+struct hrtimer_cpu_base {
+ spinlock_t lock;
+ struct hrtimer_clock_base clock_base[2];
+};
+static inline __attribute__((always_inline)) void hrtimer_set_expires(struct hrtimer *timer, ktime_t time)
+{
+ timer->_expires = time;
+ timer->_softexpires = time;
+}
+static inline __attribute__((always_inline)) void hrtimer_set_expires_range(struct hrtimer *timer, ktime_t time, ktime_t delta)
+{
+ timer->_softexpires = time;
+ timer->_expires = ktime_add_safe(time, delta);
+}
+static inline __attribute__((always_inline)) void hrtimer_set_expires_range_ns(struct hrtimer *timer, ktime_t time, unsigned long delta)
+{
+ timer->_softexpires = time;
+ timer->_expires = ktime_add_safe(time, ns_to_ktime(delta));
+}
+static inline __attribute__((always_inline)) void hrtimer_set_expires_tv64(struct hrtimer *timer, s64 tv64)
+{
+ timer->_expires.tv64 = tv64;
+ timer->_softexpires.tv64 = tv64;
+}
+static inline __attribute__((always_inline)) void hrtimer_add_expires(struct hrtimer *timer, ktime_t time)
+{
+ timer->_expires = ktime_add_safe(timer->_expires, time);
+ timer->_softexpires = ktime_add_safe(timer->_softexpires, time);
+}
+static inline __attribute__((always_inline)) void hrtimer_add_expires_ns(struct hrtimer *timer, u64 ns)
+{
+ timer->_expires = ktime_add_ns(timer->_expires, ns);
+ timer->_softexpires = ktime_add_ns(timer->_softexpires, ns);
+}
+static inline __attribute__((always_inline)) ktime_t hrtimer_get_expires(const struct hrtimer *timer)
+{
+ return timer->_expires;
+}
+static inline __attribute__((always_inline)) ktime_t hrtimer_get_softexpires(const struct hrtimer *timer)
+{
+ return timer->_softexpires;
+}
+static inline __attribute__((always_inline)) s64 hrtimer_get_expires_tv64(const struct hrtimer *timer)
+{
+ return timer->_expires.tv64;
+}
+static inline __attribute__((always_inline)) s64 hrtimer_get_softexpires_tv64(const struct hrtimer *timer)
+{
+ return timer->_softexpires.tv64;
+}
+static inline __attribute__((always_inline)) s64 hrtimer_get_expires_ns(const struct hrtimer *timer)
+{
+ return ktime_to_ns(timer->_expires);
+}
+static inline __attribute__((always_inline)) ktime_t hrtimer_expires_remaining(const struct hrtimer *timer)
+{
+    return ktime_sub(timer->_expires, timer->base->get_time());
+}
+static inline __attribute__((always_inline)) void clock_was_set(void) { }
+static inline __attribute__((always_inline)) void hrtimer_peek_ahead_timers(void) { }
+static inline __attribute__((always_inline)) void hres_timers_resume(void) { }
+static inline __attribute__((always_inline)) ktime_t hrtimer_cb_get_time(struct hrtimer *timer)
+{
+ return timer->base->softirq_time;
+}
+static inline __attribute__((always_inline)) int hrtimer_is_hres_active(struct hrtimer *timer)
+{
+ return 0;
+}
+extern ktime_t ktime_get(void);
+extern ktime_t ktime_get_real(void);
+extern __attribute__((section(".data" ""))) __typeof__(struct tick_device) per_cpu__tick_cpu_device;
+extern void hrtimer_init(struct hrtimer *timer, clockid_t which_clock,
+    enum hrtimer_mode mode);
+static inline __attribute__((always_inline)) void hrtimer_init_on_stack(struct hrtimer *timer,
+      clockid_t which_clock,
+      enum hrtimer_mode mode)
+{
+ hrtimer_init(timer, which_clock, mode);
+}
+static inline __attribute__((always_inline)) void destroy_hrtimer_on_stack(struct hrtimer *timer) { }
+extern int hrtimer_start(struct hrtimer *timer, ktime_t tim,
+    const enum hrtimer_mode mode);
+extern int hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,
+   unsigned long range_ns, const enum hrtimer_mode mode);
+extern int
+__hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,
+    unsigned long delta_ns,
+    const enum hrtimer_mode mode, int wakeup);
+extern int hrtimer_cancel(struct hrtimer *timer);
+extern int hrtimer_try_to_cancel(struct hrtimer *timer);
+static inline __attribute__((always_inline)) int hrtimer_start_expires(struct hrtimer *timer,
+      enum hrtimer_mode mode)
+{
+ unsigned long delta;
+ ktime_t soft, hard;
+ soft = hrtimer_get_softexpires(timer);
+ hard = hrtimer_get_expires(timer);
+ delta = ktime_to_ns(ktime_sub(hard, soft));
+ return hrtimer_start_range_ns(timer, soft, delta, mode);
+}
+static inline __attribute__((always_inline)) int hrtimer_restart(struct hrtimer *timer)
+{
+ return hrtimer_start_expires(timer, HRTIMER_MODE_ABS);
+}
+extern ktime_t hrtimer_get_remaining(const struct hrtimer *timer);
+extern int hrtimer_get_res(const clockid_t which_clock, struct timespec *tp);
+extern ktime_t hrtimer_get_next_event(void);
+static inline __attribute__((always_inline)) int hrtimer_active(const struct hrtimer *timer)
+{
+ return timer->state != 0x00;
+}
+static inline __attribute__((always_inline)) int hrtimer_is_queued(struct hrtimer *timer)
+{
+ return timer->state & 0x01;
+}
+static inline __attribute__((always_inline)) int hrtimer_callback_running(struct hrtimer *timer)
+{
+ return timer->state & 0x02;
+}
+extern u64
+hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval);
+static inline __attribute__((always_inline)) u64 hrtimer_forward_now(struct hrtimer *timer,
+          ktime_t interval)
+{
+ return hrtimer_forward(timer, timer->base->get_time(), interval);
+}
+extern long hrtimer_nanosleep(struct timespec *rqtp,
+         struct timespec *rmtp,
+         const enum hrtimer_mode mode,
+         const clockid_t clockid);
+extern long hrtimer_nanosleep_restart(struct restart_block *restart_block);
+extern void hrtimer_init_sleeper(struct hrtimer_sleeper *sl,
+     struct task_struct *tsk);
+extern int schedule_hrtimeout_range(ktime_t *expires, unsigned long delta,
+      const enum hrtimer_mode mode);
+extern int schedule_hrtimeout(ktime_t *expires, const enum hrtimer_mode mode);
+extern void hrtimer_run_queues(void);
+extern void hrtimer_run_pending(void);
+extern void __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) __attribute__((no_instrument_function)) hrtimers_init(void);
+extern u64 ktime_divns(const ktime_t kt, s64 div);
+extern void sysrq_timer_list_show(void);
+static inline __attribute__((always_inline)) void timer_stats_account_hrtimer(struct hrtimer *timer)
+{
+}
+static inline __attribute__((always_inline)) void timer_stats_hrtimer_set_start_info(struct hrtimer *timer)
+{
+}
+static inline __attribute__((always_inline)) void timer_stats_hrtimer_clear_start_info(struct hrtimer *timer)
+{
+}
+struct task_io_accounting {
+};
+struct kobject;
+struct module;
+struct attribute {
+ const char *name;
+ struct module *owner;
+ mode_t mode;
+};
+struct attribute_group {
+ const char *name;
+ mode_t (*is_visible)(struct kobject *,
+           struct attribute *, int);
+ struct attribute **attrs;
+};
+struct vm_area_struct;
+struct bin_attribute {
+ struct attribute attr;
+ size_t size;
+ void *private;
+ ssize_t (*read)(struct kobject *, struct bin_attribute *,
+   char *, loff_t, size_t);
+ ssize_t (*write)(struct kobject *, struct bin_attribute *,
+    char *, loff_t, size_t);
+ int (*mmap)(struct kobject *, struct bin_attribute *attr,
+      struct vm_area_struct *vma);
+};
+struct sysfs_ops {
+ ssize_t (*show)(struct kobject *, struct attribute *,char *);
+ ssize_t (*store)(struct kobject *,struct attribute *,const char *, size_t);
+};
+struct sysfs_dirent;
+int sysfs_schedule_callback(struct kobject *kobj, void (*func)(void *),
+       void *data, struct module *owner);
+int sysfs_create_dir(struct kobject *kobj);
+void sysfs_remove_dir(struct kobject *kobj);
+int sysfs_rename_dir(struct kobject *kobj, const char *new_name);
+int sysfs_move_dir(struct kobject *kobj,
+    struct kobject *new_parent_kobj);
+int sysfs_create_file(struct kobject *kobj,
+       const struct attribute *attr);
+int sysfs_chmod_file(struct kobject *kobj, struct attribute *attr,
+      mode_t mode);
+void sysfs_remove_file(struct kobject *kobj, const struct attribute *attr);
+int sysfs_create_bin_file(struct kobject *kobj,
+           struct bin_attribute *attr);
+void sysfs_remove_bin_file(struct kobject *kobj, struct bin_attribute *attr);
+int sysfs_create_link(struct kobject *kobj, struct kobject *target,
+       const char *name);
+int sysfs_create_link_nowarn(struct kobject *kobj,
+       struct kobject *target,
+       const char *name);
+void sysfs_remove_link(struct kobject *kobj, const char *name);
+int sysfs_create_group(struct kobject *kobj,
+        const struct attribute_group *grp);
+int sysfs_update_group(struct kobject *kobj,
+         const struct attribute_group *grp);
+void sysfs_remove_group(struct kobject *kobj,
+   const struct attribute_group *grp);
+int sysfs_add_file_to_group(struct kobject *kobj,
+   const struct attribute *attr, const char *group);
+void sysfs_remove_file_from_group(struct kobject *kobj,
+   const struct attribute *attr, const char *group);
+void sysfs_notify(struct kobject *kobj, const char *dir, const char *attr);
+void sysfs_notify_dirent(struct sysfs_dirent *sd);
+struct sysfs_dirent *sysfs_get_dirent(struct sysfs_dirent *parent_sd,
+          const unsigned char *name);
+struct sysfs_dirent *sysfs_get(struct sysfs_dirent *sd);
+void sysfs_put(struct sysfs_dirent *sd);
+void sysfs_printk_last_file(void);
+int sysfs_init(void);
+struct kref {
+ atomic_t refcount;
+};
+void kref_set(struct kref *kref, int num);
+void kref_init(struct kref *kref);
+void kref_get(struct kref *kref);
+int kref_put(struct kref *kref, void (*release) (struct kref *kref));
+extern char uevent_helper[];
+extern u64 uevent_seqnum;
+enum kobject_action {
+ KOBJ_ADD,
+ KOBJ_REMOVE,
+ KOBJ_CHANGE,
+ KOBJ_MOVE,
+ KOBJ_ONLINE,
+ KOBJ_OFFLINE,
+ KOBJ_MAX
+};
+struct kobject {
+ const char *name;
+ struct list_head entry;
+ struct kobject *parent;
+ struct kset *kset;
+ struct kobj_type *ktype;
+ struct sysfs_dirent *sd;
+ struct kref kref;
+ unsigned int state_initialized:1;
+ unsigned int state_in_sysfs:1;
+ unsigned int state_add_uevent_sent:1;
+ unsigned int state_remove_uevent_sent:1;
+ unsigned int uevent_suppress:1;
+};
+extern int kobject_set_name(struct kobject *kobj, const char *name, ...)
+       __attribute__((format(printf, 2, 3)));
+extern int kobject_set_name_vargs(struct kobject *kobj, const char *fmt,
+      va_list vargs);
+static inline __attribute__((always_inline)) const char *kobject_name(const struct kobject *kobj)
+{
+ return kobj->name;
+}
+extern void kobject_init(struct kobject *kobj, struct kobj_type *ktype);
+extern int kobject_add(struct kobject *kobj,
+        struct kobject *parent,
+        const char *fmt, ...);
+extern int kobject_init_and_add(struct kobject *kobj,
+          struct kobj_type *ktype,
+          struct kobject *parent,
+          const char *fmt, ...);
+extern void kobject_del(struct kobject *kobj);
+extern struct kobject * kobject_create(void);
+extern struct kobject * kobject_create_and_add(const char *name,
+      struct kobject *parent);
+extern int kobject_rename(struct kobject *, const char *new_name);
+extern int kobject_move(struct kobject *, struct kobject *);
+extern struct kobject *kobject_get(struct kobject *kobj);
+extern void kobject_put(struct kobject *kobj);
+extern char *kobject_get_path(struct kobject *kobj, gfp_t flag);
+struct kobj_type {
+ void (*release)(struct kobject *kobj);
+ struct sysfs_ops *sysfs_ops;
+ struct attribute **default_attrs;
+};
+struct kobj_uevent_env {
+ char *envp[32];
+ int envp_idx;
+ char buf[2048];
+ int buflen;
+};
+struct kset_uevent_ops {
+ int (*filter)(struct kset *kset, struct kobject *kobj);
+ const char *(*name)(struct kset *kset, struct kobject *kobj);
+ int (*uevent)(struct kset *kset, struct kobject *kobj,
+        struct kobj_uevent_env *env);
+};
+struct kobj_attribute {
+ struct attribute attr;
+ ssize_t (*show)(struct kobject *kobj, struct kobj_attribute *attr,
+   char *buf);
+ ssize_t (*store)(struct kobject *kobj, struct kobj_attribute *attr,
+    const char *buf, size_t count);
+};
+extern struct sysfs_ops kobj_sysfs_ops;
+struct kset {
+ struct list_head list;
+ spinlock_t list_lock;
+ struct kobject kobj;
+ struct kset_uevent_ops *uevent_ops;
+};
+extern void kset_init(struct kset *kset);
+extern int kset_register(struct kset *kset);
+extern void kset_unregister(struct kset *kset);
+extern struct kset * kset_create_and_add(const char *name,
+      struct kset_uevent_ops *u,
+      struct kobject *parent_kobj);
+static inline __attribute__((always_inline)) struct kset *to_kset(struct kobject *kobj)
+{
+ return kobj ? ({ const typeof( ((struct kset *)0)->kobj ) *__mptr = (kobj); (struct kset *)( (char *)__mptr - __builtin_offsetof(struct kset,kobj) );}) : ((void *)0);
+}
+static inline __attribute__((always_inline)) struct kset *kset_get(struct kset *k)
+{
+ return k ? to_kset(kobject_get(&k->kobj)) : ((void *)0);
+}
+static inline __attribute__((always_inline)) void kset_put(struct kset *k)
+{
+ kobject_put(&k->kobj);
+}
+static inline __attribute__((always_inline)) struct kobj_type *get_ktype(struct kobject *kobj)
+{
+ return kobj->ktype;
+}
+extern struct kobject *kset_find_obj(struct kset *, const char *);
+extern struct kobject *kernel_kobj;
+extern struct kobject *mm_kobj;
+extern struct kobject *hypervisor_kobj;
+extern struct kobject *power_kobj;
+extern struct kobject *firmware_kobj;
+int kobject_uevent(struct kobject *kobj, enum kobject_action action);
+int kobject_uevent_env(struct kobject *kobj, enum kobject_action action,
+   char *envp[]);
+int add_uevent_var(struct kobj_uevent_env *env, const char *format, ...)
+ __attribute__((format (printf, 2, 3)));
+int kobject_action_type(const char *buf, size_t count,
+   enum kobject_action *type);
+static inline __attribute__((always_inline)) void
+account_scheduler_latency(struct task_struct *task, int usecs, int inter)
+{
+}
+static inline __attribute__((always_inline)) void clear_all_latency_tracing(struct task_struct *p)
+{
+}
+struct completion;
+struct __sysctl_args {
+ int *name;
+ int nlen;
+ void *oldval;
+ size_t *oldlenp;
+ void *newval;
+ size_t newlen;
+ unsigned long __unused[4];
+};
+enum
+{
+ CTL_KERN=1,
+ CTL_VM=2,
+ CTL_NET=3,
+ CTL_PROC=4,
+ CTL_FS=5,
+ CTL_DEBUG=6,
+ CTL_DEV=7,
+ CTL_BUS=8,
+ CTL_ABI=9,
+ CTL_CPU=10,
+ CTL_ARLAN=254,
+ CTL_S390DBF=5677,
+ CTL_SUNRPC=7249,
+ CTL_PM=9899,
+ CTL_FRV=9898,
+};
+enum
+{
+ CTL_BUS_ISA=1
+};
+enum
+{
+ INOTIFY_MAX_USER_INSTANCES=1,
+ INOTIFY_MAX_USER_WATCHES=2,
+ INOTIFY_MAX_QUEUED_EVENTS=3
+};
+enum
+{
+ KERN_OSTYPE=1,
+ KERN_OSRELEASE=2,
+ KERN_OSREV=3,
+ KERN_VERSION=4,
+ KERN_SECUREMASK=5,
+ KERN_PROF=6,
+ KERN_NODENAME=7,
+ KERN_DOMAINNAME=8,
+ KERN_PANIC=15,
+ KERN_REALROOTDEV=16,
+ KERN_SPARC_REBOOT=21,
+ KERN_CTLALTDEL=22,
+ KERN_PRINTK=23,
+ KERN_NAMETRANS=24,
+ KERN_PPC_HTABRECLAIM=25,
+ KERN_PPC_ZEROPAGED=26,
+ KERN_PPC_POWERSAVE_NAP=27,
+ KERN_MODPROBE=28,
+ KERN_SG_BIG_BUFF=29,
+ KERN_ACCT=30,
+ KERN_PPC_L2CR=31,
+ KERN_RTSIGNR=32,
+ KERN_RTSIGMAX=33,
+ KERN_SHMMAX=34,
+ KERN_MSGMAX=35,
+ KERN_MSGMNB=36,
+ KERN_MSGPOOL=37,
+ KERN_SYSRQ=38,
+ KERN_MAX_THREADS=39,
+  KERN_RANDOM=40,
+  KERN_SHMALL=41,
+  KERN_MSGMNI=42,
+  KERN_SEM=43,
+  KERN_SPARC_STOP_A=44,
+  KERN_SHMMNI=45,
+ KERN_OVERFLOWUID=46,
+ KERN_OVERFLOWGID=47,
+ KERN_SHMPATH=48,
+ KERN_HOTPLUG=49,
+ KERN_IEEE_EMULATION_WARNINGS=50,
+ KERN_S390_USER_DEBUG_LOGGING=51,
+ KERN_CORE_USES_PID=52,
+ KERN_TAINTED=53,
+ KERN_CADPID=54,
+ KERN_PIDMAX=55,
+   KERN_CORE_PATTERN=56,
+ KERN_PANIC_ON_OOPS=57,
+ KERN_HPPA_PWRSW=58,
+ KERN_HPPA_UNALIGNED=59,
+ KERN_PRINTK_RATELIMIT=60,
+ KERN_PRINTK_RATELIMIT_BURST=61,
+ KERN_PTY=62,
+ KERN_NGROUPS_MAX=63,
+ KERN_SPARC_SCONS_PWROFF=64,
+ KERN_HZ_TIMER=65,
+ KERN_UNKNOWN_NMI_PANIC=66,
+ KERN_BOOTLOADER_TYPE=67,
+ KERN_RANDOMIZE=68,
+ KERN_SETUID_DUMPABLE=69,
+ KERN_SPIN_RETRY=70,
+ KERN_ACPI_VIDEO_FLAGS=71,
+ KERN_IA64_UNALIGNED=72,
+ KERN_COMPAT_LOG=73,
+ KERN_MAX_LOCK_DEPTH=74,
+ KERN_NMI_WATCHDOG=75,
+ KERN_PANIC_ON_NMI=76,
+ KERN_FBCON_DECOR=77,
+};
+enum
+{
+ VM_UNUSED1=1,
+ VM_UNUSED2=2,
+ VM_UNUSED3=3,
+ VM_UNUSED4=4,
+ VM_OVERCOMMIT_MEMORY=5,
+ VM_UNUSED5=6,
+ VM_UNUSED7=7,
+ VM_UNUSED8=8,
+ VM_UNUSED9=9,
+ VM_PAGE_CLUSTER=10,
+ VM_DIRTY_BACKGROUND=11,
+ VM_DIRTY_RATIO=12,
+ VM_DIRTY_WB_CS=13,
+ VM_DIRTY_EXPIRE_CS=14,
+ VM_NR_PDFLUSH_THREADS=15,
+ VM_OVERCOMMIT_RATIO=16,
+ VM_PAGEBUF=17,
+ VM_HUGETLB_PAGES=18,
+ VM_SWAPPINESS=19,
+ VM_LOWMEM_RESERVE_RATIO=20,
+ VM_MIN_FREE_KBYTES=21,
+ VM_MAX_MAP_COUNT=22,
+ VM_LAPTOP_MODE=23,
+ VM_BLOCK_DUMP=24,
+ VM_HUGETLB_GROUP=25,
+ VM_VFS_CACHE_PRESSURE=26,
+ VM_LEGACY_VA_LAYOUT=27,
+ VM_SWAP_TOKEN_TIMEOUT=28,
+ VM_DROP_PAGECACHE=29,
+ VM_PERCPU_PAGELIST_FRACTION=30,
+ VM_ZONE_RECLAIM_MODE=31,
+ VM_MIN_UNMAPPED=32,
+ VM_PANIC_ON_OOM=33,
+ VM_VDSO_ENABLED=34,
+ VM_MIN_SLAB=35,
+};
+enum
+{
+ NET_CORE=1,
+ NET_ETHER=2,
+ NET_802=3,
+ NET_UNIX=4,
+ NET_IPV4=5,
+ NET_IPX=6,
+ NET_ATALK=7,
+ NET_NETROM=8,
+ NET_AX25=9,
+ NET_BRIDGE=10,
+ NET_ROSE=11,
+ NET_IPV6=12,
+ NET_X25=13,
+ NET_TR=14,
+ NET_DECNET=15,
+ NET_ECONET=16,
+ NET_SCTP=17,
+ NET_LLC=18,
+ NET_NETFILTER=19,
+ NET_DCCP=20,
+ NET_IRDA=412,
+};
+enum
+{
+ RANDOM_POOLSIZE=1,
+ RANDOM_ENTROPY_COUNT=2,
+ RANDOM_READ_THRESH=3,
+ RANDOM_WRITE_THRESH=4,
+ RANDOM_BOOT_ID=5,
+ RANDOM_UUID=6
+};
+enum
+{
+ PTY_MAX=1,
+ PTY_NR=2
+};
+enum
+{
+ BUS_ISA_MEM_BASE=1,
+ BUS_ISA_PORT_BASE=2,
+ BUS_ISA_PORT_SHIFT=3
+};
+enum
+{
+ NET_CORE_WMEM_MAX=1,
+ NET_CORE_RMEM_MAX=2,
+ NET_CORE_WMEM_DEFAULT=3,
+ NET_CORE_RMEM_DEFAULT=4,
+ NET_CORE_MAX_BACKLOG=6,
+ NET_CORE_FASTROUTE=7,
+ NET_CORE_MSG_COST=8,
+ NET_CORE_MSG_BURST=9,
+ NET_CORE_OPTMEM_MAX=10,
+ NET_CORE_HOT_LIST_LENGTH=11,
+ NET_CORE_DIVERT_VERSION=12,
+ NET_CORE_NO_CONG_THRESH=13,
+ NET_CORE_NO_CONG=14,
+ NET_CORE_LO_CONG=15,
+ NET_CORE_MOD_CONG=16,
+ NET_CORE_DEV_WEIGHT=17,
+ NET_CORE_SOMAXCONN=18,
+ NET_CORE_BUDGET=19,
+ NET_CORE_AEVENT_ETIME=20,
+ NET_CORE_AEVENT_RSEQTH=21,
+ NET_CORE_WARNINGS=22,
+};
+enum
+{
+ NET_UNIX_DESTROY_DELAY=1,
+ NET_UNIX_DELETE_DELAY=2,
+ NET_UNIX_MAX_DGRAM_QLEN=3,
+};
+enum
+{
+ NET_NF_CONNTRACK_MAX=1,
+ NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT=2,
+ NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV=3,
+ NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED=4,
+ NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT=5,
+ NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT=6,
+ NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK=7,
+ NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT=8,
+ NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE=9,
+ NET_NF_CONNTRACK_UDP_TIMEOUT=10,
+ NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM=11,
+ NET_NF_CONNTRACK_ICMP_TIMEOUT=12,
+ NET_NF_CONNTRACK_GENERIC_TIMEOUT=13,
+ NET_NF_CONNTRACK_BUCKETS=14,
+ NET_NF_CONNTRACK_LOG_INVALID=15,
+ NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS=16,
+ NET_NF_CONNTRACK_TCP_LOOSE=17,
+ NET_NF_CONNTRACK_TCP_BE_LIBERAL=18,
+ NET_NF_CONNTRACK_TCP_MAX_RETRANS=19,
+ NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED=20,
+ NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT=21,
+ NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED=22,
+ NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED=23,
+ NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT=24,
+ NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD=25,
+ NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT=26,
+ NET_NF_CONNTRACK_COUNT=27,
+ NET_NF_CONNTRACK_ICMPV6_TIMEOUT=28,
+ NET_NF_CONNTRACK_FRAG6_TIMEOUT=29,
+ NET_NF_CONNTRACK_FRAG6_LOW_THRESH=30,
+ NET_NF_CONNTRACK_FRAG6_HIGH_THRESH=31,
+ NET_NF_CONNTRACK_CHECKSUM=32,
+};
+enum
+{
+ NET_IPV4_FORWARD=8,
+ NET_IPV4_DYNADDR=9,
+ NET_IPV4_CONF=16,
+ NET_IPV4_NEIGH=17,
+ NET_IPV4_ROUTE=18,
+ NET_IPV4_FIB_HASH=19,
+ NET_IPV4_NETFILTER=20,
+ NET_IPV4_TCP_TIMESTAMPS=33,
+ NET_IPV4_TCP_WINDOW_SCALING=34,
+ NET_IPV4_TCP_SACK=35,
+ NET_IPV4_TCP_RETRANS_COLLAPSE=36,
+ NET_IPV4_DEFAULT_TTL=37,
+ NET_IPV4_AUTOCONFIG=38,
+ NET_IPV4_NO_PMTU_DISC=39,
+ NET_IPV4_TCP_SYN_RETRIES=40,
+ NET_IPV4_IPFRAG_HIGH_THRESH=41,
+ NET_IPV4_IPFRAG_LOW_THRESH=42,
+ NET_IPV4_IPFRAG_TIME=43,
+ NET_IPV4_TCP_MAX_KA_PROBES=44,
+ NET_IPV4_TCP_KEEPALIVE_TIME=45,
+ NET_IPV4_TCP_KEEPALIVE_PROBES=46,
+ NET_IPV4_TCP_RETRIES1=47,
+ NET_IPV4_TCP_RETRIES2=48,
+ NET_IPV4_TCP_FIN_TIMEOUT=49,
+ NET_IPV4_IP_MASQ_DEBUG=50,
+ NET_TCP_SYNCOOKIES=51,
+ NET_TCP_STDURG=52,
+ NET_TCP_RFC1337=53,
+ NET_TCP_SYN_TAILDROP=54,
+ NET_TCP_MAX_SYN_BACKLOG=55,
+ NET_IPV4_LOCAL_PORT_RANGE=56,
+ NET_IPV4_ICMP_ECHO_IGNORE_ALL=57,
+ NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS=58,
+ NET_IPV4_ICMP_SOURCEQUENCH_RATE=59,
+ NET_IPV4_ICMP_DESTUNREACH_RATE=60,
+ NET_IPV4_ICMP_TIMEEXCEED_RATE=61,
+ NET_IPV4_ICMP_PARAMPROB_RATE=62,
+ NET_IPV4_ICMP_ECHOREPLY_RATE=63,
+ NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES=64,
+ NET_IPV4_IGMP_MAX_MEMBERSHIPS=65,
+ NET_TCP_TW_RECYCLE=66,
+ NET_IPV4_ALWAYS_DEFRAG=67,
+ NET_IPV4_TCP_KEEPALIVE_INTVL=68,
+ NET_IPV4_INET_PEER_THRESHOLD=69,
+ NET_IPV4_INET_PEER_MINTTL=70,
+ NET_IPV4_INET_PEER_MAXTTL=71,
+ NET_IPV4_INET_PEER_GC_MINTIME=72,
+ NET_IPV4_INET_PEER_GC_MAXTIME=73,
+ NET_TCP_ORPHAN_RETRIES=74,
+ NET_TCP_ABORT_ON_OVERFLOW=75,
+ NET_TCP_SYNACK_RETRIES=76,
+ NET_TCP_MAX_ORPHANS=77,
+ NET_TCP_MAX_TW_BUCKETS=78,
+ NET_TCP_FACK=79,
+ NET_TCP_REORDERING=80,
+ NET_TCP_ECN=81,
+ NET_TCP_DSACK=82,
+ NET_TCP_MEM=83,
+ NET_TCP_WMEM=84,
+ NET_TCP_RMEM=85,
+ NET_TCP_APP_WIN=86,
+ NET_TCP_ADV_WIN_SCALE=87,
+ NET_IPV4_NONLOCAL_BIND=88,
+ NET_IPV4_ICMP_RATELIMIT=89,
+ NET_IPV4_ICMP_RATEMASK=90,
+ NET_TCP_TW_REUSE=91,
+ NET_TCP_FRTO=92,
+ NET_TCP_LOW_LATENCY=93,
+ NET_IPV4_IPFRAG_SECRET_INTERVAL=94,
+ NET_IPV4_IGMP_MAX_MSF=96,
+ NET_TCP_NO_METRICS_SAVE=97,
+ NET_TCP_DEFAULT_WIN_SCALE=105,
+ NET_TCP_MODERATE_RCVBUF=106,
+ NET_TCP_TSO_WIN_DIVISOR=107,
+ NET_TCP_BIC_BETA=108,
+ NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR=109,
+ NET_TCP_CONG_CONTROL=110,
+ NET_TCP_ABC=111,
+ NET_IPV4_IPFRAG_MAX_DIST=112,
+  NET_TCP_MTU_PROBING=113,
+ NET_TCP_BASE_MSS=114,
+ NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS=115,
+ NET_TCP_DMA_COPYBREAK=116,
+ NET_TCP_SLOW_START_AFTER_IDLE=117,
+ NET_CIPSOV4_CACHE_ENABLE=118,
+ NET_CIPSOV4_CACHE_BUCKET_SIZE=119,
+ NET_CIPSOV4_RBM_OPTFMT=120,
+ NET_CIPSOV4_RBM_STRICTVALID=121,
+ NET_TCP_AVAIL_CONG_CONTROL=122,
+ NET_TCP_ALLOWED_CONG_CONTROL=123,
+ NET_TCP_MAX_SSTHRESH=124,
+ NET_TCP_FRTO_RESPONSE=125,
+};
+enum {
+ NET_IPV4_ROUTE_FLUSH=1,
+ NET_IPV4_ROUTE_MIN_DELAY=2,
+ NET_IPV4_ROUTE_MAX_DELAY=3,
+ NET_IPV4_ROUTE_GC_THRESH=4,
+ NET_IPV4_ROUTE_MAX_SIZE=5,
+ NET_IPV4_ROUTE_GC_MIN_INTERVAL=6,
+ NET_IPV4_ROUTE_GC_TIMEOUT=7,
+ NET_IPV4_ROUTE_GC_INTERVAL=8,
+ NET_IPV4_ROUTE_REDIRECT_LOAD=9,
+ NET_IPV4_ROUTE_REDIRECT_NUMBER=10,
+ NET_IPV4_ROUTE_REDIRECT_SILENCE=11,
+ NET_IPV4_ROUTE_ERROR_COST=12,
+ NET_IPV4_ROUTE_ERROR_BURST=13,
+ NET_IPV4_ROUTE_GC_ELASTICITY=14,
+ NET_IPV4_ROUTE_MTU_EXPIRES=15,
+ NET_IPV4_ROUTE_MIN_PMTU=16,
+ NET_IPV4_ROUTE_MIN_ADVMSS=17,
+ NET_IPV4_ROUTE_SECRET_INTERVAL=18,
+ NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS=19,
+};
+enum
+{
+ NET_PROTO_CONF_ALL=-2,
+ NET_PROTO_CONF_DEFAULT=-3
+};
+enum
+{
+ NET_IPV4_CONF_FORWARDING=1,
+ NET_IPV4_CONF_MC_FORWARDING=2,
+ NET_IPV4_CONF_PROXY_ARP=3,
+ NET_IPV4_CONF_ACCEPT_REDIRECTS=4,
+ NET_IPV4_CONF_SECURE_REDIRECTS=5,
+ NET_IPV4_CONF_SEND_REDIRECTS=6,
+ NET_IPV4_CONF_SHARED_MEDIA=7,
+ NET_IPV4_CONF_RP_FILTER=8,
+ NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE=9,
+ NET_IPV4_CONF_BOOTP_RELAY=10,
+ NET_IPV4_CONF_LOG_MARTIANS=11,
+ NET_IPV4_CONF_TAG=12,
+ NET_IPV4_CONF_ARPFILTER=13,
+ NET_IPV4_CONF_MEDIUM_ID=14,
+ NET_IPV4_CONF_NOXFRM=15,
+ NET_IPV4_CONF_NOPOLICY=16,
+ NET_IPV4_CONF_FORCE_IGMP_VERSION=17,
+ NET_IPV4_CONF_ARP_ANNOUNCE=18,
+ NET_IPV4_CONF_ARP_IGNORE=19,
+ NET_IPV4_CONF_PROMOTE_SECONDARIES=20,
+ NET_IPV4_CONF_ARP_ACCEPT=21,
+ NET_IPV4_CONF_ARP_NOTIFY=22,
+ NET_IPV4_CONF_SRC_VMARK=24,
+ __NET_IPV4_CONF_MAX
+};
+enum
+{
+ NET_IPV4_NF_CONNTRACK_MAX=1,
+ NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT=2,
+ NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV=3,
+ NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED=4,
+ NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT=5,
+ NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT=6,
+ NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK=7,
+ NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT=8,
+ NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE=9,
+ NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT=10,
+ NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM=11,
+ NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT=12,
+ NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT=13,
+ NET_IPV4_NF_CONNTRACK_BUCKETS=14,
+ NET_IPV4_NF_CONNTRACK_LOG_INVALID=15,
+ NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS=16,
+ NET_IPV4_NF_CONNTRACK_TCP_LOOSE=17,
+ NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL=18,
+ NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS=19,
+  NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED=20,
+  NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT=21,
+  NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED=22,
+  NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED=23,
+  NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT=24,
+  NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD=25,
+  NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT=26,
+ NET_IPV4_NF_CONNTRACK_COUNT=27,
+ NET_IPV4_NF_CONNTRACK_CHECKSUM=28,
+};
+enum {
+ NET_IPV6_CONF=16,
+ NET_IPV6_NEIGH=17,
+ NET_IPV6_ROUTE=18,
+ NET_IPV6_ICMP=19,
+ NET_IPV6_BINDV6ONLY=20,
+ NET_IPV6_IP6FRAG_HIGH_THRESH=21,
+ NET_IPV6_IP6FRAG_LOW_THRESH=22,
+ NET_IPV6_IP6FRAG_TIME=23,
+ NET_IPV6_IP6FRAG_SECRET_INTERVAL=24,
+ NET_IPV6_MLD_MAX_MSF=25,
+};
+enum {
+ NET_IPV6_ROUTE_FLUSH=1,
+ NET_IPV6_ROUTE_GC_THRESH=2,
+ NET_IPV6_ROUTE_MAX_SIZE=3,
+ NET_IPV6_ROUTE_GC_MIN_INTERVAL=4,
+ NET_IPV6_ROUTE_GC_TIMEOUT=5,
+ NET_IPV6_ROUTE_GC_INTERVAL=6,
+ NET_IPV6_ROUTE_GC_ELASTICITY=7,
+ NET_IPV6_ROUTE_MTU_EXPIRES=8,
+ NET_IPV6_ROUTE_MIN_ADVMSS=9,
+ NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS=10
+};
+enum {
+ NET_IPV6_FORWARDING=1,
+ NET_IPV6_HOP_LIMIT=2,
+ NET_IPV6_MTU=3,
+ NET_IPV6_ACCEPT_RA=4,
+ NET_IPV6_ACCEPT_REDIRECTS=5,
+ NET_IPV6_AUTOCONF=6,
+ NET_IPV6_DAD_TRANSMITS=7,
+ NET_IPV6_RTR_SOLICITS=8,
+ NET_IPV6_RTR_SOLICIT_INTERVAL=9,
+ NET_IPV6_RTR_SOLICIT_DELAY=10,
+ NET_IPV6_USE_TEMPADDR=11,
+ NET_IPV6_TEMP_VALID_LFT=12,
+ NET_IPV6_TEMP_PREFERED_LFT=13,
+ NET_IPV6_REGEN_MAX_RETRY=14,
+ NET_IPV6_MAX_DESYNC_FACTOR=15,
+ NET_IPV6_MAX_ADDRESSES=16,
+ NET_IPV6_FORCE_MLD_VERSION=17,
+ NET_IPV6_ACCEPT_RA_DEFRTR=18,
+ NET_IPV6_ACCEPT_RA_PINFO=19,
+ NET_IPV6_ACCEPT_RA_RTR_PREF=20,
+ NET_IPV6_RTR_PROBE_INTERVAL=21,
+ NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN=22,
+ NET_IPV6_PROXY_NDP=23,
+ NET_IPV6_ACCEPT_SOURCE_ROUTE=25,
+ __NET_IPV6_MAX
+};
+enum {
+ NET_IPV6_ICMP_RATELIMIT=1
+};
+enum {
+ NET_NEIGH_MCAST_SOLICIT=1,
+ NET_NEIGH_UCAST_SOLICIT=2,
+ NET_NEIGH_APP_SOLICIT=3,
+ NET_NEIGH_RETRANS_TIME=4,
+ NET_NEIGH_REACHABLE_TIME=5,
+ NET_NEIGH_DELAY_PROBE_TIME=6,
+ NET_NEIGH_GC_STALE_TIME=7,
+ NET_NEIGH_UNRES_QLEN=8,
+ NET_NEIGH_PROXY_QLEN=9,
+ NET_NEIGH_ANYCAST_DELAY=10,
+ NET_NEIGH_PROXY_DELAY=11,
+ NET_NEIGH_LOCKTIME=12,
+ NET_NEIGH_GC_INTERVAL=13,
+ NET_NEIGH_GC_THRESH1=14,
+ NET_NEIGH_GC_THRESH2=15,
+ NET_NEIGH_GC_THRESH3=16,
+ NET_NEIGH_RETRANS_TIME_MS=17,
+ NET_NEIGH_REACHABLE_TIME_MS=18,
+ __NET_NEIGH_MAX
+};
+enum {
+ NET_DCCP_DEFAULT=1,
+};
+enum {
+ NET_IPX_PPROP_BROADCASTING=1,
+ NET_IPX_FORWARDING=2
+};
+enum {
+ NET_LLC2=1,
+ NET_LLC_STATION=2,
+};
+enum {
+ NET_LLC2_TIMEOUT=1,
+};
+enum {
+ NET_LLC_STATION_ACK_TIMEOUT=1,
+};
+enum {
+ NET_LLC2_ACK_TIMEOUT=1,
+ NET_LLC2_P_TIMEOUT=2,
+ NET_LLC2_REJ_TIMEOUT=3,
+ NET_LLC2_BUSY_TIMEOUT=4,
+};
+enum {
+ NET_ATALK_AARP_EXPIRY_TIME=1,
+ NET_ATALK_AARP_TICK_TIME=2,
+ NET_ATALK_AARP_RETRANSMIT_LIMIT=3,
+ NET_ATALK_AARP_RESOLVE_TIME=4
+};
+enum {
+ NET_NETROM_DEFAULT_PATH_QUALITY=1,
+ NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER=2,
+ NET_NETROM_NETWORK_TTL_INITIALISER=3,
+ NET_NETROM_TRANSPORT_TIMEOUT=4,
+ NET_NETROM_TRANSPORT_MAXIMUM_TRIES=5,
+ NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY=6,
+ NET_NETROM_TRANSPORT_BUSY_DELAY=7,
+ NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE=8,
+ NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT=9,
+ NET_NETROM_ROUTING_CONTROL=10,
+ NET_NETROM_LINK_FAILS_COUNT=11,
+ NET_NETROM_RESET=12
+};
+enum {
+ NET_AX25_IP_DEFAULT_MODE=1,
+ NET_AX25_DEFAULT_MODE=2,
+ NET_AX25_BACKOFF_TYPE=3,
+ NET_AX25_CONNECT_MODE=4,
+ NET_AX25_STANDARD_WINDOW=5,
+ NET_AX25_EXTENDED_WINDOW=6,
+ NET_AX25_T1_TIMEOUT=7,
+ NET_AX25_T2_TIMEOUT=8,
+ NET_AX25_T3_TIMEOUT=9,
+ NET_AX25_IDLE_TIMEOUT=10,
+ NET_AX25_N2=11,
+ NET_AX25_PACLEN=12,
+ NET_AX25_PROTOCOL=13,
+ NET_AX25_DAMA_SLAVE_TIMEOUT=14
+};
+enum {
+ NET_ROSE_RESTART_REQUEST_TIMEOUT=1,
+ NET_ROSE_CALL_REQUEST_TIMEOUT=2,
+ NET_ROSE_RESET_REQUEST_TIMEOUT=3,
+ NET_ROSE_CLEAR_REQUEST_TIMEOUT=4,
+ NET_ROSE_ACK_HOLD_BACK_TIMEOUT=5,
+ NET_ROSE_ROUTING_CONTROL=6,
+ NET_ROSE_LINK_FAIL_TIMEOUT=7,
+ NET_ROSE_MAX_VCS=8,
+ NET_ROSE_WINDOW_SIZE=9,
+ NET_ROSE_NO_ACTIVITY_TIMEOUT=10
+};
+enum {
+ NET_X25_RESTART_REQUEST_TIMEOUT=1,
+ NET_X25_CALL_REQUEST_TIMEOUT=2,
+ NET_X25_RESET_REQUEST_TIMEOUT=3,
+ NET_X25_CLEAR_REQUEST_TIMEOUT=4,
+ NET_X25_ACK_HOLD_BACK_TIMEOUT=5,
+ NET_X25_FORWARD=6
+};
+enum
+{
+ NET_TR_RIF_TIMEOUT=1
+};
+enum {
+ NET_DECNET_NODE_TYPE = 1,
+ NET_DECNET_NODE_ADDRESS = 2,
+ NET_DECNET_NODE_NAME = 3,
+ NET_DECNET_DEFAULT_DEVICE = 4,
+ NET_DECNET_TIME_WAIT = 5,
+ NET_DECNET_DN_COUNT = 6,
+ NET_DECNET_DI_COUNT = 7,
+ NET_DECNET_DR_COUNT = 8,
+ NET_DECNET_DST_GC_INTERVAL = 9,
+ NET_DECNET_CONF = 10,
+ NET_DECNET_NO_FC_MAX_CWND = 11,
+ NET_DECNET_MEM = 12,
+ NET_DECNET_RMEM = 13,
+ NET_DECNET_WMEM = 14,
+ NET_DECNET_DEBUG_LEVEL = 255
+};
+enum {
+ NET_DECNET_CONF_LOOPBACK = -2,
+ NET_DECNET_CONF_DDCMP = -3,
+ NET_DECNET_CONF_PPP = -4,
+ NET_DECNET_CONF_X25 = -5,
+ NET_DECNET_CONF_GRE = -6,
+ NET_DECNET_CONF_ETHER = -7
+};
+enum {
+ NET_DECNET_CONF_DEV_PRIORITY = 1,
+ NET_DECNET_CONF_DEV_T1 = 2,
+ NET_DECNET_CONF_DEV_T2 = 3,
+ NET_DECNET_CONF_DEV_T3 = 4,
+ NET_DECNET_CONF_DEV_FORWARDING = 5,
+ NET_DECNET_CONF_DEV_BLKSIZE = 6,
+ NET_DECNET_CONF_DEV_STATE = 7
+};
+enum {
+ NET_SCTP_RTO_INITIAL = 1,
+ NET_SCTP_RTO_MIN = 2,
+ NET_SCTP_RTO_MAX = 3,
+ NET_SCTP_RTO_ALPHA = 4,
+ NET_SCTP_RTO_BETA = 5,
+ NET_SCTP_VALID_COOKIE_LIFE = 6,
+ NET_SCTP_ASSOCIATION_MAX_RETRANS = 7,
+ NET_SCTP_PATH_MAX_RETRANS = 8,
+ NET_SCTP_MAX_INIT_RETRANSMITS = 9,
+ NET_SCTP_HB_INTERVAL = 10,
+ NET_SCTP_PRESERVE_ENABLE = 11,
+ NET_SCTP_MAX_BURST = 12,
+ NET_SCTP_ADDIP_ENABLE = 13,
+ NET_SCTP_PRSCTP_ENABLE = 14,
+ NET_SCTP_SNDBUF_POLICY = 15,
+ NET_SCTP_SACK_TIMEOUT = 16,
+ NET_SCTP_RCVBUF_POLICY = 17,
+};
+enum {
+ NET_BRIDGE_NF_CALL_ARPTABLES = 1,
+ NET_BRIDGE_NF_CALL_IPTABLES = 2,
+ NET_BRIDGE_NF_CALL_IP6TABLES = 3,
+ NET_BRIDGE_NF_FILTER_VLAN_TAGGED = 4,
+ NET_BRIDGE_NF_FILTER_PPPOE_TAGGED = 5,
+};
+enum {
+ NET_IRDA_DISCOVERY=1,
+ NET_IRDA_DEVNAME=2,
+ NET_IRDA_DEBUG=3,
+ NET_IRDA_FAST_POLL=4,
+ NET_IRDA_DISCOVERY_SLOTS=5,
+ NET_IRDA_DISCOVERY_TIMEOUT=6,
+ NET_IRDA_SLOT_TIMEOUT=7,
+ NET_IRDA_MAX_BAUD_RATE=8,
+ NET_IRDA_MIN_TX_TURN_TIME=9,
+ NET_IRDA_MAX_TX_DATA_SIZE=10,
+ NET_IRDA_MAX_TX_WINDOW=11,
+ NET_IRDA_MAX_NOREPLY_TIME=12,
+ NET_IRDA_WARN_NOREPLY_TIME=13,
+ NET_IRDA_LAP_KEEPALIVE_TIME=14,
+};
+enum
+{
+ FS_NRINODE=1,
+ FS_STATINODE=2,
+ FS_MAXINODE=3,
+ FS_NRDQUOT=4,
+ FS_MAXDQUOT=5,
+ FS_NRFILE=6,
+ FS_MAXFILE=7,
+ FS_DENTRY=8,
+ FS_NRSUPER=9,
+ FS_MAXSUPER=10,
+ FS_OVERFLOWUID=11,
+ FS_OVERFLOWGID=12,
+ FS_LEASES=13,
+ FS_DIR_NOTIFY=14,
+ FS_LEASE_TIME=15,
+ FS_DQSTATS=16,
+ FS_XFS=17,
+ FS_AIO_NR=18,
+ FS_AIO_MAX_NR=19,
+ FS_INOTIFY=20,
+ FS_OCFS2=988,
+};
+enum {
+ FS_DQ_LOOKUPS = 1,
+ FS_DQ_DROPS = 2,
+ FS_DQ_READS = 3,
+ FS_DQ_WRITES = 4,
+ FS_DQ_CACHE_HITS = 5,
+ FS_DQ_ALLOCATED = 6,
+ FS_DQ_FREE = 7,
+ FS_DQ_SYNCS = 8,
+ FS_DQ_WARNINGS = 9,
+};
+enum {
+ DEV_CDROM=1,
+ DEV_HWMON=2,
+ DEV_PARPORT=3,
+ DEV_RAID=4,
+ DEV_MAC_HID=5,
+ DEV_SCSI=6,
+ DEV_IPMI=7,
+};
+enum {
+ DEV_CDROM_INFO=1,
+ DEV_CDROM_AUTOCLOSE=2,
+ DEV_CDROM_AUTOEJECT=3,
+ DEV_CDROM_DEBUG=4,
+ DEV_CDROM_LOCK=5,
+ DEV_CDROM_CHECK_MEDIA=6
+};
+enum {
+ DEV_PARPORT_DEFAULT=-3
+};
+enum {
+ DEV_RAID_SPEED_LIMIT_MIN=1,
+ DEV_RAID_SPEED_LIMIT_MAX=2
+};
+enum {
+ DEV_PARPORT_DEFAULT_TIMESLICE=1,
+ DEV_PARPORT_DEFAULT_SPINTIME=2
+};
+enum {
+ DEV_PARPORT_SPINTIME=1,
+ DEV_PARPORT_BASE_ADDR=2,
+ DEV_PARPORT_IRQ=3,
+ DEV_PARPORT_DMA=4,
+ DEV_PARPORT_MODES=5,
+ DEV_PARPORT_DEVICES=6,
+ DEV_PARPORT_AUTOPROBE=16
+};
+enum {
+ DEV_PARPORT_DEVICES_ACTIVE=-3,
+};
+enum {
+ DEV_PARPORT_DEVICE_TIMESLICE=1,
+};
+enum {
+ DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES=1,
+ DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES=2,
+ DEV_MAC_HID_MOUSE_BUTTON_EMULATION=3,
+ DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE=4,
+ DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE=5,
+ DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES=6
+};
+enum {
+ DEV_SCSI_LOGGING_LEVEL=1,
+};
+enum {
+ DEV_IPMI_POWEROFF_POWERCYCLE=1,
+};
+enum
+{
+ ABI_DEFHANDLER_COFF=1,
+ ABI_DEFHANDLER_ELF=2,
+ ABI_DEFHANDLER_LCALL7=3,
+ ABI_DEFHANDLER_LIBCSO=4,
+ ABI_TRACE=5,
+ ABI_FAKE_UTSNAME=6,
+};
+struct ctl_table;
+struct nsproxy;
+struct ctl_table_root;
+struct ctl_table_set {
+ struct list_head list;
+ struct ctl_table_set *parent;
+ int (*is_seen)(struct ctl_table_set *);
+};
+extern void setup_sysctl_set(struct ctl_table_set *p,
+ struct ctl_table_set *parent,
+ int (*is_seen)(struct ctl_table_set *));
+struct ctl_table_header;
+extern void sysctl_head_get(struct ctl_table_header *);
+extern void sysctl_head_put(struct ctl_table_header *);
+extern int sysctl_is_seen(struct ctl_table_header *);
+extern struct ctl_table_header *sysctl_head_grab(struct ctl_table_header *);
+extern struct ctl_table_header *sysctl_head_next(struct ctl_table_header *prev);
+extern struct ctl_table_header *__sysctl_head_next(struct nsproxy *namespaces,
+      struct ctl_table_header *prev);
+extern void sysctl_head_finish(struct ctl_table_header *prev);
+extern int sysctl_perm(struct ctl_table_root *root,
+  struct ctl_table *table, int op);
+typedef struct ctl_table ctl_table;
+typedef int ctl_handler (struct ctl_table *table,
+    void *oldval, size_t *oldlenp,
+    void *newval, size_t newlen);
+typedef int proc_handler (struct ctl_table *ctl, int write,
+     void *buffer, size_t *lenp, loff_t *ppos);
+extern int proc_dostring(struct ctl_table *, int,
+    void *, size_t *, loff_t *);
+extern int proc_dointvec(struct ctl_table *, int,
+    void *, size_t *, loff_t *);
+extern int proc_dointvec_minmax(struct ctl_table *, int,
+    void *, size_t *, loff_t *);
+extern int proc_dointvec_jiffies(struct ctl_table *, int,
+     void *, size_t *, loff_t *);
+extern int proc_dointvec_userhz_jiffies(struct ctl_table *, int,
+     void *, size_t *, loff_t *);
+extern int proc_dointvec_ms_jiffies(struct ctl_table *, int,
+        void *, size_t *, loff_t *);
+extern int proc_doulongvec_minmax(struct ctl_table *, int,
+      void *, size_t *, loff_t *);
+extern int proc_doulongvec_ms_jiffies_minmax(struct ctl_table *table, int,
+          void *, size_t *, loff_t *);
+extern int do_sysctl (int *name, int nlen,
+        void *oldval, size_t *oldlenp,
+        void *newval, size_t newlen);
+extern ctl_handler sysctl_data;
+extern ctl_handler sysctl_string;
+extern ctl_handler sysctl_intvec;
+extern ctl_handler sysctl_jiffies;
+extern ctl_handler sysctl_ms_jiffies;
+struct ctl_table
+{
+ int ctl_name;
+ const char *procname;
+ void *data;
+ int maxlen;
+ mode_t mode;
+ struct ctl_table *child;
+ struct ctl_table *parent;
+ proc_handler *proc_handler;
+ ctl_handler *strategy;
+ void *extra1;
+ void *extra2;
+};
+struct ctl_table_root {
+ struct list_head root_list;
+ struct ctl_table_set default_set;
+ struct ctl_table_set *(*lookup)(struct ctl_table_root *root,
+        struct nsproxy *namespaces);
+ int (*permissions)(struct ctl_table_root *root,
+   struct nsproxy *namespaces, struct ctl_table *table);
+};
+struct ctl_table_header
+{
+ struct ctl_table *ctl_table;
+ struct list_head ctl_entry;
+ int used;
+ int count;
+ struct completion *unregistering;
+ struct ctl_table *ctl_table_arg;
+ struct ctl_table_root *root;
+ struct ctl_table_set *set;
+ struct ctl_table *attached_by;
+ struct ctl_table *attached_to;
+ struct ctl_table_header *parent;
+};
+struct ctl_path {
+ const char *procname;
+ int ctl_name;
+};
+void register_sysctl_root(struct ctl_table_root *root);
+struct ctl_table_header *__register_sysctl_paths(
+ struct ctl_table_root *root, struct nsproxy *namespaces,
+ const struct ctl_path *path, struct ctl_table *table);
+struct ctl_table_header *register_sysctl_table(struct ctl_table * table);
+struct ctl_table_header *register_sysctl_paths(const struct ctl_path *path,
+      struct ctl_table *table);
+void unregister_sysctl_table(struct ctl_table_header * table);
+int sysctl_check_table(struct nsproxy *namespaces, struct ctl_table *table);
+typedef int32_t key_serial_t;
+typedef uint32_t key_perm_t;
+struct key;
+struct selinux_audit_rule;
+struct audit_context;
+struct kern_ipc_perm;
+static inline __attribute__((always_inline)) int selinux_string_to_sid(const char *str, u32 *sid)
+{
+       *sid = 0;
+       return 0;
+}
+static inline __attribute__((always_inline)) int selinux_secmark_relabel_packet_permission(u32 sid)
+{
+ return 0;
+}
+static inline __attribute__((always_inline)) void selinux_secmark_refcount_inc(void)
+{
+ return;
+}
+static inline __attribute__((always_inline)) void selinux_secmark_refcount_dec(void)
+{
+ return;
+}
+static inline __attribute__((always_inline)) bool selinux_is_enabled(void)
+{
+ return false;
+}
+struct user_struct;
+struct cred;
+struct inode;
+struct group_info {
+ atomic_t usage;
+ int ngroups;
+ int nblocks;
+ gid_t small_block[32];
+ gid_t *blocks[0];
+};
+static inline __attribute__((always_inline)) struct group_info *get_group_info(struct group_info *gi)
+{
+ atomic_add(1,(&gi->usage));
+ return gi;
+}
+extern struct group_info *groups_alloc(int);
+extern struct group_info init_groups;
+extern void groups_free(struct group_info *);
+extern int set_current_groups(struct group_info *);
+extern int set_groups(struct cred *, struct group_info *);
+extern int groups_search(const struct group_info *, gid_t);
+extern int in_group_p(gid_t);
+extern int in_egroup_p(gid_t);
+struct cred {
+ atomic_t usage;
+ uid_t uid;
+ gid_t gid;
+ uid_t suid;
+ gid_t sgid;
+ uid_t euid;
+ gid_t egid;
+ uid_t fsuid;
+ gid_t fsgid;
+ unsigned securebits;
+ kernel_cap_t cap_inheritable;
+ kernel_cap_t cap_permitted;
+ kernel_cap_t cap_effective;
+ kernel_cap_t cap_bset;
+ struct user_struct *user;
+ struct group_info *group_info;
+ struct rcu_head rcu;
+};
+extern void __put_cred(struct cred *);
+extern void exit_creds(struct task_struct *);
+extern int copy_creds(struct task_struct *, unsigned long);
+extern struct cred *cred_alloc_blank(void);
+extern struct cred *prepare_creds(void);
+extern struct cred *prepare_exec_creds(void);
+extern struct cred *prepare_usermodehelper_creds(void);
+extern int commit_creds(struct cred *);
+extern void abort_creds(struct cred *);
+extern const struct cred *override_creds(const struct cred *);
+extern void revert_creds(const struct cred *);
+extern struct cred *prepare_kernel_cred(struct task_struct *);
+extern int change_create_files_as(struct cred *, struct inode *);
+extern int set_security_override(struct cred *, u32);
+extern int set_security_override_from_ctx(struct cred *, const char *);
+extern int set_create_files_as(struct cred *, struct inode *);
+extern void __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) __attribute__((no_instrument_function)) cred_init(void);
+static inline __attribute__((always_inline)) void validate_creds(const struct cred *cred)
+{
+}
+static inline __attribute__((always_inline)) void validate_creds_for_do_exit(struct task_struct *tsk)
+{
+}
+static inline __attribute__((always_inline)) void validate_process_creds(void)
+{
+}
+static inline __attribute__((always_inline)) struct cred *get_new_cred(struct cred *cred)
+{
+ atomic_add(1,(&cred->usage));
+ return cred;
+}
+static inline __attribute__((always_inline)) const struct cred *get_cred(const struct cred *cred)
+{
+ struct cred *nonconst_cred = (struct cred *) cred;
+ validate_creds(cred);
+ return get_new_cred(nonconst_cred);
+}
+static inline __attribute__((always_inline)) void put_cred(const struct cred *_cred)
+{
+ struct cred *cred = (struct cred *) _cred;
+ validate_creds(cred);
+ if ((atomic_sub_return(1, (&(cred)->usage)) == 0))
+  __put_cred(cred);
+}
+struct exec_domain;
+struct futex_pi_state;
+struct robust_list_head;
+struct bio;
+struct fs_struct;
+struct bts_context;
+struct perf_event_context;
+extern unsigned long avenrun[];
+extern void get_avenrun(unsigned long *loads, unsigned long offset, int shift);
+extern unsigned long total_forks;
+extern int nr_threads;
+extern __attribute__((section(".data" ""))) __typeof__(unsigned long) per_cpu__process_counts;
+extern int nr_processes(void);
+extern unsigned long nr_running(void);
+extern unsigned long nr_uninterruptible(void);
+extern unsigned long nr_iowait(void);
+extern unsigned long nr_iowait_cpu(void);
+extern unsigned long this_cpu_load(void);
+extern void calc_global_load(void);
+extern u64 cpu_nr_migrations(int cpu);
+extern unsigned long get_parent_ip(unsigned long addr);
+struct seq_file;
+struct cfs_rq;
+struct task_group;
+static inline __attribute__((always_inline)) void
+proc_sched_show_task(struct task_struct *p, struct seq_file *m)
+{
+}
+static inline __attribute__((always_inline)) void proc_sched_set_task(struct task_struct *p)
+{
+}
+static inline __attribute__((always_inline)) void
+print_cfs_rq(struct seq_file *m, int cpu, struct cfs_rq *cfs_rq)
+{
+}
+extern unsigned long long time_sync_thresh;
+extern rwlock_t tasklist_lock;
+extern spinlock_t mmlist_lock;
+struct task_struct;
+extern void sched_init(void);
+extern void sched_init_smp(void);
+extern void schedule_tail(struct task_struct *prev);
+extern void init_idle(struct task_struct *idle, int cpu);
+extern void init_idle_bootup_task(struct task_struct *idle);
+extern int runqueue_is_locked(int cpu);
+extern void task_rq_unlock_wait(struct task_struct *p);
+extern cpumask_var_t nohz_cpu_mask;
+static inline __attribute__((always_inline)) int select_nohz_load_balancer(int cpu)
+{
+ return 0;
+}
+extern void show_state_filter(unsigned long state_filter);
+static inline __attribute__((always_inline)) void show_state(void)
+{
+ show_state_filter(0);
+}
+extern void show_regs(struct pt_regs *);
+extern void show_stack(struct task_struct *task, unsigned long *sp);
+void io_schedule(void);
+long io_schedule_timeout(long timeout);
+extern void cpu_init (void);
+extern void trap_init(void);
+extern void update_process_times(int user);
+extern void scheduler_tick(void);
+extern void sched_show_task(struct task_struct *p);
+static inline __attribute__((always_inline)) void softlockup_tick(void)
+{
+}
+static inline __attribute__((always_inline)) void touch_softlockup_watchdog(void)
+{
+}
+static inline __attribute__((always_inline)) void touch_all_softlockup_watchdogs(void)
+{
+}
+extern char __sched_text_start[], __sched_text_end[];
+extern int in_sched_functions(unsigned long addr);
+extern signed long schedule_timeout(signed long timeout);
+extern signed long schedule_timeout_interruptible(signed long timeout);
+extern signed long schedule_timeout_killable(signed long timeout);
+extern signed long schedule_timeout_uninterruptible(signed long timeout);
+ void __schedule(void);
+ void schedule(void);
+extern int mutex_spin_on_owner(struct mutex *lock, struct thread_info *owner);
+struct nsproxy;
+struct user_namespace;
+extern int sysctl_max_map_count;
+struct workqueue_struct;
+struct work_struct;
+typedef void (*work_func_t)(struct work_struct *work);
+struct work_struct {
+ atomic_long_t data;
+ struct list_head entry;
+ work_func_t func;
+};
+struct delayed_work {
+ struct work_struct work;
+ struct timer_list timer;
+};
+static inline __attribute__((always_inline)) struct delayed_work *to_delayed_work(struct work_struct *work)
+{
+ return ({ const typeof( ((struct delayed_work *)0)->work ) *__mptr = (work); (struct delayed_work *)( (char *)__mptr - __builtin_offsetof(struct delayed_work,work) );});
+}
+struct execute_work {
+ struct work_struct work;
+};
+extern struct workqueue_struct *
+__create_workqueue_key(const char *name, int singlethread,
+         int freezeable, int rt, struct lock_class_key *key,
+         const char *lock_name);
+extern void destroy_workqueue(struct workqueue_struct *wq);
+extern int queue_work(struct workqueue_struct *wq, struct work_struct *work);
+extern int queue_work_on(int cpu, struct workqueue_struct *wq,
+   struct work_struct *work);
+extern int queue_delayed_work(struct workqueue_struct *wq,
+   struct delayed_work *work, unsigned long delay);
+extern int queue_delayed_work_on(int cpu, struct workqueue_struct *wq,
+   struct delayed_work *work, unsigned long delay);
+extern void flush_workqueue(struct workqueue_struct *wq);
+extern void flush_scheduled_work(void);
+extern void flush_delayed_work(struct delayed_work *work);
+extern int schedule_work(struct work_struct *work);
+extern int schedule_work_on(int cpu, struct work_struct *work);
+extern int schedule_delayed_work(struct delayed_work *work, unsigned long delay);
+extern int schedule_delayed_work_on(int cpu, struct delayed_work *work,
+     unsigned long delay);
+extern int schedule_on_each_cpu(work_func_t func);
+extern int current_is_keventd(void);
+extern int keventd_up(void);
+extern void init_workqueues(void);
+int execute_in_process_context(work_func_t fn, struct execute_work *);
+extern int flush_work(struct work_struct *work);
+extern int cancel_work_sync(struct work_struct *work);
+static inline __attribute__((always_inline)) int cancel_delayed_work(struct delayed_work *work)
+{
+ int ret;
+ ret = del_timer(&work->timer);
+ if (ret)
+  clear_bit(0, ((unsigned long *)(&(&work->work)->data)));
+ return ret;
+}
+static inline __attribute__((always_inline)) int __cancel_delayed_work(struct delayed_work *work)
+{
+ int ret;
+ ret = del_timer(&work->timer);
+ if (ret)
+  clear_bit(0, ((unsigned long *)(&(&work->work)->data)));
+ return ret;
+}
+extern int cancel_delayed_work_sync(struct delayed_work *work);
+static inline __attribute__((always_inline))
+void cancel_rearming_delayed_workqueue(struct workqueue_struct *wq,
+     struct delayed_work *work)
+{
+ cancel_delayed_work_sync(work);
+}
+static inline __attribute__((always_inline))
+void cancel_rearming_delayed_work(struct delayed_work *work)
+{
+ cancel_delayed_work_sync(work);
+}
+static inline __attribute__((always_inline)) long work_on_cpu(unsigned int cpu, long (*fn)(void *), void *arg)
+{
+ return fn(arg);
+}
+typedef unsigned long aio_context_t;
+enum {
+ IOCB_CMD_PREAD = 0,
+ IOCB_CMD_PWRITE = 1,
+ IOCB_CMD_FSYNC = 2,
+ IOCB_CMD_FDSYNC = 3,
+ IOCB_CMD_NOOP = 6,
+ IOCB_CMD_PREADV = 7,
+ IOCB_CMD_PWRITEV = 8,
+};
+struct io_event {
+ __u64 data;
+ __u64 obj;
+ __s64 res;
+ __s64 res2;
+};
+struct iocb {
+ __u64 aio_data;
+ __u32 aio_key, aio_reserved1;
+ __u16 aio_lio_opcode;
+ __s16 aio_reqprio;
+ __u32 aio_fildes;
+ __u64 aio_buf;
+ __u64 aio_nbytes;
+ __s64 aio_offset;
+ __u64 aio_reserved2;
+ __u32 aio_flags;
+ __u32 aio_resfd;
+};
+struct iovec
+{
+ void *iov_base;
+ __kernel_size_t iov_len;
+};
+struct kvec {
+ void *iov_base;
+ size_t iov_len;
+};
+static inline __attribute__((always_inline)) size_t iov_length(const struct iovec *iov, unsigned long nr_segs)
+{
+ unsigned long seg;
+ size_t ret = 0;
+ for (seg = 0; seg < nr_segs; seg++)
+  ret += iov[seg].iov_len;
+ return ret;
+}
+unsigned long iov_shorten(struct iovec *iov, unsigned long nr_segs, size_t to);
+struct kioctx;
+struct kiocb {
+ struct list_head ki_run_list;
+ unsigned long ki_flags;
+ int ki_users;
+ unsigned ki_key;
+ struct file *ki_filp;
+ struct kioctx *ki_ctx;
+ int (*ki_cancel)(struct kiocb *, struct io_event *);
+ ssize_t (*ki_retry)(struct kiocb *);
+ void (*ki_dtor)(struct kiocb *);
+ union {
+  void *user;
+  struct task_struct *tsk;
+ } ki_obj;
+ __u64 ki_user_data;
+ wait_queue_t ki_wait;
+ loff_t ki_pos;
+ void *private;
+ unsigned short ki_opcode;
+ size_t ki_nbytes;
+ char *ki_buf;
+ size_t ki_left;
+ struct iovec ki_inline_vec;
+  struct iovec *ki_iovec;
+  unsigned long ki_nr_segs;
+  unsigned long ki_cur_seg;
+ struct list_head ki_list;
+ struct eventfd_ctx *ki_eventfd;
+};
+struct aio_ring {
+ unsigned id;
+ unsigned nr;
+ unsigned head;
+ unsigned tail;
+ unsigned magic;
+ unsigned compat_features;
+ unsigned incompat_features;
+ unsigned header_length;
+ struct io_event io_events[0];
+};
+struct aio_ring_info {
+ unsigned long mmap_base;
+ unsigned long mmap_size;
+ struct page **ring_pages;
+ spinlock_t ring_lock;
+ long nr_pages;
+ unsigned nr, tail;
+ struct page *internal_pages[8];
+};
+struct kioctx {
+ atomic_t users;
+ int dead;
+ struct mm_struct *mm;
+ unsigned long user_id;
+ struct hlist_node list;
+ wait_queue_head_t wait;
+ spinlock_t ctx_lock;
+ int reqs_active;
+ struct list_head active_reqs;
+ struct list_head run_list;
+ unsigned max_reqs;
+ struct aio_ring_info ring_info;
+ struct delayed_work wq;
+ struct rcu_head rcu_head;
+};
+extern unsigned aio_max_size;
+extern ssize_t wait_on_sync_kiocb(struct kiocb *iocb);
+extern int aio_put_req(struct kiocb *iocb);
+extern void kick_iocb(struct kiocb *iocb);
+extern int aio_complete(struct kiocb *iocb, long res, long res2);
+struct mm_struct;
+extern void exit_aio(struct mm_struct *mm);
+static inline __attribute__((always_inline)) struct kiocb *list_kiocb(struct list_head *h)
+{
+ return ({ const typeof( ((struct kiocb *)0)->ki_list ) *__mptr = (h); (struct kiocb *)( (char *)__mptr - __builtin_offsetof(struct kiocb,ki_list) );});
+}
+extern unsigned long aio_nr;
+extern unsigned long aio_max_nr;
+extern unsigned long
+arch_get_unmapped_area(struct file *, unsigned long, unsigned long,
+         unsigned long, unsigned long);
+extern unsigned long
+arch_get_unmapped_area_topdown(struct file *filp, unsigned long addr,
+     unsigned long len, unsigned long pgoff,
+     unsigned long flags);
+extern void arch_unmap_area(struct mm_struct *, unsigned long);
+extern void arch_unmap_area_topdown(struct mm_struct *, unsigned long);
+static inline __attribute__((always_inline)) unsigned long get_mm_hiwater_rss(struct mm_struct *mm)
+{
+ return ({ typeof(mm->hiwater_rss) _max1 = (mm->hiwater_rss); typeof((((mm)->_file_rss) + ((mm)->_anon_rss))) _max2 = ((((mm)->_file_rss) + ((mm)->_anon_rss))); (void) (&_max1 == &_max2); _max1 > _max2 ? _max1 : _max2; });
+}
+static inline __attribute__((always_inline)) void setmax_mm_hiwater_rss(unsigned long *maxrss,
+      struct mm_struct *mm)
+{
+ unsigned long hiwater_rss = get_mm_hiwater_rss(mm);
+ if (*maxrss < hiwater_rss)
+  *maxrss = hiwater_rss;
+}
+static inline __attribute__((always_inline)) unsigned long get_mm_hiwater_vm(struct mm_struct *mm)
+{
+ return ({ typeof(mm->hiwater_vm) _max1 = (mm->hiwater_vm); typeof(mm->total_vm) _max2 = (mm->total_vm); (void) (&_max1 == &_max2); _max1 > _max2 ? _max1 : _max2; });
+}
+extern void set_dumpable(struct mm_struct *mm, int value);
+extern int get_dumpable(struct mm_struct *mm);
+struct sighand_struct {
+ atomic_t count;
+ struct k_sigaction action[64];
+ spinlock_t siglock;
+ wait_queue_head_t signalfd_wqh;
+};
+struct pacct_struct {
+ int ac_flag;
+ long ac_exitcode;
+ unsigned long ac_mem;
+ cputime_t ac_utime, ac_stime;
+ unsigned long ac_minflt, ac_majflt;
+};
+struct cpu_itimer {
+ cputime_t expires;
+ cputime_t incr;
+ u32 error;
+ u32 incr_error;
+};
+struct task_cputime {
+ cputime_t utime;
+ cputime_t stime;
+ unsigned long long sum_exec_runtime;
+};
+struct thread_group_cputimer {
+ struct task_cputime cputime;
+ int running;
+ spinlock_t lock;
+};
+struct signal_struct {
+ atomic_t count;
+ atomic_t live;
+ wait_queue_head_t wait_chldexit;
+ struct task_struct *curr_target;
+ struct sigpending shared_pending;
+ int group_exit_code;
+ int notify_count;
+ struct task_struct *group_exit_task;
+ int group_stop_count;
+ unsigned int flags;
+ struct list_head posix_timers;
+ struct hrtimer real_timer;
+ struct pid *leader_pid;
+ ktime_t it_real_incr;
+ struct cpu_itimer it[2];
+ struct thread_group_cputimer cputimer;
+ struct task_cputime cputime_expires;
+ struct list_head cpu_timers[3];
+ struct pid *tty_old_pgrp;
+ int leader;
+ struct tty_struct *tty;
+ cputime_t utime, stime, cutime, cstime;
+ cputime_t gtime;
+ cputime_t cgtime;
+ unsigned long nvcsw, nivcsw, cnvcsw, cnivcsw;
+ unsigned long min_flt, maj_flt, cmin_flt, cmaj_flt;
+ unsigned long inblock, oublock, cinblock, coublock;
+ unsigned long maxrss, cmaxrss;
+ struct task_io_accounting ioac;
+ unsigned long long sum_sched_runtime;
+ struct rlimit rlim[16];
+ int oom_adj;
+};
+static inline __attribute__((always_inline)) int signal_group_exit(const struct signal_struct *sig)
+{
+ return (sig->flags & 0x00000008) ||
+  (sig->group_exit_task != ((void *)0));
+}
+struct user_struct {
+ atomic_t __count;
+ atomic_t processes;
+ atomic_t files;
+ atomic_t sigpending;
+ atomic_t inotify_watches;
+ atomic_t inotify_devs;
+ atomic_t epoll_watches;
+ unsigned long locked_shm;
+ struct hlist_node uidhash_node;
+ uid_t uid;
+ struct user_namespace *user_ns;
+};
+extern int uids_sysfs_init(void);
+extern struct user_struct *find_user(uid_t);
+extern struct user_struct root_user;
+struct backing_dev_info;
+struct reclaim_state;
+static inline __attribute__((always_inline)) int sched_info_on(void)
+{
+ return 0;
+}
+enum cpu_idle_type {
+ CPU_IDLE,
+ CPU_NOT_IDLE,
+ CPU_NEWLY_IDLE,
+ CPU_MAX_IDLE_TYPES
+};
+struct sched_domain_attr;
+static inline __attribute__((always_inline)) void
+partition_sched_domains(int ndoms_new, struct cpumask *doms_new,
+   struct sched_domain_attr *dattr_new)
+{
+}
+struct io_context;
+static inline __attribute__((always_inline)) void prefetch_stack(struct task_struct *t) { }
+struct audit_context;
+struct mempolicy;
+struct pipe_inode_info;
+struct uts_namespace;
+struct rq;
+struct sched_domain;
+struct sched_class {
+ const struct sched_class *next;
+ void (*enqueue_task) (struct rq *rq, struct task_struct *p, int wakeup);
+ void (*dequeue_task) (struct rq *rq, struct task_struct *p, int sleep);
+ void (*yield_task) (struct rq *rq);
+ void (*check_preempt_curr) (struct rq *rq, struct task_struct *p, int flags);
+ struct task_struct * (*pick_next_task) (struct rq *rq);
+ void (*put_prev_task) (struct rq *rq, struct task_struct *p);
+ void (*set_curr_task) (struct rq *rq);
+ void (*task_tick) (struct rq *rq, struct task_struct *p, int queued);
+ void (*task_new) (struct rq *rq, struct task_struct *p);
+ void (*switched_from) (struct rq *this_rq, struct task_struct *task,
+          int running);
+ void (*switched_to) (struct rq *this_rq, struct task_struct *task,
+        int running);
+ void (*prio_changed) (struct rq *this_rq, struct task_struct *task,
+        int oldprio, int running);
+ unsigned int (*get_rr_interval) (struct task_struct *task);
+};
+struct load_weight {
+ unsigned long weight, inv_weight;
+};
+struct sched_entity {
+ struct load_weight load;
+ struct rb_node run_node;
+ struct list_head group_node;
+ unsigned int on_rq;
+ u64 exec_start;
+ u64 sum_exec_runtime;
+ u64 vruntime;
+ u64 prev_sum_exec_runtime;
+ u64 last_wakeup;
+ u64 avg_overlap;
+ u64 nr_migrations;
+ u64 start_runtime;
+ u64 avg_wakeup;
+ u64 avg_running;
+};
+struct sched_rt_entity {
+ struct list_head run_list;
+ unsigned long timeout;
+ unsigned int time_slice;
+ int nr_cpus_allowed;
+ struct sched_rt_entity *back;
+};
+struct rcu_node;
+struct task_struct {
+ volatile long state;
+ void *stack;
+ atomic_t usage;
+ unsigned int flags;
+ unsigned int ptrace;
+ int lock_depth;
+ int prio, static_prio, normal_prio;
+ unsigned int rt_priority;
+ const struct sched_class *sched_class;
+ struct sched_entity se;
+ struct sched_rt_entity rt;
+ unsigned char fpu_counter;
+ unsigned int policy;
+ cpumask_t cpus_allowed;
+ struct list_head tasks;
+ struct plist_node pushable_tasks;
+ struct mm_struct *mm, *active_mm;
+ int exit_state;
+ int exit_code, exit_signal;
+ int pdeath_signal;
+ unsigned int personality;
+ unsigned did_exec:1;
+ unsigned in_execve:1;
+ unsigned in_iowait:1;
+ unsigned sched_reset_on_fork:1;
+ pid_t pid;
+ pid_t tgid;
+ struct task_struct *real_parent;
+ struct task_struct *parent;
+ struct list_head children;
+ struct list_head sibling;
+ struct task_struct *group_leader;
+ struct list_head ptraced;
+ struct list_head ptrace_entry;
+ struct bts_context *bts;
+ struct pid_link pids[PIDTYPE_MAX];
+ struct list_head thread_group;
+ struct completion *vfork_done;
+ int *set_child_tid;
+ int *clear_child_tid;
+ cputime_t utime, stime, utimescaled, stimescaled;
+ cputime_t gtime;
+ cputime_t prev_utime, prev_stime;
+ unsigned long nvcsw, nivcsw;
+ struct timespec start_time;
+ struct timespec real_start_time;
+ unsigned long min_flt, maj_flt;
+ struct task_cputime cputime_expires;
+ struct list_head cpu_timers[3];
+ const struct cred *real_cred;
+ const struct cred *cred;
+ struct mutex cred_guard_mutex;
+ struct cred *replacement_session_keyring;
+ char comm[16];
+ int link_count, total_link_count;
+ struct sysv_sem sysvsem;
+ struct thread_struct thread;
+ struct fs_struct *fs;
+ struct files_struct *files;
+ struct nsproxy *nsproxy;
+ struct signal_struct *signal;
+ struct sighand_struct *sighand;
+ sigset_t blocked, real_blocked;
+ sigset_t saved_sigmask;
+ struct sigpending pending;
+ unsigned long sas_ss_sp;
+ size_t sas_ss_size;
+ int (*notifier)(void *priv);
+ void *notifier_data;
+ sigset_t *notifier_mask;
+ struct audit_context *audit_context;
+ seccomp_t seccomp;
+    u32 parent_exec_id;
+    u32 self_exec_id;
+ spinlock_t alloc_lock;
+ struct irqaction *irqaction;
+ spinlock_t pi_lock;
+ struct plist_head pi_waiters;
+ struct rt_mutex_waiter *pi_blocked_on;
+ void *journal_info;
+ struct bio *bio_list, **bio_tail;
+ struct reclaim_state *reclaim_state;
+ struct backing_dev_info *backing_dev_info;
+ struct io_context *io_context;
+ unsigned long ptrace_message;
+ siginfo_t *last_siginfo;
+ struct task_io_accounting ioac;
+ struct robust_list_head *robust_list;
+ struct list_head pi_state_list;
+ struct futex_pi_state *pi_state_cache;
+ atomic_t fs_excl;
+ struct rcu_head rcu;
+ struct pipe_inode_info *splice_pipe;
+ struct prop_local_single dirties;
+ unsigned long timer_slack_ns;
+ unsigned long default_timer_slack_ns;
+ struct list_head *scm_work_list;
+};
+static inline __attribute__((always_inline)) int rt_prio(int prio)
+{
+ if (__builtin_expect(!!(prio < 100), 0))
+  return 1;
+ return 0;
+}
+static inline __attribute__((always_inline)) int rt_task(struct task_struct *p)
+{
+ return rt_prio(p->prio);
+}
+static inline __attribute__((always_inline)) struct pid *task_pid(struct task_struct *task)
+{
+ return task->pids[PIDTYPE_PID].pid;
+}
+static inline __attribute__((always_inline)) struct pid *task_tgid(struct task_struct *task)
+{
+ return task->group_leader->pids[PIDTYPE_PID].pid;
+}
+static inline __attribute__((always_inline)) struct pid *task_pgrp(struct task_struct *task)
+{
+ return task->group_leader->pids[PIDTYPE_PGID].pid;
+}
+static inline __attribute__((always_inline)) struct pid *task_session(struct task_struct *task)
+{
+ return task->group_leader->pids[PIDTYPE_SID].pid;
+}
+struct pid_namespace;
+pid_t __task_pid_nr_ns(struct task_struct *task, enum pid_type type,
+   struct pid_namespace *ns);
+static inline __attribute__((always_inline)) pid_t task_pid_nr(struct task_struct *tsk)
+{
+ return tsk->pid;
+}
+static inline __attribute__((always_inline)) pid_t task_pid_nr_ns(struct task_struct *tsk,
+     struct pid_namespace *ns)
+{
+ return __task_pid_nr_ns(tsk, PIDTYPE_PID, ns);
+}
+static inline __attribute__((always_inline)) pid_t task_pid_vnr(struct task_struct *tsk)
+{
+ return __task_pid_nr_ns(tsk, PIDTYPE_PID, ((void *)0));
+}
+static inline __attribute__((always_inline)) pid_t task_tgid_nr(struct task_struct *tsk)
+{
+ return tsk->tgid;
+}
+pid_t task_tgid_nr_ns(struct task_struct *tsk, struct pid_namespace *ns);
+static inline __attribute__((always_inline)) pid_t task_tgid_vnr(struct task_struct *tsk)
+{
+ return pid_vnr(task_tgid(tsk));
+}
+static inline __attribute__((always_inline)) pid_t task_pgrp_nr_ns(struct task_struct *tsk,
+     struct pid_namespace *ns)
+{
+ return __task_pid_nr_ns(tsk, PIDTYPE_PGID, ns);
+}
+static inline __attribute__((always_inline)) pid_t task_pgrp_vnr(struct task_struct *tsk)
+{
+ return __task_pid_nr_ns(tsk, PIDTYPE_PGID, ((void *)0));
+}
+static inline __attribute__((always_inline)) pid_t task_session_nr_ns(struct task_struct *tsk,
+     struct pid_namespace *ns)
+{
+ return __task_pid_nr_ns(tsk, PIDTYPE_SID, ns);
+}
+static inline __attribute__((always_inline)) pid_t task_session_vnr(struct task_struct *tsk)
+{
+ return __task_pid_nr_ns(tsk, PIDTYPE_SID, ((void *)0));
+}
+static inline __attribute__((always_inline)) pid_t task_pgrp_nr(struct task_struct *tsk)
+{
+ return task_pgrp_nr_ns(tsk, &init_pid_ns);
+}
+static inline __attribute__((always_inline)) int pid_alive(struct task_struct *p)
+{
+ return p->pids[PIDTYPE_PID].pid != ((void *)0);
+}
+static inline __attribute__((always_inline)) int is_global_init(struct task_struct *tsk)
+{
+ return tsk->pid == 1;
+}
+extern int is_container_init(struct task_struct *tsk);
+extern struct pid *cad_pid;
+extern void free_task(struct task_struct *tsk);
+extern void __put_task_struct(struct task_struct *t);
+static inline __attribute__((always_inline)) void put_task_struct(struct task_struct *t)
+{
+ if ((atomic_sub_return(1, (&t->usage)) == 0))
+  __put_task_struct(t);
+}
+extern cputime_t task_utime(struct task_struct *p);
+extern cputime_t task_stime(struct task_struct *p);
+extern cputime_t task_gtime(struct task_struct *p);
+static inline __attribute__((always_inline)) void rcu_copy_process(struct task_struct *p)
+{
+}
+static inline __attribute__((always_inline)) int set_cpus_allowed_ptr(struct task_struct *p,
+           const struct cpumask *new_mask)
+{
+ if (!test_bit(cpumask_check(0), (((new_mask))->bits)))
+  return -22;
+ return 0;
+}
+static inline __attribute__((always_inline)) int set_cpus_allowed(struct task_struct *p, cpumask_t new_mask)
+{
+ return set_cpus_allowed_ptr(p, &new_mask);
+}
+extern unsigned long long sched_clock(void);
+extern void sched_clock_init(void);
+extern u64 sched_clock_cpu(int cpu);
+static inline __attribute__((always_inline)) void sched_clock_tick(void)
+{
+}
+static inline __attribute__((always_inline)) void sched_clock_idle_sleep_event(void)
+{
+}
+static inline __attribute__((always_inline)) void sched_clock_idle_wakeup_event(u64 delta_ns)
+{
+}
+extern unsigned long long cpu_clock(int cpu);
+extern unsigned long long
+task_sched_runtime(struct task_struct *task);
+extern unsigned long long thread_group_sched_runtime(struct task_struct *task);
+extern void sched_clock_idle_sleep_event(void);
+extern void sched_clock_idle_wakeup_event(u64 delta_ns);
+static inline __attribute__((always_inline)) void idle_task_exit(void) {}
+extern void sched_idle_next(void);
+static inline __attribute__((always_inline)) void wake_up_idle_cpu(int cpu) { }
+extern unsigned int sysctl_sched_latency;
+extern unsigned int sysctl_sched_min_granularity;
+extern unsigned int sysctl_sched_wakeup_granularity;
+extern unsigned int sysctl_sched_shares_ratelimit;
+extern unsigned int sysctl_sched_shares_thresh;
+extern unsigned int sysctl_sched_child_runs_first;
+static inline __attribute__((always_inline)) unsigned int get_sysctl_timer_migration(void)
+{
+ return 1;
+}
+extern unsigned int sysctl_sched_rt_period;
+extern int sysctl_sched_rt_runtime;
+int sched_rt_handler(struct ctl_table *table, int write,
+  void *buffer, size_t *lenp,
+  loff_t *ppos);
+extern unsigned int sysctl_sched_compat_yield;
+extern int rt_mutex_getprio(struct task_struct *p);
+extern void rt_mutex_setprio(struct task_struct *p, int prio);
+extern void rt_mutex_adjust_pi(struct task_struct *p);
+extern void set_user_nice(struct task_struct *p, long nice);
+extern int task_prio(const struct task_struct *p);
+extern int task_nice(const struct task_struct *p);
+extern int can_nice(const struct task_struct *p, const int nice);
+extern int task_curr(const struct task_struct *p);
+extern int idle_cpu(int cpu);
+extern int sched_setscheduler(struct task_struct *, int, struct sched_param *);
+extern int sched_setscheduler_nocheck(struct task_struct *, int,
+          struct sched_param *);
+extern struct task_struct *idle_task(int cpu);
+extern struct task_struct *curr_task(int cpu);
+extern void set_curr_task(int cpu, struct task_struct *p);
+void yield(void);
+extern struct exec_domain default_exec_domain;
+union thread_union {
+ struct thread_info thread_info;
+ unsigned long stack[(1 << 13)/sizeof(long)];
+};
+static inline __attribute__((always_inline)) int kstack_end(void *addr)
+{
+ return !(((unsigned long)addr+sizeof(void*)-1) & ((1 << 13)-sizeof(void*)));
+}
+extern union thread_union init_thread_union;
+extern struct task_struct init_task;
+extern struct mm_struct init_mm;
+extern struct pid_namespace init_pid_ns;
+extern struct task_struct *find_task_by_vpid(pid_t nr);
+extern struct task_struct *find_task_by_pid_ns(pid_t nr,
+  struct pid_namespace *ns);
+extern void __set_special_pids(struct pid *pid);
+extern struct user_struct * alloc_uid(struct user_namespace *, uid_t);
+static inline __attribute__((always_inline)) struct user_struct *get_uid(struct user_struct *u)
+{
+ atomic_add(1,(&u->__count));
+ return u;
+}
+extern void free_uid(struct user_struct *);
+extern void release_uids(struct user_namespace *ns);
+extern void do_timer(unsigned long ticks);
+extern int wake_up_state(struct task_struct *tsk, unsigned int state);
+extern int wake_up_process(struct task_struct *tsk);
+extern void wake_up_new_task(struct task_struct *tsk,
+    unsigned long clone_flags);
+ static inline __attribute__((always_inline)) void kick_process(struct task_struct *tsk) { }
+extern void sched_fork(struct task_struct *p, int clone_flags);
+extern void sched_dead(struct task_struct *p);
+extern void proc_caches_init(void);
+extern void flush_signals(struct task_struct *);
+extern void __flush_signals(struct task_struct *);
+extern void ignore_signals(struct task_struct *);
+extern void flush_signal_handlers(struct task_struct *, int force_default);
+extern int dequeue_signal(struct task_struct *tsk, sigset_t *mask, siginfo_t *info);
+static inline __attribute__((always_inline)) int dequeue_signal_lock(struct task_struct *tsk, sigset_t *mask, siginfo_t *info)
+{
+ unsigned long flags;
+ int ret;
+ do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); do { (flags) = __raw_local_irq_save(); } while (0); do { } while (0); } while (0); do { do { do { (current_thread_info()->preempt_count) += (1); } while (0); __asm__ __volatile__("": : :"memory"); } while (0); (void)0; (void)(&tsk->sighand->siglock); } while (0); } while (0); } while (0);
+ ret = dequeue_signal(tsk, mask, info);
+ do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); do { do { ({ unsigned long __dummy; typeof(flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); if (raw_irqs_disabled_flags(flags)) { raw_local_irq_restore(flags); do { } while (0); } else { do { } while (0); raw_local_irq_restore(flags); } } while (0); do { do { do { __asm__ __volatile__("": : :"memory"); do { (current_thread_info()->preempt_count) -= (1); } while (0); } while (0); __asm__ __volatile__("": : :"memory"); do { if (__builtin_expect(!!(test_ti_thread_flag(current_thread_info(), 2)), 0)) preempt_schedule(); } while (0); } while (0); (void)0; (void)(&tsk->sighand->siglock); } while (0); } while (0); } while (0);
+ return ret;
+}
+extern void block_all_signals(int (*notifier)(void *priv), void *priv,
+         sigset_t *mask);
+extern void unblock_all_signals(void);
+extern void release_task(struct task_struct * p);
+extern int send_sig_info(int, struct siginfo *, struct task_struct *);
+extern int force_sigsegv(int, struct task_struct *);
+extern int force_sig_info(int, struct siginfo *, struct task_struct *);
+extern int __kill_pgrp_info(int sig, struct siginfo *info, struct pid *pgrp);
+extern int kill_pid_info(int sig, struct siginfo *info, struct pid *pid);
+extern int kill_pid_info_as_uid(int, struct siginfo *, struct pid *, uid_t, uid_t, u32);
+extern int kill_pgrp(struct pid *pid, int sig, int priv);
+extern int kill_pid(struct pid *pid, int sig, int priv);
+extern int kill_proc_info(int, struct siginfo *, pid_t);
+extern int do_notify_parent(struct task_struct *, int);
+extern void __wake_up_parent(struct task_struct *p, struct task_struct *parent);
+extern void force_sig(int, struct task_struct *);
+extern void force_sig_specific(int, struct task_struct *);
+extern int send_sig(int, struct task_struct *, int);
+extern void zap_other_threads(struct task_struct *p);
+extern struct sigqueue *sigqueue_alloc(void);
+extern void sigqueue_free(struct sigqueue *);
+extern int send_sigqueue(struct sigqueue *, struct task_struct *, int group);
+extern int do_sigaction(int, struct k_sigaction *, struct k_sigaction *);
+extern int do_sigaltstack(const stack_t *, stack_t *, unsigned long);
+static inline __attribute__((always_inline)) int kill_cad_pid(int sig, int priv)
+{
+ return kill_pid(cad_pid, sig, priv);
+}
+static inline __attribute__((always_inline)) int is_si_special(const struct siginfo *info)
+{
+ return info <= ((struct siginfo *) 2);
+}
+static inline __attribute__((always_inline)) int on_sig_stack(unsigned long sp)
+{
+ return sp > (current_thread_info()->task)->sas_ss_sp &&
+  sp - (current_thread_info()->task)->sas_ss_sp <= (current_thread_info()->task)->sas_ss_size;
+}
+static inline __attribute__((always_inline)) int sas_ss_flags(unsigned long sp)
+{
+ return ((current_thread_info()->task)->sas_ss_size == 0 ? 2
+  : on_sig_stack(sp) ? 1 : 0);
+}
+extern struct mm_struct * mm_alloc(void);
+extern void __mmdrop(struct mm_struct *);
+static inline __attribute__((always_inline)) void mmdrop(struct mm_struct * mm)
+{
+ if (__builtin_expect(!!((atomic_sub_return(1, (&mm->mm_count)) == 0)), 0))
+  __mmdrop(mm);
+}
+extern void mmput(struct mm_struct *);
+extern struct mm_struct *get_task_mm(struct task_struct *task);
+extern void mm_release(struct task_struct *, struct mm_struct *);
+extern struct mm_struct *dup_mm(struct task_struct *tsk);
+extern int copy_thread(unsigned long, unsigned long, unsigned long,
+   struct task_struct *, struct pt_regs *);
+extern void flush_thread(void);
+extern void exit_thread(void);
+extern void exit_files(struct task_struct *);
+extern void __cleanup_signal(struct signal_struct *);
+extern void __cleanup_sighand(struct sighand_struct *);
+extern void exit_itimers(struct signal_struct *);
+extern void flush_itimer_signals(void);
+extern void do_group_exit(int);
+extern void daemonize(const char *, ...);
+extern int allow_signal(int);
+extern int disallow_signal(int);
+extern int do_execve(char *, char * *, char * *, struct pt_regs *);
+extern long do_fork(unsigned long, unsigned long, struct pt_regs *, unsigned long, int *, int *);
+struct task_struct *fork_idle(int);
+extern void set_task_comm(struct task_struct *tsk, char *from);
+extern char *get_task_comm(char *to, struct task_struct *tsk);
+static inline __attribute__((always_inline)) void wait_task_context_switch(struct task_struct *p) {}
+static inline __attribute__((always_inline)) unsigned long wait_task_inactive(struct task_struct *p,
+            long match_state)
+{
+ return 1;
+}
+extern bool current_is_single_threaded(void);
+static inline __attribute__((always_inline)) int has_group_leader_pid(struct task_struct *p)
+{
+ return p->pid == p->tgid;
+}
+static inline __attribute__((always_inline))
+int same_thread_group(struct task_struct *p1, struct task_struct *p2)
+{
+ return p1->tgid == p2->tgid;
+}
+static inline __attribute__((always_inline)) struct task_struct *next_thread(const struct task_struct *p)
+{
+ return ({ const typeof( ((struct task_struct *)0)->thread_group ) *__mptr = (({ typeof(p->thread_group.next) _________p1 = (*(volatile typeof(p->thread_group.next) *)&(p->thread_group.next)); do { } while(0); (_________p1); })); (struct task_struct *)( (char *)__mptr - __builtin_offsetof(struct task_struct,thread_group) );})
+                                          ;
+}
+static inline __attribute__((always_inline)) int thread_group_empty(struct task_struct *p)
+{
+ return list_empty(&p->thread_group);
+}
+static inline __attribute__((always_inline)) int task_detached(struct task_struct *p)
+{
+ return p->exit_signal == -1;
+}
+static inline __attribute__((always_inline)) void task_lock(struct task_struct *p)
+{
+ do { do { do { (current_thread_info()->preempt_count) += (1); } while (0); __asm__ __volatile__("": : :"memory"); } while (0); (void)0; (void)(&p->alloc_lock); } while (0);
+}
+static inline __attribute__((always_inline)) void task_unlock(struct task_struct *p)
+{
+ do { do { do { __asm__ __volatile__("": : :"memory"); do { (current_thread_info()->preempt_count) -= (1); } while (0); } while (0); __asm__ __volatile__("": : :"memory"); do { if (__builtin_expect(!!(test_ti_thread_flag(current_thread_info(), 2)), 0)) preempt_schedule(); } while (0); } while (0); (void)0; (void)(&p->alloc_lock); } while (0);
+}
+extern struct sighand_struct *lock_task_sighand(struct task_struct *tsk,
+       unsigned long *flags);
+static inline __attribute__((always_inline)) void unlock_task_sighand(struct task_struct *tsk,
+      unsigned long *flags)
+{
+ do { ({ unsigned long __dummy; typeof(*flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); do { do { ({ unsigned long __dummy; typeof(*flags) __dummy2; (void)(&__dummy == &__dummy2); 1; }); if (raw_irqs_disabled_flags(*flags)) { raw_local_irq_restore(*flags); do { } while (0); } else { do { } while (0); raw_local_irq_restore(*flags); } } while (0); do { do { do { __asm__ __volatile__("": : :"memory"); do { (current_thread_info()->preempt_count) -= (1); } while (0); } while (0); __asm__ __volatile__("": : :"memory"); do { if (__builtin_expect(!!(test_ti_thread_flag(current_thread_info(), 2)), 0)) preempt_schedule(); } while (0); } while (0); (void)0; (void)(&tsk->sighand->siglock); } while (0); } while (0); } while (0);
+}
+static inline __attribute__((always_inline)) void setup_thread_stack(struct task_struct *p, struct task_struct *org)
+{
+ *((struct thread_info *)(p)->stack) = *((struct thread_info *)(org)->stack);
+ ((struct thread_info *)(p)->stack)->task = p;
+}
+static inline __attribute__((always_inline)) unsigned long *end_of_stack(struct task_struct *p)
+{
+ return (unsigned long *)(((struct thread_info *)(p)->stack) + 1);
+}
+static inline __attribute__((always_inline)) int object_is_on_stack(void *obj)
+{
+ void *stack = (((current_thread_info()->task))->stack);
+ return (obj >= stack) && (obj < (stack + (1 << 13)));
+}
+extern void thread_info_cache_init(void);
+static inline __attribute__((always_inline)) void set_tsk_thread_flag(struct task_struct *tsk, int flag)
+{
+ set_ti_thread_flag(((struct thread_info *)(tsk)->stack), flag);
+}
+static inline __attribute__((always_inline)) void clear_tsk_thread_flag(struct task_struct *tsk, int flag)
+{
+ clear_ti_thread_flag(((struct thread_info *)(tsk)->stack), flag);
+}
+static inline __attribute__((always_inline)) int test_and_set_tsk_thread_flag(struct task_struct *tsk, int flag)
+{
+ return test_and_set_ti_thread_flag(((struct thread_info *)(tsk)->stack), flag);
+}
+static inline __attribute__((always_inline)) int test_and_clear_tsk_thread_flag(struct task_struct *tsk, int flag)
+{
+ return test_and_clear_ti_thread_flag(((struct thread_info *)(tsk)->stack), flag);
+}
+static inline __attribute__((always_inline)) int test_tsk_thread_flag(struct task_struct *tsk, int flag)
+{
+ return test_ti_thread_flag(((struct thread_info *)(tsk)->stack), flag);
+}
+static inline __attribute__((always_inline)) void set_tsk_need_resched(struct task_struct *tsk)
+{
+ set_tsk_thread_flag(tsk,2);
+}
+static inline __attribute__((always_inline)) void clear_tsk_need_resched(struct task_struct *tsk)
+{
+ clear_tsk_thread_flag(tsk,2);
+}
+static inline __attribute__((always_inline)) int test_tsk_need_resched(struct task_struct *tsk)
+{
+ return __builtin_expect(!!(test_tsk_thread_flag(tsk,2)), 0);
+}
+static inline __attribute__((always_inline)) int restart_syscall(void)
+{
+ set_tsk_thread_flag((current_thread_info()->task), 1);
+ return -513;
+}
+static inline __attribute__((always_inline)) int signal_pending(struct task_struct *p)
+{
+ return __builtin_expect(!!(test_tsk_thread_flag(p,1)), 0);
+}
+static inline __attribute__((always_inline)) int __fatal_signal_pending(struct task_struct *p)
+{
+ return __builtin_expect(!!(sigismember(&p->pending.signal, 9)), 0);
+}
+static inline __attribute__((always_inline)) int fatal_signal_pending(struct task_struct *p)
+{
+ return signal_pending(p) && __fatal_signal_pending(p);
+}
+static inline __attribute__((always_inline)) int signal_pending_state(long state, struct task_struct *p)
+{
+ if (!(state & (1 | 128)))
+  return 0;
+ if (!signal_pending(p))
+  return 0;
+ return (state & 1) || __fatal_signal_pending(p);
+}
+static inline __attribute__((always_inline)) int need_resched(void)
+{
+ return __builtin_expect(!!(test_ti_thread_flag(current_thread_info(), 2)), 0);
+}
+extern int _cond_resched(void);
+extern int __cond_resched_lock(spinlock_t *lock);
+extern int __cond_resched_softirq(void);
+static inline __attribute__((always_inline)) int spin_needbreak(spinlock_t *lock)
+{
+ return (((void)(&(lock)->raw_lock), 0));
+}
+void thread_group_cputime(struct task_struct *tsk, struct task_cputime *times);
+void thread_group_cputimer(struct task_struct *tsk, struct task_cputime *times);
+static inline __attribute__((always_inline)) void thread_group_cputime_init(struct signal_struct *sig)
+{
+ sig->cputimer.cputime = (struct task_cputime) { .utime = (0UL), .stime = (0UL), .sum_exec_runtime = 0, };
+ do { *(&sig->cputimer.lock) = (spinlock_t) { .raw_lock = { }, }; } while (0);
+ sig->cputimer.running = 0;
+}
+static inline __attribute__((always_inline)) void thread_group_cputime_free(struct signal_struct *sig)
+{
+}
+extern void recalc_sigpending_and_wake(struct task_struct *t);
+extern void recalc_sigpending(void);
+extern void signal_wake_up(struct task_struct *t, int resume_stopped);
+static inline __attribute__((always_inline)) unsigned int task_cpu(const struct task_struct *p)
+{
+ return 0;
+}
+static inline __attribute__((always_inline)) void set_task_cpu(struct task_struct *p, unsigned int cpu)
+{
+}
+extern void arch_pick_mmap_layout(struct mm_struct *mm);
+static inline __attribute__((always_inline)) void
+__trace_special(void *__tr, void *__data,
+  unsigned long arg1, unsigned long arg2, unsigned long arg3)
+{
+}
+extern long sched_setaffinity(pid_t pid, const struct cpumask *new_mask);
+extern long sched_getaffinity(pid_t pid, struct cpumask *mask);
+extern void normalize_rt_tasks(void);
+extern int task_can_switch_user(struct user_struct *up,
+     struct task_struct *tsk);
+static inline __attribute__((always_inline)) void add_rchar(struct task_struct *tsk, ssize_t amt)
+{
+}
+static inline __attribute__((always_inline)) void add_wchar(struct task_struct *tsk, ssize_t amt)
+{
+}
+static inline __attribute__((always_inline)) void inc_syscr(struct task_struct *tsk)
+{
+}
+static inline __attribute__((always_inline)) void inc_syscw(struct task_struct *tsk)
+{
+}
+extern void task_oncpu_function_call(struct task_struct *p,
+         void (*func) (void *info), void *info);
+static inline __attribute__((always_inline)) void mm_update_next_owner(struct mm_struct *mm)
+{
+}
+static inline __attribute__((always_inline)) void mm_init_owner(struct mm_struct *mm, struct task_struct *p)
+{
+}
+static inline __attribute__((always_inline)) unsigned long task_rlimit(const struct task_struct *tsk,
+  unsigned int limit)
+{
+ return (*(volatile typeof(tsk->signal->rlim[limit].rlim_cur) *)&(tsk->signal->rlim[limit].rlim_cur));
+}
+static inline __attribute__((always_inline)) unsigned long task_rlimit_max(const struct task_struct *tsk,
+  unsigned int limit)
+{
+ return (*(volatile typeof(tsk->signal->rlim[limit].rlim_max) *)&(tsk->signal->rlim[limit].rlim_max));
+}
+static inline __attribute__((always_inline)) unsigned long rlimit(unsigned int limit)
+{
+ return task_rlimit((current_thread_info()->task), limit);
+}
+static inline __attribute__((always_inline)) unsigned long rlimit_max(unsigned int limit)
+{
+ return task_rlimit_max((current_thread_info()->task), limit);
+}
+struct mnt_namespace;
+struct uts_namespace;
+struct ipc_namespace;
+struct pid_namespace;
+struct fs_struct;
+struct nsproxy {
+ atomic_t count;
+ struct uts_namespace *uts_ns;
+ struct ipc_namespace *ipc_ns;
+ struct mnt_namespace *mnt_ns;
+ struct pid_namespace *pid_ns;
+ struct net *net_ns;
+};
+extern struct nsproxy init_nsproxy;
+static inline __attribute__((always_inline)) struct nsproxy *task_nsproxy(struct task_struct *tsk)
+{
+ return ({ typeof(tsk->nsproxy) _________p1 = (*(volatile typeof(tsk->nsproxy) *)&(tsk->nsproxy)); do { } while(0); (_________p1); });
+}
+int copy_namespaces(unsigned long flags, struct task_struct *tsk);
+void exit_task_namespaces(struct task_struct *tsk);
+void switch_task_namespaces(struct task_struct *tsk, struct nsproxy *new);
+void free_nsproxy(struct nsproxy *ns);
+int unshare_nsproxy_namespaces(unsigned long, struct nsproxy **,
+ struct fs_struct *);
+static inline __attribute__((always_inline)) void put_nsproxy(struct nsproxy *ns)
+{
+ if ((atomic_sub_return(1, (&ns->count)) == 0)) {
+  free_nsproxy(ns);
+ }
+}
+static inline __attribute__((always_inline)) void get_nsproxy(struct nsproxy *ns)
+{
+ atomic_add(1,(&ns->count));
+}
+static inline __attribute__((always_inline)) int ns_cgroup_clone(struct task_struct *tsk, struct pid *pid)
+{
+ return 0;
+}
+static inline __attribute__((always_inline)) void *ERR_PTR(long error)
+{
+ return (void *) error;
+}
+static inline __attribute__((always_inline)) long PTR_ERR(const void *ptr)
+{
+ return (long) ptr;
+}
+static inline __attribute__((always_inline)) long IS_ERR(const void *ptr)
+{
+ return __builtin_expect(!!(((unsigned long)ptr) >= (unsigned long)-4095), 0);
+}
+static inline __attribute__((always_inline)) void *ERR_CAST(const void *ptr)
+{
+ return (void *) ptr;
+}
+struct uts_namespace {
+ struct kref kref;
+ struct new_utsname name;
+};
+extern struct uts_namespace init_uts_ns;
+static inline __attribute__((always_inline)) void get_uts_ns(struct uts_namespace *ns)
+{
+}
+static inline __attribute__((always_inline)) void put_uts_ns(struct uts_namespace *ns)
+{
+}
+static inline __attribute__((always_inline)) struct uts_namespace *copy_utsname(unsigned long flags,
+     struct uts_namespace *ns)
+{
+ if (flags & 0x04000000)
+  return ERR_PTR(-22);
+ return ns;
+}
+static inline __attribute__((always_inline)) struct new_utsname *utsname(void)
+{
+ return &(current_thread_info()->task)->nsproxy->uts_ns->name;
+}
+static inline __attribute__((always_inline)) struct new_utsname *init_utsname(void)
+{
+ return &init_uts_ns.name;
+}
+extern struct rw_semaphore uts_sem;
+struct user_fpu_struct {
+ unsigned long fp_regs[16];
+ unsigned long xfp_regs[16];
+ unsigned long fpscr;
+ unsigned long fpul;
+};
+struct user {
+ struct pt_regs regs;
+ struct user_fpu_struct fpu;
+ int u_fpvalid;
+ size_t u_tsize;
+ size_t u_dsize;
+ size_t u_ssize;
+ unsigned long start_code;
+ unsigned long start_data;
+ unsigned long start_stack;
+ long int signal;
+ unsigned long u_ar0;
+ struct user_fpu_struct* u_fpstate;
+ unsigned long magic;
+ char u_comm[32];
+};
+typedef unsigned long elf_greg_t;
+typedef elf_greg_t elf_gregset_t[(sizeof (struct pt_regs) / sizeof(elf_greg_t))];
+typedef struct user_fpu_struct elf_fpregset_t;
+extern int l1i_cache_shape, l1d_cache_shape, l2_cache_shape;
+struct file;
+typedef __u32 Elf32_Addr;
+typedef __u16 Elf32_Half;
+typedef __u32 Elf32_Off;
+typedef __s32 Elf32_Sword;
+typedef __u32 Elf32_Word;
+typedef __u64 Elf64_Addr;
+typedef __u16 Elf64_Half;
+typedef __s16 Elf64_SHalf;
+typedef __u64 Elf64_Off;
+typedef __s32 Elf64_Sword;
+typedef __u32 Elf64_Word;
+typedef __u64 Elf64_Xword;
+typedef __s64 Elf64_Sxword;
+typedef struct dynamic{
+  Elf32_Sword d_tag;
+  union{
+    Elf32_Sword d_val;
+    Elf32_Addr d_ptr;
+  } d_un;
+} Elf32_Dyn;
+typedef struct {
+  Elf64_Sxword d_tag;
+  union {
+    Elf64_Xword d_val;
+    Elf64_Addr d_ptr;
+  } d_un;
+} Elf64_Dyn;
+typedef struct elf32_rel {
+  Elf32_Addr r_offset;
+  Elf32_Word r_info;
+} Elf32_Rel;
+typedef struct elf64_rel {
+  Elf64_Addr r_offset;
+  Elf64_Xword r_info;
+} Elf64_Rel;
+typedef struct elf32_rela{
+  Elf32_Addr r_offset;
+  Elf32_Word r_info;
+  Elf32_Sword r_addend;
+} Elf32_Rela;
+typedef struct elf64_rela {
+  Elf64_Addr r_offset;
+  Elf64_Xword r_info;
+  Elf64_Sxword r_addend;
+} Elf64_Rela;
+typedef struct elf32_sym{
+  Elf32_Word st_name;
+  Elf32_Addr st_value;
+  Elf32_Word st_size;
+  unsigned char st_info;
+  unsigned char st_other;
+  Elf32_Half st_shndx;
+} Elf32_Sym;
+typedef struct elf64_sym {
+  Elf64_Word st_name;
+  unsigned char st_info;
+  unsigned char st_other;
+  Elf64_Half st_shndx;
+  Elf64_Addr st_value;
+  Elf64_Xword st_size;
+} Elf64_Sym;
+typedef struct elf32_hdr{
+  unsigned char e_ident[16];
+  Elf32_Half e_type;
+  Elf32_Half e_machine;
+  Elf32_Word e_version;
+  Elf32_Addr e_entry;
+  Elf32_Off e_phoff;
+  Elf32_Off e_shoff;
+  Elf32_Word e_flags;
+  Elf32_Half e_ehsize;
+  Elf32_Half e_phentsize;
+  Elf32_Half e_phnum;
+  Elf32_Half e_shentsize;
+  Elf32_Half e_shnum;
+  Elf32_Half e_shstrndx;
+} Elf32_Ehdr;
+typedef struct elf64_hdr {
+  unsigned char e_ident[16];
+  Elf64_Half e_type;
+  Elf64_Half e_machine;
+  Elf64_Word e_version;
+  Elf64_Addr e_entry;
+  Elf64_Off e_phoff;
+  Elf64_Off e_shoff;
+  Elf64_Word e_flags;
+  Elf64_Half e_ehsize;
+  Elf64_Half e_phentsize;
+  Elf64_Half e_phnum;
+  Elf64_Half e_shentsize;
+  Elf64_Half e_shnum;
+  Elf64_Half e_shstrndx;
+} Elf64_Ehdr;
+typedef struct elf32_phdr{
+  Elf32_Word p_type;
+  Elf32_Off p_offset;
+  Elf32_Addr p_vaddr;
+  Elf32_Addr p_paddr;
+  Elf32_Word p_filesz;
+  Elf32_Word p_memsz;
+  Elf32_Word p_flags;
+  Elf32_Word p_align;
+} Elf32_Phdr;
+typedef struct elf64_phdr {
+  Elf64_Word p_type;
+  Elf64_Word p_flags;
+  Elf64_Off p_offset;
+  Elf64_Addr p_vaddr;
+  Elf64_Addr p_paddr;
+  Elf64_Xword p_filesz;
+  Elf64_Xword p_memsz;
+  Elf64_Xword p_align;
+} Elf64_Phdr;
+typedef struct {
+  Elf32_Word sh_name;
+  Elf32_Word sh_type;
+  Elf32_Word sh_flags;
+  Elf32_Addr sh_addr;
+  Elf32_Off sh_offset;
+  Elf32_Word sh_size;
+  Elf32_Word sh_link;
+  Elf32_Word sh_info;
+  Elf32_Word sh_addralign;
+  Elf32_Word sh_entsize;
+} Elf32_Shdr;
+typedef struct elf64_shdr {
+  Elf64_Word sh_name;
+  Elf64_Word sh_type;
+  Elf64_Xword sh_flags;
+  Elf64_Addr sh_addr;
+  Elf64_Off sh_offset;
+  Elf64_Xword sh_size;
+  Elf64_Word sh_link;
+  Elf64_Word sh_info;
+  Elf64_Xword sh_addralign;
+  Elf64_Xword sh_entsize;
+} Elf64_Shdr;
+typedef struct elf32_note {
+  Elf32_Word n_namesz;
+  Elf32_Word n_descsz;
+  Elf32_Word n_type;
+} Elf32_Nhdr;
+typedef struct elf64_note {
+  Elf64_Word n_namesz;
+  Elf64_Word n_descsz;
+  Elf64_Word n_type;
+} Elf64_Nhdr;
+extern Elf32_Dyn _DYNAMIC [];
+static inline __attribute__((always_inline)) int elf_coredump_extra_notes_size(void) { return 0; }
+static inline __attribute__((always_inline)) int elf_coredump_extra_notes_write(struct file *file,
+   loff_t *foffset) { return 0; }
+struct kernel_param;
+typedef int (*param_set_fn)(const char *val, struct kernel_param *kp);
+typedef int (*param_get_fn)(char *buffer, struct kernel_param *kp);
+struct kernel_param {
+ const char *name;
+ u16 perm;
+ u16 flags;
+ param_set_fn set;
+ param_get_fn get;
+ union {
+  void *arg;
+  const struct kparam_string *str;
+  const struct kparam_array *arr;
+ };
+};
+struct kparam_string {
+ unsigned int maxlen;
+ char *string;
+};
+struct kparam_array
+{
+ unsigned int max;
+ unsigned int *num;
+ param_set_fn set;
+ param_get_fn get;
+ unsigned int elemsize;
+ void *elem;
+};
+extern int parse_args(const char *name,
+        char *args,
+        struct kernel_param *params,
+        unsigned num,
+        int (*unknown)(char *param, char *val));
+extern void destroy_params(const struct kernel_param *params, unsigned num);
+extern int param_set_byte(const char *val, struct kernel_param *kp);
+extern int param_get_byte(char *buffer, struct kernel_param *kp);
+extern int param_set_short(const char *val, struct kernel_param *kp);
+extern int param_get_short(char *buffer, struct kernel_param *kp);
+extern int param_set_ushort(const char *val, struct kernel_param *kp);
+extern int param_get_ushort(char *buffer, struct kernel_param *kp);
+extern int param_set_int(const char *val, struct kernel_param *kp);
+extern int param_get_int(char *buffer, struct kernel_param *kp);
+extern int param_set_uint(const char *val, struct kernel_param *kp);
+extern int param_get_uint(char *buffer, struct kernel_param *kp);
+extern int param_set_long(const char *val, struct kernel_param *kp);
+extern int param_get_long(char *buffer, struct kernel_param *kp);
+extern int param_set_ulong(const char *val, struct kernel_param *kp);
+extern int param_get_ulong(char *buffer, struct kernel_param *kp);
+extern int param_set_charp(const char *val, struct kernel_param *kp);
+extern int param_get_charp(char *buffer, struct kernel_param *kp);
+extern int param_set_bool(const char *val, struct kernel_param *kp);
+extern int param_get_bool(char *buffer, struct kernel_param *kp);
+extern int param_set_invbool(const char *val, struct kernel_param *kp);
+extern int param_get_invbool(char *buffer, struct kernel_param *kp);
+extern int param_array_set(const char *val, struct kernel_param *kp);
+extern int param_array_get(char *buffer, struct kernel_param *kp);
+extern int param_set_copystring(const char *val, struct kernel_param *kp);
+extern int param_get_string(char *buffer, struct kernel_param *kp);
+struct module;
+extern int module_param_sysfs_setup(struct module *mod,
+        struct kernel_param *kparam,
+        unsigned int num_params);
+extern void module_param_sysfs_remove(struct module *mod);
+typedef struct
+{
+ atomic_long_t a;
+} local_t;
+struct mod_arch_specific
+{
+};
+struct module;
+static inline __attribute__((always_inline)) void
+ _do_trace_module_load
+ (struct tracepoint *tp, struct module *mod) { } static inline __attribute__((always_inline)) void
+ trace_module_load
+ (struct module *mod) { } static inline __attribute__((always_inline)) int
+ register_trace_module_load
+ (void (*probe)(struct module *mod)) { return -38; } static inline __attribute__((always_inline)) int
+ unregister_trace_module_load
+ (void (*probe)(struct module *mod)) { return -38; }
+ ;
+static inline __attribute__((always_inline)) void
+ _do_trace_module_free
+ (struct tracepoint *tp, struct module *mod) { } static inline __attribute__((always_inline)) void
+ trace_module_free
+ (struct module *mod) { } static inline __attribute__((always_inline)) int
+ register_trace_module_free
+ (void (*probe)(struct module *mod)) { return -38; } static inline __attribute__((always_inline)) int
+ unregister_trace_module_free
+ (void (*probe)(struct module *mod)) { return -38; }
+ ;
+static inline __attribute__((always_inline)) void
+ _do_trace_module_get
+ (struct tracepoint *tp, struct module *mod, unsigned long ip, int refcnt) { } static inline __attribute__((always_inline)) void
+ trace_module_get
+ (struct module *mod, unsigned long ip, int refcnt) { } static inline __attribute__((always_inline)) int
+ register_trace_module_get
+ (void (*probe)(struct module *mod, unsigned long ip, int refcnt)) { return -38; } static inline __attribute__((always_inline)) int
+ unregister_trace_module_get
+ (void (*probe)(struct module *mod, unsigned long ip, int refcnt)) { return -38; }
+ ;
+static inline __attribute__((always_inline)) void
+ _do_trace_module_put
+ (struct tracepoint *tp, struct module *mod, unsigned long ip, int refcnt) { } static inline __attribute__((always_inline)) void
+ trace_module_put
+ (struct module *mod, unsigned long ip, int refcnt) { } static inline __attribute__((always_inline)) int
+ register_trace_module_put
+ (void (*probe)(struct module *mod, unsigned long ip, int refcnt)) { return -38; } static inline __attribute__((always_inline)) int
+ unregister_trace_module_put
+ (void (*probe)(struct module *mod, unsigned long ip, int refcnt)) { return -38; }
+ ;
+static inline __attribute__((always_inline)) void
+ _do_trace_module_request
+ (struct tracepoint *tp, char *name, bool wait, unsigned long ip) { } static inline __attribute__((always_inline)) void
+ trace_module_request
+ (char *name, bool wait, unsigned long ip) { } static inline __attribute__((always_inline)) int
+ register_trace_module_request
+ (void (*probe)(char *name, bool wait, unsigned long ip)) { return -38; } static inline __attribute__((always_inline)) int
+ unregister_trace_module_request
+ (void (*probe)(char *name, bool wait, unsigned long ip)) { return -38; }
+ ;
+struct kernel_symbol
+{
+ unsigned long value;
+ const char *name;
+ unsigned long hash_value;
+};
+struct elf_htable {
+ uint32_t nbucket;
+ uint32_t nchain;
+ const uint32_t *elf_buckets;
+ const uint32_t *chains;
+};
+struct modversion_info
+{
+ unsigned long crc;
+ char name[(64 - sizeof(unsigned long))];
+};
+struct module;
+struct module_attribute {
+        struct attribute attr;
+        ssize_t (*show)(struct module_attribute *, struct module *, char *);
+        ssize_t (*store)(struct module_attribute *, struct module *,
+    const char *, size_t count);
+ void (*setup)(struct module *, const char *);
+ int (*test)(struct module *);
+ void (*free)(struct module *);
+};
+struct module_kobject
+{
+ struct kobject kobj;
+ struct module *mod;
+ struct kobject *drivers_dir;
+ struct module_param_attrs *mp;
+};
+extern int init_module(void);
+extern void cleanup_module(void);
+struct exception_table_entry;
+const struct exception_table_entry *
+search_extable(const struct exception_table_entry *first,
+        const struct exception_table_entry *last,
+        unsigned long value);
+void sort_extable(struct exception_table_entry *start,
+    struct exception_table_entry *finish);
+void sort_main_extable(void);
+void trim_init_extable(struct module *m);
+extern struct module __this_module;
+const struct exception_table_entry *search_exception_tables(unsigned long add);
+struct notifier_block;
+void *__symbol_get(const char *symbol);
+void *__symbol_get_gpl(const char *symbol);
+enum module_state
+{
+ MODULE_STATE_LIVE,
+ MODULE_STATE_COMING,
+ MODULE_STATE_GOING,
+};
+struct module
+{
+ enum module_state state;
+ struct list_head list;
+ char name[(64 - sizeof(unsigned long))];
+ struct module_kobject mkobj;
+ struct module_attribute *modinfo_attrs;
+ const char *version;
+ const char *srcversion;
+ struct kobject *holders_dir;
+ const struct kernel_symbol *syms;
+ const unsigned long *crcs;
+ unsigned int num_syms;
+ const uint32_t *syms_htable;;
+ struct kernel_param *kp;
+ unsigned int num_kp;
+ unsigned int num_gpl_syms;
+ const struct kernel_symbol *gpl_syms;
+ const unsigned long *gpl_crcs;
+ const uint32_t *gpl_syms_htable;;
+ const struct kernel_symbol *gpl_future_syms;
+ const unsigned long *gpl_future_crcs;
+ unsigned int num_gpl_future_syms;
+ const uint32_t *gpl_future_syms_htable;;
+ unsigned int num_exentries;
+ struct exception_table_entry *extable;
+ int (*init)(void);
+ void *module_init;
+ void *module_core;
+ unsigned int init_size, core_size;
+ unsigned int init_text_size, core_text_size;
+ struct mod_arch_specific arch;
+ unsigned int taints;
+ unsigned num_bugs;
+ struct list_head bug_list;
+ struct bug_entry *bug_table;
+ Elf32_Sym *symtab, *core_symtab;
+ unsigned int num_symtab, core_num_syms;
+ char *strtab, *core_strtab;
+ struct module_sect_attrs *sect_attrs;
+ struct module_notes_attrs *notes_attrs;
+ void *percpu;
+ char *args;
+ struct list_head modules_which_use_me;
+ struct task_struct *waiter;
+ void (*exit)(void);
+ local_t ref;
+ ctor_fn_t *ctors;
+ unsigned int num_ctors;
+};
+extern struct mutex module_mutex;
+static inline __attribute__((always_inline)) int module_is_live(struct module *mod)
+{
+ return mod->state != MODULE_STATE_GOING;
+}
+struct module *__module_text_address(unsigned long addr);
+struct module *__module_address(unsigned long addr);
+bool is_module_address(unsigned long addr);
+bool is_module_text_address(unsigned long addr);
+static inline __attribute__((always_inline)) int within_module_core(unsigned long addr, struct module *mod)
+{
+ return (unsigned long)mod->module_core <= addr &&
+        addr < (unsigned long)mod->module_core + mod->core_size;
+}
+static inline __attribute__((always_inline)) int within_module_init(unsigned long addr, struct module *mod)
+{
+ return (unsigned long)mod->module_init <= addr &&
+        addr < (unsigned long)mod->module_init + mod->init_size;
+}
+struct module *find_module(const char *name);
+struct symsearch {
+ const uint32_t *htable;
+ const struct kernel_symbol *start, *stop;
+ const unsigned long *crcs;
+ enum {
+  NOT_GPL_ONLY,
+  GPL_ONLY,
+  WILL_BE_GPL_ONLY,
+ } licence;
+ bool unused;
+};
+const struct kernel_symbol *find_symbol(const char *name,
+     struct module **owner,
+     const unsigned long **crc,
+     bool gplok,
+     bool warn);
+bool each_symbol(bool (*fn)(const struct symsearch *arr, struct module *owner,
+       unsigned int symnum, void *data), void *data);
+int module_get_kallsym(unsigned int symnum, unsigned long *value, char *type,
+   char *name, char *module_name, int *exported);
+unsigned long module_kallsyms_lookup_name(const char *name);
+int module_kallsyms_on_each_symbol(int (*fn)(void *, const char *,
+          struct module *, unsigned long),
+       void *data);
+extern void __module_put_and_exit(struct module *mod, long code)
+ __attribute__((noreturn));
+unsigned int module_refcount(struct module *mod);
+void __symbol_put(const char *symbol);
+void symbol_put_addr(void *addr);
+static inline __attribute__((always_inline)) local_t *__module_ref_addr(struct module *mod, int cpu)
+{
+ return &mod->ref;
+}
+static inline __attribute__((always_inline)) void __module_get(struct module *module)
+{
+ if (module) {
+  unsigned int cpu = ({ do { do { (current_thread_info()->preempt_count) += (1); } while (0); __asm__ __volatile__("": : :"memory"); } while (0); 0; });
+  atomic_long_inc(&(__module_ref_addr(module, cpu))->a);
+  trace_module_get(module, ({ __label__ __here; __here: (unsigned long)&&__here; }),
+     atomic_long_read(&(__module_ref_addr(module, cpu))->a));
+  do { do { __asm__ __volatile__("": : :"memory"); do { (current_thread_info()->preempt_count) -= (1); } while (0); } while (0); __asm__ __volatile__("": : :"memory"); do { if (__builtin_expect(!!(test_ti_thread_flag(current_thread_info(), 2)), 0)) preempt_schedule(); } while (0); } while (0);
+ }
+}
+static inline __attribute__((always_inline)) int try_module_get(struct module *module)
+{
+ int ret = 1;
+ if (module) {
+  unsigned int cpu = ({ do { do { (current_thread_info()->preempt_count) += (1); } while (0); __asm__ __volatile__("": : :"memory"); } while (0); 0; });
+  if (__builtin_expect(!!(module_is_live(module)), 1)) {
+   atomic_long_inc(&(__module_ref_addr(module, cpu))->a);
+   trace_module_get(module, ({ __label__ __here; __here: (unsigned long)&&__here; }),
+    atomic_long_read(&(__module_ref_addr(module, cpu))->a));
+  }
+  else
+   ret = 0;
+  do { do { __asm__ __volatile__("": : :"memory"); do { (current_thread_info()->preempt_count) -= (1); } while (0); } while (0); __asm__ __volatile__("": : :"memory"); do { if (__builtin_expect(!!(test_ti_thread_flag(current_thread_info(), 2)), 0)) preempt_schedule(); } while (0); } while (0);
+ }
+ return ret;
+}
+extern void module_put(struct module *module);
+int use_module(struct module *a, struct module *b);
+const char *module_address_lookup(unsigned long addr,
+       unsigned long *symbolsize,
+       unsigned long *offset,
+       char **modname,
+       char *namebuf);
+int lookup_module_symbol_name(unsigned long addr, char *symname);
+int lookup_module_symbol_attrs(unsigned long addr, unsigned long *size, unsigned long *offset, char *modname, char *name);
+const struct exception_table_entry *search_module_extables(unsigned long addr);
+int register_module_notifier(struct notifier_block * nb);
+int unregister_module_notifier(struct notifier_block * nb);
+extern void print_modules(void);
+extern void module_update_tracepoints(void);
+extern int module_get_iter_tracepoints(struct tracepoint_iter *iter);
+struct device_driver;
+struct module;
+extern struct kset *module_kset;
+extern struct kobj_type module_ktype;
+extern int module_sysfs_initialized;
+int mod_sysfs_init(struct module *mod);
+int mod_sysfs_setup(struct module *mod,
+      struct kernel_param *kparam,
+      unsigned int num_params);
+int module_add_modinfo_attrs(struct module *mod);
+void module_remove_modinfo_attrs(struct module *mod);
+int module_bug_finalize(const Elf32_Ehdr *, const Elf32_Shdr *,
+    struct module *);
+void module_bug_cleanup(struct module *);
+extern unsigned int __invalid_size_argument_for_IOC;
+struct files_stat_struct {
+ int nr_files;
+ int nr_free_files;
+ int max_files;
+};
+struct inodes_stat_t {
+ int nr_inodes;
+ int nr_unused;
+ int dummy[5];
+};
+static inline __attribute__((always_inline)) int old_valid_dev(dev_t dev)
+{
+ return ((unsigned int) ((dev) >> 20)) < 256 && ((unsigned int) ((dev) & ((1U << 20) - 1))) < 256;
+}
+static inline __attribute__((always_inline)) u16 old_encode_dev(dev_t dev)
+{
+ return (((unsigned int) ((dev) >> 20)) << 8) | ((unsigned int) ((dev) & ((1U << 20) - 1)));
+}
+static inline __attribute__((always_inline)) dev_t old_decode_dev(u16 val)
+{
+ return ((((val >> 8) & 255) << 20) | (val & 255));
+}
+static inline __attribute__((always_inline)) int new_valid_dev(dev_t dev)
+{
+ return 1;
+}
+static inline __attribute__((always_inline)) u32 new_encode_dev(dev_t dev)
+{
+ unsigned major = ((unsigned int) ((dev) >> 20));
+ unsigned minor = ((unsigned int) ((dev) & ((1U << 20) - 1)));
+ return (minor & 0xff) | (major << 8) | ((minor & ~0xff) << 12);
+}
+static inline __attribute__((always_inline)) dev_t new_decode_dev(u32 dev)
+{
+ unsigned major = (dev & 0xfff00) >> 8;
+ unsigned minor = (dev & 0xff) | ((dev >> 12) & 0xfff00);
+ return (((major) << 20) | (minor));
+}
+static inline __attribute__((always_inline)) int huge_valid_dev(dev_t dev)
+{
+ return 1;
+}
+static inline __attribute__((always_inline)) u64 huge_encode_dev(dev_t dev)
+{
+ return new_encode_dev(dev);
+}
+static inline __attribute__((always_inline)) dev_t huge_decode_dev(u64 dev)
+{
+ return new_decode_dev(dev);
+}
+static inline __attribute__((always_inline)) int sysv_valid_dev(dev_t dev)
+{
+ return ((unsigned int) ((dev) >> 20)) < (1<<14) && ((unsigned int) ((dev) & ((1U << 20) - 1))) < (1<<18);
+}
+static inline __attribute__((always_inline)) u32 sysv_encode_dev(dev_t dev)
+{
+ return ((unsigned int) ((dev) & ((1U << 20) - 1))) | (((unsigned int) ((dev) >> 20)) << 18);
+}
+static inline __attribute__((always_inline)) unsigned sysv_major(u32 dev)
+{
+ return (dev >> 18) & 0x3fff;
+}
+static inline __attribute__((always_inline)) unsigned sysv_minor(u32 dev)
+{
+ return dev & 0x3ffff;
+}
+struct nameidata;
+struct path;
+struct vfsmount;
+struct qstr {
+ unsigned int hash;
+ unsigned int len;
+ const unsigned char *name;
+};
+struct dentry_stat_t {
+ int nr_dentry;
+ int nr_unused;
+ int age_limit;
+ int want_pages;
+ int dummy[2];
+};
+extern struct dentry_stat_t dentry_stat;
+static inline __attribute__((always_inline)) unsigned long
+partial_name_hash(unsigned long c, unsigned long prevhash)
+{
+ return (prevhash + (c << 4) + (c >> 4)) * 11;
+}
+static inline __attribute__((always_inline)) unsigned long end_name_hash(unsigned long hash)
+{
+ return (unsigned int) hash;
+}
+static inline __attribute__((always_inline)) unsigned int
+full_name_hash(const unsigned char *name, unsigned int len)
+{
+ unsigned long hash = 0;
+ while (len--)
+  hash = partial_name_hash(*name++, hash);
+ return end_name_hash(hash);
+}
+struct dentry {
+ atomic_t d_count;
+ unsigned int d_flags;
+ spinlock_t d_lock;
+ int d_mounted;
+ struct inode *d_inode;
+ struct hlist_node d_hash;
+ struct dentry *d_parent;
+ struct qstr d_name;
+ struct list_head d_lru;
+ union {
+  struct list_head d_child;
+   struct rcu_head d_rcu;
+ } d_u;
+ struct list_head d_subdirs;
+ struct list_head d_alias;
+ unsigned long d_time;
+ const struct dentry_operations *d_op;
+ struct super_block *d_sb;
+ void *d_fsdata;
+ unsigned char d_iname[40];
+};
+enum dentry_d_lock_class
+{
+ DENTRY_D_LOCK_NORMAL,
+ DENTRY_D_LOCK_NESTED
+};
+struct dentry_operations {
+ int (*d_revalidate)(struct dentry *, struct nameidata *);
+ int (*d_hash) (struct dentry *, struct qstr *);
+ int (*d_compare) (struct dentry *, struct qstr *, struct qstr *);
+ int (*d_delete)(struct dentry *);
+ void (*d_release)(struct dentry *);
+ void (*d_iput)(struct dentry *, struct inode *);
+ char *(*d_dname)(struct dentry *, char *, int);
+};
+extern spinlock_t dcache_lock;
+extern seqlock_t rename_lock;
+static inline __attribute__((always_inline)) void __d_drop(struct dentry *dentry)
+{
+ if (!(dentry->d_flags & 0x0010)) {
+  dentry->d_flags |= 0x0010;
+  hlist_del_rcu(&dentry->d_hash);
+ }
+}
+static inline __attribute__((always_inline)) void d_drop(struct dentry *dentry)
+{
+ do { do { do { (current_thread_info()->preempt_count) += (1); } while (0); __asm__ __volatile__("": : :"memory"); } while (0); (void)0; (void)(&dcache_lock); } while (0);
+ do { do { do { (current_thread_info()->preempt_count) += (1); } while (0); __asm__ __volatile__("": : :"memory"); } while (0); (void)0; (void)(&dentry->d_lock); } while (0);
+  __d_drop(dentry);
+ do { do { do { __asm__ __volatile__("": : :"memory"); do { (current_thread_info()->preempt_count) -= (1); } while (0); } while (0); __asm__ __volatile__("": : :"memory"); do { if (__builtin_expect(!!(test_ti_thread_flag(current_thread_info(), 2)), 0)) preempt_schedule(); } while (0); } while (0); (void)0; (void)(&dentry->d_lock); } while (0);
+ do { do { do { __asm__ __volatile__("": : :"memory"); do { (current_thread_info()->preempt_count) -= (1); } while (0); } while (0); __asm__ __volatile__("": : :"memory"); do { if (__builtin_expect(!!(test_ti_thread_flag(current_thread_info(), 2)), 0)) preempt_schedule(); } while (0); } while (0); (void)0; (void)(&dcache_lock); } while (0);
+}
+static inline __attribute__((always_inline)) int dname_external(struct dentry *dentry)
+{
+ return dentry->d_name.name != dentry->d_iname;
+}
+extern void d_instantiate(struct dentry *, struct inode *);
+extern struct dentry * d_instantiate_unique(struct dentry *, struct inode *);
+extern struct dentry * d_materialise_unique(struct dentry *, struct inode *);
+extern void d_delete(struct dentry *);
+extern struct dentry * d_alloc(struct dentry *, const struct qstr *);
+extern struct dentry * d_splice_alias(struct inode *, struct dentry *);
+extern struct dentry * d_add_ci(struct dentry *, struct inode *, struct qstr *);
+extern struct dentry * d_obtain_alias(struct inode *);
+extern void shrink_dcache_sb(struct super_block *);
+extern void shrink_dcache_parent(struct dentry *);
+extern void shrink_dcache_for_umount(struct super_block *);
+extern int d_invalidate(struct dentry *);
+extern struct dentry * d_alloc_root(struct inode *);
+extern void d_genocide(struct dentry *);
+extern struct dentry *d_find_alias(struct inode *);
+extern void d_prune_aliases(struct inode *);
+extern int have_submounts(struct dentry *);
+extern void d_rehash(struct dentry *);
+static inline __attribute__((always_inline)) void d_add(struct dentry *entry, struct inode *inode)
+{
+ d_instantiate(entry, inode);
+ d_rehash(entry);
+}
+static inline __attribute__((always_inline)) struct dentry *d_add_unique(struct dentry *entry, struct inode *inode)
+{
+ struct dentry *res;
+ res = d_instantiate_unique(entry, inode);
+ d_rehash(res != ((void *)0) ? res : entry);
+ return res;
+}
+extern void d_move(struct dentry *, struct dentry *);
+extern struct dentry *d_ancestor(struct dentry *, struct dentry *);
+extern struct dentry * d_lookup(struct dentry *, struct qstr *);
+extern struct dentry * __d_lookup(struct dentry *, struct qstr *);
+extern struct dentry * d_hash_and_lookup(struct dentry *, struct qstr *);
+extern int d_validate(struct dentry *, struct dentry *);
+extern char *dynamic_dname(struct dentry *, char *, int, const char *, ...);
+extern char *__d_path(const struct path *path, struct path *root, char *, int);
+extern char *d_path(const struct path *, char *, int);
+extern char *dentry_path(struct dentry *, char *, int);
+static inline __attribute__((always_inline)) struct dentry *dget(struct dentry *dentry)
+{
+ if (dentry) {
+  do { if (__builtin_expect(!!(!((&dentry->d_count)->counter)), 0)) do { __asm__ __volatile__ ( "1:\t.short %O0\n" "\t.pushsection __bug_table,\"a\"\n" "2:\t.long 1b\n" "\t.short %O3\n" "\t.org 2b+%O4\n" "\t.popsection\n" : : "n" (0xc33e), "i" ("include/linux/dcache.h"), "i" (336), "i" (0), "i" (sizeof(struct bug_entry))); } while (0); } while(0);
+  atomic_add(1,(&dentry->d_count));
+ }
+ return dentry;
+}
+extern struct dentry * dget_locked(struct dentry *);
+static inline __attribute__((always_inline)) int d_unhashed(struct dentry *dentry)
+{
+ return (dentry->d_flags & 0x0010);
+}
+static inline __attribute__((always_inline)) int d_unlinked(struct dentry *dentry)
+{
+ return d_unhashed(dentry) && !((dentry) == (dentry)->d_parent);
+}
+static inline __attribute__((always_inline)) struct dentry *dget_parent(struct dentry *dentry)
+{
+ struct dentry *ret;
+ do { do { do { (current_thread_info()->preempt_count) += (1); } while (0); __asm__ __volatile__("": : :"memory"); } while (0); (void)0; (void)(&dentry->d_lock); } while (0);
+ ret = dget(dentry->d_parent);
+ do { do { do { __asm__ __volatile__("": : :"memory"); do { (current_thread_info()->preempt_count) -= (1); } while (0); } while (0); __asm__ __volatile__("": : :"memory"); do { if (__builtin_expect(!!(test_ti_thread_flag(current_thread_info(), 2)), 0)) preempt_schedule(); } while (0); } while (0); (void)0; (void)(&dentry->d_lock); } while (0);
+ return ret;
+}
+extern void dput(struct dentry *);
+static inline __attribute__((always_inline)) int d_mountpoint(struct dentry *dentry)
+{
+ return dentry->d_mounted;
+}
+extern struct vfsmount *lookup_mnt(struct path *);
+extern struct dentry *lookup_create(struct nameidata *nd, int is_dir);
+extern int sysctl_vfs_cache_pressure;
+static inline __attribute__((always_inline)) void *radix_tree_ptr_to_indirect(void *ptr)
+{
+ return (void *)((unsigned long)ptr | 1);
+}
+static inline __attribute__((always_inline)) void *radix_tree_indirect_to_ptr(void *ptr)
+{
+ return (void *)((unsigned long)ptr & ~1);
+}
+static inline __attribute__((always_inline)) int radix_tree_is_indirect_ptr(void *ptr)
+{
+ return (int)((unsigned long)ptr & 1);
+}
+struct radix_tree_root {
+ unsigned int height;
+ gfp_t gfp_mask;
+ struct radix_tree_node *rnode;
+};
+static inline __attribute__((always_inline)) void *radix_tree_deref_slot(void **pslot)
+{
+ void *ret = ({ typeof(*pslot) _________p1 = (*(volatile typeof(*pslot) *)&(*pslot)); do { } while(0); (_________p1); });
+ if (__builtin_expect(!!(radix_tree_is_indirect_ptr(ret)), 0))
+  ret = ((void *)-1UL);
+ return ret;
+}
+static inline __attribute__((always_inline)) void radix_tree_replace_slot(void **pslot, void *item)
+{
+ do { if (__builtin_expect(!!(radix_tree_is_indirect_ptr(item)), 0)) do { __asm__ __volatile__ ( "1:\t.short %O0\n" "\t.pushsection __bug_table,\"a\"\n" "2:\t.long 1b\n" "\t.short %O3\n" "\t.org 2b+%O4\n" "\t.popsection\n" : : "n" (0xc33e), "i" ("include/linux/radix-tree.h"), "i" (154), "i" (0), "i" (sizeof(struct bug_entry))); } while (0); } while(0);
+ ({ if (!__builtin_constant_p(item) || ((item) != ((void *)0))) __asm__ __volatile__("": : :"memory"); (*pslot) = (item); });
+}
+int radix_tree_insert(struct radix_tree_root *, unsigned long, void *);
+void *radix_tree_lookup(struct radix_tree_root *, unsigned long);
+void **radix_tree_lookup_slot(struct radix_tree_root *, unsigned long);
+void *radix_tree_delete(struct radix_tree_root *, unsigned long);
+unsigned int
+radix_tree_gang_lookup(struct radix_tree_root *root, void **results,
+   unsigned long first_index, unsigned int max_items);
+unsigned int
+radix_tree_gang_lookup_slot(struct radix_tree_root *root, void ***results,
+   unsigned long first_index, unsigned int max_items);
+unsigned long radix_tree_next_hole(struct radix_tree_root *root,
+    unsigned long index, unsigned long max_scan);
+unsigned long radix_tree_prev_hole(struct radix_tree_root *root,
+    unsigned long index, unsigned long max_scan);
+int radix_tree_preload(gfp_t gfp_mask);
+void radix_tree_init(void);
+void *radix_tree_tag_set(struct radix_tree_root *root,
+   unsigned long index, unsigned int tag);
+void *radix_tree_tag_clear(struct radix_tree_root *root,
+   unsigned long index, unsigned int tag);
+int radix_tree_tag_get(struct radix_tree_root *root,
+   unsigned long index, unsigned int tag);
+unsigned int
+radix_tree_gang_lookup_tag(struct radix_tree_root *root, void **results,
+  unsigned long first_index, unsigned int max_items,
+  unsigned int tag);
+unsigned int
+radix_tree_gang_lookup_tag_slot(struct radix_tree_root *root, void ***results,
+  unsigned long first_index, unsigned int max_items,
+  unsigned int tag);
+int radix_tree_tagged(struct radix_tree_root *root, unsigned int tag);
+static inline __attribute__((always_inline)) void radix_tree_preload_end(void)
+{
+ do { do { __asm__ __volatile__("": : :"memory"); do { (current_thread_info()->preempt_count) -= (1); } while (0); } while (0); __asm__ __volatile__("": : :"memory"); do { if (__builtin_expect(!!(test_ti_thread_flag(current_thread_info(), 2)), 0)) preempt_schedule(); } while (0); } while (0);
+}
+struct semaphore {
+ spinlock_t lock;
+ unsigned int count;
+ struct list_head wait_list;
+};
+static inline __attribute__((always_inline)) void sema_init(struct semaphore *sem, int val)
+{
+ static struct lock_class_key __key;
+ *sem = (struct semaphore) { .lock = (spinlock_t) { .raw_lock = { }, }, .count = val, .wait_list = { &((*sem).wait_list), &((*sem).wait_list) }, };
+ do { (void)("semaphore->lock"); (void)(&__key); } while (0);
+}
+extern void down(struct semaphore *sem);
+extern int down_interruptible(struct semaphore *sem);
+extern int down_killable(struct semaphore *sem);
+extern int down_trylock(struct semaphore *sem);
+extern int down_timeout(struct semaphore *sem, long jiffies);
+extern void up(struct semaphore *sem);
+struct fiemap_extent {
+ __u64 fe_logical;
+ __u64 fe_physical;
+ __u64 fe_length;
+ __u64 fe_reserved64[2];
+ __u32 fe_flags;
+ __u32 fe_reserved[3];
+};
+struct fiemap {
+ __u64 fm_start;
+ __u64 fm_length;
+ __u32 fm_flags;
+ __u32 fm_mapped_extents;
+ __u32 fm_extent_count;
+ __u32 fm_reserved;
+ struct fiemap_extent fm_extents[0];
+};
+struct export_operations;
+struct hd_geometry;
+struct iovec;
+struct nameidata;
+struct kiocb;
+struct pipe_inode_info;
+struct poll_table_struct;
+struct kstatfs;
+struct vm_area_struct;
+struct vfsmount;
+struct cred;
+extern void __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) __attribute__((no_instrument_function)) inode_init(void);
+extern void __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) __attribute__((no_instrument_function)) inode_init_early(void);
+extern void __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) __attribute__((no_instrument_function)) files_init(unsigned long);
+extern struct files_stat_struct files_stat;
+extern int get_max_files(void);
+extern int sysctl_nr_open;
+extern struct inodes_stat_t inodes_stat;
+extern int leases_enable, lease_break_time;
+extern int dir_notify_enable;
+struct buffer_head;
+typedef int (get_block_t)(struct inode *inode, sector_t iblock,
+   struct buffer_head *bh_result, int create);
+typedef void (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
+   ssize_t bytes, void *private);
+struct iattr {
+ unsigned int ia_valid;
+ umode_t ia_mode;
+ uid_t ia_uid;
+ gid_t ia_gid;
+ loff_t ia_size;
+ struct timespec ia_atime;
+ struct timespec ia_mtime;
+ struct timespec ia_ctime;
+ struct file *ia_file;
+};
+enum {
+ QIF_BLIMITS_B = 0,
+ QIF_SPACE_B,
+ QIF_ILIMITS_B,
+ QIF_INODES_B,
+ QIF_BTIME_B,
+ QIF_ITIME_B,
+};
+struct if_dqblk {
+ __u64 dqb_bhardlimit;
+ __u64 dqb_bsoftlimit;
+ __u64 dqb_curspace;
+ __u64 dqb_ihardlimit;
+ __u64 dqb_isoftlimit;
+ __u64 dqb_curinodes;
+ __u64 dqb_btime;
+ __u64 dqb_itime;
+ __u32 dqb_valid;
+};
+struct if_dqinfo {
+ __u64 dqi_bgrace;
+ __u64 dqi_igrace;
+ __u32 dqi_flags;
+ __u32 dqi_valid;
+};
+enum {
+ QUOTA_NL_C_UNSPEC,
+ QUOTA_NL_C_WARNING,
+ __QUOTA_NL_C_MAX,
+};
+enum {
+ QUOTA_NL_A_UNSPEC,
+ QUOTA_NL_A_QTYPE,
+ QUOTA_NL_A_EXCESS_ID,
+ QUOTA_NL_A_WARNING,
+ QUOTA_NL_A_DEV_MAJOR,
+ QUOTA_NL_A_DEV_MINOR,
+ QUOTA_NL_A_CAUSED_ID,
+ __QUOTA_NL_A_MAX,
+};
+typedef struct fs_disk_quota {
+ __s8 d_version;
+ __s8 d_flags;
+ __u16 d_fieldmask;
+ __u32 d_id;
+ __u64 d_blk_hardlimit;
+ __u64 d_blk_softlimit;
+ __u64 d_ino_hardlimit;
+ __u64 d_ino_softlimit;
+ __u64 d_bcount;
+ __u64 d_icount;
+ __s32 d_itimer;
+ __s32 d_btimer;
+ __u16 d_iwarns;
+ __u16 d_bwarns;
+ __s32 d_padding2;
+ __u64 d_rtb_hardlimit;
+ __u64 d_rtb_softlimit;
+ __u64 d_rtbcount;
+ __s32 d_rtbtimer;
+ __u16 d_rtbwarns;
+ __s16 d_padding3;
+ char d_padding4[8];
+} fs_disk_quota_t;
+typedef struct fs_qfilestat {
+ __u64 qfs_ino;
+ __u64 qfs_nblks;
+ __u32 qfs_nextents;
+} fs_qfilestat_t;
+typedef struct fs_quota_stat {
+ __s8 qs_version;
+ __u16 qs_flags;
+ __s8 qs_pad;
+ fs_qfilestat_t qs_uquota;
+ fs_qfilestat_t qs_gquota;
+ __u32 qs_incoredqs;
+ __s32 qs_btimelimit;
+ __s32 qs_itimelimit;
+ __s32 qs_rtbtimelimit;
+ __u16 qs_bwarnlimit;
+ __u16 qs_iwarnlimit;
+} fs_quota_stat_t;
+struct dquot;
+struct qtree_fmt_operations {
+ void (*mem2disk_dqblk)(void *disk, struct dquot *dquot);
+ void (*disk2mem_dqblk)(struct dquot *dquot, void *disk);
+ int (*is_id)(void *disk, struct dquot *dquot);
+};
+struct qtree_mem_dqinfo {
+ struct super_block *dqi_sb;
+ int dqi_type;
+ unsigned int dqi_blocks;
+ unsigned int dqi_free_blk;
+ unsigned int dqi_free_entry;
+ unsigned int dqi_blocksize_bits;
+ unsigned int dqi_entry_size;
+ unsigned int dqi_usable_bs;
+ unsigned int dqi_qtree_depth;
+ struct qtree_fmt_operations *dqi_ops;
+};
+int qtree_write_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot);
+int qtree_read_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot);
+int qtree_delete_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot);
+int qtree_release_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot);
+int qtree_entry_unused(struct qtree_mem_dqinfo *info, char *disk);
+static inline __attribute__((always_inline)) int qtree_depth(struct qtree_mem_dqinfo *info)
+{
+ unsigned int epb = info->dqi_usable_bs >> 2;
+ unsigned long long entries = epb;
+ int i;
+ for (i = 1; entries < (1ULL << 32); i++)
+  entries *= epb;
+ return i;
+}
+typedef __kernel_uid32_t qid_t;
+typedef long long qsize_t;
+extern spinlock_t dq_data_lock;
+struct mem_dqblk {
+ qsize_t dqb_bhardlimit;
+ qsize_t dqb_bsoftlimit;
+ qsize_t dqb_curspace;
+ qsize_t dqb_rsvspace;
+ qsize_t dqb_ihardlimit;
+ qsize_t dqb_isoftlimit;
+ qsize_t dqb_curinodes;
+ time_t dqb_btime;
+ time_t dqb_itime;
+};
+struct quota_format_type;
+struct mem_dqinfo {
+ struct quota_format_type *dqi_format;
+ int dqi_fmt_id;
+ struct list_head dqi_dirty_list;
+ unsigned long dqi_flags;
+ unsigned int dqi_bgrace;
+ unsigned int dqi_igrace;
+ qsize_t dqi_maxblimit;
+ qsize_t dqi_maxilimit;
+ void *dqi_priv;
+};
+struct super_block;
+extern void mark_info_dirty(struct super_block *sb, int type);
+static inline __attribute__((always_inline)) int info_dirty(struct mem_dqinfo *info)
+{
+ return test_bit(16, &info->dqi_flags);
+}
+struct dqstats {
+ int lookups;
+ int drops;
+ int reads;
+ int writes;
+ int cache_hits;
+ int allocated_dquots;
+ int free_dquots;
+ int syncs;
+};
+extern struct dqstats dqstats;
+struct dquot {
+ struct hlist_node dq_hash;
+ struct list_head dq_inuse;
+ struct list_head dq_free;
+ struct list_head dq_dirty;
+ struct mutex dq_lock;
+ atomic_t dq_count;
+ wait_queue_head_t dq_wait_unused;
+ struct super_block *dq_sb;
+ unsigned int dq_id;
+ loff_t dq_off;
+ unsigned long dq_flags;
+ short dq_type;
+ struct mem_dqblk dq_dqb;
+};
+struct quota_format_ops {
+ int (*check_quota_file)(struct super_block *sb, int type);
+ int (*read_file_info)(struct super_block *sb, int type);
+ int (*write_file_info)(struct super_block *sb, int type);
+ int (*free_file_info)(struct super_block *sb, int type);
+ int (*read_dqblk)(struct dquot *dquot);
+ int (*commit_dqblk)(struct dquot *dquot);
+ int (*release_dqblk)(struct dquot *dquot);
+};
+struct dquot_operations {
+ int (*initialize) (struct inode *, int);
+ int (*drop) (struct inode *);
+ int (*alloc_space) (struct inode *, qsize_t, int);
+ int (*alloc_inode) (const struct inode *, qsize_t);
+ int (*free_space) (struct inode *, qsize_t);
+ int (*free_inode) (const struct inode *, qsize_t);
+ int (*transfer) (struct inode *, struct iattr *);
+ int (*write_dquot) (struct dquot *);
+ struct dquot *(*alloc_dquot)(struct super_block *, int);
+ void (*destroy_dquot)(struct dquot *);
+ int (*acquire_dquot) (struct dquot *);
+ int (*release_dquot) (struct dquot *);
+ int (*mark_dirty) (struct dquot *);
+ int (*write_info) (struct super_block *, int);
+ int (*reserve_space) (struct inode *, qsize_t, int);
+ int (*claim_space) (struct inode *, qsize_t);
+ void (*release_rsv) (struct inode *, qsize_t);
+ qsize_t *(*get_reserved_space) (struct inode *);
+};
+struct quotactl_ops {
+ int (*quota_on)(struct super_block *, int, int, char *, int);
+ int (*quota_off)(struct super_block *, int, int);
+ int (*quota_sync)(struct super_block *, int);
+ int (*get_info)(struct super_block *, int, struct if_dqinfo *);
+ int (*set_info)(struct super_block *, int, struct if_dqinfo *);
+ int (*get_dqblk)(struct super_block *, int, qid_t, struct if_dqblk *);
+ int (*set_dqblk)(struct super_block *, int, qid_t, struct if_dqblk *);
+ int (*get_xstate)(struct super_block *, struct fs_quota_stat *);
+ int (*set_xstate)(struct super_block *, unsigned int, int);
+ int (*get_xquota)(struct super_block *, int, qid_t, struct fs_disk_quota *);
+ int (*set_xquota)(struct super_block *, int, qid_t, struct fs_disk_quota *);
+};
+struct quota_format_type {
+ int qf_fmt_id;
+ struct quota_format_ops *qf_ops;
+ struct module *qf_owner;
+ struct quota_format_type *qf_next;
+};
+enum {
+ _DQUOT_USAGE_ENABLED = 0,
+ _DQUOT_LIMITS_ENABLED,
+ _DQUOT_SUSPENDED,
+ _DQUOT_STATE_FLAGS
+};
+static inline __attribute__((always_inline)) unsigned int dquot_state_flag(unsigned int flags, int type)
+{
+ if (type == 0)
+  return flags;
+ return flags << _DQUOT_STATE_FLAGS;
+}
+static inline __attribute__((always_inline)) unsigned int dquot_generic_flag(unsigned int flags, int type)
+{
+ if (type == 0)
+  return flags;
+ return flags >> _DQUOT_STATE_FLAGS;
+}
+struct quota_info {
+ unsigned int flags;
+ struct mutex dqio_mutex;
+ struct mutex dqonoff_mutex;
+ struct rw_semaphore dqptr_sem;
+ struct inode *files[2];
+ struct mem_dqinfo info[2];
+ struct quota_format_ops *ops[2];
+};
+int register_quota_format(struct quota_format_type *fmt);
+void unregister_quota_format(struct quota_format_type *fmt);
+struct quota_module_name {
+ int qm_fmt_id;
+ char *qm_mod_name;
+};
+enum positive_aop_returns {
+ AOP_WRITEPAGE_ACTIVATE = 0x80000,
+ AOP_TRUNCATED_PAGE = 0x80001,
+};
+struct page;
+struct address_space;
+struct writeback_control;
+struct iov_iter {
+ const struct iovec *iov;
+ unsigned long nr_segs;
+ size_t iov_offset;
+ size_t count;
+};
+size_t iov_iter_copy_from_user_atomic(struct page *page,
+  struct iov_iter *i, unsigned long offset, size_t bytes);
+size_t iov_iter_copy_from_user(struct page *page,
+  struct iov_iter *i, unsigned long offset, size_t bytes);
+void iov_iter_advance(struct iov_iter *i, size_t bytes);
+int iov_iter_fault_in_readable(struct iov_iter *i, size_t bytes);
+size_t iov_iter_single_seg_count(struct iov_iter *i);
+static inline __attribute__((always_inline)) void iov_iter_init(struct iov_iter *i,
+   const struct iovec *iov, unsigned long nr_segs,
+   size_t count, size_t written)
+{
+ i->iov = iov;
+ i->nr_segs = nr_segs;
+ i->iov_offset = 0;
+ i->count = count + written;
+ iov_iter_advance(i, written);
+}
+static inline __attribute__((always_inline)) size_t iov_iter_count(struct iov_iter *i)
+{
+ return i->count;
+}
+typedef struct {
+ size_t written;
+ size_t count;
+ union {
+  char *buf;
+  void *data;
+ } arg;
+ int error;
+} read_descriptor_t;
+typedef int (*read_actor_t)(read_descriptor_t *, struct page *,
+  unsigned long, unsigned long);
+struct address_space_operations {
+ int (*writepage)(struct page *page, struct writeback_control *wbc);
+ int (*readpage)(struct file *, struct page *);
+ void (*sync_page)(struct page *);
+ int (*writepages)(struct address_space *, struct writeback_control *);
+ int (*set_page_dirty)(struct page *page);
+ int (*readpages)(struct file *filp, struct address_space *mapping,
+   struct list_head *pages, unsigned nr_pages);
+ int (*write_begin)(struct file *, struct address_space *mapping,
+    loff_t pos, unsigned len, unsigned flags,
+    struct page **pagep, void **fsdata);
+ int (*write_end)(struct file *, struct address_space *mapping,
+    loff_t pos, unsigned len, unsigned copied,
+    struct page *page, void *fsdata);
+ sector_t (*bmap)(struct address_space *, sector_t);
+ void (*invalidatepage) (struct page *, unsigned long);
+ int (*releasepage) (struct page *, gfp_t);
+ ssize_t (*direct_IO)(int, struct kiocb *, const struct iovec *iov,
+   loff_t offset, unsigned long nr_segs);
+ int (*get_xip_mem)(struct address_space *, unsigned long, int,
+      void **, unsigned long *);
+ int (*migratepage) (struct address_space *,
+   struct page *, struct page *);
+ int (*launder_page) (struct page *);
+ int (*is_partially_uptodate) (struct page *, read_descriptor_t *,
+     unsigned long);
+ int (*error_remove_page)(struct address_space *, struct page *);
+};
+int pagecache_write_begin(struct file *, struct address_space *mapping,
+    loff_t pos, unsigned len, unsigned flags,
+    struct page **pagep, void **fsdata);
+int pagecache_write_end(struct file *, struct address_space *mapping,
+    loff_t pos, unsigned len, unsigned copied,
+    struct page *page, void *fsdata);
+struct backing_dev_info;
+struct address_space {
+ struct inode *host;
+ struct radix_tree_root page_tree;
+ spinlock_t tree_lock;
+ unsigned int i_mmap_writable;
+ struct prio_tree_root i_mmap;
+ struct list_head i_mmap_nonlinear;
+ spinlock_t i_mmap_lock;
+ unsigned int truncate_count;
+ unsigned long nrpages;
+ unsigned long writeback_index;
+ const struct address_space_operations *a_ops;
+ unsigned long flags;
+ struct backing_dev_info *backing_dev_info;
+ spinlock_t private_lock;
+ struct list_head private_list;
+ struct address_space *assoc_mapping;
+} __attribute__((aligned(sizeof(long))));
+struct block_device {
+ dev_t bd_dev;
+ struct inode * bd_inode;
+ struct super_block * bd_super;
+ int bd_openers;
+ struct mutex bd_mutex;
+ struct list_head bd_inodes;
+ void * bd_holder;
+ int bd_holders;
+ struct list_head bd_holder_list;
+ struct block_device * bd_contains;
+ unsigned bd_block_size;
+ struct hd_struct * bd_part;
+ unsigned bd_part_count;
+ int bd_invalidated;
+ struct gendisk * bd_disk;
+ struct list_head bd_list;
+ unsigned long bd_private;
+ int bd_fsfreeze_count;
+ struct mutex bd_fsfreeze_mutex;
+};
+int mapping_tagged(struct address_space *mapping, int tag);
+static inline __attribute__((always_inline)) int mapping_mapped(struct address_space *mapping)
+{
+ return !prio_tree_empty(&mapping->i_mmap) ||
+  !list_empty(&mapping->i_mmap_nonlinear);
+}
+static inline __attribute__((always_inline)) int mapping_writably_mapped(struct address_space *mapping)
+{
+ return mapping->i_mmap_writable != 0;
+}
+struct posix_acl;
+struct inode {
+ struct hlist_node i_hash;
+ struct list_head i_list;
+ struct list_head i_sb_list;
+ struct list_head i_dentry;
+ unsigned long i_ino;
+ atomic_t i_count;
+ unsigned int i_nlink;
+ uid_t i_uid;
+ gid_t i_gid;
+ dev_t i_rdev;
+ u64 i_version;
+ loff_t i_size;
+ struct timespec i_atime;
+ struct timespec i_mtime;
+ struct timespec i_ctime;
+ blkcnt_t i_blocks;
+ unsigned int i_blkbits;
+ unsigned short i_bytes;
+ umode_t i_mode;
+ spinlock_t i_lock;
+ struct mutex i_mutex;
+ struct rw_semaphore i_alloc_sem;
+ const struct inode_operations *i_op;
+ const struct file_operations *i_fop;
+ struct super_block *i_sb;
+ struct file_lock *i_flock;
+ struct address_space *i_mapping;
+ struct address_space i_data;
+ struct list_head i_devices;
+ union {
+  struct pipe_inode_info *i_pipe;
+  struct block_device *i_bdev;
+  struct cdev *i_cdev;
+ };
+ __u32 i_generation;
+ __u32 i_fsnotify_mask;
+ struct hlist_head i_fsnotify_mark_entries;
+ struct list_head inotify_watches;
+ struct mutex inotify_mutex;
+ unsigned long i_state;
+ unsigned long dirtied_when;
+ unsigned int i_flags;
+ atomic_t i_writecount;
+ void *i_private;
+};
+enum inode_i_mutex_lock_class
+{
+ I_MUTEX_NORMAL,
+ I_MUTEX_PARENT,
+ I_MUTEX_CHILD,
+ I_MUTEX_XATTR,
+ I_MUTEX_QUOTA
+};
+static inline __attribute__((always_inline)) loff_t i_size_read(const struct inode *inode)
+{
+ loff_t i_size;
+ do { do { (current_thread_info()->preempt_count) += (1); } while (0); __asm__ __volatile__("": : :"memory"); } while (0);
+ i_size = inode->i_size;
+ do { do { __asm__ __volatile__("": : :"memory"); do { (current_thread_info()->preempt_count) -= (1); } while (0); } while (0); __asm__ __volatile__("": : :"memory"); do { if (__builtin_expect(!!(test_ti_thread_flag(current_thread_info(), 2)), 0)) preempt_schedule(); } while (0); } while (0);
+ return i_size;
+}
+static inline __attribute__((always_inline)) void i_size_write(struct inode *inode, loff_t i_size)
+{
+ do { do { (current_thread_info()->preempt_count) += (1); } while (0); __asm__ __volatile__("": : :"memory"); } while (0);
+ inode->i_size = i_size;
+ do { do { __asm__ __volatile__("": : :"memory"); do { (current_thread_info()->preempt_count) -= (1); } while (0); } while (0); __asm__ __volatile__("": : :"memory"); do { if (__builtin_expect(!!(test_ti_thread_flag(current_thread_info(), 2)), 0)) preempt_schedule(); } while (0); } while (0);
+}
+static inline __attribute__((always_inline)) unsigned iminor(const struct inode *inode)
+{
+ return ((unsigned int) ((inode->i_rdev) & ((1U << 20) - 1)));
+}
+static inline __attribute__((always_inline)) unsigned imajor(const struct inode *inode)
+{
+ return ((unsigned int) ((inode->i_rdev) >> 20));
+}
+extern struct block_device *I_BDEV(struct inode *inode);
+struct fown_struct {
+ rwlock_t lock;
+ struct pid *pid;
+ enum pid_type pid_type;
+ uid_t uid, euid;
+ int signum;
+};
+struct file_ra_state {
+ unsigned long start;
+ unsigned int size;
+ unsigned int async_size;
+ unsigned int ra_pages;
+ unsigned int mmap_miss;
+ loff_t prev_pos;
+};
+static inline __attribute__((always_inline)) int ra_has_index(struct file_ra_state *ra, unsigned long index)
+{
+ return (index >= ra->start &&
+  index < ra->start + ra->size);
+}
+struct file {
+ union {
+  struct list_head fu_list;
+  struct rcu_head fu_rcuhead;
+ } f_u;
+ struct path f_path;
+ const struct file_operations *f_op;
+ spinlock_t f_lock;
+ atomic_long_t f_count;
+ unsigned int f_flags;
+ fmode_t f_mode;
+ loff_t f_pos;
+ struct fown_struct f_owner;
+ const struct cred *f_cred;
+ struct file_ra_state f_ra;
+ u64 f_version;
+ void *private_data;
+ struct list_head f_ep_links;
+ struct address_space *f_mapping;
+};
+extern spinlock_t files_lock;
+static inline __attribute__((always_inline)) void file_take_write(struct file *filp) {}
+static inline __attribute__((always_inline)) void file_release_write(struct file *filp) {}
+static inline __attribute__((always_inline)) void file_reset_write(struct file *filp) {}
+static inline __attribute__((always_inline)) void file_check_state(struct file *filp) {}
+static inline __attribute__((always_inline)) int file_check_writeable(struct file *filp)
+{
+ return 0;
+}
+typedef struct files_struct *fl_owner_t;
+struct file_lock_operations {
+ void (*fl_copy_lock)(struct file_lock *, struct file_lock *);
+ void (*fl_release_private)(struct file_lock *);
+};
+struct lock_manager_operations {
+ int (*fl_compare_owner)(struct file_lock *, struct file_lock *);
+ void (*fl_notify)(struct file_lock *);
+ int (*fl_grant)(struct file_lock *, struct file_lock *, int);
+ void (*fl_copy_lock)(struct file_lock *, struct file_lock *);
+ void (*fl_release_private)(struct file_lock *);
+ void (*fl_break)(struct file_lock *);
+ int (*fl_mylease)(struct file_lock *, struct file_lock *);
+ int (*fl_change)(struct file_lock **, int);
+};
+struct lock_manager {
+ struct list_head list;
+};
+void locks_start_grace(struct lock_manager *);
+void locks_end_grace(struct lock_manager *);
+int locks_in_grace(void);
+ enum nfs_stat {
+ NFS_OK = 0,
+ NFSERR_PERM = 1,
+ NFSERR_NOENT = 2,
+ NFSERR_IO = 5,
+ NFSERR_NXIO = 6,
+ NFSERR_EAGAIN = 11,
+ NFSERR_ACCES = 13,
+ NFSERR_EXIST = 17,
+ NFSERR_XDEV = 18,
+ NFSERR_NODEV = 19,
+ NFSERR_NOTDIR = 20,
+ NFSERR_ISDIR = 21,
+ NFSERR_INVAL = 22,
+ NFSERR_FBIG = 27,
+ NFSERR_NOSPC = 28,
+ NFSERR_ROFS = 30,
+ NFSERR_MLINK = 31,
+ NFSERR_OPNOTSUPP = 45,
+ NFSERR_NAMETOOLONG = 63,
+ NFSERR_NOTEMPTY = 66,
+ NFSERR_DQUOT = 69,
+ NFSERR_STALE = 70,
+ NFSERR_REMOTE = 71,
+ NFSERR_WFLUSH = 99,
+ NFSERR_BADHANDLE = 10001,
+ NFSERR_NOT_SYNC = 10002,
+ NFSERR_BAD_COOKIE = 10003,
+ NFSERR_NOTSUPP = 10004,
+ NFSERR_TOOSMALL = 10005,
+ NFSERR_SERVERFAULT = 10006,
+ NFSERR_BADTYPE = 10007,
+ NFSERR_JUKEBOX = 10008,
+ NFSERR_SAME = 10009,
+ NFSERR_DENIED = 10010,
+ NFSERR_EXPIRED = 10011,
+ NFSERR_LOCKED = 10012,
+ NFSERR_GRACE = 10013,
+ NFSERR_FHEXPIRED = 10014,
+ NFSERR_SHARE_DENIED = 10015,
+ NFSERR_WRONGSEC = 10016,
+ NFSERR_CLID_INUSE = 10017,
+ NFSERR_RESOURCE = 10018,
+ NFSERR_MOVED = 10019,
+ NFSERR_NOFILEHANDLE = 10020,
+ NFSERR_MINOR_VERS_MISMATCH = 10021,
+ NFSERR_STALE_CLIENTID = 10022,
+ NFSERR_STALE_STATEID = 10023,
+ NFSERR_OLD_STATEID = 10024,
+ NFSERR_BAD_STATEID = 10025,
+ NFSERR_BAD_SEQID = 10026,
+ NFSERR_NOT_SAME = 10027,
+ NFSERR_LOCK_RANGE = 10028,
+ NFSERR_SYMLINK = 10029,
+ NFSERR_RESTOREFH = 10030,
+ NFSERR_LEASE_MOVED = 10031,
+ NFSERR_ATTRNOTSUPP = 10032,
+ NFSERR_NO_GRACE = 10033,
+ NFSERR_RECLAIM_BAD = 10034,
+ NFSERR_RECLAIM_CONFLICT = 10035,
+ NFSERR_BAD_XDR = 10036,
+ NFSERR_LOCKS_HELD = 10037,
+ NFSERR_OPENMODE = 10038,
+ NFSERR_BADOWNER = 10039,
+ NFSERR_BADCHAR = 10040,
+ NFSERR_BADNAME = 10041,
+ NFSERR_BAD_RANGE = 10042,
+ NFSERR_LOCK_NOTSUPP = 10043,
+ NFSERR_OP_ILLEGAL = 10044,
+ NFSERR_DEADLOCK = 10045,
+ NFSERR_FILE_OPEN = 10046,
+ NFSERR_ADMIN_REVOKED = 10047,
+ NFSERR_CB_PATH_DOWN = 10048,
+};
+enum nfs_ftype {
+ NFNON = 0,
+ NFREG = 1,
+ NFDIR = 2,
+ NFBLK = 3,
+ NFCHR = 4,
+ NFLNK = 5,
+ NFSOCK = 6,
+ NFBAD = 7,
+ NFFIFO = 8
+};
+typedef u32 rpc_authflavor_t;
+enum rpc_auth_flavors {
+ RPC_AUTH_NULL = 0,
+ RPC_AUTH_UNIX = 1,
+ RPC_AUTH_SHORT = 2,
+ RPC_AUTH_DES = 3,
+ RPC_AUTH_KRB = 4,
+ RPC_AUTH_GSS = 6,
+ RPC_AUTH_MAXFLAVOR = 8,
+ RPC_AUTH_GSS_KRB5 = 390003,
+ RPC_AUTH_GSS_KRB5I = 390004,
+ RPC_AUTH_GSS_KRB5P = 390005,
+ RPC_AUTH_GSS_LKEY = 390006,
+ RPC_AUTH_GSS_LKEYI = 390007,
+ RPC_AUTH_GSS_LKEYP = 390008,
+ RPC_AUTH_GSS_SPKM = 390009,
+ RPC_AUTH_GSS_SPKMI = 390010,
+ RPC_AUTH_GSS_SPKMP = 390011,
+};
+enum rpc_msg_type {
+ RPC_CALL = 0,
+ RPC_REPLY = 1
+};
+enum rpc_reply_stat {
+ RPC_MSG_ACCEPTED = 0,
+ RPC_MSG_DENIED = 1
+};
+enum rpc_accept_stat {
+ RPC_SUCCESS = 0,
+ RPC_PROG_UNAVAIL = 1,
+ RPC_PROG_MISMATCH = 2,
+ RPC_PROC_UNAVAIL = 3,
+ RPC_GARBAGE_ARGS = 4,
+ RPC_SYSTEM_ERR = 5,
+ RPC_DROP_REPLY = 60000,
+};
+enum rpc_reject_stat {
+ RPC_MISMATCH = 0,
+ RPC_AUTH_ERROR = 1
+};
+enum rpc_auth_stat {
+ RPC_AUTH_OK = 0,
+ RPC_AUTH_BADCRED = 1,
+ RPC_AUTH_REJECTEDCRED = 2,
+ RPC_AUTH_BADVERF = 3,
+ RPC_AUTH_REJECTEDVERF = 4,
+ RPC_AUTH_TOOWEAK = 5,
+ RPCSEC_GSS_CREDPROBLEM = 13,
+ RPCSEC_GSS_CTXPROBLEM = 14
+};
+typedef __be32 rpc_fraghdr;
+extern __be32 in_aton(const char *str);
+extern int in4_pton(const char *src, int srclen, u8 *dst, int delim, const char **end);
+extern int in6_pton(const char *src, int srclen, u8 *dst, int delim, const char **end);
+struct nfs_fh {
+ unsigned short size;
+ unsigned char data[128];
+};
+static inline __attribute__((always_inline)) int nfs_compare_fh(const struct nfs_fh *a, const struct nfs_fh *b)
+{
+ return a->size != b->size || memcmp(a->data, b->data, a->size) != 0;
+}
+static inline __attribute__((always_inline)) void nfs_copy_fh(struct nfs_fh *target, const struct nfs_fh *source)
+{
+ target->size = source->size;
+ memcpy(target->data, source->data, source->size);
+}
+enum nfs3_stable_how {
+ NFS_UNSTABLE = 0,
+ NFS_DATA_SYNC = 1,
+ NFS_FILE_SYNC = 2
+};
+struct nlm_lockowner;
+struct nfs_lock_info {
+ u32 state;
+ struct nlm_lockowner *owner;
+ struct list_head list;
+};
+struct nfs4_lock_state;
+struct nfs4_lock_info {
+ struct nfs4_lock_state *owner;
+};
+struct file_lock {
+ struct file_lock *fl_next;
+ struct list_head fl_link;
+ struct list_head fl_block;
+ fl_owner_t fl_owner;
+ unsigned char fl_flags;
+ unsigned char fl_type;
+ unsigned int fl_pid;
+ struct pid *fl_nspid;
+ wait_queue_head_t fl_wait;
+ struct file *fl_file;
+ loff_t fl_start;
+ loff_t fl_end;
+ struct fasync_struct * fl_fasync;
+ unsigned long fl_break_time;
+ const struct file_lock_operations *fl_ops;
+ const struct lock_manager_operations *fl_lmops;
+ union {
+  struct nfs_lock_info nfs_fl;
+  struct nfs4_lock_info nfs4_fl;
+  struct {
+   struct list_head link;
+   int state;
+  } afs;
+ } fl_u;
+};
+struct f_owner_ex {
+ int type;
+ pid_t pid;
+};
+struct flock {
+ short l_type;
+ short l_whence;
+ __kernel_off_t l_start;
+ __kernel_off_t l_len;
+ __kernel_pid_t l_pid;
+};
+struct flock64 {
+ short l_type;
+ short l_whence;
+ __kernel_loff_t l_start;
+ __kernel_loff_t l_len;
+ __kernel_pid_t l_pid;
+};
+extern void send_sigio(struct fown_struct *fown, int fd, int band);
+extern int do_sync_mapping_range(struct address_space *mapping, loff_t offset,
+   loff_t endbyte, unsigned int flags);
+extern int fcntl_getlk(struct file *, struct flock *);
+extern int fcntl_setlk(unsigned int, struct file *, unsigned int,
+   struct flock *);
+extern int fcntl_getlk64(struct file *, struct flock64 *);
+extern int fcntl_setlk64(unsigned int, struct file *, unsigned int,
+   struct flock64 *);
+extern int fcntl_setlease(unsigned int fd, struct file *filp, long arg);
+extern int fcntl_getlease(struct file *filp);
+extern void locks_init_lock(struct file_lock *);
+extern void locks_copy_lock(struct file_lock *, struct file_lock *);
+extern void __locks_copy_lock(struct file_lock *, const struct file_lock *);
+extern void locks_remove_posix(struct file *, fl_owner_t);
+extern void locks_remove_flock(struct file *);
+extern void locks_release_private(struct file_lock *);
+extern void posix_test_lock(struct file *, struct file_lock *);
+extern int posix_lock_file(struct file *, struct file_lock *, struct file_lock *);
+extern int posix_lock_file_wait(struct file *, struct file_lock *);
+extern int posix_unblock_lock(struct file *, struct file_lock *);
+extern int vfs_test_lock(struct file *, struct file_lock *);
+extern int vfs_lock_file(struct file *, unsigned int, struct file_lock *, struct file_lock *);
+extern int vfs_cancel_lock(struct file *filp, struct file_lock *fl);
+extern int flock_lock_file_wait(struct file *filp, struct file_lock *fl);
+extern int __break_lease(struct inode *inode, unsigned int flags);
+extern void lease_get_mtime(struct inode *, struct timespec *time);
+extern int generic_setlease(struct file *, long, struct file_lock **);
+extern int vfs_setlease(struct file *, long, struct file_lock **);
+extern int lease_modify(struct file_lock **, int);
+extern int lock_may_read(struct inode *, loff_t start, unsigned long count);
+extern int lock_may_write(struct inode *, loff_t start, unsigned long count);
+struct fasync_struct {
+ int magic;
+ int fa_fd;
+ struct fasync_struct *fa_next;
+ struct file *fa_file;
+};
+extern int fasync_helper(int, struct file *, int, struct fasync_struct **);
+extern void kill_fasync(struct fasync_struct **, int, int);
+extern void __kill_fasync(struct fasync_struct *, int, int);
+extern int __f_setown(struct file *filp, struct pid *, enum pid_type, int force);
+extern int f_setown(struct file *filp, unsigned long arg, int force);
+extern void f_delown(struct file *filp);
+extern pid_t f_getown(struct file *filp);
+extern int send_sigurg(struct fown_struct *fown);
+extern struct list_head super_blocks;
+extern spinlock_t sb_lock;
+struct super_block {
+ struct list_head s_list;
+ dev_t s_dev;
+ unsigned long s_blocksize;
+ unsigned char s_blocksize_bits;
+ unsigned char s_dirt;
+ loff_t s_maxbytes;
+ struct file_system_type *s_type;
+ const struct super_operations *s_op;
+ const struct dquot_operations *dq_op;
+ const struct quotactl_ops *s_qcop;
+ const struct export_operations *s_export_op;
+ unsigned long s_flags;
+ unsigned long s_magic;
+ struct dentry *s_root;
+ struct rw_semaphore s_umount;
+ struct mutex s_lock;
+ int s_count;
+ int s_need_sync;
+ atomic_t s_active;
+ struct xattr_handler **s_xattr;
+ struct list_head s_inodes;
+ struct hlist_head s_anon;
+ struct list_head s_files;
+ struct list_head s_dentry_lru;
+ int s_nr_dentry_unused;
+ struct block_device *s_bdev;
+ struct backing_dev_info *s_bdi;
+ struct mtd_info *s_mtd;
+ struct list_head s_instances;
+ struct quota_info s_dquot;
+ int s_frozen;
+ wait_queue_head_t s_wait_unfrozen;
+ char s_id[32];
+ void *s_fs_info;
+ fmode_t s_mode;
+ struct mutex s_vfs_rename_mutex;
+ u32 s_time_gran;
+ char *s_subtype;
+ char *s_options;
+};
+extern struct timespec current_fs_time(struct super_block *sb);
+enum {
+ SB_UNFROZEN = 0,
+ SB_FREEZE_WRITE = 1,
+ SB_FREEZE_TRANS = 2,
+};
+extern void lock_super(struct super_block *);
+extern void unlock_super(struct super_block *);
+extern int vfs_create(struct inode *, struct dentry *, int, struct nameidata *);
+extern int vfs_mkdir(struct inode *, struct dentry *, int);
+extern int vfs_mknod(struct inode *, struct dentry *, int, dev_t);
+extern int vfs_symlink(struct inode *, struct dentry *, const char *);
+extern int vfs_link(struct dentry *, struct inode *, struct dentry *);
+extern int vfs_rmdir(struct inode *, struct dentry *);
+extern int vfs_unlink(struct inode *, struct dentry *);
+extern int vfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *);
+extern void dentry_unhash(struct dentry *dentry);
+extern int file_permission(struct file *, int);
+struct fiemap_extent_info {
+ unsigned int fi_flags;
+ unsigned int fi_extents_mapped;
+ unsigned int fi_extents_max;
+ struct fiemap_extent *fi_extents_start;
+};
+int fiemap_fill_next_extent(struct fiemap_extent_info *info, u64 logical,
+       u64 phys, u64 len, u32 flags);
+int fiemap_check_flags(struct fiemap_extent_info *fieinfo, u32 fs_flags);
+typedef int (*filldir_t)(void *, const char *, int, loff_t, u64, unsigned);
+struct block_device_operations;
+struct file_operations {
+ struct module *owner;
+ loff_t (*llseek) (struct file *, loff_t, int);
+ ssize_t (*read) (struct file *, char *, size_t, loff_t *);
+ ssize_t (*write) (struct file *, const char *, size_t, loff_t *);
+ ssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long, loff_t);
+ ssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t);
+ int (*readdir) (struct file *, void *, filldir_t);
+ unsigned int (*poll) (struct file *, struct poll_table_struct *);
+ int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);
+ long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
+ long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
+ int (*mmap) (struct file *, struct vm_area_struct *);
+ int (*open) (struct inode *, struct file *);
+ int (*flush) (struct file *, fl_owner_t id);
+ int (*release) (struct inode *, struct file *);
+ int (*fsync) (struct file *, struct dentry *, int datasync);
+ int (*aio_fsync) (struct kiocb *, int datasync);
+ int (*fasync) (int, struct file *, int);
+ int (*lock) (struct file *, int, struct file_lock *);
+ ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);
+ unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
+ int (*check_flags)(int);
+ int (*flock) (struct file *, int, struct file_lock *);
+ ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
+ ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
+ int (*setlease)(struct file *, long, struct file_lock **);
+};
+struct inode_operations {
+ int (*create) (struct inode *,struct dentry *,int, struct nameidata *);
+ struct dentry * (*lookup) (struct inode *,struct dentry *, struct nameidata *);
+ int (*link) (struct dentry *,struct inode *,struct dentry *);
+ int (*unlink) (struct inode *,struct dentry *);
+ int (*symlink) (struct inode *,struct dentry *,const char *);
+ int (*mkdir) (struct inode *,struct dentry *,int);
+ int (*rmdir) (struct inode *,struct dentry *);
+ int (*mknod) (struct inode *,struct dentry *,int,dev_t);
+ int (*rename) (struct inode *, struct dentry *,
+   struct inode *, struct dentry *);
+ int (*readlink) (struct dentry *, char *,int);
+ void * (*follow_link) (struct dentry *, struct nameidata *);
+ void (*put_link) (struct dentry *, struct nameidata *, void *);
+ void (*truncate) (struct inode *);
+ int (*permission) (struct inode *, int);
+ int (*check_acl)(struct inode *, int);
+ int (*setattr) (struct dentry *, struct iattr *);
+ int (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);
+ int (*setxattr) (struct dentry *, const char *,const void *,size_t,int);
+ ssize_t (*getxattr) (struct dentry *, const char *, void *, size_t);
+ ssize_t (*listxattr) (struct dentry *, char *, size_t);
+ int (*removexattr) (struct dentry *, const char *);
+ void (*truncate_range)(struct inode *, loff_t, loff_t);
+ long (*fallocate)(struct inode *inode, int mode, loff_t offset,
+     loff_t len);
+ int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 start,
+        u64 len);
+};
+struct seq_file;
+ssize_t rw_copy_check_uvector(int type, const struct iovec * uvector,
+    unsigned long nr_segs, unsigned long fast_segs,
+    struct iovec *fast_pointer,
+    struct iovec **ret_pointer);
+extern ssize_t vfs_read(struct file *, char *, size_t, loff_t *);
+extern ssize_t vfs_write(struct file *, const char *, size_t, loff_t *);
+extern ssize_t vfs_readv(struct file *, const struct iovec *,
+  unsigned long, loff_t *);
+extern ssize_t vfs_writev(struct file *, const struct iovec *,
+  unsigned long, loff_t *);
+struct super_operations {
+    struct inode *(*alloc_inode)(struct super_block *sb);
+ void (*destroy_inode)(struct inode *);
+    void (*dirty_inode) (struct inode *);
+ int (*write_inode) (struct inode *, int);
+ void (*drop_inode) (struct inode *);
+ void (*delete_inode) (struct inode *);
+ void (*put_super) (struct super_block *);
+ void (*write_super) (struct super_block *);
+ int (*sync_fs)(struct super_block *sb, int wait);
+ int (*freeze_fs) (struct super_block *);
+ int (*unfreeze_fs) (struct super_block *);
+ int (*statfs) (struct dentry *, struct kstatfs *);
+ int (*remount_fs) (struct super_block *, int *, char *);
+ void (*clear_inode) (struct inode *);
+ void (*umount_begin) (struct super_block *);
+ int (*show_options)(struct seq_file *, struct vfsmount *);
+ int (*show_stats)(struct seq_file *, struct vfsmount *);
+ int (*bdev_try_to_free_page)(struct super_block*, struct page*, gfp_t);
+};
+extern void __mark_inode_dirty(struct inode *, int);
+static inline __attribute__((always_inline)) void mark_inode_dirty(struct inode *inode)
+{
+ __mark_inode_dirty(inode, (1 | 2 | 4));
+}
+static inline __attribute__((always_inline)) void mark_inode_dirty_sync(struct inode *inode)
+{
+ __mark_inode_dirty(inode, 1);
+}
+static inline __attribute__((always_inline)) void inc_nlink(struct inode *inode)
+{
+ inode->i_nlink++;
+}
+static inline __attribute__((always_inline)) void inode_inc_link_count(struct inode *inode)
+{
+ inc_nlink(inode);
+ mark_inode_dirty(inode);
+}
+static inline __attribute__((always_inline)) void drop_nlink(struct inode *inode)
+{
+ inode->i_nlink--;
+}
+static inline __attribute__((always_inline)) void clear_nlink(struct inode *inode)
+{
+ inode->i_nlink = 0;
+}
+static inline __attribute__((always_inline)) void inode_dec_link_count(struct inode *inode)
+{
+ drop_nlink(inode);
+ mark_inode_dirty(inode);
+}
+static inline __attribute__((always_inline)) void inode_inc_iversion(struct inode *inode)
+{
+       do { do { do { (current_thread_info()->preempt_count) += (1); } while (0); __asm__ __volatile__("": : :"memory"); } while (0); (void)0; (void)(&inode->i_lock); } while (0);
+       inode->i_version++;
+       do { do { do { __asm__ __volatile__("": : :"memory"); do { (current_thread_info()->preempt_count) -= (1); } while (0); } while (0); __asm__ __volatile__("": : :"memory"); do { if (__builtin_expect(!!(test_ti_thread_flag(current_thread_info(), 2)), 0)) preempt_schedule(); } while (0); } while (0); (void)0; (void)(&inode->i_lock); } while (0);
+}
+extern void touch_atime(struct vfsmount *mnt, struct dentry *dentry);
+static inline __attribute__((always_inline)) void file_accessed(struct file *file)
+{
+ if (!(file->f_flags & 01000000))
+  touch_atime(file->f_path.mnt, file->f_path.dentry);
+}
+int sync_inode(struct inode *inode, struct writeback_control *wbc);
+struct file_system_type {
+ const char *name;
+ int fs_flags;
+ int (*get_sb) (struct file_system_type *, int,
+         const char *, void *, struct vfsmount *);
+ void (*kill_sb) (struct super_block *);
+ struct module *owner;
+ struct file_system_type * next;
+ struct list_head fs_supers;
+ struct lock_class_key s_lock_key;
+ struct lock_class_key s_umount_key;
+ struct lock_class_key i_lock_key;
+ struct lock_class_key i_mutex_key;
+ struct lock_class_key i_mutex_dir_key;
+ struct lock_class_key i_alloc_sem_key;
+};
+extern int get_sb_ns(struct file_system_type *fs_type, int flags, void *data,
+ int (*fill_super)(struct super_block *, void *, int),
+ struct vfsmount *mnt);
+extern int get_sb_bdev(struct file_system_type *fs_type,
+ int flags, const char *dev_name, void *data,
+ int (*fill_super)(struct super_block *, void *, int),
+ struct vfsmount *mnt);
+extern int get_sb_single(struct file_system_type *fs_type,
+ int flags, void *data,
+ int (*fill_super)(struct super_block *, void *, int),
+ struct vfsmount *mnt);
+extern int get_sb_nodev(struct file_system_type *fs_type,
+ int flags, void *data,
+ int (*fill_super)(struct super_block *, void *, int),
+ struct vfsmount *mnt);
+void generic_shutdown_super(struct super_block *sb);
+void kill_block_super(struct super_block *sb);
+void kill_anon_super(struct super_block *sb);
+void kill_litter_super(struct super_block *sb);
+void deactivate_super(struct super_block *sb);
+void deactivate_locked_super(struct super_block *sb);
+int set_anon_super(struct super_block *s, void *data);
+struct super_block *sget(struct file_system_type *type,
+   int (*test)(struct super_block *,void *),
+   int (*set)(struct super_block *,void *),
+   void *data);
+extern int get_sb_pseudo(struct file_system_type *, char *,
+ const struct super_operations *ops, unsigned long,
+ struct vfsmount *mnt);
+extern void simple_set_mnt(struct vfsmount *mnt, struct super_block *sb);
+int __put_super_and_need_restart(struct super_block *sb);
+void put_super(struct super_block *sb);
+extern int register_filesystem(struct file_system_type *);
+extern int unregister_filesystem(struct file_system_type *);
+extern struct vfsmount *kern_mount_data(struct file_system_type *, void *data);
+extern int may_umount_tree(struct vfsmount *);
+extern int may_umount(struct vfsmount *);
+extern long do_mount(char *, char *, char *, unsigned long, void *);
+extern struct vfsmount *collect_mounts(struct path *);
+extern void drop_collected_mounts(struct vfsmount *);
+extern int vfs_statfs(struct dentry *, struct kstatfs *);
+extern int current_umask(void);
+extern struct kobject *fs_kobj;
+extern int rw_verify_area(int, struct file *, loff_t *, size_t);
+extern int locks_mandatory_locked(struct inode *);
+extern int locks_mandatory_area(int, struct inode *, struct file *, loff_t, size_t);
+static inline __attribute__((always_inline)) int __mandatory_lock(struct inode *ino)
+{
+ return (ino->i_mode & (0002000 | 00010)) == 0002000;
+}
+static inline __attribute__((always_inline)) int mandatory_lock(struct inode *ino)
+{
+ return ((ino)->i_sb->s_flags & (64)) && __mandatory_lock(ino);
+}
+static inline __attribute__((always_inline)) int locks_verify_locked(struct inode *inode)
+{
+ if (mandatory_lock(inode))
+  return locks_mandatory_locked(inode);
+ return 0;
+}
+static inline __attribute__((always_inline)) int locks_verify_truncate(struct inode *inode,
+        struct file *filp,
+        loff_t size)
+{
+ if (inode->i_flock && mandatory_lock(inode))
+  return locks_mandatory_area(
+   2, inode, filp,
+   size < inode->i_size ? size : inode->i_size,
+   (size < inode->i_size ? inode->i_size - size
+    : size - inode->i_size)
+  );
+ return 0;
+}
+static inline __attribute__((always_inline)) int break_lease(struct inode *inode, unsigned int mode)
+{
+ if (inode->i_flock)
+  return __break_lease(inode, mode);
+ return 0;
+}
+extern int do_truncate(struct dentry *, loff_t start, unsigned int time_attrs,
+         struct file *filp);
+extern int do_fallocate(struct file *file, int mode, loff_t offset,
+   loff_t len);
+extern long do_sys_open(int dfd, const char *filename, int flags,
+   int mode);
+extern struct file *filp_open(const char *, int, int);
+extern struct file * dentry_open(struct dentry *, struct vfsmount *, int,
+     const struct cred *);
+extern int filp_close(struct file *, fl_owner_t id);
+extern char * getname(const char *);
+extern int ioctl_preallocate(struct file *filp, void *argp);
+extern void __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) __attribute__((no_instrument_function)) vfs_caches_init_early(void);
+extern void __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) __attribute__((no_instrument_function)) vfs_caches_init(unsigned long);
+extern struct kmem_cache *names_cachep;
+extern int register_blkdev(unsigned int, const char *);
+extern void unregister_blkdev(unsigned int, const char *);
+extern struct block_device *bdget(dev_t);
+extern struct block_device *bdgrab(struct block_device *bdev);
+extern void bd_set_size(struct block_device *, loff_t size);
+extern void bd_forget(struct inode *inode);
+extern void bdput(struct block_device *);
+extern struct block_device *open_by_devnum(dev_t, fmode_t);
+extern void invalidate_bdev(struct block_device *);
+extern int sync_blockdev(struct block_device *bdev);
+extern struct super_block *freeze_bdev(struct block_device *);
+extern void emergency_thaw_all(void);
+extern int thaw_bdev(struct block_device *bdev, struct super_block *sb);
+extern int fsync_bdev(struct block_device *);
+extern int sync_filesystem(struct super_block *);
+extern const struct file_operations def_blk_fops;
+extern const struct file_operations def_chr_fops;
+extern const struct file_operations bad_sock_fops;
+extern const struct file_operations def_fifo_fops;
+extern int ioctl_by_bdev(struct block_device *, unsigned, unsigned long);
+extern int blkdev_ioctl(struct block_device *, fmode_t, unsigned, unsigned long);
+extern long compat_blkdev_ioctl(struct file *, unsigned, unsigned long);
+extern int blkdev_get(struct block_device *, fmode_t);
+extern int blkdev_put(struct block_device *, fmode_t);
+extern int bd_claim(struct block_device *, void *);
+extern void bd_release(struct block_device *);
+extern int bd_claim_by_disk(struct block_device *, void *, struct gendisk *);
+extern void bd_release_from_disk(struct block_device *, struct gendisk *);
+extern int alloc_chrdev_region(dev_t *, unsigned, unsigned, const char *);
+extern int register_chrdev_region(dev_t, unsigned, const char *);
+extern int __register_chrdev(unsigned int major, unsigned int baseminor,
+        unsigned int count, const char *name,
+        const struct file_operations *fops);
+extern void __unregister_chrdev(unsigned int major, unsigned int baseminor,
+    unsigned int count, const char *name);
+extern void unregister_chrdev_region(dev_t, unsigned);
+extern void chrdev_show(struct seq_file *,off_t);
+static inline __attribute__((always_inline)) int register_chrdev(unsigned int major, const char *name,
+      const struct file_operations *fops)
+{
+ return __register_chrdev(major, 0, 256, name, fops);
+}
+static inline __attribute__((always_inline)) void unregister_chrdev(unsigned int major, const char *name)
+{
+ __unregister_chrdev(major, 0, 256, name);
+}
+extern const char *__bdevname(dev_t, char *buffer);
+extern const char *bdevname(struct block_device *bdev, char *buffer);
+extern struct block_device *lookup_bdev(const char *);
+extern struct block_device *open_bdev_exclusive(const char *, fmode_t, void *);
+extern void close_bdev_exclusive(struct block_device *, fmode_t);
+extern void blkdev_show(struct seq_file *,off_t);
+extern void init_special_inode(struct inode *, umode_t, dev_t);
+extern void make_bad_inode(struct inode *);
+extern int is_bad_inode(struct inode *);
+extern const struct file_operations read_pipefifo_fops;
+extern const struct file_operations write_pipefifo_fops;
+extern const struct file_operations rdwr_pipefifo_fops;
+extern int fs_may_remount_ro(struct super_block *);
+extern void check_disk_size_change(struct gendisk *disk,
+       struct block_device *bdev);
+extern int revalidate_disk(struct gendisk *);
+extern int check_disk_change(struct block_device *);
+extern int __invalidate_device(struct block_device *);
+extern int invalidate_partition(struct gendisk *, int);
+extern int invalidate_inodes(struct super_block *);
+unsigned long invalidate_mapping_pages(struct address_space *mapping,
+     unsigned long start, unsigned long end);
+static inline __attribute__((always_inline)) unsigned long __attribute__((deprecated))
+invalidate_inode_pages(struct address_space *mapping)
+{
+ return invalidate_mapping_pages(mapping, 0, ~0UL);
+}
+static inline __attribute__((always_inline)) void invalidate_remote_inode(struct inode *inode)
+{
+ if ((((inode->i_mode) & 00170000) == 0100000) || (((inode->i_mode) & 00170000) == 0040000) ||
+     (((inode->i_mode) & 00170000) == 0120000))
+  invalidate_mapping_pages(inode->i_mapping, 0, -1);
+}
+extern int invalidate_inode_pages2(struct address_space *mapping);
+extern int invalidate_inode_pages2_range(struct address_space *mapping,
+      unsigned long start, unsigned long end);
+extern int write_inode_now(struct inode *, int);
+extern int filemap_fdatawrite(struct address_space *);
+extern int filemap_flush(struct address_space *);
+extern int filemap_fdatawait(struct address_space *);
+extern int filemap_fdatawait_range(struct address_space *, loff_t lstart,
+       loff_t lend);
+extern int filemap_write_and_wait(struct address_space *mapping);
+extern int filemap_write_and_wait_range(struct address_space *mapping,
+            loff_t lstart, loff_t lend);
+extern int wait_on_page_writeback_range(struct address_space *mapping,
+    unsigned long start, unsigned long end);
+extern int __filemap_fdatawrite_range(struct address_space *mapping,
+    loff_t start, loff_t end, int sync_mode);
+extern int filemap_fdatawrite_range(struct address_space *mapping,
+    loff_t start, loff_t end);
+extern int vfs_fsync_range(struct file *file, struct dentry *dentry,
+      loff_t start, loff_t end, int datasync);
+extern int vfs_fsync(struct file *file, struct dentry *dentry, int datasync);
+extern int generic_write_sync(struct file *file, loff_t pos, loff_t count);
+extern void sync_supers(void);
+extern void emergency_sync(void);
+extern void emergency_remount(void);
+extern sector_t bmap(struct inode *, sector_t);
+extern int notify_change(struct dentry *, struct iattr *);
+extern int inode_permission(struct inode *, int);
+extern int generic_permission(struct inode *, int,
+  int (*check_acl)(struct inode *, int));
+static inline __attribute__((always_inline)) bool execute_ok(struct inode *inode)
+{
+ return (inode->i_mode & (00100|00010|00001)) || (((inode->i_mode) & 00170000) == 0040000);
+}
+extern int get_write_access(struct inode *);
+extern int deny_write_access(struct file *);
+static inline __attribute__((always_inline)) void put_write_access(struct inode * inode)
+{
+ atomic_sub(1,(&inode->i_writecount));
+}
+static inline __attribute__((always_inline)) void allow_write_access(struct file *file)
+{
+ if (file)
+  atomic_add(1,(&file->f_path.dentry->d_inode->i_writecount));
+}
+extern int do_pipe_flags(int *, int);
+extern struct file *create_read_pipe(struct file *f, int flags);
+extern struct file *create_write_pipe(int flags);
+extern void free_write_pipe(struct file *);
+extern struct file *do_filp_open(int dfd, const char *pathname,
+  int open_flag, int mode, int acc_mode);
+extern int may_open(struct path *, int, int);
+extern int kernel_read(struct file *, loff_t, char *, unsigned long);
+extern struct file * open_exec(const char *);
+extern int is_subdir(struct dentry *, struct dentry *);
+extern ino_t find_inode_number(struct dentry *, struct qstr *);
+extern loff_t default_llseek(struct file *file, loff_t offset, int origin);
+extern loff_t vfs_llseek(struct file *file, loff_t offset, int origin);
+extern int inode_init_always(struct super_block *, struct inode *);
+extern void inode_init_once(struct inode *);
+extern void inode_add_to_lists(struct super_block *, struct inode *);
+extern void iput(struct inode *);
+extern struct inode * igrab(struct inode *);
+extern ino_t iunique(struct super_block *, ino_t);
+extern int inode_needs_sync(struct inode *inode);
+extern void generic_delete_inode(struct inode *inode);
+extern void generic_drop_inode(struct inode *inode);
+extern int generic_detach_inode(struct inode *inode);
+extern struct inode *ilookup5_nowait(struct super_block *sb,
+  unsigned long hashval, int (*test)(struct inode *, void *),
+  void *data);
+extern struct inode *ilookup5(struct super_block *sb, unsigned long hashval,
+  int (*test)(struct inode *, void *), void *data);
+extern struct inode *ilookup(struct super_block *sb, unsigned long ino);
+extern struct inode * iget5_locked(struct super_block *, unsigned long, int (*test)(struct inode *, void *), int (*set)(struct inode *, void *), void *);
+extern struct inode * iget_locked(struct super_block *, unsigned long);
+extern int insert_inode_locked4(struct inode *, unsigned long, int (*test)(struct inode *, void *), void *);
+extern int insert_inode_locked(struct inode *);
+extern void unlock_new_inode(struct inode *);
+extern void __iget(struct inode * inode);
+extern void iget_failed(struct inode *);
+extern void clear_inode(struct inode *);
+extern void destroy_inode(struct inode *);
+extern void __destroy_inode(struct inode *);
+extern struct inode *new_inode(struct super_block *);
+extern int should_remove_suid(struct dentry *);
+extern int file_remove_suid(struct file *);
+extern void __insert_inode_hash(struct inode *, unsigned long hashval);
+extern void remove_inode_hash(struct inode *);
+static inline __attribute__((always_inline)) void insert_inode_hash(struct inode *inode) {
+ __insert_inode_hash(inode, inode->i_ino);
+}
+extern struct file * get_empty_filp(void);
+extern void file_move(struct file *f, struct list_head *list);
+extern void file_kill(struct file *f);
+struct bio;
+extern void submit_bio(int, struct bio *);
+extern int bdev_read_only(struct block_device *);
+extern int set_blocksize(struct block_device *, int);
+extern int sb_set_blocksize(struct super_block *, int);
+extern int sb_min_blocksize(struct super_block *, int);
+extern int generic_file_mmap(struct file *, struct vm_area_struct *);
+extern int generic_file_readonly_mmap(struct file *, struct vm_area_struct *);
+extern int file_read_actor(read_descriptor_t * desc, struct page *page, unsigned long offset, unsigned long size);
+int generic_write_checks(struct file *file, loff_t *pos, size_t *count, int isblk);
+extern ssize_t generic_file_aio_read(struct kiocb *, const struct iovec *, unsigned long, loff_t);
+extern ssize_t __generic_file_aio_write(struct kiocb *, const struct iovec *, unsigned long,
+  loff_t *);
+extern ssize_t generic_file_aio_write(struct kiocb *, const struct iovec *, unsigned long, loff_t);
+extern ssize_t generic_file_direct_write(struct kiocb *, const struct iovec *,
+  unsigned long *, loff_t, loff_t *, size_t, size_t);
+extern ssize_t generic_file_buffered_write(struct kiocb *, const struct iovec *,
+  unsigned long, loff_t, loff_t *, size_t, ssize_t);
+extern ssize_t do_sync_read(struct file *filp, char *buf, size_t len, loff_t *ppos);
+extern ssize_t do_sync_write(struct file *filp, const char *buf, size_t len, loff_t *ppos);
+extern int generic_segment_checks(const struct iovec *iov,
+  unsigned long *nr_segs, size_t *count, int access_flags);
+extern ssize_t blkdev_aio_write(struct kiocb *iocb, const struct iovec *iov,
+    unsigned long nr_segs, loff_t pos);
+extern int block_fsync(struct file *filp, struct dentry *dentry, int datasync);
+extern ssize_t generic_file_splice_read(struct file *, loff_t *,
+  struct pipe_inode_info *, size_t, unsigned int);
+extern ssize_t default_file_splice_read(struct file *, loff_t *,
+  struct pipe_inode_info *, size_t, unsigned int);
+extern ssize_t generic_file_splice_write(struct pipe_inode_info *,
+  struct file *, loff_t *, size_t, unsigned int);
+extern ssize_t generic_splice_sendpage(struct pipe_inode_info *pipe,
+  struct file *out, loff_t *, size_t len, unsigned int flags);
+extern long do_splice_direct(struct file *in, loff_t *ppos, struct file *out,
+  size_t len, unsigned int flags);
+extern void
+file_ra_state_init(struct file_ra_state *ra, struct address_space *mapping);
+extern loff_t no_llseek(struct file *file, loff_t offset, int origin);
+extern loff_t generic_file_llseek(struct file *file, loff_t offset, int origin);
+extern loff_t generic_file_llseek_unlocked(struct file *file, loff_t offset,
+   int origin);
+extern int generic_file_open(struct inode * inode, struct file * filp);
+extern int nonseekable_open(struct inode * inode, struct file * filp);
+static inline __attribute__((always_inline)) int xip_truncate_page(struct address_space *mapping, loff_t from)
+{
+ return 0;
+}
+ssize_t __blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode,
+ struct block_device *bdev, const struct iovec *iov, loff_t offset,
+ unsigned long nr_segs, get_block_t get_block, dio_iodone_t end_io,
+ int lock_type);
+enum {
+ DIO_LOCKING = 1,
+ DIO_NO_LOCKING,
+ DIO_OWN_LOCKING,
+};
+static inline __attribute__((always_inline)) ssize_t blockdev_direct_IO(int rw, struct kiocb *iocb,
+ struct inode *inode, struct block_device *bdev, const struct iovec *iov,
+ loff_t offset, unsigned long nr_segs, get_block_t get_block,
+ dio_iodone_t end_io)
+{
+ return __blockdev_direct_IO(rw, iocb, inode, bdev, iov, offset,
+    nr_segs, get_block, end_io, DIO_LOCKING);
+}
+static inline __attribute__((always_inline)) ssize_t blockdev_direct_IO_no_locking(int rw, struct kiocb *iocb,
+ struct inode *inode, struct block_device *bdev, const struct iovec *iov,
+ loff_t offset, unsigned long nr_segs, get_block_t get_block,
+ dio_iodone_t end_io)
+{
+ return __blockdev_direct_IO(rw, iocb, inode, bdev, iov, offset,
+    nr_segs, get_block, end_io, DIO_NO_LOCKING);
+}
+static inline __attribute__((always_inline)) ssize_t blockdev_direct_IO_own_locking(int rw, struct kiocb *iocb,
+ struct inode *inode, struct block_device *bdev, const struct iovec *iov,
+ loff_t offset, unsigned long nr_segs, get_block_t get_block,
+ dio_iodone_t end_io)
+{
+ return __blockdev_direct_IO(rw, iocb, inode, bdev, iov, offset,
+    nr_segs, get_block, end_io, DIO_OWN_LOCKING);
+}
+extern const struct file_operations generic_ro_fops;
+extern int vfs_readlink(struct dentry *, char *, int, const char *);
+extern int vfs_follow_link(struct nameidata *, const char *);
+extern int page_readlink(struct dentry *, char *, int);
+extern void *page_follow_link_light(struct dentry *, struct nameidata *);
+extern void page_put_link(struct dentry *, struct nameidata *, void *);
+extern int __page_symlink(struct inode *inode, const char *symname, int len,
+  int nofs);
+extern int page_symlink(struct inode *inode, const char *symname, int len);
+extern const struct inode_operations page_symlink_inode_operations;
+extern int generic_readlink(struct dentry *, char *, int);
+extern void generic_fillattr(struct inode *, struct kstat *);
+extern int vfs_getattr(struct vfsmount *, struct dentry *, struct kstat *);
+void __inode_add_bytes(struct inode *inode, loff_t bytes);
+void inode_add_bytes(struct inode *inode, loff_t bytes);
+void inode_sub_bytes(struct inode *inode, loff_t bytes);
+loff_t inode_get_bytes(struct inode *inode);
+void inode_set_bytes(struct inode *inode, loff_t bytes);
+extern int vfs_readdir(struct file *, filldir_t, void *);
+extern int vfs_stat(char *, struct kstat *);
+extern int vfs_lstat(char *, struct kstat *);
+extern int vfs_fstat(unsigned int, struct kstat *);
+extern int vfs_fstatat(int , char *, struct kstat *, int);
+extern int do_vfs_ioctl(struct file *filp, unsigned int fd, unsigned int cmd,
+      unsigned long arg);
+extern int __generic_block_fiemap(struct inode *inode,
+      struct fiemap_extent_info *fieinfo, u64 start,
+      u64 len, get_block_t *get_block);
+extern int generic_block_fiemap(struct inode *inode,
+    struct fiemap_extent_info *fieinfo, u64 start,
+    u64 len, get_block_t *get_block);
+extern void get_filesystem(struct file_system_type *fs);
+extern void put_filesystem(struct file_system_type *fs);
+extern struct file_system_type *get_fs_type(const char *name);
+extern struct super_block *get_super(struct block_device *);
+extern struct super_block *get_active_super(struct block_device *bdev);
+extern struct super_block *user_get_super(dev_t);
+extern void drop_super(struct super_block *sb);
+extern int dcache_dir_open(struct inode *, struct file *);
+extern int dcache_dir_close(struct inode *, struct file *);
+extern loff_t dcache_dir_lseek(struct file *, loff_t, int);
+extern int dcache_readdir(struct file *, void *, filldir_t);
+extern int simple_getattr(struct vfsmount *, struct dentry *, struct kstat *);
+extern int simple_statfs(struct dentry *, struct kstatfs *);
+extern int simple_link(struct dentry *, struct inode *, struct dentry *);
+extern int simple_unlink(struct inode *, struct dentry *);
+extern int simple_rmdir(struct inode *, struct dentry *);
+extern int simple_rename(struct inode *, struct dentry *, struct inode *, struct dentry *);
+extern int simple_sync_file(struct file *, struct dentry *, int);
+extern int simple_empty(struct dentry *);
+extern int simple_readpage(struct file *file, struct page *page);
+extern int simple_prepare_write(struct file *file, struct page *page,
+   unsigned offset, unsigned to);
+extern int simple_write_begin(struct file *file, struct address_space *mapping,
+   loff_t pos, unsigned len, unsigned flags,
+   struct page **pagep, void **fsdata);
+extern int simple_write_end(struct file *file, struct address_space *mapping,
+   loff_t pos, unsigned len, unsigned copied,
+   struct page *page, void *fsdata);
+extern struct dentry *simple_lookup(struct inode *, struct dentry *, struct nameidata *);
+extern ssize_t generic_read_dir(struct file *, char *, size_t, loff_t *);
+extern const struct file_operations simple_dir_operations;
+extern const struct inode_operations simple_dir_inode_operations;
+struct tree_descr { char *name; const struct file_operations *ops; int mode; };
+struct dentry *d_alloc_name(struct dentry *, const char *);
+extern int simple_fill_super(struct super_block *, unsigned long, struct tree_descr *);
+extern int simple_pin_fs(struct file_system_type *, struct vfsmount **mount, int *count);
+extern void simple_release_fs(struct vfsmount **mount, int *count);
+extern ssize_t simple_read_from_buffer(void *to, size_t count,
+   loff_t *ppos, const void *from, size_t available);
+extern int simple_fsync(struct file *, struct dentry *, int);
+extern int inode_change_ok(const struct inode *, struct iattr *);
+extern int inode_newsize_ok(const struct inode *, loff_t offset);
+extern int inode_setattr(struct inode *, struct iattr *);
+extern void file_update_time(struct file *file);
+extern int generic_show_options(struct seq_file *m, struct vfsmount *mnt);
+extern void save_mount_options(struct super_block *sb, char *options);
+extern void replace_mount_options(struct super_block *sb, char *options);
+static inline __attribute__((always_inline)) ino_t parent_ino(struct dentry *dentry)
+{
+ ino_t res;
+ do { do { do { (current_thread_info()->preempt_count) += (1); } while (0); __asm__ __volatile__("": : :"memory"); } while (0); (void)0; (void)(&dentry->d_lock); } while (0);
+ res = dentry->d_parent->d_inode->i_ino;
+ do { do { do { __asm__ __volatile__("": : :"memory"); do { (current_thread_info()->preempt_count) -= (1); } while (0); } while (0); __asm__ __volatile__("": : :"memory"); do { if (__builtin_expect(!!(test_ti_thread_flag(current_thread_info(), 2)), 0)) preempt_schedule(); } while (0); } while (0); (void)0; (void)(&dentry->d_lock); } while (0);
+ return res;
+}
+struct simple_transaction_argresp {
+ ssize_t size;
+ char data[0];
+};
+char *simple_transaction_get(struct file *file, const char *buf,
+    size_t size);
+ssize_t simple_transaction_read(struct file *file, char *buf,
+    size_t size, loff_t *pos);
+int simple_transaction_release(struct inode *inode, struct file *file);
+void simple_transaction_set(struct file *file, size_t n);
+static inline __attribute__((always_inline)) void __attribute__((format(printf, 1, 2)))
+__simple_attr_check_format(const char *fmt, ...)
+{
+}
+int simple_attr_open(struct inode *inode, struct file *file,
+       int (*get)(void *, u64 *), int (*set)(void *, u64),
+       const char *fmt);
+int simple_attr_release(struct inode *inode, struct file *file);
+ssize_t simple_attr_read(struct file *file, char *buf,
+    size_t len, loff_t *ppos);
+ssize_t simple_attr_write(struct file *file, const char *buf,
+     size_t len, loff_t *ppos);
+struct ctl_table;
+int proc_nr_files(struct ctl_table *table, int write,
+    void *buffer, size_t *lenp, loff_t *ppos);
+int __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) __attribute__((no_instrument_function)) get_filesystem_list(char *buf);
+struct task_struct;
+extern int debug_locks;
+extern int debug_locks_silent;
+static inline __attribute__((always_inline)) int __debug_locks_off(void)
+{
+ return ((__typeof__(*(&debug_locks)))({ unsigned long __xchg__res; volatile void *__xchg_ptr = ((&debug_locks)); switch (sizeof(*(&debug_locks))) { case 4: __xchg__res = xchg_u32(__xchg_ptr, (unsigned long)(0)); break; case 1: __xchg__res = xchg_u8(__xchg_ptr, (unsigned long)(0)); break; default: __xchg_called_with_bad_pointer(); __xchg__res = (unsigned long)(0); break; } __xchg__res; }));
+}
+extern int debug_locks_off(void);
+struct task_struct;
+static inline __attribute__((always_inline)) void debug_show_all_locks(void)
+{
+}
+static inline __attribute__((always_inline)) void __debug_show_held_locks(struct task_struct *task)
+{
+}
+static inline __attribute__((always_inline)) void debug_show_held_locks(struct task_struct *task)
+{
+}
+static inline __attribute__((always_inline)) void
+debug_check_no_locks_freed(const void *from, unsigned long len)
+{
+}
+static inline __attribute__((always_inline)) void
+debug_check_no_locks_held(struct task_struct *task)
+{
+}
+struct mempolicy;
+struct anon_vma;
+struct file_ra_state;
+struct user_struct;
+struct writeback_control;
+struct rlimit;
+extern unsigned long max_mapnr;
+extern unsigned long num_physpages;
+extern unsigned long totalram_pages;
+extern void * high_memory;
+extern int page_cluster;
+extern int sysctl_legacy_va_layout;
+typedef struct { pgd_t pgd; } pud_t;
+static inline __attribute__((always_inline)) int pgd_none(pgd_t pgd) { return 0; }
+static inline __attribute__((always_inline)) int pgd_bad(pgd_t pgd) { return 0; }
+static inline __attribute__((always_inline)) int pgd_present(pgd_t pgd) { return 1; }
+static inline __attribute__((always_inline)) void pgd_clear(pgd_t *pgd) { }
+static inline __attribute__((always_inline)) pud_t * pud_offset(pgd_t * pgd, unsigned long address)
+{
+ return (pud_t *)pgd;
+}
+struct mm_struct;
+typedef struct { pud_t pud; } pmd_t;
+static inline __attribute__((always_inline)) int pud_none(pud_t pud) { return 0; }
+static inline __attribute__((always_inline)) int pud_bad(pud_t pud) { return 0; }
+static inline __attribute__((always_inline)) int pud_present(pud_t pud) { return 1; }
+static inline __attribute__((always_inline)) void pud_clear(pud_t *pud) { }
+static inline __attribute__((always_inline)) pmd_t * pmd_offset(pud_t * pud, unsigned long address)
+{
+ return (pmd_t *)pud;
+}
+static inline __attribute__((always_inline)) void pmd_free(struct mm_struct *mm, pmd_t *pmd)
+{
+}
+enum fixed_addresses {
+ FIX_CMAP_BEGIN,
+ FIX_CMAP_END = FIX_CMAP_BEGIN + 16 - 1,
+ FIX_UNCACHED,
+ __end_of_fixed_addresses
+};
+extern void __set_fixmap(enum fixed_addresses idx,
+    unsigned long phys, pgprot_t flags);
+extern void __this_fixmap_does_not_exist(void);
+static inline __attribute__((always_inline)) unsigned long fix_to_virt(const unsigned int idx)
+{
+ if (idx >= __end_of_fixed_addresses)
+  __this_fixmap_does_not_exist();
+        return ((0xe0000000 - ((1UL) << 12)) - ((idx) << 12));
+}
+static inline __attribute__((always_inline)) unsigned long virt_to_fix(const unsigned long vaddr)
+{
+ do { if (__builtin_expect(!!(vaddr >= (0xe0000000 - ((1UL) << 12)) || vaddr < ((0xe0000000 - ((1UL) << 12)) - (__end_of_fixed_addresses << 12))), 0)) do { __asm__ __volatile__ ( "1:\t.short %O0\n" "\t.pushsection __bug_table,\"a\"\n" "2:\t.long 1b\n" "\t.short %O3\n" "\t.org 2b+%O4\n" "\t.popsection\n" : : "n" (0xc33e), "i" ("/vob/stb_stcdidvb_sdk/kernel/stcdi_kernel/arch/sh/include/asm/fixmap.h"), "i" (120), "i" (0), "i" (sizeof(struct bug_entry))); } while (0); } while(0);
+ return (((0xe0000000 - ((1UL) << 12)) - ((vaddr)&(~(((1UL) << 12)-1)))) >> 12);
+}
+extern unsigned long empty_zero_page[((1UL) << 12) / sizeof(unsigned long)];
+static inline __attribute__((always_inline)) unsigned long long neff_sign_extend(unsigned long val)
+{
+ unsigned long long extended = val;
+ return (extended & (1LL << (32 - 1))) ? (extended | (-1LL << 32)) : extended;
+}
+static inline __attribute__((always_inline)) unsigned long copy_ptea_attributes(unsigned long x)
+{
+ return ((x >> 28) & 0xe) | (x & 0x1);
+}
+static inline __attribute__((always_inline)) pte_t pte_wrprotect(pte_t pte) { pte.pte_low &= ~0x020; return pte; };
+static inline __attribute__((always_inline)) pte_t pte_mkwrite(pte_t pte) { pte.pte_low |= 0x020; return pte; };
+static inline __attribute__((always_inline)) pte_t pte_mkhuge(pte_t pte) { pte.pte_low |= (0x010); return pte; };
+static inline __attribute__((always_inline)) pte_t pte_mkclean(pte_t pte) { pte.pte_low &= ~0x004; return pte; };
+static inline __attribute__((always_inline)) pte_t pte_mkdirty(pte_t pte) { pte.pte_low |= 0x004; return pte; };
+static inline __attribute__((always_inline)) pte_t pte_mkold(pte_t pte) { pte.pte_low &= ~0x400; return pte; };
+static inline __attribute__((always_inline)) pte_t pte_mkyoung(pte_t pte) { pte.pte_low |= 0x400; return pte; };
+static inline __attribute__((always_inline)) pte_t pte_mkspecial(pte_t pte) { pte.pte_low |= 0x800; return pte; };
+static inline __attribute__((always_inline)) pte_t pte_modify(pte_t pte, pgprot_t newprot)
+{
+ pte.pte_low &= ((~(((1UL) << 12)-1)) | 0x400 | 0x008 | 0x004 | 0x800);
+ pte.pte_low |= ((newprot).pgprot);
+ return pte;
+}
+typedef pte_t *pte_addr_t;
+struct vm_area_struct;
+extern void __update_cache(struct vm_area_struct *vma,
+      unsigned long address, pte_t pte);
+extern void __update_tlb(struct vm_area_struct *vma,
+    unsigned long address, pte_t pte);
+static inline __attribute__((always_inline)) void
+update_mmu_cache(struct vm_area_struct *vma, unsigned long address, pte_t pte)
+{
+ __update_cache(vma, address, pte);
+ __update_tlb(vma, address, pte);
+}
+extern pgd_t swapper_pg_dir[(((1UL) << 12) / sizeof(pgd_t))];
+extern void paging_init(void);
+extern void page_table_range_init(unsigned long start, unsigned long end,
+      pgd_t *pgd);
+struct mm_struct;
+static inline __attribute__((always_inline)) void ptep_set_wrprotect(struct mm_struct *mm, unsigned long address, pte_t *ptep)
+{
+ pte_t old_pte = *ptep;
+ (*(ptep) = pte_wrprotect(old_pte));
+}
+void pgd_clear_bad(pgd_t *);
+void pud_clear_bad(pud_t *);
+void pmd_clear_bad(pmd_t *);
+static inline __attribute__((always_inline)) int pgd_none_or_clear_bad(pgd_t *pgd)
+{
+ if (pgd_none(*pgd))
+  return 1;
+ if (__builtin_expect(!!(pgd_bad(*pgd)), 0)) {
+  pgd_clear_bad(pgd);
+  return 1;
+ }
+ return 0;
+}
+static inline __attribute__((always_inline)) int pud_none_or_clear_bad(pud_t *pud)
+{
+ if (pud_none(*pud))
+  return 1;
+ if (__builtin_expect(!!(pud_bad(*pud)), 0)) {
+  pud_clear_bad(pud);
+  return 1;
+ }
+ return 0;
+}
+static inline __attribute__((always_inline)) int pmd_none_or_clear_bad(pmd_t *pmd)
+{
+ if ((!((((((*pmd).pud).pgd).pgd)))))
+  return 1;
+ if (__builtin_expect(!!((((((((*pmd).pud).pgd).pgd))) & ~(~(((1UL) << 12)-1)))), 0)) {
+  pmd_clear_bad(pmd);
+  return 1;
+ }
+ return 0;
+}
+static inline __attribute__((always_inline)) pte_t __ptep_modify_prot_start(struct mm_struct *mm,
+          unsigned long addr,
+          pte_t *ptep)
+{
+ return ({ pte_t __pte = *(ptep); do { (*((ptep)) = ((pte_t) { (0) } )); } while (0); __pte; });
+}
+static inline __attribute__((always_inline)) void __ptep_modify_prot_commit(struct mm_struct *mm,
+          unsigned long addr,
+          pte_t *ptep, pte_t pte)
+{
+ (*(ptep) = pte);
+}
+static inline __attribute__((always_inline)) pte_t ptep_modify_prot_start(struct mm_struct *mm,
+        unsigned long addr,
+        pte_t *ptep)
+{
+ return __ptep_modify_prot_start(mm, addr, ptep);
+}
+static inline __attribute__((always_inline)) void ptep_modify_prot_commit(struct mm_struct *mm,
+        unsigned long addr,
+        pte_t *ptep, pte_t pte)
+{
+ __ptep_modify_prot_commit(mm, addr, ptep, pte);
+}
+static inline __attribute__((always_inline)) int track_pfn_vma_new(struct vm_area_struct *vma, pgprot_t *prot,
+     unsigned long pfn, unsigned long size)
+{
+ return 0;
+}
+static inline __attribute__((always_inline)) int track_pfn_vma_copy(struct vm_area_struct *vma)
+{
+ return 0;
+}
+static inline __attribute__((always_inline)) void untrack_pfn_vma(struct vm_area_struct *vma,
+     unsigned long pfn, unsigned long size)
+{
+}
+extern struct kmem_cache *vm_area_cachep;
+extern pgprot_t protection_map[16];
+static inline __attribute__((always_inline)) int is_linear_pfn_mapping(struct vm_area_struct *vma)
+{
+ return (vma->vm_flags & 0x40000000);
+}
+static inline __attribute__((always_inline)) int is_pfn_mapping(struct vm_area_struct *vma)
+{
+ return (vma->vm_flags & 0x00000400);
+}
+struct vm_fault {
+ unsigned int flags;
+ unsigned long pgoff;
+ void *virtual_address;
+ struct page *page;
+};
+struct vm_operations_struct {
+ void (*open)(struct vm_area_struct * area);
+ void (*close)(struct vm_area_struct * area);
+ int (*fault)(struct vm_area_struct *vma, struct vm_fault *vmf);
+ int (*page_mkwrite)(struct vm_area_struct *vma, struct vm_fault *vmf);
+ int (*access)(struct vm_area_struct *vma, unsigned long addr,
+        void *buf, int len, int write);
+};
+struct mmu_gather;
+struct inode;
+enum pageflags {
+ PG_locked,
+ PG_error,
+ PG_referenced,
+ PG_uptodate,
+ PG_dirty,
+ PG_lru,
+ PG_active,
+ PG_slab,
+ PG_owner_priv_1,
+ PG_arch_1,
+ PG_reserved,
+ PG_private,
+ PG_private_2,
+ PG_writeback,
+ PG_head,
+ PG_tail,
+ PG_swapcache,
+ PG_mappedtodisk,
+ PG_reclaim,
+ PG_buddy,
+ PG_swapbacked,
+ PG_unevictable,
+ PG_mlocked,
+ __NR_PAGEFLAGS,
+ PG_checked = PG_owner_priv_1,
+ PG_fscache = PG_private_2,
+ PG_pinned = PG_owner_priv_1,
+ PG_savepinned = PG_dirty,
+ PG_slob_free = PG_private,
+ PG_slub_frozen = PG_active,
+ PG_slub_debug = PG_error,
+};
+struct page;
+static inline __attribute__((always_inline)) int PageLocked(struct page *page) { return test_bit(PG_locked, &page->flags); } static inline __attribute__((always_inline)) int TestSetPageLocked(struct page *page) { return test_and_set_bit(PG_locked, &page->flags); }
+static inline __attribute__((always_inline)) int PageError(struct page *page) { return test_bit(PG_error, &page->flags); } static inline __attribute__((always_inline)) void SetPageError(struct page *page) { set_bit(PG_error, &page->flags); } static inline __attribute__((always_inline)) void ClearPageError(struct page *page) { clear_bit(PG_error, &page->flags); }
+static inline __attribute__((always_inline)) int PageReferenced(struct page *page) { return test_bit(PG_referenced, &page->flags); } static inline __attribute__((always_inline)) void SetPageReferenced(struct page *page) { set_bit(PG_referenced, &page->flags); } static inline __attribute__((always_inline)) void ClearPageReferenced(struct page *page) { clear_bit(PG_referenced, &page->flags); } static inline __attribute__((always_inline)) int TestClearPageReferenced(struct page *page) { return test_and_clear_bit(PG_referenced, &page->flags); }
+static inline __attribute__((always_inline)) int PageDirty(struct page *page) { return test_bit(PG_dirty, &page->flags); } static inline __attribute__((always_inline)) void SetPageDirty(struct page *page) { set_bit(PG_dirty, &page->flags); } static inline __attribute__((always_inline)) void ClearPageDirty(struct page *page) { clear_bit(PG_dirty, &page->flags); } static inline __attribute__((always_inline)) int TestSetPageDirty(struct page *page) { return test_and_set_bit(PG_dirty, &page->flags); } static inline __attribute__((always_inline)) int TestClearPageDirty(struct page *page) { return test_and_clear_bit(PG_dirty, &page->flags); } static inline __attribute__((always_inline)) void __ClearPageDirty(struct page *page) { __clear_bit(PG_dirty, &page->flags); }
+static inline __attribute__((always_inline)) int PageLRU(struct page *page) { return test_bit(PG_lru, &page->flags); } static inline __attribute__((always_inline)) void SetPageLRU(struct page *page) { set_bit(PG_lru, &page->flags); } static inline __attribute__((always_inline)) void ClearPageLRU(struct page *page) { clear_bit(PG_lru, &page->flags); } static inline __attribute__((always_inline)) void __ClearPageLRU(struct page *page) { __clear_bit(PG_lru, &page->flags); }
+static inline __attribute__((always_inline)) int PageActive(struct page *page) { return test_bit(PG_active, &page->flags); } static inline __attribute__((always_inline)) void SetPageActive(struct page *page) { set_bit(PG_active, &page->flags); } static inline __attribute__((always_inline)) void ClearPageActive(struct page *page) { clear_bit(PG_active, &page->flags); } static inline __attribute__((always_inline)) void __ClearPageActive(struct page *page) { __clear_bit(PG_active, &page->flags); }
+ static inline __attribute__((always_inline)) int TestClearPageActive(struct page *page) { return test_and_clear_bit(PG_active, &page->flags); }
+static inline __attribute__((always_inline)) int PageSlab(struct page *page) { return test_bit(PG_slab, &page->flags); } static inline __attribute__((always_inline)) void __SetPageSlab(struct page *page) { __set_bit(PG_slab, &page->flags); } static inline __attribute__((always_inline)) void __ClearPageSlab(struct page *page) { __clear_bit(PG_slab, &page->flags); }
+static inline __attribute__((always_inline)) int PageChecked(struct page *page) { return test_bit(PG_checked, &page->flags); } static inline __attribute__((always_inline)) void SetPageChecked(struct page *page) { set_bit(PG_checked, &page->flags); } static inline __attribute__((always_inline)) void ClearPageChecked(struct page *page) { clear_bit(PG_checked, &page->flags); }
+static inline __attribute__((always_inline)) int PagePinned(struct page *page) { return test_bit(PG_pinned, &page->flags); } static inline __attribute__((always_inline)) void SetPagePinned(struct page *page) { set_bit(PG_pinned, &page->flags); } static inline __attribute__((always_inline)) void ClearPagePinned(struct page *page) { clear_bit(PG_pinned, &page->flags); } static inline __attribute__((always_inline)) int TestSetPagePinned(struct page *page) { return test_and_set_bit(PG_pinned, &page->flags); } static inline __attribute__((always_inline)) int TestClearPagePinned(struct page *page) { return test_and_clear_bit(PG_pinned, &page->flags); }
+static inline __attribute__((always_inline)) int PageSavePinned(struct page *page) { return test_bit(PG_savepinned, &page->flags); } static inline __attribute__((always_inline)) void SetPageSavePinned(struct page *page) { set_bit(PG_savepinned, &page->flags); } static inline __attribute__((always_inline)) void ClearPageSavePinned(struct page *page) { clear_bit(PG_savepinned, &page->flags); };
+static inline __attribute__((always_inline)) int PageReserved(struct page *page) { return test_bit(PG_reserved, &page->flags); } static inline __attribute__((always_inline)) void SetPageReserved(struct page *page) { set_bit(PG_reserved, &page->flags); } static inline __attribute__((always_inline)) void ClearPageReserved(struct page *page) { clear_bit(PG_reserved, &page->flags); } static inline __attribute__((always_inline)) void __ClearPageReserved(struct page *page) { __clear_bit(PG_reserved, &page->flags); }
+static inline __attribute__((always_inline)) int PageSwapBacked(struct page *page) { return test_bit(PG_swapbacked, &page->flags); } static inline __attribute__((always_inline)) void SetPageSwapBacked(struct page *page) { set_bit(PG_swapbacked, &page->flags); } static inline __attribute__((always_inline)) void ClearPageSwapBacked(struct page *page) { clear_bit(PG_swapbacked, &page->flags); } static inline __attribute__((always_inline)) void __ClearPageSwapBacked(struct page *page) { __clear_bit(PG_swapbacked, &page->flags); }
+static inline __attribute__((always_inline)) int PageSlobFree(struct page *page) { return test_bit(PG_slob_free, &page->flags); } static inline __attribute__((always_inline)) void __SetPageSlobFree(struct page *page) { __set_bit(PG_slob_free, &page->flags); } static inline __attribute__((always_inline)) void __ClearPageSlobFree(struct page *page) { __clear_bit(PG_slob_free, &page->flags); }
+static inline __attribute__((always_inline)) int PageSlubFrozen(struct page *page) { return test_bit(PG_slub_frozen, &page->flags); } static inline __attribute__((always_inline)) void __SetPageSlubFrozen(struct page *page) { __set_bit(PG_slub_frozen, &page->flags); } static inline __attribute__((always_inline)) void __ClearPageSlubFrozen(struct page *page) { __clear_bit(PG_slub_frozen, &page->flags); }
+static inline __attribute__((always_inline)) int PageSlubDebug(struct page *page) { return test_bit(PG_slub_debug, &page->flags); } static inline __attribute__((always_inline)) void __SetPageSlubDebug(struct page *page) { __set_bit(PG_slub_debug, &page->flags); } static inline __attribute__((always_inline)) void __ClearPageSlubDebug(struct page *page) { __clear_bit(PG_slub_debug, &page->flags); }
+static inline __attribute__((always_inline)) int PagePrivate(struct page *page) { return test_bit(PG_private, &page->flags); } static inline __attribute__((always_inline)) void SetPagePrivate(struct page *page) { set_bit(PG_private, &page->flags); } static inline __attribute__((always_inline)) void ClearPagePrivate(struct page *page) { clear_bit(PG_private, &page->flags); } static inline __attribute__((always_inline)) void __SetPagePrivate(struct page *page) { __set_bit(PG_private, &page->flags); }
+ static inline __attribute__((always_inline)) void __ClearPagePrivate(struct page *page) { __clear_bit(PG_private, &page->flags); }
+static inline __attribute__((always_inline)) int PagePrivate2(struct page *page) { return test_bit(PG_private_2, &page->flags); } static inline __attribute__((always_inline)) void SetPagePrivate2(struct page *page) { set_bit(PG_private_2, &page->flags); } static inline __attribute__((always_inline)) void ClearPagePrivate2(struct page *page) { clear_bit(PG_private_2, &page->flags); } static inline __attribute__((always_inline)) int TestSetPagePrivate2(struct page *page) { return test_and_set_bit(PG_private_2, &page->flags); } static inline __attribute__((always_inline)) int TestClearPagePrivate2(struct page *page) { return test_and_clear_bit(PG_private_2, &page->flags); }
+static inline __attribute__((always_inline)) int PageOwnerPriv1(struct page *page) { return test_bit(PG_owner_priv_1, &page->flags); } static inline __attribute__((always_inline)) void SetPageOwnerPriv1(struct page *page) { set_bit(PG_owner_priv_1, &page->flags); } static inline __attribute__((always_inline)) void ClearPageOwnerPriv1(struct page *page) { clear_bit(PG_owner_priv_1, &page->flags); } static inline __attribute__((always_inline)) int TestClearPageOwnerPriv1(struct page *page) { return test_and_clear_bit(PG_owner_priv_1, &page->flags); }
+static inline __attribute__((always_inline)) int PageWriteback(struct page *page) { return test_bit(PG_writeback, &page->flags); } static inline __attribute__((always_inline)) int TestSetPageWriteback(struct page *page) { return test_and_set_bit(PG_writeback, &page->flags); } static inline __attribute__((always_inline)) int TestClearPageWriteback(struct page *page) { return test_and_clear_bit(PG_writeback, &page->flags); }
+static inline __attribute__((always_inline)) int PageBuddy(struct page *page) { return test_bit(PG_buddy, &page->flags); } static inline __attribute__((always_inline)) void __SetPageBuddy(struct page *page) { __set_bit(PG_buddy, &page->flags); } static inline __attribute__((always_inline)) void __ClearPageBuddy(struct page *page) { __clear_bit(PG_buddy, &page->flags); }
+static inline __attribute__((always_inline)) int PageMappedToDisk(struct page *page) { return test_bit(PG_mappedtodisk, &page->flags); } static inline __attribute__((always_inline)) void SetPageMappedToDisk(struct page *page) { set_bit(PG_mappedtodisk, &page->flags); } static inline __attribute__((always_inline)) void ClearPageMappedToDisk(struct page *page) { clear_bit(PG_mappedtodisk, &page->flags); }
+static inline __attribute__((always_inline)) int PageReclaim(struct page *page) { return test_bit(PG_reclaim, &page->flags); } static inline __attribute__((always_inline)) void SetPageReclaim(struct page *page) { set_bit(PG_reclaim, &page->flags); } static inline __attribute__((always_inline)) void ClearPageReclaim(struct page *page) { clear_bit(PG_reclaim, &page->flags); } static inline __attribute__((always_inline)) int TestClearPageReclaim(struct page *page) { return test_and_clear_bit(PG_reclaim, &page->flags); }
+static inline __attribute__((always_inline)) int PageReadahead(struct page *page) { return test_bit(PG_reclaim, &page->flags); } static inline __attribute__((always_inline)) void SetPageReadahead(struct page *page) { set_bit(PG_reclaim, &page->flags); } static inline __attribute__((always_inline)) void ClearPageReadahead(struct page *page) { clear_bit(PG_reclaim, &page->flags); }
+static inline __attribute__((always_inline)) int PageHighMem(struct page *page) { return 0; }
+static inline __attribute__((always_inline)) int PageSwapCache(struct page *page) { return test_bit(PG_swapcache, &page->flags); } static inline __attribute__((always_inline)) void SetPageSwapCache(struct page *page) { set_bit(PG_swapcache, &page->flags); } static inline __attribute__((always_inline)) void ClearPageSwapCache(struct page *page) { clear_bit(PG_swapcache, &page->flags); }
+static inline __attribute__((always_inline)) int PageUnevictable(struct page *page) { return test_bit(PG_unevictable, &page->flags); } static inline __attribute__((always_inline)) void SetPageUnevictable(struct page *page) { set_bit(PG_unevictable, &page->flags); } static inline __attribute__((always_inline)) void ClearPageUnevictable(struct page *page) { clear_bit(PG_unevictable, &page->flags); } static inline __attribute__((always_inline)) void __ClearPageUnevictable(struct page *page) { __clear_bit(PG_unevictable, &page->flags); }
+ static inline __attribute__((always_inline)) int TestClearPageUnevictable(struct page *page) { return test_and_clear_bit(PG_unevictable, &page->flags); }
+static inline __attribute__((always_inline)) int PageMlocked(struct page *page) { return test_bit(PG_mlocked, &page->flags); } static inline __attribute__((always_inline)) void SetPageMlocked(struct page *page) { set_bit(PG_mlocked, &page->flags); } static inline __attribute__((always_inline)) void ClearPageMlocked(struct page *page) { clear_bit(PG_mlocked, &page->flags); } static inline __attribute__((always_inline)) void __ClearPageMlocked(struct page *page) { __clear_bit(PG_mlocked, &page->flags); }
+ static inline __attribute__((always_inline)) int TestSetPageMlocked(struct page *page) { return test_and_set_bit(PG_mlocked, &page->flags); } static inline __attribute__((always_inline)) int TestClearPageMlocked(struct page *page) { return test_and_clear_bit(PG_mlocked, &page->flags); } static inline __attribute__((always_inline)) int __TestClearPageMlocked(struct page *page) { return __test_and_clear_bit(PG_mlocked, &page->flags); }
+static inline __attribute__((always_inline)) int PageUncached(struct page *page) { return 0; }
+static inline __attribute__((always_inline)) int PageHWPoison(struct page *page) { return 0; }
+static inline __attribute__((always_inline)) int PageUptodate(struct page *page)
+{
+ int ret = test_bit(PG_uptodate, &(page)->flags);
+ if (ret)
+  __asm__ __volatile__("": : :"memory");
+ return ret;
+}
+static inline __attribute__((always_inline)) void __SetPageUptodate(struct page *page)
+{
+ __asm__ __volatile__("": : :"memory");
+ __set_bit(PG_uptodate, &(page)->flags);
+}
+static inline __attribute__((always_inline)) void SetPageUptodate(struct page *page)
+{
+ __asm__ __volatile__("": : :"memory");
+ set_bit(PG_uptodate, &(page)->flags);
+}
+static inline __attribute__((always_inline)) void ClearPageUptodate(struct page *page) { clear_bit(PG_uptodate, &page->flags); }
+extern void cancel_dirty_page(struct page *page, unsigned int account_size);
+int test_clear_page_writeback(struct page *page);
+int test_set_page_writeback(struct page *page);
+static inline __attribute__((always_inline)) void set_page_writeback(struct page *page)
+{
+ test_set_page_writeback(page);
+}
+static inline __attribute__((always_inline)) int PageHead(struct page *page) { return test_bit(PG_head, &page->flags); } static inline __attribute__((always_inline)) void __SetPageHead(struct page *page) { __set_bit(PG_head, &page->flags); } static inline __attribute__((always_inline)) void __ClearPageHead(struct page *page) { __clear_bit(PG_head, &page->flags); }
+static inline __attribute__((always_inline)) int PageTail(struct page *page) { return test_bit(PG_tail, &page->flags); } static inline __attribute__((always_inline)) void __SetPageTail(struct page *page) { __set_bit(PG_tail, &page->flags); } static inline __attribute__((always_inline)) void __ClearPageTail(struct page *page) { __clear_bit(PG_tail, &page->flags); }
+static inline __attribute__((always_inline)) int PageCompound(struct page *page)
+{
+ return page->flags & ((1L << PG_head) | (1L << PG_tail));
+}
+static inline __attribute__((always_inline)) int page_has_private(struct page *page)
+{
+ return !!(page->flags & (1 << PG_private | 1 << PG_private_2));
+}
+static inline __attribute__((always_inline)) int put_page_testzero(struct page *page)
+{
+ do { } while (0);
+ return (atomic_sub_return(1, (&page->_count)) == 0);
+}
+static inline __attribute__((always_inline)) int get_page_unless_zero(struct page *page)
+{
+ return atomic_add_unless((&page->_count), 1, 0);
+}
+struct page *vmalloc_to_page(const void *addr);
+unsigned long vmalloc_to_pfn(const void *addr);
+static inline __attribute__((always_inline)) int is_vmalloc_addr(const void *x)
+{
+ unsigned long addr = (unsigned long)x;
+ return addr >= (0xc0000000 +0x01000000) && addr < (((0xe0000000 - ((1UL) << 12)) - (__end_of_fixed_addresses << 12))-2*((1UL) << 12));
+}
+extern int is_vmalloc_or_module_addr(const void *x);
+static inline __attribute__((always_inline)) struct page *compound_head(struct page *page)
+{
+ if (__builtin_expect(!!(PageTail(page)), 0))
+  return page->first_page;
+ return page;
+}
+static inline __attribute__((always_inline)) int page_count(struct page *page)
+{
+ return ((&compound_head(page)->_count)->counter);
+}
+static inline __attribute__((always_inline)) void get_page(struct page *page)
+{
+ page = compound_head(page);
+ do { } while (0);
+ atomic_add(1,(&page->_count));
+}
+static inline __attribute__((always_inline)) struct page *virt_to_head_page(const void *x)
+{
+ struct page *page = (mem_map + ((((unsigned long)(x)-0x80000000 +0x0) >> 12) - ((0x0 >> 12))));
+ return compound_head(page);
+}
+static inline __attribute__((always_inline)) void init_page_count(struct page *page)
+{
+ ((&page->_count)->counter = (1));
+}
+void put_page(struct page *page);
+void put_pages_list(struct list_head *pages);
+void split_page(struct page *page, unsigned int order);
+typedef void compound_page_dtor(struct page *);
+static inline __attribute__((always_inline)) void set_compound_page_dtor(struct page *page,
+      compound_page_dtor *dtor)
+{
+ page[1].lru.next = (void *)dtor;
+}
+static inline __attribute__((always_inline)) compound_page_dtor *get_compound_page_dtor(struct page *page)
+{
+ return (compound_page_dtor *)page[1].lru.next;
+}
+static inline __attribute__((always_inline)) int compound_order(struct page *page)
+{
+ if (!PageHead(page))
+  return 0;
+ return (unsigned long)page[1].lru.prev;
+}
+static inline __attribute__((always_inline)) void set_compound_order(struct page *page, unsigned long order)
+{
+ page[1].lru.prev = (void *)order;
+}
+static inline __attribute__((always_inline)) enum zone_type page_zonenum(struct page *page)
+{
+ return (page->flags >> (((((sizeof(unsigned long)*8) - 0) - 0) - 1) * (1 != 0))) & ((1UL << 1) - 1);
+}
+static inline __attribute__((always_inline)) int page_zone_id(struct page *page)
+{
+ return (page->flags >> ((((((sizeof(unsigned long)*8) - 0) - 0) < ((((sizeof(unsigned long)*8) - 0) - 0) - 1))? (((sizeof(unsigned long)*8) - 0) - 0) : ((((sizeof(unsigned long)*8) - 0) - 0) - 1)) * ((0 + 1) != 0))) & ((1UL << (0 + 1)) - 1);
+}
+static inline __attribute__((always_inline)) int zone_to_nid(struct zone *zone)
+{
+ return 0;
+}
+static inline __attribute__((always_inline)) int page_to_nid(struct page *page)
+{
+ return (page->flags >> ((((sizeof(unsigned long)*8) - 0) - 0) * (0 != 0))) & ((1UL << 0) - 1);
+}
+static inline __attribute__((always_inline)) struct zone *page_zone(struct page *page)
+{
+ return &(&contig_page_data)->node_zones[page_zonenum(page)];
+}
+static inline __attribute__((always_inline)) void set_page_zone(struct page *page, enum zone_type zone)
+{
+ page->flags &= ~(((1UL << 1) - 1) << (((((sizeof(unsigned long)*8) - 0) - 0) - 1) * (1 != 0)));
+ page->flags |= (zone & ((1UL << 1) - 1)) << (((((sizeof(unsigned long)*8) - 0) - 0) - 1) * (1 != 0));
+}
+static inline __attribute__((always_inline)) void set_page_node(struct page *page, unsigned long node)
+{
+ page->flags &= ~(((1UL << 0) - 1) << ((((sizeof(unsigned long)*8) - 0) - 0) * (0 != 0)));
+ page->flags |= (node & ((1UL << 0) - 1)) << ((((sizeof(unsigned long)*8) - 0) - 0) * (0 != 0));
+}
+static inline __attribute__((always_inline)) void set_page_section(struct page *page, unsigned long section)
+{
+ page->flags &= ~(((1UL << 0) - 1) << (((sizeof(unsigned long)*8) - 0) * (0 != 0)));
+ page->flags |= (section & ((1UL << 0) - 1)) << (((sizeof(unsigned long)*8) - 0) * (0 != 0));
+}
+static inline __attribute__((always_inline)) void set_page_links(struct page *page, enum zone_type zone,
+ unsigned long node, unsigned long pfn)
+{
+ set_page_zone(page, zone);
+ set_page_node(page, node);
+ set_page_section(page, ((pfn) >> 0));
+}
+enum vm_event_item { PGPGIN, PGPGOUT, PSWPIN, PSWPOUT,
+  PGALLOC_NORMAL , PGALLOC_MOVABLE,
+  PGFREE, PGACTIVATE, PGDEACTIVATE,
+  PGFAULT, PGMAJFAULT,
+  PGREFILL_NORMAL , PGREFILL_MOVABLE,
+  PGSTEAL_NORMAL , PGSTEAL_MOVABLE,
+  PGSCAN_KSWAPD_NORMAL , PGSCAN_KSWAPD_MOVABLE,
+  PGSCAN_DIRECT_NORMAL , PGSCAN_DIRECT_MOVABLE,
+  PGINODESTEAL, SLABS_SCANNED, KSWAPD_STEAL, KSWAPD_INODESTEAL,
+  PAGEOUTRUN, ALLOCSTALL, PGROTATED,
+  UNEVICTABLE_PGCULLED,
+  UNEVICTABLE_PGSCANNED,
+  UNEVICTABLE_PGRESCUED,
+  UNEVICTABLE_PGMLOCKED,
+  UNEVICTABLE_PGMUNLOCKED,
+  UNEVICTABLE_PGCLEARED,
+  UNEVICTABLE_PGSTRANDED,
+  UNEVICTABLE_MLOCKFREED,
+  NR_VM_EVENT_ITEMS
+};
+extern int sysctl_stat_interval;
+struct vm_event_state {
+ unsigned long event[NR_VM_EVENT_ITEMS];
+};
+extern __attribute__((section(".data" ""))) __typeof__(struct vm_event_state) per_cpu__vm_event_states;
+static inline __attribute__((always_inline)) void __count_vm_event(enum vm_event_item item)
+{
+ per_cpu__vm_event_states.event[item]++;
+}
+static inline __attribute__((always_inline)) void count_vm_event(enum vm_event_item item)
+{
+ (*({ extern int simple_identifier_vm_event_states(void); do { do { (current_thread_info()->preempt_count) += (1); } while (0); __asm__ __volatile__("": : :"memory"); } while (0); &per_cpu__vm_event_states; })).event[item]++;
+ do { do { __asm__ __volatile__("": : :"memory"); do { (current_thread_info()->preempt_count) -= (1); } while (0); } while (0); __asm__ __volatile__("": : :"memory"); do { if (__builtin_expect(!!(test_ti_thread_flag(current_thread_info(), 2)), 0)) preempt_schedule(); } while (0); } while (0);
+}
+static inline __attribute__((always_inline)) void __count_vm_events(enum vm_event_item item, long delta)
+{
+ per_cpu__vm_event_states.event[item] += delta;
+}
+static inline __attribute__((always_inline)) void count_vm_events(enum vm_event_item item, long delta)
+{
+ (*({ extern int simple_identifier_vm_event_states(void); do { do { (current_thread_info()->preempt_count) += (1); } while (0); __asm__ __volatile__("": : :"memory"); } while (0); &per_cpu__vm_event_states; })).event[item] += delta;
+ do { do { __asm__ __volatile__("": : :"memory"); do { (current_thread_info()->preempt_count) -= (1); } while (0); } while (0); __asm__ __volatile__("": : :"memory"); do { if (__builtin_expect(!!(test_ti_thread_flag(current_thread_info(), 2)), 0)) preempt_schedule(); } while (0); } while (0);
+}
+extern void all_vm_events(unsigned long *);
+extern void vm_events_fold_cpu(int cpu);
+extern atomic_long_t vm_stat[NR_VM_ZONE_STAT_ITEMS];
+static inline __attribute__((always_inline)) void zone_page_state_add(long x, struct zone *zone,
+     enum zone_stat_item item)
+{
+ atomic_long_add(x, &zone->vm_stat[item]);
+ atomic_long_add(x, &vm_stat[item]);
+}
+static inline __attribute__((always_inline)) unsigned long global_page_state(enum zone_stat_item item)
+{
+ long x = atomic_long_read(&vm_stat[item]);
+ return x;
+}
+static inline __attribute__((always_inline)) unsigned long zone_page_state(struct zone *zone,
+     enum zone_stat_item item)
+{
+ long x = atomic_long_read(&zone->vm_stat[item]);
+ return x;
+}
+extern unsigned long global_reclaimable_pages(void);
+extern unsigned long zone_reclaimable_pages(struct zone *zone);
+static inline __attribute__((always_inline)) void zap_zone_vm_stats(struct zone *zone)
+{
+ memset(zone->vm_stat, 0, sizeof(zone->vm_stat));
+}
+extern void inc_zone_state(struct zone *, enum zone_stat_item);
+static inline __attribute__((always_inline)) void __mod_zone_page_state(struct zone *zone,
+   enum zone_stat_item item, int delta)
+{
+ zone_page_state_add(delta, zone, item);
+}
+static inline __attribute__((always_inline)) void __inc_zone_state(struct zone *zone, enum zone_stat_item item)
+{
+ atomic_long_inc(&zone->vm_stat[item]);
+ atomic_long_inc(&vm_stat[item]);
+}
+static inline __attribute__((always_inline)) void __inc_zone_page_state(struct page *page,
+   enum zone_stat_item item)
+{
+ __inc_zone_state(page_zone(page), item);
+}
+static inline __attribute__((always_inline)) void __dec_zone_state(struct zone *zone, enum zone_stat_item item)
+{
+ atomic_long_dec(&zone->vm_stat[item]);
+ atomic_long_dec(&vm_stat[item]);
+}
+static inline __attribute__((always_inline)) void __dec_zone_page_state(struct page *page,
+   enum zone_stat_item item)
+{
+ __dec_zone_state(page_zone(page), item);
+}
+static inline __attribute__((always_inline)) void refresh_cpu_vm_stats(int cpu) { }
+static inline __attribute__((always_inline)) __attribute__((always_inline)) void *lowmem_page_address(struct page *page)
+{
+ return ((void *)((unsigned long)(((unsigned long)((page) - mem_map) + ((0x0 >> 12))) << 12)+0x80000000 -0x0));
+}
+extern struct address_space swapper_space;
+static inline __attribute__((always_inline)) struct address_space *page_mapping(struct page *page)
+{
+ struct address_space *mapping = page->mapping;
+ do { } while (0);
+ if (__builtin_expect(!!(PageSwapCache(page)), 0))
+  mapping = &swapper_space;
+ else
+ if (__builtin_expect(!!((unsigned long)mapping & 1), 0))
+  mapping = ((void *)0);
+ return mapping;
+}
+static inline __attribute__((always_inline)) int PageAnon(struct page *page)
+{
+ return ((unsigned long)page->mapping & 1) != 0;
+}
+static inline __attribute__((always_inline)) unsigned long page_index(struct page *page)
+{
+ if (__builtin_expect(!!(PageSwapCache(page)), 0))
+  return ((page)->private);
+ return page->index;
+}
+static inline __attribute__((always_inline)) void reset_page_mapcount(struct page *page)
+{
+ ((&(page)->_mapcount)->counter = (-1));
+}
+static inline __attribute__((always_inline)) int page_mapcount(struct page *page)
+{
+ return ((&(page)->_mapcount)->counter) + 1;
+}
+static inline __attribute__((always_inline)) int page_mapped(struct page *page)
+{
+ return ((&(page)->_mapcount)->counter) >= 0;
+}
+extern void pagefault_out_of_memory(void);
+extern void show_free_areas(void);
+int shmem_lock(struct file *file, int lock, struct user_struct *user);
+struct file *shmem_file_setup(const char *name, loff_t size, unsigned long flags);
+int shmem_zero_setup(struct vm_area_struct *);
+extern int can_do_mlock(void);
+extern int user_shm_lock(size_t, struct user_struct *);
+extern void user_shm_unlock(size_t, struct user_struct *);
+struct zap_details {
+ struct vm_area_struct *nonlinear_vma;
+ struct address_space *check_mapping;
+ unsigned long first_index;
+ unsigned long last_index;
+ spinlock_t *i_mmap_lock;
+ unsigned long truncate_count;
+};
+struct page *vm_normal_page(struct vm_area_struct *vma, unsigned long addr,
+  pte_t pte);
+int zap_vma_ptes(struct vm_area_struct *vma, unsigned long address,
+  unsigned long size);
+unsigned long zap_page_range(struct vm_area_struct *vma, unsigned long address,
+  unsigned long size, struct zap_details *);
+unsigned long unmap_vmas(struct mmu_gather **tlb,
+  struct vm_area_struct *start_vma, unsigned long start_addr,
+  unsigned long end_addr, unsigned long *nr_accounted,
+  struct zap_details *);
+struct mm_walk {
+ int (*pgd_entry)(pgd_t *, unsigned long, unsigned long, struct mm_walk *);
+ int (*pud_entry)(pud_t *, unsigned long, unsigned long, struct mm_walk *);
+ int (*pmd_entry)(pmd_t *, unsigned long, unsigned long, struct mm_walk *);
+ int (*pte_entry)(pte_t *, unsigned long, unsigned long, struct mm_walk *);
+ int (*pte_hole)(unsigned long, unsigned long, struct mm_walk *);
+ struct mm_struct *mm;
+ void *private;
+};
+int walk_page_range(unsigned long addr, unsigned long end,
+  struct mm_walk *walk);
+void free_pgd_range(struct mmu_gather *tlb, unsigned long addr,
+  unsigned long end, unsigned long floor, unsigned long ceiling);
+int copy_page_range(struct mm_struct *dst, struct mm_struct *src,
+   struct vm_area_struct *vma);
+void unmap_mapping_range(struct address_space *mapping,
+  loff_t const holebegin, loff_t const holelen, int even_cows);
+int follow_pfn(struct vm_area_struct *vma, unsigned long address,
+ unsigned long *pfn);
+int follow_phys(struct vm_area_struct *vma, unsigned long address,
+  unsigned int flags, unsigned long *prot, resource_size_t *phys);
+int generic_access_phys(struct vm_area_struct *vma, unsigned long addr,
+   void *buf, int len, int write);
+static inline __attribute__((always_inline)) void unmap_shared_mapping_range(struct address_space *mapping,
+  loff_t const holebegin, loff_t const holelen)
+{
+ unmap_mapping_range(mapping, holebegin, holelen, 0);
+}
+extern void truncate_pagecache(struct inode *inode, loff_t old, loff_t new);
+extern int vmtruncate(struct inode *inode, loff_t offset);
+extern int vmtruncate_range(struct inode *inode, loff_t offset, loff_t end);
+int truncate_inode_page(struct address_space *mapping, struct page *page);
+int generic_error_remove_page(struct address_space *mapping, struct page *page);
+int invalidate_inode_page(struct page *page);
+extern int handle_mm_fault(struct mm_struct *mm, struct vm_area_struct *vma,
+   unsigned long address, unsigned int flags);
+extern int make_pages_present(unsigned long addr, unsigned long end);
+extern int access_process_vm(struct task_struct *tsk, unsigned long addr, void *buf, int len, int write);
+int get_user_pages(struct task_struct *tsk, struct mm_struct *mm,
+   unsigned long start, int nr_pages, int write, int force,
+   struct page **pages, struct vm_area_struct **vmas);
+int get_user_pages_fast(unsigned long start, int nr_pages, int write,
+   struct page **pages);
+struct page *get_dump_page(unsigned long addr);
+extern int try_to_release_page(struct page * page, gfp_t gfp_mask);
+extern void do_invalidatepage(struct page *page, unsigned long offset);
+int __set_page_dirty_nobuffers(struct page *page);
+int __set_page_dirty_no_writeback(struct page *page);
+int redirty_page_for_writepage(struct writeback_control *wbc,
+    struct page *page);
+void account_page_dirtied(struct page *page, struct address_space *mapping);
+int set_page_dirty(struct page *page);
+int set_page_dirty_lock(struct page *page);
+int clear_page_dirty_for_io(struct page *page);
+extern unsigned long move_page_tables(struct vm_area_struct *vma,
+  unsigned long old_addr, struct vm_area_struct *new_vma,
+  unsigned long new_addr, unsigned long len);
+extern unsigned long do_mremap(unsigned long addr,
+          unsigned long old_len, unsigned long new_len,
+          unsigned long flags, unsigned long new_addr);
+extern int mprotect_fixup(struct vm_area_struct *vma,
+     struct vm_area_struct **pprev, unsigned long start,
+     unsigned long end, unsigned long newflags);
+int __get_user_pages_fast(unsigned long start, int nr_pages, int write,
+     struct page **pages);
+struct shrinker {
+ int (*shrink)(int nr_to_scan, gfp_t gfp_mask);
+ int seeks;
+ struct list_head list;
+ long nr;
+};
+extern void register_shrinker(struct shrinker *);
+extern void unregister_shrinker(struct shrinker *);
+int vma_wants_writenotify(struct vm_area_struct *vma);
+extern pte_t *get_locked_pte(struct mm_struct *mm, unsigned long addr, spinlock_t **ptl);
+static inline __attribute__((always_inline)) int __pud_alloc(struct mm_struct *mm, pgd_t *pgd,
+      unsigned long address)
+{
+ return 0;
+}
+static inline __attribute__((always_inline)) int __pmd_alloc(struct mm_struct *mm, pud_t *pud,
+      unsigned long address)
+{
+ return 0;
+}
+int __pte_alloc(struct mm_struct *mm, pmd_t *pmd, unsigned long address);
+int __pte_alloc_kernel(pmd_t *pmd, unsigned long address);
+static inline __attribute__((always_inline)) pud_t *pud_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address)
+{
+ return (__builtin_expect(!!(pgd_none(*pgd)), 0) && __pud_alloc(mm, pgd, address))?
+  ((void *)0): pud_offset(pgd, address);
+}
+static inline __attribute__((always_inline)) pmd_t *pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)
+{
+ return (__builtin_expect(!!(pud_none(*pud)), 0) && __pmd_alloc(mm, pud, address))?
+  ((void *)0): pmd_offset(pud, address);
+}
+static inline __attribute__((always_inline)) void pgtable_page_ctor(struct page *page)
+{
+ do {} while (0);
+ __inc_zone_page_state(page, NR_PAGETABLE);
+}
+static inline __attribute__((always_inline)) void pgtable_page_dtor(struct page *page)
+{
+ do {} while (0);
+ __dec_zone_page_state(page, NR_PAGETABLE);
+}
+extern void free_area_init(unsigned long * zones_size);
+extern void free_area_init_node(int nid, unsigned long * zones_size,
+  unsigned long zone_start_pfn, unsigned long *zholes_size);
+extern void free_area_init_nodes(unsigned long *max_zone_pfn);
+extern void add_active_range(unsigned int nid, unsigned long start_pfn,
+     unsigned long end_pfn);
+extern void remove_active_range(unsigned int nid, unsigned long start_pfn,
+     unsigned long end_pfn);
+extern void remove_all_active_ranges(void);
+extern unsigned long absent_pages_in_range(unsigned long start_pfn,
+      unsigned long end_pfn);
+extern void get_pfn_range_for_nid(unsigned int nid,
+   unsigned long *start_pfn, unsigned long *end_pfn);
+extern unsigned long find_min_pfn_with_active_regions(void);
+extern void free_bootmem_with_active_regions(int nid,
+      unsigned long max_low_pfn);
+typedef int (*work_fn_t)(unsigned long, unsigned long, void *);
+extern void work_with_active_regions(int nid, work_fn_t work_fn, void *data);
+extern void sparse_memory_present_with_active_regions(int nid);
+extern int __attribute__ ((__section__(".meminit.text"))) __attribute__((__cold__)) early_pfn_to_nid(unsigned long pfn);
+extern void set_dma_reserve(unsigned long new_dma_reserve);
+extern void memmap_init_zone(unsigned long, int, unsigned long,
+    unsigned long, enum memmap_context);
+extern void setup_per_zone_wmarks(void);
+extern void calculate_zone_inactive_ratio(struct zone *zone);
+extern void mem_init(void);
+extern void __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) __attribute__((no_instrument_function)) mmap_init(void);
+extern void show_mem(void);
+extern void si_meminfo(struct sysinfo * val);
+extern void si_meminfo_node(struct sysinfo *val, int nid);
+extern int after_bootmem;
+static inline __attribute__((always_inline)) void setup_per_cpu_pageset(void) {}
+extern void zone_pcp_update(struct zone *zone);
+extern atomic_long_t mmap_pages_allocated;
+void vma_prio_tree_add(struct vm_area_struct *, struct vm_area_struct *old);
+void vma_prio_tree_insert(struct vm_area_struct *, struct prio_tree_root *);
+void vma_prio_tree_remove(struct vm_area_struct *, struct prio_tree_root *);
+struct vm_area_struct *vma_prio_tree_next(struct vm_area_struct *vma,
+ struct prio_tree_iter *iter);
+static inline __attribute__((always_inline)) void vma_nonlinear_insert(struct vm_area_struct *vma,
+     struct list_head *list)
+{
+ vma->shared.vm_set.parent = ((void *)0);
+ list_add_tail(&vma->shared.vm_set.list, list);
+}
+extern int __vm_enough_memory(struct mm_struct *mm, long pages, int cap_sys_admin);
+extern void vma_adjust(struct vm_area_struct *vma, unsigned long start,
+ unsigned long end, unsigned long pgoff, struct vm_area_struct *insert);
+extern struct vm_area_struct *vma_merge(struct mm_struct *,
+ struct vm_area_struct *prev, unsigned long addr, unsigned long end,
+ unsigned long vm_flags, struct anon_vma *, struct file *, unsigned long,
+ struct mempolicy *);
+extern struct anon_vma *find_mergeable_anon_vma(struct vm_area_struct *);
+extern int split_vma(struct mm_struct *,
+ struct vm_area_struct *, unsigned long addr, int new_below);
+extern int insert_vm_struct(struct mm_struct *, struct vm_area_struct *);
+extern void __vma_link_rb(struct mm_struct *, struct vm_area_struct *,
+ struct rb_node **, struct rb_node *);
+extern void unlink_file_vma(struct vm_area_struct *);
+extern struct vm_area_struct *copy_vma(struct vm_area_struct **,
+ unsigned long addr, unsigned long len, unsigned long pgoff);
+extern void exit_mmap(struct mm_struct *);
+extern int mm_take_all_locks(struct mm_struct *mm);
+extern void mm_drop_all_locks(struct mm_struct *mm);
+extern void added_exe_file_vma(struct mm_struct *mm);
+extern void removed_exe_file_vma(struct mm_struct *mm);
+extern int may_expand_vm(struct mm_struct *mm, unsigned long npages);
+extern int install_special_mapping(struct mm_struct *mm,
+       unsigned long addr, unsigned long len,
+       unsigned long flags, struct page **pages);
+extern unsigned long get_unmapped_area(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
+extern unsigned long do_mmap_pgoff(struct file *file, unsigned long addr,
+ unsigned long len, unsigned long prot,
+ unsigned long flag, unsigned long pgoff);
+extern unsigned long mmap_region(struct file *file, unsigned long addr,
+ unsigned long len, unsigned long flags,
+ unsigned int vm_flags, unsigned long pgoff);
+static inline __attribute__((always_inline)) unsigned long do_mmap(struct file *file, unsigned long addr,
+ unsigned long len, unsigned long prot,
+ unsigned long flag, unsigned long offset)
+{
+ unsigned long ret = -22;
+ if ((offset + (((len)+((typeof(len))(((1UL) << 12))-1))&~((typeof(len))(((1UL) << 12))-1))) < offset)
+  goto out;
+ if (!(offset & ~(~(((1UL) << 12)-1))))
+  ret = do_mmap_pgoff(file, addr, len, prot, flag, offset >> 12);
+out:
+ return ret;
+}
+extern int do_munmap(struct mm_struct *, unsigned long, size_t);
+extern unsigned long do_brk(unsigned long, unsigned long);
+extern unsigned long page_unuse(struct page *);
+extern void truncate_inode_pages(struct address_space *, loff_t);
+extern void truncate_inode_pages_range(struct address_space *,
+           loff_t lstart, loff_t lend);
+extern int filemap_fault(struct vm_area_struct *, struct vm_fault *);
+int write_one_page(struct page *page, int wait);
+void task_dirty_inc(struct task_struct *tsk);
+int force_page_cache_readahead(struct address_space *mapping, struct file *filp,
+   unsigned long offset, unsigned long nr_to_read);
+void page_cache_sync_readahead(struct address_space *mapping,
+          struct file_ra_state *ra,
+          struct file *filp,
+          unsigned long offset,
+          unsigned long size);
+void page_cache_async_readahead(struct address_space *mapping,
+    struct file_ra_state *ra,
+    struct file *filp,
+    struct page *pg,
+    unsigned long offset,
+    unsigned long size);
+unsigned long max_sane_readahead(unsigned long nr);
+unsigned long ra_submit(struct file_ra_state *ra,
+   struct address_space *mapping,
+   struct file *filp);
+extern int expand_stack(struct vm_area_struct *vma, unsigned long address);
+extern int expand_stack_downwards(struct vm_area_struct *vma,
+      unsigned long address);
+extern struct vm_area_struct * find_vma(struct mm_struct * mm, unsigned long addr);
+extern struct vm_area_struct * find_vma_prev(struct mm_struct * mm, unsigned long addr,
+          struct vm_area_struct **pprev);
+static inline __attribute__((always_inline)) struct vm_area_struct * find_vma_intersection(struct mm_struct * mm, unsigned long start_addr, unsigned long end_addr)
+{
+ struct vm_area_struct * vma = find_vma(mm,start_addr);
+ if (vma && end_addr <= vma->vm_start)
+  vma = ((void *)0);
+ return vma;
+}
+static inline __attribute__((always_inline)) unsigned long vma_pages(struct vm_area_struct *vma)
+{
+ return (vma->vm_end - vma->vm_start) >> 12;
+}
+pgprot_t vm_get_page_prot(unsigned long vm_flags);
+struct vm_area_struct *find_extend_vma(struct mm_struct *, unsigned long addr);
+int remap_pfn_range(struct vm_area_struct *, unsigned long addr,
+   unsigned long pfn, unsigned long size, pgprot_t);
+int vm_insert_page(struct vm_area_struct *, unsigned long addr, struct page *);
+int vm_insert_pfn(struct vm_area_struct *vma, unsigned long addr,
+   unsigned long pfn);
+int vm_insert_mixed(struct vm_area_struct *vma, unsigned long addr,
+   unsigned long pfn);
+struct page *follow_page(struct vm_area_struct *, unsigned long address,
+   unsigned int foll_flags);
+typedef int (*pte_fn_t)(pte_t *pte, pgtable_t token, unsigned long addr,
+   void *data);
+extern int apply_to_page_range(struct mm_struct *mm, unsigned long address,
+          unsigned long size, pte_fn_t fn, void *data);
+void vm_stat_account(struct mm_struct *, unsigned long, struct file *, long);
+static inline __attribute__((always_inline)) void
+kernel_map_pages(struct page *page, int numpages, int enable) {}
+static inline __attribute__((always_inline)) void enable_debug_pagealloc(void)
+{
+}
+extern struct vm_area_struct *get_gate_vma(struct task_struct *tsk);
+int in_gate_area_no_task(unsigned long addr);
+int drop_caches_sysctl_handler(struct ctl_table *, int,
+     void *, size_t *, loff_t *);
+unsigned long shrink_slab(unsigned long scanned, gfp_t gfp_mask,
+   unsigned long lru_pages);
+extern int randomize_va_space;
+const char * arch_vma_name(struct vm_area_struct *vma);
+void print_vma_addr(char *prefix, unsigned long rip);
+struct page *sparse_mem_map_populate(unsigned long pnum, int nid);
+pgd_t *vmemmap_pgd_populate(unsigned long addr, int node);
+pud_t *vmemmap_pud_populate(pgd_t *pgd, unsigned long addr, int node);
+pmd_t *vmemmap_pmd_populate(pud_t *pud, unsigned long addr, int node);
+pte_t *vmemmap_pte_populate(pmd_t *pmd, unsigned long addr, int node);
+void *vmemmap_alloc_block(unsigned long size, int node);
+void vmemmap_verify(pte_t *, int, unsigned long, unsigned long);
+int vmemmap_populate_basepages(struct page *start_page,
+      unsigned long pages, int node);
+int vmemmap_populate(struct page *start_page, unsigned long pages, int node);
+void vmemmap_populate_print_last(void);
+extern int account_locked_memory(struct mm_struct *mm, struct rlimit *rlim,
+     size_t size);
+extern void refund_locked_memory(struct mm_struct *mm, size_t size);
+extern void memory_failure(unsigned long pfn, int trapno);
+extern int __memory_failure(unsigned long pfn, int trapno, int ref);
+extern int sysctl_memory_failure_early_kill;
+extern int sysctl_memory_failure_recovery;
+extern atomic_long_t mce_bad_pages;
+struct resource {
+ resource_size_t start;
+ resource_size_t end;
+ const char *name;
+ unsigned long flags;
+ struct resource *parent, *sibling, *child;
+};
+struct resource_list {
+ struct resource_list *next;
+ struct resource *res;
+ struct pci_dev *dev;
+};
+extern struct resource ioport_resource;
+extern struct resource iomem_resource;
+extern int request_resource(struct resource *root, struct resource *new);
+extern int release_resource(struct resource *new);
+extern void reserve_region_with_split(struct resource *root,
+        resource_size_t start, resource_size_t end,
+        const char *name);
+extern int insert_resource(struct resource *parent, struct resource *new);
+extern void insert_resource_expand_to_fit(struct resource *root, struct resource *new);
+extern int allocate_resource(struct resource *root, struct resource *new,
+        resource_size_t size, resource_size_t min,
+        resource_size_t max, resource_size_t align,
+        void (*alignf)(void *, struct resource *,
+         resource_size_t, resource_size_t),
+        void *alignf_data);
+int adjust_resource(struct resource *res, resource_size_t start,
+      resource_size_t size);
+resource_size_t resource_alignment(struct resource *res);
+static inline __attribute__((always_inline)) resource_size_t resource_size(struct resource *res)
+{
+ return res->end - res->start + 1;
+}
+static inline __attribute__((always_inline)) unsigned long resource_type(struct resource *res)
+{
+ return res->flags & 0x00000f00;
+}
+extern struct resource * __request_region(struct resource *,
+     resource_size_t start,
+     resource_size_t n,
+     const char *name, int flags);
+extern int __check_region(struct resource *, resource_size_t, resource_size_t);
+extern void __release_region(struct resource *, resource_size_t,
+    resource_size_t);
+static inline __attribute__((always_inline)) int __attribute__((deprecated)) check_region(resource_size_t s,
+      resource_size_t n)
+{
+ return __check_region(&ioport_resource, s, n);
+}
+struct device;
+extern struct resource * __devm_request_region(struct device *dev,
+    struct resource *parent, resource_size_t start,
+    resource_size_t n, const char *name);
+extern void __devm_release_region(struct device *dev, struct resource *parent,
+      resource_size_t start, resource_size_t n);
+extern int iomem_map_sanity_check(resource_size_t addr, unsigned long size);
+extern int iomem_is_exclusive(u64 addr);
+extern int
+walk_system_ram_range(unsigned long start_pfn, unsigned long nr_pages,
+  void *arg, int (*func)(unsigned long, unsigned long, void *));
+extern unsigned long loops_per_jiffy;
+extern void __bad_udelay(void);
+extern void __bad_ndelay(void);
+extern void __udelay(unsigned long usecs);
+extern void __ndelay(unsigned long nsecs);
+extern void __const_udelay(unsigned long xloops);
+extern void __delay(unsigned long loops);
+extern unsigned long lpj_fine;
+void calibrate_delay(void);
+void msleep(unsigned int msecs);
+unsigned long msleep_interruptible(unsigned int msecs);
+static inline __attribute__((always_inline)) void ssleep(unsigned int seconds)
+{
+ msleep(seconds * 1000);
+}
+enum irqreturn {
+ IRQ_NONE,
+ IRQ_HANDLED,
+ IRQ_WAKE_THREAD,
+};
+typedef enum irqreturn irqreturn_t;
+extern int nr_irqs;
+extern struct irq_desc *irq_to_desc(unsigned int irq);
+extern int __attribute__((section(".spinlock.text"))) __reacquire_kernel_lock(void);
+extern void __attribute__((section(".spinlock.text"))) __release_kernel_lock(void);
+static inline __attribute__((always_inline)) int reacquire_kernel_lock(struct task_struct *task)
+{
+ if (__builtin_expect(!!(task->lock_depth >= 0), 0))
+  return __reacquire_kernel_lock();
+ return 0;
+}
+extern void __attribute__((section(".spinlock.text"))) lock_kernel(void) ;
+extern void __attribute__((section(".spinlock.text"))) unlock_kernel(void) ;
+static inline __attribute__((always_inline)) void cycle_kernel_lock(void)
+{
+ lock_kernel();
+ unlock_kernel();
+}
+static inline __attribute__((always_inline)) void ftrace_nmi_enter(void) { }
+static inline __attribute__((always_inline)) void ftrace_nmi_exit(void) { }
+extern void ack_bad_irq(unsigned int irq);
+struct sh_machine_vector {
+ void (*mv_setup)(char **cmdline_p);
+ const char *mv_name;
+ int mv_nr_irqs;
+ u8 (*mv_inb)(unsigned long);
+ u16 (*mv_inw)(unsigned long);
+ u32 (*mv_inl)(unsigned long);
+ void (*mv_outb)(u8, unsigned long);
+ void (*mv_outw)(u16, unsigned long);
+ void (*mv_outl)(u32, unsigned long);
+ u8 (*mv_inb_p)(unsigned long);
+ u16 (*mv_inw_p)(unsigned long);
+ u32 (*mv_inl_p)(unsigned long);
+ void (*mv_outb_p)(u8, unsigned long);
+ void (*mv_outw_p)(u16, unsigned long);
+ void (*mv_outl_p)(u32, unsigned long);
+ void (*mv_insb)(unsigned long, void *dst, unsigned long count);
+ void (*mv_insw)(unsigned long, void *dst, unsigned long count);
+ void (*mv_insl)(unsigned long, void *dst, unsigned long count);
+ void (*mv_outsb)(unsigned long, const void *src, unsigned long count);
+ void (*mv_outsw)(unsigned long, const void *src, unsigned long count);
+ void (*mv_outsl)(unsigned long, const void *src, unsigned long count);
+ int (*mv_irq_demux)(int irq);
+ void (*mv_init_irq)(void);
+ void *(*mv_ioport_map)(unsigned long port, unsigned int size);
+ void (*mv_ioport_unmap)(void *);
+ int (*mv_clk_init)(void);
+ int (*mv_mode_pins)(void);
+};
+extern struct sh_machine_vector sh_mv;
+extern void make_maskreg_irq(unsigned int irq);
+extern unsigned short *irq_mask_register;
+void init_IRQ_pint(void);
+void make_imask_irq(unsigned int irq);
+static inline __attribute__((always_inline)) int generic_irq_demux(int irq)
+{
+ return irq;
+}
+void init_IRQ(void);
+ int do_IRQ(unsigned int irq, struct pt_regs *regs);
+static inline __attribute__((always_inline)) int irq_canonicalize(int irq)
+{
+ return irq;
+}
+extern __attribute__((section(".data" ""))) __typeof__(struct pt_regs *) per_cpu____irq_regs;
+static inline __attribute__((always_inline)) struct pt_regs *get_irq_regs(void)
+{
+ return per_cpu____irq_regs;
+}
+static inline __attribute__((always_inline)) struct pt_regs *set_irq_regs(struct pt_regs *new_regs)
+{
+ struct pt_regs *old_regs, **pp_regs = &per_cpu____irq_regs;
+ old_regs = *pp_regs;
+ *pp_regs = new_regs;
+ return old_regs;
+}
+struct irq_desc;
+typedef void (*irq_flow_handler_t)(unsigned int irq,
+         struct irq_desc *desc);
+struct proc_dir_entry;
+struct msi_desc;
+struct irq_chip {
+ const char *name;
+ unsigned int (*startup)(unsigned int irq);
+ void (*shutdown)(unsigned int irq);
+ void (*enable)(unsigned int irq);
+ void (*disable)(unsigned int irq);
+ void (*ack)(unsigned int irq);
+ void (*mask)(unsigned int irq);
+ void (*mask_ack)(unsigned int irq);
+ void (*unmask)(unsigned int irq);
+ void (*eoi)(unsigned int irq);
+ void (*end)(unsigned int irq);
+ int (*set_affinity)(unsigned int irq,
+     const struct cpumask *dest);
+ int (*retrigger)(unsigned int irq);
+ int (*set_type)(unsigned int irq, unsigned int flow_type);
+ int (*set_wake)(unsigned int irq, unsigned int on);
+ void (*bus_lock)(unsigned int irq);
+ void (*bus_sync_unlock)(unsigned int irq);
+ const char *typename;
+};
+struct timer_rand_state;
+struct irq_2_iommu;
+struct irq_desc {
+ unsigned int irq;
+ struct timer_rand_state *timer_rand_state;
+ unsigned int *kstat_irqs;
+ irq_flow_handler_t handle_irq;
+ struct irq_chip *chip;
+ struct msi_desc *msi_desc;
+ void *handler_data;
+ void *chip_data;
+ struct irqaction *action;
+ unsigned int status;
+ unsigned int depth;
+ unsigned int wake_depth;
+ unsigned int irq_count;
+ unsigned long last_unhandled;
+ unsigned int irqs_unhandled;
+ spinlock_t lock;
+ atomic_t threads_active;
+ wait_queue_head_t wait_for_threads;
+ struct proc_dir_entry *dir;
+ const char *name;
+} ;
+extern void arch_init_copy_chip_data(struct irq_desc *old_desc,
+     struct irq_desc *desc, int node);
+extern void arch_free_chip_data(struct irq_desc *old_desc, struct irq_desc *desc);
+extern struct irq_desc irq_desc[500];
+static inline __attribute__((always_inline)) struct irq_desc *move_irq_desc(struct irq_desc *desc, int node)
+{
+ return desc;
+}
+extern struct irq_desc *irq_to_desc_alloc_node(unsigned int irq, int node);
+typedef unsigned char intc_enum;
+struct intc_vect {
+ intc_enum enum_id;
+ unsigned short vect;
+};
+struct intc_group {
+ intc_enum enum_id;
+ intc_enum enum_ids[32];
+};
+struct intc_mask_reg {
+ unsigned long set_reg, clr_reg, reg_width;
+ intc_enum enum_ids[32];
+};
+struct intc_prio_reg {
+ unsigned long set_reg, clr_reg, reg_width, field_width;
+ intc_enum enum_ids[16];
+};
+struct intc_sense_reg {
+ unsigned long reg, reg_width, field_width;
+ intc_enum enum_ids[16];
+};
+struct intc_desc {
+ struct intc_vect *vectors;
+ unsigned int nr_vectors;
+ struct intc_group *groups;
+ unsigned int nr_groups;
+ struct intc_mask_reg *mask_regs;
+ unsigned int nr_mask_regs;
+ struct intc_prio_reg *prio_regs;
+ unsigned int nr_prio_regs;
+ struct intc_sense_reg *sense_regs;
+ unsigned int nr_sense_regs;
+ char *name;
+};
+void __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) __attribute__((no_instrument_function)) register_intc_controller(struct intc_desc *desc);
+int intc_set_priority(unsigned int irq, unsigned int prio);
+extern atomic_t irq_err_count;
+struct ipr_data {
+ unsigned char irq;
+ unsigned char ipr_idx;
+ unsigned char shift;
+ unsigned char priority;
+};
+struct ipr_desc {
+ unsigned long *ipr_offsets;
+ unsigned int nr_offsets;
+ struct ipr_data *ipr_data;
+ unsigned int nr_irqs;
+ struct irq_chip chip;
+};
+void register_ipr_controller(struct ipr_desc *);
+void __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) __attribute__((no_instrument_function)) plat_irq_setup(void);
+void __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) __attribute__((no_instrument_function)) plat_irq_setup_sh3(void);
+void __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) __attribute__((no_instrument_function)) plat_irq_setup_pins(int mode);
+enum { IRQ_MODE_IRQ, IRQ_MODE_IRQ7654, IRQ_MODE_IRQ3210,
+       IRQ_MODE_IRL7654_MASK, IRQ_MODE_IRL3210_MASK,
+       IRQ_MODE_IRL7654, IRQ_MODE_IRL3210 };
+extern int setup_irq(unsigned int irq, struct irqaction *new);
+extern void remove_irq(unsigned int irq, struct irqaction *act);
+extern int no_irq_affinity;
+static inline __attribute__((always_inline)) int irq_balancing_disabled(unsigned int irq)
+{
+ struct irq_desc *desc;
+ desc = irq_to_desc(irq);
+ return desc->status & (0x00010000 | 0x00400000);
+}
+extern irqreturn_t handle_IRQ_event(unsigned int irq, struct irqaction *action);
+extern void handle_level_irq(unsigned int irq, struct irq_desc *desc);
+extern void handle_fasteoi_irq(unsigned int irq, struct irq_desc *desc);
+extern void handle_edge_irq(unsigned int irq, struct irq_desc *desc);
+extern void handle_simple_irq(unsigned int irq, struct irq_desc *desc);
+extern void handle_percpu_irq(unsigned int irq, struct irq_desc *desc);
+extern void handle_bad_irq(unsigned int irq, struct irq_desc *desc);
+extern void handle_nested_irq(unsigned int irq);
+static inline __attribute__((always_inline)) void generic_handle_irq_desc(unsigned int irq, struct irq_desc *desc)
+{
+ desc->handle_irq(irq, desc);
+}
+static inline __attribute__((always_inline)) void generic_handle_irq(unsigned int irq)
+{
+ generic_handle_irq_desc(irq, irq_to_desc(irq));
+}
+extern void note_interrupt(unsigned int irq, struct irq_desc *desc,
+      irqreturn_t action_ret);
+void check_irq_resend(struct irq_desc *desc, unsigned int irq);
+extern int noirqdebug_setup(char *str);
+extern int can_request_irq(unsigned int irq, unsigned long irqflags);
+extern struct irq_chip no_irq_chip;
+extern struct irq_chip dummy_irq_chip;
+extern void
+set_irq_chip_and_handler(unsigned int irq, struct irq_chip *chip,
+    irq_flow_handler_t handle);
+extern void
+set_irq_chip_and_handler_name(unsigned int irq, struct irq_chip *chip,
+         irq_flow_handler_t handle, const char *name);
+extern void
+__set_irq_handler(unsigned int irq, irq_flow_handler_t handle, int is_chained,
+    const char *name);
+static inline __attribute__((always_inline)) void __set_irq_handler_unlocked(int irq,
+           irq_flow_handler_t handler)
+{
+ struct irq_desc *desc;
+ desc = irq_to_desc(irq);
+ desc->handle_irq = handler;
+}
+static inline __attribute__((always_inline)) void
+set_irq_handler(unsigned int irq, irq_flow_handler_t handle)
+{
+ __set_irq_handler(irq, handle, 0, ((void *)0));
+}
+static inline __attribute__((always_inline)) void
+set_irq_chained_handler(unsigned int irq,
+   irq_flow_handler_t handle)
+{
+ __set_irq_handler(irq, handle, 1, ((void *)0));
+}
+extern void set_irq_nested_thread(unsigned int irq, int nest);
+extern void set_irq_noprobe(unsigned int irq);
+extern void set_irq_probe(unsigned int irq);
+extern unsigned int create_irq_nr(unsigned int irq_want, int node);
+extern int create_irq(void);
+extern void destroy_irq(unsigned int irq);
+static inline __attribute__((always_inline)) int irq_has_action(unsigned int irq)
+{
+ struct irq_desc *desc = irq_to_desc(irq);
+ return desc->action != ((void *)0);
+}
+extern void dynamic_irq_init(unsigned int irq);
+void dynamic_irq_init_keep_chip_data(unsigned int irq);
+extern void dynamic_irq_cleanup(unsigned int irq);
+void dynamic_irq_cleanup_keep_chip_data(unsigned int irq);
+extern int set_irq_chip(unsigned int irq, struct irq_chip *chip);
+extern int set_irq_data(unsigned int irq, void *data);
+extern int set_irq_chip_data(unsigned int irq, void *data);
+extern int set_irq_type(unsigned int irq, unsigned int type);
+extern int set_irq_msi(unsigned int irq, struct msi_desc *entry);
+static inline __attribute__((always_inline)) bool alloc_desc_masks(struct irq_desc *desc, int node,
+        bool boot)
+{
+ return true;
+}
+static inline __attribute__((always_inline)) void init_desc_masks(struct irq_desc *desc)
+{
+}
+static inline __attribute__((always_inline)) void init_copy_desc_masks(struct irq_desc *old_desc,
+     struct irq_desc *new_desc)
+{
+}
+static inline __attribute__((always_inline)) void free_desc_masks(struct irq_desc *old_desc,
+       struct irq_desc *new_desc)
+{
+}
+typedef struct {
+ unsigned int __softirq_pending;
+} __attribute__((__aligned__((1 << 5)))) irq_cpustat_t;
+extern irq_cpustat_t irq_stat[];
+extern void synchronize_irq(unsigned int irq);
+struct task_struct;
+static inline __attribute__((always_inline)) void account_system_vtime(struct task_struct *tsk)
+{
+}
+extern void irq_enter(void);
+extern void irq_exit(void);
+enum {
+ IRQTF_RUNTHREAD,
+ IRQTF_DIED,
+ IRQTF_WARNED,
+ IRQTF_AFFINITY,
+};
+typedef irqreturn_t (*irq_handler_t)(int, void *);
+struct irqaction {
+ irq_handler_t handler;
+ unsigned long flags;
+ const char *name;
+ void *dev_id;
+ struct irqaction *next;
+ int irq;
+ struct proc_dir_entry *dir;
+ irq_handler_t thread_fn;
+ struct task_struct *thread;
+ unsigned long thread_flags;
+};
+extern irqreturn_t no_action(int cpl, void *dev_id);
+extern int
+request_threaded_irq(unsigned int irq, irq_handler_t handler,
+       irq_handler_t thread_fn,
+       unsigned long flags, const char *name, void *dev);
+static inline __attribute__((always_inline)) int
+request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,
+     const char *name, void *dev)
+{
+ return request_threaded_irq(irq, handler, ((void *)0), flags, name, dev);
+}
+extern void exit_irq_thread(void);
+extern void free_irq(unsigned int, void *);
+struct device;
+extern int
+devm_request_threaded_irq(struct device *dev, unsigned int irq,
+     irq_handler_t handler, irq_handler_t thread_fn,
+     unsigned long irqflags, const char *devname,
+     void *dev_id);
+static inline __attribute__((always_inline)) int
+devm_request_irq(struct device *dev, unsigned int irq, irq_handler_t handler,
+   unsigned long irqflags, const char *devname, void *dev_id)
+{
+ return devm_request_threaded_irq(dev, irq, handler, ((void *)0), irqflags,
+      devname, dev_id);
+}
+extern void devm_free_irq(struct device *dev, unsigned int irq, void *dev_id);
+extern void disable_irq_nosync(unsigned int irq);
+extern void disable_irq(unsigned int irq);
+extern void enable_irq(unsigned int irq);
+extern void suspend_device_irqs(void);
+extern void resume_device_irqs(void);
+extern int check_wakeup_irqs(void);
+static inline __attribute__((always_inline)) int irq_set_affinity(unsigned int irq, const struct cpumask *m)
+{
+ return -22;
+}
+static inline __attribute__((always_inline)) int irq_can_set_affinity(unsigned int irq)
+{
+ return 0;
+}
+static inline __attribute__((always_inline)) int irq_select_affinity(unsigned int irq) { return 0; }
+static inline __attribute__((always_inline)) void disable_irq_nosync_lockdep(unsigned int irq)
+{
+ disable_irq_nosync(irq);
+}
+static inline __attribute__((always_inline)) void disable_irq_nosync_lockdep_irqsave(unsigned int irq, unsigned long *flags)
+{
+ disable_irq_nosync(irq);
+}
+static inline __attribute__((always_inline)) void disable_irq_lockdep(unsigned int irq)
+{
+ disable_irq(irq);
+}
+static inline __attribute__((always_inline)) void enable_irq_lockdep(unsigned int irq)
+{
+ enable_irq(irq);
+}
+static inline __attribute__((always_inline)) void enable_irq_lockdep_irqrestore(unsigned int irq, unsigned long *flags)
+{
+ enable_irq(irq);
+}
+extern int set_irq_wake(unsigned int irq, unsigned int on);
+static inline __attribute__((always_inline)) int enable_irq_wake(unsigned int irq)
+{
+ return set_irq_wake(irq, 1);
+}
+static inline __attribute__((always_inline)) int disable_irq_wake(unsigned int irq)
+{
+ return set_irq_wake(irq, 0);
+}
+enum
+{
+ HI_SOFTIRQ=0,
+ TIMER_SOFTIRQ,
+ NET_TX_SOFTIRQ,
+ NET_RX_SOFTIRQ,
+ BLOCK_SOFTIRQ,
+ BLOCK_IOPOLL_SOFTIRQ,
+ TASKLET_SOFTIRQ,
+ SCHED_SOFTIRQ,
+ HRTIMER_SOFTIRQ,
+ RCU_SOFTIRQ,
+ NR_SOFTIRQS
+};
+extern char *softirq_to_name[NR_SOFTIRQS];
+struct softirq_action
+{
+ void (*action)(struct softirq_action *);
+};
+ void do_softirq(void);
+ void __do_softirq(void);
+extern void open_softirq(int nr, void (*action)(struct softirq_action *));
+extern void softirq_init(void);
+extern void raise_softirq_irqoff(unsigned int nr);
+extern void raise_softirq(unsigned int nr);
+extern void wakeup_softirqd(void);
+extern __attribute__((section(".data" ""))) __typeof__(struct list_head [NR_SOFTIRQS]) per_cpu__softirq_work_list;
+extern void send_remote_softirq(struct call_single_data *cp, int cpu, int softirq);
+extern void __send_remote_softirq(struct call_single_data *cp, int cpu,
+      int this_cpu, int softirq);
+struct tasklet_struct
+{
+ struct tasklet_struct *next;
+ unsigned long state;
+ atomic_t count;
+ void (*func)(unsigned long);
+ unsigned long data;
+};
+enum
+{
+ TASKLET_STATE_SCHED,
+ TASKLET_STATE_RUN
+};
+extern void __tasklet_schedule(struct tasklet_struct *t);
+static inline __attribute__((always_inline)) void tasklet_schedule(struct tasklet_struct *t)
+{
+ if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
+  __tasklet_schedule(t);
+}
+extern void __tasklet_hi_schedule(struct tasklet_struct *t);
+static inline __attribute__((always_inline)) void tasklet_hi_schedule(struct tasklet_struct *t)
+{
+ if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
+  __tasklet_hi_schedule(t);
+}
+extern void __tasklet_hi_schedule_first(struct tasklet_struct *t);
+static inline __attribute__((always_inline)) void tasklet_hi_schedule_first(struct tasklet_struct *t)
+{
+ if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
+  __tasklet_hi_schedule_first(t);
+}
+static inline __attribute__((always_inline)) void tasklet_disable_nosync(struct tasklet_struct *t)
+{
+ atomic_add(1,(&t->count));
+ __asm__ __volatile__("": : :"memory");
+}
+static inline __attribute__((always_inline)) void tasklet_disable(struct tasklet_struct *t)
+{
+ tasklet_disable_nosync(t);
+ do { } while (0);
+ __asm__ __volatile__("": : :"memory");
+}
+static inline __attribute__((always_inline)) void tasklet_enable(struct tasklet_struct *t)
+{
+ __asm__ __volatile__("": : :"memory");
+ atomic_sub(1,(&t->count));
+}
+static inline __attribute__((always_inline)) void tasklet_hi_enable(struct tasklet_struct *t)
+{
+ __asm__ __volatile__("": : :"memory");
+ atomic_sub(1,(&t->count));
+}
+extern void tasklet_kill(struct tasklet_struct *t);
+extern void tasklet_kill_immediate(struct tasklet_struct *t, unsigned int cpu);
+extern void tasklet_init(struct tasklet_struct *t,
+    void (*func)(unsigned long), unsigned long data);
+struct tasklet_hrtimer {
+ struct hrtimer timer;
+ struct tasklet_struct tasklet;
+ enum hrtimer_restart (*function)(struct hrtimer *);
+};
+extern void
+tasklet_hrtimer_init(struct tasklet_hrtimer *ttimer,
+       enum hrtimer_restart (*function)(struct hrtimer *),
+       clockid_t which_clock, enum hrtimer_mode mode);
+static inline __attribute__((always_inline))
+int tasklet_hrtimer_start(struct tasklet_hrtimer *ttimer, ktime_t time,
+     const enum hrtimer_mode mode)
+{
+ return hrtimer_start(&ttimer->timer, time, mode);
+}
+static inline __attribute__((always_inline))
+void tasklet_hrtimer_cancel(struct tasklet_hrtimer *ttimer)
+{
+ hrtimer_cancel(&ttimer->timer);
+ tasklet_kill(&ttimer->tasklet);
+}
+extern unsigned long probe_irq_on(void);
+extern int probe_irq_off(unsigned long);
+extern unsigned int probe_irq_mask(unsigned long);
+extern void init_irq_proc(void);
+static inline __attribute__((always_inline)) void debug_poll_all_shared_irqs(void) { }
+struct seq_file;
+int show_interrupts(struct seq_file *p, void *v);
+struct irq_desc;
+extern int early_irq_init(void);
+extern int arch_probe_nr_irqs(void);
+extern int arch_early_irq_init(void);
+extern int arch_init_chip_data(struct irq_desc *desc, int node);
+struct pollfd {
+ int fd;
+ short events;
+ short revents;
+};
+struct __large_struct { unsigned long buf[100]; };
+static inline __attribute__((always_inline)) int __access_ok(unsigned long addr, unsigned long size)
+{
+ unsigned long flag, sum;
+ __asm__("clrt\n\t"
+  "addc	%3, %1\n\t"
+  "movt	%0\n\t"
+  "cmp/hi	%4, %1\n\t"
+  "rotcl	%0"
+  :"=&r" (flag), "=r" (sum)
+  :"1" (addr), "r" (size),
+   "r" (current_thread_info()->addr_limit.seg)
+  :"t");
+ return flag == 0;
+}
+extern void __get_user_unknown(void);
+extern void __put_user_unknown(void);
+static inline __attribute__((always_inline)) int
+__strncpy_from_user(unsigned long __dest, unsigned long __src, int __count)
+{
+ __kernel_size_t res;
+ unsigned long __dummy, _d, _s, _c;
+ __asm__ __volatile__(
+  "9:\n"
+  "mov.b	@%2+, %1\n\t"
+  "cmp/eq	#0, %1\n\t"
+  "bt/s	2f\n"
+  "1:\n"
+  "mov.b	%1, @%3\n\t"
+  "dt	%4\n\t"
+  "bf/s	9b\n\t"
+  " add	#1, %3\n\t"
+  "2:\n\t"
+  "sub	%4, %0\n"
+  "3:\n"
+  ".section .fixup,\"ax\"\n"
+  "4:\n\t"
+  "mov.l	5f, %1\n\t"
+  "jmp	@%1\n\t"
+  " mov	%9, %0\n\t"
+  ".balign 4\n"
+  "5:	.long 3b\n"
+  ".previous\n"
+  ".section __ex_table,\"a\"\n"
+  "	.balign 4\n"
+  "	.long 9b,4b\n"
+  ".previous"
+  : "=r" (res), "=&z" (__dummy), "=r" (_s), "=r" (_d), "=r"(_c)
+  : "0" (__count), "2" (__src), "3" (__dest), "4" (__count),
+    "i" (-14)
+  : "memory", "t");
+ return res;
+}
+static inline __attribute__((always_inline)) long __strnlen_user(const char *__s, long __n)
+{
+ unsigned long res;
+ unsigned long __dummy;
+ __asm__ __volatile__(
+  "1:\t"
+  "mov.b	@(%0,%3), %1\n\t"
+  "cmp/eq	%4, %0\n\t"
+  "bt/s	2f\n\t"
+  " add	#1, %0\n\t"
+  "tst	%1, %1\n\t"
+  "bf	1b\n\t"
+  "2:\n"
+  ".section .fixup,\"ax\"\n"
+  "3:\n\t"
+  "mov.l	4f, %1\n\t"
+  "jmp	@%1\n\t"
+  " mov	#0, %0\n"
+  ".balign 4\n"
+  "4:	.long 2b\n"
+  ".previous\n"
+  ".section __ex_table,\"a\"\n"
+  "	.balign 4\n"
+  "	.long 1b,3b\n"
+  ".previous"
+  : "=z" (res), "=&r" (__dummy)
+  : "0" (0), "r" (__s), "r" (__n)
+  : "t");
+ return res;
+}
+__kernel_size_t __copy_user(void *to, const void *from, __kernel_size_t n);
+static inline __attribute__((always_inline)) __attribute__((always_inline)) unsigned long
+__copy_from_user(void *to, const void *from, unsigned long n)
+{
+ return __copy_user(to, ( void *)from, n);
+}
+static inline __attribute__((always_inline)) __attribute__((always_inline)) unsigned long
+__copy_to_user(void *to, const void *from, unsigned long n)
+{
+ return __copy_user(( void *)to, from, n);
+}
+__kernel_size_t __clear_user(void *addr, __kernel_size_t size);
+static inline __attribute__((always_inline)) unsigned long
+copy_from_user(void *to, const void *from, unsigned long n)
+{
+ unsigned long __copy_from = (unsigned long) from;
+ __kernel_size_t __copy_size = (__kernel_size_t) n;
+ if (__copy_size && __access_ok(__copy_from, __copy_size))
+  return __copy_user(to, from, __copy_size);
+ return __copy_size;
+}
+static inline __attribute__((always_inline)) unsigned long
+copy_to_user(void *to, const void *from, unsigned long n)
+{
+ unsigned long __copy_to = (unsigned long) to;
+ __kernel_size_t __copy_size = (__kernel_size_t) n;
+ if (__copy_size && __access_ok(__copy_to, __copy_size))
+  return __copy_user(to, from, __copy_size);
+ return __copy_size;
+}
+static inline __attribute__((always_inline)) long strnlen_user(const char *s, long n)
+{
+ if (!((unsigned long )(s) < current_thread_info()->addr_limit.seg))
+  return 0;
+ else
+  return __strnlen_user(s, n);
+}
+struct exception_table_entry {
+ unsigned long insn, fixup;
+};
+int fixup_exception(struct pt_regs *regs);
+unsigned long search_exception_table(unsigned long addr);
+const struct exception_table_entry *search_exception_tables(unsigned long addr);
+struct poll_table_struct;
+typedef void (*poll_queue_proc)(struct file *, wait_queue_head_t *, struct poll_table_struct *);
+typedef struct poll_table_struct {
+ poll_queue_proc qproc;
+ unsigned long key;
+} poll_table;
+static inline __attribute__((always_inline)) void poll_wait(struct file * filp, wait_queue_head_t * wait_address, poll_table *p)
+{
+ if (p && wait_address)
+  p->qproc(filp, wait_address, p);
+}
+static inline __attribute__((always_inline)) void init_poll_funcptr(poll_table *pt, poll_queue_proc qproc)
+{
+ pt->qproc = qproc;
+ pt->key = ~0UL;
+}
+struct poll_table_entry {
+ struct file *filp;
+ unsigned long key;
+ wait_queue_t wait;
+ wait_queue_head_t *wait_address;
+};
+struct poll_wqueues {
+ poll_table pt;
+ struct poll_table_page *table;
+ struct task_struct *polling_task;
+ int triggered;
+ int error;
+ int inline_index;
+ struct poll_table_entry inline_entries[((832 - 256) / sizeof(struct poll_table_entry))];
+};
+extern void poll_initwait(struct poll_wqueues *pwq);
+extern void poll_freewait(struct poll_wqueues *pwq);
+extern int poll_schedule_timeout(struct poll_wqueues *pwq, int state,
+     ktime_t *expires, unsigned long slack);
+static inline __attribute__((always_inline)) int poll_schedule(struct poll_wqueues *pwq, int state)
+{
+ return poll_schedule_timeout(pwq, state, ((void *)0), 0);
+}
+typedef struct {
+ unsigned long *in, *out, *ex;
+ unsigned long *res_in, *res_out, *res_ex;
+} fd_set_bits;
+static inline __attribute__((always_inline))
+int get_fd_set(unsigned long nr, void *ufdset, unsigned long *fdset)
+{
+ nr = ((((nr)+(8*sizeof(long))-1)/(8*sizeof(long)))*sizeof(long));
+ if (ufdset)
+  return copy_from_user(fdset, ufdset, nr) ? -14 : 0;
+ memset(fdset, 0, nr);
+ return 0;
+}
+static inline __attribute__((always_inline)) unsigned long
+set_fd_set(unsigned long nr, void *ufdset, unsigned long *fdset)
+{
+ if (ufdset)
+  return __copy_to_user(ufdset, fdset, ((((nr)+(8*sizeof(long))-1)/(8*sizeof(long)))*sizeof(long)));
+ return 0;
+}
+static inline __attribute__((always_inline))
+void zero_fd_set(unsigned long nr, unsigned long *fdset)
+{
+ memset(fdset, 0, ((((nr)+(8*sizeof(long))-1)/(8*sizeof(long)))*sizeof(long)));
+}
+extern int do_select(int n, fd_set_bits *fds, struct timespec *end_time);
+extern int do_sys_poll(struct pollfd * ufds, unsigned int nfds,
+         struct timespec *end_time);
+extern int core_sys_select(int n, fd_set *inp, fd_set *outp,
+      fd_set *exp, struct timespec *end_time);
+extern int poll_select_set_timeout(struct timespec *to, long sec, long nsec);
+struct vm_area_struct;
+struct vm_struct {
+ struct vm_struct *next;
+ void *addr;
+ unsigned long size;
+ unsigned long flags;
+ struct page **pages;
+ unsigned int nr_pages;
+ unsigned long phys_addr;
+ void *caller;
+};
+extern void vm_unmap_ram(const void *mem, unsigned int count);
+extern void *vm_map_ram(struct page **pages, unsigned int count,
+    int node, pgprot_t prot);
+extern void vm_unmap_aliases(void);
+extern void __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) __attribute__((no_instrument_function)) vmalloc_init(void);
+extern void *vmalloc(unsigned long size);
+extern void *vmalloc_user(unsigned long size);
+extern void *vmalloc_node(unsigned long size, int node);
+extern void *vmalloc_exec(unsigned long size);
+extern void *vmalloc_32(unsigned long size);
+extern void *vmalloc_32_user(unsigned long size);
+extern void *__vmalloc(unsigned long size, gfp_t gfp_mask, pgprot_t prot);
+extern void *__vmalloc_area(struct vm_struct *area, gfp_t gfp_mask,
+    pgprot_t prot);
+extern void vfree(const void *addr);
+extern void *vmap(struct page **pages, unsigned int count,
+   unsigned long flags, pgprot_t prot);
+extern void vunmap(const void *addr);
+extern int remap_vmalloc_range(struct vm_area_struct *vma, void *addr,
+       unsigned long pgoff);
+void vmalloc_sync_all(void);
+static inline __attribute__((always_inline)) size_t get_vm_area_size(const struct vm_struct *area)
+{
+ return area->size - ((1UL) << 12);
+}
+extern struct vm_struct *get_vm_area(unsigned long size, unsigned long flags);
+extern struct vm_struct *get_vm_area_caller(unsigned long size,
+     unsigned long flags, void *caller);
+extern struct vm_struct *__get_vm_area(unsigned long size, unsigned long flags,
+     unsigned long start, unsigned long end);
+extern struct vm_struct *__get_vm_area_caller(unsigned long size,
+     unsigned long flags,
+     unsigned long start, unsigned long end,
+     void *caller);
+extern struct vm_struct *get_vm_area_node(unsigned long size,
+       unsigned long flags, int node,
+       gfp_t gfp_mask);
+extern struct vm_struct *remove_vm_area(const void *addr);
+extern int map_vm_area(struct vm_struct *area, pgprot_t prot,
+   struct page ***pages);
+extern int map_kernel_range_noflush(unsigned long start, unsigned long size,
+        pgprot_t prot, struct page **pages);
+extern void unmap_kernel_range_noflush(unsigned long addr, unsigned long size);
+extern void unmap_kernel_range(unsigned long addr, unsigned long size);
+extern struct vm_struct *alloc_vm_area(size_t size);
+extern void free_vm_area(struct vm_struct *area);
+extern long vread(char *buf, char *addr, unsigned long count);
+extern long vwrite(char *buf, char *addr, unsigned long count);
+extern rwlock_t vmlist_lock;
+extern struct vm_struct *vmlist;
+extern __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) __attribute__((no_instrument_function)) void vm_area_register_early(struct vm_struct *vm, size_t align);
+struct vm_struct **pcpu_get_vm_areas(const unsigned long *offsets,
+         const size_t *sizes, int nr_vms,
+         size_t align, gfp_t gfp_mask);
+void pcpu_free_vm_areas(struct vm_struct **vms, int nr_vms);
+struct __kernel_sockaddr_storage {
+ unsigned short ss_family;
+ char __data[128 - sizeof(unsigned short)];
+} __attribute__ ((aligned((__alignof__ (struct sockaddr *)))));
+struct seq_file;
+extern void socket_seq_show(struct seq_file *seq);
+typedef unsigned short sa_family_t;
+struct sockaddr {
+ sa_family_t sa_family;
+ char sa_data[14];
+};
+struct linger {
+ int l_onoff;
+ int l_linger;
+};
+struct msghdr {
+ void * msg_name;
+ int msg_namelen;
+ struct iovec * msg_iov;
+ __kernel_size_t msg_iovlen;
+ void * msg_control;
+ __kernel_size_t msg_controllen;
+ unsigned msg_flags;
+};
+struct cmsghdr {
+ __kernel_size_t cmsg_len;
+        int cmsg_level;
+        int cmsg_type;
+};
+static inline __attribute__((always_inline)) struct cmsghdr * __cmsg_nxthdr(void *__ctl, __kernel_size_t __size,
+            struct cmsghdr *__cmsg)
+{
+ struct cmsghdr * __ptr;
+ __ptr = (struct cmsghdr*)(((unsigned char *) __cmsg) + ( ((__cmsg->cmsg_len)+sizeof(long)-1) & ~(sizeof(long)-1) ));
+ if ((unsigned long)((char*)(__ptr+1) - (char *) __ctl) > __size)
+  return (struct cmsghdr *)0;
+ return __ptr;
+}
+static inline __attribute__((always_inline)) struct cmsghdr * cmsg_nxthdr (struct msghdr *__msg, struct cmsghdr *__cmsg)
+{
+ return __cmsg_nxthdr(__msg->msg_control, __msg->msg_controllen, __cmsg);
+}
+struct ucred {
+ __u32 pid;
+ __u32 uid;
+ __u32 gid;
+};
+extern int memcpy_fromiovec(unsigned char *kdata, struct iovec *iov, int len);
+extern int memcpy_fromiovecend(unsigned char *kdata, const struct iovec *iov,
+          int offset, int len);
+extern int csum_partial_copy_fromiovecend(unsigned char *kdata,
+       struct iovec *iov,
+       int offset,
+       unsigned int len, __wsum *csump);
+extern int verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr *address, int mode);
+extern int memcpy_toiovec(struct iovec *v, unsigned char *kdata, int len);
+extern int memcpy_toiovecend(const struct iovec *v, unsigned char *kdata,
+        int offset, int len);
+extern int move_addr_to_user(struct sockaddr *kaddr, int klen, void *uaddr, int *ulen);
+extern int move_addr_to_kernel(void *uaddr, int ulen, struct sockaddr *kaddr);
+extern int put_cmsg(struct msghdr*, int level, int type, int len, void *data);
+typedef struct {
+ unsigned int clock_rate;
+ unsigned int clock_type;
+ unsigned short loopback;
+} sync_serial_settings;
+typedef struct {
+ unsigned int clock_rate;
+ unsigned int clock_type;
+ unsigned short loopback;
+ unsigned int slot_map;
+} te1_settings;
+typedef struct {
+ unsigned short encoding;
+ unsigned short parity;
+} raw_hdlc_proto;
+typedef struct {
+ unsigned int t391;
+ unsigned int t392;
+ unsigned int n391;
+ unsigned int n392;
+ unsigned int n393;
+ unsigned short lmi;
+ unsigned short dce;
+} fr_proto;
+typedef struct {
+ unsigned int dlci;
+} fr_proto_pvc;
+typedef struct {
+ unsigned int dlci;
+ char master[16];
+}fr_proto_pvc_info;
+typedef struct {
+    unsigned int interval;
+    unsigned int timeout;
+} cisco_proto;
+enum {
+ IF_OPER_UNKNOWN,
+ IF_OPER_NOTPRESENT,
+ IF_OPER_DOWN,
+ IF_OPER_LOWERLAYERDOWN,
+ IF_OPER_TESTING,
+ IF_OPER_DORMANT,
+ IF_OPER_UP,
+};
+enum {
+ IF_LINK_MODE_DEFAULT,
+ IF_LINK_MODE_DORMANT,
+};
+struct ifmap
+{
+ unsigned long mem_start;
+ unsigned long mem_end;
+ unsigned short base_addr;
+ unsigned char irq;
+ unsigned char dma;
+ unsigned char port;
+};
+struct if_settings
+{
+ unsigned int type;
+ unsigned int size;
+ union {
+  raw_hdlc_proto *raw_hdlc;
+  cisco_proto *cisco;
+  fr_proto *fr;
+  fr_proto_pvc *fr_pvc;
+  fr_proto_pvc_info *fr_pvc_info;
+  sync_serial_settings *sync;
+  te1_settings *te1;
+ } ifs_ifsu;
+};
+struct ifreq
+{
+ union
+ {
+  char ifrn_name[16];
+ } ifr_ifrn;
+ union {
+  struct sockaddr ifru_addr;
+  struct sockaddr ifru_dstaddr;
+  struct sockaddr ifru_broadaddr;
+  struct sockaddr ifru_netmask;
+  struct sockaddr ifru_hwaddr;
+  short ifru_flags;
+  int ifru_ivalue;
+  int ifru_mtu;
+  struct ifmap ifru_map;
+  char ifru_slave[16];
+  char ifru_newname[16];
+  void * ifru_data;
+  struct if_settings ifru_settings;
+ } ifr_ifru;
+};
+struct ifconf
+{
+ int ifc_len;
+ union
+ {
+  char *ifcu_buf;
+  struct ifreq *ifcu_req;
+ } ifc_ifcu;
+};
+struct ethhdr {
+ unsigned char h_dest[6];
+ unsigned char h_source[6];
+ __be16 h_proto;
+} __attribute__((packed));
+static inline __attribute__((always_inline)) void
+kmemcheck_alloc_shadow(struct page *page, int order, gfp_t flags, int node)
+{
+}
+static inline __attribute__((always_inline)) void
+kmemcheck_free_shadow(struct page *page, int order)
+{
+}
+static inline __attribute__((always_inline)) void
+kmemcheck_slab_alloc(struct kmem_cache *s, gfp_t gfpflags, void *object,
+       size_t size)
+{
+}
+static inline __attribute__((always_inline)) void kmemcheck_slab_free(struct kmem_cache *s, void *object,
+           size_t size)
+{
+}
+static inline __attribute__((always_inline)) void kmemcheck_pagealloc_alloc(struct page *p,
+ unsigned int order, gfp_t gfpflags)
+{
+}
+static inline __attribute__((always_inline)) bool kmemcheck_page_is_tracked(struct page *p)
+{
+ return false;
+}
+static inline __attribute__((always_inline)) void kmemcheck_mark_unallocated(void *address, unsigned int n)
+{
+}
+static inline __attribute__((always_inline)) void kmemcheck_mark_uninitialized(void *address, unsigned int n)
+{
+}
+static inline __attribute__((always_inline)) void kmemcheck_mark_initialized(void *address, unsigned int n)
+{
+}
+static inline __attribute__((always_inline)) void kmemcheck_mark_freed(void *address, unsigned int n)
+{
+}
+static inline __attribute__((always_inline)) void kmemcheck_mark_unallocated_pages(struct page *p,
+          unsigned int n)
+{
+}
+static inline __attribute__((always_inline)) void kmemcheck_mark_uninitialized_pages(struct page *p,
+            unsigned int n)
+{
+}
+static inline __attribute__((always_inline)) void kmemcheck_mark_initialized_pages(struct page *p,
+          unsigned int n)
+{
+}
+static inline __attribute__((always_inline)) bool kmemcheck_is_obj_initialized(unsigned long addr, size_t size)
+{
+ return true;
+}
+typedef enum {
+ SS_FREE = 0,
+ SS_UNCONNECTED,
+ SS_CONNECTING,
+ SS_CONNECTED,
+ SS_DISCONNECTING
+} socket_state;
+struct rand_pool_info {
+ int entropy_count;
+ int buf_size;
+ __u32 buf[0];
+};
+extern void rand_initialize_irq(int irq);
+extern void add_input_randomness(unsigned int type, unsigned int code,
+     unsigned int value);
+extern void add_interrupt_randomness(int irq);
+extern void add_random_data(const char* rdata, int count);
+extern void get_random_bytes(void *buf, int nbytes);
+void generate_random_uuid(unsigned char uuid_out[16]);
+extern __u32 secure_ip_id(__be32 daddr);
+extern u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport);
+extern u32 secure_ipv6_port_ephemeral(const __be32 *saddr, const __be32 *daddr,
+          __be16 dport);
+extern __u32 secure_tcp_sequence_number(__be32 saddr, __be32 daddr,
+     __be16 sport, __be16 dport);
+extern __u32 secure_tcpv6_sequence_number(__be32 *saddr, __be32 *daddr,
+       __be16 sport, __be16 dport);
+extern u64 secure_dccp_sequence_number(__be32 saddr, __be32 daddr,
+           __be16 sport, __be16 dport);
+unsigned int get_random_int(void);
+unsigned long randomize_range(unsigned long start, unsigned long end, unsigned long len);
+u32 random32(void);
+void srandom32(u32 seed);
+struct poll_table_struct;
+struct pipe_inode_info;
+struct inode;
+struct net;
+enum sock_type {
+ SOCK_STREAM = 1,
+ SOCK_DGRAM = 2,
+ SOCK_RAW = 3,
+ SOCK_RDM = 4,
+ SOCK_SEQPACKET = 5,
+ SOCK_DCCP = 6,
+ SOCK_PACKET = 10,
+};
+enum sock_shutdown_cmd {
+ SHUT_RD = 0,
+ SHUT_WR = 1,
+ SHUT_RDWR = 2,
+};
+struct socket {
+ socket_state state;
+ int type_begin[0];;
+ short type;
+ int type_end[0];;
+ unsigned long flags;
+ struct fasync_struct *fasync_list;
+ wait_queue_head_t wait;
+ struct file *file;
+ struct sock *sk;
+ const struct proto_ops *ops;
+};
+struct vm_area_struct;
+struct page;
+struct kiocb;
+struct sockaddr;
+struct msghdr;
+struct module;
+struct proto_ops {
+ int family;
+ struct module *owner;
+ int (*release) (struct socket *sock);
+ int (*bind) (struct socket *sock,
+          struct sockaddr *myaddr,
+          int sockaddr_len);
+ int (*connect) (struct socket *sock,
+          struct sockaddr *vaddr,
+          int sockaddr_len, int flags);
+ int (*socketpair)(struct socket *sock1,
+          struct socket *sock2);
+ int (*accept) (struct socket *sock,
+          struct socket *newsock, int flags);
+ int (*getname) (struct socket *sock,
+          struct sockaddr *addr,
+          int *sockaddr_len, int peer);
+ unsigned int (*poll) (struct file *file, struct socket *sock,
+          struct poll_table_struct *wait);
+ int (*ioctl) (struct socket *sock, unsigned int cmd,
+          unsigned long arg);
+ int (*compat_ioctl) (struct socket *sock, unsigned int cmd,
+          unsigned long arg);
+ int (*listen) (struct socket *sock, int len);
+ int (*shutdown) (struct socket *sock, int flags);
+ int (*setsockopt)(struct socket *sock, int level,
+          int optname, char *optval, unsigned int optlen);
+ int (*getsockopt)(struct socket *sock, int level,
+          int optname, char *optval, int *optlen);
+ int (*compat_setsockopt)(struct socket *sock, int level,
+          int optname, char *optval, unsigned int optlen);
+ int (*compat_getsockopt)(struct socket *sock, int level,
+          int optname, char *optval, int *optlen);
+ int (*sendmsg) (struct kiocb *iocb, struct socket *sock,
+          struct msghdr *m, size_t total_len);
+ int (*recvmsg) (struct kiocb *iocb, struct socket *sock,
+          struct msghdr *m, size_t total_len,
+          int flags);
+ int (*mmap) (struct file *file, struct socket *sock,
+          struct vm_area_struct * vma);
+ ssize_t (*sendpage) (struct socket *sock, struct page *page,
+          int offset, size_t size, int flags);
+ ssize_t (*splice_read)(struct socket *sock, loff_t *ppos,
+           struct pipe_inode_info *pipe, size_t len, unsigned int flags);
+};
+struct net_proto_family {
+ int family;
+ int (*create)(struct net *net, struct socket *sock, int protocol);
+ struct module *owner;
+};
+struct iovec;
+struct kvec;
+enum {
+ SOCK_WAKE_IO,
+ SOCK_WAKE_WAITD,
+ SOCK_WAKE_SPACE,
+ SOCK_WAKE_URG,
+};
+extern int sock_wake_async(struct socket *sk, int how, int band);
+extern int sock_register(const struct net_proto_family *fam);
+extern void sock_unregister(int family);
+extern int sock_create(int family, int type, int proto,
+     struct socket **res);
+extern int sock_create_kern(int family, int type, int proto,
+          struct socket **res);
+extern int sock_create_lite(int family, int type, int proto,
+          struct socket **res);
+extern void sock_release(struct socket *sock);
+extern int sock_sendmsg(struct socket *sock, struct msghdr *msg,
+      size_t len);
+extern int sock_recvmsg(struct socket *sock, struct msghdr *msg,
+      size_t size, int flags);
+extern int sock_map_fd(struct socket *sock, int flags);
+extern struct socket *sockfd_lookup(int fd, int *err);
+extern int net_ratelimit(void);
+extern int kernel_sendmsg(struct socket *sock, struct msghdr *msg,
+        struct kvec *vec, size_t num, size_t len);
+extern int kernel_recvmsg(struct socket *sock, struct msghdr *msg,
+        struct kvec *vec, size_t num,
+        size_t len, int flags);
+extern int kernel_bind(struct socket *sock, struct sockaddr *addr,
+         int addrlen);
+extern int kernel_listen(struct socket *sock, int backlog);
+extern int kernel_accept(struct socket *sock, struct socket **newsock,
+    int flags);
+extern int kernel_connect(struct socket *sock, struct sockaddr *addr,
+     int addrlen, int flags);
+extern int kernel_getsockname(struct socket *sock, struct sockaddr *addr,
+         int *addrlen);
+extern int kernel_getpeername(struct socket *sock, struct sockaddr *addr,
+         int *addrlen);
+extern int kernel_getsockopt(struct socket *sock, int level, int optname,
+        char *optval, int *optlen);
+extern int kernel_setsockopt(struct socket *sock, int level, int optname,
+        char *optval, unsigned int optlen);
+extern int kernel_sendpage(struct socket *sock, struct page *page, int offset,
+      size_t size, int flags);
+extern int kernel_sock_ioctl(struct socket *sock, int cmd, unsigned long arg);
+extern int kernel_sock_shutdown(struct socket *sock,
+    enum sock_shutdown_cmd how);
+extern struct ratelimit_state net_ratelimit_state;
+struct ts_config;
+struct ts_state
+{
+ unsigned int offset;
+ char cb[40];
+};
+struct ts_ops
+{
+ const char *name;
+ struct ts_config * (*init)(const void *, unsigned int, gfp_t, int);
+ unsigned int (*find)(struct ts_config *,
+     struct ts_state *);
+ void (*destroy)(struct ts_config *);
+ void * (*get_pattern)(struct ts_config *);
+ unsigned int (*get_pattern_len)(struct ts_config *);
+ struct module *owner;
+ struct list_head list;
+};
+struct ts_config
+{
+ struct ts_ops *ops;
+ int flags;
+ unsigned int (*get_next_block)(unsigned int consumed,
+        const u8 **dst,
+        struct ts_config *conf,
+        struct ts_state *state);
+ void (*finish)(struct ts_config *conf,
+       struct ts_state *state);
+};
+static inline __attribute__((always_inline)) unsigned int textsearch_next(struct ts_config *conf,
+        struct ts_state *state)
+{
+ unsigned int ret = conf->ops->find(conf, state);
+ if (conf->finish)
+  conf->finish(conf, state);
+ return ret;
+}
+static inline __attribute__((always_inline)) unsigned int textsearch_find(struct ts_config *conf,
+        struct ts_state *state)
+{
+ state->offset = 0;
+ return textsearch_next(conf, state);
+}
+static inline __attribute__((always_inline)) void *textsearch_get_pattern(struct ts_config *conf)
+{
+ return conf->ops->get_pattern(conf);
+}
+static inline __attribute__((always_inline)) unsigned int textsearch_get_pattern_len(struct ts_config *conf)
+{
+ return conf->ops->get_pattern_len(conf);
+}
+extern int textsearch_register(struct ts_ops *);
+extern int textsearch_unregister(struct ts_ops *);
+extern struct ts_config *textsearch_prepare(const char *, const void *,
+         unsigned int, gfp_t, int);
+extern void textsearch_destroy(struct ts_config *conf);
+extern unsigned int textsearch_find_continuous(struct ts_config *,
+            struct ts_state *,
+            const void *, unsigned int);
+static inline __attribute__((always_inline)) struct ts_config *alloc_ts_config(size_t payload,
+      gfp_t gfp_mask)
+{
+ struct ts_config *conf;
+ conf = kzalloc((((sizeof(*conf)) + 8 -1) & ~(8 -1)) + payload, gfp_mask);
+ if (conf == ((void *)0))
+  return ERR_PTR(-12);
+ return conf;
+}
+static inline __attribute__((always_inline)) void *ts_config_priv(struct ts_config *conf)
+{
+ return ((u8 *) conf + (((sizeof(struct ts_config)) + 8 -1) & ~(8 -1)));
+}
+struct in6_addr
+{
+ union
+ {
+  __u8 u6_addr8[16];
+  __be16 u6_addr16[8];
+  __be32 u6_addr32[4];
+ } in6_u;
+};
+extern const struct in6_addr in6addr_any;
+extern const struct in6_addr in6addr_loopback;
+extern const struct in6_addr in6addr_linklocal_allnodes;
+extern const struct in6_addr in6addr_linklocal_allrouters;
+struct sockaddr_in6 {
+ unsigned short int sin6_family;
+ __be16 sin6_port;
+ __be32 sin6_flowinfo;
+ struct in6_addr sin6_addr;
+ __u32 sin6_scope_id;
+};
+struct ipv6_mreq {
+ struct in6_addr ipv6mr_multiaddr;
+ int ipv6mr_ifindex;
+};
+struct in6_flowlabel_req
+{
+ struct in6_addr flr_dst;
+ __be32 flr_label;
+ __u8 flr_action;
+ __u8 flr_share;
+ __u16 flr_flags;
+ __u16 flr_expires;
+ __u16 flr_linger;
+ __u32 __flr_pad;
+};
+ __wsum csum_partial(const void *buff, int len, __wsum sum);
+ __wsum csum_partial_copy_generic(const void *src, void *dst,
+         int len, __wsum sum,
+         int *src_err_ptr, int *dst_err_ptr);
+static inline __attribute__((always_inline))
+__wsum csum_partial_copy_nocheck(const void *src, void *dst,
+     int len, __wsum sum)
+{
+ return csum_partial_copy_generic(src, dst, len, sum, ((void *)0), ((void *)0));
+}
+static inline __attribute__((always_inline))
+__wsum csum_partial_copy_from_user(const void *src, void *dst,
+       int len, __wsum sum, int *err_ptr)
+{
+ return csum_partial_copy_generic(( const void *)src, dst,
+     len, sum, err_ptr, ((void *)0));
+}
+static inline __attribute__((always_inline)) __sum16 csum_fold(__wsum sum)
+{
+ unsigned int __dummy;
+ __asm__("swap.w %0, %1\n\t"
+  "extu.w	%0, %0\n\t"
+  "extu.w	%1, %1\n\t"
+  "add	%1, %0\n\t"
+  "swap.w	%0, %1\n\t"
+  "add	%1, %0\n\t"
+  "not	%0, %0\n\t"
+  : "=r" (sum), "=&r" (__dummy)
+  : "0" (sum)
+  : "t");
+ return ( __sum16)sum;
+}
+static inline __attribute__((always_inline)) __sum16 ip_fast_csum(const void *iph, unsigned int ihl)
+{
+ unsigned int sum, __dummy0, __dummy1;
+ __asm__ __volatile__(
+  "mov.l	@%1+, %0\n\t"
+  "mov.l	@%1+, %3\n\t"
+  "add	#-2, %2\n\t"
+  "clrt\n\t"
+  "1:\t"
+  "addc	%3, %0\n\t"
+  "movt	%4\n\t"
+  "mov.l	@%1+, %3\n\t"
+  "dt	%2\n\t"
+  "bf/s	1b\n\t"
+  " cmp/eq #1, %4\n\t"
+  "addc	%3, %0\n\t"
+  "addc	%2, %0"
+ : "=r" (sum), "=r" (iph), "=r" (ihl), "=&r" (__dummy0), "=&z" (__dummy1)
+ : "1" (iph), "2" (ihl)
+ : "t", "memory");
+ return csum_fold(sum);
+}
+static inline __attribute__((always_inline)) __wsum csum_tcpudp_nofold(__be32 saddr, __be32 daddr,
+     unsigned short len,
+     unsigned short proto,
+     __wsum sum)
+{
+ unsigned long len_proto = (proto + len) << 8;
+ __asm__("clrt\n\t"
+  "addc	%0, %1\n\t"
+  "addc	%2, %1\n\t"
+  "addc	%3, %1\n\t"
+  "movt	%0\n\t"
+  "add	%1, %0"
+  : "=r" (sum), "=r" (len_proto)
+  : "r" (daddr), "r" (saddr), "1" (len_proto), "0" (sum)
+  : "t");
+ return sum;
+}
+static inline __attribute__((always_inline)) __sum16 csum_tcpudp_magic(__be32 saddr, __be32 daddr,
+     unsigned short len,
+     unsigned short proto,
+     __wsum sum)
+{
+ return csum_fold(csum_tcpudp_nofold(saddr, daddr, len, proto, sum));
+}
+static inline __attribute__((always_inline)) __sum16 ip_compute_csum(const void *buff, int len)
+{
+    return csum_fold(csum_partial(buff, len, 0));
+}
+static inline __attribute__((always_inline)) __sum16 csum_ipv6_magic(const struct in6_addr *saddr,
+          const struct in6_addr *daddr,
+          __u32 len, unsigned short proto,
+          __wsum sum)
+{
+ unsigned int __dummy;
+ __asm__("clrt\n\t"
+  "mov.l	@(0,%2), %1\n\t"
+  "addc	%1, %0\n\t"
+  "mov.l	@(4,%2), %1\n\t"
+  "addc	%1, %0\n\t"
+  "mov.l	@(8,%2), %1\n\t"
+  "addc	%1, %0\n\t"
+  "mov.l	@(12,%2), %1\n\t"
+  "addc	%1, %0\n\t"
+  "mov.l	@(0,%3), %1\n\t"
+  "addc	%1, %0\n\t"
+  "mov.l	@(4,%3), %1\n\t"
+  "addc	%1, %0\n\t"
+  "mov.l	@(8,%3), %1\n\t"
+  "addc	%1, %0\n\t"
+  "mov.l	@(12,%3), %1\n\t"
+  "addc	%1, %0\n\t"
+  "addc	%4, %0\n\t"
+  "addc	%5, %0\n\t"
+  "movt	%1\n\t"
+  "add	%1, %0\n"
+  : "=r" (sum), "=&r" (__dummy)
+  : "r" (saddr), "r" (daddr),
+    "r" ((( __be32)(__builtin_constant_p((__u32)((len))) ? ((__u32)( (((__u32)((len)) & (__u32)0x000000ffUL) << 24) | (((__u32)((len)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((len)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((len)) & (__u32)0xff000000UL) >> 24))) : __fswab32((len))))), "r" ((( __be32)(__builtin_constant_p((__u32)((proto))) ? ((__u32)( (((__u32)((proto)) & (__u32)0x000000ffUL) << 24) | (((__u32)((proto)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((proto)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((proto)) & (__u32)0xff000000UL) >> 24))) : __fswab32((proto))))), "0" (sum)
+  : "t");
+ return csum_fold(sum);
+}
+static inline __attribute__((always_inline)) __wsum csum_and_copy_to_user(const void *src,
+        void *dst,
+        int len, __wsum sum,
+        int *err_ptr)
+{
+ if (((void)0, __access_ok((unsigned long )(dst), (len))))
+  return csum_partial_copy_generic(( const void *)src,
+      dst, len, sum, ((void *)0), err_ptr);
+ if (len)
+  *err_ptr = -14;
+ return ( __wsum)-1;
+}
+static inline __attribute__((always_inline))
+__wsum csum_and_copy_from_user (const void *src, void *dst,
+          int len, __wsum sum, int *err_ptr)
+{
+ if (((void)0, __access_ok((unsigned long )(src), (len))))
+  return csum_partial_copy_from_user(src, dst, len, sum, err_ptr);
+ if (len)
+  *err_ptr = -14;
+ return sum;
+}
+static inline __attribute__((always_inline)) __wsum csum_add(__wsum csum, __wsum addend)
+{
+ u32 res = ( u32)csum;
+ res += ( u32)addend;
+ return ( __wsum)(res + (res < ( u32)addend));
+}
+static inline __attribute__((always_inline)) __wsum csum_sub(__wsum csum, __wsum addend)
+{
+ return csum_add(csum, ~addend);
+}
+static inline __attribute__((always_inline)) __wsum
+csum_block_add(__wsum csum, __wsum csum2, int offset)
+{
+ u32 sum = ( u32)csum2;
+ if (offset&1)
+  sum = ((sum&0xFF00FF)<<8)+((sum>>8)&0xFF00FF);
+ return csum_add(csum, ( __wsum)sum);
+}
+static inline __attribute__((always_inline)) __wsum
+csum_block_sub(__wsum csum, __wsum csum2, int offset)
+{
+ u32 sum = ( u32)csum2;
+ if (offset&1)
+  sum = ((sum&0xFF00FF)<<8)+((sum>>8)&0xFF00FF);
+ return csum_sub(csum, ( __wsum)sum);
+}
+static inline __attribute__((always_inline)) __wsum csum_unfold(__sum16 n)
+{
+ return ( __wsum)n;
+}
+static inline __attribute__((always_inline)) void csum_replace4(__sum16 *sum, __be32 from, __be32 to)
+{
+ __be32 diff[] = { ~from, to };
+ *sum = csum_fold(csum_partial(diff, sizeof(diff), ~csum_unfold(*sum)));
+}
+static inline __attribute__((always_inline)) void csum_replace2(__sum16 *sum, __be16 from, __be16 to)
+{
+ csum_replace4(sum, ( __be32)from, ( __be32)to);
+}
+struct sk_buff;
+extern void inet_proto_csum_replace4(__sum16 *sum, struct sk_buff *skb,
+         __be32 from, __be32 to, int pseudohdr);
+static inline __attribute__((always_inline)) void inet_proto_csum_replace2(__sum16 *sum, struct sk_buff *skb,
+         __be16 from, __be16 to,
+         int pseudohdr)
+{
+ inet_proto_csum_replace4(sum, skb, ( __be32)from,
+     ( __be32)to, pseudohdr);
+}
+struct klist_node;
+struct klist {
+ spinlock_t k_lock;
+ struct list_head k_list;
+ void (*get)(struct klist_node *);
+ void (*put)(struct klist_node *);
+} __attribute__ ((aligned (4)));
+extern void klist_init(struct klist *k, void (*get)(struct klist_node *),
+         void (*put)(struct klist_node *));
+struct klist_node {
+ void *n_klist;
+ struct list_head n_node;
+ struct kref n_ref;
+};
+extern void klist_add_tail(struct klist_node *n, struct klist *k);
+extern void klist_add_head(struct klist_node *n, struct klist *k);
+extern void klist_add_after(struct klist_node *n, struct klist_node *pos);
+extern void klist_add_before(struct klist_node *n, struct klist_node *pos);
+extern void klist_del(struct klist_node *n);
+extern void klist_remove(struct klist_node *n);
+extern int klist_node_attached(struct klist_node *n);
+struct klist_iter {
+ struct klist *i_klist;
+ struct klist_node *i_cur;
+};
+extern void klist_iter_init(struct klist *k, struct klist_iter *i);
+extern void klist_iter_init_node(struct klist *k, struct klist_iter *i,
+     struct klist_node *n);
+extern void klist_iter_exit(struct klist_iter *i);
+extern struct klist_node *klist_next(struct klist_iter *i);
+extern void (*pm_idle)(void);
+extern void (*pm_power_off)(void);
+extern void (*pm_power_off_prepare)(void);
+struct device;
+typedef struct pm_message {
+ int event;
+} pm_message_t;
+struct dev_pm_ops {
+ int (*prepare)(struct device *dev);
+ void (*complete)(struct device *dev);
+ int (*suspend)(struct device *dev);
+ int (*resume)(struct device *dev);
+ int (*freeze)(struct device *dev);
+ int (*thaw)(struct device *dev);
+ int (*poweroff)(struct device *dev);
+ int (*restore)(struct device *dev);
+ int (*suspend_noirq)(struct device *dev);
+ int (*resume_noirq)(struct device *dev);
+ int (*freeze_noirq)(struct device *dev);
+ int (*thaw_noirq)(struct device *dev);
+ int (*poweroff_noirq)(struct device *dev);
+ int (*restore_noirq)(struct device *dev);
+ int (*runtime_suspend)(struct device *dev);
+ int (*runtime_resume)(struct device *dev);
+ int (*runtime_idle)(struct device *dev);
+};
+enum dpm_state {
+ DPM_INVALID,
+ DPM_ON,
+ DPM_PREPARING,
+ DPM_RESUMING,
+ DPM_SUSPENDING,
+ DPM_OFF,
+ DPM_OFF_IRQ,
+};
+enum rpm_status {
+ RPM_ACTIVE = 0,
+ RPM_RESUMING,
+ RPM_SUSPENDED,
+ RPM_SUSPENDING,
+};
+enum rpm_request {
+ RPM_REQ_NONE = 0,
+ RPM_REQ_IDLE,
+ RPM_REQ_SUSPEND,
+ RPM_REQ_RESUME,
+};
+struct dev_pm_info {
+ pm_message_t power_state;
+ unsigned int can_wakeup:1;
+ unsigned int should_wakeup:1;
+ enum dpm_state status;
+ struct list_head entry;
+ struct timer_list suspend_timer;
+ unsigned long timer_expires;
+ struct work_struct work;
+ wait_queue_head_t wait_queue;
+ spinlock_t lock;
+ atomic_t usage_count;
+ atomic_t child_count;
+ unsigned int disable_depth:3;
+ unsigned int ignore_children:1;
+ unsigned int idle_notification:1;
+ unsigned int request_pending:1;
+ unsigned int deferred_resume:1;
+ enum rpm_request request;
+ enum rpm_status runtime_status;
+ int runtime_error;
+};
+extern void device_pm_lock(void);
+extern int sysdev_resume(void);
+extern void dpm_resume_noirq(pm_message_t state);
+extern void dpm_resume_end(pm_message_t state);
+extern void device_pm_unlock(void);
+extern int sysdev_suspend(pm_message_t state);
+extern int dpm_suspend_noirq(pm_message_t state);
+extern int dpm_suspend_start(pm_message_t state);
+extern void __suspend_report_result(const char *function, void *fn, int ret);
+enum dpm_order {
+ DPM_ORDER_NONE,
+ DPM_ORDER_DEV_AFTER_PARENT,
+ DPM_ORDER_PARENT_BEFORE_DEV,
+ DPM_ORDER_DEV_LAST,
+};
+extern unsigned int pm_flags;
+struct dev_archdata {
+};
+struct platform_device;
+int platform_resource_setup_memory(struct platform_device *pdev,
+       char *name, unsigned long memsize);
+void plat_early_device_setup(void);
+struct pdev_archdata {
+ int hwblk_id;
+ unsigned long flags;
+ struct list_head entry;
+ struct mutex mutex;
+};
+struct device;
+struct device_private;
+struct device_driver;
+struct driver_private;
+struct class;
+struct class_private;
+struct bus_type;
+struct bus_type_private;
+struct bus_attribute {
+ struct attribute attr;
+ ssize_t (*show)(struct bus_type *bus, char *buf);
+ ssize_t (*store)(struct bus_type *bus, const char *buf, size_t count);
+};
+extern int bus_create_file(struct bus_type *,
+     struct bus_attribute *);
+extern void bus_remove_file(struct bus_type *, struct bus_attribute *);
+struct bus_type {
+ const char *name;
+ struct bus_attribute *bus_attrs;
+ struct device_attribute *dev_attrs;
+ struct driver_attribute *drv_attrs;
+ int (*match)(struct device *dev, struct device_driver *drv);
+ int (*uevent)(struct device *dev, struct kobj_uevent_env *env);
+ int (*probe)(struct device *dev);
+ int (*remove)(struct device *dev);
+ void (*shutdown)(struct device *dev);
+ int (*suspend)(struct device *dev, pm_message_t state);
+ int (*resume)(struct device *dev);
+ const struct dev_pm_ops *pm;
+ struct bus_type_private *p;
+};
+extern int bus_register(struct bus_type *bus);
+extern void bus_unregister(struct bus_type *bus);
+extern int bus_rescan_devices(struct bus_type *bus);
+int bus_for_each_dev(struct bus_type *bus, struct device *start, void *data,
+       int (*fn)(struct device *dev, void *data));
+struct device *bus_find_device(struct bus_type *bus, struct device *start,
+          void *data,
+          int (*match)(struct device *dev, void *data));
+struct device *bus_find_device_by_name(struct bus_type *bus,
+           struct device *start,
+           const char *name);
+int bus_for_each_drv(struct bus_type *bus,
+      struct device_driver *start, void *data,
+      int (*fn)(struct device_driver *, void *));
+void bus_sort_breadthfirst(struct bus_type *bus,
+      int (*compare)(const struct device *a,
+       const struct device *b));
+struct notifier_block;
+extern int bus_register_notifier(struct bus_type *bus,
+     struct notifier_block *nb);
+extern int bus_unregister_notifier(struct bus_type *bus,
+       struct notifier_block *nb);
+extern struct kset *bus_get_kset(struct bus_type *bus);
+extern struct klist *bus_get_device_klist(struct bus_type *bus);
+struct device_driver {
+ const char *name;
+ struct bus_type *bus;
+ struct module *owner;
+ const char *mod_name;
+ bool suppress_bind_attrs;
+ int (*probe) (struct device *dev);
+ int (*remove) (struct device *dev);
+ void (*shutdown) (struct device *dev);
+ int (*suspend) (struct device *dev, pm_message_t state);
+ int (*resume) (struct device *dev);
+ const struct attribute_group **groups;
+ const struct dev_pm_ops *pm;
+ struct driver_private *p;
+};
+extern int driver_register(struct device_driver *drv);
+extern void driver_unregister(struct device_driver *drv);
+extern struct device_driver *get_driver(struct device_driver *drv);
+extern void put_driver(struct device_driver *drv);
+extern struct device_driver *driver_find(const char *name,
+      struct bus_type *bus);
+extern int driver_probe_done(void);
+extern void wait_for_device_probe(void);
+struct driver_attribute {
+ struct attribute attr;
+ ssize_t (*show)(struct device_driver *driver, char *buf);
+ ssize_t (*store)(struct device_driver *driver, const char *buf,
+    size_t count);
+};
+extern int driver_create_file(struct device_driver *driver,
+        struct driver_attribute *attr);
+extern void driver_remove_file(struct device_driver *driver,
+          struct driver_attribute *attr);
+extern int driver_add_kobj(struct device_driver *drv,
+     struct kobject *kobj,
+     const char *fmt, ...);
+extern int driver_for_each_device(struct device_driver *drv,
+            struct device *start,
+            void *data,
+            int (*fn)(struct device *dev,
+        void *));
+struct device *driver_find_device(struct device_driver *drv,
+      struct device *start, void *data,
+      int (*match)(struct device *dev, void *data));
+struct class {
+ const char *name;
+ struct module *owner;
+ struct class_attribute *class_attrs;
+ struct device_attribute *dev_attrs;
+ struct kobject *dev_kobj;
+ int (*dev_uevent)(struct device *dev, struct kobj_uevent_env *env);
+ char *(*devnode)(struct device *dev, mode_t *mode);
+ void (*class_release)(struct class *class);
+ void (*dev_release)(struct device *dev);
+ int (*suspend)(struct device *dev, pm_message_t state);
+ int (*resume)(struct device *dev);
+ const struct dev_pm_ops *pm;
+ struct class_private *p;
+};
+struct class_dev_iter {
+ struct klist_iter ki;
+ const struct device_type *type;
+};
+extern struct kobject *sysfs_dev_block_kobj;
+extern struct kobject *sysfs_dev_char_kobj;
+extern int __class_register(struct class *class,
+      struct lock_class_key *key);
+extern void class_unregister(struct class *class);
+struct class_compat;
+struct class_compat *class_compat_register(const char *name);
+void class_compat_unregister(struct class_compat *cls);
+int class_compat_create_link(struct class_compat *cls, struct device *dev,
+        struct device *device_link);
+void class_compat_remove_link(struct class_compat *cls, struct device *dev,
+         struct device *device_link);
+extern void class_dev_iter_init(struct class_dev_iter *iter,
+    struct class *class,
+    struct device *start,
+    const struct device_type *type);
+extern struct device *class_dev_iter_next(struct class_dev_iter *iter);
+extern void class_dev_iter_exit(struct class_dev_iter *iter);
+extern int class_for_each_device(struct class *class, struct device *start,
+     void *data,
+     int (*fn)(struct device *dev, void *data));
+extern struct device *class_find_device(struct class *class,
+     struct device *start, void *data,
+     int (*match)(struct device *, void *));
+struct class_attribute {
+ struct attribute attr;
+ ssize_t (*show)(struct class *class, char *buf);
+ ssize_t (*store)(struct class *class, const char *buf, size_t count);
+};
+extern int class_create_file(struct class *class,
+       const struct class_attribute *attr);
+extern void class_remove_file(struct class *class,
+         const struct class_attribute *attr);
+struct class_interface {
+ struct list_head node;
+ struct class *class;
+ int (*add_dev) (struct device *, struct class_interface *);
+ void (*remove_dev) (struct device *, struct class_interface *);
+};
+extern int class_interface_register(struct class_interface *);
+extern void class_interface_unregister(struct class_interface *);
+extern struct class * __class_create(struct module *owner,
+        const char *name,
+        struct lock_class_key *key);
+extern void class_destroy(struct class *cls);
+struct device_type {
+ const char *name;
+ const struct attribute_group **groups;
+ int (*uevent)(struct device *dev, struct kobj_uevent_env *env);
+ char *(*devnode)(struct device *dev, mode_t *mode);
+ void (*release)(struct device *dev);
+ const struct dev_pm_ops *pm;
+};
+struct device_attribute {
+ struct attribute attr;
+ ssize_t (*show)(struct device *dev, struct device_attribute *attr,
+   char *buf);
+ ssize_t (*store)(struct device *dev, struct device_attribute *attr,
+    const char *buf, size_t count);
+};
+extern int device_create_file(struct device *device,
+        struct device_attribute *entry);
+extern void device_remove_file(struct device *dev,
+          struct device_attribute *attr);
+extern int device_create_bin_file(struct device *dev,
+            struct bin_attribute *attr);
+extern void device_remove_bin_file(struct device *dev,
+       struct bin_attribute *attr);
+extern int device_schedule_callback_owner(struct device *dev,
+  void (*func)(struct device *dev), struct module *owner);
+typedef void (*dr_release_t)(struct device *dev, void *res);
+typedef int (*dr_match_t)(struct device *dev, void *res, void *match_data);
+extern void *devres_alloc(dr_release_t release, size_t size, gfp_t gfp);
+extern void devres_free(void *res);
+extern void devres_add(struct device *dev, void *res);
+extern void *devres_find(struct device *dev, dr_release_t release,
+    dr_match_t match, void *match_data);
+extern void *devres_get(struct device *dev, void *new_res,
+   dr_match_t match, void *match_data);
+extern void *devres_remove(struct device *dev, dr_release_t release,
+      dr_match_t match, void *match_data);
+extern int devres_destroy(struct device *dev, dr_release_t release,
+     dr_match_t match, void *match_data);
+extern void * devres_open_group(struct device *dev, void *id,
+          gfp_t gfp);
+extern void devres_close_group(struct device *dev, void *id);
+extern void devres_remove_group(struct device *dev, void *id);
+extern int devres_release_group(struct device *dev, void *id);
+extern void *devm_kzalloc(struct device *dev, size_t size, gfp_t gfp);
+extern void devm_kfree(struct device *dev, void *p);
+struct device_dma_parameters {
+ unsigned int max_segment_size;
+ unsigned long segment_boundary_mask;
+};
+struct device {
+ struct device *parent;
+ struct device_private *p;
+ struct kobject kobj;
+ const char *init_name;
+ struct device_type *type;
+ unsigned suppress_bind:1;
+ struct semaphore sem;
+ struct bus_type *bus;
+ struct device_driver *driver;
+ void *platform_data;
+ struct dev_pm_info power;
+ u64 *dma_mask;
+ u64 coherent_dma_mask;
+ struct device_dma_parameters *dma_parms;
+ struct list_head dma_pools;
+ struct dma_coherent_mem *dma_mem;
+ struct dev_archdata archdata;
+ dev_t devt;
+ spinlock_t devres_lock;
+ struct list_head devres_head;
+ struct klist_node knode_class;
+ struct class *class;
+ const struct attribute_group **groups;
+ void (*release)(struct device *dev);
+};
+static inline __attribute__((always_inline)) void device_init_wakeup(struct device *dev, int val)
+{
+ dev->power.can_wakeup = dev->power.should_wakeup = !!val;
+}
+static inline __attribute__((always_inline)) void device_set_wakeup_capable(struct device *dev, int val)
+{
+ dev->power.can_wakeup = !!val;
+}
+static inline __attribute__((always_inline)) int device_can_wakeup(struct device *dev)
+{
+ return dev->power.can_wakeup;
+}
+static inline __attribute__((always_inline)) void device_set_wakeup_enable(struct device *dev, int val)
+{
+ dev->power.should_wakeup = !!val;
+}
+static inline __attribute__((always_inline)) int device_may_wakeup(struct device *dev)
+{
+ return dev->power.can_wakeup && dev->power.should_wakeup;
+}
+static inline __attribute__((always_inline)) const char *dev_name(const struct device *dev)
+{
+ return kobject_name(&dev->kobj);
+}
+extern int dev_set_name(struct device *dev, const char *name, ...)
+   __attribute__((format(printf, 2, 3)));
+static inline __attribute__((always_inline)) int dev_to_node(struct device *dev)
+{
+ return -1;
+}
+static inline __attribute__((always_inline)) void set_dev_node(struct device *dev, int node)
+{
+}
+static inline __attribute__((always_inline)) unsigned int dev_get_uevent_suppress(const struct device *dev)
+{
+ return dev->kobj.uevent_suppress;
+}
+static inline __attribute__((always_inline)) void dev_set_uevent_suppress(struct device *dev, int val)
+{
+ dev->kobj.uevent_suppress = val;
+}
+static inline __attribute__((always_inline)) int device_is_registered(struct device *dev)
+{
+ return dev->kobj.state_in_sysfs;
+}
+void driver_init(void);
+extern int device_register(struct device *dev);
+extern void device_unregister(struct device *dev);
+extern void device_initialize(struct device *dev);
+extern int device_add(struct device *dev);
+extern void device_del(struct device *dev);
+extern int device_for_each_child(struct device *dev, void *data,
+       int (*fn)(struct device *dev, void *data));
+extern struct device *device_find_child(struct device *dev, void *data,
+    int (*match)(struct device *dev, void *data));
+extern int device_rename(struct device *dev, char *new_name);
+extern int device_move(struct device *dev, struct device *new_parent,
+         enum dpm_order dpm_order);
+extern const char *device_get_devnode(struct device *dev,
+          mode_t *mode, const char **tmp);
+extern void *dev_get_drvdata(const struct device *dev);
+extern void dev_set_drvdata(struct device *dev, void *data);
+extern struct device *__root_device_register(const char *name,
+          struct module *owner);
+static inline __attribute__((always_inline)) struct device *root_device_register(const char *name)
+{
+ return __root_device_register(name, (&__this_module));
+}
+extern void root_device_unregister(struct device *root);
+static inline __attribute__((always_inline)) void *dev_get_platdata(const struct device *dev)
+{
+ return dev->platform_data;
+}
+extern int device_bind_driver(struct device *dev);
+extern void device_release_driver(struct device *dev);
+extern int device_attach(struct device *dev);
+extern int driver_attach(struct device_driver *drv);
+extern int device_reprobe(struct device *dev);
+extern struct device *device_create_vargs(struct class *cls,
+       struct device *parent,
+       dev_t devt,
+       void *drvdata,
+       const char *fmt,
+       va_list vargs);
+extern struct device *device_create(struct class *cls, struct device *parent,
+        dev_t devt, void *drvdata,
+        const char *fmt, ...)
+        __attribute__((format(printf, 5, 6)));
+extern void device_destroy(struct class *cls, dev_t devt);
+extern int (*platform_notify)(struct device *dev);
+extern int (*platform_notify_remove)(struct device *dev);
+extern struct device *get_device(struct device *dev);
+extern void put_device(struct device *dev);
+extern void wait_for_device_probe(void);
+static inline __attribute__((always_inline)) int devtmpfs_create_node(struct device *dev) { return 0; }
+static inline __attribute__((always_inline)) int devtmpfs_delete_node(struct device *dev) { return 0; }
+static inline __attribute__((always_inline)) int devtmpfs_mount(const char *mountpoint) { return 0; }
+extern void device_shutdown(void);
+extern void sysdev_shutdown(void);
+extern const char *dev_driver_string(const struct device *dev);
+enum bug_trap_type {
+ BUG_TRAP_TYPE_NONE = 0,
+ BUG_TRAP_TYPE_WARN = 1,
+ BUG_TRAP_TYPE_BUG = 2,
+};
+struct pt_regs;
+static inline __attribute__((always_inline)) int is_warning_bug(const struct bug_entry *bug)
+{
+ return bug->flags & (1<<0);
+}
+const struct bug_entry *find_bug(unsigned long bugaddr);
+enum bug_trap_type report_bug(unsigned long bug_addr, struct pt_regs *regs);
+int is_valid_bugaddr(unsigned long addr);
+enum dma_attr {
+ DMA_ATTR_WRITE_BARRIER,
+ DMA_ATTR_WEAK_ORDERING,
+ DMA_ATTR_MAX,
+};
+struct dma_attrs {
+ unsigned long flags[(((DMA_ATTR_MAX) + (8 * sizeof(long)) - 1) / (8 * sizeof(long)))];
+};
+static inline __attribute__((always_inline)) void init_dma_attrs(struct dma_attrs *attrs)
+{
+ bitmap_zero(attrs->flags, (((DMA_ATTR_MAX) + (8 * sizeof(long)) - 1) / (8 * sizeof(long))));
+}
+static inline __attribute__((always_inline)) void dma_set_attr(enum dma_attr attr, struct dma_attrs *attrs)
+{
+}
+static inline __attribute__((always_inline)) int dma_get_attr(enum dma_attr attr, struct dma_attrs *attrs)
+{
+ return 0;
+}
+struct scatterlist {
+ unsigned long page_link;
+ unsigned int offset;
+ unsigned int length;
+ dma_addr_t dma_address;
+ unsigned int dma_length;
+};
+extern unsigned int ioread8(void *);
+extern unsigned int ioread16(void *);
+extern unsigned int ioread16be(void *);
+extern unsigned int ioread32(void *);
+extern unsigned int ioread32be(void *);
+extern void iowrite8(u8, void *);
+extern void iowrite16(u16, void *);
+extern void iowrite16be(u16, void *);
+extern void iowrite32(u32, void *);
+extern void iowrite32be(u32, void *);
+extern void ioread8_rep(void *port, void *buf, unsigned long count);
+extern void ioread16_rep(void *port, void *buf, unsigned long count);
+extern void ioread32_rep(void *port, void *buf, unsigned long count);
+extern void iowrite8_rep(void *port, const void *buf, unsigned long count);
+extern void iowrite16_rep(void *port, const void *buf, unsigned long count);
+extern void iowrite32_rep(void *port, const void *buf, unsigned long count);
+extern void *ioport_map(unsigned long port, unsigned int nr);
+extern void ioport_unmap(void *);
+struct pci_dev;
+extern void *pci_iomap(struct pci_dev *dev, int bar, unsigned long max);
+extern void pci_iounmap(struct pci_dev *dev, void *);
+u8 generic_inb(unsigned long);
+u16 generic_inw(unsigned long);
+u32 generic_inl(unsigned long);
+void generic_outb(u8, unsigned long);
+void generic_outw(u16, unsigned long);
+void generic_outl(u32, unsigned long);
+u8 generic_inb_p(unsigned long);
+u16 generic_inw_p(unsigned long);
+u32 generic_inl_p(unsigned long);
+void generic_outb_p(u8, unsigned long);
+void generic_outw_p(u16, unsigned long);
+void generic_outl_p(u32, unsigned long);
+void generic_insb(unsigned long, void *dst, unsigned long count);
+void generic_insw(unsigned long, void *dst, unsigned long count);
+void generic_insl(unsigned long, void *dst, unsigned long count);
+void generic_outsb(unsigned long, const void *src, unsigned long count);
+void generic_outsw(unsigned long, const void *src, unsigned long count);
+void generic_outsl(unsigned long, const void *src, unsigned long count);
+void *generic_ioremap(unsigned long offset, unsigned long size);
+void generic_iounmap(void *addr);
+void *generic_ioport_map(unsigned long addr, unsigned int size);
+void generic_ioport_unmap(void *addr);
+struct trapped_io {
+ unsigned int magic;
+ struct resource *resource;
+ unsigned int num_resources;
+ unsigned int minimum_bus_width;
+ struct list_head list;
+ void *virt_base;
+} __attribute__((aligned(((1UL) << 12))));
+static inline __attribute__((always_inline)) void ctrl_delay(void)
+{
+ ((void)0, *(volatile u16 *)(0xff000030));
+}
+static inline __attribute__((always_inline)) void __raw_writesb(volatile void *mem, const void *addr, unsigned int count) { const volatile u8 *__addr = addr; while (count--) { ((void)0, *(volatile u8 *)(mem) = (*__addr)); __addr++; } } static inline __attribute__((always_inline)) void __raw_readsb(volatile void *mem, void *addr, unsigned int count) { volatile u8 *__addr = addr; while (count--) { *__addr = ((void)0, *(volatile u8 *)(mem)); __addr++; } }
+static inline __attribute__((always_inline)) void __raw_writesw(volatile void *mem, const void *addr, unsigned int count) { const volatile u16 *__addr = addr; while (count--) { ((void)0, *(volatile u16 *)(mem) = (*__addr)); __addr++; } } static inline __attribute__((always_inline)) void __raw_readsw(volatile void *mem, void *addr, unsigned int count) { volatile u16 *__addr = addr; while (count--) { *__addr = ((void)0, *(volatile u16 *)(mem)); __addr++; } }
+void __raw_writesl(void *addr, const void *data, int longlen);
+void __raw_readsl(const void *addr, void *data, int longlen);
+static inline __attribute__((always_inline)) void __raw_writesq(volatile void *mem, const void *addr, unsigned int count) { const volatile u64 *__addr = addr; while (count--) { ((void)0, *(volatile u64 *)(mem) = (*__addr)); __addr++; } } static inline __attribute__((always_inline)) void __raw_readsq(volatile void *mem, void *addr, unsigned int count) { volatile u64 *__addr = addr; while (count--) { *__addr = ((void)0, *(volatile u64 *)(mem)); __addr++; } }
+extern unsigned long generic_io_base;
+static inline __attribute__((always_inline)) void __set_io_port_base(unsigned long pbase)
+{
+ generic_io_base = pbase;
+}
+void memcpy_fromio(void *, const volatile void *, unsigned long);
+void memcpy_toio(volatile void *, const void *, unsigned long);
+void memset_io(volatile void *, int, unsigned long);
+unsigned long long peek_real_address_q(unsigned long long addr);
+unsigned long long poke_real_address_q(unsigned long long addr,
+           unsigned long long val);
+void *__ioremap(unsigned long offset, unsigned long size,
+   unsigned long flags);
+void __iounmap(void *addr);
+static inline __attribute__((always_inline)) void *
+__ioremap_mode(unsigned long offset, unsigned long size, unsigned long flags)
+{
+ void *ret;
+ ret = ((void *)0);
+ if (ret)
+  return ret;
+ return __ioremap(offset, size, flags);
+}
+int valid_phys_addr_range(unsigned long addr, size_t size);
+int valid_mmap_phys_addr_range(unsigned long pfn, size_t size);
+struct sg_table {
+ struct scatterlist *sgl;
+ unsigned int nents;
+ unsigned int orig_nents;
+};
+static inline __attribute__((always_inline)) void sg_assign_page(struct scatterlist *sg, struct page *page)
+{
+ unsigned long page_link = sg->page_link & 0x3;
+ do { if (__builtin_expect(!!((unsigned long) page & 0x03), 0)) do { __asm__ __volatile__ ( "1:\t.short %O0\n" "\t.pushsection __bug_table,\"a\"\n" "2:\t.long 1b\n" "\t.short %O3\n" "\t.org 2b+%O4\n" "\t.popsection\n" : : "n" (0xc33e), "i" ("include/linux/scatterlist.h"), "i" (63), "i" (0), "i" (sizeof(struct bug_entry))); } while (0); } while(0);
+ sg->page_link = page_link | (unsigned long) page;
+}
+static inline __attribute__((always_inline)) void sg_set_page(struct scatterlist *sg, struct page *page,
+          unsigned int len, unsigned int offset)
+{
+ sg_assign_page(sg, page);
+ sg->offset = offset;
+ sg->length = len;
+}
+static inline __attribute__((always_inline)) struct page *sg_page(struct scatterlist *sg)
+{
+ return (struct page *)((sg)->page_link & ~0x3);
+}
+static inline __attribute__((always_inline)) void sg_set_buf(struct scatterlist *sg, const void *buf,
+         unsigned int buflen)
+{
+ sg_set_page(sg, (mem_map + ((((unsigned long)(buf)-0x80000000 +0x0) >> 12) - ((0x0 >> 12)))), buflen, ((unsigned long)(buf) & ~(~(((1UL) << 12)-1))));
+}
+static inline __attribute__((always_inline)) void sg_chain(struct scatterlist *prv, unsigned int prv_nents,
+       struct scatterlist *sgl)
+{
+ prv[prv_nents - 1].offset = 0;
+ prv[prv_nents - 1].length = 0;
+ prv[prv_nents - 1].page_link = ((unsigned long) sgl | 0x01) & ~0x02;
+}
+static inline __attribute__((always_inline)) void sg_mark_end(struct scatterlist *sg)
+{
+ sg->page_link |= 0x02;
+ sg->page_link &= ~0x01;
+}
+static inline __attribute__((always_inline)) dma_addr_t sg_phys(struct scatterlist *sg)
+{
+ return (((unsigned long)((sg_page(sg)) - mem_map) + ((0x0 >> 12))) << 12) + sg->offset;
+}
+static inline __attribute__((always_inline)) void *sg_virt(struct scatterlist *sg)
+{
+ return lowmem_page_address(sg_page(sg)) + sg->offset;
+}
+struct scatterlist *sg_next(struct scatterlist *);
+struct scatterlist *sg_last(struct scatterlist *s, unsigned int);
+void sg_init_table(struct scatterlist *, unsigned int);
+void sg_init_one(struct scatterlist *, const void *, unsigned int);
+typedef struct scatterlist *(sg_alloc_fn)(unsigned int, gfp_t);
+typedef void (sg_free_fn)(struct scatterlist *, unsigned int);
+void __sg_free_table(struct sg_table *, unsigned int, sg_free_fn *);
+void sg_free_table(struct sg_table *);
+int __sg_alloc_table(struct sg_table *, unsigned int, unsigned int, gfp_t,
+       sg_alloc_fn *);
+int sg_alloc_table(struct sg_table *, unsigned int, gfp_t);
+size_t sg_copy_from_buffer(struct scatterlist *sgl, unsigned int nents,
+      void *buf, size_t buflen);
+size_t sg_copy_to_buffer(struct scatterlist *sgl, unsigned int nents,
+    void *buf, size_t buflen);
+struct sg_mapping_iter {
+ struct page *page;
+ void *addr;
+ size_t length;
+ size_t consumed;
+ struct scatterlist *__sg;
+ unsigned int __nents;
+ unsigned int __offset;
+ unsigned int __flags;
+};
+void sg_miter_start(struct sg_mapping_iter *miter, struct scatterlist *sgl,
+      unsigned int nents, unsigned int flags);
+bool sg_miter_next(struct sg_mapping_iter *miter);
+void sg_miter_stop(struct sg_mapping_iter *miter);
+enum dma_data_direction {
+ DMA_BIDIRECTIONAL = 0,
+ DMA_TO_DEVICE = 1,
+ DMA_FROM_DEVICE = 2,
+ DMA_NONE = 3,
+};
+struct dma_map_ops {
+ void* (*alloc_coherent)(struct device *dev, size_t size,
+    dma_addr_t *dma_handle, gfp_t gfp);
+ void (*free_coherent)(struct device *dev, size_t size,
+         void *vaddr, dma_addr_t dma_handle);
+ dma_addr_t (*map_page)(struct device *dev, struct page *page,
+          unsigned long offset, size_t size,
+          enum dma_data_direction dir,
+          struct dma_attrs *attrs);
+ void (*unmap_page)(struct device *dev, dma_addr_t dma_handle,
+      size_t size, enum dma_data_direction dir,
+      struct dma_attrs *attrs);
+ int (*map_sg)(struct device *dev, struct scatterlist *sg,
+        int nents, enum dma_data_direction dir,
+        struct dma_attrs *attrs);
+ void (*unmap_sg)(struct device *dev,
+    struct scatterlist *sg, int nents,
+    enum dma_data_direction dir,
+    struct dma_attrs *attrs);
+ void (*sync_single_for_cpu)(struct device *dev,
+        dma_addr_t dma_handle, size_t size,
+        enum dma_data_direction dir);
+ void (*sync_single_for_device)(struct device *dev,
+           dma_addr_t dma_handle, size_t size,
+           enum dma_data_direction dir);
+ void (*sync_single_range_for_cpu)(struct device *dev,
+       dma_addr_t dma_handle,
+       unsigned long offset,
+       size_t size,
+       enum dma_data_direction dir);
+ void (*sync_single_range_for_device)(struct device *dev,
+          dma_addr_t dma_handle,
+          unsigned long offset,
+          size_t size,
+          enum dma_data_direction dir);
+ void (*sync_sg_for_cpu)(struct device *dev,
+    struct scatterlist *sg, int nents,
+    enum dma_data_direction dir);
+ void (*sync_sg_for_device)(struct device *dev,
+       struct scatterlist *sg, int nents,
+       enum dma_data_direction dir);
+ int (*mapping_error)(struct device *dev, dma_addr_t dma_addr);
+ int (*dma_supported)(struct device *dev, u64 mask);
+ int (*set_dma_mask)(struct device *dev, u64 mask);
+ int is_phys;
+};
+typedef u64 DMA_nnBIT_MASK __attribute__((deprecated));
+static inline __attribute__((always_inline)) int valid_dma_direction(int dma_direction)
+{
+ return ((dma_direction == DMA_BIDIRECTIONAL) ||
+  (dma_direction == DMA_TO_DEVICE) ||
+  (dma_direction == DMA_FROM_DEVICE));
+}
+static inline __attribute__((always_inline)) int is_device_dma_capable(struct device *dev)
+{
+ return dev->dma_mask != ((void *)0) && *dev->dma_mask != 0x0ULL;
+}
+struct device;
+struct scatterlist;
+struct bus_type;
+static inline __attribute__((always_inline)) void dma_debug_add_bus(struct bus_type *bus)
+{
+}
+static inline __attribute__((always_inline)) void dma_debug_init(u32 num_entries)
+{
+}
+static inline __attribute__((always_inline)) int dma_debug_resize_entries(u32 num_entries)
+{
+ return 0;
+}
+static inline __attribute__((always_inline)) void debug_dma_map_page(struct device *dev, struct page *page,
+          size_t offset, size_t size,
+          int direction, dma_addr_t dma_addr,
+          bool map_single)
+{
+}
+static inline __attribute__((always_inline)) void debug_dma_unmap_page(struct device *dev, dma_addr_t addr,
+     size_t size, int direction,
+     bool map_single)
+{
+}
+static inline __attribute__((always_inline)) void debug_dma_map_sg(struct device *dev, struct scatterlist *sg,
+        int nents, int mapped_ents, int direction)
+{
+}
+static inline __attribute__((always_inline)) void debug_dma_unmap_sg(struct device *dev,
+          struct scatterlist *sglist,
+          int nelems, int dir)
+{
+}
+static inline __attribute__((always_inline)) void debug_dma_alloc_coherent(struct device *dev, size_t size,
+         dma_addr_t dma_addr, void *virt)
+{
+}
+static inline __attribute__((always_inline)) void debug_dma_free_coherent(struct device *dev, size_t size,
+        void *virt, dma_addr_t addr)
+{
+}
+static inline __attribute__((always_inline)) void debug_dma_sync_single_for_cpu(struct device *dev,
+       dma_addr_t dma_handle,
+       size_t size, int direction)
+{
+}
+static inline __attribute__((always_inline)) void debug_dma_sync_single_for_device(struct device *dev,
+          dma_addr_t dma_handle,
+          size_t size, int direction)
+{
+}
+static inline __attribute__((always_inline)) void debug_dma_sync_single_range_for_cpu(struct device *dev,
+             dma_addr_t dma_handle,
+             unsigned long offset,
+             size_t size,
+             int direction)
+{
+}
+static inline __attribute__((always_inline)) void debug_dma_sync_single_range_for_device(struct device *dev,
+         dma_addr_t dma_handle,
+         unsigned long offset,
+         size_t size,
+         int direction)
+{
+}
+static inline __attribute__((always_inline)) void debug_dma_sync_sg_for_cpu(struct device *dev,
+          struct scatterlist *sg,
+          int nelems, int direction)
+{
+}
+static inline __attribute__((always_inline)) void debug_dma_sync_sg_for_device(struct device *dev,
+      struct scatterlist *sg,
+      int nelems, int direction)
+{
+}
+static inline __attribute__((always_inline)) void debug_dma_dump_mappings(struct device *dev)
+{
+}
+static inline __attribute__((always_inline)) void __l2_flush_wback_region(void *start, int size)
+{
+}
+static inline __attribute__((always_inline)) void __l2_flush_purge_region(void *start, int size)
+{
+}
+static inline __attribute__((always_inline)) void __l2_flush_invalidate_region(void *start, int size)
+{
+}
+static inline __attribute__((always_inline)) void __l2_flush_wback_phys(unsigned long start, int size)
+{
+}
+static inline __attribute__((always_inline)) void __l2_flush_purge_phys(unsigned long start, int size)
+{
+}
+static inline __attribute__((always_inline)) void __l2_flush_invalidate_phys(unsigned long start, int size)
+{
+}
+extern void (*local_flush_cache_all)(void *args);
+extern void (*local_flush_cache_mm)(void *args);
+extern void (*local_flush_cache_dup_mm)(void *args);
+extern void (*local_flush_cache_page)(void *args);
+extern void (*local_flush_cache_range)(void *args);
+extern void (*local_flush_dcache_page)(void *args);
+extern void (*local_flush_icache_range)(void *args);
+extern void (*local_flush_icache_page)(void *args);
+extern void (*local_flush_cache_sigtramp)(void *args);
+static inline __attribute__((always_inline)) void cache_noop(void *args) { }
+extern void (*__flush_wback_region)(void *start, int size);
+extern void (*__flush_purge_region)(void *start, int size);
+extern void (*__flush_invalidate_region)(void *start, int size);
+extern void flush_cache_all(void);
+extern void flush_cache_mm(struct mm_struct *mm);
+extern void flush_cache_dup_mm(struct mm_struct *mm);
+extern void flush_cache_page(struct vm_area_struct *vma,
+    unsigned long addr, unsigned long pfn);
+extern void flush_cache_range(struct vm_area_struct *vma,
+     unsigned long start, unsigned long end);
+extern void flush_dcache_page(struct page *page);
+extern void flush_icache_range(unsigned long start, unsigned long end);
+extern void flush_icache_page(struct vm_area_struct *vma,
+     struct page *page);
+extern void flush_cache_sigtramp(unsigned long address);
+struct flusher_data {
+ struct vm_area_struct *vma;
+ unsigned long addr1, addr2;
+};
+extern void __flush_anon_page(struct page *page, unsigned long);
+static inline __attribute__((always_inline)) void flush_anon_page(struct vm_area_struct *vma,
+       struct page *page, unsigned long vmaddr)
+{
+ if (cpu_data[0].dcache.n_aliases && PageAnon(page))
+  __flush_anon_page(page, vmaddr);
+}
+void flush_kernel_dcache_page_addr(unsigned long addr);
+static inline __attribute__((always_inline)) void flush_kernel_dcache_page(struct page *page)
+{
+ flush_kernel_dcache_page_addr((unsigned long)lowmem_page_address(page));
+}
+extern void copy_to_user_page(struct vm_area_struct *vma,
+ struct page *page, unsigned long vaddr, void *dst, const void *src,
+ unsigned long len);
+extern void copy_from_user_page(struct vm_area_struct *vma,
+ struct page *page, unsigned long vaddr, void *dst, const void *src,
+ unsigned long len);
+static inline __attribute__((always_inline)) void flush_ioremap_region(unsigned long phys, void *virt,
+     unsigned offset, size_t size)
+{
+ void *start = (void *)virt + offset;
+ __flush_purge_region(start, size);
+ __l2_flush_purge_phys(phys + offset, size);
+}
+static inline __attribute__((always_inline)) void writeback_ioremap_region(unsigned long phys, void *virt,
+         unsigned offset, size_t size)
+{
+ void *start = (void *)virt + offset;
+ __flush_wback_region(start, size);
+ __l2_flush_wback_phys(phys + offset, size);
+}
+static inline __attribute__((always_inline)) void invalidate_ioremap_region(unsigned long phys, void *virt,
+          unsigned offset, size_t size)
+{
+ void *start = (void *)virt + offset;
+ __flush_invalidate_region(start, size);
+ __l2_flush_invalidate_phys(phys + offset, size);
+}
+void kmap_coherent_init(void);
+void *kmap_coherent(struct page *page, unsigned long addr);
+void kunmap_coherent(void *kvaddr);
+void cpu_cache_init(void);
+int dma_alloc_from_coherent(struct device *dev, ssize_t size,
+           dma_addr_t *dma_handle, void **ret);
+int dma_release_from_coherent(struct device *dev, int order, void *vaddr);
+extern int
+dma_declare_coherent_memory(struct device *dev, dma_addr_t bus_addr,
+       dma_addr_t device_addr, size_t size, int flags);
+extern void
+dma_release_declared_memory(struct device *dev);
+extern void *
+dma_mark_declared_memory_occupied(struct device *dev,
+      dma_addr_t device_addr, size_t size);
+extern struct bus_type pci_bus_type;
+static inline __attribute__((always_inline)) int dma_set_mask(struct device *dev, u64 mask)
+{
+ if (!dev->dma_mask || !(1))
+  return -5;
+ *dev->dma_mask = mask;
+ return 0;
+}
+void *dma_alloc_coherent(struct device *dev, size_t size,
+    dma_addr_t *dma_handle, gfp_t flag);
+void dma_free_coherent(struct device *dev, size_t size,
+         void *vaddr, dma_addr_t dma_handle);
+void dma_cache_sync(struct device *dev, void *vaddr, size_t size,
+      enum dma_data_direction dir);
+static inline __attribute__((always_inline)) dma_addr_t dma_map_single(struct device *dev,
+     void *ptr, size_t size,
+     enum dma_data_direction dir)
+{
+ dma_addr_t addr = (((unsigned long)(ptr)-0x80000000 +0x0));
+ dma_cache_sync(dev, ptr, size, dir);
+ debug_dma_map_page(dev, (mem_map + ((((unsigned long)(ptr)-0x80000000 +0x0) >> 12) - ((0x0 >> 12)))),
+      (unsigned long)ptr & ~(~(((1UL) << 12)-1)), size,
+      dir, addr, true);
+ return addr;
+}
+static inline __attribute__((always_inline)) void dma_unmap_single(struct device *dev, dma_addr_t addr,
+        size_t size, enum dma_data_direction dir)
+{
+ debug_dma_unmap_page(dev, addr, size, dir, true);
+}
+static inline __attribute__((always_inline)) int dma_map_sg(struct device *dev, struct scatterlist *sg,
+        int nents, enum dma_data_direction dir)
+{
+ int i;
+ for (i = 0; i < nents; i++) {
+  dma_cache_sync(dev, sg_virt(&sg[i]), sg[i].length, dir);
+  sg[i].dma_address = sg_phys(&sg[i]);
+  sg[i].dma_length = sg[i].length;
+ }
+ debug_dma_map_sg(dev, sg, nents, i, dir);
+ return nents;
+}
+static inline __attribute__((always_inline)) void dma_unmap_sg(struct device *dev, struct scatterlist *sg,
+    int nents, enum dma_data_direction dir)
+{
+ debug_dma_unmap_sg(dev, sg, nents, dir);
+}
+static inline __attribute__((always_inline)) dma_addr_t dma_map_page(struct device *dev, struct page *page,
+          unsigned long offset, size_t size,
+          enum dma_data_direction dir)
+{
+ return dma_map_single(dev, lowmem_page_address(page) + offset, size, dir);
+}
+static inline __attribute__((always_inline)) void dma_unmap_page(struct device *dev, dma_addr_t dma_address,
+      size_t size, enum dma_data_direction dir)
+{
+ dma_unmap_single(dev, dma_address, size, dir);
+}
+static inline __attribute__((always_inline)) void __dma_sync_single(struct device *dev, dma_addr_t dma_handle,
+       size_t size, enum dma_data_direction dir)
+{
+ dma_cache_sync(dev, (((void *)((unsigned long)(dma_handle)+0x80000000 -0x0))), size, dir);
+}
+static inline __attribute__((always_inline)) void dma_sync_single_range(struct device *dev,
+      dma_addr_t dma_handle,
+      unsigned long offset, size_t size,
+      enum dma_data_direction dir)
+{
+ dma_cache_sync(dev, (((void *)((unsigned long)(dma_handle)+0x80000000 -0x0))) + offset, size, dir);
+}
+static inline __attribute__((always_inline)) void __dma_sync_sg(struct device *dev, struct scatterlist *sg,
+          int nelems, enum dma_data_direction dir)
+{
+ int i;
+ for (i = 0; i < nelems; i++) {
+  dma_cache_sync(dev, sg_virt(&sg[i]), sg[i].length, dir);
+  sg[i].dma_address = sg_phys(&sg[i]);
+  sg[i].dma_length = sg[i].length;
+ }
+}
+static inline __attribute__((always_inline)) void dma_sync_single_for_cpu(struct device *dev,
+        dma_addr_t dma_handle, size_t size,
+        enum dma_data_direction dir)
+{
+ debug_dma_sync_single_for_cpu(dev, dma_handle, size, dir);
+}
+static inline __attribute__((always_inline)) void dma_sync_single_for_device(struct device *dev,
+           dma_addr_t dma_handle,
+           size_t size,
+           enum dma_data_direction dir)
+{
+ __dma_sync_single(dev, dma_handle, size, dir);
+ debug_dma_sync_single_for_device(dev, dma_handle, size, dir);
+}
+static inline __attribute__((always_inline)) void dma_sync_single_range_for_cpu(struct device *dev,
+       dma_addr_t dma_handle,
+       unsigned long offset,
+       size_t size,
+       enum dma_data_direction direction)
+{
+ debug_dma_sync_single_range_for_cpu(dev, dma_handle,
+         offset, size, direction);
+}
+static inline __attribute__((always_inline)) void dma_sync_single_range_for_device(struct device *dev,
+          dma_addr_t dma_handle,
+          unsigned long offset,
+          size_t size,
+          enum dma_data_direction direction)
+{
+ __dma_sync_single(dev, dma_handle+offset, size, direction);
+ debug_dma_sync_single_range_for_device(dev, dma_handle,
+            offset, size, direction);
+}
+static inline __attribute__((always_inline)) void dma_sync_sg_for_cpu(struct device *dev,
+           struct scatterlist *sg, int nelems,
+           enum dma_data_direction dir)
+{
+ debug_dma_sync_sg_for_cpu(dev, sg, nelems, dir);
+}
+static inline __attribute__((always_inline)) void dma_sync_sg_for_device(struct device *dev,
+       struct scatterlist *sg, int nelems,
+       enum dma_data_direction dir)
+{
+ __dma_sync_sg(dev, sg, nelems, dir);
+ debug_dma_sync_sg_for_device(dev, sg, nelems, dir);
+}
+static inline __attribute__((always_inline)) int dma_get_cache_alignment(void)
+{
+ return (1 << 5);
+}
+static inline __attribute__((always_inline)) int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
+{
+ return dma_addr == 0;
+}
+extern int
+dma_declare_coherent_memory(struct device *dev, dma_addr_t bus_addr,
+       dma_addr_t device_addr, size_t size, int flags);
+extern void
+dma_release_declared_memory(struct device *dev);
+extern void *
+dma_mark_declared_memory_occupied(struct device *dev,
+      dma_addr_t device_addr, size_t size);
+static inline __attribute__((always_inline)) void __attribute__((deprecated)) dma_sync_single(struct device *dev,
+      dma_addr_t addr, size_t size,
+      enum dma_data_direction dir)
+{
+ dma_sync_single_for_cpu(dev, addr, size, dir);
+}
+static inline __attribute__((always_inline)) void __attribute__((deprecated)) dma_sync_sg(struct device *dev,
+         struct scatterlist *sg, int nelems,
+         enum dma_data_direction dir)
+{
+ dma_sync_sg_for_cpu(dev, sg, nelems, dir);
+}
+static inline __attribute__((always_inline)) u64 dma_get_mask(struct device *dev)
+{
+ if (dev && dev->dma_mask && *dev->dma_mask)
+  return *dev->dma_mask;
+ return (((32) == 64) ? ~0ULL : ((1ULL<<(32))-1));
+}
+extern u64 dma_get_required_mask(struct device *dev);
+static inline __attribute__((always_inline)) unsigned int dma_get_max_seg_size(struct device *dev)
+{
+ return dev->dma_parms ? dev->dma_parms->max_segment_size : 65536;
+}
+static inline __attribute__((always_inline)) unsigned int dma_set_max_seg_size(struct device *dev,
+      unsigned int size)
+{
+ if (dev->dma_parms) {
+  dev->dma_parms->max_segment_size = size;
+  return 0;
+ } else
+  return -5;
+}
+static inline __attribute__((always_inline)) unsigned long dma_get_seg_boundary(struct device *dev)
+{
+ return dev->dma_parms ?
+  dev->dma_parms->segment_boundary_mask : 0xffffffff;
+}
+static inline __attribute__((always_inline)) int dma_set_seg_boundary(struct device *dev, unsigned long mask)
+{
+ if (dev->dma_parms) {
+  dev->dma_parms->segment_boundary_mask = mask;
+  return 0;
+ } else
+  return -5;
+}
+extern void *dmam_alloc_coherent(struct device *dev, size_t size,
+     dma_addr_t *dma_handle, gfp_t gfp);
+extern void dmam_free_coherent(struct device *dev, size_t size, void *vaddr,
+          dma_addr_t dma_handle);
+extern void *dmam_alloc_noncoherent(struct device *dev, size_t size,
+        dma_addr_t *dma_handle, gfp_t gfp);
+extern void dmam_free_noncoherent(struct device *dev, size_t size, void *vaddr,
+      dma_addr_t dma_handle);
+extern int dmam_declare_coherent_memory(struct device *dev, dma_addr_t bus_addr,
+     dma_addr_t device_addr, size_t size,
+     int flags);
+extern void dmam_release_declared_memory(struct device *dev);
+struct dma_attrs;
+typedef s32 dma_cookie_t;
+enum dma_status {
+ DMA_SUCCESS,
+ DMA_IN_PROGRESS,
+ DMA_ERROR,
+};
+enum dma_transaction_type {
+ DMA_MEMCPY,
+ DMA_XOR,
+ DMA_PQ,
+ DMA_XOR_VAL,
+ DMA_PQ_VAL,
+ DMA_MEMSET,
+ DMA_INTERRUPT,
+ DMA_PRIVATE,
+ DMA_ASYNC_TX,
+ DMA_SLAVE,
+};
+enum dma_ctrl_flags {
+ DMA_PREP_INTERRUPT = (1 << 0),
+ DMA_CTRL_ACK = (1 << 1),
+ DMA_COMPL_SKIP_SRC_UNMAP = (1 << 2),
+ DMA_COMPL_SKIP_DEST_UNMAP = (1 << 3),
+ DMA_COMPL_SRC_UNMAP_SINGLE = (1 << 4),
+ DMA_COMPL_DEST_UNMAP_SINGLE = (1 << 5),
+ DMA_PREP_PQ_DISABLE_P = (1 << 6),
+ DMA_PREP_PQ_DISABLE_Q = (1 << 7),
+ DMA_PREP_CONTINUE = (1 << 8),
+ DMA_PREP_FENCE = (1 << 9),
+};
+enum sum_check_bits {
+ SUM_CHECK_P = 0,
+ SUM_CHECK_Q = 1,
+};
+enum sum_check_flags {
+ SUM_CHECK_P_RESULT = (1 << SUM_CHECK_P),
+ SUM_CHECK_Q_RESULT = (1 << SUM_CHECK_Q),
+};
+typedef struct { unsigned long bits[((((DMA_SLAVE + 1)) + (8 * sizeof(long)) - 1) / (8 * sizeof(long)))]; } dma_cap_mask_t;
+struct dma_chan_percpu {
+ unsigned long memcpy_count;
+ unsigned long bytes_transferred;
+};
+struct dma_chan {
+ struct dma_device *device;
+ dma_cookie_t cookie;
+ int chan_id;
+ struct dma_chan_dev *dev;
+ struct list_head device_node;
+ struct dma_chan_percpu *local;
+ int client_count;
+ int table_count;
+ void *private;
+};
+struct dma_chan_dev {
+ struct dma_chan *chan;
+ struct device device;
+ int dev_id;
+ atomic_t *idr_ref;
+};
+static inline __attribute__((always_inline)) const char *dma_chan_name(struct dma_chan *chan)
+{
+ return dev_name(&chan->dev->device);
+}
+void dma_chan_cleanup(struct kref *kref);
+typedef bool (*dma_filter_fn)(struct dma_chan *chan, void *filter_param);
+typedef void (*dma_async_tx_callback)(void *dma_async_param);
+struct dma_async_tx_descriptor {
+ dma_cookie_t cookie;
+ enum dma_ctrl_flags flags;
+ dma_addr_t phys;
+ struct dma_chan *chan;
+ dma_cookie_t (*tx_submit)(struct dma_async_tx_descriptor *tx);
+ dma_async_tx_callback callback;
+ void *callback_param;
+ struct dma_async_tx_descriptor *next;
+ struct dma_async_tx_descriptor *parent;
+ spinlock_t lock;
+};
+struct dma_device {
+ unsigned int chancnt;
+ unsigned int privatecnt;
+ struct list_head channels;
+ struct list_head global_node;
+ dma_cap_mask_t cap_mask;
+ unsigned short max_xor;
+ unsigned short max_pq;
+ u8 copy_align;
+ u8 xor_align;
+ u8 pq_align;
+ u8 fill_align;
+ int dev_id;
+ struct device *dev;
+ int (*device_alloc_chan_resources)(struct dma_chan *chan);
+ void (*device_free_chan_resources)(struct dma_chan *chan);
+ struct dma_async_tx_descriptor *(*device_prep_dma_memcpy)(
+  struct dma_chan *chan, dma_addr_t dest, dma_addr_t src,
+  size_t len, unsigned long flags);
+ struct dma_async_tx_descriptor *(*device_prep_dma_xor)(
+  struct dma_chan *chan, dma_addr_t dest, dma_addr_t *src,
+  unsigned int src_cnt, size_t len, unsigned long flags);
+ struct dma_async_tx_descriptor *(*device_prep_dma_xor_val)(
+  struct dma_chan *chan, dma_addr_t *src, unsigned int src_cnt,
+  size_t len, enum sum_check_flags *result, unsigned long flags);
+ struct dma_async_tx_descriptor *(*device_prep_dma_pq)(
+  struct dma_chan *chan, dma_addr_t *dst, dma_addr_t *src,
+  unsigned int src_cnt, const unsigned char *scf,
+  size_t len, unsigned long flags);
+ struct dma_async_tx_descriptor *(*device_prep_dma_pq_val)(
+  struct dma_chan *chan, dma_addr_t *pq, dma_addr_t *src,
+  unsigned int src_cnt, const unsigned char *scf, size_t len,
+  enum sum_check_flags *pqres, unsigned long flags);
+ struct dma_async_tx_descriptor *(*device_prep_dma_memset)(
+  struct dma_chan *chan, dma_addr_t dest, int value, size_t len,
+  unsigned long flags);
+ struct dma_async_tx_descriptor *(*device_prep_dma_interrupt)(
+  struct dma_chan *chan, unsigned long flags);
+ struct dma_async_tx_descriptor *(*device_prep_slave_sg)(
+  struct dma_chan *chan, struct scatterlist *sgl,
+  unsigned int sg_len, enum dma_data_direction direction,
+  unsigned long flags);
+ void (*device_terminate_all)(struct dma_chan *chan);
+ enum dma_status (*device_is_tx_complete)(struct dma_chan *chan,
+   dma_cookie_t cookie, dma_cookie_t *last,
+   dma_cookie_t *used);
+ void (*device_issue_pending)(struct dma_chan *chan);
+};
+static inline __attribute__((always_inline)) bool dmaengine_check_align(u8 align, size_t off1, size_t off2, size_t len)
+{
+ size_t mask;
+ if (!align)
+  return true;
+ mask = (1 << align) - 1;
+ if (mask & (off1 | off2 | len))
+  return false;
+ return true;
+}
+static inline __attribute__((always_inline)) bool is_dma_copy_aligned(struct dma_device *dev, size_t off1,
+           size_t off2, size_t len)
+{
+ return dmaengine_check_align(dev->copy_align, off1, off2, len);
+}
+static inline __attribute__((always_inline)) bool is_dma_xor_aligned(struct dma_device *dev, size_t off1,
+          size_t off2, size_t len)
+{
+ return dmaengine_check_align(dev->xor_align, off1, off2, len);
+}
+static inline __attribute__((always_inline)) bool is_dma_pq_aligned(struct dma_device *dev, size_t off1,
+         size_t off2, size_t len)
+{
+ return dmaengine_check_align(dev->pq_align, off1, off2, len);
+}
+static inline __attribute__((always_inline)) bool is_dma_fill_aligned(struct dma_device *dev, size_t off1,
+           size_t off2, size_t len)
+{
+ return dmaengine_check_align(dev->fill_align, off1, off2, len);
+}
+static inline __attribute__((always_inline)) void
+dma_set_maxpq(struct dma_device *dma, int maxpq, int has_pq_continue)
+{
+ dma->max_pq = maxpq;
+ if (has_pq_continue)
+  dma->max_pq |= (1 << 15);
+}
+static inline __attribute__((always_inline)) bool dmaf_continue(enum dma_ctrl_flags flags)
+{
+ return (flags & DMA_PREP_CONTINUE) == DMA_PREP_CONTINUE;
+}
+static inline __attribute__((always_inline)) bool dmaf_p_disabled_continue(enum dma_ctrl_flags flags)
+{
+ enum dma_ctrl_flags mask = DMA_PREP_CONTINUE | DMA_PREP_PQ_DISABLE_P;
+ return (flags & mask) == mask;
+}
+static inline __attribute__((always_inline)) bool dma_dev_has_pq_continue(struct dma_device *dma)
+{
+ return (dma->max_pq & (1 << 15)) == (1 << 15);
+}
+static unsigned short dma_dev_to_maxpq(struct dma_device *dma)
+{
+ return dma->max_pq & ~(1 << 15);
+}
+static inline __attribute__((always_inline)) int dma_maxpq(struct dma_device *dma, enum dma_ctrl_flags flags)
+{
+ if (dma_dev_has_pq_continue(dma) || !dmaf_continue(flags))
+  return dma_dev_to_maxpq(dma);
+ else if (dmaf_p_disabled_continue(flags))
+  return dma_dev_to_maxpq(dma) - 1;
+ else if (dmaf_continue(flags))
+  return dma_dev_to_maxpq(dma) - 3;
+ do { __asm__ __volatile__ ( "1:\t.short %O0\n" "\t.pushsection __bug_table,\"a\"\n" "2:\t.long 1b\n" "\t.short %O3\n" "\t.org 2b+%O4\n" "\t.popsection\n" : : "n" (0xc33e), "i" ("include/linux/dmaengine.h"), "i" (409), "i" (0), "i" (sizeof(struct bug_entry))); } while (0);
+}
+static inline __attribute__((always_inline)) void dmaengine_get(void)
+{
+}
+static inline __attribute__((always_inline)) void dmaengine_put(void)
+{
+}
+static inline __attribute__((always_inline)) void net_dmaengine_get(void)
+{
+}
+static inline __attribute__((always_inline)) void net_dmaengine_put(void)
+{
+}
+static inline __attribute__((always_inline)) void async_dmaengine_get(void)
+{
+}
+static inline __attribute__((always_inline)) void async_dmaengine_put(void)
+{
+}
+static inline __attribute__((always_inline)) struct dma_chan *
+async_dma_find_channel(enum dma_transaction_type type)
+{
+ return ((void *)0);
+}
+dma_cookie_t dma_async_memcpy_buf_to_buf(struct dma_chan *chan,
+ void *dest, void *src, size_t len);
+dma_cookie_t dma_async_memcpy_buf_to_pg(struct dma_chan *chan,
+ struct page *page, unsigned int offset, void *kdata, size_t len);
+dma_cookie_t dma_async_memcpy_pg_to_pg(struct dma_chan *chan,
+ struct page *dest_pg, unsigned int dest_off, struct page *src_pg,
+ unsigned int src_off, size_t len);
+void dma_async_tx_descriptor_init(struct dma_async_tx_descriptor *tx,
+ struct dma_chan *chan);
+static inline __attribute__((always_inline)) void async_tx_ack(struct dma_async_tx_descriptor *tx)
+{
+ tx->flags |= DMA_CTRL_ACK;
+}
+static inline __attribute__((always_inline)) void async_tx_clear_ack(struct dma_async_tx_descriptor *tx)
+{
+ tx->flags &= ~DMA_CTRL_ACK;
+}
+static inline __attribute__((always_inline)) bool async_tx_test_ack(struct dma_async_tx_descriptor *tx)
+{
+ return (tx->flags & DMA_CTRL_ACK) == DMA_CTRL_ACK;
+}
+static inline __attribute__((always_inline)) int __first_dma_cap(const dma_cap_mask_t *srcp)
+{
+ return ({ int __min1 = ((DMA_SLAVE + 1)); int __min2 = (find_next_bit((srcp->bits), ((DMA_SLAVE + 1)), 0)); __min1 < __min2 ? __min1: __min2; })
+                                              ;
+}
+static inline __attribute__((always_inline)) int __next_dma_cap(int n, const dma_cap_mask_t *srcp)
+{
+ return ({ int __min1 = ((DMA_SLAVE + 1)); int __min2 = (find_next_bit(srcp->bits, (DMA_SLAVE + 1), n+1)); __min1 < __min2 ? __min1: __min2; })
+                                                  ;
+}
+static inline __attribute__((always_inline)) void
+__dma_cap_set(enum dma_transaction_type tx_type, dma_cap_mask_t *dstp)
+{
+ set_bit(tx_type, dstp->bits);
+}
+static inline __attribute__((always_inline)) void
+__dma_cap_clear(enum dma_transaction_type tx_type, dma_cap_mask_t *dstp)
+{
+ clear_bit(tx_type, dstp->bits);
+}
+static inline __attribute__((always_inline)) void __dma_cap_zero(dma_cap_mask_t *dstp)
+{
+ bitmap_zero(dstp->bits, (DMA_SLAVE + 1));
+}
+static inline __attribute__((always_inline)) int
+__dma_has_cap(enum dma_transaction_type tx_type, dma_cap_mask_t *srcp)
+{
+ return test_bit(tx_type, srcp->bits);
+}
+static inline __attribute__((always_inline)) void dma_async_issue_pending(struct dma_chan *chan)
+{
+ chan->device->device_issue_pending(chan);
+}
+static inline __attribute__((always_inline)) enum dma_status dma_async_is_tx_complete(struct dma_chan *chan,
+ dma_cookie_t cookie, dma_cookie_t *last, dma_cookie_t *used)
+{
+ return chan->device->device_is_tx_complete(chan, cookie, last, used);
+}
+static inline __attribute__((always_inline)) enum dma_status dma_async_is_complete(dma_cookie_t cookie,
+   dma_cookie_t last_complete, dma_cookie_t last_used)
+{
+ if (last_complete <= last_used) {
+  if ((cookie <= last_complete) || (cookie > last_used))
+   return DMA_SUCCESS;
+ } else {
+  if ((cookie <= last_complete) && (cookie > last_used))
+   return DMA_SUCCESS;
+ }
+ return DMA_IN_PROGRESS;
+}
+enum dma_status dma_sync_wait(struct dma_chan *chan, dma_cookie_t cookie);
+static inline __attribute__((always_inline)) enum dma_status dma_wait_for_async_tx(struct dma_async_tx_descriptor *tx)
+{
+ return DMA_SUCCESS;
+}
+static inline __attribute__((always_inline)) void dma_issue_pending_all(void)
+{
+ do { } while (0);
+}
+int dma_async_device_register(struct dma_device *device);
+void dma_async_device_unregister(struct dma_device *device);
+void dma_run_dependencies(struct dma_async_tx_descriptor *tx);
+struct dma_chan *dma_find_channel(enum dma_transaction_type tx_type);
+struct dma_chan *__dma_request_channel(dma_cap_mask_t *mask, dma_filter_fn fn, void *fn_param);
+void dma_release_channel(struct dma_chan *chan);
+struct dma_page_list {
+ char *base_address;
+ int nr_pages;
+ struct page **pages;
+};
+struct dma_pinned_list {
+ int nr_iovecs;
+ struct dma_page_list page_list[0];
+};
+struct dma_pinned_list *dma_pin_iovec_pages(struct iovec *iov, size_t len);
+void dma_unpin_iovec_pages(struct dma_pinned_list* pinned_list);
+dma_cookie_t dma_memcpy_to_iovec(struct dma_chan *chan, struct iovec *iov,
+ struct dma_pinned_list *pinned_list, unsigned char *kdata, size_t len);
+dma_cookie_t dma_memcpy_pg_to_iovec(struct dma_chan *chan, struct iovec *iov,
+ struct dma_pinned_list *pinned_list, struct page *page,
+ unsigned int offset, size_t len);
+struct net_device;
+struct scatterlist;
+struct pipe_inode_info;
+struct sk_buff_head {
+ struct sk_buff *next;
+ struct sk_buff *prev;
+ __u32 qlen;
+ spinlock_t lock;
+};
+struct sk_buff;
+typedef struct skb_frag_struct skb_frag_t;
+struct skb_frag_struct {
+ struct page *page;
+ __u32 page_offset;
+ __u32 size;
+};
+struct skb_shared_hwtstamps {
+ ktime_t hwtstamp;
+ ktime_t syststamp;
+};
+union skb_shared_tx {
+ struct {
+  __u8 hardware:1,
+   software:1,
+   in_progress:1;
+ };
+ __u8 flags;
+};
+struct skb_shared_info {
+ unsigned short nr_frags;
+ unsigned short gso_size;
+ dma_addr_t dma_head;
+ unsigned short gso_segs;
+ unsigned short gso_type;
+ __be32 ip6_frag_id;
+ union skb_shared_tx tx_flags;
+ struct sk_buff *frag_list;
+ struct skb_shared_hwtstamps hwtstamps;
+ atomic_t dataref;
+ skb_frag_t frags[(65536/((1UL) << 12) + 2)];
+ dma_addr_t dma_maps[(65536/((1UL) << 12) + 2)];
+ void * destructor_arg;
+};
+enum {
+ SKB_FCLONE_UNAVAILABLE,
+ SKB_FCLONE_ORIG,
+ SKB_FCLONE_CLONE,
+};
+enum {
+ SKB_GSO_TCPV4 = 1 << 0,
+ SKB_GSO_UDP = 1 << 1,
+ SKB_GSO_DODGY = 1 << 2,
+ SKB_GSO_TCP_ECN = 1 << 3,
+ SKB_GSO_TCPV6 = 1 << 4,
+ SKB_GSO_FCOE = 1 << 5,
+};
+typedef unsigned char *sk_buff_data_t;
+struct sk_buff {
+ struct sk_buff *next;
+ struct sk_buff *prev;
+ struct sock *sk;
+ ktime_t tstamp;
+ struct net_device *dev;
+ unsigned long _skb_dst;
+ struct sec_path *sp;
+ char cb[48];
+ unsigned int len,
+    data_len;
+ __u16 mac_len,
+    hdr_len;
+ union {
+  __wsum csum;
+  struct {
+   __u16 csum_start;
+   __u16 csum_offset;
+  };
+ };
+ __u32 priority;
+ int flags1_begin[0];;
+ __u8 local_df:1,
+    cloned:1,
+    ip_summed:2,
+    nohdr:1,
+    nfctinfo:3;
+ __u8 pkt_type:3,
+    fclone:2,
+    ipvs_property:1,
+    peeked:1,
+    nf_trace:1;
+ __be16 protocol:16;
+ int flags1_end[0];;
+ void (*destructor)(struct sk_buff *skb);
+ int iif;
+ int flags2_begin[0];;
+ __u16 queue_mapping:16;
+ int flags2_end[0];;
+ __u32 mark;
+ __u16 vlan_tci;
+ sk_buff_data_t transport_header;
+ sk_buff_data_t network_header;
+ sk_buff_data_t mac_header;
+ sk_buff_data_t tail;
+ sk_buff_data_t end;
+ unsigned char *head,
+    *data;
+ unsigned int truesize;
+ atomic_t users;
+};
+extern int skb_dma_map(struct device *dev, struct sk_buff *skb,
+         enum dma_data_direction dir);
+extern void skb_dma_unmap(struct device *dev, struct sk_buff *skb,
+     enum dma_data_direction dir);
+static inline __attribute__((always_inline)) struct dst_entry *skb_dst(const struct sk_buff *skb)
+{
+ return (struct dst_entry *)skb->_skb_dst;
+}
+static inline __attribute__((always_inline)) void skb_dst_set(struct sk_buff *skb, struct dst_entry *dst)
+{
+ skb->_skb_dst = (unsigned long)dst;
+}
+static inline __attribute__((always_inline)) struct rtable *skb_rtable(const struct sk_buff *skb)
+{
+ return (struct rtable *)skb_dst(skb);
+}
+extern void kfree_skb(struct sk_buff *skb);
+extern void consume_skb(struct sk_buff *skb);
+extern void __kfree_skb(struct sk_buff *skb);
+extern struct sk_buff *__alloc_skb(unsigned int size,
+       gfp_t priority, int fclone, int node);
+static inline __attribute__((always_inline)) struct sk_buff *alloc_skb(unsigned int size,
+     gfp_t priority)
+{
+ return __alloc_skb(size, priority, 0, -1);
+}
+static inline __attribute__((always_inline)) struct sk_buff *alloc_skb_fclone(unsigned int size,
+            gfp_t priority)
+{
+ return __alloc_skb(size, priority, 1, -1);
+}
+extern int skb_recycle_check(struct sk_buff *skb, int skb_size);
+extern struct sk_buff *skb_morph(struct sk_buff *dst, struct sk_buff *src);
+extern struct sk_buff *skb_clone(struct sk_buff *skb,
+     gfp_t priority);
+extern struct sk_buff *skb_copy(const struct sk_buff *skb,
+    gfp_t priority);
+extern struct sk_buff *pskb_copy(struct sk_buff *skb,
+     gfp_t gfp_mask);
+extern int pskb_expand_head(struct sk_buff *skb,
+     int nhead, int ntail,
+     gfp_t gfp_mask);
+extern struct sk_buff *skb_realloc_headroom(struct sk_buff *skb,
+         unsigned int headroom);
+extern struct sk_buff *skb_copy_expand(const struct sk_buff *skb,
+           int newheadroom, int newtailroom,
+           gfp_t priority);
+extern int skb_to_sgvec(struct sk_buff *skb,
+        struct scatterlist *sg, int offset,
+        int len);
+extern int skb_cow_data(struct sk_buff *skb, int tailbits,
+        struct sk_buff **trailer);
+extern int skb_pad(struct sk_buff *skb, int pad);
+extern void skb_over_panic(struct sk_buff *skb, int len,
+         void *here);
+extern void skb_under_panic(struct sk_buff *skb, int len,
+          void *here);
+extern int skb_append_datato_frags(struct sock *sk, struct sk_buff *skb,
+   int getfrag(void *from, char *to, int offset,
+   int len,int odd, struct sk_buff *skb),
+   void *from, int length);
+struct skb_seq_state
+{
+ __u32 lower_offset;
+ __u32 upper_offset;
+ __u32 frag_idx;
+ __u32 stepped_offset;
+ struct sk_buff *root_skb;
+ struct sk_buff *cur_skb;
+ __u8 *frag_data;
+};
+extern void skb_prepare_seq_read(struct sk_buff *skb,
+        unsigned int from, unsigned int to,
+        struct skb_seq_state *st);
+extern unsigned int skb_seq_read(unsigned int consumed, const u8 **data,
+       struct skb_seq_state *st);
+extern void skb_abort_seq_read(struct skb_seq_state *st);
+extern unsigned int skb_find_text(struct sk_buff *skb, unsigned int from,
+        unsigned int to, struct ts_config *config,
+        struct ts_state *state);
+static inline __attribute__((always_inline)) unsigned char *skb_end_pointer(const struct sk_buff *skb)
+{
+ return skb->end;
+}
+static inline __attribute__((always_inline)) struct skb_shared_hwtstamps *skb_hwtstamps(struct sk_buff *skb)
+{
+ return &((struct skb_shared_info *)(skb_end_pointer(skb)))->hwtstamps;
+}
+static inline __attribute__((always_inline)) union skb_shared_tx *skb_tx(struct sk_buff *skb)
+{
+ return &((struct skb_shared_info *)(skb_end_pointer(skb)))->tx_flags;
+}
+static inline __attribute__((always_inline)) int skb_queue_empty(const struct sk_buff_head *list)
+{
+ return list->next == (struct sk_buff *)list;
+}
+static inline __attribute__((always_inline)) bool skb_queue_is_last(const struct sk_buff_head *list,
+         const struct sk_buff *skb)
+{
+ return (skb->next == (struct sk_buff *) list);
+}
+static inline __attribute__((always_inline)) bool skb_queue_is_first(const struct sk_buff_head *list,
+          const struct sk_buff *skb)
+{
+ return (skb->prev == (struct sk_buff *) list);
+}
+static inline __attribute__((always_inline)) struct sk_buff *skb_queue_next(const struct sk_buff_head *list,
+          const struct sk_buff *skb)
+{
+ do { if (__builtin_expect(!!(skb_queue_is_last(list, skb)), 0)) do { __asm__ __volatile__ ( "1:\t.short %O0\n" "\t.pushsection __bug_table,\"a\"\n" "2:\t.long 1b\n" "\t.short %O3\n" "\t.org 2b+%O4\n" "\t.popsection\n" : : "n" (0xc33e), "i" ("include/linux/skbuff.h"), "i" (595), "i" (0), "i" (sizeof(struct bug_entry))); } while (0); } while(0);
+ return skb->next;
+}
+static inline __attribute__((always_inline)) struct sk_buff *skb_queue_prev(const struct sk_buff_head *list,
+          const struct sk_buff *skb)
+{
+ do { if (__builtin_expect(!!(skb_queue_is_first(list, skb)), 0)) do { __asm__ __volatile__ ( "1:\t.short %O0\n" "\t.pushsection __bug_table,\"a\"\n" "2:\t.long 1b\n" "\t.short %O3\n" "\t.org 2b+%O4\n" "\t.popsection\n" : : "n" (0xc33e), "i" ("include/linux/skbuff.h"), "i" (613), "i" (0), "i" (sizeof(struct bug_entry))); } while (0); } while(0);
+ return skb->prev;
+}
+static inline __attribute__((always_inline)) struct sk_buff *skb_get(struct sk_buff *skb)
+{
+ atomic_add(1,(&skb->users));
+ return skb;
+}
+static inline __attribute__((always_inline)) int skb_cloned(const struct sk_buff *skb)
+{
+ return skb->cloned &&
+        (((&((struct skb_shared_info *)(skb_end_pointer(skb)))->dataref)->counter) & ((1 << 16) - 1)) != 1;
+}
+static inline __attribute__((always_inline)) int skb_header_cloned(const struct sk_buff *skb)
+{
+ int dataref;
+ if (!skb->cloned)
+  return 0;
+ dataref = ((&((struct skb_shared_info *)(skb_end_pointer(skb)))->dataref)->counter);
+ dataref = (dataref & ((1 << 16) - 1)) - (dataref >> 16);
+ return dataref != 1;
+}
+static inline __attribute__((always_inline)) void skb_header_release(struct sk_buff *skb)
+{
+ do { if (__builtin_expect(!!(skb->nohdr), 0)) do { __asm__ __volatile__ ( "1:\t.short %O0\n" "\t.pushsection __bug_table,\"a\"\n" "2:\t.long 1b\n" "\t.short %O3\n" "\t.org 2b+%O4\n" "\t.popsection\n" : : "n" (0xc33e), "i" ("include/linux/skbuff.h"), "i" (678), "i" (0), "i" (sizeof(struct bug_entry))); } while (0); } while(0);
+ skb->nohdr = 1;
+ atomic_add(1 << 16, &((struct skb_shared_info *)(skb_end_pointer(skb)))->dataref);
+}
+static inline __attribute__((always_inline)) int skb_shared(const struct sk_buff *skb)
+{
+ return ((&skb->users)->counter) != 1;
+}
+static inline __attribute__((always_inline)) struct sk_buff *skb_share_check(struct sk_buff *skb,
+           gfp_t pri)
+{
+ do { if (pri & (( gfp_t)0x10u)) do { do { } while (0); } while (0); } while (0);
+ if (skb_shared(skb)) {
+  struct sk_buff *nskb = skb_clone(skb, pri);
+  kfree_skb(skb);
+  skb = nskb;
+ }
+ return skb;
+}
+static inline __attribute__((always_inline)) struct sk_buff *skb_unshare(struct sk_buff *skb,
+       gfp_t pri)
+{
+ do { if (pri & (( gfp_t)0x10u)) do { do { } while (0); } while (0); } while (0);
+ if (skb_cloned(skb)) {
+  struct sk_buff *nskb = skb_copy(skb, pri);
+  kfree_skb(skb);
+  skb = nskb;
+ }
+ return skb;
+}
+static inline __attribute__((always_inline)) struct sk_buff *skb_peek(struct sk_buff_head *list_)
+{
+ struct sk_buff *list = ((struct sk_buff *)list_)->next;
+ if (list == (struct sk_buff *)list_)
+  list = ((void *)0);
+ return list;
+}
+static inline __attribute__((always_inline)) struct sk_buff *skb_peek_tail(struct sk_buff_head *list_)
+{
+ struct sk_buff *list = ((struct sk_buff *)list_)->prev;
+ if (list == (struct sk_buff *)list_)
+  list = ((void *)0);
+ return list;
+}
+static inline __attribute__((always_inline)) __u32 skb_queue_len(const struct sk_buff_head *list_)
+{
+ return list_->qlen;
+}
+static inline __attribute__((always_inline)) void __skb_queue_head_init(struct sk_buff_head *list)
+{
+ list->prev = list->next = (struct sk_buff *)list;
+ list->qlen = 0;
+}
+static inline __attribute__((always_inline)) void skb_queue_head_init(struct sk_buff_head *list)
+{
+ do { *(&list->lock) = (spinlock_t) { .raw_lock = { }, }; } while (0);
+ __skb_queue_head_init(list);
+}
+static inline __attribute__((always_inline)) void skb_queue_head_init_class(struct sk_buff_head *list,
+  struct lock_class_key *class)
+{
+ skb_queue_head_init(list);
+ do { (void)(class); } while (0);
+}
+extern void skb_insert(struct sk_buff *old, struct sk_buff *newsk, struct sk_buff_head *list);
+static inline __attribute__((always_inline)) void __skb_insert(struct sk_buff *newsk,
+    struct sk_buff *prev, struct sk_buff *next,
+    struct sk_buff_head *list)
+{
+ newsk->next = next;
+ newsk->prev = prev;
+ next->prev = prev->next = newsk;
+ list->qlen++;
+}
+static inline __attribute__((always_inline)) void __skb_queue_splice(const struct sk_buff_head *list,
+          struct sk_buff *prev,
+          struct sk_buff *next)
+{
+ struct sk_buff *first = list->next;
+ struct sk_buff *last = list->prev;
+ first->prev = prev;
+ prev->next = first;
+ last->next = next;
+ next->prev = last;
+}
+static inline __attribute__((always_inline)) void skb_queue_splice(const struct sk_buff_head *list,
+        struct sk_buff_head *head)
+{
+ if (!skb_queue_empty(list)) {
+  __skb_queue_splice(list, (struct sk_buff *) head, head->next);
+  head->qlen += list->qlen;
+ }
+}
+static inline __attribute__((always_inline)) void skb_queue_splice_init(struct sk_buff_head *list,
+      struct sk_buff_head *head)
+{
+ if (!skb_queue_empty(list)) {
+  __skb_queue_splice(list, (struct sk_buff *) head, head->next);
+  head->qlen += list->qlen;
+  __skb_queue_head_init(list);
+ }
+}
+static inline __attribute__((always_inline)) void skb_queue_splice_tail(const struct sk_buff_head *list,
+      struct sk_buff_head *head)
+{
+ if (!skb_queue_empty(list)) {
+  __skb_queue_splice(list, head->prev, (struct sk_buff *) head);
+  head->qlen += list->qlen;
+ }
+}
+static inline __attribute__((always_inline)) void skb_queue_splice_tail_init(struct sk_buff_head *list,
+           struct sk_buff_head *head)
+{
+ if (!skb_queue_empty(list)) {
+  __skb_queue_splice(list, head->prev, (struct sk_buff *) head);
+  head->qlen += list->qlen;
+  __skb_queue_head_init(list);
+ }
+}
+static inline __attribute__((always_inline)) void __skb_queue_after(struct sk_buff_head *list,
+         struct sk_buff *prev,
+         struct sk_buff *newsk)
+{
+ __skb_insert(newsk, prev, prev->next, list);
+}
+extern void skb_append(struct sk_buff *old, struct sk_buff *newsk,
+         struct sk_buff_head *list);
+static inline __attribute__((always_inline)) void __skb_queue_before(struct sk_buff_head *list,
+          struct sk_buff *next,
+          struct sk_buff *newsk)
+{
+ __skb_insert(newsk, next->prev, next, list);
+}
+extern void skb_queue_head(struct sk_buff_head *list, struct sk_buff *newsk);
+static inline __attribute__((always_inline)) void __skb_queue_head(struct sk_buff_head *list,
+        struct sk_buff *newsk)
+{
+ __skb_queue_after(list, (struct sk_buff *)list, newsk);
+}
+extern void skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk);
+static inline __attribute__((always_inline)) void __skb_queue_tail(struct sk_buff_head *list,
+       struct sk_buff *newsk)
+{
+ __skb_queue_before(list, (struct sk_buff *)list, newsk);
+}
+extern void skb_unlink(struct sk_buff *skb, struct sk_buff_head *list);
+static inline __attribute__((always_inline)) void __skb_unlink(struct sk_buff *skb, struct sk_buff_head *list)
+{
+ struct sk_buff *next, *prev;
+ list->qlen--;
+ next = skb->next;
+ prev = skb->prev;
+ skb->next = skb->prev = ((void *)0);
+ next->prev = prev;
+ prev->next = next;
+}
+extern struct sk_buff *skb_dequeue(struct sk_buff_head *list);
+static inline __attribute__((always_inline)) struct sk_buff *__skb_dequeue(struct sk_buff_head *list)
+{
+ struct sk_buff *skb = skb_peek(list);
+ if (skb)
+  __skb_unlink(skb, list);
+ return skb;
+}
+extern struct sk_buff *skb_dequeue_tail(struct sk_buff_head *list);
+static inline __attribute__((always_inline)) struct sk_buff *__skb_dequeue_tail(struct sk_buff_head *list)
+{
+ struct sk_buff *skb = skb_peek_tail(list);
+ if (skb)
+  __skb_unlink(skb, list);
+ return skb;
+}
+static inline __attribute__((always_inline)) int skb_is_nonlinear(const struct sk_buff *skb)
+{
+ return skb->data_len;
+}
+static inline __attribute__((always_inline)) unsigned int skb_headlen(const struct sk_buff *skb)
+{
+ return skb->len - skb->data_len;
+}
+static inline __attribute__((always_inline)) int skb_pagelen(const struct sk_buff *skb)
+{
+ int i, len = 0;
+ for (i = (int)((struct skb_shared_info *)(skb_end_pointer(skb)))->nr_frags - 1; i >= 0; i--)
+  len += ((struct skb_shared_info *)(skb_end_pointer(skb)))->frags[i].size;
+ return len + skb_headlen(skb);
+}
+static inline __attribute__((always_inline)) void skb_fill_page_desc(struct sk_buff *skb, int i,
+          struct page *page, int off, int size)
+{
+ skb_frag_t *frag = &((struct skb_shared_info *)(skb_end_pointer(skb)))->frags[i];
+ frag->page = page;
+ frag->page_offset = off;
+ frag->size = size;
+ ((struct skb_shared_info *)(skb_end_pointer(skb)))->nr_frags = i + 1;
+}
+extern void skb_add_rx_frag(struct sk_buff *skb, int i, struct page *page,
+       int off, int size);
+static inline __attribute__((always_inline)) unsigned char *skb_tail_pointer(const struct sk_buff *skb)
+{
+ return skb->tail;
+}
+static inline __attribute__((always_inline)) void skb_reset_tail_pointer(struct sk_buff *skb)
+{
+ skb->tail = skb->data;
+}
+static inline __attribute__((always_inline)) void skb_set_tail_pointer(struct sk_buff *skb, const int offset)
+{
+ skb->tail = skb->data + offset;
+}
+extern unsigned char *skb_put(struct sk_buff *skb, unsigned int len);
+static inline __attribute__((always_inline)) unsigned char *__skb_put(struct sk_buff *skb, unsigned int len)
+{
+ unsigned char *tmp = skb_tail_pointer(skb);
+ do { if (__builtin_expect(!!(skb_is_nonlinear(skb)), 0)) do { __asm__ __volatile__ ( "1:\t.short %O0\n" "\t.pushsection __bug_table,\"a\"\n" "2:\t.long 1b\n" "\t.short %O3\n" "\t.org 2b+%O4\n" "\t.popsection\n" : : "n" (0xc33e), "i" ("include/linux/skbuff.h"), "i" (1128), "i" (0), "i" (sizeof(struct bug_entry))); } while (0); } while(0);
+ skb->tail += len;
+ skb->len += len;
+ return tmp;
+}
+extern unsigned char *skb_push(struct sk_buff *skb, unsigned int len);
+static inline __attribute__((always_inline)) unsigned char *__skb_push(struct sk_buff *skb, unsigned int len)
+{
+ skb->data -= len;
+ skb->len += len;
+ return skb->data;
+}
+extern unsigned char *skb_pull(struct sk_buff *skb, unsigned int len);
+static inline __attribute__((always_inline)) unsigned char *__skb_pull(struct sk_buff *skb, unsigned int len)
+{
+ skb->len -= len;
+ do { if (__builtin_expect(!!(skb->len < skb->data_len), 0)) do { __asm__ __volatile__ ( "1:\t.short %O0\n" "\t.pushsection __bug_table,\"a\"\n" "2:\t.long 1b\n" "\t.short %O3\n" "\t.org 2b+%O4\n" "\t.popsection\n" : : "n" (0xc33e), "i" ("include/linux/skbuff.h"), "i" (1146), "i" (0), "i" (sizeof(struct bug_entry))); } while (0); } while(0);
+ return skb->data += len;
+}
+extern unsigned char *__pskb_pull_tail(struct sk_buff *skb, int delta);
+static inline __attribute__((always_inline)) unsigned char *__pskb_pull(struct sk_buff *skb, unsigned int len)
+{
+ if (len > skb_headlen(skb) &&
+     !__pskb_pull_tail(skb, len - skb_headlen(skb)))
+  return ((void *)0);
+ skb->len -= len;
+ return skb->data += len;
+}
+static inline __attribute__((always_inline)) unsigned char *pskb_pull(struct sk_buff *skb, unsigned int len)
+{
+ return __builtin_expect(!!(len > skb->len), 0) ? ((void *)0) : __pskb_pull(skb, len);
+}
+static inline __attribute__((always_inline)) int pskb_may_pull(struct sk_buff *skb, unsigned int len)
+{
+ if (__builtin_expect(!!(len <= skb_headlen(skb)), 1))
+  return 1;
+ if (__builtin_expect(!!(len > skb->len), 0))
+  return 0;
+ return __pskb_pull_tail(skb, len - skb_headlen(skb)) != ((void *)0);
+}
+static inline __attribute__((always_inline)) unsigned int skb_headroom(const struct sk_buff *skb)
+{
+ return skb->data - skb->head;
+}
+static inline __attribute__((always_inline)) int skb_tailroom(const struct sk_buff *skb)
+{
+ return skb_is_nonlinear(skb) ? 0 : skb->end - skb->tail;
+}
+static inline __attribute__((always_inline)) void skb_reserve(struct sk_buff *skb, int len)
+{
+ skb->data += len;
+ skb->tail += len;
+}
+static inline __attribute__((always_inline)) unsigned char *skb_transport_header(const struct sk_buff *skb)
+{
+ return skb->transport_header;
+}
+static inline __attribute__((always_inline)) void skb_reset_transport_header(struct sk_buff *skb)
+{
+ skb->transport_header = skb->data;
+}
+static inline __attribute__((always_inline)) void skb_set_transport_header(struct sk_buff *skb,
+         const int offset)
+{
+ skb->transport_header = skb->data + offset;
+}
+static inline __attribute__((always_inline)) unsigned char *skb_network_header(const struct sk_buff *skb)
+{
+ return skb->network_header;
+}
+static inline __attribute__((always_inline)) void skb_reset_network_header(struct sk_buff *skb)
+{
+ skb->network_header = skb->data;
+}
+static inline __attribute__((always_inline)) void skb_set_network_header(struct sk_buff *skb, const int offset)
+{
+ skb->network_header = skb->data + offset;
+}
+static inline __attribute__((always_inline)) unsigned char *skb_mac_header(const struct sk_buff *skb)
+{
+ return skb->mac_header;
+}
+static inline __attribute__((always_inline)) int skb_mac_header_was_set(const struct sk_buff *skb)
+{
+ return skb->mac_header != ((void *)0);
+}
+static inline __attribute__((always_inline)) void skb_reset_mac_header(struct sk_buff *skb)
+{
+ skb->mac_header = skb->data;
+}
+static inline __attribute__((always_inline)) void skb_set_mac_header(struct sk_buff *skb, const int offset)
+{
+ skb->mac_header = skb->data + offset;
+}
+static inline __attribute__((always_inline)) int skb_transport_offset(const struct sk_buff *skb)
+{
+ return skb_transport_header(skb) - skb->data;
+}
+static inline __attribute__((always_inline)) u32 skb_network_header_len(const struct sk_buff *skb)
+{
+ return skb->transport_header - skb->network_header;
+}
+static inline __attribute__((always_inline)) int skb_network_offset(const struct sk_buff *skb)
+{
+ return skb_network_header(skb) - skb->data;
+}
+extern int ___pskb_trim(struct sk_buff *skb, unsigned int len);
+static inline __attribute__((always_inline)) void __skb_trim(struct sk_buff *skb, unsigned int len)
+{
+ if (__builtin_expect(!!(skb->data_len), 0)) {
+  ({ int __ret_warn_on = !!(1); if (__builtin_constant_p(__ret_warn_on)) { if (__ret_warn_on) do { __asm__ __volatile__ ( "1:\t.short %O0\n" "\t.pushsection __bug_table,\"a\"\n" "2:\t.long 1b\n" "\t.short %O3\n" "\t.org 2b+%O4\n" "\t.popsection\n" : : "n" (0xc33e), "i" ("include/linux/skbuff.h"), "i" (1383), "i" ((1<<0)), "i" (sizeof(struct bug_entry))); } while (0); } else { if (__builtin_expect(!!(__ret_warn_on), 0)) do { __asm__ __volatile__ ( "1:\t.short %O0\n" "\t.pushsection __bug_table,\"a\"\n" "2:\t.long 1b\n" "\t.short %O3\n" "\t.org 2b+%O4\n" "\t.popsection\n" : : "n" (0xc33e), "i" ("include/linux/skbuff.h"), "i" (1383), "i" ((1<<0)), "i" (sizeof(struct bug_entry))); } while (0); } __builtin_expect(!!(__ret_warn_on), 0); });
+  return;
+ }
+ skb->len = len;
+ skb_set_tail_pointer(skb, len);
+}
+extern void skb_trim(struct sk_buff *skb, unsigned int len);
+static inline __attribute__((always_inline)) int __pskb_trim(struct sk_buff *skb, unsigned int len)
+{
+ if (skb->data_len)
+  return ___pskb_trim(skb, len);
+ __skb_trim(skb, len);
+ return 0;
+}
+static inline __attribute__((always_inline)) int pskb_trim(struct sk_buff *skb, unsigned int len)
+{
+ return (len < skb->len) ? __pskb_trim(skb, len) : 0;
+}
+static inline __attribute__((always_inline)) void pskb_trim_unique(struct sk_buff *skb, unsigned int len)
+{
+ int err = pskb_trim(skb, len);
+ do { if (__builtin_expect(!!(err), 0)) do { __asm__ __volatile__ ( "1:\t.short %O0\n" "\t.pushsection __bug_table,\"a\"\n" "2:\t.long 1b\n" "\t.short %O3\n" "\t.org 2b+%O4\n" "\t.popsection\n" : : "n" (0xc33e), "i" ("include/linux/skbuff.h"), "i" (1417), "i" (0), "i" (sizeof(struct bug_entry))); } while (0); } while(0);
+}
+static inline __attribute__((always_inline)) void skb_orphan(struct sk_buff *skb)
+{
+ if (skb->destructor)
+  skb->destructor(skb);
+ skb->destructor = ((void *)0);
+ skb->sk = ((void *)0);
+}
+extern void skb_queue_purge(struct sk_buff_head *list);
+static inline __attribute__((always_inline)) void __skb_queue_purge(struct sk_buff_head *list)
+{
+ struct sk_buff *skb;
+ while ((skb = __skb_dequeue(list)) != ((void *)0))
+  kfree_skb(skb);
+}
+static inline __attribute__((always_inline)) struct sk_buff *__dev_alloc_skb(unsigned int length,
+           gfp_t gfp_mask)
+{
+ struct sk_buff *skb = alloc_skb(length + 32, gfp_mask);
+ if (__builtin_expect(!!(skb), 1))
+  skb_reserve(skb, 32);
+ return skb;
+}
+extern struct sk_buff *dev_alloc_skb(unsigned int length);
+extern struct sk_buff *__netdev_alloc_skb(struct net_device *dev,
+  unsigned int length, gfp_t gfp_mask);
+static inline __attribute__((always_inline)) struct sk_buff *netdev_alloc_skb(struct net_device *dev,
+  unsigned int length)
+{
+ return __netdev_alloc_skb(dev, length, ((( gfp_t)0x20u)));
+}
+static inline __attribute__((always_inline)) struct sk_buff *netdev_alloc_skb_ip_align(struct net_device *dev,
+  unsigned int length)
+{
+ struct sk_buff *skb = netdev_alloc_skb(dev, length + 2);
+ if (2 && skb)
+  skb_reserve(skb, 2);
+ return skb;
+}
+extern struct page *__netdev_alloc_page(struct net_device *dev, gfp_t gfp_mask);
+static inline __attribute__((always_inline)) struct page *netdev_alloc_page(struct net_device *dev)
+{
+ return __netdev_alloc_page(dev, ((( gfp_t)0x20u)));
+}
+static inline __attribute__((always_inline)) void netdev_free_page(struct net_device *dev, struct page *page)
+{
+ __free_pages((page), 0);
+}
+static inline __attribute__((always_inline)) int skb_clone_writable(struct sk_buff *skb, unsigned int len)
+{
+ return !skb_header_cloned(skb) &&
+        skb_headroom(skb) + len <= skb->hdr_len;
+}
+static inline __attribute__((always_inline)) int __skb_cow(struct sk_buff *skb, unsigned int headroom,
+       int cloned)
+{
+ int delta = 0;
+ if (headroom < 32)
+  headroom = 32;
+ if (headroom > skb_headroom(skb))
+  delta = headroom - skb_headroom(skb);
+ if (delta || cloned)
+  return pskb_expand_head(skb, (((delta)+((typeof(delta))(32)-1))&~((typeof(delta))(32)-1)), 0,
+     ((( gfp_t)0x20u)));
+ return 0;
+}
+static inline __attribute__((always_inline)) int skb_cow(struct sk_buff *skb, unsigned int headroom)
+{
+ return __skb_cow(skb, headroom, skb_cloned(skb));
+}
+static inline __attribute__((always_inline)) int skb_cow_head(struct sk_buff *skb, unsigned int headroom)
+{
+ return __skb_cow(skb, headroom, skb_header_cloned(skb));
+}
+static inline __attribute__((always_inline)) int skb_padto(struct sk_buff *skb, unsigned int len)
+{
+ unsigned int size = skb->len;
+ if (__builtin_expect(!!(size >= len), 1))
+  return 0;
+ return skb_pad(skb, len - size);
+}
+static inline __attribute__((always_inline)) int skb_add_data(struct sk_buff *skb,
+          char *from, int copy)
+{
+ const int off = skb->len;
+ if (skb->ip_summed == 0) {
+  int err = 0;
+  __wsum csum = csum_and_copy_from_user(from, skb_put(skb, copy),
+           copy, 0, &err);
+  if (!err) {
+   skb->csum = csum_block_add(skb->csum, csum, off);
+   return 0;
+  }
+ } else if (!copy_from_user(skb_put(skb, copy), from, copy))
+  return 0;
+ __skb_trim(skb, off);
+ return -14;
+}
+static inline __attribute__((always_inline)) int skb_can_coalesce(struct sk_buff *skb, int i,
+       struct page *page, int off)
+{
+ if (i) {
+  struct skb_frag_struct *frag = &((struct skb_shared_info *)(skb_end_pointer(skb)))->frags[i - 1];
+  return page == frag->page &&
+         off == frag->page_offset + frag->size;
+ }
+ return 0;
+}
+static inline __attribute__((always_inline)) int __skb_linearize(struct sk_buff *skb)
+{
+ return __pskb_pull_tail(skb, skb->data_len) ? 0 : -12;
+}
+static inline __attribute__((always_inline)) int skb_linearize(struct sk_buff *skb)
+{
+ return skb_is_nonlinear(skb) ? __skb_linearize(skb) : 0;
+}
+static inline __attribute__((always_inline)) int skb_linearize_cow(struct sk_buff *skb)
+{
+ return skb_is_nonlinear(skb) || skb_cloned(skb) ?
+        __skb_linearize(skb) : 0;
+}
+static inline __attribute__((always_inline)) void skb_postpull_rcsum(struct sk_buff *skb,
+          const void *start, unsigned int len)
+{
+ if (skb->ip_summed == 2)
+  skb->csum = csum_sub(skb->csum, csum_partial(start, len, 0));
+}
+unsigned char *skb_pull_rcsum(struct sk_buff *skb, unsigned int len);
+static inline __attribute__((always_inline)) int pskb_trim_rcsum(struct sk_buff *skb, unsigned int len)
+{
+ if (__builtin_expect(!!(len >= skb->len), 1))
+  return 0;
+ if (skb->ip_summed == 2)
+  skb->ip_summed = 0;
+ return __pskb_trim(skb, len);
+}
+static inline __attribute__((always_inline)) bool skb_has_frags(const struct sk_buff *skb)
+{
+ return ((struct skb_shared_info *)(skb_end_pointer(skb)))->frag_list != ((void *)0);
+}
+static inline __attribute__((always_inline)) void skb_frag_list_init(struct sk_buff *skb)
+{
+ ((struct skb_shared_info *)(skb_end_pointer(skb)))->frag_list = ((void *)0);
+}
+static inline __attribute__((always_inline)) void skb_frag_add_head(struct sk_buff *skb, struct sk_buff *frag)
+{
+ frag->next = ((struct skb_shared_info *)(skb_end_pointer(skb)))->frag_list;
+ ((struct skb_shared_info *)(skb_end_pointer(skb)))->frag_list = frag;
+}
+extern struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned flags,
+        int *peeked, int *err);
+extern struct sk_buff *skb_recv_datagram(struct sock *sk, unsigned flags,
+      int noblock, int *err);
+extern unsigned int datagram_poll(struct file *file, struct socket *sock,
+         struct poll_table_struct *wait);
+extern int skb_copy_datagram_iovec(const struct sk_buff *from,
+            int offset, struct iovec *to,
+            int size);
+extern int skb_copy_and_csum_datagram_iovec(struct sk_buff *skb,
+       int hlen,
+       struct iovec *iov);
+extern int skb_copy_datagram_from_iovec(struct sk_buff *skb,
+          int offset,
+          const struct iovec *from,
+          int from_offset,
+          int len);
+extern int skb_copy_datagram_const_iovec(const struct sk_buff *from,
+           int offset,
+           const struct iovec *to,
+           int to_offset,
+           int size);
+extern void skb_free_datagram(struct sock *sk, struct sk_buff *skb);
+extern void skb_free_datagram_locked(struct sock *sk,
+      struct sk_buff *skb);
+extern int skb_kill_datagram(struct sock *sk, struct sk_buff *skb,
+      unsigned int flags);
+extern __wsum skb_checksum(const struct sk_buff *skb, int offset,
+        int len, __wsum csum);
+extern int skb_copy_bits(const struct sk_buff *skb, int offset,
+         void *to, int len);
+extern int skb_store_bits(struct sk_buff *skb, int offset,
+          const void *from, int len);
+extern __wsum skb_copy_and_csum_bits(const struct sk_buff *skb,
+           int offset, u8 *to, int len,
+           __wsum csum);
+extern int skb_splice_bits(struct sk_buff *skb,
+      unsigned int offset,
+      struct pipe_inode_info *pipe,
+      unsigned int len,
+      unsigned int flags);
+extern void skb_copy_and_csum_dev(const struct sk_buff *skb, u8 *to);
+extern void skb_split(struct sk_buff *skb,
+     struct sk_buff *skb1, const u32 len);
+extern int skb_shift(struct sk_buff *tgt, struct sk_buff *skb,
+     int shiftlen);
+extern struct sk_buff *skb_segment(struct sk_buff *skb, int features);
+static inline __attribute__((always_inline)) void *skb_header_pointer(const struct sk_buff *skb, int offset,
+           int len, void *buffer)
+{
+ int hlen = skb_headlen(skb);
+ if (hlen - offset >= len)
+  return skb->data + offset;
+ if (skb_copy_bits(skb, offset, buffer, len) < 0)
+  return ((void *)0);
+ return buffer;
+}
+static inline __attribute__((always_inline)) void skb_copy_from_linear_data(const struct sk_buff *skb,
+          void *to,
+          const unsigned int len)
+{
+ memcpy(to, skb->data, len);
+}
+static inline __attribute__((always_inline)) void skb_copy_from_linear_data_offset(const struct sk_buff *skb,
+          const int offset, void *to,
+          const unsigned int len)
+{
+ memcpy(to, skb->data + offset, len);
+}
+static inline __attribute__((always_inline)) void skb_copy_to_linear_data(struct sk_buff *skb,
+        const void *from,
+        const unsigned int len)
+{
+ memcpy(skb->data, from, len);
+}
+static inline __attribute__((always_inline)) void skb_copy_to_linear_data_offset(struct sk_buff *skb,
+        const int offset,
+        const void *from,
+        const unsigned int len)
+{
+ memcpy(skb->data + offset, from, len);
+}
+extern void skb_init(void);
+static inline __attribute__((always_inline)) ktime_t skb_get_ktime(const struct sk_buff *skb)
+{
+ return skb->tstamp;
+}
+static inline __attribute__((always_inline)) void skb_get_timestamp(const struct sk_buff *skb,
+         struct timeval *stamp)
+{
+ *stamp = ktime_to_timeval(skb->tstamp);
+}
+static inline __attribute__((always_inline)) void skb_get_timestampns(const struct sk_buff *skb,
+           struct timespec *stamp)
+{
+ *stamp = ktime_to_timespec(skb->tstamp);
+}
+static inline __attribute__((always_inline)) void __net_timestamp(struct sk_buff *skb)
+{
+ skb->tstamp = ktime_get_real();
+}
+static inline __attribute__((always_inline)) ktime_t net_timedelta(ktime_t t)
+{
+ return ktime_sub(ktime_get_real(), t);
+}
+static inline __attribute__((always_inline)) ktime_t net_invalid_timestamp(void)
+{
+ return ktime_set(0, 0);
+}
+extern void skb_tstamp_tx(struct sk_buff *orig_skb,
+   struct skb_shared_hwtstamps *hwtstamps);
+extern __sum16 __skb_checksum_complete_head(struct sk_buff *skb, int len);
+extern __sum16 __skb_checksum_complete(struct sk_buff *skb);
+static inline __attribute__((always_inline)) int skb_csum_unnecessary(const struct sk_buff *skb)
+{
+ return skb->ip_summed & 1;
+}
+static inline __attribute__((always_inline)) __sum16 skb_checksum_complete(struct sk_buff *skb)
+{
+ return skb_csum_unnecessary(skb) ?
+        0 : __skb_checksum_complete(skb);
+}
+static inline __attribute__((always_inline)) void nf_reset(struct sk_buff *skb)
+{
+}
+static inline __attribute__((always_inline)) void __nf_copy(struct sk_buff *dst, const struct sk_buff *src)
+{
+}
+static inline __attribute__((always_inline)) void nf_copy(struct sk_buff *dst, const struct sk_buff *src)
+{
+ __nf_copy(dst, src);
+}
+static inline __attribute__((always_inline)) void skb_copy_secmark(struct sk_buff *to, const struct sk_buff *from)
+{ }
+static inline __attribute__((always_inline)) void skb_init_secmark(struct sk_buff *skb)
+{ }
+static inline __attribute__((always_inline)) void skb_set_queue_mapping(struct sk_buff *skb, u16 queue_mapping)
+{
+ skb->queue_mapping = queue_mapping;
+}
+static inline __attribute__((always_inline)) u16 skb_get_queue_mapping(const struct sk_buff *skb)
+{
+ return skb->queue_mapping;
+}
+static inline __attribute__((always_inline)) void skb_copy_queue_mapping(struct sk_buff *to, const struct sk_buff *from)
+{
+ to->queue_mapping = from->queue_mapping;
+}
+static inline __attribute__((always_inline)) void skb_record_rx_queue(struct sk_buff *skb, u16 rx_queue)
+{
+ skb->queue_mapping = rx_queue + 1;
+}
+static inline __attribute__((always_inline)) u16 skb_get_rx_queue(const struct sk_buff *skb)
+{
+ return skb->queue_mapping - 1;
+}
+static inline __attribute__((always_inline)) bool skb_rx_queue_recorded(const struct sk_buff *skb)
+{
+ return (skb->queue_mapping != 0);
+}
+extern u16 skb_tx_hash(const struct net_device *dev,
+         const struct sk_buff *skb);
+static inline __attribute__((always_inline)) struct sec_path *skb_sec_path(struct sk_buff *skb)
+{
+ return skb->sp;
+}
+static inline __attribute__((always_inline)) int skb_is_gso(const struct sk_buff *skb)
+{
+ return ((struct skb_shared_info *)(skb_end_pointer(skb)))->gso_size;
+}
+static inline __attribute__((always_inline)) int skb_is_gso_v6(const struct sk_buff *skb)
+{
+ return ((struct skb_shared_info *)(skb_end_pointer(skb)))->gso_type & SKB_GSO_TCPV6;
+}
+extern void __skb_warn_lro_forwarding(const struct sk_buff *skb);
+static inline __attribute__((always_inline)) bool skb_warn_if_lro(const struct sk_buff *skb)
+{
+ struct skb_shared_info *shinfo = ((struct skb_shared_info *)(skb_end_pointer(skb)));
+ if (shinfo->gso_size != 0 && __builtin_expect(!!(shinfo->gso_type == 0), 0)) {
+  __skb_warn_lro_forwarding(skb);
+  return true;
+ }
+ return false;
+}
+static inline __attribute__((always_inline)) void skb_forward_csum(struct sk_buff *skb)
+{
+ if (skb->ip_summed == 2)
+  skb->ip_summed = 0;
+}
+bool skb_partial_csum_set(struct sk_buff *skb, u16 start, u16 off);
+static inline __attribute__((always_inline)) struct ethhdr *eth_hdr(const struct sk_buff *skb)
+{
+ return (struct ethhdr *)skb_mac_header(skb);
+}
+int eth_header_parse(const struct sk_buff *skb, unsigned char *haddr);
+extern struct ctl_table ether_table[];
+extern ssize_t sysfs_format_mac(char *buf, const unsigned char *addr, int len);
+extern char *print_mac(char *buf, const unsigned char *addr) __attribute__((deprecated));
+struct sockaddr_pkt
+{
+ unsigned short spkt_family;
+ unsigned char spkt_device[14];
+ __be16 spkt_protocol;
+};
+struct sockaddr_ll
+{
+ unsigned short sll_family;
+ __be16 sll_protocol;
+ int sll_ifindex;
+ unsigned short sll_hatype;
+ unsigned char sll_pkttype;
+ unsigned char sll_halen;
+ unsigned char sll_addr[8];
+};
+struct tpacket_stats
+{
+ unsigned int tp_packets;
+ unsigned int tp_drops;
+};
+struct tpacket_auxdata
+{
+ __u32 tp_status;
+ __u32 tp_len;
+ __u32 tp_snaplen;
+ __u16 tp_mac;
+ __u16 tp_net;
+ __u16 tp_vlan_tci;
+};
+struct tpacket_hdr
+{
+ unsigned long tp_status;
+ unsigned int tp_len;
+ unsigned int tp_snaplen;
+ unsigned short tp_mac;
+ unsigned short tp_net;
+ unsigned int tp_sec;
+ unsigned int tp_usec;
+};
+struct tpacket2_hdr
+{
+ __u32 tp_status;
+ __u32 tp_len;
+ __u32 tp_snaplen;
+ __u16 tp_mac;
+ __u16 tp_net;
+ __u32 tp_sec;
+ __u32 tp_nsec;
+ __u16 tp_vlan_tci;
+};
+enum tpacket_versions
+{
+ TPACKET_V1,
+ TPACKET_V2,
+};
+struct tpacket_req
+{
+ unsigned int tp_block_size;
+ unsigned int tp_block_nr;
+ unsigned int tp_frame_size;
+ unsigned int tp_frame_nr;
+};
+struct packet_mreq
+{
+ int mr_ifindex;
+ unsigned short mr_type;
+ unsigned short mr_alen;
+ unsigned char mr_address[8];
+};
+struct ethtool_cmd {
+ __u32 cmd;
+ __u32 supported;
+ __u32 advertising;
+ __u16 speed;
+ __u8 duplex;
+ __u8 port;
+ __u8 phy_address;
+ __u8 transceiver;
+ __u8 autoneg;
+ __u8 mdio_support;
+ __u32 maxtxpkt;
+ __u32 maxrxpkt;
+ __u16 speed_hi;
+ __u8 eth_tp_mdix;
+ __u8 reserved2;
+ __u32 lp_advertising;
+ __u32 reserved[2];
+};
+static inline __attribute__((always_inline)) void ethtool_cmd_speed_set(struct ethtool_cmd *ep,
+      __u32 speed)
+{
+ ep->speed = (__u16)speed;
+ ep->speed_hi = (__u16)(speed >> 16);
+}
+static inline __attribute__((always_inline)) __u32 ethtool_cmd_speed(struct ethtool_cmd *ep)
+{
+ return (ep->speed_hi << 16) | ep->speed;
+}
+struct ethtool_drvinfo {
+ __u32 cmd;
+ char driver[32];
+ char version[32];
+ char fw_version[32];
+ char bus_info[32];
+ char reserved1[32];
+ char reserved2[12];
+ __u32 n_priv_flags;
+ __u32 n_stats;
+ __u32 testinfo_len;
+ __u32 eedump_len;
+ __u32 regdump_len;
+};
+struct ethtool_wolinfo {
+ __u32 cmd;
+ __u32 supported;
+ __u32 wolopts;
+ __u8 sopass[6];
+};
+struct ethtool_value {
+ __u32 cmd;
+ __u32 data;
+};
+struct ethtool_regs {
+ __u32 cmd;
+ __u32 version;
+ __u32 len;
+ __u8 data[0];
+};
+struct ethtool_eeprom {
+ __u32 cmd;
+ __u32 magic;
+ __u32 offset;
+ __u32 len;
+ __u8 data[0];
+};
+struct ethtool_coalesce {
+ __u32 cmd;
+ __u32 rx_coalesce_usecs;
+ __u32 rx_max_coalesced_frames;
+ __u32 rx_coalesce_usecs_irq;
+ __u32 rx_max_coalesced_frames_irq;
+ __u32 tx_coalesce_usecs;
+ __u32 tx_max_coalesced_frames;
+ __u32 tx_coalesce_usecs_irq;
+ __u32 tx_max_coalesced_frames_irq;
+ __u32 stats_block_coalesce_usecs;
+ __u32 use_adaptive_rx_coalesce;
+ __u32 use_adaptive_tx_coalesce;
+ __u32 pkt_rate_low;
+ __u32 rx_coalesce_usecs_low;
+ __u32 rx_max_coalesced_frames_low;
+ __u32 tx_coalesce_usecs_low;
+ __u32 tx_max_coalesced_frames_low;
+ __u32 pkt_rate_high;
+ __u32 rx_coalesce_usecs_high;
+ __u32 rx_max_coalesced_frames_high;
+ __u32 tx_coalesce_usecs_high;
+ __u32 tx_max_coalesced_frames_high;
+ __u32 rate_sample_interval;
+};
+struct ethtool_ringparam {
+ __u32 cmd;
+ __u32 rx_max_pending;
+ __u32 rx_mini_max_pending;
+ __u32 rx_jumbo_max_pending;
+ __u32 tx_max_pending;
+ __u32 rx_pending;
+ __u32 rx_mini_pending;
+ __u32 rx_jumbo_pending;
+ __u32 tx_pending;
+};
+struct ethtool_pauseparam {
+ __u32 cmd;
+ __u32 autoneg;
+ __u32 rx_pause;
+ __u32 tx_pause;
+};
+enum ethtool_stringset {
+ ETH_SS_TEST = 0,
+ ETH_SS_STATS,
+ ETH_SS_PRIV_FLAGS,
+};
+struct ethtool_gstrings {
+ __u32 cmd;
+ __u32 string_set;
+ __u32 len;
+ __u8 data[0];
+};
+enum ethtool_test_flags {
+ ETH_TEST_FL_OFFLINE = (1 << 0),
+ ETH_TEST_FL_FAILED = (1 << 1),
+};
+struct ethtool_test {
+ __u32 cmd;
+ __u32 flags;
+ __u32 reserved;
+ __u32 len;
+ __u64 data[0];
+};
+struct ethtool_stats {
+ __u32 cmd;
+ __u32 n_stats;
+ __u64 data[0];
+};
+struct ethtool_perm_addr {
+ __u32 cmd;
+ __u32 size;
+ __u8 data[0];
+};
+enum ethtool_flags {
+ ETH_FLAG_LRO = (1 << 15),
+};
+struct ethtool_tcpip4_spec {
+ __be32 ip4src;
+ __be32 ip4dst;
+ __be16 psrc;
+ __be16 pdst;
+ __u8 tos;
+};
+struct ethtool_ah_espip4_spec {
+ __be32 ip4src;
+ __be32 ip4dst;
+ __be32 spi;
+ __u8 tos;
+};
+struct ethtool_rawip4_spec {
+ __be32 ip4src;
+ __be32 ip4dst;
+ __u8 hdata[64];
+};
+struct ethtool_ether_spec {
+ __be16 ether_type;
+ __u8 frame_size;
+ __u8 eframe[16];
+};
+struct ethtool_usrip4_spec {
+ __be32 ip4src;
+ __be32 ip4dst;
+ __be32 l4_4_bytes;
+ __u8 tos;
+ __u8 ip_ver;
+ __u8 proto;
+};
+struct ethtool_rx_flow_spec {
+ __u32 flow_type;
+ union {
+  struct ethtool_tcpip4_spec tcp_ip4_spec;
+  struct ethtool_tcpip4_spec udp_ip4_spec;
+  struct ethtool_tcpip4_spec sctp_ip4_spec;
+  struct ethtool_ah_espip4_spec ah_ip4_spec;
+  struct ethtool_ah_espip4_spec esp_ip4_spec;
+  struct ethtool_rawip4_spec raw_ip4_spec;
+  struct ethtool_ether_spec ether_spec;
+  struct ethtool_usrip4_spec usr_ip4_spec;
+  __u8 hdata[64];
+ } h_u, m_u;
+ __u64 ring_cookie;
+ __u32 location;
+};
+struct ethtool_rxnfc {
+ __u32 cmd;
+ __u32 flow_type;
+ __u64 data;
+ struct ethtool_rx_flow_spec fs;
+ __u32 rule_cnt;
+ __u32 rule_locs[0];
+};
+enum ethtool_flash_op_type {
+ ETHTOOL_FLASH_ALL_REGIONS = 0,
+};
+struct ethtool_flash {
+ __u32 cmd;
+ __u32 region;
+ char data[128];
+};
+struct net_device;
+u32 ethtool_op_get_link(struct net_device *dev);
+u32 ethtool_op_get_rx_csum(struct net_device *dev);
+u32 ethtool_op_get_tx_csum(struct net_device *dev);
+int ethtool_op_set_tx_csum(struct net_device *dev, u32 data);
+int ethtool_op_set_tx_hw_csum(struct net_device *dev, u32 data);
+int ethtool_op_set_tx_ipv6_csum(struct net_device *dev, u32 data);
+u32 ethtool_op_get_sg(struct net_device *dev);
+int ethtool_op_set_sg(struct net_device *dev, u32 data);
+u32 ethtool_op_get_tso(struct net_device *dev);
+int ethtool_op_set_tso(struct net_device *dev, u32 data);
+u32 ethtool_op_get_ufo(struct net_device *dev);
+int ethtool_op_set_ufo(struct net_device *dev, u32 data);
+u32 ethtool_op_get_flags(struct net_device *dev);
+int ethtool_op_set_flags(struct net_device *dev, u32 data);
+struct ethtool_ops {
+ int (*get_settings)(struct net_device *, struct ethtool_cmd *);
+ int (*set_settings)(struct net_device *, struct ethtool_cmd *);
+ void (*get_drvinfo)(struct net_device *, struct ethtool_drvinfo *);
+ int (*get_regs_len)(struct net_device *);
+ void (*get_regs)(struct net_device *, struct ethtool_regs *, void *);
+ void (*get_wol)(struct net_device *, struct ethtool_wolinfo *);
+ int (*set_wol)(struct net_device *, struct ethtool_wolinfo *);
+ u32 (*get_msglevel)(struct net_device *);
+ void (*set_msglevel)(struct net_device *, u32);
+ int (*nway_reset)(struct net_device *);
+ u32 (*get_link)(struct net_device *);
+ int (*get_eeprom_len)(struct net_device *);
+ int (*get_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
+ int (*set_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
+ int (*get_coalesce)(struct net_device *, struct ethtool_coalesce *);
+ int (*set_coalesce)(struct net_device *, struct ethtool_coalesce *);
+ void (*get_ringparam)(struct net_device *, struct ethtool_ringparam *);
+ int (*set_ringparam)(struct net_device *, struct ethtool_ringparam *);
+ void (*get_pauseparam)(struct net_device *, struct ethtool_pauseparam*);
+ int (*set_pauseparam)(struct net_device *, struct ethtool_pauseparam*);
+ u32 (*get_rx_csum)(struct net_device *);
+ int (*set_rx_csum)(struct net_device *, u32);
+ u32 (*get_tx_csum)(struct net_device *);
+ int (*set_tx_csum)(struct net_device *, u32);
+ u32 (*get_sg)(struct net_device *);
+ int (*set_sg)(struct net_device *, u32);
+ u32 (*get_tso)(struct net_device *);
+ int (*set_tso)(struct net_device *, u32);
+ void (*self_test)(struct net_device *, struct ethtool_test *, u64 *);
+ void (*get_strings)(struct net_device *, u32 stringset, u8 *);
+ int (*phys_id)(struct net_device *, u32);
+ void (*get_ethtool_stats)(struct net_device *, struct ethtool_stats *, u64 *);
+ int (*begin)(struct net_device *);
+ void (*complete)(struct net_device *);
+ u32 (*get_ufo)(struct net_device *);
+ int (*set_ufo)(struct net_device *, u32);
+ u32 (*get_flags)(struct net_device *);
+ int (*set_flags)(struct net_device *, u32);
+ u32 (*get_priv_flags)(struct net_device *);
+ int (*set_priv_flags)(struct net_device *, u32);
+ int (*get_sset_count)(struct net_device *, int);
+ int (*self_test_count)(struct net_device *);
+ int (*get_stats_count)(struct net_device *);
+ int (*get_rxnfc)(struct net_device *, struct ethtool_rxnfc *, void *);
+ int (*set_rxnfc)(struct net_device *, struct ethtool_rxnfc *);
+ int (*flash_device)(struct net_device *, struct ethtool_flash *);
+};
+struct ctl_table_header;
+struct prot_inuse;
+struct netns_core {
+ struct ctl_table_header *sysctl_hdr;
+ int sysctl_somaxconn;
+ struct prot_inuse *inuse;
+};
+enum
+{
+ IPSTATS_MIB_NUM = 0,
+ IPSTATS_MIB_INPKTS,
+ IPSTATS_MIB_INHDRERRORS,
+ IPSTATS_MIB_INTOOBIGERRORS,
+ IPSTATS_MIB_INNOROUTES,
+ IPSTATS_MIB_INADDRERRORS,
+ IPSTATS_MIB_INUNKNOWNPROTOS,
+ IPSTATS_MIB_INTRUNCATEDPKTS,
+ IPSTATS_MIB_INDISCARDS,
+ IPSTATS_MIB_INDELIVERS,
+ IPSTATS_MIB_OUTFORWDATAGRAMS,
+ IPSTATS_MIB_OUTPKTS,
+ IPSTATS_MIB_OUTDISCARDS,
+ IPSTATS_MIB_OUTNOROUTES,
+ IPSTATS_MIB_REASMTIMEOUT,
+ IPSTATS_MIB_REASMREQDS,
+ IPSTATS_MIB_REASMOKS,
+ IPSTATS_MIB_REASMFAILS,
+ IPSTATS_MIB_FRAGOKS,
+ IPSTATS_MIB_FRAGFAILS,
+ IPSTATS_MIB_FRAGCREATES,
+ IPSTATS_MIB_INMCASTPKTS,
+ IPSTATS_MIB_OUTMCASTPKTS,
+ IPSTATS_MIB_INBCASTPKTS,
+ IPSTATS_MIB_OUTBCASTPKTS,
+ IPSTATS_MIB_INOCTETS,
+ IPSTATS_MIB_OUTOCTETS,
+ IPSTATS_MIB_INMCASTOCTETS,
+ IPSTATS_MIB_OUTMCASTOCTETS,
+ IPSTATS_MIB_INBCASTOCTETS,
+ IPSTATS_MIB_OUTBCASTOCTETS,
+ __IPSTATS_MIB_MAX
+};
+enum
+{
+ ICMP_MIB_NUM = 0,
+ ICMP_MIB_INMSGS,
+ ICMP_MIB_INERRORS,
+ ICMP_MIB_INDESTUNREACHS,
+ ICMP_MIB_INTIMEEXCDS,
+ ICMP_MIB_INPARMPROBS,
+ ICMP_MIB_INSRCQUENCHS,
+ ICMP_MIB_INREDIRECTS,
+ ICMP_MIB_INECHOS,
+ ICMP_MIB_INECHOREPS,
+ ICMP_MIB_INTIMESTAMPS,
+ ICMP_MIB_INTIMESTAMPREPS,
+ ICMP_MIB_INADDRMASKS,
+ ICMP_MIB_INADDRMASKREPS,
+ ICMP_MIB_OUTMSGS,
+ ICMP_MIB_OUTERRORS,
+ ICMP_MIB_OUTDESTUNREACHS,
+ ICMP_MIB_OUTTIMEEXCDS,
+ ICMP_MIB_OUTPARMPROBS,
+ ICMP_MIB_OUTSRCQUENCHS,
+ ICMP_MIB_OUTREDIRECTS,
+ ICMP_MIB_OUTECHOS,
+ ICMP_MIB_OUTECHOREPS,
+ ICMP_MIB_OUTTIMESTAMPS,
+ ICMP_MIB_OUTTIMESTAMPREPS,
+ ICMP_MIB_OUTADDRMASKS,
+ ICMP_MIB_OUTADDRMASKREPS,
+ __ICMP_MIB_MAX
+};
+enum
+{
+ ICMP6_MIB_NUM = 0,
+ ICMP6_MIB_INMSGS,
+ ICMP6_MIB_INERRORS,
+ ICMP6_MIB_OUTMSGS,
+ __ICMP6_MIB_MAX
+};
+enum
+{
+ TCP_MIB_NUM = 0,
+ TCP_MIB_RTOALGORITHM,
+ TCP_MIB_RTOMIN,
+ TCP_MIB_RTOMAX,
+ TCP_MIB_MAXCONN,
+ TCP_MIB_ACTIVEOPENS,
+ TCP_MIB_PASSIVEOPENS,
+ TCP_MIB_ATTEMPTFAILS,
+ TCP_MIB_ESTABRESETS,
+ TCP_MIB_CURRESTAB,
+ TCP_MIB_INSEGS,
+ TCP_MIB_OUTSEGS,
+ TCP_MIB_RETRANSSEGS,
+ TCP_MIB_INERRS,
+ TCP_MIB_OUTRSTS,
+ __TCP_MIB_MAX
+};
+enum
+{
+ UDP_MIB_NUM = 0,
+ UDP_MIB_INDATAGRAMS,
+ UDP_MIB_NOPORTS,
+ UDP_MIB_INERRORS,
+ UDP_MIB_OUTDATAGRAMS,
+ UDP_MIB_RCVBUFERRORS,
+ UDP_MIB_SNDBUFERRORS,
+ __UDP_MIB_MAX
+};
+enum
+{
+ LINUX_MIB_NUM = 0,
+ LINUX_MIB_SYNCOOKIESSENT,
+ LINUX_MIB_SYNCOOKIESRECV,
+ LINUX_MIB_SYNCOOKIESFAILED,
+ LINUX_MIB_EMBRYONICRSTS,
+ LINUX_MIB_PRUNECALLED,
+ LINUX_MIB_RCVPRUNED,
+ LINUX_MIB_OFOPRUNED,
+ LINUX_MIB_OUTOFWINDOWICMPS,
+ LINUX_MIB_LOCKDROPPEDICMPS,
+ LINUX_MIB_ARPFILTER,
+ LINUX_MIB_TIMEWAITED,
+ LINUX_MIB_TIMEWAITRECYCLED,
+ LINUX_MIB_TIMEWAITKILLED,
+ LINUX_MIB_PAWSPASSIVEREJECTED,
+ LINUX_MIB_PAWSACTIVEREJECTED,
+ LINUX_MIB_PAWSESTABREJECTED,
+ LINUX_MIB_DELAYEDACKS,
+ LINUX_MIB_DELAYEDACKLOCKED,
+ LINUX_MIB_DELAYEDACKLOST,
+ LINUX_MIB_LISTENOVERFLOWS,
+ LINUX_MIB_LISTENDROPS,
+ LINUX_MIB_TCPPREQUEUED,
+ LINUX_MIB_TCPDIRECTCOPYFROMBACKLOG,
+ LINUX_MIB_TCPDIRECTCOPYFROMPREQUEUE,
+ LINUX_MIB_TCPPREQUEUEDROPPED,
+ LINUX_MIB_TCPHPHITS,
+ LINUX_MIB_TCPHPHITSTOUSER,
+ LINUX_MIB_TCPPUREACKS,
+ LINUX_MIB_TCPHPACKS,
+ LINUX_MIB_TCPRENORECOVERY,
+ LINUX_MIB_TCPSACKRECOVERY,
+ LINUX_MIB_TCPSACKRENEGING,
+ LINUX_MIB_TCPFACKREORDER,
+ LINUX_MIB_TCPSACKREORDER,
+ LINUX_MIB_TCPRENOREORDER,
+ LINUX_MIB_TCPTSREORDER,
+ LINUX_MIB_TCPFULLUNDO,
+ LINUX_MIB_TCPPARTIALUNDO,
+ LINUX_MIB_TCPDSACKUNDO,
+ LINUX_MIB_TCPLOSSUNDO,
+ LINUX_MIB_TCPLOSS,
+ LINUX_MIB_TCPLOSTRETRANSMIT,
+ LINUX_MIB_TCPRENOFAILURES,
+ LINUX_MIB_TCPSACKFAILURES,
+ LINUX_MIB_TCPLOSSFAILURES,
+ LINUX_MIB_TCPFASTRETRANS,
+ LINUX_MIB_TCPFORWARDRETRANS,
+ LINUX_MIB_TCPSLOWSTARTRETRANS,
+ LINUX_MIB_TCPTIMEOUTS,
+ LINUX_MIB_TCPRENORECOVERYFAIL,
+ LINUX_MIB_TCPSACKRECOVERYFAIL,
+ LINUX_MIB_TCPSCHEDULERFAILED,
+ LINUX_MIB_TCPRCVCOLLAPSED,
+ LINUX_MIB_TCPDSACKOLDSENT,
+ LINUX_MIB_TCPDSACKOFOSENT,
+ LINUX_MIB_TCPDSACKRECV,
+ LINUX_MIB_TCPDSACKOFORECV,
+ LINUX_MIB_TCPABORTONSYN,
+ LINUX_MIB_TCPABORTONDATA,
+ LINUX_MIB_TCPABORTONCLOSE,
+ LINUX_MIB_TCPABORTONMEMORY,
+ LINUX_MIB_TCPABORTONTIMEOUT,
+ LINUX_MIB_TCPABORTONLINGER,
+ LINUX_MIB_TCPABORTFAILED,
+ LINUX_MIB_TCPMEMORYPRESSURES,
+ LINUX_MIB_TCPSACKDISCARD,
+ LINUX_MIB_TCPDSACKIGNOREDOLD,
+ LINUX_MIB_TCPDSACKIGNOREDNOUNDO,
+ LINUX_MIB_TCPSPURIOUSRTOS,
+ LINUX_MIB_TCPMD5NOTFOUND,
+ LINUX_MIB_TCPMD5UNEXPECTED,
+ LINUX_MIB_SACKSHIFTED,
+ LINUX_MIB_SACKMERGED,
+ LINUX_MIB_SACKSHIFTFALLBACK,
+ __LINUX_MIB_MAX
+};
+enum
+{
+ LINUX_MIB_XFRMNUM = 0,
+ LINUX_MIB_XFRMINERROR,
+ LINUX_MIB_XFRMINBUFFERERROR,
+ LINUX_MIB_XFRMINHDRERROR,
+ LINUX_MIB_XFRMINNOSTATES,
+ LINUX_MIB_XFRMINSTATEPROTOERROR,
+ LINUX_MIB_XFRMINSTATEMODEERROR,
+ LINUX_MIB_XFRMINSTATESEQERROR,
+ LINUX_MIB_XFRMINSTATEEXPIRED,
+ LINUX_MIB_XFRMINSTATEMISMATCH,
+ LINUX_MIB_XFRMINSTATEINVALID,
+ LINUX_MIB_XFRMINTMPLMISMATCH,
+ LINUX_MIB_XFRMINNOPOLS,
+ LINUX_MIB_XFRMINPOLBLOCK,
+ LINUX_MIB_XFRMINPOLERROR,
+ LINUX_MIB_XFRMOUTERROR,
+ LINUX_MIB_XFRMOUTBUNDLEGENERROR,
+ LINUX_MIB_XFRMOUTBUNDLECHECKERROR,
+ LINUX_MIB_XFRMOUTNOSTATES,
+ LINUX_MIB_XFRMOUTSTATEPROTOERROR,
+ LINUX_MIB_XFRMOUTSTATEMODEERROR,
+ LINUX_MIB_XFRMOUTSTATESEQERROR,
+ LINUX_MIB_XFRMOUTSTATEEXPIRED,
+ LINUX_MIB_XFRMOUTPOLBLOCK,
+ LINUX_MIB_XFRMOUTPOLDEAD,
+ LINUX_MIB_XFRMOUTPOLERROR,
+ __LINUX_MIB_XFRMMAX
+};
+struct snmp_mib {
+ char *name;
+ int entry;
+};
+struct ipstats_mib {
+ unsigned long mibs[__IPSTATS_MIB_MAX];
+} __attribute__((__aligned__((1 << 5))));
+struct icmp_mib {
+ unsigned long mibs[(__ICMP_MIB_MAX + 1)];
+} __attribute__((__aligned__((1 << 5))));
+struct icmpmsg_mib {
+ unsigned long mibs[512];
+} __attribute__((__aligned__((1 << 5))));
+struct icmpv6_mib {
+ unsigned long mibs[__ICMP6_MIB_MAX];
+} __attribute__((__aligned__((1 << 5))));
+struct icmpv6msg_mib {
+ unsigned long mibs[512];
+} __attribute__((__aligned__((1 << 5))));
+struct tcp_mib {
+ unsigned long mibs[__TCP_MIB_MAX];
+} __attribute__((__aligned__((1 << 5))));
+struct udp_mib {
+ unsigned long mibs[__UDP_MIB_MAX];
+} __attribute__((__aligned__((1 << 5))));
+struct linux_mib {
+ unsigned long mibs[__LINUX_MIB_MAX];
+};
+struct linux_xfrm_mib {
+ unsigned long mibs[__LINUX_MIB_XFRMMAX];
+};
+struct netns_mib {
+ __typeof__(struct tcp_mib) *tcp_statistics[2];
+ __typeof__(struct ipstats_mib) *ip_statistics[2];
+ __typeof__(struct linux_mib) *net_statistics[2];
+ __typeof__(struct udp_mib) *udp_statistics[2];
+ __typeof__(struct udp_mib) *udplite_statistics[2];
+ __typeof__(struct icmp_mib) *icmp_statistics[2];
+ __typeof__(struct icmpmsg_mib) *icmpmsg_statistics[2];
+};
+struct ctl_table_header;
+struct netns_unix {
+ int sysctl_max_dgram_qlen;
+ struct ctl_table_header *ctl;
+};
+struct netns_packet {
+ rwlock_t sklist_lock;
+ struct hlist_head sklist;
+};
+struct netns_frags {
+ int nqueues;
+ atomic_t mem;
+ struct list_head lru_list;
+ int timeout;
+ int high_thresh;
+ int low_thresh;
+};
+struct inet_frag_queue {
+ struct hlist_node list;
+ struct netns_frags *net;
+ struct list_head lru_list;
+ spinlock_t lock;
+ atomic_t refcnt;
+ struct timer_list timer;
+ struct sk_buff *fragments;
+ ktime_t stamp;
+ int len;
+ int meat;
+ __u8 last_in;
+};
+struct inet_frags {
+ struct hlist_head hash[64];
+ rwlock_t lock;
+ u32 rnd;
+ int qsize;
+ int secret_interval;
+ struct timer_list secret_timer;
+ unsigned int (*hashfn)(struct inet_frag_queue *);
+ void (*constructor)(struct inet_frag_queue *q,
+      void *arg);
+ void (*destructor)(struct inet_frag_queue *);
+ void (*skb_free)(struct sk_buff *);
+ int (*match)(struct inet_frag_queue *q,
+      void *arg);
+ void (*frag_expire)(unsigned long data);
+};
+void inet_frags_init(struct inet_frags *);
+void inet_frags_fini(struct inet_frags *);
+void inet_frags_init_net(struct netns_frags *nf);
+void inet_frags_exit_net(struct netns_frags *nf, struct inet_frags *f);
+void inet_frag_kill(struct inet_frag_queue *q, struct inet_frags *f);
+void inet_frag_destroy(struct inet_frag_queue *q,
+    struct inet_frags *f, int *work);
+int inet_frag_evictor(struct netns_frags *nf, struct inet_frags *f);
+struct inet_frag_queue *inet_frag_find(struct netns_frags *nf,
+  struct inet_frags *f, void *key, unsigned int hash)
+ ;
+static inline __attribute__((always_inline)) void inet_frag_put(struct inet_frag_queue *q, struct inet_frags *f)
+{
+ if ((atomic_sub_return(1, (&q->refcnt)) == 0))
+  inet_frag_destroy(q, f, ((void *)0));
+}
+struct ctl_table_header;
+struct ipv4_devconf;
+struct fib_rules_ops;
+struct hlist_head;
+struct sock;
+struct netns_ipv4 {
+ struct ctl_table_header *forw_hdr;
+ struct ctl_table_header *frags_hdr;
+ struct ctl_table_header *ipv4_hdr;
+ struct ctl_table_header *route_hdr;
+ struct ipv4_devconf *devconf_all;
+ struct ipv4_devconf *devconf_dflt;
+ struct hlist_head *fib_table_hash;
+ struct sock *fibnl;
+ struct sock **icmp_sk;
+ struct sock *tcp_sock;
+ struct netns_frags frags;
+ struct xt_table *iptable_filter;
+ struct xt_table *iptable_mangle;
+ struct xt_table *iptable_raw;
+ struct xt_table *arptable_filter;
+ struct xt_table *iptable_security;
+ struct xt_table *nat_table;
+ struct hlist_head *nat_bysource;
+ unsigned int nat_htable_size;
+ int nat_vmalloced;
+ int sysctl_icmp_echo_ignore_all;
+ int sysctl_icmp_echo_ignore_broadcasts;
+ int sysctl_icmp_ignore_bogus_error_responses;
+ int sysctl_icmp_ratelimit;
+ int sysctl_icmp_ratemask;
+ int sysctl_icmp_errors_use_inbound_ifaddr;
+ int sysctl_rt_cache_rebuild_count;
+ int current_rt_cache_rebuild_count;
+ struct timer_list rt_secret_timer;
+ atomic_t rt_genid;
+};
+struct dst_entry;
+struct kmem_cachep;
+struct net_device;
+struct sk_buff;
+struct dst_ops {
+ unsigned short family;
+ __be16 protocol;
+ unsigned gc_thresh;
+ int (*gc)(struct dst_ops *ops);
+ struct dst_entry * (*check)(struct dst_entry *, __u32 cookie);
+ void (*destroy)(struct dst_entry *);
+ void (*ifdown)(struct dst_entry *,
+       struct net_device *dev, int how);
+ struct dst_entry * (*negative_advice)(struct dst_entry *);
+ void (*link_failure)(struct sk_buff *);
+ void (*update_pmtu)(struct dst_entry *dst, u32 mtu);
+ int (*local_out)(struct sk_buff *skb);
+ atomic_t entries;
+ struct kmem_cache *kmem_cachep;
+};
+struct ctl_table_header;
+struct netns_sysctl_ipv6 {
+ struct ctl_table_header *table;
+ struct ctl_table_header *frags_hdr;
+ int bindv6only;
+ int flush_delay;
+ int ip6_rt_max_size;
+ int ip6_rt_gc_min_interval;
+ int ip6_rt_gc_timeout;
+ int ip6_rt_gc_interval;
+ int ip6_rt_gc_elasticity;
+ int ip6_rt_mtu_expires;
+ int ip6_rt_min_advmss;
+ int icmpv6_time;
+};
+struct netns_ipv6 {
+ struct netns_sysctl_ipv6 sysctl;
+ struct ipv6_devconf *devconf_all;
+ struct ipv6_devconf *devconf_dflt;
+ struct netns_frags frags;
+ struct xt_table *ip6table_filter;
+ struct xt_table *ip6table_mangle;
+ struct xt_table *ip6table_raw;
+ struct xt_table *ip6table_security;
+ struct rt6_info *ip6_null_entry;
+ struct rt6_statistics *rt6_stats;
+ struct timer_list ip6_fib_timer;
+ struct hlist_head *fib_table_hash;
+ struct fib6_table *fib6_main_tbl;
+ struct dst_ops ip6_dst_ops;
+ unsigned int ip6_rt_gc_expire;
+ unsigned long ip6_rt_last_gc;
+ struct sock **icmp_sk;
+ struct sock *ndisc_sk;
+ struct sock *tcp_sk;
+ struct sock *igmp_sk;
+};
+struct sock;
+struct netns_dccp {
+ struct sock *v4_ctl_sk;
+ struct sock *v6_ctl_sk;
+};
+enum {
+  IPPROTO_IP = 0,
+  IPPROTO_ICMP = 1,
+  IPPROTO_IGMP = 2,
+  IPPROTO_IPIP = 4,
+  IPPROTO_TCP = 6,
+  IPPROTO_EGP = 8,
+  IPPROTO_PUP = 12,
+  IPPROTO_UDP = 17,
+  IPPROTO_IDP = 22,
+  IPPROTO_DCCP = 33,
+  IPPROTO_RSVP = 46,
+  IPPROTO_GRE = 47,
+  IPPROTO_IPV6 = 41,
+  IPPROTO_ESP = 50,
+  IPPROTO_AH = 51,
+  IPPROTO_BEETPH = 94,
+  IPPROTO_PIM = 103,
+  IPPROTO_COMP = 108,
+  IPPROTO_SCTP = 132,
+  IPPROTO_UDPLITE = 136,
+  IPPROTO_RAW = 255,
+  IPPROTO_MAX
+};
+struct in_addr {
+ __be32 s_addr;
+};
+struct ip_mreq
+{
+ struct in_addr imr_multiaddr;
+ struct in_addr imr_interface;
+};
+struct ip_mreqn
+{
+ struct in_addr imr_multiaddr;
+ struct in_addr imr_address;
+ int imr_ifindex;
+};
+struct ip_mreq_source {
+ __be32 imr_multiaddr;
+ __be32 imr_interface;
+ __be32 imr_sourceaddr;
+};
+struct ip_msfilter {
+ __be32 imsf_multiaddr;
+ __be32 imsf_interface;
+ __u32 imsf_fmode;
+ __u32 imsf_numsrc;
+ __be32 imsf_slist[1];
+};
+struct group_req
+{
+ __u32 gr_interface;
+ struct __kernel_sockaddr_storage gr_group;
+};
+struct group_source_req
+{
+ __u32 gsr_interface;
+ struct __kernel_sockaddr_storage gsr_group;
+ struct __kernel_sockaddr_storage gsr_source;
+};
+struct group_filter
+{
+ __u32 gf_interface;
+ struct __kernel_sockaddr_storage gf_group;
+ __u32 gf_fmode;
+ __u32 gf_numsrc;
+ struct __kernel_sockaddr_storage gf_slist[1];
+};
+struct in_pktinfo
+{
+ int ipi_ifindex;
+ struct in_addr ipi_spec_dst;
+ struct in_addr ipi_addr;
+};
+struct sockaddr_in {
+  sa_family_t sin_family;
+  __be16 sin_port;
+  struct in_addr sin_addr;
+  unsigned char __pad[16 - sizeof(short int) -
+   sizeof(unsigned short int) - sizeof(struct in_addr)];
+};
+static inline __attribute__((always_inline)) bool ipv4_is_loopback(__be32 addr)
+{
+ return (addr & (( __be32)(__builtin_constant_p((__u32)((0xff000000))) ? ((__u32)( (((__u32)((0xff000000)) & (__u32)0x000000ffUL) << 24) | (((__u32)((0xff000000)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((0xff000000)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((0xff000000)) & (__u32)0xff000000UL) >> 24))) : __fswab32((0xff000000))))) == (( __be32)(__builtin_constant_p((__u32)((0x7f000000))) ? ((__u32)( (((__u32)((0x7f000000)) & (__u32)0x000000ffUL) << 24) | (((__u32)((0x7f000000)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((0x7f000000)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((0x7f000000)) & (__u32)0xff000000UL) >> 24))) : __fswab32((0x7f000000))));
+}
+static inline __attribute__((always_inline)) bool ipv4_is_multicast(__be32 addr)
+{
+ return (addr & (( __be32)(__builtin_constant_p((__u32)((0xf0000000))) ? ((__u32)( (((__u32)((0xf0000000)) & (__u32)0x000000ffUL) << 24) | (((__u32)((0xf0000000)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((0xf0000000)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((0xf0000000)) & (__u32)0xff000000UL) >> 24))) : __fswab32((0xf0000000))))) == (( __be32)(__builtin_constant_p((__u32)((0xe0000000))) ? ((__u32)( (((__u32)((0xe0000000)) & (__u32)0x000000ffUL) << 24) | (((__u32)((0xe0000000)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((0xe0000000)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((0xe0000000)) & (__u32)0xff000000UL) >> 24))) : __fswab32((0xe0000000))));
+}
+static inline __attribute__((always_inline)) bool ipv4_is_local_multicast(__be32 addr)
+{
+ return (addr & (( __be32)(__builtin_constant_p((__u32)((0xffffff00))) ? ((__u32)( (((__u32)((0xffffff00)) & (__u32)0x000000ffUL) << 24) | (((__u32)((0xffffff00)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((0xffffff00)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((0xffffff00)) & (__u32)0xff000000UL) >> 24))) : __fswab32((0xffffff00))))) == (( __be32)(__builtin_constant_p((__u32)((0xe0000000))) ? ((__u32)( (((__u32)((0xe0000000)) & (__u32)0x000000ffUL) << 24) | (((__u32)((0xe0000000)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((0xe0000000)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((0xe0000000)) & (__u32)0xff000000UL) >> 24))) : __fswab32((0xe0000000))));
+}
+static inline __attribute__((always_inline)) bool ipv4_is_lbcast(__be32 addr)
+{
+ return addr == (( __be32)(__builtin_constant_p((__u32)((((unsigned long int) 0xffffffff)))) ? ((__u32)( (((__u32)((((unsigned long int) 0xffffffff))) & (__u32)0x000000ffUL) << 24) | (((__u32)((((unsigned long int) 0xffffffff))) & (__u32)0x0000ff00UL) << 8) | (((__u32)((((unsigned long int) 0xffffffff))) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((((unsigned long int) 0xffffffff))) & (__u32)0xff000000UL) >> 24))) : __fswab32((((unsigned long int) 0xffffffff)))));
+}
+static inline __attribute__((always_inline)) bool ipv4_is_zeronet(__be32 addr)
+{
+ return (addr & (( __be32)(__builtin_constant_p((__u32)((0xff000000))) ? ((__u32)( (((__u32)((0xff000000)) & (__u32)0x000000ffUL) << 24) | (((__u32)((0xff000000)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((0xff000000)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((0xff000000)) & (__u32)0xff000000UL) >> 24))) : __fswab32((0xff000000))))) == (( __be32)(__builtin_constant_p((__u32)((0x00000000))) ? ((__u32)( (((__u32)((0x00000000)) & (__u32)0x000000ffUL) << 24) | (((__u32)((0x00000000)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((0x00000000)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((0x00000000)) & (__u32)0xff000000UL) >> 24))) : __fswab32((0x00000000))));
+}
+static inline __attribute__((always_inline)) bool ipv4_is_private_10(__be32 addr)
+{
+ return (addr & (( __be32)(__builtin_constant_p((__u32)((0xff000000))) ? ((__u32)( (((__u32)((0xff000000)) & (__u32)0x000000ffUL) << 24) | (((__u32)((0xff000000)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((0xff000000)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((0xff000000)) & (__u32)0xff000000UL) >> 24))) : __fswab32((0xff000000))))) == (( __be32)(__builtin_constant_p((__u32)((0x0a000000))) ? ((__u32)( (((__u32)((0x0a000000)) & (__u32)0x000000ffUL) << 24) | (((__u32)((0x0a000000)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((0x0a000000)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((0x0a000000)) & (__u32)0xff000000UL) >> 24))) : __fswab32((0x0a000000))));
+}
+static inline __attribute__((always_inline)) bool ipv4_is_private_172(__be32 addr)
+{
+ return (addr & (( __be32)(__builtin_constant_p((__u32)((0xfff00000))) ? ((__u32)( (((__u32)((0xfff00000)) & (__u32)0x000000ffUL) << 24) | (((__u32)((0xfff00000)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((0xfff00000)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((0xfff00000)) & (__u32)0xff000000UL) >> 24))) : __fswab32((0xfff00000))))) == (( __be32)(__builtin_constant_p((__u32)((0xac100000))) ? ((__u32)( (((__u32)((0xac100000)) & (__u32)0x000000ffUL) << 24) | (((__u32)((0xac100000)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((0xac100000)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((0xac100000)) & (__u32)0xff000000UL) >> 24))) : __fswab32((0xac100000))));
+}
+static inline __attribute__((always_inline)) bool ipv4_is_private_192(__be32 addr)
+{
+ return (addr & (( __be32)(__builtin_constant_p((__u32)((0xffff0000))) ? ((__u32)( (((__u32)((0xffff0000)) & (__u32)0x000000ffUL) << 24) | (((__u32)((0xffff0000)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((0xffff0000)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((0xffff0000)) & (__u32)0xff000000UL) >> 24))) : __fswab32((0xffff0000))))) == (( __be32)(__builtin_constant_p((__u32)((0xc0a80000))) ? ((__u32)( (((__u32)((0xc0a80000)) & (__u32)0x000000ffUL) << 24) | (((__u32)((0xc0a80000)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((0xc0a80000)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((0xc0a80000)) & (__u32)0xff000000UL) >> 24))) : __fswab32((0xc0a80000))));
+}
+static inline __attribute__((always_inline)) bool ipv4_is_linklocal_169(__be32 addr)
+{
+ return (addr & (( __be32)(__builtin_constant_p((__u32)((0xffff0000))) ? ((__u32)( (((__u32)((0xffff0000)) & (__u32)0x000000ffUL) << 24) | (((__u32)((0xffff0000)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((0xffff0000)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((0xffff0000)) & (__u32)0xff000000UL) >> 24))) : __fswab32((0xffff0000))))) == (( __be32)(__builtin_constant_p((__u32)((0xa9fe0000))) ? ((__u32)( (((__u32)((0xa9fe0000)) & (__u32)0x000000ffUL) << 24) | (((__u32)((0xa9fe0000)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((0xa9fe0000)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((0xa9fe0000)) & (__u32)0xff000000UL) >> 24))) : __fswab32((0xa9fe0000))));
+}
+static inline __attribute__((always_inline)) bool ipv4_is_anycast_6to4(__be32 addr)
+{
+ return (addr & (( __be32)(__builtin_constant_p((__u32)((0xffffff00))) ? ((__u32)( (((__u32)((0xffffff00)) & (__u32)0x000000ffUL) << 24) | (((__u32)((0xffffff00)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((0xffffff00)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((0xffffff00)) & (__u32)0xff000000UL) >> 24))) : __fswab32((0xffffff00))))) == (( __be32)(__builtin_constant_p((__u32)((0xc0586300))) ? ((__u32)( (((__u32)((0xc0586300)) & (__u32)0x000000ffUL) << 24) | (((__u32)((0xc0586300)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((0xc0586300)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((0xc0586300)) & (__u32)0xff000000UL) >> 24))) : __fswab32((0xc0586300))));
+}
+static inline __attribute__((always_inline)) bool ipv4_is_test_192(__be32 addr)
+{
+ return (addr & (( __be32)(__builtin_constant_p((__u32)((0xffffff00))) ? ((__u32)( (((__u32)((0xffffff00)) & (__u32)0x000000ffUL) << 24) | (((__u32)((0xffffff00)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((0xffffff00)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((0xffffff00)) & (__u32)0xff000000UL) >> 24))) : __fswab32((0xffffff00))))) == (( __be32)(__builtin_constant_p((__u32)((0xc0000200))) ? ((__u32)( (((__u32)((0xc0000200)) & (__u32)0x000000ffUL) << 24) | (((__u32)((0xc0000200)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((0xc0000200)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((0xc0000200)) & (__u32)0xff000000UL) >> 24))) : __fswab32((0xc0000200))));
+}
+static inline __attribute__((always_inline)) bool ipv4_is_test_198(__be32 addr)
+{
+ return (addr & (( __be32)(__builtin_constant_p((__u32)((0xfffe0000))) ? ((__u32)( (((__u32)((0xfffe0000)) & (__u32)0x000000ffUL) << 24) | (((__u32)((0xfffe0000)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((0xfffe0000)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((0xfffe0000)) & (__u32)0xff000000UL) >> 24))) : __fswab32((0xfffe0000))))) == (( __be32)(__builtin_constant_p((__u32)((0xc6120000))) ? ((__u32)( (((__u32)((0xc6120000)) & (__u32)0x000000ffUL) << 24) | (((__u32)((0xc6120000)) & (__u32)0x0000ff00UL) << 8) | (((__u32)((0xc6120000)) & (__u32)0x00ff0000UL) >> 8) | (((__u32)((0xc6120000)) & (__u32)0xff000000UL) >> 24))) : __fswab32((0xc6120000))));
+}
+enum nf_inet_hooks {
+ NF_INET_PRE_ROUTING,
+ NF_INET_LOCAL_IN,
+ NF_INET_FORWARD,
+ NF_INET_LOCAL_OUT,
+ NF_INET_POST_ROUTING,
+ NF_INET_NUMHOOKS
+};
+enum {
+ NFPROTO_UNSPEC = 0,
+ NFPROTO_IPV4 = 2,
+ NFPROTO_ARP = 3,
+ NFPROTO_BRIDGE = 7,
+ NFPROTO_IPV6 = 10,
+ NFPROTO_DECNET = 12,
+ NFPROTO_NUMPROTO,
+};
+union nf_inet_addr {
+ __u32 all[4];
+ __be32 ip;
+ __be32 ip6[4];
+ struct in_addr in;
+ struct in6_addr in6;
+};
+static inline __attribute__((always_inline)) int nf_inet_addr_cmp(const union nf_inet_addr *a1,
+       const union nf_inet_addr *a2)
+{
+ return a1->all[0] == a2->all[0] &&
+        a1->all[1] == a2->all[1] &&
+        a1->all[2] == a2->all[2] &&
+        a1->all[3] == a2->all[3];
+}
+extern void netfilter_init(void);
+struct sk_buff;
+typedef unsigned int nf_hookfn(unsigned int hooknum,
+          struct sk_buff *skb,
+          const struct net_device *in,
+          const struct net_device *out,
+          int (*okfn)(struct sk_buff *));
+struct nf_hook_ops
+{
+ struct list_head list;
+ nf_hookfn *hook;
+ struct module *owner;
+ u_int8_t pf;
+ unsigned int hooknum;
+ int priority;
+};
+struct nf_sockopt_ops
+{
+ struct list_head list;
+ u_int8_t pf;
+ int set_optmin;
+ int set_optmax;
+ int (*set)(struct sock *sk, int optval, void *user, unsigned int len);
+ int (*compat_set)(struct sock *sk, int optval,
+   void *user, unsigned int len);
+ int get_optmin;
+ int get_optmax;
+ int (*get)(struct sock *sk, int optval, void *user, int *len);
+ int (*compat_get)(struct sock *sk, int optval,
+   void *user, int *len);
+ struct module *owner;
+};
+int nf_register_hook(struct nf_hook_ops *reg);
+void nf_unregister_hook(struct nf_hook_ops *reg);
+int nf_register_hooks(struct nf_hook_ops *reg, unsigned int n);
+void nf_unregister_hooks(struct nf_hook_ops *reg, unsigned int n);
+int nf_register_sockopt(struct nf_sockopt_ops *reg);
+void nf_unregister_sockopt(struct nf_sockopt_ops *reg);
+extern struct ctl_path nf_net_netfilter_sysctl_path[];
+extern struct ctl_path nf_net_ipv4_netfilter_sysctl_path[];
+extern struct list_head nf_hooks[NFPROTO_NUMPROTO][8];
+int nf_hook_slow(u_int8_t pf, unsigned int hook, struct sk_buff *skb,
+   struct net_device *indev, struct net_device *outdev,
+   int (*okfn)(struct sk_buff *), int thresh);
+static inline __attribute__((always_inline)) int nf_hook_thresh(u_int8_t pf, unsigned int hook,
+     struct sk_buff *skb,
+     struct net_device *indev,
+     struct net_device *outdev,
+     int (*okfn)(struct sk_buff *), int thresh,
+     int cond)
+{
+ if (!cond)
+  return 1;
+ if (list_empty(&nf_hooks[pf][hook]))
+  return 1;
+ return nf_hook_slow(pf, hook, skb, indev, outdev, okfn, thresh);
+}
+static inline __attribute__((always_inline)) int nf_hook(u_int8_t pf, unsigned int hook, struct sk_buff *skb,
+     struct net_device *indev, struct net_device *outdev,
+     int (*okfn)(struct sk_buff *))
+{
+ return nf_hook_thresh(pf, hook, skb, indev, outdev, okfn, (-((int)(~0U>>1)) - 1), 1);
+}
+int nf_setsockopt(struct sock *sk, u_int8_t pf, int optval, char *opt,
+    unsigned int len);
+int nf_getsockopt(struct sock *sk, u_int8_t pf, int optval, char *opt,
+    int *len);
+int compat_nf_setsockopt(struct sock *sk, u_int8_t pf, int optval,
+  char *opt, unsigned int len);
+int compat_nf_getsockopt(struct sock *sk, u_int8_t pf, int optval,
+  char *opt, int *len);
+extern int skb_make_writable(struct sk_buff *skb, unsigned int writable_len);
+struct flowi;
+struct nf_queue_entry;
+struct nf_afinfo {
+ unsigned short family;
+ __sum16 (*checksum)(struct sk_buff *skb, unsigned int hook,
+        unsigned int dataoff, u_int8_t protocol);
+ __sum16 (*checksum_partial)(struct sk_buff *skb,
+         unsigned int hook,
+         unsigned int dataoff,
+         unsigned int len,
+         u_int8_t protocol);
+ int (*route)(struct dst_entry **dst, struct flowi *fl);
+ void (*saveroute)(const struct sk_buff *skb,
+         struct nf_queue_entry *entry);
+ int (*reroute)(struct sk_buff *skb,
+       const struct nf_queue_entry *entry);
+ int route_key_size;
+};
+extern const struct nf_afinfo *nf_afinfo[NFPROTO_NUMPROTO];
+static inline __attribute__((always_inline)) const struct nf_afinfo *nf_get_afinfo(unsigned short family)
+{
+ return ({ typeof(nf_afinfo[family]) _________p1 = (*(volatile typeof(nf_afinfo[family]) *)&(nf_afinfo[family])); do { } while(0); (_________p1); });
+}
+static inline __attribute__((always_inline)) __sum16
+nf_checksum(struct sk_buff *skb, unsigned int hook, unsigned int dataoff,
+     u_int8_t protocol, unsigned short family)
+{
+ const struct nf_afinfo *afinfo;
+ __sum16 csum = 0;
+ rcu_read_lock();
+ afinfo = nf_get_afinfo(family);
+ if (afinfo)
+  csum = afinfo->checksum(skb, hook, dataoff, protocol);
+ rcu_read_unlock();
+ return csum;
+}
+static inline __attribute__((always_inline)) __sum16
+nf_checksum_partial(struct sk_buff *skb, unsigned int hook,
+      unsigned int dataoff, unsigned int len,
+      u_int8_t protocol, unsigned short family)
+{
+ const struct nf_afinfo *afinfo;
+ __sum16 csum = 0;
+ rcu_read_lock();
+ afinfo = nf_get_afinfo(family);
+ if (afinfo)
+  csum = afinfo->checksum_partial(skb, hook, dataoff, len,
+      protocol);
+ rcu_read_unlock();
+ return csum;
+}
+extern int nf_register_afinfo(const struct nf_afinfo *afinfo);
+extern void nf_unregister_afinfo(const struct nf_afinfo *afinfo);
+struct flowi {
+ int oif;
+ int iif;
+ __u32 mark;
+ union {
+  struct {
+   __be32 daddr;
+   __be32 saddr;
+   __u8 tos;
+   __u8 scope;
+  } ip4_u;
+  struct {
+   struct in6_addr daddr;
+   struct in6_addr saddr;
+   __be32 flowlabel;
+  } ip6_u;
+  struct {
+   __le16 daddr;
+   __le16 saddr;
+   __u8 scope;
+  } dn_u;
+ } nl_u;
+ __u8 proto;
+ __u8 flags;
+ union {
+  struct {
+   __be16 sport;
+   __be16 dport;
+  } ports;
+  struct {
+   __u8 type;
+   __u8 code;
+  } icmpt;
+  struct {
+   __le16 sport;
+   __le16 dport;
+  } dnports;
+  __be32 spi;
+  struct {
+   __u8 type;
+  } mht;
+ } uli_u;
+ __u32 secid;
+} __attribute__((__aligned__(32/8)));
+struct net;
+struct sock;
+typedef int (*flow_resolve_t)(struct net *net, struct flowi *key, u16 family,
+         u8 dir, void **objp, atomic_t **obj_refp);
+extern void *flow_cache_lookup(struct net *net, struct flowi *key, u16 family,
+          u8 dir, flow_resolve_t resolver);
+extern void flow_cache_flush(void);
+extern atomic_t flow_cache_genid;
+static inline __attribute__((always_inline)) int flow_cache_uli_match(struct flowi *fl1, struct flowi *fl2)
+{
+ return (fl1->proto == fl2->proto &&
+  !memcmp(&fl1->uli_u, &fl2->uli_u, sizeof(fl1->uli_u)));
+}
+extern void (*ip_nat_decode_session)(struct sk_buff *, struct flowi *);
+static inline __attribute__((always_inline)) void
+nf_nat_decode_session(struct sk_buff *skb, struct flowi *fl, u_int8_t family)
+{
+}
+struct net;
+struct completion;
+struct mm_struct;
+enum {
+ PROC_ROOT_INO = 1,
+};
+typedef int (read_proc_t)(char *page, char **start, off_t off,
+     int count, int *eof, void *data);
+typedef int (write_proc_t)(struct file *file, const char *buffer,
+      unsigned long count, void *data);
+struct proc_dir_entry {
+ unsigned int low_ino;
+ unsigned short namelen;
+ const char *name;
+ mode_t mode;
+ nlink_t nlink;
+ uid_t uid;
+ gid_t gid;
+ loff_t size;
+ const struct inode_operations *proc_iops;
+ const struct file_operations *proc_fops;
+ struct proc_dir_entry *next, *parent, *subdir;
+ void *data;
+ read_proc_t *read_proc;
+ write_proc_t *write_proc;
+ atomic_t count;
+ int pde_users;
+ spinlock_t pde_unload_lock;
+ struct completion *pde_unload_completion;
+ struct list_head pde_openers;
+};
+enum kcore_type {
+ KCORE_TEXT,
+ KCORE_VMALLOC,
+ KCORE_RAM,
+ KCORE_VMEMMAP,
+ KCORE_OTHER,
+};
+struct kcore_list {
+ struct list_head list;
+ unsigned long addr;
+ size_t size;
+ int type;
+};
+struct vmcore {
+ struct list_head list;
+ unsigned long long paddr;
+ unsigned long long size;
+ loff_t offset;
+};
+extern void proc_root_init(void);
+void proc_flush_task(struct task_struct *task);
+extern struct proc_dir_entry *create_proc_entry(const char *name, mode_t mode,
+      struct proc_dir_entry *parent);
+struct proc_dir_entry *proc_create_data(const char *name, mode_t mode,
+    struct proc_dir_entry *parent,
+    const struct file_operations *proc_fops,
+    void *data);
+extern void remove_proc_entry(const char *name, struct proc_dir_entry *parent);
+struct pid_namespace;
+extern int pid_ns_prepare_proc(struct pid_namespace *ns);
+extern void pid_ns_release_proc(struct pid_namespace *ns);
+struct tty_driver;
+extern void proc_tty_init(void);
+extern void proc_tty_register_driver(struct tty_driver *driver);
+extern void proc_tty_unregister_driver(struct tty_driver *driver);
+extern struct proc_dir_entry *proc_symlink(const char *,
+  struct proc_dir_entry *, const char *);
+extern struct proc_dir_entry *proc_mkdir(const char *,struct proc_dir_entry *);
+extern struct proc_dir_entry *proc_mkdir_mode(const char *name, mode_t mode,
+   struct proc_dir_entry *parent);
+static inline __attribute__((always_inline)) struct proc_dir_entry *proc_create(const char *name, mode_t mode,
+ struct proc_dir_entry *parent, const struct file_operations *proc_fops)
+{
+ return proc_create_data(name, mode, parent, proc_fops, ((void *)0));
+}
+static inline __attribute__((always_inline)) struct proc_dir_entry *create_proc_read_entry(const char *name,
+ mode_t mode, struct proc_dir_entry *base,
+ read_proc_t *read_proc, void * data)
+{
+ struct proc_dir_entry *res=create_proc_entry(name,mode,base);
+ if (res) {
+  res->read_proc=read_proc;
+  res->data=data;
+ }
+ return res;
+}
+extern struct proc_dir_entry *proc_net_fops_create(struct net *net,
+ const char *name, mode_t mode, const struct file_operations *fops);
+extern void proc_net_remove(struct net *net, const char *name);
+extern struct proc_dir_entry *proc_net_mkdir(struct net *net, const char *name,
+ struct proc_dir_entry *parent);
+extern void set_mm_exe_file(struct mm_struct *mm, struct file *new_exe_file);
+extern struct file *get_mm_exe_file(struct mm_struct *mm);
+extern void dup_mm_exe_file(struct mm_struct *oldmm, struct mm_struct *newmm);
+static inline __attribute__((always_inline)) void
+kclist_add(struct kcore_list *new, void *addr, size_t size, int type)
+{
+}
+union proc_op {
+ int (*proc_get_link)(struct inode *, struct path *);
+ int (*proc_read)(struct task_struct *task, char *page);
+ int (*proc_show)(struct seq_file *m,
+  struct pid_namespace *ns, struct pid *pid,
+  struct task_struct *task);
+};
+struct ctl_table_header;
+struct ctl_table;
+struct proc_inode {
+ struct pid *pid;
+ int fd;
+ union proc_op op;
+ struct proc_dir_entry *pde;
+ struct ctl_table_header *sysctl;
+ struct ctl_table *sysctl_entry;
+ struct inode vfs_inode;
+};
+static inline __attribute__((always_inline)) struct proc_inode *PROC_I(const struct inode *inode)
+{
+ return ({ const typeof( ((struct proc_inode *)0)->vfs_inode ) *__mptr = (inode); (struct proc_inode *)( (char *)__mptr - __builtin_offsetof(struct proc_inode,vfs_inode) );});
+}
+static inline __attribute__((always_inline)) struct proc_dir_entry *PDE(const struct inode *inode)
+{
+ return PROC_I(inode)->pde;
+}
+static inline __attribute__((always_inline)) struct net *PDE_NET(struct proc_dir_entry *pde)
+{
+ return pde->parent->data;
+}
+struct proc_maps_private {
+ struct pid *pid;
+ struct task_struct *task;
+ struct vm_area_struct *tail_vma;
+};
+extern struct proc_dir_entry *proc_net_netfilter;
+static inline __attribute__((always_inline)) void nf_ct_attach(struct sk_buff *new, struct sk_buff *skb) {}
+struct ebt_table;
+struct netns_xt {
+ struct list_head tables[NFPROTO_NUMPROTO];
+};
+typedef union
+{
+ __be32 a4;
+ __be32 a6[4];
+} xfrm_address_t;
+struct xfrm_id
+{
+ xfrm_address_t daddr;
+ __be32 spi;
+ __u8 proto;
+};
+struct xfrm_sec_ctx {
+ __u8 ctx_doi;
+ __u8 ctx_alg;
+ __u16 ctx_len;
+ __u32 ctx_sid;
+ char ctx_str[0];
+};
+struct xfrm_selector
+{
+ xfrm_address_t daddr;
+ xfrm_address_t saddr;
+ __be16 dport;
+ __be16 dport_mask;
+ __be16 sport;
+ __be16 sport_mask;
+ __u16 family;
+ __u8 prefixlen_d;
+ __u8 prefixlen_s;
+ __u8 proto;
+ int ifindex;
+ __kernel_uid32_t user;
+};
+struct xfrm_lifetime_cfg
+{
+ __u64 soft_byte_limit;
+ __u64 hard_byte_limit;
+ __u64 soft_packet_limit;
+ __u64 hard_packet_limit;
+ __u64 soft_add_expires_seconds;
+ __u64 hard_add_expires_seconds;
+ __u64 soft_use_expires_seconds;
+ __u64 hard_use_expires_seconds;
+};
+struct xfrm_lifetime_cur
+{
+ __u64 bytes;
+ __u64 packets;
+ __u64 add_time;
+ __u64 use_time;
+};
+struct xfrm_replay_state
+{
+ __u32 oseq;
+ __u32 seq;
+ __u32 bitmap;
+};
+struct xfrm_algo {
+ char alg_name[64];
+ unsigned int alg_key_len;
+ char alg_key[0];
+};
+struct xfrm_algo_aead {
+ char alg_name[64];
+ unsigned int alg_key_len;
+ unsigned int alg_icv_len;
+ char alg_key[0];
+};
+struct xfrm_stats {
+ __u32 replay_window;
+ __u32 replay;
+ __u32 integrity_failed;
+};
+enum
+{
+ XFRM_POLICY_TYPE_MAIN = 0,
+ XFRM_POLICY_TYPE_SUB = 1,
+ XFRM_POLICY_TYPE_MAX = 2,
+ XFRM_POLICY_TYPE_ANY = 255
+};
+enum
+{
+ XFRM_POLICY_IN = 0,
+ XFRM_POLICY_OUT = 1,
+ XFRM_POLICY_FWD = 2,
+ XFRM_POLICY_MASK = 3,
+ XFRM_POLICY_MAX = 3
+};
+enum
+{
+ XFRM_SHARE_ANY,
+ XFRM_SHARE_SESSION,
+ XFRM_SHARE_USER,
+ XFRM_SHARE_UNIQUE
+};
+enum {
+ XFRM_MSG_BASE = 0x10,
+ XFRM_MSG_NEWSA = 0x10,
+ XFRM_MSG_DELSA,
+ XFRM_MSG_GETSA,
+ XFRM_MSG_NEWPOLICY,
+ XFRM_MSG_DELPOLICY,
+ XFRM_MSG_GETPOLICY,
+ XFRM_MSG_ALLOCSPI,
+ XFRM_MSG_ACQUIRE,
+ XFRM_MSG_EXPIRE,
+ XFRM_MSG_UPDPOLICY,
+ XFRM_MSG_UPDSA,
+ XFRM_MSG_POLEXPIRE,
+ XFRM_MSG_FLUSHSA,
+ XFRM_MSG_FLUSHPOLICY,
+ XFRM_MSG_NEWAE,
+ XFRM_MSG_GETAE,
+ XFRM_MSG_REPORT,
+ XFRM_MSG_MIGRATE,
+ XFRM_MSG_NEWSADINFO,
+ XFRM_MSG_GETSADINFO,
+ XFRM_MSG_NEWSPDINFO,
+ XFRM_MSG_GETSPDINFO,
+ XFRM_MSG_MAPPING,
+ __XFRM_MSG_MAX
+};
+struct xfrm_user_sec_ctx {
+ __u16 len;
+ __u16 exttype;
+ __u8 ctx_alg;
+ __u8 ctx_doi;
+ __u16 ctx_len;
+};
+struct xfrm_user_tmpl {
+ struct xfrm_id id;
+ __u16 family;
+ xfrm_address_t saddr;
+ __u32 reqid;
+ __u8 mode;
+ __u8 share;
+ __u8 optional;
+ __u32 aalgos;
+ __u32 ealgos;
+ __u32 calgos;
+};
+struct xfrm_encap_tmpl {
+ __u16 encap_type;
+ __be16 encap_sport;
+ __be16 encap_dport;
+ xfrm_address_t encap_oa;
+};
+enum xfrm_ae_ftype_t {
+ XFRM_AE_UNSPEC,
+ XFRM_AE_RTHR=1,
+ XFRM_AE_RVAL=2,
+ XFRM_AE_LVAL=4,
+ XFRM_AE_ETHR=8,
+ XFRM_AE_CR=16,
+ XFRM_AE_CE=32,
+ XFRM_AE_CU=64,
+ __XFRM_AE_MAX
+};
+struct xfrm_userpolicy_type {
+ __u8 type;
+ __u16 reserved1;
+ __u8 reserved2;
+};
+enum xfrm_attr_type_t {
+ XFRMA_UNSPEC,
+ XFRMA_ALG_AUTH,
+ XFRMA_ALG_CRYPT,
+ XFRMA_ALG_COMP,
+ XFRMA_ENCAP,
+ XFRMA_TMPL,
+ XFRMA_SA,
+ XFRMA_POLICY,
+ XFRMA_SEC_CTX,
+ XFRMA_LTIME_VAL,
+ XFRMA_REPLAY_VAL,
+ XFRMA_REPLAY_THRESH,
+ XFRMA_ETIMER_THRESH,
+ XFRMA_SRCADDR,
+ XFRMA_COADDR,
+ XFRMA_LASTUSED,
+ XFRMA_POLICY_TYPE,
+ XFRMA_MIGRATE,
+ XFRMA_ALG_AEAD,
+ XFRMA_KMADDRESS,
+ __XFRMA_MAX
+};
+enum xfrm_sadattr_type_t {
+ XFRMA_SAD_UNSPEC,
+ XFRMA_SAD_CNT,
+ XFRMA_SAD_HINFO,
+ __XFRMA_SAD_MAX
+};
+struct xfrmu_sadhinfo {
+ __u32 sadhcnt;
+ __u32 sadhmcnt;
+};
+enum xfrm_spdattr_type_t {
+ XFRMA_SPD_UNSPEC,
+ XFRMA_SPD_INFO,
+ XFRMA_SPD_HINFO,
+ __XFRMA_SPD_MAX
+};
+struct xfrmu_spdinfo {
+ __u32 incnt;
+ __u32 outcnt;
+ __u32 fwdcnt;
+ __u32 inscnt;
+ __u32 outscnt;
+ __u32 fwdscnt;
+};
+struct xfrmu_spdhinfo {
+ __u32 spdhcnt;
+ __u32 spdhmcnt;
+};
+struct xfrm_usersa_info {
+ struct xfrm_selector sel;
+ struct xfrm_id id;
+ xfrm_address_t saddr;
+ struct xfrm_lifetime_cfg lft;
+ struct xfrm_lifetime_cur curlft;
+ struct xfrm_stats stats;
+ __u32 seq;
+ __u32 reqid;
+ __u16 family;
+ __u8 mode;
+ __u8 replay_window;
+ __u8 flags;
+};
+struct xfrm_usersa_id {
+ xfrm_address_t daddr;
+ __be32 spi;
+ __u16 family;
+ __u8 proto;
+};
+struct xfrm_aevent_id {
+ struct xfrm_usersa_id sa_id;
+ xfrm_address_t saddr;
+ __u32 flags;
+ __u32 reqid;
+};
+struct xfrm_userspi_info {
+ struct xfrm_usersa_info info;
+ __u32 min;
+ __u32 max;
+};
+struct xfrm_userpolicy_info {
+ struct xfrm_selector sel;
+ struct xfrm_lifetime_cfg lft;
+ struct xfrm_lifetime_cur curlft;
+ __u32 priority;
+ __u32 index;
+ __u8 dir;
+ __u8 action;
+ __u8 flags;
+ __u8 share;
+};
+struct xfrm_userpolicy_id {
+ struct xfrm_selector sel;
+ __u32 index;
+ __u8 dir;
+};
+struct xfrm_user_acquire {
+ struct xfrm_id id;
+ xfrm_address_t saddr;
+ struct xfrm_selector sel;
+ struct xfrm_userpolicy_info policy;
+ __u32 aalgos;
+ __u32 ealgos;
+ __u32 calgos;
+ __u32 seq;
+};
+struct xfrm_user_expire {
+ struct xfrm_usersa_info state;
+ __u8 hard;
+};
+struct xfrm_user_polexpire {
+ struct xfrm_userpolicy_info pol;
+ __u8 hard;
+};
+struct xfrm_usersa_flush {
+ __u8 proto;
+};
+struct xfrm_user_report {
+ __u8 proto;
+ struct xfrm_selector sel;
+};
+struct xfrm_user_kmaddress {
+ xfrm_address_t local;
+ xfrm_address_t remote;
+ __u32 reserved;
+ __u16 family;
+};
+struct xfrm_user_migrate {
+ xfrm_address_t old_daddr;
+ xfrm_address_t old_saddr;
+ xfrm_address_t new_daddr;
+ xfrm_address_t new_saddr;
+ __u8 proto;
+ __u8 mode;
+ __u16 reserved;
+ __u32 reqid;
+ __u16 old_family;
+ __u16 new_family;
+};
+struct xfrm_user_mapping {
+ struct xfrm_usersa_id id;
+ __u32 reqid;
+ xfrm_address_t old_saddr;
+ xfrm_address_t new_saddr;
+ __be16 old_sport;
+ __be16 new_sport;
+};
+enum xfrm_nlgroups {
+ XFRMNLGRP_NONE,
+ XFRMNLGRP_ACQUIRE,
+ XFRMNLGRP_EXPIRE,
+ XFRMNLGRP_SA,
+ XFRMNLGRP_POLICY,
+ XFRMNLGRP_AEVENTS,
+ XFRMNLGRP_REPORT,
+ XFRMNLGRP_MIGRATE,
+ XFRMNLGRP_MAPPING,
+ __XFRMNLGRP_MAX
+};
+struct ctl_table_header;
+struct xfrm_policy_hash {
+ struct hlist_head *table;
+ unsigned int hmask;
+};
+struct netns_xfrm {
+ struct list_head state_all;
+ struct hlist_head *state_bydst;
+ struct hlist_head *state_bysrc;
+ struct hlist_head *state_byspi;
+ unsigned int state_hmask;
+ unsigned int state_num;
+ struct work_struct state_hash_work;
+ struct hlist_head state_gc_list;
+ struct work_struct state_gc_work;
+ wait_queue_head_t km_waitq;
+ struct list_head policy_all;
+ struct hlist_head *policy_byidx;
+ unsigned int policy_idx_hmask;
+ struct hlist_head policy_inexact[XFRM_POLICY_MAX * 2];
+ struct xfrm_policy_hash policy_bydst[XFRM_POLICY_MAX * 2];
+ unsigned int policy_count[XFRM_POLICY_MAX * 2];
+ struct work_struct policy_hash_work;
+ struct sock *nlsk;
+ u32 sysctl_aevent_etime;
+ u32 sysctl_aevent_rseqth;
+ int sysctl_larval_drop;
+ u32 sysctl_acq_expires;
+ struct ctl_table_header *sysctl_hdr;
+};
+struct proc_dir_entry;
+struct net_device;
+struct sock;
+struct ctl_table_header;
+struct net_generic;
+struct sock;
+struct net {
+ atomic_t count;
+ struct list_head list;
+ struct work_struct work;
+ struct proc_dir_entry *proc_net;
+ struct proc_dir_entry *proc_net_stat;
+ struct ctl_table_set sysctls;
+ struct net_device *loopback_dev;
+ struct list_head dev_base_head;
+ struct hlist_head *dev_name_head;
+ struct hlist_head *dev_index_head;
+ struct list_head rules_ops;
+ spinlock_t rules_mod_lock;
+ struct sock *rtnl;
+ struct sock *genl_sock;
+ struct netns_core core;
+ struct netns_mib mib;
+ struct netns_packet packet;
+ struct netns_unix unx;
+ struct netns_ipv4 ipv4;
+ struct netns_xt xt;
+ struct netns_xfrm xfrm;
+ struct sk_buff_head wext_nlevents;
+ struct net_generic *gen;
+};
+struct seq_operations;
+struct file;
+struct path;
+struct inode;
+struct dentry;
+struct seq_file {
+ char *buf;
+ size_t size;
+ size_t from;
+ size_t count;
+ loff_t index;
+ loff_t read_pos;
+ u64 version;
+ struct mutex lock;
+ const struct seq_operations *op;
+ void *private;
+};
+struct seq_operations {
+ void * (*start) (struct seq_file *m, loff_t *pos);
+ void (*stop) (struct seq_file *m, void *v);
+ void * (*next) (struct seq_file *m, void *v, loff_t *pos);
+ int (*show) (struct seq_file *m, void *v);
+};
+static inline __attribute__((always_inline)) size_t seq_get_buf(struct seq_file *m, char **bufp)
+{
+ do { if (__builtin_expect(!!(m->count > m->size), 0)) do { __asm__ __volatile__ ( "1:\t.short %O0\n" "\t.pushsection __bug_table,\"a\"\n" "2:\t.long 1b\n" "\t.short %O3\n" "\t.org 2b+%O4\n" "\t.popsection\n" : : "n" (0xc33e), "i" ("include/linux/seq_file.h"), "i" (48), "i" (0), "i" (sizeof(struct bug_entry))); } while (0); } while(0);
+ if (m->count < m->size)
+  *bufp = m->buf + m->count;
+ else
+  *bufp = ((void *)0);
+ return m->size - m->count;
+}
+static inline __attribute__((always_inline)) void seq_commit(struct seq_file *m, int num)
+{
+ if (num < 0) {
+  m->count = m->size;
+ } else {
+  do { if (__builtin_expect(!!(m->count + num > m->size), 0)) do { __asm__ __volatile__ ( "1:\t.short %O0\n" "\t.pushsection __bug_table,\"a\"\n" "2:\t.long 1b\n" "\t.short %O3\n" "\t.org 2b+%O4\n" "\t.popsection\n" : : "n" (0xc33e), "i" ("include/linux/seq_file.h"), "i" (71), "i" (0), "i" (sizeof(struct bug_entry))); } while (0); } while(0);
+  m->count += num;
+ }
+}
+char *mangle_path(char *s, char *p, char *esc);
+int seq_open(struct file *, const struct seq_operations *);
+ssize_t seq_read(struct file *, char *, size_t, loff_t *);
+loff_t seq_lseek(struct file *, loff_t, int);
+int seq_release(struct inode *, struct file *);
+int seq_escape(struct seq_file *, const char *, const char *);
+int seq_putc(struct seq_file *m, char c);
+int seq_puts(struct seq_file *m, const char *s);
+int seq_write(struct seq_file *seq, const void *data, size_t len);
+int seq_printf(struct seq_file *, const char *, ...)
+ __attribute__ ((format (printf,2,3)));
+int seq_path(struct seq_file *, struct path *, char *);
+int seq_dentry(struct seq_file *, struct dentry *, char *);
+int seq_path_root(struct seq_file *m, struct path *path, struct path *root,
+    char *esc);
+int seq_bitmap(struct seq_file *m, const unsigned long *bits,
+       unsigned int nr_bits);
+static inline __attribute__((always_inline)) int seq_cpumask(struct seq_file *m, const struct cpumask *mask)
+{
+ return seq_bitmap(m, ((mask)->bits), 1);
+}
+static inline __attribute__((always_inline)) int seq_nodemask(struct seq_file *m, nodemask_t *mask)
+{
+ return seq_bitmap(m, mask->bits, (1 << 0));
+}
+int seq_bitmap_list(struct seq_file *m, const unsigned long *bits,
+  unsigned int nr_bits);
+static inline __attribute__((always_inline)) int seq_cpumask_list(struct seq_file *m,
+       const struct cpumask *mask)
+{
+ return seq_bitmap_list(m, ((mask)->bits), 1);
+}
+static inline __attribute__((always_inline)) int seq_nodemask_list(struct seq_file *m, nodemask_t *mask)
+{
+ return seq_bitmap_list(m, mask->bits, (1 << 0));
+}
+int single_open(struct file *, int (*)(struct seq_file *, void *), void *);
+int single_release(struct inode *, struct file *);
+void *__seq_open_private(struct file *, const struct seq_operations *, int);
+int seq_open_private(struct file *, const struct seq_operations *, int);
+int seq_release_private(struct inode *, struct file *);
+extern struct list_head *seq_list_start(struct list_head *head,
+  loff_t pos);
+extern struct list_head *seq_list_start_head(struct list_head *head,
+  loff_t pos);
+extern struct list_head *seq_list_next(void *v, struct list_head *head,
+  loff_t *ppos);
+struct net;
+extern struct net init_net;
+struct seq_net_private {
+};
+int seq_open_net(struct inode *, struct file *,
+   const struct seq_operations *, int);
+int single_open_net(struct inode *, struct file *file,
+  int (*show)(struct seq_file *, void *));
+int seq_release_net(struct inode *, struct file *);
+int single_release_net(struct inode *, struct file *);
+static inline __attribute__((always_inline)) struct net *seq_file_net(struct seq_file *seq)
+{
+ return &init_net;
+}
+extern struct net init_net;
+extern struct net *copy_net_ns(unsigned long flags, struct net *net_ns);
+extern struct list_head net_namespace_list;
+extern struct net *get_net_ns_by_pid(pid_t pid);
+static inline __attribute__((always_inline)) struct net *get_net(struct net *net)
+{
+ return net;
+}
+static inline __attribute__((always_inline)) void put_net(struct net *net)
+{
+}
+static inline __attribute__((always_inline)) struct net *maybe_get_net(struct net *net)
+{
+ return net;
+}
+static inline __attribute__((always_inline))
+int net_eq(const struct net *net1, const struct net *net2)
+{
+ return 1;
+}
+static inline __attribute__((always_inline)) struct net *hold_net(struct net *net)
+{
+ return net;
+}
+static inline __attribute__((always_inline)) void release_net(struct net *net)
+{
+}
+struct pernet_operations {
+ struct list_head list;
+ int (*init)(struct net *net);
+ void (*exit)(struct net *net);
+};
+extern int register_pernet_subsys(struct pernet_operations *);
+extern void unregister_pernet_subsys(struct pernet_operations *);
+extern int register_pernet_gen_subsys(int *id, struct pernet_operations *);
+extern void unregister_pernet_gen_subsys(int id, struct pernet_operations *);
+extern int register_pernet_device(struct pernet_operations *);
+extern void unregister_pernet_device(struct pernet_operations *);
+extern int register_pernet_gen_device(int *id, struct pernet_operations *);
+extern void unregister_pernet_gen_device(int id, struct pernet_operations *);
+struct ctl_path;
+struct ctl_table;
+struct ctl_table_header;
+extern struct ctl_table_header *register_net_sysctl_table(struct net *net,
+ const struct ctl_path *path, struct ctl_table *table);
+extern struct ctl_table_header *register_net_sysctl_rotable(
+ const struct ctl_path *path, struct ctl_table *table);
+extern void unregister_net_sysctl_table(struct ctl_table_header *header);
+struct dsa_chip_data {
+ struct device *mii_bus;
+ int sw_addr;
+ char *port_names[12];
+ s8 *rtable;
+};
+struct dsa_platform_data {
+ struct device *netdev;
+ int nr_chips;
+ struct dsa_chip_data *chip;
+};
+extern bool dsa_uses_dsa_tags(void *dsa_ptr);
+extern bool dsa_uses_trailer_tags(void *dsa_ptr);
+struct vlan_group;
+struct netpoll_info;
+struct wireless_dev;
+enum netdev_tx {
+ NETDEV_TX_OK = 0,
+ NETDEV_TX_BUSY,
+ NETDEV_TX_LOCKED = -1,
+};
+typedef enum netdev_tx netdev_tx_t;
+struct net_device_stats
+{
+ unsigned long rx_packets;
+ unsigned long tx_packets;
+ unsigned long rx_bytes;
+ unsigned long tx_bytes;
+ unsigned long rx_errors;
+ unsigned long tx_errors;
+ unsigned long rx_dropped;
+ unsigned long tx_dropped;
+ unsigned long multicast;
+ unsigned long collisions;
+ unsigned long rx_length_errors;
+ unsigned long rx_over_errors;
+ unsigned long rx_crc_errors;
+ unsigned long rx_frame_errors;
+ unsigned long rx_fifo_errors;
+ unsigned long rx_missed_errors;
+ unsigned long tx_aborted_errors;
+ unsigned long tx_carrier_errors;
+ unsigned long tx_fifo_errors;
+ unsigned long tx_heartbeat_errors;
+ unsigned long tx_window_errors;
+ unsigned long rx_compressed;
+ unsigned long tx_compressed;
+};
+enum {
+        IF_PORT_UNKNOWN = 0,
+        IF_PORT_10BASE2,
+        IF_PORT_10BASET,
+        IF_PORT_AUI,
+        IF_PORT_100BASET,
+        IF_PORT_100BASETX,
+        IF_PORT_100BASEFX
+};
+struct neighbour;
+struct neigh_parms;
+struct sk_buff;
+struct netif_rx_stats
+{
+ unsigned total;
+ unsigned dropped;
+ unsigned time_squeeze;
+ unsigned cpu_collision;
+};
+extern __attribute__((section(".data" ""))) __typeof__(struct netif_rx_stats) per_cpu__netdev_rx_stat;
+struct dev_addr_list
+{
+ struct dev_addr_list *next;
+ u8 da_addr[32];
+ u8 da_addrlen;
+ u8 da_synced;
+ int da_users;
+ int da_gusers;
+};
+struct netdev_hw_addr {
+ struct list_head list;
+ unsigned char addr[32];
+ unsigned char type;
+ int refcount;
+ bool synced;
+ struct rcu_head rcu_head;
+};
+struct netdev_hw_addr_list {
+ struct list_head list;
+ int count;
+};
+struct hh_cache
+{
+ struct hh_cache *hh_next;
+ atomic_t hh_refcnt;
+ __be16 hh_type ;
+ u16 hh_len;
+ int (*hh_output)(struct sk_buff *skb);
+ seqlock_t hh_lock;
+ unsigned long hh_data[(((96)+(16 -1))&~(16 - 1)) / sizeof(long)];
+};
+struct header_ops {
+ int (*create) (struct sk_buff *skb, struct net_device *dev,
+      unsigned short type, const void *daddr,
+      const void *saddr, unsigned len);
+ int (*parse)(const struct sk_buff *skb, unsigned char *haddr);
+ int (*rebuild)(struct sk_buff *skb);
+ int (*cache)(const struct neighbour *neigh, struct hh_cache *hh);
+ void (*cache_update)(struct hh_cache *hh,
+    const struct net_device *dev,
+    const unsigned char *haddr);
+};
+enum netdev_state_t
+{
+ __LINK_STATE_START,
+ __LINK_STATE_PRESENT,
+ __LINK_STATE_NOCARRIER,
+ __LINK_STATE_LINKWATCH_PENDING,
+ __LINK_STATE_DORMANT,
+};
+struct netdev_boot_setup {
+ char name[16];
+ struct ifmap map;
+};
+extern int __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) __attribute__((no_instrument_function)) netdev_boot_setup(char *str);
+struct napi_struct {
+ struct list_head poll_list;
+ unsigned long state;
+ int weight;
+ int (*poll)(struct napi_struct *, int);
+ unsigned int gro_count;
+ struct net_device *dev;
+ struct list_head dev_list;
+ struct sk_buff *gro_list;
+ struct sk_buff *skb;
+};
+enum
+{
+ NAPI_STATE_SCHED,
+ NAPI_STATE_DISABLE,
+ NAPI_STATE_NPSVC,
+};
+enum {
+ GRO_MERGED,
+ GRO_MERGED_FREE,
+ GRO_HELD,
+ GRO_NORMAL,
+ GRO_DROP,
+};
+extern void __napi_schedule(struct napi_struct *n);
+static inline __attribute__((always_inline)) int napi_disable_pending(struct napi_struct *n)
+{
+ return test_bit(NAPI_STATE_DISABLE, &n->state);
+}
+static inline __attribute__((always_inline)) int napi_schedule_prep(struct napi_struct *n)
+{
+ return !napi_disable_pending(n) &&
+  !test_and_set_bit(NAPI_STATE_SCHED, &n->state);
+}
+static inline __attribute__((always_inline)) void napi_schedule(struct napi_struct *n)
+{
+ if (napi_schedule_prep(n))
+  __napi_schedule(n);
+}
+static inline __attribute__((always_inline)) int napi_reschedule(struct napi_struct *napi)
+{
+ if (napi_schedule_prep(napi)) {
+  __napi_schedule(napi);
+  return 1;
+ }
+ return 0;
+}
+extern void __napi_complete(struct napi_struct *n);
+extern void napi_complete(struct napi_struct *n);
+static inline __attribute__((always_inline)) void napi_disable(struct napi_struct *n)
+{
+ set_bit(NAPI_STATE_DISABLE, &n->state);
+ while (test_and_set_bit(NAPI_STATE_SCHED, &n->state))
+  msleep(1);
+ clear_bit(NAPI_STATE_DISABLE, &n->state);
+}
+static inline __attribute__((always_inline)) void napi_enable(struct napi_struct *n)
+{
+ do { if (__builtin_expect(!!(!test_bit(NAPI_STATE_SCHED, &n->state)), 0)) do { __asm__ __volatile__ ( "1:\t.short %O0\n" "\t.pushsection __bug_table,\"a\"\n" "2:\t.long 1b\n" "\t.short %O3\n" "\t.org 2b+%O4\n" "\t.popsection\n" : : "n" (0xc33e), "i" ("include/linux/netdevice.h"), "i" (437), "i" (0), "i" (sizeof(struct bug_entry))); } while (0); } while(0);
+ __asm__ __volatile__("": : :"memory");
+ clear_bit(NAPI_STATE_SCHED, &n->state);
+}
+enum netdev_queue_state_t
+{
+ __QUEUE_STATE_XOFF,
+ __QUEUE_STATE_FROZEN,
+};
+struct netdev_queue {
+ struct net_device *dev;
+ struct Qdisc *qdisc;
+ unsigned long state;
+ struct Qdisc *qdisc_sleeping;
+ spinlock_t _xmit_lock ;
+ int xmit_lock_owner;
+ unsigned long trans_start;
+ unsigned long tx_bytes;
+ unsigned long tx_packets;
+ unsigned long tx_dropped;
+} ;
+struct net_device_ops {
+ int (*ndo_init)(struct net_device *dev);
+ void (*ndo_uninit)(struct net_device *dev);
+ int (*ndo_open)(struct net_device *dev);
+ int (*ndo_stop)(struct net_device *dev);
+ netdev_tx_t (*ndo_start_xmit) (struct sk_buff *skb,
+         struct net_device *dev);
+ u16 (*ndo_select_queue)(struct net_device *dev,
+          struct sk_buff *skb);
+ void (*ndo_change_rx_flags)(struct net_device *dev,
+             int flags);
+ void (*ndo_set_rx_mode)(struct net_device *dev);
+ void (*ndo_set_multicast_list)(struct net_device *dev);
+ int (*ndo_set_mac_address)(struct net_device *dev,
+             void *addr);
+ int (*ndo_validate_addr)(struct net_device *dev);
+ int (*ndo_do_ioctl)(struct net_device *dev,
+             struct ifreq *ifr, int cmd);
+ int (*ndo_set_config)(struct net_device *dev,
+               struct ifmap *map);
+ int (*ndo_change_mtu)(struct net_device *dev,
+        int new_mtu);
+ int (*ndo_neigh_setup)(struct net_device *dev,
+         struct neigh_parms *);
+ void (*ndo_tx_timeout) (struct net_device *dev);
+ struct net_device_stats* (*ndo_get_stats)(struct net_device *dev);
+ void (*ndo_vlan_rx_register)(struct net_device *dev,
+              struct vlan_group *grp);
+ void (*ndo_vlan_rx_add_vid)(struct net_device *dev,
+             unsigned short vid);
+ void (*ndo_vlan_rx_kill_vid)(struct net_device *dev,
+              unsigned short vid);
+};
+struct net_device
+{
+ char name[16];
+ struct hlist_node name_hlist;
+ char *ifalias;
+ unsigned long mem_end;
+ unsigned long mem_start;
+ unsigned long base_addr;
+ unsigned int irq;
+ unsigned char if_port;
+ unsigned char dma;
+ unsigned long state;
+ struct list_head dev_list;
+ struct list_head napi_list;
+ unsigned long features;
+ int ifindex;
+ int iflink;
+ struct net_device_stats stats;
+ const struct iw_handler_def * wireless_handlers;
+ struct iw_public_data * wireless_data;
+ const struct net_device_ops *netdev_ops;
+ const struct ethtool_ops *ethtool_ops;
+ const struct header_ops *header_ops;
+ unsigned int flags;
+ unsigned short gflags;
+        unsigned short priv_flags;
+ unsigned short padded;
+ unsigned char operstate;
+ unsigned char link_mode;
+ unsigned mtu;
+ unsigned short type;
+ unsigned short hard_header_len;
+ unsigned short needed_headroom;
+ unsigned short needed_tailroom;
+ struct net_device *master;
+ unsigned char perm_addr[32];
+ unsigned char addr_len;
+ unsigned short dev_id;
+ struct netdev_hw_addr_list uc;
+ int uc_promisc;
+ spinlock_t addr_list_lock;
+ struct dev_addr_list *mc_list;
+ int mc_count;
+ unsigned int promiscuity;
+ unsigned int allmulti;
+ void *atalk_ptr;
+ void *ip_ptr;
+ void *dn_ptr;
+ void *ip6_ptr;
+ void *ec_ptr;
+ void *ax25_ptr;
+ struct wireless_dev *ieee80211_ptr;
+ unsigned long last_rx;
+ unsigned char *dev_addr;
+ struct netdev_hw_addr_list dev_addrs;
+ unsigned char broadcast[32];
+ struct netdev_queue rx_queue;
+ struct netdev_queue *_tx ;
+ unsigned int num_tx_queues;
+ unsigned int real_num_tx_queues;
+ struct Qdisc *qdisc;
+ unsigned long tx_queue_len;
+ spinlock_t tx_global_lock;
+ unsigned long trans_start;
+ int watchdog_timeo;
+ struct timer_list watchdog_timer;
+ atomic_t refcnt ;
+ struct list_head todo_list;
+ struct hlist_node index_hlist;
+ struct net_device *link_watch_next;
+ enum { NETREG_UNINITIALIZED=0,
+        NETREG_REGISTERED,
+        NETREG_UNREGISTERING,
+        NETREG_UNREGISTERED,
+        NETREG_RELEASED,
+        NETREG_DUMMY,
+ } reg_state;
+ void (*destructor)(struct net_device *dev);
+ void *ml_priv;
+ struct net_bridge_port *br_port;
+ struct macvlan_port *macvlan_port;
+ struct garp_port *garp_port;
+ struct device dev;
+ const struct attribute_group *sysfs_groups[3];
+ const struct rtnl_link_ops *rtnl_link_ops;
+ unsigned long vlan_features;
+ unsigned int gso_max_size;
+};
+static inline __attribute__((always_inline))
+struct netdev_queue *netdev_get_tx_queue(const struct net_device *dev,
+      unsigned int index)
+{
+ return &dev->_tx[index];
+}
+static inline __attribute__((always_inline)) void netdev_for_each_tx_queue(struct net_device *dev,
+         void (*f)(struct net_device *,
+            struct netdev_queue *,
+            void *),
+         void *arg)
+{
+ unsigned int i;
+ for (i = 0; i < dev->num_tx_queues; i++)
+  f(dev, &dev->_tx[i], arg);
+}
+static inline __attribute__((always_inline))
+struct net *dev_net(const struct net_device *dev)
+{
+ return &init_net;
+}
+static inline __attribute__((always_inline))
+void dev_net_set(struct net_device *dev, struct net *net)
+{
+}
+static inline __attribute__((always_inline)) bool netdev_uses_dsa_tags(struct net_device *dev)
+{
+ return 0;
+}
+static inline __attribute__((always_inline)) bool netdev_uses_trailer_tags(struct net_device *dev)
+{
+ return 0;
+}
+static inline __attribute__((always_inline)) void *netdev_priv(const struct net_device *dev)
+{
+ return (char *)dev + (((sizeof(struct net_device))+((typeof(sizeof(struct net_device)))(32)-1))&~((typeof(sizeof(struct net_device)))(32)-1));
+}
+void netif_napi_add(struct net_device *dev, struct napi_struct *napi,
+      int (*poll)(struct napi_struct *, int), int weight);
+void netif_napi_del(struct napi_struct *napi);
+struct napi_gro_cb {
+ void *frag0;
+ unsigned int frag0_len;
+ int data_offset;
+ int same_flow;
+ int flush;
+ int count;
+ int free;
+};
+struct packet_type {
+ __be16 type;
+ struct net_device *dev;
+ int (*func) (struct sk_buff *,
+      struct net_device *,
+      struct packet_type *,
+      struct net_device *);
+ struct sk_buff *(*gso_segment)(struct sk_buff *skb,
+      int features);
+ int (*gso_send_check)(struct sk_buff *skb);
+ struct sk_buff **(*gro_receive)(struct sk_buff **head,
+            struct sk_buff *skb);
+ int (*gro_complete)(struct sk_buff *skb);
+ void *af_packet_priv;
+ struct list_head list;
+};
+extern rwlock_t dev_base_lock;
+static inline __attribute__((always_inline)) struct net_device *next_net_device(struct net_device *dev)
+{
+ struct list_head *lh;
+ struct net *net;
+ net = dev_net(dev);
+ lh = dev->dev_list.next;
+ return lh == &net->dev_base_head ? ((void *)0) : ({ const typeof( ((struct net_device *)0)->dev_list ) *__mptr = (lh); (struct net_device *)( (char *)__mptr - __builtin_offsetof(struct net_device,dev_list) );});
+}
+static inline __attribute__((always_inline)) struct net_device *first_net_device(struct net *net)
+{
+ return list_empty(&net->dev_base_head) ? ((void *)0) :
+  ({ const typeof( ((struct net_device *)0)->dev_list ) *__mptr = (net->dev_base_head.next); (struct net_device *)( (char *)__mptr - __builtin_offsetof(struct net_device,dev_list) );});
+}
+extern int netdev_boot_setup_check(struct net_device *dev);
+extern unsigned long netdev_boot_base(const char *prefix, int unit);
+extern struct net_device *dev_getbyhwaddr(struct net *net, unsigned short type, char *hwaddr);
+extern struct net_device *dev_getfirstbyhwtype(struct net *net, unsigned short type);
+extern struct net_device *__dev_getfirstbyhwtype(struct net *net, unsigned short type);
+extern void dev_add_pack(struct packet_type *pt);
+extern void dev_remove_pack(struct packet_type *pt);
+extern void __dev_remove_pack(struct packet_type *pt);
+extern struct net_device *dev_get_by_flags(struct net *net, unsigned short flags,
+        unsigned short mask);
+extern struct net_device *dev_get_by_name(struct net *net, const char *name);
+extern struct net_device *__dev_get_by_name(struct net *net, const char *name);
+extern int dev_alloc_name(struct net_device *dev, const char *name);
+extern int dev_open(struct net_device *dev);
+extern int dev_close(struct net_device *dev);
+extern void dev_disable_lro(struct net_device *dev);
+extern int dev_queue_xmit(struct sk_buff *skb);
+extern int register_netdevice(struct net_device *dev);
+extern void unregister_netdevice(struct net_device *dev);
+extern void free_netdev(struct net_device *dev);
+extern void synchronize_net(void);
+extern int register_netdevice_notifier(struct notifier_block *nb);
+extern int unregister_netdevice_notifier(struct notifier_block *nb);
+extern int init_dummy_netdev(struct net_device *dev);
+extern void netdev_resync_ops(struct net_device *dev);
+extern int call_netdevice_notifiers(unsigned long val, struct net_device *dev);
+extern struct net_device *dev_get_by_index(struct net *net, int ifindex);
+extern struct net_device *__dev_get_by_index(struct net *net, int ifindex);
+extern int dev_restart(struct net_device *dev);
+extern int skb_gro_receive(struct sk_buff **head,
+           struct sk_buff *skb);
+extern void skb_gro_reset_offset(struct sk_buff *skb);
+static inline __attribute__((always_inline)) unsigned int skb_gro_offset(const struct sk_buff *skb)
+{
+ return ((struct napi_gro_cb *)(skb)->cb)->data_offset;
+}
+static inline __attribute__((always_inline)) unsigned int skb_gro_len(const struct sk_buff *skb)
+{
+ return skb->len - ((struct napi_gro_cb *)(skb)->cb)->data_offset;
+}
+static inline __attribute__((always_inline)) void skb_gro_pull(struct sk_buff *skb, unsigned int len)
+{
+ ((struct napi_gro_cb *)(skb)->cb)->data_offset += len;
+}
+static inline __attribute__((always_inline)) void *skb_gro_header_fast(struct sk_buff *skb,
+     unsigned int offset)
+{
+ return ((struct napi_gro_cb *)(skb)->cb)->frag0 + offset;
+}
+static inline __attribute__((always_inline)) int skb_gro_header_hard(struct sk_buff *skb, unsigned int hlen)
+{
+ return ((struct napi_gro_cb *)(skb)->cb)->frag0_len < hlen;
+}
+static inline __attribute__((always_inline)) void *skb_gro_header_slow(struct sk_buff *skb, unsigned int hlen,
+     unsigned int offset)
+{
+ ((struct napi_gro_cb *)(skb)->cb)->frag0 = ((void *)0);
+ ((struct napi_gro_cb *)(skb)->cb)->frag0_len = 0;
+ return pskb_may_pull(skb, hlen) ? skb->data + offset : ((void *)0);
+}
+static inline __attribute__((always_inline)) void *skb_gro_mac_header(struct sk_buff *skb)
+{
+ return ((struct napi_gro_cb *)(skb)->cb)->frag0 ?: skb_mac_header(skb);
+}
+static inline __attribute__((always_inline)) void *skb_gro_network_header(struct sk_buff *skb)
+{
+ return (((struct napi_gro_cb *)(skb)->cb)->frag0 ?: skb->data) +
+        skb_network_offset(skb);
+}
+static inline __attribute__((always_inline)) int dev_hard_header(struct sk_buff *skb, struct net_device *dev,
+      unsigned short type,
+      const void *daddr, const void *saddr,
+      unsigned len)
+{
+ if (!dev->header_ops || !dev->header_ops->create)
+  return 0;
+ return dev->header_ops->create(skb, dev, type, daddr, saddr, len);
+}
+static inline __attribute__((always_inline)) int dev_parse_header(const struct sk_buff *skb,
+       unsigned char *haddr)
+{
+ const struct net_device *dev = skb->dev;
+ if (!dev->header_ops || !dev->header_ops->parse)
+  return 0;
+ return dev->header_ops->parse(skb, haddr);
+}
+typedef int gifconf_func_t(struct net_device * dev, char * bufptr, int len);
+extern int register_gifconf(unsigned int family, gifconf_func_t * gifconf);
+static inline __attribute__((always_inline)) int unregister_gifconf(unsigned int family)
+{
+ return register_gifconf(family, ((void *)0));
+}
+struct softnet_data
+{
+ struct Qdisc *output_queue;
+ struct sk_buff_head input_pkt_queue;
+ struct list_head poll_list;
+ struct sk_buff *completion_queue;
+ struct napi_struct backlog;
+};
+extern __attribute__((section(".data" ""))) __typeof__(struct softnet_data) per_cpu__softnet_data;
+extern void __netif_schedule(struct Qdisc *q);
+static inline __attribute__((always_inline)) void netif_schedule_queue(struct netdev_queue *txq)
+{
+ if (!test_bit(__QUEUE_STATE_XOFF, &txq->state))
+  __netif_schedule(txq->qdisc);
+}
+static inline __attribute__((always_inline)) void netif_tx_schedule_all(struct net_device *dev)
+{
+ unsigned int i;
+ for (i = 0; i < dev->num_tx_queues; i++)
+  netif_schedule_queue(netdev_get_tx_queue(dev, i));
+}
+static inline __attribute__((always_inline)) void netif_tx_start_queue(struct netdev_queue *dev_queue)
+{
+ clear_bit(__QUEUE_STATE_XOFF, &dev_queue->state);
+}
+static inline __attribute__((always_inline)) void netif_start_queue(struct net_device *dev)
+{
+ netif_tx_start_queue(netdev_get_tx_queue(dev, 0));
+}
+static inline __attribute__((always_inline)) void netif_tx_start_all_queues(struct net_device *dev)
+{
+ unsigned int i;
+ for (i = 0; i < dev->num_tx_queues; i++) {
+  struct netdev_queue *txq = netdev_get_tx_queue(dev, i);
+  netif_tx_start_queue(txq);
+ }
+}
+static inline __attribute__((always_inline)) void netif_tx_wake_queue(struct netdev_queue *dev_queue)
+{
+ if (test_and_clear_bit(__QUEUE_STATE_XOFF, &dev_queue->state))
+  __netif_schedule(dev_queue->qdisc);
+}
+static inline __attribute__((always_inline)) void netif_wake_queue(struct net_device *dev)
+{
+ netif_tx_wake_queue(netdev_get_tx_queue(dev, 0));
+}
+static inline __attribute__((always_inline)) void netif_tx_wake_all_queues(struct net_device *dev)
+{
+ unsigned int i;
+ for (i = 0; i < dev->num_tx_queues; i++) {
+  struct netdev_queue *txq = netdev_get_tx_queue(dev, i);
+  netif_tx_wake_queue(txq);
+ }
+}
+static inline __attribute__((always_inline)) void netif_tx_stop_queue(struct netdev_queue *dev_queue)
+{
+ set_bit(__QUEUE_STATE_XOFF, &dev_queue->state);
+}
+static inline __attribute__((always_inline)) void netif_stop_queue(struct net_device *dev)
+{
+ netif_tx_stop_queue(netdev_get_tx_queue(dev, 0));
+}
+static inline __attribute__((always_inline)) void netif_tx_stop_all_queues(struct net_device *dev)
+{
+ unsigned int i;
+ for (i = 0; i < dev->num_tx_queues; i++) {
+  struct netdev_queue *txq = netdev_get_tx_queue(dev, i);
+  netif_tx_stop_queue(txq);
+ }
+}
+static inline __attribute__((always_inline)) int netif_tx_queue_stopped(const struct netdev_queue *dev_queue)
+{
+ return test_bit(__QUEUE_STATE_XOFF, &dev_queue->state);
+}
+static inline __attribute__((always_inline)) int netif_queue_stopped(const struct net_device *dev)
+{
+ return netif_tx_queue_stopped(netdev_get_tx_queue(dev, 0));
+}
+static inline __attribute__((always_inline)) int netif_tx_queue_frozen(const struct netdev_queue *dev_queue)
+{
+ return test_bit(__QUEUE_STATE_FROZEN, &dev_queue->state);
+}
+static inline __attribute__((always_inline)) int netif_running(const struct net_device *dev)
+{
+ return test_bit(__LINK_STATE_START, &dev->state);
+}
+static inline __attribute__((always_inline)) void netif_start_subqueue(struct net_device *dev, u16 queue_index)
+{
+ struct netdev_queue *txq = netdev_get_tx_queue(dev, queue_index);
+ netif_tx_start_queue(txq);
+}
+static inline __attribute__((always_inline)) void netif_stop_subqueue(struct net_device *dev, u16 queue_index)
+{
+ struct netdev_queue *txq = netdev_get_tx_queue(dev, queue_index);
+ netif_tx_stop_queue(txq);
+}
+static inline __attribute__((always_inline)) int __netif_subqueue_stopped(const struct net_device *dev,
+      u16 queue_index)
+{
+ struct netdev_queue *txq = netdev_get_tx_queue(dev, queue_index);
+ return netif_tx_queue_stopped(txq);
+}
+static inline __attribute__((always_inline)) int netif_subqueue_stopped(const struct net_device *dev,
+      struct sk_buff *skb)
+{
+ return __netif_subqueue_stopped(dev, skb_get_queue_mapping(skb));
+}
+static inline __attribute__((always_inline)) void netif_wake_subqueue(struct net_device *dev, u16 queue_index)
+{
+ struct netdev_queue *txq = netdev_get_tx_queue(dev, queue_index);
+ if (test_and_clear_bit(__QUEUE_STATE_XOFF, &txq->state))
+  __netif_schedule(txq->qdisc);
+}
+static inline __attribute__((always_inline)) int netif_is_multiqueue(const struct net_device *dev)
+{
+ return (dev->num_tx_queues > 1);
+}
+extern void dev_kfree_skb_irq(struct sk_buff *skb);
+extern void dev_kfree_skb_any(struct sk_buff *skb);
+extern int netif_rx(struct sk_buff *skb);
+extern int netif_rx_ni(struct sk_buff *skb);
+extern int netif_receive_skb(struct sk_buff *skb);
+extern void napi_gro_flush(struct napi_struct *napi);
+extern int dev_gro_receive(struct napi_struct *napi,
+     struct sk_buff *skb);
+extern int napi_skb_finish(int ret, struct sk_buff *skb);
+extern int napi_gro_receive(struct napi_struct *napi,
+      struct sk_buff *skb);
+extern void napi_reuse_skb(struct napi_struct *napi,
+           struct sk_buff *skb);
+extern struct sk_buff * napi_get_frags(struct napi_struct *napi);
+extern int napi_frags_finish(struct napi_struct *napi,
+       struct sk_buff *skb, int ret);
+extern struct sk_buff * napi_frags_skb(struct napi_struct *napi);
+extern int napi_gro_frags(struct napi_struct *napi);
+static inline __attribute__((always_inline)) void napi_free_frags(struct napi_struct *napi)
+{
+ kfree_skb(napi->skb);
+ napi->skb = ((void *)0);
+}
+extern void netif_nit_deliver(struct sk_buff *skb);
+extern int dev_valid_name(const char *name);
+extern int dev_ioctl(struct net *net, unsigned int cmd, void *);
+extern int dev_ethtool(struct net *net, struct ifreq *);
+extern unsigned dev_get_flags(const struct net_device *);
+extern int dev_change_flags(struct net_device *, unsigned);
+extern int dev_change_name(struct net_device *, const char *);
+extern int dev_set_alias(struct net_device *, const char *, size_t);
+extern int dev_change_net_namespace(struct net_device *,
+       struct net *, const char *);
+extern int dev_set_mtu(struct net_device *, int);
+extern int dev_set_mac_address(struct net_device *,
+         struct sockaddr *);
+extern int dev_hard_start_xmit(struct sk_buff *skb,
+         struct net_device *dev,
+         struct netdev_queue *txq);
+extern int netdev_budget;
+extern void netdev_run_todo(void);
+static inline __attribute__((always_inline)) void dev_put(struct net_device *dev)
+{
+ atomic_sub(1,(&dev->refcnt));
+}
+static inline __attribute__((always_inline)) void dev_hold(struct net_device *dev)
+{
+ atomic_add(1,(&dev->refcnt));
+}
+extern void linkwatch_fire_event(struct net_device *dev);
+static inline __attribute__((always_inline)) int netif_carrier_ok(const struct net_device *dev)
+{
+ return !test_bit(__LINK_STATE_NOCARRIER, &dev->state);
+}
+extern unsigned long dev_trans_start(struct net_device *dev);
+extern void __netdev_watchdog_up(struct net_device *dev);
+extern void netif_carrier_on(struct net_device *dev);
+extern void netif_carrier_off(struct net_device *dev);
+static inline __attribute__((always_inline)) void netif_dormant_on(struct net_device *dev)
+{
+ if (!test_and_set_bit(__LINK_STATE_DORMANT, &dev->state))
+  linkwatch_fire_event(dev);
+}
+static inline __attribute__((always_inline)) void netif_dormant_off(struct net_device *dev)
+{
+ if (test_and_clear_bit(__LINK_STATE_DORMANT, &dev->state))
+  linkwatch_fire_event(dev);
+}
+static inline __attribute__((always_inline)) int netif_dormant(const struct net_device *dev)
+{
+ return test_bit(__LINK_STATE_DORMANT, &dev->state);
+}
+static inline __attribute__((always_inline)) int netif_oper_up(const struct net_device *dev) {
+ return (dev->operstate == IF_OPER_UP ||
+  dev->operstate == IF_OPER_UNKNOWN );
+}
+static inline __attribute__((always_inline)) int netif_device_present(struct net_device *dev)
+{
+ return test_bit(__LINK_STATE_PRESENT, &dev->state);
+}
+extern void netif_device_detach(struct net_device *dev);
+extern void netif_device_attach(struct net_device *dev);
+enum {
+ NETIF_MSG_DRV = 0x0001,
+ NETIF_MSG_PROBE = 0x0002,
+ NETIF_MSG_LINK = 0x0004,
+ NETIF_MSG_TIMER = 0x0008,
+ NETIF_MSG_IFDOWN = 0x0010,
+ NETIF_MSG_IFUP = 0x0020,
+ NETIF_MSG_RX_ERR = 0x0040,
+ NETIF_MSG_TX_ERR = 0x0080,
+ NETIF_MSG_TX_QUEUED = 0x0100,
+ NETIF_MSG_INTR = 0x0200,
+ NETIF_MSG_TX_DONE = 0x0400,
+ NETIF_MSG_RX_STATUS = 0x0800,
+ NETIF_MSG_PKTDATA = 0x1000,
+ NETIF_MSG_HW = 0x2000,
+ NETIF_MSG_WOL = 0x4000,
+};
+static inline __attribute__((always_inline)) u32 netif_msg_init(int debug_value, int default_msg_enable_bits)
+{
+ if (debug_value < 0 || debug_value >= (sizeof(u32) * 8))
+  return default_msg_enable_bits;
+ if (debug_value == 0)
+  return 0;
+ return (1 << debug_value) - 1;
+}
+static inline __attribute__((always_inline)) void __netif_tx_lock(struct netdev_queue *txq, int cpu)
+{
+ do { do { do { (current_thread_info()->preempt_count) += (1); } while (0); __asm__ __volatile__("": : :"memory"); } while (0); (void)0; (void)(&txq->_xmit_lock); } while (0);
+ txq->xmit_lock_owner = cpu;
+}
+static inline __attribute__((always_inline)) void __netif_tx_lock_bh(struct netdev_queue *txq)
+{
+ do { local_bh_disable(); do { do { do { (current_thread_info()->preempt_count) += (1); } while (0); __asm__ __volatile__("": : :"memory"); } while (0); (void)0; (void)(&txq->_xmit_lock); } while (0); } while (0);
+ txq->xmit_lock_owner = 0;
+}
+static inline __attribute__((always_inline)) int __netif_tx_trylock(struct netdev_queue *txq)
+{
+ int ok = (({ do { do { do { (current_thread_info()->preempt_count) += (1); } while (0); __asm__ __volatile__("": : :"memory"); } while (0); (void)0; (void)(&txq->_xmit_lock); } while (0); 1; }));
+ if (__builtin_expect(!!(ok), 1))
+  txq->xmit_lock_owner = 0;
+ return ok;
+}
+static inline __attribute__((always_inline)) void __netif_tx_unlock(struct netdev_queue *txq)
+{
+ txq->xmit_lock_owner = -1;
+ do { do { do { __asm__ __volatile__("": : :"memory"); do { (current_thread_info()->preempt_count) -= (1); } while (0); } while (0); __asm__ __volatile__("": : :"memory"); do { if (__builtin_expect(!!(test_ti_thread_flag(current_thread_info(), 2)), 0)) preempt_schedule(); } while (0); } while (0); (void)0; (void)(&txq->_xmit_lock); } while (0);
+}
+static inline __attribute__((always_inline)) void __netif_tx_unlock_bh(struct netdev_queue *txq)
+{
+ txq->xmit_lock_owner = -1;
+ do { do { __asm__ __volatile__("": : :"memory"); do { (current_thread_info()->preempt_count) -= (1); } while (0); } while (0); local_bh_enable(); (void)0; (void)(&txq->_xmit_lock); } while (0);
+}
+static inline __attribute__((always_inline)) void txq_trans_update(struct netdev_queue *txq)
+{
+ if (txq->xmit_lock_owner != -1)
+  txq->trans_start = jiffies;
+}
+static inline __attribute__((always_inline)) void netif_tx_lock(struct net_device *dev)
+{
+ unsigned int i;
+ int cpu;
+ do { do { do { (current_thread_info()->preempt_count) += (1); } while (0); __asm__ __volatile__("": : :"memory"); } while (0); (void)0; (void)(&dev->tx_global_lock); } while (0);
+ cpu = 0;
+ for (i = 0; i < dev->num_tx_queues; i++) {
+  struct netdev_queue *txq = netdev_get_tx_queue(dev, i);
+  __netif_tx_lock(txq, cpu);
+  set_bit(__QUEUE_STATE_FROZEN, &txq->state);
+  __netif_tx_unlock(txq);
+ }
+}
+static inline __attribute__((always_inline)) void netif_tx_lock_bh(struct net_device *dev)
+{
+ local_bh_disable();
+ netif_tx_lock(dev);
+}
+static inline __attribute__((always_inline)) void netif_tx_unlock(struct net_device *dev)
+{
+ unsigned int i;
+ for (i = 0; i < dev->num_tx_queues; i++) {
+  struct netdev_queue *txq = netdev_get_tx_queue(dev, i);
+  clear_bit(__QUEUE_STATE_FROZEN, &txq->state);
+  netif_schedule_queue(txq);
+ }
+ do { do { do { __asm__ __volatile__("": : :"memory"); do { (current_thread_info()->preempt_count) -= (1); } while (0); } while (0); __asm__ __volatile__("": : :"memory"); do { if (__builtin_expect(!!(test_ti_thread_flag(current_thread_info(), 2)), 0)) preempt_schedule(); } while (0); } while (0); (void)0; (void)(&dev->tx_global_lock); } while (0);
+}
+static inline __attribute__((always_inline)) void netif_tx_unlock_bh(struct net_device *dev)
+{
+ netif_tx_unlock(dev);
+ local_bh_enable();
+}
+static inline __attribute__((always_inline)) void netif_tx_disable(struct net_device *dev)
+{
+ unsigned int i;
+ int cpu;
+ local_bh_disable();
+ cpu = 0;
+ for (i = 0; i < dev->num_tx_queues; i++) {
+  struct netdev_queue *txq = netdev_get_tx_queue(dev, i);
+  __netif_tx_lock(txq, cpu);
+  netif_tx_stop_queue(txq);
+  __netif_tx_unlock(txq);
+ }
+ local_bh_enable();
+}
+static inline __attribute__((always_inline)) void netif_addr_lock(struct net_device *dev)
+{
+ do { do { do { (current_thread_info()->preempt_count) += (1); } while (0); __asm__ __volatile__("": : :"memory"); } while (0); (void)0; (void)(&dev->addr_list_lock); } while (0);
+}
+static inline __attribute__((always_inline)) void netif_addr_lock_bh(struct net_device *dev)
+{
+ do { local_bh_disable(); do { do { do { (current_thread_info()->preempt_count) += (1); } while (0); __asm__ __volatile__("": : :"memory"); } while (0); (void)0; (void)(&dev->addr_list_lock); } while (0); } while (0);
+}
+static inline __attribute__((always_inline)) void netif_addr_unlock(struct net_device *dev)
+{
+ do { do { do { __asm__ __volatile__("": : :"memory"); do { (current_thread_info()->preempt_count) -= (1); } while (0); } while (0); __asm__ __volatile__("": : :"memory"); do { if (__builtin_expect(!!(test_ti_thread_flag(current_thread_info(), 2)), 0)) preempt_schedule(); } while (0); } while (0); (void)0; (void)(&dev->addr_list_lock); } while (0);
+}
+static inline __attribute__((always_inline)) void netif_addr_unlock_bh(struct net_device *dev)
+{
+ do { do { __asm__ __volatile__("": : :"memory"); do { (current_thread_info()->preempt_count) -= (1); } while (0); } while (0); local_bh_enable(); (void)0; (void)(&dev->addr_list_lock); } while (0);
+}
+extern void ether_setup(struct net_device *dev);
+extern struct net_device *alloc_netdev_mq(int sizeof_priv, const char *name,
+           void (*setup)(struct net_device *),
+           unsigned int queue_count);
+extern int register_netdev(struct net_device *dev);
+extern void unregister_netdev(struct net_device *dev);
+extern int dev_addr_add(struct net_device *dev, unsigned char *addr,
+   unsigned char addr_type);
+extern int dev_addr_del(struct net_device *dev, unsigned char *addr,
+   unsigned char addr_type);
+extern int dev_addr_add_multiple(struct net_device *to_dev,
+     struct net_device *from_dev,
+     unsigned char addr_type);
+extern int dev_addr_del_multiple(struct net_device *to_dev,
+     struct net_device *from_dev,
+     unsigned char addr_type);
+extern void dev_set_rx_mode(struct net_device *dev);
+extern void __dev_set_rx_mode(struct net_device *dev);
+extern int dev_unicast_delete(struct net_device *dev, void *addr);
+extern int dev_unicast_add(struct net_device *dev, void *addr);
+extern int dev_unicast_sync(struct net_device *to, struct net_device *from);
+extern void dev_unicast_unsync(struct net_device *to, struct net_device *from);
+extern int dev_mc_delete(struct net_device *dev, void *addr, int alen, int all);
+extern int dev_mc_add(struct net_device *dev, void *addr, int alen, int newonly);
+extern int dev_mc_sync(struct net_device *to, struct net_device *from);
+extern void dev_mc_unsync(struct net_device *to, struct net_device *from);
+extern int __dev_addr_delete(struct dev_addr_list **list, int *count, void *addr, int alen, int all);
+extern int __dev_addr_add(struct dev_addr_list **list, int *count, void *addr, int alen, int newonly);
+extern int __dev_addr_sync(struct dev_addr_list **to, int *to_count, struct dev_addr_list **from, int *from_count);
+extern void __dev_addr_unsync(struct dev_addr_list **to, int *to_count, struct dev_addr_list **from, int *from_count);
+extern int dev_set_promiscuity(struct net_device *dev, int inc);
+extern int dev_set_allmulti(struct net_device *dev, int inc);
+extern void netdev_state_change(struct net_device *dev);
+extern void netdev_bonding_change(struct net_device *dev,
+           unsigned long event);
+extern void netdev_features_change(struct net_device *dev);
+extern void dev_load(struct net *net, const char *name);
+extern void dev_mcast_init(void);
+extern const struct net_device_stats *dev_get_stats(struct net_device *dev);
+extern int netdev_max_backlog;
+extern int weight_p;
+extern int netdev_set_master(struct net_device *dev, struct net_device *master);
+extern int skb_checksum_help(struct sk_buff *skb);
+extern struct sk_buff *skb_gso_segment(struct sk_buff *skb, int features);
+extern void netdev_rx_csum_fault(struct net_device *dev);
+extern void net_enable_timestamp(void);
+extern void net_disable_timestamp(void);
+extern void *dev_seq_start(struct seq_file *seq, loff_t *pos);
+extern void *dev_seq_next(struct seq_file *seq, void *v, loff_t *pos);
+extern void dev_seq_stop(struct seq_file *seq, void *v);
+extern int netdev_class_create_file(struct class_attribute *class_attr);
+extern void netdev_class_remove_file(struct class_attribute *class_attr);
+extern char *netdev_drivername(const struct net_device *dev, char *buffer, int len);
+extern void linkwatch_run_queue(void);
+unsigned long netdev_increment_features(unsigned long all, unsigned long one,
+     unsigned long mask);
+unsigned long netdev_fix_features(unsigned long features, const char *name);
+static inline __attribute__((always_inline)) int net_gso_ok(int features, int gso_type)
+{
+ int feature = gso_type << 16;
+ return (features & feature) == feature;
+}
+static inline __attribute__((always_inline)) int skb_gso_ok(struct sk_buff *skb, int features)
+{
+ return net_gso_ok(features, ((struct skb_shared_info *)(skb_end_pointer(skb)))->gso_type) &&
+        (!skb_has_frags(skb) || (features & 64));
+}
+static inline __attribute__((always_inline)) int netif_needs_gso(struct net_device *dev, struct sk_buff *skb)
+{
+ return skb_is_gso(skb) &&
+        (!skb_gso_ok(skb, dev->features) ||
+  __builtin_expect(!!(skb->ip_summed != 3), 0));
+}
+static inline __attribute__((always_inline)) void netif_set_gso_max_size(struct net_device *dev,
+       unsigned int size)
+{
+ dev->gso_max_size = size;
+}
+static inline __attribute__((always_inline)) void skb_bond_set_mac_by_master(struct sk_buff *skb,
+           struct net_device *master)
+{
+ if (skb->pkt_type == 0) {
+  u16 *dest = (u16 *) eth_hdr(skb)->h_dest;
+  memcpy(dest, master->dev_addr, 6);
+ }
+}
+static inline __attribute__((always_inline)) int skb_bond_should_drop(struct sk_buff *skb)
+{
+ struct net_device *dev = skb->dev;
+ struct net_device *master = dev->master;
+ if (master) {
+  if (master->priv_flags & 0x100)
+   dev->last_rx = jiffies;
+  if ((master->priv_flags & 0x10) && master->br_port) {
+   skb_bond_set_mac_by_master(skb, master);
+  }
+  if (dev->priv_flags & 0x4) {
+   if ((dev->priv_flags & 0x40) &&
+       skb->protocol == (( __be16)(__builtin_constant_p((__u16)((0x0806))) ? ((__u16)( (((__u16)((0x0806)) & (__u16)0x00ffU) << 8) | (((__u16)((0x0806)) & (__u16)0xff00U) >> 8))) : __fswab16((0x0806)))))
+    return 0;
+   if (master->priv_flags & 0x10) {
+    if (skb->pkt_type != 1 &&
+        skb->pkt_type != 2)
+     return 0;
+   }
+   if (master->priv_flags & 0x8 &&
+       skb->protocol == (( __be16)(__builtin_constant_p((__u16)((0x8809))) ? ((__u16)( (((__u16)((0x8809)) & (__u16)0x00ffU) << 8) | (((__u16)((0x8809)) & (__u16)0xff00U) >> 8))) : __fswab16((0x8809)))))
+    return 0;
+   return 1;
+  }
+ }
+ return 0;
+}
+extern struct pernet_operations __attribute__ ((__section__(".init.data"))) loopback_net_ops;
+static inline __attribute__((always_inline)) int dev_ethtool_get_settings(struct net_device *dev,
+        struct ethtool_cmd *cmd)
+{
+ if (!dev->ethtool_ops || !dev->ethtool_ops->get_settings)
+  return -95;
+ return dev->ethtool_ops->get_settings(dev, cmd);
+}
+static inline __attribute__((always_inline)) u32 dev_ethtool_get_rx_csum(struct net_device *dev)
+{
+ if (!dev->ethtool_ops || !dev->ethtool_ops->get_rx_csum)
+  return 0;
+ return dev->ethtool_ops->get_rx_csum(dev);
+}
+static inline __attribute__((always_inline)) u32 dev_ethtool_get_flags(struct net_device *dev)
+{
+ if (!dev->ethtool_ops || !dev->ethtool_ops->get_flags)
+  return 0;
+ return dev->ethtool_ops->get_flags(dev);
+}
+struct file_operations;
+struct inode;
+struct module;
+struct cdev {
+ struct kobject kobj;
+ struct module *owner;
+ const struct file_operations *ops;
+ struct list_head list;
+ dev_t dev;
+ unsigned int count;
+};
+void cdev_init(struct cdev *, const struct file_operations *);
+struct cdev *cdev_alloc(void);
+void cdev_put(struct cdev *p);
+int cdev_add(struct cdev *, dev_t, unsigned);
+void cdev_del(struct cdev *);
+int cdev_index(struct inode *inode);
+void cd_forget(struct inode *);
+extern struct backing_dev_info directly_mappable_cdev_bdi;
+typedef enum ST_HWIPtype_e
+{
+        STIP_TSMERGER,
+        STIP_STFE,
+        STIP_TSGDMA,
+        STIP_PTI,
+        STIP_PDES3,
+        STIP_CRYPTOCORE2,
+        STIP_CRYPTOCORE3,
+        STIP_TKDMA,
+        STIP_ICAM,
+        STIP_RNG,
+        STIP_NVSTORAGE,
+        STIP_FDMA,
+        STIP_DOCSIS,
+        STIP_MCHI,
+        STIP_NQAMDMOD,
+        STIP_SAFEMEMHV,
+        STIP_EBEAM,
+        STIP_CCSC,
+        STIP_XVP,
+        STIP_MAINVDP,
+        STIP_SECVDP,
+        STIP_AUXVDP,
+        STIP_BLITTER,
+        STIP_COMPOSITOR,
+        STIP_DVP,
+        STIP_DELTA,
+        STIP_VDAC,
+        STIP_HDTVOUT,
+        STIP_VTG,
+        STIP_DENC,
+        STIP_HDMI,
+        STIP_HDFORMAT,
+        STIP_AWG_DCS,
+        STIP_DVO,
+        STIP_HDCP,
+        STIP_SDTVOUT,
+        STIP_RFMOD,
+        STIP_PCMPLAYER,
+        STIP_PCMREADER,
+        STIP_ADAC,
+        STIP_SPDIFPLAYER,
+        STIP_EMISS,
+        STIP_PCI,
+        STIP_PLI,
+        STIP_MES,
+        STIP_COMMS,
+        STIP_PIOSTDALONE,
+        STIP_SATALINK,
+        STIP_SATAPHY,
+        STIP_SATAHOST,
+        STIP_CPGSATA,
+        STIP_FTMSATA,
+        STIP_HDMISERIALISER,
+        STIP_SH4CPU,
+        STIP_C6S4300,
+        STIP_ST231,
+        STIP_FE900,
+        STIP_CLKGENA,
+        STIP_CLKGENB,
+        STIP_PLL800,
+        STIP_PLL1600,
+        STIP_QFS
+} ST_HWIPtype_t;
+typedef unsigned long long U64;
+typedef signed long long S64;
+typedef int BOOL;
+typedef char* ST_String_t;
+typedef U32 ST_ErrorCode_t;
+typedef const char * ST_Revision_t;
+typedef U16 ST_DriverId_t;
+typedef U8 ST_CPU_t;
+typedef char ST_DeviceName_t[16];
+typedef int partition_t;
+typedef partition_t ST_Partition_t;
+typedef struct {
+  U32 size;
+  void* addr;
+}ST_ScatterPage_t ;
+typedef struct {
+   U32 nbPages;
+   ST_ScatterPage_t pages[];
+}ST_ScatterList_t;
+enum
+{
+    ST_NO_ERROR = (0 << 16),
+    ST_ERROR_BAD_PARAMETER,
+    ST_ERROR_NO_MEMORY,
+    ST_ERROR_UNKNOWN_DEVICE,
+    ST_ERROR_ALREADY_INITIALIZED,
+    ST_ERROR_NO_FREE_HANDLES,
+    ST_ERROR_OPEN_HANDLE,
+    ST_ERROR_INVALID_HANDLE,
+    ST_ERROR_FEATURE_NOT_SUPPORTED,
+    ST_ERROR_INTERRUPT_INSTALL,
+    ST_ERROR_INTERRUPT_UNINSTALL,
+    ST_ERROR_TIMEOUT,
+    ST_ERROR_DEVICE_BUSY,
+    ST_ERROR_SUSPENDED
+};
+typedef enum STTBX_ReportLevel_e
+{
+    STTBX_REPORT_LEVEL_FATAL = 0,
+    STTBX_REPORT_LEVEL_ERROR,
+    STTBX_REPORT_LEVEL_WARNING,
+    STTBX_REPORT_LEVEL_ENTER_LEAVE_FN,
+    STTBX_REPORT_LEVEL_INFO,
+    STTBX_REPORT_LEVEL_USER1,
+    STTBX_REPORT_LEVEL_USER2,
+    STTBX_REPORT_LEVEL_SET_TRACE,
+    STTBX_NB_OF_REPORT_LEVEL
+} STTBX_ReportLevel_t;
+void STTBX_Report_arg(const STTBX_ReportLevel_t ReportLevel, const char *const Format_p, ...);
+typedef BOOL boolean;
+typedef struct ST_ClockInfo_s
+{
+ struct
+  {
+   U32 lmi_clk;
+   U32 pll0_clk;
+   U32 pll1_clk;
+   U32 st40cpu_clk;
+   U32 st40tick_clk;
+   U32 com_clk;
+   U32 fdma0_clk;
+   U32 fdma1_clk;
+   U32 lxaud_clk;
+   U32 lxdmu_clk;
+   U32 bdisp_clk;
+   U32 disp_clk;
+   U32 ts_clk;
+   U32 vdp_clk;
+   U32 blit_clk;
+   U32 eth_clk;
+   U32 pci_clk;
+   U32 emi_clk;
+  } ckga;
+ struct
+  {
+   U32 fs0_1_clk;
+   U32 fs0_2_clk;
+   U32 fs0_3_clk;
+   U32 fs1_1_clk;
+   U32 fs1_2_clk;
+   U32 fs1_3_clk;
+   U32 fs1_4_clk;
+   U32 hdmidll_clk;
+   U32 hdmibch_clk;
+   U32 hdmitmds_clk;
+   U32 hdmipix_clk;
+   U32 hdpix_clk;
+   U32 hddisp_clk;
+   U32 c656_clk;
+   U32 gdp3_clk;
+   U32 sdpix_clk;
+   U32 sddisp_clk;
+   U32 dvp_clk;
+   U32 pipe_clk;
+   U32 h264pp_clk;
+   U32 ic_clk;
+   U32 rtc_clk;
+   U32 lpc_clk;
+  } ckgb;
+ struct
+  {
+   U32 fs0_1_clk;
+   U32 fs0_2_clk;
+   U32 fs0_3_clk;
+   U32 fs0_4_clk;
+  }ckgc;
+ struct
+  {
+   U32 lmi_clk;
+  }ckgd;
+} ST_ClockInfo_t;
+typedef struct ST_LegacyClockInfo_s
+{
+    U32 STBus;
+    U32 CommsBlock;
+    U32 VideoMem;
+    U32 AudioDSP;
+    U32 EMI;
+    U32 Flash;
+    U32 SDRAM;
+    U32 PCM;
+    U32 HPTimer;
+    U32 LPTimer;
+    U32 st40;
+    U32 ST40Per;
+    U32 PCI;
+    U32 Aux;
+} ST_LegacyClockInfo_t;
+typedef struct ST_AudioInfoFrame_s
+{
+U32 InfoFrameType : 8;
+U32 InfoFrameVersion : 8;
+U32 LengthOfAudioInfo : 8;
+U32 AudioChannelCount : 3;
+U32 F13 : 1;
+U32 AudioCodingType : 4;
+U32 SampleSize : 2;
+U32 SamplingFreq : 3;
+U32 F25_27 : 3;
+U32 CXT : 5;
+U32 F35_37 : 3;
+U32 ChannelAllocation : 8;
+U32 LFE : 2;
+U32 F52 : 1;
+U32 LSV : 4;
+U32 DM_INH : 1;
+U32 F60_97 : 32;
+U32 F100_107 : 8;
+U32 Align32 : 24;
+} ST_AudioInfoFrame_t;
+typedef enum
+{
+    STCOMMON_JITTER_DISTRIB_TYPE_TUNER,
+    STCOMMON_JITTER_DISTRIB_TYPE_IP,
+    STCOMMON_JITTER_DISTRIB_TYPE_MAX
+} STCOMMON_JitterDistrib_e;
+U32 ST_ConvRevToNum(ST_Revision_t *ptRevision_p);
+U32 ST_GetCutRevision(void);
+U32 ST_GetClockSpeed(void);
+U32 ST_GetClocksPerSecond(void);
+U32 ST_GetClocksPerSecondHigh(void);
+U32 ST_GetClocksPerSecondLow(void);
+U32 ST_GetMajorRevision(ST_Revision_t *ptRevision_p);
+U32 ST_GetMinorRevision(ST_Revision_t *ptRevision_p);
+U32 ST_GetPatchRevision(ST_Revision_t *ptRevision_p);
+U32 ST_GetIpVersion(ST_HWIPtype_t ipname);
+U32 ST_GetSocRevision(void);
+BOOL ST_AreStringsEqual(const char *DeviceName1_p,const char *DeviceName2_p);
+ST_ErrorCode_t ST_GetClockInfo(ST_ClockInfo_t *ClockInfo_p);
+ST_ErrorCode_t ST_GetLegacyClockInfo (ST_LegacyClockInfo_t *ClockInfo_p);
+ST_Revision_t STCOMMON_GetRevision(void);
+ST_ErrorCode_t ST_GetJitterProfile(STCOMMON_JitterDistrib_e JitterProfile,U32 *JitterAmplitude);
+ST_ErrorCode_t STCOMMON_Open(void);
+ST_ErrorCode_t STCOMMON_Close(void);
+ST_ErrorCode_t STCOMMON_HandleGetDriverData(U32 SysHandle, void **DriverData);
+ST_ErrorCode_t STCOMMON_HandleFromDriverData(U32 *SysHandle, void *DriverData);
+ST_ErrorCode_t STCOMMON_HandleAlloc(U32 DriverID, void *DriverData, U32 *SysHandle_p);
+ST_ErrorCode_t STCOMMON_HandleFree(U32 SysHandle);
+typedef enum
+{
+    STOS_FAST_IRQ = 0x01,
+    STOS_SHARED_IRQ = 0x02,
+    STOS_RANDOM_SEED_IRQ = 0x04
+} STOS_InterruptType_t;
+typedef struct STOS_InterruptParam_s
+{
+    STOS_InterruptType_t InterruptType;
+} STOS_InterruptParam_t;
+enum{
+    STOS_TaskFlags_Suspended = 1
+};
+typedef unsigned long STOS_Clock_t ;
+typedef int STOS_Error_t;
+typedef int STOS_Partition_t;
+typedef int STOS_TaskContext_t;
+enum {
+    STOS_TaskContext_Task = 0 ,
+    STOS_TaskContext_Interrupt = 1
+};
+typedef struct task_struct STOS_Task_t;
+typedef void * STOS_TaskDesc_t;
+typedef int STOS_TaskFlags_t;
+    struct STOS_Semaphore_s
+    {
+        struct semaphore _sema;
+    };
+typedef struct STOS_Semaphore_s STOS_Semaphore_t;
+typedef struct STOS_Mutex_s STOS_Mutex_t;
+typedef struct
+{
+    STOS_Semaphore_t * MsgSemaphore_p;
+    STOS_Semaphore_t * ClaimSemaphore_p;
+    int Index;
+} STOS_MessageQueue_t;
+ST_Revision_t STOS_GetRevision(void);
+ST_ErrorCode_t STOS_TaskCreate (void (*Function)(void* Param),
+                                       void* Param,
+                                       STOS_Partition_t* StackPartition,
+                                       size_t StackSize,
+                                       void** Stack,
+                                       STOS_Partition_t* TaskPartition,
+                                       STOS_Task_t** Task,
+                                       STOS_TaskDesc_t* Tdesc,
+                                       int Priority,
+                                       const char* Name,
+                                       STOS_TaskFlags_t Flags );
+ST_ErrorCode_t STOS_TaskResume ( STOS_Task_t* Task);
+ST_ErrorCode_t STOS_TaskWait ( STOS_Task_t** Task, const STOS_Clock_t * TimeOutValue_p );
+ST_ErrorCode_t STOS_TaskEnter ( void * Param );
+ST_ErrorCode_t STOS_TaskExit ( void * Param );
+ST_ErrorCode_t STOS_TaskDelete (STOS_Task_t* Task,
+                                 STOS_Partition_t* TaskPartition,
+                                 void* Stack,
+                                 STOS_Partition_t* StackPartition );
+STOS_TaskContext_t STOS_TaskContext(STOS_Task_t **task, int* level);
+int STOS_TaskGetPriority(STOS_Task_t *task);
+STOS_Error_t STOS_TaskSetPriority(STOS_Task_t *task, int priority);
+STOS_Semaphore_t * STOS_SemaphoreCreateFifo (STOS_Partition_t * Partition_p, const int InitialValue);
+STOS_Semaphore_t * STOS_SemaphoreCreateFifoTimeOut (STOS_Partition_t * Partition_p, const int InitialValue);
+STOS_Semaphore_t * STOS_SemaphoreCreatePriority (STOS_Partition_t * Partition_p, const int InitialValue);
+STOS_Semaphore_t * STOS_SemaphoreCreatePriorityTimeOut(STOS_Partition_t * Partition_p, const int InitialValue);
+int STOS_SemaphoreDelete(STOS_Partition_t * Partition_p, STOS_Semaphore_t * Semaphore_p);
+void STOS_SemaphoreSignal(STOS_Semaphore_t * Semaphore_p);
+int STOS_SemaphoreWait(STOS_Semaphore_t * Semaphore_p);
+int STOS_SemaphoreWaitTimeOut (STOS_Semaphore_t * Semaphore_p, const STOS_Clock_t * TimeOutValue);
+void STOS_memsetPhysicalMemory(void* PhysicalAddress, U8 Pattern, U32 Size);
+void STOS_memsetUncached(void* PhysicalAddress, U8 Pattern, U32 Size) ;
+void STOS_memcpyUncachedToUncached(void* uncached_dest, void* uncached_src, U32 Size) ;
+void STOS_memcpyCachedToUncached(void* uncached_dest, void* uncached_src, U32 Size) ;
+void STOS_memcpyUncachedToCached(void* uncached_dest, void* uncached_src, U32 Size) ;
+void STOS_memcpyCachedToCached(void* cached_dest, void* cached_src, U32 Size) ;
+void * STOS_memcpy(void * dst, const void * src, size_t count);
+void* STOS_MemoryAllocate(STOS_Partition_t *part, size_t size);
+void STOS_MemoryDeallocate(STOS_Partition_t *part, void* block);
+void* STOS_MemoryReallocate (STOS_Partition_t* Partition, void* Block, size_t Requested, size_t OldSize);
+void* STOS_MemoryAllocateClear(STOS_Partition_t* Partition, size_t nelem, size_t elsize);
+void STOS_debug_print_Allocators(U32 limit);
+void* STOS_VirtToPhys(void* vAddr);
+void* STOS_MapRegisters(void* pAddr, U32 Length, char * Name);
+void STOS_UnmapRegisters(void* vAddr, U32 Length);
+void* STOS_MapPhysToCached(void* pAddr, U32 Length);
+void* STOS_MapPhysToUncached(void* pAddr, U32 Length);
+void STOS_UnmapPhysToCached(void* vAddr, U32 Length);
+void STOS_UnmapPhysToUncached(void* vAddr, U32 Length);
+void STOS_TaskLock(void);
+void STOS_TaskUnlock(void);
+U32 STOS_GetClocksPerSecond(void);
+STOS_Clock_t STOS_TimeNow(void);
+STOS_Clock_t STOS_TimeMinus(STOS_Clock_t t1, STOS_Clock_t t2);
+STOS_Clock_t STOS_TimePlus(STOS_Clock_t t1, STOS_Clock_t t2);
+int STOS_TimeAfter(STOS_Clock_t t1,STOS_Clock_t t2);
+STOS_Mutex_t * STOS_MutexCreateFifo (void);
+STOS_Mutex_t * STOS_MutexCreatePriority(void);
+int STOS_MutexDelete (STOS_Mutex_t *mutex);
+int STOS_MutexLock (STOS_Mutex_t* mutex);
+int STOS_MutexTryLock(STOS_Mutex_t * mutex);
+int STOS_MutexRelease (STOS_Mutex_t* mutex);
+void STOS_TaskDelay(STOS_Clock_t ticks);
+void STOS_TaskDelayUntil(STOS_Clock_t timeout);
+void STOS_TaskDelayUs(int microsec);
+static void STOS_TaskSchedule(void);
+static void STOS_TaskYield(void);
+void STOS_InterruptLock(void);
+void STOS_InterruptUnlock(void);
+STOS_Error_t STOS_InterruptEnable(unsigned int Number,unsigned int Level);
+STOS_Error_t STOS_InterruptDisable(unsigned int Number,unsigned int Level);
+STOS_Error_t STOS_InterruptClear(unsigned int Number, unsigned int Level);
+int STOS_InterruptMapGet(int InterruptNumber);
+STOS_Error_t STOS_InterruptInstallConfigurable( U32 InterruptNumber,
+                                    U32 InterruptLevel,
+                                    irq_handler_t Fct,
+                                    STOS_InterruptParam_t * InterruptParam_p,
+                                    char * IrqName,
+                                    void * Params);
+STOS_Error_t STOS_InterruptInstall( U32 InterruptNumber,
+                                    U32 InterruptLevel,
+                                    irq_handler_t Fct,
+                                    char * IrqName,
+                                    void * Params);
+STOS_Error_t STOS_InterruptUninstall(U32 InterruptNumber,
+                                     U32 InterruptLevel,
+                                     void * Params);
+STOS_Error_t STOS_InterruptUninstallConfigurable(U32 InterruptNumber,
+                                     U32 InterruptLevel,
+                                     irq_handler_t Fct,
+                                     STOS_InterruptParam_t * InterruptParam_p,
+                                     void * Params);
+STOS_MessageQueue_t * STOS_MessageQueueCreate(size_t ElementSize, unsigned int NoElements);
+int STOS_MessageQueueDelete(STOS_MessageQueue_t* MessageQueue);
+void* STOS_MessageQueueClaimTimeout(STOS_MessageQueue_t *queue, STOS_Clock_t * time_end_p);
+void* STOS_MessageQueueClaim(STOS_MessageQueue_t * MessageQueue);
+void STOS_MessageQueueRelease (STOS_MessageQueue_t* MessageQueue, void* Message);
+void STOS_MessageQueueSend(STOS_MessageQueue_t *queue, void *message);
+void *STOS_MessageQueueReceive (STOS_MessageQueue_t* MessageQueue);
+void *STOS_MessageQueueReceiveTimeout (STOS_MessageQueue_t* MessageQueue, STOS_Clock_t * ticks);
+int STLINUX_DeviceRegister(struct file_operations *stdevice_fops,
+                         U32 nbdevices,
+                         char *DeviceName,
+                         unsigned int *DeviceMajor_p,
+                         struct cdev **stdevice_cdev,
+                         struct class **stdevice_class);
+int STLINUX_DeviceUnregister(U32 nbdevices,
+                           char *DeviceName,
+                           unsigned int DeviceMajor,
+                           struct cdev *stdevice_cdev,
+                           struct class *stdevice_class);
+STOS_Clock_t STLINUX_TimeNowUser(void);
+unsigned long rand(void);
+void * STLINUX_MapRegion(void * Address_p, U32 Width, char * RegionName);
+void STLINUX_UnmapRegion(void * MappedAddress_p, U32 Width);
+int STLINUX_MMapMethod(struct file *filp, struct vm_area_struct *vma);
+inline __attribute__((always_inline)) void STOS_TaskSchedule(void) { schedule(); }
+inline __attribute__((always_inline)) void STOS_TaskYield(void) { yield(); }
+enum {
+     OS21_SUCCESS = 0 ,
+     OS21_FAILURE = -1
+} ;
+typedef STOS_Clock_t osclock_t ;
+typedef STOS_Mutex_t mutex_t ;
+enum {
+    task_flags_no_min_stack_size = 0 ,
+    task_flags_suspended =1 ,
+    task_flags_high_priority_process = 2
+} ;
+enum
+{
+    task_context_task = STOS_TaskContext_Task ,
+    task_context_interrupt = STOS_TaskContext_Interrupt
+} ;
+typedef STOS_TaskContext_t task_context_t ;
+typedef STOS_Task_t task_t ;
+typedef STOS_TaskDesc_t tdesc_t ;
+typedef STOS_TaskFlags_t task_flags_t ;
+typedef STOS_Semaphore_t semaphore_t ;
+typedef STOS_MessageQueue_t message_queue_t ;
+void* memory_allocate(STOS_Partition_t *part, size_t size) ;
+void memory_deallocate(STOS_Partition_t *part, void* block) ;
+void* memory_reallocate (STOS_Partition_t* Partition, void* Block, size_t Requested, size_t OldSize) ;
+void* memory_allocate_clear(STOS_Partition_t* Partition, size_t nelem, size_t elsize) ;
+STOS_Mutex_t * mutex_create_fifo(void) ;
+int mutex_lockit(STOS_Mutex_t *mutex) ;
+int mutex_release(STOS_Mutex_t *mutex) ;
+int mutex_delete(STOS_Mutex_t *mutex) ;
+int semaphore_init_fifo(STOS_Semaphore_t *sem, int count) ;
+STOS_Semaphore_t * semaphore_create_fifo_timeout(int count) ;
+int semaphore_wait(STOS_Semaphore_t *sem) ;
+int semaphore_signal(STOS_Semaphore_t *sem) ;
+int semaphore_wait_timeout(STOS_Semaphore_t *sem, STOS_Clock_t *timeout) ;
+int semaphore_delete (STOS_Semaphore_t* Semaphore) ;
+void message_init_queue_timeout(STOS_MessageQueue_t* MessageQueue,
+                                void* memory, size_t ElementSize,
+                                unsigned int NoElements) ;
+void message_init_queue(STOS_MessageQueue_t* MessageQueue,
+                        void* memory, size_t ElementSize,
+                        unsigned int NoElements) ;
+STOS_MessageQueue_t * message_create_queue_timeout(size_t ElementSize, unsigned int NoElements) ;
+int message_delete_queue(STOS_MessageQueue_t* MessageQueue) ;
+void* message_claim_timeout(STOS_MessageQueue_t *queue, STOS_Clock_t * time_end_p) ;
+void* message_claim(STOS_MessageQueue_t * MessageQueue) ;
+void message_release (STOS_MessageQueue_t* MessageQueue, void* Message) ;
+void message_send(STOS_MessageQueue_t *queue, void *message) ;
+void *message_receive (STOS_MessageQueue_t* MessageQueue) ;
+void *message_receive_timeout (STOS_MessageQueue_t* MessageQueue, STOS_Clock_t * ticks) ;
+STOS_Clock_t time_now (void) ;
+STOS_Clock_t time_minus (STOS_Clock_t Time1, STOS_Clock_t Time2) ;
+STOS_Clock_t time_plus (STOS_Clock_t Time1, STOS_Clock_t Time2) ;
+int time_after_STAPI (STOS_Clock_t Time1, STOS_Clock_t Time2) ;
+int task_delay(int ticks) ;
+int task_delay_until(STOS_Clock_t timeout) ;
+task_context_t task_context(STOS_Task_t **task, int* level) ;
+void interrupt_lock(void) ;
+void interrupt_unlock(void) ;
+STOS_Clock_t STOS_time_now (void) ;
+STOS_Clock_t STOS_time_minus (STOS_Clock_t Time1, STOS_Clock_t Time2) ;
+STOS_Clock_t STOS_time_plus (STOS_Clock_t Time1, STOS_Clock_t Time2) ;
+int STOS_time_after (STOS_Clock_t Time1, STOS_Clock_t Time2) ;
+typedef enum ST_MM_Bitstream_Marker_e {
+    ST_MARKER_CHUNK_ID = 0,
+    ST_MARKER_BRK_FWD,
+    ST_MARKER_BRK_BWD,
+    ST_MARKER_BRK_BWD_OVERLAP,
+    ST_MARKER_BRK_BWD_NO_OVERLAP,
+    ST_MARKER_BRK_FWD_SPLICING
+} ST_MM_Bitstream_Marker_t;
+typedef enum ST_MM_3D_Format_e {
+    ST_3D_NONE,
+    ST_3D_FORMAT_SIDEBYSIDE_HALF,
+    ST_3D_FORMAT_STACKED_HALF,
+    ST_3D_FORMAT_SIDEBYSIDE_FULL,
+    ST_3D_FORMAT_STACKED_FRAME,
+    ST_3D_FORMAT_FRAME_SEQ,
+    ST_3D_FORMAT_FIELD_ALTERNATE,
+    ST_3D_FORMAT_PICTURE_INTERLEAVE,
+    ST_3D_FORMAT_L_D,
+    ST_3D_FORMAT_L_D_G_GMINUSD,
+    ST_3D_FORMAT_2_INDEP_STREAMS,
+    ST_3D_FORMAT_FRAME_SEQ_L_L_R_R
+} ST_MM_3D_Format_t;
+typedef enum STEVT_MemSizeFlag_e
+{
+    STEVT_UNKNOWN_SIZE = 0,
+    STEVT_USER_DEFINED = ((18 << 16) + 18)
+} STEVT_MemSizeFlag_t;
+typedef enum STEVT_CallReason_e
+{
+    CALL_REASON_NOTIFY_CALL
+} STEVT_CallReason_t;
+typedef U32 STEVT_EventConstant_t;
+typedef U32 STEVT_EventID_t;
+typedef U32 STEVT_SubscriberID_t;
+typedef U32 STEVT_Handle_t;
+typedef struct STEVT_InitParams_s
+{
+    U32 EventMaxNum;
+    U32 ConnectMaxNum;
+    U32 SubscrMaxNum;
+    ST_Partition_t *MemoryPartition;
+    STEVT_MemSizeFlag_t MemorySizeFlag;
+    U32 MemoryPoolSize;
+} STEVT_InitParams_t;
+typedef struct STEVT_TermParams_s
+{
+    BOOL ForceTerminate;
+} STEVT_TermParams_t;
+typedef struct STEVT_OpenParams_s
+{
+    int dummy;
+} STEVT_OpenParams_t;
+typedef struct STEVT_CapabilityParams_s
+{
+    int dummy;
+} STEVT_CapabilityParams_t;
+typedef void (*STEVT_CallbackProc_t)(
+    STEVT_CallReason_t Reason,
+    STEVT_EventConstant_t Event,
+    const void *EventData
+);
+typedef void (*STEVT_DeviceCallbackProc_t)(
+    STEVT_CallReason_t Reason,
+    const ST_DeviceName_t RegistrantName,
+    STEVT_EventConstant_t Event,
+    const void *EventData,
+    const void *SubscriberData_p
+);
+typedef void (*STEVT_DeviceCallbackProcWithSize_t)(
+    STEVT_CallReason_t Reason,
+    const ST_DeviceName_t RegistrantName,
+    STEVT_EventConstant_t Event,
+    const void *EventData,
+    const void *SubscriberData_p,
+    U32 EventDataSize
+);
+typedef struct STEVT_SubscribeParams_s
+{
+    STEVT_CallbackProc_t NotifyCallback;
+} STEVT_SubscribeParams_t;
+typedef struct STEVT_DeviceSubscribeParams_s
+{
+    STEVT_DeviceCallbackProc_t NotifyCallback;
+    void *SubscriberData_p;
+} STEVT_DeviceSubscribeParams_t;
+typedef struct STEVT_DeviceSubscribeParamsWithSize_s
+{
+    STEVT_DeviceCallbackProcWithSize_t NotifyCallback;
+    void *SubscriberData_p;
+} STEVT_DeviceSubscribeParamsWithSize_t;
+enum { STEVT_ERROR_INVALID_EVENT_ID = ((18 << 16) + 1),
+       STEVT_ERROR_INVALID_SUBSCRIBER_ID,
+       STEVT_ERROR_ALREADY_SUBSCRIBED,
+       STEVT_ERROR_ALREADY_REGISTERED,
+       STEVT_ERROR_NO_MORE_SPACE,
+       STEVT_ERROR_INVALID_EVENT_NAME,
+       STEVT_ERROR_ALREADY_UNREGISTERED,
+       STEVT_ERROR_MISSING_NOTIFY_CALLBACK,
+       STEVT_ERROR_NOT_SUBSCRIBED,
+       STEVT_ERROR_INTERRUPT_HANDLER
+     };
+ST_ErrorCode_t STEVT_Init (const ST_DeviceName_t EventHandlerName,
+                           const STEVT_InitParams_t *InitParams);
+ST_ErrorCode_t STEVT_Term (const ST_DeviceName_t EventHandlerName,
+                           const STEVT_TermParams_t *TermParams);
+ST_ErrorCode_t STEVT_Open (const ST_DeviceName_t EventHandlerName,
+                           const STEVT_OpenParams_t *OpenParams,
+                           STEVT_Handle_t *Handle);
+ST_ErrorCode_t STEVT_Close (STEVT_Handle_t Handle);
+ST_ErrorCode_t STEVT_GetCapability (const ST_DeviceName_t EventHandlerName,
+                                    STEVT_CapabilityParams_t *CapabilityParams);
+ST_Revision_t STEVT_GetRevision (void);
+U32 STEVT_GetAllocatedMemory(STEVT_Handle_t Handle);
+ST_ErrorCode_t STEVT_RegisterInt (STEVT_Handle_t Handle,
+                               STEVT_EventConstant_t Event,
+                               STEVT_EventID_t *EventID,
+           const char *EventName);
+ST_ErrorCode_t STEVT_RegisterDeviceEventInt (STEVT_Handle_t Handle,
+                                           const ST_DeviceName_t RegistrantName,
+                                           STEVT_EventConstant_t Event,
+                                           STEVT_EventID_t *EventID,
+         const char *EventName);
+ST_ErrorCode_t STEVT_Unregister (STEVT_Handle_t Handle,
+                                 STEVT_EventConstant_t Event);
+ST_ErrorCode_t STEVT_UnregisterDeviceEvent (STEVT_Handle_t Handle,
+                                           const ST_DeviceName_t RegistrantName,
+                                           STEVT_EventConstant_t Event);
+ST_ErrorCode_t STEVT_NotifyWithSize (STEVT_Handle_t Handle,
+                                     STEVT_EventID_t EventID,
+                                     const void *EventData,
+                                     U32 DataSize);
+ST_ErrorCode_t STEVT_NotifySubscriberWithSize (STEVT_Handle_t Handle,
+                                       STEVT_EventID_t EventID,
+                                       const void *EventData,
+                                       STEVT_SubscriberID_t SubscriberID,
+                                       U32 DataSize);
+ST_ErrorCode_t STEVT_GetSubscriberID (STEVT_Handle_t Handle,
+                                      STEVT_SubscriberID_t *SubscriberID);
+ST_ErrorCode_t STEVT_SubscribeInt (STEVT_Handle_t Handle,
+                                STEVT_EventConstant_t Event,
+                                const char* EventName,
+                                const STEVT_SubscribeParams_t *SubscribeParams);
+ST_ErrorCode_t STEVT_SubscribeDeviceEventWithSizeInt(STEVT_Handle_t Handle,
+                                           const ST_DeviceName_t RegistrantName,
+                                           STEVT_EventConstant_t EventConst,
+                                           const char *EventName,
+                                           const STEVT_DeviceSubscribeParamsWithSize_t *SubscribeParams);
+ST_ErrorCode_t STEVT_SubscribeDeviceEventInt (STEVT_Handle_t Handle,
+                                           const ST_DeviceName_t RegistrantName,
+                                           STEVT_EventConstant_t Event,
+                                           const STEVT_DeviceSubscribeParams_t *SubscribeParams,
+                                           const char *EventName);
+ST_ErrorCode_t STEVT_Unsubscribe (STEVT_Handle_t Handle,
+                                  STEVT_EventConstant_t Event);
+ST_ErrorCode_t STEVT_RegisterRelay(void *RelaySubscription_p);
+ST_ErrorCode_t STEVT_UnsubscribeDeviceEvent (STEVT_Handle_t Handle,
+                                             const ST_DeviceName_t RegistrantName,
+                                             STEVT_EventConstant_t Event);
+enum
+{
+    STAVMEM_ERROR_FUNCTION_NOT_IMPLEMENTED = (39 << 16),
+    STAVMEM_ERROR_MAX_PARTITION,
+    STAVMEM_ERROR_INVALID_PARTITION_HANDLE,
+    STAVMEM_ERROR_PARTITION_FULL,
+    STAVMEM_ERROR_CREATED_PARTITION,
+    STAVMEM_ERROR_MAX_BLOCKS,
+    STAVMEM_ERROR_INVALID_BLOCK_HANDLE,
+    STAVMEM_ERROR_ALLOCATED_BLOCK,
+    STAVMEM_ERROR_BLOCK_IN_FORBIDDEN_ZONE,
+    STAVMEM_ERROR_GPDMA_OPEN,
+    STAVMEM_ERROR_GPDMA_CLOSE
+};
+typedef enum STAVMEM_AllocMode_e
+{
+    STAVMEM_ALLOC_MODE_INVALID,
+    STAVMEM_ALLOC_MODE_RESERVED,
+    STAVMEM_ALLOC_MODE_FORBIDDEN,
+    STAVMEM_ALLOC_MODE_TOP_BOTTOM,
+    STAVMEM_ALLOC_MODE_BOTTOM_TOP
+} STAVMEM_AllocMode_t;
+typedef enum STAVMEM_DeviceType_e
+{
+    STAVMEM_DEVICE_TYPE_GENERIC,
+    STAVMEM_DEVICE_TYPE_VIRTUAL
+} STAVMEM_DeviceType_t;
+typedef struct STAVMEM_MemoryRange_s
+{
+    void *StartAddr_p;
+    void *StopAddr_p;
+} STAVMEM_MemoryRange_t;
+typedef struct STAVMEM_Capability_s
+{
+    U32 MaxPartition;
+    U32 *FillBlock1DPatternSize;
+    U32 FillBlock2DPatternHeight[2];
+    U32 *FillBlock2DPatternWidth;
+    BOOL IsCopyFillCapable;
+} STAVMEM_Capability_t;
+typedef struct STAVMEM_SharedMemoryVirtualMapping_s
+{
+    void * PhysicalAddressSeenFromCPU_p;
+    void * PhysicalAddressSeenFromDevice_p;
+    void * PhysicalAddressSeenFromDevice2_p;
+    void * VirtualBaseAddress_p;
+    U32 VirtualSize;
+    U32 VirtualWindowOffset;
+    U32 VirtualWindowSize;
+} STAVMEM_SharedMemoryVirtualMapping_t;
+typedef struct STAVMEM_InitParams_s
+{
+    STAVMEM_DeviceType_t DeviceType;
+    ST_Partition_t *CPUPartition_p;
+    ST_Partition_t *NCachePartition_p;
+    U32 MaxPartitions;
+    U32 MaxBlocks;
+    U32 MaxForbiddenRanges;
+    U32 MaxForbiddenBorders;
+    U32 MaxNumberOfMemoryMapRanges;
+    void *OptimisedMemAccessStrategy_p;
+    void *BlockMoveDmaBaseAddr_p;
+    void *CacheBaseAddr_p;
+    void *VideoBaseAddr_p;
+    STAVMEM_SharedMemoryVirtualMapping_t * SharedMemoryVirtualMapping_p;
+    void *SDRAMBaseAddr_p;
+    U32 SDRAMSize;
+    U32 NumberOfDCachedRanges;
+    STAVMEM_MemoryRange_t *DCachedRanges_p;
+    ST_DeviceName_t GpdmaName;
+} STAVMEM_InitParams_t;
+typedef struct STAVMEM_CreatePartitionParams_s
+{
+    U32 NumberOfPartitionRanges;
+    STAVMEM_MemoryRange_t * PartitionRanges_p;
+} STAVMEM_CreatePartitionParams_t;
+typedef struct STAVMEM_DeletePartitionParams_s
+{
+    BOOL ForceDelete;
+} STAVMEM_DeletePartitionParams_t;
+typedef U32 STAVMEM_PartitionHandle_t;
+typedef struct STAVMEM_TermParams_s
+{
+    BOOL ForceTerminate;
+} STAVMEM_TermParams_t;
+typedef U32 STAVMEM_BlockHandle_t;
+typedef struct STAVMEM_AllocBlockParams_s
+{
+    STAVMEM_PartitionHandle_t PartitionHandle;
+    U32 Size;
+    U32 Alignment;
+    STAVMEM_AllocMode_t AllocMode;
+    U32 NumberOfForbiddenRanges;
+    STAVMEM_MemoryRange_t *ForbiddenRangeArray_p;
+    U32 NumberOfForbiddenBorders;
+    void **ForbiddenBorderArray_p;
+} STAVMEM_AllocBlockParams_t;
+typedef void (*STAVMEM_PreserveDataFunction_t) (
+    void* SrcAddress_p,
+    void* DestAddress_p,
+    U32 Size
+);
+typedef struct STAVMEM_ReAllocBlockParams_s
+{
+    STAVMEM_PartitionHandle_t PartitionHandle;
+    U32 Size;
+    U32 NumberOfForbiddenRanges;
+    STAVMEM_MemoryRange_t *ForbiddenRangeArray_p;
+    U32 NumberOfForbiddenBorders;
+    void **ForbiddenBorderArray_p;
+    BOOL PreserveData;
+    STAVMEM_PreserveDataFunction_t PreserveDataFunction;
+} STAVMEM_ReAllocBlockParams_t;
+typedef struct STAVMEM_FreeBlockParams_s
+{
+    STAVMEM_PartitionHandle_t PartitionHandle;
+} STAVMEM_FreeBlockParams_t;
+typedef struct STAVMEM_BlockParams_s
+{
+    U32 Size;
+    void *StartAddr_p;
+    STAVMEM_AllocMode_t AllocMode;
+    U32 Alignment;
+} STAVMEM_BlockParams_t;
+typedef struct STAVMEM_BlockInfo_s
+{
+    STAVMEM_PartitionHandle_t PartitionHandle;
+    STAVMEM_BlockHandle_t BlockHandle;
+    ST_DeviceName_t AllocatorName;
+    STAVMEM_AllocMode_t AllocMode;
+    U32 StartAddress;
+    U32 Size;
+    U32 UserSize;
+    U32 Alignment;
+    U32 AlignedStartAddress;
+} STAVMEM_BlockInfo_t;
+extern STAVMEM_SharedMemoryVirtualMapping_t * STAVMEM_VIRTUAL_MAPPING_AUTO_P;
+ST_Revision_t STAVMEM_GetRevision(void);
+ST_ErrorCode_t STAVMEM_GetCapability(const ST_DeviceName_t DeviceName, STAVMEM_Capability_t * const Capability_p);
+ST_ErrorCode_t STAVMEM_Init(const ST_DeviceName_t DeviceName, const STAVMEM_InitParams_t * const InitParams_p);
+ST_ErrorCode_t STAVMEM_Term(const ST_DeviceName_t DeviceName, const STAVMEM_TermParams_t * const TermParams_p);
+ST_ErrorCode_t STAVMEM_GetFreeSize(const ST_DeviceName_t DeviceName, U32 *TotalFreeSize_p);
+ST_ErrorCode_t STAVMEM_GetSharedMemoryVirtualMapping(STAVMEM_SharedMemoryVirtualMapping_t * const SharedMemoryVirtualMapping_p);
+ST_ErrorCode_t STAVMEM_GetMemoryStatus(const ST_DeviceName_t DeviceName, char *buf, int *len, U8 PartitionIndex );
+ST_ErrorCode_t STAVMEM_CreatePartition(const ST_DeviceName_t DeviceName,
+                                       const STAVMEM_CreatePartitionParams_t *CreateParams_p,
+                                       STAVMEM_PartitionHandle_t *PartitionHandle_p);
+ST_ErrorCode_t STAVMEM_DeletePartition(const ST_DeviceName_t DeviceName,
+                                       const STAVMEM_DeletePartitionParams_t *DeleteParams_p,
+                                       STAVMEM_PartitionHandle_t *PartitionHandle_p);
+ST_ErrorCode_t STAVMEM_GetPartitionFreeSize(STAVMEM_PartitionHandle_t PartitionHandle, U32 *PartitionFreeSize_p);
+ST_ErrorCode_t STAVMEM_SetPartitionID(STAVMEM_PartitionHandle_t PartitionHandle, U32 PartitionID);
+STAVMEM_PartitionHandle_t STAVMEM_GetPartitionHandle(U32 PartitionID);
+ST_ErrorCode_t STAVMEM_AllocBlock(const STAVMEM_AllocBlockParams_t *AllocBlockParams_p, STAVMEM_BlockHandle_t *BlockHandle_p);
+ST_ErrorCode_t STAVMEM_ReAllocBlock(const STAVMEM_ReAllocBlockParams_t *ReAllocBlockParams_p, STAVMEM_BlockHandle_t *BlockHandle_p);
+ST_ErrorCode_t STAVMEM_FreeBlock(const STAVMEM_FreeBlockParams_t *FreeBlockParams_p, STAVMEM_BlockHandle_t *BlockHandle_p);
+ST_ErrorCode_t STAVMEM_GetBlockParams(STAVMEM_BlockHandle_t BlockHandle, STAVMEM_BlockParams_t *BlockParams_p);
+ST_ErrorCode_t STAVMEM_GetBlockAddress(STAVMEM_BlockHandle_t BlockHandle, void **Address_p);
+ST_ErrorCode_t STAVMEM_GetBlockAddressPhysical(STAVMEM_BlockHandle_t BlockHandle, void **Address_Phyp);
+ST_ErrorCode_t STAVMEM_GetBlockAddressCached(STAVMEM_BlockHandle_t BlockHandle, void **Address_Cp);
+ST_ErrorCode_t STAVMEM_GetBlockAddressUncached(STAVMEM_BlockHandle_t BlockHandle, void **Address_NCp);
+ST_ErrorCode_t STAVMEM_GetBlockAddressKernelUncached(STAVMEM_BlockHandle_t BlockHandle, void **Address_NCp);
+ST_ErrorCode_t STAVMEM_CopyBlock1D(void * const SrcAddress, void * const DestAddress, const U32 Size);
+ST_ErrorCode_t STAVMEM_CopyBlock2D(void * const SrcAddress, const U32 SrcWidth, const U32 SrcHeight, const U32 SrcPitch,
+                                   void * const DestAddress, const U32 DestPitch);
+ST_ErrorCode_t STAVMEM_FillBlock1D(void * const Pattern, const U32 PatternSize, void * const DestAddress, const U32 DestSize);
+ST_ErrorCode_t STAVMEM_FillBlock2D(void * const Pattern, const U32 PatternWidth, const U32 PatternHeight, const U32 PatternPitch,
+                                   void * const DestAddress, const U32 DestWidth, const U32 DestHeight, const U32 DestPitch);
+ST_ErrorCode_t STAVMEM_AllocBuffer( int PartitionNumber, U32 Size, U32 Alignment, void **BufferAddress_p );
+ST_ErrorCode_t STAVMEM_FreeBuffer( int PartitionNumber, void *BufferAddress_p );
+ST_ErrorCode_t STAVMEM_GetSharedMemoryVirtualMapping2( U32 PartitionID, STAVMEM_SharedMemoryVirtualMapping_t * const SharedMemoryVirtualMapping_p );
+ST_ErrorCode_t STAVMEM_GetBlockInfo( STAVMEM_PartitionHandle_t PartitionHandle
+                                   , STAVMEM_BlockInfo_t *BlockInfo_p
+                                   , U32 *NextValidBlock_p);
+typedef enum STGXOBJ_AspectRatio_e
+{
+  STGXOBJ_ASPECT_RATIO_16TO9 = 1,
+  STGXOBJ_ASPECT_RATIO_4TO3 = 2,
+  STGXOBJ_ASPECT_RATIO_221TO1= 3,
+  STGXOBJ_ASPECT_RATIO_SQUARE= 4,
+  STGXOBJ_ASPECT_RATIO_14TO9 = 5,
+  STGXOBJ_ASPECT_RATIO_EXTENDED_PAR = 99
+} STGXOBJ_AspectRatio_t;
+typedef enum STGXOBJ_BitmapType_e
+{
+  STGXOBJ_BITMAP_TYPE_RASTER_PROGRESSIVE,
+  STGXOBJ_BITMAP_TYPE_RASTER_TOP_BOTTOM,
+  STGXOBJ_BITMAP_TYPE_MB,
+  STGXOBJ_BITMAP_TYPE_MB_HDPIP,
+  STGXOBJ_BITMAP_TYPE_MB_TOP_BOTTOM,
+  STGXOBJ_BITMAP_TYPE_MB_RANGE_MAP,
+  STGXOBJ_BITMAP_TYPE_R2B_PROGRESSIVE
+}STGXOBJ_BitmapType_t;
+typedef enum STGXOBJ_ColorKeyType_e
+{
+  STGXOBJ_COLOR_KEY_TYPE_CLUT1,
+  STGXOBJ_COLOR_KEY_TYPE_CLUT8,
+  STGXOBJ_COLOR_KEY_TYPE_RGB888,
+  STGXOBJ_COLOR_KEY_TYPE_YCbCr888_SIGNED,
+  STGXOBJ_COLOR_KEY_TYPE_YCbCr888_UNSIGNED,
+  STGXOBJ_COLOR_KEY_TYPE_RGB565
+} STGXOBJ_ColorKeyType_t;
+typedef enum STGXOBJ_ColorSpaceConversionMode_e
+{
+    STGXOBJ_ITU_R_BT601,
+    STGXOBJ_ITU_R_BT709,
+    STGXOBJ_ITU_R_BT470_2_M,
+    STGXOBJ_ITU_R_BT470_2_BG,
+    STGXOBJ_SMPTE_170M,
+    STGXOBJ_SMPTE_240M,
+    STGXOBJ_FCC,
+    STGXOBJ_CONVERSION_MODE_UNKNOWN
+} STGXOBJ_ColorSpaceConversionMode_t;
+typedef enum STGXOBJ_ColorType_e
+{
+  STGXOBJ_COLOR_TYPE_ARGB8888,
+  STGXOBJ_COLOR_TYPE_RGB888,
+  STGXOBJ_COLOR_TYPE_ARGB8565,
+  STGXOBJ_COLOR_TYPE_RGB565,
+  STGXOBJ_COLOR_TYPE_ARGB1555,
+  STGXOBJ_COLOR_TYPE_ARGB4444,
+  STGXOBJ_COLOR_TYPE_CLUT8,
+  STGXOBJ_COLOR_TYPE_CLUT4,
+  STGXOBJ_COLOR_TYPE_CLUT2,
+  STGXOBJ_COLOR_TYPE_CLUT1,
+  STGXOBJ_COLOR_TYPE_ACLUT88,
+  STGXOBJ_COLOR_TYPE_ACLUT44,
+  STGXOBJ_COLOR_TYPE_SIGNED_YCBCR888_444,
+  STGXOBJ_COLOR_TYPE_UNSIGNED_YCBCR888_444,
+  STGXOBJ_COLOR_TYPE_SIGNED_YCBCR888_422,
+  STGXOBJ_COLOR_TYPE_UNSIGNED_YCBCR888_422,
+  STGXOBJ_COLOR_TYPE_SIGNED_YCBCR888_420,
+  STGXOBJ_COLOR_TYPE_UNSIGNED_YCBCR888_420,
+  STGXOBJ_COLOR_TYPE_UNSIGNED_AYCBCR6888_444,
+  STGXOBJ_COLOR_TYPE_SIGNED_AYCBCR8888,
+  STGXOBJ_COLOR_TYPE_UNSIGNED_AYCBCR8888,
+  STGXOBJ_COLOR_TYPE_ALPHA1,
+  STGXOBJ_COLOR_TYPE_ALPHA4,
+  STGXOBJ_COLOR_TYPE_ALPHA8,
+  STGXOBJ_COLOR_TYPE_BYTE,
+  STGXOBJ_COLOR_TYPE_ARGB8888_255,
+  STGXOBJ_COLOR_TYPE_ARGB8565_255,
+  STGXOBJ_COLOR_TYPE_ACLUT88_255,
+  STGXOBJ_COLOR_TYPE_ALPHA8_255,
+  STGXOBJ_COLOR_TYPE_ARGB6888,
+  STGXOBJ_COLOR_TYPE_ARGB6101010,
+  STGXOBJ_COLOR_TYPE_RGB101010
+} STGXOBJ_ColorType_t;
+typedef enum STGXOBJ_PaletteType_e
+{
+  STGXOBJ_PALETTE_TYPE_DEVICE_INDEPENDENT,
+  STGXOBJ_PALETTE_TYPE_DEVICE_DEPENDENT
+}STGXOBJ_PaletteType_t;
+typedef enum STGXOBJ_ScanType_e
+{
+    STGXOBJ_PROGRESSIVE_SCAN,
+    STGXOBJ_INTERLACED_SCAN
+} STGXOBJ_ScanType_t;
+typedef enum STGXOBJ_SubByteFormat_e
+{
+    STGXOBJ_SUBBYTE_FORMAT_RPIX_MSB = 0,
+    STGXOBJ_SUBBYTE_FORMAT_RPIX_LSB = 1
+}STGXOBJ_SubByteFormat_t;
+typedef enum STGXOBJ_HardUse_e
+{
+    STGXOBJ_NO_HARD = 0x00000000,
+    STGXOBJ_SUBPIC_CELL = 0x00000001,
+    STGXOBJ_STILLPIC_CELL = 0x00000002,
+    STGXOBJ_OSDFRAME_CELL = 0x00000004,
+    STGXOBJ_OSDTOP_BOT_CELL = 0x00000008,
+    STGXOBJ_GAMMA_BLITTER = 0x00000010,
+    STGXOBJ_SOFT_EMU_BLITTER = 0x00000020,
+    STGXOBJ_GAMMA_GDP_PIPELINE = 0x00000040,
+    STGXOBJ_GAMMA_BKL_PIPELINE = 0x00000080,
+    STGXOBJ_GAMMA_CURS_PIPELINE = 0x00000100
+}STGXOBJ_HardUse_t;
+typedef enum STGXOBJ_MPEGFrame_e
+{
+    STGXOBJ_MPEG_FRAME_I = 1,
+    STGXOBJ_MPEG_FRAME_P = 2,
+    STGXOBJ_MPEG_FRAME_B = 4
+} STGXOBJ_MPEGFrame_t;
+typedef struct STGXOBJ_PictureInfos_s
+{
+    struct
+    {
+        STGXOBJ_MPEGFrame_t MPEGFrame;
+    } VideoParams;
+} STGXOBJ_PictureInfos_t;
+typedef enum YUV_Scaling_s
+{
+    YUV_NO_RESCALE = 1,
+    YUV_HALF_VALUE,
+    YUV_RANGE_MAP_0,
+    YUV_RANGE_MAP_1,
+    YUV_RANGE_MAP_2,
+    YUV_RANGE_MAP_3,
+    YUV_RANGE_MAP_4,
+    YUV_RANGE_MAP_5,
+    YUV_RANGE_MAP_6,
+    YUV_RANGE_MAP_7
+} YUV_Scaling_t;
+typedef struct YUV_ScalingFactor_s
+{
+    YUV_Scaling_t ScalingFactorY;
+    YUV_Scaling_t ScalingFactorUV;
+} YUV_ScalingFactor_t;
+typedef struct STGXOBJ_Bitmap_s
+{
+  STGXOBJ_ColorType_t ColorType;
+  STGXOBJ_BitmapType_t BitmapType;
+  BOOL PreMultipliedColor;
+  STGXOBJ_ColorSpaceConversionMode_t ColorSpaceConversion;
+  STGXOBJ_AspectRatio_t AspectRatio;
+  U32 Width;
+  U32 Height;
+  U32 Pitch;
+  U32 Offset;
+  void* Data1_p;
+  void* Data1_Cp;
+  void* Data1_NCp;
+  U32 Size1;
+  void* Data2_p;
+  void* Data2_Cp;
+  void* Data2_NCp;
+  U32 Size2;
+  STGXOBJ_SubByteFormat_t SubByteFormat;
+  BOOL BigNotLittle;
+  U32 Pitch2;
+  U32 Offset2;
+  YUV_ScalingFactor_t YUVScaling;
+} STGXOBJ_Bitmap_t;
+typedef struct STGXOBJ_BitmapAllocParams_s
+{
+  STAVMEM_AllocBlockParams_t AllocBlockParams;
+  U32 Pitch;
+  U32 Offset;
+} STGXOBJ_BitmapAllocParams_t;
+typedef struct STGXOBJ_Capability_s
+{
+  char TBD;
+} STGXOBJ_Capability_t;
+typedef struct STGXOBJ_ColorACLUT_s
+{
+  U8 Alpha;
+  U8 PaletteEntry;
+} STGXOBJ_ColorACLUT_t;
+typedef struct STGXOBJ_ColorARGB_s
+{
+  U8 Alpha;
+  U8 R;
+  U8 G;
+  U8 B;
+} STGXOBJ_ColorARGB_t;
+typedef struct STGXOBJ_ColorKeyCLUT_s
+{
+  U8 PaletteEntryMin;
+  U8 PaletteEntryMax;
+  BOOL PaletteEntryOut;
+  BOOL PaletteEntryEnable;
+} STGXOBJ_ColorKeyCLUT_t;
+typedef struct STGXOBJ_ColorKeyRGB_s
+{
+  U8 RMin;
+  U8 RMax;
+  BOOL ROut;
+  BOOL REnable;
+  U8 GMin;
+  U8 GMax;
+  BOOL GOut;
+  BOOL GEnable;
+  U8 BMin;
+  U8 BMax;
+  BOOL BOut;
+  BOOL BEnable;
+} STGXOBJ_ColorKeyRGB_t;
+typedef struct STGXOBJ_ColorKeySignedYCbCr_s
+{
+  U8 YMin;
+  U8 YMax;
+  BOOL YOut;
+  BOOL YEnable;
+  S8 CbMin;
+  S8 CbMax;
+  BOOL CbOut;
+  BOOL CbEnable;
+  S8 CrMin;
+  S8 CrMax ;
+  BOOL CrOut;
+  BOOL CrEnable;
+} STGXOBJ_ColorKeySignedYCbCr_t;
+typedef struct STGXOBJ_ColorKeyUnsignedYCbCr_s
+{
+  U8 YMin;
+  U8 YMax;
+  BOOL YOut;
+  BOOL YEnable;
+  U8 CbMin;
+  U8 CbMax;
+  BOOL CbOut;
+  BOOL CbEnable;
+  U8 CrMin;
+  U8 CrMax ;
+  BOOL CrOut;
+  BOOL CrEnable;
+} STGXOBJ_ColorKeyUnsignedYCbCr_t;
+typedef union STGXOBJ_ColorKeyValue_u
+{
+  STGXOBJ_ColorKeyCLUT_t CLUT1;
+  STGXOBJ_ColorKeyCLUT_t CLUT8;
+  STGXOBJ_ColorKeyRGB_t RGB888;
+  STGXOBJ_ColorKeySignedYCbCr_t SignedYCbCr888;
+  STGXOBJ_ColorKeyUnsignedYCbCr_t UnsignedYCbCr888;
+  STGXOBJ_ColorKeyRGB_t RGB565;
+} STGXOBJ_ColorKeyValue_t;
+typedef struct STGXOBJ_ColorKey_s
+{
+  STGXOBJ_ColorKeyType_t Type;
+  STGXOBJ_ColorKeyValue_t Value;
+} STGXOBJ_ColorKey_t;
+typedef struct STGXOBJ_ColorRGB_s
+{
+  U8 R;
+  U8 G;
+  U8 B;
+} STGXOBJ_ColorRGB_t;
+typedef struct STGXOBJ_ColorSignedYCbCr_s
+{
+  U8 Y;
+  S8 Cb;
+  S8 Cr;
+} STGXOBJ_ColorSignedYCbCr_t;
+typedef struct STGXOBJ_ColorUnsignedYCbCr_s
+{
+  U8 Y;
+  U8 Cb;
+  U8 Cr;
+} STGXOBJ_ColorUnsignedYCbCr_t;
+typedef struct STGXOBJ_ColorSignedAYCbCr_s
+{
+  U8 Alpha;
+  U8 Y;
+  S8 Cb;
+  S8 Cr;
+} STGXOBJ_ColorSignedAYCbCr_t;
+typedef struct STGXOBJ_ColorUnsignedAYCbCr_s
+{
+  U8 Alpha;
+  U8 Y;
+  U8 Cb;
+  U8 Cr;
+} STGXOBJ_ColorUnsignedAYCbCr_t;
+typedef struct STGXOBJ_ColorRGBTen_s
+{
+  U16 Y;
+  U16 Cb;
+  U16 Cr;
+} STGXOBJ_ColorRGBTen_t;
+typedef struct STGXOBJ_ColorARGBTen_s
+{
+  U8 Alpha;
+  U16 Y;
+  U16 Cb;
+  U16 Cr;
+} STGXOBJ_ColorARGBTen_t;
+typedef union STGXOBJ_ColorValue_u
+{
+  STGXOBJ_ColorARGB_t ARGB8888;
+  STGXOBJ_ColorRGB_t RGB888;
+  STGXOBJ_ColorARGB_t ARGB8565;
+  STGXOBJ_ColorRGB_t RGB565;
+  STGXOBJ_ColorARGB_t ARGB1555;
+  STGXOBJ_ColorARGB_t ARGB4444;
+  STGXOBJ_ColorARGB_t ARGB6888;
+  STGXOBJ_ColorARGBTen_t ARGB6101010;
+  STGXOBJ_ColorRGBTen_t RGB101010;
+  U8 CLUT8;
+  U8 CLUT4;
+  U8 CLUT2;
+  U8 CLUT1;
+  STGXOBJ_ColorACLUT_t ACLUT88 ;
+  STGXOBJ_ColorACLUT_t ACLUT44 ;
+  STGXOBJ_ColorSignedYCbCr_t SignedYCbCr888_444;
+  STGXOBJ_ColorUnsignedYCbCr_t UnsignedYCbCr888_444;
+  STGXOBJ_ColorSignedYCbCr_t SignedYCbCr888_422;
+  STGXOBJ_ColorUnsignedYCbCr_t UnsignedYCbCr888_422;
+  STGXOBJ_ColorSignedYCbCr_t SignedYCbCr888_420;
+  STGXOBJ_ColorUnsignedYCbCr_t UnsignedYCbCr888_420;
+  STGXOBJ_ColorUnsignedAYCbCr_t UnsignedAYCbCr6888_444;
+  STGXOBJ_ColorSignedAYCbCr_t SignedAYCbCr8888;
+  STGXOBJ_ColorUnsignedAYCbCr_t UnsignedAYCbCr8888;
+  U8 ALPHA1;
+  U8 ALPHA4;
+  U8 ALPHA8;
+  U8 Byte;
+} STGXOBJ_ColorValue_t;
+typedef struct STGXOBJ_Color_s
+{
+  STGXOBJ_ColorType_t Type;
+  STGXOBJ_ColorValue_t Value;
+} STGXOBJ_Color_t;
+typedef struct STGXOBJ_Palette_s
+{
+  STGXOBJ_ColorType_t ColorType;
+  STGXOBJ_PaletteType_t PaletteType;
+  U8 ColorDepth;
+  void* Data_p;
+  void* Data_Cp;
+  void* Data_NCp;
+} STGXOBJ_Palette_t;
+typedef struct STGXOBJ_PaletteAllocParams_s
+{
+  STAVMEM_AllocBlockParams_t AllocBlockParams;
+} STGXOBJ_PaletteAllocParams_t;
+typedef struct STGXOBJ_Rectangle_s
+{
+  S32 PositionX;
+  S32 PositionY;
+  U32 Width;
+  U32 Height;
+} STGXOBJ_Rectangle_t;
+ST_ErrorCode_t STGXOBJ_ConvertPalette(
+  STGXOBJ_Palette_t* SrcPalette_p,
+  STGXOBJ_Palette_t* DstPalette_p,
+  STGXOBJ_ColorSpaceConversionMode_t ConvMode
+);
+ST_ErrorCode_t STGXOBJ_GetPaletteColor(
+  STGXOBJ_Palette_t* Palette_p,
+  U8 PaletteIndex,
+  STGXOBJ_Color_t* Color_p
+);
+ST_ErrorCode_t STGXOBJ_SetPaletteColor(
+  STGXOBJ_Palette_t* Palette_p,
+  U8 PaletteIndex,
+  STGXOBJ_Color_t* Color_p
+);
+ST_ErrorCode_t STGXOBJ_GetBitmapAllocParams(STGXOBJ_Bitmap_t* Bitmap_p,
+                                    STGXOBJ_HardUse_t HardUse,
+                                    STGXOBJ_BitmapAllocParams_t* Params1_p,
+                                    STGXOBJ_BitmapAllocParams_t* Params2_p);
+ST_ErrorCode_t STGXOBJ_GetPaletteAllocParams(STGXOBJ_Palette_t* Palette_p,
+                                        STGXOBJ_HardUse_t HardUse,
+                                        STGXOBJ_PaletteAllocParams_t* Params_p);
+ST_Revision_t STGXOBJ_GetRevision(void);
+enum
+{
+  STLAYER_ERROR_INVALID_INPUT_RECTANGLE = (158 << 16),
+  STLAYER_ERROR_INVALID_OUTPUT_RECTANGLE,
+  STLAYER_ERROR_NO_FREE_HANDLES,
+  STLAYER_SUCCESS_IORECTANGLES_ADJUSTED,
+  STLAYER_ERROR_IORECTANGLES_NOT_ADJUSTABLE,
+  STLAYER_ERROR_INVALID_LAYER_TYPE,
+  STLAYER_ERROR_USER_ALLOCATION_NOT_ALLOWED,
+  STLAYER_ERROR_OVERLAP_VIEWPORT,
+  STLAYER_ERROR_NO_AV_MEMORY ,
+  STLAYER_ERROR_OUT_OF_LAYER,
+  STLAYER_ERROR_OUT_OF_BITMAP,
+  STLAYER_ERROR_INSIDE_LAYER,
+  STLAYER_ERROR_EVENT_REGISTRATION
+};
+  typedef enum STLAYER_FlickerFilterMode_e
+{
+    STLAYER_FLICKER_FILTER_MODE_SIMPLE,
+    STLAYER_FLICKER_FILTER_MODE_ADAPTIVE,
+    STLAYER_FLICKER_FILTER_MODE_USING_BLITTER
+} STLAYER_FlickerFilterMode_t;
+enum
+{
+    STLAYER_UPDATE_PARAMS_EVT = (158 << 16),
+    STLAYER_UPDATE_DECIMATION_EVT,
+    STLAYER_NEW_FMD_REPORTED_EVT,
+    STLAYER_VSYNC_DISPLAY_SETTINGS_EVT,
+    STLAYER_TAKE_RELEASE_EVT,
+    STLAYER_DEVICE_INITIALIZED_EVT,
+    STLAYER_DEVICE_TERMINATED_EVT
+};
+typedef enum STLAYER_Layer_e
+{
+    STLAYER_GAMMA_CURSOR,
+    STLAYER_GAMMA_GDP,
+    STLAYER_GAMMA_BKL,
+    STLAYER_GAMMA_ALPHA,
+    STLAYER_GAMMA_FILTER,
+    STLAYER_OMEGA2_VIDEO1,
+    STLAYER_OMEGA2_VIDEO2,
+    STLAYER_7020_VIDEO1,
+    STLAYER_7020_VIDEO2,
+    STLAYER_OMEGA1_CURSOR,
+    STLAYER_OMEGA1_VIDEO,
+    STLAYER_OMEGA1_OSD,
+    STLAYER_OMEGA1_STILL,
+    STLAYER_SDDISPO2_VIDEO1,
+    STLAYER_SDDISPO2_VIDEO2,
+    STLAYER_HDDISPO2_VIDEO1,
+    STLAYER_HDDISPO2_VIDEO2,
+    STLAYER_DISPLAYPIPE_VIDEO1,
+    STLAYER_DISPLAYPIPE_VIDEO2,
+    STLAYER_DISPLAYPIPE_VIDEO3,
+    STLAYER_DISPLAYPIPE_VIDEO4,
+    STLAYER_DISPLAYPIPE_VIDEO5,
+    STLAYER_DISPLAYPIPE_VIDEO6,
+    STLAYER_HQVDP_VIDEO1,
+    STLAYER_VIRTUAL_VIDEOLAYER,
+    STLAYER_COMPOSITOR,
+    STLAYER_GAMMA_GDPVBI
+} STLAYER_Layer_t;
+typedef enum STLAYER_ViewPortSourceType_e
+{
+    STLAYER_GRAPHIC_BITMAP,
+    STLAYER_STREAMING_VIDEO
+} STLAYER_ViewPortSourceType_t;
+typedef enum STLAYER_CompressionLevel_e
+{
+    STLAYER_COMPRESSION_LEVEL_NONE = 1,
+    STLAYER_COMPRESSION_LEVEL_1 = 2,
+    STLAYER_COMPRESSION_LEVEL_2 = 4
+} STLAYER_CompressionLevel_t;
+typedef enum STLAYER_DecimationFactor_e
+{
+    STLAYER_DECIMATION_FACTOR_NONE = 0,
+    STLAYER_DECIMATION_FACTOR_2 = 1,
+    STLAYER_DECIMATION_FACTOR_4 = 2,
+    STLAYER_DECIMATION_MPEG4_P2 = 3,
+    STLAYER_DECIMATION_AVS = 4
+} STLAYER_DecimationFactor_t;
+typedef enum STLAYER_UpdateReason_e
+{
+    STLAYER_DISCONNECT_REASON = 0x01,
+    STLAYER_SCREEN_PARAMS_REASON = 0x02,
+    STLAYER_OFFSET_REASON = 0x04,
+    STLAYER_VTG_REASON = 0x08,
+    STLAYER_CHANGE_ID_REASON = 0x10,
+    STLAYER_DISPLAY_REASON = 0x20,
+    STLAYER_LAYER_PARAMS_REASON = 0x40,
+    STLAYER_DECIMATION_NEED_REASON = 0x80,
+    STLAYER_IMPOSSIBLE_WITH_PROFILE = 0x100,
+    STLAYER_CONNECT_REASON = 0x200,
+    STLAYER_DISABLE_MIXER_REASON = 0x400,
+    STLAYER_ENABLE_MIXER_REASON = 0x800
+}STLAYER_UpdateReason_t;
+typedef enum
+{
+    STLAYER_NORMAL_MODE,
+    STLAYER_SPECTACLE_MODE
+} STLAYER_OutputMode_t;
+typedef enum STLAYER_DeiMode_e
+{
+    STLAYER_DEI_MODE_OFF = 0,
+    STLAYER_DEI_MODE_AUTO,
+    STLAYER_DEI_MODE_BYPASS,
+    STLAYER_DEI_MODE_VERTICAL,
+    STLAYER_DEI_MODE_DIRECTIONAL,
+    STLAYER_DEI_MODE_FIELD_MERGING,
+    STLAYER_DEI_MODE_MEDIAN_FILTER,
+    STLAYER_DEI_MODE_MLD,
+    STLAYER_DEI_MODE_LMU,
+    STLAYER_DEI_MODE_YMLD_CDI,
+    STLAYER_DEI_MODE_FIELD_MERGING_WITH_PREVIOUS,
+    STLAYER_DEI_MODE_FIELD_MERGING_WITH_NEXT,
+    STLAYER_DEI_MODE_MAX
+} STLAYER_DeiMode_t;
+typedef U32 STLAYER_Handle_t;
+typedef U32 STLAYER_ViewPortHandle_t;
+typedef U32 STLAYER_PictureBufferHandle_t;
+typedef struct STLAYER_TakeReleaseParams_s
+{
+    BOOL DoTakeNotRelease;
+    STLAYER_PictureBufferHandle_t PictureBufferHandle;
+    U32 SourceBufferHandle;
+} STLAYER_TakeReleaseParams_t;
+typedef enum
+{
+    STLAYER_TOP_FIELD,
+    STLAYER_BOTTOM_FIELD
+} STLAYER_FieldType_t;
+typedef enum STLAYER_ProcessFlow_e
+{
+    STLAYER_VIEWPORT_INPUT,
+    STLAYER_VIEWPORT_OUTPUT
+} STLAYER_ProcessFlow_t;
+typedef enum STLAYER_GrabReleaseMode_e
+{
+    RELEASE_PREVIOUSLY_GRABBED,
+    RELEASE_NONE
+} STLAYER_GrabReleaseMode_t;
+typedef enum STLAYER_DecimationMode_e
+{
+    AUTOMATIC_DECIMATION,
+    FORCED_NO_DECIMATION,
+    FORCED_USE_DECIMATION
+} STLAYER_DecimationMode_t;
+typedef enum STLAYER_UnLockViewportMode_e
+{
+    STLAYER_AUTOMATIC_UNLOCK_WITH_NEW_PICTURE_RECEIVED,
+    STLAYER_MANUAL_UNLOCK
+} STLAYER_UnLockViewportMode_t;
+typedef struct STLAYER_Field_s
+{
+    BOOL FieldAvailable;
+    U32 PictureIndex;
+    STLAYER_PictureBufferHandle_t PictureBufferHandle;
+    U32 PictureSignature;
+    STLAYER_FieldType_t FieldType;
+    void * Data1_p;
+    void * Data2_p;
+} STLAYER_Field_t;
+typedef struct STLAYER_PictureID_s
+{
+    S32 ID;
+    U32 IDExtension;
+} STLAYER_PictureID_t;
+typedef struct STLAYER_3D_Properties_s
+{
+    ST_MM_3D_Format_t Video3DFormat;
+    BOOL Frame0IsLeft;
+    U16 Frame0GridPosition_x;
+    U16 Frame1GridPosition_x;
+    U16 Frame0GridPosition_y;
+    U16 Frame1GridPosition_y;
+    BOOL Frame0Flipping;
+    BOOL Frame1Flipping;
+    BOOL IsFlat3DRequested;
+} STLAYER_3D_Properties_t;
+typedef struct STLAYER_StreamingVideo_s
+{
+    U32 SourceNumber;
+    U32 SourceBufferHandle;
+    STGXOBJ_Bitmap_t BitmapParams;
+    STGXOBJ_ScanType_t ScanType;
+    U32 SrcFrameRate;
+    BOOL PresentedFieldInverted;
+    STLAYER_CompressionLevel_t CompressionLevel;
+    STLAYER_DecimationFactor_t AvailableHorizontalDecimationFactor;
+    STLAYER_DecimationFactor_t AvailableVerticalDecimationFactor;
+    STLAYER_DecimationFactor_t HorizontalDecimationFactor;
+    STLAYER_DecimationFactor_t VerticalDecimationFactor;
+    STLAYER_3D_Properties_t VideoStream3DProperties;
+    BOOL AdvancedHDecimation;
+    BOOL PeriodicFieldInversionDueToFRC;
+    STLAYER_PictureID_t ExtendedPresentationOrderPictureID;
+    U32 PictureSignature;
+    STLAYER_Field_t PreviousField;
+    STLAYER_Field_t CurrentField;
+    STLAYER_Field_t NextField;
+    BOOL IsAsynchronousProgramming;
+    BOOL DisplayDirectionHasChanged;
+    BOOL SrcDiscontinuity;
+    BOOL IsPanoramicModeRequested;
+    U32 CEHRegisters[32];
+} STLAYER_StreamingVideo_t;
+typedef struct STLAYER_ViewPortSource_s
+{
+    STLAYER_ViewPortSourceType_t SourceType;
+    union
+    {
+        STGXOBJ_Bitmap_t * BitMap_p;
+        STLAYER_StreamingVideo_t * VideoStream_p;
+    } Data;
+    STGXOBJ_Palette_t * Palette_p;
+} STLAYER_ViewPortSource_t;
+typedef struct STLAYER_AllocParams_s
+{
+    U32 ViewPortDescriptorsBufferSize;
+    BOOL ViewPortNodesInSharedMemory;
+    U32 ViewPortNodesBufferSize;
+    U32 ViewPortNodesBufferAlignment;
+} STLAYER_AllocParams_t;
+typedef struct STLAYER_Capability_s
+{
+    STLAYER_Layer_t LayerType;
+    U32 DeviceId;
+    BOOL MultipleViewPorts;
+    BOOL HorizontalResizing;
+    BOOL AlphaBorder;
+    BOOL GlobalAlpha;
+    BOOL ColorKeying;
+    BOOL MultipleViewPortsOnScanLineCapable;
+    BOOL PSI;
+    U8 FrameBufferDisplayLatency;
+    U8 FrameBufferHoldTime;
+} STLAYER_Capability_t;
+typedef struct STLAYER_GainParams_s
+{
+    U8 BlackLevel;
+    U8 GainLevel;
+} STLAYER_GainParams_t;
+typedef struct STLAYER_GlobalAlpha_s
+{
+    U8 A0;
+    U8 A1;
+} STLAYER_GlobalAlpha_t;
+typedef struct STLAYER_LayerParams_s
+{
+    U32 Width;
+    U32 Height;
+    STGXOBJ_AspectRatio_t AspectRatio;
+    STGXOBJ_ScanType_t ScanType;
+}STLAYER_LayerParams_t;
+typedef enum
+{
+    FILTERSET_LEGACY=0,
+    FILTERSET_SHARP,
+    FILTERSET_MEDIUM,
+    FILTERSET_SMOOTH,
+    FILTERSET_LAST
+} STLAYER_ZoomFilterSet_t;
+typedef struct STLAYER_InitParams_s
+{
+    STLAYER_Layer_t LayerType;
+    ST_Partition_t * CPUPartition_p;
+    BOOL CPUBigEndian;
+    void * DeviceBaseAddress_p;
+    void * BaseAddress_p;
+    void * BaseAddress2_p;
+    void * SharedMemoryBaseAddress_p;
+    U32 MaxHandles;
+    STAVMEM_PartitionHandle_t AVMEM_Partition;
+    ST_DeviceName_t EventHandlerName;
+    ST_DeviceName_t InterruptEventName;
+    STEVT_EventConstant_t VideoDisplayInterrupt;
+    U32 MaxViewPorts;
+    void * ViewPortNodeBuffer_p;
+    BOOL NodeBufferUserAllocated;
+    void * ViewPortBuffer_p;
+    BOOL ViewPortBufferUserAllocated;
+    STLAYER_LayerParams_t * LayerParams_p;
+} STLAYER_InitParams_t;
+typedef struct STLAYER_OpenParams_s
+{
+    U32 Dummy;
+} STLAYER_OpenParams_t;
+typedef struct STLAYER_OutputParams_s
+{
+    STLAYER_UpdateReason_t UpdateReason;
+    STGXOBJ_AspectRatio_t AspectRatio;
+    STGXOBJ_ScanType_t ScanType;
+    U32 FrameRate;
+    U32 Width;
+    U32 Height;
+    U32 XStart;
+    U32 YStart;
+    S8 XOffset;
+    S8 YOffset;
+    ST_DeviceName_t VTGName;
+    U32 DeviceId;
+    BOOL DisplayEnable;
+    STLAYER_Handle_t BackLayerHandle;
+    STLAYER_Handle_t FrontLayerHandle;
+    U32 DisplayHandle;
+    U8 FrameBufferDisplayLatency;
+    U8 FrameBufferHoldTime;
+}STLAYER_OutputParams_t;
+typedef enum STLAYER_VideoFiltering_s
+{
+    STLAYER_VIDEO_CHROMA_AUTOFLESH,
+    STLAYER_VIDEO_CHROMA_GREENBOOST,
+    STLAYER_VIDEO_CHROMA_TINT,
+    STLAYER_VIDEO_CHROMA_SAT,
+    STLAYER_VIDEO_LUMA_EDGE_REPLACEMENT,
+    STLAYER_VIDEO_LUMA_PEAKING,
+    STLAYER_VIDEO_LUMA_DCI,
+    STLAYER_VIDEO_LUMA_BC,
+    STLAYER_ZOOM_FILTERSET,
+    STLAYER_VIDEO_IQI_LTI,
+    STLAYER_VIDEO_IQI_CTI,
+    STLAYER_VIDEO_IQI_PEAKING,
+    STLAYER_VIDEO_IQI_LUMA_ENHANCER,
+    STLAYER_VIDEO_IQI_DEMO_MODE,
+    STLAYER_VIDEO_COLORBOOST,
+    STLAYER_MAX_VIDEO_FILTER_POSITION
+} STLAYER_VideoFiltering_t;
+typedef enum STLAYER_VideoFilteringControl_s
+{
+    STLAYER_DISABLE,
+    STLAYER_ENABLE_AUTO_MODE1,
+    STLAYER_ENABLE_AUTO_MODE2,
+    STLAYER_ENABLE_AUTO_MODE3,
+    STLAYER_ENABLE_MANUAL
+} STLAYER_VideoFilteringControl_t;
+typedef enum STLAYER_ContrastAutoCurve_s
+{
+    STLAYER_CONTRAST_PPLCE,
+    STLAYER_CONTRAST_DUALSEG
+} STLAYER_ContrastAutoCurve_t;
+typedef enum
+{
+    STLAYER_COMPOSITION_RECURRENCE_EVERY_VSYNC,
+    STLAYER_COMPOSITION_RECURRENCE_MANUAL_OR_VIEWPORT_PARAMS_CHANGES
+} STLAYER_CompositionRecurrence_t;
+typedef struct STLAYER_AutoFleshParameters_s {
+    U32 AutoFleshControl;
+    enum {
+        LARGE_WIDTH,
+        MEDIUM_WIDTH,
+        SMALL_WIDTH
+    } QuadratureFleshWidthControl;
+    enum {
+        AXIS_116_6,
+        AXIS_121_0,
+        AXIS_125_5,
+        AXIS_130_2
+    } AutoFleshAxisControl;
+} STLAYER_AutoFleshParameters_t;
+typedef struct STLAYER_GreenBoostParameters_s {
+    S32 GreenBoostControl;
+} STLAYER_GreenBoostParameters_t;
+typedef struct STLAYER_TintRotationControl_s {
+    S32 TintRotationControl;
+} STLAYER_TintParameters_t;
+typedef struct STLAYER_SatParameters_s {
+    S32 SaturationGainControl;
+} STLAYER_SatParameters_t;
+typedef struct STLAYER_ColorBoostParameters_s {
+    S32 RedBoost;
+    S32 GreenBoost;
+    S32 BlueBoost;
+} STLAYER_ColorBoostParameters_t;
+typedef struct STLAYER_EdgeReplacementParameters_s {
+    U32 GainControl;
+    enum {
+        HIGH_FREQ_FILTER = 1,
+        MEDIUM_FREQ_FILTER,
+        LOW_FREQ_FILTER
+    } FrequencyControl;
+} STLAYER_EdgeReplacementParameters_t;
+typedef struct STLAYER_PeakingParameters_s {
+    S32 VerticalPeakingGainControl;
+    U32 CoringForVerticalPeaking;
+    S32 HorizontalPeakingGainControl;
+    U32 CoringForHorizontalPeaking;
+    U32 HorizontalPeakingFilterSelection;
+    BOOL SINECompensationEnable;
+} STLAYER_PeakingParameters_t;
+typedef struct STLAYER_DCIParameters{
+    U32 CoringLevelGainControl;
+    U32 FirstPixelAnalysisWindow;
+    U32 LastPixelAnalysisWindow;
+    U32 FirstLineAnalysisWindow;
+    U32 LastLineAnalysisWindow;
+} STLAYER_DCIParameters_t;
+typedef struct STLAYER_BrightnessContrastParameters_s {
+    S32 BrightnessGainControl;
+    U32 ContrastGainControl;
+} STLAYER_BrightnessContrastParameters_t;
+typedef struct STLAYER_ZoomFilterSetParameters_s {
+    STLAYER_ZoomFilterSet_t ZoomFilterSet;
+} STLAYER_ZoomFilterSetParameters_t;
+typedef struct STLAYER_PictureInfos_s
+{
+    STGXOBJ_Bitmap_t BitmapParams;
+    STLAYER_DecimationFactor_t HorizontalDecimationFactor;
+    STLAYER_DecimationFactor_t VerticalDecimationFactor;
+    BOOL AdvancedHDecimation;
+    STLAYER_PictureID_t ExtendedPresentationOrderPictureID;
+    STGXOBJ_ScanType_t ScanType;
+    STLAYER_FieldType_t FieldType;
+    U32 PictureSignature;
+    STLAYER_PictureBufferHandle_t PictureBufferHandle;
+} STLAYER_PictureInfos_t;
+typedef enum
+{
+    STLAYER_IQI_PeakingFreq_0_15_FsDiv2 = 0,
+    STLAYER_IQI_PeakingFreq_0_18_FsDiv2,
+    STLAYER_IQI_PeakingFreq_0_22_FsDiv2,
+    STLAYER_IQI_PeakingFreq_0_26_FsDiv2,
+    STLAYER_IQI_PeakingFreq_0_30_FsDiv2,
+    STLAYER_IQI_PeakingFreq_0_34_FsDiv2,
+    STLAYER_IQI_PeakingFreq_0_37_FsDiv2,
+    STLAYER_IQI_PeakingFreq_0_40_FsDiv2,
+    STLAYER_IQI_PeakingFreq_0_44_FsDiv2,
+    STLAYER_IQI_PeakingFreq_0_48_FsDiv2,
+    STLAYER_IQI_PeakingFreq_0_51_FsDiv2,
+    STLAYER_IQI_PeakingFreq_0_55_FsDiv2,
+    STLAYER_IQI_PeakingFreq_0_58_FsDiv2,
+    STLAYER_IQI_PeakingFreq_0_63_FsDiv2,
+    STLAYER_IQI_PeakingFreq_Nb
+} STLAYER_IQI_PeakingFrequency_t;
+typedef enum
+{
+    STLAYER_IQI_PeakingNoclipping=0,
+    STLAYER_IQI_PeakingSoftClipping1=1,
+    STLAYER_IQI_PeakingSoftClipping2=2,
+    STLAYER_IQI_PeakingClippingCurvesNumber=3
+} STLAYER_IQI_PeakingClippingParameters_t;
+ typedef enum
+{
+    STLAYER_IQI_PeakingGain_6_0db_neg=0,
+    STLAYER_IQI_PeakingGain_5_5db_neg=1,
+    STLAYER_IQI_PeakingGain_5_0db_neg=2,
+    STLAYER_IQI_PeakingGain_4_5db_neg=3,
+    STLAYER_IQI_PeakingGain_4_0db_neg=4,
+    STLAYER_IQI_PeakingGain_3_5db_neg=5,
+    STLAYER_IQI_PeakingGain_3_0db_neg=6,
+    STLAYER_IQI_PeakingGain_2_5db_neg=7,
+    STLAYER_IQI_PeakingGain_2_0db_neg=8,
+    STLAYER_IQI_PeakingGain_1_5db_neg=9,
+    STLAYER_IQI_PeakingGain_1_0db_neg=10,
+    STLAYER_IQI_PeakingGain_0_5db_neg=11,
+    STLAYER_IQI_PeakingGain_0_0db_pos=12,
+    STLAYER_IQI_PeakingGain_0_5db_pos=13,
+    STLAYER_IQI_PeakingGain_1_0db_pos=14,
+    STLAYER_IQI_PeakingGain_1_5db_pos=15,
+    STLAYER_IQI_PeakingGain_2_0db_pos=16,
+    STLAYER_IQI_PeakingGain_2_5db_pos=17,
+    STLAYER_IQI_PeakingGain_3_0db_pos=18,
+    STLAYER_IQI_PeakingGain_3_5db_pos=19,
+    STLAYER_IQI_PeakingGain_4_0db_pos=20,
+    STLAYER_IQI_PeakingGain_4_5db_pos=21,
+    STLAYER_IQI_PeakingGain_5_0db_pos=22,
+    STLAYER_IQI_PeakingGain_5_5db_pos=23,
+    STLAYER_IQI_PeakingGain_6_0db_pos=24,
+    STLAYER_IQI_PeakingGain_6_5db_pos=25,
+    STLAYER_IQI_PeakingGain_7_0db_pos=26,
+    STLAYER_IQI_PeakingGain_7_5db_pos=27,
+    STLAYER_IQI_PeakingGain_8_0db_pos=28,
+    STLAYER_IQI_PeakingGain_8_5db_pos=29,
+    STLAYER_IQI_PeakingGain_9_0db_pos=30,
+    STLAYER_IQI_PeakingGain_9_5db_pos=31,
+    STLAYER_IQI_PeakingGain_10_0db_pos=32,
+    STLAYER_IQI_PeakingGain_10_5db_pos=33,
+    STLAYER_IQI_PeakingGain_11_0db_pos=34,
+    STLAYER_IQI_PeakingGain_11_5db_pos=35,
+    STLAYER_IQI_PeakingGain_12_0db_pos=36,
+    STLAYER_IQI_PeakingGainMax
+} STLAYER_IQI_PeakingGain_t;
+typedef enum
+{
+    STLAYER_IQI_PeakingFactor_1_00=0,
+    STLAYER_IQI_PeakingFactor_0_75=1,
+    STLAYER_IQI_PeakingFactor_0_50=2,
+    STLAYER_IQI_PeakingFactor_0_25=3
+} STLAYER_IQI_PeakingFactor_t;
+typedef enum
+{
+    STLAYER_IQI_LtiSelectiveEdgeOff=0,
+    STLAYER_IQI_LtiSelectiveEdgeMin=1,
+    STLAYER_IQI_LtiSelectiveEdgeMed=2,
+    STLAYER_IQI_LtiSelectiveEdgeMax=3
+} STLAYER_IQI_LtiSelectiveEdge_t;
+typedef enum
+{
+    STLAYER_IQI_LtiPreFilterOff=0,
+    STLAYER_IQI_LtiWeakPreFiltering=1,
+    STLAYER_IQI_LtiStrongPreFilter=2
+} STLAYER_IQI_LtiEdgePrefilter_t;
+typedef struct STLAYER_IQI_DemoParameters_s
+{
+    BOOL IsLTIDemoEnabled;
+    BOOL IsCTIDemoEnabled;
+    BOOL IsLEDemoEnabled;
+    BOOL IsPeakingDemoEnabled;
+    U16 DemoWindowStartPercent;
+    U16 DemoWindowEndPercent;
+} STLAYER_IQI_DemoParameters_t;
+typedef struct STLAYER_IQI_PeakingParameters_s
+{
+    STLAYER_IQI_PeakingGain_t HorGainBandPass;
+    STLAYER_IQI_PeakingGain_t HorGainHighPass;
+    STLAYER_IQI_PeakingGain_t VerticalGain;
+    BOOL IsVerticalPeakingEnabled;
+    U8 CoringLevel;
+    BOOL IsCoringModeChromaAdaptative;
+    STLAYER_IQI_PeakingFactor_t Overshoot;
+    STLAYER_IQI_PeakingFactor_t Undershoot;
+    STLAYER_IQI_PeakingClippingParameters_t ClippingMode;
+    STLAYER_IQI_PeakingFrequency_t BandPassFilterCenterFrequency;
+    STLAYER_IQI_PeakingFrequency_t HighPassFilterCutoffFrequency;
+} STLAYER_IQI_PeakingParameters_t;
+typedef struct STLAYER_IQI_LEFixedCurve_s
+{
+    U16 BlackStretchInflexionPoint;
+    U8 BlackStretchGain;
+    U16 BlackStretchLimitPoint;
+    U16 WhiteStretchInflexionPoint;
+    U8 WhiteStretchGain;
+    U16 WhiteStretchLimitPoint;
+} STLAYER_IQI_LEFixedCurve_t;
+typedef struct STLAYER_IQI_LEAutoCurve_s
+{
+    U8 BlackStretchGain;
+    U16 BlackStretchLimitPoint;
+    U8 WhiteStretchGain;
+    U16 WhiteStretchLimitPoint;
+} STLAYER_IQI_LEAutoCurve_t;
+typedef struct STLAYER_IQI_LEParameters_s
+{
+    U8 CSCGain;
+    BOOL IsFixedCurveEnabled;
+    STLAYER_IQI_LEFixedCurve_t FixedCurveParams;
+    BOOL IsCustomCurveEnabled;
+    const S16 *CustomCurveData_p;
+    BOOL IsAutoCurveEnabled;
+    STLAYER_ContrastAutoCurve_t AutoCurveType;
+    STLAYER_IQI_LEAutoCurve_t AutoCurveParams;
+    U8 AutoCurveCSCGain;
+} STLAYER_IQI_LEParameters_t;
+typedef struct STLAYER_IQI_LTIParameters_s
+{
+    STLAYER_IQI_LtiSelectiveEdge_t SelectiveEdgeMode;
+    BOOL IsAntiAliasingEnabled;
+    STLAYER_IQI_LtiEdgePrefilter_t EdgePrefilterMode;
+    BOOL IsVerticalLtiEnabled;
+    U8 HorLtiStrength;
+    U8 VerLtiStrength;
+} STLAYER_IQI_LTIParameters_t;
+typedef struct STLAYER_IQI_CTIParameters_s
+{
+    U8 CtiStrength1;
+    U8 CtiStrength2;
+} STLAYER_IQI_CTIParameters_t;
+typedef union STLAYER_VideoFilteringParameters_s
+{
+    STLAYER_AutoFleshParameters_t AutoFleshParameters;
+    STLAYER_GreenBoostParameters_t GreenBoostParameters;
+    STLAYER_TintParameters_t TintParameters;
+    STLAYER_SatParameters_t SatParameters;
+    STLAYER_EdgeReplacementParameters_t EdgeReplacementParameters;
+    STLAYER_PeakingParameters_t PeakingParameters;
+    STLAYER_DCIParameters_t DCIParameters;
+    STLAYER_BrightnessContrastParameters_t BCParameters;
+    STLAYER_ZoomFilterSetParameters_t ZoomFilterSetParameters;
+    STLAYER_IQI_LTIParameters_t LTIParameters;
+    STLAYER_IQI_CTIParameters_t CTIParameters;
+    STLAYER_IQI_LEParameters_t LEParameters;
+    STLAYER_IQI_PeakingParameters_t IQIPeakingParameters;
+    STLAYER_IQI_DemoParameters_t IQIDemoParameters;
+    STLAYER_ColorBoostParameters_t ColorBoostParameters;
+} STLAYER_VideoFilteringParameters_t;
+typedef struct STLAYER_PSI_s
+{
+  STLAYER_VideoFiltering_t VideoFiltering;
+  STLAYER_VideoFilteringControl_t VideoFilteringControl;
+  STLAYER_VideoFilteringParameters_t VideoFilteringParameters;
+} STLAYER_PSI_t;
+typedef struct
+{
+    U16 NumberOfZone;
+    U16 * SizeOfZone_p;
+    U16 EffectControl;
+} STLAYER_SpectacleModeParams_t;
+typedef union
+{
+    STLAYER_SpectacleModeParams_t SpectacleModeParams;
+} STLAYER_OutputWindowSpecialModeParams_t;
+typedef struct STLAYER_TermParams_s
+{
+    BOOL ForceTerminate;
+} STLAYER_TermParams_t;
+typedef struct STLAYER_QualityOptimizations_s
+{
+    BOOL DoForceStartOnEvenLine;
+    BOOL DoNotRescaleForZoomCloseToUnity;
+} STLAYER_QualityOptimizations_t;
+typedef struct STLAYER_ViewPortParams_s
+{
+    STLAYER_ViewPortSource_t * Source_p;
+    STGXOBJ_Rectangle_t InputRectangle;
+    STGXOBJ_Rectangle_t OutputRectangle;
+} STLAYER_ViewPortParams_t;
+typedef struct STLAYER_ViewPortLayerInfo_s
+{
+    STLAYER_Layer_t LayerType;
+    ST_DeviceName_t LayerName;
+} STLAYER_ViewPortLayerInfo_t;
+typedef struct STLAYER_FMDParams_s
+{
+    U32 SceneChangeDetectionThreshold;
+    U32 RepeatFieldDetectionThreshold;
+    U32 PixelMoveDetectionThreshold;
+    U32 BlockMoveDetectionThreshold;
+    U32 CFDThreshold;
+} STLAYER_FMDParams_t;
+typedef struct STLAYER_FMDResults_s
+{
+    U32 PictureIndex;
+    U32 FieldRepeatCount;
+    U32 FieldSum;
+    U32 CFDSum;
+    U32 SceneCount;
+    BOOL MoveStatus;
+    BOOL RepeatStatus;
+} STLAYER_FMDResults_t;
+typedef struct STLAYER_VTGParams_s
+{
+    ST_DeviceName_t VTGName;
+    U32 VTGFrameRate;
+} STLAYER_VTGParams_t;
+typedef struct STLAYER_UpdateParams_s
+{
+    STLAYER_UpdateReason_t UpdateReason;
+    STLAYER_LayerParams_t * LayerParams_p;
+    STLAYER_VTGParams_t VTGParams;
+    ST_DeviceName_t VTG_Name;
+    BOOL IsDecimationNeeded;
+    STLAYER_DecimationFactor_t RecommendedVerticalDecimation;
+    STLAYER_DecimationFactor_t RecommendedHorizontalDecimation;
+    U32 StreamWidth;
+    U32 StreamHeight;
+    struct
+    {
+        U32 FrameBufferDisplayLatency;
+        U32 FrameBufferHoldTime;
+    } DisplayParamsForVideo;
+} STLAYER_UpdateParams_t;
+typedef struct STLAYER_AllocDataParams_s
+{
+    U32 Size;
+    U32 Alignment;
+} STLAYER_AllocDataParams_t;
+ST_ErrorCode_t STLAYER_MapAddress( void *KernelAddress_p, void **UserAddress_p );
+ST_ErrorCode_t STLAYER_AllocData( STLAYER_Handle_t LayerHandle, STLAYER_AllocDataParams_t *Params_p, void **Address_p );
+ST_ErrorCode_t STLAYER_AllocDataSecure( STLAYER_Handle_t LayerHandle, STLAYER_AllocDataParams_t *Params_p, void **Address_p );
+ST_ErrorCode_t STLAYER_FreeData( STLAYER_Handle_t LayerHandle, void *Address_p );
+U32 *STLAYER_UserToKernel( U32 VirtUserAddress_p );
+U32 *STLAYER_KernelToUser( U32 VirtKernelAddress_p );
+ST_ErrorCode_t STLAYER_GetCapability(const ST_DeviceName_t DeviceName,
+                                     STLAYER_Capability_t * const Capability);
+ST_ErrorCode_t STLAYER_GetInitAllocParams(STLAYER_Layer_t LayerType,
+                                          U32 ViewPortsNumber,
+                                          STLAYER_AllocParams_t * Params);
+ST_Revision_t STLAYER_GetRevision(void);
+ST_ErrorCode_t STLAYER_Init(const ST_DeviceName_t DeviceName,
+                            const STLAYER_InitParams_t * const InitParams_p);
+ST_ErrorCode_t STLAYER_Term(const ST_DeviceName_t DeviceName,
+                            const STLAYER_TermParams_t * const TermParams_p);
+ST_ErrorCode_t STLAYER_Open(const ST_DeviceName_t DeviceName,
+                            const STLAYER_OpenParams_t * const Params,
+                            STLAYER_Handle_t * Handle);
+ST_ErrorCode_t STLAYER_Close(STLAYER_Handle_t Handle);
+ST_ErrorCode_t STLAYER_GetLayerParams(STLAYER_Handle_t Handle,
+        STLAYER_LayerParams_t * LayerParams_p);
+ST_ErrorCode_t STLAYER_SetLayerParams(STLAYER_Handle_t Handle,
+        STLAYER_LayerParams_t * LayerParams_p);
+ST_ErrorCode_t STLAYER_OpenViewPort(
+  STLAYER_Handle_t LayerHandle,
+  STLAYER_ViewPortParams_t* Params,
+  STLAYER_ViewPortHandle_t* VPHandle);
+ST_ErrorCode_t STLAYER_CloseViewPort(STLAYER_ViewPortHandle_t VPHandle);
+ST_ErrorCode_t STLAYER_EnableViewPort(STLAYER_ViewPortHandle_t VPHandle);
+ST_ErrorCode_t STLAYER_DisableViewPort(STLAYER_ViewPortHandle_t VPHandle);
+ST_ErrorCode_t STLAYER_LockViewPort(STLAYER_ViewPortHandle_t VPHandle, STLAYER_UnLockViewportMode_t UnLockViewportMode,
+                                    STAVMEM_PartitionHandle_t PicturePartitionHandle, STAVMEM_BlockHandle_t PictureBlockHandle);
+ST_ErrorCode_t STLAYER_UnLockViewPort(STLAYER_ViewPortHandle_t VPHandle);
+ST_ErrorCode_t STLAYER_AdjustViewPortParams(
+  STLAYER_Handle_t LayerHandle,
+  STLAYER_ViewPortParams_t* Params_p
+);
+ST_ErrorCode_t STLAYER_GetViewPortLayerInformation(
+  const STLAYER_ViewPortHandle_t VPHandle,
+  STLAYER_ViewPortLayerInfo_t * ViewPortLayerInfo_p);
+ST_ErrorCode_t STLAYER_SetViewPortParams(
+  const STLAYER_ViewPortHandle_t VPHandle,
+  STLAYER_ViewPortParams_t* Params_p
+);
+ST_ErrorCode_t STLAYER_GetViewPortParams(
+  const STLAYER_ViewPortHandle_t VPHandle,
+  STLAYER_ViewPortParams_t* Params_p
+);
+ST_ErrorCode_t STLAYER_SetViewPortSource(
+  STLAYER_ViewPortHandle_t VPHandle,
+  STLAYER_ViewPortSource_t* VPSource
+);
+ST_ErrorCode_t STLAYER_GetViewPortSource(
+  STLAYER_ViewPortHandle_t VPHandle,
+  STLAYER_ViewPortSource_t* VPSource
+);
+ST_ErrorCode_t STLAYER_SetViewPortIORectangle(
+  STLAYER_ViewPortHandle_t VPHandle,
+  STGXOBJ_Rectangle_t* InputRectangle,
+  STGXOBJ_Rectangle_t* OutputRectangle
+);
+ST_ErrorCode_t STLAYER_AdjustIORectangle(
+  STLAYER_Handle_t Handle,
+  STGXOBJ_Rectangle_t* InputRectangle,
+  STGXOBJ_Rectangle_t* OutputRectangle
+);
+ST_ErrorCode_t STLAYER_GetViewPortIORectangle(
+  STLAYER_ViewPortHandle_t VPHandle,
+  STGXOBJ_Rectangle_t* InputRectangle,
+  STGXOBJ_Rectangle_t* OutputRectangle
+);
+ST_ErrorCode_t STLAYER_SetViewPortPosition(
+  STLAYER_ViewPortHandle_t VPHandle,
+  S32 XPosition,
+  S32 YPosition
+);
+ST_ErrorCode_t STLAYER_GetViewPortPosition(
+  STLAYER_ViewPortHandle_t VPHandle,
+  S32* XPosition,
+  S32* YPosition
+);
+ST_ErrorCode_t STLAYER_DisableColorKey(STLAYER_ViewPortHandle_t VPHandle);
+ST_ErrorCode_t STLAYER_EnableColorKey(STLAYER_ViewPortHandle_t VPHandle);
+ST_ErrorCode_t STLAYER_SetViewPortColorKey(
+  STLAYER_ViewPortHandle_t VPHandle,
+  STGXOBJ_ColorKey_t* ColorKey
+);
+ST_ErrorCode_t STLAYER_GetViewPortColorKey(
+  STLAYER_ViewPortHandle_t VPHandle,
+  STGXOBJ_ColorKey_t* ColorKey
+);
+ST_ErrorCode_t STLAYER_DisableBorderAlpha(STLAYER_ViewPortHandle_t VPHandle);
+ST_ErrorCode_t STLAYER_EnableBorderAlpha(STLAYER_ViewPortHandle_t VPHandle);
+ST_ErrorCode_t STLAYER_GetViewPortAlpha(
+  STLAYER_ViewPortHandle_t VPHandle,
+  STLAYER_GlobalAlpha_t* Alpha
+);
+ST_ErrorCode_t STLAYER_SetViewPortAlpha(
+  STLAYER_ViewPortHandle_t VPHandle,
+  STLAYER_GlobalAlpha_t* Alpha
+);
+ST_ErrorCode_t STLAYER_SetViewPortGain(
+  STLAYER_ViewPortHandle_t VPHandle,
+  STLAYER_GainParams_t* Params
+);
+ST_ErrorCode_t STLAYER_GetViewPortGain(
+  STLAYER_ViewPortHandle_t VPHandle,
+  STLAYER_GainParams_t* Params
+);
+ST_ErrorCode_t STLAYER_SetViewPortRecordable(STLAYER_ViewPortHandle_t VPHandle,
+                                             BOOL Recordable);
+ST_ErrorCode_t STLAYER_GetViewPortRecordable(STLAYER_ViewPortHandle_t VPHandle,
+                                             BOOL * Recordable_p);
+ST_ErrorCode_t STLAYER_GetBitmapAllocParams(
+  STLAYER_Handle_t LayerHandle,
+  STGXOBJ_Bitmap_t* Bitmap_p,
+  STGXOBJ_BitmapAllocParams_t* Params1_p,
+  STGXOBJ_BitmapAllocParams_t* Params2_p
+);
+ST_ErrorCode_t STLAYER_GetBitmapHeaderSize(
+  STLAYER_Handle_t LayerHandle,
+  STGXOBJ_Bitmap_t* Bitmap_p,
+  U32 * HeaderSize_p
+);
+ST_ErrorCode_t STLAYER_GetPaletteAllocParams(
+  STLAYER_Handle_t LayerHandle,
+  STGXOBJ_Palette_t* Palette_p,
+  STGXOBJ_PaletteAllocParams_t* Params_p
+);
+ST_ErrorCode_t STLAYER_GetVTGName(
+  STLAYER_Handle_t LayerHandle,
+  ST_DeviceName_t * const VTGName_p
+);
+ST_ErrorCode_t STLAYER_DisableViewPortFilter(STLAYER_ViewPortHandle_t VPHandle);
+ST_ErrorCode_t STLAYER_EnableViewPortFilter(STLAYER_ViewPortHandle_t VPHandle,
+                                            STLAYER_Handle_t FilterHandle);
+ST_ErrorCode_t STLAYER_AttachAlphaViewPort(STLAYER_ViewPortHandle_t VPHandle,
+                                           STLAYER_Handle_t MaskedLayer);
+ST_ErrorCode_t STLAYER_GetViewPortFlickerFilterMode(
+    STLAYER_ViewPortHandle_t VPHandle,
+    STLAYER_FlickerFilterMode_t* FlickerFilterMode_p);
+ST_ErrorCode_t STLAYER_SetViewPortFlickerFilterMode(
+    STLAYER_ViewPortHandle_t VPHandle,
+    STLAYER_FlickerFilterMode_t FlickerFilterMode);
+ST_ErrorCode_t STLAYER_DisableViewportColorFill(STLAYER_ViewPortHandle_t VPHandle);
+ST_ErrorCode_t STLAYER_EnableViewportColorFill(STLAYER_ViewPortHandle_t VPHandle);
+ST_ErrorCode_t STLAYER_SetViewportColorFill(
+  STLAYER_ViewPortHandle_t VPHandle,
+  STGXOBJ_ColorARGB_t* ColorFill
+);
+ST_ErrorCode_t STLAYER_GetViewportColorFill(
+  STLAYER_ViewPortHandle_t VPHandle,
+  STGXOBJ_ColorARGB_t* ColorFill
+);
+ST_ErrorCode_t STLAYER_GrabAndTakePictureBuffer(
+    const STLAYER_ViewPortHandle_t VPHandle,
+    const STLAYER_ProcessFlow_t GrabLocation,
+    const STLAYER_GrabReleaseMode_t GrabReleaseMode,
+    STLAYER_PictureInfos_t * const PictureInfos_p
+);
+ST_ErrorCode_t STLAYER_ReleasePictureBuffer(
+    const STLAYER_ViewPortHandle_t VPHandle,
+    const STLAYER_PictureBufferHandle_t PictureBufferHandle
+);
+ST_ErrorCode_t STLAYER_SetViewPortDecimationMode(
+    const STLAYER_ViewPortHandle_t VPHandle,
+    STLAYER_DecimationMode_t DecimationMode
+);
+ST_ErrorCode_t STLAYER_GetViewPortDecimationMode(
+    const STLAYER_ViewPortHandle_t VPHandle,
+    STLAYER_DecimationMode_t *DecimationMode_p
+);
+ST_ErrorCode_t STLAYER_UpdateFromMixer(
+  STLAYER_Handle_t LayerHandle,
+  STLAYER_OutputParams_t * OutputParams_p
+);
+ST_ErrorCode_t STLAYER_SetViewPortCompositionRecurrence(STLAYER_ViewPortHandle_t VPHandle,
+                                                  const STLAYER_CompositionRecurrence_t CompositionRecurrence);
+ST_ErrorCode_t STLAYER_PerformViewPortComposition(STLAYER_ViewPortHandle_t VPHandle);
+ST_ErrorCode_t STLAYER_InformPictureToBeDecoded(
+  const STLAYER_ViewPortHandle_t VPHandle,
+  STGXOBJ_PictureInfos_t* PictureInfos_p
+);
+ST_ErrorCode_t STLAYER_CommitViewPortParams(STLAYER_ViewPortHandle_t VPHandle);
+ST_ErrorCode_t STLAYER_GetVTGParams(
+  STLAYER_Handle_t LayerHandle,
+  STLAYER_VTGParams_t * const VTGParams_p
+);
+ST_ErrorCode_t STLAYER_SetViewPortPSI(
+  STLAYER_ViewPortHandle_t VPHandle,
+  STLAYER_PSI_t* VPPSI_p
+);
+ST_ErrorCode_t STLAYER_GetViewPortPSI(
+  STLAYER_ViewPortHandle_t VPHandle,
+  STLAYER_PSI_t* VPPSI_p
+);
+ST_ErrorCode_t STLAYER_SetViewPortSpecialMode (
+  const STLAYER_ViewPortHandle_t VPHandle,
+  const STLAYER_OutputMode_t OuputMode,
+  const STLAYER_OutputWindowSpecialModeParams_t * const Params_p);
+ST_ErrorCode_t STLAYER_GetViewPortSpecialMode (
+  const STLAYER_ViewPortHandle_t VPHandle,
+  STLAYER_OutputMode_t * const OuputMode_p,
+  STLAYER_OutputWindowSpecialModeParams_t * const Params_p);
+typedef enum
+{
+    VHSRC_FILTER_NONE,
+    VHSRC_FILTER_A,
+    VHSRC_FILTER_B,
+    VHSRC_FILTER_C,
+    VHSRC_FILTER_D,
+    VHSRC_FILTER_E,
+    VHSRC_FILTER_F,
+    VHSRC_FILTER_G,
+    VHSRC_FILTER_H,
+    VHSRC_FILTER_I,
+    VHSRC_FILTER_J,
+    VHSRC_FILTER_K,
+    VHSRC_FILTER_L,
+    VHSRC_FILTER_CHRX2
+} STLAYER_VHSRCFilter_t;
+typedef struct STLAYER_VHSRCHorizontalParams_s
+{
+    U32 Increment;
+    U32 InitialPhase;
+    U32 PixelRepeat;
+} STLAYER_VHSRCHorizontalParams_t;
+typedef struct STLAYER_VHSRCVerticalParams_s
+{
+    U32 Increment;
+    U32 InitialPhase;
+    U32 LineRepeat;
+} STLAYER_VHSRCVerticalParams_t;
+typedef struct STLAYER_VHSRCParams_s
+{
+   STLAYER_VHSRCHorizontalParams_t LumaHorizontal;
+   STLAYER_VHSRCHorizontalParams_t ChromaHorizontal;
+   STLAYER_VHSRCVerticalParams_t LumaTop;
+   STLAYER_VHSRCVerticalParams_t ChromaTop;
+   STLAYER_VHSRCVerticalParams_t LumaBot;
+   STLAYER_VHSRCVerticalParams_t ChromaBot;
+} STLAYER_VHSRCParams_t;
+typedef struct STLAYER_VHSRCVideoDisplayFilters_s
+{
+    STLAYER_ZoomFilterSet_t CurrentFilterSet;
+    STLAYER_VHSRCFilter_t LumaHorizontalCoefType;
+    STLAYER_VHSRCFilter_t ChromaHorizontalCoefType;
+    STLAYER_VHSRCFilter_t LumaVerticalCoefType;
+    STLAYER_VHSRCFilter_t ChromaVerticalCoefType;
+} STLAYER_VHSRCVideoDisplayFilters_t;
+typedef struct STLAYER_VHSRCViewportParams_s
+{
+   STGXOBJ_Rectangle_t LumaViewport;
+   STGXOBJ_Rectangle_t ChromaViewport;
+} STLAYER_VHSRCViewportParams_t;
+typedef struct STLAYER_MemoryStacks_s
+{
+    U32 YF_STACK_l0;
+    U32 YF_STACK_l1;
+    U32 YF_STACK_l2;
+    U32 YF_STACK_l3;
+    U32 YF_STACK_l4;
+    U32 YF_STACK_p0;
+    U32 YF_STACK_p1;
+    U32 YF_STACK_p2;
+    U32 CF_STACK_l0;
+    U32 CF_STACK_l1;
+    U32 CF_STACK_l2;
+    U32 CF_STACK_l3;
+    U32 CF_STACK_l4;
+    U32 CF_STACK_p0;
+    U32 CF_STACK_p1;
+    U32 CF_STACK_p2;
+    U32 MF_STACK_l0;
+    U32 MF_STACK_p0;
+} STLAYER_MemoryStacks_t;
+typedef struct STLAYER_FmdData_s
+{
+    U32 FieldSum;
+    U32 CFDSum;
+} STLAYER_FmdData_t;
+typedef enum STLAYER_DisplayParamsMode_e
+{
+    STLAYER_DISPLAYPARAMS_AUTO,
+    STLAYER_DISPLAYPARAMS_STATIC_MANUAL,
+    STLAYER_DISPLAYPARAMS_FULL_MANUAL
+} STLAYER_DisplayParamsMode_t;
+typedef enum STLAYER_DisplayType_e
+{
+    STLAYER_SDDISPO2_DISPLAY,
+    STLAYER_VDP_DISPLAY,
+    STLAYER_VIRTUAL_DISPLAY,
+    STLAYER_HQVDP_DISPLAY
+} STLAYER_DisplayType_t;
+typedef struct STLAYER_SDDISPO2_VideoDisplayParams_s
+{
+    STLAYER_VHSRCParams_t VHSRCparams;
+    STLAYER_VHSRCVideoDisplayFilters_t VHSRCVideoDisplayFilters;
+    STLAYER_VHSRCViewportParams_t VHSRCViewportParams;
+} STLAYER_SDDISPO2_VideoDisplayParams_t;
+typedef struct STLAYER_CRCData_s
+{
+    U32 Y;
+    U32 Cb;
+    U32 Cr;
+    BOOL IsValid;
+} STLAYER_CRCData_t;
+typedef struct STLAYER_CRCDecode_s
+{
+    U32 LumaCRC;
+    U32 ChromaCRC;
+} STLAYER_CRCDecode_t;
+typedef struct STLAYER_DEIParams_s
+{
+    STGXOBJ_Rectangle_t DEIViewport;
+} STLAYER_DEIParams_t;
+typedef struct STLAYER_VDP_VideoDisplayParams_s
+{
+    STLAYER_VHSRCParams_t VHSRCparams;
+    STLAYER_VHSRCVideoDisplayFilters_t VHSRCVideoDisplayFilters;
+    STLAYER_MemoryStacks_t Stacks;
+    STLAYER_FmdData_t FmdData;
+    STLAYER_CRCData_t MisrCRCData;
+    STLAYER_CRCDecode_t CRCDecode;
+    STLAYER_DEIParams_t DEIparams;
+} STLAYER_VDP_VideoDisplayParams_t;
+typedef struct STLAYER_HQVDPCommand_s
+{
+    struct
+    {
+        U32 Config;
+        U32 MemFormat;
+        U32 CurrentLuma;
+        U32 CurrentChroma;
+        U32 OutputData;
+        U32 LumaSrcPitch;
+        U32 ChromaSrcPitch;
+        U32 ProcessedPitch;
+        U32 InputFrameSize;
+        U32 InputViewportOri;
+        U32 InputViewportSize;
+        U32 CrcResetCtrl;
+    } Top;
+    struct
+    {
+        U32 CtrlPrvCsdi;
+        U32 CtrlCurCsdi;
+        U32 CtrlNxtCsdi;
+        U32 CtrlCurFmd;
+        U32 CtrlNxtFmd;
+    } Vc1re;
+    struct
+    {
+        U32 Config;
+        U32 ViewportOri;
+        U32 ViewportSize;
+        U32 NextNextLuma;
+        U32 NextNextNextLuma;
+        U32 ThresholdScd;
+        U32 ThresholdRfd;
+        U32 ThresholdMove;
+        U32 ThresholdCfd;
+    } Fmd;
+    struct
+    {
+        U32 Config;
+        U32 Config2;
+        U32 DcdiConfig;
+        U32 PrevLuma;
+        U32 NextLuma;
+        U32 PrevChroma;
+        U32 NextChroma;
+        U32 PrevMotion;
+        U32 CurMotion;
+        U32 NextMotion;
+        U32 LfmMap;
+    } Csdi;
+    struct
+    {
+        U32 HorPanoramicCtrl;
+        U32 OutputPictureSize;
+        U32 InitPhaseCtrl;
+        U32 FilteringCtrl;
+        U32 ParamCtrl;
+    } Hqr;
+    struct
+    {
+        U32 Config;
+        U32 DemoWindSize;
+        U32 PkConfig;
+        U32 Coeff0Coeff1;
+        U32 Coeff2Coeff3;
+        U32 Coeff4;
+        U32 PkLut;
+        U32 PkGain;
+        U32 PkCoringLevel;
+        U32 LtiConfig;
+        U32 LtiThreshold;
+        U32 LtiDeltaSlope;
+        U32 CtiConfig;
+        U32 LeConfig;
+        U32 LeLut[64];
+        U32 ConBri;
+        U32 SatGain;
+        U32 PxfConf;
+        U32 DefaultColor;
+    } Iqi;
+    struct
+    {
+        U32 InputYCrc;
+        U32 InputUvCrc;
+    } TopStatus;
+    struct
+    {
+        U32 FmdRepeatMoveStatus;
+        U32 FmdSceneCountStatus;
+        U32 CfdSum;
+        U32 FieldSum;
+        U32 NextYFmdCrc;
+        U32 NextNextYFmdCrc;
+        U32 NextNextNextYFmdCrc;
+    } FmdStatus;
+    struct
+    {
+        U32 PrevYCsdiCrc;
+        U32 CurYCsdiCrc;
+        U32 NextYCsdiCrc;
+        U32 PrevUvCsdiCrc;
+        U32 CurUvCsdiCrc;
+        U32 NextUvCsdiCrc;
+        U32 YCsdiCrc;
+        U32 UvCsdiCrc;
+        U32 UvCupCrc;
+        U32 MotCsdiCrc;
+        U32 MotCurCsdiCrc;
+        U32 MotPrevCsdiCrc;
+    } CsdiStatus;
+    struct
+    {
+        U32 YHqrCrc;
+        U32 UHqrCrc;
+        U32 VHqrCrc;
+    } HqrStatus;
+    struct
+    {
+        U32 PxfItStatus;
+        U32 YIqiCrc;
+        U32 UIqiCrc;
+        U32 VIqiCrc;
+    } IqiStatus;
+} STLAYER_HQVDPCommand_t;
+typedef struct STLAYER_HQVDP_VideoDisplayParams_s
+{
+    STLAYER_HQVDPCommand_t CurrentCmd;
+    STLAYER_ZoomFilterSet_t CurrentFilterSet;
+    STLAYER_CRCData_t MisrCRCData;
+} STLAYER_HQVDP_VideoDisplayParams_t;
+typedef struct STLAYER_VIRTLAY_VideoDisplayParams_s
+{
+    U32 ViewportId;
+} STLAYER_VIRTLAY_VideoDisplayParams_t;
+typedef struct STLAYER_VideoDisplayParams_s
+{
+    STGXOBJ_Rectangle_t InputRectangle;
+    STGXOBJ_Rectangle_t OutputRectangle;
+    STLAYER_DecimationFactor_t VerticalDecimFactor;
+    STLAYER_DecimationFactor_t HorizontalDecimFactor;
+    STLAYER_DeiMode_t DeiMode;
+    STGXOBJ_ScanType_t SourceScanType;
+    STGXOBJ_BitmapType_t BitmapType;
+    STLAYER_DisplayParamsMode_t DisplayParamsMode;
+    STLAYER_DisplayType_t DisplayType;
+    union
+    {
+        STLAYER_SDDISPO2_VideoDisplayParams_t SDDispo2Params;
+        STLAYER_VDP_VideoDisplayParams_t VDPParams;
+        STLAYER_HQVDP_VideoDisplayParams_t HQVDPParams;
+        STLAYER_VIRTLAY_VideoDisplayParams_t VIRTLAYParams;
+   } TypeData;
+} STLAYER_VideoDisplayParams_t;
+typedef struct STLAYER_DisplaySettings_s
+{
+    STLAYER_Layer_t LayerType;
+    BOOL IsLayerOnMainDisplay;
+    STLAYER_Field_t PresentedField;
+    BOOL IsVSyncTop;
+    BOOL DoesFieldPolarityMatch;
+    STLAYER_VideoDisplayParams_t VideoDisplayParams;
+    STLAYER_PictureID_t PictureID;
+    U32 PictureIndex;
+    U32 PictureSignature;
+    U32 PrevPictureSignature;
+    U32 NextPictureSignature;
+    STLAYER_FieldType_t PrevFieldType;
+    STLAYER_FieldType_t CurFieldType;
+    STLAYER_FieldType_t NextFieldType;
+    BOOL IsNewPicturePresented;
+} STLAYER_DisplaySettings_t;
+ST_ErrorCode_t STLAYER_GetVideoDisplayParams(STLAYER_ViewPortHandle_t VPHandle,
+                                    STLAYER_VideoDisplayParams_t * Params_p);
+ST_ErrorCode_t STLAYER_SetVideoDisplayParams(STLAYER_ViewPortHandle_t VPHandle,
+                                    const STLAYER_VideoDisplayParams_t * Params_p);
+typedef enum STPTI_ErrorType_s
+{
+    STPTI_ERROR_ALREADY_WAITING_ON_SLOT = ((13 << 16) + 1),
+    STPTI_ERROR_ALT_OUT_ALREADY_IN_USE,
+    STPTI_ERROR_ALT_OUT_TYPE_NOT_SUPPORTED,
+    STPTI_ERROR_BUFFER_NOT_LINKED,
+    STPTI_ERROR_CAROUSEL_ALREADY_ALLOCATED,
+    STPTI_ERROR_CAROUSEL_ENTRY_INSERTED,
+    STPTI_ERROR_CAROUSEL_LOCKED_BY_DIFFERENT_SESSION,
+    STPTI_ERROR_CAROUSEL_NOT_LOCKED,
+    STPTI_ERROR_CAROUSEL_OUTPUT_ONLY_ON_NULL_SLOT,
+    STPTI_ERROR_COLLECT_FOR_ALT_OUT_ONLY_ON_NULL_SLOT,
+    STPTI_ERROR_CORRUPT_DATA_IN_BUFFER,
+    STPTI_ERROR_DESCRAMBLER_ALREADY_ASSOCIATED,
+    STPTI_ERROR_DESCRAMBLER_NOT_ASSOCIATED,
+    STPTI_ERROR_DESCRAMBLER_TYPE_NOT_SUPPORTED,
+    STPTI_ERROR_DMA_UNAVAILABLE,
+    STPTI_ERROR_ENTRY_ALREADY_INSERTED,
+    STPTI_ERROR_ENTRY_IN_USE,
+    STPTI_ERROR_ENTRY_NOT_IN_CAROUSEL,
+    STPTI_ERROR_EVENT_QUEUE_EMPTY,
+    STPTI_ERROR_EVENT_QUEUE_FULL,
+    STPTI_ERROR_FILTER_ALREADY_ASSOCIATED,
+    STPTI_ERROR_FLUSH_FILTERS_NOT_SUPPORTED,
+    STPTI_ERROR_FUNCTION_NOT_SUPPORTED,
+    STPTI_ERROR_INCOMPLETE_PES_IN_BUFFER,
+    STPTI_ERROR_INCOMPLETE_SECTION_IN_BUFFER,
+    STPTI_ERROR_INDEX_INVALID_ASSOCIATION,
+    STPTI_ERROR_INDEX_INVALID_HANDLE,
+    STPTI_ERROR_INDEX_NONE_FREE,
+    STPTI_ERROR_INDEX_NOT_ASSOCIATED,
+    STPTI_ERROR_INDEX_PID_ALREADY_ASSOCIATED,
+    STPTI_ERROR_INDEX_SLOT_ALREADY_ASSOCIATED,
+    STPTI_ERROR_INTERRUPT_QUEUE_EMPTY,
+    STPTI_ERROR_INTERRUPT_QUEUE_FULL,
+    STPTI_ERROR_INVALID_ALLOW_OUTPUT_TYPE,
+    STPTI_ERROR_INVALID_ALTERNATE_OUTPUT_TYPE,
+    STPTI_ERROR_INVALID_BUFFER_HANDLE,
+    STPTI_ERROR_INVALID_CAROUSEL_ENTRY_HANDLE,
+    STPTI_ERROR_INVALID_CAROUSEL_HANDLE,
+    STPTI_ERROR_INVALID_CD_FIFO_ADDRESS,
+    STPTI_ERROR_INVALID_DESCRAMBLER_ASSOCIATION,
+    STPTI_ERROR_INVALID_DESCRAMBLER_HANDLE,
+    STPTI_ERROR_INVALID_DEVICE,
+    STPTI_ERROR_INVALID_TCLOADER,
+    STPTI_ERROR_INVALID_FILTER_DATA,
+    STPTI_ERROR_INVALID_FILTER_HANDLE,
+    STPTI_ERROR_INVALID_FILTER_OPERATING_MODE,
+    STPTI_ERROR_INVALID_FILTER_REPEAT_MODE,
+    STPTI_ERROR_INVALID_FILTER_TYPE,
+    STPTI_ERROR_INVALID_INJECTION_TYPE,
+    STPTI_ERROR_INVALID_KEY_USAGE,
+    STPTI_ERROR_INVALID_LOADER_OPTIONS,
+    STPTI_ERROR_INVALID_PARITY,
+    STPTI_ERROR_INVALID_PES_START_CODE,
+    STPTI_ERROR_INVALID_PID,
+    STPTI_ERROR_INVALID_SESSION_HANDLE,
+    STPTI_ERROR_INVALID_SIGNAL_HANDLE,
+    STPTI_ERROR_INVALID_SLOT_HANDLE,
+    STPTI_ERROR_INVALID_SLOT_TYPE,
+    STPTI_ERROR_INVALID_SUPPORTED_TC_CODE,
+    STPTI_ERROR_NOT_ALLOCATED_IN_SAME_SESSION,
+    STPTI_ERROR_NOT_INITIALISED,
+    STPTI_ERROR_NOT_ON_SAME_DEVICE,
+    STPTI_ERROR_NOT_SUPPORTED_FOR_DTV,
+    STPTI_ERROR_NO_FREE_DESCRAMBLERS,
+    STPTI_ERROR_NO_FREE_DMAS,
+    STPTI_ERROR_NO_FREE_FILTERS,
+    STPTI_ERROR_NO_FREE_SLOTS,
+    STPTI_ERROR_NO_PACKET,
+    STPTI_ERROR_OFFSET_EXCEEDS_PACKET_SIZE,
+    STPTI_ERROR_ONLY_ONE_SIGNAL_PER_BUFFER,
+    STPTI_ERROR_ONLY_ONE_SIGNAL_PER_SLOT,
+    STPTI_ERROR_PID_ALREADY_COLLECTED,
+    STPTI_ERROR_SET_MATCH_ACTION_NOT_SUPPORTED,
+    STPTI_ERROR_SIGNAL_ABORTED,
+    STPTI_ERROR_SIGNAL_EVERY_PACKET_ONLY_ON_PES_SLOT,
+    STPTI_ERROR_SLOT_FLAG_NOT_SUPPORTED,
+    STPTI_ERROR_SLOT_NOT_ASSOCIATED,
+    STPTI_ERROR_SLOT_NOT_RAW_MODE,
+    STPTI_ERROR_SLOT_NOT_SIGNAL_EVERY_PACKET,
+    STPTI_ERROR_STORE_LAST_HEADER_ONLY_ON_RAW_SLOT,
+    STPTI_ERROR_UNABLE_TO_ENABLE_FILTERS,
+    STPTI_ERROR_USER_BUFFER_NOT_ALIGNED,
+    STPTI_ERROR_WILDCARD_PID_ALREADY_SET,
+    STPTI_ERROR_WILDCARD_PID_NOT_SUPPORTED,
+    STPTI_ERROR_SLOT_ALREADY_LINKED,
+    STPTI_ERROR_NOT_A_MANUAL_BUFFER,
+    STPTI_ERROR_CAROUSEL_ENTRY_ALREADY_ALLOCATED,
+    STPTI_ERROR_IOREMAPFAILED,
+    STPTI_ERROR_FRONTEND_ALREADY_LINKED,
+    STPTI_ERROR_FRONTEND_NOT_LINKED,
+    STPTI_ERROR_INVALID_FRONTEND_TYPE,
+    STPTI_ERROR_INVALID_STREAM_ID,
+    STPTI_ERROR_FILTER_NOT_ASSOCIATED,
+    STPTI_ERROR_CAROUSEL_ALREADY_LOCKED_BY_THIS_SESSION,
+    STPTI_ERROR_CAROUSEL_REMOVE_ENTRY_FAILED,
+    STPTI_ERROR_CAROUSEL_ALREADY_LINKED_TO_BUFFER,
+    STPTI_ERROR_CAROUSEL_NOT_LINKED_TO_BUFFER,
+    STPTI_ERROR_ENTRY_REPEAT_MODE_MAX_REACHED,
+    STPTI_ERROR_CAROUSEL_ONLY_ONE_ENTRY_PER_SLOT,
+    STPTI_ERROR_TOO_MANY_SECONDARY_PIDS,
+    STPTI_ERROR_SLOT_NOT_LINKED,
+    STPTI_ERROR_END
+}STPTI_ErrorType_t;
+typedef enum STPTI_Event_s
+{
+    STPTI_EVENT_BUFFER_OVERFLOW_EVT = (13 << 16),
+    STPTI_EVENT_CAROUSEL_ENTRY_COMPLETE_EVT,
+    STPTI_EVENT_CAROUSEL_ENTRY_TIMEOUT_EVT,
+    STPTI_EVENT_CAROUSEL_CYCLE_COMPLETE_EVT,
+    STPTI_EVENT_CC_ERROR_EVT,
+    STPTI_EVENT_CLEAR_TO_SCRAMBLED_EVT,
+    STPTI_EVENT_CWP_BLOCK_EVT,
+    STPTI_EVENT_DMA_COMPLETE_EVT,
+    STPTI_EVENT_INDEX_MATCH_EVT,
+    STPTI_EVENT_INTERRUPT_FAIL_EVT,
+    STPTI_EVENT_INVALID_DESCRAMBLE_KEY_EVT,
+    STPTI_EVENT_INVALID_LINK_EVT,
+    STPTI_EVENT_INVALID_PARAMETER_EVT,
+    STPTI_EVENT_PACKET_ERROR_EVT,
+    STPTI_EVENT_PCR_RECEIVED_EVT,
+    STPTI_EVENT_SCRAMBLED_TO_CLEAR_EVT,
+    STPTI_EVENT_SECTIONS_DISCARDED_ON_CRC_CHECK_EVT,
+    STPTI_EVENT_TC_CODE_FAULT_EVT,
+    STPTI_EVENT_PES_ERROR_EVT,
+    STPTI_EVENT_BUFFER_LEVEL_CHANGE_EVT,
+    STPTI_EVENT_INVALID_SECONDARY_PACKET_EVT,
+    STPTI_EVENT_MARKER_ERROR_EVT,
+    STPTI_EVENT_END
+}STPTI_Event_t;
+typedef enum STPTI_CDReqLine_s
+{
+    STPTI_CDREQ_UNUSED = 0,
+    STPTI_CDREQ_VIDEO,
+    STPTI_CDREQ_AUDIO,
+    STPTI_CDREQ_SUBP,
+    STPTI_CDREQ_PCMO,
+    STPTI_CDREQ_PCMI,
+    STPTI_CDREQ_SWTS,
+    STPTI_CDREQ_EXT_0,
+    STPTI_CDREQ_EXT_1,
+    STPTI_CDREQ_EXT_2,
+    STPTI_CDREQ_EXT_3,
+    STPTI_CDREQ_EXT_4,
+    STPTI_CDREQ_EXT_5,
+    STPTI_CDREQ_EXT_6,
+    STPTI_CDREQ_VIDEO2,
+    STPTI_CDREQ_AUDIO2,
+    STPTI_CDREQ_AUDIO3
+}STPTI_CDReqLine_t;
+typedef enum STPTI_Timer_s
+{
+    STPTI_AUDIO_TIMER0,
+    STPTI_VIDEO_TIMER0
+} STPTI_Timer_t;
+typedef enum STPTI_AlternateOutputType_s
+{
+    STPTI_ALTERNATE_OUTPUT_TYPE_NO_OUTPUT,
+    STPTI_ALTERNATE_OUTPUT_TYPE_OUTPUT_AS_IS,
+    STPTI_ALTERNATE_OUTPUT_TYPE_DESCRAMBLED
+} STPTI_AlternateOutputType_t;
+typedef enum STPTI_ArrivalTimeSource_s
+{
+    STPTI_ARRIVAL_TIME_SOURCE_PTI,
+    STPTI_ARRIVAL_TIME_SOURCE_TSMERGER
+}
+STPTI_ArrivalTimeSource_t;
+typedef enum STPTI_Copy_s
+{
+    STPTI_COPY_TRANSFER_BY_DMA,
+    STPTI_COPY_TRANSFER_BY_GPDMA,
+    STPTI_COPY_TRANSFER_BY_MEMCPY,
+    STPTI_COPY_TRANSFER_BY_FDMA,
+    STPTI_COPY_TRANSFER_BY_PCP
+    ,
+    STPTI_COPY_TRANSFER_BY_MEMCPY_LINUX_KERNEL
+} STPTI_Copy_t;
+typedef enum STPTI_SCBits_s
+{
+    STPTI_SCB_CLEAR,
+    STPTI_SCB_ODD,
+    STPTI_SCB_EVEN
+} STPTI_SCBits_t;
+typedef enum STPTI_DescramblerAssociation_s
+{
+    STPTI_DESCRAMBLER_ASSOCIATION_ASSOCIATE_WITH_PIDS,
+    STPTI_DESCRAMBLER_ASSOCIATION_ASSOCIATE_WITH_SLOTS
+} STPTI_DescramblerAssociation_t;
+typedef enum STPTI_DescramblerType_s
+{
+    STPTI_DESCRAMBLER_TYPE_DVB_DESCRAMBLER,
+    STPTI_DESCRAMBLER_TYPE_DES_ECB_DESCRAMBLER,
+    STPTI_DESCRAMBLER_TYPE_DES_CBC_DESCRAMBLER,
+    STPTI_DESCRAMBLER_TYPE_DES_ECB_DVS042_DESCRAMBLER,
+    STPTI_DESCRAMBLER_TYPE_DES_CBC_DVS042_DESCRAMBLER,
+    STPTI_DESCRAMBLER_TYPE_DES_OFB_DESCRAMBLER,
+    STPTI_DESCRAMBLER_TYPE_DES_CTS_DESCRAMBLER,
+    STPTI_DESCRAMBLER_TYPE_FASTI_DESCRAMBLER,
+    STPTI_DESCRAMBLER_TYPE_MULTI2_ECB_DESCRAMBLER,
+    STPTI_DESCRAMBLER_TYPE_MULTI2_CBC_DESCRAMBLER,
+    STPTI_DESCRAMBLER_TYPE_MULTI2_ECB_DVS042_DESCRAMBLER,
+    STPTI_DESCRAMBLER_TYPE_MULTI2_CBC_DVS042_DESCRAMBLER,
+    STPTI_DESCRAMBLER_TYPE_MULTI2_OFB_DESCRAMBLER,
+    STPTI_DESCRAMBLER_TYPE_MULTI2_CTS_DESCRAMBLER,
+    STPTI_DESCRAMBLER_TYPE_AES_ECB_DESCRAMBLER,
+    STPTI_DESCRAMBLER_TYPE_AES_CBC_DESCRAMBLER,
+    STPTI_DESCRAMBLER_TYPE_AES_ECB_DVS042_DESCRAMBLER,
+    STPTI_DESCRAMBLER_TYPE_AES_CBC_DVS042_DESCRAMBLER,
+    STPTI_DESCRAMBLER_TYPE_AES_OFB_DESCRAMBLER,
+    STPTI_DESCRAMBLER_TYPE_AES_CTS_DESCRAMBLER,
+    STPTI_DESCRAMBLER_TYPE_AES_CTS_SCHNEIER_DESCRAMBLER,
+    STPTI_DESCRAMBLER_TYPE_AES_NSA_MDD_DESCRAMBLER,
+    STPTI_DESCRAMBLER_TYPE_AES_NSA_MDI_DESCRAMBLER,
+    STPTI_DESCRAMBLER_TYPE_AES_IPTV_CSA_DESCRAMBLER,
+    STPTI_DESCRAMBLER_TYPE_DVB_EAVS_DESCRAMBLER,
+    STPTI_DESCRAMBLER_TYPE_AES_ECB_LR_DESCRAMBLER,
+    STPTI_DESCRAMBLER_TYPE_AES_CBC_LR_DESCRAMBLER,
+    STPTI_DESCRAMBLER_TYPE_3DES_ECB_DESCRAMBLER,
+    STPTI_DESCRAMBLER_TYPE_3DES_CBC_DESCRAMBLER,
+    STPTI_DESCRAMBLER_TYPE_3DES_ECB_DVS042_DESCRAMBLER,
+    STPTI_DESCRAMBLER_TYPE_3DES_CBC_DVS042_DESCRAMBLER,
+    STPTI_DESCRAMBLER_TYPE_3DES_OFB_DESCRAMBLER,
+    STPTI_DESCRAMBLER_TYPE_3DES_CTS_DESCRAMBLER
+    ,
+    STPTI_DESCRAMBLER_TYPE_AES_ECB_PERM0,
+    STPTI_DESCRAMBLER_TYPE_AES_CBC_PERM0,
+    STPTI_DESCRAMBLER_TYPE_AES_ECB_DVS042_PERM0,
+    STPTI_DESCRAMBLER_TYPE_AES_CBC_DVS042_PERM0,
+    STPTI_DESCRAMBLER_TYPE_AES_OFB_PERM0,
+    STPTI_DESCRAMBLER_TYPE_AES_CTS_PERM0,
+    STPTI_DESCRAMBLER_TYPE_AES_NSA_MDD_PERM0,
+    STPTI_DESCRAMBLER_TYPE_AES_NSA_MDI_PERM0,
+    STPTI_DESCRAMBLER_TYPE_AES_IPTV_CSA_PERM0,
+    STPTI_DESCRAMBLER_TYPE_AES_ECB_PERM1,
+    STPTI_DESCRAMBLER_TYPE_AES_CBC_PERM1,
+    STPTI_DESCRAMBLER_TYPE_AES_ECB_DVS042_PERM1,
+    STPTI_DESCRAMBLER_TYPE_AES_CBC_DVS042_PERM1,
+    STPTI_DESCRAMBLER_TYPE_AES_OFB_PERM1,
+    STPTI_DESCRAMBLER_TYPE_AES_CTS_PERM1,
+    STPTI_DESCRAMBLER_TYPE_AES_NSA_MDD_PERM1,
+    STPTI_DESCRAMBLER_TYPE_AES_NSA_MDI_PERM1,
+    STPTI_DESCRAMBLER_TYPE_AES_IPTV_CSA_PERM1
+} STPTI_DescramblerType_t;
+typedef enum STPTI_NSAMode_s
+{
+    STPTI_NSA_MODE_MDI,
+    STPTI_NSA_MODE_MDD
+} STPTI_NSAMode_t;
+typedef enum STPTI_Device_s
+{
+    STPTI_DEVICE_LINK_INTERFACE,
+    STPTI_DEVICE_PTI_1,
+    STPTI_DEVICE_PTI_3,
+    STPTI_DEVICE_PTI_4
+} STPTI_Device_t;
+typedef enum STPTI_DMABurstMode_s
+{
+    STPTI_DMA_BURST_MODE_FOUR_BYTE = 0,
+    STPTI_DMA_BURST_MODE_ONE_BYTE
+} STPTI_DMABurstMode_t;
+typedef enum STPTI_FilterOperatingMode_s
+{
+    STPTI_FILTER_OPERATING_MODE_64x16,
+    STPTI_FILTER_OPERATING_MODE_64x8,
+    STPTI_FILTER_OPERATING_MODE_32x8,
+    STPTI_FILTER_OPERATING_MODE_32xANY,
+    STPTI_FILTER_OPERATING_MODE_8x8,
+    STPTI_FILTER_OPERATING_MODE_16x8,
+    STPTI_FILTER_OPERATING_MODE_8x16,
+    STPTI_FILTER_OPERATING_MODE_16x16,
+    STPTI_FILTER_OPERATING_MODE_32x16,
+    STPTI_FILTER_OPERATING_MODE_48x16,
+    STPTI_FILTER_OPERATING_MODE_48x8,
+    STPTI_FILTER_OPERATING_MODE_ANYx8,
+    STPTI_FILTER_OPERATING_MODE_ANYx16,
+    STPTI_FILTER_OPERATING_MODE_NONE
+} STPTI_FilterOperatingMode_t;
+typedef enum STPTI_FilterRepeatMode_s
+{
+    STPTI_FILTER_REPEAT_MODE_STPTI_FILTER_ONE_SHOT,
+    STPTI_FILTER_REPEAT_MODE_STPTI_FILTER_REPEATED
+} STPTI_FilterRepeatMode_t;
+typedef enum STPTI_FilterType_s
+{
+    STPTI_FILTER_TYPE_EMM_FILTER,
+    STPTI_FILTER_TYPE_ECM_FILTER,
+    STPTI_FILTER_TYPE_SECTION_FILTER,
+    STPTI_FILTER_TYPE_SECTION_FILTER_LONG_MODE,
+    STPTI_FILTER_TYPE_SECTION_FILTER_SHORT_MODE,
+    STPTI_FILTER_TYPE_SECTION_FILTER_NEG_MATCH_MODE,
+    STPTI_FILTER_TYPE_PES_FILTER,
+    STPTI_FILTER_TYPE_TSHEADER_FILTER,
+    STPTI_FILTER_TYPE_PES_STREAMID_FILTER
+} STPTI_FilterType_t;
+typedef enum STPTI_IndexAssociation_s
+{
+    STPTI_INDEX_ASSOCIATION_ASSOCIATE_WITH_PIDS,
+    STPTI_INDEX_ASSOCIATION_ASSOCIATE_WITH_SLOTS
+} STPTI_IndexAssociation_t;
+typedef enum STPTI_KeyParity_s
+{
+    STPTI_KEY_PARITY_EVEN_PARITY,
+    STPTI_KEY_PARITY_ODD_PARITY,
+    STPTI_KEY_PARITY_GENERIC_KEY
+} STPTI_KeyParity_t;
+typedef enum STPTI_KeyUsage_s
+{
+    STPTI_KEY_USAGE_INVALID,
+    STPTI_KEY_USAGE_VALID_FOR_PES,
+    STPTI_KEY_USAGE_VALID_FOR_TRANSPORT,
+    STPTI_KEY_USAGE_VALID_FOR_ALL
+} STPTI_KeyUsage_t;
+typedef enum STPTI_ScrambleState_s
+{
+    STPTI_SCRAMBLE_STATE_UNKNOWN,
+    STPTI_SCRAMBLE_STATE_CLEAR,
+    STPTI_SCRAMBLE_STATE_TRANSPORT_SCRAMBLED,
+    STPTI_SCRAMBLE_STATE_PES_SCRAMBLED
+}STPTI_ScrambleState_t;
+typedef enum STPTI_SlotType_s
+{
+    STPTI_SLOT_TYPE_NULL,
+    STPTI_SLOT_TYPE_SECTION,
+    STPTI_SLOT_TYPE_PES,
+    STPTI_SLOT_TYPE_RAW,
+    STPTI_SLOT_TYPE_EMM,
+    STPTI_SLOT_TYPE_ECM,
+    STPTI_SLOT_TYPE_PCR
+} STPTI_SlotType_t;
+typedef enum STPTI_StreamID_s
+{
+    STPTI_STREAM_ID_TSIN0 = 0x20,
+    STPTI_STREAM_ID_TSIN1,
+    STPTI_STREAM_ID_TSIN2,
+    STPTI_STREAM_ID_TSIN3,
+    STPTI_STREAM_ID_SWTS0,
+    STPTI_STREAM_ID_SWTS1,
+    STPTI_STREAM_ID_SWTS2,
+    STPTI_STREAM_ID_ALTOUT,
+    STPTI_STREAM_ID_NOTAGS = 0x80,
+    STPTI_STREAM_ID_NONE
+}STPTI_StreamID_t;
+typedef enum STPTI_SupportedTCCodes_s
+{
+    STPTI_SUPPORTED_TCCODES_SUPPORTS_DVB
+} STPTI_SupportedTCCodes_t;
+typedef enum STPTI_SecondaryPidMode_e
+{
+    STPTI_SECONDARY_PID_MODE_SUBSTITUTION,
+    STPTI_SECONDARY_PID_MODE_INSERTION,
+    STPTI_SECONDARY_PID_MODE_INSERTDELETE
+} STPTI_SecondaryPidMode_t;
+typedef U32 STPTI_Handle_t;
+typedef STPTI_Handle_t STPTI_Buffer_t;
+typedef STPTI_Handle_t STPTI_Descrambler_t;
+typedef STPTI_Handle_t STPTI_Filter_t;
+typedef STPTI_Handle_t STPTI_Frontend_t;
+typedef STPTI_Handle_t STPTI_Signal_t;
+typedef STPTI_Handle_t STPTI_Slot_t;
+typedef STPTI_Handle_t STPTI_Index_t;
+ typedef volatile U32 *STPTI_DevicePtr_t;
+typedef volatile U32 stpti_device_word_t;
+typedef U16 STPTI_Pid_t;
+typedef U8 STPTI_AlternateOutputTag_t;
+typedef U8 STPTI_TSPacket_t[188];
+typedef struct STPTI_Capability_s
+{
+    STPTI_Device_t Device;
+    U32 TCDeviceAddress;
+    STPTI_DescramblerAssociation_t Association;
+    ST_DeviceName_t EventHandlerName;
+    U16 NumberSlots;
+    U16 NumberDMAs;
+    U16 NumberKeys;
+    U16 NumberSectionFilters;
+    BOOL AlternateOutputSupport;
+    BOOL AutomaticSectionFiltering;
+    BOOL ManualSectionFiltering;
+    BOOL PidWildcardingSupport;
+    BOOL RawStreamDescrambling;
+    STPTI_SupportedTCCodes_t TCCodes;
+} STPTI_Capability_t;
+typedef struct STPTI_DMAParams_s
+{
+    U32 Destination;
+    U8 Holdoff;
+    U8 WriteLength;
+    STPTI_CDReqLine_t CDReqLine;
+    U32 *DMAUsed;
+    STPTI_DMABurstMode_t BurstSize;
+} STPTI_DMAParams_t;
+typedef struct STPTI_TimeStamp_s
+{
+    U32 LSW;
+    U8 Bit32;
+} STPTI_TimeStamp_t;
+typedef union STPTI_IndexDefinition_s
+{
+    struct
+    {
+        U32 PayloadUnitStartIndicator:1;
+        U32 ScramblingChangeToClear:1;
+        U32 ScramblingChangeToEven:1;
+        U32 ScramblingChangeToOdd:1;
+        U32 DiscontinuityIndicator:1;
+        U32 RandomAccessIndicator:1;
+        U32 PriorityIndicator:1;
+        U32 PCRFlag:1;
+        U32 OPCRFlag:1;
+        U32 SplicingPointFlag:1;
+        U32 TransportPrivateDataFlag:1;
+        U32 AdaptationFieldExtensionFlag:1;
+        U32 FirstRecordedPacket:1;
+        U32 MPEGStartCode:1;
+        U32 IFrameStart:1;
+        U32 PFrameStart:1;
+        U32 BFrameStart:1;
+        U32 IFieldStart:1;
+        U32 PFieldStart:1;
+        U32 BFieldStart:1;
+        U32 IDRFrameStart:1;
+        U32 IDRFieldStart:1;
+        U32 SequenceStart:1;
+        U32 Reserved:7;
+        U32 StraspTimerTick:1;
+        U32 StraspPacketReplaced:1;
+    } s;
+    U32 word;
+} STPTI_IndexDefinition_t;
+typedef struct STPTI_StartCode_s
+{
+    U8 MPEGStartCodeValue;
+    U8 MPEGStartCodeOffsetInToTSPacket;
+    U16 AuxillaryData;
+} STPTI_StartCode_t;
+typedef struct STPTI_IndexEventData_s
+{
+    STPTI_IndexDefinition_t IndexBitMap;
+    U32 PacketCount;
+    U32 BufferPacketAddress;
+    U32 RecordBufferPacketCount;
+    size_t OffsetIntoBuffer;
+    STPTI_Buffer_t BufferHandle;
+    STPTI_TimeStamp_t PCRTime;
+    U16 PCRTimeExtension;
+    STPTI_TimeStamp_t PacketArrivalTime;
+    U16 ArrivalTimeExtension;
+    U32 FRP_PacketArrivalTime;
+    U8 NumberStartCodesDetected;
+    STPTI_StartCode_t MPEGStartCode[7];
+} STPTI_IndexEventData_t;
+typedef struct STPTI_DMAEventData_s
+{
+    U32 Destination;
+} STPTI_DMAEventData_t;
+typedef struct STPTI_PCREventData_s
+{
+    BOOL DiscontinuityFlag;
+    STPTI_TimeStamp_t PCRArrivalTime;
+    U16 PCRArrivalTimeExtension;
+    STPTI_TimeStamp_t PCRBase;
+    U16 PCRExtension;
+} STPTI_PCREventData_t;
+typedef struct STPTI_ErrEventData_s
+{
+    U32 DMANumber;
+    U32 BytesRemaining;
+    U32 ExpectedCC;
+    U32 ReceivedCC;
+} STPTI_ErrEventData_t;
+typedef struct STPTI_BufferLevelData_s
+{
+    STPTI_Buffer_t BufferHandle;
+    U32 FreeLength;
+} STPTI_BufferLevelData_t;
+typedef struct STPTI_MarkerEventData_s
+{
+    ST_MM_Bitstream_Marker_t Marker;
+    U32 MarkerID0;
+    U32 MarkerID1;
+} STPTI_MarkerEventData_t;
+typedef struct STPTI_EventData_s
+{
+    union
+    {
+        STPTI_DMAEventData_t DMAEventData;
+        STPTI_PCREventData_t PCREventData;
+        STPTI_ErrEventData_t ErrEventData;
+        STPTI_IndexEventData_t IndexEventData;
+        STPTI_BufferLevelData_t BufferLevelData;
+        STPTI_MarkerEventData_t MarkerData;
+    } u;
+    STPTI_Slot_t SlotHandle;
+    STPTI_Buffer_t BufferHandle;
+    ST_DeviceName_t DeviceName;
+} STPTI_EventData_t;
+typedef struct STPTI_PESFilter_s
+{
+    STPTI_TimeStamp_t *PTSValueMax_p;
+    STPTI_TimeStamp_t *DTSValueMax_p;
+    STPTI_TimeStamp_t *PTSValueMin_p;
+    STPTI_TimeStamp_t *DTSValueMin_p;
+    U8 PesHeaderFlags;
+    U8 PesHeaderFlagsMask;
+    U8 PesTrickModeFlags;
+    U8 PesTrickModeFlagsMask;
+} STPTI_PESFilter_t;
+typedef struct STPTI_PESStreamIDFilter_s
+{
+    U8 StreamID;
+}STPTI_PESStreamIDFilter_t;
+typedef struct STPTI_SectionFilter_s
+{
+    BOOL DiscardOnCrcError;
+    U8 *ModePattern_p;
+    BOOL NotMatchMode;
+    BOOL OverrideSSIBit;
+} STPTI_SectionFilter_t;
+typedef struct STPTI_TransportFilter_s
+{
+    void *dummy_p;
+} STPTI_TransportFilter_t;
+typedef struct STPTI_NDSIcamEmmFilter_s
+{
+    BOOL TIDFiltering;
+    U8 IcamEmmReg1[4];
+    U8 IcamEmmMask1[4];
+    U8 IcamEmmReg2[4];
+    U8 IcamEmmMask2[4];
+    U8 IcamEmmReg3[4];
+    U8 IcamEmmMask3[4];
+    U8 IcamEmmTidModes[4];
+} STPTI_NDSIcamEmmFilter_t;
+typedef struct STPTI_FilterData_s
+{
+    STPTI_FilterType_t FilterType;
+    STPTI_FilterRepeatMode_t FilterRepeatMode;
+    BOOL InitialStateEnabled;
+    U8 *FilterBytes_p;
+    U8 *FilterMasks_p;
+    union
+    {
+        STPTI_SectionFilter_t SectionFilter;
+        STPTI_TransportFilter_t TransportFilter;
+        STPTI_PESFilter_t PESFilter;
+        STPTI_NDSIcamEmmFilter_t *NDSIcamEmmFilter;
+        STPTI_PESStreamIDFilter_t PESStreamIDFilter;
+    } u;
+} STPTI_FilterData_t;
+typedef struct STPTI_InitParams_s
+{
+    STPTI_Device_t Device;
+    STPTI_DevicePtr_t TCDeviceAddress_p;
+    ST_ErrorCode_t (*TCLoader_p) (STPTI_DevicePtr_t, void *);
+    STPTI_SupportedTCCodes_t TCCodes;
+    STPTI_DescramblerAssociation_t DescramblerAssociation;
+    ST_Partition_t *Partition_p;
+    ST_Partition_t *NCachePartition_p;
+    ST_DeviceName_t EventHandlerName;
+    S32 EventProcessPriority;
+    S32 InterruptProcessPriority;
+    S32 InterruptLevel;
+    S32 InterruptNumber;
+    U32 SyncLock;
+    U32 SyncDrop;
+    STPTI_FilterOperatingMode_t SectionFilterOperatingMode;
+    STPTI_IndexAssociation_t IndexAssociation;
+    S32 IndexProcessPriority;
+    STPTI_StreamID_t StreamID;
+    U16 NumberOfSlots;
+    U8 AlternateOutputLatency;
+    BOOL DiscardOnCrcError;
+    STPTI_ArrivalTimeSource_t PacketArrivalTimeSource;
+    U8 NumberOfSectionFilters;
+} STPTI_InitParams_t;
+typedef struct STPTI_OpenParams_s
+{
+    ST_Partition_t *DriverPartition_p;
+    ST_Partition_t *NonCachedPartition_p;
+} STPTI_OpenParams_t;
+typedef struct STPTI_SlotFlags_s
+{
+    BOOL SignalOnEveryTransportPacket;
+    BOOL CollectForAlternateOutputOnly;
+    BOOL AlternateOutputInjectCarouselPacket;
+    BOOL StoreLastTSHeader;
+    BOOL InsertSequenceError;
+    BOOL OutPesWithoutMetadata;
+    BOOL ForcePesLengthToZero;
+    BOOL AppendSyncBytePrefixToRawData;
+    BOOL SoftwareCDFifo;
+} STPTI_SlotFlags_t;
+typedef struct STPTI_SlotData_s
+{
+    STPTI_SlotType_t SlotType;
+    STPTI_SlotFlags_t SlotFlags;
+} STPTI_SlotData_t;
+typedef union STPTI_SlotOrPid_s
+{
+    STPTI_Slot_t Slot;
+    STPTI_Pid_t Pid;
+} STPTI_SlotOrPid_t;
+typedef struct STPTI_Statistics_s
+{
+    U32 InputPacketCount;
+    U32 ContinuityCountErrorCount;
+    U32 TransportErrorCount;
+} STPTI_Statistics_t;
+typedef enum STPTI_Feature_e
+{
+    STPTI_FEATURE_MINIMUM_ENTRY,
+    STPTI_SESSION_FEATURE_CONFIGURE_SBOX,
+    STPTI_SLOT_FEATURE_DLNA_FORMATTED_OUTPUT,
+    STPTI_SLOT_FEATURE_OUTPUT_WITH_TAG_BYTES,
+    STPTI_CAROUSEL_FEATURE_DLNA_FORMATTED_OUTPUT,
+    STPTI_FEATURE_MAXIMUM_ENTRY
+}STPTI_Feature_t;
+typedef struct STPTI_FeatureInfo_s
+{
+    STPTI_Feature_t Feature;
+    void* Params_p;
+} STPTI_FeatureInfo_t;
+typedef union STPTI_TermParams_u
+{
+    BOOL ForceTermination;
+    BOOL ForceTerminate;
+} STPTI_TermParams_t;
+ST_ErrorCode_t STPTI_AlternateOutputSetDefaultAction(STPTI_Handle_t Handle, STPTI_AlternateOutputType_t Method, STPTI_AlternateOutputTag_t Tag);
+ST_ErrorCode_t STPTI_BufferAllocate(STPTI_Handle_t Handle, U32 RequiredSize, U32 NumberOfPacketsInMultiPacket, STPTI_Buffer_t * BufferHandle_p);
+ST_ErrorCode_t STPTI_BufferAllocateManual(STPTI_Handle_t Handle, U8* Base_p, U32 RequiredSize, U32 NumberOfPacketsInMultiPacket, STPTI_Buffer_t * BufferHandle_p);
+ST_ErrorCode_t STPTI_BufferDeallocate(STPTI_Buffer_t BufferHandle);
+ST_ErrorCode_t STPTI_BufferExtractData(STPTI_Buffer_t BufferHandle, U32 Offset, U32 NumBytesToExtract,
+                                       U8 *Destination0_p, U32 DestinationSize0, U8 *Destination1_p,
+                                       U32 DestinationSize1, U32 *DataSize_p, STPTI_Copy_t DmaOrMemCpy);
+ST_ErrorCode_t STPTI_BufferExtractPartialPesPacketData(STPTI_Buffer_t BufferHandle, BOOL *PayloadUnitStart_p,
+                                                       BOOL *CCDiscontinuity_p, U8 *ContinuityCount_p,
+                                                       U16 *DataLength_p);
+ST_ErrorCode_t STPTI_BufferExtractPesPacketData(STPTI_Buffer_t BufferHandle, U8 *PesFlags_p, U8 *TrickModeFlags_p,
+                                                U32 *PESPacketLength_p, STPTI_TimeStamp_t * PTSValue_p,
+                                                STPTI_TimeStamp_t * DTSValue_p);
+ST_ErrorCode_t STPTI_BufferExtractSectionData(STPTI_Buffer_t BufferHandle, STPTI_Filter_t MatchedFilterList[],
+                                              U16 MaxLengthofFilterList, U16 *NumOfFilterMatches_p, BOOL *CRCValid_p,
+                                              U32 *SectionHeader_p);
+ST_ErrorCode_t STPTI_BufferExtractTSHeaderData(STPTI_Buffer_t BufferHandle, U32 *TSHeader_p);
+ST_ErrorCode_t STPTI_BufferFlush(STPTI_Buffer_t BufferHandle);
+ST_ErrorCode_t STPTI_BufferLevelSignalEnable( STPTI_Buffer_t BufferHandle, U32 BufferLevelThreshold );
+ST_ErrorCode_t STPTI_BufferLevelSignalDisable( STPTI_Buffer_t BufferHandle );
+ST_ErrorCode_t STPTI_BufferGetFreeLength(STPTI_Buffer_t BufferHandle, U32 *FreeLength_p);
+ST_ErrorCode_t STPTI_BufferGetWritePointer(STPTI_Buffer_t BufferHandle, void **Write_p);
+ST_ErrorCode_t STPTI_BufferGetWriteOffset(STPTI_Buffer_t BufferHandle, U32 *WriteOffSet_p);
+ST_ErrorCode_t STPTI_BufferLinkToCdFifo(STPTI_Buffer_t Buffer, STPTI_DMAParams_t * CdFifoParams_p);
+ST_ErrorCode_t STPTI_BufferPacketCount(STPTI_Buffer_t BufferHandle, U32 *Count_p);
+ST_ErrorCode_t STPTI_BufferRead(STPTI_Buffer_t BufferHandle, U8 *Destination0_p, U32 DestinationSize0,
+                                U8 *Destination1_p, U32 DestinationSize1, U32 *DataSize_p, STPTI_Copy_t DmaOrMemcpy);
+ST_ErrorCode_t STPTI_BufferReadNBytes(STPTI_Buffer_t BufferHandle, U8 *Destination0_p, U32 DestinationSize0,
+                                U8 *Destination1_p, U32 DestinationSize1, U32 *DataSize_p,
+                                STPTI_Copy_t DmaOrMemcpy, U32 BytesToCopy);
+ST_ErrorCode_t STPTI_BufferReadPartialPesPacket(STPTI_Buffer_t BufferHandle, U8 *Destination0_p, U32 DestinationSize0,
+                                                U8 *Destination1_p, U32 DestinationSize1, BOOL *PayloadUnitStart_p,
+                                                BOOL *CCDiscontinuity_p, U8 *ContinuityCount_p, U32 *DataSize_p,
+                                                STPTI_Copy_t DmaOrMemcpy);
+ST_ErrorCode_t STPTI_BufferReadPes(STPTI_Buffer_t BufferHandle, U8 *Destination0_p, U32 DestinationSize0,
+                                   U8 *Destination1_p, U32 DestinationSize1, U32 *Datasize_p, STPTI_Copy_t DmaOrMemcpy);
+ST_ErrorCode_t STPTI_BufferReadSection(STPTI_Buffer_t BufferHandle, STPTI_Filter_t MatchedFilterList[],
+                                       U32 MaxLengthofFilterList, U32 *NumOfFilterMatches_p, BOOL *CRCValid_p,
+                                       U8 *Destination0_p, U32 DestinationSize0, U8 *Destination1_p,
+                                       U32 DestinationSize1, U32 *DataSize_p, STPTI_Copy_t DmaOrMemcpy);
+ST_ErrorCode_t STPTI_BufferReadTSPacket(STPTI_Buffer_t BufferHandle, U8 *Destination0_p, U32 DestinationSize0,
+                                        U8 *Destination1_p, U32 DestinationSize1, U32 *DataSize_p,
+                                        STPTI_Copy_t DmaOrMemcpy);
+ST_ErrorCode_t STPTI_BufferSetMultiPacket(STPTI_Buffer_t BufferHandle, U32 NumberOfPacketsInMultiPacket);
+ST_ErrorCode_t STPTI_BufferSetOverflowControl(STPTI_Buffer_t BufferHandle, BOOL IgnoreOverflow);
+ST_ErrorCode_t STPTI_BufferSetReadPointer(STPTI_Buffer_t BufferHandle, void* Read_p);
+ST_ErrorCode_t STPTI_BufferSetReadOffset(STPTI_Buffer_t BufferHandle, U32 ReadOffset);
+ST_ErrorCode_t STPTI_BufferTestForData(STPTI_Buffer_t BufferHandle, U32 *BytesInBuffer_p);
+ST_ErrorCode_t STPTI_BufferUnLink(STPTI_Buffer_t Buffer);
+ST_ErrorCode_t STPTI_Close(STPTI_Handle_t Handle);
+ST_ErrorCode_t STPTI_SetSystemKey(ST_DeviceName_t DeviceName, U8 *Data);
+ST_ErrorCode_t STPTI_DescramblerAllocate(STPTI_Handle_t Handle, STPTI_Descrambler_t * DescramblerObject_p, STPTI_DescramblerType_t DescramblerType);
+ST_ErrorCode_t STPTI_DescramblerAssociate(STPTI_Descrambler_t DescramblerHandle, STPTI_SlotOrPid_t SlotOrPid);
+ST_ErrorCode_t STPTI_DescramblerDeallocate(STPTI_Descrambler_t DescramblerHandle);
+ST_ErrorCode_t STPTI_DescramblerDisassociate(STPTI_Descrambler_t DescramblerHandle, STPTI_SlotOrPid_t SlotOrPid);
+ST_ErrorCode_t STPTI_DescramblerSet(STPTI_Descrambler_t DescramblerHandle, STPTI_KeyParity_t Parity, STPTI_KeyUsage_t Usage, U8 *Data_p);
+ST_ErrorCode_t STPTI_DescramblerSetType(STPTI_Descrambler_t DescramblerHandle, STPTI_DescramblerType_t DescramblerType);
+ST_ErrorCode_t STPTI_DescramblerSetSVP(STPTI_Descrambler_t DescHandle, BOOL Clear_SCB, STPTI_NSAMode_t mode, BOOL MSCDescrambling);
+ST_ErrorCode_t STPTI_EnableScramblingEvents(STPTI_Slot_t SlotHandle);
+ST_ErrorCode_t STPTI_DisableScramblingEvents(STPTI_Slot_t SlotHandle);
+ST_ErrorCode_t STPTI_FilterAllocate(STPTI_Handle_t Handle, STPTI_FilterType_t FilterType,
+                                    STPTI_Filter_t * FilterObject_p);
+ST_ErrorCode_t STPTI_FilterAssociate(STPTI_Filter_t FilterHandle, STPTI_Slot_t SlotHandle);
+ST_ErrorCode_t STPTI_FilterDeallocate(STPTI_Filter_t FilterHandle);
+ST_ErrorCode_t STPTI_FilterDisassociate(STPTI_Filter_t FilterHandle, STPTI_Slot_t SlotHandle);
+ST_ErrorCode_t STPTI_FilterSet(STPTI_Filter_t FilterHandle, STPTI_FilterData_t * FilterData_p);
+ST_ErrorCode_t STPTI_FilterSetMatchAction(STPTI_Filter_t FilterHandle, STPTI_Filter_t FiltersToEnable[], U16 NumOfFiltersToEnable);
+ST_ErrorCode_t STPTI_FiltersFlush(STPTI_Buffer_t BufferHandle, STPTI_Filter_t Filters[], U16 NumOfFiltersToFlush);
+ST_ErrorCode_t STPTI_GetCapability(ST_DeviceName_t DeviceName, STPTI_Capability_t * DeviceCapability_p);
+ST_ErrorCode_t STPTI_GetCurrentPTITimer(ST_DeviceName_t DeviceName, STPTI_TimeStamp_t * TimeStamp);
+ST_ErrorCode_t STPTI_GetGlobalPacketCount(ST_DeviceName_t DeviceName, U32 *Count_p);
+ST_ErrorCode_t STPTI_GetInputPacketCount(ST_DeviceName_t DeviceName, U16 *Count_p);
+ST_ErrorCode_t STPTI_GetStatistics(ST_DeviceName_t DeviceName, STPTI_Statistics_t *Statistics_p);
+ST_ErrorCode_t STPTI_GetPacketArrivalTime(STPTI_Handle_t Handle, STPTI_TimeStamp_t * ArrivalTime_p, U16 *ArrivalTimeExtension_p);
+ST_ErrorCode_t STPTI_GetPacketErrorCount(ST_DeviceName_t DeviceName, U32 *Count_p);
+ST_ErrorCode_t STPTI_GetPresentationSTC(ST_DeviceName_t DeviceName, STPTI_Timer_t Timer, STPTI_TimeStamp_t * TimeStamp);
+ST_ErrorCode_t STPTI_HardwarePause(ST_DeviceName_t DeviceName);
+ST_ErrorCode_t STPTI_HardwareFIFOLevels(ST_DeviceName_t DeviceName, BOOL *Overflow, U16 *InputLevel, U16 *AltLevel, U16 *HeaderLevel);
+ST_ErrorCode_t STPTI_HardwareReset(ST_DeviceName_t DeviceName);
+ST_ErrorCode_t STPTI_HardwareResume(ST_DeviceName_t DeviceName);
+ST_ErrorCode_t STPTI_IndexAllocate(STPTI_Handle_t SessionHandle, STPTI_Index_t * IndexHandle_p);
+ST_ErrorCode_t STPTI_IndexAssociate(STPTI_Index_t IndexHandle, STPTI_SlotOrPid_t SlotOrPid);
+ST_ErrorCode_t STPTI_IndexDeallocate(STPTI_Index_t IndexHandle);
+ST_ErrorCode_t STPTI_IndexDisassociate(STPTI_Index_t IndexHandle, STPTI_SlotOrPid_t SlotOrPid);
+ST_ErrorCode_t STPTI_IndexSet(STPTI_Index_t IndexHandle, STPTI_IndexDefinition_t IndexMask, U32 MPEGStartCode, U32 MPEGStartCodeMode );
+ST_ErrorCode_t STPTI_IndexChain(STPTI_Index_t *IndexHandles, U32 NumberOfHandles);
+ST_ErrorCode_t STPTI_IndexReset(STPTI_Index_t IndexHandle);
+ST_ErrorCode_t STPTI_IndexStart(ST_DeviceName_t DeviceName);
+ST_ErrorCode_t STPTI_IndexStop(ST_DeviceName_t DeviceName);
+ST_ErrorCode_t STPTI_BufferReadAndAlterTSAtOffset(STPTI_Buffer_t BufferHandle,
+                                                  size_t OffsetIntoBuffer,
+                                                  STPTI_TSPacket_t * PacketBuffer_p,
+                                                  U32 ReplaceStart,
+                                                  U8 *ReplaceWith,
+                                                  U32 ReplaceCount);
+ST_ErrorCode_t STPTI_GetNdsRaspData(STPTI_Buffer_t BufferHandle, U32 *BufferCount, STPTI_Pid_t *LastPid);
+ST_ErrorCode_t STPTI_Init(ST_DeviceName_t DeviceName, const STPTI_InitParams_t * InitParams_p);
+ST_ErrorCode_t STPTI_ModifyGlobalFilterState(STPTI_Filter_t FiltersToDisable[], U16 NumOfFiltersToDisable,
+                                             STPTI_Filter_t FiltersToEnable[], U16 NumOfFiltersToEnable);
+ST_ErrorCode_t STPTI_ModifySyncLockAndDrop(ST_DeviceName_t DeviceName, U8 SyncLock, U8 SyncDrop);
+ST_ErrorCode_t STPTI_Open(ST_DeviceName_t DeviceName, const STPTI_OpenParams_t * OpenParams_p, STPTI_Handle_t * Handle_p);
+ST_ErrorCode_t STPTI_ObjectEnableFeature(STPTI_Handle_t ObjectHandle, STPTI_FeatureInfo_t FeatureInfo);
+ST_ErrorCode_t STPTI_ObjectDisableFeature(STPTI_Handle_t ObjectHandle, STPTI_Feature_t Feature);
+ST_ErrorCode_t STPTI_ObjectGetDeviceName(STPTI_Handle_t ObjectHandle, ST_DeviceName_t *DeviceName);
+ST_ErrorCode_t STPTI_ResetStatistics(ST_DeviceName_t DeviceName);
+ST_ErrorCode_t STPTI_SetStreamID(ST_DeviceName_t Device, STPTI_StreamID_t StreamID);
+ST_ErrorCode_t STPTI_PidQuery(ST_DeviceName_t Device, STPTI_Pid_t Pid, STPTI_Slot_t * Slot_p);
+ST_ErrorCode_t STPTI_SetDiscardParams(ST_DeviceName_t Device, U8 NumberOfDiscardBytes);
+ST_ErrorCode_t STPTI_SignalAbort(STPTI_Signal_t SignalHandle);
+ST_ErrorCode_t STPTI_SignalAllocate(STPTI_Handle_t Handle, STPTI_Signal_t * SignalHandle_p);
+ST_ErrorCode_t STPTI_SignalAssociateBuffer(STPTI_Signal_t SignalHandle, STPTI_Buffer_t BufferHandle);
+ST_ErrorCode_t STPTI_SignalDeallocate(STPTI_Signal_t SignalHandle);
+ST_ErrorCode_t STPTI_SignalDisassociateBuffer(STPTI_Signal_t SignalHandle, STPTI_Buffer_t BufferHandle);
+ST_ErrorCode_t STPTI_SignalWaitBuffer(STPTI_Signal_t SignalHandle, STPTI_Buffer_t * BufferHandle_p, U32 TimeoutMS);
+ST_ErrorCode_t STPTI_SlotAllocate(STPTI_Handle_t Handle, STPTI_Slot_t * SlotHandle_p, STPTI_SlotData_t * SlotData_p);
+ST_ErrorCode_t STPTI_SlotClearPid( STPTI_Slot_t SlotHandle );
+ST_ErrorCode_t STPTI_SlotDeallocate(STPTI_Slot_t SlotHandle);
+ST_ErrorCode_t STPTI_SlotDescramblingControl(STPTI_Slot_t SlotHandle, BOOL EnableDescramblingControl);
+ST_ErrorCode_t STPTI_SlotCancelForceSCB(STPTI_Slot_t SlotHandle);
+ST_ErrorCode_t STPTI_SlotForceSCB(STPTI_Slot_t SlotHandle, STPTI_SCBits_t In, STPTI_SCBits_t Out);
+ST_ErrorCode_t STPTI_SlotLinkToBuffer(STPTI_Slot_t Slot, STPTI_Buffer_t Buffer);
+ST_ErrorCode_t STPTI_SlotLinkToRecordBuffer(STPTI_Slot_t Slot, STPTI_Buffer_t Buffer, BOOL DescrambleTS);
+ST_ErrorCode_t STPTI_SlotLinkToCdFifo(STPTI_Slot_t Slot, STPTI_DMAParams_t * CdFifoParams_p);
+ST_ErrorCode_t STPTI_SlotLinkSecondaryToPrimary (STPTI_Slot_t SecondarySlotHandle, STPTI_Slot_t PrimarySlotHandle, STPTI_SecondaryPidMode_t SecondaryPidMode );
+ST_ErrorCode_t STPTI_SlotUnLinkSecondaryToPrimary(STPTI_Slot_t SecondarySlotHandle, STPTI_Slot_t PrimarySlotHandle );
+ST_ErrorCode_t STPTI_SlotPacketCount(STPTI_Slot_t SlotHandle, U16 *Count_p);
+ST_ErrorCode_t STPTI_SlotQuery(STPTI_Slot_t SlotHandle, BOOL *PacketsSeen_p, BOOL *TransportScrambledPacketsSeen_p,
+                               BOOL *PESScrambledPacketsSeen_p, STPTI_Pid_t * Pid_p);
+ST_ErrorCode_t STPTI_SlotSetAlternateOutputAction(STPTI_Slot_t SlotHandle, STPTI_AlternateOutputType_t Method, STPTI_AlternateOutputTag_t Tag);
+ST_ErrorCode_t STPTI_SlotSetCCControl(STPTI_Slot_t SlotHandle, BOOL DisableCCCheck);
+ST_ErrorCode_t STPTI_SlotSetCorruptionParams(STPTI_Slot_t SlotHandle, U8 Offset, U8 Value);
+ST_ErrorCode_t STPTI_SlotSetPid(STPTI_Slot_t SlotHandle, STPTI_Pid_t Pid);
+ST_ErrorCode_t STPTI_SlotSetPidAndRemap( STPTI_Slot_t SlotHandle, STPTI_Pid_t InputPid, STPTI_Pid_t OutputPid );
+ST_ErrorCode_t STPTI_SlotState(STPTI_Slot_t SlotHandle, U32 *SlotCount_p, STPTI_ScrambleState_t * ScrambleState_p, STPTI_Pid_t * Pid_p);
+ST_ErrorCode_t STPTI_SlotUnLink(STPTI_Slot_t Slot);
+ST_ErrorCode_t STPTI_SlotUnLinkRecordBuffer(STPTI_Slot_t Slot);
+ST_ErrorCode_t STPTI_SlotUpdatePid( STPTI_Slot_t SlotHandle, STPTI_Pid_t Pid );
+ST_ErrorCode_t STPTI_Term(ST_DeviceName_t DeviceName, const STPTI_TermParams_t * TermParams_p);
+ST_ErrorCode_t STPTI_UserDataBlockMove(U8 *DataPtr_p, U32 DataLength, STPTI_DMAParams_t *DMAParams_p);
+ST_ErrorCode_t STPTI_UserDataCircularAppend(U32 DataLength, STPTI_DMAParams_t *DMAParams_p, U8 **NextData_p);
+ST_ErrorCode_t STPTI_UserDataCircularSetup(U8 *Buffer_p, U32 BufferSize, U8 *DataPtr_p, U32 DataLength, STPTI_DMAParams_t *DMAParams_p, U8 **NextData_p);
+ST_ErrorCode_t STPTI_UserDataSynchronize(STPTI_DMAParams_t *DMAParams_p);
+ST_ErrorCode_t STPTI_UserDataWrite(U8 *DataPtr_p, U32 DataLength, STPTI_DMAParams_t * DMAParams_p);
+ST_ErrorCode_t STPTI_UserDataRemaining(STPTI_DMAParams_t *DMAParams_p, U32 *UserDataRemaining);
+ST_Revision_t STPTI_GetRevision(void);
+ST_ErrorCode_t STPTI_EnableErrorEvent(ST_DeviceName_t DeviceName, STPTI_Event_t EventName);
+ST_ErrorCode_t STPTI_DisableErrorEvent(ST_DeviceName_t DeviceName, STPTI_Event_t EventName);
+ST_ErrorCode_t STPTI_Debug(ST_DeviceName_t DeviceName, char *dbg_class, char *string, int string_size);
+ST_ErrorCode_t STPTI_PrintDebug(ST_DeviceName_t DeviceName);
+ST_ErrorCode_t STPTI_DumpInputTS(STPTI_Buffer_t BufferHandle, U16 bytes_to_capture_per_packet);
+ST_ErrorCode_t STPTI_GetBuffersFromSlot(STPTI_Slot_t SlotHandle, STPTI_Buffer_t *BufferHandle_p, STPTI_Buffer_t *RecordBufferHandle_p);
+ST_ErrorCode_t STPTI_BufferLevelChangeEvent(STPTI_Handle_t BufferHandle, BOOL Enable);
+ST_ErrorCode_t STPTI_TermAll(void);
+ST_ErrorCode_t STPTI_TEST_ForceLoader(int Variant);
+ST_ErrorCode_t STPTI_GetSWCDFifoCfg(void** GetWritePtrFn, void** SetReadPtrFn);
+ST_ErrorCode_t STPTI_SubscribeEvent(STPTI_Handle_t Session, STPTI_Event_t Event_ID );
+ST_ErrorCode_t STPTI_UnsubscribeEvent(STPTI_Handle_t Session, STPTI_Event_t Event_ID );
+ST_ErrorCode_t STPTI_SendEvent(STPTI_Handle_t Session, STPTI_Event_t Event_ID, STPTI_EventData_t *EventData );
+ST_ErrorCode_t STPTI_WaitForEvent(STPTI_Handle_t Session, STPTI_Event_t *Event_ID, STPTI_EventData_t *EventData );
+ST_ErrorCode_t STPTI_DmaMalloc(U32 Size, void **Buffer_p, BOOL UseBigPhysArea);
+ST_ErrorCode_t STPTI_DmaFree(void *Buffer_p);
+ST_ErrorCode_t STPTI_BufferAllocateManualUser( STPTI_Handle_t SessionHandle,
+                                               U8 *Base_p,
+                                               U32 RequiredSize,
+                                               U32 NumberOfPacketsInMultiPacket,
+                                               STPTI_Buffer_t * BufferHandle );
+typedef ST_ErrorCode_t (*STPTI_LoaderFunctionPointer_t)(STPTI_DevicePtr_t, void *);
+STPTI_LoaderFunctionPointer_t STPTI_GetDefaultLoaderFunctionPointer(void);
+ST_ErrorCode_t STPTI_DVBTCLoader(STPTI_DevicePtr_t CodeStart, void * Params_p);
+ST_ErrorCode_t STPTI_DVBTCLoader4L(STPTI_DevicePtr_t CodeStart, void * Params_p);
+ST_ErrorCode_t STPTI_DVBTCLoaderAL(STPTI_DevicePtr_t CodeStart, void * Params_p);
+ST_ErrorCode_t STPTI_DVBTCLoaderBSLL(STPTI_DevicePtr_t CodeStart, void * Params_p);
+ST_ErrorCode_t STPTI_DVBTCLoaderBSLSL(STPTI_DevicePtr_t CodeStart, void * Params_p);
+ST_ErrorCode_t STPTI_DVBTCLoaderBSLSL2(STPTI_DevicePtr_t CodeStart, void * Params_p);
+ST_ErrorCode_t STPTI_DVBTCLoaderBSLSL3(STPTI_DevicePtr_t CodeStart, void * Params_p);
+ST_ErrorCode_t STPTI_DVBTCLoaderG2(STPTI_DevicePtr_t CodeStart, void * Params_p);
+ST_ErrorCode_t STPTI_DVBTCLoaderG2L(STPTI_DevicePtr_t CodeStart, void * Params_p);
+ST_ErrorCode_t STPTI_DVBTCLoaderG2SL(STPTI_DevicePtr_t CodeStart, void * Params_p);
+ST_ErrorCode_t STPTI_DVBTCLoaderIPL(STPTI_DevicePtr_t CodeStart, void * Params_p);
+ST_ErrorCode_t STPTI_DVBTCLoaderIPSL(STPTI_DevicePtr_t CodeStart, void * Params_p);
+ST_ErrorCode_t STPTI_DVBTCLoaderL(STPTI_DevicePtr_t CodeStart, void * Params_p);
+ST_ErrorCode_t STPTI_DVBTCLoaderLRL(STPTI_DevicePtr_t CodeStart, void * Params_p);
+ST_ErrorCode_t STPTI_DVBTCLoaderSL(STPTI_DevicePtr_t CodeStart, void * Params_p);
+ST_ErrorCode_t STPTI_DVBTCLoaderSL2(STPTI_DevicePtr_t CodeStart, void * Params_p);
+ST_ErrorCode_t STPTI_DVBTCLoaderSL3(STPTI_DevicePtr_t CodeStart, void * Params_p);
+ST_ErrorCode_t STPTI_DVBTCLoaderSLS(STPTI_DevicePtr_t CodeStart, void * Params_p);
+ST_ErrorCode_t STPTI_DVBTCLoaderLRNDSL(STPTI_DevicePtr_t CodeStart, void * Params_p);
+ST_ErrorCode_t STPTI_DVBTCLoaderNDSL(STPTI_DevicePtr_t CodeStart, void * Params_p);
+ST_ErrorCode_t STPTI_DVBTCLoaderNDSSL(STPTI_DevicePtr_t CodeStart, void * Params_p);
+ST_ErrorCode_t STPTI_DVBTCLoaderNDSSL2(STPTI_DevicePtr_t CodeStart, void * Params_p);
+ST_ErrorCode_t STPTI_DVBTCLoaderNDSSL3(STPTI_DevicePtr_t CodeStart, void * Params_p);
+typedef enum STCLKRV_ApplicationMode_e
+{
+    STCLKRV_APPLICATION_MODE_NORMAL,
+    STCLKRV_APPLICATION_MODE_DVO1_SD_ONLY,
+    STCLKRV_APPLICATION_MODE_SD_ONLY
+}STCLKRV_ApplicationMode_t;
+typedef enum STCLKRV_Clock_e
+{
+    STCLKRV_CLOCK_SD_0,
+    STCLKRV_CLOCK_SD_1,
+    STCLKRV_CLOCK_PCM_0,
+    STCLKRV_CLOCK_PCM_1,
+    STCLKRV_CLOCK_PCM_2,
+    STCLKRV_CLOCK_PCM_3,
+    STCLKRV_CLOCK_SPDIF_HDMI_0,
+    STCLKRV_CLOCK_SPDIF_0,
+    STCLKRV_CLOCK_HD_0,
+    STCLKRV_CLOCK_HD_1
+}STCLKRV_ClockSource_t;
+typedef enum STCLKRV_Decode_e
+{
+    STCLKRV_DECODE_PRIMARY,
+    STCLKRV_DECODE_SECONDARY
+}STCLKRV_Decode_t;
+typedef enum STCLKRV_PCRSource_e
+{
+    STCLKRV_PCR_SOURCE_PTI
+}STCLKRV_PCRSource_t;
+typedef enum STCLKRV_STCSource_e
+{
+    STCLKRV_STC_SOURCE_PCR,
+    STCLKRV_STC_SOURCE_BASELINE,
+    STCLKRV_STC_SOURCE_PCR_BASELINE
+}STCLKRV_STCSource_t;
+typedef struct STCLKRV_WMAParams_s
+{
+   U32 PCRDriftThres;
+    U32 MinSampleThres;
+    U32 MaxWindowSize;
+}STCLKRV_WMAParams_t;
+typedef struct STCLKRV_LLRParams_s
+{
+  STCOMMON_JitterDistrib_e JitterDistribType;
+    U32 MaxJitterValue;
+    U32 MaxPCRRate;
+}STCLKRV_LLRParams_t;
+typedef enum STCLKRV_SelectAlgo_e
+{
+     STCLKRV_WMA,
+     STCLKRV_LLR
+}STCLKRV_SelectAlgo_t;
+typedef union Algo_Params_u
+{
+ STCLKRV_WMAParams_t WMAParams;
+ STCLKRV_LLRParams_t LLRParams;
+}STCLKRV_Algo_Params;
+typedef struct STCLKRV_Algo_s
+{
+ STCLKRV_SelectAlgo_t SelectedAlgo;
+ STCLKRV_Algo_Params AlgoParams;
+}STCLKRV_Algo_t;
+typedef struct STCLKRV_SourceParams_s
+{
+    STCLKRV_PCRSource_t Source;
+    union
+    {
+        struct
+        {
+            STPTI_Slot_t Slot;
+        }STPTI_s;
+    }Source_u;
+}STCLKRV_SourceParams_t;
+typedef enum STCLKRV_Event_s
+{
+    STCLKRV_PCR_VALID_EVT = ( 72 << 16 ),
+    STCLKRV_PCR_DISCONTINUITY_EVT = ( 72 << 16 ) + 1,
+    STCLKRV_PCR_GLITCH_EVT = ( 72 << 16 ) + 2,
+    STCLKRV_PCR_END_EVT = ( 72 << 16 ) + 3
+} STCLKRV_Event_t;
+typedef enum STCLKRV_Device_e
+{
+    STCLKRV_DEVICE_TYPE_5100,
+    STCLKRV_DEVICE_TYPE_7710,
+    STCLKRV_DEVICE_TYPE_7100,
+    STCLKRV_DEVICE_TYPE_5525,
+    STCLKRV_DEVICE_TYPE_7200,
+    STCLKRV_DEVICE_TYPE_BASELINE_ONLY
+}STCLKRV_Device_t;
+typedef struct STCLKRV_InitParams_s
+{
+    STCLKRV_Device_t DeviceType;
+    ST_Partition_t *Partition_p;
+    ST_DeviceName_t EVTDeviceName;
+    ST_DeviceName_t PCREvtHandlerName;
+    ST_DeviceName_t PTIDeviceName;
+    U32 PCRMaxGlitch;
+    U32 PCRDriftThres;
+    U32 MinSampleThres;
+    U32 MaxWindowSize;
+    U32 InterruptNumber;
+    U32 InterruptLevel;
+    void *FSBaseAddress_p;
+    void *AUDCFGBaseAddress_p;
+    STCLKRV_Decode_t DecodeType;
+    void *CRUBaseAddress_p;
+} STCLKRV_InitParams_t;
+typedef struct STCLKRV_TermParams_s
+{
+    BOOL ForceTerminate;
+} STCLKRV_TermParams_t;
+typedef struct STCLKRV_ExtendedSTC_s
+{
+    U32 BaseBit32;
+    U32 BaseValue;
+    U32 Extension;
+} STCLKRV_ExtendedSTC_t;
+typedef enum STCLKRV_StatisticsVersion_e
+{
+ STCLKRV_STAT_VERSION1 = (0x434c4b << 8),
+ STCLKRV_STAT_UNSUPPORTED
+}STCLKRV_StatisticsVersion_t;
+extern const char STATIC_CLKRV_ASSERTION__Too_many_Versions_in_STCLKRV_StatisticsVersion_e[(!(STCLKRV_STAT_UNSUPPORTED>= ((0x434c4b+1) << 8)))?1:-1];
+typedef struct STCLKRV_StatStructVer1_s
+{
+ U32 PCRAccuracyErrorCounter;
+ U32 PCRRepetitionErrorCounter;
+ U32 PCRDiscontinuityCounter;
+} STCLKRV_StatStructVer1_t;
+typedef struct STCLKRV_Statistics_s
+{
+  U32 StatMagicNumber;
+  STCLKRV_StatisticsVersion_t Version;
+  union
+  {
+    STCLKRV_StatStructVer1_t StatStructVer1;
+  }Statistics;
+}STCLKRV_Statistics_t;
+typedef enum STCLKRV_SetupObject_e
+{
+ STCLKRV_SETUP_PTI_NAME= 0x0001
+} STCLKRV_SetupObject_t;
+typedef struct STCLKRV_SetupParams_s
+{
+ STCLKRV_SetupObject_t SetupObject;
+ union
+ {
+  ST_DeviceName_t PTIDeviceName;
+ } SetupSettings;
+}
+STCLKRV_SetupParams_t;
+typedef void* STCLKRV_OpenParams_t;
+typedef U32 STCLKRV_Handle_t;
+ST_Revision_t STCLKRV_GetRevision(void);
+ST_ErrorCode_t STCLKRV_Init(const ST_DeviceName_t Name, const STCLKRV_InitParams_t *InitParams);
+ST_ErrorCode_t STCLKRV_Open(const ST_DeviceName_t Name, const STCLKRV_OpenParams_t *OpenParams, STCLKRV_Handle_t *Handle);
+ST_ErrorCode_t STCLKRV_SetApplicationMode(STCLKRV_Handle_t Handle, STCLKRV_ApplicationMode_t AppMode);
+ST_ErrorCode_t STCLKRV_GetRecoveryMethod(STCLKRV_Handle_t Handle , STCLKRV_Algo_t *SelectAlgorithm);
+ST_ErrorCode_t STCLKRV_SetRecoveryMethod(STCLKRV_Handle_t Handle, STCLKRV_Algo_t SelectAlgorithm );
+ST_ErrorCode_t STCLKRV_SetNominalFreq(STCLKRV_Handle_t Handle, STCLKRV_ClockSource_t ClockSource, U32 Frequency);
+ST_ErrorCode_t STCLKRV_Close(STCLKRV_Handle_t Handle);
+ST_ErrorCode_t STCLKRV_Term(const ST_DeviceName_t Name, const STCLKRV_TermParams_t *TermParams);
+ST_ErrorCode_t STCLKRV_Enable(STCLKRV_Handle_t Handle);
+ST_ErrorCode_t STCLKRV_SetSTCSource(STCLKRV_Handle_t Handle, STCLKRV_STCSource_t STCSource);
+ST_ErrorCode_t STCLKRV_SetPCRSource(STCLKRV_Handle_t ClkHandle, STCLKRV_SourceParams_t *PCRSource);
+ST_ErrorCode_t STCLKRV_SetSTCBaseline(STCLKRV_Handle_t Handle, STCLKRV_ExtendedSTC_t *STC);
+ST_ErrorCode_t STCLKRV_SetSTCOffset(STCLKRV_Handle_t Handle, S32 STCOffset);
+ST_ErrorCode_t STCLKRV_InvDecodeClk(STCLKRV_Handle_t Handle);
+ST_ErrorCode_t STCLKRV_Disable(STCLKRV_Handle_t Handle);
+ST_ErrorCode_t STCLKRV_GetSTC(STCLKRV_Handle_t Handle, U32 *STC );
+ST_ErrorCode_t STCLKRV_GetExtendedSTC(STCLKRV_Handle_t Handle, STCLKRV_ExtendedSTC_t *ExtendedSTC);
+ST_ErrorCode_t STCLKRV_GetStatistics(STCLKRV_Handle_t Handle,STCLKRV_Statistics_t *STCLKRV_Statistics_p);
+ST_ErrorCode_t STCLKRV_ResetStatistics(STCLKRV_Handle_t Handle,STCLKRV_Statistics_t *STCLKRV_Statistics_p);
+ST_ErrorCode_t STCLKRV_Setup( STCLKRV_Handle_t Handle, STCLKRV_SetupParams_t *SetupParams_p ) ;
+BOOL STCLKRV_IsAlreadyRegistered(const ST_DeviceName_t DeviceName);
+int stclkrv_IPrC_Handler(U32 request, void *arg);
+enum
+{
+    STVID_ERROR_DECODER_RUNNING = (21 << 16),
+    STVID_ERROR_DECODER_RUNNING_IN_RT_MODE,
+    STVID_ERROR_DECODER_PAUSING,
+    STVID_ERROR_DECODER_STOPPED,
+    STVID_ERROR_DECODER_NOT_PAUSING,
+    STVID_ERROR_NOT_AVAILABLE,
+    STVID_ERROR_DECODER_FREEZING,
+    STVID_ERROR_EVENT_REGISTRATION,
+    STVID_ERROR_SYSTEM_CLOCK,
+    STVID_ERROR_IMPOSSIBLE_WITH_MEM_PROFILE,
+    STVID_ERROR_MEMORY_ACCESS,
+    STVID_ERROR_DATA_INJECTION,
+    STVID_ERROR_DECODER_BUSY
+};
+enum
+{
+    STVID_ASPECT_RATIO_CHANGE_EVT = (21 << 16),
+    STVID_BACK_TO_SYNC_EVT,
+    STVID_DATA_ERROR_EVT,
+    STVID_DATA_OVERFLOW_EVT,
+    STVID_DATA_UNDERFLOW_EVT,
+    STVID_DIGINPUT_WIN_CHANGE_EVT,
+    STVID_FRAME_RATE_CHANGE_EVT,
+    STVID_IMPOSSIBLE_WITH_MEM_PROFILE_EVT,
+    STVID_NEW_PICTURE_TO_BE_DISPLAYED_EVT,
+    STVID_NEW_PICTURE_DECODED_EVT,
+    STVID_OUT_OF_SYNC_EVT,
+    STVID_PICTURE_DECODING_ERROR_EVT,
+    STVID_RESOLUTION_CHANGE_EVT,
+    STVID_SCAN_TYPE_CHANGE_EVT,
+    STVID_SEQUENCE_INFO_EVT,
+    STVID_SPEED_DRIFT_THRESHOLD_EVT,
+    STVID_STOPPED_EVT,
+    STVID_USER_DATA_EVT,
+    STVID_SYNCHRONISATION_CHECK_EVT,
+    STVID_SEQUENCE_END_CODE_EVT,
+    STVID_NEW_PICTURE_ORDERED_EVT,
+    STVID_PARSED_DATA_EVT,
+    STVID_END_OF_CRC_CHECK_EVT,
+    STVID_NEW_CRC_QUEUED_EVT,
+    STVID_NEW_FIELD_TO_BE_DISPLAYED_EVT,
+    STVID_UNSUPPORTED_STREAM_TYPE_EVT,
+    STVID_PICTURE_CHARACTERISTICS_CHANGE_EVT,
+    STVID_SPEED_SLAVE_MODE_LIMIT_REACHED_EVT,
+    STVID_MARKER_DETECTION_EVT,
+    STVID_NO_MORE_PICTURE_TO_BE_DISPLAYED_EVT
+};
+typedef enum STVID_BroadcastProfile_e
+{
+    STVID_BROADCAST_DVB = 1,
+    STVID_BROADCAST_DIRECTV = 2,
+    STVID_BROADCAST_ATSC = 4,
+    STVID_BROADCAST_DVD = 8,
+    STVID_BROADCAST_ARIB = 16
+} STVID_BroadcastProfile_t;
+typedef enum STVID_Clear_e
+{
+    STVID_CLEAR_DISPLAY_BLACK_FILL = 1,
+    STVID_CLEAR_DISPLAY_PATTERN_FILL = 2,
+    STVID_CLEAR_FREEING_DISPLAY_FRAME_BUFFER = 4
+} STVID_Clear_t;
+typedef enum STVID_CodingMode_e
+{
+    STVID_CODING_MODE_MB = 1
+} STVID_CodingMode_t;
+typedef enum STVID_ColorType_e
+{
+    STVID_COLOR_TYPE_YUV420 = 1,
+    STVID_COLOR_TYPE_YUV422 = 2,
+    STVID_COLOR_TYPE_YUV444 = 4
+} STVID_ColorType_t;
+typedef enum STVID_DecimationFactor_e
+{
+    STVID_DECIMATION_FACTOR_NONE = 0,
+    STVID_DECIMATION_FACTOR_H2 = 1,
+    STVID_DECIMATION_FACTOR_V2 = 2,
+    STVID_DECIMATION_FACTOR_H4 = 4,
+    STVID_DECIMATION_FACTOR_V4 = 8,
+    STVID_DECIMATION_FACTOR_H4_ADAPTATIVE_H2 = 16,
+    STVID_DECIMATION_FACTOR_2 = (STVID_DECIMATION_FACTOR_H2 | STVID_DECIMATION_FACTOR_V2),
+    STVID_DECIMATION_FACTOR_4 = (STVID_DECIMATION_FACTOR_H4 | STVID_DECIMATION_FACTOR_V4),
+    STVID_DECIMATION_FACTOR_420 = 32,
+    STVID_POSTPROCESS_RECONSTRUCTION = 64,
+    STVID_WATERMARK_RECONSTRUCTION = 128
+} STVID_DecimationFactor_t;
+typedef enum STVID_PostProcessing_Command_e
+{
+    STVID_POSTPROCESSING_ENABLE_DEBLOCKING =1,
+    STVID_POSTPROCESSING_DISABLE_DEBLOCKING =2,
+    STVID_POSTPROCESSING_ENABLE_DERINGING =4,
+    STVID_POSTPROCESSING_DISABLE_DERINGING =8,
+    STVID_POSTPROCESSING_DEBLOCKING_STRENGTH =16,
+    STVID_POSTPROCESSING_DERINGING_STRENGTH =32
+} STVID_POSTPROCESSING_Command_t;
+typedef enum STVID_PostProcessing_Strength_e
+{
+    STVID_POSTPROCESSING_STRENGTH_MIN =0,
+    STVID_POSTPROCESSING_STRENGTH_MEDIUM =128,
+    STVID_POSTPROCESSING_STRENGTH_MAX =255
+} STVID_PostProcessing_Strength_t;
+typedef struct STVID_PostProcessing_Param_s
+{
+    struct
+    {
+        STVID_PostProcessing_Strength_t DeblockingStrength;
+    } PPDeblocking;
+    struct
+    {
+        STVID_PostProcessing_Strength_t DeringingStrength;
+    } PPDeringing;
+} STVID_POSTPROCESSING_Param_t;
+typedef enum STVID_DecodedPictures_e
+{
+    STVID_DECODED_PICTURES_ALL,
+    STVID_DECODED_PICTURES_IP,
+    STVID_DECODED_PICTURES_I,
+    STVID_DECODED_PICTURES_FIRST_I
+} STVID_DecodedPictures_t;
+typedef enum STVID_FlushMode_e
+{
+    STVID_FLUSH_CANCEL,
+    STVID_FLUSH_ALL,
+    STVID_FLUSH_FROM_DISCONTINUITY_TO_PTS,
+    STVID_FLUSH_FROM_PTS_TO_DISCONTINUITY,
+    STVID_FLUSH_FROM_PTS,
+    STVID_FLUSH_TO_PTS,
+    STVID_FLUSH_FROM_DISCONTINUITY,
+    STVID_FLUSH_TO_DISCONTINUITY
+} STVID_FlushMode_t;
+typedef enum STVID_InjectionMode_e
+{
+    STVID_INJECTION_DEFAULT,
+    STVID_INJECTION_LIVE,
+    STVID_INJECTION_LOCAL,
+    STVID_INJECTION_LOCAL_NORAP,
+    STVID_INJECTION_LIVE_IP
+} STVID_InjectionMode_t;
+typedef enum STVID_FormatLevel_e
+{
+    STVID_FORMAT_LEVEL_DEFAULT = 0,
+    STVID_FORMAT_LEVEL_SELF_DETECT,
+    STVID_FORMAT_LEVEL_QCIF,
+    STVID_FORMAT_LEVEL_CIF,
+    STVID_FORMAT_LEVEL_SD,
+    STVID_FORMAT_LEVEL_HD_720,
+    STVID_FORMAT_LEVEL_HD_1080
+} STVID_FormatLevel_t;
+typedef enum STVID_Context_e
+{
+   STVID_CONTEXT_STANDARD = 0<<0,
+   STVID_CONTEXT_MOSAIC = 1<<0,
+   STVID_CONTEXT_IP_INJECTION = 1<<1,
+   STVID_CONTEXT_DVR = 1<<2,
+   STVID_CONTEXT_DVR_I_ONLY_BWD = 1<<3,
+   STVID_CONTEXT_NORASTER_MAIN_BUFFER = 1<<4
+} STVID_Context_t;
+typedef enum
+{
+    STVID_DEVICE_TYPE_5162_BASE = 0,
+    STVID_DEVICE_TYPE_5197_BASE = 0,
+    STVID_DEVICE_TYPE_7109_BASE,
+    STVID_DEVICE_TYPE_7111_BASE,
+    STVID_DEVICE_TYPE_7105_BASE,
+    STVID_DEVICE_TYPE_7141_BASE,
+    STVID_DEVICE_TYPE_7106_BASE,
+    STVID_DEVICE_TYPE_7108_BASE,
+    STVID_DEVICE_TYPE_5206_BASE,
+    STVID_DEVICE_TYPE_H205_BASE,
+    STVID_DEVICE_TYPE_DELTAHE_BASE
+} STVID_DeviceTypeBase_t;
+typedef enum STVID_DeviceType_e
+{
+    STVID_DEVICE_TYPE_5162_MPEG = STVID_DEVICE_TYPE_5162_BASE |
+                                             (1 << (0 + 7)) |
+                                             ((1 << 0) << ((0 + 7) + 8)) |
+                                             (4 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_5197_MPEG = STVID_DEVICE_TYPE_5197_BASE |
+                                             (1 << (0 + 7)) |
+                                             ((1 << 0) << ((0 + 7) + 8)) |
+                                             (4 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7109_MPEG = STVID_DEVICE_TYPE_7109_BASE |
+                                             (1 << (0 + 7)) |
+                                             ((1 << 4) << ((0 + 7) + 8)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (4 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7109D_MPEG = STVID_DEVICE_TYPE_7109_BASE |
+                                             (1 << (0 + 7)) |
+                                             ((1 << 4) << ((0 + 7) + 8)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7109_H264 = STVID_DEVICE_TYPE_7109_BASE |
+                                             (3 << (0 + 7)) |
+                                             ((1 << 4) << ((0 + 7) + 8)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7109_VC1 = STVID_DEVICE_TYPE_7109_BASE |
+                                             (4 << (0 + 7)) |
+                                             ((1 << 4) << ((0 + 7) + 8)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7109_MPEG4P2 = STVID_DEVICE_TYPE_7109_BASE |
+                                             (5 << (0 + 7)) |
+                                             ((1 << 4) << ((0 + 7) + 8)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7109_AVS = STVID_DEVICE_TYPE_7109_BASE |
+                                             (6 << (0 + 7)) |
+                                             ((1 << 4) << ((0 + 7) + 8)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7109_RV = STVID_DEVICE_TYPE_7109_BASE |
+                                             (10 << (0 + 7)) |
+                                             ((1 << 4) << ((0 + 7) + 8)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7109_MJPEG = STVID_DEVICE_TYPE_7109_BASE |
+                                             (11 << (0 + 7)) |
+                                             ((1 << 4) << ((0 + 7) + 8)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7109_JPEG = STVID_DEVICE_TYPE_7109_BASE |
+                                             (12 << (0 + 7)) |
+                                             ((1 << 4) << ((0 + 7) + 8)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7109_VP6 = STVID_DEVICE_TYPE_7109_BASE |
+                                             (8 << (0 + 7)) |
+                                             ((1 << 4) << ((0 + 7) + 8)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7109_FLV1 = STVID_DEVICE_TYPE_7109_BASE |
+                                             (9 << (0 + 7)) |
+                                             ((1 << 4) << ((0 + 7) + 8)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7109_THEORA = STVID_DEVICE_TYPE_7109_BASE |
+                                             (13 << (0 + 7)) |
+                                             ((1 << 4) << ((0 + 7) + 8)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7109_DIGITAL_INPUT = STVID_DEVICE_TYPE_7109_BASE |
+                                             (2 << (0 + 7)) |
+                                             ((1 << 4) << ((0 + 7) + 8)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7111_MPEG = STVID_DEVICE_TYPE_7111_BASE |
+                                             (1 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7111_H264 = STVID_DEVICE_TYPE_7111_BASE |
+                                             (3 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7111_VC1 = STVID_DEVICE_TYPE_7111_BASE |
+                                             (4 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7111_MPEG4P2 = STVID_DEVICE_TYPE_7111_BASE |
+                                             (5 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7111_AVS = STVID_DEVICE_TYPE_7111_BASE |
+                                             (6 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7111_RV = STVID_DEVICE_TYPE_7111_BASE |
+                                             (10 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7111_MJPEG = STVID_DEVICE_TYPE_7111_BASE |
+                                             (11 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7111_JPEG = STVID_DEVICE_TYPE_7111_BASE |
+                                             (12 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7111_VP6 = STVID_DEVICE_TYPE_7111_BASE |
+                                             (8 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7111_FLV1 = STVID_DEVICE_TYPE_7111_BASE |
+                                             (9 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7111_THEORA = STVID_DEVICE_TYPE_7111_BASE |
+                                             (13 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7111_DIGITAL_INPUT = STVID_DEVICE_TYPE_7111_BASE |
+                                             (2 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7105_MPEG = STVID_DEVICE_TYPE_7105_BASE |
+                                             (1 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7105_H264 = STVID_DEVICE_TYPE_7105_BASE |
+                                             (3 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7105_VC1 = STVID_DEVICE_TYPE_7105_BASE |
+                                             (4 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7105_MPEG4P2 = STVID_DEVICE_TYPE_7105_BASE |
+                                             (5 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7105_AVS = STVID_DEVICE_TYPE_7105_BASE |
+                                             (6 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7105_RV = STVID_DEVICE_TYPE_7105_BASE |
+                                             (10 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7105_MJPEG = STVID_DEVICE_TYPE_7105_BASE |
+                                             (11 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7105_JPEG = STVID_DEVICE_TYPE_7105_BASE |
+                                             (12 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7105_VP6 = STVID_DEVICE_TYPE_7105_BASE |
+                                             (8 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7105_FLV1 = STVID_DEVICE_TYPE_7105_BASE |
+                                             (9 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7105_THEORA = STVID_DEVICE_TYPE_7105_BASE |
+                                             (13 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7105_DIGITAL_INPUT = STVID_DEVICE_TYPE_7105_BASE |
+                                             (2 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7106_MPEG = STVID_DEVICE_TYPE_7106_BASE |
+                                             (1 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7106_H264 = STVID_DEVICE_TYPE_7106_BASE |
+                                             (3 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7106_VC1 = STVID_DEVICE_TYPE_7106_BASE |
+                                             (4 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7106_MPEG4P2 = STVID_DEVICE_TYPE_7106_BASE |
+                                             (5 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7106_AVS = STVID_DEVICE_TYPE_7106_BASE |
+                                             (7 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7106_RV = STVID_DEVICE_TYPE_7106_BASE |
+                                             (10 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7106_MJPEG = STVID_DEVICE_TYPE_7106_BASE |
+                                             (11 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7106_JPEG = STVID_DEVICE_TYPE_7106_BASE |
+                                             (12 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7106_VP6 = STVID_DEVICE_TYPE_7106_BASE |
+                                             (8 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7106_FLV1 = STVID_DEVICE_TYPE_7106_BASE |
+                                             (9 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7106_THEORA = STVID_DEVICE_TYPE_7106_BASE |
+                                             (13 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7106_DIGITAL_INPUT = STVID_DEVICE_TYPE_7106_BASE |
+                                             (2 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_5206_MPEG = STVID_DEVICE_TYPE_5206_BASE |
+                                             (1 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_5206_H264 = STVID_DEVICE_TYPE_5206_BASE |
+                                             (3 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_5206_VC1 = STVID_DEVICE_TYPE_5206_BASE |
+                                             (4 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_5206_MPEG4P2 = STVID_DEVICE_TYPE_5206_BASE |
+                                             (5 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_5206_AVS = STVID_DEVICE_TYPE_5206_BASE |
+                                             (7 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_5206_RV = STVID_DEVICE_TYPE_5206_BASE |
+                                             (10 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_5206_MJPEG = STVID_DEVICE_TYPE_5206_BASE |
+                                             (11 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_5206_JPEG = STVID_DEVICE_TYPE_5206_BASE |
+                                             (12 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_5206_VP6 = STVID_DEVICE_TYPE_5206_BASE |
+                                             (8 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_5206_FLV1 = STVID_DEVICE_TYPE_5206_BASE |
+                                             (9 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_5206_THEORA = STVID_DEVICE_TYPE_5206_BASE |
+                                             (13 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_5206_DIGITAL_INPUT = STVID_DEVICE_TYPE_5206_BASE |
+                                             (2 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7141_MPEG = STVID_DEVICE_TYPE_7141_BASE |
+                                             (1 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7141_H264 = STVID_DEVICE_TYPE_7141_BASE |
+                                             (3 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7141_VC1 = STVID_DEVICE_TYPE_7141_BASE |
+                                             (4 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7141_MPEG4P2 = STVID_DEVICE_TYPE_7141_BASE |
+                                             (5 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7141_AVS = STVID_DEVICE_TYPE_7141_BASE |
+                                             (6 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7141_RV = STVID_DEVICE_TYPE_7141_BASE |
+                                             (10 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7141_MJPEG = STVID_DEVICE_TYPE_7141_BASE |
+                                             (11 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7141_JPEG = STVID_DEVICE_TYPE_7141_BASE |
+                                             (12 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7141_VP6 = STVID_DEVICE_TYPE_7141_BASE |
+                                             (8 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7141_FLV1 = STVID_DEVICE_TYPE_7141_BASE |
+                                             (9 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7141_THEORA = STVID_DEVICE_TYPE_7141_BASE |
+                                             (13 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7141_DIGITAL_INPUT = STVID_DEVICE_TYPE_7141_BASE |
+                                             (2 << (0 + 7)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7108_MPEG = STVID_DEVICE_TYPE_7108_BASE |
+                                             (1 << (0 + 7)) |
+                                             ((1 << 6) << ((0 + 7) + 8)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7108_H264 = STVID_DEVICE_TYPE_7108_BASE |
+                                             (3 << (0 + 7)) |
+                                             ((1 << 6) << ((0 + 7) + 8)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7108_H264_MVC = STVID_DEVICE_TYPE_7108_BASE |
+                                             (14 << (0 + 7)) |
+                                             ((1 << 6) << ((0 + 7) + 8)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7108_VC1 = STVID_DEVICE_TYPE_7108_BASE |
+                                             (4 << (0 + 7)) |
+                                             ((1 << 6) << ((0 + 7) + 8)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7108_MPEG4P2 = STVID_DEVICE_TYPE_7108_BASE |
+                                             (5 << (0 + 7)) |
+                                             ((1 << 6) << ((0 + 7) + 8)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7108_AVS = STVID_DEVICE_TYPE_7108_BASE |
+                                             (7 << (0 + 7)) |
+                                             ((1 << 6) << ((0 + 7) + 8)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7108_RV = STVID_DEVICE_TYPE_7108_BASE |
+                                             (10 << (0 + 7)) |
+                                             ((1 << 6) << ((0 + 7) + 8)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7108_MJPEG = STVID_DEVICE_TYPE_7108_BASE |
+                                             (11 << (0 + 7)) |
+                                             ((1 << 6) << ((0 + 7) + 8)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7108_JPEG = STVID_DEVICE_TYPE_7108_BASE |
+                                             (12 << (0 + 7)) |
+                                             ((1 << 6) << ((0 + 7) + 8)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7108_VP6 = STVID_DEVICE_TYPE_7108_BASE |
+                                             (8 << (0 + 7)) |
+                                             ((1 << 6) << ((0 + 7) + 8)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7108_FLV1 = STVID_DEVICE_TYPE_7108_BASE |
+                                             (9 << (0 + 7)) |
+                                             ((1 << 6) << ((0 + 7) + 8)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7108_THEORA = STVID_DEVICE_TYPE_7108_BASE |
+                                             (13 << (0 + 7)) |
+                                             ((1 << 6) << ((0 + 7) + 8)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_7108_DIGITAL_INPUT = STVID_DEVICE_TYPE_7108_BASE |
+                                             (2 << (0 + 7)) |
+                                             ((1 << 6) << ((0 + 7) + 8)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_H205_MPEG = STVID_DEVICE_TYPE_H205_BASE |
+                                             (1 << (0 + 7)) |
+                                             ((1 << 6) << ((0 + 7) + 8)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_H205_H264 = STVID_DEVICE_TYPE_H205_BASE |
+                                             (3 << (0 + 7)) |
+                                             ((1 << 6) << ((0 + 7) + 8)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_H205_VC1 = STVID_DEVICE_TYPE_H205_BASE |
+                                             (4 << (0 + 7)) |
+                                             ((1 << 6) << ((0 + 7) + 8)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_H205_MPEG4P2 = STVID_DEVICE_TYPE_H205_BASE |
+                                             (5 << (0 + 7)) |
+                                             ((1 << 6) << ((0 + 7) + 8)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_H205_AVS = STVID_DEVICE_TYPE_H205_BASE |
+                                             (7 << (0 + 7)) |
+                                             ((1 << 6) << ((0 + 7) + 8)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_H205_RV = STVID_DEVICE_TYPE_H205_BASE |
+                                             (10 << (0 + 7)) |
+                                             ((1 << 6) << ((0 + 7) + 8)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_H205_MJPEG = STVID_DEVICE_TYPE_H205_BASE |
+                                             (11 << (0 + 7)) |
+                                             ((1 << 6) << ((0 + 7) + 8)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_H205_JPEG = STVID_DEVICE_TYPE_H205_BASE |
+                                             (12 << (0 + 7)) |
+                                             ((1 << 6) << ((0 + 7) + 8)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_H205_VP6 = STVID_DEVICE_TYPE_H205_BASE |
+                                             (8 << (0 + 7)) |
+                                             ((1 << 6) << ((0 + 7) + 8)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_H205_FLV1 = STVID_DEVICE_TYPE_H205_BASE |
+                                             (9 << (0 + 7)) |
+                                             ((1 << 6) << ((0 + 7) + 8)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_H205_THEORA = STVID_DEVICE_TYPE_H205_BASE |
+                                             (13 << (0 + 7)) |
+                                             ((1 << 6) << ((0 + 7) + 8)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (5 << (((0 + 7) + 8) + 10)) |
+                                             (((1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3)),
+    STVID_DEVICE_TYPE_H205_DIGITAL_INPUT = STVID_DEVICE_TYPE_H205_BASE |
+                                             (2 << (0 + 7)) |
+                                             ((1 << 6) << ((0 + 7) + 8)) |
+                                             ((1 << 5) << ((0 + 7) + 8)) |
+                                             (((1 << 1) | (1 << 0) | (1 << 2)) << ((((0 + 7) + 8) + 10) + 3))
+} STVID_DeviceType_t;
+typedef enum STVID_DisplayAspectRatio_e
+{
+    STVID_DISPLAY_ASPECT_RATIO_16TO9 = STGXOBJ_ASPECT_RATIO_16TO9,
+    STVID_DISPLAY_ASPECT_RATIO_4TO3 = STGXOBJ_ASPECT_RATIO_4TO3,
+    STVID_DISPLAY_ASPECT_RATIO_221TO1 = STGXOBJ_ASPECT_RATIO_221TO1,
+    STVID_DISPLAY_ASPECT_RATIO_SQUARE = STGXOBJ_ASPECT_RATIO_SQUARE,
+    STVID_DISPLAY_ASPECT_RATIO_EXTENDED_PAR = 99
+} STVID_DisplayAspectRatio_t;
+typedef enum STVID_DisplayAspectRatioConversion_e
+{
+    STVID_DISPLAY_AR_CONVERSION_PAN_SCAN = 1,
+    STVID_DISPLAY_AR_CONVERSION_LETTER_BOX = 2,
+    STVID_DISPLAY_AR_CONVERSION_COMBINED = 4,
+    STVID_DISPLAY_AR_CONVERSION_IGNORE = 8,
+    STVID_DISPLAY_AR_CONVERSION_PANORAMIC = 16
+} STVID_DisplayAspectRatioConversion_t;
+typedef enum STVID_ErrorRecoveryMode_e
+{
+    STVID_ERROR_RECOVERY_FULL = 1,
+    STVID_ERROR_RECOVERY_PARTIAL = 2,
+    STVID_ERROR_RECOVERY_NONE = 4,
+    STVID_ERROR_RECOVERY_HIGH = 8
+} STVID_ErrorRecoveryMode_t;
+typedef enum STVID_ForceMode_e
+{
+    STVID_FORCE_MODE_DISABLED,
+    STVID_FORCE_MODE_ENABLED
+} STVID_ForceMode_t;
+typedef enum STVID_FreezeField_e
+{
+    STVID_FREEZE_FIELD_TOP = 1,
+    STVID_FREEZE_FIELD_BOTTOM = 2,
+    STVID_FREEZE_FIELD_CURRENT = 4,
+    STVID_FREEZE_FIELD_NEXT = 8
+} STVID_FreezeField_t;
+typedef enum STVID_FreezeMode_e
+{
+    STVID_FREEZE_MODE_NONE = 1,
+    STVID_FREEZE_MODE_FORCE = 2,
+    STVID_FREEZE_MODE_NO_FLICKER = 4
+} STVID_FreezeMode_t;
+typedef enum STVID_MPEGFrame_e
+{
+    STVID_MPEG_FRAME_I = STGXOBJ_MPEG_FRAME_I,
+    STVID_MPEG_FRAME_P = STGXOBJ_MPEG_FRAME_P,
+    STVID_MPEG_FRAME_B = STGXOBJ_MPEG_FRAME_B
+} STVID_MPEGFrame_t;
+typedef enum STVID_MPEGStandard_e
+{
+    STVID_MPEG_STANDARD_ISO_IEC_11172 = 1,
+    STVID_MPEG_STANDARD_ISO_IEC_13818 = 2,
+    STVID_MPEG_STANDARD_ISO_IEC_14496 = 4,
+    STVID_MPEG_STANDARD_SMPTE_421M = 8,
+    STVID_MPEG_STANDARD_ISO_IEC_14496_2 = 16,
+    STVID_MPEG_STANDARD_AVS_GB_T_20090_2 = 32,
+    STVID_MPEG_STANDARD_FLV1 = 64,
+    STVID_MPEG_STANDARD_VP6 = 128,
+    STVID_MPEG_STANDARD_RV_8_9 = 256,
+    STVID_MPEG_STANDARD_MJPEG = 512,
+    STVID_MPEG_STANDARD_JPEG = 1024,
+    STVID_MPEG_STANDARD_THEORA = 2048
+} STVID_MPEGStandard_t;
+typedef enum STVID_ParsedDataType_e
+{
+    STVID_PARSED_DATA_TYPE_STARTCODE,
+    STVID_PARSED_DATA_TYPE_SERIES_BYTES
+} STVID_ParsedDataType_t;
+typedef enum STVID_Picture_e
+{
+    STVID_PICTURE_LAST_DECODED = 1,
+    STVID_PICTURE_DISPLAYED = 2
+} STVID_Picture_t;
+typedef enum STVID_PictureStructure_e
+{
+    STVID_PICTURE_STRUCTURE_TOP_FIELD,
+    STVID_PICTURE_STRUCTURE_BOTTOM_FIELD,
+    STVID_PICTURE_STRUCTURE_FRAME
+} STVID_PictureStructure_t;
+typedef enum STVID_ScanType_e
+{
+    STVID_SCAN_TYPE_PROGRESSIVE = STGXOBJ_PROGRESSIVE_SCAN,
+    STVID_SCAN_TYPE_INTERLACED = STGXOBJ_INTERLACED_SCAN
+} STVID_ScanType_t;
+typedef enum STVID_SetupObject_e
+{
+    STVID_SETUP_FRAME_BUFFERS_PARTITION = 0x0001,
+    STVID_SETUP_DECODER_INTERMEDIATE_BUFFER_PARTITION = 0x0002,
+    STVID_SETUP_DECIMATED_FRAME_BUFFERS_PARTITION = 0x0004,
+    STVID_SETUP_FDMA_NODES_PARTITION = 0x0008,
+    STVID_SETUP_PICTURE_PARAMETER_BUFFERS_PARTITION = 0x0010,
+    STVID_SETUP_ES_COPY_BUFFER_PARTITION = 0x0020,
+    STVID_SETUP_ES_COPY_BUFFER = 0x0040,
+    STVID_SETUP_PARSING_RESULTS_BUFFER_PARTITION = 0x0080,
+    STVID_SETUP_DATA_INPUT_BUFFER_PARTITION = 0x0100,
+    STVID_SETUP_BIT_BUFFER_PARTITION = 0x0200,
+    STVID_SETUP_FORCE_SEQUENCE_INFO = 0x0400,
+    STVID_SETUP_DEFAULT_SEQUENCE_INFO = 0x0800,
+    STVID_SETUP_DEFAULT_CODEC_SPECIFIC_INFO = 0x1000,
+    STVID_SETUP_DISPLAY_32PULLDOWN_DETECTION = 0x2000,
+    STVID_SETUP_DATA_INPUT_BUFFER = 0x4000
+} STVID_SetupObject_t;
+typedef enum STVID_Stop_e
+{
+    STVID_STOP_WHEN_NEXT_REFERENCE = 1,
+    STVID_STOP_WHEN_END_OF_DATA = 2,
+    STVID_STOP_NOW = 4,
+    STVID_STOP_WHEN_NEXT_I = 8
+} STVID_Stop_t;
+typedef enum STVID_StreamType_e
+{
+    STVID_STREAM_TYPE_ES = 1,
+    STVID_STREAM_TYPE_PES = 2,
+    STVID_STREAM_TYPE_MPEG1_PACKET = 4,
+    STVID_STREAM_TYPE_UNCOMPRESSED = 8
+} STVID_StreamType_t;
+typedef enum STVID_SynchroAction_e
+{
+    STVID_SYNCHRO_ACTION_PAUSE,
+    STVID_SYNCHRO_ACTION_SKIP
+} STVID_SynchroAction_t;
+typedef enum STVID_UserDataPosition_e
+{
+    STVID_USER_DATA_AFTER_SEQUENCE,
+    STVID_USER_DATA_AFTER_GOP,
+    STVID_USER_DATA_AFTER_PICTURE
+} STVID_UserDataPosition_t;
+typedef enum STVID_WinAlign_e
+{
+    STVID_WIN_ALIGN_TOP_LEFT = 1,
+    STVID_WIN_ALIGN_VCENTRE_LEFT = 2,
+    STVID_WIN_ALIGN_BOTTOM_LEFT = 4,
+    STVID_WIN_ALIGN_TOP_RIGHT = 8,
+    STVID_WIN_ALIGN_VCENTRE_RIGHT = 16,
+    STVID_WIN_ALIGN_BOTTOM_RIGHT = 32,
+    STVID_WIN_ALIGN_BOTTOM_HCENTRE = 64,
+    STVID_WIN_ALIGN_TOP_HCENTRE = 128,
+    STVID_WIN_ALIGN_VCENTRE_HCENTRE = 256
+} STVID_WinAlign_t;
+typedef enum STVID_WinSize_e
+{
+    STVID_WIN_SIZE_FIXED = 1,
+    STVID_WIN_SIZE_DONT_CARE = 2,
+    STVID_WIN_SIZE_INCREASE = 4,
+    STVID_WIN_SIZE_DECREASE = 8
+} STVID_WinSize_t;
+typedef enum STVID_CodecMode_e
+{
+    STVID_CODEC_MODE_DECODE = 0,
+    STVID_CODEC_MODE_TRANSCODE = 1
+} STVID_CodecMode_t;
+typedef enum STVID_VP6_Standard_e
+{
+    STVID_VP6_DEFAULT = 0,
+    STVID_VP6_VP6F = 1
+} STVID_VP6_Standard_t;
+typedef enum STVID_3D_Flipping_e
+{
+    STVID_NO_FLIPPING,
+    STVID_FLIPPING_FRAME0,
+    STVID_FLIPPING_FRAME1
+} STVID_3D_Flipping_t;
+typedef enum
+{
+    STVID_DATA_INPUT_TYPE_PES,
+    STVID_DATA_INPUT_TYPE_PARTIALLY_FILLED_PES_FROM_OFFSET,
+    STVID_DATA_INPUT_TYPE_PARTIALLY_FILLED_PES_FROM_ADDRESS
+} STVID_DataInputType_t;
+typedef struct STVID_ScalingFactors_s
+{
+    U16 N;
+    U16 M;
+} STVID_ScalingFactors_t;
+typedef struct STVID_ScalingCapability_s
+{
+    BOOL Continuous;
+    U16 NbScalingFactors;
+    STVID_ScalingFactors_t *ScalingFactors_p;
+    STVID_ScalingFactors_t ScalingFactorsArray[7];
+} STVID_ScalingCapability_t;
+typedef struct STVID_Capability_s
+{
+    STVID_BroadcastProfile_t SupportedBroadcastProfile;
+    STVID_CodingMode_t SupportedCodingMode;
+    STVID_ColorType_t SupportedColorType;
+    STVID_DecimationFactor_t SupportedDecimationFactor;
+    STVID_DisplayAspectRatioConversion_t SupportedDisplayARConversion;
+    STVID_ErrorRecoveryMode_t SupportedErrorRecoveryMode;
+    STVID_FreezeMode_t SupportedFreezeMode;
+    STVID_FreezeField_t SupportedFreezeField;
+    STVID_Picture_t SupportedPicture;
+    STVID_ScanType_t SupportedScreenScanType;
+    STVID_Stop_t SupportedStop;
+    STVID_StreamType_t SupportedStreamType;
+    BOOL ProfileCapable;
+    BOOL StillPictureCapable;
+    BOOL ManualInputWindowCapable;
+    BOOL ManualOutputWindowCapable;
+    BOOL ColorKeyingCapable;
+    BOOL PSICapable;
+    STVID_WinAlign_t SupportedWinAlign;
+    STVID_WinSize_t SupportedWinSize;
+    U8 InputWindowHeightMin;
+    U8 InputWindowWidthMin;
+    U8 InputWindowPositionXPrecision;
+    U8 InputWindowPositionYPrecision;
+    U8 InputWindowWidthPrecision;
+    U8 InputWindowHeightPrecision;
+    U8 OutputWindowHeightMin;
+    U8 OutputWindowWidthMin;
+    U8 OutputWindowPositionXPrecision;
+    U8 OutputWindowPositionYPrecision;
+    U8 OutputWindowWidthPrecision;
+    U8 OutputWindowHeightPrecision;
+    STVID_ScalingCapability_t SupportedVerticalScaling;
+    STVID_ScalingCapability_t SupportedHorizontalScaling;
+    U8 DecoderNumber;
+    STVID_SetupObject_t SupportedSetupObject;
+} STVID_Capability_t;
+typedef struct STVID_ConfigureEventParams_s
+{
+    BOOL Enable;
+    U32 NotificationsToSkip;
+} STVID_ConfigureEventParams_t;
+typedef struct STVID_ClearParams_s
+{
+    STVID_Clear_t ClearMode;
+    void * PatternAddress1_Cp;
+    U32 PatternSize1;
+    void * PatternAddress2_Cp;
+    U32 PatternSize2;
+} STVID_ClearParams_t;
+typedef struct STVID_DataInjectionCompletedParams_s
+{
+    BOOL TransferRelatedToPrevious;
+} STVID_DataInjectionCompletedParams_t;
+typedef struct STVID_DataUnderflow_s
+{
+    U32 BitBufferFreeSize;
+    U32 BitRateValue;
+    S32 RequiredTimeJump;
+    U32 RequiredDuration;
+    BOOL TransferRelatedToPrevious;
+} STVID_DataUnderflow_t;
+typedef struct STVID_DigitalInputWindows_s
+{
+    STGXOBJ_Rectangle_t InputRectangle;
+    U32 OutputWidth;
+    U32 OutputHeight;
+} STVID_DigitalInputWindows_t;
+typedef struct STVID_ForceDecimationFactorParams_s
+{
+    STVID_ForceMode_t ForceMode;
+    STVID_DecimationFactor_t DecimationFactor;
+} STVID_ForceDecimationFactorParams_t;
+typedef struct STVID_Freeze_s
+{
+    STVID_FreezeMode_t Mode;
+    STVID_FreezeField_t Field;
+} STVID_Freeze_t;
+typedef U32 STVID_Handle_t;
+typedef struct STVID_InitContext_s
+{
+    STVID_Context_t Context;
+    struct
+        {
+        STVID_FormatLevel_t FormatLevel;
+        U32 Reserved[6];
+        } ContextParams;
+} STVID_InitContext_t;
+typedef struct STVID_InitParams_s
+{
+    STVID_DeviceType_t DeviceType;
+    void * BaseAddress_p;
+    void * DeviceBaseAddress_p;
+    BOOL BitBufferAllocated;
+    void * BitBufferAddress_p;
+    U32 BitBufferSize;
+    STEVT_EventConstant_t InterruptEvent;
+    ST_DeviceName_t InterruptEventName;
+    BOOL InstallVideoInterruptHandler;
+    U32 InterruptNumber;
+    U32 InterruptLevel;
+    ST_Partition_t * CPUPartition_p;
+    STAVMEM_PartitionHandle_t AVMEMPartition;
+    U32 MaxOpen;
+    U32 UserDataSize;
+    ST_DeviceName_t EvtHandlerName;
+    ST_DeviceName_t ClockRecoveryName;
+    U32 AVSYNCDriftThreshold;
+    void * BaseAddress2_p;
+    void * BaseAddress3_p;
+    STVID_InitContext_t * InitContext_p;
+} STVID_InitParams_t;
+typedef struct STVID_MemoryProfile_s
+{
+    U32 MaxWidth;
+    U32 MaxHeight;
+    U8 NbFrameStore;
+    STVID_DecimationFactor_t DecimationFactor;
+    union
+    {
+        struct
+        {
+            U8 Main;
+            U8 Decimated;
+        } OptimisedNumber;
+        struct
+        {
+            U32 Main;
+            U32 Decimated;
+        } VariableInFixedSize;
+        struct
+        {
+            STAVMEM_PartitionHandle_t Main;
+            STAVMEM_PartitionHandle_t Decimated;
+        } VariableInFullPartition;
+    } FrameStoreIDParams;
+} STVID_MemoryProfile_t;
+typedef struct STVID_OpenParams_s
+{
+    U32 Dummy;
+} STVID_OpenParams_t;
+typedef struct STVID_ParsedData_s
+{
+    STVID_ParsedDataType_t ParsedDataType;
+    union
+    {
+         struct
+         {
+               U8 Value;
+         } StartCode;
+         struct
+         {
+               U32 SeriesSizeInBytes;
+         } ByteSeries;
+    } WantedData;
+    void * ParsedDataAddress1;
+    U32 ParsedDataSize1;
+    void * ParsedDataAddress2;
+    U32 ParsedDataSize2;
+} STVID_ParsedData_t;
+typedef struct STVID_PTS_s
+{
+    U32 PTS;
+    BOOL PTS33;
+    BOOL Interpolated;
+    BOOL IsValid;
+} STVID_PTS_t;
+typedef struct STVID_SetupCodecSpecificInfo_s
+{
+    STVID_MPEGStandard_t MPEGStandard;
+    union
+    {
+        struct
+        {
+            STVID_VP6_Standard_t VP6_Standard;
+        } STANDARD_VP6;
+    } CodecSetup;
+} STVID_SetupCodecSpecificInfo_t;
+typedef struct STVID_SequenceInfo_s
+{
+    U32 Height;
+    U32 Width;
+    STVID_DisplayAspectRatio_t Aspect;
+    U32 PAR_Num;
+    U32 PAR_Den;
+    STVID_ScanType_t ScanType;
+    U32 FrameRate;
+    U32 BitRate;
+    STVID_MPEGStandard_t MPEGStandard;
+    BOOL IsLowDelay;
+    U32 VBVBufferSize;
+    U8 StreamID;
+    U32 ProfileAndLevelIndication;
+    U8 VideoFormat;
+    U8 FrameRateExtensionN;
+    U8 FrameRateExtensionD;
+    BOOL OverScanAllowed;
+} STVID_SequenceInfo_t;
+typedef struct STVID_SetupParams_s
+{
+    STVID_SetupObject_t SetupObject;
+    union
+    {
+        STAVMEM_PartitionHandle_t AVMEMPartition;
+        STVID_SequenceInfo_t SequenceInfo;
+        STVID_SetupCodecSpecificInfo_t SetupCodecSpecificInfo;
+        struct
+        {
+            U32 BufferSize;
+            BOOL BufferAllocated;
+            void * BufferAddress_p;
+        } SingleBuffer;
+        struct
+        {
+            U32 BufferSize;
+            BOOL BufferAllocated;
+            void * BufferAddress1_p;
+            void * BufferAddress2_p;
+        } DoubleBuffer;
+        struct
+        {
+            U8 NumberOfBuffers;
+            U32 * BufferSizesTable;
+            BOOL BufferAllocated;
+            void ** BufferAddressesTable;
+        } AnyBuffer;
+        struct
+        {
+            BOOL Detect32PulldownRepetitions;
+        } DisplaySetup;
+    } SetupSettings;
+} STVID_SetupParams_t;
+typedef struct STVID_TimeCode_s
+{
+    U8 Hours;
+    U8 Minutes;
+    U8 Seconds;
+    U8 Frames;
+    BOOL Interpolated;
+} STVID_TimeCode_t;
+typedef struct STVID_DecimatedBitmapParams_s
+{
+    void * Data1_p;
+    void * Data1_Cp;
+    void * Data1_NCp;
+    U32 Size1;
+    void * Data2_p;
+    void * Data2_Cp;
+    void * Data2_NCp;
+    U32 Size2;
+} STVID_DecimatedBitmapParams_t;
+typedef struct STVID_3D_SideBySideHalf_s
+{
+    BOOL Frame0IsLeft;
+    U16 Frame0GridPosition_x;
+    U16 Frame1GridPosition_x;
+    STVID_3D_Flipping_t Flipping;
+} STVID_3D_SideBySideHalf_t;
+typedef struct STVID_3D_StackedHalf_s
+{
+    BOOL Frame0IsLeft;
+    U16 Frame0GridPosition_y;
+    U16 Frame1GridPosition_y;
+    STVID_3D_Flipping_t Flipping;
+} STVID_3D_StackedHalf_t;
+typedef struct STVID_3D_FrameSeq_s
+{
+    BOOL IsFrame0;
+    BOOL Frame0IsLeft;
+    STVID_3D_Flipping_t Flipping;
+} STVID_3D_FrameSeq_t;
+typedef union STVID_3D_VideoSupplInfo_s
+{
+    STVID_3D_SideBySideHalf_t STVID_3D_SideBySideHalf;
+    STVID_3D_StackedHalf_t STVID_3D_StackedHalf;
+    STVID_3D_FrameSeq_t STVID_3D_FrameSeq;
+} STVID_3D_VideoSupplInfo_t;
+typedef struct STVID_3D_Property_s
+{
+    ST_MM_3D_Format_t STVID_3D_Format;
+    STVID_3D_VideoSupplInfo_t STVID_3D_SupplInfo;
+} STVID_3DVideoProperty_t;
+typedef struct STVID_VideoParams_s
+{
+    U32 FrameRate;
+    STGXOBJ_ScanType_t ScanType;
+    STVID_3DVideoProperty_t STVID_3D_Property;
+    STGXOBJ_Bitmap_t SecondViewBitmapParams;
+    STVID_MPEGFrame_t MPEGFrame;
+    STVID_PictureStructure_t PictureStructure;
+    BOOL TopFieldFirst;
+    STVID_TimeCode_t TimeCode;
+    STVID_PTS_t PTS;
+    STVID_DecimationFactor_t DecimationFactors;
+    BOOL DoesNonDecimatedExist;
+    STVID_DecimatedBitmapParams_t DecimatedBitmapParams;
+    U32 PictureSignature;
+    U32 CEHRegisters[32];
+} STVID_VideoParams_t;
+typedef struct STVID_PictureDescriptors_s
+{
+    U32 PictureMeanQP;
+    U32 PictureVarianceQP;
+} STVID_PictureDescriptors_t;
+typedef void * STVID_PictureBufferHandle_t;
+typedef struct STVID_PictureInfos_s
+{
+    STGXOBJ_Bitmap_t BitmapParams;
+    STVID_VideoParams_t VideoParams;
+    STVID_PictureBufferHandle_t PictureBufferHandle;
+    STVID_PictureBufferHandle_t DecimatedPictureBufferHandle;
+    STVID_PictureDescriptors_t PictureDescriptors;
+} STVID_PictureInfos_t;
+typedef struct STVID_FieldInfos_s
+{
+    BOOL DisplayTopNotBottom;
+    STVID_PictureBufferHandle_t PictureBufferHandle;
+} STVID_FieldInfos_t;
+typedef enum STVID_CharacteristicsChanged_e
+{
+    STVID_ASPECT_RATIO_CHANGE = 1,
+    STVID_SCAN_TYPE_CHANGE = 2,
+    STVID_FRAME_RATE_CHANGE = 4,
+    STVID_RESOLUTION_CHANGE = 8,
+    STVID_CENTRE_FRAME_OFFSET_CHANGE= 16,
+    STVID_3D_FORMAT = 32
+} STVID_CharacteristicsChanged_t;
+typedef struct STVID_PictureCharacteristicsChangeParams_s
+{
+    STVID_CharacteristicsChanged_t CharacteristicsChanged;
+    STVID_PictureInfos_t PictureInfo;
+} STVID_PictureCharacteristicsChangeParams_t;
+typedef struct STVID_DisplayPictureInfos_s
+{
+    U8 NumberOfPanAndScan;
+    struct
+    {
+        S32 FrameCentreHorizontalOffset;
+        S32 FrameCentreVerticalOffset;
+        U32 DisplayHorizontalSize;
+        U32 DisplayVerticalSize;
+        BOOL HasDisplaySizeRecommendation;
+    } PanAndScanIn16thPixel [3];
+    struct
+    {
+        U32 LeftOffset;
+        U32 RightOffset;
+        U32 TopOffset;
+        U32 BottomOffset;
+    } FrameCropInPixel;
+} STVID_DisplayPictureInfos_t;
+typedef struct STVID_SpeedDriftThreshold_s
+{
+    S32 DriftTime;
+    U32 BitRateValue;
+    U32 SpeedRatio;
+} STVID_SpeedDriftThreshold_t;
+typedef struct STVID_StartParams_s
+{
+    BOOL RealTime;
+    BOOL UpdateDisplay;
+    STVID_BroadcastProfile_t BrdCstProfile;
+    STVID_StreamType_t StreamType;
+    U8 StreamID;
+    BOOL DecodeOnce;
+} STVID_StartParams_t;
+typedef struct STVID_SynchronisationInfo_s
+{
+    S32 ClocksDifference;
+    BOOL IsSynchronisationOk;
+    BOOL IsLoosingSynchronisation;
+    BOOL IsBackToSynchronisation;
+} STVID_SynchronisationInfo_t;
+typedef struct STVID_TermParams_s
+{
+    BOOL ForceTerminate;
+} STVID_TermParams_t;
+typedef struct STVID_UserData_s
+{
+    STVID_BroadcastProfile_t BroadcastProfile;
+    STVID_UserDataPosition_t PositionInStream;
+    U32 Length;
+    BOOL BufferOverflow;
+    void * Buff_p;
+    STVID_PTS_t PTS;
+    S32 pTemporalReference;
+    BOOL IsRegistered;
+    U8 itu_t_t35_country_code;
+    U8 itu_t_t35_country_code_extension_byte;
+    U16 itu_t_t35_provider_code;
+} STVID_UserData_t;
+typedef struct STVID_MarkerData_t {
+    ST_MM_Bitstream_Marker_t Marker;
+    STVID_PTS_t PTS;
+    U32 MarkerID0;
+    U32 MarkerID1;
+} STVID_MarkerData_t;
+typedef void * STVID_ViewPortHandle_t;
+typedef struct STVID_ViewPortParams_s
+{
+    ST_DeviceName_t LayerName;
+} STVID_ViewPortParams_t;
+typedef struct STVID_WindowParams_s
+{
+    STVID_WinAlign_t Align;
+    STVID_WinSize_t Size;
+} STVID_WindowParams_t;
+typedef struct STVID_UnsupportedStreamType_s
+{
+    STVID_MPEGStandard_t MPEGStandard;
+    U32 UnsupportedProfileAndLevelIndication;
+    BOOL UnsupportedResolutionBeyondCapability;
+   union
+    {
+        struct
+        {
+            BOOL ASO;
+            BOOL FMO;
+            BOOL RedundantSlices;
+        } STANDARD_ISO_IEC_14496;
+        struct
+        {
+            BOOL GMCTool;
+            BOOL QuarterPixel;
+        } STANDARD_ISO_IEC_14496_2;
+    } Unsupported;
+} STVID_UnsupportedStreamType_t;
+typedef struct STVID_FlushParams_s
+{
+    STVID_FlushMode_t FlushMode;
+    struct
+    {
+        struct
+        {
+            U32 NbPictureToKeep;
+        } DiscontinuityBased;
+        struct
+        {
+            STVID_PTS_t PTS;
+            S32 Tolerance;
+        } PTSBased;
+    }Trigger;
+} STVID_FlushParams_t;
+typedef struct STVID_InjectionModeParams_s
+{
+    const U32 reserved;
+} STVID_InjectionModeParams_t;
+typedef struct STVID_EnhancedDataInputInterfaceParams_s
+{
+    struct
+    {
+        STVID_DataInputType_t DataInputType;
+        void * FunctionsHandle;
+        void * ReadAddress_p;
+        U32 Offset;
+    } InputBufferParams[2];
+    ST_ErrorCode_t (*GetWriteAddress) (void * Handle, void ** Address_p);
+    void (*InformReadAddress) (void * Handle, void * Address);
+} STVID_EnhancedDataInputInterfaceParams_t;
+ST_Revision_t STVID_GetRevision(void);
+ST_ErrorCode_t STVID_GetCapability(const ST_DeviceName_t DeviceName, STVID_Capability_t * const Capability_p);
+ST_ErrorCode_t STVID_Init(const ST_DeviceName_t DeviceName, const STVID_InitParams_t * const InitParams_p);
+ST_ErrorCode_t STVID_Open(const ST_DeviceName_t DeviceName, const STVID_OpenParams_t * const OpenParams_p, STVID_Handle_t * const Handle_p);
+ST_ErrorCode_t STVID_Close(const STVID_Handle_t Handle);
+ST_ErrorCode_t STVID_Term(const ST_DeviceName_t DeviceName, const STVID_TermParams_t * const TermParams_p);
+ST_ErrorCode_t STVID_Clear(const STVID_Handle_t Handle, const STVID_ClearParams_t * const Params_p);
+ST_ErrorCode_t STVID_ConfigureEvent(const STVID_Handle_t Handle, const STEVT_EventID_t Event, const STVID_ConfigureEventParams_t * const Params_p);
+ST_ErrorCode_t STVID_DataInjectionCompleted(const STVID_Handle_t Handle, const STVID_DataInjectionCompletedParams_t * const Params_p);
+ST_ErrorCode_t STVID_DeleteDataInputInterface(const STVID_Handle_t Handle);
+ST_ErrorCode_t STVID_DisableDeblocking(const STVID_Handle_t Handle);
+ST_ErrorCode_t STVID_DisableFrameRateConversion(const STVID_Handle_t Handle);
+ST_ErrorCode_t STVID_DisableSynchronisation(const STVID_Handle_t Handle);
+ST_ErrorCode_t STVID_DisableSynchronisationOnInterpolatedPTS(const STVID_Handle_t Handle);
+ST_ErrorCode_t STVID_EnableSynchronisationOnInterpolatedPTS(const STVID_Handle_t Handle);
+ST_ErrorCode_t STVID_SetInterpolatedPTSBaseline(const STVID_Handle_t VideoHandle,
+                                                const STVID_PTS_t * const InterpolatedPTSBaseline_p);
+ST_ErrorCode_t STVID_EnableDeblocking(const STVID_Handle_t Handle);
+ST_ErrorCode_t STVID_EnableFrameRateConversion(const STVID_Handle_t Handle);
+ST_ErrorCode_t STVID_EnableSynchronisation(const STVID_Handle_t Handle);
+ST_ErrorCode_t STVID_ForceDecimationFactor(const STVID_Handle_t Handle, const STVID_ForceDecimationFactorParams_t * const Params_p);
+ST_ErrorCode_t STVID_Freeze(const STVID_Handle_t Handle, const STVID_Freeze_t * const Freeze_p);
+ST_ErrorCode_t STVID_GetBitBufferFreeSize(const STVID_Handle_t Handle, U32 * const FreeSize_p);
+ST_ErrorCode_t STVID_GetBitBufferParams(const STVID_Handle_t Handle, void ** const BaseAddress_p, U32 * const InitSize_p);
+ST_ErrorCode_t STVID_GetDataInputBufferParams(const STVID_Handle_t
+     Handle, void ** const BaseAddress_NCp, U32 * const Size_p);
+ST_ErrorCode_t STVID_GetDecimationFactor(const STVID_Handle_t Handle, STVID_DecimationFactor_t * const DecimationFactor_p);
+ST_ErrorCode_t STVID_GetDecodedPictures(const STVID_Handle_t Handle, STVID_DecodedPictures_t * const DecodedPictures_p);
+ST_ErrorCode_t STVID_GetErrorRecoveryMode(const STVID_Handle_t Handle, STVID_ErrorRecoveryMode_t * const Mode_p);
+ST_ErrorCode_t STVID_GetMemoryProfile(const STVID_Handle_t Handle, STVID_MemoryProfile_t * const MemoryProfile_p);
+ST_ErrorCode_t STVID_GetPictureAllocInfos(const STVID_Handle_t Handle, const STVID_PictureInfos_t * const Params_p, STAVMEM_AllocBlockParams_t * const AllocParams_p);
+ST_ErrorCode_t STVID_GetPictureInfos(const STVID_Handle_t Handle, const STVID_Picture_t PictureType, STVID_PictureInfos_t * const PictureInfos_p);
+ST_ErrorCode_t STVID_GetDisplayPictureInfo(const STVID_Handle_t Handle, const STVID_PictureBufferHandle_t PictureBufferHandle, STVID_DisplayPictureInfos_t * const DisplayPictureInfos_p);
+ST_ErrorCode_t STVID_GetInjectionMode(const STVID_Handle_t VideoHandle, STVID_InjectionMode_t * const InjectionMode_p);
+ST_ErrorCode_t STVID_GetSpeed(const STVID_Handle_t Handle, S32 * const Speed_p);
+ST_ErrorCode_t STVID_InjectDiscontinuity(const STVID_Handle_t Handle);
+ST_ErrorCode_t STVID_Pause(const STVID_Handle_t Handle, const STVID_Freeze_t * const Freeze_p);
+ST_ErrorCode_t STVID_PostProcessingControl(const STVID_Handle_t VideoHandle, const STVID_POSTPROCESSING_Command_t POSTPROCESSING_Command, const STVID_POSTPROCESSING_Param_t * const POSTPROCESSING_Param_p);
+ST_ErrorCode_t STVID_Resume(const STVID_Handle_t Handle);
+ST_ErrorCode_t STVID_SetEnhancedDataInputInterface(const STVID_Handle_t Handle,
+                                                   const STVID_EnhancedDataInputInterfaceParams_t * const Params_p);
+ST_ErrorCode_t STVID_SetDataInputInterface(const STVID_Handle_t Handle,
+     ST_ErrorCode_t (*GetWriteAddress) (void * const Handle, void ** const Address_p),
+     void (*InformReadAddress)(void * const Handle, void * const Address),
+     void * const FunctionsHandle);
+ST_ErrorCode_t STVID_SetDeblockingStrength(const STVID_Handle_t VideoHandle, const U8 DeblockingStrength);
+ST_ErrorCode_t STVID_SetDecodedPictures(const STVID_Handle_t Handle, const STVID_DecodedPictures_t DecodedPictures);
+ST_ErrorCode_t STVID_SetErrorRecoveryMode(const STVID_Handle_t Handle, const STVID_ErrorRecoveryMode_t Mode);
+ST_ErrorCode_t STVID_SetInjectionMode(const STVID_Handle_t VideoHandle, const STVID_InjectionMode_t InjectionMode, const STVID_InjectionModeParams_t * const InjectionParams_p);
+ST_ErrorCode_t STVID_SetMemoryProfile(const STVID_Handle_t Handle, const STVID_MemoryProfile_t * const MemoryProfile_p);
+ST_ErrorCode_t STVID_SetSpeed(const STVID_Handle_t Handle, const S32 Speed);
+ST_ErrorCode_t STVID_Setup(const STVID_Handle_t Handle, const STVID_SetupParams_t * const SetupParams_p);
+ST_ErrorCode_t STVID_RepeatSynchro(const STVID_Handle_t Handle, const U32 NumberOfFields, U32 * const NumberDone_p);
+ST_ErrorCode_t STVID_SkipSynchro(const STVID_Handle_t Handle, const U32 NumberOfFields, U32 * const NumberDone_p);
+ST_ErrorCode_t STVID_Start(const STVID_Handle_t Handle, const STVID_StartParams_t * const Params_p);
+ST_ErrorCode_t STVID_StartUpdatingDisplay(const STVID_Handle_t Handle);
+ST_ErrorCode_t STVID_Step(const STVID_Handle_t Handle);
+ST_ErrorCode_t STVID_StepFrame(const STVID_Handle_t Handle);
+ST_ErrorCode_t STVID_Stop(const STVID_Handle_t Handle, const STVID_Stop_t StopMode, const STVID_Freeze_t * const Freeze_p);
+ST_ErrorCode_t STVID_GetSynchronizationDelay(const STVID_Handle_t VideoHandle, S32 * const SyncDelay_p);
+ST_ErrorCode_t STVID_SetSynchronizationDelay(const STVID_Handle_t VideoHandle, const S32 SyncDelay);
+ST_ErrorCode_t STVID_SetClockRecoverySource(const STVID_Handle_t Handle, const STCLKRV_Handle_t ClkSource);
+ST_ErrorCode_t STVID_Flush(const STVID_Handle_t VideoHandle, const STVID_FlushParams_t * const FlushParams_p);
+typedef struct STVID_GetPictureBufferParams_s
+{
+    STVID_PictureStructure_t PictureStructure;
+    BOOL TopFieldFirst;
+    BOOL ExpectingSecondField;
+    U32 ExtendedTemporalReference;
+    U32 PictureWidth;
+    U32 PictureHeight;
+} STVID_GetPictureBufferParams_t;
+typedef struct STVID_PictureBufferDataParams_s
+{
+    void * Data1_p;
+    void * Data1_Cp;
+    void * Data1_NCp;
+    U32 Size1;
+    void * Data2_p;
+    void * Data2_Cp;
+    void * Data2_NCp;
+    U32 Size2;
+} STVID_PictureBufferDataParams_t;
+typedef U32 STVID_SwapParams_t ;
+ST_ErrorCode_t STVID_ReleasePictureBuffer(const STVID_Handle_t Handle, const STVID_PictureBufferHandle_t PictureBufferHandle);
+ST_ErrorCode_t STVID_TakePictureBuffer(const STVID_Handle_t Handle, const STVID_PictureBufferHandle_t PictureBufferHandle);
+ST_ErrorCode_t STVID_DisableDisplay(const STVID_Handle_t VideoHandle);
+ST_ErrorCode_t STVID_EnableDisplay(const STVID_Handle_t VideoHandle);
+ST_ErrorCode_t STVID_PrintPictureBuffersStatus(const STVID_Handle_t Handle);
+        ST_ErrorCode_t STVID_CloseViewPort(const STVID_ViewPortHandle_t ViewPortHandle);
+        ST_ErrorCode_t STVID_LockViewPort(const STVID_ViewPortHandle_t ViewPortHandle, const STLAYER_UnLockViewportMode_t UnLockViewportMode);
+        ST_ErrorCode_t STVID_UnLockViewPort(const STVID_ViewPortHandle_t ViewPortHandle);
+        ST_ErrorCode_t STVID_DisableBorderAlpha(const STVID_ViewPortHandle_t ViewPortHandle);
+        ST_ErrorCode_t STVID_DisableColorKey(const STVID_ViewPortHandle_t ViewPortHandle);
+        ST_ErrorCode_t STVID_DisableOutputWindow(const STVID_ViewPortHandle_t ViewPortHandle);
+        ST_ErrorCode_t STVID_EnableBorderAlpha(const STVID_ViewPortHandle_t ViewPortHandle);
+        ST_ErrorCode_t STVID_EnableColorKey(const STVID_ViewPortHandle_t ViewPortHandle);
+        ST_ErrorCode_t STVID_EnableOutputWindow(const STVID_ViewPortHandle_t ViewPortHandle);
+        ST_ErrorCode_t STVID_GetAlignIOWindows(const STVID_ViewPortHandle_t ViewPortHandle,
+                            S32 * const InputWinX_p, S32 * const InputWinY_p, U32 * const InputWinWidth_p, U32 * const InputWinHeight_p,
+                            S32 * const OutputWinX_p, S32 * const OutputWinY_p, U32 * const OutputWinWidth_p, U32 * const OutputWinHeight_p);
+        ST_ErrorCode_t STVID_GetDisplayAspectRatioConversion(const STVID_ViewPortHandle_t ViewPortHandle, STVID_DisplayAspectRatioConversion_t * const Conversion_p);
+        ST_ErrorCode_t STVID_GetInputWindowMode(const STVID_ViewPortHandle_t ViewPortHandle, BOOL * const AutoMode_p, STVID_WindowParams_t * const WinParams_p);
+        ST_ErrorCode_t STVID_GetIOWindows(const STVID_ViewPortHandle_t ViewPortHandle,
+                            S32 * const InputWinX_p, S32 * const InputWinY_p, U32 * const InputWinWidth_p, U32 * const InputWinHeight_p,
+                            S32 * const OutputWinX_p, S32 * const OutputWinY_p, U32 * const OutputWinWidth_p, U32 * const OutputWinHeight_p);
+        ST_ErrorCode_t STVID_GetOutputWindowMode(const STVID_ViewPortHandle_t ViewPortHandle, BOOL * const AutoMode_p, STVID_WindowParams_t * const WinParams_p);
+        ST_ErrorCode_t STVID_GetViewPortAlpha(const STVID_ViewPortHandle_t ViewPortHandle, STLAYER_GlobalAlpha_t * const GlobalAlpha_p);
+        ST_ErrorCode_t STVID_GetViewPortColorKey(const STVID_ViewPortHandle_t ViewPortHandle, STGXOBJ_ColorKey_t * const ColorKey_p);
+        ST_ErrorCode_t STVID_GetViewPortPSI(const STVID_ViewPortHandle_t ViewPortHandle, STLAYER_PSI_t * const VPPSI_p);
+        ST_ErrorCode_t STVID_HidePicture(const STVID_ViewPortHandle_t ViewPortHandle);
+        ST_ErrorCode_t STVID_OpenViewPort(const STVID_Handle_t VideoHandle,
+                                          const STVID_ViewPortParams_t * const ViewPortParams_p,
+                                          STVID_ViewPortHandle_t * const ViewPortHandle_p);
+        ST_ErrorCode_t STVID_SetDisplayAspectRatioConversion(const STVID_ViewPortHandle_t ViewPortHandle, const STVID_DisplayAspectRatioConversion_t Mode);
+        ST_ErrorCode_t STVID_SetInputWindowMode(const STVID_ViewPortHandle_t ViewPortHandle, const BOOL AutoMode, const STVID_WindowParams_t * const WinParams_p);
+        ST_ErrorCode_t STVID_SetIOWindows(const STVID_ViewPortHandle_t ViewPortHandle,
+                            const S32 InputWinX, const S32 InputWinY, const U32 InputWinWidth, const U32 InputWinHeight,
+                            const S32 OutputWinX, const S32 OutputWinY, const U32 OutputWinWidth, const U32 OutputWinHeight);
+        ST_ErrorCode_t STVID_SetOutputWindowMode(const STVID_ViewPortHandle_t ViewPortHandle, const BOOL AutoMode, const STVID_WindowParams_t * const WinParams_p);
+        ST_ErrorCode_t STVID_SetViewPortAlpha(const STVID_ViewPortHandle_t ViewPortHandle, const STLAYER_GlobalAlpha_t * const GlobalAlpha_p);
+        ST_ErrorCode_t STVID_SetViewPortColorKey(const STVID_ViewPortHandle_t ViewPortHandle, const STGXOBJ_ColorKey_t * const ColorKey_p);
+        ST_ErrorCode_t STVID_SetViewPortPSI(const STVID_ViewPortHandle_t ViewPortHandle, const STLAYER_PSI_t * const VPPSI_p);
+        ST_ErrorCode_t STVID_ShowPicture(const STVID_ViewPortHandle_t ViewPortHandle, STVID_PictureInfos_t * const Infos_p, const STVID_Freeze_t * const Freeze_p);
+        ST_ErrorCode_t STVID_GetViewPortSpecialMode (const STVID_ViewPortHandle_t ViewPortHandle, STLAYER_OutputMode_t * const OuputMode_p, STLAYER_OutputWindowSpecialModeParams_t * const Params_p);
+        ST_ErrorCode_t STVID_SetViewPortSpecialMode (const STVID_ViewPortHandle_t ViewPortHandle, const STLAYER_OutputMode_t OuputMode, const STLAYER_OutputWindowSpecialModeParams_t * const Params_p);
+        ST_ErrorCode_t STVID_SwapViewPorts( const STVID_ViewPortHandle_t ViewPortHandle1, const STVID_ViewPortHandle_t ViewPortHandle2, STVID_SwapParams_t *SwapParams_p);
+ST_ErrorCode_t STVID_GetPictureBuffer(const STVID_Handle_t Handle, const STVID_GetPictureBufferParams_t * const Params_p,
+                                      STVID_PictureBufferDataParams_t * const PictureBufferParams_p,
+                                      STVID_PictureBufferHandle_t * const PictureBufferHandle_p);
+ST_ErrorCode_t STVID_DisplayPictureBuffer(const STVID_Handle_t Handle, const STVID_PictureBufferHandle_t PictureBufferHandle,
+                                          const STVID_PictureInfos_t* const PictureInfos_p);
+ST_ErrorCode_t STVID_SetFrameBuffersColorType(const STVID_Handle_t Handle, STGXOBJ_ColorType_t const ColorType);
+typedef struct STVID_Statistics_s
+{
+    U32 ApiPbLiveResetWaitForFirstPictureDetected;
+    U32 ApiPbLiveResetWaitForFirstPictureDecoded;
+    U32 ApiPbLiveResetWaitForNextPicture;
+    U32 AvsyncSkippedFields;
+    U32 AvsyncRepeatedFields;
+    U32 AvsyncMaxRepeatedFields;
+    U32 AvsyncFailedToSkipFields;
+    U32 AvsyncExtendedSTCAvailable;
+    U32 AvsyncPictureWithNonInterpolatedPTS;
+    U32 AvsyncPictureCheckedSynchronizedOk;
+    U32 AvsyncPTSInconsistency;
+    U32 DecodeHardwareSoftReset;
+    U32 DecodeStartCodeFound;
+    U32 DecodeSequenceFound;
+    U32 DecodeUserDataFound;
+    U32 DecodePictureFound;
+    U32 DecodePictureFoundMPEGFrameI;
+    U32 DecodePictureFoundMPEGFrameP;
+    U32 DecodePictureFoundMPEGFrameB;
+    U32 DecodePictureSkippedRequested;
+    U32 DecodePictureSkippedNotRequested;
+    U32 DecodePictureDecodeLaunched;
+    U32 DecodeStartConditionVbvDelay;
+    U32 DecodeStartConditionPtsTimeComparison;
+    U32 DecodeStartConditionVbvBufferSize;
+    U32 DecodeInterruptStartDecode;
+    U32 DecodeInterruptPipelineIdle;
+    U32 DecodeInterruptDecoderIdle;
+    U32 DecodeInterruptBitBufferEmpty;
+    U32 DecodeInterruptBitBufferFull;
+    U32 DecodePbStartCodeFoundInvalid;
+    U32 DecodePbStartCodeFoundVideoPES;
+    U32 DecodePbMaxNbInterruptSyntaxErrorPerPicture;
+    U32 DecodePbInterruptSyntaxError;
+    U32 DecodePbInterruptDecodeOverflowError;
+    U32 DecodePbInterruptDecodeUnderflowError;
+    U32 DecodePbDecodeTimeOutError;
+    U32 DecodePbInterruptMisalignmentError;
+    U32 DecodePbInterruptQueueOverflow;
+    U32 DecodePbHeaderFifoEmpty;
+    U32 DecodePbVbvSizeGreaterThanBitBuffer;
+    U32 DecodeMinBitBufferLevelReached;
+    U32 DecodeMaxBitBufferLevelReached;
+    U32 DecodePbSequenceNotInMemProfileSkipped;
+    U32 DecodePbParserError;
+    U32 DecodePbPreprocError;
+    U32 DecodePbFirmwareError;
+    U32 DecodeGNBvd42696Error;
+    U32 DecodeTimeNbPictures;
+    U32 DecodeTimeMinPreprocessTime;
+    U32 DecodeTimeMaxPreprocessTime;
+    U32 DecodeTimeSumOfPreprocessTime;
+    U32 DecodeTimeMinBufferSearchTime;
+    U32 DecodeTimeMaxBufferSearchTime;
+    U32 DecodeTimeSumOfBufferSearchTime;
+    U32 DecodeTimeMinDecodeTime;
+    U32 DecodeTimeMaxDecodeTime;
+    U32 DecodeTimeSumOfDecodeTime;
+    U32 DecodeTimeMinFullDecodeTime;
+    U32 DecodeTimeMaxFullDecodeTime;
+    U32 DecodeTimeSumOfFullDecodeTime;
+    U32 DisplayPictureInsertedInQueue;
+    U32 DisplayPictureInsertedInQueueDecimated;
+    U32 DisplayPictureDisplayedByMain;
+    U32 DisplayPictureDisplayedByAux;
+    U32 DisplayPictureDisplayedBySec;
+    U32 DisplayPictureDisplayedDecimatedByMain;
+    U32 DisplayPictureDisplayedDecimatedByAux;
+    U32 DisplayPictureDisplayedDecimatedBySec;
+    U32 DisplayPbQueueLockedByLackOfPicture;
+    U32 DisplayPbVSyncDuringDisplayProgramming;
+    U32 DisplayPbQueueOverflow;
+    U32 DisplayPbPictureTooLateRejectedByMain;
+    U32 DisplayPbPictureTooLateRejectedByAux;
+    U32 DisplayPbPictureTooLateRejectedBySec;
+    U32 DisplayPbPicturePreparedAtLastMinuteRejected;
+    U32 QueuePictureInsertedInQueue;
+    U32 QueuePictureRemovedFromQueue;
+    U32 QueuePicturePushedToDisplay;
+    U32 QueuePbPictureTooLateRejected;
+    U32 SpeedDisplayBFramesNb;
+    U32 SpeedDisplayPFramesNb;
+    U32 SpeedDisplayIFramesNb;
+    U32 MaxBitRate;
+    U32 MinBitRate;
+    U32 LastBitRate;
+    S32 MaxPositiveDriftRequested;
+    S32 MaxNegativeDriftRequested;
+    U32 NbDecodedPicturesB;
+    U32 NbDecodedPicturesP;
+    U32 NbDecodedPicturesI;
+    U32 SpeedSkipReturnNone;
+    U32 SpeedRepeatReturnNone;
+    U32 InjectFdmaTransfers;
+    void * InjectDataInputReadPointer;
+    void * InjectDataInputWritePointer;
+} STVID_Statistics_t;
+ST_ErrorCode_t STVID_GetStatistics(const ST_DeviceName_t DeviceName, STVID_Statistics_t * const Statistics_p);
+ST_ErrorCode_t STVID_ResetStatistics(const ST_DeviceName_t DeviceName, const STVID_Statistics_t * const Statistics_p);
+typedef struct STVID_Status_s
+{
+    void * BitBufferAddress_p;
+    U32 BitBufferSize;
+    void * DataInputBufferAddress_p;
+    U32 DataInputBufferSize;
+    void * SCListBufferAddress_p;
+    U32 SCListBufferSize;
+    void * IntermediateBuffersAddress_p;
+    U32 IntermediateBuffersSize;
+    U32 FdmaNodesSize;
+    U32 InjectFlushBufferSize;
+    STVID_MemoryProfile_t MemoryProfile;
+    enum StateMachine_e
+    {
+      VIDEO_STATE_STOPPED,
+      VIDEO_STATE_RUNNING,
+      VIDEO_STATE_PAUSING,
+      VIDEO_STATE_FREEZING
+    } StateMachine;
+    S32 SyncDelay;
+    BOOL VideoAlreadyStarted;
+    STVID_StartParams_t LastStartParams;
+    BOOL VideoAlreadyFreezed;
+    STVID_Freeze_t LastFreezeParams;
+    void * BitBufferReadPointer;
+    void * BitBufferWritePointer;
+    void * DataInputBufferReadPointer;
+    void * DataInputBufferWritePointer;
+    void * SCListBufferReadPointer;
+    void * SCListBufferWritePointer;
+    STVID_SequenceInfo_t* SequenceInfo_p;
+} STVID_Status_t;
+ST_ErrorCode_t STVID_GetStatus(const ST_DeviceName_t DeviceName, STVID_Status_t * const Status_p);
+        ST_ErrorCode_t STVID_SetViewPortQualityOptimizations(const STVID_ViewPortHandle_t ViewPortHandle,
+                                                             const STLAYER_QualityOptimizations_t * Params_p);
+        ST_ErrorCode_t STVID_GetViewPortQualityOptimizations(const STVID_ViewPortHandle_t ViewPortHandle,
+                                                             STLAYER_QualityOptimizations_t * const Params_p);
+        ST_ErrorCode_t STVID_GrabAndTakeViewportPictureBuffer (const STVID_ViewPortHandle_t ViewPortHandle,
+                                                               const STLAYER_GrabReleaseMode_t GrabReleaseMode,
+                                                               STLAYER_PictureInfos_t * const PictureInfos_p);
+        ST_ErrorCode_t STVID_ReleaseViewportPictureBuffer (const STVID_ViewPortHandle_t ViewPortHandle,
+                                                           const STLAYER_PictureBufferHandle_t PictureBufferHandle);
+        ST_ErrorCode_t STVID_SetViewPortDecimationMode (const STVID_ViewPortHandle_t ViewPortHandle,
+                                                        const STLAYER_DecimationMode_t DecimationMode);
+        ST_ErrorCode_t STVID_GetViewPortDecimationMode (const STVID_ViewPortHandle_t ViewPortHandle,
+                                                        STLAYER_DecimationMode_t * DecimationMode_p);
+            ST_ErrorCode_t STVID_GetVideoDisplayParams(const STVID_ViewPortHandle_t ViewPortHandle, STLAYER_VideoDisplayParams_t * Params_p);
+            ST_ErrorCode_t STVID_SetVideoDisplayParams(const STVID_ViewPortHandle_t ViewPortHandle, const STLAYER_VideoDisplayParams_t * Params_p);
+int stvid_IPrC_Handler(U32 request, void *arg);
+typedef enum VIDCOM_MODULE_ID_e
+{
+    VIDCOM_APPLICATION_MODULE_BASE,
+    VIDCOM_VIDORDQUEUE_MODULE_BASE,
+    VIDCOM_VIDAPI_MODULE_BASE,
+    VIDCOM_VIDDEC_REF_MODULE_BASE,
+    VIDCOM_VIDBUFF_MODULE_BASE,
+    VIDCOM_VIDDEC_MODULE_BASE,
+    VIDCOM_VIDDISP_MODULE_BASE,
+    VIDCOM_VIDSPEED_MODULE_BASE,
+    VIDCOM_VIDTRICK_MODULE_BASE,
+    VIDCOM_VIDPROD_MODULE_BASE,
+    VIDCOM_VIDQUEUE_MODULE_BASE,
+    VIDCOM_DEI_MODULE_BASE,
+    VIDCOM_XCODE_MODULE_BASE,
+    VIDCOM_LAYER_MODULE_BASE,
+    VIDCOM_MAX_MODULE_NBR
+} VIDCOM_MODULE_ID_t;
+typedef enum VIDCOM_ErrorLevel_e
+{
+    VIDCOM_ERROR_LEVEL_NONE = 0,
+    VIDCOM_ERROR_LEVEL_INFORMATION = 1,
+    VIDCOM_ERROR_LEVEL_BAD_DISPLAY = 2,
+    VIDCOM_ERROR_LEVEL_CRASH = 4,
+    VIDCOM_ERROR_LEVEL_RESET = 8
+} VIDCOM_ErrorLevel_t;
+typedef enum VIDBUFF_AllocationMode_e
+{
+    VIDBUFF_ALLOCATION_MODE_SHARED_MEMORY,
+    VIDBUFF_ALLOCATION_MODE_CPU_PARTITION
+} VIDBUFF_AllocationMode_t;
+typedef enum VIDBUFF_FrameBufferType_e
+{
+    VIDBUFF_UNKNOWN_FRAME_BUFFER_TYPE,
+    VIDBUFF_PRIMARY_FRAME_BUFFER,
+    VIDBUFF_INTERNAL_FRAME_BUFFER,
+    VIDBUFF_SECONDARY_FRAME_BUFFER,
+    VIDBUFF_EXTRA_PRIMARY_FRAME_BUFFER,
+    VIDBUFF_EXTRA_SECONDARY_FRAME_BUFFER
+} VIDBUFF_FrameBufferType_t;
+typedef enum VIDBUFF_AvailableReconstructionMode_e
+{
+    VIDBUFF_NONE_RECONSTRUCTION,
+    VIDBUFF_MAIN_RECONSTRUCTION,
+    VIDBUFF_SECONDARY_RECONSTRUCTION,
+    VIDBUFF_BOTH_RECONSTRUCTION
+} VIDBUFF_AvailableReconstructionMode_t;
+typedef enum VIDBUFF_BufferType_e
+{
+    VIDBUFF_BUFFER_SIMPLE,
+    VIDBUFF_BUFFER_FRAME_12BITS_PER_PIXEL,
+    VIDBUFF_BUFFER_FRAME_16BITS_PER_PIXEL,
+    VIDBUFF_BUFFER_FRAME_24BITS_PER_PIXEL,
+    VIDBUFF_BUFFER_FRAME_32BITS_PER_PIXEL
+} VIDBUFF_BufferType_t;
+typedef enum VIDBUFF_PictureDecodingStatus_e
+{
+    VIDBUFF_PICTURE_BUFFER_EMPTY,
+    VIDBUFF_PICTURE_BUFFER_PARSED,
+    VIDBUFF_PICTURE_BUFFER_WAITING_CONFIRM_EVT,
+    VIDBUFF_PICTURE_BUFFER_WAITING_FRAME_BUFFER,
+    VIDBUFF_PICTURE_BUFFER_DECODING,
+    VIDBUFF_PICTURE_BUFFER_DECODED
+} VIDBUFF_PictureDecodingStatus_t;
+typedef enum VIDCOM_DegradationMode_e
+{
+    NO_DEGRADED_MODE = 0,
+    DEGRADED_BSLICES,
+    DEGRADED_PSLICES
+} VIDCOM_DegradationMode_t;
+typedef struct VIDCOM_Interrupt_s {
+    U32 Mask;
+    U32 Status;
+    BOOL InstallHandler;
+    U32 Level;
+    U32 Number;
+    STEVT_EventID_t EventID;
+} VIDCOM_Interrupt_t;
+typedef struct VIDCOM_Task_s {
+    STOS_Task_t * Task_p;
+    STOS_TaskDesc_t TaskDesc;
+    void * TaskStack;
+    BOOL IsRunning;
+    BOOL ToBeDeleted;
+} VIDCOM_Task_t;
+typedef struct VIDCOM_InternalProfile_s
+{
+    STVID_MemoryProfile_t ApiProfile;
+    U32 NbMainFrameStore;
+    U32 NbSecondaryFrameStore;
+    STVID_DecimationFactor_t ApplicableDecimationFactor;
+} VIDCOM_InternalProfile_t;
+typedef struct VIDCOM_FrameCropInPixel_s
+{
+    U32 LeftOffset;
+    U32 RightOffset;
+    U32 TopOffset;
+    U32 BottomOffset;
+} VIDCOM_FrameCropInPixel_t;
+typedef struct VIDCOM_GlobalDecodingContextGenericData_s
+{
+    STVID_SequenceInfo_t SequenceInfo;
+    U8 ColourPrimaries;
+    U8 TransferCharacteristics;
+    U8 MatrixCoefficients;
+    VIDCOM_FrameCropInPixel_t FrameCropInPixel;
+    U8 NumberOfReferenceFrames;
+    U8 MaxDecFrameBuffering;
+    VIDCOM_ErrorLevel_t ParsingError;
+} VIDCOM_GlobalDecodingContextGenericData_t;
+typedef struct VIDCOM_GlobalDecodingContext_s
+{
+    VIDCOM_GlobalDecodingContextGenericData_t GlobalDecodingContextGenericData;
+    U32 SizeOfGlobalDecodingContextSpecificDataInByte;
+    void * GlobalDecodingContextSpecificData_p;
+} VIDCOM_GlobalDecodingContext_t;
+typedef struct VIDCOM_PictureDecodingContext_s
+{
+    VIDCOM_GlobalDecodingContext_t * GlobalDecodingContext_p;
+    U32 SizeOfPictureDecodingContextSpecificDataInByte;
+    void * PictureDecodingContextSpecificData_p;
+} VIDCOM_PictureDecodingContext_t;
+typedef struct VIDCOM_PictureID_s
+{
+    S32 ID;
+    U32 IDExtension;
+} VIDCOM_PictureID_t;
+typedef struct VIDCOM_PanAndScanIn16thPixel_s
+{
+    S32 FrameCentreHorizontalOffset;
+    S32 FrameCentreVerticalOffset;
+    U32 DisplayHorizontalSize;
+    U32 DisplayVerticalSize;
+    BOOL HasDisplaySizeRecommendation;
+} VIDCOM_PanAndScanIn16thPixel_t;
+typedef struct VIDCOM_PictureGenericData_s
+{
+    STVID_PictureInfos_t PictureInfos;
+    BOOL RepeatFirstField;
+    U8 RepeatProgressiveCounter;
+    VIDCOM_PanAndScanIn16thPixel_t PanAndScanIn16thPixel[3];
+    U8 NumberOfPanAndScan;
+    U32 PanScanRectRepetitionPeriod;
+    S32 PanScanRectPersistence;
+    U32 DecodingOrderFrameID;
+    VIDCOM_PictureID_t ExtendedPresentationOrderPictureID;
+    BOOL IsExtendedPresentationOrderIDValid;
+    BOOL IsDisplayBoundPictureIDValid;
+    VIDCOM_PictureID_t DisplayBoundPictureID;
+    BOOL IsFirstOfTwoFields;
+    BOOL PreviousPictureHasAMissingField;
+    U32 MissingFieldPictureDecodingOrderFrameID;
+    BOOL IsReference;
+    U32 FullReferenceFrameList[16];
+    BOOL IsValidIndexInReferenceFrame[16];
+    BOOL IsBrokenLinkIndexInReferenceFrame[16];
+    U32 UsedSizeInReferenceListP0;
+    U32 ReferenceListP0[(2 * 16)];
+    U32 UsedSizeInReferenceListB0;
+    U32 ReferenceListB0[(2 * 16)];
+    U32 UsedSizeInReferenceListB1;
+    U32 ReferenceListB1[(2 * 16)];
+    void * BitBufferPictureStartAddress;
+    void * BitBufferPictureStopAddress;
+    struct
+    {
+        BOOL FlushPresentationQueue;
+        BOOL FreezePresentationOnThisFrame;
+        BOOL ResumePresentationOnThisFrame;
+    } AsynchronousCommands;
+    STOS_Clock_t DecodeStartTime;
+    BOOL IsDecodeStartTimeValid;
+    STOS_Clock_t PresentationStartTime;
+    BOOL IsPresentationStartTimeValid;
+    U32 NbFieldsDisplay;
+    VIDCOM_ErrorLevel_t ParsingError;
+    U32 AccessUnitID;
+} VIDCOM_PictureGenericData_t;
+typedef struct VIDCOM_ParsedPictureInformation_s
+{
+    VIDCOM_PictureDecodingContext_t * PictureDecodingContext_p;
+    VIDCOM_PictureGenericData_t PictureGenericData;
+    U32 SizeOfPictureSpecificDataInByte;
+    void * PictureSpecificData_p;
+} VIDCOM_ParsedPictureInformation_t;
+typedef struct VIDCOM_FrameOrFieldIdInfo_s
+{
+    BOOL IsFrameOrFirstField;
+ struct VIDBUFF_FrameBuffer_s * LinkedFrameBuffer_p;
+} VIDCOM_FrameOrFieldIdInfo_t;
+typedef struct VIDBUFF_BufferAllocationParams_s
+{
+    STAVMEM_PartitionHandle_t PartitionHandle;
+    VIDBUFF_BufferType_t BufferType;
+    void * Address_p;
+    void * Address_NCp;
+    void * Address_Cp;
+    U32 TotalSize;
+    void * Address2_p;
+    void * Address2_NCp;
+    void * Address2_Cp;
+    U32 Size2;
+    VIDBUFF_AllocationMode_t AllocationMode;
+    STAVMEM_BlockHandle_t AvmemBlockHandle;
+    BOOL IsBlockLockedAndNotFreeable;
+} VIDBUFF_BufferAllocationParams_t;
+typedef struct VIDBUFF_AdditionnalData_s
+{
+    STAVMEM_PartitionHandle_t AvmemPartitionHandleForAdditionnalData;
+    STAVMEM_BlockHandle_t AvmemBlockHandle;
+    void * Address_p;
+    U32 Size;
+    U8 FieldCounter;
+    BOOL TobeKilledAsap;
+} VIDBUFF_AdditionnalData_t;
+typedef struct VIDBUFF_ModuleCounter_s
+{
+ U32 TakeReleaseCounter;
+} VIDBUFF_ModuleCounter_t;
+typedef struct VIDBUFF_TakeReleaseStatus_s
+{
+    U32 PictureLockCounter;
+    VIDBUFF_ModuleCounter_t Module[VIDCOM_MAX_MODULE_NBR];
+} VIDBUFF_TakeReleaseStatus_t;
+typedef struct VIDBUFF_FrameBuffer_s
+{
+    VIDBUFF_BufferAllocationParams_t Allocation;
+    BOOL AllocationIsDone;
+    BOOL ToBeKilledAsSoonAsPossible;
+    STVID_DecimationFactor_t DecimationFactor;
+    BOOL AdvancedHDecimation;
+    VIDBUFF_AvailableReconstructionMode_t AvailableReconstructionMode;
+    VIDBUFF_FrameBufferType_t FrameBufferType;
+ VIDCOM_FrameOrFieldIdInfo_t FrameOrFirstFieldId;
+ VIDCOM_FrameOrFieldIdInfo_t NothingOrSecondFieldId;
+    struct VIDBUFF_FrameBuffer_s * NextAllocated_p;
+    struct VIDBUFF_PictureBuffer_s * FrameOrFirstFieldPicture_p;
+    struct VIDBUFF_PictureBuffer_s * NothingOrSecondFieldPicture_p;
+    VIDBUFF_AdditionnalData_t PPB;
+    VIDBUFF_TakeReleaseStatus_t Buffers;
+} VIDBUFF_FrameBuffer_t;
+typedef struct VIDBUFF_PictureBuffer_s
+{
+    VIDCOM_ParsedPictureInformation_t ParsedPictureInformation;
+    U8 PictureSpecificData[(1140)];
+    VIDCOM_PictureDecodingContext_t PictureDecodingContext;
+    U8 PictureDecodingContextSpecificData[(1020)];
+    VIDCOM_GlobalDecodingContext_t GlobalDecodingContext;
+    U8 GlobalDecodingContextSpecificData[(4096)];
+    BOOL IsReferenceForDecoding;
+    BOOL IsNeededForPresentation;
+    BOOL IsPushed;
+    VIDBUFF_FrameBuffer_t * ReferencesFrameBufferPointer[16];
+    VIDCOM_ErrorLevel_t ReferenceDecodingError;
+    BOOL IsInUse;
+    VIDBUFF_FrameBuffer_t * InternalFrameBuffer_p;
+    VIDBUFF_FrameBuffer_t * FrameBuffer_p;
+    VIDBUFF_FrameBuffer_t * SecondViewFrameBuffer_p;
+    VIDBUFF_FrameBuffer_t * DecimatedFrameBuffer_p;
+    VIDBUFF_BufferAllocationParams_t* BitBuffer_p;
+    struct
+    {
+        VIDBUFF_PictureDecodingStatus_t PictureDecodingStatus;
+        U32 CommandId;
+        STOS_Clock_t StartTime;
+        STOS_Clock_t ConfirmEVTTime;
+        STOS_Clock_t BufferSeachStartTime;
+        STOS_Clock_t ConfirmedTime;
+        STOS_Clock_t DecodeStartTime;
+        STOS_Clock_t JobCompletedTime;
+        VIDCOM_ErrorLevel_t DecodingError;
+    } Decode;
+    void * SmoothBackwardPictureInfo_p;
+    struct
+    {
+        BOOL IsInDisplayList;
+        BOOL IsInDisplayQueue;
+        BOOL IsGoneOutOfDisplay;
+        struct VIDBUFF_PictureBuffer_s * DecodedPictureBuffer_p;
+        struct VIDBUFF_PictureBuffer_s * ReferencePicturesList[16];
+        U32 NumberOfReferences;
+        BOOL IsReducedRefList;
+        struct VIDBUFF_PictureBuffer_s * NextDisplayablePicture_p;
+        struct VIDBUFF_PictureBuffer_s * AssociatedFieldPicture_p;
+        struct VIDBUFF_PictureBuffer_s * PreviousIPicture_p;
+        void * LinearBitBufferStoredInfo_p;
+        U32 IndiceInBuffer;
+    } SmoothBackward;
+    BOOL IsTemporalDiscontinuity;
+    U32 PictureNumber;
+    U32 PictureIndexInGOP;
+} VIDBUFF_PictureBuffer_t;
+typedef struct VIDBUFF_BufferBaseAddresses_s
+{
+    void * BaseAddress_p;
+    void * BaseAddress_NCp;
+    void * BaseAddress_Cp;
+} VIDBUFF_BufferBaseAddresses_t;
+typedef struct {
+    U8 * Data_p;
+    U32 TotalSize;
+    U32 UsedSize;
+    U32 MaxUsedSize;
+    U8 * BeginPointer_p;
+} CommandsBuffer_t;
+typedef struct {
+    U32 * Data_p;
+    U32 TotalSize;
+    U32 UsedSize;
+    U32 MaxUsedSize;
+    U32 * BeginPointer_p;
+} CommandsBuffer32_t;
+typedef struct
+{
+    STVID_DeviceType_t DeviceType;
+    STVID_BroadcastProfile_t BrdCstProfile;
+    U32 VTGFrameRate;
+} BitmapDefaultFillParams_t;
+void vidcom_IncrementTimeCode(STVID_TimeCode_t * const TimeCode_p, const U32 FrameRate, BOOL DropFrameFlag);
+ST_ErrorCode_t vidcom_PopCommand(CommandsBuffer_t * const Buffer_p, U8 * const Data_p);
+void vidcom_PushCommand(CommandsBuffer_t * const Buffer_p, const U8 Data);
+ST_ErrorCode_t vidcom_PopCommand32(CommandsBuffer32_t * const Buffer_p, U32 * const Data_p);
+void vidcom_PushCommand32(CommandsBuffer32_t * const Buffer_p, const U32 Data);
+void vidcom_PushCommand32DoOrValueIfFull(CommandsBuffer32_t * const Buffer_p, const U32 Data);
+S32 vidcom_ComparePictureID(VIDCOM_PictureID_t *PictureID1_p, VIDCOM_PictureID_t *PictureID2_p);
+void vidcom_FillBitmapWithDefaults(const BitmapDefaultFillParams_t * const BitmapDefaultFillParams_p, STGXOBJ_Bitmap_t * const Bitmap_p);
+ST_ErrorCode_t vidcom_FillBlock1D(void * const Pattern_Cp, const U32 PatternSize,
+                                  void * const DestAddr_Cp, const U32 DestSize);
+void vidcom_NotifyUserData(STEVT_Handle_t EventsHandle, STEVT_EventID_t EventId, STVID_UserData_t * UserData_p);
+void vidcom_FillBitmapParamsFromFrameBufferAllocData(STGXOBJ_Bitmap_t * BitmapParams_p,
+                                                     VIDBUFF_BufferAllocationParams_t * FrameBufferAllocData_p);
+void vidcom_FillDecimatedBitmapParamsFromFrameBufferAllocData(STVID_DecimatedBitmapParams_t * DecimatedBitmapParams_p,
+                                                              VIDBUFF_BufferAllocationParams_t * FrameBufferAllocData_p);
+typedef enum MME_AllocationFlags_t {
+  MME_ALLOCATION_PHYSICAL = 1,
+  MME_ALLOCATION_CACHED = 2,
+  MME_ALLOCATION_UNCACHED = 4
+} MME_AllocationFlags_t;
+typedef enum MME_CommandCode_t {
+  MME_SET_PARAMS,
+  MME_TRANSFORM,
+  MME_SEND_BUFFERS,
+  MME_PING
+} MME_CommandCode_t;
+typedef enum MME_CommandState_t {
+  MME_COMMAND_IDLE,
+  MME_COMMAND_PENDING,
+  MME_COMMAND_EXECUTING,
+  MME_COMMAND_COMPLETED,
+  MME_COMMAND_FAILED
+} MME_CommandState_t;
+typedef enum MME_CommandEndType_t {
+  MME_COMMAND_END_RETURN_NO_INFO,
+  MME_COMMAND_END_RETURN_NOTIFY,
+  MME_COMMAND_END_RETURN_WAKE
+} MME_CommandEndType_t;
+typedef enum MME_Event_t {
+  MME_COMMAND_COMPLETED_EVT,
+  MME_DATA_UNDERFLOW_EVT,
+  MME_NOT_ENOUGH_MEMORY_EVT,
+  MME_NEW_COMMAND_EVT,
+  MME_TRANSFORMER_TIMEOUT
+} MME_Event_t;
+typedef enum MME_ERROR {
+  MME_SUCCESS = 0,
+  MME_DRIVER_NOT_INITIALIZED = 1,
+  MME_DRIVER_ALREADY_INITIALIZED = 2,
+  MME_NOMEM = 3,
+  MME_INVALID_TRANSPORT = 4,
+  MME_INVALID_HANDLE = 5,
+  MME_INVALID_ARGUMENT = 6,
+  MME_UNKNOWN_TRANSFORMER = 7,
+  MME_TRANSFORMER_NOT_RESPONDING = 8,
+  MME_HANDLES_STILL_OPEN = 9,
+  MME_COMMAND_STILL_EXECUTING = 10,
+  MME_COMMAND_ABORTED = 11,
+  MME_DATA_UNDERFLOW = 12,
+  MME_DATA_OVERFLOW = 13,
+  MME_TRANSFORM_DEFERRED = 14,
+  MME_SYSTEM_INTERRUPT = 15,
+  MME_ICS_ERROR = 16,
+  MME_INTERNAL_ERROR = 17,
+  MME_NOT_IMPLEMENTED = 18,
+  MME_COMMAND_TIMEOUT = 19
+} MME_ERROR;
+typedef enum MME_CacheFlags_t {
+  MME_DATA_CACHE_COHERENT = (1 << 31),
+  MME_DATA_TRANSIENT = (1 << 30),
+  MME_REMOTE_CACHE_COHERENT = (1 << 29),
+  MME_DATA_PHYSICAL = (1 << 28)
+} MME_CacheFlags_t;
+typedef enum {
+  MME_TUNEABLE_MANAGER_THREAD_PRIORITY,
+  MME_TUNEABLE_TRANSFORMER_THREAD_PRIORITY,
+  MME_TUNEABLE_EXECUTION_LOOP_HIGHEST_PRIORITY,
+  MME_TUNEABLE_EXECUTION_LOOP_ABOVE_NORMAL_PRIORITY,
+  MME_TUNEABLE_EXECUTION_LOOP_NORMAL_PRIORITY,
+  MME_TUNEABLE_EXECUTION_LOOP_BELOW_NORMAL_PRIORITY,
+  MME_TUNEABLE_EXECUTION_LOOP_LOWEST_PRIORITY,
+  MME_TUNEABLE_TRANSFORMER_TIMEOUT,
+  MME_TUNEABLE_BUFFER_POOL_SIZE,
+  MME_TUNEABLE_COMMAND_TIMEOUT,
+  MME_TUNEABLE_MAX
+} MME_Tuneable_t;
+typedef enum MME_Priority_t {
+  MME_PRIORITY_HIGHEST = 5000,
+  MME_PRIORITY_ABOVE_NORMAL = 4000,
+  MME_PRIORITY_NORMAL = 3000,
+  MME_PRIORITY_BELOW_NORMAL = 2000,
+  MME_PRIORITY_LOWEST = 1000
+} MME_Priority_t;
+typedef unsigned int MME_UINT;
+typedef unsigned long MME_ULONG;
+typedef unsigned long MME_SIZE;
+typedef double MME_GENERIC64;
+typedef MME_UINT MME_Time_t;
+typedef void* MME_GenericParams_t;
+typedef MME_UINT MME_CommandId_t;
+typedef MME_UINT MME_TransformerHandle_t;
+typedef MME_UINT MME_MemoryHandle_t;
+typedef struct MME_CommandStatus_t {
+  MME_CommandId_t CmdId;
+  MME_CommandState_t State;
+  MME_Time_t ProcessedTime;
+  MME_ERROR Error;
+  MME_UINT AdditionalInfoSize;
+  MME_GenericParams_t AdditionalInfo_p;
+} MME_CommandStatus_t;
+typedef struct MME_ScatterPage_t {
+  void* Page_p;
+  MME_UINT Size;
+  MME_UINT BytesUsed;
+  MME_UINT FlagsIn;
+  MME_UINT FlagsOut;
+} MME_ScatterPage_t;
+typedef struct MME_DataBuffer_t {
+  MME_UINT StructSize;
+  void* UserData_p;
+  MME_UINT Flags;
+  MME_UINT StreamNumber;
+  MME_UINT NumberOfScatterPages;
+  MME_ScatterPage_t* ScatterPages_p;
+  MME_UINT TotalSize;
+  MME_UINT StartOffset;
+} MME_DataBuffer_t;
+typedef struct MME_Command_t {
+  MME_UINT StructSize;
+  MME_CommandCode_t CmdCode;
+  MME_CommandEndType_t CmdEnd;
+  MME_Time_t DueTime;
+  MME_UINT NumberInputBuffers;
+  MME_UINT NumberOutputBuffers;
+  MME_DataBuffer_t** DataBuffers_p;
+  MME_CommandStatus_t CmdStatus;
+  MME_UINT ParamSize;
+  MME_GenericParams_t Param_p;
+} MME_Command_t;
+typedef struct MME_DataFormat_t {
+  unsigned char FourCC[4];
+} MME_DataFormat_t;
+typedef struct MME_TransformerCapability_t {
+  MME_UINT StructSize;
+  MME_UINT Version;
+  MME_DataFormat_t InputType;
+  MME_DataFormat_t OutputType;
+  MME_UINT TransformerInfoSize;
+  MME_GenericParams_t TransformerInfo_p;
+} MME_TransformerCapability_t;
+typedef void (*MME_GenericCallback_t) (MME_Event_t event, MME_Command_t * callbackData, void *userData);
+typedef struct MME_TransformerInitParams_t {
+  MME_UINT StructSize;
+  MME_Priority_t Priority;
+  MME_GenericCallback_t Callback;
+  void* CallbackUserData;
+  MME_UINT TransformerInitParamsSize;
+  MME_GenericParams_t TransformerInitParams_p;
+} MME_TransformerInitParams_t;
+typedef MME_ERROR (*MME_AbortCommand_t) (void *context, MME_CommandId_t commandId);
+typedef MME_ERROR (*MME_GetTransformerCapability_t) (MME_TransformerCapability_t * capability);
+typedef MME_ERROR (*MME_InitTransformer_t) (MME_UINT initParamsLength, MME_GenericParams_t initParams, void **context);
+typedef MME_ERROR (*MME_ProcessCommand_t) (void *context, MME_Command_t * commandInfo);
+typedef MME_ERROR (*MME_TermTransformer_t) (void *context);
+MME_ERROR MME_AbortCommand (MME_TransformerHandle_t handle, MME_CommandId_t cmdId);
+MME_ERROR MME_KillCommand (MME_TransformerHandle_t handle, MME_CommandId_t cmdId);
+MME_ERROR MME_KillCommandAll (MME_TransformerHandle_t handle);
+MME_ERROR MME_AllocDataBuffer (MME_TransformerHandle_t handle,
+          MME_UINT size,
+          MME_AllocationFlags_t flags,
+          MME_DataBuffer_t ** dataBuffer_p);
+MME_ERROR MME_DeregisterTransformer (const char *name);
+MME_ERROR MME_DeregisterTransport (const char *name);
+MME_ERROR MME_FreeDataBuffer (MME_DataBuffer_t * DataBuffer);
+MME_ERROR MME_GetTransformerCapability (const char *name,
+     MME_TransformerCapability_t * capability);
+MME_ERROR MME_Init (void);
+MME_ERROR MME_InitTransformer (const char *name,
+          MME_TransformerInitParams_t * params,
+          MME_TransformerHandle_t * handlep);
+MME_ERROR MME_ModifyTuneable (MME_Tuneable_t key, MME_UINT value);
+MME_UINT MME_GetTuneable (MME_Tuneable_t key);
+MME_ERROR MME_NotifyHost (MME_Event_t event, MME_Command_t * commandInfo, MME_ERROR res);
+MME_ERROR MME_RegisterTransformer (const char *name,
+       MME_AbortCommand_t abortFunc,
+       MME_GetTransformerCapability_t getTransformerCapabilityFunc,
+       MME_InitTransformer_t initTransformerFunc,
+       MME_ProcessCommand_t processCommandFunc,
+       MME_TermTransformer_t termTransformerFunc);
+MME_ERROR MME_RegisterTransport (const char *name);
+MME_ERROR MME_Run (void);
+MME_ERROR MME_SendCommand (MME_TransformerHandle_t handle, MME_Command_t *commandInfo);
+MME_ERROR MME_Term (void);
+MME_ERROR MME_TermTransformer (MME_TransformerHandle_t handle);
+MME_ERROR MME_KillTransformer (MME_TransformerHandle_t handle);
+MME_ERROR MME_IsStillAlive (MME_TransformerHandle_t handle, MME_UINT *alive);
+MME_ERROR MME_HostRegisterTransport(const char *name);
+MME_ERROR MME_HostDeregisterTransport(const char* name);
+MME_ERROR MME_HostInit(void);
+MME_ERROR MME_HostTerm(void);
+const char *MME_Version (void);
+MME_ERROR MME_WaitCommand (MME_TransformerHandle_t handle,
+      MME_CommandId_t cmdId,
+      MME_Event_t *eventp,
+      MME_Time_t timeout);
+MME_ERROR MME_PingTransformer (MME_TransformerHandle_t handle, MME_Time_t timeout);
+MME_ERROR MME_RegisterMemory (MME_TransformerHandle_t handle,
+         void *base,
+         MME_SIZE size,
+         MME_MemoryHandle_t *handlep);
+MME_ERROR MME_DeregisterMemory (MME_MemoryHandle_t handle);
+typedef enum mme_debug_flags
+{
+  MME_DBG = 0x0000,
+  MME_DBG_ERR = 0x0001,
+  MME_DBG_INIT = 0x0002,
+  MME_DBG_MANAGER = 0x0004,
+  MME_DBG_RECEIVER = 0x0010,
+  MME_DBG_TRANSFORMER = 0x0020,
+  MME_DBG_EXEC = 0x0040,
+  MME_DBG_COMMAND = 0x0100,
+  MME_DBG_BUFFER = 0x0200,
+} MME_DBG_FLAGS;
+const char *MME_ErrorStr (MME_ERROR res);
+MME_ERROR MME_DebugFlags (MME_DBG_FLAGS flags);
+typedef long int wchar_t;
+typedef void EMBX_VOID;
+typedef char EMBX_CHAR;
+typedef unsigned char EMBX_UCHAR;
+typedef unsigned char EMBX_BYTE;
+typedef short EMBX_SHORT;
+typedef unsigned short EMBX_USHORT;
+typedef int EMBX_INT;
+typedef unsigned int EMBX_UINT;
+typedef long EMBX_LONG;
+typedef unsigned long EMBX_ULONG;
+typedef int EMBX_BOOL;
+typedef unsigned long EMBX_OFFSET;
+typedef size_t EMBX_SIZE;
+typedef EMBX_UINT EMBX_HANDLE;
+typedef EMBX_HANDLE EMBX_PORT;
+typedef EMBX_HANDLE EMBX_HEAP;
+typedef EMBX_HANDLE EMBX_FACTORY;
+typedef EMBX_HANDLE EMBX_TRANSPORT;
+typedef enum
+{
+  EMBX_SUCCESS = 0,
+  EMBX_DRIVER_NOT_INITIALIZED,
+  EMBX_ALREADY_INITIALIZED,
+  EMBX_NOMEM,
+  EMBX_INVALID_ARGUMENT,
+  EMBX_INVALID_PORT,
+  EMBX_INVALID_STATUS,
+  EMBX_INVALID_TRANSPORT,
+  EMBX_TRANSPORT_INVALIDATED,
+  EMBX_TRANSPORT_CLOSED,
+  EMBX_PORTS_STILL_OPEN,
+  EMBX_PORT_INVALIDATED,
+  EMBX_PORT_CLOSED,
+  EMBX_PORT_NOT_BIND,
+  EMBX_ALREADY_BIND,
+  EMBX_CONNECTION_REFUSED,
+  EMBX_SYSTEM_INTERRUPT,
+  EMBX_SYSTEM_ERROR,
+  EMBX_INCOHERENT_MEMORY,
+  EMBX_SYSTEM_TIMEOUT,
+} EMBX_ERROR;
+typedef enum {
+  EMBX_TUNEABLE_THREAD_STACK_SIZE,
+  EMBX_TUNEABLE_THREAD_PRIORITY,
+  EMBX_TUNEABLE_MAILBOX_PRIORITY,
+  EMBX_TUNEABLE_MAX
+} EMBX_Tuneable_t;
+typedef enum
+{
+  EMBX_INLINE = 0x01,
+  EMBX_CACHED = 0x02,
+  EMBX_UNCACHED = 0x04,
+  EMBX_WRITE_BUFFER = 0x08,
+} EMBX_MEM_FLAGS;
+typedef struct
+{
+  EMBX_VOID *data;
+  EMBX_SIZE size;
+  EMBX_MEM_FLAGS flags;
+  EMBX_UINT srcCpu;
+  EMBX_CHAR payload[96];
+} EMBX_RECEIVE_EVENT;
+typedef struct
+{
+    EMBX_CHAR name[31 +1];
+    EMBX_BOOL isInitialized;
+    EMBX_BOOL usesZeroCopy;
+    EMBX_BOOL allowsPointerTranslation;
+    EMBX_BOOL allowsMultipleConnections;
+    EMBX_UINT maxPorts;
+    EMBX_UINT nrOpenHandles;
+    EMBX_UINT nrPortsInUse;
+    EMBX_VOID *memStart;
+    EMBX_VOID *memEnd;
+    EMBX_INT reserved[4];
+} EMBX_TPINFO;
+typedef struct EMBX_Transport_s EMBX_Transport_t;
+typedef EMBX_Transport_t *EMBX_TransportFactory_fn(EMBX_VOID *);
+extern EMBX_ERROR EMBX_Init (void);
+extern EMBX_ERROR EMBX_Deinit (void);
+extern EMBX_ERROR EMBX_ModifyTuneable (EMBX_Tuneable_t key, EMBX_UINT value);
+extern EMBX_ERROR EMBX_RegisterTransport (EMBX_TransportFactory_fn *fn, EMBX_VOID *arg, EMBX_UINT argSize, EMBX_FACTORY *hFactory);
+extern EMBX_ERROR EMBX_UnregisterTransport (EMBX_FACTORY hFactory);
+extern EMBX_ERROR EMBX_FindTransport (const EMBX_CHAR *name, EMBX_TPINFO *tpinfo);
+extern EMBX_ERROR EMBX_GetFirstTransport (EMBX_TPINFO *tpinfo);
+extern EMBX_ERROR EMBX_GetNextTransport (EMBX_TPINFO *tpinfo);
+extern EMBX_ERROR EMBX_OpenTransport (const EMBX_CHAR *name, EMBX_TRANSPORT *tp);
+extern EMBX_ERROR EMBX_CloseTransport (EMBX_TRANSPORT tp);
+extern EMBX_ERROR EMBX_GetTransportInfo (EMBX_TRANSPORT tp, EMBX_TPINFO *tpinfo);
+extern EMBX_ERROR EMBX_Alloc (EMBX_TRANSPORT tp, EMBX_UINT size, EMBX_VOID **buffer);
+extern EMBX_ERROR EMBX_Free (EMBX_VOID *buffer);
+extern EMBX_ERROR EMBX_Release (EMBX_TRANSPORT tp, EMBX_VOID *buffer);
+extern EMBX_ERROR EMBX_GetBufferSize(EMBX_VOID *buffer, EMBX_UINT *size);
+extern EMBX_ERROR EMBX_CreatePort (EMBX_TRANSPORT tp, const EMBX_CHAR *portName, EMBX_PORT *port);
+extern EMBX_ERROR EMBX_Connect (EMBX_TRANSPORT tp, const EMBX_CHAR *portName, EMBX_PORT *port);
+extern EMBX_ERROR EMBX_ConnectBlock (EMBX_TRANSPORT tp, const EMBX_CHAR *portName, EMBX_PORT *port);
+extern EMBX_ERROR EMBX_ConnectBlockTimeout (EMBX_TRANSPORT htp, const EMBX_CHAR *portName, EMBX_PORT *port, EMBX_UINT timeout);
+extern EMBX_ERROR EMBX_ClosePort (EMBX_PORT port);
+extern EMBX_ERROR EMBX_InvalidatePort (EMBX_PORT port);
+extern EMBX_ERROR EMBX_Receive (EMBX_PORT port, EMBX_RECEIVE_EVENT *);
+extern EMBX_ERROR EMBX_ReceiveBlock (EMBX_PORT port, EMBX_RECEIVE_EVENT *);
+extern EMBX_ERROR EMBX_ReceiveBlockTimeout (EMBX_PORT port, EMBX_RECEIVE_EVENT *recev, EMBX_UINT timeout);
+extern EMBX_ERROR EMBX_SendMessage (EMBX_PORT port, EMBX_VOID *buffer, EMBX_UINT size);
+extern EMBX_ERROR EMBX_Offset (EMBX_TRANSPORT tp, EMBX_VOID *address, EMBX_INT *offset);
+extern EMBX_ERROR EMBX_Address (EMBX_TRANSPORT tp, EMBX_INT offset, EMBX_VOID **address);
+extern EMBX_INT embx_cpuNum;
+extern EMBX_ULONG embx_cpuMask;
+extern EMBX_UINT embx_heapSize;
+extern EMBX_UINT embx_heapFlags;
+extern EMBX_Transport_t *EMBXSHM_mailbox_factory (EMBX_VOID *param);
+extern EMBX_Transport_t *EMBXSHMC_mailbox_factory (EMBX_VOID *param);
+enum
+{
+    STFDMA_ERROR_NOT_INITIALIZED = (323 << 16),
+    STFDMA_ERROR_DEVICE_NOT_SUPPORTED,
+    STFDMA_ERROR_NO_CALLBACK_TASK,
+    STFDMA_ERROR_BLOCKING_TIMEOUT,
+    STFDMA_ERROR_CHANNEL_BUSY,
+    STFDMA_ERROR_NO_FREE_CHANNELS,
+    STFDMA_ERROR_ALL_CHANNELS_LOCKED,
+    STFDMA_ERROR_CHANNEL_NOT_LOCKED,
+    STFDMA_ERROR_UNKNOWN_CHANNEL_ID,
+    STFDMA_ERROR_UNKNOWN_DEVICE_NUMBER,
+    STFDMA_ERROR_UNKNOWN_REGION_NUMBER,
+    STFDMA_ERROR_UNKNOWN_ADR_PARAMETER,
+    STFDMA_ERROR_UNKNOWN_REQUEST_SIGNAL,
+    STFDMA_ERROR_INVALID_TRANSFER_ID,
+    STFDMA_ERROR_TRANSFER_ABORTED,
+    STFDMA_ERROR_TRANSFER_IN_PROGRESS,
+    STFDMA_ERROR_INVALID_BUFFER,
+    STFDMA_ERROR_INVALID_CHANNEL,
+    STFDMA_ERROR_INVALID_CONTEXT_ID,
+    STFDMA_ERROR_INVALID_SC_RANGE,
+    STFDMA_ERROR_NO_FREE_CONTEXTS,
+    STFDMA_ERROR_TRANSFER_FAILED,
+    STFDMA_ERROR_REQUEST_SIGNAL_BUSY,
+    STFDMA_ERROR_IO_REMAP_FAILED,
+    STFDMA_ERROR_MAP_PHY2UNCACHED_FAILED,
+    STFDMA_ERROR_LOW_POWER_STATE
+};
+enum
+{
+    STFDMA_DIRECTION_STATIC = 1,
+    STFDMA_DIRECTION_INCREMENTING
+};
+enum
+{
+    STFDMA_EXT_NODE_PES = 0,
+    STFDMA_EXT_NODE_SPDIF,
+    STFDMA_EXT_NODE_FEI,
+    STFDMA_EXT_NODE_NAND,
+    STFDMA_EXT_NODE_MCHI = 0x06
+};
+enum
+{
+    STFDMA_SC_ENTRY = 0,
+    STFDMA_PTS_ENTRY,
+    STFDMA_MARKER_ENTRY
+};
+typedef enum STFDMA_RequestSignal_e
+{
+    STFDMA_REQUEST_SIGNAL_NONE = 0,
+ STFDMA_REQUEST_SIGNAL_PCI_HALF = 10,
+ STFDMA_REQUEST_SIGNAL_SSC0_RX = 14,
+ STFDMA_REQUEST_SIGNAL_SSC0_TX = 15,
+ STFDMA_REQUEST_SIGNAL_CD_EXT1 = 16,
+ STFDMA_REQUEST_SIGNAL_CD_EXT2 = 17,
+ STFDMA_REQUEST_SIGNAL_CPXM_DECRYPTED_INPUT = 18,
+ STFDMA_REQUEST_SIGNAL_CPXM_DECRYPTED_OUTPUT = 19,
+ STFDMA_REQUEST_SIGNAL_CPXM_ENCRYPTED_INPUT = 20,
+ STFDMA_REQUEST_SIGNAL_CPXM_ENCRYPTED_OUTPUT = 21,
+ STFDMA_REQUEST_SIGNAL_PCM1 = 23,
+ STFDMA_REQUEST_SIGNAL_NAND_CMD = 24,
+ STFDMA_REQUEST_SIGNAL_NAND_DATA = 25,
+ STFDMA_REQUEST_SIGNAL_PCMREADER = 27,
+ STFDMA_REQUEST_SIGNAL_HDMI_PCM_PLYR = 29,
+ STFDMA_REQUEST_SIGNAL_HDMI_SPDIF_PLYR = 30,
+ STFDMA_REQUEST_SIGNAL_SSC1_RX = 1,
+ STFDMA_REQUEST_SIGNAL_SSC2_RX = 2,
+ STFDMA_REQUEST_SIGNAL_SSC3_RX = 3,
+ STFDMA_REQUEST_SIGNAL_SSC1_TX = 5,
+ STFDMA_REQUEST_SIGNAL_SSC2_TX = 6,
+ STFDMA_REQUEST_SIGNAL_SSC3_TX = 7,
+ STFDMA_REQUEST_SIGNAL_UART0_RX = 9,
+ STFDMA_REQUEST_SIGNAL_UART1_RX = 10,
+ STFDMA_REQUEST_SIGNAL_UART2_RX = 11,
+ STFDMA_REQUEST_SIGNAL_UART3_RX = 12,
+ STFDMA_REQUEST_SIGNAL_UART0_TX = 13,
+ STFDMA_REQUEST_SIGNAL_UART1_TX = 14,
+ STFDMA_REQUEST_SIGNAL_UART2_TX = 15,
+ STFDMA_REQUEST_SIGNAL_UART3_TX = 16,
+ STFDMA_REQUEST_SIGNAL_IRB_RX_HALF = 18,
+ STFDMA_REQUEST_SIGNAL_IRB_RX = 19,
+ STFDMA_REQUEST_SIGNAL_CD_EXT3 = 20,
+ STFDMA_REQUEST_SIGNAL_CD_EXT0 = 21,
+ STFDMA_REQUEST_SIGNAL_SWTS2 = 22,
+ STFDMA_REQUEST_SIGNAL_SWTS1 = 23,
+ STFDMA_REQUEST_SIGNAL_SWTS0 = 24,
+ STFDMA_REQUEST_SIGNAL_HDMI_AVI_BUFF_EMPTY = 26,
+ STFDMA_REQUEST_SIGNAL_TTXT_SDTVOUT = 30
+} STFDMA_RequestSignal_t;
+typedef enum STFDMA_Device_e
+{
+    STFDMA_DEVICE_FDMA_1,
+    STFDMA_DEVICE_FDMA_2
+} STFDMA_Device_t;
+typedef enum STFDMA_Block_e
+{
+    STFDMA_1,
+    STFDMA_2,
+    STFDMA_MPX,
+ STFDMA_3 = STFDMA_MPX,
+    STFDMA_MAX = 2
+}STFDMA_Block_t;
+typedef enum STFDMA_Pool_e
+{
+    STFDMA_DEFAULT_POOL,
+    STFDMA_PES_POOL,
+    STFDMA_SPDIF_POOL,
+    STFDMA_HIGH_BANDWIDTH_POOL,
+    STFDMA_MAX_POOL
+} STFDMA_Pool_t;
+typedef enum STFDMA_Event_e
+{
+    STFDMA_NOTIFY_NODE_COMPLETE_DMA_CONTINUING,
+    STFDMA_NOTIFY_NODE_COMPLETE_DMA_PAUSED,
+    STFDMA_NOTIFY_TRANSFER_ABORTED,
+    STFDMA_NOTIFY_TRANSFER_COMPLETE,
+    STFDMA_NOTIFY_NAND_READ_ERROR
+} STFDMA_Event_t;
+typedef enum STFDMA_SCRange_e
+{
+    STFDMA_DEVICE_PES_RANGE_0,
+    STFDMA_DEVICE_ES_RANGE_0,
+    STFDMA_DEVICE_ES_RANGE_1,
+    STFDMA_DEVICE_MPEG_RANGE_0 = 1,
+    STFDMA_DEVICE_MPEG_RANGE_1 = 2,
+    STFDMA_DEVICE_H264_RANGE_0 = 3,
+    STFDMA_DEVICE_VC1_RANGE_0 = 4,
+    STFDMA_DEVICE_MAX_RANGE
+} STFDMA_SCRange_t;
+typedef enum STFDMA_VideoCodec_e
+{
+    VIDEO_CODEC_MPEG,
+    VIDEO_CODEC_H264,
+    VIDEO_CODEC_VC1,
+    VIDEO_CODEC_MAX
+}STFDMA_VideoCodec_t;
+typedef enum STFDMA_AdditionalDataRegion_e
+{
+    PES_ADDITIONAL_DATA_REGION_0,
+    PES_ADDITIONAL_DATA_REGION_1,
+    PES_ADDITIONAL_DATA_REGION_2,
+    SPDIF_ADDITIONAL_DATA_REGION_3,
+    PES_ADDITIONAL_DATA_REGION_4,
+    PES_ADDITIONAL_DATA_REGION_5,
+    PES_ADDITIONAL_DATA_REGION_6,
+    ADDITIONAL_DATA_REGION_MAX
+} STFDMA_AdditionalDataRegion_t;
+typedef enum STFDMA_AdditionalDataRegionParameter_e
+{
+    PES_SC_WRITE = 0,
+    PES_SC_SIZE,
+    PES_ESBUF_TOP,
+    PES_ESBUF_READ,
+    PES_ESBUF_WRITE,
+    PES_ESBUF_BOT,
+    PES_PES_CTRL,
+    PES_SC1_CTRL,
+    PES_SC2_CTRL,
+    PES_SCD_STATE_WORD_0,
+    PES_SCD_STATE_WORD_1,
+    PES_SCD_STATE_WORD_2,
+    PES_SCD_STATE_WORD_3,
+    PES_SCD_STATE,
+    PES_SCD_STATE_WORD_4,
+    PES_SCD_STATE_WORD_5,
+    PES_RESERVED_0,
+    PES_RESERVED_1,
+    PES_RESERVED_2,
+    PES_RESERVED_3,
+    PES_RESERVED_4,
+    PES_RESERVED_5,
+    PES_RESERVED_6,
+    PES_RESERVED_7,
+    PES_RESERVED_8,
+    PES_RESERVED_9,
+    PES_RESERVED_10,
+    PES_RESERVED_11,
+    PES_RESERVED_12,
+    PES_RESERVED_13,
+    PES_RESERVED_14,
+    PES_RESERVED_15,
+    PES_MVC_RESERVED_0,
+    PES_MVC_RESERVED_1,
+    PES_MVC_RESERVED_2,
+    PES_MVC_RESERVED_3,
+    PES_MVC_RESERVED_4,
+    PES_MVC_RESERVED_5,
+    PES_MVC_ES_WRITE_COPY,
+    PES_MVC_CBUF_ADDR,
+    PES_LAST,
+    SPDIF_RESERVED_0 = 0,
+    SPDIF_RESERVED_1,
+    SPDIF_RESERVED_2,
+    SPDIF_RESERVED_3,
+    SPDIF_RESERVED_4,
+    SPDIF_RESERVED_5,
+    SPDIF_RESERVED_6,
+    SPDIF_RESERVED_7,
+    SPDIF_FRAME_COUNT,
+    SPDIF_FRAMES_TO_GO,
+    SPDIF_DATA_PRECISION_MASK,
+    SPDIF_RESERVED_11,
+    SPDIF_RESERVED_12,
+    SPDIF_RESERVED_13,
+    SPDIF_RESERVED_14,
+    SPDIF_RESERVED_15,
+ SPDIF_FRAME_COUNT_1 = 24,
+    SPDIF_FRAMES_TO_GO_1,
+    SPDIF_DATA_PRECISION_MASK_1,
+    SPDIF_LAST
+} STFDMA_AdditionalDataRegionParameter_t;
+typedef enum STFDMA_RegType_e
+{
+ STFDMA_REG_PIO_BIT,
+ STFDMA_REG_POLLING_TIMEOUT,
+ STFDMA_REG_NACK_POLLING_TIMEOUT,
+ STFDMA_REG_PIO_ADDRESS,
+ STFDMA_REG_PTI_ADDRESS,
+ STFDMA_REG_MAX
+}STFDMA_RegType_t;
+typedef U32 STFDMA_ChannelId_t;
+typedef U32 STFDMA_TransferId_t;
+typedef U32 STFDMA_ContextId_t;
+typedef struct STFDMA_RegValue_s
+{
+ STFDMA_RegType_t RegType;
+ U32 Value;
+}STFDMA_RegValue_t;
+typedef struct STFDMA_RegParams_s
+{
+ U32 NumRegParams;
+ STFDMA_RegValue_t RegValues[STFDMA_REG_MAX];
+}STFDMA_RegParams_t;
+typedef struct STFDMA_SPDIFChannelStatus_s
+{
+    U32 Status_0;
+    union
+    {
+        struct
+        {
+            U32 Status_1 : 9;
+            U32 UserStatus : 1;
+            U32 Valid : 1;
+            U32 Pad : 21;
+        }PCMMode;
+        struct
+        {
+            U32 Status_1 : 4;
+            U32 UserStatus : 1;
+            U32 Valid : 1;
+            U32 Pad : 26;
+        }CompressedMode;
+    }Status;
+} STFDMA_SPDIFChannelStatus_t;
+typedef struct STFDMA_InitParams_s
+{
+    STFDMA_Device_t DeviceType;
+    ST_Partition_t *DriverPartition_p;
+    ST_Partition_t *NCachePartition_p;
+    U32 *BaseAddress_p;
+    U32 InterruptNumber;
+    U32 InterruptLevel;
+    U32 NumberCallbackTasks;
+    U32 ClockTicksPerSecond;
+    STFDMA_Block_t FDMABlock;
+} STFDMA_InitParams_t;
+typedef struct STFDMA_NodeControl_s
+{
+    U32 PaceSignal : 5;
+    U32 SourceDirection : 2;
+    U32 DestinationDirection : 2;
+    U32 Reserved : 6;
+    U32 Secure : 1;
+    U32 Reserved1 : 14;
+    U32 NodeCompletePause : 1;
+    U32 NodeCompleteNotify : 1;
+} STFDMA_NodeControl_t;
+typedef struct STFDMA_Node_s
+{
+    struct STFDMA_Node_s *Next_p;
+    STFDMA_NodeControl_t NodeControl;
+    U32 NumberBytes;
+    void *SourceAddress_p;
+    void *DestinationAddress_p;
+    U32 Length;
+    S32 SourceStride;
+    S32 DestinationStride;
+} STFDMA_Node_t;
+typedef struct STFDMA_SPDIFNode_s
+{
+    struct STFDMA_SPDIFNode_s *Next_p;
+    U32 Extended : 5;
+    U32 Type : 3;
+    U32 DReq : 5;
+    U32 ModeData : 1;
+    U32 Pad : 1;
+    U32 Secure : 1;
+    U32 Pad2 : 12;
+    U32 BurstEnd : 1;
+    U32 Valid : 1;
+    U32 NodeCompletePause : 1;
+    U32 NodeCompleteNotify : 1;
+    U32 NumberBytes;
+    void *SourceAddress_p;
+    void *DestinationAddress_p;
+    union
+    {
+        struct
+        {
+            U32 Reserved1;
+            U32 SStride;
+            U32 Reserved2;
+        }PCMMode;
+        struct
+        {
+            U16 PreambleB;
+            U16 PreambleA;
+            U16 PreambleD;
+            U16 PreambleC;
+            U32 BurstPeriod;
+        }CompressedMode;
+    }Data;
+    STFDMA_SPDIFChannelStatus_t Channel0;
+    STFDMA_SPDIFChannelStatus_t Channel1;
+    U32 Pad1[4];
+} STFDMA_SPDIFNode_t;
+typedef struct STFDMA_FEINode_s
+{
+    struct STFDMA_FEINode_s *Next_p;
+    U32 Extended : 5;
+    U32 Type : 3;
+    U32 DreqStart : 5;
+    U32 DreqData : 5;
+    U32 FirstNodeOfTransfer : 1;
+    U32 Pad1 : 11;
+    U32 NodeCompletePause : 1;
+    U32 NodeCompleteNotify : 1;
+    U32 NumberBytes;
+    void *SourceAddress_p;
+    void *DestinationAddress_p;
+    void *TVOCounterAddress_p;
+    U32 Pad2[10];
+} STFDMA_FEINode_t;
+typedef struct STFDMA_ContextNode_s
+{
+    struct STFDMA_ContextNode_s *Next_p;
+ U32 Extended : 5;
+ U32 Type : 3;
+ U32 Context : 4;
+ U32 PESChunkSize : 2;
+ U32 Pad1 : 1;
+ U32 Secure : 1;
+ U32 Tag : 8;
+ U32 Pad2 : 6;
+ U32 NodeCompletePause : 1;
+ U32 NodeCompleteNotify : 1;
+ U32 NumberBytes;
+ void *SourceAddress_p;
+ U32 Pad3[4];
+} STFDMA_ContextNode_t;
+typedef struct STFDMA_MCHIRxNode_s
+{
+    struct STFDMA_MCHIRxNode_s *Next_p;
+    U32 Extended : 5;
+    U32 Type : 3;
+    U32 DReq : 5;
+    U32 Pad1 : 2;
+    U32 Secure : 1;
+    U32 MCHIPacketStartDReq : 5;
+    U32 Pad2 : 9;
+    U32 NodeCompletePause : 1;
+    U32 NodeCompleteNotify : 1;
+    U32 NumberBytes;
+    void *SourceAddress_p;
+    void *DestinationAddress_p;
+    U32 Length;
+    U32 *RXFifoLvlAddress_p;
+    S32 DestinationStride;
+   U32 Pad3[8];
+} STFDMA_MCHIRxNode_t;
+typedef struct STFDMA_FlowControlNode_s
+{
+    struct STFDMA_FlowControlNode_s *Next_p;
+    U32 PaceSignal : 5;
+    U32 SourceDirection : 2;
+    U32 DestinationDirection : 2;
+    U32 Reserved : 6;
+    U32 Secure : 1;
+    U32 Reserved1 : 3;
+    U32 PollingPaceEnable : 1;
+    U32 PollingType : 2;
+    U32 Reserved2 : 8;
+    U32 NodeCompletePause : 1;
+    U32 NodeCompleteNotify : 1;
+    U32 NumberBytes;
+    void *SourceAddress_p;
+    void *DestinationAddress_p;
+    U32 Length;
+    S32 SourceStride;
+    S32 DestinationStride;
+} STFDMA_FlowControlNode_t;
+typedef struct STFDMA_COMMSNode_s
+{
+ struct STFDMA_COMMSNode_s *Next_p;
+ U32 PaceSignal : 5;
+ U32 SourceDirection : 2;
+ U32 DestinationDirection : 2;
+ U32 CommsEnable : 1;
+ U32 DreqTimeout : 5;
+ U32 Secure : 1;
+ U32 CommsMode : 3;
+ U32 PTICounter : 1;
+ U32 Pad1 : 10;
+ U32 NodeCompletePause : 1;
+ U32 NodeCompleteNotify : 1;
+ U32 NumberBytes;
+ void *SourceAddress_p;
+ void *DestinationAddress_p;
+ U32 Length;
+ U32 CommsStatus;
+ U32 ParityErrorThreshold;
+   U32 Pad2[8];
+}STFDMA_COMMSNode_t;
+typedef union STFDMA_GenericNode_s
+{
+    struct
+    {
+        union STFDMA_GenericNode_s *Next_p;
+        U32 Extended : 5;
+        U32 Type : 3;
+        U32 Pad : 24;
+        U32 NumberBytes;
+        void *SourceAddress_p;
+    } Gen;
+    STFDMA_Node_t Node;
+    STFDMA_ContextNode_t ContextNode;
+    STFDMA_SPDIFNode_t SPDIFNode;
+    STFDMA_FEINode_t FEINode;
+    STFDMA_MCHIRxNode_t MCHIRxNode;
+ STFDMA_FlowControlNode_t FlowControlNode;
+ STFDMA_COMMSNode_t COMMSNode;
+} STFDMA_GenericNode_t;
+typedef union STFDMA_SCEntry_s
+{
+    struct
+    {
+        U32 Type : 2;
+        U32 Pad1 : 6;
+        U32 Tag : 8;
+        U32 DriverReco : 1;
+        U32 InterView : 1;
+        U32 AnchorPic : 1;
+        U32 TemporalId : 3;
+        U32 ViewId : 10;
+        void *Addr;
+        union
+        {
+            struct
+            {
+                U8 SCValue;
+                U8 Reserved[3];
+            }MPEG2;
+            struct
+            {
+                U32 SCValue : 8;
+                U32 SliceCount : 16;
+                U32 Reserved : 1;
+                U32 PriorityId : 6;
+                U32 NonIdr : 1;
+            }H264;
+            struct
+            {
+                U32 SCValue : 8;
+                U32 SliceAddress : 9;
+                U32 Reserved : 15;
+            }VC1;
+        }ExtendedInfo;
+    }
+    SC;
+    struct
+    {
+        U32 Type : 2;
+        U32 Pad1 : 6;
+        U32 Tag : 8;
+        U32 Pad2 : 16;
+        void *Addr;
+        U32 PTS1;
+        U32 PTS0;
+    }
+    PTS;
+    struct
+    {
+  U32 Type : 2;
+  U32 Pad1 : 6;
+  U32 Tag : 8;
+  U32 Marker : 8;
+  U32 Pad2 : 8;
+  void *Addr;
+  U32 MarkerId0;
+  U32 MarkerId1;
+    }
+    MarkerEntry;
+} STFDMA_SCEntry_t;
+typedef struct STFDMA_SCState_s
+{
+    U8 RangeStart;
+    U8 RangeEnd;
+    BOOL RangeEnabled;
+    BOOL PTSEnabled;
+    BOOL OneShotEnabled;
+} STFDMA_SCState_t;
+typedef struct STFDMA_TransferStatus_s
+{
+    BOOL Paused;
+    U32 NodeAddress;
+    U32 NodeBytesRemaining;
+} STFDMA_TransferStatus_t;
+typedef void (*STFDMA_CallbackFunction_t) (U32 TransferId,
+                                            U32 CallbackReason,
+                                            U32 *CurrentNode_p,
+                                            U32 NodeBytesTransfered,
+                                            BOOL Error,
+                                            void *ApplicationData_p,
+                                            STOS_Clock_t InterruptTime);
+typedef struct STFDMA_TransferGenericParams_s
+{
+    STFDMA_ChannelId_t ChannelId;
+    STFDMA_Pool_t Pool;
+    STFDMA_GenericNode_t *NodeAddress_p;
+    STFDMA_GenericNode_t *NodeAddress_Vp;
+    U32 BlockingTimeout;
+    STFDMA_CallbackFunction_t CallbackFunction;
+    void *ApplicationData_p;
+    STFDMA_Block_t FDMABlock;
+} STFDMA_TransferGenericParams_t;
+typedef struct STFDMA_TransferParams_s
+{
+    STFDMA_ChannelId_t ChannelId;
+    STFDMA_Node_t *NodeAddress_p;
+    STFDMA_Node_t *NodeAddress_Vp;
+    U32 BlockingTimeout;
+    STFDMA_CallbackFunction_t CallbackFunction;
+    void *ApplicationData_p;
+    STFDMA_Block_t FDMABlock;
+} STFDMA_TransferParams_t;
+ST_ErrorCode_t STFDMA_Init(const ST_DeviceName_t DeviceName,
+                           const STFDMA_InitParams_t *InitParams_p);
+ST_ErrorCode_t STFDMA_StartGenericTransfer(STFDMA_TransferGenericParams_t *TransferParams_p,
+                                           STFDMA_TransferId_t *TransferId_p,
+                                           BOOL IsPaced);
+ST_ErrorCode_t STFDMA_StartTransfer (STFDMA_TransferParams_t *TransferParams_p,
+                                       STFDMA_TransferId_t *TransferId_p,
+                                       BOOL IsPaced);
+ST_ErrorCode_t STFDMA_ResumeTransfer(STFDMA_TransferId_t TransferId);
+ST_ErrorCode_t STFDMA_FlushTransfer (STFDMA_TransferId_t TransferId);
+ST_ErrorCode_t STFDMA_AbortTransfer(STFDMA_TransferId_t TransferId);
+ST_ErrorCode_t STFDMA_AllocateContext (STFDMA_ContextId_t *ContextId);
+ST_ErrorCode_t STFDMA_DeallocateContext (STFDMA_ContextId_t ContextId);
+ST_ErrorCode_t STFDMA_ContextGetSCList (STFDMA_ContextId_t ContextId,
+                                             STFDMA_SCEntry_t **SCList,
+                                             U32 *Size,
+                                             BOOL *Overflow);
+ST_ErrorCode_t STFDMA_ContextSetSCList (STFDMA_ContextId_t ContextId,
+                                             STFDMA_SCEntry_t *SCList,
+                                             U32 Size);
+ST_ErrorCode_t STFDMA_ContextGetSCState (STFDMA_ContextId_t ContextId,
+                                             STFDMA_SCState_t *State,
+                                             STFDMA_SCRange_t Range);
+ST_ErrorCode_t STFDMA_ContextSetSCState (STFDMA_ContextId_t ContextId,
+                                             STFDMA_SCState_t *State,
+                                             STFDMA_SCRange_t Range);
+ST_ErrorCode_t STFDMA_ContextSetESBuffer (STFDMA_ContextId_t ContextId, void *Buffer, U32 Size);
+ST_ErrorCode_t STFDMA_ContextSetESReadPtr (STFDMA_ContextId_t ContextId, void *Read);
+ST_ErrorCode_t STFDMA_ContextSetESWritePtr (STFDMA_ContextId_t ContextId, void *Write);
+ST_ErrorCode_t STFDMA_ContextGetESReadPtr (STFDMA_ContextId_t ContextId, void **Read);
+ST_ErrorCode_t STFDMA_ContextGetESWritePtr (STFDMA_ContextId_t ContextId, void **Write, BOOL *Overflow);
+ST_ErrorCode_t STFDMA_GetTransferStatus(STFDMA_TransferId_t TransferId,
+                                        STFDMA_TransferStatus_t *TransferStatus_p);
+ST_ErrorCode_t STFDMA_LockChannelInPool(STFDMA_Pool_t Pool, STFDMA_ChannelId_t *ChannelId, STFDMA_Block_t DeviceNo);
+ST_ErrorCode_t STFDMA_LockChannel (STFDMA_ChannelId_t *ChannelId, STFDMA_Block_t DeviceNo);
+ST_ErrorCode_t STFDMA_UnlockChannel(STFDMA_ChannelId_t ChannelId, STFDMA_Block_t DeviceNo);
+ST_ErrorCode_t STFDMA_SetTransferCount(U32 RequestLineNo, U32 TransferCount, STFDMA_Block_t DeviceNo);
+ST_ErrorCode_t STFDMA_SetRequestLineOpCode(U32 RequestLineNo, U8 OpCode, STFDMA_Block_t DeviceNo);
+ST_ErrorCode_t STFDMA_SetAddDataRegionParameter(STFDMA_Block_t DeviceNo, STFDMA_AdditionalDataRegion_t RegionNo, STFDMA_AdditionalDataRegionParameter_t ADRParameter, U32 Value);
+ST_ErrorCode_t STFDMA_SetRegParams(STFDMA_Block_t DeviceNo, STFDMA_RegParams_t RegParams);
+ST_Revision_t STFDMA_GetRevision(void);
+ST_ErrorCode_t STFDMA_GetFirmwareRevision(STFDMA_Block_t DeviceNo, U32 *FWRevision);
+ST_ErrorCode_t STFDMA_Term(const ST_DeviceName_t DeviceName,
+                           const BOOL ForceTerminate,
+                           STFDMA_Block_t DeviceNo);
+void STFDMA_NO_CALLBACK (U32 TransferId,
+                          U32 CallbackReason,
+                          U32 *CurrentNode_p,
+                          U32 NodeBytesTransfered,
+                          BOOL Error,
+                          void *ApplicationData_p,
+                          STOS_Clock_t InterruptTime);
+ST_ErrorCode_t STFDMA_MVCEnable(STFDMA_Block_t DeviceNo, STFDMA_ChannelId_t ChannelId, BOOL Enable);
+typedef U32 STPOWER_Handle_t ;
+typedef char STPOWER_DeviceName_t[31 +1];
+enum
+{
+    STPOWER_ERROR_DEVICE_PRESENT=(9 << 16),
+    STPOWER_ERROR_DEVICE_NOT_PRESENT,
+    STPOWER_ERROR_PROFILE_NOT_SET,
+    STPOWER_ERROR_DRIVER_NOT_INITIALIZED
+};
+typedef enum STPOWER_DeviceType_e
+{
+    STPOWER_DEVICE,
+    STPOWER_DEVICE_NATIVE_LINUX
+} STPOWER_DeviceType_t;
+typedef enum STPOWER_Parameter_e
+{
+    STPOWER_RESET_CALLBACK_PARAMS
+} STPOWER_Parameter_t;
+typedef enum STPOWER_State_e
+{
+    STPOWER_DEVICE_STATE_D0=1<<1,
+    STPOWER_DEVICE_STATE_D1=1<<2,
+    STPOWER_DEVICE_STATE_D2=1<<3
+} STPOWER_State_t;
+typedef ST_ErrorCode_t (*STPOWER_Func_t) (STPOWER_State_t State ,const void * DeviceData_p);
+typedef struct STPOWER_InitParams_s
+{
+    ST_Partition_t * CPUPartition;
+} STPOWER_InitParams_t;
+typedef struct STPOWER_OpenParams_s
+{
+    U32 Dummy;
+} STPOWER_OpenParams_t;
+typedef struct STPOWER_TermParams_s
+{
+    BOOL ForceTerminate;
+} STPOWER_TermParams_t;
+typedef enum STPOWER_CPUState_e
+{
+    STPOWER_CPU_STATE_NORMAL,
+    STPOWER_CPU_STATE_SLEEP,
+    STPOWER_CPU_STATE_STANDBY,
+    STPOWER_CPU_STATE_OFF,
+}
+STPOWER_CPUState_t;
+typedef enum STPOWER_WakeUpReason_e
+{
+    STPOWER_WAKEUP_UNKNOWN=1<<0,
+    STPOWER_WAKEUP_NMI=1<<1,
+    STPOWER_WAKEUP_IR=1<<2,
+    STPOWER_WAKEUP_FRONTPANEL=1<<3,
+    STPOWER_WAKEUP_ETHERNET=1<<4,
+    STPOWER_WAKEUP_TIMER=1<<5,
+    STPOWER_WAKEUP_HDMI=1<<6,
+    STPOWER_WAKEUP_MSG_REMOTE_CPU=1<<7,
+    STPOWER_WAKEUP_GPIO=1<<8,
+    STPOWER_WAKEUP_LAST=1<<9
+} STPOWER_WakeUpReason_t;
+typedef union STPOWER_Wakeup_Params_s
+{
+    struct
+    {
+        STPOWER_DeviceName_t PathOfDevice;
+    } Ethernet;
+    struct
+    {
+        U32 TimeInSec;
+    } Timer;
+    struct
+    {
+        STPOWER_DeviceName_t PathOfPIODevice;
+        U32 PIOPortNumber;
+    }PIO;
+} STPOWER_Wakeup_Params_t;
+typedef ST_ErrorCode_t (*STPOWER_UserCallbackFunc_t) (STPOWER_WakeUpReason_t wakeupreason, const void * DeviceData_p);
+typedef struct STPOWER_UserFunc_s
+{
+    STPOWER_UserCallbackFunc_t EntryFn;
+    STPOWER_UserCallbackFunc_t ExitFn;
+}STPOWER_UserFunc_t;
+typedef struct STPOWER_ProfileEntry_s
+{
+    STPOWER_DeviceName_t DeviceName;
+    STPOWER_DeviceType_t DeviceType;
+    STPOWER_State_t DeviceState;
+} STPOWER_ProfileEntry_t;
+typedef struct STPOWER_ErrorCode_s {
+  ST_ErrorCode_t ErrorCode;
+  ST_DeviceName_t DeviceName;
+}STPOWER_ErrorCode_t;
+ST_ErrorCode_t STPOWER_Init(const ST_DeviceName_t DeviceName,
+                            STPOWER_InitParams_t *InitParams_p);
+ST_ErrorCode_t STPOWER_Open(const ST_DeviceName_t DeviceName,
+                            const STPOWER_OpenParams_t *Params,
+                            STPOWER_Handle_t *Handle_p);
+ST_ErrorCode_t STPOWER_Close(const STPOWER_Handle_t Handle);
+ST_ErrorCode_t STPOWER_Term(const ST_DeviceName_t DeviceName,
+                            const STPOWER_TermParams_t *TermParams_p);
+ST_Revision_t STPOWER_GetRevision(void);
+ST_ErrorCode_t STPOWER_RegisterProfile(const STPOWER_Handle_t Handle,
+                                    STPOWER_ProfileEntry_t *Profile_p,
+                                    U32 NumEntries, U32 *ProfileID_p);
+ST_ErrorCode_t STPOWER_UnRegisterProfile(const STPOWER_Handle_t Handle_p,
+                                                U32 ProfileID_p);
+ST_ErrorCode_t STPOWER_SetProfile(const STPOWER_Handle_t Handle,
+                                    U32 ProfileID);
+ST_ErrorCode_t STPOWER_GetDeviceErrorInProfile(const STPOWER_Handle_t Handle,
+                                              U32 ProfileID,
+                                              STPOWER_ErrorCode_t *DeviceError);
+ST_ErrorCode_t STPOWER_RegisterPowerFunction(const ST_DeviceName_t DeviceName,
+                                STPOWER_Func_t Func, U32 SupportedState, void *
+                                DeviceData_p);
+ST_ErrorCode_t STPOWER_UnRegisterPowerFunction(const ST_DeviceName_t DeviceName);
+ST_ErrorCode_t STPOWER_SetCPUState(const STPOWER_Handle_t Handle, STPOWER_CPUState_t CPUState, STPOWER_WakeUpReason_t *WakeUpReason_p);
+ST_ErrorCode_t STPOWER_SetWakeUpDevice(STPOWER_Handle_t Handle, STPOWER_WakeUpReason_t Reason,
+                                    STPOWER_Wakeup_Params_t * WakeUpParams_p);
+ST_ErrorCode_t STPOWER_UnSetWakeUpDevice(STPOWER_Handle_t Handle, STPOWER_WakeUpReason_t Reason);
+ST_ErrorCode_t STPOWER_GetWakeUpDevices(STPOWER_Handle_t Handle, U32 *WakeUPDevices_p);
+ST_ErrorCode_t STPOWER_SetCPUFrequency(STPOWER_Handle_t Handle, ST_CPU_t CPUId, U32 Frequency);
+ST_ErrorCode_t STPOWER_SetUserFunc(STPOWER_Handle_t Handle,STPOWER_UserFunc_t UserFunc, const void * Userdata );
+ST_ErrorCode_t STPOWER_GetParameter(STPOWER_Handle_t Handle, STPOWER_Parameter_t Parameter, U32 *Value);
+ST_ErrorCode_t STPOWER_GetCPUWakeupReason(STPOWER_Handle_t Handle, ST_CPU_t CPUId, STPOWER_WakeUpReason_t *WakeUpReason_p);
+typedef enum VIDPOWER_State_e
+{
+    VIDPOWER_STATE_D0=STPOWER_DEVICE_STATE_D0,
+    VIDPOWER_STATE_D1=STPOWER_DEVICE_STATE_D1,
+    VIDPOWER_STATE_D2=STPOWER_DEVICE_STATE_D2
+} VIDPOWER_State_t;
+typedef struct VIDPOWER_InitParams_s
+{
+    ST_Partition_t *CPUPartition_p;
+} VIDPOWER_InitParams_t;
+typedef ST_ErrorCode_t (*VIDPOWER_Func_t) (VIDPOWER_State_t State,
+                                           const void *DeviceData_p);
+typedef struct VIDPOWER_OpenParams_s
+{
+    VIDPOWER_Func_t Func_p;
+    const void *PrivateModuleData_p;
+    U32 NBCreatedTask;
+    U32 SupportedState;
+} VIDPOWER_OpenParams_t;
+typedef char ST_ModuleName_t[16];
+typedef struct VIDPOWER_TermParams_s
+{
+} VIDPOWER_TermParams_t;
+typedef const void* VIDPOWER_Handle_t;
+ST_ErrorCode_t VIDPOWER_Init ( const ST_DeviceName_t DeviceName,
+                                VIDPOWER_InitParams_t *InitParams_p);
+ST_ErrorCode_t VIDPOWER_Open( const ST_DeviceName_t DeviceName,
+                                const ST_ModuleName_t ModuleName,
+                                const VIDPOWER_OpenParams_t *Params,
+                                VIDPOWER_Handle_t *Handle_p);
+ST_ErrorCode_t VIDPOWER_Close( const VIDPOWER_Handle_t Handle_p);
+ST_ErrorCode_t VIDPOWER_Term( const ST_DeviceName_t DeviceName,
+                                const VIDPOWER_TermParams_t *TermParams_p);
+ST_ErrorCode_t VIDPOWER_Unschedule ( const VIDPOWER_Handle_t Handle);
+ST_ErrorCode_t VIDPOWER_Schedule ( const VIDPOWER_Handle_t Handle);
+ST_ErrorCode_t VIDPOWER_GetPowerState ( const VIDPOWER_Handle_t Handle_p,
+                                              VIDPOWER_State_t *DeviceState);
+typedef enum VIDINJ_ErrorType_e
+{
+    VIDINJ_ERROR_NONE,
+    VIDINJ_ERROR_BAD_PARAMETER,
+    VIDINJ_ERROR_FLUSH_POINTER_BAD_ALIGNMENT,
+    VIDINJ_ERROR_FLUSH_BUFFER_TOO_SMALL,
+    VIDINJ_ERROR_FLUSH_DEST_BUFFER_FULL,
+    VIDINJ_ERROR_FDMA_GENERIC,
+    VIDINJ_ERROR_FDMA_OVERFLOW,
+    VIDINJ_ERROR_FDMA_TRANSFERT
+} VIDINJ_ErrorType_t;
+typedef void (*VIDINJ_TransferDoneFct_t) (U32 UserIdent,void * ES_Write_p,
+                                              void * SCListWrite_p,
+                                              void * SCListLoop_p
+                                            , BOOL IsInjectionFinished
+);
+typedef void * VIDINJ_Handle_t;
+typedef struct VIDINJ_GetInjectParams_s
+{
+    VIDINJ_TransferDoneFct_t TransferDoneFct;
+    U32 UserIdent;
+    STAVMEM_PartitionHandle_t AvmemPartition;
+    ST_Partition_t * CPUPartition;
+} VIDINJ_GetInjectParams_t;
+typedef struct VIDINJ_ParserRanges_s
+{
+    STFDMA_SCState_t RangeConfig;
+    STFDMA_SCRange_t RangeId;
+} VIDINJ_ParserRanges_t;
+typedef struct VIDINJ_InitParams_s
+{
+    ST_Partition_t * CPUPartition_p;
+    STVID_DeviceType_t DeviceType;
+    BOOL FDMASecureTransferMode;
+} VIDINJ_InitParams_t;
+ST_ErrorCode_t VIDINJ_Init(const VIDINJ_InitParams_t * const InitParams_p, VIDINJ_Handle_t * const InjecterHandle_p);
+ST_ErrorCode_t VIDINJ_Term(const VIDINJ_Handle_t InjecterHandle);
+ST_ErrorCode_t VIDINJ_InitVidPower(const VIDINJ_InitParams_t * const InitParams_p, const VIDINJ_Handle_t InjecterHandle);
+ST_ErrorCode_t VIDINJ_TermVidPower(const VIDINJ_Handle_t InjecterHandle);
+void VIDINJ_EnterCriticalSection(const VIDINJ_Handle_t InjecterHandle, const U32 InjectNum);
+void VIDINJ_LeaveCriticalSection(const VIDINJ_Handle_t InjecterHandle, const U32 InjectNum);
+void VIDINJ_GetRemainingDataToInject(const VIDINJ_Handle_t InjecterHandle, const U32 InjectNum, U32* RemainingData);
+void VIDINJ_InjectStartCode(const VIDINJ_Handle_t InjecterHandle, const U32 InjectNum, const U32 SCValue, const void* SCAdd);
+void VIDINJ_SoftReset(const VIDINJ_Handle_t InjecterHandle, const U32 InjectNum);
+void VIDINJ_TransferReset(const VIDINJ_Handle_t InjecterHandle, const U32 InjectNum);
+VIDINJ_ErrorType_t VIDINJ_TransferFlush(const VIDINJ_Handle_t InjecterHandle, const U32 InjectNum, const BOOL DiscontinuityStartCode, U8 * const Pattern, const U8 Size);
+U32 VIDINJ_TransferGetInject(const VIDINJ_Handle_t InjecterHandle, VIDINJ_GetInjectParams_t * const Params_p);
+void VIDINJ_TransferReleaseInject(const VIDINJ_Handle_t InjecterHandle, const U32 InjectNum);
+void VIDINJ_TransferStop(const VIDINJ_Handle_t InjecterHandle, const U32 InjectNum);
+void VIDINJ_TransferStart(const VIDINJ_Handle_t InjecterHandle, const U32 InjectNum, const BOOL IsRealTime);
+void VIDINJ_MVCEnable(const VIDINJ_Handle_t InjecterHandle, const BOOL MVCEnable);
+void VIDINJ_TransferLimits(const VIDINJ_Handle_t InjecterHandle, const U32 InjectNum,
+                           void * const ES_Start_Cp, void * const ES_Start_p, void * const ES_Stop_p,
+                           void * const SCListStart_Cp, void * const SCListStart_p, void * const SCListStop_p,
+                           void * const InputStart_Cp, void * const InputStart_p, void * const InputStop_p
+                           );
+ST_ErrorCode_t VIDINJ_Transfer_SetEnhancedDataInputInterface(const VIDINJ_Handle_t InjecterHandle,
+        const U32 InjectNum,
+        const STVID_EnhancedDataInputInterfaceParams_t * const Params_p );
+ST_ErrorCode_t VIDINJ_Transfer_SetDataInputInterface(const VIDINJ_Handle_t InjecterHandle,
+        const U32 InjectNum,
+        ST_ErrorCode_t (*GetWriteAddress)(void * const Handle,
+                                          void ** const Address_p),
+        void (*InformReadAddress)(void * const Handle, void * const Address),
+        void * const Handle );
+void VIDINJ_TransferSetESRead(const VIDINJ_Handle_t InjecterHandle, const U32 InjectNum, void * const Read );
+void VIDINJ_DataInjectionCompleted(const VIDINJ_Handle_t InjecterHandle, const U32 InjectNum);
+void VIDINJ_TransferSetSCListRead(const VIDINJ_Handle_t InjecterHandle, const U32 InjectNum, void * const Read );
+void VIDINJ_SetSCRanges(const VIDINJ_Handle_t InjecterHandle, const U32 InjectNum, const U32 NbParserRanges, VIDINJ_ParserRanges_t ParserRanges[]);
+ST_ErrorCode_t VIDINJ_ReallocateFDMANodes(const VIDINJ_Handle_t InjecterHandle, const U32 InjecterIndex, const STVID_SetupParams_t * const SetupParams_p);
+ST_ErrorCode_t VIDINJ_GetStatistics(const VIDINJ_Handle_t InjecterHandle, const U32 InjectNum,
+                                STVID_Statistics_t * const Statistics_p);
+ST_ErrorCode_t VIDINJ_ResetStatistics(const VIDINJ_Handle_t InjecterHandle, const U32 InjectNum,
+                                const STVID_Statistics_t * const Statistics_p);
+ST_ErrorCode_t VIDINJ_GetStatus(const VIDINJ_Handle_t InjecterHandle, const U32 InjectNum,
+                                STVID_Status_t * const Status_p);
+ST_ErrorCode_t StubInject_SetStreamSize(U32 Size);
+ST_ErrorCode_t StubInject_GetStreamSize(U32 * Size_p);
+ST_ErrorCode_t StubInject_SetBBInfo(void * BaseAddress_p, U32 Size);
+ST_ErrorCode_t StubInject_GetBBInfo(void ** BaseAddress_pp, U32 * Size_p);
+typedef enum DecodingDirection_e
+{
+    DECODING_FORWARD,
+    DECODING_BACKWARD
+} DecodingDirection_t;
+typedef void * DECODER_Handle_t;
+enum
+{
+    DECODER_INFORM_READ_ADDRESS_EVT = (21 << 16) + 0xB00,
+    DECODER_JOB_COMPLETED_EVT,
+    DECODER_CONFIRM_BUFFER_EVT,
+};
+typedef enum DECODER_ErrorCode_e
+{
+    DECODER_NO_ERROR,
+    DECODER_ERROR_PICTURE_SYNTAX,
+    DECODER_ERROR_MISSING_SLICE,
+    DECODER_ERROR_CORRUPTED
+} DECODER_ErrorCode_t;
+typedef enum DECODER_SourceType_e
+{
+    DECODER_SOURCE_TYPE_MPEG2_COMPRESSED_PICTURE,
+    DECODER_SOURCE_TYPE_H264_COMPRESSED_PICTURE
+} DECODER_SourceType_t;
+typedef enum DECODER_State_e
+{
+    DECODER_STATE_IDLE,
+    DECODER_STATE_READY_TO_DECODE,
+    DECODER_STATE_DECODING
+} DECODER_State_t;
+typedef enum DECODER_JobState_e
+{
+    DECODER_JOB_UNDEFINED,
+    DECODER_JOB_PREPROCESSING,
+    DECODER_JOB_WAITING_CONFIRM_BUFFER,
+    DECODER_JOB_DECODING,
+    DECODER_JOB_COMPLETED
+} DECODER_JobState_t;
+typedef U32 CommandId_t;
+typedef STOS_Clock_t GENERIC_Time_t;
+typedef struct DECODER_DecodingJobStatus_s
+{
+    DECODER_JobState_t JobState;
+    GENERIC_Time_t JobSubmissionTime;
+    GENERIC_Time_t JobCompletionTime;
+    U32 PictureMeanQP;
+    U32 PictureVarianceQP;
+} DECODER_DecodingJobStatus_t;
+typedef struct DECODER_DecodingJobResults_s
+{
+    DECODER_DecodingJobStatus_t DecodingJobStatus;
+    DECODER_ErrorCode_t ErrorCode;
+    CommandId_t CommandId;
+} DECODER_DecodingJobResults_t;
+typedef struct DECODER_InformReadAddress_s
+{
+    CommandId_t CommandId;
+    void * DecoderReadAddress_p;
+} DECODER_InformReadAddress_t;
+typedef struct DECODER_InitParams_s
+{
+    ST_Partition_t * CPUPartition_p;
+    STAVMEM_PartitionHandle_t AvmemPartitionHandle;
+    ST_DeviceName_t EventsHandlerName;
+    void * RegistersBaseAddress_NCp;
+    char MMETransportName[32];
+    ST_DeviceName_t VideoName;
+    void * BitBufferAddress_p;
+    void * BitBufferAddress_NCp;
+    U32 BitBufferSize;
+    STVID_DeviceType_t DeviceType;
+    U8 DecoderNumber;
+    DECODER_SourceType_t SourceType;
+    STVID_ErrorRecoveryMode_t ErrorRecoveryMode;
+    struct
+    {
+        U32 Event;
+        U32 Level;
+        U32 Number;
+    } SharedItParams;
+    STVID_CodecMode_t CodecMode;
+ BOOL IsNoRasterOnMainRequired;
+} DECODER_InitParams_t;
+typedef struct DECODER_DecodePictureParams_s
+{
+    VIDBUFF_PictureBuffer_t * PictureInformation;
+    STVID_ErrorRecoveryMode_t ErrorRecoveryMode;
+    BOOL DeblockingEnabled;
+    BOOL DeringingEnabled;
+    U32 DeblockingStrength;
+    U32 DeringingStrength;
+} DECODER_DecodePictureParams_t;
+typedef struct DECODER_Status_s
+{
+    DECODER_State_t State;
+    BOOL IsJobSubmitted;
+    CommandId_t CommandId;
+    DECODER_DecodingJobStatus_t DecodingJobStatus;
+} DECODER_Status_t;
+typedef struct DECODER_ConfirmBufferParams_s
+{
+    CommandId_t CommandId;
+    BOOL ConfirmBuffer;
+    VIDBUFF_PictureBuffer_t * NewPictureBuffer_p;
+} DECODER_ConfirmBufferParams_t;
+typedef struct DECODER_CodecInfo_s
+{
+  U32 MaximumDecodingLatencyInSystemClockUnit;
+  U32 FrameBufferAdditionalDataBytesPerMB;
+  U32 DecodePictureToConfirmBufferMaxTime;
+} DECODER_CodecInfo_t;
+typedef struct DECODER_SetupIntermediateBuffersParams_s
+{
+    STAVMEM_PartitionHandle_t AvmemPartitionHandleForIntermediateBuffers;
+} DECODER_SetupIntermediateBuffersParams_t;
+typedef struct
+{
+    ST_ErrorCode_t (*GetState)(const DECODER_Handle_t DecoderHandle, const CommandId_t CommandId, DECODER_Status_t * const DecoderStatus_p);
+    ST_ErrorCode_t (*GetCodecInfo)(const DECODER_Handle_t DecoderHandle, DECODER_CodecInfo_t * const CodecInfo_p, const U32 ProfileAndLevelIndication, const STVID_CodecMode_t CodecMode);
+    ST_ErrorCode_t (*GetStatistics)(const DECODER_Handle_t DecoderHandle, STVID_Statistics_t * const Statistics_p);
+    ST_ErrorCode_t (*ResetStatistics)(const DECODER_Handle_t DecoderHandle, const STVID_Statistics_t * const Statistics_p);
+    ST_ErrorCode_t (*GetStatus)(const DECODER_Handle_t DecoderHandle, STVID_Status_t * const Status_p);
+    ST_ErrorCode_t (*Init)(const DECODER_Handle_t DecoderHandle, const DECODER_InitParams_t * const InitParams_p);
+    ST_ErrorCode_t (*Reset)(const DECODER_Handle_t DecoderHandle);
+    ST_ErrorCode_t (*DecodePicture)(const DECODER_Handle_t DecoderHandle, const DECODER_DecodePictureParams_t * const DecodePictureParams_p, DECODER_Status_t * const DecoderStatus_p);
+    ST_ErrorCode_t (*ConfirmBuffer)(const DECODER_Handle_t DecoderHandle, const DECODER_ConfirmBufferParams_t * const ConfirmBufferParams_p);
+    ST_ErrorCode_t (*Abort)(const DECODER_Handle_t DecoderHandle, const CommandId_t CommandId);
+    ST_ErrorCode_t (*Setup)(const DECODER_Handle_t DecoderHandle, const STVID_SetupParams_t * const SetupParams_p);
+    ST_ErrorCode_t (*FillAdditionnalDataBuffer)(const DECODER_Handle_t DecoderHandle, const VIDBUFF_PictureBuffer_t* const Picture_p);
+    ST_ErrorCode_t (*Term)(const DECODER_Handle_t DecoderHandle);
+    void (*SetDecodingDirection)(const DECODER_Handle_t DecoderHandle, const DecodingDirection_t Direction);
+    ST_ErrorCode_t (*UpdateBitBufferParams)(const DECODER_Handle_t DecoderHandle, void * const Address_p, const U32 Size);
+} DECODER_FunctionsTable_t;
+typedef struct {
+    const DECODER_FunctionsTable_t * FunctionsTable_p;
+    ST_Partition_t * CPUPartition_p;
+    STEVT_Handle_t EventsHandle;
+    STAVMEM_PartitionHandle_t AvmemPartitionHandle;
+    ST_DeviceName_t VideoName;
+    STVID_DeviceType_t DeviceType;
+    void * RegistersBaseAddress_NCp;
+    U32 ValidityCheck;
+    U8 DecoderNumber;
+    U32 InterruptEvt;
+    U32 InterruptLevel;
+    U32 InterruptNumber;
+    void * PrivateData_p;
+    STVID_CodecMode_t CodecMode;
+    char MMETransportName[32];
+    STAVMEM_BlockHandle_t DataBufferPointerBlockHandle;
+    STAVMEM_BlockHandle_t DataBufferBlockHandle;
+    STAVMEM_BlockHandle_t ScatterPageBlockHandle;
+    MME_Command_t CmdDecoder;
+    MME_TransformerHandle_t TransformHandleDecoder;
+    char TransformerName[(63U)];
+    MME_TransformerInitParams_t InitParamsDecoder;
+    BOOL IsEmbxTransportValid;
+ BOOL IsNoRasterOnMainRequired;
+    VIDCOM_DegradationMode_t DegradationMode;
+} DECODER_Properties_t;
+ST_ErrorCode_t DECODER_Init(const DECODER_InitParams_t * const InitParams_p, DECODER_Handle_t * const DecoderHandle_p);
+ST_ErrorCode_t DECODER_Term(const DECODER_Handle_t DecoderHandle);
+void DECODER_SetDegradationMode(const DECODER_Handle_t DecoderHandle, const VIDCOM_DegradationMode_t Mode);
+typedef struct H264_SPSError_s
+{
+    BOOL MaxBytesPerPicDenomRangeError;
+    BOOL MaxBitsPerMBDenomError;
+    BOOL Log2MaxMvLengthHorizontalRangeError;
+    BOOL Log2MaxMvLengthVerticalRangeError;
+    BOOL NumReorderFrameRangeError;
+    BOOL MaxDecBufferingRangeError;
+    BOOL IsNotSupportedProfileError;
+    BOOL AuxCodedPicturePresent;
+    BOOL ReservedZero4BitsError;
+    BOOL LevelIdcRangeError;
+    BOOL Log2MaxFrameNumMinus4RangeError;
+    BOOL Log2MaxPicOrderCntLsbMinus4RangeError;
+    BOOL NumRefFramesRangeError;
+    BOOL Direct8x8InferenceFlagNullWithFrameMbsOnlyFlagError;
+    BOOL Direct8x8InferenceFlagNullWithLevel3OrMoreError;
+    BOOL TruncatedNAL;
+    BOOL NalCpbCntMinus1RangeError;
+    BOOL NalBitRateRangeError;
+    BOOL NalCpbSizeRangeError;
+    BOOL NonIncreasingNalBitRateError;
+    BOOL NonIncreasingNalCpbSizeError;
+    BOOL VclCpbCntMinus1RangeError;
+    BOOL VclBitRateRangeError;
+    BOOL VclCpbSizeRangeError;
+    BOOL NonIncreasingVclBitRateError;
+    BOOL NonIncreasingVclCpbSizeError;
+    BOOL InitialCpbRemovalDelayDifferError;
+    BOOL CpbRemovalDelayLengthDifferError;
+    BOOL DpbOutputDelayLengthDifferError;
+    BOOL TimeOffsetLengthDifferError;
+    BOOL LowDelayHrdFlagNotNullError;
+    BOOL WidthRangeError;
+    BOOL HeightRangeError;
+    BOOL AspectRatioRangeError;
+} H264_SPSError_t;
+typedef struct H264_SpecificScalingMatrix_s
+{
+    BOOL ScalingListPresentFlag[8];
+    U32 FirstSixScalingList[6][16];
+    U32 NextTwoScalingList[2][64];
+} H264_SpecificScalingMatrix_t;
+typedef struct H264_GlobalDecodingContextSpecificData_s
+{
+    U32 seq_parameter_set_id;
+    U32 chroma_format_idc;
+    BOOL residual_colour_transform_flag;
+    U32 bit_depth_luma_minus8;
+    U32 bit_depth_chroma_minus8;
+    BOOL qpprime_y_zero_transform_bypass_flag;
+    BOOL seq_scaling_matrix_present_flag;
+    H264_SpecificScalingMatrix_t ScalingMatrix;
+    U32 log2_max_frame_num_minus4;
+    U32 pic_order_cnt_type;
+    U32 log2_max_pic_order_cnt_lsb_minus4;
+    U32 delta_pic_order_always_zero_flag;
+    U32 frame_mbs_only_flag;
+    U32 mb_adaptive_frame_field_flag;
+    U32 direct_8x8_inference_flag;
+    BOOL overscan_appropriate_flag;
+    BOOL video_full_range_flag;
+    U32 chroma_sample_loc_type_top_field;
+    U32 chroma_sample_loc_type_bottom_field;
+    BOOL motion_vectors_over_pic_boundaries_flag;
+    U32 max_bytes_per_pic_denom;
+    U32 max_bits_per_mb_denom;
+    U32 log2_max_mv_length_horizontal;
+    U32 log2_max_mv_length_vertical;
+    U32 num_reorder_frames;
+    U32 nal_cpb_cnt_minus1;
+    U32 vcl_cpb_cnt_minus1;
+    U32 nal_BitRate[32];
+    U32 nal_CpbSize[32];
+    U32 nal_cbr_flag[32];
+    U32 vcl_BitRate[32];
+    U32 vcl_CpbSize[32];
+    U32 vcl_cbr_flag[32];
+    H264_SPSError_t SPSError;
+    BOOL SPS_HasChanged;
+    U16 num_views_minus1;
+    U16 view_id[1024];
+    U16 num_anchor_refs_l0[1 + 1];
+    U16 num_anchor_refs_l1[1 + 1];
+    U16 num_non_anchor_refs_l0[1 + 1];
+    U16 num_non_anchor_refs_l1[1 + 1];
+    U16 anchor_ref_l0[1 + 1][1 + 1];
+    U16 anchor_ref_l1[1 + 1][1 + 1];
+    U16 non_anchor_ref_l0[1 + 1][1 + 1];
+    U16 non_anchor_ref_l1[1 + 1][1 + 1];
+    U16 VOIndex[1 + 1];
+} H264_GlobalDecodingContextSpecificData_t;
+typedef struct H264_PPSError_s
+{
+    BOOL NumSliceGroupsMinus1NotNullError;
+    BOOL NumRefIdxActiveMinus1RangeError;
+    BOOL WeightedBiPredIdcRangeError;
+    BOOL PicInitQpMinus26RangeError;
+    BOOL PicInitQsMinus26RangeError;
+    BOOL ChromaQpIndexOffsetRangeError;
+    BOOL TruncatedNAL;
+} H264_PPSError_t;
+typedef struct H264_PictureDecodingContextSpecificData_s
+{
+    U32 pic_parameter_set_id;
+    U32 entropy_coding_mode_flag;
+    U32 pic_order_present_flag;
+    U32 num_ref_idx_l0_active_minus1;
+    U32 num_ref_idx_l1_active_minus1;
+    U32 weighted_pred_flag;
+    U32 weighted_bipred_idc;
+    S32 pic_init_qp_minus26;
+    S32 chroma_qp_index_offset;
+    U32 deblocking_filter_control_present_flag;
+    U32 constrained_intra_pred_flag;
+    BOOL transform_8x8_mode_flag;
+    BOOL pic_scaling_matrix_present_flag;
+    H264_SpecificScalingMatrix_t ScalingMatrix;
+    BOOL ScalingMatrixUpdatedFromSPS;
+    S32 second_chroma_qp_index_offset;
+    H264_PPSError_t PPSError;
+    BOOL PPS_HasChanged;
+} H264_PictureDecodingContextSpecificData_t;
+typedef struct H264_SpecificReferenceList_s
+{
+    BOOL IsLongTerm;
+    BOOL IsNonExisting;
+    S32 PictureNumber;
+    S32 NonExistingPicOrderCnt;
+} H264_SpecificReferenceList_t;
+typedef struct H264_ClockTS_s
+{
+    BOOL discontinuity_flag;
+    U32 clockTimeStamp;
+} H264_ClockTS_t;
+typedef struct H264_MarkingError_s
+{
+    BOOL MarkInUsedFrameBufferError;
+    BOOL DPBRefFullError;
+    BOOL NoShortTermToSlideError;
+    BOOL NoShortTermToMarkAsUnusedError;
+    BOOL NoLongTermToMarkAsUnusedError;
+    BOOL MarkNonExistingAsLongError;
+    BOOL NoShortPictureToMarkAsLongError;
+    BOOL Marking2ndFieldWithDifferentLongTermFrameIdxError;
+    BOOL NoLongTermAssignmentAllowedError;
+    BOOL LongTermFrameIdxOutOfRangeError;
+} H264_MarkingError_t;
+typedef struct H264_SliceError_s
+{
+    BOOL NalRefIdcNullForIDRError;
+    BOOL NotTheFirstSliceError;
+    BOOL NoPPSAvailableError;
+    BOOL NoSPSAvailableError;
+    BOOL UnintentionalLossOfPictureError;
+    BOOL DeltaPicOrderCntBottomRangeError;
+    BOOL PicOrderCntType2SemanticsError;
+    BOOL LongTermReferenceFlagNotNullError;
+    BOOL MaxLongTermFrameIdxPlus1RangeError;
+    BOOL DuplicateMMCO4Error;
+    BOOL MMCO1OrMMCO3WithMMCO5Error;
+    BOOL DuplicateMMCO5Error;
+    BOOL IdrPicIdViolationError;
+    BOOL NumRefIdxActiveMinus1RangeError;
+    BOOL NumRefIdxActiveOverrrideFlagNullError;
+    BOOL SameParityOnComplementaryFieldsError;
+} H264_SliceError_t;
+typedef struct H264_POCError_s
+{
+    BOOL IDRWithPOCNotNullError;
+    BOOL PicOrderCntTypeRangeError;
+    BOOL ListDOverFlowError;
+    BOOL FieldOrderCntNotConsecutiveInListOError;
+    BOOL DuplicateTopFieldOrderCntInListOError;
+    BOOL DuplicateBottomFieldOrderCntInListOError;
+    BOOL NonPairedFieldsShareSameFieldOrderCntInListOError;
+    BOOL DifferenceBetweenPicOrderCntExceedsAllowedRangeError;
+} H264_POCError_t;
+typedef struct H264_SEIError_s
+{
+    BOOL ReservedPictStructSEIMessageError;
+    BOOL TruncatedNAL;
+} H264_SEIError_t;
+typedef struct H264_PictureError_s
+{
+    H264_SliceError_t SliceError;
+    H264_POCError_t POCError;
+    H264_MarkingError_t MarkingError;
+    H264_SEIError_t SEIError;
+    BOOL TruncatedNAL;
+} H264_PictureError_t;
+typedef struct H264_PictureSpecificData_s
+{
+    BOOL IsIDR;
+    S32 PicOrderCntTop;
+    S32 PicOrderCntBot;
+    S32 PreDecodingPicOrderCntTop;
+    S32 PreDecodingPicOrderCntBot;
+    S32 PreDecodingPicOrderCnt;
+    H264_SpecificReferenceList_t FullReferenceTopFieldList[16];
+    H264_SpecificReferenceList_t FullReferenceBottomFieldList[16];
+    BOOL IsReferenceTopFieldP0[(2 * 16)];
+    BOOL IsReferenceTopFieldB0[(2 * 16)];
+    BOOL IsReferenceTopFieldB1[(2 * 16)];
+    U32 NumClockTS;
+    H264_ClockTS_t ClockTS[3];
+    H264_PictureError_t PictureError;
+    U32 SliceCount;
+    BOOL non_idr_flag;
+    U8 priority_id;
+    U16 view_id;
+    U16 voindex;
+    U8 temporal_id;
+    BOOL anchor_pic_flag;
+    BOOL inter_view_flag;
+    BOOL IsBaseView;
+} H264_PictureSpecificData_t;
+typedef struct H264_DECODERError_s
+{
+    BOOL SyntaxError;
+} H264_DECODERError_t;
+typedef struct H264_DECODERStatistics_s
+{
+    BOOL ProcessedPicturesNumber;
+} H264_DECODERStatistics_t;
+typedef struct H264_PARSERStatistics_s
+{
+    BOOL ProcessedPicturesNumber;
+} H264_PARSERStatistics_t;
+enum
+{
+    VIDBUFF_PICTURE_OUT_OF_DISPLAY_EVT = (21 << 16) + 0x400,
+    VIDBUFF_IMPOSSIBLE_WITH_MEM_PROFILE_EVT,
+    VIDBUFF_NEW_ALLOCATED_FRAMEBUFFERS_EVT,
+    VIDBUFF_DEALLOCATED_FRAMEBUFFERS_EVT,
+    VIDBUFF_NEW_PICTURE_BUFFER_AVAILABLE_EVT
+};
+typedef void * VIDBUFF_Handle_t;
+typedef struct FrameBuffers_s {
+    void * Address_Phyp;
+    void * Address_Vp;
+    void * Address_NCp;
+    void * Address_Cp;
+    void * Address_p;
+    void * Address_Up;
+    U32 Size;
+} FrameBuffers_t;
+typedef struct VIDBUFF_FrameBufferList_s
+{
+    FrameBuffers_t * FrameBuffers_p;
+    U32 NbFrameBuffers;
+} VIDBUFF_FrameBufferList_t;
+typedef struct VIDBUFF_AllocateBufferParams_s
+{
+    VIDBUFF_BufferType_t BufferType;
+    U32 PictureWidth;
+    U32 PictureHeight;
+    U32 BufferSize;
+    VIDBUFF_AllocationMode_t AllocationMode;
+} VIDBUFF_AllocateBufferParams_t;
+typedef struct VIDBUFF_Infos_s
+{
+    U32 FrameBufferAdditionalDataBytesPerMB;
+    U32 StreamWidth;
+    U32 StreamHeight;
+} VIDBUFF_Infos_t;
+typedef struct VIDBUFF_GetUnusedPictureBufferParams_s
+{
+    BOOL IsFrameBufferRequested;
+    BOOL IsDecimatedFrameBufferRequested;
+    BOOL IsInternalBufferRequested;
+    U32 PictureWidth;
+    U32 PictureHeight;
+    STVID_PictureStructure_t PictureStructure;
+    BOOL ExpectingSecondField;
+    U32 DecodingOrderFrameID;
+    BOOL TopFieldFirst;
+} VIDBUFF_GetUnusedPictureBufferParams_t;
+typedef struct VIDBUFF_InitParams_s
+{
+    ST_Partition_t * CPUPartition_p;
+    ST_DeviceName_t EventsHandlerName;
+    STAVMEM_PartitionHandle_t AvmemPartitionHandle;
+    U8 MaxFrameBuffersInProfile;
+    BOOL IsReconstructionUsed;
+ BOOL IsNoRasterOnMainRequired;
+    STVID_DeviceType_t DeviceType;
+    ST_DeviceName_t VideoName;
+    VIDBUFF_BufferType_t FrameBuffersType;
+} VIDBUFF_InitParams_t;
+ST_ErrorCode_t VIDBUFF_Init(const VIDBUFF_InitParams_t * const InitParams_p, VIDBUFF_Handle_t * const Handle_p);
+ST_ErrorCode_t VIDBUFF_Term(const VIDBUFF_Handle_t Handle);
+ST_ErrorCode_t VIDBUFF_AllocateBitBuffer(const VIDBUFF_Handle_t BuffersHandle, const VIDBUFF_AllocateBufferParams_t * const AllocParams_p, VIDBUFF_BufferAllocationParams_t * const BufferParams_p);
+ST_ErrorCode_t VIDBUFF_AllocateMemoryForProfile(const VIDBUFF_Handle_t BuffersHandle, const BOOL ManualNumberOfBuffers, const U8 NumberOfBuffers);
+ST_ErrorCode_t VIDBUFF_ClearFrameBuffer(const VIDBUFF_Handle_t BuffersHandle,
+                                        VIDBUFF_BufferAllocationParams_t * const BufferParams_p,
+                                        const STVID_ClearParams_t * const ClearFrameBufferParams_p);
+ST_ErrorCode_t VIDBUFF_DeAllocateBitBuffer(const VIDBUFF_Handle_t BuffersHandle, VIDBUFF_BufferAllocationParams_t * const BufferParams_p);
+ST_ErrorCode_t VIDBUFF_DeAllocateUnusedMemoryOfProfile(const VIDBUFF_Handle_t Handle);
+ST_ErrorCode_t VIDBUFF_SetInfos(const VIDBUFF_Handle_t BuffersHandle, VIDBUFF_Infos_t * const Infos_p);
+ST_ErrorCode_t VIDBUFF_ForceDecimationFactor(const VIDBUFF_Handle_t BuffersHandle, const STVID_DecimationFactor_t DecimationFactor);
+ST_ErrorCode_t VIDBUFF_GetMemoryProfile(const VIDBUFF_Handle_t Handle, VIDCOM_InternalProfile_t * const Profile_p);
+ST_ErrorCode_t VIDBUFF_GetMemoryProfileDecimationFactor(const VIDBUFF_Handle_t Handle, STVID_DecimationFactor_t * const DecimationFactor_p);
+ST_ErrorCode_t VIDBUFF_GetApplicableDecimationFactor(const VIDBUFF_Handle_t Handle, STVID_DecimationFactor_t * const DecimationFactor_p);
+ST_ErrorCode_t VIDBUFF_GetPictureAllocInfos(const VIDBUFF_Handle_t BuffersHandle, const U32 PictureWidth, const U32 PictureHeight, U32 * const TotalSize_p, U32 * const Aligment_p);
+ST_ErrorCode_t VIDBUFF_GetAndTakeUnusedPictureBuffer(const VIDBUFF_Handle_t Handle, const VIDBUFF_GetUnusedPictureBufferParams_t * const Params_p,
+                                              VIDBUFF_PictureBuffer_t ** const PictureBuffer_p,
+                                              VIDCOM_MODULE_ID_t ModId);
+ST_ErrorCode_t VIDBUFF_GetVirtualPictureBufferForShowPicture(const VIDBUFF_Handle_t BuffersHandle, VIDBUFF_PictureBuffer_t ** const PictureBuffer_p_p);
+ST_ErrorCode_t VIDBUFF_ReleaseVirtualPictureBufferForShowPicture(const VIDBUFF_Handle_t BuffersHandle, VIDBUFF_PictureBuffer_t * const PictureBuffer_p);
+ST_ErrorCode_t VIDBUFF_ReAllocateBitBuffer(const VIDBUFF_Handle_t BuffersHandle, const VIDBUFF_AllocateBufferParams_t * const AllocParams_p,
+                                           VIDBUFF_BufferAllocationParams_t * const BufferParams_p, const STAVMEM_PartitionHandle_t AVMEMPartitionHandle);
+ST_ErrorCode_t VIDBUFF_SetMemoryProfile(const VIDBUFF_Handle_t Handle,VIDCOM_InternalProfile_t* const Profile_p);
+ST_ErrorCode_t VIDBUFF_SetFrameBuffersType(const VIDBUFF_Handle_t BuffersHandle, VIDBUFF_BufferType_t const FrameBuffersType);
+ST_ErrorCode_t VIDBUFF_SetAvmemPartitionForFrameBuffers(const VIDBUFF_Handle_t BuffersHandle, const STAVMEM_PartitionHandle_t AvmemPartitionHandle);
+ST_ErrorCode_t VIDBUFF_SetAvmemPartitionForDecimatedFrameBuffers(const VIDBUFF_Handle_t BuffersHandle, const STAVMEM_PartitionHandle_t AvmemPartitionHandle);
+ST_ErrorCode_t VIDBUFF_SetAvmemPartitionForAdditionnalData(const VIDBUFF_Handle_t BuffersHandle, const STAVMEM_PartitionHandle_t AvmemPartitionHandle);
+ST_ErrorCode_t VIDBUFF_TakePicture(const VIDBUFF_Handle_t BuffersHandle, VIDBUFF_FrameBuffer_t * const Frame_p, VIDCOM_MODULE_ID_t ModId);
+ST_ErrorCode_t VIDBUFF_ReleasePicture(const VIDBUFF_Handle_t BuffersHandle, VIDBUFF_FrameBuffer_t * const Frame_p, VIDCOM_MODULE_ID_t ModId);
+ST_ErrorCode_t VIDBUFF_RecoverFrameBuffers(const VIDBUFF_Handle_t BuffersHandle);
+void VIDBUFF_PrintPictureBuffersStatus(const VIDBUFF_Handle_t BuffersHandle);
+void VIDBUFF_TagAllAdditionnalDataBuffersToBeKilledAsap(const VIDBUFF_Handle_t BuffersHandle);
+BOOL VIDBUFF_NeedToChangeAdditionnalDataBufferParams(const VIDBUFF_Handle_t BuffersHandle, const VIDBUFF_Infos_t * Infos_p);
+U32 VIDBUFF_GetNbrOfAvailableExtraSecondaryFrameBuffers(const VIDBUFF_Handle_t BuffersHandle);
+U32 VIDBUFF_GetNbrOfAvailableExtraPrimaryFrameBuffers(const VIDBUFF_Handle_t BuffersHandle);
+ST_ErrorCode_t VIDBUFF_SetNbrOfExtraPrimaryFrameBuffers(const VIDBUFF_Handle_t BuffersHandle,
+                                                        const U32 NumberOfBuffersRequested);
+ST_ErrorCode_t VIDBUFF_DeAllocateUnusedExtraBuffers(const VIDBUFF_Handle_t BuffersHandle);
+ST_ErrorCode_t VIDBUFF_SetNbrOfExtraSecondaryFrameBuffers(const VIDBUFF_Handle_t BuffersHandle,
+                                                          const U32 NumberOfBuffersRequested);
+ST_ErrorCode_t VIDBUFF_DeAllocateUnusedExtraSecondaryBuffers(const VIDBUFF_Handle_t BuffersHandle);
+void VIDBUFF_ResetSmoothBackwardPictureInfos(const VIDBUFF_Handle_t BuffersHandle);
+BOOL VIDBUFF_NeedToChangeFrameBufferParams(const VIDBUFF_Handle_t BuffersHandle, const U32 Width, const U32 Height, const U8 NumberOfFrames);
+ST_ErrorCode_t VIDBUFF_ChangeFrameBufferParams(const VIDBUFF_Handle_t BuffersHandle, const U32 Width, const U32 Height, const U8 NumberOfFrames);
+void VIDBUFF_GetAllocatedFrameNumbers(const VIDBUFF_Handle_t BuffersHandle, U32 * const MainBuffers, U32 * const DecimBuffers);
+ST_ErrorCode_t VIDBUFF_AllocateNewFrameBuffer(const VIDBUFF_Handle_t BuffersHandle, BOOL * const NeedForExtraAllocation_p, BOOL * const MaxSizedReached_p);
+ST_ErrorCode_t VIDBUFF_AllocateNewInternalBuffer(const VIDBUFF_Handle_t BuffersHandle, BOOL * const NeedForExtraAllocation_p, BOOL * const MaxSizedReached_p);
+ST_ErrorCode_t VIDBUFF_AllocateNewDecimatedFrameBuffer(const VIDBUFF_Handle_t BuffersHandle, BOOL * const NeedForExtraAllocationDecimated_p, BOOL * const MaxSizedReached_p);
+enum
+{
+    VIDQUEUE_READY_FOR_DISPLAY_EVT = (21 << 16) + 0xD00,
+    VIDQUEUE_PICTURE_CANDIDATE_TO_BE_REMOVED_FROM_DISPLAY_QUEUE_EVT,
+    VIDQUEUE_USER_DATA_EVT
+};
+typedef enum VIDQUEUE_InsertionOrder_e
+{
+    VIDQUEUE_INSERTION_ORDER_INCREASING,
+    VIDQUEUE_INSERTION_ORDER_DECREASING,
+    VIDQUEUE_INSERTION_ORDER_LAST_PLACE
+} VIDQUEUE_InsertionOrder_t;
+typedef void * VIDQUEUE_Handle_t;
+typedef struct VIDQUEUE_ReadyForDisplayParams_s
+{
+    VIDBUFF_PictureBuffer_t * Picture_p;
+} VIDQUEUE_ReadyForDisplayParams_t;
+typedef struct VIDQUEUE_PictureCandidateToBeRemovedParams_s
+{
+    VIDCOM_PictureID_t PictureID;
+} VIDQUEUE_PictureCandidateToBeRemovedParams_t;
+typedef struct
+{
+    ST_Partition_t * CPUPartition_p;
+    ST_DeviceName_t EventsHandlerName;
+    VIDBUFF_Handle_t BufferManagerHandle;
+    ST_DeviceName_t VideoName;
+    U32 UserDataSize;
+} VIDQUEUE_InitParams_t;
+typedef struct VIDQUEUE_UserData_s
+{
+    STVID_UserData_t UserData;
+    VIDCOM_PictureID_t DisplayOrderID;
+    U8 UserDataID;
+    BOOL IsFree;
+} VIDQUEUE_UserData_t;
+ST_ErrorCode_t VIDQUEUE_Init(const VIDQUEUE_InitParams_t * const InitParams_p, VIDQUEUE_Handle_t * const OrderingQueueHandle_p);
+ST_ErrorCode_t VIDQUEUE_Term(const VIDQUEUE_Handle_t OrderingQueueHandle);
+ST_ErrorCode_t VIDQUEUE_InsertPictureUserDataInOrderingQueue(const VIDQUEUE_Handle_t OrderingQueueHandle, const VIDQUEUE_UserData_t UserData);
+ST_ErrorCode_t VIDQUEUE_InsertPictureInQueue(const VIDQUEUE_Handle_t OrderingQueueHandle, VIDBUFF_PictureBuffer_t * Picture_p, VIDQUEUE_InsertionOrder_t InsertionOrder);
+ST_ErrorCode_t VIDQUEUE_PushPicturesToDisplay(const VIDQUEUE_Handle_t OrderingQueueHandle, VIDCOM_PictureID_t * const PictureID_p);
+ST_ErrorCode_t VIDQUEUE_PushAllPicturesToDisplay(const VIDQUEUE_Handle_t OrderingQueueHandle);
+ST_ErrorCode_t VIDQUEUE_CancelPicture(const VIDQUEUE_Handle_t OrderingQueueHandle, VIDCOM_PictureID_t * const PictureID_p);
+ST_ErrorCode_t VIDQUEUE_CancelUpToPicture(const VIDQUEUE_Handle_t OrderingQueueHandle, VIDCOM_PictureID_t * const PictureID_p);
+ST_ErrorCode_t VIDQUEUE_CancelAllPictures(const VIDQUEUE_Handle_t OrderingQueueHandle);
+void VIDQUEUE_ConfigureDecodeDirection(const VIDQUEUE_Handle_t OrderingQueueHandle, const BOOL FWDecode);
+ST_ErrorCode_t VIDQUEUE_ConfigureEvent(const VIDQUEUE_Handle_t OrderingQueueHandle, const STEVT_EventID_t Event, const STVID_ConfigureEventParams_t * const Params_p);
+ST_ErrorCode_t VIDQUEUE_SetInterpolatedPTSBaseline(const VIDQUEUE_Handle_t OrderingQueueHandle,
+                                                   const STVID_PTS_t * const InterpolatedPTSBaseline_p);
+ST_ErrorCode_t VIDQUEUE_GetStatistics(const VIDQUEUE_Handle_t OrderingQueueHandle, STVID_Statistics_t * const Statistics_p);
+ST_ErrorCode_t VIDQUEUE_ResetStatistics(const VIDQUEUE_Handle_t OrderingQueueHandle, const STVID_Statistics_t * const Statistics_p);
+typedef enum {
+    COMPO_CID = (0*0x20),
+    ST2FX_CID = (1*0x20),
+    ST3FX_CID = (2*0x20),
+    STATAPI_CID = (3*0x20),
+    STAUDLX_CID = (4*0x20),
+    STAVMEM_CID = (5*0x20),
+    STBLAST_CID = (6*0x20),
+    STBLIT_CID = (7*0x20),
+    STBOOT_CID = (8*0x20),
+    STCC_CID = (9*0x20),
+    STCLKRV_CID = (10*0x20),
+    STCLOCK_CID = (11*0x20),
+    STCOMMON_CID = (12*0x20),
+    STDENC_CID = (13*0x20),
+    STDISP_CID = (14*0x20),
+    STEVT_CID = (15*0x20),
+    STFDMA_CID = (16*0x20),
+    STFLASH_CID = (17*0x20),
+    STFRONTEND_CID = (18*0x20),
+    STGFB_CID = (19*0x20),
+    STHDMI_CID = (20*0x20),
+    STI2C_CID = (21*0x20),
+    STINJECT_CID = (22*0x20),
+    STIPRC_CID = (23*0x20),
+    STKEYSCN_CID = (24*0x20),
+    STLAYER_CID = (25*0x20),
+    STMERGE_CID = (26*0x20),
+    STNET_CID = (27*0x20),
+    STOS_CID = (28*0x20),
+    STPCCRD_CID = (29*0x20),
+    STPCPD_CID = (30*0x20),
+    STPIO_CID = (31*0x20),
+    STPOD_CID = (32*0x20),
+    STPOWER_CID = (33*0x20),
+    STPTI4_CID = (34*0x20),
+    STPTI5_CID = (35*0x20),
+    STPWM_CID = (36*0x20),
+    STRESET_CID = (37*0x20),
+    STSCART_CID = (38*0x20),
+    STSMART_CID = (39*0x20),
+    STSPI_CID = (40*0x20),
+    STSUBT_CID = (41*0x20),
+    STSYS_CID = (42*0x20),
+    STTBX_CID = (43*0x20),
+    STTTX_CID = (44*0x20),
+    STUART_CID = (45*0x20),
+    STVBI_CID = (46*0x20),
+    STVID_CID = (47*0x20),
+    STVIN_CID = (48*0x20),
+    STVMIX_CID = (49*0x20),
+    STVOUT_CID = (50*0x20),
+    STVTG_CID = (51*0x20),
+    STBUFFER_CID = (52*0x20),
+    STXCPU_CID = (53*0x20),
+    STAPP_CID = (54*0x20),
+    STTUNER_CID = (55*0x20),
+    STTKDMA_CID = (56*0x20),
+    STFSK_CID = (57*0x20),
+    STEVT_RELAY_CID = (58*0x20),
+    STTRACE_LAST_CID = (59*0x20)
+} STTRACE_DriverComponentID;
+typedef enum {
+    FATAL=0,
+    ERROR,
+    WARNING,
+    INFO,
+    API_IN,
+    API_OUT,
+    USER,
+    STTRACE_LAST_TYPE
+} STTRACE_Type;
+typedef enum {
+    LEVEL0 = 0,
+    LEVEL1 = 1,
+    LEVEL2 = 2,
+    LEVEL3 = 3,
+ STTRACE_LAST_LEVEL = 4
+} STTRACE_Level;
+typedef void (* STTBX_TraceTxt_functionpointer_t) (const STTRACE_DriverComponentID component_id , const STTRACE_Type type , const STTRACE_Level level , const char * format , ...);
+extern STTBX_TraceTxt_functionpointer_t STTBX_TraceTxt_fptr;
+typedef U8 STPIO_BitMask_t;
+typedef U32 STPIO_Handle_t;
+typedef enum STPIO_BitConfig_e
+{
+    STPIO_BIT_NOT_SPECIFIED = 0,
+    STPIO_BIT_BIDIRECTIONAL = 1,
+    STPIO_BIT_OUTPUT = 2,
+    STPIO_BIT_INPUT = 4,
+    STPIO_BIT_ALTERNATE_OUTPUT = 6,
+    STPIO_BIT_ALTERNATE_BIDIRECTIONAL = 7,
+    STPIO_BIT_BIDIRECTIONAL_HIGH = 9,
+    STPIO_BIT_OUTPUT_HIGH = 10
+} STPIO_BitConfig_t;
+typedef enum STPIO_CompareClear_e
+{
+    STPIO_COMPARE_CLEAR_AUTO,
+    STPIO_COMPARE_CLEAR_MANUAL
+} STPIO_CompareClear_t;
+typedef struct STPIO_Compare_s
+{
+    STPIO_BitMask_t CompareEnable;
+    STPIO_BitMask_t ComparePattern;
+} STPIO_Compare_t;
+typedef struct STPIO_PIOBit_s
+{
+    ST_DeviceName_t PortName;
+    STPIO_BitMask_t BitMask;
+} STPIO_PIOBit_t;
+typedef struct STPIO_InitParams_s
+{
+    U32 *BaseAddress;
+    U32 InterruptNumber;
+    U32 InterruptLevel;
+    ST_Partition_t *DriverPartition;
+} STPIO_InitParams_t;
+typedef struct STPIO_OpenParams_s
+{
+    STPIO_BitMask_t ReservedBits;
+    STPIO_BitConfig_t BitConfigure[8];
+    void (* IntHandler)(STPIO_Handle_t Handle, STPIO_BitMask_t ActiveBits);
+} STPIO_OpenParams_t;
+typedef struct STPIO_Status_s
+{
+    STPIO_BitMask_t BitMask;
+    STPIO_BitConfig_t BitConfigure[8];
+} STPIO_Status_t;
+typedef struct STPIO_TermParams_s
+{
+    BOOL ForceTerminate;
+} STPIO_TermParams_t;
+ST_ErrorCode_t STPIO_Init (const ST_DeviceName_t DeviceName,
+                           STPIO_InitParams_t *InitParams);
+ST_ErrorCode_t STPIO_InitNoReset (const ST_DeviceName_t DeviceName,
+                                  STPIO_InitParams_t *InitParams);
+ST_ErrorCode_t STPIO_Open (const ST_DeviceName_t DeviceName,
+                           STPIO_OpenParams_t *OpenParams,
+                           STPIO_Handle_t *Handle);
+ST_ErrorCode_t STPIO_Close (STPIO_Handle_t Handle);
+ST_ErrorCode_t STPIO_Write (STPIO_Handle_t Handle, U8 Buffer);
+ST_ErrorCode_t STPIO_Read (STPIO_Handle_t Handle, U8 *Buffer);
+ST_ErrorCode_t STPIO_Set (STPIO_Handle_t Handle, STPIO_BitMask_t BitMask);
+ST_ErrorCode_t STPIO_Clear (STPIO_Handle_t Handle, STPIO_BitMask_t BitMask);
+ST_ErrorCode_t STPIO_GetCompare (STPIO_Handle_t Handle,
+                                 STPIO_Compare_t *CompareStatus);
+ST_ErrorCode_t STPIO_GetCompareClear (STPIO_Handle_t Handle,
+                                      STPIO_CompareClear_t *CompareClear_p);
+ST_ErrorCode_t STPIO_SetCompare (STPIO_Handle_t Handle,
+                                 STPIO_Compare_t *CompareStatus);
+ST_ErrorCode_t STPIO_SetCompareClear(STPIO_Handle_t Handle,
+                                     STPIO_CompareClear_t CompareClear);
+ST_ErrorCode_t STPIO_SetConfig (STPIO_Handle_t Handle,
+                                const STPIO_BitConfig_t BitConfigure[8]);
+ST_ErrorCode_t STPIO_GetBaseAddress (ST_DeviceName_t DeviceName,
+                                     U32 **BaseAddress);
+ST_Revision_t STPIO_GetRevision (void);
+ST_ErrorCode_t STPIO_Term (const ST_DeviceName_t DeviceName,
+                           STPIO_TermParams_t *TermParams);
+typedef U32 STUART_Handle_t;
+typedef enum STUART_DataBits_e
+{
+ STUART_7BITS_ODD_PARITY,
+ STUART_7BITS_EVEN_PARITY,
+ STUART_8BITS_NO_PARITY,
+ STUART_8BITS_ODD_PARITY,
+ STUART_8BITS_EVEN_PARITY,
+ STUART_8BITS_PLUS_WAKEUP,
+ STUART_9BITS_NO_PARITY,
+ STUART_9BITS_UNKNOWN_PARITY,
+ STUART_9BITS_CONFIRMED_PARITY
+} STUART_DataBits_t;
+typedef enum STUART_StopBits_e
+{
+ STUART_STOP_0_5,
+ STUART_STOP_1_0,
+ STUART_STOP_1_5,
+ STUART_STOP_2_0
+} STUART_StopBits_t;
+typedef enum STUART_FlowControl_e
+{
+ STUART_NO_FLOW_CONTROL,
+ STUART_SW_FLOW_CONTROL,
+ STUART_RTSCTS_FLOW_CONTROL
+} STUART_FlowControl_t;
+typedef enum STUART_SWFlowControl_e
+{
+ STUART_SW_FLOW_NOTHING,
+ STUART_SW_FLOW_START,
+ STUART_SW_FLOW_STOP
+} STUART_SWFlowControl_t;
+typedef enum STUART_TransferType_e{
+ STUART_CPU,
+ STUART_FDMA,
+} STUART_TransferType_t;
+typedef enum STUART_Device_e
+{
+ STUART_NO_HW_FIFO,
+ STUART_16_BYTE_FIFO,
+ STUART_RTSCTS,
+ STUART_ISO7816,
+ STUART_FSK,
+ STUART_UNKNOWN_DEVICE
+} STUART_Device_t;
+typedef enum STUART_Direction_e
+{
+ STUART_DIRECTION_TRANSMIT = 1,
+ STUART_DIRECTION_RECEIVE = 2,
+ STUART_DIRECTION_BOTH = 3
+} STUART_Direction_t;
+typedef enum STUART_ExtendedParams_e
+{
+ STUART_STANDARD_PARAMS = (1<<0),
+ STUART_ATUO_PARITY_REJECT = (1<<1),
+ STUART_THRESHOLD = (1<<2),
+ STUART_SC_FLOW_CONTROL = (1<<3)
+} STUART_ExtendedParamType_t;
+typedef struct STUART_Protocol_s
+{
+ STUART_DataBits_t DataBits;
+ STUART_StopBits_t StopBits;
+ STUART_FlowControl_t FlowControl;
+ U32 BaudRate;
+ ST_String_t TermString;
+ U32 TimeOut;
+ void (*NotifyFunction)(STUART_Handle_t Handle, ST_ErrorCode_t ErrorCode);
+} STUART_Protocol_t;
+typedef struct STUART_Params_s
+{
+ BOOL SmartCardModeEnabled;
+ U16 GuardTime;
+ U8 Retries;
+ STUART_Protocol_t RxMode;
+ STUART_Protocol_t TxMode;
+ BOOL NACKSignalDisabled;
+ BOOL HWFifoDisabled;
+ BOOL UARTUseFDMA;
+} STUART_Params_t;
+typedef struct STUART_OpenParams_s
+{
+ BOOL LoopBackEnabled;
+ BOOL FlushIOBuffers;
+ STUART_Params_t *DefaultParams;
+} STUART_OpenParams_t;
+typedef struct STUART_InitParams_s
+{
+ STUART_Device_t UARTType;
+ STUART_TransferType_t UartTransferType;
+ ST_Partition_t *DriverPartition;
+ ST_Partition_t *NCachePartition;
+ U32 *BaseAddress;
+ U32 InterruptNumber;
+ U32 InterruptLevel;
+ U32 ClockFrequency;
+ BOOL SwFIFOEnable;
+ U32 FIFOLength;
+ STPIO_PIOBit_t RXD;
+ STPIO_PIOBit_t TXD;
+ STPIO_PIOBit_t RTS;
+ STPIO_PIOBit_t CTS;
+ STUART_Params_t *DefaultParams;
+} STUART_InitParams_t;
+typedef struct STUART_TermParams_s
+{
+ BOOL ForceTerminate;
+} STUART_TermParams_t;
+typedef struct STUART_Statistics_s
+{
+ U32 NumberBytesReceived;
+ U32 NumberBytesTransmitted;
+ U32 NumberOverrunErrors;
+ U32 NumberFramingErrors;
+ U32 NumberParityErrors;
+}STUART_Statistics_t;
+typedef struct STUART_ParityRejectParam_s
+{
+ BOOL AutoParityRejectionEnable;
+} STUART_ParityRejectParam_t;
+typedef struct STUART_ThresholdParam_s
+{
+ BOOL ThresholdEnable;
+ U32 ThresholdValue;
+} STUART_ThresholdParam_t;
+typedef struct STUART_SCFlowControlParam_s
+{
+ BOOL FlowControlDisable;
+} STUART_SCFlowControlParam_t;
+typedef struct STUART_ExtendedParam_s
+{
+ STUART_Params_t UartStandardParams;
+ STUART_ParityRejectParam_t ParityRejectionParams;
+ STUART_ThresholdParam_t ThresholdParams;
+ STUART_SCFlowControlParam_t FlowControlParams;
+} STUART_ExtendedParam_t;
+ST_ErrorCode_t STUART_EnableStuffing (STUART_Handle_t Handle,U8 StuffByte);
+ST_ErrorCode_t STUART_DisableStuffing(STUART_Handle_t Handle);
+ST_ErrorCode_t STUART_Abort(STUART_Handle_t Handle, STUART_Direction_t Direction);
+ST_ErrorCode_t STUART_Close(STUART_Handle_t Handle);
+ST_ErrorCode_t STUART_Flush(STUART_Handle_t Handle);
+ST_ErrorCode_t STUART_GetActualBaudRate(STUART_Handle_t Handle,
+          U32 *ActualBaudRate
+            );
+ST_ErrorCode_t STUART_GetParams(STUART_Handle_t Handle,
+        STUART_Params_t *Params
+          );
+ST_ErrorCode_t STUART_GetStatistics(STUART_Handle_t Handle,
+         STUART_Statistics_t *Stats_p);
+ST_Revision_t STUART_GetRevision(void);
+ST_ErrorCode_t STUART_Init(const ST_DeviceName_t DeviceName,
+         const STUART_InitParams_t *InitParams
+        );
+ST_ErrorCode_t STUART_Open(const ST_DeviceName_t DeviceName,
+         STUART_OpenParams_t *OpenParameters,
+         STUART_Handle_t *Handle
+        );
+ST_ErrorCode_t STUART_Pause(STUART_Handle_t Handle,
+       STUART_Direction_t Direction);
+ST_ErrorCode_t STUART_PosixRead(STUART_Handle_t Handle,
+        U8 *Buffer,
+        U32 MinToRead,
+        U32 MaxToRead,
+        U32 *NumberRead,
+        U32 TimeOut
+        );
+ST_ErrorCode_t STUART_Resume(STUART_Handle_t Handle,
+        STUART_Direction_t Direction);
+ST_ErrorCode_t STUART_SetParams(STUART_Handle_t Handle,
+        STUART_Params_t *Params
+          );
+ST_ErrorCode_t STUART_Term(const ST_DeviceName_t DeviceName,
+         const STUART_TermParams_t *TermParams
+        );
+ST_ErrorCode_t STUART_Write(STUART_Handle_t Handle,
+       U8 *Buffer,
+       U32 NumberToWrite,
+       U32 *NumberWritten,
+       U32 Timeout
+         );
+typedef ST_ErrorCode_t (* STUART_Write_functionpointer_t) (STUART_Handle_t,
+                                                            U8 *,
+                                                            U32,
+                                                            U32 *,
+                                                            U32);
+ST_ErrorCode_t STUART_GetExtendedParams(STUART_Handle_t Handle,
+          STUART_ExtendedParamType_t ParamType,
+          STUART_ExtendedParam_t *Params);
+ST_ErrorCode_t STUART_SetExtendedParams(STUART_Handle_t Handle,
+          STUART_ExtendedParamType_t ParamType,
+          STUART_ExtendedParam_t *Params);
+typedef struct STTBX_DataDesc_s
+{
+    U16 cpu;
+    U16 unused_align;
+    ST_DeviceName_t name;
+    ST_DeviceName_t instance;
+} STTBX_DataDesc_t;
+typedef struct STTBX_DataInfo_s
+{
+    S64 val;
+    S64 min;
+    S64 max;
+    U32 read;
+} STTBX_DataInfo_t;
+typedef struct STTBX_Data_s
+{
+    STTBX_DataDesc_t DataDesc;
+    STTBX_DataInfo_t DataInfo;
+} STTBX_Data_t;
+typedef struct STTBX_DataRef_s
+{
+    U16 cpu;
+    U16 idx;
+    STTBX_DataInfo_t* dataInfo_p;
+} STTBX_DataRef_t;
+ST_ErrorCode_t STTBX_DataInit(STTBX_Data_t* Getsttbx_DataCpu[]);
+ST_ErrorCode_t STTBX_DataTerm(void);
+ST_ErrorCode_t STTBX_GetDataRef (STTBX_DataDesc_t dataDesc, STTBX_DataRef_t* dataRef);
+ST_ErrorCode_t STTBX_GetDataInfo (STTBX_DataRef_t dataRef, STTBX_DataInfo_t* dataInfo);
+ST_ErrorCode_t STTBX_GetNextData (STTBX_Data_t* data, STTBX_DataRef_t* dataRef);
+ST_ErrorCode_t STTBX_SetData (STTBX_Data_t data, STTBX_DataRef_t* dataRef);
+ST_ErrorCode_t STTBX_SetDataInfo (STTBX_DataRef_t dataRef, STTBX_DataInfo_t dataInfo);
+typedef struct STTBX_InitParams_s
+{
+}STTBX_InitParams_t;
+typedef struct STTBX_TermParams_s
+{
+}STTBX_TermParams_t;
+ST_ErrorCode_t STTBX_Init(const ST_DeviceName_t DeviceName, const STTBX_InitParams_t * InitParams_p);
+ST_ErrorCode_t STTBX_Term(const ST_DeviceName_t DeviceName, const STTBX_TermParams_t * TermParams_p);
+ST_ErrorCode_t STTBX_FullTrace_Init(void);
+ST_ErrorCode_t STTBX_FullTrace_Cleanup(void);
+ST_ErrorCode_t STTBX_SetTraceFilter(STTRACE_DriverComponentID component_id, STTRACE_Type type, STTRACE_Level level,U8 Value);
+ST_ErrorCode_t STTBX_PrintTraceFilter(STTRACE_DriverComponentID component_id);
+ST_ErrorCode_t STTBX_EarlyTrace_Init(void);
+ST_ErrorCode_t STTBX_EarlyTrace_Cleanup(void);
+extern STTBX_TraceTxt_functionpointer_t STTBX_TraceTxt_fptr;
+extern STUART_Write_functionpointer_t STTBX_TraceTxt_stuart_fptr;
+extern STUART_Handle_t STTBX_TraceTxt_stuart_handle;
+void STTBX_TraceTxt_register_stuart(STUART_Write_functionpointer_t fptr, STUART_Handle_t hnd);
+extern const U32 STTBX_EarlyTrace_buffer_entry_size;
+extern volatile U32 STTBX_EarlyTrace_buffer_entries_count;
+extern U8 * STTBX_EarlyTrace_buffer;
+extern volatile U32 STTBX_EarlyTrace_inprogress;
+typedef struct STTBX_ODD_Context_s STTBX_ODD_Context_t ;
+typedef ST_ErrorCode_t (*STTBX_ODD_GenCallbackFn_t)( STTBX_ODD_Context_t *ODDContext, void *LocalData, BOOL *EOF_Indicator );
+ST_ErrorCode_t STTBX_ODD_Register( char *Path, U32 MaxDataSize, STTBX_ODD_GenCallbackFn_t GenFn, void *LocalData);
+ST_ErrorCode_t STTBX_ODD_Unregister(char *Path);
+ST_ErrorCode_t STTBX_ODD_Printf(STTBX_ODD_Context_t *ODDContext, const char *format, ...) __attribute__ ((format (printf, 2, 3)));
+    extern ST_ErrorCode_t TRACE_Print(const char *format,...);
+typedef struct ForTask_s
+{
+    STOS_Clock_t MaxWaitOrderTime;
+    BOOL ControllerCommand;
+} ForTask_t;
+typedef enum
+{
+    PARSER_STATE_IDLE,
+    PARSER_STATE_READY_TO_PARSE,
+    PARSER_STATE_PARSING,
+    PARSER_STATE_NOTIFYING
+} ParserState_t;
+typedef struct
+{
+    BOOL IsInBitBuffer;
+    BOOL IsPending;
+    U8 Value;
+    U8 * StartAddress_p;
+    U8 * StopAddress_p;
+    U32 SliceCount;
+    BOOL SliceFound;
+    U8 * SliceStartAddress_p;
+    BOOL SubBDUPending;
+    U8 SubBDUType;
+    U8* SubBDUStartAddress;
+    U8* FirstSubBDUStartAddress;
+} StartCode_t;
+typedef struct SCBuffer_s
+{
+    STAVMEM_BlockHandle_t SCListHdl;
+    STFDMA_SCEntry_t * SCList_Start_p;
+    STFDMA_SCEntry_t * SCList_Start_NCp;
+    STFDMA_SCEntry_t * SCList_Start_Cp;
+    STFDMA_SCEntry_t * SCList_Stop_p;
+    STFDMA_SCEntry_t * SCList_Loop_p;
+    STFDMA_SCEntry_t * SCList_Write_p;
+    STFDMA_SCEntry_t * LastLatchSCList_Loop_p;
+    STFDMA_SCEntry_t * LastLatchSCList_Write_p;
+    STFDMA_SCEntry_t * NextSCEntry_p;
+    STFDMA_SCEntry_t * CurrentSCEntry_p;
+    STFDMA_SCEntry_t * SavedNextSCEntry_p;
+} SCBuffer_t;
+typedef struct
+{
+    U32 PTS32;
+    BOOL PTS33;
+    void* Address_p;
+} PTS_t;
+typedef struct
+{
+    PTS_t SCList[10];
+    PTS_t* Write_p;
+    PTS_t* Read_p;
+} PTS_SCList_t;
+typedef struct BitBuffer_s
+{
+    U8 * ES_Start_p;
+    U8 * ES_Start_NCp;
+    U8 * ES_Start_Cp;
+    U8 * ES_Stop_p;
+    U8 * ES_Write_p;
+    U8 * ES_ParserRead_p;
+    U8 * ES_DecoderRead_p;
+    U8 ES0RangeEnabled;
+    U8 ES0RangeStart;
+    U8 ES0RangeEnd;
+    BOOL ES0OneShotEnabled;
+    U8 ES1RangeEnabled;
+    U8 ES1RangeStart;
+    U8 ES1RangeEnd;
+    BOOL ES1OneShotEnabled;
+} BitBuffer_t;
+typedef struct GetStreamBits_s {
+    U8* SC_StartByte_Cp;
+    U8* Byte_Cp;
+    U32 ByteOffset;
+    U32 BufferSize;
+    U8* BufferEnd_Cp;
+    U8* Start_BBAddress_Cp;
+    U8* Stop_BBAddress_Cp;
+    U8* BufferLimit_Cp;
+    BOOL IsStreamToWrap;
+    BOOL WasStreamWrapped;
+    U32 Bits;
+    U8 NumberOfBits;
+    BOOL ReachEndOfStream;
+    BOOL IsEmulationPreventionSupported;
+    U8 EmulationPreventionPattern;
+    U8 EmulationPreventionByteOffset;
+    BOOL WordSwapFlag;
+} GetStreamBits_t;
+typedef struct PESBuffer_s
+{
+    STAVMEM_BlockHandle_t PESBufferHdl;
+    void * PESBufferBase_p;
+    void * PESBufferBase_NCp;
+    void * PESBufferBase_Cp;
+    void * PESBufferTop_p;
+    BOOL PESRangeEnabled;
+    U8 PESSCRangeStart;
+    U8 PESSCRangeEnd;
+    BOOL PESOneShotEnabled;
+    BOOL InternalAllocation;
+} PESBuffer_t;
+typedef struct Inject_s
+{
+    VIDINJ_Handle_t InjecterHandle;
+    U32 InjectNum;
+} Inject_t;
+enum
+{
+    PARSER_JOB_COMPLETED_EVT = (21 << 16) + 0xA00,
+    PARSER_STOP_EVT,
+    PARSER_PICTURE_SKIPPED_EVT,
+    PARSER_FIND_DISCONTINUITY_EVT,
+    PARSER_ES_INJECTION_FINISHED_EVT,
+    PARSER_BITBUFFER_FULLY_PARSED_EVT,
+    PARSER_USER_DATA_EVT
+};
+typedef enum PARSER_ErrorCode_e
+{
+    PARSER_NO_ERROR,
+    PARSER_ERROR_STREAM_SYNTAX
+} PARSER_ErrorCode_t;
+typedef struct PARSER_ParsingJobStatus_s
+{
+    BOOL HasErrors;
+    PARSER_ErrorCode_t ErrorCode;
+    STOS_Clock_t JobSubmissionTime;
+    STOS_Clock_t JobCompletionTime;
+} PARSER_ParsingJobStatus_t;
+typedef struct PARSER_ParsingJobResults_s
+{
+    PARSER_ParsingJobStatus_t ParsingJobStatus;
+    VIDCOM_ParsedPictureInformation_t * ParsedPictureInformation_p;
+    U32 OutputCounter;
+} PARSER_ParsingJobResults_t;
+typedef struct PARSER_PictureParamsForBitRate_s
+{
+    U32 NbFieldsDisplay;
+    BOOL RepeatFirstField;
+    U8 RepeatProgressiveCounter;
+    STVID_PictureStructure_t PictureStructure;
+    BOOL TopFieldFirst;
+    U32 FrameRate;
+}PARSER_PictureParamsForBitRate_t;
+typedef struct PARSER_ParserSkipPictureParams_s
+{
+    BOOL IsPictureParamsToComputeFieldsValid;
+    U32 OutputCounter;
+    void * BitBufferPictureStopAddress;
+    PARSER_PictureParamsForBitRate_t PictureParamsForBitRate;
+    U32 DecodingOrderFrameID;
+} PARSER_ParserSkipPictureParams_t;
+typedef void * PARSER_Handle_t;
+typedef enum BitBufferType_e
+{
+    BIT_BUFFER_CIRCULAR,
+    BIT_BUFFER_LINEAR
+} BitBufferType_t;
+typedef struct
+{
+    void * BufferAddress_p;
+    void * BufferAddress_NCp;
+    void * BufferAddress_Cp;
+    U32 BufferSize;
+} PARSER_ExtraParams_t;
+typedef struct PARSER_InitParams_s
+{
+    ST_Partition_t * CPUPartition_p;
+    ST_DeviceName_t EventsHandlerName;
+    ST_DeviceName_t VideoName;
+    void * BitBufferAddress_p;
+    void * BitBufferAddress_NCp;
+    void * BitBufferAddress_Cp;
+    U32 BitBufferSize;
+    U32 UserDataSize;
+    U8 DecoderNumber;
+    STVID_DeviceType_t DeviceType;
+    STAVMEM_PartitionHandle_t AvmemPartitionHandle;
+    void * RegistersBaseAddress_NCp;
+    void * CompressedDataInputBaseAddress_p;
+    VIDINJ_Handle_t InjecterHandle;
+    BOOL IsMosaicContext;
+    BOOL IsSmoothBackward;
+} PARSER_InitParams_t;
+typedef struct PARSER_StartParams_s
+{
+    STVID_StreamType_t StreamType;
+    STVID_BroadcastProfile_t BroadcastProfile;
+    U8 StreamID;
+    STVID_ErrorRecoveryMode_t ErrorRecoveryMode;
+    BOOL OverwriteFullBitBuffer;
+    void * BitBufferWriteAddress_p;
+    VIDCOM_GlobalDecodingContext_t *DefaultGDC_p;
+    VIDCOM_PictureDecodingContext_t *DefaultPDC_p;
+    BOOL RealTime;
+    BOOL ResetParserContext;
+    BOOL DecodeOnce;
+} PARSER_StartParams_t;
+typedef struct PARSER_GetPictureParams_s
+{
+    BOOL GetRandomAccessPoint;
+    STVID_ErrorRecoveryMode_t ErrorRecoveryMode;
+    STVID_DecodedPictures_t DecodedPictures;
+    BOOL ForceIDisplayOnDiscontinuity;
+} PARSER_GetPictureParams_t;
+typedef struct PARSER_InformReadAddressParams_s
+{
+    void * DecoderReadAddress_p;
+    STVID_ErrorRecoveryMode_t ErrorRecoveryMode;
+} PARSER_InformReadAddressParams_t;
+typedef struct PARSER_GetBitBufferLevelParams_s
+{
+    U32 BitBufferLevelInBytes;
+} PARSER_GetBitBufferLevelParams_t;
+typedef struct
+{
+    ST_ErrorCode_t (*Init)(const PARSER_Handle_t ParserHandle, const PARSER_InitParams_t * const InitParams_p);
+    ST_ErrorCode_t (*Stop)(const PARSER_Handle_t ParserHandle);
+    ST_ErrorCode_t (*Start)(const PARSER_Handle_t ParserHandle, const PARSER_StartParams_t * const StartParams_p);
+    ST_ErrorCode_t (*GetPicture)(const PARSER_Handle_t ParserHandle, const PARSER_GetPictureParams_t * const GetPictureParams_p);
+    ST_ErrorCode_t (*Term)(const PARSER_Handle_t ParserHandle);
+    ST_ErrorCode_t (*InformReadAddress)(const PARSER_Handle_t ParserHandle, const PARSER_InformReadAddressParams_t * const InformReadAddressParams_p);
+    ST_ErrorCode_t (*GetBitBufferLevel)(const PARSER_Handle_t ParserHandle, PARSER_GetBitBufferLevelParams_t * const GetBitBufferLevelParams_p);
+    ST_ErrorCode_t (*Setup)(const PARSER_Handle_t ParserHandle, const STVID_SetupParams_t * const SetupParams_p);
+    ST_ErrorCode_t (*FlushInjection)(const PARSER_Handle_t ParserHandle);
+    ST_ErrorCode_t (*DataInjectionCompleted)(const PARSER_Handle_t ParserHandle);
+    U32 (*GetBitBufferOutputCounter)(const PARSER_Handle_t ParserHandle);
+    void (*SetBitBuffer)(const PARSER_Handle_t ParserHandle,
+                         void * const BufferAddressStart_p,
+                         const U32 BufferSize,
+                         const BitBufferType_t BufferType,
+                         const BOOL Stop);
+} PARSER_FunctionsTable_t;
+typedef struct
+{
+    const PARSER_FunctionsTable_t * FunctionsTable_p;
+    ST_Partition_t * CPUPartition_p;
+    STEVT_Handle_t EventsHandle;
+    STAVMEM_PartitionHandle_t AvmemPartitionHandle;
+    ST_DeviceName_t VideoName;
+    STVID_DeviceType_t DeviceType;
+    void * RegistersBaseAddress_NCp;
+    U32 ValidityCheck;
+    void * CompressedDataInputBaseAddress_p;
+    U8 DecoderNumber;
+    U32 InterruptEvt;
+    U32 InterruptLevel;
+    U32 InterruptNumber;
+    void * PrivateData_p;
+    U32 DefaultWidth;
+    U32 DefaultHeight;
+    U32 DefaultFrameRate;
+    U32 DefaultAspectRatio;
+    U32 ForcedWidth;
+    U32 ForcedHeight;
+    U32 ForcedFrameRate;
+    U32 ForcedAspectRatio;
+    SCBuffer_t SCBuffer;
+    BitBuffer_t BitBuffer;
+    PESBuffer_t PESBuffer;
+    Inject_t Inject;
+    StartCode_t StartCode;
+    BOOL PTSAvailableForNextPicture;
+    STVID_PTS_t PTSForNextPicture;
+    PTS_t LastPTSStored;
+    PTS_SCList_t PTS_SCList;
+    BOOL StopIsPending;
+    VIDCOM_Task_t ParserTask;
+    ParserState_t ParserState;
+    PARSER_ParsingJobResults_t ParserJobResults;
+    VIDQUEUE_UserData_t UserData;
+    U32 UserDataSize;
+    STOS_Semaphore_t * ParserOrder;
+    STOS_Semaphore_t * ParserSC;
+    ForTask_t ForTask;
+    U8 * LastSCAdd_p;
+    GetStreamBits_t GSB;
+    STVID_MarkerData_t MarkerData[5];
+    U8 MarkerDataIndex;
+    BOOL MarkerChunkID;
+    BOOL MarkerWaitPTS;
+    BOOL MarkerBreakFWD;
+    BOOL SendMarkerPTS;
+    STVID_MarkerData_t PreviousMarkerDataNotSent[5];
+    U8 PreviousMarkerDataNotSentIndex;
+    BOOL PreviousMarkerNotSent;
+    BOOL ForceIDisplayOnDiscontinuity;
+    STVID_InjectionMode_t InjectionMode;
+    BOOL IsESInjectionFinished;
+    BOOL Backward;
+    BOOL IsSmoothBackward;
+    BOOL IsBitBufferFullyParsed;
+    BOOL StopParsing;
+} PARSER_Properties_t;
+ST_ErrorCode_t VPARCOM_AllocatePESBuffer(const PARSER_Handle_t ParserHandle,
+                                         const U32 PESBufferSize,
+                                         const PARSER_InitParams_t * const InitParams_p);
+ST_ErrorCode_t VPARCOM_DeAllocatePESBuffer(const PARSER_Handle_t ParserHandle);
+ST_ErrorCode_t VPARCOM_ReAllocatePESBuffer(const PARSER_Handle_t ParserHandle, const STVID_SetupParams_t * SetupParams_p, const U32 PESBufferSize);
+ST_ErrorCode_t VPARCOM_AllocateSCBuffer(const PARSER_Handle_t ParserHandle,
+                                        const U32 SCBufferSize,
+                                        const PARSER_InitParams_t * const InitParams_p);
+ST_ErrorCode_t VPARCOM_DeAllocateSCBuffer(const PARSER_Handle_t ParserHandle);
+ST_ErrorCode_t VPARCOM_ReAllocateSCBuffer(const PARSER_Handle_t ParserHandle, const STVID_SetupParams_t * SetupParams_p, const U32 SCBufferSize);
+void VPARCOM_InitSCBuffer(const PARSER_Handle_t ParserHandle);
+void VPARCOM_TransferLimits(const PARSER_Handle_t ParserHandle);
+ST_ErrorCode_t VPARCOM_BitBufferInjectionInit(const PARSER_Handle_t ParserHandle, const PARSER_ExtraParams_t * const BitBufferInjectionParams_p);
+void VPARCOM_InformReadAddress(const PARSER_Handle_t ParserHandle,
+                               const PARSER_InformReadAddressParams_t * const InformReadAddressParams_p,
+                               STVID_ErrorRecoveryMode_t * ErrorRecoveryMode_p);
+void VPARCOM_GetBitBufferLevel(const PARSER_Handle_t ParserHandle, U8 StartCode, BOOL Flush,
+                               PARSER_GetBitBufferLevelParams_t * const GetBitBufferLevelParams_p);
+void VPARCOM_GetControllerCommand(const PARSER_Handle_t ParserHandle);
+ST_ErrorCode_t VPARCOM_GetDataInputBufferParams(const PARSER_Handle_t ParserHandle,
+                                                VIDBUFF_BufferBaseAddresses_t * const InputBufferBaseAddress_p,
+                                                U32 * const Size_p);
+void VPARCOM_PointOnNextSC(const PARSER_Handle_t ParserHandle);
+ST_ErrorCode_t VPARCOM_SetEnhancedDataInputInterface(const PARSER_Handle_t ParserHandle,
+                                const STVID_EnhancedDataInputInterfaceParams_t * const Params_p );
+ST_ErrorCode_t VPARCOM_SetDataInputInterface(const PARSER_Handle_t ParserHandle,
+                                ST_ErrorCode_t (*GetWriteAddress) (void * const Handle, void ** const Address_p),
+                                void (*InformReadAddress)(void * const Handle, void * const Address),
+                                void * const Handle);
+void VPARCOM_InitParserProperties(const PARSER_Handle_t ParserHandle);
+void VPARCOM_InitPictureGenericData(VIDCOM_PictureGenericData_t * const PictureGenericData_p);
+void VPARCOM_SetBitBuffer(const PARSER_Handle_t ParserHandle,
+                            void * const BufferAddressStart_p,
+                            const U32 BufferSize,
+                            const BitBufferType_t BufferType,
+                            const BOOL Stop);
+void VPARCOM_SetRange(const PARSER_Handle_t ParserHandle,
+                      const PARSER_StartParams_t * const StartParams_p,
+                      U8 PESSCRangeStart, U8 PESSCRangeEnd,
+                      BOOL ES0RangeEnabled,U8 ES0RangeId,U8 ES0RangeStart, U8 ES0RangeEnd, BOOL ES0OneShotEnabled,
+                      BOOL ES1RangeEnabled,U8 ES1RangeId,U8 ES1RangeStart, U8 ES1RangeEnd, BOOL ES1OneShotEnabled);
+ST_ErrorCode_t VPARCOM_Setup(const PARSER_Handle_t ParserHandle, const U32 SCBufferSize, const U32 PESBufferSize, const STVID_SetupParams_t * const SetupParams_p);
+U32 VPARCOM_GetBitBufferOutputCounter(const PARSER_Handle_t ParserHandle);
+ST_ErrorCode_t VPARCOM_StartParserTask(const PARSER_Handle_t ParserHandle, char* TaskName_p, void (*ParserTaskFunc)(void* ParserHandle));
+ST_ErrorCode_t VPARCOM_StopParserTask(const PARSER_Handle_t ParserHandle);
+ST_ErrorCode_t VPARCOM_Term(const PARSER_Handle_t ParserHandle);
+void VPARCOM_Stop(const PARSER_Handle_t ParserHandle);
+ST_ErrorCode_t VPARCOM_GetStatistics(const PARSER_Handle_t ParserHandle, STVID_Statistics_t * const Statistics_p);
+ST_ErrorCode_t VPARCOM_ResetStatistics(const PARSER_Handle_t ParserHandle, const STVID_Statistics_t * const Statistics_p);
+void VPARCOM_GetStatus(const PARSER_Handle_t ParserHandle, STVID_Status_t * Status_p);
+void VPARCOM_SavePTSEntry(const PARSER_Handle_t ParserHandle, STFDMA_SCEntry_t* CPUPTSEntry_Cp, U32 PTSSCAdd);
+void VPARCOM_SearchForAssociatedPTS(const PARSER_Handle_t ParserHandle, U8 * PictureStartAddress_p);
+U8 * VPARCOM_MoveBackInStream(const PARSER_Handle_t ParserHandle, U8 * Address, U8 RewindInByte);
+U8 * VPARCOM_MoveForwardInStream(const PARSER_Handle_t ParserHandle, U8 * Address, U8 Increment);
+void VPARCOM_InitPTSList(const PARSER_Handle_t ParserHandle);
+ST_ErrorCode_t PARSER_Init(const PARSER_InitParams_t * const InitParams_p, PARSER_Handle_t * const ParserHandle_p);
+ST_ErrorCode_t PARSER_Term(const PARSER_Handle_t ParserHandle);
+ST_ErrorCode_t PARSER_Setup(const PARSER_Handle_t ParserHandle, const STVID_SetupParams_t * const SetupParams_p);
+ST_ErrorCode_t PARSER_SetInjectionMode(const PARSER_Handle_t ParserHandle, const STVID_InjectionMode_t InjectionMode);
+ST_ErrorCode_t PARSER_HasPendingStartCode(const PARSER_Handle_t ParserHandle, BOOL * const HasPendingStartCode_p);
+U8 VPARCOM_GetByteFromByteStream(const PARSER_Handle_t ParserHandle);
+U8 VPARCOM_GetBitFromByteStream(const PARSER_Handle_t ParserHandle);
+U32 VPARCOM_GetUnsigned(U8 Len, const PARSER_Handle_t ParserHandle);
+U32 VPARCOM_ReadUnsigned(U8 Len, const PARSER_Handle_t ParserHandle);
+U32 VPARCOM_GetVariableLengthCode(U32 *VLCTable, U32 maxlength, const PARSER_Handle_t ParserHandle);
+void VPARCOM_ByteAlign(const PARSER_Handle_t ParserHandle);
+U32 VPARCOM_ByteAligned(const PARSER_Handle_t ParserHandle, U32 nBits);
+U32 VPARCOM_NextBitsByteAligned(const PARSER_Handle_t ParserHandle, U32 nBits);
+void VPARCOM_GetMarker(const PARSER_Handle_t ParserHandle, STFDMA_SCEntry_t* CPUNextSCEntry_Cp);
+void VPARCOM_GetChunkIDMarker(const PARSER_Handle_t ParserHandle, STFDMA_SCEntry_t* CPUNextSCEntry_Cp);
+void VPARCOM_NotifyMarker(const PARSER_Handle_t ParserHandle, STEVT_EventID_t EventID, STVID_PTS_t PTSMarker);
+void VPARCOM_EnableDetectionOfStartCodeEmulationPreventionBytes(const PARSER_Handle_t ParserHandle);
+void VPARCOM_DisableDetectionOfStartCodeEmulationPreventionBytes(const PARSER_Handle_t ParserHandle);
+void VPARCOM_SwitchFromLittleEndianToBigEndianParsing(const PARSER_Handle_t ParserHandle);
+void VPARCOM_SwitchFromBigEndianToLittleEndianParsing(const PARSER_Handle_t ParserHandle);
+static __inline __attribute__((always_inline)) void UpdateStreamPosition(GetStreamBits_t* GSB_p)
+{
+    if (!(GSB_p->IsStreamToWrap))
+    {
+        if (GSB_p->Byte_Cp >= GSB_p->BufferEnd_Cp)
+        {
+            GSB_p->ReachEndOfStream = (1 == 1);
+        }
+    }
+    else
+    {
+        if (GSB_p->Byte_Cp > GSB_p->BufferLimit_Cp)
+        {
+            if (GSB_p->Start_BBAddress_Cp == GSB_p->BufferEnd_Cp)
+            {
+                GSB_p->ReachEndOfStream = (1 == 1);
+            }
+            GSB_p->Byte_Cp = GSB_p->Start_BBAddress_Cp;
+            GSB_p->BufferLimit_Cp = GSB_p->BufferEnd_Cp;
+            GSB_p->IsStreamToWrap = (!(1 == 1));
+            GSB_p->WasStreamWrapped = (1 == 1);
+        }
+    }
+}
+static __inline __attribute__((always_inline)) void MoveToNextByteFromStream(GetStreamBits_t* GSB_p)
+{
+    GSB_p->Byte_Cp ++;
+    UpdateStreamPosition(GSB_p);
+}
+static __inline __attribute__((always_inline)) void GSB_InitBitStream(const PARSER_Handle_t ParserHandle)
+{
+    PARSER_Properties_t * PARSER_Properties_p = (PARSER_Properties_t *) ParserHandle;
+    U8 * StartAddress_Cp;
+    if (PARSER_Properties_p->StartCode.StopAddress_p < PARSER_Properties_p->StartCode.StartAddress_p)
+    {
+        PARSER_Properties_p->GSB.BufferSize = (((U32)PARSER_Properties_p->StartCode.StopAddress_p - (U32)PARSER_Properties_p->BitBuffer.ES_Start_p)
+                               + ((U32)PARSER_Properties_p->BitBuffer.ES_Stop_p - (U32)PARSER_Properties_p->StartCode.StartAddress_p+1)
+                               - 1);
+    }
+    else
+    {
+        PARSER_Properties_p->GSB.BufferSize = ((U32)PARSER_Properties_p->StartCode.StopAddress_p - (U32)PARSER_Properties_p->StartCode.StartAddress_p - 1);
+    }
+    PARSER_Properties_p->GSB.Start_BBAddress_Cp = PARSER_Properties_p->BitBuffer.ES_Start_Cp;
+    PARSER_Properties_p->GSB.Stop_BBAddress_Cp = PARSER_Properties_p->GSB.Start_BBAddress_Cp + (PARSER_Properties_p->BitBuffer.ES_Stop_p - PARSER_Properties_p->BitBuffer.ES_Start_p);
+    StartAddress_Cp = ((void *)((U32)(PARSER_Properties_p->BitBuffer.ES_Start_Cp) + ((U32)(PARSER_Properties_p->StartCode.StartAddress_p) - (U32)(PARSER_Properties_p->BitBuffer.ES_Start_p))))
+                                                                                              ;
+    PARSER_Properties_p->GSB.BufferEnd_Cp = (U8 *) ((U32) StartAddress_Cp + PARSER_Properties_p->GSB.BufferSize);
+    PARSER_Properties_p->GSB.BufferLimit_Cp = PARSER_Properties_p->GSB.BufferEnd_Cp;
+    PARSER_Properties_p->GSB.IsStreamToWrap = (!(1 == 1));
+    PARSER_Properties_p->GSB.WasStreamWrapped = (!(1 == 1));
+    if (((U32) PARSER_Properties_p->GSB.BufferEnd_Cp) > ((U32) PARSER_Properties_p->GSB.Stop_BBAddress_Cp))
+    {
+        PARSER_Properties_p->GSB.IsStreamToWrap = (1 == 1);
+        PARSER_Properties_p->GSB.BufferEnd_Cp = (U8 *) ((U32) PARSER_Properties_p->GSB.BufferEnd_Cp - (U32) PARSER_Properties_p->GSB.Stop_BBAddress_Cp + (U32) PARSER_Properties_p->GSB.Start_BBAddress_Cp - 1);
+        PARSER_Properties_p->GSB.BufferLimit_Cp = PARSER_Properties_p->GSB.Stop_BBAddress_Cp;
+    }
+    PARSER_Properties_p->GSB.Byte_Cp = StartAddress_Cp;
+    PARSER_Properties_p->GSB.SC_StartByte_Cp = StartAddress_Cp;
+    PARSER_Properties_p->GSB.Bits = 0;
+    PARSER_Properties_p->GSB.NumberOfBits = 0;
+    PARSER_Properties_p->GSB.ReachEndOfStream = (!(1 == 1));
+    PARSER_Properties_p->GSB.EmulationPreventionByteOffset = 0;
+    MoveToNextByteFromStream(&PARSER_Properties_p->GSB);
+}
+static __inline __attribute__((always_inline)) U8 GetAByteFromStream(GetStreamBits_t *GSB_p)
+{
+    U8 Addr8;
+    Addr8 = *GSB_p->Byte_Cp;
+    MoveToNextByteFromStream(GSB_p);
+    if (GSB_p->IsEmulationPreventionSupported)
+    {
+        if ((Addr8 == GSB_p->EmulationPreventionPattern) &&
+            (GSB_p->EmulationPreventionByteOffset >= 2))
+        {
+            GSB_p->EmulationPreventionByteOffset = 0;
+            if (!GSB_p->ReachEndOfStream)
+            {
+                Addr8 = *(GSB_p->Byte_Cp);
+                MoveToNextByteFromStream(GSB_p);
+                if (Addr8 == 0)
+                {
+                    GSB_p->EmulationPreventionByteOffset ++;
+                }
+            }
+        }
+        else if (Addr8 == 0)
+        {
+            GSB_p->EmulationPreventionByteOffset ++;
+        }
+        else
+        {
+            GSB_p->EmulationPreventionByteOffset = 0;
+        }
+    }
+    return(Addr8);
+}
+static __inline __attribute__((always_inline)) BOOL GSB_GetOneBit(GetStreamBits_t *GSB_p)
+{
+    BOOL RequestedBit;
+    if (GSB_p->NumberOfBits > 0)
+    {
+        if ((GSB_p->Bits & 0x80000000) != 0)
+        {
+            RequestedBit = (1 == 1);
+        }
+        else
+        {
+            RequestedBit = (!(1 == 1));
+        }
+        GSB_p->Bits = GSB_p->Bits << 1;
+        GSB_p->NumberOfBits --;
+    }
+    else
+    {
+        GSB_p->Bits = (U32)GetAByteFromStream(GSB_p);
+        if ((GSB_p->Bits & 0x80) != 0)
+        {
+            RequestedBit = (1 == 1);
+        }
+        else
+        {
+            RequestedBit = (!(1 == 1));
+        }
+        GSB_p->Bits = (GSB_p->Bits << 25);
+        GSB_p->NumberOfBits = 7;
+    }
+    return(RequestedBit);
+}
+static __inline __attribute__((always_inline)) U32 GSB_GetBits(GetStreamBits_t *GSB_p, U32 NbRequestedBits)
+{
+    U32 RequestedBits;
+    S32 MissingBits;
+    RequestedBits = ((NbRequestedBits == 0) ? 0 : (GSB_p->Bits >> (32 - NbRequestedBits)));
+    MissingBits = NbRequestedBits - GSB_p->NumberOfBits;
+    if (MissingBits <= 0)
+    {
+        GSB_p->Bits = GSB_p->Bits << (NbRequestedBits);
+        GSB_p->NumberOfBits = (U8) (- MissingBits);
+    }
+    else
+    {
+        GSB_p->Bits = (U32)GetAByteFromStream(GSB_p);
+        MissingBits -= 8;
+        if (MissingBits > 0)
+        {
+            GSB_p->Bits = ((GSB_p->Bits << 8) | GetAByteFromStream(GSB_p));
+            MissingBits -= 8;
+            if (MissingBits > 0)
+            {
+                GSB_p->Bits = ((GSB_p->Bits << 8) | GetAByteFromStream(GSB_p));
+                MissingBits -= 8;
+                if (MissingBits > 0)
+                {
+                    GSB_p->Bits = ((GSB_p->Bits << 8) | GetAByteFromStream(GSB_p));
+                    MissingBits -= 8;
+                }
+            }
+        }
+        GSB_p->NumberOfBits = (U8) (- MissingBits);
+        RequestedBits |= (GSB_p->Bits >> (GSB_p->NumberOfBits));
+        MissingBits+=32;
+        if (MissingBits >= 32)
+        {
+            GSB_p->Bits = 0;
+        }
+        else
+        {
+            GSB_p->Bits = (GSB_p->Bits << ((U32) (MissingBits)));
+        }
+    }
+    return(RequestedBits);
+}
+static __inline __attribute__((always_inline)) S32 GSB_GetSignedBits(GetStreamBits_t *GSB_p, U32 NbRequestedBits)
+{
+    U32 Int;
+    S32 RequestedBits;
+    if (NbRequestedBits > 1)
+    {
+        if (GSB_p->NumberOfBits == 0)
+        {
+            GSB_p->Bits = (U32)GetAByteFromStream(GSB_p);
+            GSB_p->NumberOfBits = 8;
+        }
+        RequestedBits = (GSB_p->Bits >> (GSB_p->NumberOfBits - 1));
+        GSB_p->Bits = GSB_p->Bits << 1;
+        GSB_p->NumberOfBits --;
+        Int = GSB_GetBits(GSB_p,NbRequestedBits - 1);
+        if (RequestedBits == 1)
+        {
+            RequestedBits = -Int;
+        }
+        else
+        {
+            RequestedBits = Int;
+        }
+    }
+    else if (NbRequestedBits ==1)
+    {
+        if (GSB_p->NumberOfBits == 0)
+        {
+            GSB_p->Bits = (U32)GetAByteFromStream(GSB_p);
+            GSB_p->NumberOfBits = 8;
+        }
+        RequestedBits = (GSB_p->Bits >> (GSB_p->NumberOfBits - 1));
+        GSB_p->Bits = GSB_p->Bits << 1;
+        GSB_p->NumberOfBits --;
+    }
+    else
+    {
+        RequestedBits = 0;
+    }
+    return(RequestedBits);
+}
+static __inline __attribute__((always_inline)) U32 GSB_AlignAndGetBits(GetStreamBits_t *GSB_p, U32 NbRequestedBits)
+{
+    U32 RequestedBits;
+    S32 MissingBits;
+    GSB_p->Bits = (U32)GetAByteFromStream(GSB_p);
+    MissingBits = NbRequestedBits - 8;
+    if (MissingBits > 0)
+    {
+        MissingBits -= 8;
+        GSB_p->Bits = ((GSB_p->Bits << 8) | GetAByteFromStream(GSB_p));
+        if (MissingBits > 0)
+        {
+            MissingBits -= 8;
+            GSB_p->Bits = ((GSB_p->Bits << 8) | GetAByteFromStream(GSB_p));
+            if (MissingBits > 0)
+            {
+                MissingBits -= 8;
+                GSB_p->Bits = ((GSB_p->Bits << 8) | GetAByteFromStream(GSB_p));
+            }
+        }
+    }
+    GSB_p->NumberOfBits = (U8) (- MissingBits);
+    RequestedBits = (GSB_p->Bits >> (GSB_p->NumberOfBits));
+    MissingBits+=32;
+    if (MissingBits >= 32)
+    {
+        GSB_p->Bits = 0;
+    }
+    else
+    {
+        GSB_p->Bits = (GSB_p->Bits << ((U32) (MissingBits)));
+    }
+    return(RequestedBits);
+}
+static __inline __attribute__((always_inline)) U8 GSB_AlignAndGet8Bits(GetStreamBits_t* GSB_p)
+{
+    GSB_p->NumberOfBits = 0;
+    return(GetAByteFromStream(GSB_p));
+}
+static __inline __attribute__((always_inline)) U16 GSB_AlignAndGet16Bits(GetStreamBits_t* GSB_p)
+{
+    U16 RequestedBits;
+    GSB_p->NumberOfBits = 0;
+    RequestedBits = GetAByteFromStream(GSB_p);
+    RequestedBits = ((RequestedBits << 8) | GetAByteFromStream(GSB_p));
+    return(RequestedBits);
+}
+static __inline __attribute__((always_inline)) U32 GSB_AlignAndGet24Bits(GetStreamBits_t* GSB_p)
+{
+    U32 RequestedBits;
+    GSB_p->NumberOfBits = 0;
+    RequestedBits = GetAByteFromStream(GSB_p);
+    RequestedBits = ((RequestedBits << 8) | GetAByteFromStream(GSB_p));
+    RequestedBits = ((RequestedBits << 8) | GetAByteFromStream(GSB_p));
+    return(RequestedBits);
+}
+static __inline __attribute__((always_inline)) U32 GSB_AlignAndGet32Bits(GetStreamBits_t* GSB_p)
+{
+    U32 RequestedBits;
+    GSB_p->NumberOfBits = 0;
+    RequestedBits = GetAByteFromStream(GSB_p);
+    RequestedBits = ((RequestedBits << 8) | GetAByteFromStream(GSB_p));
+    RequestedBits = ((RequestedBits << 8) | GetAByteFromStream(GSB_p));
+    RequestedBits = ((RequestedBits << 8) | GetAByteFromStream(GSB_p));
+    return(RequestedBits);
+}
+static __inline __attribute__((always_inline)) U32 GSB_GetUnSignedExpGolomb(GetStreamBits_t* GSB_p)
+{
+    S8 LeadingZerosLoop;
+    U32 UnsExpGolomb;
+    LeadingZerosLoop = -1;
+    do
+    {
+        if (GSB_p->ReachEndOfStream)
+        {
+            break;
+        }
+        LeadingZerosLoop++;
+    } while (!GSB_GetOneBit(GSB_p));
+    if (!GSB_p->ReachEndOfStream)
+    {
+        if (LeadingZerosLoop == 0)
+        {
+            UnsExpGolomb = 0;
+        }
+        else
+        {
+            UnsExpGolomb = 1 << LeadingZerosLoop;
+            UnsExpGolomb --;
+            UnsExpGolomb += GSB_GetBits(GSB_p,LeadingZerosLoop);
+        }
+    }
+    else
+    {
+        return(0xFFFFFFFF);
+    }
+    return (UnsExpGolomb);
+}
+static __inline __attribute__((always_inline)) U32 GSB_GetSignedExpGolomb(GetStreamBits_t* GSB_p)
+{
+    U32 UnsExpGolomb;
+    S32 SiExpGolomb;
+    UnsExpGolomb = GSB_GetUnSignedExpGolomb(GSB_p);
+    SiExpGolomb = (UnsExpGolomb + 1) >> 1;
+    if ((UnsExpGolomb & 0x1) == 0)
+    {
+        SiExpGolomb = - SiExpGolomb;
+    }
+    return SiExpGolomb;
+}
+static __inline __attribute__((always_inline)) void GSB_SkipBits(GetStreamBits_t *GSB_p, U32 NbBitsToSkip)
+{
+    U8 Byte;
+    S32 MissingBits;
+    U32 BytesToSkipNow;
+    MissingBits = NbBitsToSkip - GSB_p->NumberOfBits;
+    if (MissingBits <= 0)
+    {
+        GSB_p->Bits = GSB_p->Bits << (NbBitsToSkip);
+        GSB_p->NumberOfBits = (U8) (- MissingBits);
+    }
+    else
+    {
+        if (MissingBits > 8)
+        {
+            BytesToSkipNow = ((U32) MissingBits) >> 3;
+            MissingBits &= 0x7;
+            do {
+                GSB_AlignAndGet8Bits(GSB_p);
+                BytesToSkipNow--;
+            }
+            while (BytesToSkipNow > 0);
+        }
+        if (MissingBits > 0)
+        {
+            Byte = GSB_AlignAndGet8Bits(GSB_p);
+            GSB_p->Bits = (Byte << 24);
+            GSB_p->Bits <<= ((U32) MissingBits);
+            GSB_p->NumberOfBits = ((U32) (8 - MissingBits));
+        }
+        else
+        {
+            GSB_p->NumberOfBits = 0;
+        }
+    }
+}
+static __inline __attribute__((always_inline)) void GSB_SavePosition(GetStreamBits_t* GSB_p, GetStreamBits_t* const CurrentPositionInSB_p)
+{
+    CurrentPositionInSB_p->Byte_Cp = GSB_p->Byte_Cp;
+    CurrentPositionInSB_p->BufferSize = GSB_p->BufferSize;
+    CurrentPositionInSB_p->BufferEnd_Cp = GSB_p->BufferEnd_Cp;
+    CurrentPositionInSB_p->Start_BBAddress_Cp = GSB_p->Start_BBAddress_Cp;
+    CurrentPositionInSB_p->Stop_BBAddress_Cp = GSB_p->Stop_BBAddress_Cp;
+    CurrentPositionInSB_p->BufferLimit_Cp = GSB_p->BufferLimit_Cp;
+    CurrentPositionInSB_p->IsStreamToWrap = GSB_p->IsStreamToWrap;
+    CurrentPositionInSB_p->Bits = GSB_p->Bits;
+    CurrentPositionInSB_p->NumberOfBits = GSB_p->NumberOfBits;
+    CurrentPositionInSB_p->ReachEndOfStream = GSB_p->ReachEndOfStream;
+    CurrentPositionInSB_p->IsEmulationPreventionSupported = GSB_p->IsEmulationPreventionSupported;
+    CurrentPositionInSB_p->EmulationPreventionPattern = GSB_p->EmulationPreventionPattern;
+    CurrentPositionInSB_p->EmulationPreventionByteOffset = GSB_p->EmulationPreventionByteOffset;
+}
+static __inline __attribute__((always_inline)) void GSB_RestorePosition(GetStreamBits_t* GSB_p, const GetStreamBits_t CurrentPositionInSB)
+{
+    GSB_p->Byte_Cp = CurrentPositionInSB.Byte_Cp;
+    GSB_p->BufferSize = CurrentPositionInSB.BufferSize;
+    GSB_p->BufferSize = CurrentPositionInSB.BufferSize;
+    GSB_p->BufferEnd_Cp = CurrentPositionInSB.BufferEnd_Cp;
+    GSB_p->Start_BBAddress_Cp = CurrentPositionInSB.Start_BBAddress_Cp;
+    GSB_p->Stop_BBAddress_Cp = CurrentPositionInSB.Stop_BBAddress_Cp;
+    GSB_p->BufferLimit_Cp = CurrentPositionInSB.BufferLimit_Cp;
+    GSB_p->IsStreamToWrap = CurrentPositionInSB.IsStreamToWrap;
+    GSB_p->Bits = CurrentPositionInSB.Bits;
+    GSB_p->NumberOfBits = CurrentPositionInSB.NumberOfBits;
+    GSB_p->ReachEndOfStream = CurrentPositionInSB.ReachEndOfStream;
+    GSB_p->IsEmulationPreventionSupported = CurrentPositionInSB.IsEmulationPreventionSupported;
+    GSB_p->EmulationPreventionPattern = CurrentPositionInSB.EmulationPreventionPattern;
+    GSB_p->EmulationPreventionByteOffset = CurrentPositionInSB.EmulationPreventionByteOffset;
+}
+static __inline __attribute__((always_inline)) BOOL GSB_IsMoreRbspData(GetStreamBits_t* GSB_p)
+{
+    GetStreamBits_t SavedGSB;
+    BOOL IsMoreRbspData = (!(1 == 1));
+    SavedGSB = *GSB_p;
+    if(!GSB_GetOneBit(GSB_p))
+    {
+        IsMoreRbspData = (1 == 1);
+    }
+    else
+    {
+        if (GSB_p->Bits != 0)
+        {
+            IsMoreRbspData = (1 == 1);
+        }
+        else
+        {
+            while ((!IsMoreRbspData) &&
+                    (!GSB_p->ReachEndOfStream))
+            {
+                if (GetAByteFromStream(GSB_p) != 0)
+                {
+                    IsMoreRbspData = (1 == 1);
+                }
+            }
+        }
+    }
+    *GSB_p = SavedGSB;
+    return(IsMoreRbspData);
+}
+enum
+{
+    PARSER_JOB_COMPLETED_EVT_ID,
+    PARSER_STOP_EVT_ID,
+    PARSER_USER_DATA_EVT_ID,
+    PARSER_PICTURE_SKIPPED_EVT_ID,
+    PARSER_FIND_DISCONTINUITY_EVT_ID,
+    PARSER_ES_INJECTION_FINISHED_EVT_ID,
+    PARSER_BITBUFFER_FULLY_PARSED_EVT_ID,
+    PARSER_UNSUPPORTED_STREAM_TYPE_EVT_ID,
+    PARSER_MARKER_DETECTION_EVT_ID,
+    H264PARSER_NB_REGISTERED_EVENTS_IDS
+};
+typedef enum
+{
+    PARSER_COMMAND_START,
+    PARSER_COMMAND_START_CODE_TO_PROCESS
+} ParserCommands_t;
+typedef enum {
+    SEI_BUFFERING_PERIOD = 0,
+    SEI_PIC_TIMING,
+    SEI_PAN_SCAN_RECT,
+    SEI_FILLER_PAYLOAD,
+    SEI_USER_DATA_REGISTERED_ITU_T_T35,
+    SEI_USER_DATA_UNREGISTERED,
+    SEI_RECOVERY_POINT,
+    SEI_DEC_REF_PIC_MARKING_REPETITION,
+    SEI_SPARE_PIC,
+    SEI_SCENE_INFO,
+    SEI_SUB_SEQ_INFO,
+    SEI_SUB_SEQ_LAYER_CHARACTERISTICS,
+    SEI_SUB_SEQ_CHARACTERISTICS,
+    SEI_FULL_FRAME_FREEZE,
+    SEI_FULL_FRAME_FREEZE_RELEASE,
+    SEI_FULL_FRAME_SNAPSHOT,
+    SEI_PROGRESSIVE_REFINEMENT_SEGMENT_START,
+    SEI_PROGRESSIVE_REFINEMENT_SEGMENT_END,
+    SEI_MOTION_CONSTRAINED_SLICE_GROUP_SET,
+    SEI_FILM_GRAIN_CHARACTERISTICS,
+    SEI_DEBLOCKING_FILTER_DISPLAY_PREFERENCE,
+    SEI_STEREO_VIDEO_INFO,
+    SEI_POST_FILTER_HINT,
+    SEI_TONE_MAPPING_INFO,
+    SEI_SCALABILITY_INFO,
+    SEI_SUB_PIC_SCALABLE_LAYER,
+    SEI_NON_REQUIRED_LAYER_REP,
+    SEI_PRIORITY_LAYER_INFO,
+    SEI_LAYERS_NOT_PRESENT,
+    SEI_LAYER_DEPENDENCY_CHANGE,
+    SEI_SCALABLE_NESTING,
+    SEI_BASE_LAYER_TEMPORAL_HRD,
+    SEI_QUALITY_LAYER_INTEGRITY_CHECK,
+    SEI_REDUNDANT_PIC_PROPERTY,
+    SEI_TL0_DEP_REP_INDEX,
+    SEI_TL_SWITCHING_POINT,
+    SEI_PARALLEL_DECODING_INFO,
+    SEI_MVC_SCALABLE_NESTING,
+    SEI_VIEW_SCALABILITY_INFO,
+    SEI_MULTIVIEW_SCENE_INFO,
+    SEI_MULTIVIEW_ACQUISITION_INFO,
+    SEI_NON_REQUIRED_VIEW_COMPONENT,
+    SEI_VIEW_DEPENDENCY_CHANGE,
+    SEI_OPERATION_POINTS_NOT_PRESENT,
+    SEI_BASE_VIEW_TEMPORAL_HRD,
+    SEI_FRAME_PACKING_ARRANGEMENT,
+    SEI_RESERVED_SEI_MESSAGE,
+    SEI_MAX_ELEMENTS
+} SEIType;
+typedef enum
+{
+    RECOVERY_NONE,
+    RECOVERY_PENDING,
+    RECOVERY_COMPUTED,
+    RECOVERY_REACHED
+} RecoveryPointState_t;
+typedef enum
+{
+    CONTENTINTERPRETATIONTYPE_VAL0,
+    CONTENTINTERPRETATIONTYPE_VAL1,
+    CONTENTINTERPRETATIONTYPE_VAL2
+} ContentInterpretationType_t;
+typedef enum
+{
+    FRAMEPACKINGARRANGEMENTTYPE_VAL0,
+    FRAMEPACKINGARRANGEMENTTYPE_VAL1,
+    FRAMEPACKINGARRANGEMENTTYPE_VAL2,
+    FRAMEPACKINGARRANGEMENTTYPE_VAL3,
+    FRAMEPACKINGARRANGEMENTTYPE_VAL4,
+    FRAMEPACKINGARRANGEMENTTYPE_VAL5
+} FramePackingArrangementType_t;
+typedef struct SEIArray_s {
+    GetStreamBits_t GSB[30];
+    U32 Iterator;
+} SEIArray_t;
+typedef struct UserDataArray_s {
+    GetStreamBits_t GSB[10];
+    U32 PayloadSize[10];
+    U32 PayloadType[10];
+    U32 Iterator;
+} UserDataArray_t;
+typedef struct PreviousPictureInDecodingOrder_s
+{
+    BOOL IsAvailable;
+    STVID_PictureStructure_t PictureStructure;
+    BOOL HasMMCO5;
+    BOOL IsFirstOfTwoFields;
+    U32 FrameNumOffset;
+    U32 frame_num;
+    BOOL IsIDR;
+    U32 IdrPicId;
+    BOOL IsReference;
+    BOOL IsRandomAccessPoint;
+    U32 Width;
+    U32 Height;
+    U8 MaxDecFrameBuffering;
+    U32 DecodingOrderFrameID;
+} PreviousPictureInDecodingOrder_t;
+typedef struct PreviousReferencePictureInDecodingOrder_s
+{
+    BOOL HasMMCO5;
+    STVID_PictureStructure_t PictureStructure;
+    S32 TopFieldOrderCnt;
+    S32 PicOrderCntMsb;
+    U32 pic_order_cnt_lsb;
+    U32 frame_num;
+} PreviousReferencePictureInDecodingOrder_t;
+typedef struct PictureLocalData_s
+{
+    U32 pic_order_cnt_lsb;
+    S32 PicOrderCntMsb;
+    S32 delta_pic_order_cnt_bottom;
+    S32 delta_pic_order_cnt[2];
+    S32 FrameNumOffset;
+    U32 frame_num;
+    U32 PrevRefFrameNum;
+    BOOL HasMMCO5;
+    U8 ActivePPS;
+    BOOL IsNonExisting;
+    U32 Width;
+    U32 Height;
+    U8 MaxDecFrameBuffering;
+    U32 IdrPicId;
+    BOOL IsRandomAccessPoint;
+    BOOL IncrementEPOID;
+    BOOL IsValidPicture;
+    BOOL HasSEIMessage;
+    BOOL HasUserData;
+    BOOL HasPicStruct;
+    U8 PicStruct;
+    BOOL HasCtType;
+    U8 CtType;
+    GetStreamBits_t SEIPositionInNAL;
+    U8 PrimaryPicType;
+} PictureLocalData_t;
+typedef struct SPSLocalData_s
+{
+    BOOL IsAvailable;
+    U32 MaxPicOrderCntLsb;
+    U32 MaxFrameNum;
+    U8 num_ref_frames_in_pic_cnt_cycle;
+    S32 offset_for_ref_frame[255];
+    S32 offset_for_non_ref_pic;
+    S32 offset_for_top_to_bottom_field;
+    BOOL gaps_in_frame_num_allowed_flag;
+    BOOL pic_struct_present_flag;
+    U8 MaxDpbSize;
+    U32 MaxBR;
+    U32 MaxCPB;
+    U32 MaxWidth;
+    U32 MaxHeight;
+    U32 MaxPixel;
+    U32 MaxFrameRate;
+    BOOL NalHrdBpPresentFlag;
+    BOOL VclHrdBpPresentFlag;
+    BOOL CpbDpbDelaysPresentFlag;
+    U8 InitialCpbRemovalDelayLength;
+    U8 CpbRemovalDelayLength;
+    U8 DpbOutputDelayLength;
+    U8 TimeOffsetLength;
+    BOOL IsInitialCpbRemovalDelayValid;
+    U32 InitialCpbRemovalDelay;
+} SPSLocalData_t;
+typedef struct PPSLocalData_s
+{
+    BOOL IsAvailable;
+    U8 seq_parameter_set_id;
+} PPSLocalData_t;
+typedef struct RecoveryPoint_s
+{
+    RecoveryPointState_t RecoveryPointState;
+    U32 RecoveryFrameCnt;
+    BOOL ExactMatchFlag;
+    BOOL BrokenLinkFlag;
+    U32 RecoveryFrameNum;
+    BOOL RecoveryPointAlreadyInProgress;
+    BOOL RecoveryPointHasBeenHit;
+    BOOL CheckPOC;
+    BOOL CurrentPicturePOIDToBeSaved;
+    VIDCOM_PictureID_t RecoveryPointPresentationOrderPictureID;
+    BOOL RecoveryPointPresentationOrderPictureIDComputed;
+    U32 RecoveryPointDecodingOrderFrameID;
+    U32 NextRecoveryFrameCnt;
+    BOOL NextExactMatchFlag;
+    BOOL NextBrokenLinkFlag;
+    BOOL NextRecoveryParsed;
+} RecoveryPoint_t;
+typedef struct MVCPrefixData_s
+{
+    BOOL MvcPrefixNaluPresentFlag;
+    BOOL AccessUnitIdentifier ;
+    BOOL non_idr_flag;
+    U8 priority_id;
+    U16 view_id;
+    U8 temporal_id;
+    BOOL anchor_pic_flag;
+    BOOL inter_view_flag;
+} MVCPrefixData_t;
+typedef struct ParserGlobalVariable_s
+{
+    U32 MaxLongTermFrameIdx;
+    U32 CurrentPictureDecodingOrderFrameID;
+    U8 CurrentPictureFrameIndexInDPBRef;
+    U32 ExtendedPresentationOrderPictureID;
+    U8 StreamID;
+    STVID_BroadcastProfile_t Broadcast_profile;
+    RecoveryPoint_t RecoveryPoint;
+    U8 ProfileIdc;
+    STVID_ErrorRecoveryMode_t ErrorRecoveryMode;
+    STVID_DecodedPictures_t DecodedPictures;
+    MVCPrefixData_t MVCPrefixData;
+} ParserGlobalVariable_t;
+typedef struct PreMarkingContext_s
+{
+    U32 frame_num;
+    BOOL IsIDR;
+    STVID_PictureStructure_t PictureStructure;
+    BOOL IsReference;
+    S32 delta_pic_order_cnt[2];
+} PreMarkingContext_t;
+typedef struct H264_FramePackingArrangementSpecificData_s
+{
+    U32 FPARepetitionPeriod;
+    S32 FPAPersistence;
+    BOOL CanResetFPASetting;
+} H264_FramePackingArrangementSpecificData_t;
+typedef struct H264_PanScanRectSpecificData_s
+{
+    U32 PanScanRectRepetitionPeriod;
+    S32 PanScanRectPersistence;
+    BOOL CanResetPanScanRectSetting;
+} H264_PanScanRectSpecificData_t;
+typedef struct DPBFrameReference_s
+{
+    BOOL TopFieldIsReference;
+    BOOL BottomFieldIsReference;
+    U32 DecodingOrderFrameID;
+    U32 frame_num;
+    S32 FrameNumWrap;
+    S32 TopFieldPicNum;
+    S32 BottomFieldPicNum;
+    U32 LongTermFrameIdx;
+    U32 TopFieldLongTermPicNum;
+    U32 BottomFieldLongTermPicNum;
+    BOOL TopFieldIsLongTerm;
+    BOOL BottomFieldIsLongTerm;
+    S32 TopFieldOrderCnt;
+    S32 BottomFieldOrderCnt;
+    S32 PreDecodingTopFieldOrderCnt;
+    S32 PreDecodingBottomFieldOrderCnt;
+    BOOL IsNonExisting;
+    BOOL IsBrokenLink;
+    U16 view_id;
+    BOOL inter_view_flag;
+    U32 AccessUnitID;
+    U32 TopFieldAccessUnitID;
+    U32 BottomFieldAccessUnitID;
+} DPBFrameReference_t;
+typedef struct H264ParserPrivateData_s
+{
+    PictureLocalData_t PictureLocalData;
+    VIDCOM_PictureGenericData_t PictureGenericData;
+    H264_PictureSpecificData_t PictureSpecificData;
+    PreviousPictureInDecodingOrder_t PreviousPictureInDecodingOrder[1 + 1];
+    PreviousReferencePictureInDecodingOrder_t PreviousReferencePictureInDecodingOrder[1 + 1];
+    SPSLocalData_t SPSLocalData[32 * 2];
+    SPSLocalData_t *ActiveSPSLocalData_p;
+    VIDCOM_GlobalDecodingContextGenericData_t GlobalDecodingContextGenericData[32 * 2];
+    VIDCOM_GlobalDecodingContextGenericData_t *ActiveGlobalDecodingContextGenericData_p;
+    H264_GlobalDecodingContextSpecificData_t GlobalDecodingContextSpecificData[32 * 2];
+    H264_GlobalDecodingContextSpecificData_t *ActiveGlobalDecodingContextSpecificData_p;
+    PPSLocalData_t PPSLocalData[256];
+    PPSLocalData_t *ActivePPSLocalData_p;
+    H264_PictureDecodingContextSpecificData_t PictureDecodingContextSpecificData[256];
+    H264_PictureDecodingContextSpecificData_t *ActivePictureDecodingContextSpecificData_p;
+    ParserGlobalVariable_t ParserGlobalVariable;
+    H264_FramePackingArrangementSpecificData_t FramePackingArrangementSpecificData;
+    H264_PanScanRectSpecificData_t PanScanRectSpecificData;
+    GetStreamBits_t SEIMessagePosition;
+    SEIArray_t SEIPositionArray;
+    GetStreamBits_t UserDataPosition;
+    UserDataArray_t UserDataPositionArray;
+    DPBFrameReference_t DPBFrameReference[(16 + 1) ];
+    DPBFrameReference_t InterViewOnlyReferenceArray[1];
+    PreMarkingContext_t PreMarkingContext;
+    STEVT_EventID_t RegisteredEventsID[H264PARSER_NB_REGISTERED_EVENTS_IDS];
+    STVID_Statistics_t Statistics;
+    PARSER_GetPictureParams_t GetPictureParams;
+    BOOL DiscontinuityDetected;
+    U32 OutputCounter;
+    U8 * LastSCAdd_p;
+    STVID_DecodedPictures_t SkipMode;
+    U8 * LastSCAddBeforeSEI_p;
+    DPBFrameReference_t ShortTermFramesBelowPOC[16];
+    DPBFrameReference_t ShortTermFramesAbovePOC[16];
+    DPBFrameReference_t RefFrameList0ShortTerm[16];
+    DPBFrameReference_t RefFrameList1ShortTerm[16];
+    DPBFrameReference_t RefFrameList0LongTerm[16];
+    BOOL PreviousSCWasNotValid;
+    PARSER_ParserSkipPictureParams_t ParserSkipPictureParams;
+    STVID_UnsupportedStreamType_t UnsupportedStreamType;
+    BOOL StreamNotSupported;
+    BOOL HasSentUnsupportedEventForCurrentSequence;
+    BOOL DecodeOnce;
+    BOOL BadFrameNumBetweenNonRefRecoveryOnGoing;
+    U8 * SPSorPPSFoundAddress_p;
+    U8 * MvcCodedSliceExtensionFoundAddress_p;
+    U32 MvcCodedSliceExtensionCount;
+} H264ParserPrivateData_t;
+void h264par_AssignShortTermInFrameBuffer(U8 FrameIndex, const PARSER_Handle_t ParserHandle);
+void h264par_DecodingProcessForPictureNumbers(const PARSER_Handle_t ParserHandle);
+S32 h264par_ComputePicNumX(U32 DifferenceOfPicNumsMinus1, const PARSER_Handle_t ParserHandle);
+void h264par_DoMMCO1(U32 DifferenceOfPicNumsMinus1, const PARSER_Handle_t ParserHandle);
+void h264par_DoMMCO2(U32 LongTermPicNum, const PARSER_Handle_t ParserHandle);
+void h264par_DoMMCO3(U32 DifferenceOfPicNumsMinus1, U32 LongTermFrameIdx, const PARSER_Handle_t ParserHandle);
+void h264par_DoMMCO4(U32 MaxLongTermFrameIdxPlus1, const PARSER_Handle_t ParserHandle);
+void h264par_DoMMCO5(const PARSER_Handle_t ParserHandle);
+void h264par_DoMMCO6(U32 LongTermFrameIdx, const PARSER_Handle_t ParserHandle);
+S8 h264par_FindFreeFrameIndex(const PARSER_Handle_t ParserHandle);
+S8 h264par_FindComplementaryField(const PARSER_Handle_t ParserHandle);
+void h264par_MarkAllPicturesAsUnusedForReference(const PARSER_Handle_t ParserHandle);
+S8 h264par_MarkCurrentAsShortTermInFreeFrameBuffer(const PARSER_Handle_t ParserHandle);
+void h264par_MarkCurrentPictureAsLongTerm(U32 FrameIndex, U32 LongTermFrameIdx, const PARSER_Handle_t ParserHandle);
+void h264par_MarkCurrentPictureAsShortTerm(const PARSER_Handle_t ParserHandle);
+void h264par_MarkFrameAsUnusedForReference(U8 FrameIndex, const PARSER_Handle_t ParserHandle);
+void h264par_MarkPictureBySliding(const PARSER_Handle_t ParserHandle);
+void h264par_MarkPictureWithLongTermFrameIdxAsUnusedForReference(U32 LongTermFrameIdx, S8 FrameToMark, const PARSER_Handle_t ParserHandle);
+void h264par_MarkPicNumXAsLongTerm(U32 FrameIndex, S32 PicNumX, U32 LongTermFrameIdx, const PARSER_Handle_t ParserHandle);
+void h264par_PerformPreMarking(const PARSER_Handle_t ParserHandle);
+void h264par_PerformSlidingWindowOnDPBRef (const PARSER_Handle_t ParserHandle);
+void h264par_PostProcessFrameNumOnMMCO5(const PARSER_Handle_t ParserHandle);
+void h264par_PostProcessPicOrderCntOnMMCO5 (const PARSER_Handle_t ParserHandle);
+void h264par_RestoreContextAfterPreMarking(const PARSER_Handle_t ParserHandle);
+void h264par_SaveContextBeforePreMarking(const PARSER_Handle_t ParserHandle);
+void h264par_ClipDPBAfterMMCO(const PARSER_Handle_t ParserHandle);
+void h264par_CompactDPB_FixForGNBvd67709(const PARSER_Handle_t ParserHandle);
+void h264par_InitializePPS (U8 PicParameterSetId, const PARSER_Handle_t ParserHandle);
+ST_ErrorCode_t h264par_ParsePPS (const PARSER_Handle_t ParserHandle);
+U32 h264par_ComputeDecodingOrderFrameID (const PARSER_Handle_t ParserHandle);
+void h264par_InitializeCurrentPicture(U8 NalRefIdc, U8 NalUnitType, U8 SeqParameterSetId, U8 PicParameterSetId, const PARSER_Handle_t ParserHandle);
+BOOL h264par_IsComplementaryFieldOfPreviousPicture(const PARSER_Handle_t ParserHandle);
+void h264par_ParseDecodedReferencePictureMarking(const PARSER_Handle_t ParserHandle);
+void h264par_ParsePredictionWeightTable(U8 SliceType, U8 NumRefIdxActiveL0ActiveMinus1, U8 NumRefIdxActiveL1ActiveMinus1, const PARSER_Handle_t ParserHandle);
+void h264par_ParseReferencePictureListReodering(U8 SliceType, const PARSER_Handle_t ParserHandle);
+void h264par_ParseRestOfSliceHeader(U8 SliceType, const PARSER_Handle_t ParserHandle);
+void h264par_GetSliceTypeFromSliceHeader (const PARSER_Handle_t ParserHandle, U8 *SliceType);
+void h264par_ParseSliceHeader(U8 NalRefIdc, U8 NalUnitType, StartCode_t * StartCode_p, const PARSER_Handle_t ParserHandle, const U8 SliceType);
+void h264par_UpdatePreviousPictureInfo(const PARSER_Handle_t ParserHandle);
+void h264par_ComputeMaxFromLevel(U8 LevelIdc, U8 PicWidthInMbsMinus1, U8 PicHeightInMapUnitsMinus1, U8 FrameMbsOnlyFlag,U8 SeqParameterSetId, U8 ConstraintSet4Flag, const PARSER_Handle_t ParserHandle);
+void h264par_InitializeGlobalDecodingContext(U8 SeqParameterSedId, const PARSER_Handle_t ParserHandle);
+ST_ErrorCode_t h264par_ParseSPS(const PARSER_Handle_t ParserHandle);
+ST_ErrorCode_t h264par_ParseMvcSubsetSPS(const PARSER_Handle_t ParserHandle);
+void h264par_ParseSPSExtension(const PARSER_Handle_t ParserHandle);
+void h264par_GetSampleAspectRatio(U8 AspectRatioIdc, U16 * SarWidth, U16 * SarHeight);
+void h264par_ParseVUI (U8 SeqParameterSetId, const PARSER_Handle_t ParserHandle);
+void h264par_SetFlatScalingMatrix(H264_SpecificScalingMatrix_t *ScalingMatrix);
+void h264par_SetScalingListDefault(H264_SpecificScalingMatrix_t *ScalingMatrix, U32 ScalingListNumber);
+void h264par_SetScalingListFallBackA(H264_SpecificScalingMatrix_t *ScalingMatrix,U32 ScalingListNumber);
+void h264par_SetScalingListFallBackB(H264_SpecificScalingMatrix_t *PPSScalingMatrix,const H264_SpecificScalingMatrix_t *SPSScalingMatrix,U32 ScalingListNumber);
+void h264par_GetScalingList(const PARSER_Handle_t ParserHandle, H264_SpecificScalingMatrix_t *ScalingMatrix,U32 ScalingListNumber);
+void h264par_CheckTopAndBottomFieldOrderCnt(const PARSER_Handle_t ParserHandle);
+void h264par_ComputePicOrderCnt (const PARSER_Handle_t ParserHandle);
+void h264par_ComputeTopAndBottomFieldOrderCntForPOC0 (const PARSER_Handle_t ParserHandle);
+void h264par_ComputeTopAndBottomFieldOrderCntForPOC1 (const PARSER_Handle_t ParserHandle);
+void h264par_ComputeTopAndBottomFieldOrderCntForPOC2 (const PARSER_Handle_t ParserHandle);
+void h264par_AlternateFieldsInList(U32 * UsedSizeInReferenceListX,
+                                   U32 * ReferenceListX,
+                                   BOOL * IsReferenceTopField,
+                                   U8 NumberOfFrames,
+                                   DPBFrameReference_t * RefFrameListX,
+                                   BOOL (* h264par_IsCurrentParity) (DPBFrameReference_t RefFrame),
+                                   BOOL (* h264par_IsAlternateParity) (DPBFrameReference_t RefFrame),
+                                   const PARSER_Handle_t ParserHandle);
+void h264par_BuildReferenceFieldsList(U32 * UsedSizeInReferenceListX,
+                                      U32 * ReferenceListX,
+                                      BOOL * IsReferenceTopField,
+                                      U8 NumberOfShortTermFrames,
+                                      U8 NumberOfLongTermFrames,
+                                      DPBFrameReference_t * RefFrameListXShortTerm,
+                                      DPBFrameReference_t * RefFrameListXLongTerm,
+                                      const PARSER_Handle_t ParserHandle);
+void h264par_CheckIfB0AndB1ListAreEqual(const PARSER_Handle_t ParserHandle);
+void h264par_InitFullList(const PARSER_Handle_t ParserHandle);
+void h264par_InitRefPicListForBSlicesInField(const PARSER_Handle_t ParserHandle);
+void h264par_InitRefPicListForBSlicesInFrame(const PARSER_Handle_t ParserHandle);
+void h264par_InitRefPicListForPSlicesInField(const PARSER_Handle_t ParserHandle);
+void h264par_InitRefPicListForPSlicesInFrame(const PARSER_Handle_t ParserHandle);
+BOOL h264par_IsBottomFieldLongRef(DPBFrameReference_t RefFrameLongTerm);
+BOOL h264par_IsBottomFieldShortRef(DPBFrameReference_t RefFrameShortTerm);
+BOOL h264par_IsTopFieldLongRef(DPBFrameReference_t RefFrameLongTerm);
+BOOL h264par_IsTopFieldShortRef(DPBFrameReference_t RefFrameShortTerm);
+BOOL h264par_IsRefViewID(const PARSER_Handle_t ParserHandle, U16 input_view_id);
+S32 h264par_PicOrderCnt(S32 Elem1, S32 Elem2);
+S32 h264par_PicOrderCntDPB(const DPBFrameReference_t * DPBFrameReference);
+void h264par_ReferencePictureListsInitialisation(const PARSER_Handle_t ParserHandle);
+S32 h264par_SortAscendingLongTermFrameIdxFunction(const void *Elem1, const void *Elem2);
+S32 h264par_SortAscendingPicOrderCntFunction(const void *Elem1, const void *Elem2);
+S32 h264par_SortAscendingTopFieldLongTermPicNumFunction(const void *Elem1, const void *Elem2);
+S32 h264par_SortDescendingFrameNumWrapFunction(const void *Elem1, const void *Elem2);
+S32 h264par_SortDescendingPicNumFunction(const void *Elem1, const void *Elem2);
+S32 h264par_SortDescendingPicOrderCntFunction(const void *Elem1, const void *Elem2);
+void h264par_ParseBufferingPeriod(U32 PayLoadSize, const PARSER_Handle_t ParserHandle);
+void h264par_ParseDataUnregistered(U32 PayLoadSize, const PARSER_Handle_t ParserHandle);
+void h264par_ParseDecRefPicMarkingRepetitionPeriod(U32 PayLoadSize, const PARSER_Handle_t ParserHandle);
+void h264par_ParseFillerPayLoad(U32 PayLoadSize, const PARSER_Handle_t ParserHandle);
+void h264par_ParsePicTiming(U32 PayLoadSize, const PARSER_Handle_t ParserHandle);
+void h264par_ParsePanScanRect(U32 PayLoadSize, const PARSER_Handle_t ParserHandle);
+void h264par_ParseRecoveryPoint(U32 PayLoadSize, const PARSER_Handle_t ParserHandle);
+void h264par_ParseUserDataRegisteredITUTT35(U32 PayLoadSize, const PARSER_Handle_t ParserHandle);
+void h264par_ParseSparePic(U32 PayLoadSize, const PARSER_Handle_t ParserHandle);
+void h264par_ParseSceneInfo(U32 PayLoadSize, const PARSER_Handle_t ParserHandle);
+void h264par_ParseSubSeqInfo(U32 PayLoadSize, const PARSER_Handle_t ParserHandle);
+void h264par_ParseSubSeqLayerCharacteristics(U32 PayLoadSize, const PARSER_Handle_t ParserHandle);
+void h264par_ParseSubSeqCharacteristics(U32 PayLoadSize, const PARSER_Handle_t ParserHandle);
+void h264par_ParseFullFrameFreeze(U32 PayLoadSize, const PARSER_Handle_t ParserHandle);
+void h264par_ParseFullFrameFreezeRelease(U32 PayLoadSize, const PARSER_Handle_t ParserHandle);
+void h264par_ParseFullFrameSnapshot(U32 PayLoadSize, const PARSER_Handle_t ParserHandle);
+void h264par_ParseProgressiveRefinementSegmentStart(U32 PayLoadSize, const PARSER_Handle_t ParserHandle);
+void h264par_ParseProgressiveRefinementSegmentEnd(U32 PayLoadSize, const PARSER_Handle_t ParserHandle);
+void h264par_ParseMotionConstrainedSliceGroupSet(U32 PayLoadSize, const PARSER_Handle_t ParserHandle);
+void h264par_ParseReservedSeiMessage(U32 PayLoadSize, const PARSER_Handle_t ParserHandle);
+void h264par_SEIPayLoad(U32 PayLoadType, U32 PayLoadSize, const PARSER_Handle_t ParserHandle);
+void h264par_ParseFilmGrainCharacteristics(const PARSER_Handle_t ParserHandle);
+void h264par_SetDefaultSEI(const PARSER_Handle_t ParserHandle);
+void h264par_ResetPicturePanAndScanIn16thPixel(const PARSER_Handle_t ParserHandle);
+void h264par_ResetPictureFPA3DVideoProperty(const PARSER_Handle_t ParserHandle);
+void h264par_IncrementInterpolatedTimeCode(const PARSER_Handle_t ParserHandle);
+void h264par_ParseAUD (const PARSER_Handle_t ParserHandle);
+void h264par_PrepareToParseSEI(const PARSER_Handle_t ParserHandle);
+void h264par_MoveToNextSEIMessage(U32 PayLoadSize, const PARSER_Handle_t ParserHandle);
+void h264par_PushSEIListItem(const PARSER_Handle_t ParserHandle);
+GetStreamBits_t* h264par_GetSEIListItem(const PARSER_Handle_t ParserHandle);
+void h264par_PushUserDataItem(U32 PayLoadSize, U32 PayLoadType, const PARSER_Handle_t ParserHandle);
+GetStreamBits_t* h264par_GetUserDataItem(U32 * PayLoadSize_p, U32 * PayLoadType_p, const PARSER_Handle_t ParserHandle);
+void h264par_ParseSEI (const PARSER_Handle_t ParserHandle);
+void h264par_CheckEventToSend(const PARSER_Handle_t ParserHandle);
+void h264par_DMATransferDoneFct(U32 ParserHandle,void * ES_Write_p, void * SCListWrite_p, void * SCListLoop_p, BOOL IsInjectionFinished);
+void h264par_FillParsingJobResult(const PARSER_Handle_t ParserHandle);
+void h264par_FillSkipPictureParams(const PARSER_Handle_t ParserHandle);
+void h264par_GetStartCodeCommand(const PARSER_Handle_t ParserHandle);
+ST_ErrorCode_t h264par_InitInjectionBuffers(const PARSER_Handle_t ParserHandle, const PARSER_InitParams_t * const InitParams_p, const U32 SC_ListSize, const U32 PESBufferSize);
+void h264par_InitParserContext(const PARSER_Handle_t ParserHandle);
+void h264par_InitSCBuffer(const PARSER_Handle_t ParserHandle);
+void h264par_IsNALInBitBuffer(const PARSER_Handle_t ParserHandle);
+void h264par_GetNextStartCodeToProcess(const PARSER_Handle_t ParserHandle);
+void h264par_IsThereStartCodeToProcess(const PARSER_Handle_t ParserHandle);
+void h264par_ParserTaskFunc(const PARSER_Handle_t ParserHandle);
+ST_ErrorCode_t h264par_ProcessStartCode(const PARSER_Handle_t ParserHandle);
+ST_ErrorCode_t h264par_StartParserTask(const PARSER_Handle_t ParserHandle);
+ST_ErrorCode_t h264par_StopParserTask(const PARSER_Handle_t ParserHandle);
+ST_ErrorCode_t h264par_Setup(const PARSER_Handle_t ParserHandle, const STVID_SetupParams_t * const SetupParams_p);
+ST_ErrorCode_t h264par_FlushInjection(const PARSER_Handle_t ParserHandle);
+ST_ErrorCode_t h264par_DataInjectionCompleted(const PARSER_Handle_t ParserHandle);
+U32 h264par_GetBitBufferOutputCounter(const PARSER_Handle_t ParserHandle);
+void h264par_SetBitBuffer(const PARSER_Handle_t ParserHandle, void * const BufferAddressStart_p, const U32 BufferSize, const BitBufferType_t BufferType, const BOOL Stop);
+const U32 ZZ_SCAN[16] =
+{ 0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15
+};
+const U32 ZZ_SCAN8[64] =
+{ 0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5,
+   12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28,
+   35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51,
+   58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63
+};
+static void h264par_InitializeDefaultHRDParameters(U8 SeqParameterSetId, const PARSER_Handle_t ParserHandle);
+void h264par_SetFlatScalingMatrix(H264_SpecificScalingMatrix_t *ScalingMatrix)
+{
+    U32 ScalingListCounter;
+    U32 CoefCounter;
+    for(ScalingListCounter = 0 ; ScalingListCounter < 8 ; ScalingListCounter++)
+    {
+        if(ScalingListCounter < 6)
+        {
+            for(CoefCounter = 0 ; CoefCounter < 16 ; CoefCounter++)
+            {
+                ScalingMatrix->FirstSixScalingList[ScalingListCounter][CoefCounter] = 16;
+            }
+        }
+        else
+        {
+            for(CoefCounter = 0 ; CoefCounter < 64 ; CoefCounter++)
+            {
+                ScalingMatrix->NextTwoScalingList[ScalingListCounter-6][CoefCounter] = 16;
+            }
+        }
+    }
+}
+void h264par_SetScalingListDefault(H264_SpecificScalingMatrix_t *ScalingMatrix, U32 ScalingListNumber)
+{
+    static U32 DefaultScalingList4x4Intra[16] = { 6, 13, 13, 20,
+                                                 20, 20, 28, 28,
+                                                 28, 28, 32, 32,
+                                                 32, 37, 37, 42};
+    static U32 DefaultScalingList4x4Inter[16] = {10, 14, 14, 20,
+                                                 20, 20, 24, 24,
+                                                 24, 24, 27, 27,
+                                                 27, 30, 30, 34};
+    static U32 DefaultScalingList8x8Intra[64] = { 6, 10, 10, 13, 11, 13, 16, 16,
+                                                 16, 16, 18, 18, 18, 18, 18, 23,
+                                                 23, 23, 23, 23, 23, 25, 25, 25,
+                                                 25, 25, 25, 25, 27, 27, 27, 27,
+                                                 27, 27, 27, 27, 29, 29 ,29, 29,
+                                                 29, 29, 29, 31, 31, 31, 31, 31,
+                                                 31, 33, 33, 33, 33, 33, 36, 36,
+                                                 36, 36, 38, 38, 38, 40, 40, 42};
+    static U32 DefaultScalingList8x8Inter[64] = { 9, 13, 13, 15, 13, 15 ,17 ,17,
+                                                 17, 17, 19, 19, 19, 19, 19, 21,
+                                                 21, 21, 21, 21, 21, 22, 22, 22,
+                                                 22, 22, 22, 22, 24, 24, 24, 24,
+                                                 24, 24, 24, 24, 25, 25, 25, 25,
+                                                 25, 25, 25, 27, 27, 27, 27, 27,
+                                                 27, 28, 28, 28, 28, 28, 30, 30,
+                                                 30, 30, 32, 32, 32, 33, 33, 35};
+    U32 j;
+    U32 scanj;
+    switch(ScalingListNumber)
+    {
+        case 0 :
+        case 1 :
+        case 2 :
+            for(j=0;j<16;j++)
+            {
+                scanj = ZZ_SCAN[j];
+                ScalingMatrix->FirstSixScalingList[ScalingListNumber][scanj] = DefaultScalingList4x4Intra[j];
+            }
+            break;
+        case 3 :
+        case 4 :
+        case 5 :
+            for(j=0;j<16;j++)
+            {
+                scanj = ZZ_SCAN[j];
+                ScalingMatrix->FirstSixScalingList[ScalingListNumber][scanj] = DefaultScalingList4x4Inter[j];
+            }
+            break;
+        case 6 :
+            for(j=0;j<64;j++)
+            {
+                scanj = ZZ_SCAN8[j];
+                ScalingMatrix->NextTwoScalingList[ScalingListNumber-6][scanj] = DefaultScalingList8x8Intra[j];
+            }
+            break;
+        case 7 :
+            for(j=0;j<64;j++)
+            {
+                scanj = ZZ_SCAN8[j];
+                ScalingMatrix->NextTwoScalingList[ScalingListNumber-6][scanj] = DefaultScalingList8x8Inter[j];
+            }
+            break;
+    }
+}
+void h264par_SetScalingListFallBackA(H264_SpecificScalingMatrix_t *ScalingMatrix,U32 ScalingListNumber)
+{
+    switch(ScalingListNumber)
+    {
+        case 0 :
+        case 3 :
+        case 6 :
+        case 7 :
+            h264par_SetScalingListDefault(ScalingMatrix, ScalingListNumber);
+            break;
+        case 1 :
+        case 2 :
+        case 4 :
+        case 5 :
+            memcpy(&(ScalingMatrix->FirstSixScalingList[ScalingListNumber]), ScalingMatrix->FirstSixScalingList[ScalingListNumber-1], sizeof(ScalingMatrix->FirstSixScalingList[ScalingListNumber]));
+            break;
+    }
+}
+void h264par_SetScalingListFallBackB(H264_SpecificScalingMatrix_t *PPSScalingMatrix, const H264_SpecificScalingMatrix_t *SPSScalingMatrix,U32 ScalingListNumber)
+{
+    switch(ScalingListNumber)
+    {
+        case 0 :
+        case 3 :
+            memcpy(&(PPSScalingMatrix->FirstSixScalingList[ScalingListNumber]), SPSScalingMatrix->FirstSixScalingList[ScalingListNumber], sizeof(PPSScalingMatrix->FirstSixScalingList[ScalingListNumber]));
+            break;
+        case 6 :
+        case 7 :
+            memcpy(&(PPSScalingMatrix->NextTwoScalingList[ScalingListNumber-6]), SPSScalingMatrix->NextTwoScalingList[ScalingListNumber-6], sizeof(PPSScalingMatrix->NextTwoScalingList[ScalingListNumber-6]));
+            break;
+        case 1 :
+        case 2 :
+        case 4 :
+        case 5 :
+            memcpy(&(PPSScalingMatrix->FirstSixScalingList[ScalingListNumber]), PPSScalingMatrix->FirstSixScalingList[ScalingListNumber-1], sizeof(PPSScalingMatrix->FirstSixScalingList[ScalingListNumber]));
+            break;
+    }
+}
+void h264par_GetScalingList(const PARSER_Handle_t ParserHandle, H264_SpecificScalingMatrix_t *ScalingMatrix,U32 ScalingListNumber)
+{
+    U32 lastScale;
+    U32 nextScale;
+    U32 sizeOfScalingList;
+    S32 DeltaScale;
+    BOOL useDefaultScalingMatrixFlag;
+    U32 CoefCounter;
+    U32 *ScalingList;
+    U32 scanj;
+    PARSER_Properties_t * PARSER_Properties_p = (PARSER_Properties_t *) ParserHandle;
+    H264ParserPrivateData_t * PARSER_Data_p;
+    PARSER_Data_p = ((H264ParserPrivateData_t *)((PARSER_Properties_t *) ParserHandle)->PrivateData_p);
+    useDefaultScalingMatrixFlag = (!(1 == 1));
+    lastScale = 8;
+    nextScale = 8;
+    if(ScalingListNumber < 6)
+    {
+        sizeOfScalingList = 16;
+        ScalingList = (U32 *)ScalingMatrix->FirstSixScalingList[ScalingListNumber];
+    }
+    else
+    {
+        sizeOfScalingList = 64;
+        ScalingList = (U32 *)ScalingMatrix->NextTwoScalingList[ScalingListNumber-6];
+    }
+    for(CoefCounter = 0 ; (CoefCounter < sizeOfScalingList) && !useDefaultScalingMatrixFlag; CoefCounter++ )
+    {
+        scanj = (sizeOfScalingList==16) ? ZZ_SCAN[CoefCounter]:ZZ_SCAN8[CoefCounter];
+        if(nextScale != 0)
+        {
+            DeltaScale = GSB_GetSignedExpGolomb(&PARSER_Properties_p->GSB);
+            nextScale = (lastScale + DeltaScale + 256) % 256;
+            if((CoefCounter == 0) && (nextScale == 0))
+            {
+                useDefaultScalingMatrixFlag = (1 == 1);
+            }
+        }
+        if(nextScale == 0)
+        {
+            ScalingList[scanj] = lastScale;
+        }
+        else
+        {
+            ScalingList[scanj] = nextScale;
+        }
+        lastScale = ScalingList[scanj];
+    }
+    if(useDefaultScalingMatrixFlag)
+    {
+        h264par_SetScalingListDefault(ScalingMatrix, ScalingListNumber);
+    }
+}
+static void h264par_InitializeDefaultHRDParameters(U8 SeqParameterSetId, const PARSER_Handle_t ParserHandle)
+{
+    H264ParserPrivateData_t * PARSER_Data_p;
+    PARSER_Data_p = ((H264ParserPrivateData_t *)((PARSER_Properties_t *) ParserHandle)->PrivateData_p);
+    PARSER_Data_p->SPSLocalData[SeqParameterSetId].NalHrdBpPresentFlag = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].nal_cpb_cnt_minus1 = 0;
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].nal_BitRate[0] = 1200 * PARSER_Data_p->SPSLocalData[SeqParameterSetId].MaxBR;
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].nal_CpbSize[0] = 1200 * PARSER_Data_p->SPSLocalData[SeqParameterSetId].MaxCPB;
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].nal_cbr_flag[0] = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.BitRate =
+         PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].nal_BitRate[0] / 400;
+    PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.VBVBufferSize =
+         PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].nal_CpbSize[0] / 8;
+    PARSER_Data_p->SPSLocalData[SeqParameterSetId].VclHrdBpPresentFlag = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].vcl_cpb_cnt_minus1 = 0;
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].vcl_BitRate[0] = 1000 * PARSER_Data_p->SPSLocalData[SeqParameterSetId].MaxBR;
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].vcl_CpbSize[0] = 1000 * PARSER_Data_p->SPSLocalData[SeqParameterSetId].MaxCPB;
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].vcl_cbr_flag[0] = (!(1 == 1));
+}
+void h264par_InitializeGlobalDecodingContext(U8 SeqParameterSetId, const PARSER_Handle_t ParserHandle)
+{
+    U32 ScalingListCounter;
+    U16 ViewCounter, AnchorRefCounter;
+    H264ParserPrivateData_t * PARSER_Data_p;
+    PARSER_Data_p = ((H264ParserPrivateData_t *)((PARSER_Properties_t *) ParserHandle)->PrivateData_p);
+    PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.MPEGStandard = STVID_MPEG_STANDARD_ISO_IEC_14496;
+    PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.IsLowDelay = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.OverScanAllowed = (1 == 1);
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].chroma_format_idc = 1;
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].residual_colour_transform_flag = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].bit_depth_luma_minus8 = 0;
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].bit_depth_chroma_minus8 = 0;
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].qpprime_y_zero_transform_bypass_flag = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].seq_scaling_matrix_present_flag = (!(1 == 1));
+    for(ScalingListCounter = 0 ; ScalingListCounter < 8 ; ScalingListCounter++)
+    {
+        PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].ScalingMatrix.ScalingListPresentFlag[ScalingListCounter] = (!(1 == 1));
+    }
+    h264par_SetFlatScalingMatrix(&(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].ScalingMatrix));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].mb_adaptive_frame_field_flag = 0;
+     PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].FrameCropInPixel.LeftOffset = 0;
+     PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].FrameCropInPixel.RightOffset = 0;
+     PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].FrameCropInPixel.TopOffset = 0;
+     PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].FrameCropInPixel.BottomOffset = 0;
+    PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.Aspect = STVID_DISPLAY_ASPECT_RATIO_4TO3;
+    PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.VideoFormat = 5;
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].video_full_range_flag = 0;
+    PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ColourPrimaries = 2;
+    PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].TransferCharacteristics = 2;
+    PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].MatrixCoefficients = 2;
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].chroma_sample_loc_type_top_field = 0;
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].chroma_sample_loc_type_bottom_field = 0;
+    PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.FrameRate = 1010;
+    PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.StreamID = PARSER_Data_p->ParserGlobalVariable.StreamID;
+    PARSER_Data_p->SPSLocalData[SeqParameterSetId].num_ref_frames_in_pic_cnt_cycle = 0;
+    PARSER_Data_p->SPSLocalData[SeqParameterSetId].pic_struct_present_flag = (!(1 == 1));
+    PARSER_Data_p->SPSLocalData[SeqParameterSetId].CpbDpbDelaysPresentFlag = 0;
+    PARSER_Data_p->SPSLocalData[SeqParameterSetId].InitialCpbRemovalDelayLength = 24;
+    PARSER_Data_p->SPSLocalData[SeqParameterSetId].CpbRemovalDelayLength = 24;
+    PARSER_Data_p->SPSLocalData[SeqParameterSetId].DpbOutputDelayLength = 24;
+    PARSER_Data_p->SPSLocalData[SeqParameterSetId].TimeOffsetLength = 24;
+    PARSER_Data_p->SPSLocalData[SeqParameterSetId].IsInitialCpbRemovalDelayValid = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].motion_vectors_over_pic_boundaries_flag = 1;
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].max_bytes_per_pic_denom = 2;
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].max_bits_per_mb_denom = 1;
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].log2_max_mv_length_horizontal = 16;
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].log2_max_mv_length_vertical = 16;
+    PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.ScanType = STVID_SCAN_TYPE_INTERLACED;
+    PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_NONE;
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.MaxBytesPerPicDenomRangeError = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.MaxBitsPerMBDenomError = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.Log2MaxMvLengthHorizontalRangeError = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.Log2MaxMvLengthVerticalRangeError = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.NumReorderFrameRangeError = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.MaxDecBufferingRangeError = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.IsNotSupportedProfileError = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.AuxCodedPicturePresent = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.ReservedZero4BitsError = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.LevelIdcRangeError = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.Log2MaxFrameNumMinus4RangeError = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.Log2MaxPicOrderCntLsbMinus4RangeError = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.NumRefFramesRangeError = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.Direct8x8InferenceFlagNullWithFrameMbsOnlyFlagError = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.Direct8x8InferenceFlagNullWithLevel3OrMoreError = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.TruncatedNAL = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.NalCpbCntMinus1RangeError = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.NalBitRateRangeError = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.NalCpbSizeRangeError = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.NonIncreasingNalBitRateError = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.NonIncreasingNalCpbSizeError = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.VclCpbCntMinus1RangeError = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.VclBitRateRangeError = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.VclCpbSizeRangeError = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.NonIncreasingVclBitRateError = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.NonIncreasingVclCpbSizeError = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.InitialCpbRemovalDelayDifferError = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.CpbRemovalDelayLengthDifferError = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.DpbOutputDelayLengthDifferError = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.TimeOffsetLengthDifferError = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.LowDelayHrdFlagNotNullError = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.WidthRangeError = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.HeightRangeError = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.AspectRatioRangeError = (!(1 == 1));
+    PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.FrameRateExtensionN = 0;
+    PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.FrameRateExtensionD = 0;
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].num_views_minus1 = 0;
+    for (ViewCounter = 0; ViewCounter <= 1 ; ViewCounter++ )
+    {
+        PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].view_id[ViewCounter] = 0;
+        PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].num_anchor_refs_l0[ViewCounter] = 0;
+        PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].num_anchor_refs_l1[ViewCounter] = 0;
+        PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].num_non_anchor_refs_l0[ViewCounter] = 0;
+        PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].num_non_anchor_refs_l1[ViewCounter] = 0;
+        PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].VOIndex[ViewCounter] = 0;
+        for (AnchorRefCounter = 0; AnchorRefCounter <= 1 ; AnchorRefCounter++ )
+        {
+            PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].anchor_ref_l0[ViewCounter][AnchorRefCounter] = 0;
+            PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].anchor_ref_l1[ViewCounter][AnchorRefCounter] = 0;
+            PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].non_anchor_ref_l0[ViewCounter][AnchorRefCounter] = 0;
+            PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].non_anchor_ref_l1[ViewCounter][AnchorRefCounter] = 0;
+        }
+    }
+}
+void h264par_GetSampleAspectRatio(U8 AspectRatioIdc, U16 * SarWidth, U16 * SarHeight)
+{
+    *SarWidth = 1;
+    *SarHeight = 1;
+    switch (AspectRatioIdc)
+    {
+        case 0:
+        case 1:
+            * SarWidth = 1;
+            * SarHeight = 1;
+            break;
+       case 2:
+            * SarWidth = 12;
+            * SarHeight = 11;
+            break;
+       case 3:
+            * SarWidth = 10;
+            * SarHeight = 11;
+            break;
+       case 4:
+            * SarWidth = 16;
+            * SarHeight = 11;
+            break;
+       case 5:
+            * SarWidth = 40;
+            * SarHeight = 33;
+            break;
+       case 6:
+            * SarWidth = 24;
+            * SarHeight = 11;
+            break;
+       case 7:
+            * SarWidth = 20;
+            * SarHeight = 11;
+            break;
+       case 8:
+            * SarWidth = 32;
+            * SarHeight = 11;
+            break;
+       case 9:
+            * SarWidth = 80;
+            * SarHeight = 33;
+            break;
+       case 10:
+            * SarWidth = 18;
+            * SarHeight = 11;
+            break;
+       case 11:
+            * SarWidth = 15;
+            * SarHeight = 11;
+            break;
+       case 12:
+            * SarWidth = 64;
+            * SarHeight = 33;
+            break;
+       case 13:
+            * SarWidth = 160;
+            * SarHeight = 99;
+            break;
+       case 14:
+            * SarWidth = 4;
+            * SarHeight = 3;
+            break;
+       case 15:
+            * SarWidth = 3;
+            * SarHeight = 2;
+            break;
+       case 16:
+            * SarWidth = 2;
+            * SarHeight = 1;
+            break;
+       case 255:
+            * SarWidth = 4;
+            * SarHeight = 3;
+            break;
+       default:
+            break;
+    }
+}
+void h264par_ParseVUI (U8 SeqParameterSetId, const PARSER_Handle_t ParserHandle)
+{
+    BOOL AspectRatioInfoPresentFlag = (!(1 == 1));
+    U8 AspectRatioIdc;
+    U16 SarWidth;
+    U16 SarHeight;
+    BOOL OverscanInfoPresentFlag = (!(1 == 1));
+    BOOL VideoSignalTypePresentFlag = (!(1 == 1));
+    U8 VideoFormat;
+    U8 VideoFullRangeFlag = 0;
+    U8 ColourDescriptionPresentFlag;
+    U8 ColourPrimaries;
+    U8 TransferCharacteristics;
+    U8 MatrixCoefficients;
+    BOOL ChromaLocInfoPresentFlag = (!(1 == 1));
+    BOOL TimingInfoPresentFlag = (!(1 == 1));
+    U32 NumUnitsInTicks;
+    U32 TimeScale;
+    U32 IntPart = 0;
+    U32 Remaining = 0;
+    BOOL FixedFrameRateFlag = (!(1 == 1));
+    BOOL NalHrdParametersPresentFlag = (!(1 == 1));
+    BOOL VclHrdParametersPresentFlag = (!(1 == 1));
+    BOOL LowDelayHrdFlag = (!(1 == 1));
+    U8 PicStructPresentFlag;
+    U8 BitstreamRestrictionFlag;
+    U8 NalCpbCntMinus1 = - 1;
+    U8 VclCpbCntMinus1 = -1;
+    U8 BitRateScale;
+    U8 CpbSizeScale;
+    U8 SchedSelIdx;
+    U32 BitRateValueMinus1;
+    U32 CpbSizeValueMinus1;
+    U8 VclInitialCpbRemovalDelayLength;
+    U8 VclCpbRemovalDelayLength;
+    U8 VclDpbOutputDelayLength;
+    U8 VclTimeOffsetLength;
+    U32 DisplayAspectRatio;
+    U32 NalMaxBitRate;
+    U32 VclMaxBitRate;
+    U32 NalMaxCpbSize;
+    U32 VclMaxCpbSize;
+    U32 RequestedBits;
+    PARSER_Properties_t * PARSER_Properties_p = (PARSER_Properties_t *) ParserHandle;
+    H264ParserPrivateData_t * PARSER_Data_p;
+    PARSER_Data_p = ((H264ParserPrivateData_t *)((PARSER_Properties_t *) ParserHandle)->PrivateData_p);
+    SarWidth = 1;
+    SarHeight = 1;
+    AspectRatioIdc = 0;
+    FixedFrameRateFlag = (!(1 == 1));
+    NalMaxBitRate = 0;
+    VclMaxBitRate = 0;
+    NalMaxCpbSize = 0;
+    VclMaxCpbSize = 0;
+    AspectRatioInfoPresentFlag = GSB_GetOneBit(&PARSER_Properties_p->GSB);
+    if (AspectRatioInfoPresentFlag)
+    {
+        RequestedBits = GSB_GetBits(&PARSER_Properties_p->GSB, 8);
+        AspectRatioIdc = (U8)RequestedBits;
+        h264par_GetSampleAspectRatio(AspectRatioIdc, &SarWidth, &SarHeight);
+        if (AspectRatioIdc == 255)
+        {
+            RequestedBits = GSB_GetBits(&PARSER_Properties_p->GSB, 32 );
+            SarWidth = (RequestedBits >> 16) & 0xFFFF;
+            SarHeight = RequestedBits & 0xFFFF;
+        }
+    }
+    if ((SarWidth == 0)||(SarHeight == 0))
+    {
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.Aspect = STVID_DISPLAY_ASPECT_RATIO_4TO3;
+    }
+    else
+    {
+        DisplayAspectRatio = (9* SarWidth * PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.Width) /
+                             (SarHeight * PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.Height);
+        if ((DisplayAspectRatio >= 9) && (DisplayAspectRatio < 14))
+        {
+           PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.Aspect = STVID_DISPLAY_ASPECT_RATIO_4TO3;
+        }
+        else if ((DisplayAspectRatio >= 14) && (DisplayAspectRatio < 18))
+        {
+           PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.Aspect = STVID_DISPLAY_ASPECT_RATIO_16TO9;
+        }
+        else if ((DisplayAspectRatio >= 18) && (DisplayAspectRatio < 22))
+        {
+           PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.Aspect = STVID_DISPLAY_ASPECT_RATIO_221TO1;
+        }
+        else
+        {
+            PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.Aspect = STVID_DISPLAY_ASPECT_RATIO_4TO3;
+            if (AspectRatioIdc != 0)
+            {
+              PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+              {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.AspectRatioRangeError) = (1 == 1); }
+                                                                             ;
+            }
+        }
+    }
+    OverscanInfoPresentFlag = GSB_GetOneBit(&PARSER_Properties_p->GSB);
+    if (OverscanInfoPresentFlag)
+    {
+        PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].overscan_appropriate_flag = GSB_GetOneBit(&PARSER_Properties_p->GSB);
+        if (PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].overscan_appropriate_flag == 0)
+        {
+            PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.OverScanAllowed = (!(1 == 1));
+        }
+    }
+    VideoSignalTypePresentFlag = GSB_GetOneBit(&PARSER_Properties_p->GSB);
+    if (VideoSignalTypePresentFlag)
+    {
+        RequestedBits = GSB_GetBits(&PARSER_Properties_p->GSB, 5 );
+        VideoFormat = (RequestedBits >> 2) & 0x7;
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.VideoFormat = VideoFormat;
+        VideoFullRangeFlag = (RequestedBits >> 1) & 0x1;
+        ColourDescriptionPresentFlag = RequestedBits & 0x1;
+        if (ColourDescriptionPresentFlag == 1)
+        {
+            RequestedBits = GSB_GetBits(&PARSER_Properties_p->GSB, 24 );
+            ColourPrimaries = (RequestedBits >> 16) & 0xFF;
+            PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ColourPrimaries = ColourPrimaries;
+            TransferCharacteristics = (RequestedBits >> 8) & 0xFF;
+            PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].TransferCharacteristics = TransferCharacteristics;
+            MatrixCoefficients = RequestedBits & 0xFF;
+            PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].MatrixCoefficients = MatrixCoefficients;
+        }
+    }
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].video_full_range_flag = VideoFullRangeFlag;
+    ChromaLocInfoPresentFlag = GSB_GetOneBit(&PARSER_Properties_p->GSB);
+    if (ChromaLocInfoPresentFlag)
+    {
+        PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].chroma_sample_loc_type_top_field = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+        PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].chroma_sample_loc_type_bottom_field = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+    }
+    TimingInfoPresentFlag = GSB_GetOneBit(&PARSER_Properties_p->GSB);
+    if (TimingInfoPresentFlag)
+    {
+        NumUnitsInTicks = GSB_GetBits(&PARSER_Properties_p->GSB, 32 );
+        TimeScale = GSB_GetBits(&PARSER_Properties_p->GSB, 32 );
+        FixedFrameRateFlag = GSB_GetOneBit(&PARSER_Properties_p->GSB);
+        if ((NumUnitsInTicks != 0) && (TimeScale != 0) && (FixedFrameRateFlag != 0))
+        {
+            if (TimeScale >= (4294967 - (NumUnitsInTicks/2)/1000))
+            {
+                IntPart = 1000 * (TimeScale / NumUnitsInTicks);
+                Remaining = ((1000 * (TimeScale % NumUnitsInTicks)) + (NumUnitsInTicks/2)) / NumUnitsInTicks;
+                PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.FrameRate = IntPart + Remaining;
+            }
+            else
+            {
+                PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.FrameRate = ((1000 * TimeScale) + (NumUnitsInTicks/2)) / NumUnitsInTicks;
+            }
+            PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.FrameRate /= 2;
+            if (PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.FrameRate == 0)
+            {
+                PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.FrameRate = 1010;
+            }
+            if (PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.FrameRate > PARSER_Data_p->SPSLocalData[SeqParameterSetId].MaxFrameRate)
+            {
+                PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.FrameRate = 1010;
+            }
+        }
+        else
+        {
+            PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.FrameRate = 1010;
+        }
+    }
+    else
+    {
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.FrameRate = 1010;
+    }
+    NalHrdParametersPresentFlag = GSB_GetOneBit(&PARSER_Properties_p->GSB);
+    if (NalHrdParametersPresentFlag)
+    {
+        NalCpbCntMinus1 = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+        if (NalCpbCntMinus1 > 31)
+        {
+            NalCpbCntMinus1 = 1;
+            PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+            {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.NalCpbCntMinus1RangeError) = (1 == 1); }
+                                                                                ;
+            NalCpbCntMinus1 = 31;
+        }
+        PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].nal_cpb_cnt_minus1 = NalCpbCntMinus1;
+        RequestedBits = GSB_GetBits(&PARSER_Properties_p->GSB, 8 );
+        BitRateScale = (RequestedBits >> 4) & 0xF;
+        CpbSizeScale = RequestedBits & 0xF;
+        for (SchedSelIdx = 0; SchedSelIdx <= NalCpbCntMinus1; SchedSelIdx ++)
+        {
+            if ((BitRateValueMinus1=GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB)) == 0xFFFFFFFF)
+            {
+                PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].nal_BitRate[SchedSelIdx] = 1;
+                PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+                {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.NalBitRateRangeError) = (1 == 1); }
+                                                                             ;
+            }
+            else
+            {
+                PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].nal_BitRate[SchedSelIdx] = (BitRateValueMinus1 + 1) * (1 << (6 + BitRateScale));
+            }
+            if ((CpbSizeValueMinus1 = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB)) == 0xFFFFFFFF)
+            {
+                PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].nal_CpbSize[SchedSelIdx] = 1;
+                PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+                {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.NalCpbSizeRangeError) = (1 == 1); }
+                                                                             ;
+            }
+            else
+            {
+                PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].nal_CpbSize[SchedSelIdx] = (CpbSizeValueMinus1 + 1) * (1 << (4 + CpbSizeScale));
+            }
+            PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].nal_cbr_flag[SchedSelIdx] = GSB_GetBits(&PARSER_Properties_p->GSB, 1);
+            if (SchedSelIdx > 0)
+            {
+                if (PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].nal_BitRate[SchedSelIdx] <=
+                    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].nal_BitRate[SchedSelIdx - 1]
+                   )
+                {
+                    PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+                    {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.NonIncreasingNalBitRateError) = (1 == 1); }
+                                                                                   ;
+                }
+                if (PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].nal_CpbSize[SchedSelIdx] <=
+                    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].nal_CpbSize[SchedSelIdx - 1]
+                   )
+                {
+                    PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+                    {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.NonIncreasingNalCpbSizeError) = (1 == 1); }
+                                                                                   ;
+                }
+            }
+            if (NalMaxBitRate < PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].nal_BitRate[SchedSelIdx])
+            {
+                NalMaxBitRate = PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].nal_BitRate[SchedSelIdx];
+            }
+            if (NalMaxCpbSize < PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].nal_CpbSize[SchedSelIdx])
+            {
+                NalMaxCpbSize = PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].nal_CpbSize[SchedSelIdx];
+            }
+        }
+        PARSER_Data_p->SPSLocalData[SeqParameterSetId].NalHrdBpPresentFlag = (1 == 1);
+        RequestedBits = GSB_GetBits(&PARSER_Properties_p->GSB, 20 );
+        PARSER_Data_p->SPSLocalData[SeqParameterSetId].InitialCpbRemovalDelayLength = ((RequestedBits >> 15) & 0x1F) + 1; ;
+        PARSER_Data_p->SPSLocalData[SeqParameterSetId].CpbRemovalDelayLength = ((RequestedBits >> 10) & 0x1F) + 1;
+        PARSER_Data_p->SPSLocalData[SeqParameterSetId].DpbOutputDelayLength = ((RequestedBits >> 5) & 0x1F) + 1;
+        PARSER_Data_p->SPSLocalData[SeqParameterSetId].TimeOffsetLength = RequestedBits & 0x1F;
+    }
+    VclHrdParametersPresentFlag = GSB_GetOneBit(&PARSER_Properties_p->GSB);
+    if (VclHrdParametersPresentFlag)
+    {
+        VclCpbCntMinus1 = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+        if (VclCpbCntMinus1 > 31)
+        {
+            VclCpbCntMinus1 = 1;
+            PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+            {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.VclCpbCntMinus1RangeError) = (1 == 1); }
+                                                                                ;
+            VclCpbCntMinus1 = 31;
+        }
+        PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].vcl_cpb_cnt_minus1 = VclCpbCntMinus1;
+        RequestedBits = GSB_GetBits(&PARSER_Properties_p->GSB, 8 );
+        BitRateScale = (RequestedBits >> 4) & 0xF;
+        CpbSizeScale = RequestedBits & 0xF;
+        for (SchedSelIdx = 0; SchedSelIdx <= VclCpbCntMinus1; SchedSelIdx ++)
+        {
+            if ((BitRateValueMinus1 = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB)) == 0xFFFFFFFF)
+            {
+                PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].vcl_BitRate[SchedSelIdx] = 1;
+                PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+                {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.VclBitRateRangeError) = (1 == 1); }
+                                                                             ;
+            }
+            else
+            {
+                PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].vcl_BitRate[SchedSelIdx] = (BitRateValueMinus1 + 1) * (1 << (6 + BitRateScale));
+            }
+            if ((CpbSizeValueMinus1 = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB)) == 0xFFFFFFFF)
+            {
+                PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].vcl_CpbSize[SchedSelIdx] = 1;
+                PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+                {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.VclCpbSizeRangeError) = (1 == 1); }
+                                                                             ;
+            }
+            else
+            {
+                PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].vcl_CpbSize[SchedSelIdx] = (CpbSizeValueMinus1 + 1) * (1 << (4 + CpbSizeScale));
+            }
+            PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].vcl_cbr_flag[SchedSelIdx] = GSB_GetBits(&PARSER_Properties_p->GSB, 1);
+            if (SchedSelIdx > 0)
+            {
+                if (PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].vcl_BitRate[SchedSelIdx] <=
+                    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].vcl_BitRate[SchedSelIdx - 1]
+                   )
+                {
+                    PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+                    {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.NonIncreasingVclBitRateError) = (1 == 1); }
+                                                                                   ;
+                }
+                if (PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].vcl_CpbSize[SchedSelIdx] <=
+                    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].vcl_CpbSize[SchedSelIdx - 1]
+                   )
+                {
+                    PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+                    {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.NonIncreasingVclCpbSizeError) = (1 == 1); }
+                                                                                   ;
+                }
+            }
+            if (VclMaxBitRate < PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].vcl_BitRate[SchedSelIdx])
+            {
+                VclMaxBitRate = PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].vcl_BitRate[SchedSelIdx];
+            }
+            if (VclMaxCpbSize < PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].vcl_CpbSize[SchedSelIdx])
+            {
+                VclMaxCpbSize = PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].vcl_CpbSize[SchedSelIdx];
+            }
+        }
+        RequestedBits = GSB_GetBits(&PARSER_Properties_p->GSB, 20 );
+        VclInitialCpbRemovalDelayLength = ((RequestedBits >> 15) & 0x1F) + 1;
+        VclCpbRemovalDelayLength = ((RequestedBits >> 10) & 0x1F) + 1;
+        VclDpbOutputDelayLength = ((RequestedBits >> 5) & 0x1F) + 1;
+        VclTimeOffsetLength = RequestedBits & 0x1F;
+        if (NalHrdParametersPresentFlag)
+        {
+            if (PARSER_Data_p->SPSLocalData[SeqParameterSetId].InitialCpbRemovalDelayLength != VclInitialCpbRemovalDelayLength)
+            {
+                PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+                {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.InitialCpbRemovalDelayDifferError) = (1 == 1); }
+                                                                                                                      ;
+            }
+            if (PARSER_Data_p->SPSLocalData[SeqParameterSetId].CpbRemovalDelayLength != VclCpbRemovalDelayLength)
+            {
+                PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+                {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.CpbRemovalDelayLengthDifferError) = (1 == 1); }
+                                                                                                              ;
+            }
+            if (PARSER_Data_p->SPSLocalData[SeqParameterSetId].DpbOutputDelayLength != VclDpbOutputDelayLength)
+            {
+                PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+                {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.DpbOutputDelayLengthDifferError) = (1 == 1); }
+                                                                                                             ;
+            }
+            if (PARSER_Data_p->SPSLocalData[SeqParameterSetId].TimeOffsetLength != VclTimeOffsetLength)
+            {
+                PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+                {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.TimeOffsetLengthDifferError) = (1 == 1); }
+                                                                                                        ;
+            }
+        }
+        PARSER_Data_p->SPSLocalData[SeqParameterSetId].VclHrdBpPresentFlag = (1 == 1);
+        PARSER_Data_p->SPSLocalData[SeqParameterSetId].InitialCpbRemovalDelayLength = VclInitialCpbRemovalDelayLength;
+        PARSER_Data_p->SPSLocalData[SeqParameterSetId].CpbRemovalDelayLength = VclCpbRemovalDelayLength;
+        PARSER_Data_p->SPSLocalData[SeqParameterSetId].DpbOutputDelayLength = VclDpbOutputDelayLength;
+        PARSER_Data_p->SPSLocalData[SeqParameterSetId].TimeOffsetLength = VclTimeOffsetLength;
+    }
+    if ((NalHrdParametersPresentFlag) || (VclHrdParametersPresentFlag))
+    {
+        if (NalMaxBitRate > (6 * VclMaxBitRate / 5))
+        {
+            PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.BitRate = NalMaxBitRate / 400;
+        }
+        else
+        {
+            PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.BitRate = (6 * VclMaxBitRate / 5) / 400;
+        }
+        if (NalMaxCpbSize > (6 * VclMaxCpbSize / 5))
+        {
+            PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.VBVBufferSize = NalMaxCpbSize / 8;
+        }
+        else
+        {
+            PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.VBVBufferSize = (6 * VclMaxCpbSize / 5) / 8;
+        }
+        PARSER_Data_p->SPSLocalData[SeqParameterSetId].CpbDpbDelaysPresentFlag = 1;
+        LowDelayHrdFlag = GSB_GetOneBit(&PARSER_Properties_p->GSB);
+        if (LowDelayHrdFlag)
+        {
+            if (FixedFrameRateFlag)
+            {
+                PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+                {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.LowDelayHrdFlagNotNullError) = (1 == 1); }
+                                                                                                                         ;
+            }
+            if (NalCpbCntMinus1 != 0)
+            {
+                PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+                {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.NalCpbCntMinus1RangeError) = (1 == 1); }
+                                                                                    ;
+            }
+            if (VclCpbCntMinus1 != 0)
+            {
+                PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+                {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.VclCpbCntMinus1RangeError) = (1 == 1); }
+                                                                                    ;
+            }
+            PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.IsLowDelay = (1 == 1);
+        }
+    }
+    RequestedBits = GSB_GetBits(&PARSER_Properties_p->GSB, 2 );
+    PicStructPresentFlag = (RequestedBits >> 1) & 0x1;
+    if (PicStructPresentFlag == 1)
+    {
+        PARSER_Data_p->SPSLocalData[SeqParameterSetId].pic_struct_present_flag = (1 == 1);
+    }
+    else
+    {
+        PARSER_Data_p->SPSLocalData[SeqParameterSetId].pic_struct_present_flag = (!(1 == 1));
+    }
+    BitstreamRestrictionFlag = RequestedBits & 0x1;
+    if (BitstreamRestrictionFlag == 1)
+    {
+        PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].motion_vectors_over_pic_boundaries_flag = GSB_GetOneBit(&PARSER_Properties_p->GSB);
+        PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].max_bytes_per_pic_denom = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+        if (PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].max_bytes_per_pic_denom > 16)
+        {
+            PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+            {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.MaxBytesPerPicDenomRangeError) = (1 == 1); }
+                                                                                          ;
+        }
+        PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].max_bits_per_mb_denom = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+        if (PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].max_bits_per_mb_denom > 16)
+        {
+            PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+            {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.MaxBitsPerMBDenomError) = (1 == 1); }
+                                                                                        ;
+        }
+        PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].log2_max_mv_length_horizontal = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+        if (PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].log2_max_mv_length_horizontal > 16)
+        {
+            PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+            {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.Log2MaxMvLengthHorizontalRangeError) = (1 == 1); }
+                                                                                                ;
+        }
+        PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].log2_max_mv_length_vertical = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+        if (PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].log2_max_mv_length_vertical > 16)
+        {
+            PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+            {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.Log2MaxMvLengthVerticalRangeError) = (1 == 1); }
+                                                                                              ;
+        }
+        PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].num_reorder_frames = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].MaxDecFrameBuffering = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+        if (PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].num_reorder_frames > PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].MaxDecFrameBuffering)
+        {
+            PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+            {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.NumReorderFrameRangeError) = (1 == 1); }
+                                                                                     ;
+        }
+        if (PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].MaxDecFrameBuffering > PARSER_Data_p->SPSLocalData[SeqParameterSetId].MaxDpbSize)
+        {
+            PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+            {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.MaxDecBufferingRangeError) = (1 == 1); }
+                                                                                          ;
+        }
+    }
+}
+void h264par_ComputeMaxFromLevel(U8 LevelIdc, U8 PicWidthInMbsMinus1, U8 PicHeightInMapUnitsMinus1, U8 FrameMbsOnlyFlag, U8 SeqParameterSetId, U8 ConstraintSet4Flag, const PARSER_Handle_t ParserHandle)
+{
+    U8 FrameHeightInMbs;
+    U8 PicWidthInMbs;
+    U8 PicHeightInMapUnits;
+    U32 TempMaxDpbSize;
+    U32 MaxDPB = 0;
+    U32 MaxBR = 0;
+    U32 MaxCPB = 0;
+    U32 MaxWidth = 0;
+    U32 MaxHeight = 0;
+    U32 MaxPixel = 0;
+    U32 MaxMBperSecond = 0;
+    U8 ProfileIdc;
+    H264ParserPrivateData_t * PARSER_Data_p;
+    PARSER_Properties_t * PARSER_Properties_p;
+    PARSER_Data_p = ((H264ParserPrivateData_t *)((PARSER_Properties_t *) ParserHandle)->PrivateData_p);
+    PARSER_Properties_p = (PARSER_Properties_t *) ParserHandle;
+    ProfileIdc = PARSER_Data_p->ParserGlobalVariable.ProfileIdc;
+    PicWidthInMbs = PicWidthInMbsMinus1 + 1;
+    PicHeightInMapUnits = PicHeightInMapUnitsMinus1 + 1;
+    FrameHeightInMbs = (2 - FrameMbsOnlyFlag) * PicHeightInMapUnits;
+    switch (LevelIdc)
+    {
+        case 10: MaxDPB = 152064;
+                 MaxBR = 64;
+                 MaxCPB = 175;
+                 MaxPixel = 99 * 256;
+                 MaxWidth = 448;
+                 MaxHeight = 448;
+                 MaxMBperSecond = 1485;
+                 break;
+        case 11: MaxDPB = 345600;
+                 MaxBR = 192;
+                 MaxCPB = 500;
+                 MaxPixel = 396 * 256;
+                 MaxWidth = 896;
+                 MaxHeight = 896;
+                 MaxMBperSecond = 3000;
+                 break;
+        case 12: MaxDPB = 912384;
+                 MaxBR = 384;
+                 MaxCPB = 1000;
+                 MaxPixel = 396 * 256;
+                 MaxWidth = 896;
+                 MaxHeight = 896;
+                 MaxMBperSecond = 6000;
+                 break;
+        case 13: MaxDPB = 912384;
+                 MaxBR = 768;
+                 MaxCPB = 2000;
+                 MaxPixel = 396 * 256;
+                 MaxWidth = 896;
+                 MaxHeight = 896;
+                 MaxMBperSecond = 11880;
+                 break;
+        case 20: MaxDPB = 912384;
+                 MaxBR = 2000;
+                 MaxCPB = 2000;
+                 MaxPixel = 396 * 256;
+                 MaxWidth = 896;
+                 MaxHeight = 896;
+                 MaxMBperSecond = 11880;
+                 break;
+        case 21: MaxDPB = 1824768;
+                 MaxBR = 4000;
+                 MaxCPB = 4000;
+                 MaxPixel = 792 * 256;
+                 MaxWidth = 1264;
+                 MaxHeight = 1088;
+                 MaxMBperSecond = 19800;
+                 break;
+        case 22: MaxDPB = 3110400;
+                 MaxBR = 4000;
+                 MaxCPB = 4000;
+                 MaxPixel = 1620 * 256;
+                 MaxWidth = 1808;
+                 MaxHeight = 1088;
+                 MaxMBperSecond = 20250;
+                 break;
+        case 30: MaxDPB = 3110400;
+                 MaxBR = 10000;
+                 MaxCPB = 10000;
+                 MaxPixel = 1620 * 256;
+                 MaxWidth = 1808;
+                 MaxHeight = 1088;
+                 MaxMBperSecond = 40500;
+                 break;
+        case 31: MaxDPB = 6912000;
+                 MaxBR = 14000;
+                 MaxCPB = 14000;
+                 MaxPixel = 3600 * 256;
+                 MaxWidth = 1920;
+                 MaxHeight = 1088;
+                 MaxMBperSecond = 108000;
+                 break;
+        case 32: MaxDPB = 7864320;
+                 MaxBR = 20000;
+                 MaxCPB = 20000;
+                 MaxPixel = 5120 * 256;
+                 MaxWidth = 1920;
+                 MaxHeight = 1088;
+                 MaxMBperSecond = 216000;
+                 break;
+        case 40: MaxDPB = 12582912;
+                 MaxBR = 20000;
+                 MaxCPB = 25000;
+                 MaxPixel = 8192 * 256;
+                 MaxWidth = 1920;
+                 MaxHeight = 1088;
+                 MaxMBperSecond = 245760;
+                 break;
+        case 41:
+                 MaxDPB = 12582912;
+                 MaxBR = 50000;
+                 MaxCPB = 62500;
+                 MaxPixel = 8192 * 256;
+                 MaxWidth = 1920;
+                 MaxHeight = 1088;
+                 MaxMBperSecond = 245760;
+                 break;
+        case 42 :
+                MaxDPB = 13369344;
+                MaxBR = 50000;
+                MaxCPB = 62500;
+                MaxPixel = 8704 * 256;
+                MaxWidth = 1920;
+                MaxHeight = 1088;
+                MaxMBperSecond = 522240;
+                break;
+        case 50 :
+                MaxDPB = 42393600;
+                MaxBR = 135000;
+                MaxCPB = 135000;
+                MaxPixel = 22080 * 256;
+                MaxWidth = 1920;
+                MaxHeight = 1088;
+                MaxMBperSecond = 589824;
+                break;
+        case 51 :
+        default:
+                MaxDPB = 70778880;
+                MaxBR = 240000;
+                MaxCPB = 240000;
+                MaxPixel = 36864 * 256;
+                MaxWidth = 1920;
+                MaxHeight = 1088;
+                MaxMBperSecond = 983040;
+                break;
+    }
+    if (MaxDPB > 12582912)
+    {
+        MaxDPB = 12582912;
+    }
+    if (PicWidthInMbs == 0)
+        PicWidthInMbs = 1;
+    if (FrameHeightInMbs == 0)
+        FrameHeightInMbs = 1;
+    TempMaxDpbSize = (U32)(MaxDPB / (PicWidthInMbs * FrameHeightInMbs * (256 + 128)));
+    if((((PARSER_Properties_p->DeviceType & (((1 << 8) - 1) << (0 + 7))) >> (0 + 7)) == 3))
+    {
+        if (LevelIdc >=40)
+        {
+            if (TempMaxDpbSize > 9)
+            {
+                TempMaxDpbSize = 9;
+            }
+        }
+    }
+    if((((PARSER_Properties_p->DeviceType & (((1 << 8) - 1) << (0 + 7))) >> (0 + 7)) == 14))
+    {
+        {
+            TempMaxDpbSize = 2 * TempMaxDpbSize;
+        }
+    }
+    if (TempMaxDpbSize > 16)
+    {
+        TempMaxDpbSize = 16;
+    }
+    PARSER_Data_p->SPSLocalData[SeqParameterSetId].MaxDpbSize = TempMaxDpbSize;
+    PARSER_Data_p->SPSLocalData[SeqParameterSetId].MaxBR = MaxBR;
+    PARSER_Data_p->SPSLocalData[SeqParameterSetId].MaxCPB = MaxCPB;
+    PARSER_Data_p->SPSLocalData[SeqParameterSetId].MaxWidth = MaxWidth;
+    PARSER_Data_p->SPSLocalData[SeqParameterSetId].MaxHeight = MaxHeight;
+    PARSER_Data_p->SPSLocalData[SeqParameterSetId].MaxPixel = MaxPixel;
+    PARSER_Data_p->SPSLocalData[SeqParameterSetId].MaxFrameRate = ((1000 * MaxMBperSecond) / (PicWidthInMbs * FrameHeightInMbs));
+    if (PARSER_Data_p->SPSLocalData[SeqParameterSetId].MaxFrameRate > 172000)
+    {
+        PARSER_Data_p->SPSLocalData[SeqParameterSetId].MaxFrameRate = 172000;
+    }
+}
+ST_ErrorCode_t h264par_ParseSPS (const PARSER_Handle_t ParserHandle)
+{
+    U8 ProfileIdc;
+    U8 ConstraintSet0Flag;
+    U8 ConstraintSet1Flag;
+    U8 ConstraintSet2Flag;
+    U8 ConstraintSet3Flag;
+    U8 ConstraintSet4Flag;
+    U8 ConstraintSet5Flag;
+    U8 ReservedZero2Bits;
+    U8 LevelIdc;
+    U8 SeqParameterSetId;
+    U8 PicOrderCntType;
+    U8 Log2MaxFrameNumMinus4;
+    U8 Log2MaxPixOrderCntLsbMinus4;
+    U32 NumRefFramesInPicOrderCntCycle;
+    U32 i;
+    U8 NumRefFrames;
+    U8 PicWidthInMbsMinus1;
+    U8 PicHeightInMapUnitsMinus1;
+    U8 FrameMbsOnlyFlag;
+    U8 Direct8x8InferenceFlag;
+    BOOL FrameCroppingFlag = (!(1 == 1));
+    U16 PictureDisplayHeightAfterCropping;
+    U32 CropUnitX, CropUnitY;
+    BOOL VuiParametersPresentFlag = (!(1 == 1));
+    U32 ProfileAndLevelIndication;
+    BOOL SeqScalingListPresentFlag = (!(1 == 1));
+    U32 ScalingListNumber;
+    U32 RequestedBits;
+    U32 PicWidthInMbs;
+    U32 PicHeightInMapUnits;
+    U32 NumberOfMbsInAFrame;
+    U32 NumberOfMbsPerSecond;
+    ST_ErrorCode_t ErrorCode = ST_NO_ERROR;
+    H264ParserPrivateData_t * PARSER_Data_p;
+    PARSER_Properties_t * PARSER_Properties_p;
+    PARSER_Data_p = ((H264ParserPrivateData_t *)((PARSER_Properties_t *) ParserHandle)->PrivateData_p);
+    PARSER_Properties_p = (PARSER_Properties_t *) ParserHandle;
+    RequestedBits = GSB_AlignAndGet24Bits(&PARSER_Properties_p->GSB);
+    ProfileIdc = (RequestedBits >> 16) & 0xFF;
+    PARSER_Data_p->ParserGlobalVariable.ProfileIdc = ProfileIdc;
+    ConstraintSet0Flag = (RequestedBits >> 15) & 0x1;
+    ConstraintSet1Flag = (RequestedBits >> 14) & 0x1;
+    ConstraintSet2Flag = (RequestedBits >> 13) & 0x1;
+    ConstraintSet3Flag = (RequestedBits >> 12) & 0x1;
+    ConstraintSet4Flag = (RequestedBits >> 11) & 0x1;
+    ConstraintSet5Flag = (RequestedBits >> 10) & 0x1;
+    ReservedZero2Bits = (RequestedBits >> 8) & 0x3;
+    LevelIdc = RequestedBits & 0xFF;
+    SeqParameterSetId = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+    if (SeqParameterSetId > (32 -1))
+    {
+        return (ErrorCode);
+    }
+    h264par_InitializeGlobalDecodingContext(SeqParameterSetId, ParserHandle);
+    ProfileAndLevelIndication = ((ConstraintSet3Flag << 19) |
+                                 (ConstraintSet2Flag << 18) |
+                                 (ConstraintSet1Flag << 17) |
+                                 (ConstraintSet0Flag << 16) |
+                                 (ProfileIdc << 8) |
+                                 LevelIdc
+                                );
+    if ((ProfileIdc != 77) && (ProfileIdc != 100) && (ConstraintSet1Flag != 1))
+    {
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+        {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.IsNotSupportedProfileError) = (1 == 1); }
+                                                                                                              ;
+    }
+    if (ReservedZero2Bits != 0)
+    {
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+        {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.ReservedZero4BitsError) = (1 == 1); }
+                                                                              ;
+    }
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].seq_parameter_set_id = SeqParameterSetId;
+    PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.ProfileAndLevelIndication = ProfileAndLevelIndication;
+    if (ProfileIdc == 100)
+    {
+        PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].chroma_format_idc = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+        if(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].chroma_format_idc == 3)
+        {
+            PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].residual_colour_transform_flag = GSB_GetOneBit(&PARSER_Properties_p->GSB);
+        }
+        PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].bit_depth_luma_minus8 = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+        PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].bit_depth_chroma_minus8 = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+        RequestedBits = GSB_GetBits(&PARSER_Properties_p->GSB, 2 );
+        PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].qpprime_y_zero_transform_bypass_flag = (RequestedBits >> 1) & 0x1;
+        PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].seq_scaling_matrix_present_flag = RequestedBits & 0x1;
+        if(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].seq_scaling_matrix_present_flag)
+        {
+            for(ScalingListNumber = 0 ; ScalingListNumber < 8 ; ScalingListNumber++)
+            {
+                SeqScalingListPresentFlag = GSB_GetOneBit(&PARSER_Properties_p->GSB);
+                PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].ScalingMatrix.ScalingListPresentFlag[ScalingListNumber] = SeqScalingListPresentFlag;
+                if(SeqScalingListPresentFlag)
+                {
+                    h264par_GetScalingList(ParserHandle, &(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].ScalingMatrix), ScalingListNumber);
+                }
+                else
+                {
+                    h264par_SetScalingListFallBackA(&(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].ScalingMatrix),ScalingListNumber);
+                }
+            }
+        }
+    }
+    Log2MaxFrameNumMinus4 = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+    if (Log2MaxFrameNumMinus4 > 12)
+    {
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+        {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.Log2MaxFrameNumMinus4RangeError) = (1 == 1); }
+                                                                                         ;
+        Log2MaxFrameNumMinus4 = 12;
+    }
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].log2_max_frame_num_minus4 = Log2MaxFrameNumMinus4;
+    PARSER_Data_p->SPSLocalData[SeqParameterSetId].MaxFrameNum = 1 << (PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].log2_max_frame_num_minus4 + 4);
+    PicOrderCntType = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].pic_order_cnt_type = PicOrderCntType;
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].log2_max_pic_order_cnt_lsb_minus4 = 0;
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].delta_pic_order_always_zero_flag = 0;
+    if (PicOrderCntType == 0)
+    {
+        Log2MaxPixOrderCntLsbMinus4 = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+        if (Log2MaxPixOrderCntLsbMinus4 > 12)
+        {
+            PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+            {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.Log2MaxPicOrderCntLsbMinus4RangeError) = (1 == 1); }
+                                                                                                     ;
+            Log2MaxPixOrderCntLsbMinus4 = 12;
+        }
+        PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].log2_max_pic_order_cnt_lsb_minus4 = Log2MaxPixOrderCntLsbMinus4;
+        PARSER_Data_p->SPSLocalData[SeqParameterSetId].MaxPicOrderCntLsb = 1 << (Log2MaxPixOrderCntLsbMinus4 + 4);
+    }
+    else if (PicOrderCntType == 1)
+    {
+        PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].delta_pic_order_always_zero_flag = GSB_GetBits(&PARSER_Properties_p->GSB, 1);
+        PARSER_Data_p->SPSLocalData[SeqParameterSetId].offset_for_non_ref_pic = GSB_GetSignedExpGolomb(&PARSER_Properties_p->GSB);
+        PARSER_Data_p->SPSLocalData[SeqParameterSetId].offset_for_top_to_bottom_field = GSB_GetSignedExpGolomb(&PARSER_Properties_p->GSB);
+        NumRefFramesInPicOrderCntCycle = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+        if (NumRefFramesInPicOrderCntCycle > 255)
+        {
+            NumRefFramesInPicOrderCntCycle = 0;
+        }
+        PARSER_Data_p->SPSLocalData[SeqParameterSetId].num_ref_frames_in_pic_cnt_cycle = (U8)NumRefFramesInPicOrderCntCycle;
+        for (i = 0; i < NumRefFramesInPicOrderCntCycle; i++)
+        {
+            PARSER_Data_p->SPSLocalData[SeqParameterSetId].offset_for_ref_frame[i] = GSB_GetSignedExpGolomb(&PARSER_Properties_p->GSB);
+        }
+    }
+    NumRefFrames = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+    PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].NumberOfReferenceFrames = NumRefFrames;
+    PARSER_Data_p->SPSLocalData[SeqParameterSetId].gaps_in_frame_num_allowed_flag = GSB_GetOneBit(&PARSER_Properties_p->GSB);
+    PicWidthInMbsMinus1 = (U8)GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+    if ((U8)(PicWidthInMbsMinus1 + 1) == 0)
+    {
+        PicWidthInMbsMinus1 = 0;
+    }
+    PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.Width = 16 * (PicWidthInMbsMinus1 + 1);
+    PicHeightInMapUnitsMinus1 = (U8)GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+    if ((U8)(PicHeightInMapUnitsMinus1 + 1) == 0)
+    {
+        PicHeightInMapUnitsMinus1 = 0;
+    }
+    RequestedBits = GSB_GetBits(&PARSER_Properties_p->GSB, 1);
+    FrameMbsOnlyFlag = (U8) RequestedBits;
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].frame_mbs_only_flag = FrameMbsOnlyFlag;
+    PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.Height = 16 * (2 - FrameMbsOnlyFlag) * (PicHeightInMapUnitsMinus1 + 1);
+    h264par_ComputeMaxFromLevel(LevelIdc, PicWidthInMbsMinus1, PicHeightInMapUnitsMinus1, FrameMbsOnlyFlag, SeqParameterSetId, ConstraintSet4Flag, ParserHandle);
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].num_reorder_frames = PARSER_Data_p->SPSLocalData[SeqParameterSetId].MaxDpbSize;
+    PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].MaxDecFrameBuffering = PARSER_Data_p->SPSLocalData[SeqParameterSetId].MaxDpbSize;
+    h264par_InitializeDefaultHRDParameters(SeqParameterSetId, ParserHandle);
+    if (PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.Width *
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.Height >
+        PARSER_Data_p->SPSLocalData[SeqParameterSetId].MaxPixel)
+    {
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_BAD_DISPLAY;
+        {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.WidthRangeError) = (1 == 1); }
+                                                                                         ;
+    }
+    if (PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.Width > PARSER_Data_p->SPSLocalData[SeqParameterSetId].MaxWidth)
+    {
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_BAD_DISPLAY;
+        {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.WidthRangeError) = (1 == 1); }
+                                                                         ;
+    }
+    if (PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.Height > PARSER_Data_p->SPSLocalData[SeqParameterSetId].MaxHeight)
+    {
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_BAD_DISPLAY;
+        {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.HeightRangeError) = (1 == 1); }
+                                                                          ;
+    }
+    if (PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].NumberOfReferenceFrames > PARSER_Data_p->SPSLocalData[SeqParameterSetId].MaxDpbSize)
+    {
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+        {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.NumRefFramesRangeError) = (1 == 1); }
+                                                                             ;
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].NumberOfReferenceFrames = PARSER_Data_p->SPSLocalData[SeqParameterSetId].MaxDpbSize;
+    }
+    if (FrameMbsOnlyFlag == 0)
+    {
+        PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].mb_adaptive_frame_field_flag = GSB_GetBits(&PARSER_Properties_p->GSB, 1);
+    }
+    RequestedBits = GSB_GetBits(&PARSER_Properties_p->GSB, 1);
+    Direct8x8InferenceFlag = (U8) RequestedBits;
+    if ((FrameMbsOnlyFlag == 0) && (Direct8x8InferenceFlag == 0))
+    {
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+        {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.Direct8x8InferenceFlagNullWithFrameMbsOnlyFlagError) = (1 == 1); }
+                                                                                                                             ;
+    }
+    if ((Direct8x8InferenceFlag == 0) && (LevelIdc >= 30))
+    {
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+        {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.Direct8x8InferenceFlagNullWithLevel3OrMoreError) = (1 == 1); }
+                                                                                                                  ;
+    }
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].direct_8x8_inference_flag = Direct8x8InferenceFlag;
+    FrameCroppingFlag = GSB_GetOneBit(&PARSER_Properties_p->GSB);
+    if (FrameCroppingFlag)
+    {
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].FrameCropInPixel.LeftOffset = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].FrameCropInPixel.RightOffset = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].FrameCropInPixel.TopOffset = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].FrameCropInPixel.BottomOffset = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+        switch (PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].chroma_format_idc)
+        {
+            case 1 :
+                CropUnitX = 2;
+                CropUnitY = 2 * ( 2 - FrameMbsOnlyFlag );
+                break;
+            case 2 :
+                CropUnitX = 2;
+                CropUnitY = ( 2 - FrameMbsOnlyFlag );
+                break;
+            case 3 :
+            case 0 :
+            default :
+                CropUnitX = 1;
+                CropUnitY = ( 2 - FrameMbsOnlyFlag );
+                break;
+        }
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].FrameCropInPixel.LeftOffset *= CropUnitX;
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].FrameCropInPixel.RightOffset *= CropUnitX;
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].FrameCropInPixel.TopOffset *= CropUnitY;
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].FrameCropInPixel.BottomOffset *= CropUnitY;
+    }
+    PictureDisplayHeightAfterCropping = PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.Height
+                                        - PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].FrameCropInPixel.TopOffset
+                                        - PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].FrameCropInPixel.BottomOffset;
+    if (PictureDisplayHeightAfterCropping == 720)
+    {
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.ScanType = STVID_SCAN_TYPE_PROGRESSIVE;
+    }
+    if (PictureDisplayHeightAfterCropping > 1080)
+    {
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].FrameCropInPixel.BottomOffset =
+                PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.Height - 1080;
+    }
+    VuiParametersPresentFlag = GSB_GetOneBit(&PARSER_Properties_p->GSB);
+    if (VuiParametersPresentFlag)
+    {
+        h264par_ParseVUI(SeqParameterSetId, ParserHandle);
+    }
+    if (PARSER_Properties_p->ForcedFrameRate != 0)
+    {
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.FrameRate = PARSER_Properties_p->ForcedFrameRate;
+    }
+    else
+    {
+        if (PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.FrameRate == 1010)
+        {
+                PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.FrameRate = PARSER_Properties_p->DefaultFrameRate;
+        }
+    }
+    PicWidthInMbs = (PicWidthInMbsMinus1 + 1);
+    PicHeightInMapUnits = (2 - FrameMbsOnlyFlag) * (PicHeightInMapUnitsMinus1 + 1);
+    NumberOfMbsInAFrame = PicWidthInMbs * PicHeightInMapUnits;
+    NumberOfMbsPerSecond = NumberOfMbsInAFrame * PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.FrameRate;
+    NumberOfMbsPerSecond = NumberOfMbsPerSecond / 1000;
+    if ((PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.Width > 1920) || ((LevelIdc > 41) && (NumberOfMbsPerSecond > 245760)))
+    {
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_CRASH;
+        {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.LevelIdcRangeError) = (1 == 1); }
+                                                                                                 ;
+        PARSER_Data_p->UnsupportedStreamType.UnsupportedProfileAndLevelIndication = ProfileAndLevelIndication;
+        PARSER_Data_p->UnsupportedStreamType.Unsupported.STANDARD_ISO_IEC_14496.ASO = (!(1 == 1));
+        PARSER_Data_p->UnsupportedStreamType.Unsupported.STANDARD_ISO_IEC_14496.FMO = (!(1 == 1));
+        PARSER_Data_p->UnsupportedStreamType.Unsupported.STANDARD_ISO_IEC_14496.RedundantSlices = (!(1 == 1));
+        PARSER_Data_p->StreamNotSupported = (1 == 1);
+        ErrorCode = ST_ERROR_FEATURE_NOT_SUPPORTED;
+        return (ErrorCode);
+    }
+    else
+    {
+        PARSER_Data_p->StreamNotSupported = (!(1 == 1));
+        PARSER_Data_p->HasSentUnsupportedEventForCurrentSequence = (!(1 == 1));
+    }
+    PARSER_Data_p->SPSLocalData[SeqParameterSetId].IsAvailable = (1 == 1);
+    if (PARSER_Properties_p->GSB.ReachEndOfStream)
+    {
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_CRASH;
+        PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.TruncatedNAL = (1 == 1);
+    }
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPS_HasChanged = (1 == 1);
+    return (ErrorCode);
+}
+ST_ErrorCode_t h264par_ParseMvcSubsetSPS (const PARSER_Handle_t ParserHandle)
+{
+    U8 ProfileIdc;
+    U8 ConstraintSet0Flag;
+    U8 ConstraintSet1Flag;
+    U8 ConstraintSet2Flag;
+    U8 ConstraintSet3Flag;
+    U8 ConstraintSet4Flag;
+    U8 ConstraintSet5Flag;
+    U8 ReservedZero2Bits;
+    U8 LevelIdc;
+    U8 SeqParameterSetId;
+    U8 PicOrderCntType;
+    U8 Log2MaxFrameNumMinus4;
+    U8 Log2MaxPixOrderCntLsbMinus4;
+    U32 NumRefFramesInPicOrderCntCycle;
+    U32 i, j, k;
+    U8 NumRefFrames;
+    U8 PicWidthInMbsMinus1;
+    U8 PicHeightInMapUnitsMinus1;
+    U8 FrameMbsOnlyFlag;
+    U8 Direct8x8InferenceFlag;
+    BOOL FrameCroppingFlag = (!(1 == 1));
+    U16 PictureDisplayHeightAfterCropping;
+    U32 CropUnitX, CropUnitY;
+    BOOL VuiParametersPresentFlag = (!(1 == 1));
+ BOOL MvcVuiParametersPresentFlag = (!(1 == 1));
+    BOOL BitEqualToOneFlag = (!(1 == 1));
+    U32 ProfileAndLevelIndication;
+    BOOL SeqScalingListPresentFlag = (!(1 == 1));
+    U32 ScalingListNumber;
+    U32 RequestedBits;
+    U32 PicWidthInMbs;
+    U32 PicHeightInMapUnits;
+    U32 NumberOfMbsInAFrame;
+    U32 NumberOfMbsPerSecond;
+    ST_ErrorCode_t ErrorCode = ST_NO_ERROR;
+    H264ParserPrivateData_t * PARSER_Data_p;
+    PARSER_Properties_t * PARSER_Properties_p;
+    PARSER_Data_p = ((H264ParserPrivateData_t *)((PARSER_Properties_t *) ParserHandle)->PrivateData_p);
+    PARSER_Properties_p = (PARSER_Properties_t *) ParserHandle;
+    RequestedBits = GSB_AlignAndGet24Bits(&PARSER_Properties_p->GSB);
+    ProfileIdc = (RequestedBits >> 16) & 0xFF;
+    PARSER_Data_p->ParserGlobalVariable.ProfileIdc = ProfileIdc;
+    ConstraintSet0Flag = (RequestedBits >> 15) & 0x1;
+    ConstraintSet1Flag = (RequestedBits >> 14) & 0x1;
+    ConstraintSet2Flag = (RequestedBits >> 13) & 0x1;
+    ConstraintSet3Flag = (RequestedBits >> 12) & 0x1;
+    ConstraintSet4Flag = (RequestedBits >> 11) & 0x1;
+    ConstraintSet5Flag = (RequestedBits >> 10) & 0x1;
+ ReservedZero2Bits = (RequestedBits >> 8) & 0x3;
+    LevelIdc = RequestedBits & 0xFF;
+    SeqParameterSetId = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+    if (SeqParameterSetId > (32 -1))
+    {
+        return (ErrorCode);
+    }
+    SeqParameterSetId += 32;
+    h264par_InitializeGlobalDecodingContext(SeqParameterSetId, ParserHandle);
+    ProfileAndLevelIndication = ((ConstraintSet5Flag << 21) |
+                                 (ConstraintSet4Flag << 20) |
+                                 (ConstraintSet3Flag << 19) |
+                                 (ConstraintSet2Flag << 18) |
+                                 (ConstraintSet1Flag << 17) |
+                                 (ConstraintSet0Flag << 16) |
+                                 (ProfileIdc << 8) |
+                                 LevelIdc
+                                );
+    if ( ( ((ProfileIdc == 77) || (ProfileIdc == 100)) && (ConstraintSet4Flag != 1)) ||
+     ( (ProfileIdc != 118) && (ProfileIdc != 128)) )
+    {
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+        {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.IsNotSupportedProfileError) = (1 == 1); }
+                                                                                                                           ;
+    }
+    if (ReservedZero2Bits != 0)
+    {
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+        {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.ReservedZero4BitsError) = (1 == 1); }
+                                                                              ;
+    }
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].seq_parameter_set_id = SeqParameterSetId - 32;
+    PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.ProfileAndLevelIndication = ProfileAndLevelIndication;
+    if ( (ProfileIdc == 100) || (ProfileIdc == 118) || (ProfileIdc == 128) )
+    {
+        PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].chroma_format_idc = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+        if(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].chroma_format_idc == 3)
+        {
+            PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].residual_colour_transform_flag = GSB_GetOneBit(&PARSER_Properties_p->GSB);
+        }
+        PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].bit_depth_luma_minus8 = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+        PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].bit_depth_chroma_minus8 = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+        RequestedBits = GSB_GetBits(&PARSER_Properties_p->GSB, 2 );
+        PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].qpprime_y_zero_transform_bypass_flag = (RequestedBits >> 1) & 0x1;
+        PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].seq_scaling_matrix_present_flag = RequestedBits & 0x1;
+        if(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].seq_scaling_matrix_present_flag)
+        {
+            for(ScalingListNumber = 0 ; ScalingListNumber < 8 ; ScalingListNumber++)
+            {
+                SeqScalingListPresentFlag = GSB_GetOneBit(&PARSER_Properties_p->GSB);
+                PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].ScalingMatrix.ScalingListPresentFlag[ScalingListNumber] = SeqScalingListPresentFlag;
+                if(SeqScalingListPresentFlag)
+                {
+                    h264par_GetScalingList(ParserHandle, &(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].ScalingMatrix), ScalingListNumber);
+                }
+                else
+                {
+                    h264par_SetScalingListFallBackA(&(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].ScalingMatrix),ScalingListNumber);
+                }
+            }
+        }
+    }
+    Log2MaxFrameNumMinus4 = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+    if (Log2MaxFrameNumMinus4 > 12)
+    {
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+        {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.Log2MaxFrameNumMinus4RangeError) = (1 == 1); }
+                                                                                         ;
+        Log2MaxFrameNumMinus4 = 12;
+    }
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].log2_max_frame_num_minus4 = Log2MaxFrameNumMinus4;
+    PARSER_Data_p->SPSLocalData[SeqParameterSetId].MaxFrameNum = 1 << (PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].log2_max_frame_num_minus4 + 4);
+    PicOrderCntType = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].pic_order_cnt_type = PicOrderCntType;
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].log2_max_pic_order_cnt_lsb_minus4 = 0;
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].delta_pic_order_always_zero_flag = 0;
+    if (PicOrderCntType == 0)
+    {
+        Log2MaxPixOrderCntLsbMinus4 = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+        if (Log2MaxPixOrderCntLsbMinus4 > 12)
+        {
+            PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+            {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.Log2MaxPicOrderCntLsbMinus4RangeError) = (1 == 1); }
+                                                                                                     ;
+            Log2MaxPixOrderCntLsbMinus4 = 12;
+        }
+        PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].log2_max_pic_order_cnt_lsb_minus4 = Log2MaxPixOrderCntLsbMinus4;
+        PARSER_Data_p->SPSLocalData[SeqParameterSetId].MaxPicOrderCntLsb = 1 << (Log2MaxPixOrderCntLsbMinus4 + 4);
+    }
+    else if (PicOrderCntType == 1)
+    {
+        PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].delta_pic_order_always_zero_flag = GSB_GetBits(&PARSER_Properties_p->GSB, 1);
+        PARSER_Data_p->SPSLocalData[SeqParameterSetId].offset_for_non_ref_pic = GSB_GetSignedExpGolomb(&PARSER_Properties_p->GSB);
+        PARSER_Data_p->SPSLocalData[SeqParameterSetId].offset_for_top_to_bottom_field = GSB_GetSignedExpGolomb(&PARSER_Properties_p->GSB);
+        NumRefFramesInPicOrderCntCycle = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+        if (NumRefFramesInPicOrderCntCycle > 255)
+        {
+            NumRefFramesInPicOrderCntCycle = 0;
+        }
+        PARSER_Data_p->SPSLocalData[SeqParameterSetId].num_ref_frames_in_pic_cnt_cycle = (U8)NumRefFramesInPicOrderCntCycle;
+        for (i = 0; i < NumRefFramesInPicOrderCntCycle; i++)
+        {
+            PARSER_Data_p->SPSLocalData[SeqParameterSetId].offset_for_ref_frame[i] = GSB_GetSignedExpGolomb(&PARSER_Properties_p->GSB);
+        }
+    }
+    NumRefFrames = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+    PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].NumberOfReferenceFrames = NumRefFrames;
+    PARSER_Data_p->SPSLocalData[SeqParameterSetId].gaps_in_frame_num_allowed_flag = GSB_GetOneBit(&PARSER_Properties_p->GSB);
+    PicWidthInMbsMinus1 = (U8)GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+    if ((U8)(PicWidthInMbsMinus1 + 1) == 0)
+    {
+        PicWidthInMbsMinus1 = 0;
+    }
+    PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.Width = 16 * (PicWidthInMbsMinus1 + 1);
+    PicHeightInMapUnitsMinus1 = (U8)GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+    if ((U8)(PicHeightInMapUnitsMinus1 + 1) == 0)
+    {
+        PicHeightInMapUnitsMinus1 = 0;
+    }
+    RequestedBits = GSB_GetBits(&PARSER_Properties_p->GSB, 1);
+    FrameMbsOnlyFlag = (U8) RequestedBits;
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].frame_mbs_only_flag = FrameMbsOnlyFlag;
+    PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.Height = 16 * (2 - FrameMbsOnlyFlag) * (PicHeightInMapUnitsMinus1 + 1);
+    h264par_ComputeMaxFromLevel(LevelIdc, PicWidthInMbsMinus1, PicHeightInMapUnitsMinus1, FrameMbsOnlyFlag, SeqParameterSetId, ConstraintSet4Flag, ParserHandle);
+    if (PARSER_Data_p->SPSLocalData[SeqParameterSetId].MaxDpbSize > 16)
+    {
+       PARSER_Data_p->SPSLocalData[SeqParameterSetId].MaxDpbSize = 16;
+    }
+    for(i = 32; i < (2 * 32); i++)
+ {
+    if(PARSER_Data_p->SPSLocalData[i].IsAvailable)
+    {
+          PARSER_Data_p->SPSLocalData[i].MaxDpbSize = PARSER_Data_p->SPSLocalData[SeqParameterSetId].MaxDpbSize;
+    PARSER_Data_p->GlobalDecodingContextGenericData[i].MaxDecFrameBuffering = PARSER_Data_p->SPSLocalData[SeqParameterSetId].MaxDpbSize;
+          PARSER_Data_p->GlobalDecodingContextSpecificData[i].num_reorder_frames = PARSER_Data_p->SPSLocalData[SeqParameterSetId].MaxDpbSize;
+    }
+    }
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].num_reorder_frames = PARSER_Data_p->SPSLocalData[SeqParameterSetId].MaxDpbSize;
+    PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].MaxDecFrameBuffering = PARSER_Data_p->SPSLocalData[SeqParameterSetId].MaxDpbSize;
+    h264par_InitializeDefaultHRDParameters(SeqParameterSetId, ParserHandle);
+    if (PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.Width *
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.Height >
+        PARSER_Data_p->SPSLocalData[SeqParameterSetId].MaxPixel)
+    {
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_BAD_DISPLAY;
+        {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.WidthRangeError) = (1 == 1); }
+                                                                                         ;
+    }
+    if (PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.Width > PARSER_Data_p->SPSLocalData[SeqParameterSetId].MaxWidth)
+    {
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_BAD_DISPLAY;
+        {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.WidthRangeError) = (1 == 1); }
+                                                                         ;
+    }
+    if (PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.Height > PARSER_Data_p->SPSLocalData[SeqParameterSetId].MaxHeight)
+    {
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_BAD_DISPLAY;
+        {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.HeightRangeError) = (1 == 1); }
+                                                                          ;
+    }
+    if (PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].NumberOfReferenceFrames > PARSER_Data_p->SPSLocalData[SeqParameterSetId].MaxDpbSize)
+    {
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+        {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.NumRefFramesRangeError) = (1 == 1); }
+                                                                             ;
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].NumberOfReferenceFrames = PARSER_Data_p->SPSLocalData[SeqParameterSetId].MaxDpbSize;
+    }
+    if (FrameMbsOnlyFlag == 0)
+    {
+        PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].mb_adaptive_frame_field_flag = GSB_GetBits(&PARSER_Properties_p->GSB, 1);
+    }
+    RequestedBits = GSB_GetBits(&PARSER_Properties_p->GSB, 1);
+    Direct8x8InferenceFlag = (U8) RequestedBits;
+    if ((FrameMbsOnlyFlag == 0) && (Direct8x8InferenceFlag == 0))
+    {
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+        {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.Direct8x8InferenceFlagNullWithFrameMbsOnlyFlagError) = (1 == 1); }
+                                                                                                                             ;
+    }
+    if ((Direct8x8InferenceFlag == 0) && (LevelIdc >= 30))
+    {
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+        {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.Direct8x8InferenceFlagNullWithLevel3OrMoreError) = (1 == 1); }
+                                                                                                                  ;
+    }
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].direct_8x8_inference_flag = Direct8x8InferenceFlag;
+    FrameCroppingFlag = GSB_GetOneBit(&PARSER_Properties_p->GSB);
+    if (FrameCroppingFlag)
+    {
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].FrameCropInPixel.LeftOffset = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].FrameCropInPixel.RightOffset = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].FrameCropInPixel.TopOffset = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].FrameCropInPixel.BottomOffset = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+        switch (PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].chroma_format_idc)
+        {
+            case 1 :
+                CropUnitX = 2;
+                CropUnitY = 2 * ( 2 - FrameMbsOnlyFlag );
+                break;
+            case 2 :
+                CropUnitX = 2;
+                CropUnitY = ( 2 - FrameMbsOnlyFlag );
+                break;
+            case 3 :
+            case 0 :
+            default :
+                CropUnitX = 1;
+                CropUnitY = ( 2 - FrameMbsOnlyFlag );
+                break;
+        }
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].FrameCropInPixel.LeftOffset *= CropUnitX;
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].FrameCropInPixel.RightOffset *= CropUnitX;
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].FrameCropInPixel.TopOffset *= CropUnitY;
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].FrameCropInPixel.BottomOffset *= CropUnitY;
+    }
+    PictureDisplayHeightAfterCropping = PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.Height
+                                        - PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].FrameCropInPixel.TopOffset
+                                        - PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].FrameCropInPixel.BottomOffset;
+    if (PictureDisplayHeightAfterCropping == 720)
+    {
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.ScanType = STVID_SCAN_TYPE_PROGRESSIVE;
+    }
+    if (PictureDisplayHeightAfterCropping > 1080)
+    {
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].FrameCropInPixel.BottomOffset =
+                PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.Height - 1080;
+    }
+    VuiParametersPresentFlag = GSB_GetOneBit(&PARSER_Properties_p->GSB);
+    if (VuiParametersPresentFlag)
+    {
+        h264par_ParseVUI(SeqParameterSetId, ParserHandle);
+    }
+    BitEqualToOneFlag = GSB_GetOneBit(&PARSER_Properties_p->GSB);
+ if(BitEqualToOneFlag == 0)
+ {
+ }
+ {
+  PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].num_views_minus1 = (U32)GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+  for( i = 0; i <= PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].num_views_minus1; i++ )
+  {
+   PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].view_id[i] = (U32)GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+  }
+  for( i = 1; i <= PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].num_views_minus1; i++ )
+  {
+   PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].num_anchor_refs_l0[i] = (U32)GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+   for( j = 0; j < PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].num_anchor_refs_l0[i]; j++ )
+   {
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].anchor_ref_l0[i][j] = (U32)GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+   }
+   PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].num_anchor_refs_l1[i] = (U32)GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+   for( j = 0; j < PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].num_anchor_refs_l1[i]; j++ )
+   {
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].anchor_ref_l1[i][j] = (U32)GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+   }
+  }
+  for( i = 1; i <= PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].num_views_minus1; i++ )
+  {
+   PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].num_non_anchor_refs_l0[i] = (U32)GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+   for( j = 0; j < PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].num_non_anchor_refs_l0[i]; j++ )
+   {
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].non_anchor_ref_l0[i][j] = (U32)GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+   }
+   PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].num_non_anchor_refs_l1[i] = (U32)GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+   for( j = 0; j < PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].num_non_anchor_refs_l1[i]; j++ )
+   {
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].non_anchor_ref_l1[i][j] = (U32)GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+   }
+  }
+  {
+   U8 num_level_values_signalled_minus1;
+   U16 level_idc[4];
+   U16 num_applicable_ops_minus1[4];
+   U8 applicable_op_temporal_id[4][4];
+   U16 applicable_op_num_target_views_minus1[4][4];
+   U16 applicable_op_num_views_minus1[4][4];
+   U16 applicable_op_target_view_id[4][4][4];
+   num_level_values_signalled_minus1 = (U32)GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+   for(i = 0; i <= num_level_values_signalled_minus1; i++)
+   {
+    level_idc[i] = GSB_GetBits(&PARSER_Properties_p->GSB, 8);
+    num_applicable_ops_minus1[i] = (U32)GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+    for( j = 0; j <= num_applicable_ops_minus1[i]; j++)
+    {
+     applicable_op_temporal_id[i][j] = GSB_GetBits(&PARSER_Properties_p->GSB, 3);
+     applicable_op_num_target_views_minus1[i][j] = (U32)GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+     for( k = 0; k <= applicable_op_num_target_views_minus1[i][j]; k++)
+     {
+       applicable_op_target_view_id[i][j][k] = (U32)GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+     }
+     applicable_op_num_views_minus1[i][j] = (U32)GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+    }
+   }
+  }
+  for(i = 0; i <= PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].num_views_minus1; i++ )
+  {
+   U16 view_id = PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].view_id[i];
+   PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].VOIndex[view_id] = i;
+  }
+ }
+ MvcVuiParametersPresentFlag = GSB_GetOneBit(&PARSER_Properties_p->GSB);
+    if (MvcVuiParametersPresentFlag)
+    {
+    }
+    if (PARSER_Properties_p->ForcedFrameRate != 0)
+    {
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.FrameRate = PARSER_Properties_p->ForcedFrameRate;
+    }
+    else
+    {
+        if (PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.FrameRate == 1010)
+        {
+                PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.FrameRate = PARSER_Properties_p->DefaultFrameRate;
+        }
+    }
+    PicWidthInMbs = (PicWidthInMbsMinus1 + 1);
+    PicHeightInMapUnits = (2 - FrameMbsOnlyFlag) * (PicHeightInMapUnitsMinus1 + 1);
+    NumberOfMbsInAFrame = PicWidthInMbs * PicHeightInMapUnits;
+    NumberOfMbsPerSecond = NumberOfMbsInAFrame * PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.FrameRate;
+    NumberOfMbsPerSecond = NumberOfMbsPerSecond / 1000;
+    if ((PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].SequenceInfo.Width > 1920) || ((LevelIdc > 41) && (NumberOfMbsPerSecond > 245760)))
+    {
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_CRASH;
+        {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.LevelIdcRangeError) = (1 == 1); }
+                                                                                                 ;
+        PARSER_Data_p->UnsupportedStreamType.UnsupportedProfileAndLevelIndication = ProfileAndLevelIndication;
+        PARSER_Data_p->UnsupportedStreamType.Unsupported.STANDARD_ISO_IEC_14496.ASO = (!(1 == 1));
+        PARSER_Data_p->UnsupportedStreamType.Unsupported.STANDARD_ISO_IEC_14496.FMO = (!(1 == 1));
+        PARSER_Data_p->UnsupportedStreamType.Unsupported.STANDARD_ISO_IEC_14496.RedundantSlices = (!(1 == 1));
+        PARSER_Data_p->StreamNotSupported = (1 == 1);
+        ErrorCode = ST_ERROR_FEATURE_NOT_SUPPORTED;
+        return (ErrorCode);
+    }
+    else
+    {
+        PARSER_Data_p->StreamNotSupported = (!(1 == 1));
+        PARSER_Data_p->HasSentUnsupportedEventForCurrentSequence = (!(1 == 1));
+    }
+    PARSER_Data_p->SPSLocalData[SeqParameterSetId].IsAvailable = (1 == 1);
+    if (PARSER_Properties_p->GSB.ReachEndOfStream)
+    {
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_CRASH;
+        PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.TruncatedNAL = (1 == 1);
+    }
+    PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPS_HasChanged = (1 == 1);
+    return (ErrorCode);
+}
+void h264par_ParseSPSExtension (const PARSER_Handle_t ParserHandle)
+{
+    U8 SeqParameterSetId;
+    U8 AuxFormatIdc;
+    U8 BitDepthAuxMinus8;
+    PARSER_Properties_t * PARSER_Properties_p = (PARSER_Properties_t *) ParserHandle;
+    H264ParserPrivateData_t * PARSER_Data_p;
+    PARSER_Data_p = ((H264ParserPrivateData_t *)((PARSER_Properties_t *) ParserHandle)->PrivateData_p);
+    if (PARSER_Data_p->ParserGlobalVariable.ProfileIdc != 100)
+    {
+      return;
+    }
+    SeqParameterSetId = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+    if (SeqParameterSetId > (32 -1))
+    {
+        return;
+    }
+    AuxFormatIdc = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+    if (AuxFormatIdc != 0)
+    {
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_INFORMATION;
+        {(PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.AuxCodedPicturePresent) = (1 == 1); }
+                                                                                                ;
+        BitDepthAuxMinus8 = GSB_GetUnSignedExpGolomb(&PARSER_Properties_p->GSB);
+        GSB_SkipBits(&PARSER_Properties_p->GSB, 19);
+        GSB_SkipBits(&PARSER_Properties_p->GSB, BitDepthAuxMinus8 + BitDepthAuxMinus8);
+    }
+    GSB_SkipBits(&PARSER_Properties_p->GSB, 1);
+    if (PARSER_Properties_p->GSB.ReachEndOfStream)
+    {
+        PARSER_Data_p->GlobalDecodingContextGenericData[SeqParameterSetId].ParsingError = VIDCOM_ERROR_LEVEL_CRASH;
+        PARSER_Data_p->GlobalDecodingContextSpecificData[SeqParameterSetId].SPSError.TruncatedNAL = (1 == 1);
+    }
+}
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/gcc.target/sh/torture/pr58475.c gcc-st40-4.8.2.140205/gcc/testsuite/gcc.target/sh/torture/pr58475.c
--- gcc-gnu-4.8.2/gcc/testsuite/gcc.target/sh/torture/pr58475.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/gcc.target/sh/torture/pr58475.c	2013-09-20 12:22:25.000000000 +0200
@@ -0,0 +1,15 @@
+/* { dg-do compile { target "sh*-*-*" } } */
+
+int
+kerninfo(int __bsx, double tscale)
+{
+ return (
+	 (int)(__extension__
+	       ({
+		 ((((__bsx) & 0xff000000u) >> 24)
+		  | (((__bsx) & 0x00ff0000) >> 8)
+		  | (((__bsx) & 0x0000ff00) << 8)
+		  | (((__bsx) & 0x000000ff) << 24)
+		  ); }))
+	       * tscale);
+}
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/g++.dg/eh/postreload.C gcc-st40-4.8.2.140205/gcc/testsuite/g++.dg/eh/postreload.C
--- gcc-gnu-4.8.2/gcc/testsuite/g++.dg/eh/postreload.C	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/g++.dg/eh/postreload.C	2013-05-28 13:15:34.000000000 +0200
@@ -0,0 +1,35 @@
+// This testcase failed on sh, because stack offset to access i was shared
+// between handler and main.
+// { dg-do run }
+// { dg-options "-O2" }
+
+extern void abort (void);
+extern void exit (int);
+
+void
+bar (int *i, int *tab) __attribute__ ((weak,noinline)); 
+
+main()
+{
+  int i = 123;
+  int tab[47];
+
+  bar (&i, tab);
+
+  try
+    {
+      throw 1;
+    }
+  catch (...)
+    {
+      return 0;
+    }
+
+  abort ();
+}
+
+void
+bar (int *i, int *tab)
+{
+}
+
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/g++.dg/other/error27.C gcc-st40-4.8.2.140205/gcc/testsuite/g++.dg/other/error27.C
--- gcc-gnu-4.8.2/gcc/testsuite/g++.dg/other/error27.C	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/testsuite/g++.dg/other/error27.C	2013-05-28 13:15:34.000000000 +0200
@@ -1,5 +1,4 @@
 // PR c++/35332
-// { dg-do compile }
 // { dg-options "-fno-finite-math-only" { target sh*-*-* } }
 
 void foo (double x, double y)
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/lib/c-torture.exp gcc-st40-4.8.2.140205/gcc/testsuite/lib/c-torture.exp
--- gcc-gnu-4.8.2/gcc/testsuite/lib/c-torture.exp	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/testsuite/lib/c-torture.exp	2013-05-28 13:15:34.000000000 +0200
@@ -126,7 +126,8 @@
 #
 proc c-torture-execute { sources args } {
     global tmpdir tool srcdir output compiler_conditional_xfail_data
-
+    global additional_linker_flag
+    
     # Use the first source filename given as the filename under test.
     set src [lindex $sources 0]
 
@@ -135,6 +136,11 @@
     } else {
 	set additional_flags ""
     }
+
+    if { [info exists additional_linker_flag] } {
+       lappend additional_flags $additional_linker_flag
+    }
+
     # Check for alternate driver.
     if [file exists [file rootname $src].x] {
 	verbose "Using alternate driver [file rootname [file tail $src]].x" 2
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/lib/scanobj.exp gcc-st40-4.8.2.140205/gcc/testsuite/lib/scanobj.exp
--- gcc-gnu-4.8.2/gcc/testsuite/lib/scanobj.exp	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/gcc/testsuite/lib/scanobj.exp	2013-05-28 13:15:34.000000000 +0200
@@ -0,0 +1,138 @@
+# Reset data used to avoid unecessary recompilation of same file
+proc dg-scan-obj-reset {} {
+    global saved_output_filename
+    global saved_output_datafile
+
+    if [info exists saved_output_filename] {
+        set saved_output_filename 0
+    }
+    if [info exists saved_output_datafile] {
+        set saved_output_datafile 0
+    }
+}
+
+
+# Scan a symbol in an object file.  If it is present and POSITIVE
+# is non-zero, or it is not present and POSITIVE is zero, the test
+# passes.  The ORIG_ARGS is the list of arguments provided by dg-final
+# to scan-assembler.
+# The first element in ORIG_ARGS is the regular expression to look for
+# in the file.
+# The secund element in ORIG_ARGS is the begin pattern to look for in the file.
+# The third element in ORIG_ARGS is the end pattern to look for in the file.
+# The fourth element in ORIG_ARGS, if present, is the object file.
+# The last element in ORIG_ARGS, if present, is a DejaGNU target selector.
+proc dg-scan-obj { name positive testcase orig_args } {
+    global GCC_UNDER_TEST
+    global objdump
+    global base_dir
+    global saved_output_filename
+    global saved_output_datafile
+
+    if { [llength $orig_args] >= 5 } {
+	switch [dg-process-target [lindex $orig_args 4]] {
+	    "S" { }
+	    "N" { return }
+	    "F" { setup_xfail "*-*-*" }
+	    "P" { }
+	}
+    }
+
+    # Find objdump like we find g++ in g++.exp.
+    if ![info exists objdump]  {
+        set objdump "objdump"
+        regsub "(.*)gcc$" $GCC_UNDER_TEST {\1objdump} objdump
+	set objdump [findfile $objdump $objdump \
+                [findfile $base_dir/../../../binutils/objdump \
+                     $base_dir/../../../binutils/objdump \
+                     [findfile $base_dir/../../objdump $base_dir/../../objdump \
+                          [findfile $base_dir/objdump $base_dir/objdump \
+                               [transform objdump]]]]]
+	verbose -log "objdump is $objdump"
+    }
+
+    # what is the object filename?
+    if { [llength $orig_args] >= 4 } {
+        # object file is given by the user
+        set objfile [lindex $orig_args 3]
+    } else {
+        # object file is the one from the testcase
+        set objfile "[file rootname [file tail [lindex $testcase 0]]].o"
+    }
+    set objfile [string trim $objfile]
+
+    set output_file "[glob -nocomplain $objfile]"
+    if { $output_file == "" } {
+	fail "$name $orig_args: object file does not exist"
+	return
+    }
+
+    if {[info exists saved_output_filename] &&
+        [info exists saved_output_datafile] &&
+        $saved_output_filename == $output_file} {
+        # get data from previous step
+        set output $saved_output_datafile
+    } else {
+        # get new data
+        set fd [open "| $objdump -d $output_file" r]
+        set output [read $fd]
+        close $fd
+        set saved_output_filename $output_file
+        set saved_output_datafile $output
+    }
+
+    set pattern [string trim [lindex $orig_args 0]]
+    set begin   [string trim [lindex $orig_args 1]]
+    set end     [string trim [lindex $orig_args 2]]
+
+    set match 0
+    set inside 0
+    set data [split $output "\n"]
+    foreach line $data {
+        if { $inside == "1" } {
+            # Detect pattern
+            if { [regexp $pattern $line] } {
+                set match 1
+                break
+            }
+            # Detect end
+            if { [regexp $end $line] } {
+                break
+            }
+        }
+        # Detect begin
+        if { [regexp $begin $line] } {
+            set inside 1
+        }
+    }
+
+    if { $match == $positive } {
+	pass "$testcase $name $orig_args"
+    } else {
+	fail "$testcase $name $orig_args"
+    }
+}
+
+
+# Look for a symbol in an object file, invoked via dg-final.
+# See dg-scan-obj for details.
+
+proc scan-obj { args } {
+    # This assumes that we are two frames down from dg-test, and that
+    # it still stores the filename of the testcase in a local variable "name".
+    upvar 2 name testcase
+
+    dg-scan-obj "scan-obj" 1 $testcase $args
+}
+
+
+# Check that a symbol is not present in an object file, invoked via dg-final.
+# See dg-scan-obj for details.
+
+proc scan-obj-not { args } {
+    # This assumes that we are two frames down from dg-test, and that
+    # it still stores the filename of the testcase in a local variable "name".
+    upvar 2 name testcase
+
+    dg-scan-obj "scan-obj-not" 0 $testcase $args
+}
diff -ruN gcc-gnu-4.8.2/gcc/testsuite/lib/target-supports.exp gcc-st40-4.8.2.140205/gcc/testsuite/lib/target-supports.exp
--- gcc-gnu-4.8.2/gcc/testsuite/lib/target-supports.exp	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/testsuite/lib/target-supports.exp	2013-05-28 13:15:34.000000000 +0200
@@ -499,6 +499,13 @@
 	return 0
     }
 
+    # There is no profiling support on SH when running on the simu.
+    if { [istarget sh-superh-elf] } {
+	if [board_info target exists is_simulator] {
+	    return 0
+	}
+    }
+
     # uClibc does not have gcrt1.o.
     if { [check_effective_target_uclibc]
 	 && ($test_what == "-p" || $test_what == "-pg") } {
@@ -4376,6 +4383,7 @@
 	     || [istarget s390*-*-*] 
 	     || [istarget powerpc*-*-*]
 	     || [istarget crisv32-*-*] || [istarget cris-*-*]
+	     || [istarget sh*-superh-elf]
 	     || ([istarget sparc*-*-*] && [check_effective_target_sparc_v9])
 	     || [check_effective_target_mips_llsc] } {
            set et_sync_int_long_saved 1
@@ -4458,6 +4466,15 @@
     }]
 }
 
+# Return true if this is a target supports complex.h
+
+proc check_effective_target_complex { } {
+    return [check_no_compiler_messages complex assembly {
+	#include <complex.h>
+	main() { complex double a; return 0; }
+    }]
+}
+
 # Return 1 if
 #   (a) an error of a few ULP is expected in string to floating-point
 #       conversion functions; and
diff -ruN gcc-gnu-4.8.2/gcc/toplev.c gcc-st40-4.8.2.140205/gcc/toplev.c
--- gcc-gnu-4.8.2/gcc/toplev.c	2013-06-06 12:32:56.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/toplev.c	2013-06-07 09:56:46.000000000 +0200
@@ -606,6 +606,7 @@
       process_pending_assemble_externals ();
    }
 
+#ifndef HAVE_LTO_PLUGIN 
   /* Emit LTO marker if LTO info has been previously emitted.  This is
      used by collect2 to determine whether an object file contains IL.
      We used to emit an undefined reference here, but this produces
@@ -643,6 +644,7 @@
 #endif
         }
     }
+#endif
 
   /* Attach a special .ident directive to the end of the file to identify
      the version of GCC which compiled this code.  The format of the .ident
diff -ruN gcc-gnu-4.8.2/gcc/tree.c gcc-st40-4.8.2.140205/gcc/tree.c
--- gcc-gnu-4.8.2/gcc/tree.c	2013-06-06 12:32:56.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/tree.c	2013-06-07 09:56:46.000000000 +0200
@@ -1589,7 +1589,10 @@
 {
   switch (TREE_CODE (type))
     {
-    case INTEGER_TYPE: case ENUMERAL_TYPE: case BOOLEAN_TYPE:
+    case BOOLEAN_TYPE:
+      return boolean_true_node;
+    
+    case INTEGER_TYPE: case ENUMERAL_TYPE:
     case POINTER_TYPE: case REFERENCE_TYPE:
     case OFFSET_TYPE:
       return build_int_cst (type, 1);
@@ -1628,7 +1631,10 @@
 {
   switch (TREE_CODE (type))
     {
-    case INTEGER_TYPE: case ENUMERAL_TYPE: case BOOLEAN_TYPE:
+    case BOOLEAN_TYPE:
+      return boolean_false_node;
+    
+    case INTEGER_TYPE: case ENUMERAL_TYPE:
     case POINTER_TYPE: case REFERENCE_TYPE:
     case OFFSET_TYPE: case NULLPTR_TYPE:
       return build_int_cst (type, 0);
diff -ruN gcc-gnu-4.8.2/gcc/tree-chrec.c gcc-st40-4.8.2.140205/gcc/tree-chrec.c
--- gcc-gnu-4.8.2/gcc/tree-chrec.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/tree-chrec.c	2013-07-08 14:52:23.000000000 +0200
@@ -1348,11 +1348,13 @@
 		       fold_convert (type, TREE_OPERAND (chrec, 1)));
   /* Similar perform the trick that (signed char)((int)x + 2) can be
      narrowed to (signed char)((unsigned char)x + 2).  */
+  /* Similarly, (unsigned char)((int)x + 2) with x an unsigned char 
+     is simply narrowed to (unsigned char)((unsigned char)x + 2) */
   else if (use_overflow_semantics
 	   && TREE_CODE (chrec) == POLYNOMIAL_CHREC
 	   && TREE_CODE (ct) == INTEGER_TYPE
 	   && TREE_CODE (type) == INTEGER_TYPE
-	   && TYPE_OVERFLOW_UNDEFINED (type)
+	   && TYPE_MODE (type) != TYPE_MODE (ct)
 	   && TYPE_PRECISION (type) < TYPE_PRECISION (ct))
     {
       tree utype = unsigned_type_for (type);
diff -ruN gcc-gnu-4.8.2/gcc/tree-inline.c gcc-st40-4.8.2.140205/gcc/tree-inline.c
--- gcc-gnu-4.8.2/gcc/tree-inline.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/tree-inline.c	2013-05-28 13:15:34.000000000 +0200
@@ -3849,9 +3849,9 @@
 	  /* PR 20090218-1_0.c. Body can be provided by another module. */
 	  && (reason != CIF_BODY_NOT_AVAILABLE || !flag_generate_lto))
 	{
-	  error ("inlining failed in call to always_inline %q+F: %s", fn,
-		 cgraph_inline_failed_string (reason));
-	  error ("called from here");
+	  warning (OPT_Winline, "inlining failed in call to %q+F: %s",
+		   fn, cgraph_inline_failed_string (reason));
+	  warning (OPT_Winline, "called from here");
 	}
       else if (warn_inline
 	       && DECL_DECLARED_INLINE_P (fn)
diff -ruN gcc-gnu-4.8.2/gcc/tree-scalar-evolution.c gcc-st40-4.8.2.140205/gcc/tree-scalar-evolution.c
--- gcc-gnu-4.8.2/gcc/tree-scalar-evolution.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/tree-scalar-evolution.c	2013-07-08 14:52:23.000000000 +0200
@@ -1767,13 +1767,15 @@
       if (TREE_CODE (type) == INTEGER_TYPE
 	  && TREE_CODE (TREE_TYPE (rhs1)) == INTEGER_TYPE
 	  && TYPE_PRECISION (type) < TYPE_PRECISION (TREE_TYPE (rhs1))
-	  && TYPE_OVERFLOW_UNDEFINED (type)
+	  && TYPE_MODE (type) != TYPE_MODE (TREE_TYPE (rhs1))
 	  && TREE_CODE (rhs1) == SSA_NAME
 	  && (def = SSA_NAME_DEF_STMT (rhs1))
 	  && is_gimple_assign (def)
 	  && TREE_CODE_CLASS (gimple_assign_rhs_code (def)) == tcc_binary
 	  && TREE_CODE (gimple_assign_rhs2 (def)) == INTEGER_CST)
 	{
+         /* type might already be unsigned, in that case type and utype 
+	     are the same : (unsigned char)((unsigned char)x + 2) */
 	  tree utype = unsigned_type_for (type);
 	  chrec1 = interpret_rhs_expr (loop, at_stmt, utype,
 				       gimple_assign_rhs1 (def),
diff -ruN gcc-gnu-4.8.2/gcc/tree-ssa-ccp.c gcc-st40-4.8.2.140205/gcc/tree-ssa-ccp.c
--- gcc-gnu-4.8.2/gcc/tree-ssa-ccp.c	2013-10-16 16:17:23.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/tree-ssa-ccp.c	2013-10-17 12:15:29.000000000 +0200
@@ -2,6 +2,7 @@
    Copyright (C) 2000-2013 Free Software Foundation, Inc.
    Adapted from original RTL SSA-CCP by Daniel Berlin <dberlin@dberlin.org>
    Adapted to GIMPLE trees by Diego Novillo <dnovillo@redhat.com>
+   Copyright (c) 2010 STMicroelectronics.
 
 This file is part of GCC.
 
@@ -383,6 +384,9 @@
   if (!HONOR_NANS (mode)
       && REAL_VALUE_ISNAN (d))
     {
+      if (warn_non_finite_math)
+	warning (OPT_Wnon_finite_math,
+		 "non-finite operation %E not honored", val->value);
       val->lattice_val = UNDEFINED;
       val->value = NULL;
       return;
diff -ruN gcc-gnu-4.8.2/gcc/tree-ssa-math-opts.c gcc-st40-4.8.2.140205/gcc/tree-ssa-math-opts.c
--- gcc-gnu-4.8.2/gcc/tree-ssa-math-opts.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/tree-ssa-math-opts.c	2013-05-28 13:15:34.000000000 +0200
@@ -1414,7 +1414,8 @@
 		CASE_FLT_FN (BUILT_IN_SIN):
 		CASE_FLT_FN (BUILT_IN_CEXPI):
 		  /* Make sure we have either sincos or cexp.  */
-		  if (!TARGET_HAS_SINCOS && !TARGET_C99_FUNCTIONS)
+		  if (!TARGET_HAS_SINCOS && !TARGET_C99_FUNCTIONS
+		      && flag_cse_sincos)
 		    break;
 
 		  arg = gimple_call_arg (stmt, 0);
diff -ruN gcc-gnu-4.8.2/gcc/varasm.c gcc-st40-4.8.2.140205/gcc/varasm.c
--- gcc-gnu-4.8.2/gcc/varasm.c	2013-06-06 12:32:56.000000000 +0200
+++ gcc-st40-4.8.2.140205/gcc/varasm.c	2013-06-07 09:56:46.000000000 +0200
@@ -1611,14 +1611,14 @@
      Note that we still need to align to DECL_ALIGN, as above,
      because ASM_OUTPUT_MAX_SKIP_ALIGN might not do any alignment at all.  */
   if (! DECL_USER_ALIGN (decl)
-      && align_functions_log > align
+      && ASM_ALIGN_FUNCTION_LOG (decl) > align
       && optimize_function_for_speed_p (cfun))
     {
 #ifdef ASM_OUTPUT_MAX_SKIP_ALIGN
       ASM_OUTPUT_MAX_SKIP_ALIGN (asm_out_file,
 				 align_functions_log, align_functions - 1);
 #else
-      ASM_OUTPUT_ALIGN (asm_out_file, align_functions_log);
+      ASM_OUTPUT_ALIGN (asm_out_file, ASM_ALIGN_FUNCTION_LOG (decl));
 #endif
     }
 
diff -ruN gcc-gnu-4.8.2/.gitignore gcc-st40-4.8.2.140205/.gitignore
--- gcc-gnu-4.8.2/.gitignore	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/.gitignore	1970-01-01 01:00:00.000000000 +0100
@@ -1,42 +0,0 @@
-*.diff
-*.patch
-*.orig
-*.rej
-
-*~
-.#*
-*#
-
-*.flt
-*.gmo
-*.info
-*.la
-*.lo
-*.o
-*.pyc
-*.tmp
-
-.deps
-.libs
-
-autom4te.cache
-config.cache
-config.h
-config.intl
-config.log
-config.status
-libtool
-POTFILES
-*-POTFILES
-
-TAGS
-TAGS.sub
-
-.gdbinit
-.gdb_history
-
-# ignore core files, but not java/net/protocol/core/
-core
-!core/
-
-lost+found
diff -ruN gcc-gnu-4.8.2/include/ChangeLog.STM gcc-st40-4.8.2.140205/include/ChangeLog.STM
--- gcc-gnu-4.8.2/include/ChangeLog.STM	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/include/ChangeLog.STM	2013-05-28 13:18:08.000000000 +0200
@@ -0,0 +1,3 @@
+2006-03-27  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* libiberty.h: Add support for cygpath.c.
diff -ruN gcc-gnu-4.8.2/include/libiberty.h gcc-st40-4.8.2.140205/include/libiberty.h
--- gcc-gnu-4.8.2/include/libiberty.h	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/include/libiberty.h	2013-05-28 13:18:08.000000000 +0200
@@ -678,9 +678,21 @@
    (char *) memcpy (libiberty_nptr, libiberty_optr, libiberty_len))
 #endif
 
+#ifdef __MINGW32__
+/* Reassign the pointer PATH without freeing anything.  */
+extern char *cygpath (const char *path);
+#define CYGPATH(path) do {path = cygpath (path);} while(0)
+
+/* Reassign the pointer PATH and free the previous content.  */
+extern void cygpath_replace (char **path);
+#else
+/* If these were properly empty statements then there might be warnings
+   which would kill a -Werror build.  */
+#define CYGPATH(path) do {} while (0)
+#endif
+
 #ifdef __cplusplus
 }
 #endif
 
-
 #endif /* ! defined (LIBIBERTY_H) */
diff -ruN gcc-gnu-4.8.2/libcpp/ChangeLog.STM gcc-st40-4.8.2.140205/libcpp/ChangeLog.STM
--- gcc-gnu-4.8.2/libcpp/ChangeLog.STM	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libcpp/ChangeLog.STM	2013-05-28 13:17:25.000000000 +0200
@@ -0,0 +1,12 @@
+2009-06-10  Antony King  <antony.king@st.com>
+
+	* mkdeps.c (deps_write): Use ISALPHA instead of isalpha.
+	(deps_phony_targets): Likewise.
+
+2007-08-14  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* mkdeps.c (deps_write): Convert paths to Cygwin format on MinGW,
+	if GCC_CYGWIN_DEPS environment variable is set.
+	(deps_phony_targets): Likewise.
+
+
diff -ruN gcc-gnu-4.8.2/libcpp/mkdeps.c gcc-st40-4.8.2.140205/libcpp/mkdeps.c
--- gcc-gnu-4.8.2/libcpp/mkdeps.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/libcpp/mkdeps.c	2013-05-28 13:17:25.000000000 +0200
@@ -320,6 +320,17 @@
 	      column++;
 	    }
 	}
+#ifdef __MINGW32__
+      if (getenv ("GCC_CYGWIN_DEPS") != NULL
+	  && ISALPHA (d->targetv[i][0])
+	  && d->targetv[i][1] == ':')
+	{
+	  fputs ("/cygdrive/", fp);
+	  fputc (d->targetv[i][0], fp);
+	  fputs (d->targetv[i]+2, fp);
+	}
+      else
+#endif
       fputs (d->targetv[i], fp);
     }
 
@@ -340,6 +351,17 @@
 	  putc (' ', fp);
 	  column++;
 	}
+#ifdef __MINGW32__
+      if (getenv ("GCC_CYGWIN_DEPS") != NULL
+	  && ISALPHA (d->depv[i][0])
+	  && d->depv[i][1] == ':')
+	{
+	  fputs ("/cygdrive/", fp);
+	  fputc (d->depv[i][0], fp);
+	  fputs (d->depv[i]+2, fp);
+	}
+      else
+#endif
       fputs (d->depv[i], fp);
     }
   putc ('\n', fp);
@@ -353,6 +375,17 @@
   for (i = 1; i < d->ndeps; i++)
     {
       putc ('\n', fp);
+#ifdef __MINGW32__
+      if (getenv ("GCC_CYGWIN_DEPS") != NULL
+	  && ISALPHA (d->depv[i][0])
+	  && d->depv[i][1] == ':')
+	{
+	  fputs ("/cygdrive/", fp);
+	  fputc (d->depv[i][0], fp);
+	  fputs (d->depv[i]+2, fp);
+	}
+      else
+#endif
       fputs (d->depv[i], fp);
       putc (':', fp);
       putc ('\n', fp);
diff -ruN gcc-gnu-4.8.2/libgcc/ChangeLog.STM gcc-st40-4.8.2.140205/libgcc/ChangeLog.STM
--- gcc-gnu-4.8.2/libgcc/ChangeLog.STM	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libgcc/ChangeLog.STM	2013-08-02 11:04:10.000000000 +0200
@@ -0,0 +1,24 @@
+2012-11-28  Laurent Alfonsi  <laurent.alfonsi@st.com>
+
+        * config/sh/lib1funcs.S (movmem): Add local labels for pc-relative
+        operations.
+
+2013-04-30  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/ieee-754-sf.S: Move here
+	Don't include insn-constants.h
+	* config/sh/ieee-754-ff.S: Likewise.
+
+2013-02-12  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/supervisor-atomic.S: New file.
+	* config/sh/supervisor-sync.S: Rename.
+	* config/sh/t-superh (LIB2ADD): Add supervisor-sync.S
+
+2012-11-13  Christian Bruel  <christian.bruel@st.com>
+
+	* config/sh/lib1funcs.S (movmem): Remove strmem aliases.
+
+2009-07-27  Christian Bruel  <christian.bruel@st.com>
+
+        * config.host (extra_parts): Set for sh*-*-linux.
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/crt1.S gcc-st40-4.8.2.140205/libgcc/config/sh/crt1.S
--- gcc-gnu-4.8.2/libgcc/config/sh/crt1.S	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/crt1.S	2013-05-28 13:16:16.000000000 +0200
@@ -1,6 +1,8 @@
 /* Copyright (C) 2000-2013 Free Software Foundation, Inc.
    This file was pretty much copied from newlib.
 
+   Copyright (c) 2006  STMicroelectronics.
+
 This file is part of GCC.
 
 GCC is free software; you can redistribute it and/or modify it
@@ -33,7 +35,7 @@
 /* Label at the highest stack address where the stack grows from */
 __timer_stack:
 #endif /* MMU_SUPPORT */
-	
+
 	/* ;----------------------------------------
 	Normal newlib crt1.S */
 
@@ -420,7 +422,7 @@
 #endif /* MMU_SUPPORT */
 
 	pt/l	.Lzero_bss_loop, tr0
-	pt/l	_init, tr5
+	pt/l	__init, tr5
 	pt/l	___setup_argv_and_call_main, tr6
 	pt/l	_exit, tr7
 
@@ -452,7 +454,7 @@
 
 	! arrange for exit to call fini
 	pt/l	_atexit, tr1
-	LOAD_ADDR (_fini, r2)
+	LOAD_ADDR (__fini, r2)
 	blink	tr1, r18
 
 	! call init
@@ -850,9 +852,9 @@
 atexit_k:
 	.long	_atexit
 init_k:
-	.long	_init
+	.long	__init
 fini_k:
-	.long	_fini
+	.long	__fini
 #ifdef VBR_SETUP
 old_vbr_k:
 	.long	old_vbr
@@ -1168,201 +1170,5 @@
 handler_exit_k:
 	.long _exit
 	.align 2
-! Simulated compile of trap handler.
-	.section	.debug_abbrev,"",@progbits
-.Ldebug_abbrev0:
-	.section	.debug_info,"",@progbits
-.Ldebug_info0:
-	.section	.debug_line,"",@progbits
-.Ldebug_line0:
-	.text
-.Ltext0:
-	.align 5
-	.type	__superh_trap_handler,@function
-__superh_trap_handler:
-.LFB1:
-	mov.l	r14,@-r15
-.LCFI0:
-	add	#-4,r15
-.LCFI1:
-	mov	r15,r14
-.LCFI2:
-	mov.l	r4,@r14
-	lds	r1, pr
-	add	#4,r14
-	mov	r14,r15
-	mov.l	@r15+,r14
-	rts	
-	nop
-.LFE1:
-.Lfe1:
-	.size	__superh_trap_handler,.Lfe1-__superh_trap_handler
-	.section	.debug_frame,"",@progbits
-.Lframe0:
-	.ualong	.LECIE0-.LSCIE0
-.LSCIE0:
-	.ualong	0xffffffff
-	.byte	0x1
-	.string	""
-	.uleb128 0x1
-	.sleb128 -4
-	.byte	0x11
-	.byte	0xc
-	.uleb128 0xf
-	.uleb128 0x0
-	.align 2
-.LECIE0:
-.LSFDE0:
-	.ualong	.LEFDE0-.LASFDE0
-.LASFDE0:
-	.ualong	.Lframe0
-	.ualong	.LFB1
-	.ualong	.LFE1-.LFB1
-	.byte	0x4
-	.ualong	.LCFI0-.LFB1
-	.byte	0xe
-	.uleb128 0x4
-	.byte	0x4
-	.ualong	.LCFI1-.LCFI0
-	.byte	0xe
-	.uleb128 0x8
-	.byte	0x8e
-	.uleb128 0x1
-	.byte	0x4
-	.ualong	.LCFI2-.LCFI1
-	.byte	0xd
-	.uleb128 0xe
-	.align 2
-.LEFDE0:
-	.text
-.Letext0:
-	.section	.debug_info
-	.ualong	0xb3
-	.uaword	0x2
-	.ualong	.Ldebug_abbrev0
-	.byte	0x4
-	.uleb128 0x1
-	.ualong	.Ldebug_line0
-	.ualong	.Letext0
-	.ualong	.Ltext0
-	.string	"trap_handler.c"
-	.string	"xxxxxxxxxxxxxxxxxxxxxxxxxxxx"
-	.string	"GNU C 3.2 20020529 (experimental)"
-	.byte	0x1
-	.uleb128 0x2
-	.ualong	0xa6
-	.byte	0x1
-	.string	"_superh_trap_handler"
-	.byte	0x1
-	.byte	0x2
-	.byte	0x1
-	.ualong	.LFB1
-	.ualong	.LFE1
-	.byte	0x1
-	.byte	0x5e
-	.uleb128 0x3
-	.string	"trap_reason"
-	.byte	0x1
-	.byte	0x1
-	.ualong	0xa6
-	.byte	0x2
-	.byte	0x91
-	.sleb128 0
-	.byte	0x0
-	.uleb128 0x4
-	.string	"unsigned int"
-	.byte	0x4
-	.byte	0x7
-	.byte	0x0
-	.section	.debug_abbrev
-	.uleb128 0x1
-	.uleb128 0x11
-	.byte	0x1
-	.uleb128 0x10
-	.uleb128 0x6
-	.uleb128 0x12
-	.uleb128 0x1
-	.uleb128 0x11
-	.uleb128 0x1
-	.uleb128 0x3
-	.uleb128 0x8
-	.uleb128 0x1b
-	.uleb128 0x8
-	.uleb128 0x25
-	.uleb128 0x8
-	.uleb128 0x13
-	.uleb128 0xb
-	.byte	0x0
-	.byte	0x0
-	.uleb128 0x2
-	.uleb128 0x2e
-	.byte	0x1
-	.uleb128 0x1
-	.uleb128 0x13
-	.uleb128 0x3f
-	.uleb128 0xc
-	.uleb128 0x3
-	.uleb128 0x8
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x27
-	.uleb128 0xc
-	.uleb128 0x11
-	.uleb128 0x1
-	.uleb128 0x12
-	.uleb128 0x1
-	.uleb128 0x40
-	.uleb128 0xa
-	.byte	0x0
-	.byte	0x0
-	.uleb128 0x3
-	.uleb128 0x5
-	.byte	0x0
-	.uleb128 0x3
-	.uleb128 0x8
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x2
-	.uleb128 0xa
-	.byte	0x0
-	.byte	0x0
-	.uleb128 0x4
-	.uleb128 0x24
-	.byte	0x0
-	.uleb128 0x3
-	.uleb128 0x8
-	.uleb128 0xb
-	.uleb128 0xb
-	.uleb128 0x3e
-	.uleb128 0xb
-	.byte	0x0
-	.byte	0x0
-	.byte	0x0
-	.section	.debug_pubnames,"",@progbits
-	.ualong	0x27
-	.uaword	0x2
-	.ualong	.Ldebug_info0
-	.ualong	0xb7
-	.ualong	0x67
-	.string	"_superh_trap_handler"
-	.ualong	0x0
-	.section	.debug_aranges,"",@progbits
-	.ualong	0x1c
-	.uaword	0x2
-	.ualong	.Ldebug_info0
-	.byte	0x4
-	.byte	0x0
-	.uaword	0x0
-	.uaword	0x0
-	.ualong	.Ltext0
-	.ualong	.Letext0-.Ltext0
-	.ualong	0x0
-	.ualong	0x0
 #endif /* VBR_SETUP */
 #endif /* ! __SH5__ */
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/crti.S gcc-st40-4.8.2.140205/libgcc/config/sh/crti.S
--- gcc-gnu-4.8.2/libgcc/config/sh/crti.S	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/crti.S	2013-05-28 13:16:16.000000000 +0200
@@ -44,8 +44,8 @@
 #else
 	.p2align 1
 #endif
-	.global	 _init
-_init:
+	.global	 __init
+__init:
 #if __SHMEDIA__
 	addi	r15, -16, r15
 	st.q	r15, 8, r14
@@ -89,8 +89,8 @@
 #else
 	.p2align 1
 #endif
-	.global  _fini
-_fini:	
+	.global  __fini
+__fini:
 #if __SHMEDIA__
 	addi	r15, -16, r15
 	st.q	r15, 8, r14
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/crtn.S gcc-st40-4.8.2.140205/libgcc/config/sh/crtn.S
--- gcc-gnu-4.8.2/libgcc/config/sh/crtn.S	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/crtn.S	2013-05-28 13:16:16.000000000 +0200
@@ -39,9 +39,15 @@
 	rts
 	add	#8,r15
 #else
+#ifdef	DB_ST40300_BUG_WORKAROUND
+	.align	2
+#endif	
 	mov	r14,r15
 	lds.l	@r15+,pr
 	mov.l	@r15+,r14
+#ifdef	DB_ST40300_BUG_WORKAROUND
+	nop
+#endif		
 	rts
 #ifdef __ELF__
 	mov.l	@r15+,r12
@@ -65,9 +71,15 @@
 	rts
 	add	#8,r15
 #else
+#ifdef	DB_ST40300_BUG_WORKAROUND
+	.align	2
+#endif		
 	mov	r14,r15
 	lds.l	@r15+,pr
 	mov.l	@r15+,r14
+#ifdef	DB_ST40300_BUG_WORKAROUND
+	nop
+#endif			
 	rts
 #ifdef __ELF__
 	mov.l	@r15+,r12
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/adddf3.S gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/adddf3.S
--- gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/adddf3.S	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/adddf3.S	2013-05-28 13:16:16.000000000 +0200
@@ -0,0 +1,799 @@
+/* Copyright (C) 2004, 2006 Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.  */
+
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+! Routine for adding two double numbers
+
+! Author: Rakesh Kumar
+! SH1 Support by Joern Rennecke
+! Sticky Bit handling : Joern Rennecke
+
+! Arguments: r4-r5, r6-r7
+! Result: r0-r1
+
+! The value in r4-r5 is referred to as op1
+! and that in r6-r7 is referred to as op2
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+
+	.text
+        .align 5
+	.global	GLOBAL (subdf3)
+	FUNC (GLOBAL (subdf3))
+        .global GLOBAL (adddf3)
+	FUNC (GLOBAL (adddf3))
+
+GLOBAL (subdf3):
+#ifdef __LITTLE_ENDIAN__
+	mov	r4,r1
+	mov	r6,r2
+
+	mov	r5,r4
+	mov	r7,r6
+
+	mov	r1,r5
+	mov	r2,r7
+#endif
+	mov.l	.L_sign,r2
+	bra	.L_adddf3_1
+	xor	r2,r6
+
+GLOBAL (adddf3):
+#ifdef	__LITTLE_ENDIAN__
+	mov	r4,r1
+	mov	r6,r2
+
+	mov	r5,r4
+	mov	r7,r6
+
+	mov	r1,r5
+	mov	r2,r7
+#endif
+	
+.L_adddf3_1:
+	mov.l	r8,@-r15
+	mov	r4,r1
+
+	mov.l 	.L_inf,r2
+	mov	r6,r3
+
+	mov.l	r9,@-r15
+	and	r2,r1		!Exponent of op1 in r1
+
+	mov.l	r10,@-r15
+	and	r2,r3		!Exponent of op2 in r3
+
+	! Check for Nan or Infinity
+	mov.l	.L_sign,r9
+	cmp/eq	r2,r1
+
+	mov	r9,r10
+	bt	.L_thread_inv_exp_op1
+
+	mov	r9,r0
+	cmp/eq	r2,r3
+! op1 has a valid exponent. We need not check it again.
+! Return op2 straight away.
+	and	r4,r9		!r9 has sign bit for op1
+	bt	.L_ret_op2
+
+	! Check for -ve zero
+	cmp/eq	r4,r0
+	and	r6,r10		!r10 has sign bit for op2
+
+	bt	.L_op1_nzero
+
+	cmp/eq	r6,r0
+	bt	.L_op2_nzero
+
+! Check for zero
+.L_non_zero:
+	tst	r4,r4
+	bt	.L_op1_zero
+
+	! op1 is not zero, check op2 for zero
+	tst	r6,r6
+	bt	.L_op2_zero
+
+! r1 and r3 has masked out exponents, r9 and r10 has signs
+.L_add:
+	mov.l	.L_high_mant,r8
+	mov	#-20,r2
+
+#if !defined (__sh1__) && !defined (__sh2__) && !defined (__SH2E__)
+	shld	r2,r1		! r1 now has exponent for op1 in its lower bits
+#else
+	SHLR20 (r1)
+#endif
+	and	r8,r6	! Higher bits of mantissa of op2
+
+#if !defined (__sh1__) && !defined (__sh2__) && !defined (__SH2E__)
+	shld	r2,r3		! r3 has exponent for op2 in its lower bits
+#else
+	SHLR20 (r3)
+#endif
+	and	r8,r4	! Higher bits of mantissa of op1
+
+	mov.l	.L_21bit,r8
+
+	tst	r1,r1
+	bt	.L_norm_op1
+
+	! Set the 21st bit.
+	or	r8,r4
+	tst	r3,r3
+
+	bt	.L_norm_op2
+	or	r8,r6
+
+! Check for negative mantissas. Make them positive by negation
+! r9 and r10 have signs of op1 and op2 respectively
+.L_neg_mant:
+	tst	r9,r9
+	bf	.L_neg_op1
+
+	tst	r10,r10
+	bf	.L_neg_op2
+
+.L_add_1:
+	cmp/ge	r1,r3
+
+	mov	r1,r0
+	bt	.L_op2_exp_greater
+
+	sub	r3,r0
+	! If exponent difference is greater than 54, the resultant exponent
+	! won't be changed. Return op1 straight away.
+	mov	#54,r2
+	cmp/gt	r2,r0
+
+	bt	.L_pack_op1
+
+	mov	r1,r3
+	clrt
+
+	cmp/eq	#0,r0
+	bt	.L_add_mant
+
+	! Shift left the first operand and apply rest of shifts to second operand.
+	mov	#0,r2
+	shll	r5
+
+	rotcl	r4
+
+	add	#-1,r3
+	dt	r0
+
+	bt	.L_add_mant
+	dt	r0
+
+	bt	LOCAL(got_guard)
+	dt	r0
+
+	bt	LOCAL(got_sticky)
+
+! Shift the mantissa part of op2 so that both exponents are equal
+.L_shfrac_op2:
+	shar	r6
+	or	r7,r2	! sticky bit
+
+	rotcr	r7
+	dt	r0
+
+	bf	.L_shfrac_op2
+
+	shlr	r2
+
+	subc	r2,r2	! spread sticky bit across r2
+LOCAL(got_sticky):
+	shar	r6
+
+	rotcr	r7
+
+	rotcr	r2
+LOCAL(got_guard):
+	shar	r6
+
+	rotcr	r7
+
+	rotcr	r2
+
+
+! Add the psotive mantissas and check for overflow by checking the
+! MSB of the resultant. In case of overflow, negate the result.
+.L_add_mant:
+	clrt
+	addc	r7,r5
+
+	mov	#0,r10	! Assume resultant to be positive
+	addc	r6,r4
+
+	cmp/pz	r4
+
+	bt	.L_mant_ptv
+	negc	r2,r2
+
+	negc	r5,r5
+
+	mov.l	.L_sign,r10 ! The assumption was wrong, result is negative
+	negc	r4,r4
+
+! 23rd bit in the high part of mantissa could be set.
+! In this case, right shift the mantissa.
+.L_mant_ptv:
+	mov.l	.L_23bit,r0
+
+	tst	r4,r0
+	bt	.L_mant_ptv_0
+
+	shlr	r4
+	rotcr	r5
+
+	add	#1,r3
+	bra	.L_mant_ptv_1
+	rotcr	r2
+
+.L_mant_ptv_0:
+	mov.l	.L_22bit,r0
+	tst	r4,r0
+
+	bt	.L_norm_mant
+
+.L_mant_ptv_1:
+	! 22 bit of resultant mantissa is set. Shift right the mantissa
+	! and add 1 to exponent
+	add	#1,r3
+	shlr	r4
+	rotcr	r5
+	! The mantissa is already normalized. We don't need to
+	! spend any effort. Branch to epilogue. 
+	bra	.L_epil
+	rotcr	r2
+
+! Normalize operands
+.L_norm_op1:
+	shll	r5
+
+	rotcl	r4
+	add	#-1,r1
+
+	tst	r4,r8
+	bt	.L_norm_op1
+
+	tst	r3,r3
+	SL(bf,	.L_neg_mant,
+	 add	#1,r1)
+
+.L_norm_op2:
+	shll	r7
+
+	rotcl	r6
+	add	#-1,r3
+
+	tst	r6,r8
+	bt	.L_norm_op2
+
+	bra	.L_neg_mant
+	add	#1,r3
+
+! Negate the mantissa of op1
+.L_neg_op1:
+	clrt
+	negc	r5,r5
+
+	negc	r4,r4
+	tst	r10,r10
+
+	bt	.L_add_1
+
+! Negate the mantissa of op2
+.L_neg_op2:
+	clrt
+	negc	r7,r7
+
+	bra	.L_add_1
+	negc	r6,r6
+
+! Thread the jump to .L_inv_exp_op1
+.L_thread_inv_exp_op1:
+	bra	.L_inv_exp_op1
+	nop
+
+.L_ret_op2:
+	mov.l	@r15+,r10
+#ifdef	__LITTLE_ENDIAN__
+	mov	r6,r1
+#else
+	mov	r6,r0
+#endif
+
+	mov.l	@r15+,r9
+#ifdef	__LITTLE_ENDIAN__
+	mov	r7,r0
+#else
+	mov	r7,r1
+#endif
+
+	rts
+	mov.l	@r15+,r8
+
+.L_op1_nzero:
+	tst	r5,r5
+	bt	.L_ret_op2
+
+	! op1 is not zero. Check op2 for negative zero
+	cmp/eq	r6,r0
+	bf	.L_non_zero	! both op1 and op2 are not -0
+
+.L_op2_nzero:
+	tst	r7,r7
+	bf	.L_non_zero
+
+	mov.l	@r15+,r10
+#ifdef	__LITTLE_ENDIAN__
+	mov	r4,r1
+#else
+	mov	r4,r0	! op2 is -0, return op1
+#endif
+
+	mov.l	@r15+,r9
+#ifdef	__LITTLE_ENDIAN__
+	mov	r5,r0
+#else
+	mov	r5,r1
+#endif
+
+	rts
+	mov.l	@r15+,r8
+
+! High bit of op1 is known to be zero.
+! Check low bit. r2 contains 0x00000000
+.L_op1_zero:
+	tst	r5,r5
+	bt	.L_ret_op2
+
+	! op1 is not zero. Check high bit of op2
+	tst	r6,r6
+	bf	.L_add	! both op1 and op2 are not zero
+
+! op1 is not zero. High bit of op2 is known to be zero.
+! Check low bit of op2. r2 contains 0x00000000
+.L_op2_zero:
+	tst	r7,r7
+	bf	.L_add
+
+	mov.l	@r15+,r10
+#ifdef	__LITTLE_ENDIAN__
+	mov	r4,r1
+#else
+	mov	r4,r0	! op2 is zero, return op1
+#endif
+
+	mov.l	@r15+,r9
+#ifdef	__LITTLE_ENDIAN__
+	mov	r5,r0
+#else
+	mov	r5,r1
+#endif
+
+	rts
+	mov.l	@r15+,r8
+
+! exp (op1) is smaller or equal to exp (op2)
+! The logic of same operations is present in .L_add. Kindly refer it for
+! comments
+.L_op2_exp_greater:
+	mov	r3,r0
+	sub	r1,r0
+
+	mov	#54,r2
+	cmp/gt	r2,r0
+
+	bt	.L_pack_op2
+
+	cmp/eq	#0,r0
+	bt	.L_add_mant
+
+	mov	#0,r2
+	shll	r7
+	rotcl	r6
+	add	#-1,r0
+	add	#-1,r3
+
+	cmp/eq	#0,r0
+	bt	.L_add_mant
+.L_shfrac_op1:	
+        add     #-1,r0
+        shar    r4
+
+	rotcr	r5
+	rotcr	r2
+
+        cmp/eq  #0,r0
+        bf      .L_shfrac_op1
+
+	bra	.L_add_mant
+	nop
+
+! Return the value in op1
+.L_ret_op1:
+        mov.l   @r15+,r10
+#ifdef	__LITTLE_ENDIAN__
+	mov	r4,r1
+#else
+        mov     r4,r0
+#endif
+
+        mov.l   @r15+,r9
+#ifdef	__LITTLE_ENDIAN__
+	mov	r5,r0
+#else
+        mov     r5,r1
+#endif
+
+        rts
+        mov.l   @r15+,r8
+
+! r1 has exp, r9 has sign, r4 and r5 mantissa
+.L_pack_op1:
+	mov.l	.L_high_mant,r7
+	mov	r4,r0
+
+	tst	r9,r9
+	bt	.L_pack_op1_1
+
+	clrt
+	negc	r5,r5
+	negc	r0,r0
+
+.L_pack_op1_1:
+	and	r7,r0
+	mov	r1,r3
+
+	mov	#20,r2
+	mov	r5,r1
+
+	mov.l	@r15+,r10
+	or	r9,r0
+
+#if !defined (__sh1__) && !defined (__sh2__) && !defined (__SH2E__)
+	shld	r2,r3
+#else
+	SHLL20 (r3)
+#endif
+	mov.l	@r15+,r9
+
+	or	r3,r0
+#ifdef	__LITTLE_ENDIAN__
+	mov	r0,r2
+	mov	r1,r0
+	mov	r2,r1
+#endif
+	rts
+	mov.l	@r15+,r8
+
+!r2 has exp, r10 has sign, r6 and r7 mantissa
+.L_pack_op2:
+	mov.l	.L_high_mant,r9
+	mov	r6,r0
+
+	tst	r10,r10
+	bt	.L_pack_op2_1
+
+	clrt
+	negc	r7,r7
+	negc	r0,r0
+
+.L_pack_op2_1:
+	and	r9,r0
+	mov	r7,r1
+
+	mov	#20,r2
+	or	r10,r0
+
+	mov.l	@r15+,r10
+#if !defined (__sh1__) && !defined (__sh2__) && !defined (__SH2E__)
+	shld	r2,r3
+#else
+	SHLL20 (r3)
+#endif
+
+	mov.l	@r15+,r9
+
+	or	r3,r0
+#ifdef	__LITTLE_ENDIAN__
+	mov	r0,r2
+	mov	r1,r0
+	mov	r2,r1
+#endif
+	rts
+	mov.l	@r15+,r8
+
+! Normalize the mantissa by setting its 21 bit in high part
+.L_norm_mant:
+	mov.l	.L_21bit,r0
+
+	tst	r4,r0
+	bf	.L_epil
+
+	tst	r4,r4
+	bf	.L_shift_till_1
+
+	tst	r5,r5
+	bf	.L_shift_till_1
+
+	! Mantissa is zero, return 0
+	mov.l	@r15+,r10
+	mov	#0,r0
+
+	mov.l	@r15+,r9
+	mov.l	@r15+,r8
+
+	rts
+	mov	#0,r1
+
+! A loop for making the 21st bit 1 in high part of resultant mantissa
+! It is already ensured that 1 bit is present in the mantissa
+.L_shift_till_1:
+	clrt
+	shll	r5
+
+	rotcl	r4
+	add	#-1,r3
+
+	tst	r4,r0
+	bt	.L_shift_till_1
+
+! Return the result. Mantissa is in r4-r5. Exponent is in r3
+! Sign bit in r10
+.L_epil:
+	cmp/pl	r3
+
+	bf	.L_denorm
+	mov.l	LOCAL(x7fffffff),r0
+
+	mov	r5,r1
+	shlr	r1
+
+	mov	#0,r1
+	addc	r0,r2
+
+! Check extra MSB here
+	mov.l	.L_22bit,r9
+	addc	r1,r5	! round to even
+
+	addc	r1,r4
+	tst	r9,r4
+
+	bf	.L_epil_1
+
+.L_epil_0:
+	mov.l	.L_21bit,r1
+
+	not	r1,r1
+	and	r1,r4
+
+	mov	r4,r0
+	or	r10,r0
+
+	mov.l	@r15+,r10
+	mov	#20,r2
+
+	mov.l	@r15+,r9
+	mov	r5,r1
+
+#if !defined (__sh1__) && !defined (__sh2__) && !defined (__SH2E__)
+	shld	r2,r3
+#else
+	SHLL20 (r3)
+#endif
+	or	r3,r0
+
+#ifdef	__LITTLE_ENDIAN__
+	mov	r0,r2
+	mov	r1,r0
+	mov	r2,r1
+#endif
+	rts
+	mov.l	@r15+,r8
+
+.L_epil_1:
+	shlr	r4
+	add	#1,r3
+	bra	.L_epil_0
+	rotcr	r5
+
+.L_denorm:
+	add	#-1,r3
+.L_denorm_1:
+	tst	r3,r3
+	bt	.L_denorm_2
+
+	shlr	r4
+	rotcr	r5
+
+	movt	r1
+	bra	.L_denorm_1
+	add	#1,r3
+
+.L_denorm_2:
+	clrt
+	mov	#0,r2
+	addc	r1,r5
+
+	addc	r2,r4
+	mov	r4,r0
+
+	or	r10,r0
+	mov.l	@r15+,r10
+
+	mov	r5,r1
+
+	mov.l	@r15+,r9
+#ifdef	__LITTLE_ENDIAN__
+	mov	r0,r2
+	mov	r1,r0
+	mov	r2,r1
+#endif
+	rts
+	mov.l	@r15+,r8
+
+! op1 is known to be positive infinity, and op2 is Inf. The sign
+! of op2 is not known. Return the appropriate value
+.L_op1_pinf_op2_inf:
+	mov.l	.L_sign,r0
+	tst	r6,r0
+
+	bt	.L_ret_op2_1
+
+	! op2 is negative infinity. Inf - Inf is being performed
+	mov.l	.L_inf,r0
+	mov.l	@r15+,r10
+	mov.l	@r15+,r9
+#ifdef	__LITTLE_ENDIAN__
+	mov	r0,r1
+#endif
+	mov.l	@r15+,r8
+
+	rts
+#ifdef	__LITTLE_ENDIAN__
+	mov	#1,r0
+#else
+	mov	#1,r1	! Any value here will return Nan
+#endif
+	
+.L_ret_op1_1:
+        mov.l   @r15+,r10
+#ifdef	__LITTLE_ENDIAN__
+	mov	r4,r1
+#else
+        mov     r4,r0
+#endif
+
+        mov.l   @r15+,r9
+#ifdef	__LITTLE_ENDIAN__
+	mov	r5,r0
+#else
+        mov     r5,r1
+#endif
+
+        rts
+        mov.l   @r15+,r8
+
+.L_ret_op2_1:
+	mov.l	@r15+,r10
+#ifdef	__LITTLE_ENDIAN__
+	mov	r6,r1
+#else
+	mov	r6,r0
+#endif
+
+	mov.l	@r15+,r9
+#ifdef	__LITTLE_ENDIAN__
+	mov	r7,r0
+#else
+	mov	r7,r1
+#endif
+
+	rts
+	mov.l	@r15+,r8
+
+! op1 is negative infinity. Check op2 for infinity or Nan
+.L_op1_ninf:
+	cmp/eq	r2,r3
+	bf	.L_ret_op1_1	! op2 is neither Nan nor Inf
+
+	mov.l	@r15+,r9
+	div0s	r4,r6		! different signs -> NaN
+	mov	r4,DBLRH
+	or	r6,DBLRH
+	mov.l	@r15+,r8
+	SL(bf, 0f,
+	 mov	r5,DBLRL)
+	mov	#-1,DBLRH	! return NaN.
+0:	rts
+	or	r7,DBLRL
+
+!r1 contains exponent for op1, r3 contains exponent for op2
+!r2 has .L_inf (+ve Inf)
+!op1 has invalid exponent. Either it contains Nan or Inf
+.L_inv_exp_op1:
+	! Check if a is Nan
+	cmp/pl	r5
+	bt	.L_ret_op1_1
+
+	mov.l	.L_high_mant,r0
+	and	r4,r0
+
+	cmp/pl	r0
+	bt	.L_ret_op1_1
+
+	! op1 is not Nan. It is infinity. Check the sign of it.
+	! If op2 is Nan, return op2
+	cmp/pz	r4
+
+	bf	.L_op1_ninf
+
+	! op2 is +ve infinity here
+	cmp/eq	r2,r3
+	bf	.L_ret_op1_1	! op2 is neither Nan nor Inf
+
+	! r2 is free now
+	mov.l	.L_high_mant,r0
+	tst	r6,r0		! op2 also has invalid exponent
+
+	bf	.L_ret_op2_1	! op2 is Infinity, and op1 is +Infinity
+
+	tst	r7,r7
+	bt	.L_op1_pinf_op2_inf	! op2 is Infinity, and op1 is +Infinity
+	!op2 is not infinity, It is Nan
+	bf	.L_ret_op2_1
+
+	.align 2	
+.L_high_mant:
+	.long 0x000FFFFF
+
+.L_21bits:
+	.long 0x001FFFFF
+
+.L_22bit:
+	.long 0x00200000
+
+.L_23bit:
+	.long 0x00400000
+
+.L_21bit:
+	.long 0x00100000
+
+.L_sign:
+	.long 0x80000000
+
+.L_inf:
+	.long 0x7ff00000
+
+LOCAL(x7fffffff): .long 0x7fffffff
+
+ENDFUNC (GLOBAL (subdf3))
+ENDFUNC (GLOBAL (adddf3))
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/addsf3.S gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/addsf3.S
--- gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/addsf3.S	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/addsf3.S	2013-05-28 13:16:16.000000000 +0200
@@ -0,0 +1,535 @@
+/* Copyright (C) 2004, 2006 Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.  */
+
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+! Add floating point numbers in r4, r5.
+
+! Author: Rakesh Kumar
+
+! Arguments are in r4, r5 and result in r0
+
+! Entry points: ___subsf3, ___addsf3
+
+! r4 and r5 are referred as op1 and op2
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+
+	.text
+	.align 5
+        .global GLOBAL (subsf3)
+	.global	GLOBAL (addsf3)
+	FUNC (GLOBAL (subsf3))
+	FUNC (GLOBAL (addsf3))
+
+GLOBAL (subsf3):
+        mov.l   .L_sign_bit,r1
+        xor     r1,r5
+
+GLOBAL (addsf3):
+	mov.l	r8,@-r15
+	mov	r4,r3
+
+	mov.l	.L_pinf,r2
+	mov	#0,r8
+
+	and	r2,r3 ! op1's exponent.
+	mov	r5,r6
+
+	! Check NaN or Infinity
+	and	r2,r6 ! op2's exponent.
+	cmp/eq	r2,r3
+
+	! go if op1 is NaN or INF. 
+	mov.l	.L_sign_bit,r0
+	SL(bt,	.L_inv_op1,
+	 mov	#-23,r1)
+	
+	! Go if op2 is NaN/INF.
+	cmp/eq	r2,r6
+	mov	r0,r7
+	bt	.L_ret_op2
+
+#if defined (__sh1__) || defined (__sh2__) || defined (__SH2E__)
+	SHLR23 (r3)
+#else
+	shld	r1,r3
+#endif
+#if defined (__sh1__) || defined (__sh2__) || defined (__SH2E__)
+	SHLR23 (r6)
+#else
+	shld	r1,r6
+#endif
+
+	! Check for negative zero
+	cmp/eq	r0,r5
+
+	mov	r5,r1
+	SL(bt,	.L_ret_op1,
+	 and	r7,r1)
+
+	cmp/eq	r0,r4
+	bt	.L_ret_op2
+
+	! if op1 is zero return op2
+	tst	r4,r4
+	bt	.L_ret_op2
+
+	! Equal numbers with opposite sign
+	mov	r4,r2
+	xor	r5,r2
+
+	cmp/eq	r0,r2
+	bt	.L_ret_zero
+
+	! if op2 is zero return op1
+	mov.l	.L_mask_fra,r2
+	tst	r5,r5
+
+	! Extract the mantissa
+	mov	r4,r0
+	SL(bt,	.L_ret_op1,
+	 and	r2,r5)
+
+	and	r2,r4
+
+	mov.l	.L_imp_bit,r2
+	and	r7,r0	! sign bit of op1
+
+	! Check for denormals
+	tst	r3,r3
+	bt	.L_norm_op1
+
+	! Attach the implicit bit
+	or	r2,r4
+	tst	r6,r6
+
+	bt	.L_norm_op2
+
+	or	r2,r5
+	tst	r0,r0
+
+	! operands are +ve or -ve??
+	bt	.L_ptv_op1
+
+	neg	r4,r4
+
+.L_ptv_op1:
+	tst	r1,r1
+	bt	.L_ptv_op2
+
+	neg	r5,r5
+
+! Test exponents for equality
+.L_ptv_op2:
+	cmp/eq	r3,r6
+	bt	.L_exp_eq
+
+! Make exponents of two arguments equal
+.L_exp_ne:
+	! r0, r1 contain sign bits.
+	! r4, r5 contain mantissas.
+	! r3, r6 contain exponents.
+	! r2, r7 scratch.
+
+	! Calculate result exponent.
+	mov	r6,r2
+	sub	r3,r2	! e2 - e1
+
+	cmp/pl	r2
+	mov	#23,r7
+
+	! e2 - e1 is -ve
+	bf	.L_exp_ne_1
+
+	mov	r6,r3 ! Result exp.
+	cmp/gt	r7,r2 ! e2-e1 > 23
+
+	mov	#1,r7
+	bt	.L_pack_op2_0
+
+	! Align the mantissa
+.L_loop_ne:
+	shar	r4
+
+	rotcr	r8
+	cmp/eq	r7,r2
+
+	add	#-1,r2
+	bf	.L_loop_ne
+
+	bt	.L_exp_eq
+
+! Exponent difference is too high.
+! Return op2 after placing pieces in proper place
+.L_pack_op2_0:
+	! If op1 is -ve
+	tst	r1,r1
+	bt	.L_pack_op2
+
+	neg	r5,r5
+
+! r6 has exponent
+! r5 has mantissa, r1 has sign
+.L_pack_op2:
+	mov.l	.L_nimp_bit,r2
+	mov	#23,r3
+
+	mov	r1,r0
+	
+	and	r2,r5
+	mov.l	@r15+,r8
+
+	or	r5,r0
+
+#if defined (__sh1__) || defined (__sh2__) || defined (__SH2E__)
+	SHLL23 (r6)
+#else
+	shld	r3,r6
+#endif
+        rts
+	or	r6,r0
+
+! return op1. It is NAN or INF or op2 is zero.
+.L_ret_op1:
+	mov	r4,r0
+
+	rts
+	mov.l	@r15+,r8
+
+! return zero
+.L_ret_zero:
+	mov	#0,r0
+
+	rts
+	mov.l	@r15+,r8
+
+! return op2. It is NaN or INF or op1 is zero.
+.L_ret_op2:
+	mov	r5,r0
+
+	rts
+	mov.l	@r15+,r8
+
+! op2 is denormal. Normalize it.
+.L_norm_op2:
+	shll	r5
+	add	#-1,r6
+
+	tst	r2,r5
+	bt	.L_norm_op2
+
+	! Check sign
+	tst	r1,r1
+	bt	.L_norm_op2_2
+
+	neg	r5,r5
+
+.L_norm_op2_2:
+	add	#1,r6
+	cmp/eq	r3,r6
+
+	bf	.L_exp_ne
+	bt	.L_exp_eq
+
+! Normalize op1
+.L_norm_op1:
+	shll	r4
+	add	#-1,r3
+
+	tst	r2,r4
+	bt	.L_norm_op1
+
+	! Check sign
+	tst	r0,r0
+	bt	.L_norm_op1_1
+
+	neg	r4,r4
+
+.L_norm_op1_1:
+	! Adjust biasing
+	add	#1,r3
+
+	! Check op2 for denormalized value
+	tst	r6,r6
+	bt	.L_norm_op2
+
+	mov.l	.L_imp_bit,r2
+
+	tst	r1,r1	! Check sign
+	or	r2,r5	! Attach 24th bit
+
+	bt	.L_norm_op1_2
+
+	neg	r5,r5
+
+.L_norm_op1_2:
+	cmp/eq	r3,r6
+
+	bt	.L_exp_eq
+	bf	.L_exp_ne
+
+! op1 is NaN or Inf
+.L_inv_op1:
+	! Return op1 if it is NAN. 
+	! r2 is infinity
+	cmp/gt	r2,r4
+	bt	.L_ret_op1
+
+	! op1 is +/- INF
+	! If op2 is same return now.
+	cmp/eq	r4,r5
+	bt	.L_ret_op1
+
+	! return op2 if it is NAN
+	cmp/gt	r2,r5
+	bt	.L_ret_op2
+
+	! Check if op2 is inf
+	cmp/eq	r2,r6
+	bf	.L_ret_op1
+	
+	! Both op1 and op2 are infinities 
+	!of opp signs, or there is -NAN. Return a NAN.
+	mov.l	@r15+,r8
+	rts
+	mov	#-1,r0
+
+! Make unequal exponents equal.
+.L_exp_ne_1:
+	mov	#-25,r7
+	cmp/gt	r2,r7 ! -23 > e2 - e1
+
+	add	#1,r2
+	bf	.L_exp_ne_2
+
+	tst	r0,r0
+	bt	.L_pack_op1
+
+.L_pack_op1_0:
+	bra	.L_pack_op1
+	neg	r4,r4
+
+! Accumulate the shifted bits in r8
+.L_exp_ne_2:
+	! Shift with rounding
+	shar	r5
+	rotcr	r8
+
+	tst	r2,r2
+
+	add	#1,r2
+	bf	.L_exp_ne_2
+
+! Exponents of op1 and op2 are equal (or made so)
+! The mantissas are in r4-r5 and remaining bits in r8
+.L_exp_eq:
+	add	r5,r4 ! Add fractions.
+	mov.l	.L_sign_bit,r2
+
+	! Check for negative result
+	mov	#0,r0
+	tst	r2,r4
+
+	mov.l	.L_255,r5
+	bt	.L_post_add
+
+	negc	r8,r8
+	negc	r4,r4
+	or	r2,r0
+
+.L_post_add:
+	! Check for extra MSB
+	mov.l	.L_chk_25,r2
+
+	tst	r2,r4
+	bt	.L_imp_check
+
+	shar 	r4
+	rotcr	r8
+
+	add	#1,r3
+	cmp/ge	r5,r3
+
+	! Return Inf if exp > 254
+	bt	.L_ret_inf
+
+! Check for implicit (24th) bit in result
+.L_imp_check:
+        mov.l	.L_imp_bit,r2
+	tst	r2,r4
+
+	bf	.L_pack_op1
+
+! Result needs left shift
+.L_lft_shft:
+	shll	r8
+	rotcl	r4
+
+	add	#-1,r3
+	tst	r2,r4
+
+	bt	.L_lft_shft
+	
+! Pack the result after rounding
+.L_pack_op1:
+	! See if denormalized result is possible 
+	mov.l	.L_chk_25,r5
+	cmp/pl	r3
+
+	bf	.L_denorm_res
+
+	! Are there any bits shifted previously?
+	tst	r8,r8
+	bt	.L_pack_1
+
+	! Round
+	shll	r8
+	movt	r6
+
+	add	r6,r4
+
+	! If we are halfway between two numbers,
+	! round towards LSB = 0
+	tst	r8,r8
+
+	bf	.L_pack_1
+
+	shlr	r4
+	shll	r4
+
+.L_pack_1:
+	! Adjust extra MSB generated after rounding
+	tst	r4,r5
+	mov.l	.L_255,r2
+
+	bt	.L_pack_2
+	shar	r4
+
+	add	#1,r3 
+	cmp/ge	r2,r3	! Check for exp overflow
+
+	bt	.L_ret_inf
+	
+! Pack it finally
+.L_pack_2:
+	! Do not store implicit bit
+	mov.l	.L_nimp_bit,r2
+	mov	#23,r1
+
+	and	r2,r4
+
+#if defined (__sh1__) || defined (__sh2__) || defined (__SH2E__)
+	SHLL23 (r3)
+#else
+	shld	r1,r3
+#endif
+	mov.l	@r15+,r8
+
+	or	r4,r0
+        rts
+	or	r3,r0
+
+! Return infinity
+.L_ret_inf:
+	mov.l	.L_pinf,r2
+
+	mov.l	@r15+,r8
+	rts
+	or	r2,r0
+
+! Result must be denormalized
+.L_denorm_res:
+	mov	#0,r2
+	
+! Denormalizing loop with rounding
+.L_den_1:
+	shar	r4
+	movt	r6
+
+	tst	r3,r3
+	bt	.L_den_2
+
+	! Increment the exponent
+	add	#1,r3
+
+	tst	r6,r6
+	bt	.L_den_0
+
+	! Count number of ON bits shifted
+	add	#1,r2
+
+.L_den_0:
+	bra	.L_den_1
+	nop
+
+! Apply rounding
+.L_den_2:
+	cmp/eq	r6,r1
+	bf	.L_den_3
+
+	add	r6,r4
+	mov	#1,r1
+
+	! If halfway between two numbers,
+	! round towards LSB = 0
+	cmp/eq	r2,r1
+	bf	.L_den_3
+
+	shar	r4
+	shll	r4
+
+.L_den_3:
+
+	mov.l	@r15+,r8
+	rts
+	or	r4,r0
+	
+	.align 2
+.L_imp_bit:
+        .long   0x00800000
+
+.L_nimp_bit:
+	.long	0xFF7FFFFF
+
+.L_mask_fra:
+        .long   0x007FFFFF
+
+.L_pinf:
+        .long   0x7F800000
+
+.L_sign_bit:
+	.long	0x80000000
+
+.L_bit_25:
+	.long	0x01000000
+
+.L_chk_25:
+        .long   0x7F000000
+
+.L_255:
+	.long	0x000000FF
+
+ENDFUNC (GLOBAL (addsf3))
+ENDFUNC (GLOBAL (subsf3))
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/divdf3.S gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/divdf3.S
--- gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/divdf3.S	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/divdf3.S	2013-05-28 13:16:16.000000000 +0200
@@ -0,0 +1,598 @@
+/* Copyright (C) 2004, 2006 Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.  */
+
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!division of two double precision floating point numbers
+!Author:Aanchal Khanna
+!
+!Entry:
+!r4,r5:dividend
+!
+!r6,r7:divisor
+!
+!Exit:
+!r0,r1:quotient
+
+!Notes: dividend is passed in regs r4 and r5 and divisor is passed in regs 
+!r6 and r7, quotient is returned in regs r0 and r1. dividend is referred as op1
+!and divisor as op2.
+!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+
+	.text
+	.align	5
+	.global	GLOBAL (divdf3)
+	FUNC (GLOBAL (divdf3))
+
+GLOBAL (divdf3):
+
+#ifdef  __LITTLE_ENDIAN__
+	mov	r4,r1
+	mov	r5,r4
+	mov	r1,r5
+
+        mov     r6,r1
+        mov     r7,r6
+        mov     r1,r7
+#endif
+	mov	r4,r2
+	mov.l	.L_inf,r1
+
+	and	r1,r2
+	mov.l   r8,@-r15
+
+	cmp/eq	r1,r2
+	mov     r6,r8
+
+	bt	.L_a_inv
+	and	r1,r8
+
+	cmp/eq	r1,r8
+	mov.l	.L_high_mant,r3
+
+	bf	.L_chk_zero
+	and	r6,r3
+
+	mov.l   .L_mask_sign,r8	
+	cmp/pl	r7
+
+	mov	r8,r0
+	bt	.L_ret_b	!op2=NaN,return op2
+
+	and	r4,r8
+	cmp/pl	r3
+
+	and	r6,r0
+	bt	.L_ret_b	!op2=NaN,return op2
+
+	xor     r8,r0           !op1=normal no,op2=Inf, return Zero
+	mov     #0,r1
+	
+#ifdef __LITTLE_ENDIAN__
+	mov	r0,r2
+	mov	r1,r0
+	mov	r2,r1
+#endif
+	rts
+	mov.l   @r15+,r8
+
+.L_ret_b:
+	mov	r7,r1
+	mov     r6,r0
+
+#ifdef __LITTLE_ENDIAN__
+        mov     r0,r2
+        mov     r1,r0
+        mov     r2,r1
+#endif
+
+	rts
+	mov.l   @r15+,r8
+
+.L_a_inv:
+	!chk if op1 is Inf or NaN
+	mov.l   .L_high_mant,r2
+	cmp/pl  r5
+
+	and	r4,r2
+	bt	.L_ret_a
+
+	and	r1,r8		!r1 contains infinity
+	cmp/pl	r2
+
+	bt	.L_ret_a
+	cmp/eq	r1,r8
+
+	mov	r1,DBLRH
+	add	DBLRH,DBLRH
+	bf	0f
+	mov	#-1,DBLRH	! Inf/Inf, return NaN.
+0:	div0s	r4,r6
+	mov.l   @r15+,r8	
+	rts
+	rotcr	DBLRH
+
+.L_ret_a:
+	!return op1
+	mov	r5,r1
+	mov	r4,r0
+
+#ifdef __LITTLE_ENDIAN__
+        mov     r0,r2
+        mov     r1,r0
+        mov     r2,r1
+#endif
+	rts
+        mov.l   @r15+,r8
+
+.L_chk_zero:
+	!chk if op1=0
+	mov.l   .L_mask_sign,r0
+        mov     r4,r3
+
+        and     r0,r3
+        shll    r4
+
+        and     r6,r0
+        shlr    r4
+
+        xor     r3,r0
+        shll    r6
+
+	shlr	r6
+	tst	r4,r4
+
+
+	bf      .L_op1_not_zero	
+	tst	r5,r5
+	
+        bf      .L_op1_not_zero
+	tst	r7,r7
+
+	mov.l   @r15+,r8
+	bf	.L_ret_zero
+
+	tst	r6,r6
+	bf	.L_ret_zero
+
+	rts
+	mov     #-1,DBLRH       !op1=op2=0, return NaN
+	
+.L_ret_zero:
+	!return zero
+	mov	r0,r1
+	rts
+#ifdef __LITTLE__ENDIAN
+	mov	#0,r0
+#else
+	mov	#0,r1		!op1=0,op2=normal no,return zero
+#endif
+
+.L_norm_b:
+	!normalize op2
+        shll    r7
+        mov.l   .L_imp_bit,r3
+
+        rotcl   r6
+        tst     r3,r6
+
+        add     #-1,r8
+        bt      .L_norm_b
+
+        bra     .L_divide
+        add     #1,r8
+
+.L_op1_not_zero:
+	!op1!=0, chk if op2=0
+	tst	r7,r7	
+	mov	r1,r3
+	
+	mov	#0,r1
+	bf	.L_normal_nos
+
+	tst	r6,r6
+	bf      .L_normal_nos
+
+	mov.l   @r15+,r8
+	or	r3,r0
+
+#ifdef __LITTLE_ENDIAN__
+        mov     r0,r2
+        mov     r1,r0
+        mov     r2,r1
+#endif
+
+	rts
+	nop
+
+.L_normal_nos:
+	!op1 and op2 are normal nos
+	tst	r2,r2
+	mov	#-20,r1
+
+! The subsequent branch is for the upper compare
+! Shifting will not alter the result, for the
+! macro is declared with care.
+#if !defined (__sh1__) && !defined (__sh2__) && !defined (__SH2E__)
+	shld    r1,r2
+#else
+	SHLR20 (r2)
+#endif
+	bt	.L_norm_a	!normalize dividend
+	
+.L_chk_b:
+	mov.l	r9,@-r15
+	tst	r8,r8
+
+        mov.l   .L_high_mant,r9
+
+! The subsequent branch is for the upper compare
+! Shifting will not alter the result, for the
+! macro is declared with care.
+#if !defined (__sh1__) && !defined (__sh2__) && !defined (__SH2E__)
+        shld    r1,r8
+#else
+        SHLR20 (r8)
+#endif
+				! T set -> normalize divisor
+	SL(bt,	.L_norm_b,
+	 and	r9,r4)
+
+.L_divide:
+	mov.l   .L_2047,r1
+	sub	r8,r2
+
+	mov.l	.L_1023,r8
+	and	r9,r6
+
+	!resultant exponent
+	add	r8,r2
+	!chk the exponent for overflow
+	cmp/ge	r1,r2
+	
+	mov.l	.L_imp_bit,r1
+	bt	.L_overflow
+	
+	mov	#0,r8
+	or	r1,r4
+	
+	or      r1,r6	
+	mov	#-24,r3
+
+	!chk if the divisor is 1(mantissa only)
+	cmp/eq	r8,r7
+	bf	.L_div2
+
+	cmp/eq	 r6,r1
+	bt	.L_den_one
+
+.L_div2:
+	!divide the mantissas
+	shll8	r4
+	mov	r5,r9
+
+#if !defined (__sh1__) && !defined (__sh2__) && !defined (__SH2E__)
+        shld    r3,r9
+#else
+        SHLR24 (r9)
+#endif
+	shll8	r6
+
+	or	r9,r4
+	shll8   r5
+
+	mov	r7,r9
+
+#if !defined (__sh1__) && !defined (__sh2__) && !defined (__SH2E__)
+        shld    r3,r9
+#else
+        SHLR24 (r9)
+#endif
+	mov	r8,r3
+	shll8	r7
+
+	or	r9,r6	
+	cmp/gt	r4,r6
+
+	mov	r3,r9
+	bt	.L_shift
+
+	cmp/eq	r4,r6
+	bf	.L_loop
+
+	cmp/gt	r5,r7
+	bf	.L_loop
+
+.L_shift:
+	add	#-1,r2
+	shll	r5
+	rotcl	r4
+
+.L_loop:
+	!actual division loop
+	cmp/gt	r6,r4
+	bt	.L_subtract
+
+	cmp/eq	r6,r4
+	bf	.L_skip
+
+	cmp/ge	r7,r5
+	bf	.L_skip
+
+.L_subtract:
+	clrt
+	subc	r7,r5
+	
+	or	r1,r8
+	subc	r6,r4
+
+.L_skip:
+	shlr	r1
+	shll	r5
+
+	rotcl	r4
+	cmp/eq	r1,r3
+
+	bf	.L_loop
+	mov.l	.L_imp_bit,r1
+
+	!chk if the divison was for the higher word of the quotient
+	tst	r1,r9
+	bf	.L_chk_exp
+
+	mov	r8,r9
+	mov.l   .L_mask_sign,r1
+
+	!divide for the lower word of the quotient
+	bra	.L_loop
+	mov	r3,r8
+
+.L_chk_exp:
+	!chk if the result needs to be denormalized
+	cmp/gt	r2,r3
+	bf	.L_round
+	mov     #-53,r7
+
+.L_underflow:
+	!denormalize the result
+	add	#1,r2
+	cmp/gt	r2,r7
+
+	or      r4,r5           !remainder
+	add	#-2,r2
+
+	mov	#32,r4
+	bt      .L_return_zero
+
+	add	r2,r4
+	cmp/ge	r3,r4
+
+	mov	r2,r7
+	mov	r3,r1
+
+	mov     #-54,r2
+	bt	.L_denorm
+	mov	#-32,r7
+
+.L_denorm:
+	shlr	r8
+	rotcr	r1
+
+	shll	r8
+	add     #1,r7
+
+	shlr	r9
+	rotcr	r8
+
+	cmp/eq	r3,r7
+	bf	.L_denorm
+
+	mov	r4,r7
+	cmp/eq	r2,r4
+
+	bt	.L_break
+	mov     r3,r6
+
+	cmp/gt	r7,r3
+	bf	.L_break
+
+	mov	r2,r4
+	mov	r1,r6
+
+	mov	r3,r1
+	bt	.L_denorm
+
+.L_break:
+	mov     #0,r2
+
+	cmp/gt	r1,r2
+
+	addc	r2,r8
+	mov.l   .L_comp_1,r4
+
+	addc	r3,r9		
+	or	r9,r0
+
+	cmp/eq	r5,r3
+	bf	.L_return	
+
+	cmp/eq	r3,r6
+	mov.l	.L_mask_sign,r7
+
+	bf	.L_return
+	cmp/eq	r7,r1
+
+	bf	.L_return
+	and	r4,r8
+
+.L_return:
+	mov.l	@r15+,r9
+	mov     r8,r1
+
+#ifdef __LITTLE_ENDIAN__
+        mov     r0,r2
+        mov     r1,r0
+        mov     r2,r1
+#endif
+	rts
+	mov.l   @r15+,r8
+
+.L_norm_a:
+        !normalize op1
+        shll    r5
+        mov.l   .L_imp_bit,r3
+
+        rotcl   r4
+        tst     r3,r4
+
+        add     #-1,r2
+        bt      .L_norm_a
+
+        bra     .L_chk_b
+        add     #1,r2
+
+.L_overflow:
+	!overflow, return inf
+	mov.l   .L_inf,r2
+#ifdef __LITTLE_ENDIAN__
+	or	r2,r1	
+	mov	#0,r0
+#else
+	or	r2,r0
+	mov	#0,r1
+#endif
+        mov.l   @r15+,r9
+        rts
+        mov.l   @r15+,r8
+
+.L_den_one:
+	!denominator=1, result=numerator
+        mov     r4,r9
+        mov   	#-53,r7
+
+	cmp/ge	r2,r8
+	mov	r8,r4
+
+	mov	r5,r8
+	mov	r4,r3
+
+	!chk the exponent for underflow
+	SL(bt,	.L_underflow,
+	 mov     r4,r5)
+
+	mov.l	.L_high_mant,r7
+        bra     .L_pack
+	mov     #20,r6
+
+.L_return_zero:
+	!return zero
+	mov	r3,r1
+	mov.l	@r15+,r9
+
+	rts
+	mov.l   @r15+,r8
+
+.L_round:
+	!apply rounding
+	cmp/eq	r4,r6
+	bt	.L_lower
+
+	clrt
+	subc    r6,r4
+
+	bra     .L_rounding
+	mov	r4,r6
+	
+.L_lower:
+	clrt
+	subc	r7,r5
+	mov	r5,r6
+	
+.L_rounding:
+	!apply rounding
+	mov.l   .L_invert,r1
+	mov	r3,r4
+
+	movt	r3
+	clrt
+	
+	not	r3,r3
+	and	r1,r3	
+
+	addc	r3,r8
+	mov.l   .L_high_mant,r7
+
+	addc	r4,r9
+	cmp/eq	r4,r6
+
+	mov.l   .L_comp_1,r3
+	SL (bf,	.L_pack,
+	 mov     #20,r6)
+	and	r3,r8
+
+.L_pack:
+	!pack the result, r2=exponent,r0=sign,r8=lower mantissa, r9=higher mantissa
+#if !defined (__sh1__) && !defined (__sh2__) && !defined (__SH2E__)
+	shld    r6,r2
+#else
+        SHLL20 (r2)
+#endif
+	and	r7,r9
+
+	or	r2,r0
+	mov	r8,r1
+
+	or      r9,r0
+	mov.l	@r15+,r9
+
+#ifdef __LITTLE_ENDIAN__
+        mov     r0,r2
+        mov     r1,r0
+        mov     r2,r1
+#endif
+	rts
+	mov.l	@r15+,r8
+
+	.align	2
+
+.L_mask_sign:
+	.long	0x80000000
+.L_high_mant:
+	.long	0x000fffff
+.L_inf:
+	.long	0x7ff00000
+.L_1023:
+	.long	1023
+.L_2047:
+	.long	2047
+.L_imp_bit:
+	.long	0x00100000	
+.L_comp_1:
+	.long	0xfffffffe
+.L_invert:
+	.long	0x00000001
+
+ENDFUNC (GLOBAL (divdf3))
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/divsf3.S gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/divsf3.S
--- gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/divsf3.S	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/divsf3.S	2013-05-28 13:16:16.000000000 +0200
@@ -0,0 +1,404 @@
+/* Copyright (C) 2004, 2006 Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.  */
+
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!divides two single precision floating point 
+
+! Author: Aanchal Khanna
+
+! Arguments: Dividend is in r4, divisor in r5
+! Result: r0
+
+! r4 and r5 are referred as op1 and op2 resp.
+
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+
+	.text
+	.align	5
+	.global	GLOBAL (divsf3)
+	FUNC (GLOBAL (divsf3))
+
+GLOBAL (divsf3):
+	mov.l	.L_mask_sign,r1
+	mov	r4,r3
+
+	xor	r5,r3
+	shll	r4
+
+	shlr	r4
+	mov.l	.L_inf,r2
+
+	and	r3,r1		!r1=resultant sign
+	mov	r4,r6
+
+	shll	r5
+	mov	#0,r0		
+
+	shlr	r5
+	and	r2,r6
+
+	cmp/eq	r2,r6
+	mov	r5,r7
+
+	and     r2,r7
+	bt	.L_op1_inv
+
+	cmp/eq	r2,r7
+	mov	#-23,r3
+
+	bt	.L_op2_inv
+#if defined (__sh1__) || defined (__sh2__) || defined (__SH2E__)
+	SHLR23 (r6)
+	SHLR23 (r7)
+#else
+	shld	r3,r6
+	shld	r3,r7
+#endif
+
+	cmp/eq	r0,r4
+
+	bt	.L_op1_zero		!dividend=0
+	cmp/eq	r0,r6
+
+	mov.l   .L_imp_bit,r3
+	bt	.L_norm_op1		!normalize dividend
+.L_chk_op2:
+	cmp/eq	r0,r5
+	bt	.L_op2_zero		!divisor=0
+
+	cmp/eq	r0,r7
+	bt	.L_norm_op2		!normalize divisor
+
+.L_div1:
+	sub	r7,r6
+	add	#127,r6			!r6=resultant exponent
+
+	mov     r3,r7
+	mov.l	.L_mask_mant,r3
+
+	and	r3,r4
+	!chk exponent for overflow
+        mov.l   .L_255,r2
+
+	and     r3,r5
+	or	r7,r4
+
+	cmp/ge  r2,r6
+	or	r7,r5
+
+	bt	.L_return_inf
+	mov	r0,r2
+
+	cmp/eq  r4,r5
+	bf      .L_den_one
+
+	cmp/ge	r6,r0
+	!numerator=denominator, quotient=1, remainder=0
+	mov	r7,r2			
+
+	mov     r0,r4
+	!chk exponent for underflow
+	bt	.L_underflow
+        bra     .L_pack
+        nop
+
+.L_den_one:
+	!denominator=1, result=numerator
+
+	cmp/eq  r7,r5
+        bf      .L_divide
+
+	!chk exponent for underflow
+	cmp/ge  r6,r0
+        mov    r4,r2           
+
+        SL(bt,    .L_underflow,
+	 mov	r0,r4)
+	bra     .L_pack
+	nop
+
+.L_divide:
+	!dividing the mantissas r4<-dividend, r5<-divisor
+
+	cmp/hi	r4,r5
+	bf	.L_loop
+
+	shll	r4		! if mantissa(op1)< mantissa(op2)
+	add     #-1,r6		! shift left the numerator and decrease the exponent.
+
+.L_loop:
+	!division loop
+
+	cmp/ge	r5,r4
+	bf	.L_skip
+
+	or	r7,r2
+	sub	r5,r4
+
+.L_skip:
+	shlr	r7
+	shll	r4
+
+	cmp/eq	r0,r7
+	bf	.L_loop
+
+	!chk the exponent for underflow
+	cmp/ge  r6,r0
+	bt      .L_underflow
+	
+	!apply rounding
+	cmp/gt	r5,r4
+	bt	.L_round1
+
+	cmp/eq	r4,r5
+	bt	.L_round2
+
+.L_pack:
+	!pack the result, r1=sign, r2=quotient, r6=exponent
+
+	mov    #23,r4
+	and     r3,r2
+
+#if defined (__sh1__) || defined (__sh2__) || defined (__SH2E__)
+	SHLL23 (r6)
+#else
+	shld	r4,r6
+#endif
+	or	r2,r1
+
+	or	r6,r1
+	mov	r1,r0	
+	
+	rts
+	nop
+
+.L_round1:
+	!Apply proper rounding
+
+        bra     .L_pack
+        add     #1,r2
+
+.L_round2:
+	!Apply proper rounding
+
+        mov.l   .L_comp_1,r5
+        bra     .L_pack
+        and     r5,r2
+
+.L_op1_inv:
+	!chk if op1 is Inf or NaN
+
+	mov.l	.L_mask_mant,r3
+	mov	r4,r6
+
+	and	r3,r6
+	cmp/hi	r0,r6
+
+	bt	.L_ret_op1
+	cmp/eq	r2,r7
+
+	SL(bf,	.L_ret_op1,
+	 mov	r1,r0)
+
+	rts
+	mov	#-1,r0	! 0/0, return NaN
+	
+.L_op2_inv:
+	!chk if op2 is Inf or NaN
+
+	mov.l	.L_mask_mant,r3
+	mov	r5,r7
+	
+	and	r3,r7
+	cmp/hi	r0,r7
+
+	bt	.L_ret_op2
+	mov	r1,r0
+	
+	rts
+	nop
+
+.L_op1_zero:
+	!op1 is zero. If op2 is zero, return NaN, else return zero
+
+	cmp/eq	r0,r5
+
+	bf	.L_ret_op1	
+
+	rts
+	mov	#-1,r0
+
+.L_op2_zero:
+	!B is zero,return Inf
+
+	rts
+	or	r2,r0
+
+.L_return_inf:
+	mov.l	.L_inf,r0
+	
+	rts
+	or	r1,r0
+
+.L_norm_op1:
+	!normalize dividend
+
+	shll	r4
+	tst	r2,r4
+	
+	add     #-1,r6
+	bt	.L_norm_op1
+
+	bra	.L_chk_op2
+	add	#1,r6
+
+.L_norm_op2:
+	!normalize divisor
+
+	shll	r5
+	tst	r2,r5
+	
+	add	#-1,r7
+	bt	.L_norm_op2
+
+	bra	.L_div1
+	add	#1,r7
+
+.L_underflow:
+	!denormalize the result
+
+	add	#1,r6
+	mov	#-24,r7
+
+	cmp/gt	r6,r7
+	mov	r2,r5
+
+	bt	.L_return_zero
+	add     #-1,r6
+
+	mov	#32,r3
+	neg	r6,r7
+
+	add	#1,r7
+#if !defined (__sh1__) && !defined (__sh2__) && !defined (__SH2E__)
+	shld	r6,r2
+#else
+	cmp/ge	r0,r6
+	bf	.L_mov_right
+
+.L_mov_left:
+	cmp/eq	r0,r6
+	bt	.L_out
+
+	shll	r2
+	bra	.L_mov_left
+	add	#-1,r6
+
+.L_mov_right:
+	cmp/eq	r0,r6
+	bt	.L_out
+
+	add	#1,r6
+	bra	.L_mov_right
+	shlr	r2
+	
+.L_out:
+#endif
+	sub	r7,r3
+
+#if !defined (__sh1__) && !defined (__sh2__) && !defined (__SH2E__)
+	shld	r3,r5
+#else
+	cmp/ge	r0,r3
+	bf	.L_mov_right_1
+
+.L_mov_left_1:
+	shll	r5
+	add	#-1,r3
+
+	cmp/eq	r0,r3
+	bf	.L_mov_left_1
+
+	bt	.L_out_1
+
+.L_mov_right_1:
+	cmp/eq	r0,r3
+	bt	.L_out_1
+
+	add	#1,r3
+	bra	.L_mov_right_1
+	shlr	r5
+
+.L_out_1:
+#endif
+	shlr	r2
+	addc	r0,r2
+
+	cmp/eq	r4,r0		!r4 contains the remainder
+	mov      r2,r0
+
+	mov.l	.L_mask_sign,r7
+	bf	.L_return
+
+	mov.l   .L_comp_1,r2
+	cmp/eq	r7,r5
+
+	bf	.L_return
+	and	r2,r0
+
+.L_return:
+	rts
+	or     r1,r0
+	
+.L_ret_op1:
+	rts
+	or	r4,r0
+
+.L_ret_op2:
+	rts
+	or	r5,r0
+
+.L_return_zero:
+	rts
+	or	r1,r0
+
+
+
+	.align	2
+.L_inf:
+	.long	0x7f800000
+.L_mask_sign:
+	.long	0x80000000
+.L_mask_mant:
+	.long	0x007fffff
+.L_imp_bit:
+	.long	0x00800000
+.L_comp_1:
+	.long	0xfffffffe
+.L_255:
+	.long	255
+
+ENDFUNC (GLOBAL (divsf3))
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/fixdfsi.S gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/fixdfsi.S
--- gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/fixdfsi.S	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/fixdfsi.S	2013-05-28 13:16:16.000000000 +0200
@@ -0,0 +1,200 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.  */
+
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!conversion of double precision floating point number to signed integer
+!Author:Aanchal Khanna
+!
+!Entry:
+!r4,r5:operand
+!
+!Exit:
+!r0:result
+!
+!Note:argument is passed in regs r4 and r5, the result is returned in
+!reg r0.
+!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+
+	.text
+	.align 	5
+	.global GLOBAL (fixdfsi)
+	FUNC (GLOBAL (fixdfsi))
+
+GLOBAL (fixdfsi):
+
+#ifdef  __LITTLE_ENDIAN__
+        mov     r4,r1
+        mov     r5,r4
+        mov     r1,r5
+
+#endif
+	mov.l	.L_p_inf,r2
+	mov     #-20,r1
+	
+	mov	r2,r7
+	mov.l   .L_1023,r3
+
+	and	r4,r2
+	shll    r4
+        
+	movt    r6		! r6 contains the sign bit
+	
+#if !defined (__sh1__) && !defined (__sh2__) && !defined (__SH2E__)
+        shld    r1,r2		! r2 contains the exponent
+#else
+        SHLR20 (r2)
+#endif
+	 shlr    r4
+
+#if !defined (__sh1__) && !defined (__sh2__) && !defined (__SH2E__)
+        shld    r1,r7
+#else
+        SHLR20 (r7)
+#endif
+	cmp/hi	r2,r3		! if exp < 1023,return 0
+	mov.l	.L_mask_high_mant,r1
+
+	SL(bt,	.L_epil,
+	 mov	#0,r0)
+	and	r4,r1		! r1 contains high mantissa
+
+	cmp/eq	r2,r7		! chk if exp is invalid
+	mov.l	.L_1053,r7
+
+	bt	.L_inv_exp
+	mov	#11,r0
+	
+	cmp/hi	r7,r2		! If exp > 1053,return maxint
+	sub     r2,r7
+
+	mov.l	.L_21bit,r2
+	SL(bt,	.L_ret_max,
+	 add	#1,r7)		! r7 contains the number of shifts
+
+	or	r2,r1
+	mov	r7,r3
+	shll8   r1
+
+	neg     r7,r7
+	shll2	r1
+
+        shll	r1
+	cmp/hi	r3,r0
+
+	!chk if the result can be made only from higher mantissa
+	SL(bt,	.L_lower_mantissa,
+	 mov	#21,r0)
+
+#if !defined (__sh1__) && !defined (__sh2__) && !defined (__SH2E__)
+        shld    r7,r1
+#else
+.L_loop:
+        tst	r7,r7
+        bt      .L_break1
+        add     #1,r7
+        bra     .L_loop
+        shlr    r1
+
+.L_break1:
+#endif
+	tst	r6,r6
+	SL(bt,	.L_epil,
+	 mov	r1,r0)
+
+	rts
+	neg	r0,r0
+
+.L_lower_mantissa:
+	!result is made from lower mantissa also
+	neg	r0,r0
+
+#if !defined (__sh1__) && !defined (__sh2__) && !defined (__SH2E__)
+        shld    r0,r5
+#else
+        SHLR21 (r5)
+#endif
+
+	or	r5,r1		!pack lower and higher mantissas
+
+#if !defined (__sh1__) && !defined (__sh2__) && !defined (__SH2E__)
+        shld    r7,r1
+#else
+.L_sh_loop:
+	tst	r7,r7
+	bt	.L_break
+	add	#1,r7
+	bra	.L_sh_loop
+	shlr	r1
+
+.L_break:
+#endif
+	mov	r1,r0
+	bra	.L_chk_sign
+	nop
+
+.L_epil:
+	rts
+	nop
+
+.L_inv_exp:
+	cmp/hi	r0,r5
+	bt	.L_epil
+
+	cmp/hi	r0,r1		!compare high mantissa,r1
+	bt	.L_epil
+
+.L_ret_max:
+	mov.l   .L_maxint,r0
+	tst	r6,r6
+	bt	.L_epil
+
+	rts
+	add	#1,r0
+
+.L_chk_sign:
+	tst	r6,r6		!sign bit is set, number is -ve
+	bt	.L_epil
+	
+	rts
+	neg	r0,r0
+
+	.align	2
+
+.L_maxint:
+	.long	0x7fffffff
+.L_p_inf:
+	.long	0x7ff00000
+.L_mask_high_mant:
+	.long	0x000fffff
+.L_1023:
+	.long	0x000003ff
+.L_1053:
+	.long	1053
+.L_21bit:
+	.long	0x00100000
+
+ENDFUNC (GLOBAL (fixdfsi))
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/fixsfsi.S gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/fixsfsi.S
--- gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/fixsfsi.S	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/fixsfsi.S	2013-05-28 13:16:16.000000000 +0200
@@ -0,0 +1,165 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.  */
+
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+! Conversion routine for float to integer
+
+! Author: Rakesh Kumar
+
+! Arguments: r4 (in floating point format)
+! Return: r0
+
+! r4 is referred as op1
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+
+	.text
+	.align 5
+	.global	GLOBAL (fixsfsi)
+	FUNC (GLOBAL (fixsfsi))
+
+GLOBAL (fixsfsi):
+	mov.l	.L_mask_sign,r7
+	mov	r4,r2
+
+	! Check for NaN
+	mov.l	.L_inf,r1
+	and	r7,r2
+
+	cmp/gt	r1,r2
+	mov	#127,r5
+
+	mov	r4,r3
+	SL(bt,	.L_epil,
+	 mov	#0,r0)
+
+	shll	r2
+	mov.l	.L_frac,r6
+
+	shlr16	r2
+	and	r6,r3	! r3 has fraction
+
+	shlr8	r2	! r2 has exponent
+	mov.l	.L_24bit,r1
+
+	! If exponent is less than 127, return 0
+	cmp/gt	r2,r5
+	or	r1,r3	! Set the implicit bit
+
+	mov.l	.L_157,r1
+	SL1(bt,	.L_epil,
+	 shll8	r3)
+
+	! If exponent is greater than 157,
+	! return the maximum/minumum integer
+	! value deducing from sign
+	cmp/gt	r1,r2
+	sub	r2,r1
+
+	mov.l	.L_sign,r2
+	SL(bt,	.L_ret_max,
+	 add	#1,r1)
+
+	and	r4,r2	! Sign in r2
+	neg	r1,r1
+
+	! Shift mantissa by exponent difference from 157
+#if !defined (__sh1__) && !defined (__sh2__) && !defined (__SH2E__)
+	shld	r1,r3
+#else
+        cmp/gt  r0,r1
+        bt      .L_mov_left
+
+.L_mov_right:
+        cmp/eq  r1,r0
+        bt      .L_ret
+
+        add     #1,r1
+        bra     .L_mov_right
+
+        shlr    r3
+
+.L_mov_left:
+        add     #-1,r1
+
+        shll    r3
+        cmp/eq  r1,r0
+
+        bf      .L_mov_left
+.L_ret:
+#endif
+	! If op1 is negative, negate the result
+	cmp/eq	r0,r2
+	SL(bf,	.L_negate,
+	 mov	r3,r0)
+
+! r0 has the appropriate value
+.L_epil:
+	rts
+	nop
+
+! Return the max/min integer value
+.L_ret_max:
+	and	r4,r2	! Sign in r2
+	mov.l	.L_max,r3
+
+	mov.l	.L_sign,r1
+	cmp/eq	r0,r2
+
+	mov	r3,r0
+	bt	.L_epil
+
+	! Negative number, return min int
+	rts
+	mov	r1,r0
+
+! Negate the result
+.L_negate:
+	rts
+	neg	r0,r0
+
+	.align 2
+.L_inf:
+	.long 0x7F800000
+
+.L_157:
+	.long 157
+
+.L_max:
+	.long 0x7FFFFFFF
+
+.L_frac:
+	.long 0x007FFFFF
+
+.L_sign:
+	.long 0x80000000
+
+.L_24bit:
+	.long 0x00800000
+
+.L_mask_sign:
+	.long 0x7FFFFFFF
+
+ENDFUNC (GLOBAL (fixsfsi))
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/fixunsdfsi.S gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/fixunsdfsi.S
--- gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/fixunsdfsi.S	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/fixunsdfsi.S	2013-05-28 13:16:16.000000000 +0200
@@ -0,0 +1,181 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.  */
+
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!conversion of double precision floating point number to unsigned integer
+!Author:Aanchal Khanna
+!
+!Entry:
+!r4,r5:operand
+!
+!Exit:
+!r0:result
+!
+!Note:argument is passed in regs r4 and r5, the result is returned in
+!reg r0.
+!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+
+	.text
+	.align 5
+	.global GLOBAL (fixunsdfsi)
+	FUNC (GLOBAL (fixunsdfsi))
+
+GLOBAL (fixunsdfsi):
+
+#ifdef  __LITTLE_ENDIAN__
+        mov     r4,r1
+        mov     r5,r4
+        mov     r1,r5
+#endif
+	mov.l	.L_p_inf,r2
+	mov     #-20,r1
+	
+	mov	r2,r7
+	mov.l   .L_1023,r3
+
+	and	r4,r2
+	shll    r4
+
+        movt    r6		! r6 contains the sign bit
+#if !defined (__sh1__) && !defined (__sh2__) && !defined (__SH2E__)
+        shld    r1,r2           ! r2 contains the exponent
+#else
+        SHLR20 (r2)
+#endif
+	shlr    r4
+#if !defined (__sh1__) && !defined (__sh2__) && !defined (__SH2E__)
+        shld    r1,r7
+#else
+        SHLR20 (r7)
+#endif
+	tst	r6,r6	
+	SL(bf,	.L_epil,
+	 mov	#0,r0)
+
+	cmp/hi	r2,r3		! if exp < 1023,return 0
+	mov.l	.L_high_mant,r1
+
+	SL(bt,	.L_epil,
+	 and	r4,r1)		! r1 contains high mantissa
+
+	cmp/eq	r2,r7		! chk if exp is invalid
+	mov.l	.L_1054,r7
+
+	bt	.L_inv_exp
+	mov	#11,r0
+	
+	cmp/hi	r7,r2		! If exp > 1054,return maxint
+	sub     r2,r7		!r7 contains the number of shifts
+
+	mov.l	.L_21bit,r2
+	bt	.L_ret_max
+
+	or	r2,r1
+	mov	r7,r3
+
+	shll8   r1
+	neg     r7,r7
+
+	shll2	r1
+
+        shll	r1
+	cmp/hi	r3,r0
+
+	SL(bt,	.L_lower_mant,
+	 mov	#21,r0)
+
+#if !defined (__sh1__) && !defined (__sh2__) && !defined (__SH2E__)
+        shld    r7,r1
+#else
+.L_sh_loop:
+        tst	r7,r7
+        bt      .L_break
+        add     #1,r7
+        bra     .L_sh_loop
+        shlr    r1
+
+.L_break:
+#endif
+	rts
+	mov     r1,r0
+
+.L_lower_mant:
+	neg	r0,r0
+
+#if !defined (__sh1__) && !defined (__sh2__) && !defined (__SH2E__)
+        shld    r0,r5
+#else
+        SHLR21 (r5)
+#endif
+	or	r5,r1		!pack lower and higher mantissas
+
+#if !defined (__sh1__) && !defined (__sh2__) && !defined (__SH2E__)
+        shld    r7,r1
+#else
+.L_loop:
+        tst	r7,r7
+        bt      .L_break1
+        add     #1,r7
+        bra     .L_loop
+        shlr    r1
+
+.L_break1:
+#endif
+	mov	r1,r0
+.L_epil:
+	rts
+	nop
+
+.L_inv_exp:
+	cmp/hi	r0,r5
+	bt	.L_epil
+
+	cmp/hi	r0,r1		!compare high mantissa,r1
+	bt	.L_epil
+
+.L_ret_max:
+	mov.l   .L_maxint,r0
+
+	rts
+	nop
+
+	.align	2
+
+.L_maxint:
+	.long	0xffffffff
+.L_p_inf:
+	.long	0x7ff00000
+.L_high_mant:
+	.long	0x000fffff
+.L_1023:
+	.long	0x000003ff
+.L_1054:
+	.long	1054
+.L_21bit:
+	.long	0x00100000
+
+ENDFUNC (GLOBAL (fixunsdfsi))
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/fixunssfsi.S gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/fixunssfsi.S
--- gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/fixunssfsi.S	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/fixunssfsi.S	2013-05-28 13:16:16.000000000 +0200
@@ -0,0 +1,155 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.  */
+
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+! Conversion from floating point to unsigned integer
+
+! Author: Rakesh Kumar
+
+! Argument: r4 (in floating point format)
+! Result: r0
+
+! For negative floating point numbers, it returns zero
+
+! The argument is referred as op1
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+
+	.text
+	.align 5
+	.global	GLOBAL (fixunssfsi)
+	FUNC (GLOBAL (fixunssfsi))
+
+GLOBAL (fixunssfsi):
+	mov.l	.L_sign,r0
+	mov	r4,r2
+
+	! Check for NaN
+	mov.l	.L_inf,r1
+	and	r4,r0
+
+	mov.l	.L_mask_sign,r7
+	mov	#127,r5
+
+	! Remove sign bit
+	cmp/eq	#0,r0
+	and	r7,r2
+
+	! If number is negative, return 0
+	! LIBGCC deviates from standard in this regard.
+	mov	r4,r3
+	SL(bf,	.L_epil,
+	 mov	#0,r0)
+
+	mov.l	.L_frac,r6
+	cmp/gt	r1,r2
+
+	shll	r2
+	SL1(bt,	.L_epil,
+	 shlr16	r2)
+
+	shlr8	r2	! r2 has exponent
+	mov.l	.L_24bit,r1
+
+	and	r6,r3	! r3 has fraction
+	cmp/gt	r2,r5
+
+	! If exponent is less than 127, return 0
+	or	r1,r3
+	bt	.L_epil
+
+	! Process only if exponent is less than 158
+	mov.l	.L_158,r1
+	shll8	r3
+
+	cmp/gt	r1,r2
+	sub	r2,r1
+
+	neg	r1,r1
+	bt	.L_ret_max
+
+! Shift the mantissa with exponent difference from 158
+#if !defined (__sh1__) && !defined (__sh2__) && !defined (__SH2E__)
+	shld	r1,r3
+#else
+	cmp/gt	r0,r1
+	bt	.L_mov_left
+
+.L_mov_right:
+	cmp/eq	r1,r0
+	bt	.L_ret
+
+	add	#1,r1
+	bra	.L_mov_right
+	shlr	r3
+
+.L_mov_left:
+	add	#-1,r1
+	
+	shll	r3
+	cmp/eq	r1,r0
+
+	bf	.L_mov_left
+
+.L_ret:	
+#endif
+	rts
+	mov	r3,r0
+
+! r0 already has appropriate value
+.L_epil:
+	rts
+	nop
+
+! Return the maximum unsigned integer value
+.L_ret_max:
+	mov.l	.L_max,r3
+
+	rts
+	mov	r3,r0
+
+	.align 2
+.L_inf:
+	.long 0x7F800000
+
+.L_158:
+	.long 158
+
+.L_max:
+	.long 0xFFFFFFFF
+
+.L_frac:
+	.long 0x007FFFFF
+
+.L_sign:
+	.long 0x80000000
+
+.L_24bit:
+	.long 0x00800000
+
+.L_mask_sign:
+	.long 0x7FFFFFFF
+
+ENDFUNC (GLOBAL (fixunssfsi))
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/floatsidf.S gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/floatsidf.S
--- gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/floatsidf.S	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/floatsidf.S	2013-05-28 13:16:16.000000000 +0200
@@ -0,0 +1,151 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.  */
+
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!conversion of signed integer to double precision floating point number
+!Author:Rakesh Kumar
+!
+!Entry:
+!r4:operand 
+!
+!Exit:
+!r0,r1:result
+!
+!Note:argument is passed in reg r4 and the result is returned in 
+!regs r0 and r1.
+!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+
+        .text
+        .align 5
+        .global GLOBAL (floatsidf)
+	FUNC (GLOBAL (floatsidf))
+
+GLOBAL (floatsidf):
+        mov.l   .L_sign,r0
+        mov     #0,r1
+
+	mov	r0,r2
+	tst	r4,r4 ! check r4 for zero
+
+	! Extract the sign
+	mov	r2,r3
+	SL(bt,	.L_ret_zero,
+	 and	r4,r0)
+
+	cmp/eq	r1,r0
+	not	r3,r3
+
+	mov	r1,r7
+	SL(bt,	.L_loop,
+	 and	r4,r3)
+
+	! Treat -2147483648 as special case
+	cmp/eq	r1,r3
+	neg	r4,r4
+
+	bt	.L_ret_min	
+
+.L_loop:
+	shll	r4	
+	mov	r4,r5
+
+	and	r2,r5
+	cmp/eq	r1,r5
+	
+	add	#1,r7
+	bt	.L_loop
+
+	mov.l	.L_initial_exp,r6
+	not	r2,r2
+	
+	and	r2,r4
+	mov	#21,r3
+
+	sub	r7,r6
+	mov	r4,r1
+
+	mov	#20,r7
+
+#if !defined (__sh1__) && !defined (__sh2__) && !defined (__SH2E__)
+        shld    r3,r1
+#else
+        SHLL21 (r1)
+#endif
+	mov	#-11,r2
+
+#if !defined (__sh1__) && !defined (__sh2__) && !defined (__SH2E__)
+        shld    r7,r6	! Exponent in proper place
+#else
+        SHLL20 (r6)
+#endif
+
+#if !defined (__sh1__) && !defined (__sh2__) && !defined (__SH2E__)
+        shld    r2,r4
+#else
+        SHLR11 (r4)
+#endif
+	or	r6,r0
+
+#ifdef __LITTLE_ENDIAN__
+        mov     r0,r2
+        mov     r1,r0
+        mov     r2,r1
+#endif
+	rts
+#ifdef __LITTLE_ENDIAN__
+	or	r4,r1
+#else
+	or	r4,r0
+#endif
+	
+.L_ret_zero:
+	rts
+	mov	#0,r0
+
+.L_ret_min:
+	mov.l	.L_min,r0
+	
+#ifdef __LITTLE_ENDIAN__
+        mov     r0,r2
+        mov     r1,r0
+        mov     r2,r1
+#endif
+	rts
+	nop
+
+	.align 2
+
+.L_initial_exp:
+	.long 0x0000041E
+
+.L_sign:
+	.long 0x80000000
+
+.L_min:
+	.long 0xC1E00000
+
+ENDFUNC (GLOBAL (floatsidf))
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/floatsisf.S gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/floatsisf.S
--- gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/floatsisf.S	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/floatsisf.S	2013-05-28 13:16:16.000000000 +0200
@@ -0,0 +1,200 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.  */
+
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+! Conversion of integer to floating point
+
+! Author: Rakesh Kumar
+
+! Argument: r4
+! Result: r0
+
+! r4 is referred as op1
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+
+        .text
+        .align 5
+        .global GLOBAL (floatsisf)
+        FUNC (GLOBAL (floatsisf))
+
+GLOBAL (floatsisf):
+	mov.l	.L_sign,r2
+	mov	#23,r6
+
+	! Check for zero
+	tst	r4,r4
+	mov.l	.L_24_bits,r7
+
+	! Extract sign
+	and	r4,r2
+	bt	.L_ret
+
+	! Negative ???
+	mov.l	.L_imp_bit,r5
+	cmp/pl	r4
+
+	not	r7,r3
+	bf	.L_neg
+
+	! Decide the direction for shifting
+	cmp/gt	r7,r4
+	mov	r4,r0
+
+	and	r5,r0
+	bt	.L_shr_0
+
+	! Number may already be in normalized form
+	cmp/eq	#0,r0
+	bf	.L_pack
+
+! Shift the bits to the left. Adjust the exponent
+.L_shl:
+	shll	r4
+	mov	r4,r0
+
+	and	r5,r0
+	cmp/eq	#0,r0
+
+	SL(bt,	.L_shl,
+	 add	#-1,r6)
+
+! Pack the value in floating point format.
+! r6 has unbiased exponent, r4 has mantissa, r2 has sign
+.L_pack:
+	mov	#23,r3
+	not	r5,r5
+
+	mov	r2,r0
+	add	#127,r6
+
+	and	r5,r4
+#if defined (__sh1__) || defined (__sh2__) || defined (__SH2E__)
+	SHLL23 (r6)
+#else
+	shld	r3,r6
+#endif
+
+	or	r6,r0
+	rts
+	or	r4,r0
+
+! Negate the number
+.L_neg:
+	! Take care for -2147483648.
+	mov	r4,r0
+	shll	r0
+	
+	cmp/eq	#0,r0
+	SL(bt,	.L_ret_min,
+	 neg	r4,r4)
+
+        cmp/gt  r7,r4
+        bt	.L_shr_0
+
+	mov	r4,r0
+	and	r5,r0
+
+	cmp/eq	#0,r0
+	bf	.L_pack
+	bt	.L_shl
+	
+.L_shr_0:
+	mov	#0,r1
+
+! Shift right the number with rounding
+.L_shr:
+	shlr	r4
+	movt	r7
+
+	tst	r7,r7
+
+	! Count number of ON bits shifted
+	bt	.L_shr_1
+	add	#1,r1
+
+.L_shr_1:
+	mov	r4,r0
+	add	#1,r6
+
+	and	r3,r0
+	cmp/eq	#0,r0
+
+	! Add MSB of shifted bits
+	bf	.L_shr
+	add	r7,r4
+
+	tst	r7,r7
+	bt	.L_pack
+
+.L_pack1:
+	mov	#1,r0
+	cmp/eq	r1,r0
+
+	bt	.L_rnd
+	mov	r4,r0
+
+	! Rounding may have misplaced MSB. Adjust.
+	and	r3,r0
+	cmp/eq	#0,r0
+
+	bf	.L_shr
+	bt	.L_pack
+
+! If only MSB of shifted bits is ON, we are halfway
+! between two numbers. Round towards even LSB of
+! resultant mantissa.
+.L_rnd:
+	shlr	r4
+	bra	.L_pack
+	shll	r4
+
+.L_ret:
+	rts
+	mov	r4,r0
+
+! Return value for -2147483648
+.L_ret_min:
+	mov.l	.L_min_val,r0
+	rts
+	nop
+
+	.align 2
+.L_sign:
+	.long 0x80000000
+
+.L_imp_bit:
+	.long 0x00800000
+
+.L_24_bits:
+	.long 0x00FFFFFF
+
+.L_nsign:
+	.long 0x7FFFFFFF
+
+.L_min_val:
+	.long 0xCF000000
+
+ENDFUNC (GLOBAL (floatsisf))
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/floatunssidf.S gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/floatunssidf.S
--- gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/floatunssidf.S	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/floatunssidf.S	2013-05-28 13:16:16.000000000 +0200
@@ -0,0 +1,76 @@
+/* Copyright (C) 2004, 2006 Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.  */
+
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!conversion of unsigned integer to double precision floating point number
+!Author:Rakesh Kumar
+!Rewritten for SH1 support: Joern Rennecke
+!
+!Entry:
+!r4:operand
+!
+!Exit:
+!r0,r1:result
+!
+!Note:argument is passed in reg r4 and the result is returned in
+!regs r0 and r1.
+!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+
+        .text
+        .align 5
+        .global GLOBAL (floatunsidf)
+	FUNC (GLOBAL (floatunsidf))
+
+GLOBAL (floatunsidf):
+	mov.w	LOCAL(x41f0),DBLRH	! bias + 32
+	tst	r4,r4			! check for zero
+	bt	.L_ret_zero
+.L_loop:
+	shll	r4	
+	SL(bf,	.L_loop,
+	 add	#-16,DBLRH)
+
+	mov	r4,DBLRL
+
+        SHLL20 (DBLRL)
+
+        shll16	DBLRH ! put exponent in proper place
+
+        SHLR12 (r4)
+
+	rts
+	or	r4,DBLRH
+	
+.L_ret_zero:
+	mov	#0,r1
+	rts
+	mov	#0,r0
+
+LOCAL(x41f0):	.word	0x41f0
+	.align 2
+
+ENDFUNC (GLOBAL (floatunsidf))
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/floatunssisf.S gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/floatunssisf.S
--- gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/floatunssisf.S	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/floatunssisf.S	2013-05-28 13:16:16.000000000 +0200
@@ -0,0 +1,137 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.  */
+
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+! Conversion of unsigned integer to floating point
+
+! Author: Rakesh Kumar
+
+! Argument: r4
+! Result: r0
+
+! r4 is referred as op1
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+
+        .text
+        .align 5
+        .global GLOBAL (floatunsisf)
+	FUNC (GLOBAL (floatunsisf))
+
+GLOBAL (floatunsisf):
+	tst	r4,r4
+	mov	#23,r6
+
+	mov.l	.L_set_24_bits,r7
+	SL(bt,	.L_return,
+	 not	r7,r3)
+
+	! Decide the direction for shifting
+	mov.l	.L_set_24_bit,r5
+	cmp/hi	r7,r4
+
+	not	r5,r2
+	SL(bt,	.L_shift_right,
+	 mov	#0,r7)
+
+	tst	r5,r4
+	
+	mov	#0,r0
+	bf	.L_pack_sf
+
+! Shift the bits to the left. Adjust the exponent
+.L_shift_left:
+	shll	r4
+	tst	r5,r4
+
+	add	#-1,r6
+	bt	.L_shift_left
+
+! Pack the value in floating point format.
+! r6 has unbiased exponent, r4 has mantissa
+.L_pack_sf:
+	mov	#23,r3
+	add	#127,r6
+
+	! Align the exponent
+	and	r2,r4
+#if defined (__sh1__) || defined (__sh2__) || defined (__SH2E__)
+        SHLL23 (r6)
+#else
+	shld	r3,r6
+#endif
+
+	or	r6,r0
+	rts
+	or	r4,r0
+
+! Shift right the number with rounding
+.L_shift_right:
+	shlr	r4
+	rotcr	r7
+
+	tst	r4,r3
+	add	#1,r6
+
+	bf	.L_shift_right
+	
+	tst	r7,r7
+	bt	.L_sh_rt_1
+
+	shll	r7
+	movt	r1
+
+	add	r1,r4
+
+	tst	r7,r7
+	bf	.L_sh_rt_1
+
+	! Halfway between two numbers.
+	! Round towards LSB = 0
+	shlr	r4
+	shll	r4
+
+.L_sh_rt_1:
+	mov	r4,r0
+
+	! Rounding may have misplaced MSB. Adjust.
+	and	r3,r0
+	cmp/eq	#0,r0
+
+	bf	.L_shift_right
+	bt	.L_pack_sf
+
+.L_return:
+	rts
+	mov	r4,r0
+
+	.align 2
+.L_set_24_bit:
+	.long 0x00800000
+
+.L_set_24_bits:
+	.long 0x00FFFFFF
+
+ENDFUNC (GLOBAL (floatunsisf))
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/m3/adddf3.S gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/m3/adddf3.S
--- gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/m3/adddf3.S	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/m3/adddf3.S	2013-05-28 13:16:16.000000000 +0200
@@ -0,0 +1,614 @@
+/* Copyright (C) 2004, 2006 Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.  */
+
+! adddf3 for the Renesas SH / STMicroelectronics ST40 CPUs.
+! Contributed by Joern Rennecke
+! joern.rennecke@st.com
+!
+! This code is optimized for SH4-200 without FPU, but can also be used for SH3.
+! Numbers with same sign are added in typically 37 cycles, worst case is
+! 43 cycles, unless there is an overflow, in which case the addition can
+! take up to takes 47 cycles.
+! Normal numbers with different sign are added in 56 (57 for PIC) cycles
+! or less on SH4.
+! If one of the inputs is a denormal, the worst case is 59 (60 for PIC)
+! cycles. (Two denormal inputs are faster than normal inputs, and
+! denormal outputs don't slow down computation).
+! Subtraction takes two cycles to negate the second input and then drops
+! through to addition.
+
+/* If the input exponents of a difference of two normalized numbers
+   differ by more than one, the output does not need to be adjusted
+   by more than one bit position.  Hence, it makes sense to ensure that
+   the shifts by 0 & 1 are handled quickly to reduce average and worst
+   case times.  */
+FUNC(GLOBAL(adddf3))
+FUNC(GLOBAL(subdf3))
+	.global	GLOBAL(adddf3)
+	.global	GLOBAL(subdf3)
+LOCAL(denorm_arg1):
+	bt LOCAL(inf_nan_arg0)
+	tst	r0,r2
+	bt/s	LOCAL(denorm_both)
+	shlr	r1
+	mov.l	LOCAL(x00100000),r3
+	bra	LOCAL(denorm_arg1_done)
+	 sub	r2,r3
+
+! Handle denorm addition here because otherwise the ordinary addition would
+! have to check for denormal results.
+! Denormal subtraction could also be done faster, but the denorm subtraction
+! path here is still one cycles faster than the one for normalized input
+! numbers, and 16 instructions shorter than the fastest version.
+! Here we also generate +0.0 + +0.0 -> +0.0 ; -0.0 + -0.0 -> -0.0
+LOCAL(denorm_both):
+	div0s	r8,DBL1H
+	mov.l	LOCAL(x800fffff),r9
+	bt/s	LOCAL(denorm_sub)
+	and	r1,DBL1H
+	and	r9,r8
+	mov.l	@r15+,r9
+	mov	DBL0L,DBLRL
+	mov	r8,DBLRH
+	addc	DBL1L,DBLRL
+	mov.l	@r15+,r8
+	rts
+	 addc	DBL1H,DBLRH
+
+! N.B., since subtraction also generates +0.0 for subtraction of numbers
+! with identical fractions, this also covers the +0.0 + -0.0 -> +0.0 /
+! -0.0 + +0.0 -> +0.0 cases.
+LOCAL(denorm_sub):
+	mov	r8,DBL0H	! tentative result sign
+	and	r1,DBL0H
+	bra	LOCAL(sub_same_exp)
+	 addc	r1,r2	! exponent++, clear T
+
+LOCAL(inf_nan_arg0):
+	cmp/hs 	r0,r3
+	bf		LOCAL(inf_nan_ret)
+	tst	DBL1L,DBL1L
+	bf		LOCAL(ret_nan)
+	shlr	r1
+	and 	DBL1H,r1
+	tst	r1,r1
+	bf		LOCAL(ret_nan)
+	div0s	r8,DBL1H
+	bf		LOCAL(inf_nan_ret)
+LOCAL(ret_nan):
+	mov 	#-1,DBLRH
+	bra	LOCAL(pop_r8_r9)
+		mov DBLRH,DBLRL
+  
+LOCAL(inf_nan_ret):
+	mov	DBL0L,DBLRL
+	bra	LOCAL(pop_r8_r9)
+		mov r8,DBLRH
+
+LOCAL(ret_arg0):
+	mov.l LOCAL(x800fffff),DBLRH
+	mov	DBL0L,DBLRL
+	mov	r2,r3
+LOCAL(ret_arg):
+	mov.l	@r15+,r9
+	and	r8,DBLRH
+	mov.l	@r15+,r8
+	rts
+	or r3,DBLRH
+
+LOCAL(no_carry):
+	shlr	r0
+	mov.l	LOCAL(x000fffff),DBLRH
+	addc	r3,r9
+	mov.w	LOCAL(d0),DBL1H
+	mov	DBL0L,DBLRL
+	and	DBL0H,DBLRH	! mask out implicit 1
+	mov.l	LOCAL(x7ff00000),r3
+	addc	DBL1H,DBLRL
+	addc	r2,DBLRH
+	mov.l	@r15+,r9
+	add	DBL1H,DBLRH	! fraction overflow -> exp increase
+	bra	LOCAL(add_done)
+	 cmp/hi	r3,DBLRH
+
+LOCAL(inf):
+	mov	#0,DBLRL
+	bra	LOCAL(or_sign)
+	mov	r3,DBLRH
+
+	.balign	4
+GLOBAL(subdf3):
+	cmp/pz DBL1H
+	add 	DBL1H,DBL1H
+	rotcr	DBL1H
+	nop
+
+GLOBAL(adddf3):
+	mov.l	LOCAL(x7ff00000),r0
+	mov	DBL0H,r2
+	mov.l	LOCAL(x001fffff),r1
+	mov	DBL1H,r3
+	mov.l	r8,@-r15
+	and	r0,r2		! r2 <- exp0
+	mov.l	r9,@-r15
+	and	r0,r3		! r3 <- exp1
+	cmp/hi r2,r3
+	or		r0,DBL0H
+	or		r0,DBL1H
+	bt		LOCAL(arg1_gt)
+	tst	r0,r3
+	mov	#-20,r9
+	mov	DBL0H,r8	! tentative result sign
+	and	r1,DBL0H	! arg0 fraction
+	bt/s	LOCAL(denorm_arg1)
+		cmp/hs r0,r2
+	bt		LOCAL(inf_nan_arg0)
+	sub	r2,r3
+LOCAL(denorm_arg1_done):	! r2 is tentative result exponent
+	shad	r9,r3
+	mov.w	LOCAL(m32),r9
+	mov	DBL1H,r0	! the 'other' sign
+	and	r1,DBL1H	! arg1 fraction
+	cmp/ge r9,r3
+	mov	DBL1H,r1
+	bf/s	LOCAL(large_shift_arg1)
+	 shld	r3,DBL1H
+LOCAL(small_shift_arg1):
+	mov	DBL1L,r9
+	shld	r3,DBL1L
+	tst	r3,r3
+	add	#32,r3
+	bt/s	LOCAL(same_exp)
+	 div0s r8,r0	! compare signs
+	shld	r3,r1
+
+	or		r1,DBL1L
+	bf/s	LOCAL(add)
+	shld	r3,r9
+	clrt
+	negc	r9,r9
+	mov.l	LOCAL(x001f0000),r3
+LOCAL(sub_high):
+	mov	DBL0L,DBLRL
+	subc	DBL1L,DBLRL
+	mov	DBL0H,DBLRH
+	bra	LOCAL(subtract_done)
+	 subc	DBL1H,DBLRH
+
+LOCAL(large_shift_arg1):
+	mov	DBL1L,r9
+	shld	r3,r9
+	add	#64,r3
+	cmp/pl r3
+	shld	r3,r1
+	shld	r3,DBL1L
+	bf		LOCAL(ret_arg0)
+	tst	DBL1L,DBL1L
+	bt		LOCAL(large_shift_arg1_end)
+	mov	#1,DBL1L
+	or 	DBL1L,r9
+LOCAL(large_shift_arg1_end):
+	mov	DBL1H,DBL1L
+	mov	#0,DBL1H
+	add	r1,r9
+	div0s	r8,r0	! compare signs
+	bf		LOCAL(add)
+	clrt
+	mov.l	LOCAL(x001f0000),r3
+	bra	LOCAL(sub_high)
+	 negc	r9,r9
+
+LOCAL(add_clr_r9):
+	mov	#0,r9
+LOCAL(add):
+	mov.l	LOCAL(x00200000),r3
+	addc	DBL1L,DBL0L
+	addc	DBL1H,DBL0H
+	mov.l	LOCAL(x80000000),r1
+	tst	r3,DBL0H
+	mov.l	LOCAL(x7fffffff),r3
+	mov	DBL0L,r0
+	bt/s	LOCAL(no_carry)
+	and	r1,r8
+	tst	r9,r9
+	bf		LOCAL(add_one)
+	tst	#2,r0
+LOCAL(add_one):
+	subc	r9,r9
+	sett
+	mov	r0,DBLRL 
+	addc	r9,DBLRL
+	mov	DBL0H,DBLRH
+	addc	r9,DBLRH
+	shlr	DBLRH
+	mov.l	LOCAL(x7ff00000),r3
+	add	r2,DBLRH
+	mov.l	@r15+,r9
+	rotcr	DBLRL
+	cmp/hs r3,DBLRH
+LOCAL(add_done):
+	bt		LOCAL(inf)
+LOCAL(or_sign):
+	or		r8,DBLRH
+	rts
+	 mov.l @r15+,r8
+
+LOCAL(same_exp):
+	bf	LOCAL(add_clr_r9)
+	clrt
+LOCAL(sub_same_exp):
+	subc	DBL1L,DBL0L
+	mov.l	LOCAL(x001f0000),r3
+	subc	DBL1H,DBL0H
+	mov.w	LOCAL(d0),r9
+	bf	LOCAL(pos_difference_0)
+	clrt
+	negc	DBL0L,DBLRL
+	mov.l	LOCAL(x80000000),DBL0L
+	negc	DBL0H,DBLRH
+	mov.l	LOCAL(x00100000),DBL0H
+	tst	r3,DBLRH
+	not	r8,r8
+	bt/s	LOCAL(long_norm)
+	and	DBL0L,r8
+	bra	LOCAL(norm_loop_2)
+	 not	DBL0L,r3
+
+LOCAL(large_shift_arg0):
+	mov	DBL0L,r9
+	shld	r2,r9
+	add	#64,r2
+	cmp/pl	r2
+	shld	r2,r1
+	shld	r2,DBL0L
+	bf	LOCAL(ret_arg1_exp_r3)
+	tst	DBL0L,DBL0L
+	bt LOCAL(large_shift_arg0_end)
+	mov 	#1,DBL0L
+	or		DBL0L,r9 
+LOCAL(large_shift_arg0_end):
+	mov	DBL0H,DBL0L
+	mov	#0,DBL0H
+	add	r1,r9
+	div0s	r8,r0	! compare signs
+	mov	r3,r2	! tentative result exponent
+	bf	LOCAL(add)
+	clrt
+	negc	r9,r9
+	bra	LOCAL(subtract_arg0_arg1_done)
+	 mov	DBL1L,DBLRL
+
+LOCAL(arg1_gt):
+	tst	r0,r2			! r0 = 0x7ff00000 r2 = exp0
+	mov	#-20,r9
+	mov	DBL1H,r8		! tentative result sign
+	and	r1,DBL1H
+	bt/s	LOCAL(denorm_arg0)
+	cmp/hs	r0,r3
+	bt	LOCAL(inf_nan_arg1)
+	sub	r3,r2
+LOCAL(denorm_arg0_done):
+	shad	r9,r2			! r2 <- shifting value
+	mov.w	LOCAL(m32),r9
+	mov	DBL0H,r0		! the 'other' sign
+	and	r1,DBL0H
+	cmp/ge	r9,r2
+	mov	DBL0H,r1
+	bf/s	LOCAL(large_shift_arg0)
+		shld	r2,DBL0H
+LOCAL(small_shift_arg0):
+	mov	DBL0L,r9
+	shld	r2,DBL0L
+	mov.l	r3,@-r15
+	mov 	#32,r3
+	add	r3,r2
+	cmp/ge	r3,r2
+	bf LOCAL(shifting)
+	mov	#0,r1
+	mov 	r1,r9
+LOCAL(shifting):
+	shld	r2,r1
+	mov	r2,r3
+	shld	r3,r9
+	div0s	r8,r0		! compare signs
+	mov.l	@r15+,r2	! tentative result exponent
+	bf/s	LOCAL(add)
+	or	r1,DBL0L
+	clrt
+	negc	r9,r9
+	mov	DBL1L,DBLRL
+LOCAL(subtract_arg0_arg1_done):
+	subc	DBL0L,DBLRL
+	mov	DBL1H,DBLRH
+	mov.l	LOCAL(x001f0000),r3
+	subc	DBL0H,DBLRH
+/* Since the exponents were different, the difference is positive.  */
+/* Fall through */
+LOCAL(subtract_done):
+/* First check if a shift by a few bits is sufficient.  This not only
+   speeds up this case, but also alleviates the need for considering
+   lower bits from r9 or rounding in the other code.
+   Moreover, by handling the upper 1+4 bits of the fraction here, long_norm
+   can assume that DBLRH fits into 20 (20 < 16) bit.  */
+	tst	r3,DBLRH
+	mov.l	LOCAL(x80000000),r3
+	mov.l	LOCAL(x00100000),DBL0H
+	bt/s	LOCAL(long_norm)
+	and	r3,r8
+	mov.l	LOCAL(x7fffffff),r3
+LOCAL(norm_loop_2):	! Well, this used to be a loop...
+	tst	DBL0H,DBLRH
+	sub	DBL0H,r2
+	bf	LOCAL(norm_round)
+	shll	r9
+	rotcl	DBLRL
+	
+	rotcl	DBLRH
+	
+	 subc	DBL0H,r2
+LOCAL(norm_loop_1):
+	bt	LOCAL(denorm0_n)
+	tst	DBL0H,DBLRH
+	bf	LOCAL(norm_round)
+	shll	DBLRL
+	rotcl	DBLRH	! clears T
+	bra	LOCAL(norm_loop_1)
+	 subc	DBL0H,r2
+	 
+LOCAL(denorm_arg0):
+	bt	LOCAL(inf_nan_arg1)
+	mov.l	LOCAL(x00100000),r2
+	shlr	r1				! r1 <- 0xfffff
+	bra	LOCAL(denorm_arg0_done)
+	 sub	r3,r2			! r2 <- 1 - exp1
+
+LOCAL(inf_nan_arg1):
+	mov	DBL1L,DBLRL
+	bra	LOCAL(pop_r8_r9)
+	 mov	r8,DBLRH
+
+LOCAL(ret_arg1_exp_r3):
+	mov.l	LOCAL(x800fffff),DBLRH
+	bra	LOCAL(ret_arg)
+	 mov	DBL1L,DBLRL
+
+LOCAL(pos_difference_0):
+	tst	r3,DBL0H
+	mov	DBL0L,DBLRL
+	mov.l	LOCAL(x80000000),DBL0L
+	mov	DBL0H,DBLRH
+	mov.l	LOCAL(x00100000),DBL0H
+	bt/s	LOCAL(long_norm)
+	and	DBL0L,r8
+	bra	LOCAL(norm_loop_2)
+	 not	DBL0L,r3
+
+#ifdef __pic__
+	.balign 8
+#endif
+LOCAL(m32):
+	.word	-32
+LOCAL(d0):
+	.word	0
+#ifndef __pic__
+	.balign 8
+#endif
+! Because we had several bits of cancellations, we know that r9 contains
+! only one bit.
+! We'll normalize by shifting words so that DBLRH:DBLRL contains
+! the fraction with 0 < DBLRH <= 0x1fffff, then we shift DBLRH:DBLRL
+! up by 21 minus the number of non-zero bits in DBLRH.
+LOCAL(long_norm):
+	tst	DBLRH,DBLRH
+	mov.w	LOCAL(xff),DBL0L
+	mov	#21,r3
+	bf	LOCAL(long_norm_highset)
+	mov.l	LOCAL(x02100000),DBL1L	! shift 32, implicit 1
+	tst	DBLRL,DBLRL
+	extu.w	DBLRL,DBL0H
+	bt	LOCAL(zero_or_ulp)
+	mov	DBLRL,DBLRH
+	cmp/hi	DBL0H,DBLRL
+	bf	0f
+	mov.l	LOCAL(x01100000),DBL1L	! shift 16, implicit 1
+	clrt
+	shlr16  DBLRH
+	xtrct	DBLRL,r9
+	mov     DBLRH,DBL0H
+LOCAL(long_norm_ulp_done):
+0:	mov	r9,DBLRL	! DBLRH:DBLRL == fraction; DBL0H == DBLRH
+	subc	DBL1L,r2
+	bt	LOCAL(denorm1_b)
+#ifdef __pic__
+	mov.l	LOCAL(c__clz_tab),DBL1H
+LOCAL(long_norm_lookup):
+	mov	r0,r9
+	mova	LOCAL(c__clz_tab),r0
+	add	DBL1H,r0
+#else
+	mov	r0,r9
+LOCAL(long_norm_lookup):
+	mov.l	LOCAL(c__clz_tab),r0
+#endif /* __pic__ */
+	cmp/hi	DBL0L,DBL0H
+	bf	0f
+	shlr8	DBL0H
+0:	mov.b	@(r0,DBL0H),r0
+	bf	0f
+	add	#-8,r3
+0:	mov.w	LOCAL(d20),DBL0L
+	mov	#-20,DBL0H
+	clrt
+	sub	r0,r3
+	mov	r9,r0
+	mov	r3,DBL1H
+	shld	DBL0L,DBL1H
+	subc	DBL1H,r2
+	!
+	bf	LOCAL(no_denorm)
+	shad	DBL0H,r2
+	bra	LOCAL(denorm1_done)
+	add	r2,r3
+	
+LOCAL(norm_round):
+	cmp/pz	r2
+	mov	#0,DBL1H
+	bf	LOCAL(denorm0_1)
+	or	r8,r2
+	mov	DBLRL,DBL1L
+	shlr	DBL1L
+	addc	r3,r9
+	mov.l	@r15+,r9
+	addc	DBL1H,DBLRL	! round to even
+	mov.l	@r15+,r8
+	rts
+	 addc	r2,DBLRH
+
+LOCAL(norm_pack):
+	add	r8,DBLRH
+	mov.l	@r15+,r8
+	rts
+	add	r2,DBLRH
+
+LOCAL(denorm0_1):
+	mov.l	@r15+,r9
+	mov	r8,DBL0L
+	mov.l	@r15+,r8
+LOCAL(denorm0_shift):
+	shlr	DBLRH
+	rotcr	DBLRL
+
+	rts
+	add	DBL0L,DBLRH
+
+LOCAL(denorm0_n):
+	mov.l	@r15+,r9
+	mov	r8,DBL0L
+	addc	DBL0H,r2
+	mov.l	@r15+,r8
+	bra LOCAL(denorm0_shift)
+		  nop
+
+LOCAL(no_denorm):
+	add	r2,r8		! add (exponent - 1) to sign
+
+LOCAL(denorm1_done):
+	shld	r3,DBLRH
+	mov	DBLRL,DBL0L
+	shld	r3,DBLRL
+
+	add	r8,DBLRH	! add in sign and (exponent - 1)
+	mov.l	@r15+,r9
+	add	#-32,r3
+	mov.l	@r15+,r8
+	shld	r3,DBL0L
+
+	rts
+	add	DBL0L,DBLRH
+
+LOCAL(long_norm_highset):
+	mov.l	LOCAL(x00200000),DBL1L	! shift 1, implicit 1
+	shll	r9
+	rotcl	DBLRL
+	mov	DBLRH,DBL0H
+	rotcl	DBLRH	! clears T
+#ifdef __pic__
+	mov.l	LOCAL(c__clz_tab),DBL1H
+#else
+	mov	r0,r9
+#endif /* __pic__ */
+	subc	DBL1L,r2
+	add	#-1,r3
+	bf	LOCAL(long_norm_lookup)
+LOCAL(denorm1_a):
+	shlr	DBLRH
+	rotcr	DBLRL
+	mov.l	@r15+,r9
+	or	r8,DBLRH
+
+	rts
+	mov.l	@r15+,r8
+
+	.balign	4
+LOCAL(denorm1_b):
+	mov	#-20,DBL0L
+	shad	DBL0L,r2
+	mov	DBLRH,DBL0L
+	shld	r2,DBLRH
+	shld	r2,DBLRL
+	or	r8,DBLRH
+	mov.l	@r15+,r9
+	add	#32,r2
+	mov.l	@r15+,r8
+	shld	r2,DBL0L
+	rts
+	or	DBL0L,DBLRL
+
+LOCAL(zero_or_ulp):
+	tst	r9,r9
+	bf	LOCAL(long_norm_ulp_done)
+	! return +0.0
+LOCAL(pop_r8_r9):
+	mov.l	@r15+,r9
+	rts
+	mov.l	@r15+,r8
+
+LOCAL(d20):
+	.word	20
+LOCAL(xff):
+	.word 0xff
+	.balign	4
+LOCAL(x7ff00000):
+	.long	0x7ff00000
+LOCAL(x001fffff):
+	.long	0x001fffff
+LOCAL(x80000000):
+	.long	0x80000000
+LOCAL(x000fffff):
+	.long	0x000fffff
+LOCAL(x800fffff):
+	.long	0x800fffff
+LOCAL(x001f0000):
+	.long	0x001f0000
+LOCAL(x00200000):
+	.long	0x00200000
+LOCAL(x7fffffff):
+	.long	0x7fffffff
+LOCAL(x00100000):
+	.long	0x00100000
+LOCAL(x02100000):
+	.long	0x02100000
+LOCAL(x01100000):
+	.long	0x01100000
+LOCAL(c__clz_tab):
+#ifdef __pic__
+	.long	GLOBAL(clz_tab) - .
+#else
+	.long	GLOBAL(clz_tab)
+#endif
+ENDFUNC(GLOBAL(adddf3))
+ENDFUNC(GLOBAL(subdf3))
+
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/m3/addsf3.S gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/m3/addsf3.S
--- gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/m3/addsf3.S	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/m3/addsf3.S	2013-05-28 13:16:16.000000000 +0200
@@ -0,0 +1,290 @@
+/* Copyright (C) 2004, 2006 Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.  */
+
+! addsf3 for the Renesas SH / STMicroelectronics ST40 CPUs.
+! Contributed by Joern Rennecke
+! joern.rennecke@st.com
+
+	.balign 4
+	.global GLOBAL(subsf3)
+	FUNC(GLOBAL(subsf3))
+	.global GLOBAL(addsf3)
+	FUNC(GLOBAL(addsf3))
+GLOBAL(subsf3):
+	cmp/pz	r5
+	add	r5,r5
+	rotcr	r5
+	.balign 4
+GLOBAL(addsf3):
+	mov.l	LOCAL(x7f800000),r3
+	mov	r4,r6
+	add	r6,r6
+	mov	r5,r7
+	add	r7,r7
+	mov	r4,r0
+	or	r3,r0
+	cmp/hi	r6,r7
+	mov	r5,r1
+	bf/s	LOCAL(r4_hs)
+	 or	r3,r1
+	cmp/eq	r5,r1
+	bt	LOCAL(ret_r5) /* sole Inf or NaN, return unchanged.  */
+	shll8	r0	! r4 fraction
+	shll8	r1	! r5 fraction
+	mov	r6,r3
+	mov	#-24,r2
+	mov	r7,r6
+	shld	r2,r6	! r5 exp
+	mov	r0,r7
+	shld	r2,r3	! r4 exp
+	tst	r3,r3
+	sub	r6,r3	! exp difference (negative or 0)
+	bt	LOCAL(denorm_r4)
+LOCAL(denorm_r4_done): ! r1: u1.31
+	shld	r3,r0	! Get 31 upper bits, including 8 guard bits
+	mov.l	LOCAL(xff000000),r2
+	add	#31,r3
+	mov.l	r5,@-r15 ! push result sign.
+	cmp/pl	r3	! r0 has no more than one bit set -> return arg 1
+	shld	r3,r7	! copy of lowest guard bit in r0 and lower guard bits
+	bf	LOCAL(ret_stack)
+	div0s	r4,r5
+	bf/s	LOCAL(add)
+	 cmp/pl	r7	/* Is LSB in r0 clear, but any lower guards bit set?  */
+	subc	r0,r1
+	mov.l	LOCAL(c__clz_tab),r7
+	tst	r2,r1
+	mov	#-24,r3
+	bf/s LOCAL(norm_r0)
+	 mov	r1,r0
+	extu.w	r1,r1
+	bra	LOCAL(norm_check2)
+	 cmp/eq	r0,r1
+LOCAL(ret_r5):
+	rts
+	mov	r5,r0
+LOCAL(ret_stack):
+	rts
+	mov.l	@r15+,r0
+
+/* We leave the numbers denormalized, but we change the bit position to be
+   consistent with normalized numbers.  This also removes the spurious
+   leading one that was inserted before.  */
+LOCAL(denorm_r4):
+	tst	r6,r6
+	add	r0,r0
+	bf	LOCAL(denorm_r4_done)
+	bra	LOCAL(denorm_r4_done)
+	add	r1,r1
+LOCAL(denorm_r5):
+	tst	r6,r6
+	add	r1,r1
+	bf	LOCAL(denorm_r5_done)
+	clrt
+	bra	LOCAL(denorm_r5_done)
+	add	r0,r0
+
+/* If the exponent differs by two or more, normalization is minimal, and
+   few guard bits are needed for an exact final result, so sticky guard
+   bit compresion before subtraction (or add) works fine.
+   If the exponent differs by one, only one extra guard bit is generated,
+   and effectively no guard bit compression takes place.  */
+
+	.balign	4
+LOCAL(r4_hs):
+	cmp/eq	r4,r0
+	mov	#-24,r3
+	bt	LOCAL(inf_nan_arg0)
+	shld	r3,r7
+	shll8	r0
+	tst	r7,r7
+	shll8	r1
+	mov.l	LOCAL(xff000000),r2
+	bt/s	LOCAL(denorm_r5)
+	shld	r3,r6
+LOCAL(denorm_r5_done):
+	mov	r1,r3
+	subc	r6,r7
+	bf	LOCAL(same_exp)
+	shld	r7,r1	/* Get 31 upper bits.  */
+	add	#31,r7
+	mov.l	r4,@-r15 ! push result sign.
+	cmp/pl	r7
+	shld	r7,r3
+	bf	LOCAL(ret_stack)
+	div0s	r4,r5
+	bf/s	LOCAL(add)
+	 cmp/pl	r3	/* Is LSB in r1 clear, but any lower guard bit set?  */
+	subc	r1,r0
+	mov.l	LOCAL(c__clz_tab),r7
+LOCAL(norm_check):
+	tst	r2,r0
+	mov	#-24,r3
+	bf LOCAL(norm_r0)
+	extu.w	r0,r1
+	cmp/eq	r0,r1
+LOCAL(norm_check2):
+	mov	#-8,r3
+	bt LOCAL(norm_r0)
+	mov	#-16,r3
+LOCAL(norm_r0):
+	mov	r0,r1
+	shld	r3,r0
+#ifdef __pic__
+	add	r0,r7
+	mova  LOCAL(c__clz_tab),r0
+#endif
+	mov.b	@(r0,r7),r7
+	add	#25,r3
+	add	#-9+1,r6
+	mov	r1,r0
+	sub	r7,r3
+	mov.l	LOCAL(xbfffffff),r7
+	sub	r3,r6	/* generate exp-1  */
+	mov.w	LOCAL(d24),r2
+	cmp/pz	r6	/* check exp > 0  */
+	shld	r3,r0	/* Leading 1 becomes +1 exp adjustment.  */
+	bf	LOCAL(zero_denorm)
+LOCAL(denorm_done):
+	add	#30,r3
+	shld	r3,r1
+	mov.w   LOCAL(m1),r3
+	tst	r7,r1	! clear T if rounding up
+	shld	r2,r6
+	subc	r3,r0	! round - overflow will boost exp adjustment to 2.
+	mov.l	@r15+,r2
+	add	r6,r0	! overflow will generate inf
+	cmp/ge	r2,r3	! get sign into T
+	rts
+	rotcr	r0
+LOCAL(ret_r4):
+	rts
+	mov	r4,r0
+
+/* At worst, we are shifting the number back in place where an incoming
+   denormal was.  Thus, the shifts won't get out of range.  They still
+   might generate a zero fraction, but that's OK, that makes it 0.  */
+LOCAL(zero_denorm):
+	add	r6,r3
+	mov	r1,r0
+	mov	#0,r6	/* leading one will become free (except for rounding) */
+	bra	LOCAL(denorm_done)
+	shld	r3,r0
+
+/* Handle abs(r4) >= abs(r5), same exponents specially so we don't need
+   check for a zero fraction in the main path.  */
+LOCAL(same_exp):
+	div0s	r4,r5
+	mov.l	r4,@-r15
+	bf	LOCAL(add)
+	cmp/eq	r1,r0
+	mov.l	LOCAL(c__clz_tab),r7
+	bf/s	LOCAL(norm_check)
+	 sub	r1,r0
+	rts	! zero difference -> return +zero
+	mov.l	@r15+,r1
+
+/* r2: 0xff000000 */
+LOCAL(add):
+	addc	r1,r0
+	mov.w	LOCAL(x2ff),r7
+	shll8	r6
+	bf/s	LOCAL(no_carry)
+	shll16	r6
+	tst	r7,r0		
+	shlr8	r0
+	mov.l	@r15+,r3	! discard saved sign
+	subc	r2,r0
+	sett
+	addc	r6,r0
+	cmp/hs	r2,r0
+	bt/s	LOCAL(inf)
+	div0s	r7,r4 /* Copy sign.  */
+	rts
+	rotcr	r0
+LOCAL(inf):
+	mov	r2,r0
+	rts
+	rotcr	r0
+	
+LOCAL(no_carry):
+	mov.w	LOCAL(m1),r3
+	tst	r6,r6
+	bt	LOCAL(denorm_add)
+	add	r0,r0
+	tst	r7,r0		! check if lower guard bit set or round to even
+	shlr8	r0
+	mov.l	@r15+,r1	! discard saved sign
+	subc	r3,r0	! round ; overflow -> exp++
+	cmp/ge	r4,r3	/* Copy sign.  */
+	add	r6,r0	! overflow -> inf
+	rts
+	rotcr	r0
+
+LOCAL(denorm_add):
+	cmp/ge	r4,r3	/* Copy sign.  */
+	shlr8	r0
+	mov.l	@r15+,r1	! discard saved sign
+	rts
+	rotcr	r0
+
+LOCAL(inf_nan_arg0):
+	cmp/eq	r5,r1
+	bf	LOCAL(ret_r4)
+	div0s	r4,r5		/* Both are inf or NaN, check signs.  */
+	bt	LOCAL(ret_nan)	/* inf - inf, or NaN.  */
+	mov	r4,r0		! same sign; return NaN if either is NaN.
+	rts
+	or	r5,r0
+LOCAL(ret_nan):
+	rts
+	mov	#-1,r0
+
+LOCAL(d24):
+	.word	24
+LOCAL(x2ff):
+	.word	0x2ff
+LOCAL(m1):
+	.word	-1
+	.balign	4
+LOCAL(x7f800000):
+	.long	0x7f800000
+LOCAL(xbfffffff):
+	.long	0xbfffffff
+LOCAL(xff000000):
+	.long	0xff000000
+LOCAL(xfe000000):
+	.long	0xfe000000
+LOCAL(c__clz_tab):
+#ifdef __pic__
+	.long	GLOBAL(clz_tab) - .
+#else
+	.long	GLOBAL(clz_tab)
+#endif
+
+	ENDFUNC(GLOBAL(addsf3))
+	ENDFUNC(GLOBAL(subsf3))
+
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/m3/divdf3-rt.S gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/m3/divdf3-rt.S
--- gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/m3/divdf3-rt.S	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/m3/divdf3-rt.S	2013-05-28 13:16:16.000000000 +0200
@@ -0,0 +1,519 @@
+/* Copyright (C) 2004, 2006 Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.  */
+
+! divdf3 for the Renesas SH / STMicroelectronics ST40 CPUs.
+! Contributed by Joern Rennecke joern.rennecke@st.com
+
+/* This version is not quite finshed, since I've found that I can
+   get better average performance with a slightly altered algorithm.
+   Still, if you want a version for hard real time, this version here might
+   be a good starting point, since it has effectively no conditional
+   branches in the path that deals with normal numbers
+   (branches with zero offset are effectively conditional execution),
+   and thus it has a uniform execution time in this path.  */
+
+/* y = 1/x  ; x (- [1,2)
+   y0 = 1.5 - x/2 - tab[(1-x)*64] = y + d ; abs(d)/y <= 0x1.0c/256
+
+   y1 = y0 - ((y0) * x - 1) * y0  =  y-x*d^2
+   y2 = y1 - ((y1) * x - 1) * y1 =~= y-x^3*d^4
+
+   z0 = y2*a ;  a1 = a - z0*x /# 32 * 64 -> 64 bit #/
+   z1 = y2*a1 (round to nearest odd 0.5 ulp);
+   a2 = a1 - z1*x /# 32 * 64 -> 64 bit #/
+
+   z = a/x = z0 + z1 - 0.5 ulp + (a2 > 0) * ulp
+
+   Unless stated otherwise, multiplies can be done in 32 * 32 bit or less
+   with suitable scaling and/or top truncation.
+   x truncated to 20 bits is sufficient to calculate y0 or even y1.
+   Table entries are adjusted by about +128 to use full signed byte range.
+   This adjustment has been perturbed slightly to allow cse with the
+   shift count constant -26.
+   The threshold point for the shift adjust before rounding is found by
+   comparing the fractions, which is exact, unlike the top bit of y2.
+   Therefore, the top bit of y2 becomes slightly random after the adjustment
+   shift, but that's OK because this can happen only at the boundaries of
+   the interval, and the baising of the error means that it can in fact happen
+   only at the bottom end.  And there, the carry propagation will make sure
+   that in the end we will have in effect an implicit 1 (or two whem rounding
+   up...)  */
+/* If an exact result exists, it can have no more bits than the divident.
+   Hence, we don't need to bother with the round-to-even tie breaker
+   unless the result is denormalized.  */
+/* 70 cycles through main path for sh4-300 .  Some cycles might be
+   saved by more careful register allocation.
+   122 cycles for sh4-200.  If execution time for sh4-200 is of concern,
+   a specially scheduled version makes sense.  */
+
+#define x_h r12
+#define yn  r3
+
+FUNC(GLOBAL(divdf3))
+ .global GLOBAL(divdf3)
+
+/* Adjust arg0 now, too.  We still have to come back to denorm_arg1_done,
+   since we heven't done any of the work yet that we do till the denorm_arg0
+   entry point.  We know that neither of the arguments is inf/nan, but
+   arg0 might be zero.  Check for that first to avoid having to establish an
+   rts return address.  */
+LOCAL(both_denorm):
+	mov.l	r9,@-r15
+	mov	DBL0H,r1
+	mov.l	r0,@-r15
+	shll2	r1
+	mov.w LOCAL(both_denorm_cleanup_off),r9
+	or	DBL0L,r1
+	tst	r1,r1
+	mov	DBL0H,r0
+	bf/s	LOCAL(zero_denorm_arg0_1)
+	shll2	r0
+	mov.l	@(4,r15),r9
+	add	#8,r15
+	bra	LOCAL(ret_inf_nan_0)
+	mov	r1,DBLRH
+
+LOCAL(both_denorm_cleanup):
+	mov.l	@r15+,r0
+	!
+	mov.l	@r15+,r9
+ mov	#12,r3
+ mov.l	LOCAL(xfffe2006),r1	! yn := (-1. << 17) + (0x80 << 6) ; shift #-26
+	bra	LOCAL(denorm_arg1_done)
+	!
+	add	r0,DBL0H
+
+/* Denorm handling leaves the incoming denorm argument with an exponent of +1
+   (implicit 1).  To leave the result exponent unaltered, the other
+   argument's exponent is adjusted by the the shift count.  */
+
+	.balign 4
+LOCAL(arg0_tiny):
+	bsr	LOCAL(clz)
+	mov	DBL0L,r0
+	shll	DBL0H
+	add	#1,r0
+	mov	DBL0L,DBL0H
+	shld	r0,DBL0H
+	rotcr	DBL0H
+	tst	DBL0L,DBL0L	/* Check for divide of zero.  */
+	add	#-33,r0
+	shld	r0,DBL0L
+	bf/s	LOCAL(adjust_arg1_exp)
+	add	#64,r0
+LOCAL(return_0): /* Return 0 with appropriate sign.  */
+	mov.l	@r15+,r10
+	mov	#0,DBLRH
+	mov.l	@r15+,r9
+	bra	LOCAL(ret_inf_nan_0)
+	mov.l	@r15+,r8
+
+	.balign 4
+LOCAL(arg1_tiny):
+	bsr	LOCAL(clz)
+	mov	DBL1L,r0
+	shll	DBL1H
+	add	#1,r0
+	mov	DBL1L,DBL1H
+	shld	r0,DBL1H
+	rotcr	DBL1H
+	tst	DBL1L,DBL1L	/* Check for divide by zero.  */
+	add	#-33,r0
+	shld	r0,DBL1L
+	bf/s	LOCAL(adjust_arg0_exp)
+	add	#64,r0
+	mov	DBL0H,r0
+	add	r0,r0
+	tst	r0,r0	! 0 / 0 ?
+	mov	#-1,DBLRH
+	bf	LOCAL(return_inf)
+	!
+	bt	LOCAL(ret_inf_nan_0)
+	!
+
+	.balign 4
+LOCAL(zero_denorm_arg1):
+	not	DBL0H,r3
+	mov	DBL1H,r0
+	tst	r2,r3
+	shll2	r0
+	bt	LOCAL(early_inf_nan_arg0)
+	tst	r0,r0
+	mov.w	LOCAL(xff00),r12
+	bt/s	LOCAL(arg1_tiny)
+	sts.l	pr,@-r15
+	bsr	LOCAL(clz)
+	shlr2	r0
+	!
+	shll	DBL1H
+	mov	DBL1L,r3
+	shld	r0,DBL1H
+	shld	r0,DBL1L
+	rotcr	DBL1H
+	add	#-32,r0
+	shld	r0,r3
+	add	#32,r0
+	or	r3,DBL1H
+LOCAL(adjust_arg0_exp):
+	tst	r2,DBL0H
+	mov	#20,r3
+	shld	r3,r0
+	bt	LOCAL(both_denorm)
+	add	DBL0H,r0
+	div0s	r0,DBL0H	! Check for obvious overflow.  */
+	not	r0,r3		! Check for more subtle overflow - lest
+	bt	LOCAL(return_inf)
+	mov	r0,DBL0H
+	tst	r2,r3		! we mistake it for NaN later
+	mov	#12,r3
+	bf	LOCAL(denorm_arg1_done)
+LOCAL(return_inf): /* Return infinity with appropriate sign.  */
+	mov	#20,r3
+	mov	#-2,DBLRH
+	bra	LOCAL(ret_inf_nan_0)
+	shad	r3,DBLRH
+
+/* inf/n -> inf; inf/0 -> inf; inf/inf -> nan; inf/nan->nan  nan/x -> nan */
+LOCAL(inf_nan_arg0):
+	mov.l	@r15+,r10
+	mov.l	@r15+,r9
+	mov.l	@r15+,r8
+LOCAL(early_inf_nan_arg0):
+	not	DBL1H,r3
+	mov	DBL0H,DBLRH
+	tst	r2,r3	! both inf/nan?
+	add	DBLRH,DBLRH
+	bf	LOCAL(ret_inf_nan_0)
+	mov	#-1,DBLRH
+LOCAL(ret_inf_nan_0):
+	mov	#0,DBLRL
+	mov.l	@r15+,r12
+	div0s	DBL0H,DBL1H
+	rts
+	rotcr	DBLRH
+	
+/* Already handled: inf/x, nan/x .  Thus: x/inf -> 0; x/nan -> nan */
+	.balign	4
+LOCAL(inf_nan_arg1):
+	mov	DBL1H,r2
+	mov	#12,r1
+	shld	r1,r2
+	mov.l	@r15+,r10
+	mov	#0,DBLRL
+	mov.l	@r15+,r9
+	or	DBL1L,r2
+	mov.l	@r15+,r8
+	cmp/hi	DBLRL,r2
+	mov.l	@r15+,r12
+	subc	DBLRH,DBLRH
+	div0s	DBL0H,DBL1H
+	rts
+	rotcr	DBLRH
+	
+	.balign 4
+LOCAL(zero_denorm_arg0):
+	mov.w	LOCAL(denorm_arg0_done_off),r9
+	not	DBL1H,r1
+	mov	DBL0H,r0
+	tst	r2,r1
+	shll2	r0
+	bt	LOCAL(inf_nan_arg1)
+LOCAL(zero_denorm_arg0_1):
+	tst	r0,r0
+	mov.w	LOCAL(xff00),r12
+	bt/s	LOCAL(arg0_tiny)
+	sts.l	pr,@-r15
+	bsr	LOCAL(clz)
+	shlr2	r0
+	shll	DBL0H
+	mov	DBL0L,r12
+	shld	r0,DBL0H
+	shld	r0,DBL0L
+	rotcr	DBL0H
+	add	#-32,r0
+	shld	r0,r12
+	add	#32,r0
+	or	r12,DBL0H
+LOCAL(adjust_arg1_exp):
+	mov	#20,r12
+	shld	r12,r0
+	add	DBL1H,r0
+	div0s	r0,DBL1H	! Check for obvious underflow.  */
+	not	r0,r12		! Check for more subtle underflow - lest
+	bt	LOCAL(return_0)
+	mov	r0,DBL1H
+	tst	r2,r12		! we mistake it for NaN later
+	bt	LOCAL(return_0)
+	!
+	braf	r9
+	mov	#13,r0
+LOCAL(zero_denorm_arg1_dispatch):
+
+LOCAL(xff00):	.word 0xff00
+LOCAL(denorm_arg0_done_off):
+	.word LOCAL(denorm_arg0_done)-LOCAL(zero_denorm_arg1_dispatch)
+LOCAL(both_denorm_cleanup_off):
+	.word LOCAL(both_denorm_cleanup)-LOCAL(zero_denorm_arg1_dispatch)
+
+ .balign	8
+GLOBAL(divdf3):
+ mov.l	LOCAL(x7ff00000),r2
+ mov	#12,r3
+ mov.l	LOCAL(xfffe2006),r1	! yn := (-1. << 17) + (0x80 << 6) ; shift #-26
+ tst	r2,DBL1H
+ mov.l	r12,@-r15
+ bt	LOCAL(zero_denorm_arg1)
+
+LOCAL(denorm_arg1_done):
+ mov	DBL1H,x_h	! x_h live in r12
+ shld	r3,x_h	! x - 1 ; u0.20
+ mov	x_h,yn
+ mova	LOCAL(ytab),r0
+ mov.l	r8,@-r15
+ shld	r1,yn	! x-1 ; u26.6
+ mov.b	@(r0,yn),yn
+ mov	#6,r0
+ mov.l	r9,@-r15
+ mov	x_h,r8
+ mov.l	r10,@-r15
+ shlr16	x_h	! x - 1; u16.16	! x/2 - 0.5 ; u15.17
+ add	x_h,r1	! SH4-200 single-issues this insn
+ shld	r0,yn
+ sub	r1,yn	! yn := y0 ; u15.17
+ mov	DBL1L,r1
+ mov	#-20,r10
+ mul.l	yn,x_h	! r12 dead
+ swap.w	yn,r9
+ shld	r10,r1
+ sts	macl,r0	! y0 * (x-1) - n ; u-1.32
+ add	r9,r0	! y0 * x - 1     ; s-1.32
+ tst	r2,DBL0H
+ dmuls.l r0,yn
+ mov.w	LOCAL(d13),r0
+ or	r1,r8	! x  - 1; u0.32
+ add	yn,yn	! yn = y0 ; u14.18
+ bt	LOCAL(zero_denorm_arg0)
+
+LOCAL(denorm_arg0_done):	! This label must stay aligned.
+ sts	mach,r1	!      d0 ; s14.18
+ sub	r1,yn	! yn = y1 ; u14.18 ; <= 0x3fffc
+ mov	DBL0L,r12
+ shld	r0,yn	! yn = y1 ; u1.31 ; <= 0x7fff8000
+ mov.w	LOCAL(d12),r9
+ dmulu.l yn,r8
+ shld	r10,r12
+ mov	yn,r0
+ mov	DBL0H,r8
+ add	yn,yn	! yn = y1 ; u0.32 ; <= 0xffff0000
+ sts	mach,r1	! y1 * (x-1); u1.31
+ add	r0,r1	! y1 * x    ; u1.31
+ dmulu.l yn,r1
+ not	DBL0H,r10
+ shld	r9,r8
+ tst	r2,r10
+ or	r8,r12	! a - 1; u0.32
+ bt	LOCAL(inf_nan_arg0)
+ sts	mach,r1	! d1+yn; u1.31
+ sett		! adjust y2 so that it can be interpreted as s1.31
+ not	DBL1H,r10
+ subc	r1,yn	! yn := y2 ; u1.31 ; can be 0x7fffffff
+ mov.l	LOCAL(x001fffff),r9
+ dmulu.l yn,r12
+ tst	r2,r10
+ or	DBL1H,r2
+ bt	LOCAL(inf_nan_arg1)
+ mov.l	r11,@-r15
+ sts	mach,r11	! y2*(a-1) ; u1.31
+ add	yn,r11		! z0       ; u1.31
+ dmulu.l r11,DBL1L
+ mov.l	LOCAL(x40000000),DBLRH	! bias + 1
+ and	r9,r2		! x ; u12.20
+ cmp/hi	DBL0L,DBL1L
+ sts	macl,r8
+ mov	#-24,r12
+ sts	mach,r9 	! r9:r8 := z0 * DBL1L; u-19.64
+ subc	DBL1H,DBLRH
+ mul.l	r11,r2  	! (r9+macl):r8 == z0*x; u-19.64
+ shll	r8
+ add	DBL0H,DBLRH	! result sign/exponent + 1
+ mov	r8,r10
+ sts	macl,DBLRL
+ add	DBLRL,r9
+ rotcl	r9		! r9:r8 := z*x; u-20.63
+ shld	r12,r10
+ mov.l	LOCAL(x7fe00000),DBLRL
+ sub	DBL0L,r9	! r9:r8 := -a ; u-20.63
+ mov.l	LOCAL(x00200000),r12
+FIXME: the following  shift might loose the sign.
+ shll8	r9
+ or	r10,r9	! -a1 ; s-28.32
+ mov.l	LOCAL(x00100000),r10
+ dmuls.l r9,yn	! r3 dead
+ mov	DBL1H,r3
+ mov.l LOCAL(xfff00000),DBL0L
+ xor	DBL0H,r3	! calculate expected sign & bit20
+ div0s	r3,DBLRH
+ xor	DBLRH,r3
+ bt	LOCAL(ret_denorm_inf)
+ tst	DBLRL,DBLRH
+ bt	LOCAL(ret_denorm)
+ sub	r12,DBLRH ! calculate sign / exponent minus implicit 1
+ tst	r10,r3	! set T if a >= x
+ sts	mach,r12! -z1 ; s-27.32
+ bt	0f
+ add	r11,r11	! z0 ; u1.31 / u0.31
+0: mov	#6,r3
+ negc	r3,r10 ! shift count := a >= x ? -7 : -6; T := 1
+ shll8	r8	! r9:r8 := -a1 ; s-28.64
+ shad	r10,r12	! -z1 ; truncate to s-20.32 / s-21.32
+ rotcl	r12	! -z1 ; s-21.32 / s-22.32 / round to odd 0.5 ulp ; T := sign
+ add	#20,r10
+ dmulu.l r12,DBL1L ! r12 signed, DBL1L unsigned
+ and	DBL0L,DBLRH	! isolate sign / exponent
+ shld	r10,r9
+ mov	r8,r3
+ shld	r10,r8
+ sts	macl,DBL0L
+ sts	mach,DBLRL
+ add	#-32,r10
+ shld	r10,r3
+ mul.l r12,r2
+ bf	0f	! adjustment for signed/unsigned multiply
+ sub	DBL1L,DBLRL	! DBL1L dead
+0: shar	r12	! -z1 ; truncate to s-20.32 / s-21.32
+ sts	macl,DBL1L
+ or	r3,r9	! r9:r8 := -a1 ;             s-41.64/s-42.64
+ !
+ cmp/hi	r8,DBL0L
+ add	DBLRL,DBL1L ! DBL1L:DBL0L := -z1*x ; s-41.64/s-42.64
+ subc	DBL1L,r9
+ not	r12,DBLRL ! z1, truncated to s-20.32 / s-21.32
+ shll	r9	! T :=  a2 > 0
+ mov	r11,r2
+ mov	#21,r7
+ shld	r7,r11
+ addc	r11,DBLRL
+ mov.l	@r15+,r11
+ mov.l	@r15+,r10
+ mov	#-11,r7
+ mov.l	@r15+,r9
+ shld	r7,r2
+ mov.l	@r15+,r8
+ addc	r2,DBLRH
+ rts
+ mov.l	@r15+,r12
+
+LOCAL(ret_denorm):
+	tst	r10,DBLRH
+	bra	LOCAL(denorm_have_count)
+	movt	DBLRH	! calculate shift count (off by 2)
+
+LOCAL(ret_denorm_inf):
+	mov	DBLRH,r12
+	add	r12,r12
+	cmp/pz	r12
+	mov	#-21,DBLRL
+	bt	LOCAL(ret_inf_late)
+	shld	DBLRL,DBLRH
+LOCAL(denorm_have_count):
+	add	#-2,DBLRH
+/* FIXME */
+	bra	LOCAL(return_0)
+	mov.l	@r15+,r11
+
+LOCAL(ret_inf_late):
+	mov.l	@r15+,r11
+	!
+	mov.l	@r15+,r10
+	!
+	mov.l	@r15+,r9
+	bra	LOCAL(return_inf)
+	mov.l	@r15+,r8
+
+	.balign	4
+LOCAL(clz):
+	mov.l	r8,@-r15
+	extu.w	r0,r8
+	mov.l	r9,@-r15
+	cmp/eq	r0,r8
+	bt/s	0f
+	mov	#8-11,r9
+	xtrct	r0,r8
+	add	#16,r9
+0:	tst	r12,r8	! 0xff00
+	mov.l	LOCAL(c_clz_tab),r0
+	bt	0f
+	shlr8	r8
+0:	bt	0f
+	add	#8,r9
+0:
+#ifdef	__PIC__
+	add	r0,r8
+	mova	LOCAL(c_clz_tab),r0
+#endif
+	mov.b	@(r0,r8),r8
+	mov	r9,r0
+	mov.l	@r15+,r9
+	!
+	!
+	!
+	sub	r8,r0
+	mov.l	@r15+,r8
+	rts
+	lds.l	@r15+,pr
+
+!	We encode even some words as pc-relative that would fit as immediate
+!	in the instruction in order to avoid some pipeline stalls on
+!	SH4-100 / SH4-200.
+LOCAL(d1):	.word 1
+LOCAL(d12):	.word 12
+LOCAL(d13):	.word 13
+
+	.balign 4
+LOCAL(x7ff00000): .long 0x7ff00000
+LOCAL(xfffe2006): .long 0xfffe2006
+LOCAL(x001fffff): .long 0x001fffff
+LOCAL(x40000000): .long 0x40000000
+LOCAL(x7fe00000): .long 0x7fe00000
+LOCAL(x00100000): .long 0x00100000
+LOCAL(x00200000): .long 0x00200000
+LOCAL(xfff00000): .long 0xfff00000
+LOCAL(c_clz_tab):
+#ifdef __pic__
+        .long   GLOBAL(clz_tab) - .
+#else
+        .long   GLOBAL(clz_tab)
+#endif
+LOCAL(ytab):
+        .byte   120, 105,  91,  78,  66,  54,  43,  33
+        .byte    24,  15,   8,   0,  -5, -12, -17, -22
+        .byte   -27, -31, -34, -37, -40, -42, -44, -45
+        .byte   -46, -46, -47, -46, -46, -45, -44, -42
+        .byte   -41, -39, -36, -34, -31, -28, -24, -20
+        .byte   -17, -12,  -8,  -4,   0,   5,  10,  16
+        .byte    21,  27,  33,  39,  45,  52,  58,  65
+        .byte    72,  79,  86,  93, 101, 109, 116, 124
+ENDFUNC(GLOBAL(divdf3))
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/m3/divdf3.S gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/m3/divdf3.S
--- gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/m3/divdf3.S	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/m3/divdf3.S	2013-05-28 13:16:16.000000000 +0200
@@ -0,0 +1,668 @@
+/* Copyright (C) 2004, 2006 Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.  */
+
+! divdf3 for the Renesas SH / STMicroelectronics ST40 CPUs.
+! Contributed by Joern Rennecke joern.rennecke@st.com
+
+/* y = 1/x  ; x (- [1,2)
+   y0 = 1.5 - x/2 - tab[(1-x)*64] = y + d ; abs(d)/y <= 0x1.0c/256
+
+   y1 = y0 - ((y0) * x - 1) * y0  =  y-x*d^2
+   y2 = y1 - ((y1) * x - 1) * y1 =~= y-x^3*d^4
+
+   z0 = y2*a ;  a1 = a - z0*x /# 32 * 64 -> 64 bit #/
+   z1 = y2*a1 (round to nearest odd 0.5 ulp);
+   a2 = a1 - z1*x /# 32 * 64 -> 64 bit #/
+
+   z = a/x = z0 + z1 - 0.5 ulp + (a2 > 0) * ulp
+
+   Unless stated otherwise, multiplies can be done in 32 * 32 bit or less
+   with suitable scaling and/or top truncation.
+   We use a slightly modified algorithm here that checks if the lower
+   bits in z1 are sufficient to determine the outcome of rounding - in that
+   case a2 is not computed.
+   -z1 is computed in units of 1/128 ulp, with an error in the range
+   -0x3.e/128 .. +0 ulp.
+   Thus, after adding three, the result can be safely rounded for normal
+   numbers if any of the bits 5..2 is set, or if the highest guard bit
+   (bit 6 if y <1, otherwise bit 7) is set.
+   (Because of the way truncation works, we would be fine for an open
+    error interval of (-4/128..+1/128) ulp )
+   For denormal numbers, the rounding point lies higher, but it would be
+   quite cumbersome to calculate where exactly; it is sufficient if any
+   of the bits 7..3 is set.
+   x truncated to 20 bits is sufficient to calculate y0 or even y1.
+   Table entries are adjusted by about +128 to use full signed byte range.
+   This adjustment has been perturbed slightly to allow cse with the
+   shift count constant -26.
+   The threshold point for the shift adjust before rounding is found by
+   comparing the fractions, which is exact, unlike the top bit of y2.
+   Therefore, the top bit of y2 becomes slightly random after the adjustment
+   shift, but that's OK because this can happen only at the boundaries of
+   the interval, and the biasing of the error means that it can in fact happen
+   only at the bottom end.  And there, the carry propagation will make sure
+   that in the end we will have in effect an implicit 1 (or two whem rounding
+   up...)  */
+/* If an exact result exists, it can have no more bits than the divident.
+   Hence, we don't need to bother with the round-to-even tie breaker
+   unless the result is denormalized.  */
+/* 64 cycles through main path for sh4-300 (about 93.7% of normalized numbers),
+   82 for the path for rounding tie-breaking for normalized numbers
+   (including one branch mispredict).
+   Some cycles might be saved by more careful register allocation.  */
+
+#define x_h r12
+#define yn  r3
+
+FUNC(GLOBAL(divdf3))
+ .global GLOBAL(divdf3)
+
+/* Adjust arg0 now, too.  We still have to come back to denorm_arg1_done,
+   since we heven't done any of the work yet that we do till the denorm_arg0
+   entry point.  We know that neither of the arguments is inf/nan, but
+   arg0 might be zero.  Check for that first to avoid having to establish an
+   rts return address.  */
+LOCAL(both_denorm):
+	mov.l	r9,@-r15
+	mov	DBL0H,r1
+	mov.l	r0,@-r15
+	shll2	r1
+	mov.w LOCAL(both_denorm_cleanup_off),r9
+	or	DBL0L,r1
+	tst	r1,r1
+	mov	DBL0H,r0
+	bf/s	LOCAL(zero_denorm_arg0_1)
+	shll2	r0
+	mov.l	@(4,r15),r9
+	add	#8,r15
+	bra	LOCAL(ret_inf_nan_0)
+	mov	r1,DBLRH
+
+LOCAL(both_denorm_cleanup):
+	mov.l	@r15+,r0
+	!
+	mov.l	@r15+,r9
+ mov	#12,r3
+ mov.l	LOCAL(xfffe2006),r1	! yn := (-1. << 17) + (0x80 << 6) ; shift #-26
+	bra	LOCAL(denorm_arg1_done)
+	!
+	add	r0,DBL0H
+
+/* Denorm handling leaves the incoming denorm argument with an exponent of +1
+   (implicit 1).  To leave the result exponent unaltered, the other
+   argument's exponent is adjusted by the the shift count.  */
+
+	.balign 4
+LOCAL(arg0_tiny):
+	bsr	LOCAL(clz)
+	mov	DBL0L,r0
+	shll	DBL0H
+	add	#1,r0
+	mov	DBL0L,DBL0H
+	shld	r0,DBL0H
+	rotcr	DBL0H
+	
+	cmp/pl r0
+	bf/s	LOCAL(a0t_dpt_neg)
+	tst	DBL0L,DBL0L	/* Check for divide of zero.  */
+	add	#-32,r0
+	shld	r0,DBL0L
+	bf/s	LOCAL(adjust_arg1_exp)
+	add	#63,r0
+	bra 	LOCAL(return_0)
+	nop
+
+LOCAL(a0t_dpt_neg):
+	add 	#31,r0
+	bf/s	LOCAL(adjust_arg1_exp)
+	shld	r0,DBL0L
+		  
+LOCAL(return_0): /* Return 0 with appropriate sign.  */
+	mov.l	@r15+,r10
+	mov	#0,DBLRH
+	mov.l	@r15+,r9
+	bra	LOCAL(ret_inf_nan_0)
+	mov.l	@r15+,r8
+
+	.balign 4
+LOCAL(arg1_tiny):
+	bsr	LOCAL(clz)
+	mov	DBL1L,r0
+	shll	DBL1H
+	add	#1,r0
+	mov	DBL1L,DBL1H
+	shld	r0,DBL1H
+	rotcr	DBL1H
+
+	cmp/pl r0
+	bf/s	LOCAL(a1t_dpt_neg)
+	tst	DBL1L,DBL1L	/* Check for divide by zero.  */
+	add	#-32,r0
+	shld	r0,DBL1L
+	bf/s	LOCAL(adjust_arg0_exp)
+	add	#63,r0
+	bra 	LOCAL(a1t_end)
+	nop
+
+LOCAL(a1t_dpt_neg):
+	add 	#31,r0
+	bf/s	LOCAL(adjust_arg0_exp)
+	shld	r0,DBL1L
+	
+LOCAL(a1t_end):		  		  
+	mov	DBL0H,r0
+	add	r0,r0
+	tst	r0,r0	! 0 / 0 ?
+	mov	#-1,DBLRH
+	bf	LOCAL(return_inf)
+	!
+	tst   DBL0L,DBL0L
+	bf	LOCAL(return_inf)
+	bt	LOCAL(ret_inf_nan_0)
+	!
+
+	.balign 4
+LOCAL(zero_denorm_arg1):
+	not	DBL0H,r3
+	mov	DBL1H,r0
+	tst	r2,r3
+	shll2	r0
+	bt	LOCAL(early_inf_nan_arg0)
+	tst	r0,r0
+	mov.w	LOCAL(xff00),r12
+	bt/s	LOCAL(arg1_tiny)
+	sts.l	pr,@-r15
+	bsr	LOCAL(clz)
+	shlr2	r0
+	!
+	shll	DBL1H
+	mov	DBL1L,r3
+	shld	r0,DBL1H
+	shld	r0,DBL1L
+	rotcr	DBL1H
+	add	#-32,r0
+	shld	r0,r3
+	add	#32,r0
+	or	r3,DBL1H
+LOCAL(adjust_arg0_exp):
+	tst	r2,DBL0H
+	mov	#20,r3
+	shld	r3,r0
+	bt	LOCAL(both_denorm)
+	add	DBL0H,r0
+	div0s	r0,DBL0H	! Check for obvious overflow.  */
+	not	r0,r3		! Check for more subtle overflow - lest
+	bt	LOCAL(return_inf)
+	mov	r0,DBL0H
+	tst	r2,r3		! we mistake it for NaN later
+	mov	#12,r3
+	bf	LOCAL(denorm_arg1_done)
+LOCAL(return_inf): /* Return infinity with appropriate sign.  */
+	mov	#20,r3
+	mov	#-2,DBLRH
+	bra	LOCAL(ret_inf_nan_0)
+	shad	r3,DBLRH
+
+/* inf/n -> inf; inf/0 -> inf; inf/inf -> nan; inf/nan->nan  nan/x -> nan */
+LOCAL(inf_nan_arg0):
+	mov.l	@r15+,r10
+	mov.l	@r15+,r9
+	mov.l	@r15+,r8
+LOCAL(early_inf_nan_arg0):
+	not	DBL1H,r3
+	mov	DBL0H,DBLRH
+	tst	r2,r3	! both inf/nan?
+	add	DBLRH,DBLRH
+	bf	LOCAL(ret_inf_nan_0)
+	mov	#-1,DBLRH
+LOCAL(ret_inf_nan_0):
+	mov	#0,DBLRL
+	mov.l	@r15+,r12
+	div0s	DBL0H,DBL1H
+	rts
+	rotcr	DBLRH
+	
+/* Already handled: inf/x, nan/x .  Thus: x/inf -> 0; x/nan -> nan */
+	.balign	4
+LOCAL(inf_nan_arg1):
+	mov	DBL1H,r2
+	mov	#12,r1
+	shld	r1,r2
+	mov.l	@r15+,r10
+	mov	#0,DBLRL
+	mov.l	@r15+,r9
+	or	DBL1L,r2
+	mov.l	@r15+,r8
+	cmp/hi	DBLRL,r2
+	mov.l	@r15+,r12
+	subc	DBLRH,DBLRH
+	div0s	DBL0H,DBL1H
+	rts
+	rotcr	DBLRH
+	
+	.balign 4
+LOCAL(zero_denorm_arg0):
+	mov.w	LOCAL(denorm_arg0_done_off),r9
+	not	DBL1H,r1
+	mov	DBL0H,r0
+	tst	r2,r1
+	shll2	r0
+	bt	LOCAL(inf_nan_arg1)
+LOCAL(zero_denorm_arg0_1):
+	tst	r0,r0
+	mov.w	LOCAL(xff00),r12
+	bt/s	LOCAL(arg0_tiny)
+	sts.l	pr,@-r15
+	bsr	LOCAL(clz)
+	shlr2	r0
+	shll	DBL0H
+	mov	DBL0L,r12
+	shld	r0,DBL0H
+	shld	r0,DBL0L
+	rotcr	DBL0H
+	add	#-32,r0
+	shld	r0,r12
+	add	#32,r0
+	or	r12,DBL0H
+LOCAL(adjust_arg1_exp):
+	mov	#20,r12
+	shld	r12,r0
+	add	DBL1H,r0
+	div0s	r0,DBL1H	! Check for obvious underflow.  */
+	not	r0,r12		! Check for more subtle underflow - lest
+	bt	LOCAL(return_0)
+	mov	r0,DBL1H
+	tst	r2,r12		! we mistake it for NaN later
+	bt	LOCAL(return_0)
+	!
+	braf	r9
+	mov	#13,r0
+LOCAL(zero_denorm_arg1_dispatch):
+
+LOCAL(xff00):	.word 0xff00
+LOCAL(denorm_arg0_done_off):
+	.word LOCAL(denorm_arg0_done)-LOCAL(zero_denorm_arg1_dispatch)
+LOCAL(both_denorm_cleanup_off):
+	.word LOCAL(both_denorm_cleanup)-LOCAL(zero_denorm_arg1_dispatch)
+
+ .balign	8
+GLOBAL(divdf3):
+ mov.l	LOCAL(x7ff00000),r2
+ mov	#12,r3
+ mov.l	LOCAL(xfffe2006),r1	! yn := (-1. << 17) + (0x80 << 6) ; shift #-26
+ tst	r2,DBL1H
+ mov.l	r12,@-r15
+ bt	LOCAL(zero_denorm_arg1)
+
+LOCAL(denorm_arg1_done):
+ mov	DBL1H,x_h	! x_h live in r12
+ shld	r3,x_h	! x - 1 ; u0.20
+ mov	x_h,yn
+ mova	LOCAL(ytab),r0
+ mov.l	r8,@-r15
+ shld	r1,yn	! x-1 ; u26.6
+ mov.b	@(r0,yn),yn
+ mov	#6,r0
+ mov.l	r9,@-r15
+ mov	x_h,r8
+ mov.l	r10,@-r15
+ shlr16	x_h	! x - 1; u16.16	! x/2 - 0.5 ; u15.17
+ add	x_h,r1	! SH4-200 single-issues this insn
+ shld	r0,yn
+ sub	r1,yn	! yn := y0 ; u15.17
+ mov	DBL1L,r1
+ mov	#-20,r10
+ mul.l	yn,x_h	! r12 dead
+ swap.w	yn,r9
+ shld	r10,r1
+ sts	macl,r0	! y0 * (x-1) - n ; u-1.32
+ add	r9,r0	! y0 * x - 1     ; s-1.32
+ tst	r2,DBL0H
+ dmuls.l r0,yn
+ mov.w	LOCAL(d13),r0
+ or	r1,r8	! x  - 1; u0.32
+ add	yn,yn	! yn = y0 ; u14.18
+ bt	LOCAL(zero_denorm_arg0)
+
+LOCAL(denorm_arg0_done):
+ sts	mach,r1	!      d0 ; s14.18
+ sub	r1,yn	! yn = y1 ; u14.18 ; <= 0x3fffc
+ mov	DBL0L,r12
+ shld	r0,yn	! yn = y1 ; u1.31 ; <= 0x7fff8000
+ mov.w	LOCAL(d12),r9
+ dmulu.l yn,r8
+ shld	r10,r12
+ mov	yn,r0
+ mov	DBL0H,r8
+ add	yn,yn	! yn = y1 ; u0.32 ; <= 0xffff0000
+ sts	mach,r1	! y1 * (x-1); u1.31
+ add	r0,r1	! y1 * x    ; u1.31
+ dmulu.l yn,r1
+ not	DBL0H,r10
+ shld	r9,r8
+ tst	r2,r10
+ or	r8,r12	! a - 1; u0.32
+ bt	LOCAL(inf_nan_arg0)
+ sts	mach,r1	! d1+yn; u1.31
+ sett		! adjust y2 so that it can be interpreted as s1.31
+ not	DBL1H,r10
+ subc	r1,yn	! yn := y2 ; u1.31 ; can be 0x7fffffff
+ mov.l	LOCAL(x001fffff),r9
+ dmulu.l yn,r12
+ tst	r2,r10
+ or	DBL1H,r2
+ bt	LOCAL(inf_nan_arg1)
+ mov.l	r11,@-r15
+ sts	mach,r12	! y2*(a-1) ; u1.31
+ add	yn,r12		! z0       ; u1.31
+ dmulu.l r12,DBL1L
+ mov.l	LOCAL(x40000000),DBLRH ! bias + 1
+ and	r9,r2		! x ; u12.20
+ cmp/hi	DBL0L,DBL1L
+ sts	macl,r8
+ mov	#-24,r11
+ sts	mach,r9 	! r9:r8 := z0 * DBL1L; u-19.64
+ 
+ subc	DBL1H,DBLRH
+ mul.l	r12,r2  	! (r9+macl):r8 == z0*x; u-19.64
+ shll	r8
+ add	DBL0H,DBLRH	! result sign/exponent + 1
+ mov	r8,r10
+ sts	macl,DBLRL
+ add	DBLRL,r9
+ rotcl	r9		! r9:r8 := z*x; u-20.63
+ shld	r11,r10
+
+! mov.l	LOCAL(xfff00000),DBLRL
+! mov DBL1H,r11
+! and DBLRL,r11
+! subc r11,DBLRH
+! add DBL0H,DBLRH
+		  
+ mov.l	LOCAL(x7fe00000),DBLRL
+ sub	DBL0L,r9	! r9:r8 := -a ; u-20.63
+ cmp/pz	r9		! In corner cases this shift can loose ..
+ shll8	r9		!  .. the sign, so check it first.
+ mov.l	LOCAL(x00200000),r11
+ !mov.l	LOCAL(x00100000),r11
+ or	r10,r9	! -a1 ; s-28.32
+ mov.l	LOCAL(x00100000),r10
+ dmulu.l r9,yn	! sign for r9 is in T
+ xor	DBL0H,DBL1H	! calculate expected sign & bit20
+ mov.w	LOCAL(d120),DBL0H ! to test bits 6..4
+ xor	DBLRH,DBL1H
+ !
+ sts	mach,DBL0L	! -z1 ; s-27.32
+ bt 0f
+ sub	yn,DBL0L	! multiply adjust for -a1 negative; r3 dies here
+0:tst	r10,DBL1H		! set T if a >= x
+ mov.l LOCAL(xfff00000),r3
+ bt	0f
+ add	DBL0L,DBL0L	! z1 ; s-27.32 / s-28.32
+0:bt 0f
+ add	r12,r12	! z0 ; u1.31 / u0.31
+0:add	#6-64,DBL0L
+ and	r3,DBLRH	! isolate sign / exponent
+ tst	DBL0H,DBL0L
+ bf/s	LOCAL(exact)	! make the hot path taken for best branch prediction
+ cmp/pz	DBL1H
+
+! Unless we follow the next branch, we need to test which way the rounding
+! should go.
+! For normal numbers, we know that the result is not exact, so the sign
+! of the rest will be conclusive.
+! We generate a number that looks safely rounded so that denorm handling
+! can safely test the number twice.
+! r10:r8 == 0 will indicate if the number was exact, which can happen
+! when we come here for denormals to check a number that is close or
+! equal to a result in whole ulps.
+ bf	LOCAL(ret_denorm_inf)	! denorm or infinity, DBLRH has inverted sign
+ add	#64,DBL0L
+LOCAL(find_adjust): tst	r10,DBL1H ! set T if a >= x
+ mov	#-2,r10
+ addc	r10,r10
+ mov	DBL0L,DBLRL	! z1 ; s-27.32 / s-28.32 ; lower 4 bits unsafe.
+ shad	r10,DBLRL	! tentatively rounded z1 ; s-24.32
+ shll8	r8		! r9:r8 := -a1 ; s-28.64
+ clrt
+ dmuls.l DBLRL,DBL1L	! DBLRL signed, DBL1L unsigned
+ mov	r8,r10
+ shll16	r8		! r8  := lowpart  of -a1 ; s-44.48
+ xtrct	r9,r10		! r10 := highpart of -a1 ; s-44.48
+ !
+ sts	macl,r3
+ subc	r3,r8
+ sts	mach,r3
+ subc	r3,r10
+ cmp/pz	DBL1L
+ mul.l	DBLRL,r2
+ bt	0f
+ sub	DBLRL,r10	! adjust for signed/unsigned multiply
+0: mov.l	LOCAL(x7fe00000),DBLRL
+ mov	#-26,r2
+ sts	macl,r9
+ sub	r9,r10		! r10:r8 := -a2
+ add	#-64+16,DBL0L	! the denorm code negates this adj. for exact results
+ shld	r2,r10		! convert sign into adjustment in the range 32..63
+ sub	r10,DBL0L
+ cmp/pz	DBL1H
+
+ .balign 4
+LOCAL(exact):
+ bf	LOCAL(ret_denorm_inf)	! denorm or infinity, DBLRH has inverted sign
+ tst	DBLRL,DBLRH
+ bt	LOCAL(ret_denorm_inf)	! denorm, DBLRH has correct sign
+ mov	#-7,DBL1H
+ cmp/pz	DBL0L		! T is sign extension of z1
+ not	DBL0L,DBLRL
+ subc	r11,DBLRH	! calculate sign / exponent minus implicit 1 minus T
+ mov.l	@r15+,r11
+ mov.l	@r15+,r10
+ shad	DBL1H,DBLRL
+ mov.l	@r15+,r9
+ mov	#-11,DBL1H
+ mov	r12,r8		! z0 contributes to DBLRH and DBLRL
+ shld	DBL1H,r12
+ mov	#21,DBL1H
+ clrt
+ shld	DBL1H,r8
+ addc	r8,DBLRL
+ mov.l	@r15+,r8
+ addc	r12,DBLRH
+ rts
+ mov.l	@r15+,r12
+
+!	sign in DBLRH ^ DBL1H
+! If the last 7 bits are in the range 64..64+7, we might have an exact
+! value in the preceding bits - or we might not. For denorms, we need to
+! find out.
+! if r10:r8 is zero, we just have found out that there is an exact value.
+	.balign	4
+LOCAL(ret_denorm_inf):
+	mov	DBLRH,r3
+	add	r3,r3
+	div0s	DBL1H,r3
+!	mov	#248,DBLRL
+	mov	#120,DBLRL
+	bt	LOCAL(ret_inf_late)
+	add	#64,DBL0L
+	tst	DBLRL,DBL0L
+	mov	#-21,DBLRL
+	bt	LOCAL(find_adjust)
+	or	r10,r8
+!	add	#-64,DBL0L
+	tst	r8,r8		! check if find_adjust found an exact value.
+	shad	DBLRL,r3
+	bf	0f
+	add	#-16,DBL0L	! if yes, cancel adjustment
+0:	mov	#-8,DBLRL	! remove the three lowest (inexact) bits
+	and	DBLRL,DBL0L
+	add	#-2-11,r3	! shift count for denorm generation
+	neg 	DBL0L,DBL0L
+	mov	#-28,r2
+	mov	DBL0L,DBLRL
+	mov.l	@r15+,r11
+	mov.l	@r15+,r10
+	shll2	DBLRL
+	mov.l	@r15+,r9
+	shad	r2,DBL0L
+	mov.l	@r15+,r8
+	mov	#-31,r2
+	cmp/ge	r2,r3
+	shll2	DBLRL
+	bt/s	0f
+	add	DBL0L,r12	! fraction in r12:DBLRL ; u1.63
+	mov	#0,r2
+	cmp/hi r2,DBLRL
+	mov	#-33,r2
+	add	#31,r3
+	mov	r12,DBLRL
+	rotcl	DBLRL		! put in sticky bit
+	movt	r12
+	cmp/ge	r3,r2
+	bt	LOCAL(test1)
+0:	div0s	DBL1H,DBLRH	! calculate sign
+	mov	r12,DBLRH
+	shld	r3,DBLRH
+	mov	DBLRL,r2
+	shld	r3,DBLRL
+	add	#32,r3
+	add	DBLRH,DBLRH
+	mov.l	LOCAL(x80000000),DBL1H
+	shld	r3,r12
+	rotcr	DBLRH		! combine sign with highpart
+	add	#-1,r3
+	shld	r3,r2
+	mov	#0,r3
+	rotl	r2
+	cmp/hi	DBL1H,r2
+	addc	r12,DBLRL
+	mov.l	@r15+,r12
+	rts
+	addc	r3,DBLRH
+
+LOCAL(test1):
+	cmp/ge	r2,r3
+	bf/s	LOCAL(return_0_late)
+	div0s	DBL1H,DBLRH
+	mov #0,DBLRH
+	mov	DBLRL,r2
+	mov #0,DBLRL
+	rotcr	DBLRH		! combine sign with highpart
+	mov	#0,r3
+	rotl	r2
+	cmp/hi	r3,r2
+	addc	r3,DBLRL
+	mov.l	@r15+,r12
+	rts
+	addc	r3,DBLRH
+		  
+		  
+LOCAL(ret_inf_late):
+	mov.l	@r15+,r11
+	mov.l	@r15+,r10
+	mov	DBLRH,DBL0H
+	mov.l	@r15+,r9
+	bra	LOCAL(return_inf)
+	mov.l	@r15+,r8
+
+LOCAL(return_0_late):
+	div0s	DBLRH,DBL1H
+	mov.l	@r15+,r12
+	mov	#0,DBLRH
+	mov	#0,DBLRL
+	rts
+	rotcr	DBLRH
+
+	
+	
+	.balign	4
+LOCAL(clz):
+	mov.l	r8,@-r15
+	extu.w	r0,r8
+	mov.l	r9,@-r15
+	cmp/eq	r0,r8
+	bt/s	0f
+	mov	#21,r9
+	shlr16	r0
+	extu.w	r0,r8
+	add	#-16,r9
+0:	tst	r12,r8	! 0xff00
+	mov.l	LOCAL(c_clz_tab),r0
+	bt	0f
+	shlr8	r8
+0:	bt	0f
+	add	#-8,r9
+0:
+#ifdef	__PIC__
+	add	r0,r8
+	mova	LOCAL(c_clz_tab),r0
+#endif
+	mov.b	@(r0,r8),r8
+	mov	r9,r0
+	mov.l	@r15+,r9
+	!
+	!
+	!
+	sub	r8,r0
+	mov.l	@r15+,r8
+	rts
+	lds.l	@r15+,pr
+
+!	We encode even some words as pc-relative that would fit as immediate
+!	in the instruction in order to avoid some pipeline stalls on
+!	SH4-100 / SH4-200.
+LOCAL(d1):	.word 1
+LOCAL(d12):	.word 12
+LOCAL(d13):	.word 13
+LOCAL(d120):	.word 120
+
+	.balign 4
+LOCAL(x7ff00000): .long 0x7ff00000
+LOCAL(xfffe2006): .long 0xfffe2006
+LOCAL(x001fffff): .long 0x001fffff
+LOCAL(x40000000): .long 0x40000000
+LOCAL(x7fe00000): .long 0x7fe00000
+LOCAL(x00100000): .long 0x00100000
+LOCAL(x00200000): .long 0x00200000
+LOCAL(xfff00000): .long 0xfff00000
+LOCAL(x80000000): .long 0x80000000
+LOCAL(c_clz_tab):
+#ifdef __pic__
+        .long   GLOBAL(clz_tab) - .
+#else
+        .long   GLOBAL(clz_tab)
+#endif
+LOCAL(ytab):
+        .byte   120, 105,  91,  78,  66,  54,  43,  33
+        .byte    24,  15,   8,   0,  -5, -12, -17, -22
+        .byte   -27, -31, -34, -37, -40, -42, -44, -45
+        .byte   -46, -46, -47, -46, -46, -45, -44, -42
+        .byte   -41, -39, -36, -34, -31, -28, -24, -20
+        .byte   -17, -12,  -8,  -4,   0,   5,  10,  16
+        .byte    21,  27,  33,  39,  45,  52,  58,  65
+        .byte    72,  79,  86,  93, 101, 109, 116, 124
+ENDFUNC(GLOBAL(divdf3))
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/m3/divsf3.S gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/m3/divsf3.S
--- gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/m3/divsf3.S	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/m3/divsf3.S	2013-05-28 13:16:16.000000000 +0200
@@ -0,0 +1,375 @@
+/* Copyright (C) 2006 Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.  */
+
+! divsf3 for the Renesas SH / STMicroelectronics ST40 CPUs.
+! Contributed by Joern Rennecke
+! joern.rennecke@st.com
+!
+! This code is optimized for SH4 without FPU, but can also be used for SH3.
+
+! long 0th..3rd significant byte
+#ifdef __LITTLE_ENDIAN__
+#define L0SB	3
+#define L1SB	2
+#define L2SB	1
+#define L3SB	0
+#else
+#define L0SB	0
+#define L1SB	1
+#define L2SB	2
+#define L3SB	3
+#endif
+
+! clobbered: r0,r1,r2,r3,r6,r7,T (and for sh.md's purposes PR)
+!
+! Note: When the divisor is larger than the divident, we have to adjust the
+! exponent down by one.  We do this automatically when subtracting the entire
+! exponent/fraction bitstring as an integer, by means of the borrow from
+! bit 23 to bit 24.
+! Note: non-denormal rounding of a division result cannot cause fraction
+! overflow / exponent change. (r4 > r5 : fraction must stay in (2..1] interval;
+! r4 < r5: having an extra bit of precision available, even the smallest
+! possible difference of the result from one is rounded in all rounding modes
+! to a fraction smaller than one.)
+! sh4-200: 59 cycles
+! sh4-300: 44 cycles
+! tab indent: exponent / sign computations
+! tab+space indent: fraction computation
+FUNC(GLOBAL(divsf3))
+	.global GLOBAL(divsf3)
+	.balign	4
+GLOBAL(divsf3):
+	mov.l	LOCAL(x7f800000),r3
+	mov	#1,r2
+	mov	r4,r6
+	 shll8	 r6
+	mov	r5,r7
+	 shll8	 r7
+	rotr	r2
+	tst	r3,r4
+	or	r2,r6
+	bt/s	LOCAL(denorm_arg0)
+	or	r2,r7
+	tst	r3,r5
+	bt	LOCAL(denorm_arg1)
+	mov.l	LOCAL(x3f000000),r3	! bias minus explict leading 1
+	 div0u
+LOCAL(denorm_done):
+!	mov.l	LOCAL(x3f000000),r3	! bias minus explict leading 1
+	cmp/hs	r7,r6
+	mov.l	r8,@-r15
+	mov.l	LOCAL(xff800000),r8
+	bt		LOCAL(no_norm)
+	add  	r8,r3
+LOCAL(no_norm):
+	shlr	 r6
+	 div1	 r7,r6
+	 bt	 0f
+	 div1	r7,r6
+0:	mov.l	r9,@-r15
+	 div1	 r7,r6
+	mov	r4,r1
+	and	r8,r1
+	add	r1,r3
+	 div1	 r7,r6
+	and	r5,r8
+	sub	r8,r3	! result sign/exponent minus 1 if no overflow/underflow
+	 div1	 r7,r6
+	or	r3,r2
+	 div1	 r7,r6
+	mov.w	LOCAL(xff00),r9
+	 div1	 r7,r6
+	mov.l	r2,@-r15 ! L0SB is 0xff iff denorm / infinity exp is computed
+	 div1	 r7,r6
+	mov.w	LOCAL(m23),r2
+	 div1	 r7,r6
+	mov	r4,r0
+	 div1	 r7,r6
+	 extu.b	 r6,r1
+	 and	 r9,r6
+	 swap.w	 r1,r1	! first 8 bits of result fraction in bit 23..16
+	 div1	 r7,r6
+	shld	r2,r0
+	 div1	 r7,r6
+	mov.b	r0,@(L3SB,r15)	! 0xff iff divident was infinity / nan
+	 div1	 r7,r6
+	mov	r5,r0
+	 div1	 r7,r6
+	shld	r2,r0
+	 div1	 r7,r6
+	mov.b	r0,@(L2SB,r15)	! 0xff iff divisor was infinity / nan
+	 div1	 r7,r6
+	mov	r4,r0
+	 div1	 r7,r6
+	mov.w	LOCAL(m31),r2
+	 div1	 r7,r6
+	 extu.b	 r6,r8	! second 8 bits of result fraction in bit 7..0
+	 and	 r9,r6
+	mov.l	LOCAL(xff800000),r9
+	 div1	 r7,r6
+	xor	r5,r0	! msb := correct result sign
+	 div1	 r7,r6
+	xor	r3,r0	! xor with sign of result sign/exponent word
+	 div1	 r7,r6
+	shad	r2,r0
+	 div1	 r7,r6
+	mov.b	r0,@(L1SB,r15)	! 0xff	iff exponent over/underflows
+	and	r9,r3	! isolate sign / exponent
+	 div1	 r7,r6
+	 swap.b	r8,r0	! second 8 bits of result fraction in bit 15..8
+	 div1	 r7,r6
+	 or	r1,r0	! first 16 bits of result fraction in bit 23..8
+	 div1	 r7,r6
+	mov.w	LOCAL(m1),r9
+	 div1	 r7,r6
+	mov.l	@r15+,r8 ! load encoding of unusal exponent conditions
+	 extu.b	 r6,r1
+	 or	 r1,r0	! 24 bit result fraction with explicit leading 1
+	addc	r3,r0	! add in exponent / sign
+	cmp/str	r9,r8
+	! (no stall *here* for SH4-100 / SH4-200)
+	bt/s	LOCAL(inf_nan_denorm_zero)
+	mov.l	@r15+,r9
+	rts
+	mov.l	@r15+,r8
+
+/* The exponennt adjustment for denormal numbers is done by leaving an
+   adjusted value in r3; r4/r5 are not changed.  */
+	.balign	4
+LOCAL(denorm_arg0):
+	mov.w	LOCAL(xff00),r1
+	sub	r2,r6	! 0x800000000 : remove implict 1
+	tst	r6,r6
+	bt	LOCAL(div_zero)
+	sts.l	pr,@-r15
+	bsr	LOCAL(clz)
+	mov	r6,r0
+	shld	r0,r6
+	tst	r3,r5
+	mov.l	LOCAL(x3f800000),r3	! bias - 1 + 1
+	mov	#23,r1
+	shld	r1,r0
+	bt/s	LOCAL(denorm_arg1_2)
+	sub	r0,r3
+	bra	LOCAL(denorm_done)
+	 div0u
+
+LOCAL(denorm_arg1):
+	mov.l	LOCAL(x3f000000),r3	! bias - 1
+LOCAL(denorm_arg1_2):
+	sub	r2,r7	! 0x800000000 : remove implict 1
+	mov.w	LOCAL(xff00),r1
+	tst	r7,r7
+	bt	LOCAL(div_by_zero)
+	sts.l	pr,@-r15
+	bsr	LOCAL(clz)
+	mov	r7,r0
+	shld	r0,r7
+	add	#-1,r0
+	mov	#23,r1
+	shld	r1,r0
+	add	r0,r3
+	bra	LOCAL(denorm_done)
+	 div0u
+
+	.balign	4
+LOCAL(inf_nan_denorm_zero):
+! r0 has the rounded result, r6 has the non-rounded lowest bits & rest.
+! the bit just below the LSB of r6 is available as ~Q
+
+! Alternative way to get at ~Q:
+! if rounding took place, ~Q must be set.
+! if the rest appears to be zero, ~Q must be set.
+! if the rest appears to be nonzero, but rounding didn't take place,
+! ~Q must be clear;  the apparent rest will then require adjusting to test if 
+! the actual rest is nonzero.
+	mov	r0,r2
+	not	r8,r0
+	tst	#0xff,r0
+	shlr8	r0
+	mov.l	@r15+,r8
+	bt/s	LOCAL(div_inf_or_nan)
+	tst	#0xff,r0
+	mov	r4,r0
+	bt	LOCAL(div_by_inf_or_nan)
+	add	r0,r0
+	mov	r5,r1
+	add	r1,r1
+	cmp/hi	r1,r0
+	mov	r6,r0
+	bt	LOCAL(overflow)
+	sub	r2,r0
+	exts.b	r0,r0	! -1 if rounding took place
+	shlr8	r6	! isolate div1-mangled rest
+	addc	r2,r0	! generate carry if rounding took place
+	shlr8	r7
+	mov.l	LOCAL(xffffff),r1
+	sub	r3,r0	! pre-rounding fraction
+	bt	0f ! going directly to denorm_sticky would cause mispredicts
+	tst	r6,r6	! rest can only be zero if lost bit was set
+0:	add	r7,r6	! (T ? corrupt : reconstruct) actual rest
+	bt	0f
+	and r1,r6
+	cmp/pl	r6
+0:	mov.w	LOCAL(m24),r1
+	addc	r0,r0	! put in sticky bit
+	add	#-1,r3
+	mov.l	LOCAL(x80000000),r6
+	add	r3,r3
+	mov	r0,r2
+	shad	r1,r3	! exponent ; s32.0
+	!
+	cmp/pl	r3
+	bt/s	LOCAL(zero_nan)	! return zero
+	clrt
+	shld	r3,r0
+	add	#31,r3
+	cmp/pl	r3
+	shld	r3,r2
+	bf	LOCAL(zero_nan)	! return zero
+	rotl	r2
+	cmp/hi	r6,r2
+	mov	#0,r7
+	addc	r7,r0
+	shll	r0
+	div0s	r4,r5
+	rts
+	rotcr	r0
+	
+! ????
+! undo normal rounding (lowest bits still in r6). then do denormal rounding.
+	
+LOCAL(overflow):
+	mov.l	LOCAL(xff000000),r0
+	div0s	r4,r5
+	rts
+	rotcr	r0
+	
+LOCAL(div_inf_or_nan):
+	mov	r4,r0
+	bra	LOCAL(nan_if_t)
+	add	r0,r0
+	
+LOCAL(div_by_inf_or_nan):
+	mov.l	LOCAL(xff000000),r1
+	mov	#0,r0
+	mov	r5,r2
+	add	r2,r2
+	bra	LOCAL(nan_if_t)
+	cmp/hi	r1,r2
+
+
+
+! still need to check for divide by zero or divide by nan
+! r3: 0x7f800000
+	.balign	4
+LOCAL(div_zero):
+	mov	r5,r1
+	add	r1,r1
+	tst	r1,r1	! 0 / 0 -> nan
+	bt	LOCAL(nan)
+	add	r3,r3
+	cmp/hi	r3,r1	! 0 / nan -> nan (but 0 / inf -> 0)
+LOCAL(zero_nan):
+	mov	#0,r0
+LOCAL(nan_if_t):
+	bf	0f:
+LOCAL(nan):
+	mov	#-1,r0
+0:	div0s	r4,r5	! compute sign
+	rts
+	rotcr	r0	! insert sign
+
+LOCAL(div_by_zero):
+	mov.l	LOCAL(xff000000),r0
+	mov	r4,r2
+	add	r2,r2
+	bra	LOCAL(nan_if_t)
+	cmp/hi	r0,r2
+	
+	.balign	4
+LOCAL(clz):
+	mov.l	r8,@-r15
+	extu.w	r0,r8
+	mov.l	r9,@-r15
+	cmp/eq	r0,r8
+	bt/s	0f
+	mov	#32,r9
+	shlr16	r0
+	extu.w	r0,r8
+	add	#-16,r9
+0:	tst	r1,r8	! 0xff00
+	mov.l	LOCAL(c_clz_tab),r0
+	bt	0f
+	shlr8	r8
+0:	bt	0f
+	add	#-8,r9
+0:
+#ifdef	__PIC__
+	add	r0,r8
+	mova	LOCAL(c_clz_tab),r0
+#endif
+	mov.b	@(r0,r8),r8
+	mov	r9,r0
+	mov.l	@r15+,r9
+	!
+	!
+	!
+	sub	r8,r0
+	mov.l	@r15+,r8
+	rts
+	lds.l	@r15+,pr
+
+!	We encode even some words as pc-relative that would fit as immediate
+!	in the instruction in order to avoid some pipeline stalls on
+!	SH4-100 / SH4-200.
+LOCAL(m23):	.word -23
+LOCAL(m24):	.word -24
+LOCAL(m31):	.word -31
+LOCAL(xff01):	.word 0xff01
+	.balign	4
+LOCAL(xff000000): .long 0xff000000
+#ifdef __LITTLE_ENDIAN__
+LOCAL(xff00):	.word 0xff00
+LOCAL(m1):	.word -1
+#else
+LOCAL(m1):	.word -1
+LOCAL(xff00):	.word 0xff00
+#endif
+LOCAL(xffffff): .long 0xffffff
+LOCAL(x7f800000): .long 0x7f800000
+LOCAL(x3f000000): .long 0x3f000000
+LOCAL(x3f800000): .long 0x3f800000
+LOCAL(xff800000): .long 0xff800000
+LOCAL(x40000000): .long 0x40000000
+LOCAL(x80000000): .long 0x80000000
+LOCAL(c_clz_tab):
+#ifdef __pic__
+        .long   GLOBAL(clz_tab) - .
+#else
+        .long   GLOBAL(clz_tab)
+#endif
+ENDFUNC(GLOBAL(divsf3))
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/m3/fixdfsi.S gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/m3/fixdfsi.S
--- gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/m3/fixdfsi.S	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/m3/fixdfsi.S	2013-05-28 13:16:16.000000000 +0200
@@ -0,0 +1,113 @@
+/* Copyright (C) 2004, 2006 Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.  */
+
+!! fixdfsi for Renesas SH / STMicroelectronics ST40 CPUs
+!! Contributed by J"orn Rennecke joern.rennecke@st.com
+
+	! What is a bit unusal about this implementation is that the
+	! sign bit influences the result for NANs: for cleared sign bit, you
+	! get UINT_MAX, for set sign bit, you get 0.
+	! However, since the result for NANs is undefined, this should be no
+	! problem.
+	! N.B. This is scheduled both for SH4-200 and SH4-300
+	.balign 4
+	.global GLOBAL(fixdfsi)
+	FUNC(GLOBAL(fixdfsi))
+	.balign	4
+GLOBAL(fixdfsi):
+	mov.w	LOCAL(x413),r1
+	mov	DBL0H,r0
+	shll	DBL0H
+	mov.l	LOCAL(mask),r3
+	mov	#-21,r2
+	shld	r2,DBL0H	! SH4-200 will start this insn in a new cycle
+	bt/s	LOCAL(neg)
+	sub	r1,DBL0H
+	cmp/pl	DBL0H		! SH4-200 will start this insn in a new cycle
+	and	r3,r0
+	bf/s	LOCAL(ignore_low)
+	addc	r3,r0	! uses T == 1; sets implict 1
+	mov	#10,r2
+	shld	DBL0H,r0	! SH4-200 will start this insn in a new cycle
+	cmp/gt	r2,DBL0H
+	add	#-32,DBL0H
+	bt	LOCAL(retmax)
+	shld	DBL0H,DBL0L
+	rts
+	or	DBL0L,r0
+
+	.balign	8
+LOCAL(ignore_low):
+	mov	#-21,r2
+	cmp/gt	DBL0H,r2	! SH4-200 will start this insn in a new cycle
+	bf	0f		! SH4-200 will start this insn in a new cycle
+	mov	#-31,DBL0H	! results in 0 return
+0:	add	#1,r0
+	rts
+	shld	DBL0H,r0
+
+	.balign 4
+LOCAL(neg):
+	cmp/pl	DBL0H
+	and	r3,r0
+	bf/s	LOCAL(ignore_low_neg)
+	addc	r3,r0	! uses T == 1; sets implict 1
+	mov	#10,r2
+	shld	DBL0H,r0	! SH4-200 will start this insn in a new cycle
+	cmp/gt	r2,DBL0H
+	add	#-32,DBL0H
+	bt	LOCAL(retmin)
+	shld	DBL0H,DBL0L
+	or	DBL0L,r0	! SH4-200 will start this insn in a new cycle
+	rts
+	neg	r0,r0
+
+	.balign 4
+LOCAL(ignore_low_neg):
+	mov	#-21,r2
+	cmp/gt	DBL0H,r2	! SH4-200 will start this insn in a new cycle
+	add	#1,r0
+	shld	DBL0H,r0
+	bf	0f
+	mov	#0,r0		! results in 0 return
+0:	rts
+	neg	r0,r0
+
+LOCAL(retmax):
+	mov	#-1,r0
+	rts
+	shlr	r0
+
+LOCAL(retmin):
+	mov	#1,r0
+	rts
+	rotr	r0
+
+LOCAL(x413): .word 0x413
+
+	.balign 4
+LOCAL(mask): .long 0x000fffff
+	ENDFUNC(GLOBAL(fixdfsi))
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/m3/fixunsdfsi.S gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/m3/fixunsdfsi.S
--- gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/m3/fixunsdfsi.S	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/m3/fixunsdfsi.S	2013-05-28 13:16:16.000000000 +0200
@@ -0,0 +1,81 @@
+/* Copyright (C) 2004, 2006 Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.  */
+
+!! fixunsdfsi for Renesas SH / STMicroelectronics ST40 CPUs
+!! Contributed by J"orn Rennecke joern.rennecke@st.com
+
+	! What is a bit unusal about this implementation is that the
+	! sign bit influences the result for NANs: for cleared sign bit, you
+	! get INT_MAX, for set sign bit, you get INT_MIN.
+	! However, since the result for NANs is undefined, this should be no
+	! problem.
+	! N.B. This is scheduled both for SH4-200 and SH4-300
+	.balign 4
+	.global GLOBAL(fixunsdfsi)
+	FUNC(GLOBAL(fixunsdfsi))
+	.balign	4
+GLOBAL(fixunsdfsi):
+	mov.w	LOCAL(x413),r1	! bias + 20
+	mov	DBL0H,r0
+	shll	DBL0H
+	mov.l	LOCAL(mask),r3
+	mov	#-21,r2
+	shld	r2,DBL0H	! SH4-200 will start this insn in a new cycle
+	bt/s	LOCAL(ret0)
+	sub	r1,DBL0H
+	cmp/pl	DBL0H		! SH4-200 will start this insn in a new cycle
+	and	r3,r0
+	bf/s	LOCAL(ignore_low)
+	addc	r3,r0	! uses T == 1; sets implict 1
+	mov	#11,r2
+	shld	DBL0H,r0	! SH4-200 will start this insn in a new cycle
+	cmp/gt	r2,DBL0H
+	add	#-32,DBL0H
+	bt	LOCAL(retmax)
+	shld	DBL0H,DBL0L
+	rts
+	or	DBL0L,r0
+
+	.balign	8
+LOCAL(ignore_low):
+	mov	#-21,r2
+	cmp/gt	DBL0H,r2	! SH4-200 will start this insn in a new cycle
+	add	#1,r0
+	bf	0f
+LOCAL(ret0): mov #0,r0		! results in 0 return
+0:	rts
+	shld	DBL0H,r0
+
+LOCAL(retmax):
+	rts
+	mov	#-1,r0
+
+LOCAL(x413): .word 0x413
+
+	.balign 4
+LOCAL(mask): .long 0x000fffff
+	ENDFUNC(GLOBAL(fixunsdfsi))
+
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/m3/floatsidf.S gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/m3/floatsidf.S
--- gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/m3/floatsidf.S	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/m3/floatsidf.S	2013-05-28 13:16:16.000000000 +0200
@@ -0,0 +1,103 @@
+/* Copyright (C) 2006 Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.  */
+
+! floatsidf for the Renesas SH / STMicroelectronics ST40 CPUs.
+! Contributed by Joern Rennecke
+! joern.rennecke@st.com
+!
+! This code is optimized for SH4 without FPU, but can also be used for SH3.
+
+FUNC(GLOBAL(floatsidf))
+	.global GLOBAL(floatsidf)
+	.balign	4
+GLOBAL(floatsidf):
+	tst	r4,r4
+	mov	r4,r1
+	bt	LOCAL(ret0)
+	cmp/pz	r4
+	bt	0f
+	neg	r4,r1
+0:	mov.l	LOCAL(c_clz_tab),r0
+	extu.w	r1,r5
+	mov.w	LOCAL(xff00),r3
+	cmp/eq	r1,r5
+	mov	#21,r2
+	bt	0f
+	mov	r1,r5
+	shlr16	r5
+	add	#-16,r2
+0:	tst	r3,r5	! 0xff00
+	bt	0f
+	shlr8	r5
+0:	bt	0f
+	add	#-8,r2
+0:
+#ifdef	__PIC__
+	add	r0,r5
+	mova	LOCAL(c_clz_tab),r0
+#endif
+	mov.b	@(r0,r5),r5
+	cmp/pz	r4
+	mov.l	LOCAL(x41200000),r3	! bias + 20 - implicit 1
+	bt	0f
+	mov.l	LOCAL(xc1200000),r3	! sign + bias + 20 - implicit 1
+0:	mov	r1,r0	! DBLRL & DBLRH
+	sub	r5,r2
+	mov	r2,r5
+	shld	r2,DBLRH
+	cmp/pz	r2
+	add	r3,DBLRH
+	add	#32,r2
+	shld	r2,DBLRL
+	bf	0f
+	mov.w	LOCAL(d0),DBLRL
+0:	mov	#20,r2
+	shld	r2,r5
+	rts
+	sub	r5,DBLRH
+LOCAL(ret0):
+	mov	#0,DBLRL
+	rts
+	mov	#0,DBLRH
+
+LOCAL(xff00):	.word 0xff00
+	.balign	4
+LOCAL(x41200000):
+#ifdef __LITTLE_ENDIAN__
+LOCAL(d0):	  .word 0
+		  .word 0x4120
+#else
+		  .word 0x4120
+LOCAL(d0):	  .word 0
+#endif
+LOCAL(xc1200000): .long 0xc1200000
+LOCAL(c_clz_tab):
+#ifdef __pic__
+        .long   GLOBAL(clz_tab) - .
+#else
+        .long   GLOBAL(clz_tab)
+#endif
+ENDFUNC(GLOBAL(floatsidf))
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/m3/floatsisf.S gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/m3/floatsisf.S
--- gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/m3/floatsisf.S	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/m3/floatsisf.S	2013-05-28 13:16:16.000000000 +0200
@@ -0,0 +1,106 @@
+/* Copyright (C) 2006 Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.  */
+
+! floatsisf for the Renesas SH / STMicroelectronics ST40 CPUs.
+! Contributed by Joern Rennecke
+! joern.rennecke@st.com
+!
+! This code is optimized for SH4 without FPU, but can also be used for SH3.
+
+FUNC(GLOBAL(floatsisf))
+	.global GLOBAL(floatsisf)
+	.balign	4
+GLOBAL(floatsisf):
+	cmp/pz	r4
+	mov	r4,r5
+	bt	0f
+	neg	r4,r5
+0:	mov.l	LOCAL(c_clz_tab),r0
+	extu.w	r5,r1
+	mov.w	LOCAL(xff00),r3
+	cmp/eq	r5,r1
+	mov	#24,r2
+	bt	0f
+	mov	r5,r1
+	shlr16	r1
+	add	#-16,r2
+0:	tst	r3,r1	! 0xff00
+	bt	0f
+	shlr8	r1
+0:	bt	0f
+	add	#-8,r2
+0:
+#ifdef	__PIC__
+	add	r0,r1
+	mova	LOCAL(c_clz_tab),r0
+#endif
+	mov.b	@(r0,r1),r1
+	cmp/pz	r4
+	mov.l	LOCAL(x4a800000),r3	! bias + 23 - implicit 1
+	bt	0f
+	mov.l	LOCAL(xca800000),r3	! sign + bias + 23 - implicit 1
+0:	mov	r5,r0
+	sub	r1,r2
+	mov.l	LOCAL(x80000000),r1
+	shld	r2,r0
+	cmp/pz	r2
+	add	r3,r0
+	bt	LOCAL(noround)
+	add	#31,r2
+	shld	r2,r5
+	add	#-31,r2
+	rotl	r5
+	cmp/hi	r1,r5
+	mov	#0,r3
+	addc	r3,r0
+	mov	#23,r1
+	shld	r1,r2
+	rts
+	sub	r2,r0
+	.balign	8
+LOCAL(noround):
+	mov	#23,r1
+	tst	r4,r4
+	shld	r1,r2
+	bt	LOCAL(ret0)
+	rts
+	sub	r2,r0
+LOCAL(ret0):
+	rts
+	mov	#0,r0
+
+LOCAL(xff00):	.word 0xff00
+	.balign	4
+LOCAL(x4a800000): .long 0x4a800000
+LOCAL(xca800000): .long 0xca800000
+LOCAL(x80000000): .long 0x80000000
+LOCAL(c_clz_tab):
+#ifdef __pic__
+        .long   GLOBAL(clz_tab) - .
+#else
+        .long   GLOBAL(clz_tab)
+#endif
+ENDFUNC(GLOBAL(floatsisf))
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/m3/floatunssidf.S gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/m3/floatunssidf.S
--- gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/m3/floatunssidf.S	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/m3/floatunssidf.S	2013-05-28 13:16:16.000000000 +0200
@@ -0,0 +1,96 @@
+/* Copyright (C) 2006 Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.  */
+
+! floatunssidf for the Renesas SH / STMicroelectronics ST40 CPUs.
+! Contributed by Joern Rennecke
+! joern.rennecke@st.com
+!
+! This code is optimized for SH4 without FPU, but can also be used for SH3.
+
+FUNC(GLOBAL(floatunsidf))
+	.global GLOBAL(floatunsidf)
+	.balign	4
+GLOBAL(floatunsidf):
+	mov.l	LOCAL(c_clz_tab),r0
+	extu.w	r4,r1
+	mov.w	LOCAL(0xff00),r3
+	cmp/eq	r4,r1
+	mov	#21,r2
+	bt	0f
+	mov	r4,r1
+	shlr16	r1
+	add	#-16,r2
+0:	tst	r3,r1	! 0xff00
+	bt	0f
+	shlr8	r1
+0:	bt	0f
+	add	#-8,r2
+0:
+#ifdef	__PIC__
+	add	r0,r1
+	mova	LOCAL(c_clz_tab),r0
+#endif
+	mov.b	@(r0,r1),r5
+	mov	r4,DBLRL
+	mov.l	LOCAL(x41200000),r3	! bias + 20 - implicit 1
+	tst	r4,r4
+	mov	r4,DBLRH
+	bt	LOCAL(ret0)
+	sub	r5,r2
+	mov	r2,r5
+	shld	r2,DBLRH
+	cmp/pz	r2
+	add	r3,DBLRH
+	add	#32,r2
+	shld	r2,DBLRL
+	bf	0f
+	mov.w	LOCAL(d0),DBLRL
+0:	mov	#20,r2
+	shld	r2,r5
+	rts
+	sub	r5,DBLRH
+LOCAL(ret0):
+	mov	r4,DBLRL
+	rts
+	mov	r4,DBLRH
+
+LOCAL(0xff00):	.word  0xff00
+	.balign	4
+LOCAL(x41200000):
+#ifdef __LITTLE_ENDIAN__
+LOCAL(d0):	  .word 0
+		  .word 0x4120
+#else
+		  .word 0x4120
+LOCAL(d0):	  .word 0
+#endif
+LOCAL(c_clz_tab):
+#ifdef __pic__
+        .long   GLOBAL(clz_tab) - .
+#else
+        .long   GLOBAL(clz_tab)
+#endif
+ENDFUNC(GLOBAL(floatunsidf))
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/m3/floatunssisf.S gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/m3/floatunssisf.S
--- gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/m3/floatunssisf.S	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/m3/floatunssisf.S	2013-05-28 13:16:16.000000000 +0200
@@ -0,0 +1,94 @@
+/* Copyright (C) 2006 Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.  */
+
+! floatsisf for the Renesas SH / STMicroelectronics ST40 CPUs.
+! Contributed by Joern Rennecke
+! joern.rennecke@st.com
+!
+! This code is optimized for SH4 without FPU, but can also be used for SH3.
+
+FUNC(GLOBAL(floatunsisf))
+	.global GLOBAL(floatunsisf)
+	.balign	4
+GLOBAL(floatunsisf):
+	mov.l	LOCAL(c_clz_tab),r0
+	extu.w	r4,r1
+	mov.w	LOCAL(xff00),r3
+	cmp/eq	r4,r1
+	mov	#24,r2
+	bt	0f
+	mov	r4,r1
+	shlr16	r1
+	add	#-16,r2
+0:	tst	r3,r1	! 0xff00
+	bt	0f
+	shlr8	r1
+0:	bt	0f
+	add	#-8,r2
+0:
+#ifdef	__PIC__
+	add	r0,r1
+	mova	LOCAL(c_clz_tab),r0
+#endif
+	mov.b	@(r0,r1),r1
+	mov	r4,r0
+	mov.l	LOCAL(x4a800000),r3	! bias + 23 - implicit 1
+	tst	r4,r4
+	bt	LOCAL(ret0)
+	!
+	sub	r1,r2
+	mov.l	LOCAL(x80000000),r1
+	shld	r2,r0
+	cmp/pz	r2
+	add	r3,r0
+	bt	LOCAL(noround)
+	add	#31,r2
+	shld	r2,r4
+	rotl	r4
+	add	#-31,r2
+	cmp/hi	r1,r4
+	mov	#0,r3
+	addc	r3,r0
+LOCAL(noround):
+	mov	#23,r1
+	shld	r1,r2
+	rts
+	sub	r2,r0
+LOCAL(ret0):
+	rts
+	nop
+
+LOCAL(xff00):	.word 0xff00
+	.balign	4
+LOCAL(x4a800000): .long 0x4a800000
+LOCAL(x80000000): .long 0x80000000
+LOCAL(c_clz_tab):
+#ifdef __pic__
+        .long   GLOBAL(clz_tab) - .
+#else
+        .long   GLOBAL(clz_tab)
+#endif
+ENDFUNC(GLOBAL(floatunsisf))
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/m3/muldf3.S gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/m3/muldf3.S
--- gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/m3/muldf3.S	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/m3/muldf3.S	2013-05-28 13:16:16.000000000 +0200
@@ -0,0 +1,502 @@
+/* Copyright (C) 2004, 2006 Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.  */
+
+! muldf3 for the Renesas SH / STMicroelectronics ST40 CPUs.
+! Contributed by Joern Rennecke
+! joern.rennecke@st.com
+!
+! This code is optimized for SH4 without FPU, but can also be used for SH3.
+! Normal numbers are multiplied in 53 or 54 cycles on SH4-200.
+
+FUNC(GLOBAL(muldf3))
+	.global GLOBAL(muldf3)
+LOCAL(normalize_arg53):
+	tst	r2,DBL0H
+	mov	#1,r2
+	bt	LOCAL(normalize_arg48)
+	mov	DBL0H,r1
+	shlr16	r1
+	bra	LOCAL(normalize_DBL0H)
+	mov	#21-16,r3
+
+LOCAL(normalize_arg16):
+	mov.w	LOCAL(m31),r2 ! 1-32
+	mov	#0,DBL0L
+LOCAL(normalize_arg48):
+	mov	DBL0H,r1
+	mov	#21,r3
+LOCAL(normalize_DBL0H):
+	extu.b	r1,r8
+	mov.l	LOCAL(c__clz_tab),r0
+	cmp/eq	r8,r1
+	!
+	bt	0f
+	shlr8	r1
+0:
+#ifdef	__pic__
+	add	r0,r1
+
+	mova	LOCAL(c__clz_tab),r0
+
+#endif /* __pic__ */
+	mov.b	@(r0,r1),r8
+	mov	DBL0L,r1
+	mov.l	@r15+,r0
+	bt	0f
+	add	#-8,r3
+0:	clrt
+	sub	r8,r3
+	mov.w	LOCAL(d20),r8
+	shld	r3,DBL0H 	! Normalization
+	shld	r3,DBL0L
+	sub	r3,r2 	! r2 <- shifting number
+	add	#-32,r3
+	shld	r3,r1
+	or	r1,DBL0H
+	shld	r8,r2 	! positioning r2 for exp
+	mov.l	@r15+,r8
+
+	! Here :  test tinyness 
+	mov 	DBL1H, r1
+	neg 	r2,r3
+	shll 	r1
+	shll 	r3
+	cmp/hi r1,r3
+	bt LOCAL(zero)
+	
+	add	r2,DBL1H
+	mov.l	LOCAL(x001fffff),r2
+	mov.l LOCAL(x00100000),r3
+	dmulu.l	DBL0L,DBL1L
+	bra	LOCAL(arg_denorm_done)
+	or	r3,r0		! set implicit 1 bit
+
+LOCAL(inf_nan_denorm_or_zero_a):
+	mov.l r8,@-r15
+	sub 	r3,DBL0H 	! isolate high fraction (r3 = 0xfff00000)
+	mov.l @(4,r15),r8 ! original DBL0H (with sign & exp)
+	mov.l r0,@-r15
+	mov.l	r10,@-r15
+	mov 	r1,r10
+	sub 	r3,r1 	! r1 <- 0x7ff00000
+	mov.l LOCAL(x60000000),r3
+	shll16 	r2 	! r2 <- 0xffff0000
+	!			  no stall here for sh4-200
+	!
+	tst 	r1,r8 	! test DBL0 Inf or NaN ?
+	bf LOCAL(inf_nan_a)
+	tst r10,r0 	! test for DBL1 inf, nan or small
+	mov.l	@r15+,r10
+	bt LOCAL(ret_inf_nan_zero)
+LOCAL(normalize_arg):
+	tst 	DBL0H,DBL0H
+	bf LOCAL(normalize_arg53)
+	tst 	DBL0L,DBL0L 	! test for DBL0 is zero
+	bt LOCAL(a_zero)
+	tst 	r2,DBL0L 	! test DBL0L = 0x0000xxxx
+	mov 	DBL0L,DBL0H ! left shift 32
+	bt LOCAL(normalize_arg16)
+	shlr16 	DBL0H
+	mov.w LOCAL(m15),r2	! 1-16
+	bra 	LOCAL(normalize_arg48)
+	shll16 	DBL0L
+
+LOCAL(a_zero):
+	mov.l	@(4,r15),r8
+	add	#8,r15
+LOCAL(zero):
+	mov	#0,DBLRH
+	bra	LOCAL(pop_ret)
+	mov	#0,DBLRL
+
+! both inf / nan -> result is nan if at least one is none, else inf.
+! BBL0 inf/nan, DBL1 zero   -> result is nan
+! DBL0 inf/nan, DBL1 finite -> result is DBL0 with sign adjustemnt
+LOCAL(inf_nan_a):
+	mov.l	@r15+,r10
+	mov	r8,DBL0H
+	mov.l	@(4,r15),r8
+	tst	r1,r0	! arg1 inf/nan ?
+	mov	DBL0H,DBLRH
+	add	#8,r15
+	mov	DBL0L,DBLRL
+	bt	LOCAL(both_inf_nan)
+	tst	DBL1L,DBL1L
+	mov	DBL1H,r2
+	bf	LOCAL(pop_ret)
+	add	r2,r2
+	tst	r2,r2
+	!
+	bf	LOCAL(pop_ret)
+LOCAL(nan):
+	mov	#-1,DBLRL
+	bra	LOCAL(pop_ret)
+	mov	#-1,DBLRH
+
+LOCAL(both_inf_nan):
+	or	DBL1L,DBLRL
+	bra	LOCAL(pop_ret)
+	or	DBL1H,DBLRH
+
+LOCAL(ret_inf_nan_zero):
+	tst	r1,r0
+	mov.l	@(4,r15),r8
+	or	DBL0L,DBL0H
+	bf/s	LOCAL(zero)
+	add	#8,r15
+	tst	DBL0H,DBL0H
+	bt	LOCAL(nan)
+LOCAL(inf_nan_b):
+	mov	DBL1L,DBLRL
+	mov	DBL1H,DBLRH
+LOCAL(pop_ret):
+	mov.l	@r15+,DBL0H
+	add	DBLRH,DBLRH
+
+	div0s	DBL0H,DBL1H
+	rts
+	rotcr	DBLRH
+
+	.balign	4
+/* Argument a has already been tested for being zero or denorm.
+   On the other side, we have to swap a and b so that we can share the
+   normalization code.
+   a: sign/exponent : @r15 fraction: DBL0H:DBL0L
+   b: sign/exponent: DBL1H fraction:    r0:DBL1L  */
+LOCAL(inf_nan_denorm_or_zero_b):
+	sub	r3,r1		! 0x7ff00000
+	mov.l	@r15,r2		! get original DBL0H
+	tst	r1,DBL1H
+	sub	r3,r0		! isolate high fraction
+	bf	LOCAL(inf_nan_b)
+	mov.l	DBL1H,@r15
+	mov	r0,DBL0H
+	mov.l	r8,@-r15
+	mov	r2,DBL1H
+	mov.l	LOCAL(0xffff0000),r2
+	mov.l	DBL1H,@-r15
+	mov	DBL1L,r1
+	mov	DBL0L,DBL1L
+	bra	LOCAL(normalize_arg)
+	mov	r1,DBL0L
+
+LOCAL(d20):
+	.word	20
+LOCAL(m15):
+	.word	-15
+LOCAL(m31):
+	.word	-31
+LOCAL(xff):
+	.word	0xff
+
+	.balign	4
+LOCAL(0xffff0000): .long 0xffff0000
+
+	! calculate a (DBL0H:DBL0L) * b (DBL1H:DBL1L)
+	.balign	4
+GLOBAL(muldf3):
+	mov.l	LOCAL(xfff00000),r3
+	mov	DBL1H,r0
+	dmulu.l	DBL0L,DBL1L
+	mov.l	LOCAL(x7fe00000),r1
+	sub	r3,r0
+	mov.l	DBL0H,@-r15
+	sub	r3,DBL0H
+	tst	r1,DBL0H
+	or	r3,DBL0H
+	mov.l	LOCAL(x001fffff),r2
+	bt	LOCAL(inf_nan_denorm_or_zero_a)
+	tst	r1,r0
+	or	r3,r0		! r0:DBL1L    := b fraction ; u12.52
+	bt	LOCAL(inf_nan_denorm_or_zero_b) ! T clear on fall-through
+LOCAL(arg_denorm_done):
+	and	r2,r0		! r0:DBL1L    := b fraction ; u12.52
+	sts	macl,r3
+	sts	mach,r1
+	dmulu.l	DBL0L,r0 ! r0 = DBL1H - exp
+	and	r2,DBL0H	! DBL0H:DBL0L := a fraction ; u12.52
+	mov.l	r8,@-r15
+	mov	#0,DBL0L
+	mov.l	r9,@-r15
+	sts	macl,r2
+	sts	mach,r8
+	dmulu.l	DBL0H,DBL1L
+	addc	r1,r2
+
+	addc	DBL0L,r8	! add T; clears T
+
+	sts	macl,r1
+	sts	mach,DBL1L
+	dmulu.l	DBL0H,r0
+	addc	r1,r2
+	mov.l	LOCAL(x7ff00000),DBL0H
+	addc	DBL1L,r8	! clears T
+	mov.l	@(8,r15),DBL1L	! a sign/exp w/fraction
+	sts	macl,DBLRL
+	sts	mach,DBLRH
+	and	DBL0H,DBL1L	! a exponent
+	mov.w	LOCAL(x200),r9
+	addc	r8,DBLRL
+	mov.l	LOCAL(x3ff00000),r8	! bias
+	addc	DBL0L,DBLRH	! add T
+	cmp/hi	DBL0L,r3	! 32 guard bits -> sticky: T := r3 != 0
+	movt	r3
+	tst	r9,DBLRH	! T := fraction < 2
+	or	r3,r2		! DBLRH:DBLRL:r2 := result fraction; u24.72
+	bt/s	LOCAL(shll12)
+	sub	r8,DBL1L
+	mov.l	LOCAL(x002fffff),r8
+	and	DBL1H,DBL0H	! b exponent
+	mov.l	LOCAL(x00100000),r9
+	add	DBL0H,DBL1L ! result exponent - 1
+	tst	r8,r2
+	mov.w	LOCAL(m20),r8
+	subc	DBL0L,r9
+	addc	r2,r9 ! r2 value is still needed for denormal rounding
+	mov.w	LOCAL(d11),DBL0L
+	rotcr	r9
+	clrt
+	shld	r8,r9
+	mov.w	LOCAL(m21),r8
+	mov	DBLRL,r3
+	shld	DBL0L,DBLRL
+	addc	r9,DBLRL
+	mov.l	@r15+,r9
+	shld	r8,r3
+	mov.l	@r15+,r8
+	shld	DBL0L,DBLRH
+	mov.l	@r15+,DBL0H
+	addc	r3,DBLRH
+	mov.l	LOCAL(x7ff00000),DBL0L
+	add	DBL1L,DBLRH	! implicit 1 adjusts exponent
+	mov.l	LOCAL(xffe00000),r3
+	cmp/hs	DBL0L,DBLRH
+	add	DBLRH,DBLRH
+	bt	LOCAL(ill_exp_11)
+	tst	r3,DBLRH
+	bt	LOCAL(denorm_exp0_11)
+	div0s	DBL0H,DBL1H
+	rts
+	rotcr	DBLRH
+
+
+LOCAL(shll12):
+	mov.l	LOCAL(x0017ffff),r8
+	extu.b	DBLRH,DBLRH	! remove implicit 1.
+	mov.l	LOCAL(x00080000),r9
+	and	DBL1H,DBL0H	! b exponent
+	add	DBL0H,DBL1L	! result exponent
+	tst	r8,r2		! rounding adjust for lower guard ...
+	mov.w	LOCAL(m19),r8
+	subc	DBL0L,r9	! ... bits and round to even; clear T
+	addc	r2,r9 ! r2 value is still needed for denormal rounding
+	mov.w	LOCAL(d12),DBL0L
+	rotcr	r9
+	clrt
+	shld	r8,r9
+	mov.w	LOCAL(m20),r8
+	mov	DBLRL,r3
+	shld	DBL0L,DBLRL
+	addc	r9,DBLRL
+	mov.l	@r15+,r9
+	shld	r8,r3
+	mov.l	@r15+,r8
+	shld	DBL0L,DBLRH
+	mov.l	LOCAL(x7ff00000),DBL0L
+	addc	r3,DBLRH
+	mov.l	@r15+,DBL0H
+	add	DBL1L,DBLRH
+	mov.l	LOCAL(xffe00000),r3
+	cmp/hs	DBL0L,DBLRH
+	add	DBLRH,DBLRH
+	bt	LOCAL(ill_exp_12)
+	tst	r3,DBLRH
+	bt	LOCAL(denorm_exp0_12)
+LOCAL(insert_sign):
+	div0s	DBL0H,DBL1H
+	rts
+	rotcr	DBLRH
+
+LOCAL(overflow):
+	mov	r3,DBLRH
+	mov	#0,DBLRL
+	bra	LOCAL(insert_sign)
+	mov.l	@r15+,r8
+
+LOCAL(denorm_exp0_11):
+	mov.l	r8,@-r15
+	mov	#-21,r8
+	mov.l	r9,@-r15
+	bra	LOCAL(denorm)
+	mov	#-2,DBL1L	! one for denormal, and one for sticky bit
+
+LOCAL(ill_exp_11):
+	mov	DBL1H,DBL1L
+	and	r3,DBL0L	! 0x7fe00000
+	add	DBL1L,DBL1L
+	mov.l	r8,@-r15
+	cmp/hi	DBL1L,DBL0L	! check if exp a was large
+	mov	#-20,DBL0L
+	bf	LOCAL(overflow)
+	mov	#-21,r8
+	mov	DBLRH,DBL1L
+	rotcr	DBL1L		! shift in negative sign
+	mov.l	r9,@-r15
+	shad	DBL0L,DBL1L	! exponent ; s32
+	bra	LOCAL(denorm)
+	add	#-2,DBL1L	! add one for denormal, and one for sticky bit
+
+LOCAL(denorm_exp0_12):
+	mov.l	r8,@-r15
+	mov	#-20,r8
+	mov.l	r9,@-r15
+	bra	LOCAL(denorm)
+	mov	#-2,DBL1L	! one for denormal, and one for sticky bit
+
+	.balign 4		! also aligns LOCAL(denorm)
+LOCAL(ill_exp_12):
+	and	r3,DBL0L	! 0x7fe00000
+	mov	DBL1H,DBL1L
+	add	DBL1L,DBL1L
+	mov.l	r8,@-r15
+	cmp/hi	DBL1L,DBL0L	! check if exp a was large
+	bf	LOCAL(overflow)
+	mov	DBLRH,DBL1L
+	rotcr	DBL1L		! shift in negative sign
+	mov	#-20,r8
+	shad	r8,DBL1L	! exponent ; s32
+	mov.l	r9,@-r15
+	add	#-2,DBL1L	! add one for denormal, and one for sticky bit
+LOCAL(denorm):
+	not	r3,r9		! 0x001fffff
+	mov.l	r10,@-r15
+	mov	r2,r10
+	shld	r8,r10	! 11 or 12 lower bit valid
+	and	r9,DBLRH ! Mask away vestiges of exponent.
+	add	#32,r8
+	sub	r3,DBLRH ! Make leading 1 explicit.
+	shld	r8,r2	! r10:r2 := unrounded result lowpart
+	shlr	DBLRH	! compensate for doubling at end of normal code
+	sub	DBLRL,r10	! reconstruct effect of previous rounding
+	exts.b	r10,r9
+	shad	r3,r10	! sign extension
+	mov	#0,r3
+	clrt
+	addc	r9,DBLRL	! Undo previous rounding.
+	bt LOCAL(unround_done)
+	addc	r9,DBLRH
+LOCAL(unround_done):
+	mov.w	LOCAL(m32),r9
+	cmp/hi	r3,r2
+	rotcl	DBLRL	! fit in the rest of r2 as a sticky bit.
+	mov.l	@r15+,r10
+	rotcl	DBLRH
+	cmp/ge	r9,DBL1L
+	bt	LOCAL(small_norm_shift)
+	cmp/hi	r3,DBLRL
+	add	#31,DBL1L
+	movt	DBLRL
+	shll 	DBLRH
+	cmp/ge	r9,DBL1L
+	or	DBLRH,DBLRL
+	bt/s	LOCAL(small_norm_shift)
+	mov	r3,DBLRH
+	mov	r3,DBLRL	! exponent too negative to shift - return zero
+	mov.l	@r15+,r9
+	mov.l	@r15+,r8
+	div0s	DBL0H,DBL1H
+	rts
+	rotcr	DBLRH
+	.balign	4
+LOCAL(small_norm_shift):
+	mov	DBLRL,r2	! stash away guard bits
+	shld	DBL1L,DBLRL
+	mov	DBLRH,DBL0L
+	shld	DBL1L,DBLRH
+	mov.l	LOCAL(x7fffffff),r9
+	add	#32,DBL1L
+	shld	DBL1L,r2
+	shld	DBL1L,DBL0L
+	or	DBL0L,DBLRL
+	or	DBLRL,DBL0L
+	shlr	DBL0L
+	addc	r2,r9
+	mov.l	@r15+,r9
+	mov.l	@r15+,r8
+	addc	r3,DBLRL
+	addc	r3,DBLRH
+	div0s	DBL0H,DBL1H
+	add	DBLRH,DBLRH
+	rts
+	rotcr	DBLRH
+
+
+LOCAL(x200):
+	.word 0x200
+LOCAL(m19):
+	.word	-19
+LOCAL(m20):
+	.word	-20
+LOCAL(m21):
+	.word	-21
+LOCAL(m32):
+	.word	-32
+LOCAL(d11):
+	.word	11
+LOCAL(d12):
+	.word	12
+	.balign	4
+LOCAL(x60000000):
+	.long	0x60000000
+LOCAL(c__clz_tab):
+#ifdef __pic__
+	.long	GLOBAL(clz_tab) - .
+#else
+	.long	GLOBAL(clz_tab)
+#endif
+LOCAL(xfff00000):
+	.long	0xfff00000
+LOCAL(x7fffffff):
+	.long	0x7fffffff
+LOCAL(x00100000):
+	.long	0x00100000
+LOCAL(x7fe00000):
+	.long	0x7fe00000
+LOCAL(x001fffff):
+	.long	0x001fffff
+LOCAL(x7ff00000):
+	.long	0x7ff00000
+LOCAL(x3ff00000):
+	.long	0x3ff00000
+LOCAL(x002fffff):
+	.long	0x002fffff
+LOCAL(xffe00000):
+	.long	0xffe00000
+LOCAL(x0017ffff):
+	.long	0x0017ffff
+LOCAL(x00080000):
+	.long	0x00080000
+ENDFUNC(GLOBAL(muldf3))
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/m3/mulsf3.S gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/m3/mulsf3.S
--- gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/m3/mulsf3.S	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/m3/mulsf3.S	2013-05-28 13:16:16.000000000 +0200
@@ -0,0 +1,269 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.  */
+
+! mulsf3 for the Renesas SH / STMicroelectronics ST40 CPUs.
+! Contributed by Joern Rennecke
+! joern.rennecke@st.com
+
+	.balign 4
+	.global GLOBAL(mulsf3)
+	FUNC(GLOBAL(mulsf3))
+GLOBAL(mulsf3):
+   mov.l   LOCAL(x7f800000),r1
+   not     r4,r2
+	mov		r4,r3
+	not		r5,r0
+	tst		r1,r2
+	or			r1,r3
+	bt/s		LOCAL(inf_nan_arg0)
+	 tst		r1,r0
+	bt			LOCAL(inf_nan_arg1)
+	tst		r1,r5
+	mov		r1,r2
+	shll8		r3
+	or			r5,r1
+	bt/s		LOCAL(zero_denorm_arg1)
+	 shll8		r1
+	tst		r2,r4
+	bt			LOCAL(zero_denorm_arg0)
+	dmulu.l	r3,r1
+	mov		r4,r0
+	and		r2,r0
+LOCAL(arg_norm):
+	and		r5,r2
+	mov.l 	LOCAL(x3f800000),r3
+	sts		mach,r1
+	sub		r3,r0
+	sts		macl,r3
+	add		r2,r0
+	cmp/pz	r1
+	mov.w 	LOCAL(x100),r2
+	bf/s		LOCAL(norm_frac) 
+	 tst		r3,r3
+	shll2		r1	 ! Shift one up, replace leading 1 with 0.  
+	shlr		r1
+	tst		r3,r3
+LOCAL(norm_frac):
+	mov.w 	LOCAL(mx80),r3
+	bf			LOCAL(round_frac)
+	tst		r2,r1
+LOCAL(round_frac):
+	mov.l 	LOCAL(xff000000),r2
+	subc		r3,r1	! Even overflow gives right result: exp++, frac=0. 
+	shlr8 	r1
+	add		r1,r0
+	shll		r0
+	bt			LOCAL(ill_exp)
+	tst		r2,r0
+	bt			LOCAL(denorm)
+	cmp/hs	r2,r0
+	bt			LOCAL(inf)
+LOCAL(insert_sign):
+	div0s	r4,r5
+	rts
+	rotcr		r0
+LOCAL(denorm0):
+	tst	r1,r1
+	mov.w 	LOCAL(x100),r2
+	bf			LOCAL(round_den0)
+	tst		r2,r0
+LOCAL(round_den0):
+	mov 		#-7,r2
+	mov.w 	LOCAL(mx80),r3
+	subc 		r3,r0
+	bra		LOCAL(insert_sign)
+	 shld 		r2,r0
+LOCAL(zero_denorm_arg1):
+	mov.l 	LOCAL(x60000000),r2	/* Check exp0 >= -64	*/
+	add		r1,r1
+	tst		r1,r1	/* arg1 == 0 ? */
+	mov		#0,r0
+	bt			LOCAL(insert_sign) /* argument 1 is zero ==> return 0  */
+	tst		r4,r2
+	bt			LOCAL(insert_sign) /* exp0 < -64  ==> return 0 */
+	mov.l 	LOCAL(c__clz_tab),r0
+	mov		r3,r2
+	mov		r1,r3
+	bra		LOCAL(arg_normalize)
+	mov		r2,r1
+LOCAL(zero_denorm_arg0):
+	mov.l 	LOCAL(x60000000),r2	/* Check exp1 >= -64	*/
+	add		r3,r3
+	tst		r3,r3	/* arg0 == 0 ? */
+	mov		#0,r0
+	bt			LOCAL(insert_sign) /* argument 0 is zero ==> return 0  */
+	tst		r5,r2
+	bt			LOCAL(insert_sign) /* exp1 < -64  ==> return 0 */
+	mov.l 	LOCAL(c__clz_tab),r0
+LOCAL(arg_normalize):
+	mov.l	r7,@-r15
+	extu.w	r3,r7
+	cmp/eq	r3,r7
+	mov.l 	LOCAL(xff000000),r7
+	mov		#-8,r2
+	bt			0f
+	tst		r7,r3
+	mov		#-16,r2
+	bt			0f
+	mov		#-24,r2
+0:
+	mov		r3,r7
+	shld		r2,r7
+#ifdef __pic__
+	add		r0,r7
+	mova  	LOCAL(c__clz_tab),r0
+#endif
+	mov.b	@(r0,r7),r0
+	add		#32,r2
+	mov		r2,r7
+	mov		#23,r2
+	sub		r0,r7
+	mov.l	LOCAL(x7f800000),r0
+	shld		r7,r3
+	shld		r2,r7
+	mov		r0,r2
+	and		r4,r0
+	sub		r7,r0
+	mov.l	@r15+,r7
+	bra		LOCAL(arg_norm)
+	 dmulu.l	r3,r1
+#if 0 /* This is slightly slower, but could be used if table lookup causes
+         cache thrashing.  */
+	bt			LOCAL(insert_sign) /* exp1 < -64  ==> return 0 */
+	mov.l 	LOCAL(xff000000),r2
+	mov		r4,r0
+LOCAL(arg_normalize):
+	tst		r2,r3
+	bf			LOCAL(arg_bit_norm)
+LOCAL(arg_byte_loop):
+	tst		r2,r3
+	add		r2,r0
+	shll8		r3
+	bt			LOCAL(arg_byte_loop)
+	add		r4,r0
+LOCAL(arg_bit_norm):
+	mov.l 	LOCAL(x7f800000),r2
+	rotl		r3
+LOCAL(arg_bit_loop):
+	add		r2,r0
+	bf/s		LOCAL(arg_bit_loop)
+	 rotl		r3
+	rotr		r3
+	rotr		r3
+	sub		r2,r0
+	bra		LOCAL(arg_norm)
+	 dmulu.l	r3,r1
+#endif /* 0 */
+LOCAL(inf):
+	bra		LOCAL(insert_sign)
+	 mov		r2,r0
+LOCAL(inf_nan_arg0):
+	bt			LOCAL(inf_nan_both)
+	add		r0,r0
+!	cmp/eq	#-1,r0	Here : modif -1 replace by -2 
+	cmp/eq	#-2,r0	/* arg1 zero? -> NAN */
+	bt			LOCAL(insert_sign)
+	mov		r4,r0
+LOCAL(inf_insert_sign):
+	bra		LOCAL(insert_sign)
+	 add		r0,r0
+LOCAL(inf_nan_both):
+	mov		r4,r0
+	bra		LOCAL(inf_insert_sign)
+	 or		r5,r0
+LOCAL(inf_nan_arg1):
+	mov		r2,r0
+	add		r0,r0
+! cmp/eq	#-1,r0	Here : modif -1 replace by -2 
+	cmp/eq	#-2,r0	/* arg0 zero? */
+	bt			LOCAL(insert_sign)
+	bra		LOCAL(inf_insert_sign)
+	 mov		r5,r0
+LOCAL(ill_exp):
+	cmp/pz	r0
+	bt			LOCAL(inf)
+LOCAL(denorm):
+	mov		#-24,r3
+	add		r1,r1
+	mov		r0,r2
+	sub		r1,r2	! remove fraction to get back pre-rounding exponent.
+	tst 		r2,r2
+	sts		mach,r0
+	sts		macl,r1
+	bt			LOCAL(denorm0)
+	shad		r3,r2
+	mov		r0,r3
+	shld		r2,r0
+	add		#32,r2
+	cmp/pz	r2
+	shld		r2,r3
+	bf			LOCAL(zero)
+	or			r1,r3
+	mov		#-1,r1
+	tst		r3,r3
+	mov.w	LOCAL(x100),r3
+	bf/s		LOCAL(denorm_round_up)
+	mov		#-0x80,r1
+	tst		r3,r0
+LOCAL(denorm_round_up):
+	mov		#-7,r3
+	subc		r1,r0
+	bra		LOCAL(insert_sign)
+	 shld		r3,r0
+LOCAL(zero):
+	bra		LOCAL(insert_sign)
+	 mov 	#0,r0
+LOCAL(x100):
+	.word	0x100
+LOCAL(x200):
+	.word	0x200
+LOCAL(x17f):
+	.word	0x17f
+LOCAL(x80):
+	.word	0x80
+LOCAL(mx80):
+	.word	-0x80
+	.balign	4
+LOCAL(mx100):
+	.word	-0x100
+	.balign	4
+LOCAL(x7f800000):
+	.long 0x7f800000
+LOCAL(x3f800000):
+	.long 0x3f800000
+LOCAL(x1000000):
+	.long	0x1000000
+LOCAL(xff000000):
+	.long	0xff000000
+LOCAL(x60000000):
+	.long	0x60000000
+LOCAL(c__clz_tab):
+#ifdef __pic__
+	.long	GLOBAL(clz_tab) - .
+#else
+	.long	GLOBAL(clz_tab)
+#endif
+	ENDFUNC(GLOBAL(mulsf3))
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/muldf3.S gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/muldf3.S
--- gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/muldf3.S	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/muldf3.S	2013-05-28 13:16:16.000000000 +0200
@@ -0,0 +1,601 @@
+/* Copyright (C) 2004, 2006 Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.  */
+
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!multiplication of two double precision floating point numbers
+!Author:Aanchal Khanna
+!SH1 Support / Simplifications: Joern Rennecke
+!
+!Entry:
+!r4,r5:operand 1
+!
+!r6,r7:operand 2
+!
+!Exit:
+!r0,r1:result
+!
+!Notes: argument 1 is passed in regs r4 and r5 and argument 2 is passed in regs
+!r6 and r7, result is returned in regs r0 and r1. operand 1 is referred as op1
+!and operand 2 as op2.
+!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+	.text
+	.align	5	
+	.global	GLOBAL (muldf3)
+	FUNC (GLOBAL (muldf3))
+
+GLOBAL (muldf3):
+
+#ifdef  __LITTLE_ENDIAN__
+        mov     r4,r1
+        mov     r5,r4
+        mov     r1,r5
+
+        mov     r6,r1
+        mov     r7,r6
+        mov     r1,r7
+#endif
+	mov.l	.L_mask_sign,r0
+	mov	r4,r2
+
+	and	r0,r2		
+	mov	#0,r1
+
+	shll	r4
+	and	r6,r0		
+	
+	xor     r2,r0		!r0 contains the result's sign bit
+	shlr	r4
+
+	mov.l   .L_inf,r2
+	shll	r6
+
+	mov	r4,r3
+	shlr	r6
+	
+.L_chk_a_inv:
+	!chk if op1 is Inf/NaN
+	and	r2,r3
+	mov.l	r8,@-r15
+
+	cmp/eq	r3,r2
+	mov.l	.L_mask_high_mant,r8
+
+	mov	r2,r3
+	bf	.L_chk_b_inv
+
+	mov	r8,r3
+	and	r4,r8
+
+	cmp/hi  r1,r8		
+	bt	.L_return_a	!op1 NaN, return op1
+
+	cmp/hi  r1,r5	
+	mov	r2,r8
+
+	bt      .L_return_a	!op1 NaN, return op1
+	and	r6,r8
+
+	cmp/eq	r8,r2		
+	and	r6,r3
+
+	bt      .L_b_inv
+	cmp/eq	r1,r6		
+
+	bf	.L_return_a	!op1 Inf,op2= normal no return op1
+	cmp/eq	r1,r7
+
+	bf	.L_return_a	!op1 Inf,op2= normal no return op1
+	mov.l   @r15+,r8	
+
+	rts
+	mov	#-1,DBLRH	!op1=Inf, op2=0,return nan
+
+.L_b_inv:
+	!op2 is NaN/Inf
+	cmp/hi	r1,r7
+	mov	r1,r2
+
+	mov	r5,r1
+	bt	.L_return_b	!op2=NaN,return op2
+
+	cmp/hi	r2,r6
+	or	r4,r0
+
+	bt	.L_return_b	!op2=NaN,return op2
+	mov.l   @r15+,r8
+
+#ifdef __LITTLE_ENDIAN__
+        mov     r0,r2
+        mov     r1,r0
+        mov     r2,r1
+#endif
+
+	rts			!op1=Inf,op2=Inf,return Inf with sign
+	nop
+
+.L_chk_b_inv:
+	!Chk if op2 is NaN/Inf
+	and	r6,r2
+	cmp/eq	r3,r2
+
+	bf	.L_chk_a_for_zero
+	and	r6,r8
+
+	cmp/hi	r1,r8
+	bt	.L_return_b	 !op2=NaN,return op2
+
+	cmp/hi	r1,r7
+	bt	.L_return_b	 !op2=NaN,return op2
+
+	cmp/eq	r5,r1
+	bf      .L_return_b	 !op1=normal number,op2=Inf,return Inf
+
+	mov	r7,r1
+	cmp/eq	r4,r1
+
+	bf	.L_return_b	/* op1=normal number, op2=Inf,return Inf */
+	mov.l   @r15+,r8
+
+	rts
+	mov	#-1,DBLRH	!op1=0,op2=Inf,return NaN
+
+.L_return_a:
+	mov	r5,r1
+	or	r4,r0
+
+#ifdef __LITTLE_ENDIAN__
+        mov     r0,r2
+        mov     r1,r0
+        mov     r2,r1
+#endif
+
+	rts
+	mov.l   @r15+,r8
+
+.L_return_b:
+	mov	r7,r1
+	or	r6,r0	
+	
+#ifdef __LITTLE_ENDIAN__
+        mov     r0,r2
+        mov     r1,r0
+        mov     r2,r1
+#endif
+
+	rts
+	mov.l	@r15+,r8
+	
+.L_chk_a_for_zero:
+	!Chk if op1 is zero
+	cmp/eq	r1,r4
+	bf	.L_chk_b_for_zero
+	
+	cmp/eq	r1,r5
+	bf	.L_chk_b_for_zero
+
+#ifdef __LITTLE_ENDIAN__
+        mov     r0,r2
+        mov     r1,r0
+        mov     r2,r1
+#endif
+	rts
+	mov.l	@r15+,r8
+
+.L_chk_b_for_zero:
+	!op1=0,chk if op2 is zero
+        cmp/eq  r1,r6
+        mov	r1,r3
+	
+	mov.l   .L_inf,r1
+	bf      .L_normal_nos
+
+        cmp/eq  r3,r7
+        bf      .L_normal_nos
+
+	mov	r3,r1
+	mov.l   @r15+,r8
+
+#ifdef __LITTLE_ENDIAN__
+        mov     r0,r2
+        mov     r1,r0
+        mov     r2,r1
+#endif
+	rts
+	nop
+
+.L_normal_nos:
+	!op1 and op2 are normal nos
+	mov.l	r9,@-r15
+	mov	r4,r3
+
+	mov     #-20,r9	
+	and	r1,r3	
+
+#if !defined (__sh1__) && !defined (__sh2__) && !defined (__SH2E__)
+        shld    r9,r2
+#else
+        SHLR20 (r2)
+#endif
+
+#if !defined (__sh1__) && !defined (__sh2__) && !defined (__SH2E__)
+        shld    r9,r3
+#else
+        SHLR20 (r3)
+#endif
+	cmp/pl	r3
+
+	bf	.L_norm_a	!normalize op1
+.L_chk_b:	
+	cmp/pl	r2
+	bf	.L_norm_b	!normalize op2
+
+.L_mul1:
+	add	r3,r2
+	mov.l  .L_1023,r1
+	
+	!resultant exponent in r2
+	add     r1,r2
+	mov.l   .L_2047,r1	
+
+	!Chk the exponent for overflow
+	cmp/ge	r1,r2
+	and     r8,r4
+
+	bt	.L_return_inf
+	mov.l	.L_imp_bit,r1
+	
+	or	r1,r4		
+	and	r8,r6
+
+	or	r1,r6
+	clrt
+
+	!multiplying the mantissas
+	DMULU_SAVE
+	DMULUL	(r7,r5,r1) 	!bits 0-31 of product 	
+
+	DMULUH	(r3)
+	
+	DMULUL	(r4,r7,r8)
+
+	addc	r3,r8
+
+	DMULUH	(r3)
+
+	movt	r9
+	clrt
+
+	DMULUL	(r5,r6,r7)
+
+	addc	r7,r8		!bits 63-32 of product
+
+	movt	r7
+	add	r7,r9
+
+	DMULUH	(r7)
+
+	add	r7,r3
+
+	add	r9,r3
+	clrt
+
+	DMULUL	(r4,r6,r7)
+
+	addc	r7,r3		!bits 64-95 of product
+
+	DMULUH	(r7)
+	DMULU_RESTORE
+	
+	mov	#0,r5
+	addc	r5,r7		!bits 96-105 of product
+
+	cmp/eq	r5,r1
+	mov     #1,r4
+
+	bt	.L_skip
+	or	r4,r8
+.L_skip:
+	mov.l   .L_106_bit,r4
+	mov	r8,r9
+
+.L_chk_extra_msb:
+	!chk if exra MSB is generated
+	and     r7,r4
+	cmp/eq	r5,r4
+
+	mov     #12,r4
+	SL(bf,	.L_shift_rt_by_1,
+	 mov     #31,r5)
+	
+.L_pack_mantissa:
+	!scale the mantissa t0 53 bits
+	mov	#-19,r6
+	mov.l	.L_mask_high_mant,r5
+
+        SHLRN (19, r6, r8)
+
+	and	r3,r5
+
+	shlr	r8
+	movt	r1
+
+        SHLLN (12, r4, r5)
+
+	add	#-1,r6
+
+	or	r5,r8		!lower bits of resulting mantissa
+#if !defined (__sh1__) && !defined (__sh2__) && !defined (__SH2E__)
+        shld    r6,r3
+#else
+        SHLR20 (r3)
+#endif
+
+#if !defined (__sh1__) && !defined (__sh2__) && !defined (__SH2E__)
+        shld    r4,r7
+#else
+        SHLL12 (r7)
+#endif
+	clrt
+
+	or	r7,r3		!higher bits of resulting mantissa
+	mov     #0,r7
+
+	!chk the exponent for underflow
+	cmp/ge	r2,r7
+	bt	.L_underflow
+
+	addc    r1,r8           !rounding
+	mov	r8,r1
+
+	addc	r7,r3		!rounding
+	mov.l	.L_mask_22_bit,r5
+
+	and	r3,r5
+	!chk if extra msb is generated after rounding
+	cmp/eq	r7,r5
+
+	mov.l	.L_mask_high_mant,r8
+	bt	.L_pack_result
+
+	add	#1,r2
+	mov.l	.L_2047,r6
+
+	cmp/ge	r6,r2
+
+	bt	.L_return_inf
+	shlr	r3
+
+	rotcr	r1
+
+.L_pack_result:
+	!pack the result, r2=exponent, r3=higher mantissa, r1=lower mantissa
+	!r0=sign bit
+	mov	#20,r6
+	and	r8,r3
+	
+#if !defined (__sh1__) && !defined (__sh2__) && !defined (__SH2E__)
+        shld    r6,r2
+#else
+        SHLL20 (r2)
+#endif
+	or	r3,r0
+	
+	or      r2,r0
+	mov.l   @r15+,r9
+
+#ifdef __LITTLE_ENDIAN__
+        mov     r0,r2
+        mov     r1,r0
+        mov     r2,r1
+#endif
+	rts
+	mov.l   @r15+,r8
+
+.L_norm_a:
+	!normalize op1
+	shll	r5
+	mov.l	.L_imp_bit,r1
+
+	rotcl	r4
+	add	#-1,r3
+
+	tst	r1,r4
+	bt	.L_norm_a
+
+	bra	.L_chk_b
+	add	#1,r3
+
+.L_norm_b:
+	!normalize op2
+        shll    r7
+        mov.l   .L_imp_bit,r1
+
+        rotcl   r6
+        add     #-1,r2
+
+        tst     r1,r6
+        bt      .L_norm_b
+
+        bra     .L_mul1
+        add     #1,r2
+
+.L_shift_rt_by_1:
+	!adjust the extra msb
+
+	add     #1,r2           !add 1 to exponent
+	mov.l	.L_2047,r6
+
+	cmp/ge	r6,r2
+	mov	#20,r6
+
+	bt	.L_return_inf
+	shlr	r7		!r7 contains bit 96-105 of product
+
+	rotcr	r3		!r3 contains bit 64-95 of product
+
+	rotcr	r8		!r8 contains bit 32-63 of product
+	bra	.L_pack_mantissa
+
+	rotcr	r1		!r1 contains bit 31-0 of product
+
+.L_return_inf:
+	!return Inf
+	mov.l	.L_inf,r2
+	mov     #0,r1
+
+	or	r2,r0
+	mov.l   @r15+,r9
+
+#ifdef __LITTLE_ENDIAN__
+        mov     r0,r2
+        mov     r1,r0
+        mov     r2,r1
+#endif
+	rts
+	mov.l   @r15+,r8
+	
+.L_underflow:
+	!check if the result needs to be denormalized
+	mov	#-53,r1
+	add	#1,r2
+
+	cmp/gt	r2,r1
+	mov	#32,r4
+
+	add	#-2,r2
+	bt	.L_return_zero
+
+	add	r2,r4
+	mov	r7,r1
+	
+	cmp/ge	r7,r4
+	mov	r2,r6
+
+	mov	#-54,r2
+	bt	.L_denorm
+
+	mov	#-32,r6
+	
+.L_denorm:
+	!denormalize the result
+	shlr	r8
+	rotcr	r1	
+
+	shll	r8
+	add	#1,r6
+
+	shlr	r3
+	rotcr	r8
+
+	cmp/eq	r7,r6
+	bf	.L_denorm
+
+	mov	r4,r6
+	cmp/eq	r2,r4
+
+	bt	.L_break
+	mov	r7,r5
+
+	cmp/gt	r6,r7
+	bf	.L_break
+
+	mov	r2,r4
+	mov	r1,r5
+
+	mov	r7,r1
+	bt	.L_denorm
+
+.L_break:
+	mov	#0,r2
+
+	cmp/gt	r1,r2
+
+	addc	r2,r8
+	mov.l	.L_comp_1,r4
+	
+	addc	r7,r3
+	or	r3,r0
+
+	cmp/eq	r9,r7
+	bf	.L_return
+
+	cmp/eq	r7,r5
+	mov.l	.L_mask_sign,r6
+
+	bf	.L_return
+	cmp/eq	r1,r6
+	
+	bf	.L_return
+	and	r4,r8
+
+.L_return:
+	mov.l	@r15+,r9
+	mov	r8,r1
+
+#ifdef __LITTLE_ENDIAN__
+        mov     r0,r2
+        mov     r1,r0
+        mov     r2,r1
+#endif
+	rts
+	mov.l   @r15+,r8
+
+.L_return_zero:
+	mov.l	@r15+,r9
+	mov	r7,r1
+
+#ifdef __LITTLE_ENDIAN__
+        mov     r0,r2
+        mov     r1,r0
+        mov     r2,r1
+#endif
+
+	rts
+	mov.l	@r15+,r8
+
+	.align	2
+
+.L_mask_high_mant:
+	.long	0x000fffff
+.L_inf:
+	.long	0x7ff00000	
+.L_mask_sign:
+	.long	0x80000000
+.L_1023:
+	.long	-1023
+.L_2047:
+	.long	2047
+.L_imp_bit:
+	.long	0x00100000
+.L_mask_22_bit:
+	.long	0x00200000
+.L_106_bit:
+	.long	0x00000200
+.L_comp_1:
+	.long	0xfffffffe
+
+ENDFUNC (GLOBAL (muldf3))
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/mulsf3.S gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/mulsf3.S
--- gcc-gnu-4.8.2/libgcc/config/sh/IEEE-754/mulsf3.S	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/IEEE-754/mulsf3.S	2013-05-28 13:16:16.000000000 +0200
@@ -0,0 +1,352 @@
+/* Copyright (C) 2004, 2006 Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.  */
+
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+! Routine for multiplying two floating point numbers
+
+! Author: Rakesh Kumar
+
+! Arguments: r4 and r5
+! Result: r0
+
+! The arguments are referred as op1 and op2
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+
+        .text
+        .align 5
+        .global GLOBAL (mulsf3)
+        FUNC (GLOBAL (mulsf3))
+
+GLOBAL (mulsf3):
+	! Extract the sign bits
+	mov.l	.L_sign,r3
+	mov	r3,r0
+
+	and	r4,r3		! sign bit for op1
+	mov.l	.L_sign_mask,r6
+
+	! Mask out the sign bit from op1 and op2
+	and	r5,r0		! sign bit for op2
+	mov.l	.L_inf,r2
+
+	and	r6,r4
+	xor	r3,r0		! Final sign in r0
+
+	and	r6,r5
+	tst	r4,r4
+
+	! Check for zero
+	mov	r5,r7
+	! Check op1 for zero
+	SL(bt,	.L_op1_zero,
+	 mov	r4,r6)
+
+	tst	r5,r5
+	bt	.L_op2_zero	! op2 is zero
+
+	! Extract the exponents
+	and	r2,r6		! Exponent of op1
+	cmp/eq	r2,r6
+
+	and	r2,r7
+	bt	.L_inv_op1	! op1 is NaN or Inf
+
+	mov.l	.L_mant,r3
+	cmp/eq	r2,r7
+
+	and	r3,r4	! Mantissa of op1
+	bt	.L_ret_op2	! op2 is Nan or Inf
+
+	and	r3,r5	! Mantissa of op2
+
+	mov	#-23,r3
+#if defined (__sh1__) || defined (__sh2__) || defined (__SH2E__)
+	SHLR23 (r6)
+	SHLR23 (r7)
+#else
+	shld	r3,r6
+	shld	r3,r7
+#endif
+	! Check for denormals
+	mov.l	.L_24bit,r3
+	tst	r6,r6
+
+	bt	.L_norm_op1	! op1 is denormal
+	add	#-127,r6	! Unbias op1's exp
+
+	tst	r7,r7
+	bt	.L_norm_op2	! op2 is denormal
+
+	add	#-127,r7	! Unbias op2's exp
+
+.L_multiply:
+	add	r6,r7	! Final exponent in r7
+	mov.l	.L_24bit,r1
+
+	! set 24th bit of mantissas
+	mov	#127,r3
+	or	r1,r4
+
+	DMULU_SAVE
+
+	! Multiply
+	or	r1,r5
+	DMULUL	(r4,r5,r4)
+
+	DMULUH	(r5)
+
+	DMULU_RESTORE
+
+	mov.l	.L_16bit,r6
+
+	! Check for extra MSB generated
+	tst	r5,r6
+
+	mov.l	.L_255,r1
+	bf	.L_shift_by_1	! Adjust the extra MSB
+	
+! Normalize the result with rounding
+.L_epil:
+	! Bias the exponent
+	add	#127,r7
+	cmp/ge	r1,r7
+	
+	! Check exponent overflow and underflow
+	bt	.L_ret_inf
+
+	cmp/pl	r7
+	bf	.L_denorm
+
+.L_epil_0:
+	mov	#-23,r3
+	shll	r5
+	mov	#0,r6
+
+! Fit resultant mantissa in 24 bits
+! Apply default rounding
+.L_loop_epil_0:
+        tst	r3,r3
+	bt	.L_loop_epil_out
+
+	add	#1,r3
+	shlr	r4
+
+	bra	.L_loop_epil_0
+	rotcr	r6
+
+! Round mantissa
+.L_loop_epil_out:
+	shll8	r5
+	or	r5,r4
+
+	mov.l	.L_mant,r2
+	mov	#23,r3
+
+	! Check last bit shifted out of result
+	tst	r6,r6
+	bt	.L_epil_2
+
+	! Round
+	shll	r6
+	movt	r5
+
+	add	r5,r4
+
+	! If this is the only ON bit shifted
+	! Round towards LSB = 0
+	tst	r6,r6
+	bf	.L_epil_2
+
+	shlr	r4
+	shll	r4
+
+.L_epil_2:
+	! Rounding may have produced extra MSB.
+	mov.l	.L_25bit,r5
+	tst	r4,r5
+
+	bt	.L_epil_1
+
+	add	#1,r7
+	shlr	r4
+
+.L_epil_1:
+#if defined (__sh1__) || defined (__sh2__) || defined (__SH2E__)
+	SHLL23 (r7)
+#else
+	shld	r3,r7
+#endif
+
+	and	r2,r4
+
+	or	r7,r4
+	rts
+	or	r4,r0
+
+.L_denorm:
+	mov	#0,r3
+
+.L_den_1:
+	shlr	r5
+	rotcr	r4
+
+	cmp/eq	r3,r7
+	bt	.L_epil_0
+
+	bra	.L_den_1
+	add	#1,r7
+	
+
+! Normalize the first argument
+.L_norm_op1:
+	shll	r4
+	tst	r3,r4
+
+	add	#-1,r6
+	bt	.L_norm_op1
+
+	! The biasing is by 126
+	add	#-126,r6
+	tst	r7,r7
+
+	bt      .L_norm_op2
+
+	bra	.L_multiply
+	add	#-127,r7
+
+! Normalize the second argument
+.L_norm_op2:
+	shll	r5
+	tst	r3,r5
+
+	add	#-1,r7
+	bt	.L_norm_op2
+
+	bra	.L_multiply
+	add	#-126,r7
+
+! op2 is zero. Check op1 for exceptional cases
+.L_op2_zero:
+	mov.l	.L_inf,r2
+	and	r2,r6
+
+	! Check if op1 is deterministic
+	cmp/eq	r2,r6
+	SL(bf,	.L_ret_op2,
+	 mov	#1,r1)
+
+	! Return NaN
+	rts
+	mov	#-1,r0
+
+! Adjust the extra MSB
+.L_shift_by_1:
+	shlr	r5
+	rotcr	r4
+
+	add	#1,r7		! Show the shift in exponent
+
+	cmp/gt	r3,r7
+	bf	.L_epil
+
+	! The resultant exponent is invalid
+	mov.l	.L_inf,r1
+	rts
+	or	r1,r0
+
+.L_ret_op1:
+	rts
+	or	r4,r0
+
+! op1 is zero. Check op2 for exceptional cases
+.L_op1_zero:
+	mov.l	.L_inf,r2
+	and	r2,r7
+	
+	! Check if op2 is deterministic
+	cmp/eq	r2,r7
+	SL(bf,	.L_ret_op1,
+	 mov	#1,r1)
+
+	! Return NaN
+	rts
+	mov	#-1,r0
+
+.L_inv_op1:
+	mov.l	.L_mant,r3
+	mov	r4,r6
+
+	and	r3,r6
+	tst	r6,r6
+
+	bf	.L_ret_op1	! op1 is Nan
+	! op1 is not Nan. It is Inf
+
+	cmp/eq	r2,r7
+	bf	.L_ret_op1	! op2 has a valid exponent
+
+! op2 has a invalid exponent. It could be Inf, -Inf, Nan.
+! It doesn't make any difference.
+.L_ret_op2:
+	rts
+	or	r5,r0
+
+.L_ret_inf:
+	rts
+	or	r2,r0
+
+.L_ret_zero:
+	mov	#0,r2
+	rts
+	or	r2,r0
+
+	
+	.align 2
+.L_mant:
+	.long 0x007FFFFF
+
+.L_inf:
+	.long 0x7F800000
+
+.L_24bit:
+	.long 0x00800000
+
+.L_25bit:
+	.long 0x01000000
+
+.L_16bit:
+	.long 0x00008000
+
+.L_sign:
+	.long 0x80000000
+
+.L_sign_mask:
+	.long 0x7FFFFFFF
+
+.L_255:
+	.long 0x000000FF
+
+ENDFUNC (GLOBAL (mulsf3))
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/ieee-754-df.S gcc-st40-4.8.2.140205/libgcc/config/sh/ieee-754-df.S
--- gcc-gnu-4.8.2/libgcc/config/sh/ieee-754-df.S	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/ieee-754-df.S	2013-05-28 13:16:16.000000000 +0200
@@ -0,0 +1,795 @@
+/* Copyright (C) 2006, 2008, 2009 Free Software Foundation, Inc.
+   Copyright (c) 2010 STMicroelectronics.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GCC is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+!! libgcc software floating-point routines for Renesas SH /
+!! STMicroelectronics ST40 CPUs
+!! Contributed by J"orn Rennecke joern.rennecke@st.com
+
+#ifndef __SH_FPU_DOUBLE__
+
+#include "lib1funcs.h"
+
+#define DF_NAN_MASK		0x7ff80000
+
+/* Double-precision floating-point emulation.
+   We handle NANs, +-infinity, and +-zero.
+   However, we assume that for NANs, the topmost bit of the fraction is set.  */
+
+#ifdef __LITTLE_ENDIAN__
+#define DBL0L r4
+#define DBL0H r5
+#define DBL1L r6
+#define DBL1H r7
+#define DBLRL r0
+#define DBLRH r1
+#else
+#define DBL0L r5
+#define DBL0H r4
+#define DBL1L r7
+#define DBL1H r6
+#define DBLRL r1
+#define DBLRH r0
+#endif
+
+#ifdef __SH_FPU_ANY__
+#define RETURN_R0_MAIN
+#define RETURN_R0 bra LOCAL(return_r0)
+#define RETURN_FR0 \
+LOCAL(return_r0): \
+ lds r0,fpul; \
+ rts; \
+ fsts fpul,fr0
+#define ARG_TO_R4 \
+ flds fr4,fpul; \
+ sts fpul,r4
+#else /* ! __SH_FPU_ANY__ */
+#define RETURN_R0_MAIN rts
+#define RETURN_R0 rts
+#define RETURN_FR0
+#define ARG_TO_R4
+#endif /* ! __SH_FPU_ANY__ */
+
+#ifdef L_nedf2
+/* -fno-finite-math-only -mb inline version, T := r4:DF == r6:DF
+	cmp/eq	r5,r7
+	mov	r4,r0
+	bf	0f
+	cmp/eq	r4,r6
+	bt	0f
+	or	r6,r0
+	add	r0,r0
+	or	r5,r0
+	tst	r0,r0
+	0:			*/
+	.balign 4
+	.global GLOBAL(nedf2)
+	HIDDEN_FUNC(GLOBAL(nedf2))
+GLOBAL(nedf2):
+	cmp/eq	DBL0L,DBL1L
+	bf.s 	LOCAL(ne)
+	mov     #1,r0
+	cmp/eq	DBL0H,DBL1H
+	mov.l   LOCAL(c_DF_NAN_MASK),r1
+	bt.s	LOCAL(check_nan)
+	not	DBL0H,r0
+	mov	DBL0H,r0
+	or	DBL1H,r0
+	add	r0,r0
+	rts
+	or	DBL0L,r0
+LOCAL(check_nan):
+	tst	r1,r0
+	bt.s 	LOCAL(nan)
+	mov	#12,r2
+	shll16  r2
+	xor 	r2,r1
+	tst 	r1,r0
+LOCAL(nan):
+	movt	r0
+LOCAL(ne):
+	rts
+	nop
+
+	.balign 4
+LOCAL(c_DF_NAN_MASK):
+	.long DF_NAN_MASK
+	ENDFUNC(GLOBAL(nedf2))
+#endif /* L_nedf2 */
+
+#ifdef L_unord_df
+	.balign 4
+	.global GLOBAL(unorddf2)
+	HIDDEN_FUNC(GLOBAL(unorddf2))
+GLOBAL(unorddf2):
+	mov.l	LOCAL(c_DF_NAN_MASK),r1
+	not	DBL0H,r0
+	tst	r1,r0
+	not	r6,r0
+	bt	LOCAL(unord)
+	tst	r1,r0
+LOCAL(unord):
+	rts
+	movt	r0
+	.balign	4
+LOCAL(c_DF_NAN_MASK):
+	.long DF_NAN_MASK
+	ENDFUNC(GLOBAL(unorddf2))
+#endif /* L_unord_df */
+
+#if defined(L_gtdf2f) || defined(L_gtdf2f_trap)
+/* -fno-finite-math-only version of _gt_df */
+#ifdef L_gtdf2f
+#define fun_label GLOBAL(gtdf2f)
+#else
+#define fun_label GLOBAL(gtdf2f_trap)
+#endif
+	.balign 4
+	.global fun_label
+	HIDDEN_FUNC(fun_label)
+fun_label:
+	/* If the raw values compare greater, the result true, unless
+	   any of them is a nan (but infinity is fine), or both values are
+	   +- zero.  Otherwise, the result false.  */
+	mov.l	LOCAL(c_DF_NAN_MASK),r1
+	cmp/pz	DBL0H
+	not	DBL1H,r0
+	SLC(bf,	LOCAL(neg),
+	 tst	r1,r0)
+	mov	DBL0H,r0
+	bt	LOCAL(nan) /* return zero if DBL1 is NAN.  */
+	cmp/eq	DBL1H,DBL0H
+	bt	LOCAL(cmp_low)
+	cmp/gt	DBL1H,DBL0H
+	or	DBL1H,r0
+	SLC(bf,	LOCAL(check_nan),
+	 cmp/gt	DBL0H,r1)
+	add	r0,r0
+	bf	LOCAL(nan) /* return zero if DBL0 is NAN.  */
+	or	DBL0L,r0
+	rts
+	or	DBL1L,r0 /* non-zero unless both DBL0 and DBL1 are +-zero.  */
+LOCAL(cmp_low):
+	cmp/hi	DBL1L,DBL0L
+	rts
+	movt	r0
+LOCAL(neg):
+	SLI(tst	r1,r0)
+	bt	LOCAL(nan) /* return zero if DBL1 is NAN.  */
+	cmp/eq	DBL1H,DBL0H
+	SLC(bt,	LOCAL(neg_cmp_low),
+	 cmp/hi	DBL0L,DBL1L)
+	not	DBL0H,r0
+	tst	r1,r0
+	bt	LOCAL(nan) /* return zero if DBL0 is NAN.  */
+	cmp/hi	DBL0H,DBL1H
+	SLI(rts	!,)
+	SLI(movt r0 !,)
+LOCAL(neg_cmp_low):
+	SLI(cmp/hi	DBL0L,DBL1L)
+	rts
+	movt	r0
+LOCAL(check_nan):
+#ifdef L_gtdf2f
+LOCAL(nan):
+	rts
+	mov	#0,r0
+#else
+	SLI(cmp/gt DBL0H,r1)
+	bf	LOCAL(nan) /* return zero if DBL0 is NAN.  */
+	rts
+	mov	#0,r0
+LOCAL(nan):
+	mov	#0,r0
+	trapa	#0
+#endif
+	.balign	4
+LOCAL(c_DF_NAN_MASK):
+	.long DF_NAN_MASK
+	ENDFUNC(fun_label)
+#endif /* defined(L_gtdf2f) || defined(L_gtdf2f_trap) */
+
+#ifdef L_gedf2f
+	.balign 4
+	.global GLOBAL(gedf2f)
+	HIDDEN_FUNC(GLOBAL(gedf2f))
+GLOBAL(gedf2f):
+	/* -fno-finite-math-only version of _ge_df */
+	/* If the raw values compare greater or equal, the result is
+	   true, unless any of them is a nan, or both are the
+	   same infinity.  If both are -+zero, the result is true;
+	   otherwise, it is false.
+	   We use 0 as true and nonzero as false for this function.  */
+	mov.l	LOCAL(c_DF_NAN_MASK),r1
+	cmp/pz	DBL1H
+	not	DBL0H,r0
+	SLC(bf,	LOCAL(neg),
+	 tst	r1,r0)
+	mov	DBL0H,r0
+	bt	LOCAL(nan)
+	cmp/eq	DBL0H,DBL1H
+	bt	LOCAL(cmp_low)
+	cmp/gt	DBL0H,DBL1H
+	or	DBL1H,r0
+	SLC(bf,	LOCAL(check_nan),
+	 cmp/ge	r1,DBL1H)
+	add	r0,r0
+	bt	LOCAL(nan)
+	or	DBL0L,r0
+	rts
+	or	DBL1L,r0
+LOCAL(cmp_low):
+	cmp/hi	DBL0L,DBL1L
+#if defined(L_gedf2f) && defined(DELAYED_BRANCHES)
+LOCAL(nan): LOCAL(check_nan):
+#endif
+	rts
+	movt	r0
+#if defined(L_gedf2f) && ! defined(DELAYED_BRANCHES)
+LOCAL(check_nan):
+	SLI(cmp/ge	r1,DBL1H)
+LOCAL(nan):
+	rts
+	movt	r0
+#elif defined(L_gedf2f_trap)
+LOCAL(check_nan):
+	SLI(cmp/ge	r1,DBL1H)
+	bt	LOCAL(nan)
+	rts
+LOCAL(nan):
+	movt	r0
+	trapa	#0
+#endif /* L_gedf2f_trap */
+LOCAL(neg):
+	SLI(tst	r1,r0)
+	bt	LOCAL(nan)
+	cmp/eq	DBL0H,DBL1H
+	not	DBL1H,r0
+	SLC(bt,	LOCAL(neg_cmp_low),
+	 cmp/hi	DBL1L,DBL0L)
+	tst	r1,r0
+	bt	LOCAL(nan)
+	cmp/hi	DBL1H,DBL0H
+	SLI(rts !,)
+	SLI(movt	r0 !,)
+LOCAL(neg_cmp_low):
+	SLI(cmp/hi	DBL1L,DBL0L)
+	rts
+	movt	r0
+	.balign	4
+LOCAL(c_DF_NAN_MASK):
+	.long DF_NAN_MASK
+	ENDFUNC(GLOBAL(gedf2f))
+#endif /* L_gedf2f */
+
+#ifndef DYN_SHIFT /* SH1 / SH2 code */
+#ifdef L_sf_to_df
+	.balign 4
+	.global GLOBAL(extendsfdf2)
+	FUNC(GLOBAL(extendsfdf2))
+GLOBAL(extendsfdf2):
+	ARG_TO_R4
+	mov.l	LOCAL(x7f800000),r3
+	mov	r4,DBLRL
+	tst	r3,r4
+	bt	LOCAL(zero_denorm)
+	mov.l	LOCAL(xe0000000),r2
+	rotr	DBLRL
+	rotr	DBLRL
+	rotr	DBLRL
+	and	r2,DBLRL
+	mov	r4,DBLRH
+	not	r4,r2
+	tst	r3,r2
+	mov.l	LOCAL(x38000000),r2
+	bf	0f
+	add	r2,r2	! infinity / NaN adjustment
+0:	shll	DBLRH
+	shlr2	DBLRH
+	shlr2	DBLRH
+	add	DBLRH,DBLRH
+	rotcr	DBLRH
+	rts
+	add	r2,DBLRH
+LOCAL(zero_denorm):
+	mov.l	r4,@-r15
+	add	r4,r4
+	tst	r4,r4
+	bt	LOCAL(zero)
+	shlr8	r3	/* 0x007f8000 */
+	mov.w	LOCAL(x389),r2
+LOCAL(shift_byte):
+	tst	r3,r4
+	shll8	r4
+	SL(bt,	LOCAL(shift_byte),
+	 add	#-8,r2)
+LOCAL(shift_bit):
+	shll	r4
+	SL(bf,	LOCAL(shift_bit),
+	 add	#-1,r2)
+	mov	#0,DBLRL
+	mov	r4,DBLRH
+	mov.l	@r15+,r4
+	shlr8	DBLRH
+	shlr2	DBLRH
+	shlr	DBLRH
+	rotcr	DBLRL
+	cmp/gt	r4,DBLRH	! get sign
+	rotcr	DBLRH
+	rotcr	DBLRL
+	shll16	r2
+	shll8	r2
+	rts
+	add	r2,DBLRH
+LOCAL(zero):
+	mov.l	@r15+,DBLRH
+	rts
+	mov	#0,DBLRL
+LOCAL(x389):	.word 0x389
+	.balign	4
+LOCAL(x7f800000):
+	.long	0x7f800000
+LOCAL(x38000000):
+	.long	0x38000000
+LOCAL(xe0000000):
+	.long	0xe0000000
+	ENDFUNC(GLOBAL(extendsfdf2))
+#endif /* L_sf_to_df */
+
+#ifdef L_df_to_sf
+	.balign 4
+	.global GLOBAL(truncdfsf2)
+	FUNC(GLOBAL(truncdfsf2))
+GLOBAL(truncdfsf2):
+	mov.l	LOCAL(x38000000),r3	! exponent adjustment DF -> SF
+	mov	DBL0H,r1
+	mov.l	LOCAL(x70000000),r2	! mask for out-of-range exponent bits
+	mov	DBL0H,r0
+	mov.l	DBL0L,@-r15
+	sub	r3,r1
+	tst	r2,r1
+	shll8	r0			!
+	shll2	r0			! Isolate highpart fraction.
+	shll2	r0			!
+	bf	LOCAL(ill_exp)
+	shll2	r1
+	mov.l	LOCAL(x2fffffff),r2 /* Fraction lsb | lower guard bits.  */
+	shll2	r1
+	mov.l	LOCAL(xff000000),r3
+	shlr8	r0
+	tst	r2,DBL0L /* Check if msb guard bit wants rounding up.  */
+	shlr16	DBL0L
+	shlr8	DBL0L
+	shlr2	DBL0L
+	SL1(bt,	LOCAL(add_frac),
+	 shlr2	DBL0L)
+	add	#1,DBL0L
+LOCAL(add_frac):
+	add	DBL0L,r0
+	mov.l	LOCAL(x01000000),r2
+	and	r3,r1
+	mov.l	@r15+,DBL0L
+	add	r1,r0
+	tst	r3,r0
+	bt	LOCAL(inf_denorm0)
+	cmp/hs	r3,r0
+LOCAL(denorm_noup_sh1):
+	bt	LOCAL(inf)
+	div0s	DBL0H,r2	/* copy orig. sign into T.  */
+RETURN_R0_MAIN
+	rotcr	r0
+RETURN_FR0
+LOCAL(inf_denorm0):	!  We might need to undo previous rounding.
+	mov.l	LOCAL(x2fffffff),r3 /* Old fraction lsb | lower guard bits.  */
+	tst	r1,r1
+	bf	LOCAL(inf)
+	add	#-1,r0
+	tst	r3,DBL0L /* Check if msb guard bit was rounded up.  */
+	mov.l	LOCAL(x5fffffff),r3 /* Fraction lsb | lower guard bits.  */
+	addc	r2,r0
+	shlr	r0
+	tst	r3,DBL0L /* Check if msb guard bit wants rounding up.  */
+#ifdef DELAYED_BRANCHES
+	bt/s	LOCAL(denorm_noup)
+#else
+	bt	LOCAL(denorm_noup_sh1)
+#endif
+	div0s	DBL0H,r2	/* copy orig. sign into T.  */
+	add	#1,r0
+LOCAL(denorm_noup):
+	RETURN_R0
+	rotcr	r0
+LOCAL(ill_exp):
+	div0s	DBL0H,r1
+	mov.l	LOCAL(x7ff80000),r2
+	add	r1,r1
+	bf	LOCAL(inf_nan)
+	mov.w	LOCAL(m32),r3 /* Handle denormal or zero.  */
+	shlr16	r1
+	exts.w	r1,r1
+	shll2	r1
+	add	r1,r1
+	shlr8	r1
+	exts.w	r1,r1
+	add	#-8,r1	/* Go from 9 to 1 guard bit in MSW.  */
+	cmp/gt	r3,r1
+	mov.l	@r15+,r3 /* DBL0L */
+	bf	LOCAL(zero)
+	mov.l	DBL0L, @-r15
+	shll8	DBL0L
+	rotcr	r0	/* Insert leading 1.  */
+	shlr16	r3
+	shll2	r3
+	add	r3,r3
+	shlr8	r3
+	cmp/pl	DBL0L	/* Check lower 23 guard bits if guard bit 23 is 0.  */
+	addc	r3,r0	/* Assemble fraction with compressed guard bits.  */
+	mov.l	@r15+,DBL0L
+	mov	#0,r2
+	neg	r1,r1
+LOCAL(denorm_loop):
+	shlr	r0
+	rotcl	r2
+	dt	r1
+	bf	LOCAL(denorm_loop)
+	tst	#2,r0
+	rotcl	r0
+	tst	r2,r2
+	rotcl	r0
+	xor	#3,r0
+	add	#3,r0	/* Even overflow gives the correct result.  */
+	shlr2	r0
+	div0s	r0,DBL0H
+	RETURN_R0
+	rotcr	r0
+LOCAL(zero):
+	mov	#0,r0
+	div0s	r0,DBL0H
+	RETURN_R0
+	rotcr	r0
+LOCAL(inf_nan):
+	not	DBL0H,r0
+	tst	r2,r0
+	mov.l	@r15+,DBL0L
+	bf	LOCAL(inf)
+	RETURN_R0
+	mov	#-1,r0	/* NAN */
+LOCAL(inf):	/* r2 must be positive here.  */
+	mov.l	LOCAL(xff000000),r0
+	div0s	r2,DBL0H
+	RETURN_R0
+	rotcr	r0
+LOCAL(m32):
+	.word	-32
+	.balign	4
+LOCAL(x38000000):
+	.long	0x38000000
+LOCAL(x70000000):
+	.long	0x70000000
+LOCAL(x2fffffff):
+	.long	0x2fffffff
+LOCAL(x01000000):
+	.long	0x01000000
+LOCAL(xff000000):
+	.long	0xff000000
+LOCAL(x5fffffff):
+	.long	0x5fffffff
+LOCAL(x7ff80000):
+	.long	0x7ff80000
+	ENDFUNC(GLOBAL(truncdfsf2))
+#endif /*  L_df_to_sf */
+#ifdef L_addsub_df
+#include "IEEE-754/adddf3.S"
+#endif /* _addsub_df */
+
+#ifdef L_mul_df
+#include "IEEE-754/muldf3.S"
+#endif /* L_mul_df */
+
+#ifdef L_df_to_usi
+#include "IEEE-754/fixunsdfsi.S"
+#endif /* L_df_to_usi */
+
+#ifdef L_df_to_si
+#include "IEEE-754/fixdfsi.S"
+#endif /* L_df_to_si */
+
+#ifdef L_usi_to_df
+#include "IEEE-754/floatunssidf.S"
+#endif /* L_usi_to_df */
+
+#ifdef L_si_to_df
+#include "IEEE-754/floatsidf.S"
+#endif /* L_si_df */
+
+#ifdef L_div_df
+#include "IEEE-754/divdf3.S"
+#endif /* L_div_df */
+#endif /* ! DYN_SHIFT */
+
+/* The actual arithmetic uses dynamic shift.  Supporting SH1 / SH2 here would
+   make this code too hard to maintain, so if you want to add SH1 / SH2
+   support, do it in a separate copy.  */
+#ifdef DYN_SHIFT
+#ifdef L_sf_to_df
+	.balign 4
+	.global GLOBAL(extendsfdf2)
+	FUNC(GLOBAL(extendsfdf2))
+GLOBAL(extendsfdf2):
+	ARG_TO_R4
+	mov.l	LOCAL(x7f800000),r2
+	mov	#29,r3
+	mov	r4,DBLRL
+	not	r4,DBLRH
+	tst	r2,r4
+	shld	r3,DBLRL
+	bt	LOCAL(zero_denorm)
+	mov	#-3,r3
+	tst	r2,DBLRH
+	mov	r4,DBLRH
+	mov.l	LOCAL(x38000000),r2
+	bt/s	LOCAL(inf_nan)
+	 shll	DBLRH
+	shld	r3,DBLRH
+	rotcr	DBLRH
+	rts
+	add	r2,DBLRH
+	.balign	4
+LOCAL(inf_nan):
+	shld	r3,DBLRH
+	add	r2,r2
+	rotcr	DBLRH
+	rts
+	add	r2,DBLRH
+LOCAL(zero_denorm):
+	mov.l	r4,@-r15
+	add	r4,r4
+	tst	r4,r4
+	extu.w	r4,r2
+	bt	LOCAL(zero)
+	cmp/eq	r4,r2
+	extu.b	r4,r1
+	mov.l	LOCAL(c__clz_tab),r0
+	bf	LOCAL(three_bytes)
+	nop
+	cmp/eq	r4,r1
+	mov	#22,DBLRH
+	bt	LOCAL(one_byte)
+	shlr8	r2
+	mov	#14,DBLRH
+LOCAL(one_byte):
+#ifdef __pic__
+	add	r0,r2
+	mova  LOCAL(c__clz_tab),r0
+#endif
+	mov.b	@(r0,r2),r2
+	mov	#21,r3
+	mov.w	LOCAL(x0),DBLRL
+	sub	r2,DBLRH
+LOCAL(norm_shift):
+	shld	DBLRH,r4
+	neg	DBLRH,DBLRH
+	mov.l	@r15+,r2
+	shld	r3,DBLRH
+	mov.l	LOCAL(x6fa00000),r3
+	add	r4,DBLRH
+	mov r2,r4
+	add	r3,DBLRH
+
+	div0s	r3,r4
+	rts
+	rotcr	DBLRH
+LOCAL(three_bytes):
+	mov	r4,r2
+	shlr16	r2
+#ifdef __pic__
+	add	r0,r2
+	mova  LOCAL(c__clz_tab),r0
+#endif
+	mov.b	@(r0,r2),r2
+	mov	#21,r3
+	mov	#6+10,DBLRH
+	sub	r2,DBLRH
+	mov	r4,DBLRL
+	shld	r3,DBLRL
+	shld	DBLRH,DBLRL
+	bra	LOCAL(norm_shift)
+	add	#-10,DBLRH
+LOCAL(zero):
+	rts	/* DBLRL has already been zeroed above.  */
+	mov.l @r15+,DBLRH
+LOCAL(x0):
+	.word 0
+	.balign	4
+LOCAL(x7f800000):
+	.long	0x7f800000
+LOCAL(x38000000):
+	.long	0x38000000
+LOCAL(x6fa00000):
+	/* Flip sign back, do exponent adjustment, and remove leading one.  */
+	.long 0x6fa00000 
+LOCAL(c__clz_tab):
+#ifdef __pic__
+	.long	GLOBAL(clz_tab) - .
+#else
+	.long	GLOBAL(clz_tab)
+#endif
+	ENDFUNC(GLOBAL(extendsfdf2))
+#endif /* L_sf_to_df */
+
+#ifdef L_df_to_sf
+	.balign 4
+	.global GLOBAL(truncdfsf2)
+	FUNC(GLOBAL(truncdfsf2))
+GLOBAL(truncdfsf2):
+	mov.l	LOCAL(x38000000),r3
+	mov	DBL0H,r1
+	mov.l	LOCAL(x70000000),r2
+	mov	DBL0H,r0
+	sub	r3,r1
+	mov.l	DBL0L,@-r15
+	tst	r2,r1
+	mov	#12,r3
+	shld	r3,r0			! Isolate highpart fraction.
+	bf	LOCAL(ill_exp)
+	shll2	r1
+	mov.l	LOCAL(x2fffffff),r2 /* Fraction lsb | lower guard bits.  */
+	shll2	r1
+	mov.l	LOCAL(xff000000),r3
+	shlr8	r0
+	tst	r2,DBL0L /* Check if msb guard bit wants rounding up.  */
+	mov	#-28,r2
+	bt/s	LOCAL(add_frac)
+	 shld	r2,DBL0L
+	add	#1,DBL0L
+LOCAL(add_frac):
+	add	DBL0L,r0
+	mov.l	LOCAL(x01000000),r2
+	and	r3,r1
+	mov.l	@r15+,DBL0L
+	add	r1,r0
+	tst	r3,r0
+	bt	LOCAL(inf_denorm0)
+	cmp/hs	r3,r0
+	bt	LOCAL(inf)
+	div0s	DBL0H,r2	/* copy orig. sign into T.  */
+	RETURN_R0_MAIN
+	rotcr	r0
+RETURN_FR0
+LOCAL(inf_denorm0):	! We might need to undo previous rounding.
+	mov.l	LOCAL(x2fffffff),r3 /* Old fraction lsb | lower guard bits.  */
+	tst	r1,r1
+	bf	LOCAL(inf)
+	add	#-1,r0
+	tst	r3,DBL0L /* Check if msb guard bit was rounded up.  */
+	mov.l	LOCAL(x5fffffff),r3 /* Fraction lsb | lower guard bits.  */
+	addc	r2,r0
+	shlr	r0
+	tst	r3,DBL0L /* Check if msb guard bit wants rounding up.  */
+	bt/s	LOCAL(denorm_noup)
+	 div0s	DBL0H,r2	/* copy orig. sign into T.  */
+	add	#1,r0
+LOCAL(denorm_noup):
+	RETURN_R0
+	rotcr	r0
+LOCAL(ill_exp):
+	div0s	DBL0H,r1
+	mov.l	LOCAL(x7ff80000),r2
+	add	r1,r1
+	bf	LOCAL(inf_nan)
+	mov.w	LOCAL(m32),r3 /* Handle denormal or zero.  */
+	mov	#-21,r2
+	shad	r2,r1
+	add	#-8,r1	/* Go from 9 to 1 guard bit in MSW.  */
+	cmp/gt	r3,r1
+	mov.l	@r15+,r3 /* DBL0L */
+	bf	LOCAL(zero)
+	mov.l	DBL0L, @-r15
+	shll8	DBL0L
+	rotcr	r0	/* Insert leading 1.  */
+	shld	r2,r3
+	cmp/pl	DBL0L	/* Check lower 23 guard bits if guard bit 23 is 0.  */
+	addc	r3,r0	/* Assemble fraction with compressed guard bits.  */
+	mov	r0,r2
+	shld	r1,r0
+	mov.l	@r15+,DBL0L
+	add	#32,r1
+	shld	r1,r2
+	tst	#2,r0
+	rotcl	r0
+	tst	r2,r2
+	rotcl	r0
+	xor	#3,r0
+	add	#3,r0	/* Even overflow gives the correct result.  */
+	shlr2	r0
+	div0s	r0,DBL0H
+	RETURN_R0
+	rotcr	r0
+LOCAL(zero):
+	mov	#0,r0
+	div0s	r0,DBL0H
+	RETURN_R0
+	rotcr	r0
+LOCAL(inf_nan):
+	not	DBL0H,r0
+	tst	r2,r0
+	mov.l	@r15+,DBL0L
+	bf	LOCAL(inf)
+	RETURN_R0
+	mov	#-1,r0	/* NAN */
+LOCAL(inf):	/* r2 must be positive here.  */
+	mov.l	LOCAL(xff000000),r0
+	div0s	r2,DBL0H
+	RETURN_R0
+	rotcr	r0
+LOCAL(m32):
+	.word	-32
+	.balign	4
+LOCAL(x38000000):
+	.long	0x38000000
+LOCAL(x70000000):
+	.long	0x70000000
+LOCAL(x2fffffff):
+	.long	0x2fffffff
+LOCAL(x01000000):
+	.long	0x01000000
+LOCAL(xff000000):
+	.long	0xff000000
+LOCAL(x5fffffff):
+	.long	0x5fffffff
+LOCAL(x7ff80000):
+	.long	0x7ff80000
+	ENDFUNC(GLOBAL(truncdfsf2))
+#endif /* L_df_to_sf */
+
+
+#ifdef L_addsub_df
+#include "IEEE-754/m3/adddf3.S"
+#endif /* _addsub_df */
+
+#ifdef L_mul_df
+#include "IEEE-754/m3/muldf3.S"
+#endif /* L_mul_df */
+
+#ifdef L_df_to_usi
+#include "IEEE-754/m3/fixunsdfsi.S"
+#endif /* L_df_to_usi */
+
+#ifdef L_df_to_si
+#include "IEEE-754/m3/fixdfsi.S"
+#endif /* L_df_to_si */
+
+#ifdef L_usi_to_df
+#include "IEEE-754/m3/floatunssidf.S"
+#endif /* L_usi_to_df */
+
+#ifdef L_si_to_df
+#include "IEEE-754/m3/floatsidf.S"
+#endif /* L_si_to_df */
+
+#ifdef L_div_df
+#include "IEEE-754/m3/divdf3.S"
+#endif /* L_div_df */
+#endif /* DYN_SHIFT */
+
+#endif /* __SH_FPU_DOUBLE__ */
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/ieee-754-sf.S gcc-st40-4.8.2.140205/libgcc/config/sh/ieee-754-sf.S
--- gcc-gnu-4.8.2/libgcc/config/sh/ieee-754-sf.S	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/ieee-754-sf.S	2013-05-28 13:16:16.000000000 +0200
@@ -0,0 +1,704 @@
+/* Copyright (C) 2006, 2008, 2009 Free Software Foundation, Inc.
+   Copyright (c) 2010 STMicroelectronics.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GCC is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+!! libgcc software floating-point routines for Renesas SH /
+!! STMicroelectronics ST40 CPUs
+!! Contributed by J"orn Rennecke joern.rennecke@st.com
+
+#ifndef __SH_FPU_ANY__
+
+#include "lib1funcs.h"
+
+#define SF_NAN_MASK		0x7fc00000
+
+/* Single-precision floating-point emulation.
+   We handle NANs, +-infinity, and +-zero.
+   However, we assume that for NANs, the topmost bit of the fraction is set.  */
+#ifdef L_nesf2
+/* -fno-finite-math-only inline version, T := r4:SF == r5:SF
+	cmp/eq	r4,r5
+	mov	r4,r0
+	bt	0f
+	or	r5,r0
+	add	r0,r0
+	tst	r0,r0	! test for +0.0 == -0.0 ; -0.0 == +0.0
+	0:			*/
+	.balign 4
+	.global GLOBAL(nesf2)
+	HIDDEN_FUNC(GLOBAL(nesf2))
+GLOBAL(nesf2):
+        /* If the raw values are unequal, the result is unequal, unless
+	   both values are +-zero.
+	   If the raw values are equal, the result is equal, unless
+	   the values are NaN.  */
+	cmp/eq	r4,r5
+	mov.l   LOCAL(c_SF_NAN_MASK),r1
+	bt.s	LOCAL(check_nan)
+	not	r4,r0
+	mov	r4,r0
+	or	r5,r0
+	rts
+	add	r0,r0
+LOCAL(check_nan):
+	tst	r1,r0
+	bt.s 	LOCAL(nan)
+	mov	#96,r2
+	shll16  r2
+	xor 	r2,r1
+	tst	r1,r0	
+LOCAL(nan):		
+	rts
+	movt	r0
+	
+	.balign 4
+LOCAL(c_SF_NAN_MASK):
+	.long SF_NAN_MASK
+LOCAL(c_SF_SNAN_MASK):
+	ENDFUNC(GLOBAL(nesf2))
+#endif /* L_nesf2 */
+
+#ifdef L_unord_sf
+	.balign 4
+	.global GLOBAL(unordsf2)
+	HIDDEN_FUNC(GLOBAL(unordsf2))
+GLOBAL(unordsf2):
+	mov.l	LOCAL(c_SF_NAN_MASK),r1
+	not	r4,r0
+	tst	r1,r0
+	not	r5,r0
+	bt	LOCAL(unord)
+	tst	r1,r0
+LOCAL(unord):
+	rts
+	movt	r0
+	.balign	4
+LOCAL(c_SF_NAN_MASK):
+	.long SF_NAN_MASK
+	ENDFUNC(GLOBAL(unordsf2))
+#endif /* L_unord_sf */
+
+#if defined(L_gtsf2f) || defined(L_gtsf2f_trap)
+/* -fno-finite-math-only inline version, T := r4:SF > r5:SF ? 0 : 1
+	cmp/pz	r4
+	mov	r4,r0
+	bf/s	0f
+	 cmp/hs	r5,r4
+	cmp/ge	r4,r5
+	or	r5,r0
+	bt	0f
+	add	r0,r0
+	tst	r0,r0
+	0:			*/
+#ifdef L_gtsf2f
+#define fun_label GLOBAL(gtsf2f)
+#else
+#define fun_label GLOBAL(gtsf2f_trap)
+#endif
+	.balign 4
+	.global fun_label
+	HIDDEN_FUNC(fun_label)
+fun_label:
+	/* If the raw values compare greater, the result true, unless
+	   any of them is a nan (but infinity is fine), or both values are
+	   +- zero.  Otherwise, the result false.  */
+	mov.l	LOCAL(c_SF_NAN_MASK),r1
+	cmp/pz	r4
+	not	r5,r0
+	SLC(bf,	LOCAL(neg),
+	 tst	r1,r0)
+	mov	r4,r0
+	bt	LOCAL(nan)
+	cmp/gt	r5,r4
+	SLC(bf,	LOCAL(check_nan),
+	 cmp/gt	r4,r1)
+	bf	LOCAL(nan)
+	or	r5,r0
+	rts
+	add	r0,r0
+LOCAL(neg):
+	SLI(tst	r1,r0)
+	bt	LOCAL(nan)
+	not	r4,r0
+	tst	r1,r0
+	bt	LOCAL(nan)
+	cmp/hi	r4,r5
+#if defined(L_gtsf2f) && defined(DELAYED_BRANCHES)
+LOCAL(check_nan):
+#endif /* DELAYED_BRANCHES */
+	rts
+	movt	r0
+#ifdef L_gtsf2f
+LOCAL(check_nan):
+LOCAL(nan):
+	rts
+	mov	#0,r0
+#else /* ! L_gtsf2f */
+LOCAL(check_nan):
+	SLI(cmp/gt	r4,r1)
+	bf	LOCAL(nan)
+	rts
+	movt	r0
+LOCAL(nan):
+	mov	#0,r0
+	trapa	#0
+#endif /* ! L_gtsf2f */
+	.balign	4
+LOCAL(c_SF_NAN_MASK):
+	.long SF_NAN_MASK
+	ENDFUNC(fun_label)
+#endif /* L_gtsf2f */
+
+#if defined(L_gesf2f) || defined(L_gesf2f_trap)
+/* -fno-finite-math-only inline version, T := r4:SF >= r5:SF */
+	cmp/pz	r5
+	mov	r4,r0
+	bf/s	0f
+	 cmp/hs	r4,r5
+	cmp/ge	r5,r4
+	or	r5,r0
+	bt	0f
+	add	r0,r0
+	tst	r0,r0
+	0:
+#ifdef L_gesf2f
+#define fun_label GLOBAL(gesf2f)
+#else
+#define fun_label GLOBAL(gesf2f_trap)
+#endif
+	.balign 4
+	.global fun_label
+	HIDDEN_FUNC(fun_label)
+fun_label:
+	/* If the raw values compare greater or equal, the result is
+	   true, unless any of them is a nan.  If both are -+zero, the
+	   result is true; otherwise, it is false.
+	   We use 0 as true and nonzero as false for this function.  */
+	mov.l	LOCAL(c_SF_NAN_MASK),r1
+	cmp/pz	r5
+	not	r4,r0
+	SLC(bf,	LOCAL(neg),
+	 tst	r1,r0)
+	mov	r4,r0
+	bt	LOCAL(nan)
+	cmp/gt	r4,r5
+	SLC(bf,	LOCAL(check_nan),
+	 cmp/ge	r1,r5)
+	bt	LOCAL(nan)
+	or	r5,r0
+	rts
+	add	r0,r0
+LOCAL(neg):
+	SLI(tst	r1,r0)
+	bt	LOCAL(nan)
+	not	r5,r0
+	tst	r1,r0
+	bt	LOCAL(nan)
+	cmp/hi	r5,r4
+#if defined(L_gesf2f) && defined(DELAYED_BRANCHES)
+LOCAL(nan): LOCAL(check_nan):
+#endif
+	rts
+	movt	r0
+#if defined(L_gesf2f) && ! defined(DELAYED_BRANCHES)
+LOCAL(check_nan):
+	cmp/ge	r1,r5
+LOCAL(nan):
+	rts
+	movt	r0
+#endif /* ! DELAYED_BRANCHES */
+#ifdef L_gesf2f_trap
+LOCAL(check_nan):
+	SLI(cmp/ge	r1,r5)
+	bt	LOCAL(nan)
+	rts
+LOCAL(nan):
+	movt	r0
+	trapa	#0
+#endif /* L_gesf2f_trap */
+	.balign	4
+LOCAL(c_SF_NAN_MASK):
+	.long SF_NAN_MASK
+	ENDFUNC(GLOBAL(gesf2f))
+#endif /* L_gesf2f */
+
+#ifndef DYN_SHIFT /* SH1 / SH2 code */
+#ifdef L_addsub_sf
+#include "IEEE-754/addsf3.S"
+#endif /* _addsub_sf */
+
+#ifdef L_mul_sf
+#include "IEEE-754/mulsf3.S"
+#endif /* L_mul_sf */
+
+#ifdef L__fixunssfsi
+#include "IEEE-754/fixunssfsi.S"
+#endif /* L_fixunssfsi */
+
+#ifdef L_sf_to_si
+#include "IEEE-754/fixsfsi.S"
+#endif /* L_sf_to_si */
+
+#ifdef L_usi_to_sf
+#include "IEEE-754/floatunssisf.S"
+#endif /* L_usi_to_sf */
+
+#ifdef L_si_to_sf
+#include "IEEE-754/floatsisf.S"
+#endif /* L_si_to_sf */
+
+#ifdef L_div_sf
+#include "IEEE-754/divsf3.S"
+#endif /* L_div_sf */
+#endif /* ! DYN_SHIFT */
+
+/* The actual arithmetic uses dynamic shift.  Supporting SH1 / SH2 here would
+   make this code too hard to maintain, so if you want to add SH1 / SH2
+   support, do it in a separate copy.  */
+#ifdef DYN_SHIFT
+#ifdef L_addsub_sf
+#include "IEEE-754/m3/addsf3.S"
+#endif /* L_addsub_sf */
+
+#ifdef L_mul_sf
+#include "IEEE-754/m3/mulsf3.S"
+#endif /* L_mul_sf */
+
+#ifdef L_fixunssfsi
+	! What is a bit unusal about this implementation is that the
+	! sign bit influences the result for NANs: for cleared sign bit, you
+	! get UINT_MAX, for set sign bit, you get 0.
+	! However, since the result for NANs is undefined, this should be no
+	! problem.
+	! N.B. This is scheduled both for SH4-200 and SH4-300
+	.balign 4
+	.global GLOBAL(fixunssfsi)
+	FUNC(GLOBAL(fixunssfsi))
+GLOBAL(fixunssfsi):
+	mov.l	LOCAL(max),r2
+	mov	#-23,r1
+	mov	r4,r0
+	shad	r1,r4
+	mov.l	LOCAL(mask),r1
+	add	#-127,r4
+	cmp/ge	r2,r0
+	or	r2,r0
+	bt	LOCAL(retmax)
+	cmp/pz	r4
+	and	r1,r0
+	bf	LOCAL(ret0)
+	add	#-23,r4
+	rts
+	shld	r4,r0
+LOCAL(ret0):
+LOCAL(retmax):
+	rts
+	subc	r0,r0
+	.balign 4
+LOCAL(mask):
+	.long	0x00ffffff
+LOCAL(max):
+	.long	0x4f800000
+	ENDFUNC(GLOBAL(fixunssfsi))
+#endif /* L_fixunssfsi */
+
+#ifdef L_sf_to_si
+	! What is a bit unusal about this implementation is that the
+	! sign bit influences the result for NANs: for cleared sign bit, you
+	! get INT_MAX, for set sign bit, you get INT_MIN.
+	! However, since the result for NANs is undefined, this should be no
+	! problem.
+	! N.B. This is scheduled both for SH4-200 and SH4-300
+	.balign 4
+	.global GLOBAL(fixsfsi)
+	FUNC(GLOBAL(fixsfsi))
+	.balign	4
+GLOBAL(fixsfsi):
+	mov	r4,r0
+	shll	r4
+	mov	#-24,r1
+	bt	LOCAL(neg)
+	mov.l	LOCAL(max),r2
+	shld	r1,r4
+	mov.l	LOCAL(mask),r1
+	add	#-127,r4
+	cmp/pz	r4
+	add	#-23,r4
+	bf	LOCAL(ret0)
+	cmp/gt	r0,r2
+	bf	LOCAL(retmax)
+	and	r1,r0
+	addc	r1,r0
+	rts
+	shld	r4,r0
+
+	.balign	4
+LOCAL(neg):
+	mov.l	LOCAL(min),r2
+	shld	r1,r4
+	mov.l	LOCAL(mask),r1
+	add	#-127,r4
+	cmp/pz	r4
+	add	#-23,r4
+	bf	LOCAL(ret0)
+	cmp/gt	r0,r2
+	bf	LOCAL(retmin)
+	and	r1,r0
+	addc	r1,r0
+	shld	r4,r0	! SH4-200 will start this insn on a new cycle
+	rts
+	neg	r0,r0
+
+	.balign	4
+LOCAL(ret0):
+	rts
+	mov	#0,r0
+
+LOCAL(retmax):
+	mov	#-1,r0
+	rts
+	shlr	r0
+
+LOCAL(retmin):
+	mov	#1,r0
+	rts
+	rotr	r0
+
+	.balign 4
+LOCAL(mask):
+	.long	0x007fffff
+LOCAL(max):
+	.long	0x4f000000
+LOCAL(min):
+	.long	0xcf000000
+	ENDFUNC(GLOBAL(fixsfsi))
+#endif /* L_sf_to_si */
+
+#ifdef L_usi_to_sf
+#include "IEEE-754/m3/floatunssisf.S"
+#endif /* L_usi_to_sf */
+
+#ifdef L_si_to_sf
+#include "IEEE-754/m3/floatsisf.S"
+#endif /* L_si_to_sf */
+
+#ifdef L_div_sf
+#include "IEEE-754/m3/divsf3.S"
+#endif /* L_div_sf */
+
+#ifdef L_hypotf
+	.balign 4
+	.global GLOBAL(hypotf)
+	FUNC(GLOBAL(hypotf))
+GLOBAL(hypotf):
+/* This integer implementation takes 71 to 72 cycles in the main path.
+   This is a bit slower than the SH4 can do this computation using double
+   precision hardware floating point - 57 cycles, or 69 with mode switches.  */
+ /* First, calculate x (r4) as the sum of the square of the fractions -
+    the exponent is calculated separately in r3.
+    Then, calculate sqrt(x) for the fraction by reciproot iteration.
+    We get an 7.5 bit inital value using linear approximation with two slopes
+    that are powers of two.
+    x (- [1. .. 2.)  y0 := 1.25 - x/4 - tab(x)   y (- (0.8 .. 1.0)
+    x (- [2. .. 4.)  y0 := 1.   - x/8 - tab(x)   y (- (0.5 .. 0.8)
+ x is represented with two bits before the point,
+ y with 0 bits before the binary point.
+ Thus, to calculate y0 := 1. - x/8 - tab(x), all you have to do is to shift x
+ right by 1, negate it, and subtract tab(x).  */
+
+ /* y1 := 1.5*y0 - 0.5 * (x * y0) * (y0 * y0)
+    z0 := x * y1
+    z1 := z0 + 0.5 * (y1 - (y1*y1) * z0) */
+
+	mov.l	LOCAL(xff000000),r1
+	add	r4,r4
+	mov	r4,r0
+	add	r5,r5
+	cmp/hs	r5,r4
+	sub	r5,r0
+	mov	#-24,r2
+	bf/s	LOCAL(r5_large)
+	shad	r2,r0
+	mov	r4,r3
+	shll8	r4
+	rotcr	r4
+	tst	#0xe0,r0
+	neg	r0,r0
+	bt	LOCAL(ret_abs_r3)
+	tst	r1,r5
+	shll8	r5
+	bt/s	LOCAL(denorm_r5)
+	cmp/hi	r3,r1
+	dmulu.l	r4,r4
+	bf	LOCAL(inf_nan)
+	rotcr	r5
+	shld	r0,r5
+LOCAL(denorm_r5_done):
+	sts	mach,r4
+	dmulu.l	r5,r5
+	mov.l	r6,@-r15
+	mov	#20,r6
+
+	sts	mach,r5
+LOCAL(add_frac):
+	mova	LOCAL(tab)-32,r0
+	mov.l	r7,@-r15
+	mov.w	LOCAL(x1380),r7
+	and	r1,r3
+	addc	r5,r4
+	mov.w	LOCAL(m25),r2	! -25
+	bf	LOCAL(frac_ok)
+	sub	r1,r3
+	rotcr	r4
+	cmp/eq	r1,r3	! did we generate infinity ?
+	bt	LOCAL(inf_nan)
+	shlr	r4
+	mov	r4,r1
+	shld	r2,r1
+	mov.b	@(r0,r1),r0
+	mov	r4,r1
+	shld	r6,r1
+	bra	LOCAL(frac_low2)
+	sub	r1,r7
+
+LOCAL(frac_ok):
+	mov	r4,r1
+	shld	r2,r1
+	mov.b	@(r0,r1),r1
+	cmp/pz	r4
+	mov	r4,r0
+	bt/s	LOCAL(frac_low)
+	shld	r6,r0
+	mov.w	LOCAL(xf80),r7
+	shlr	r0
+LOCAL(frac_low):
+	sub	r0,r7
+LOCAL(frac_low2):
+	mov.l	LOCAL(x40000080),r0 ! avoid denorm results near 1. << r3
+	sub	r1,r7	! {0.12}
+	mov.l	LOCAL(xfffe0000),r5 ! avoid rounding overflow near 4. << r3
+	swap.w	r7,r1	! {0.28}
+	dmulu.l	r1,r4 /* two issue cycles */
+	mulu.w	r7,r7  /* two issue cycles */
+	sts	mach,r2	! {0.26}
+	mov	r1,r7
+	shlr	r1
+	sts	macl,r6	! {0.24}
+	cmp/hi	r0,r4
+	shlr2	r2
+	bf	LOCAL(near_one)
+	shlr	r2	! {0.23} systemic error of linear approximation keeps y1 < 1
+	dmulu.l	r2,r6
+	cmp/hs	r5,r4
+	add	r7,r1	! {1.28}
+	bt	LOCAL(near_four)
+	shlr2	r1	! {1.26}
+	sts	mach,r0	! {0.15} x*y0^3 == {0.16} 0.5*x*y0^3
+	shlr2	r1	! {1.24}
+	shlr8	r1	! {1.16}
+	sett		! compensate for truncation of subtrahend, keep y1 < 1
+	subc	r0,r1   ! {0.16} y1;  max error about 3.5 ulp
+	swap.w	r1,r0
+	dmulu.l	r0,r4	! { 1.30 }
+	mulu.w	r1,r1
+	sts	mach,r2
+	shlr2	r0
+	sts	macl,r1
+	add	r2,r0
+	mov.l	LOCAL(xff000000),r6
+	add	r2,r0
+	dmulu.l	r1,r2
+	add	#127,r0
+	add	r6,r3	! precompensation for adding leading 1
+	sts	mach,r1
+	shlr	r3
+	mov.l	@r15+,r7
+	sub	r1,r0	! {0.31} max error about 50 ulp (+127)
+	mov.l	@r15+,r6
+	shlr8	r0	! {0.23} max error about 0.7 ulp
+	rts
+	add	r3,r0
+	
+LOCAL(r5_large):
+	mov	r5,r3
+	mov	#-31,r2
+	cmp/ge	r2,r0
+	shll8	r5
+	bf	LOCAL(ret_abs_r3)
+	rotcr	r5
+	tst	r1,r4
+	shll8	r4
+	bt/s	LOCAL(denorm_r4)
+	cmp/hi	r3,r1
+	dmulu.l	r5,r5
+	bf	LOCAL(inf_nan)
+	rotcr	r4
+LOCAL(denorm_r4_done):
+	shld	r0,r4
+	sts	mach,r5
+	dmulu.l	r4,r4
+	mov.l	r6,@-r15
+	mov	#20,r6
+	bra	LOCAL(add_frac)
+	sts	mach,r4
+
+LOCAL(near_one):
+	bra	LOCAL(assemble_sqrt)
+	mov	#0,r0
+LOCAL(near_four):
+	! exact round-to-nearest would add 255.  We add 256 for speed & compactness.
+	mov	r4,r0
+	shlr8	r0
+	add	#1,r0
+	tst	r0,r0
+	addc	r0,r3	! might generate infinity.
+LOCAL(assemble_sqrt):
+	mov.l	@r15+,r7
+	shlr	r3
+	mov.l	@r15+,r6
+	rts
+	add	r3,r0
+LOCAL(inf_nan):
+LOCAL(ret_abs_r3):
+	mov	r3,r0
+	rts
+	shlr	r0
+LOCAL(denorm_r5):
+	bf	LOCAL(inf_nan)
+	tst	r1,r4
+	bt	LOCAL(denorm_both)
+	dmulu.l	r4,r4
+	bra	LOCAL(denorm_r5_done)
+	shld	r0,r5
+LOCAL(denorm_r4):
+	bf	LOCAL(inf_nan)
+	tst	r1,r5
+	dmulu.l	r5,r5
+	bf	LOCAL(denorm_r4_done)
+LOCAL(denorm_both):	! normalize according to r3.
+	extu.w	r3,r2
+	mov.l	LOCAL(c__clz_tab),r0
+	cmp/eq	r3,r2
+	mov	#-8,r2
+	bt	0f
+	tst	r1,r3
+	mov	#-16,r2
+	bt	0f
+	mov	#-24,r2
+0:
+	shld	r2,r3
+	mov.l	r7,@-r15
+#ifdef __pic__
+	add	r0,r3
+	mova	 LOCAL(c__clz_tab),r0
+#endif
+	mov.b	@(r0,r3),r0
+	add	#32,r2
+	sub	r0,r2
+	shld	r2,r4
+	mov	r2,r7
+	dmulu.l	r4,r4
+	sts.l	pr,@-r15
+	mov	#1,r3
+	bsr	LOCAL(denorm_r5_done)
+	shld	r2,r5
+	mov.l	LOCAL(x01000000),r1
+	neg	r7,r2
+	lds.l	@r15+,pr
+	tst	r1,r0
+	mov.l	@r15+,r7
+	bt	0f
+	add	#1,r2
+	sub	r1,r0
+0:
+	rts
+	shld	r2,r0
+
+LOCAL(m25):
+	.word	-25
+LOCAL(x1380):
+	.word	0x1380
+LOCAL(xf80):
+	.word	0xf80
+	.balign	4
+LOCAL(xff000000):
+	.long	0xff000000
+LOCAL(x40000080):
+	.long	0x40000080
+LOCAL(xfffe0000):
+	.long	0xfffe0000
+LOCAL(x01000000):
+	.long	0x01000000
+LOCAL(c__clz_tab):
+#ifdef __pic__
+	.long	GLOBAL(clz_tab) - .
+#else
+	.long	GLOBAL(clz_tab)
+#endif
+
+/*
+double err(double x)
+{
+  return (x < 2. ? 1.25 - x/4. : 1. - x/8.) - 1./sqrt(x);
+}
+
+int
+main ()
+{
+  int i = 0;
+  double x, s, v;
+  double lx, hx;
+
+  s = 1./32.;
+  for (x = 1.; x < 4; x += s, i++)
+    {
+      lx = x;
+      hx = x + s - 1. / (1 << 30);
+      v = 0.5 * (err (lx) + err (hx));
+      printf ("%s% 4d%c",
+              (i & 7) == 0 ? "\t.byte\t" : "",
+              (int)(v * 4096 + 0.5) - 128,
+              (i & 7) == 7 ? '\n' : ',');
+    }
+  return 0;
+} */
+
+	.balign	4
+LOCAL(tab):
+	.byte	-113, -84, -57, -33, -11,   8,  26,  41
+	.byte	  55,  67,  78,  87,  94, 101, 106, 110
+	.byte	 113, 115, 115, 115, 114, 112, 109, 106
+	.byte	 101,  96,  91,  84,  77,  69,  61,  52
+	.byte	  51,  57,  63,  68,  72,  77,  80,  84
+	.byte	  87,  89,  91,  93,  95,  96,  97,  97
+	.byte	  97,  97,  97,  96,  95,  94,  93,  91
+	.byte	  89,  87,  84,  82,  79,  76,  72,  69
+	.byte	  65,  61,  57,  53,  49,  44,  39,  34
+	.byte	  29,  24,  19,  13,   8,   2,  -4, -10
+	.byte	 -17, -23, -29, -36, -43, -50, -57, -64
+	.byte	 -71, -78, -85, -93,-101,-108,-116,-124
+	ENDFUNC(GLOBAL(hypotf))
+#endif /* L_hypotf */
+#endif /* DYN_SHIFT */
+
+#endif /* __SH_FPU_ANY__ */
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/lib1funcs-4-300.S gcc-st40-4.8.2.140205/libgcc/config/sh/lib1funcs-4-300.S
--- gcc-gnu-4.8.2/libgcc/config/sh/lib1funcs-4-300.S	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/lib1funcs-4-300.S	2013-05-28 13:16:16.000000000 +0200
@@ -251,8 +251,8 @@
 	   don't get such an adjustment, it's OK to also compute one's -> two's
 	   complement adjustment suppression for a dividend of 0.  */
 	.balign 4
-GLOBAL(sdivsi3_i4i):
-	mov.l r6,@-r15
+GLOBAL(sdivsi3_i4i):	
+	mov.l r6,@-r15	
 	exts.b r5,r6
 	cmp/eq r5,r6
 	mov #-1,r1
@@ -403,12 +403,12 @@
 	addc r6,r0
 	rotcr r0
 	mov.l @r15+,r6
-	shad r1,r0
+	shld r1,r0	
 	rts
 	neg r0,r0
 	ENDFUNC(GLOBAL(udivsi3_i4i))
 	ENDFUNC(GLOBAL(sdivsi3_i4i))
-
+	
 /* This table has been generated by divtab-sh4.c.  */
 	.balign 4
 	.byte	-7
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/lib1funcs.h gcc-st40-4.8.2.140205/libgcc/config/sh/lib1funcs.h
--- gcc-gnu-4.8.2/libgcc/config/sh/lib1funcs.h	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/lib1funcs.h	2013-05-28 13:16:16.000000000 +0200
@@ -1,4 +1,5 @@
 /* Copyright (C) 1994-2013 Free Software Foundation, Inc.
+   Copyright (c) 2006  STMicroelectronics.
 
 This file is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
@@ -62,13 +63,152 @@
 #endif /* !__LITTLE_ENDIAN__ */
 
 #ifdef __sh1__
+/* branch with two-argument delay slot insn */
 #define SL(branch, dest, in_slot, in_slot_arg2) \
 	in_slot, in_slot_arg2; branch dest
+/* branch with one-argument delay slot insn */
 #define SL1(branch, dest, in_slot) \
 	in_slot; branch dest
+/* branch with comparison in delay slot */
+#define SLC(branch, dest, in_slot, in_slot_arg2) \
+        branch dest; in_slot, in_slot_arg2
+/* comparison in a delay slot, at branch destination */
+#define SLI(in_slot, in_slot_arg2) in_slot, in_slot_arg2
+#define SLCMP(branch, cmp1, cmp1arg2, cmp2, cmp2arg2) \
+	branch .+6; bra .+6; cmp2, cmp2arg2; cmp1, cmp1arg2
+#define DMULU_SAVE \
+ mov.l r10,@-r15; \
+ mov.l r11,@-r15; \
+ mov.l r12,@-r15; \
+ mov.l r13,@-r15
+#define DMULUL(m1, m2, rl) \
+ swap.w m1,r12; \
+ mulu.w r12,m2; \
+ swap.w m2,r13; \
+ sts macl,r10; \
+ mulu.w r13,m1; \
+ clrt; \
+ sts macl,r11; \
+ mulu.w r12,r13; \
+ addc r11,r10; \
+ sts macl,r12; \
+ mulu.w m1,m2; \
+ movt r11; \
+ sts macl,rl; \
+ mov r10,r13; \
+ shll16 r13; \
+ addc r13,rl; \
+ xtrct r11,r10; \
+ addc r10,r12 \
+/* N.B. the carry is cleared here.  */
+#define DMULUH(rh) mov r12,rh
+#define DMULU_RESTORE \
+ mov.l @r15+,r13; \
+ mov.l @r15+,r12; \
+ mov.l @r15+,r11; \
+ mov.l @r15+,r10
 #else /* ! __sh1__ */
+/* branch with two-argument delay slot insn */
 #define SL(branch, dest, in_slot, in_slot_arg2) \
-	branch##.s dest; in_slot, in_slot_arg2
+	branch##/s dest; in_slot, in_slot_arg2
+/* branch with one-argument delay slot insn */
 #define SL1(branch, dest, in_slot) \
 	branch##/s dest; in_slot
+/* branch with comparison in delay slot */
+#define SLC(branch, dest, in_slot, in_slot_arg2) \
+        branch##/s dest; in_slot, in_slot_arg2
+/* comparison in a delay slot, at branch destination */
+#define SLI(in_slot, in_slot_arg)
+#define SLCMP(branch, cmp1, cmp1arg2, cmp2, cmp2arg2) \
+	branch##/s .+6; cmp1, cmp1arg2; cmp2, cmp2arg2
+#define DMULU_SAVE
+#define DMULUL(m1, m2, rl) dmulu.l m1,m2; sts macl,rl
+#define DMULUH(rh) sts mach,rh
+#define DMULU_RESTORE
 #endif /* !__sh1__ */
+
+#if defined (__sh1__) || defined (__sh2__) || defined (__SH2E__)
+/* don't #define DYN_SHIFT */
+  #define SHLL4(REG)	\
+	shll2	REG;	\
+	shll2	REG
+
+  #define SHLR4(REG)	\
+	shlr2	REG;	\
+	shlr2	REG
+
+  #define SHLL6(REG)	\
+	shll2	REG;	\
+	shll2	REG;	\
+	shll2	REG
+
+  #define SHLR6(REG)	\
+	shlr2	REG;	\
+	shlr2	REG;	\
+	shlr2	REG
+
+  #define SHLL12(REG)	\
+	shll8	REG;	\
+	SHLL4 (REG)
+
+  #define SHLR12(REG)	\
+	shlr8	REG;	\
+	SHLR4 (REG)
+
+  #define SHLR19(REG)	\
+	shlr16	REG;	\
+	shlr2	REG;	\
+	shlr	REG
+
+  #define SHLL23(REG)	\
+	shll16	REG;	\
+	shlr	REG;	\
+	shll8	REG
+
+  #define SHLR24(REG)	\
+	shlr16	REG;	\
+	shlr8	REG
+
+  #define SHLR21(REG)	\
+	shlr16	REG;	\
+	shll2	REG;	\
+	add	REG,REG;\
+	shlr8	REG
+
+  #define SHLL21(REG)	\
+	shll16	REG;	\
+	SHLL4 (REG);	\
+	add	REG,REG
+
+  #define SHLR11(REG)	\
+	shlr8	REG;	\
+	shlr2	REG;	\
+	shlr	REG
+
+  #define SHLR22(REG)	\
+	shlr16	REG;	\
+	shll2	REG;	\
+	shlr8	REG
+
+  #define SHLR23(REG)	\
+	shlr16	REG;	\
+	add	REG,REG;\
+	shlr8	REG
+
+  #define SHLR20(REG)	\
+	shlr16	REG;	\
+	SHLR4 (REG)
+
+  #define SHLL20(REG)	\
+	shll16	REG;	\
+	SHLL4 (REG)
+#define SHLD_COUNT(N,COUNT)
+#define SHLRN(N,COUNT,REG) SHLR##N(REG)
+#define SHLLN(N,COUNT,REG) SHLL##N(REG)
+#else
+#define SHLD_COUNT(N,COUNT) mov #N,COUNT
+#define SHLRN(N,COUNT,REG) shld COUNT,REG
+#define SHLLN(N,COUNT,REG) shld COUNT,REG
+#define DYN_SHIFT 1
+#endif
+
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/lib1funcs-Os-4-200.S gcc-st40-4.8.2.140205/libgcc/config/sh/lib1funcs-Os-4-200.S
--- gcc-gnu-4.8.2/libgcc/config/sh/lib1funcs-Os-4-200.S	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/lib1funcs-Os-4-200.S	2013-05-28 13:16:16.000000000 +0200
@@ -1,4 +1,5 @@
 /* Copyright (C) 2006-2013 Free Software Foundation, Inc.
+   Copyright (c) 2009  STMicroelectronics.
 
 This file is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
@@ -39,7 +40,7 @@
 	.global GLOBAL(udivsi3_i4i)
 	FUNC(GLOBAL(udivsi3_i4i))
 GLOBAL(udivsi3_i4i):
-	mova L1,r0
+	mova LOCAL(L1),r0
 	cmp/pz r5
 	sts fpscr,r1
 	lds.l @r0+,fpscr
@@ -106,7 +107,7 @@
 	movt r0
 
 	.p2align 2
-L1:
+LOCAL(L1):
 #ifndef FMOVD_WORKS
 	.long 0x80000
 #else
@@ -272,7 +273,7 @@
 GLOBAL(sdivsi3_i4i):
 	sts.l fpscr,@-r15
 	sts fpul,r1
-	mova L1,r0
+	mova LOCAL(L1),r0
 	lds.l @r0+,fpscr
 	lds r4,fpul
 #ifdef FMOVD_WORKS
@@ -309,7 +310,7 @@
 	lds r1,fpul
 
 	.p2align 2
-L1:
+LOCAL(L1):
 #ifndef FMOVD_WORKS
 	.long 0x80000
 #else
@@ -320,3 +321,4 @@
 #endif /* __SH_FPU_DOUBLE__ */
 #endif /* L_sdivsi3_i4i */
 #endif /* !__SHMEDIA__ */
+	
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/lib1funcs.S gcc-st40-4.8.2.140205/libgcc/config/sh/lib1funcs.S
--- gcc-gnu-4.8.2/libgcc/config/sh/lib1funcs.S	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/lib1funcs.S	2013-08-02 11:04:10.000000000 +0200
@@ -1,4 +1,5 @@
 /* Copyright (C) 1994-2013 Free Software Foundation, Inc.
+   Copyright (c) 2009  STMicroelectronics.
 
 This file is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
@@ -746,7 +747,7 @@
 GLOBAL(movmem):
 	sts.l	pr,@-r15
 	shll2	r6
-	bsr	GLOBAL(movmemSI52+2)
+	bsr	LOCAL(movmemSI52)+2
 	mov.l	@(48,r5),r0
 	.balign	4
 LOCAL(movmem_loop): /* Reached with rts */
@@ -762,10 +763,10 @@
 	add	#64,r5
 	mov.l	r0,@(52,r4)
 	add	#64,r4
-	bt	GLOBAL(movmemSI52)
+	bt	LOCAL(movmemSI52)
 ! done all the large groups, do the remainder
 ! jump to movmem+
-	mova	GLOBAL(movmemSI4)+4,r0
+	mova	LOCAL(movmemSI4)+4,r0
 	add	r6,r0
 	jmp	@r0
 LOCAL(movmem_done): ! share slot insn, works out aligned.
@@ -775,102 +776,86 @@
 	rts
 	mov.l	r0,@(52,r4)
 	.balign	4
-! ??? We need aliases movstr* for movmem* for the older libraries.  These
-! aliases will be removed at the some point in the future.
 	.global	GLOBAL(movmemSI64)
 	HIDDEN_FUNC(GLOBAL(movmemSI64))
-	HIDDEN_ALIAS(movstrSI64,movmemSI64)
 GLOBAL(movmemSI64):
 	mov.l	@(60,r5),r0
 	mov.l	r0,@(60,r4)
 	.global	GLOBAL(movmemSI60)
 	HIDDEN_FUNC(GLOBAL(movmemSI60))
-	HIDDEN_ALIAS(movstrSI60,movmemSI60)
 GLOBAL(movmemSI60):
 	mov.l	@(56,r5),r0
 	mov.l	r0,@(56,r4)
 	.global	GLOBAL(movmemSI56)
 	HIDDEN_FUNC(GLOBAL(movmemSI56))
-	HIDDEN_ALIAS(movstrSI56,movmemSI56)
 GLOBAL(movmemSI56):
 	mov.l	@(52,r5),r0
 	mov.l	r0,@(52,r4)
 	.global	GLOBAL(movmemSI52)
 	HIDDEN_FUNC(GLOBAL(movmemSI52))
-	HIDDEN_ALIAS(movstrSI52,movmemSI52)
 GLOBAL(movmemSI52):
+LOCAL(movmemSI52):
 	mov.l	@(48,r5),r0
 	mov.l	r0,@(48,r4)
 	.global	GLOBAL(movmemSI48)
 	HIDDEN_FUNC(GLOBAL(movmemSI48))
-	HIDDEN_ALIAS(movstrSI48,movmemSI48)
 GLOBAL(movmemSI48):
 	mov.l	@(44,r5),r0
 	mov.l	r0,@(44,r4)
 	.global	GLOBAL(movmemSI44)
 	HIDDEN_FUNC(GLOBAL(movmemSI44))
-	HIDDEN_ALIAS(movstrSI44,movmemSI44)
 GLOBAL(movmemSI44):
 	mov.l	@(40,r5),r0
 	mov.l	r0,@(40,r4)
 	.global	GLOBAL(movmemSI40)
 	HIDDEN_FUNC(GLOBAL(movmemSI40))
-	HIDDEN_ALIAS(movstrSI40,movmemSI40)
 GLOBAL(movmemSI40):
 	mov.l	@(36,r5),r0
 	mov.l	r0,@(36,r4)
 	.global	GLOBAL(movmemSI36)
 	HIDDEN_FUNC(GLOBAL(movmemSI36))
-	HIDDEN_ALIAS(movstrSI36,movmemSI36)
 GLOBAL(movmemSI36):
 	mov.l	@(32,r5),r0
 	mov.l	r0,@(32,r4)
 	.global	GLOBAL(movmemSI32)
 	HIDDEN_FUNC(GLOBAL(movmemSI32))
-	HIDDEN_ALIAS(movstrSI32,movmemSI32)
 GLOBAL(movmemSI32):
 	mov.l	@(28,r5),r0
 	mov.l	r0,@(28,r4)
 	.global	GLOBAL(movmemSI28)
 	HIDDEN_FUNC(GLOBAL(movmemSI28))
-	HIDDEN_ALIAS(movstrSI28,movmemSI28)
 GLOBAL(movmemSI28):
 	mov.l	@(24,r5),r0
 	mov.l	r0,@(24,r4)
 	.global	GLOBAL(movmemSI24)
 	HIDDEN_FUNC(GLOBAL(movmemSI24))
-	HIDDEN_ALIAS(movstrSI24,movmemSI24)
 GLOBAL(movmemSI24):
 	mov.l	@(20,r5),r0
 	mov.l	r0,@(20,r4)
 	.global	GLOBAL(movmemSI20)
 	HIDDEN_FUNC(GLOBAL(movmemSI20))
-	HIDDEN_ALIAS(movstrSI20,movmemSI20)
 GLOBAL(movmemSI20):
 	mov.l	@(16,r5),r0
 	mov.l	r0,@(16,r4)
 	.global	GLOBAL(movmemSI16)
 	HIDDEN_FUNC(GLOBAL(movmemSI16))
-	HIDDEN_ALIAS(movstrSI16,movmemSI16)
 GLOBAL(movmemSI16):
 	mov.l	@(12,r5),r0
 	mov.l	r0,@(12,r4)
 	.global	GLOBAL(movmemSI12)
 	HIDDEN_FUNC(GLOBAL(movmemSI12))
-	HIDDEN_ALIAS(movstrSI12,movmemSI12)
 GLOBAL(movmemSI12):
 	mov.l	@(8,r5),r0
 	mov.l	r0,@(8,r4)
 	.global	GLOBAL(movmemSI8)
 	HIDDEN_FUNC(GLOBAL(movmemSI8))
-	HIDDEN_ALIAS(movstrSI8,movmemSI8)
 GLOBAL(movmemSI8):
 	mov.l	@(4,r5),r0
 	mov.l	r0,@(4,r4)
 	.global	GLOBAL(movmemSI4)
 	HIDDEN_FUNC(GLOBAL(movmemSI4))
-	HIDDEN_ALIAS(movstrSI4,movmemSI4)
 GLOBAL(movmemSI4):
+LOCAL(movmemSI4):
 	mov.l	@(0,r5),r0
 	rts
 	mov.l	r0,@(0,r4)
@@ -909,7 +894,7 @@
 	HIDDEN_ALIAS(movstrSI12_i4,movmemSI12_i4)
 
 	.p2align	5
-L_movmem_2mod4_end:
+LOCAL(movmem_2mod4_end):
 	mov.l	r0,@(16,r4)
 	rts
 	mov.l	r1,@(20,r4)
@@ -918,7 +903,7 @@
 
 GLOBAL(movmem_i4_even):
 	mov.l	@r5+,r0
-	bra	L_movmem_start_even
+	bra	LOCAL(movmem_start_even)
 	mov.l	@r5+,r1
 
 GLOBAL(movmem_i4_odd):
@@ -929,20 +914,20 @@
 	mov.l	r1,@(4,r4)
 	mov.l	r2,@(8,r4)
 
-L_movmem_loop:
+LOCAL(movmem_loop):
 	mov.l	r3,@(12,r4)
 	dt	r6
 	mov.l	@r5+,r0
-	bt/s	L_movmem_2mod4_end
+	bt/s	LOCAL(movmem_2mod4_end)
 	mov.l	@r5+,r1
 	add	#16,r4
-L_movmem_start_even:
+LOCAL(movmem_start_even):
 	mov.l	@r5+,r2
 	mov.l	@r5+,r3
 	mov.l	r0,@r4
 	dt	r6
 	mov.l	r1,@(4,r4)
-	bf/s	L_movmem_loop
+	bf/s	LOCAL(movmem_loop)
 	mov.l	r2,@(8,r4)
 	rts
 	mov.l	r3,@(12,r4)
@@ -980,17 +965,23 @@
 ! aa = bb*dd + (aa*dd*65536) + (cc*bb*65536)
 !
 
+#ifdef	DB_ST40300_BUG_WORKAROUND
+	.align	2
+#endif
 GLOBAL(mulsi3):
+#ifdef	DB_ST40300_BUG_WORKAROUND
+	nop
+#endif	
 	mulu.w  r4,r5		! multiply the lsws  macl=bb*dd
 	mov     r5,r3		! r3 = ccdd
 	swap.w  r4,r2		! r2 = bbaa
 	xtrct   r2,r3		! r3 = aacc
 	tst  	r3,r3		! msws zero ?
-	bf      hiset
+	bf      LOCAL(hiset)
 	rts			! yes - then we have the answer
 	sts     macl,r0
 
-hiset:	sts	macl,r0		! r0 = bb*dd
+LOCAL(hiset):	sts	macl,r0		! r0 = bb*dd
 	mulu.w	r2,r5		! brewing macl = aa*dd
 	sts	macl,r1
 	mulu.w	r3,r4		! brewing macl = cc*bb
@@ -1011,6 +1002,9 @@
 
 	.global	GLOBAL(sdivsi3_i4)
 	HIDDEN_FUNC(GLOBAL(sdivsi3_i4))
+#ifdef	DB_ST40300_BUG_WORKAROUND
+	.align	5
+#endif	
 GLOBAL(sdivsi3_i4):
 	lds r4,fpul
 	float fpul,dr0
@@ -1281,13 +1275,18 @@
 	blink tr2,r63
 	ENDFUNC(GLOBAL(sdivsi3))
 #else /* ! __SHMEDIA__ */
+	
+#ifdef	DB_ST40300_BUG_WORKAROUND
+	.align	2
+#endif
+	
 	FUNC(GLOBAL(sdivsi3))
 GLOBAL(sdivsi3):
 	mov	r4,r1
 	mov	r5,r0
 
 	tst	r0,r0
-	bt	div0
+	bt	LOCAL(div0)
 	mov	#0,r2
 	div0s	r2,r1
 	subc	r3,r3
@@ -1362,8 +1361,10 @@
 	rts
 	mov	r1,r0
 
-
-div0:	rts
+#ifdef	DB_ST40300_BUG_WORKAROUND
+	nop
+#endif		
+LOCAL(div0):	rts
 	mov	#0,r0
 
 	ENDFUNC(GLOBAL(sdivsi3))
@@ -1377,16 +1378,19 @@
 !! args in r4 and r5, result in fpul, clobber r0, r1, r4, r5, dr0, dr2, dr4,
 !! and t bit
 
+#ifdef	DB_ST40300_BUG_WORKAROUND
+	.align	2
+#endif
 	.global	GLOBAL(udivsi3_i4)
 	HIDDEN_FUNC(GLOBAL(udivsi3_i4))
 GLOBAL(udivsi3_i4):
 	mov #1,r1
 	cmp/hi r1,r5
-	bf trivial
+	bf LOCAL(trivial)
 	rotr r1
 	xor r1,r4
 	lds r4,fpul
-	mova L1,r0
+	mova 1f,r0
 #ifdef FMOVD_WORKS
 	fmov.d @r0+,dr4
 #else
@@ -1403,7 +1407,7 @@
 	rts
 	ftrc dr0,fpul
 
-trivial:
+LOCAL(trivial):
 	rts
 	lds r4,fpul
 
@@ -1411,7 +1415,7 @@
 #ifdef FMOVD_WORKS
 	.align 3	! make double below 8 byte aligned.
 #endif
-L1:
+1:
 	.double 2147483648
 
 	ENDFUNC(GLOBAL(udivsi3_i4))
@@ -1438,15 +1442,14 @@
 #endif /* ! __SH5__ || __SH5__ == 32 */
 #elif defined (__SH2A_SINGLE__) || defined (__SH2A_SINGLE_ONLY__) || defined(__SH4_SINGLE__) || defined(__SH4_SINGLE_ONLY__)
 !! args in r4 and r5, result in fpul, clobber r0, r1, r4, r5, dr0, dr2, dr4
-
 	.global	GLOBAL(udivsi3_i4)
 	HIDDEN_FUNC(GLOBAL(udivsi3_i4))
 GLOBAL(udivsi3_i4):
 	mov #1,r1
 	cmp/hi r1,r5
-	bf trivial
+	bf LOCAL(trivial)
 	sts.l fpscr,@-r15
-	mova L1,r0
+	mova 1f,r0
 	lds.l @r0+,fpscr
 	rotr r1
 	xor r1,r4
@@ -1471,12 +1474,12 @@
 #ifdef FMOVD_WORKS
 	.align 3	! make double below 8 byte aligned.
 #endif
-trivial:
+LOCAL(trivial):
 	rts
 	lds r4,fpul
 
 	.align 2
-L1:
+1:
 #ifndef FMOVD_WORKS
 	.long 0x80000
 #else
@@ -1491,7 +1494,6 @@
 #ifdef L_udivsi3
 /* __SH4_SINGLE_ONLY__ keeps this part for link compatibility with
    sh2e/sh3e code.  */
-
 !! args in r4 and r5, result in r0, clobbers r4, pr, and t bit
 	.global	GLOBAL(udivsi3)
 	HIDDEN_FUNC(GLOBAL(udivsi3))
@@ -1633,7 +1635,15 @@
  div1 r5,r4; rotcl r0
  div1 r5,r4; rotcl r0
  div1 r5,r4; rotcl r0
- rts; div1 r5,r4
+#ifdef	DB_ST40300_BUG_WORKAROUND
+	nop
+#endif		
+ rts
+ div1 r5,r4
+
+#ifdef	DB_ST40300_BUG_WORKAROUND
+	.align	2
+#endif
 
 GLOBAL(udivsi3):
  sts.l pr,@-r15
@@ -1647,6 +1657,9 @@
  div0u
  swap.w r4,r0
  shlr16 r4
+#ifdef	DB_ST40300_BUG_WORKAROUND
+ nop
+#endif			
  bsr LOCAL(div8)
  shll16 r5
  bsr LOCAL(div7)
@@ -1671,6 +1684,9 @@
  mov #0,r0
  xtrct r4,r0
  xtrct r0,r4
+#ifdef	DB_ST40300_BUG_WORKAROUND
+ nop
+#endif		
  bsr LOCAL(divx4)
  rotcl r0
  bsr LOCAL(divx4)
@@ -1998,6 +2014,10 @@
 #ifdef __SH5__
 	.mode	SHcompact
 #endif
+	
+#ifdef	DB_ST40300_BUG_WORKAROUND
+	.align	2
+#endif	
 	.global GLOBAL(set_fpscr)
 	HIDDEN_FUNC(GLOBAL(set_fpscr))
 GLOBAL(set_fpscr):
@@ -2039,6 +2059,9 @@
 #endif
 #if defined(__SH4__) || defined (__SH2A_DOUBLE__)
 	swap.w r0,r2
+#ifdef	DB_ST40300_BUG_WORKAROUND
+	nop
+#endif		
 	rts
 	mov.l r2,@r1
 #else /* defined(__SH2E__) || defined(__SH3E__) || defined(__SH4_SINGLE*__) */
@@ -2075,6 +2098,54 @@
 #endif /* SH2E / SH3E / SH4 */
 #endif /* __SH2A_NOFPU__ */
 #endif /* L_set_fpscr */
+
+/* i-cache flushing
+ * For system code, we use ic_invalidate_line_i, but user code
+ * needs a different mechanism.  There are a number of ways of doing
+ * this:
+ *	1.  A kernel syscall (generally not available, slow but supports multiple arch variants)
+ *	2.  A kernel vsyscall (optimum solution, supports multiple arch variants)
+ *	3.  A jump table (supports 1 arch variant)
+ * For 3, different SH4 variants use different sizes and associativities
+ * of the Icache.  We use a small bit of dispatch code that can be put
+ * hidden in every shared object, which calls the actual processor-specific
+ * invalidation code in a separate module.
+ */
+
+/*
+ * SYSCALL method for i-cache flushing
+ */
+
+#ifdef L_ic_invalidate_syscall
+#include <asm/unistd.h>
+#include <asm/cachectl.h>
+
+	.global GLOBAL(ic_invalidate_syscall)
+	HIDDEN_FUNC(GLOBAL(ic_invalidate_syscall))
+	HIDDEN_ALIAS(ic_invalidate,ic_invalidate_syscall)
+GLOBAL(ic_invalidate_syscall):
+	mov.l	1f, r6
+	mov.l	2f, r3
+	/* Note: L1 cacheline size is not exposed to userspace
+	 *       so we use a length of 4 so it will work for
+	 *       different cacheline sizes
+	 */
+	mov	#4, r5
+	trapa	#0x13
+	rts
+	 nop
+	.balign 4
+1:	.long (CACHEFLUSH_D_WB | CACHEFLUSH_I)
+2:	.long __NR_cacheflush
+
+	ENDFUNC(GLOBAL(ic_invalidate_syscall))
+
+#endif /* L_ic_invalidate_syscall */
+
+/*
+ * Jump table method for i-cache flushing
+ */
+
 #ifdef L_ic_invalidate
 #if __SH5__ == 32
 	.mode	SHmedia
@@ -2108,7 +2179,7 @@
 	synci
 	blink	tr0, r63
 	ENDFUNC(GLOBAL(ic_invalidate))
-#elif defined(__SH4A__)
+#elif defined(__SH4A__) || defined(__FORCE_SH4A__)
 	.global GLOBAL(ic_invalidate)
 	HIDDEN_FUNC(GLOBAL(ic_invalidate))
 GLOBAL(ic_invalidate):
@@ -2119,18 +2190,11 @@
 	  nop
 	ENDFUNC(GLOBAL(ic_invalidate))
 #elif defined(__SH4_SINGLE__) || defined(__SH4__) || defined(__SH4_SINGLE_ONLY__) || (defined(__SH4_NOFPU__) && !defined(__SH5__))
-	/* For system code, we use ic_invalidate_line_i, but user code
-	   needs a different mechanism.  A kernel call is generally not
-	   available, and it would also be slow.  Different SH4 variants use
-	   different sizes and associativities of the Icache.  We use a small
-	   bit of dispatch code that can be put hidden in every shared object,
-	   which calls the actual processor-specific invalidation code in a
-	   separate module.
-	   Or if you have operating system support, the OS could mmap the
-	   procesor-specific code from a single page, since it is highly
-	   repetitive.  */
 	.global GLOBAL(ic_invalidate)
 	HIDDEN_FUNC(GLOBAL(ic_invalidate))
+#ifdef	DB_ST40300_BUG_WORKAROUND
+	.align	2
+#endif	
 GLOBAL(ic_invalidate):
 #ifdef __pic__
 #ifdef __vxworks
@@ -2175,7 +2239,6 @@
 
 #ifdef L_ic_invalidate_array
 #if defined(__SH4A__) || (defined (__FORCE_SH4A__) && (defined(__SH4_SINGLE__) || defined(__SH4__) || defined(__SH4_SINGLE_ONLY__) || (defined(__SH4_NOFPU__) && !defined(__SH5__))))
-	.global GLOBAL(ic_invalidate_array)
 	/* This is needed when an SH4 dso with trampolines is used on SH4A.  */
 	.global GLOBAL(ic_invalidate_array)
 	FUNC(GLOBAL(ic_invalidate_array))
@@ -3078,7 +3141,7 @@
  .global GLOBAL(sdivsi3)
 GLOBAL(sdivsi3):
 #ifdef TEXT_DATA_BUG
- ptb datalabel Local_div_table,tr0
+ ptb datalabel LOCAL(Ldiv_table),tr0
 #else
  ptb GLOBAL(div_table_internal),tr0
 #endif
@@ -3132,8 +3195,8 @@
 #endif /* __pic__ */
 #if defined(TEXT_DATA_BUG) && defined(__pic__) && defined(__SHMEDIA__)
 	.balign 2
-	.type	Local_div_table,@object
-	.size	Local_div_table,128
+	.type	LOCAL(Ldiv_table),@object
+	.size	LOCAL(Ldiv_table),128
 /* negative division constants */
 	.word	-16638
 	.word	-17135
@@ -3169,7 +3232,7 @@
 	.byte	214
 	.byte	241
 	.skip 16
-Local_div_table:
+LOCAL(Ldiv_table):
 	.skip 16
 /* positive division factors */
 	.byte	241
@@ -3301,11 +3364,19 @@
 #define L_MSWLSB 1
 #endif
 
+	
 	.balign 4
 	.global	GLOBAL(udivsi3_i4i)
 	FUNC(GLOBAL(udivsi3_i4i))
+#ifdef	DB_ST40300_BUG_WORKAROUND
+	.align	5
+#endif			
 GLOBAL(udivsi3_i4i):
+#ifdef	DB_ST40300_BUG_WORKAROUND
+	mov.w LOCAL(c128_lw), r1
+#else
 	mov.w LOCAL(c128_w), r1
+#endif
 	div0u
 	mov r4,r0
 	shlr8 r0
@@ -3353,8 +3424,14 @@
 	rts
 	shld r1,r0
 
+#ifdef	DB_ST40300_BUG_WORKAROUND	
+LOCAL(c128_lw):
+	.word 128
+#else
 LOCAL(div_by_1_neg):
 	neg r4,r0
+#endif
+	
 LOCAL(div_by_1):
 	mov.l @r15+,r5
 	rts
@@ -3424,6 +3501,17 @@
 	FUNC(GLOBAL(sdivsi3_i4i))
 	/* This is link-compatible with a GLOBAL(sdivsi3) call,
 	   but we effectively clobber only r1.  */
+#ifdef	DB_ST40300_BUG_WORKAROUND
+	.align	5
+	
+LOCAL(div_by_1_neg):
+	neg r4,r0
+LOCAL(div_by_12):
+	mov.l @r15+,r5
+	rts
+	mov.l @r15+,r4
+#endif			
+	
 GLOBAL(sdivsi3_i4i):
 	mov.l r4,@-r15
 	cmp/pz r5
@@ -3920,6 +4008,9 @@
 	/* n1 < d, but n1 might be larger than d1.  */
 	.global GLOBAL(udiv_qrnnd_16)
 	.balign 8
+#ifdef	DB_ST40300_BUG_WORKAROUND
+	.align	5
+#endif		
 GLOBAL(udiv_qrnnd_16):
 	div0u
 	cmp/hi r6,r0
@@ -3960,3 +4051,8 @@
 	ENDFUNC(GLOBAL(udiv_qrnnd_16))
 #endif /* !__SHMEDIA__ */
 #endif /* L_udiv_qrnnd_16 */
+
+#ifndef L_div_table
+#include "ieee-754-sf.S"
+#include "ieee-754-df.S"
+#endif
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/supervisor-atomic.S gcc-st40-4.8.2.140205/libgcc/config/sh/supervisor-atomic.S
--- gcc-gnu-4.8.2/libgcc/config/sh/supervisor-atomic.S	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/supervisor-atomic.S	2013-08-09 09:33:06.000000000 +0200
@@ -0,0 +1,199 @@
+/* Copyright (C) 2006, 2008, 2009 Free Software Foundation, Inc.
+   Copyright (c) 2010 STMicroelectronics.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GCC is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+!! Atomic routines for the Renesas / SuperH SH CPUs for applications
+!! executing in supervisor mode.
+
+/* http://gcc.gnu.org/onlinedocs/gcc/_005f_005fatomic-Builtins.html
+   Just create a working set of atomic routines: When implementing patterns for these built-in functions, the memory model parameter can be ignored as long as the pattern implements the most restrictive __ATOMIC_SEQ_CST model. Any of the other memory models execute correctly with this memory model but they may not execute as efficiently as they could with a more appropriate implementation of the relaxed requirements. */
+
+#include "lib1funcs.h"
+
+#if ! __SH5__
+
+#define ATOMIC_BOOL_COMPARE_AND_SWAP(N,T) \
+	.global	GLOBAL(atomic_compare_exchange_##N); \
+	.align	1; \
+GLOBAL(atomic_compare_exchange_##N):; \
+	stc	sr, r1; \
+	mov	r1, r0; \
+	or	#0xf0, r0; \
+	ldc	r0, sr; \
+	mov.##T	@r4, r2; \
+	mov.##T	@r5, r3; \
+	cmp/eq	r2, r3; \
+	bf/s	0f; \
+	movt	r0; \
+	mov.##T	r6, @r4; \
+	ldc	r1, sr; \
+	rts; \
+	nop; \
+0:	mov.##T	r2, @r5; \
+	ldc	r1, sr; \
+	rts; \
+	nop; \
+	ENDFUNC(GLOBAL(atomic_compare_exchange_##N))
+
+ATOMIC_BOOL_COMPARE_AND_SWAP(1,b)
+ATOMIC_BOOL_COMPARE_AND_SWAP(2,w)
+ATOMIC_BOOL_COMPARE_AND_SWAP(4,l)
+
+#define ATOMIC_EXCHANGE(N,T) \
+	.global	GLOBAL(atomic_exchange_##N); \
+	.align	1; \
+GLOBAL(atomic_exchange_##N):; \
+	stc	sr, r1; \
+	mov	r1, r0; \
+	or	#0xf0, r0; \
+	ldc	r0, sr; \
+	mov.##T	@r4, r2; \
+	mov.##T	r5, @r4; \
+	ldc	r1, sr; \
+	rts; \
+	mov	r2, r0; \
+	ENDFUNC(GLOBAL(atomic_exchange_##N))
+
+ATOMIC_EXCHANGE(1,b)
+ATOMIC_EXCHANGE(2,w)
+ATOMIC_EXCHANGE(4,l)
+
+#define SYNC_FETCH_AND_OP(OP,N,T,EXT) \
+	.global	GLOBAL(atomic_fetch_##OP##_##N); \
+	.align	1; \
+GLOBAL(atomic_fetch_##OP##_##N):; \
+	stc	sr, r1; \
+	mov	r1, r0; \
+	or	#0xf0, r0; \
+	ldc	r0, sr; \
+	mov.##T	@r4, r2; \
+	mov	r5, r3; \
+	OP	r2, r3; \
+	mov.##T	r3, @r4; \
+	ldc	r1, sr; \
+	rts; \
+	 EXT	r2, r0; \
+	ENDFUNC(GLOBAL(atomic_fetch_##OP##_##N))
+
+SYNC_FETCH_AND_OP(add,1,b,extu.b)
+SYNC_FETCH_AND_OP(add,2,w,extu.w)
+SYNC_FETCH_AND_OP(add,4,l,extu.w)
+
+SYNC_FETCH_AND_OP(or,1,b,extu.b)
+SYNC_FETCH_AND_OP(or,2,w,extu.w)
+SYNC_FETCH_AND_OP(or,4,l,mov)
+
+SYNC_FETCH_AND_OP(and,1,b,extu.b)
+SYNC_FETCH_AND_OP(and,2,w,extu.w)
+SYNC_FETCH_AND_OP(and,4,l,mov)
+
+SYNC_FETCH_AND_OP(xor,1,b,extu.b)
+SYNC_FETCH_AND_OP(xor,2,w,extu.w)
+SYNC_FETCH_AND_OP(xor,4,l,mov)
+
+#define SYNC_FETCH_AND_COMBOP(OP,OP0,OP1,N,T,EXT) \
+	.global	GLOBAL(atomic_fetch_##OP##_##N); \
+	.align	1; \
+GLOBAL(atomic_fetch_##OP##_##N):; \
+	stc	sr, r1; \
+	mov	r1, r0; \
+	or	#0xf0, r0; \
+	ldc	r0, sr; \
+	mov.##T	@r4, r2; \
+	mov	r5, r3; \
+	OP0	r2, r3; \
+	OP1	r3, r3; \
+	mov.##T	r3, @r4; \
+	ldc	r1, sr; \
+	rts; \
+	 EXT	r2, r0; \
+	ENDFUNC(GLOBAL(atomic_fetch_##OP##_##N))
+
+SYNC_FETCH_AND_COMBOP(sub,sub,neg,1,b,extu.b)
+SYNC_FETCH_AND_COMBOP(sub,sub,neg,2,w,extu.w)
+SYNC_FETCH_AND_COMBOP(sub,sub,neg,4,l,mov)
+
+SYNC_FETCH_AND_COMBOP(nand,and,not,1,b,extu.b)
+SYNC_FETCH_AND_COMBOP(nand,and,not,2,w,extu.w)
+SYNC_FETCH_AND_COMBOP(nand,and,not,4,l,mov)
+
+#define SYNC_OP_AND_FETCH(OP,N,T,EXT) \
+	.global	GLOBAL(atomic_##OP##_fetch_##N); \
+	.align	1; \
+GLOBAL(atomic_##OP##_fetch_##N):; \
+	stc	sr, r1; \
+	mov	r1, r0; \
+	or	#0xf0, r0; \
+	ldc	r0, sr; \
+	mov.##T	@r4, r2; \
+	mov	r5, r3; \
+	OP	r2, r3; \
+	mov.##T	r3, @r4; \
+	ldc	r1, sr; \
+	rts; \
+	 EXT	r3, r0; \
+	ENDFUNC(GLOBAL(atomic_##OP##_fetch_##N))
+
+SYNC_OP_AND_FETCH(add,1,b,extu.b)
+SYNC_OP_AND_FETCH(add,2,w,extu.w)
+SYNC_OP_AND_FETCH(add,4,l,mov)
+
+SYNC_OP_AND_FETCH(or,1,b,extu.b)
+SYNC_OP_AND_FETCH(or,2,w,extu.w)
+SYNC_OP_AND_FETCH(or,4,l,mov)
+
+SYNC_OP_AND_FETCH(and,1,b,extu.b)
+SYNC_OP_AND_FETCH(and,2,w,extu.w)
+SYNC_OP_AND_FETCH(and,4,l,mov)
+
+SYNC_OP_AND_FETCH(xor,1,b,extu.b)
+SYNC_OP_AND_FETCH(xor,2,w,extu.w)
+SYNC_OP_AND_FETCH(xor,4,l,mov)
+
+#define SYNC_COMBOP_AND_FETCH(OP,OP0,OP1,N,T,EXT) \
+	.global	GLOBAL(atomic_##OP##_fetch_##N); \
+	.align	1; \
+GLOBAL(atomic_##OP##_fetch_##N):; \
+	stc	sr, r1; \
+	mov	r1, r0; \
+	or	#0xf0, r0; \
+	ldc	r0, sr; \
+	mov.##T	@r4, r2; \
+	mov	r5, r3; \
+	OP0	r2, r3; \
+	OP1	r3, r3; \
+	mov.##T	r3, @r4; \
+	ldc	r1, sr; \
+	rts; \
+	EXT	r3, r0; \
+	ENDFUNC(GLOBAL(atomic_##OP##_fetch_##N))
+
+SYNC_COMBOP_AND_FETCH(sub,sub,neg,1,b,extu.b)
+SYNC_COMBOP_AND_FETCH(sub,sub,neg,2,w,extu.w)
+SYNC_COMBOP_AND_FETCH(sub,sub,neg,4,l,mov)
+
+SYNC_COMBOP_AND_FETCH(nand,not,and,1,b,extu.b)
+SYNC_COMBOP_AND_FETCH(nand,not,and,2,w,extu.w)
+SYNC_COMBOP_AND_FETCH(nand,not,and,4,l,mov)
+
+#endif /* ! __SH5__ */
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/supervisor-sync.S gcc-st40-4.8.2.140205/libgcc/config/sh/supervisor-sync.S
--- gcc-gnu-4.8.2/libgcc/config/sh/supervisor-sync.S	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/supervisor-sync.S	2013-08-09 09:33:06.000000000 +0200
@@ -0,0 +1,215 @@
+/* Copyright (C) 2006, 2008, 2009 Free Software Foundation, Inc.
+   Copyright (c) 2010 STMicroelectronics.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GCC is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+!! Atomic routines for the Renesas / SuperH SH CPUs for applications
+!! executing in supervisor mode.
+
+/* http://gcc.gnu.org/onlinedocs/gcc/_005f_005fatomic-Builtins.html
+   Just create a working set of atomic routines: When implementing patterns for these built-in functions, the memory model parameter can be ignored as long as the pattern implements the most restrictive __SYNC_SEQ_CST model. Any of the other memory models execute correctly with this memory model but they may not execute as efficiently as they could with a more appropriate implementation of the relaxed requirements. */
+
+#include "lib1funcs.h"
+
+#if ! __SH5__
+
+#define SYNC_TEST_AND_SET(N,T,EXT) \
+	.global	GLOBAL(sync_lock_test_and_set_##N); \
+	.align	1; \
+GLOBAL(sync_lock_test_and_set_##N):; \
+	stc	sr, r1; \
+	mov	r1, r0; \
+	or	#0xf0, r0; \
+	ldc	r0, sr; \
+	mov.##T	@r4, r2; \
+	mov.##T	r5, @r4; \
+	ldc	r1, sr; \
+	rts; \
+	 EXT	r2, r0; \
+	ENDFUNC(GLOBAL(sync_lock_test_and_set_##N)) 
+
+SYNC_TEST_AND_SET(1,b,extu.b)
+SYNC_TEST_AND_SET(2,w,extu.w)
+SYNC_TEST_AND_SET(4,l,mov)
+
+#define SYNC_VAL_COMPARE_AND_SWAP(N,T) \
+	.global	GLOBAL(sync_val_compare_and_swap_##N); \
+	.align	1; \
+GLOBAL(sync_val_compare_and_swap_##N):; \
+	stc	sr, r1; \
+	mov	r1, r0; \
+	or	#0xf0, r0; \
+	ldc	r0, sr; \
+	mov.##T	@r4, r2; \
+	cmp/eq	r2, r5; \
+	bf	0f; \
+	mov.##T	r6, @r4; \
+0:	ldc	r1, sr; \
+	rts; \
+	mov	r2, r0; \
+	ENDFUNC(GLOBAL(sync_val_compare_and_swap_##N))
+
+SYNC_VAL_COMPARE_AND_SWAP(1,b)
+SYNC_VAL_COMPARE_AND_SWAP(2,w)
+SYNC_VAL_COMPARE_AND_SWAP(4,l)
+
+#define SYNC_BOOL_COMPARE_AND_SWAP(N,T) \
+	.global	GLOBAL(sync_bool_compare_and_swap_##N); \
+	.align	1; \
+GLOBAL(sync_bool_compare_and_swap_##N):; \
+	stc	sr, r1; \
+	mov	r1, r0; \
+	or	#0xf0, r0; \
+	ldc	r0, sr; \
+	mov.##T	@r4, r2; \
+	cmp/eq	r2, r5; \
+	bf/s	0f; \
+	movt	r0; \
+	mov.##T	r6, @r4; \
+0:	ldc	r1, sr; \
+	rts; \
+	nop; \
+	ENDFUNC(GLOBAL(sync_bool_compare_and_swap_##N))
+
+SYNC_BOOL_COMPARE_AND_SWAP(1,b)
+SYNC_BOOL_COMPARE_AND_SWAP(2,w)
+SYNC_BOOL_COMPARE_AND_SWAP(4,l)
+
+#define SYNC_FETCH_AND_OP(OP,N,T,EXT) \
+	.global	GLOBAL(sync_fetch_and_##OP##_##N); \
+	.align	1; \
+GLOBAL(sync_fetch_and_##OP##_##N):; \
+	stc	sr, r1; \
+	mov	r1, r0; \
+	or	#0xf0, r0; \
+	ldc	r0, sr; \
+	mov.##T	@r4, r2; \
+	mov	r5, r3; \
+	OP	r2, r3; \
+	mov.##T	r3, @r4; \
+	ldc	r1, sr; \
+	rts; \
+	 EXT	r2, r0; \
+	ENDFUNC(GLOBAL(sync_fetch_and_##OP##_##N))
+
+SYNC_FETCH_AND_OP(add,1,b,extu.b)
+SYNC_FETCH_AND_OP(add,2,w,extu.w)
+SYNC_FETCH_AND_OP(add,4,l,extu.w)
+
+SYNC_FETCH_AND_OP(or,1,b,extu.b)
+SYNC_FETCH_AND_OP(or,2,w,extu.w)
+SYNC_FETCH_AND_OP(or,4,l,mov)
+
+SYNC_FETCH_AND_OP(and,1,b,extu.b)
+SYNC_FETCH_AND_OP(and,2,w,extu.w)
+SYNC_FETCH_AND_OP(and,4,l,mov)
+
+SYNC_FETCH_AND_OP(xor,1,b,extu.b)
+SYNC_FETCH_AND_OP(xor,2,w,extu.w)
+SYNC_FETCH_AND_OP(xor,4,l,mov)
+
+#define SYNC_FETCH_AND_COMBOP(OP,OP0,OP1,N,T,EXT) \
+	.global	GLOBAL(sync_fetch_and_##OP##_##N); \
+	.align	1; \
+GLOBAL(sync_fetch_and_##OP##_##N):; \
+	stc	sr, r1; \
+	mov	r1, r0; \
+	or	#0xf0, r0; \
+	ldc	r0, sr; \
+	mov.##T	@r4, r2; \
+	mov	r5, r3; \
+	OP0	r2, r3; \
+	OP1	r3, r3; \
+	mov.##T	r3, @r4; \
+	ldc	r1, sr; \
+	rts; \
+	 EXT	r2, r0; \
+	ENDFUNC(GLOBAL(sync_fetch_and_##OP##_##N))
+
+SYNC_FETCH_AND_COMBOP(sub,sub,neg,1,b,extu.b)
+SYNC_FETCH_AND_COMBOP(sub,sub,neg,2,w,extu.w)
+SYNC_FETCH_AND_COMBOP(sub,sub,neg,4,l,mov)
+
+SYNC_FETCH_AND_COMBOP(nand,and,not,1,b,extu.b)
+SYNC_FETCH_AND_COMBOP(nand,and,not,2,w,extu.w)
+SYNC_FETCH_AND_COMBOP(nand,and,not,4,l,mov)
+
+#define SYNC_OP_AND_FETCH(OP,N,T,EXT) \
+	.global	GLOBAL(sync_##OP##_and_fetch_##N); \
+	.align	1; \
+GLOBAL(sync_##OP##_and_fetch_##N):; \
+	stc	sr, r1; \
+	mov	r1, r0; \
+	or	#0xf0, r0; \
+	ldc	r0, sr; \
+	mov.##T	@r4, r2; \
+	mov	r5, r3; \
+	OP	r2, r3; \
+	mov.##T	r3, @r4; \
+	ldc	r1, sr; \
+	rts; \
+	 EXT	r3, r0; \
+	ENDFUNC(GLOBAL(sync_##OP##_and_fetch_##N))
+
+SYNC_OP_AND_FETCH(add,1,b,extu.b)
+SYNC_OP_AND_FETCH(add,2,w,extu.w)
+SYNC_OP_AND_FETCH(add,4,l,mov)
+
+SYNC_OP_AND_FETCH(or,1,b,extu.b)
+SYNC_OP_AND_FETCH(or,2,w,extu.w)
+SYNC_OP_AND_FETCH(or,4,l,mov)
+
+SYNC_OP_AND_FETCH(and,1,b,extu.b)
+SYNC_OP_AND_FETCH(and,2,w,extu.w)
+SYNC_OP_AND_FETCH(and,4,l,mov)
+
+SYNC_OP_AND_FETCH(xor,1,b,extu.b)
+SYNC_OP_AND_FETCH(xor,2,w,extu.w)
+SYNC_OP_AND_FETCH(xor,4,l,mov)
+
+#define SYNC_COMBOP_AND_FETCH(OP,OP0,OP1,N,T,EXT) \
+	.global	GLOBAL(sync_##OP##_and_fetch_##N); \
+	.align	1; \
+GLOBAL(sync_##OP##_and_fetch_##N):; \
+	stc	sr, r1; \
+	mov	r1, r0; \
+	or	#0xf0, r0; \
+	ldc	r0, sr; \
+	mov.##T	@r4, r2; \
+	mov	r5, r3; \
+	OP0	r2, r3; \
+	OP1	r3, r3; \
+	mov.##T	r3, @r4; \
+	ldc	r1, sr; \
+	rts; \
+	EXT	r3, r0; \
+	ENDFUNC(GLOBAL(sync_##OP##_and_fetch_##N))
+
+SYNC_COMBOP_AND_FETCH(sub,sub,neg,1,b,extu.b)
+SYNC_COMBOP_AND_FETCH(sub,sub,neg,2,w,extu.w)
+SYNC_COMBOP_AND_FETCH(sub,sub,neg,4,l,mov)
+
+SYNC_COMBOP_AND_FETCH(nand,and,not,1,b,extu.b)
+SYNC_COMBOP_AND_FETCH(nand,and,not,2,w,extu.w)
+SYNC_COMBOP_AND_FETCH(nand,and,not,4,l,mov)
+
+#endif /* ! __SH5__ */
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/t-generic gcc-st40-4.8.2.140205/libgcc/config/sh/t-generic
--- gcc-gnu-4.8.2/libgcc/config/sh/t-generic	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/t-generic	2013-05-28 13:16:16.000000000 +0200
@@ -0,0 +1,2 @@
+# Provide dummy generic threads functions
+LIB2ADD += $(srcdir)/gthr-generic.c
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/t-linux gcc-st40-4.8.2.140205/libgcc/config/sh/t-linux
--- gcc-gnu-4.8.2/libgcc/config/sh/t-linux	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/t-linux	2013-05-28 13:16:16.000000000 +0200
@@ -1,4 +1,8 @@
-LIB1ASMFUNCS_CACHE = _ic_invalidate _ic_invalidate_array
+# Use a syscall for i-cache flushing so that all SoCs are supported by default
+# In future we will change this to a vsyscall for efficiency
+LIB1ASMFUNCS_CACHE=_ic_invalidate_syscall
+
+LIB1ASMFUNCS_DIVTABLE= _div_table
 
 LIB2ADD = $(srcdir)/config/sh/linux-atomic.c
 
@@ -16,3 +20,6 @@
 	libgcc-std.ver \
 	$(srcdir)/config/sh/libgcc-excl.ver \
 	$(srcdir)/config/sh/libgcc-glibc.ver
+
+
+
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/trap-handler.c gcc-st40-4.8.2.140205/libgcc/config/sh/trap-handler.c
--- gcc-gnu-4.8.2/libgcc/config/sh/trap-handler.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/trap-handler.c	2013-05-28 13:16:16.000000000 +0200
@@ -0,0 +1,10 @@
+extern void exit(int) __attribute__ ((noreturn));
+
+void
+_superh_trap_handler (unsigned int trap_reason)
+{
+  exit(*(int*)0xff000024);  /* return EXPEVT */
+
+  /* in case exit returns ... */
+  while(1);
+}
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/t-sh gcc-st40-4.8.2.140205/libgcc/config/sh/t-sh
--- gcc-gnu-4.8.2/libgcc/config/sh/t-sh	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/t-sh	2013-05-28 13:16:16.000000000 +0200
@@ -16,29 +16,66 @@
 # along with GCC; see the file COPYING3.  If not see
 # <http://www.gnu.org/licenses/>.
 
+# _nesf2f _nedf2f _gtsf2f _gtdf2f _gesf2f _gedf2f: no-finite-math-only optimized
+# versions of _ne_sf _ne_df _gt_sf _gt_df _ge_sf _ge_df
+# _div_table
+# XXX gtdf2f, _gedf2f, gtsf2f, gesf2f,  broken, use fp-bit version.
 LIB1ASMSRC = sh/lib1funcs.S
 LIB1ASMFUNCS = _ashiftrt _ashiftrt_n _ashiftlt _lshiftrt _movmem \
   _movmem_i4 _mulsi3 _sdivsi3 _sdivsi3_i4 _udivsi3 _udivsi3_i4 _set_fpscr \
-  _div_table _udiv_qrnnd_16 \
+  _udiv_qrnnd_16 \
+  _nesf2 _nedf2 \
+  _addsub_sf _mul_sf _addsub_df _mul_df \
+  _hypotf \
+  _sf_to_df _df_to_sf \
+  _fixunssfsi _sf_to_si _usi_to_sf _si_to_sf \
+  _usi_to_df _si_to_df \
+  _div_sf \
+  $(LIB1ASMFUNCS_DIVTABLE) \
   $(LIB1ASMFUNCS_CACHE)
 LIB1ASMFUNCS_CACHE = _ic_invalidate _ic_invalidate_array
 
+# notyet. move above and remove bellow!
+# unord_sf/unord_df
+# _div_df \
+# _df_to_usi \
+# _df_to_si \
+
+FPBIT_FUNCS = _pack_sf _unpack_sf \
+    _fpcmp_parts_sf _compare_sf _eq_sf _gt_sf _ge_sf \
+    _lt_sf _le_sf _unord_sf _negate_sf _make_sf \
+    _sf_to_tf _thenan_sf
+
+DPBIT_FUNCS = _pack_df _unpack_df _div_df \
+    _fpcmp_parts_df _compare_df _eq_df _gt_df _ge_df \
+    _lt_df _le_df _unord_df _negate_df _make_df \
+    _df_to_tf _thenan_df _df_to_usi _df_to_si
+
 crt1.o: $(srcdir)/config/sh/crt1.S
 	$(gcc_compile) -c $<
 
+ic_invalidate_array.o: $(srcdir)/config/sh/lib1funcs.S
+	$(gcc_compile) -c -DL_ic_invalidate_array $<
+ic_invalidate.o: $(srcdir)/config/sh/lib1funcs.S
+	$(gcc_compile) -c -DL_ic_invalidate $<
+libic_invalidate.a: ic_invalidate_array.o ic_invalidate.o
+	$(AR_CREATE_FOR_TARGET) $@ $<
+
 ic_invalidate_array_4-100.o: $(srcdir)/config/sh/lib1funcs.S
 	$(gcc_compile) -c -DL_ic_invalidate_array -DWAYS=1 -DWAY_SIZE=0x2000 $<
-libic_invalidate_array_4-100.a: ic_invalidate_array_4-100.o
+libic_invalidate_4-100.a: ic_invalidate_array_4-100.o ic_invalidate.o
 	$(AR_CREATE_FOR_TARGET) $@ $<
 
 ic_invalidate_array_4-200.o: $(srcdir)/config/sh/lib1funcs.S
 	$(gcc_compile) -c -DL_ic_invalidate_array -DWAYS=2 -DWAY_SIZE=0x2000 $<
-libic_invalidate_array_4-200.a: ic_invalidate_array_4-200.o
+libic_invalidate_4-200.a: ic_invalidate_array_4-200.o ic_invalidate.o
 	$(AR_CREATE_FOR_TARGET) $@ $<
 
+ic_invalidate_4a.o: $(srcdir)/config/sh/lib1funcs.S
+	$(gcc_compile) -c -DL_ic_invalidate -D__FORCE_SH4A__ -Wa,-isa=st40-300 $<
 ic_invalidate_array_4a.o: $(srcdir)/config/sh/lib1funcs.S
 	$(gcc_compile) -c -DL_ic_invalidate_array -D__FORCE_SH4A__ $<
-libic_invalidate_array_4a.a: ic_invalidate_array_4a.o
+libic_invalidate_4a.a: ic_invalidate_array_4a.o ic_invalidate_4a.o
 	$(AR_CREATE_FOR_TARGET) $@ $<
 
 sdivsi3_i4i-Os-4-200.o: $(srcdir)/config/sh/lib1funcs-Os-4-200.S
@@ -52,9 +89,16 @@
 libgcc-Os-4-200.a: $(OBJS_Os_4_200)
 	$(AR_CREATE_FOR_TARGET) $@ $(OBJS_Os_4_200)
 
+div_table-4-200.o: $(srcdir)/config/sh/lib1funcs.S
+	$(gcc_compile) -c -DL_div_table $<
+
+libgcc-4-200.a: div_table-4-200.o $(GCC_PASSES)
+	$(AR_CREATE_FOR_TARGET) $@ div_table-4-200.o
+
 div_table-4-300.o: $(srcdir)/config/sh/lib1funcs-4-300.S
 	$(gcc_compile) -c -DL_div_table $<
 
 libgcc-4-300.a: div_table-4-300.o
 	$(AR_CREATE_FOR_TARGET) $@ div_table-4-300.o
 
+
diff -ruN gcc-gnu-4.8.2/libgcc/config/sh/t-superh gcc-st40-4.8.2.140205/libgcc/config/sh/t-superh
--- gcc-gnu-4.8.2/libgcc/config/sh/t-superh	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/libgcc/config/sh/t-superh	2013-05-28 13:16:16.000000000 +0200
@@ -1,3 +1,5 @@
+LIB2ADD = $(srcdir)/config/sh/supervisor-atomic.S $(srcdir)/config/sh/supervisor-sync.S
+
 # Compile crt1-mmu.o as crt1.o with -DMMU_SUPPORT
 crt1-mmu.o: $(srcdir)/config/sh/crt1.S
 	$(gcc_compile) -c -DMMU_SUPPORT $<
@@ -9,3 +11,6 @@
 # For sh4-400: Compile gcrt1.o as crt1.o with -DPROFILE
 gcrt1.o: $(srcdir)/config/sh/crt1.S
 	$(gcc_compile) -c -DPROFILE $<
+
+trap-handler.o: $(srcdir)/config/sh/trap-handler.c
+	$(gcc_compile) $(MULTILIB_CFLAGS) -c $<
diff -ruN gcc-gnu-4.8.2/libgcc/config.host gcc-st40-4.8.2.140205/libgcc/config.host
--- gcc-gnu-4.8.2/libgcc/config.host	2013-10-16 16:17:23.000000000 +0200
+++ gcc-st40-4.8.2.140205/libgcc/config.host	2013-10-17 12:15:29.000000000 +0200
@@ -928,10 +928,11 @@
 sh-*-elf* | sh[12346l]*-*-elf*)
 	tmake_file="$tmake_file sh/t-sh t-crtstuff-pic t-fdpbit"
 	extra_parts="$extra_parts crt1.o crti.o crtn.o crtbeginS.o crtendS.o \
-		libic_invalidate_array_4-100.a \
-		libic_invalidate_array_4-200.a \
-		libic_invalidate_array_4a.a \
-		libgcc-Os-4-200.a libgcc-4-300.a"
+		libic_invalidate_4-100.a \
+		libic_invalidate_4-200.a \
+		libic_invalidate_4a.a \
+		libic_invalidate.a \
+		libgcc-4-200.a libgcc-Os-4-200.a libgcc-4-300.a"
 	case ${host} in sh64*-*-*)
 		tmake_file="$tmake_file sh/t-sh64"
 		;;
@@ -940,11 +941,13 @@
 	sh*-superh-elf)
 		tmake_file="$tmake_file sh/t-superh"
 		extra_parts="$extra_parts crt1-mmu.o gcrt1-mmu.o gcrt1.o"
+		extra_parts="$extra_parts trap-handler.o"
  		;;
  	esac
 	;;
 sh-*-linux* | sh[2346lbe]*-*-linux*)
 	tmake_file="${tmake_file} sh/t-sh t-slibgcc-libgcc sh/t-linux t-fdpbit"
+	extra_parts="$extra_parts libgcc-4-200.a libgcc-Os-4-200.a libgcc-4-300.a"
 	case ${host} in sh64*-*-linux*)
 		tmake_file="$tmake_file sh/t-sh64"
 		;;
diff -ruN gcc-gnu-4.8.2/libgcc/longlong.h gcc-st40-4.8.2.140205/libgcc/longlong.h
--- gcc-gnu-4.8.2/libgcc/longlong.h	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/libgcc/longlong.h	2013-05-28 13:16:16.000000000 +0200
@@ -1,5 +1,6 @@
 /* longlong.h -- definitions for mixed size 32/64 bit arithmetic.
    Copyright (C) 1991-2013 Free Software Foundation, Inc.
+   Copyright (c) 2013  STMicroelectronics.
 
    This file is part of the GNU C Library.
 
@@ -1051,12 +1052,36 @@
 /* This is the same algorithm as __udiv_qrnnd_c.  */
 #define UDIV_NEEDS_NORMALIZATION 1
 
+#ifdef	DB_ST40300_BUG_WORKAROUND
 #define udiv_qrnnd(q, r, n1, n0, d) \
   do {									\
     extern UWtype __udiv_qrnnd_16 (UWtype, UWtype)			\
 			__attribute__ ((visibility ("hidden")));	\
     /* r0: rn r1: qn */ /* r0: n1 r4: n0 r5: d r6: d1 */ /* r2: __m */	\
     __asm__ (								\
+"	.align	2\n"                                                    \
+"       mov%M4 %4,r5\n"						        \
+"	swap.w %3,r4\n"							\
+"	swap.w r5,r6\n"							\
+"       nop\n"                                                          \
+"	jsr @%5\n"							\
+"	shll16 r6\n"							\
+"	swap.w r4,r4\n"							\
+"       nop\n"                                                          \
+"	jsr @%5\n"							\
+"	swap.w r1,%0\n"							\
+"	or r1,%0"							\
+	: "=r" (q), "=&z" (r)						\
+	: "1" (n1), "r" (n0), "rm" (d), "r" (&__udiv_qrnnd_16)		\
+        : "r1", "r2", "r4", "r5", "r6", "pr", "t");			\
+  } while (0)
+#else
+#define udiv_qrnnd(q, r, n1, n0, d) \
+  do {									\
+    extern UWtype __udiv_qrnnd_16 (UWtype, UWtype)			\
+                        __attribute__ ((visibility ("hidden")));	\
+    /* r0: rn r1: qn */ /* r0: n1 r4: n0 r5: d r6: d1 */ /* r2: __m */	\
+    __asm__ (								\
 	"mov%M4 %4,r5\n"						\
 "	swap.w %3,r4\n"							\
 "	swap.w r5,r6\n"							\
@@ -1070,6 +1095,7 @@
 	: "1" (n1), "r" (n0), "rm" (d), "r" (&__udiv_qrnnd_16)		\
 	: "r1", "r2", "r4", "r5", "r6", "pr", "t");			\
   } while (0)
+#endif
 
 #define UDIV_TIME 80
 
diff -ruN gcc-gnu-4.8.2/libiberty/ChangeLog.STM gcc-st40-4.8.2.140205/libiberty/ChangeLog.STM
--- gcc-gnu-4.8.2/libiberty/ChangeLog.STM	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libiberty/ChangeLog.STM	2013-05-28 13:17:15.000000000 +0200
@@ -0,0 +1,25 @@
+2010-04-12  Christian Bruel  <christian.bruel@st.com>
+
+	* wrap_file.c: Fix prototypes.
+	Remove rename wrapper.
+	* cygpath.c: Shut-up warnings.
+
+2009-12-07  Yvan Roux  <yvan.roux@st.com>
+
+	* wrap_file.c: New file.
+	* Makefile.in: Add wrap_file.[co].
+	* config/mh-mingw: Add wrap_file.o.
+
+2006-05-15  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* cygpath.c (cygpath): Convert pathnames consisting only of a
+	drive specifier to a valid directory (e.g 'c:' -> 'c:/').
+
+2006-03-27  Andrew Stubbs  <andrew.stubbs@st.com>
+
+libiberty/
+	* cygpath.c: New file.
+	* config/mh-mingw: New file.
+	* configure.ac: Add mh-mingw makefile fragment when host is MinGW.
+	* configure: Regenerate.
+	* Makefile.in: Add cygpath.[co] .
diff -ruN gcc-gnu-4.8.2/libiberty/config/mh-mingw gcc-st40-4.8.2.140205/libiberty/config/mh-mingw
--- gcc-gnu-4.8.2/libiberty/config/mh-mingw	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libiberty/config/mh-mingw	2013-05-28 13:17:15.000000000 +0200
@@ -0,0 +1 @@
+EXTRA_OFILES=cygpath.o wrap_file.o
diff -ruN gcc-gnu-4.8.2/libiberty/configure gcc-st40-4.8.2.140205/libiberty/configure
--- gcc-gnu-4.8.2/libiberty/configure	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/libiberty/configure	2013-05-28 13:17:15.000000000 +0200
@@ -4842,6 +4842,7 @@
   *-*-freebsd2.2.[012])	frag=mh-fbsd21 ;;
   i370-*-opened*)       frag=mh-openedition ;;
   i[34567]86-*-windows*)	frag=mh-windows ;;
+  *-*-mingw*)		frag=mh-mingw ;;
 esac
 
 if [ -n "${frag}" ]; then
diff -ruN gcc-gnu-4.8.2/libiberty/configure.ac gcc-st40-4.8.2.140205/libiberty/configure.ac
--- gcc-gnu-4.8.2/libiberty/configure.ac	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/libiberty/configure.ac	2013-05-28 13:17:15.000000000 +0200
@@ -185,6 +185,7 @@
   *-*-freebsd2.2.[[012]])	frag=mh-fbsd21 ;;
   i370-*-opened*)       frag=mh-openedition ;;
   i[[34567]]86-*-windows*)	frag=mh-windows ;;
+  *-*-mingw*)		frag=mh-mingw ;;
 esac
 
 if [[ -n "${frag}" ]]; then
diff -ruN gcc-gnu-4.8.2/libiberty/cygpath.c gcc-st40-4.8.2.140205/libiberty/cygpath.c
--- gcc-gnu-4.8.2/libiberty/cygpath.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libiberty/cygpath.c	2013-05-28 13:17:15.000000000 +0200
@@ -0,0 +1,358 @@
+/* Basic Cygwin pathname support for MinGW.
+
+   Copyright (C) 2006 STMicroelectronics
+
+   This file is part of the libiberty library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor,
+   Boston, MA 02110-1301, USA.
+
+
+   This file implements a limited amount of support for Cygwin paths.
+   It is intended for use by MinGW programs that must interact with Cygwin.
+
+   It is limited to absolute paths only.  I.e. Those beginning with Cygwin
+   mounts, such as /cygdrive/...  See the comment on cygpath() below.  */
+
+#include "libiberty.h"
+#include <string.h>
+#include <ctype.h>
+#include <windows.h>
+
+
+/* These are all the possible settings for the ST_CYGPATH_MODE
+   environment variable.  */
+static enum
+{
+  mode_unset,
+  mode_off,
+  mode_normal,
+  mode_full
+} mode = mode_unset;
+
+
+/* These are the values extracted from the registry.
+   They are extracted the first time cygpath is called.  */
+static const char *cygdrive = NULL;
+static struct mount
+{
+  /* The name of the Cygwin mount point.  E.g. "/usr/bin"  */
+  char *mount;
+
+  /* The actual Windows path that the mount translates to.  */
+  char *actual;
+
+  struct mount *next;
+} *mounts = NULL;
+
+
+/* Read a string from the Windows Registry.
+   KEY should be a valid handle from RegOpenKeyEx().
+   NAME should be the name of the value within the key.
+   The value should be of type REG_SZ.
+   If the value does not exist, is of the wrong typei, or another error
+   occurs, then NULL is returned.
+   Otherwise a malloced string is returned.  */
+static char *
+read_string_from_registry (HKEY key, const char *name)
+{
+  DWORD valuetype = REG_NONE;
+  DWORD valuesize = 0;
+  char *value = NULL;
+
+  if (RegQueryValueEx (key, name, NULL, &valuetype,
+		       NULL, &valuesize) == ERROR_SUCCESS
+      && valuetype == REG_SZ)
+    {
+      value = (char *)xmalloc (valuesize);
+      if (RegQueryValueEx (key, name, NULL, &valuetype, (unsigned char *)value,
+			   &valuesize) != ERROR_SUCCESS)
+	{
+	  free (value);
+	  value = NULL;
+	}
+    }
+
+  return value;
+}
+
+
+/* Fill in the mounts list (mounts is defined statically above).
+   All subkeys (not values) of KEY that contain a REG_SZ value named 'native'
+   are added to the start of the mounts list.  */
+static void
+read_mounts (HKEY key)
+{
+  int mountsize = 15;
+  char *mount = (char *)xmalloc (mountsize);
+  DWORD size = mountsize;
+  int index = 0;
+  int retval = 0;
+
+  /* For each subkey ...  */
+  while ((retval = RegEnumKeyEx (key, index, mount, &size, 0, NULL, 0, NULL))
+	 != ERROR_NO_MORE_ITEMS)
+    {
+      struct mount *newmount;
+      HKEY subkey;
+      char *actual;
+
+      switch (retval) {
+      case ERROR_MORE_DATA:
+	/* The buffer wasn't large enough for this key name.
+	   Unlike RegQueryValueEx, RegEnumKeyEx won't tell us how big it
+	   should be, so just make it bigger and try again.
+	   Note that this code path does NOT increment index.
+       	   Most of the time we will only be dealing with short strings.  */
+	mountsize += 10;
+	mount = (char *)xrealloc (mount, mountsize);
+	break;
+
+      case ERROR_SUCCESS:
+	/* Find the actual windows path.  */
+  	if (RegOpenKeyEx (key, mount, 0, KEY_READ, &subkey) != ERROR_SUCCESS)
+	  {
+	    index++;
+	    break;
+	  }
+	actual = read_string_from_registry (subkey, "native");	
+	RegCloseKey (subkey);
+	if (actual == NULL)
+	  {
+	    index++;
+	    break;
+	  }
+
+	/* Create the new entry in the mount table.  */
+	newmount = (struct mount *)xmalloc (sizeof (struct mount));
+	newmount->mount = xstrdup (mount);
+	newmount->actual = actual;
+	newmount->next = mounts;
+	mounts = newmount;
+	index++;
+	break;
+
+      default:
+	/* Don't infinite loop should any other return value occur.  */
+        index++;
+      }
+
+      /* The last call to RegEnumKeyEx may have clobbered size.
+         Fix it before the next call.  */
+      size = mountsize;
+    }
+
+  free (mount);
+}
+
+
+/* The top level registry reading function.
+   Open the keys, call the above functions to get the right values,
+   and clean up.  */
+static void
+read_registry (void)
+{
+  HKEY hcu_key, hlm_key;
+
+  /* Get key handles for the two places cygwin keeps its registry data.  */
+  if (RegOpenKeyEx (HKEY_CURRENT_USER,
+		    "Software\\Cygnus Solutions\\Cygwin\\mounts v2",
+		    0, KEY_READ, &hcu_key) != ERROR_SUCCESS)
+    hcu_key = NULL;
+
+  if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
+		    "SOFTWARE\\Cygnus Solutions\\Cygwin\\mounts v2",
+		    0, KEY_READ, &hlm_key) != ERROR_SUCCESS)
+    hlm_key = NULL;
+
+  /* Get the virtual mount point used for windows drives.  */
+  if (hcu_key)
+    cygdrive = read_string_from_registry (hcu_key, "cygdrive prefix");
+  if (hlm_key && cygdrive == NULL)
+    cygdrive = read_string_from_registry (hlm_key, "cygdrive prefix");
+
+  /* Read the other mount points.
+     Read hlm before hcu to ensure hcu settings get used by preference
+     by being closer on the mounts stack.  */
+  if (hlm_key)
+    read_mounts (hlm_key);
+  if (hcu_key)
+    read_mounts (hcu_key);
+
+  if (hlm_key)
+    RegCloseKey (hlm_key);
+  if (hcu_key)
+    RegCloseKey (hcu_key);
+}
+
+
+/* Given a path of unknown variety, return the same path with any
+   Cygwin mount points substituted.
+   This function always returns a malloced string which should be
+   freed when the the caller is finished with it.
+
+   The mapping is affected by the ST_CYGPATH_MODE environment variable.
+   See the fprintf messages below for full information.
+
+   It can replace /cygdrive/<letter>/..... style pathnames, even if the
+   user has used 'mount -c' to an alternative string.
+
+   It can replace (if enabled) other Cygwin mount points, such as
+   the usual '/', '/usr/bin', '/usr/lib', as well as any other user defined
+   mount points.
+
+   It does NOT attempt to convert any pathnames that look like native Windows
+   names - such as those starting with '<letter>:' or double slash (UNC).
+
+   It does NOT handle relative pathnames passing through cygwin mounts
+   (e.g. '../cygdrive/c'), or absolute paths with repeated directory
+   separators or relative elements within the mount name
+   (e.g. '/usr/./bin').
+   
+   It does NOT allow backslash \ directory separators within the actual mount
+   path (e.g. '/usr\bin').  Cygwin does not always allow them there either.  */
+char *
+cygpath (const char *path)
+{
+  char *result = NULL;
+
+  if (path == NULL)
+    return NULL;
+
+  /* If this is the first time this function has been called then read the
+     environment and registry.  */
+  if (mode == mode_unset)
+    {
+      char *env = getenv ("ST_CYGPATH_MODE");
+
+      if (env == NULL || strcmp (env, "normal") == 0)
+    	mode = mode_normal;
+      else if (strcmp (env, "full") == 0)
+	mode = mode_full;
+      else if (strcmp (env, "off") == 0)
+	mode = mode_off;
+
+      if (mode != mode_off)
+	read_registry();
+
+      if (mode == mode_unset)
+	{
+	  /* The variable was set, but not to any known value.
+	     Set up a default and print an informational message
+	     for the user.  */
+	  mode = mode_normal;
+	  fprintf (stderr, "ST_CYGPATH_MODE should be one of:\n");
+	  fprintf (stderr, " off    - Disable all path translation.\n");
+	  fprintf (stderr, " normal - Translate %s only.\n", cygdrive);
+	  fprintf (stderr, " full   - Translate all Cygwin mounts.\n");
+	}
+    }
+
+  /* First, test if this can only be a windows (non-cygwin) path.
+     This includes paths that start with a drive letter or UNC double slash.  */
+  if ((isalpha (path[0]) && path[1] == ':')
+      || ((path[0] == '\\' || path[0] == '/')
+	  && (path[1] == '\\' || path[1] == '/')))
+    result = xstrdup (path);
+
+  /* Second, handle /cygdrive/<letter>/ (or whatever) paths.  */
+  if (!result && cygdrive != NULL && (mode == mode_normal || mode == mode_full))
+    {
+      int length = strlen (cygdrive);
+      /* Note that cygwin does not allow '\\' instead of '/' in cygdrive.  */
+      if (strncmp (cygdrive, path, length) == 0
+	  && (path[length] == '/' || path[length] == '\\'
+	      || path[length] == '\0')
+	  && isalpha (path[length+1]))
+        {
+	  result = (char *)xmalloc (strlen (path) - length+1 + 1);
+	  result[0] = path[length+1];
+	  result[1] = ':';
+	  strcpy (result + 2, path + length + 2);
+	}
+    }
+
+  /* Third, handle other types of cygwin path.  */
+  if (!result && mounts != NULL && mode == mode_full)
+    {
+      int matched = 0;
+      struct mount *foundat = NULL;
+      struct mount *mount = mounts;
+      /* Find the longest matching mount point.
+	 This is important. If we just used the first matching mount point
+	 it would probably always match '/' when '/usr/bin' is right.
+	 Use the first of equal length matches - this allows current-user
+	 mounts to override 'local machine' mounts (can this happen?).
+         It is a match only if the matching part is followed by a directory
+         separator or the end of the path, except for the root mount point.  */
+      while (mount != NULL)
+	{
+	  int length = strlen (mount->mount);
+	  if (strncmp (mount->mount, path, length) == 0
+	      && matched < length
+	      && (length == 1 /* Special case for root mount point '/'.  */
+		  || path[length] == '/' || path[length] == '\\'
+		  || path[length] == '\0'))
+	    {
+	      matched = length;
+	      foundat = mount;
+	    }
+	  mount = mount->next;
+	}
+      if (matched)
+	{
+	  /* There was a match so do the substitution.
+	     If matched is 1 then it can only be the root mount point, in
+	     which case we do not want to remove the matched part as it is the 
+	     directory separator.  */
+	  if (matched == 1)
+	    matched = 0;
+	  result = (char *)xmalloc (strlen (foundat->actual) + strlen (path) + 1
+			    - matched);
+	  strcpy (result, foundat->actual);
+	  strcat (result, path + matched);
+	}
+    }
+
+  if (result)
+    {
+      /* Ensure that the return is never just a drive letter.
+	 This is not a valid directory on Windows, but code often
+	 trims trailing slashes.  */
+      int length = strlen(result);
+      if (result[length-1] == ':')
+	{
+	  result = (char *)xrealloc (result, length+2);
+	  result[length] = '/';
+	  result[length+1] = '\0';
+	}
+      return result;
+    }
+
+  /* If we get here then it must have been some other kind of path.  */
+  return xstrdup (path);
+}
+
+
+/* This is just to make inserting the conversion more convenient.
+   The CYGPATH_REPLACE is conditionally compiled so it is harder to
+   add clean up code to go with it without this.  */
+void
+cygpath_replace (char **path)
+{
+  char *result = cygpath (*path);
+  free (*path);
+  *path = result;
+}
diff -ruN gcc-gnu-4.8.2/libiberty/Makefile.in gcc-st40-4.8.2.140205/libiberty/Makefile.in
--- gcc-gnu-4.8.2/libiberty/Makefile.in	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/libiberty/Makefile.in	2013-05-28 13:17:15.000000000 +0200
@@ -125,7 +125,7 @@
 CFILES = alloca.c argv.c asprintf.c atexit.c				\
 	basename.c bcmp.c bcopy.c bsearch.c bzero.c			\
 	calloc.c choose-temp.c clock.c concat.c cp-demangle.c		\
-	 cp-demint.c cplus-dem.c crc32.c				\
+	 cp-demint.c cplus-dem.c crc32.c cygpath.c			\
 	dwarfnames.c dyn-string.c					\
 	fdmatch.c ffs.c fibheap.c filename_cmp.c floatformat.c		\
 	fnmatch.c fopen_unlocked.c					\
@@ -155,7 +155,7 @@
 	timeval-utils.c tmpnam.c					\
 	unlink-if-ordinary.c						\
 	vasprintf.c vfork.c vfprintf.c vprintf.c vsnprintf.c vsprintf.c	\
-	waitpid.c							\
+	waitpid.c wrap_file.c						\
 	xatexit.c xexit.c xmalloc.c xmemdup.c xstrdup.c xstrerror.c	\
 	 xstrndup.c
 
@@ -199,7 +199,7 @@
 	./basename.$(objext) ./bcmp.$(objext) ./bcopy.$(objext)		\
 	./bsearch.$(objext) ./bzero.$(objext)				\
 	./calloc.$(objext) ./clock.$(objext) ./copysign.$(objext)	\
-	./_doprnt.$(objext)						\
+	./cygpath.$(object) ./_doprnt.$(objext)				\
 	 ./ffs.$(objext)						\
 	./getcwd.$(objext) ./getpagesize.$(objext)			\
 	 ./gettimeofday.$(objext)					\
@@ -222,7 +222,7 @@
 	./tmpnam.$(objext)						\
 	./vasprintf.$(objext) ./vfork.$(objext) ./vfprintf.$(objext)	\
 	 ./vprintf.$(objext) ./vsnprintf.$(objext) ./vsprintf.$(objext)	\
-	./waitpid.$(objext)
+	./waitpid.$(objext) ./wrap_file.$(object)
 
 # These files are installed if the library has been configured to do so.
 INSTALLED_HEADERS =                                                     \
@@ -637,6 +637,13 @@
 	else true; fi
 	$(COMPILE.c) $(srcdir)/dyn-string.c $(OUTPUT_OPTION)
 
+./cygpath.$(objext): $(srcdir)/cygpath.c $(INCDIR)/ansidecl.h \
+	 $(INCDIR)/libiberty.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/cygpath.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/cygpath.c $(OUTPUT_OPTION)
+
 ./fdmatch.$(objext): $(srcdir)/fdmatch.c config.h $(INCDIR)/ansidecl.h \
 	$(INCDIR)/libiberty.h
 	if [ x"$(PICFLAG)" != x ]; then \
@@ -1230,6 +1237,13 @@
 	else true; fi
 	$(COMPILE.c) $(srcdir)/waitpid.c $(OUTPUT_OPTION)
 
+./wrap_file.$(objext): $(srcdir)/wrap_file.c config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/libiberty.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/wrap_file.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/wrap_file.c $(OUTPUT_OPTION)
+
 ./xatexit.$(objext): $(srcdir)/xatexit.c config.h $(INCDIR)/ansidecl.h \
 	$(INCDIR)/libiberty.h
 	if [ x"$(PICFLAG)" != x ]; then \
diff -ruN gcc-gnu-4.8.2/libiberty/wrap_file.c gcc-st40-4.8.2.140205/libiberty/wrap_file.c
--- gcc-gnu-4.8.2/libiberty/wrap_file.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libiberty/wrap_file.c	2013-05-28 13:17:15.000000000 +0200
@@ -0,0 +1,138 @@
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2009
+*/
+/*
+ * wrap_fopen.c
+ *
+ * This file redefines the standard library functions 
+ * open, create, fopen, fdopen, freopen, remove, rename, unlink, stat for native WIN32 build.
+ * Its purpose is to preprocess argument strings in order to
+ * convert CYGWIN like paths specifiers into native WIN32 paths
+ * It uses the GNU ld -wrap functionality to replace
+ * at link time calls to fopen into calls to __wrap_fopen.
+ *
+ * This file must be linked with any DLL or EXE object
+ * and the linker command line must have the following  option:
+ * -Wl,-wrap,open,-wrap,creat,-wrap,fopen,-wrap,freopen,-wrap,remove,-wrap,rename,-wrap,unlink,-wrap,stat
+ *
+ */
+
+#ifdef __MINGW32__
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <dirent.h>
+#include <unistd.h>
+
+#include "libiberty.h"
+
+/*
+ * Declare real versions of functions.
+ */
+extern int __real_open (const char *pathname, int flags, mode_t mode);
+extern int __real_creat (const char *pathname, mode_t mode);
+extern FILE *__real_fopen (const char *path, const char *mode);
+extern FILE *__real_freopen (const char *path, const char *mode, FILE *stream);
+extern int __real_unlink (const char *pathname);
+extern int __real_remove (const char *pathname);
+extern int __real_stat (const char *file_name, struct stat *buf);
+extern int __real_chdir (const char *path);
+extern int __real_rmdir (const char *pathname); 
+extern DIR *__real_opendir (const char *name);
+extern int __real_access (const char *pathname, int mode);
+
+/*
+ * Following is the implementation of replacement functions.
+ */
+int 
+__wrap_open (const char *pathname, int flags, mode_t mode)
+{
+  int r;
+  char *path = cygpath (pathname);
+  r = __real_open (path, flags, mode);
+  return r;
+}
+
+int 
+__wrap_creat (const char *pathname, mode_t mode)
+{
+  int r;
+  char *path = cygpath (pathname);
+  r = __real_creat (path, mode);
+  return r;
+}
+
+FILE *
+__wrap_fopen (const char *pathname, const char *mode)
+{
+  FILE *f;
+  char *path = cygpath (pathname);
+  f = __real_fopen (path, mode);
+  return f;
+}
+
+FILE *__wrap_freopen (const char *pathname, const char *mode, FILE *stream)
+{
+  FILE *f;
+  char *path = cygpath (pathname);
+  f = __real_freopen (path, mode, stream);
+  return f;
+}
+
+int __wrap_unlink (const char *pathname) 
+{
+  int r;
+  char *path = cygpath (pathname);
+  r = __real_unlink (path);
+  return r;
+}
+
+int __wrap_remove (const char *pathname)
+{
+  int r;
+  char *path = cygpath (pathname);
+  r = __real_remove (path);
+  return r;
+}
+
+int __wrap_stat(const char *pathname, struct stat *buf)
+{
+  int r;
+  char *path = cygpath (pathname);
+  r = __real_stat (path, buf);
+  return r;
+}
+
+int __wrap_chdir(const char *pathname)
+{
+  int r;
+  char *path = cygpath (pathname);
+  r = __real_chdir (path);
+  return r;
+}
+
+int __wrap_rmdir(const char *pathname)
+{
+  int r;
+  char *path = cygpath (pathname);
+  r = __real_rmdir (path);
+  return r;
+}
+
+DIR *__wrap_opendir(const char *pathname)
+{
+  DIR *d;
+  char *path = cygpath (pathname);
+  d = __real_opendir (path);
+  return d;
+}
+
+int __wrap_access(const char *pathname, int mode)
+{
+  int r; 
+  char *path = cygpath (pathname);
+  r = __real_access (path, mode);
+  return r;
+}
+
+#endif /* __MINGW32__ */
diff -ruN gcc-gnu-4.8.2/libmudflap/Makefile.am gcc-st40-4.8.2.140205/libmudflap/Makefile.am
--- gcc-gnu-4.8.2/libmudflap/Makefile.am	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/libmudflap/Makefile.am	2013-10-18 14:08:52.000000000 +0200
@@ -12,7 +12,7 @@
 gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)
 
 SECTION_FLAGS = @SECTION_FLAGS@
-AM_CFLAGS = -Wall $(SECTION_FLAGS)
+AM_CFLAGS = -Wall -funwind-tables $(SECTION_FLAGS)
 
 if LIBMUDFLAPTH
 libmudflapth = libmudflapth.la
@@ -42,7 +42,7 @@
 	mf-hooks1.c \
 	mf-hooks2.c \
 	mf-hooks3.c
-libmudflapth_la_CFLAGS = -DLIBMUDFLAPTH
+libmudflapth_la_CFLAGS = -DLIBMUDFLAPTH $(AM_CFLAGS)
 libmudflapth_la_LIBADD =
 libmudflapth_la_DEPENDENCIES = $(libmudflapth_la_LIBADD)
 libmudflapth_la_LDFLAGS = -version-info `grep -v '^\#' $(srcdir)/libtool-version`
diff -ruN gcc-gnu-4.8.2/libmudflap/Makefile.in gcc-st40-4.8.2.140205/libmudflap/Makefile.in
--- gcc-gnu-4.8.2/libmudflap/Makefile.in	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/libmudflap/Makefile.in	2013-10-18 14:08:52.000000000 +0200
@@ -265,7 +265,7 @@
 
 # May be used by various substitution variables.
 gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)
-AM_CFLAGS = -Wall $(SECTION_FLAGS)
+AM_CFLAGS = -Wall -funwind-tables $(SECTION_FLAGS)
 @LIBMUDFLAPTH_FALSE@libmudflapth = 
 @LIBMUDFLAPTH_TRUE@libmudflapth = libmudflapth.la
 toolexeclib_LTLIBRARIES = libmudflap.la $(libmudflapth)
@@ -287,7 +287,7 @@
 	mf-hooks2.c \
 	mf-hooks3.c
 
-libmudflapth_la_CFLAGS = -DLIBMUDFLAPTH
+libmudflapth_la_CFLAGS = -DLIBMUDFLAPTH $(AM_CFLAGS)
 libmudflapth_la_LIBADD = 
 libmudflapth_la_DEPENDENCIES = $(libmudflapth_la_LIBADD)
 libmudflapth_la_LDFLAGS = -version-info `grep -v '^\#' $(srcdir)/libtool-version`
diff -ruN gcc-gnu-4.8.2/libmudflap/mf-hooks1.c gcc-st40-4.8.2.140205/libmudflap/mf-hooks1.c
--- gcc-gnu-4.8.2/libmudflap/mf-hooks1.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/libmudflap/mf-hooks1.c	2013-10-18 14:08:52.000000000 +0200
@@ -54,6 +54,7 @@
 #include <errno.h>
 #include <limits.h>
 #include <time.h>
+#include <sys/mman.h>
 
 #include "mf-runtime.h"
 #include "mf-impl.h"
@@ -350,8 +351,19 @@
 		 (uintptr_t) result);
   */
 
-  if (result != (void *)-1)
+  if (result == (void *)-1)
     {
+      TRACE("mmap failed\n");
+      return result;
+    }
+  else
+    {
+      if (!__mf_opts.register_anon_mmaps && (flags & MAP_ANONYMOUS))
+        {
+	  TRACE("Not registering anonymous mmap at %p\n", result);
+	  return result;
+        }
+
       /* Register each page as a heap object.  Why not register it all
 	 as a single segment?  That's so that a later munmap() call
 	 can unmap individual pages.  XXX: would __MF_TYPE_GUESS make
diff -ruN gcc-gnu-4.8.2/libmudflap/mf-hooks2.c gcc-st40-4.8.2.140205/libmudflap/mf-hooks2.c
--- gcc-gnu-4.8.2/libmudflap/mf-hooks2.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/libmudflap/mf-hooks2.c	2013-10-18 14:08:52.000000000 +0200
@@ -1139,10 +1139,13 @@
 
 WRAPPER2(int, fflush, FILE *stream)
 {
+  if (!__mf_opts.ignore_fflush)
+    {
   TRACE ("%s\n", __PRETTY_FUNCTION__);
   if (stream != NULL)
     MF_VALIDATE_EXTENT (stream, sizeof (*stream), __MF_CHECK_WRITE,
                         "fflush stream");
+    }
   return fflush (stream);
 }
 
diff -ruN gcc-gnu-4.8.2/libmudflap/mf-impl.h gcc-st40-4.8.2.140205/libmudflap/mf-impl.h
--- gcc-gnu-4.8.2/libmudflap/mf-impl.h	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/libmudflap/mf-impl.h	2013-10-18 14:08:52.000000000 +0200
@@ -169,10 +169,11 @@
   /* Collect register/unregister timestamps.  */
   unsigned timestamps;
 
-#ifdef LIBMUDFLAPTH
-  /* Thread stack size.  */
-  unsigned thread_stack;
-#endif
+  /* Register anonymous mmaps */
+  unsigned register_anon_mmaps;
+
+  /* Don't check calls to fflush even if mode_check is in effrt. */
+  unsigned ignore_fflush;
 
   /* Major operation mode */
 #define mode_nop 0      /* Do nothing.  */
diff -ruN gcc-gnu-4.8.2/libmudflap/mf-runtime.c gcc-st40-4.8.2.140205/libmudflap/mf-runtime.c
--- gcc-gnu-4.8.2/libmudflap/mf-runtime.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/libmudflap/mf-runtime.c	2013-10-18 14:08:52.000000000 +0200
@@ -299,9 +299,6 @@
   __mf_opts.call_libc_freeres = 1;
 #endif
   __mf_opts.heur_std_data = 1;
-#ifdef LIBMUDFLAPTH
-  __mf_opts.thread_stack = 0;
-#endif
 
   /* PR41443: Beware that the above flags will be applied to
      setuid/setgid binaries, and cannot be overriden with
@@ -432,11 +429,12 @@
     {"backtrace",
      "keep an N-level stack trace of each call context",
      read_integer_option, 0, &__mf_opts.backtrace},
-#ifdef LIBMUDFLAPTH
-    {"thread-stack",
-     "override thread stacks allocation: N kB",
-     read_integer_option, 0, &__mf_opts.thread_stack},
-#endif
+     {"register-anon-mmaps",
+      "anonymous mmaps are registered as valid memory objects",
+      set_option, 1, &__mf_opts.register_anon_mmaps},
+    {"ignore-fflush",
+     "ignore fflush calls - assume okay",
+     set_option, 1, &__mf_opts.ignore_fflush},
     {0, 0, set_option, 0, NULL}
   };
 
@@ -808,6 +806,8 @@
 #else
   return __real_main (argc, argv, environ);
 #endif
+  __mf_opts.register_anon_mmaps = 0;
+  __mf_opts.ignore_fflush = 0;
 }
 
 
@@ -1800,7 +1800,7 @@
   if (__mf_opts.backtrace > 0)
   {
     unsigned i;
-    for (i=0; i<obj->alloc_backtrace_size; i++)
+    for (i=2; i<obj->alloc_backtrace_size; i++)
       fprintf (stderr, "      %s\n", obj->alloc_backtrace[i]);
   }
 
@@ -1824,7 +1824,7 @@
           if (__mf_opts.backtrace > 0)
           {
             unsigned i;
-            for (i=0; i<obj->dealloc_backtrace_size; i++)
+            for (i=2; i<obj->dealloc_backtrace_size; i++)
               fprintf (stderr, "      %s\n", obj->dealloc_backtrace[i]);
           }
         }
@@ -2107,7 +2107,7 @@
            __mf_violation and presumably __mf_check, it'll detect
            recursion, and not put the new string into the database.  */
 
-        for (i=0; i<num; i++)
+        for (i=1; i<num; i++)
           fprintf (stderr, "      %s\n", symbols[i]);
 
         /* Calling free() here would trigger a violation.  */
diff -ruN gcc-gnu-4.8.2/libstdc++-v3/ChangeLog.STM gcc-st40-4.8.2.140205/libstdc++-v3/ChangeLog.STM
--- gcc-gnu-4.8.2/libstdc++-v3/ChangeLog.STM	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/libstdc++-v3/ChangeLog.STM	2013-05-28 13:16:49.000000000 +0200
@@ -0,0 +1,40 @@
+2012-04-25  Laurent Alfonsi  <laurent.alfonsi@st.com>
+
+        * testsuite/lib/libstdc++.exp (libstdc++_init): uses 
+        GCC_UNDER_TEST, GXX_UNDER_TEST. 
+        (v3_target_compile, v3_target_compile_as_c): Appends 
+	additional linker flag if exists.
+
+2012-04-17  Antony King  <antony.king@st.com>
+
+        * include/ext/concurrence.h (~__mutex): Check _M_init instead of
+        __gthread_active_p.
+        (~__recursive_mutex): Likewise.
+        (__recursive_mutex::_S_destroy): New template function for default
+        implementation using __gthread_recursive_mutex_t.
+
+2011-11-23  Christian Bruel  <christian.bruel@st.com>
+
+	* testsuite/23_containers/vector/bool/modifiers/insert/31370.cc:
+	xfail for sh-superh-elf.
+
+2009-10-06  Antony King  <antony.king@st.com>
+
+	INSbl30052:
+	* configure.host: Enable atomic builtins for sh*-superh-elf.
+	* configure: Regenerate.
+
+2009-02-24  Antony King  <antony.king@st.com>
+	    Christian Bruel  <christian.bruel@st.com>
+
+	INSbl28513:
+	* include/ext/concurrence.h (__scoped_gmutex_lock): Defined.
+	(__mutex:_M_init): Declare and initialize.
+	(__recursive_mutex:_M_init): Idem.
+	(__mutex:lock): Initialize mutex if needed.
+	(__recursive_mutex:lock): Idem.
+	* libsupc++/eh_globals.cc (__cxa_get_globals): Initialize eh_globals.
+	(__eh_globals_init:_M_create): New function
+	(__eh_globals_init): Initialize _M_once.
+	(__cxa_get_globals): Call init_create once.
+
diff -ruN gcc-gnu-4.8.2/libstdc++-v3/include/ext/concurrence.h gcc-st40-4.8.2.140205/libstdc++-v3/include/ext/concurrence.h
--- gcc-gnu-4.8.2/libstdc++-v3/include/ext/concurrence.h	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/libstdc++-v3/include/ext/concurrence.h	2013-05-29 16:05:41.000000000 +0200
@@ -1,6 +1,7 @@
 // Support for concurrent programing -*- C++ -*-
 
 // Copyright (C) 2003-2013 Free Software Foundation, Inc.
+// Copyright (c) 2013  STMicroelectronics.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -115,6 +116,63 @@
   { _GLIBCXX_THROW_OR_ABORT(__concurrence_wait_error()); }
 #endif
  
+#if __GTHREADS
+  class __scoped_gmutex_lock
+  {
+  private:
+    __scoped_gmutex_lock(const __scoped_gmutex_lock&);
+    __scoped_gmutex_lock& operator=(const __scoped_gmutex_lock&);
+
+    class __mutex_type
+    {
+    public:
+      __gthread_mutex_t _M_mutex;
+      __gthread_once_t  _M_once;
+
+      __mutex_type() : _M_once(__GTHREAD_ONCE_INIT) { }
+
+      ~__mutex_type() { }
+
+      void
+      _M_create()
+      {
+#if defined __GTHREAD_MUTEX_INIT
+	__gthread_mutex_t __tmp = __GTHREAD_MUTEX_INIT;
+	_M_mutex = __tmp;
+#else
+	__GTHREAD_MUTEX_INIT_FUNCTION(&_M_mutex);
+#endif
+      }
+    };
+
+    static __mutex_type _M_device;
+
+    static void
+    __M_device_create()
+    { _M_device._M_create(); }
+
+  public:
+    explicit __scoped_gmutex_lock()
+    {
+      // Do not need to check __gthread_active_p() as assume already
+      // checked before a sentry is created.
+      __gthread_once(&_M_device._M_once, __M_device_create);
+
+      if (__gthread_mutex_lock(&_M_device._M_mutex) != 0)
+	__throw_concurrence_lock_error();
+    }
+
+    ~__scoped_gmutex_lock() throw()
+    {
+      if (__gthread_mutex_unlock(&_M_device._M_mutex) != 0)
+	__throw_concurrence_unlock_error();
+    }
+  };
+
+  __scoped_gmutex_lock::__mutex_type __attribute__((weak))
+    __scoped_gmutex_lock::_M_device;
+#endif
+
   class __mutex 
   {
   private:
@@ -123,24 +181,31 @@
 #else
     __gthread_mutex_t _M_mutex;
 #endif
+    bool	      _M_init;
 
     __mutex(const __mutex&);
     __mutex& operator=(const __mutex&);
 
   public:
-    __mutex() 
+    __mutex() : _M_init(false)
     { 
 #if __GTHREADS && ! defined __GTHREAD_MUTEX_INIT
       if (__gthread_active_p())
-	__GTHREAD_MUTEX_INIT_FUNCTION(&_M_mutex);
+        {
+          __GTHREAD_MUTEX_INIT_FUNCTION(&_M_mutex);
+          _M_init = true;
+        }
 #endif
     }
 
 #if __GTHREADS && ! defined __GTHREAD_MUTEX_INIT
     ~__mutex() 
     { 
-      if (__gthread_active_p())
-	__gthread_mutex_destroy(&_M_mutex); 
+      if (__builtin_expect(_M_init == true, true))
+        {
+          __gthread_mutex_destroy(&_M_mutex); 
+	  _M_init = false;
+        }
     }
 #endif 
 
@@ -149,12 +214,27 @@
 #if __GTHREADS
       if (__gthread_active_p())
 	{
+	  if (__builtin_expect(_M_init == false, false))
+	    {
+	      __scoped_gmutex_lock sentry;
+	      if (_M_init == false)
+		{
+#if defined __GTHREAD_MUTEX_INIT
+		  __gthread_mutex_t __tmp = __GTHREAD_MUTEX_INIT;
+		  _M_mutex = __tmp;
+#else
+		  __GTHREAD_MUTEX_INIT_FUNCTION(&_M_mutex);
+#endif
+		  _M_init = true;
+		}
+	    }
+
 	  if (__gthread_mutex_lock(&_M_mutex) != 0)
 	    __throw_concurrence_lock_error();
 	}
 #endif
     }
-    
+
     void unlock()
     {
 #if __GTHREADS
@@ -178,24 +258,31 @@
 #else
     __gthread_recursive_mutex_t _M_mutex;
 #endif
+    bool			_M_init;
 
     __recursive_mutex(const __recursive_mutex&);
     __recursive_mutex& operator=(const __recursive_mutex&);
 
   public:
-    __recursive_mutex() 
+    __recursive_mutex()  : _M_init(false)
     { 
 #if __GTHREADS && ! defined __GTHREAD_RECURSIVE_MUTEX_INIT
       if (__gthread_active_p())
-	__GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION(&_M_mutex);
+        {
+          __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION(&_M_mutex);
+          _M_init = true;
+        }
 #endif
     }
 
 #if __GTHREADS && ! defined __GTHREAD_RECURSIVE_MUTEX_INIT
     ~__recursive_mutex()
     {
-      if (__gthread_active_p())
-	__gthread_recursive_mutex_destroy(&_M_mutex);
+      if (__builtin_expect(_M_init == true, true))
+        {
+          _S_destroy(&_M_mutex);
+	  _M_init = false;
+        }
     }
 #endif
 
@@ -204,6 +291,22 @@
 #if __GTHREADS
       if (__gthread_active_p())
 	{
+	  if (__builtin_expect(_M_init == false, false))
+	    {
+	      __scoped_gmutex_lock sentry;
+	      if (_M_init == false)
+		{
+#if defined __GTHREAD_RECURSIVE_MUTEX_INIT
+		  __gthread_recursive_mutex_t __tmp =
+		    __GTHREAD_RECURSIVE_MUTEX_INIT;
+		  _M_mutex = __tmp;
+#else
+		  __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION(&_M_mutex);
+#endif
+		  _M_init = true;
+		}
+	    }
+
 	  if (__gthread_recursive_mutex_lock(&_M_mutex) != 0)
 	    __throw_concurrence_lock_error();
 	}
@@ -223,6 +326,7 @@
 
     __gthread_recursive_mutex_t* gthread_recursive_mutex(void)
     { return &_M_mutex; }
+
   };
 
   /// Scoped lock idiom.
diff -ruN gcc-gnu-4.8.2/libstdc++-v3/include/std/mutex gcc-st40-4.8.2.140205/libstdc++-v3/include/std/mutex
--- gcc-gnu-4.8.2/libstdc++-v3/include/std/mutex	2013-10-16 16:17:23.000000000 +0200
+++ gcc-st40-4.8.2.140205/libstdc++-v3/include/std/mutex	2013-10-17 12:15:29.000000000 +0200
@@ -1,6 +1,7 @@
 // <mutex> -*- C++ -*-
 
 // Copyright (C) 2003-2013 Free Software Foundation, Inc.
+// Copyright (c) 2012 STMicroelectronics.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -102,6 +103,14 @@
 
     ~__recursive_mutex_base()
     { __gthread_recursive_mutex_destroy(&_M_mutex); }
+
+    // default match
+    template<typename _Rm>
+      static 
+      typename enable_if<is_same<_Rm, __gthread_recursive_mutex_t>::__value,
+        void>::__type
+      _S_destroy(_Rm* __mx)
+      { __gthread_recursive_mutex_destroy(__mx); }
 #endif
   };
 
diff -ruN gcc-gnu-4.8.2/libstdc++-v3/libsupc++/eh_globals.cc gcc-st40-4.8.2.140205/libstdc++-v3/libsupc++/eh_globals.cc
--- gcc-gnu-4.8.2/libstdc++-v3/libsupc++/eh_globals.cc	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/libstdc++-v3/libsupc++/eh_globals.cc	2013-05-28 13:16:49.000000000 +0200
@@ -1,5 +1,6 @@
 // -*- C++ -*- Manage the thread-local exception globals.
 // Copyright (C) 2001-2013 Free Software Foundation, Inc.
+// Copyright (c) 2009  STMicroelectronics.
 //
 // This file is part of GCC.
 //
@@ -28,6 +29,7 @@
 #include "cxxabi.h"
 #include "unwind-cxx.h"
 #include "bits/gthr.h"
+#include <ext/concurrence.h>
 
 #if _GLIBCXX_HOSTED
 using std::free;
@@ -91,12 +93,10 @@
 {
   __gthread_key_t  	_M_key;
   bool 			_M_init;
+  __gthread_once_t	_M_once;
 
-  __eh_globals_init() : _M_init(false)
-  { 
-    if (__gthread_active_p())
-      _M_init = __gthread_key_create(&_M_key, eh_globals_dtor) == 0; 
-  }
+  __eh_globals_init() : _M_init(false), _M_once(__GTHREAD_ONCE_INIT)
+  { }
 
   ~__eh_globals_init()
   {
@@ -104,14 +104,23 @@
       __gthread_key_delete(_M_key);
     _M_init = false;
   }
+
+  inline void
+  _M_create()
+  { _M_init = __gthread_key_create(&_M_key, eh_globals_dtor) == 0; }
 };
 
 static __eh_globals_init init;
 
+static void
+init_create()
+{ init._M_create(); }
+
 extern "C" __cxa_eh_globals*
 __cxxabiv1::__cxa_get_globals_fast() _GLIBCXX_NOTHROW
 {
   __cxa_eh_globals* g;
+
   if (init._M_init)
     g = static_cast<__cxa_eh_globals*>(__gthread_getspecific(init._M_key));
   else
@@ -123,6 +132,11 @@
 __cxxabiv1::__cxa_get_globals() _GLIBCXX_NOTHROW
 {
   __cxa_eh_globals* g;
+
+  if (__builtin_expect(init._M_init == false, false)
+      && __gthread_active_p())
+    __gthread_once(&init._M_once, init_create);
+
   if (init._M_init)
     {
       g = static_cast<__cxa_eh_globals*>(__gthread_getspecific(init._M_key));
diff -ruN gcc-gnu-4.8.2/libstdc++-v3/testsuite/lib/libstdc++.exp gcc-st40-4.8.2.140205/libstdc++-v3/testsuite/lib/libstdc++.exp
--- gcc-gnu-4.8.2/libstdc++-v3/testsuite/lib/libstdc++.exp	2013-10-16 16:17:23.000000000 +0200
+++ gcc-st40-4.8.2.140205/libstdc++-v3/testsuite/lib/libstdc++.exp	2013-10-17 12:15:29.000000000 +0200
@@ -93,6 +93,8 @@
     global tool_timeout
     global DEFAULT_CXXFLAGS
     global STATIC_LIBCXXFLAGS
+    global GXX_UNDER_TEST
+    global GCC_UNDER_TEST
 
     # We set LC_ALL and LANG to C so that we get the same error
     # messages as expected.
@@ -209,11 +211,21 @@
     set tool_timeout 600
 
     # Default settings.
-    set cxx [transform "g++"]
+    if [info exists GXX_UNDER_TEST] {
+        set cxx $GXX_UNDER_TEST
+    } else {
+    	set cxx [transform "g++"]
+    }
     set cxxflags "-D_GLIBCXX_ASSERT -fmessage-length=0"
     set cxxpchflags ""
     set cxxldflags ""
-    set cc [transform "gcc"]
+
+    if [info exists GCC_UNDER_TEST] {
+        set cc $GCC_UNDER_TEST
+    } else {
+    	set cc [transform "gcc"]
+    }
+    
     # Locate testsuite_hooks.h and other testsuite headers.
     set includes "-I${srcdir}/util"
     # Adapt the defaults for special circumstances.
@@ -425,6 +437,8 @@
     global cxxldflags
     global includes
     global STATIC_LIBCXXFLAGS
+    global srcdir
+    global additional_linker_flag
 
     if { [target_info needs_status_wrapper] != "" && [info exists gluefile] } {
         lappend options "libs=${gluefile}"
@@ -440,6 +454,9 @@
 
     # Flag setting based on type argument.
     if { $type == "executable" } {
+        if { [info exists additional_linker_flag] } {
+           lappend cxx_final $additional_linker_flag
+	}
 	# Link the support objects into executables.
 	lappend options "additional_flags=./libtestc++.a $cxxldflags"
     } else {
@@ -467,6 +484,8 @@
     global cc
     global cxxflags
     global STATIC_LIBCXXFLAGS
+    global srcdir
+    global additional_linker_flag
 
     if { [target_info needs_status_wrapper] != "" && [info exists gluefile] } {
         lappend options "libs=${gluefile}"
@@ -480,6 +499,10 @@
     set cc_final [concat $cc_final $STATIC_LIBCXXFLAGS]
     set cc_final [concat $cc_final $cxxflags]
     set cc_final [concat $cc_final $includes]
+    if { [info exists additional_linker_flag] } {
+        lappend cc_final $additional_linker_flag
+    }
+    
     regsub -all {\s[-]nostdinc[+][+]} $cc_final "" cc_final
 
     # This is needed for "C" tests, as this type of test may need the
diff -ruN gcc-gnu-4.8.2/lto-plugin/ChangeLog.STM gcc-st40-4.8.2.140205/lto-plugin/ChangeLog.STM
--- gcc-gnu-4.8.2/lto-plugin/ChangeLog.STM	1970-01-01 01:00:00.000000000 +0100
+++ gcc-st40-4.8.2.140205/lto-plugin/ChangeLog.STM	2013-05-28 13:16:36.000000000 +0200
@@ -0,0 +1,3 @@
+2012-10-11  Laurent Alfonsi  <laurent.alfonsi@st.com>
+
+	* lto-plugin.c (claim_file_handler): Detect no symbol case.
diff -ruN gcc-gnu-4.8.2/lto-plugin/lto-plugin.c gcc-st40-4.8.2.140205/lto-plugin/lto-plugin.c
--- gcc-gnu-4.8.2/lto-plugin/lto-plugin.c	2013-05-23 10:25:29.000000000 +0200
+++ gcc-st40-4.8.2.140205/lto-plugin/lto-plugin.c	2013-05-28 13:16:36.000000000 +0200
@@ -1,6 +1,7 @@
 /* LTO plugin for gold and/or GNU ld.
    Copyright (C) 2009, 2010 Free Software Foundation, Inc.
    Contributed by Rafael Avila de Espindola (espindola@google.com).
+   Copyright (c) 2013  STMicroelectronics.
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -910,6 +911,9 @@
 
   status = add_symbols (file->handle, lto_file.symtab.nsyms,
 			lto_file.symtab.syms);
+  if (status == LDPS_NO_SYMS)
+    goto cleanup;
+    
   check (status == LDPS_OK, LDPL_FATAL, "could not add symbols");
 
   *claimed = 1;

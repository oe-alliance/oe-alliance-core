From 8ff66276b8c109251b2054c088b5646429f7d7f7 Mon Sep 17 00:00:00 2001
From: Captain <captain.onboard@web.de>
Date: Thu, 24 Sep 2015 18:48:57 +0200
Subject: [PATCH] dvbmediasink_sh4_fix

---
 gstdvbaudiosink.c | 65 +++++++++++++++++++++++++++++++++++++++++++++++++++---
 gstdvbaudiosink.h |  2 ++
 gstdvbvideosink.c | 66 +++++++++++++++++++++++++++++++++++++++++++++++++++++--
 gstdvbvideosink.h |  2 ++
 4 files changed, 130 insertions(+), 5 deletions(-)

diff --git a/gstdvbaudiosink.c b/gstdvbaudiosink.c
index ee257f2..49222c4 100644
--- a/gstdvbaudiosink.c
+++ b/gstdvbaudiosink.c
@@ -64,6 +64,10 @@
 #include <config.h>
 #endif
 
+#ifdef __sh__
+#include <linux/dvb/stm_ioctls.h>
+#endif
+
 #include <gst/gst.h>
 #include <gst/audio/audio.h>
 #include <gst/base/gstbasesink.h>
@@ -189,6 +193,36 @@ GST_STATIC_PAD_TEMPLATE(
 	)
 );
 
+#define AUDIO_ENCODING_UNKNOWN  0xFF
+
+unsigned int bypass_to_encoding (unsigned int bypass)
+{
+#ifdef AUDIO_SET_ENCODING
+	switch(bypass)
+	{
+	case AUDIOTYPE_AC3:
+	case AUDIOTYPE_AC3_PLUS:
+		return AUDIO_ENCODING_AC3;
+	case AUDIOTYPE_MPEG:
+		return AUDIO_ENCODING_MPEG1;
+	case AUDIOTYPE_DTS:
+		return AUDIO_ENCODING_DTS;
+	case AUDIOTYPE_LPCM:
+		return AUDIO_ENCODING_LPCMA;
+	case AUDIOTYPE_MP3:
+		return AUDIO_ENCODING_MP3;
+	case AUDIOTYPE_AAC_PLUS:
+		return AUDIO_ENCODING_AAC;
+	case AUDIOTYPE_WMA:
+	case AUDIOTYPE_WMA_PRO:
+		return AUDIO_ENCODING_WMA;
+	default:
+		return AUDIO_ENCODING_UNKNOWN;
+	}
+#endif
+	return AUDIO_ENCODING_UNKNOWN;
+}
+
 static void gst_dvbaudiosink_init(GstDVBAudioSink *self);
 static void gst_dvbaudiosink_dispose(GObject *obj);
 static void gst_dvbaudiosink_reset(GObject *obj);
@@ -283,6 +317,11 @@ static void gst_dvbaudiosink_init(GstDVBAudioSink *self)
 	self->unlockfd[0] = self->unlockfd[1] = -1;
 	self->rate = 1.0;
 	self->timestamp = GST_CLOCK_TIME_NONE;
+#ifdef AUDIO_SET_ENCODING
+	self->use_set_encoding = TRUE;
+#else
+	self->use_set_encoding = FALSE;
+#endif
 #ifdef VUPLUS
 	gst_base_sink_set_sync(GST_BASE_SINK(self), TRUE);
 	gst_base_sink_set_async_enabled(GST_BASE_SINK(self), FALSE);
@@ -721,11 +760,26 @@ static gboolean gst_dvbaudiosink_set_caps(GstBaseSink *basesink, GstCaps *caps)
 		if (self->fd >= 0) ioctl(self->fd, AUDIO_STOP, 0);
 		self->playing = FALSE;
 	}
-	if (self->fd < 0 || ioctl(self->fd, AUDIO_SET_BYPASS_MODE, bypass) < 0)
+
+	if (self->use_set_encoding)
+	{
+#ifdef AUDIO_SET_ENCODING
+		unsigned int encoding = bypass_to_encoding(bypass);
+		if (self->fd < 0 || ioctl(self->fd, AUDIO_SET_ENCODING, encoding) < 0)
+		{
+			GST_ELEMENT_WARNING(self, STREAM, DECODE,(NULL),("hardware decoder can't be set to encoding %i", encoding));
+		}
+#endif
+	}
+	else
 	{
-		GST_ELEMENT_ERROR(self, STREAM, TYPE_NOT_FOUND,(NULL),("hardware decoder can't be set to bypass mode type %s", type));
-		return FALSE;
+		if (self->fd < 0 || ioctl(self->fd, AUDIO_SET_BYPASS_MODE, bypass) < 0)
+		{
+			GST_ELEMENT_ERROR(self, STREAM, TYPE_NOT_FOUND,(NULL),("hardware decoder can't be set to bypass mode type %s", type));
+			return FALSE;
+		}
 	}
+
 	if (self->fd >= 0) ioctl(self->fd, AUDIO_PLAY);
 	self->playing = TRUE;
 
@@ -782,6 +836,11 @@ static gboolean gst_dvbaudiosink_event(GstBaseSink *sink, GstEvent *event)
 	{
 		gboolean pass_eos = FALSE;
 		struct pollfd pfd[2];
+
+#ifdef AUDIO_FLUSH
+		ioctl(self->fd, AUDIO_FLUSH, 1/*NONBLOCK*/); //Notify the player that no addionional data will be injected
+#endif
+
 		pfd[0].fd = self->unlockfd[0];
 		pfd[0].events = POLLIN;
 		pfd[1].fd = self->fd;
diff --git a/gstdvbaudiosink.h b/gstdvbaudiosink.h
index c62e0f4..92bcdfd 100644
--- a/gstdvbaudiosink.h
+++ b/gstdvbaudiosink.h
@@ -134,6 +134,8 @@ struct _GstDVBAudioSink
 	gint64 timestamp_offset;
 	gint8 ok_to_write;
 
+        gboolean use_set_encoding;
+
 	queue_entry_t *queue;
 };
 
diff --git a/gstdvbvideosink.c b/gstdvbvideosink.c
index e9637b7..0b09d95 100644
--- a/gstdvbvideosink.c
+++ b/gstdvbvideosink.c
@@ -64,6 +64,10 @@
 #include <config.h>
 #endif
 
+#ifdef __sh__
+#include <linux/dvb/stm_ioctls.h>
+#endif
+
 #include <gst/gst.h>
 #include <gst/base/gstbasesink.h>
 
@@ -236,6 +240,42 @@ GST_STATIC_PAD_TEMPLATE (
 	)
 );
 
+#define VIDEO_ENCODING_UNKNOWN  0xFF
+
+unsigned int streamtype_to_encoding(unsigned int streamtype)
+{
+#ifdef VIDEO_SET_ENCODING
+	switch(streamtype)
+	{
+	case STREAMTYPE_MPEG2:
+		return VIDEO_ENCODING_AUTO;
+	case STREAMTYPE_MPEG4_H264:
+		return VIDEO_ENCODING_H264;
+	case STREAMTYPE_H263:
+		return VIDEO_ENCODING_H263;
+	case STREAMTYPE_MPEG4_Part2:
+		return VIDEO_ENCODING_MPEG4P2;
+	case STREAMTYPE_MPEG1:
+		return VIDEO_ENCODING_AUTO;
+	case STREAMTYPE_XVID:
+		return VIDEO_ENCODING_MPEG4P2;
+	case STREAMTYPE_DIVX311:
+		return VIDEO_ENCODING_MPEG4P2;
+	case STREAMTYPE_DIVX4:
+		return VIDEO_ENCODING_MPEG4P2;
+	case STREAMTYPE_DIVX5:
+		return VIDEO_ENCODING_MPEG4P2;
+	case STREAMTYPE_VC1:
+		return VIDEO_ENCODING_VC1;
+	case STREAMTYPE_VC1_SM:
+		return VIDEO_ENCODING_WMV;
+	default:
+		return VIDEO_ENCODING_UNKNOWN;
+	}
+#endif
+	return VIDEO_ENCODING_UNKNOWN;
+}
+
 static void gst_dvbvideosink_init(GstDVBVideoSink *self);
 static void gst_dvbvideosink_dispose(GObject *obj);
 static void gst_dvbvideosink_reset(GObject *obj);
@@ -333,6 +373,11 @@ static void gst_dvbvideosink_init(GstDVBVideoSink *self)
 	self->unlockfd[0] = self->unlockfd[1] = -1;
 	self->saved_fallback_framerate[0] = 0;
 	self->rate = 1.0;
+#ifdef VIDEO_SET_ENCODING
+	self->use_set_encoding      = TRUE;
+#else
+	self->use_set_encoding      = FALSE;
+#endif
 
 	gst_base_sink_set_sync(GST_BASE_SINK(self), FALSE);
 	gst_base_sink_set_async_enabled(GST_BASE_SINK(self), TRUE);
@@ -467,6 +512,10 @@ static gboolean gst_dvbvideosink_event(GstBaseSink *sink, GstEvent *event)
 		pfd[1].fd = self->fd;
 		pfd[1].events = POLLIN;
 
+#ifdef VIDEO_FLUSH
+		ioctl(self->fd, VIDEO_FLUSH, 1/*NONBLOCK*/); //Notify the player that no addionional data will be injected
+#endif
+
 		GST_BASE_SINK_PREROLL_UNLOCK(sink);
 		while (1)
 		{
@@ -1601,9 +1650,22 @@ static gboolean gst_dvbvideosink_set_caps(GstBaseSink *basesink, GstCaps *caps)
 			if (self->fd >= 0) ioctl(self->fd, VIDEO_STOP, 0);
 			self->playing = FALSE;
 		}
-		if (self->fd < 0 || ioctl(self->fd, VIDEO_SET_STREAMTYPE, self->stream_type) < 0)
+		if (self->use_set_encoding)
 		{
-			GST_ELEMENT_ERROR(self, STREAM, CODEC_NOT_FOUND, (NULL), ("hardware decoder can't handle streamtype %i", self->stream_type));
+#ifdef VIDEO_SET_ENCODING
+			unsigned int encoding = streamtype_to_encoding(self->stream_type);
+			if (self->fd < 0 || ioctl(self->fd, VIDEO_SET_ENCODING, encoding) < 0)
+			{
+				GST_ELEMENT_ERROR(self, STREAM, DECODE, (NULL), ("hardware decoder can't be set to encoding %i", encoding));
+			}
+#endif
+		}
+		else
+		{
+			if (self->fd < 0 || ioctl(self->fd, VIDEO_SET_STREAMTYPE, self->stream_type) < 0)
+			{
+				GST_ELEMENT_ERROR(self, STREAM, CODEC_NOT_FOUND, (NULL), ("hardware decoder can't handle streamtype %i", self->stream_type));
+			}
 		}
 		if (self->fd >= 0) 
 		{
diff --git a/gstdvbvideosink.h b/gstdvbvideosink.h
index 3bafdcc..4917073 100644
--- a/gstdvbvideosink.h
+++ b/gstdvbvideosink.h
@@ -134,6 +134,8 @@ struct _GstDVBVideoSink
 	gboolean must_send_header;
 	gint8 ok_to_write;
 
+	gboolean use_set_encoding;
+
 	queue_entry_t *queue;
 };
 
-- 
1.9.5.msysgit.0


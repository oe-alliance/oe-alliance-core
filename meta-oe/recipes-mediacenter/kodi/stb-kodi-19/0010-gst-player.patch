From 9b6ad60c360724c5d59331fc520a4106981b7856 Mon Sep 17 00:00:00 2001
From: Captain <captain.onboard@web.de>
Date: Fri, 17 Jul 2020 21:07:15 +0200
Subject: [PATCH 10/10] gst-player

diff --git a/cmake/modules/FindGLIB.cmake b/cmake/modules/FindGLIB.cmake
new file mode 100644
index 00000000000..656aa0b7d62
--- /dev/null
+++ b/cmake/modules/FindGLIB.cmake
@@ -0,0 +1,102 @@
+# - Try to find Glib and its components (gio, gobject etc)
+# Once done, this will define
+#
+#  GLIB_FOUND - system has Glib
+#  GLIB_INCLUDE_DIRS - the Glib include directories
+#  GLIB_LIBRARIES - link these to use Glib
+#
+# Optionally, the COMPONENTS keyword can be passed to FIND_PACKAGE()
+# and Glib components can be looked for.  Currently, the following
+# components can be used, and they define the following variables if
+# found:
+#
+#  gio:             GLIB_GIO_LIBRARIES
+#  gobject:         GLIB_GOBJECT_LIBRARIES
+#  gmodule:         GLIB_GMODULE_LIBRARIES
+#  gthread:         GLIB_GTHREAD_LIBRARIES
+#
+# Note that the respective _INCLUDE_DIR variables are not set, since
+# all headers are in the same directory as GLIB_INCLUDE_DIRS.
+#
+# Copyright (C) 2012 Raphael Kubo da Costa <rakuco@webkit.org>
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+# 1.  Redistributions of source code must retain the above copyright
+#     notice, this list of conditions and the following disclaimer.
+# 2.  Redistributions in binary form must reproduce the above copyright
+#     notice, this list of conditions and the following disclaimer in the
+#     documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND ITS CONTRIBUTORS ``AS
+# IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR ITS
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+FIND_PACKAGE(PkgConfig)
+PKG_CHECK_MODULES(PC_GLIB QUIET glib-2.0)
+
+FIND_LIBRARY(GLIB_LIBRARIES
+    NAMES glib-2.0
+    HINTS ${PC_GLIB_LIBDIR}
+          ${PC_GLIB_LIBRARY_DIRS}
+)
+
+# Files in glib's main include path may include glibconfig.h, which,
+# for some odd reason, is normally in $LIBDIR/glib-2.0/include.
+GET_FILENAME_COMPONENT(_GLIB_LIBRARY_DIR ${GLIB_LIBRARIES} PATH)
+FIND_PATH(GLIBCONFIG_INCLUDE_DIR
+    NAMES glibconfig.h
+    HINTS ${PC_LIBDIR} ${PC_LIBRARY_DIRS} ${_GLIB_LIBRARY_DIR}
+    PATH_SUFFIXES glib-2.0/include
+)
+
+FIND_PATH(GLIB_INCLUDE_DIR
+    NAMES glib.h
+    HINTS ${PC_GLIB_INCLUDEDIR}
+          ${PC_GLIB_INCLUDE_DIRS}
+    PATH_SUFFIXES glib-2.0
+)
+
+SET(GLIB_INCLUDE_DIRS ${GLIB_INCLUDE_DIR} ${GLIBCONFIG_INCLUDE_DIR})
+
+# Version detection
+FILE(READ "${GLIBCONFIG_INCLUDE_DIR}/glibconfig.h" GLIBCONFIG_H_CONTENTS)
+STRING(REGEX MATCH "#define GLIB_MAJOR_VERSION ([0-9]+)" _dummy "${GLIBCONFIG_H_CONTENTS}")
+SET(GLIB_VERSION_MAJOR "${CMAKE_MATCH_1}")
+STRING(REGEX MATCH "#define GLIB_MINOR_VERSION ([0-9]+)" _dummy "${GLIBCONFIG_H_CONTENTS}")
+SET(GLIB_VERSION_MINOR "${CMAKE_MATCH_1}")
+STRING(REGEX MATCH "#define GLIB_MICRO_VERSION ([0-9]+)" _dummy "${GLIBCONFIG_H_CONTENTS}")
+SET(GLIB_VERSION_MICRO "${CMAKE_MATCH_1}")
+SET(GLIB_VERSION "${GLIB_VERSION_MAJOR}.${GLIB_VERSION_MINOR}.${GLIB_VERSION_MICRO}")
+
+# Additional Glib components.  We only look for libraries, as not all of them
+# have corresponding headers and all headers are installed alongside the main
+# glib ones.
+FOREACH (_component ${GLIB_FIND_COMPONENTS})
+    IF (${_component} STREQUAL "gio")
+        FIND_LIBRARY(GLIB_GIO_LIBRARIES NAMES gio-2.0 HINTS ${_GLIB_LIBRARY_DIR})
+        SET(ADDITIONAL_REQUIRED_VARS ${ADDITIONAL_REQUIRED_VARS} GLIB_GIO_LIBRARIES)
+    ELSEIF (${_component} STREQUAL "gobject")
+        FIND_LIBRARY(GLIB_GOBJECT_LIBRARIES NAMES gobject-2.0 HINTS ${_GLIB_LIBRARY_DIR})
+        SET(ADDITIONAL_REQUIRED_VARS ${ADDITIONAL_REQUIRED_VARS} GLIB_GOBJECT_LIBRARIES)
+    ELSEIF (${_component} STREQUAL "gmodule")
+        FIND_LIBRARY(GLIB_GMODULE_LIBRARIES NAMES gmodule-2.0 HINTS ${_GLIB_LIBRARY_DIR})
+        SET(ADDITIONAL_REQUIRED_VARS ${ADDITIONAL_REQUIRED_VARS} GLIB_GMODULE_LIBRARIES)
+    ELSEIF (${_component} STREQUAL "gthread")
+        FIND_LIBRARY(GLIB_GTHREAD_LIBRARIES NAMES gthread-2.0 HINTS ${_GLIB_LIBRARY_DIR})
+        SET(ADDITIONAL_REQUIRED_VARS ${ADDITIONAL_REQUIRED_VARS} GLIB_GTHREAD_LIBRARIES)
+    ENDIF ()
+ENDFOREACH ()
+
+INCLUDE(FindPackageHandleStandardArgs)
+FIND_PACKAGE_HANDLE_STANDARD_ARGS(GLIB REQUIRED_VARS GLIB_INCLUDE_DIRS GLIB_LIBRARIES ${ADDITIONAL_REQUIRED_VARS}
+                                       VERSION_VAR   GLIB_VERSION)
diff --git a/cmake/modules/FindGstreamer.cmake b/cmake/modules/FindGstreamer.cmake
new file mode 100644
index 00000000000..760e7d13212
--- /dev/null
+++ b/cmake/modules/FindGstreamer.cmake
@@ -0,0 +1,40 @@
+#.rst:
+# FindGStreamer
+# -------
+# Finds the GStreamer library
+#
+# This will define the following variables::
+#
+# GSTREAMER_FOUND - system has GStreamer
+# GSTREAMER_INCLUDE_DIRS - the GStreamer include directory
+# GSTREAMER_LIBRARIES - the GStreamer libraries
+# GSTREAMER_DEFINITIONS - the GStreamer compile definitions
+
+if(PKG_CONFIG_FOUND)
+  pkg_check_modules(PC_GLIB glib-2.0 QUIET)
+  pkg_check_modules(PC_GOBJECT gobject-2.0 QUIET)
+  pkg_check_modules(PC_GSTREAMER gstreamer-1.0 QUIET)
+  pkg_check_modules(PC_GSTREAMERPBUTILS gstreamer-pbutils-1.0 QUIET)
+endif()
+
+find_path(GSTREAMER_INCLUDE_DIR NAMES gst/gst.h
+                          PATHS ${PC_GSTREAMER_INCLUDE_DIRS})
+find_library(GLIB_LIBRARY NAMES glib-2.0
+                         PATHS ${PC_GLIB_LIBDIR})
+find_library(GOBJECT_LIBRARY NAMES gobject-2.0
+                         PATHS ${PC_GOBJECT_LIBDIR})
+find_library(GSTREAMER_LIBRARY NAMES gstreamer-1.0
+                         PATHS ${PC_GSTREAMER_LIBDIR})
+find_library(GSTREAMERPBUTILS_LIBRARY NAMES gstpbutils-1.0
+                         PATHS ${PC_GSTREAMERPBUTILS_LIBDIR})
+
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(Gstreamer REQUIRED_VARS GSTREAMER_LIBRARY GSTREAMER_INCLUDE_DIR)
+
+if(GSTREAMER_FOUND)
+  set(GSTREAMER_LIBRARIES ${GSTREAMER_LIBRARY} ${GSTREAMERPBUTILS_LIBRARY} ${GOBJECT_LIBRARY} ${GLIB_LIBRARY})
+  set(GSTREAMER_INCLUDE_DIRS ${GSTREAMER_INCLUDE_DIR} ${GSTREAMERPBUTILS_INCLUDE_DIR})
+  set(GSTREAMER_DEFINITIONS -DHAVE_LIBGSTREAMER=1)
+endif()
+
+mark_as_advanced(GSTREAMER_LIBRARY GSTREAMER_INCLUDE_DIR GSTREAMER_LDFLAGS)
diff --git a/cmake/platform/linux/stb.cmake b/cmake/platform/linux/stb.cmake
index e1fe54a13d2..7d7e14205f8 100644
--- a/cmake/platform/linux/stb.cmake
+++ b/cmake/platform/linux/stb.cmake
@@ -1,4 +1,4 @@
-set(PLATFORM_REQUIRED_DEPS EGL LibInput Xkbcommon)
+set(PLATFORM_REQUIRED_DEPS EGL LibInput Xkbcommon Gstreamer GLIB)
 set(PLATFORM_OPTIONAL_DEPS VAAPI)
 
 set(STB_RENDER_SYSTEM "" CACHE STRING "Render system to use with STB: \"gl\" or \"gles\"")
diff --git a/cmake/treedata/common/cores.txt b/cmake/treedata/common/cores.txt
index 5e5c6cbf80c..cbde630e7dd 100644
--- a/cmake/treedata/common/cores.txt
+++ b/cmake/treedata/common/cores.txt
@@ -5,5 +5,6 @@ xbmc/cores/DllLoader/exports           cores/dll-loader/exports
 xbmc/cores/DllLoader/exports/util      cores/dll-loader/exports/util
 xbmc/cores/ExternalPlayer              cores/externalplayer
 xbmc/cores/Enigma2Player               cores/enigma2player
+xbmc/cores/GstPlayer                   cores/gstplayer
 xbmc/cores/paplayer                    cores/paplayer
 xbmc/cores/playercorefactory           cores/playercorefactory
diff --git a/xbmc/cores/GstPlayer/CMakeLists.txt b/xbmc/cores/GstPlayer/CMakeLists.txt
new file mode 100644
index 00000000000..1b8adfab36c
--- /dev/null
+++ b/xbmc/cores/GstPlayer/CMakeLists.txt
@@ -0,0 +1,9 @@
+set(SOURCES GstPlayer.cpp
+            GstPlayerAudio.cpp
+            GstPlayerVideo.cpp)
+
+set(HEADERS GstPlayer.h
+            GstPlayerAudio.h
+            GstPlayerVideo.h)
+
+core_add_library(gstplayer)
diff --git a/xbmc/cores/GstPlayer/GstPlayer.cpp b/xbmc/cores/GstPlayer/GstPlayer.cpp
new file mode 100644
index 00000000000..bfdf16630fb
--- /dev/null
+++ b/xbmc/cores/GstPlayer/GstPlayer.cpp
@@ -0,0 +1,687 @@
+/*
+ *      Copyright (C) 2005-2015 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with Kodi; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "GstPlayer.h"
+#include "GstPlayerVideo.h"
+#include "GstPlayerAudio.h"
+
+#include "system.h"
+#include "Util.h"
+#include "FileItem.h"
+#include "Application.h"
+#include "ServiceBroker.h"
+#include "messaging/ApplicationMessenger.h"
+#include "CompileInfo.h"
+#include "GUIInfoManager.h"
+#include "URL.h"
+#include "utils/StringUtils.h"
+#include "utils/URIUtils.h"
+#include "utils/XMLUtils.h"
+#include "utils/log.h"
+#include "cores/DataCacheCore.h"
+#include "input/InputManager.h"
+#include "settings/AdvancedSettings.h"
+#include "settings/Settings.h"
+#include "settings/SettingsComponent.h"
+#include "settings/DisplaySettings.h"
+#include "threads/SystemClock.h"
+#include "threads/SingleLock.h"
+#include "windowing/WinSystem.h"
+#include "guilib/GUIWindowManager.h"
+#include "filesystem/MusicDatabaseFile.h"
+#include "dialogs/GUIDialogBusy.h"
+#include "pvr/PVRManager.h"
+#include "pvr/PVRPlaybackState.h"
+#include "utils/StreamDetails.h"
+#include "video/Bookmark.h"
+
+#include "cores/VideoPlayer/Process/ProcessInfo.h"
+
+#include "cores/VideoPlayer/VideoPlayer.h"
+
+#include "ServiceBroker.h"
+#include "cores/AudioEngine/Engines/ActiveAE/ActiveAE.h"
+
+#include "cores/VideoPlayer/DVDInputStreams/DVDFactoryInputStream.h"
+#include "DVDInputStreams/InputStreamPVRBase.h"
+#include "settings/MediaSettings.h"
+#include "storage/MediaManager.h"
+
+//using namespace PVR;
+using namespace KODI::MESSAGING;
+using namespace XFILE;
+
+// Default time after which the item's playcount is incremented
+#define DEFAULT_PLAYCOUNT_MIN_TIME 10
+
+CGstPlayer::CGstPlayer(IPlayerCallback& callback)
+	: IPlayer(callback)
+	,CThread("GstPlayer")
+	,m_bAbortRequest(false)
+	,m_isRecording(false)
+	,m_playbackStartTime(0)
+	,m_playCountMinTime(DEFAULT_PLAYCOUNT_MIN_TIME)
+	,m_speed(1)
+	,m_totalTime(1)
+	,m_time(0)
+	,m_ready(true)
+//	,m_messenger("player")
+{
+	m_pInputStream = nullptr;
+	m_canTempo = false;
+	m_processInfo.reset(CProcessInfo::CreateInstance());
+	m_processInfo->SetDataCache(&CServiceBroker::GetDataCacheCore());
+	m_processInfo->SetSpeed(1.0);
+	m_processInfo->SetTempo(1.0);
+	m_processInfo->SetVideoRender(true); //molto importante per kodi 18
+
+	CLog::Log(LOGINFO, "CGstPlayer::%s", __FUNCTION__ );
+	
+	CreatePlayers();
+	CServiceBroker::GetWinSystem()->Register(this);
+
+	CServiceBroker::GetWinSystem()->RegisterRenderLoop(this); //From Decompiled
+
+//	CServiceBroker::GetWinSystem()->Hide();
+
+	CLog::Log(LOGINFO, "CGstPlayer::%s", __FUNCTION__ );
+}
+
+void CGstPlayer::CreatePlayers()
+{
+	CLog::Log(LOGINFO, "CGstPlayer::%s", __FUNCTION__ );
+	m_VideoPlayerAudio = new CGstPlayerAudio(*m_processInfo);
+	m_VideoPlayerVideo = new CGstPlayerVideo(this, *m_processInfo);
+	CLog::Log(LOGINFO, "CGstPlayer::%s", __FUNCTION__ );
+}
+
+void CGstPlayer::DestroyPlayers()
+{
+	CLog::Log(LOGINFO, "CGstPlayer::%s", __FUNCTION__ );
+	delete m_VideoPlayerVideo;
+	delete m_VideoPlayerAudio;
+	CLog::Log(LOGINFO, "CGstPlayer::%s", __FUNCTION__ );
+}
+
+CGstPlayer::~CGstPlayer()
+{
+	CServiceBroker::GetWinSystem()->UnregisterRenderLoop(this);
+
+	CServiceBroker::GetWinSystem()->Unregister(this);
+
+	CloseFile();
+	
+	m_pInputStream.reset();
+	
+	DestroyPlayers();
+	
+	CServiceBroker::GetActiveAE()->Resume();
+	
+	CLog::Log(LOGINFO, "CGstPlayer::%s", __FUNCTION__ );
+}
+
+bool CGstPlayer::OpenFile(const CFileItem& file, const CPlayerOptions &options)
+{
+	if (IsPlaying())
+		CloseFile();
+	
+	m_bAbortRequest = false;
+	m_processInfo->SetSpeed(1.0);
+	m_processInfo->SetTempo(1.0);
+	m_PlayerOptions = options;
+	m_item = file;
+	// Try to resolve the correct mime type
+	m_item.SetMimeTypeForInternetFile();
+	m_ready.Reset();
+	
+	Create();
+	m_callback.OnPlayBackStarted(file);
+	
+	return true;
+}
+
+bool CGstPlayer::CloseFile(bool reopen)
+{
+	m_bAbortRequest = true;
+	
+	m_VideoPlayerVideo->CloseStream();
+	
+	if(m_pInputStream)
+		m_pInputStream->Abort();
+	
+	/* wait for the thread to terminate */
+	StopThread(true);
+	
+	CLog::Log(LOGINFO, "CGstPlayer::%s: reopen=%s", __FUNCTION__, reopen == true ? "true":"false");
+
+	return true;
+}
+
+bool CGstPlayer::OpenInputStream()
+{
+	if (m_pInputStream.use_count() > 1)
+		throw std::runtime_error("m_pInputStream reference count is greater than 1");
+	m_pInputStream.reset();
+
+	CLog::Log(LOGINFO, "Creating InputStream");
+
+	// correct the filename if needed
+	std::string filename(m_item.GetPath());
+	if (URIUtils::IsProtocol(filename, "dvd") ||
+			StringUtils::EqualsNoCase(filename, "iso9660://video_ts/video_ts.ifo"))
+	{
+		m_item.SetPath(CServiceBroker::GetMediaManager().TranslateDevicePath(""));
+	}
+
+	m_pInputStream = CDVDFactoryInputStream::CreateInputStream(this, m_item, true);
+	if(m_pInputStream == NULL)
+	{
+		CLog::Log(LOGERROR, "CGstPlayer%s: - unable to create input stream for [%s]", __FUNCTION__, CURL::GetRedacted(m_item.GetPath()).c_str());
+		return false;
+	}
+
+	if (!m_pInputStream->Open())
+	{
+		CLog::Log(LOGERROR, "CGstPlayer%s: - error opening [%s]", __FUNCTION__, CURL::GetRedacted(m_item.GetPath()).c_str());
+		return false;
+	}
+
+	// find any available external subtitles for non dvd files
+	if (!m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD)
+	&&	!m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER)
+	&&	!m_pInputStream->IsStreamType(DVDSTREAM_TYPE_TV))
+	{
+		// find any available external subtitles
+		std::vector<std::string> filenames;
+		CUtil::ScanForExternalSubtitles(m_item.GetPath(), filenames);
+
+		// load any subtitles from file item
+		std::string key("subtitle:1");
+		for(unsigned s = 1; m_item.HasProperty(key); key = StringUtils::Format("subtitle:%u", ++s))
+			filenames.push_back(m_item.GetProperty(key).asString());
+
+		for(unsigned int i=0;i<filenames.size();i++)
+		{
+			// if vobsub subtitle:
+			if (URIUtils::HasExtension(filenames[i], ".idx"))
+			{
+				std::string strSubFile;
+				if ( CUtil::FindVobSubPair( filenames, filenames[i], strSubFile ) )
+				{
+					CLog::Log(LOGINFO, "CGstPlayer%s: - AddSubtitleFile", __FUNCTION__);
+					//AddSubtitleFile(filenames[i], strSubFile);
+				}
+			}
+			else
+			{
+				if ( !CUtil::IsVobSub(filenames, filenames[i] ) )
+				{
+					CLog::Log(LOGINFO, "CGstPlayer%s: - AddSubtitleFile", __FUNCTION__);
+					//AddSubtitleFile(filenames[i]);
+				}
+			}
+		} // end loop over all subtitle files
+	}
+
+	//m_clock.Reset();
+	//m_dvd.Clear();
+	//m_errorCount = 0;
+	//m_ChannelEntryTimeOut.SetInfinite();
+	
+	if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_FILE))
+		CLog::Log(LOGINFO, "CGstPlayer%s: DVDSTREAM_TYPE_FILE", __FUNCTION__);
+	else if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD))
+		CLog::Log(LOGINFO, "CGstPlayer%s: DVDSTREAM_TYPE_DVD", __FUNCTION__);
+	else if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_HTTP))
+		CLog::Log(LOGINFO, "CGstPlayer%s: DVDSTREAM_TYPE_HTTP", __FUNCTION__);
+	else if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_MEMORY))
+		CLog::Log(LOGINFO, "CGstPlayer%s: DVDSTREAM_TYPE_MEMORY", __FUNCTION__);
+	else if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_FFMPEG))
+		CLog::Log(LOGINFO, "CGstPlayer%s: DVDSTREAM_TYPE_FFMPEG", __FUNCTION__);
+	else if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_TV))
+		CLog::Log(LOGINFO, "CGstPlayer%s: DVDSTREAM_TYPE_TV", __FUNCTION__);
+	else if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_MPLS))
+		CLog::Log(LOGINFO, "CGstPlayer%s: DVDSTREAM_TYPE_MPLS", __FUNCTION__);
+	else if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_BLURAY))
+		CLog::Log(LOGINFO, "CGstPlayer%s: DVDSTREAM_TYPE_BLURAY", __FUNCTION__);
+	else if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER))
+		CLog::Log(LOGINFO, "CGstPlayer%s: DVDSTREAM_TYPE_PVRMANAGER", __FUNCTION__);
+	else if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_MULTIFILES))
+		CLog::Log(LOGINFO, "CGstPlayer%s: DVDSTREAM_TYPE_MULTIFILES", __FUNCTION__);
+	else if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_ADDON))
+		CLog::Log(LOGINFO, "CGstPlayer%s: DVDSTREAM_TYPE_ADDON", __FUNCTION__);
+	else if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_NONE))
+		CLog::Log(LOGINFO, "CGstPlayer%s: DVDSTREAM_TYPE_NONE", __FUNCTION__);
+	else 
+		CLog::Log(LOGINFO, "CGstPlayer%s: DVDSTREAM_TYPE_UNKNOWN", __FUNCTION__);
+	
+	CLog::Log(LOGINFO, "CGstPlayer%s: m_ready.Set()", __FUNCTION__);
+	m_ready.Set();
+
+	bool realtime = m_pInputStream->IsRealtime();
+
+	if (CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(CSettings::SETTING_VIDEOPLAYER_USEDISPLAYASCLOCK) &&
+			!realtime)
+		m_canTempo = true;
+	else
+		m_canTempo = false;
+
+	return true;
+}
+
+void CGstPlayer::Process()
+{
+	if (!OpenInputStream())
+	{
+		m_bAbortRequest = true;
+		return;
+	}
+	
+	CDVDStreamInfo hint;
+	
+	hint.Clear();
+	hint.filename = m_pInputStream->GetFileName();
+	
+	CURL Url(hint.filename);
+	
+	CLog::Log(LOGINFO, "CGstPlayer%s: m_pInputStream->GetFileName(): %s", __FUNCTION__, hint.filename.c_str());
+
+	CApplicationMessenger::GetInstance().PostMsg(TMSG_SWITCHTOFULLSCREEN);
+
+	m_playbackStartTime = XbmcThreads::SystemClockMillis();
+	m_time = 0;
+
+	/* Suspend AE temporarily so exclusive or hog-mode sinks */
+	/* don't block external player's access to audio device  */
+	CServiceBroker::GetActiveAE()->Suspend();
+	// wait for AE has completed suspended
+	XbmcThreads::EndTime timer(2000);
+	while (!timer.IsTimePast() && !CServiceBroker::GetActiveAE()->IsSuspended())
+	{
+		Sleep(50);
+	}
+	if (timer.IsTimePast())
+	{
+		CLog::Log(LOGERROR,"%s: AudioEngine did not suspend before launching GstPlayer", __FUNCTION__);
+	}
+
+	//m_callback.OnPlayBackStarted();
+
+	if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER) && 
+		Url.IsLocalHost())
+	{
+		hint.filename = "";
+	}
+
+	m_bStop = false;
+
+	m_VideoPlayerVideo->OpenStream(hint, m_item);
+	
+	m_bStop = true;
+	
+	CLog::Log(LOGINFO, "CGstPlayer%s: m_bStop: %s", __FUNCTION__, m_bStop == true ? "true" : "false");
+
+	CLog::Log(LOGINFO, "%s: Showing %s window", __FUNCTION__, CCompileInfo::GetAppName());
+	CServiceBroker::GetWinSystem()->Show();
+	m_time = GetTime() / 1000;
+	m_totalTime = GetTotalTime() / 1000;
+	if (m_time >= DEFAULT_PLAYCOUNT_MIN_TIME)
+	{
+		CBookmark bookmark;
+		bookmark.totalTimeInSeconds = m_totalTime;
+		bookmark.timeInSeconds = m_time;
+		bookmark.player = m_name;
+		m_callback.OnPlayerCloseFile(m_item, bookmark);
+	}
+
+	/* Resume AE processing of XBMC native audio */
+	if (!CServiceBroker::GetActiveAE()->Resume())
+	{
+	CLog::Log(LOGFATAL, "%s: Failed to restart AudioEngine after return from Gstplayer",__FUNCTION__);
+	}
+
+	// We don't want to come back to an active screensaver
+	g_application.ResetScreenSaver();
+	g_application.WakeUpScreenSaverAndDPMS();
+
+	if (g_application.CurrentFileItem().IsStack() || 
+			m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER))
+		m_callback.OnPlayBackStopped();
+	else
+		m_callback.OnPlayBackEnded();
+}
+
+
+void CGstPlayer::Pause()
+{
+	m_VideoPlayerVideo->Pause();
+}
+
+bool CGstPlayer::HasVideo() const
+{
+	return true;
+}
+
+bool CGstPlayer::HasAudio() const
+{
+	return false;
+}
+
+void CGstPlayer::SwitchToNextLanguage()
+{
+	m_VideoPlayerVideo->SwitchToNextLanguage();
+}
+
+void CGstPlayer::ToggleSubtitles()
+{
+	m_VideoPlayerVideo->ToggleSubtitles();
+}
+
+bool CGstPlayer::CanSeek()
+{
+	return m_VideoPlayerVideo->CanSeek();
+}
+
+void CGstPlayer::Seek(bool bPlus, bool bLargeStep, bool bChapterOverride)
+{
+	m_VideoPlayerVideo->Seek(bPlus, bLargeStep, bChapterOverride);
+}
+
+void CGstPlayer::SwitchToNextAudioLanguage()
+{
+	m_VideoPlayerVideo->SwitchToNextAudioLanguage();
+}
+
+void CGstPlayer::SeekPercentage(float iPercent)
+{
+	m_VideoPlayerVideo->SeekPercentage(iPercent);
+}
+
+float CGstPlayer::GetPercentage()
+{
+	int64_t iTime = GetTime();
+	int64_t iTotalTime = GetTotalTime();
+
+	if (iTotalTime != 0)
+	{
+		//CLog::Log(LOGINFO, "CGstPlayer::%s: Percentage=%f", __FUNCTION__ , (iTime * 100 / (float)iTotalTime) );
+		return iTime * 100 / (float)iTotalTime;
+	}
+
+	return 0.0f;
+}
+
+void CGstPlayer::SetAVDelay(float fValue)
+{
+	m_VideoPlayerVideo->SetAVDelay(fValue);
+}
+
+float CGstPlayer::GetAVDelay()
+{
+	return m_VideoPlayerVideo->GetAVDelay();
+}
+
+void CGstPlayer::SetSubTitleDelay(float fValue)
+{
+	m_VideoPlayerVideo->SetSubTitleDelay(fValue);
+}
+
+float CGstPlayer::GetSubTitleDelay()
+{
+	return m_VideoPlayerVideo->GetSubTitleDelay();
+}
+
+void CGstPlayer::SeekTime(int64_t iTime)
+{
+	int seekOffset = (int)(iTime - GetTime());
+	
+	m_VideoPlayerVideo->SeekTime(iTime);
+	m_callback.OnPlayBackSeek((int)iTime, seekOffset);
+}
+
+bool CGstPlayer::SeekTimeRelative(int64_t iTime)
+{
+	bool res = m_VideoPlayerVideo->SeekTimeRelative(iTime);
+	
+	if(res)
+	{
+		int64_t abstime = GetTime() + iTime;
+		m_callback.OnPlayBackSeek((int)abstime, iTime);
+	}
+	
+	return res;
+}
+
+int64_t CGstPlayer::GetTime() // in milliseconds
+{
+	return m_VideoPlayerVideo->GetTime();
+}
+
+int64_t CGstPlayer::GetTotalTime() // in milliseconds
+{
+	return m_VideoPlayerVideo->GetTotalTime();
+}
+
+bool CGstPlayer::CanRecord()
+{
+	return false;
+}
+
+bool CGstPlayer::IsRecording()
+{
+	return false;
+}
+
+void CGstPlayer::SetSpeed(float iSpeed)
+{
+	CLog::Log(LOGINFO, "CGstPlayer::%s: %f", __FUNCTION__, iSpeed);
+}
+
+void CGstPlayer::ShowOSD(bool bOnoff)
+{
+	CLog::Log(LOGINFO, "CGstPlayer::%s: %s", __FUNCTION__, bOnoff == false ? "false":"true" );
+}
+
+std::string CGstPlayer::GetPlayerState()
+{
+	CLog::Log(LOGINFO, "CGstPlayer::%s", __FUNCTION__);
+	return "";
+}
+
+bool CGstPlayer::SetPlayerState(const std::string& state)
+{
+	CLog::Log(LOGINFO, "CGstPlayer::%s: state:%s", __FUNCTION__, state.c_str());
+	return true;
+}
+
+bool CGstPlayer::Initialize(TiXmlElement* pConfig)
+{
+	CLog::Log(LOGINFO, "CGstPlayer::%s", __FUNCTION__);
+	return true;
+}
+
+void CGstPlayer::Render(bool clear, uint32_t alpha, bool gui)
+{
+	//CServiceBroker::GetWinSystem().ClearBuffers(0.0f);
+
+	//CLog::Log(LOGINFO, "CGstPlayer::%s: clear=%s, alpha=%d, gui=%s", __FUNCTION__, clear == false ? "false":"true", (int)alpha, gui == false ? "false":"true");
+}
+
+void CGstPlayer::ToggleOSD()
+{
+	CLog::Log(LOGINFO, "CGstPlayer::%s:", __FUNCTION__);
+}
+
+void CGstPlayer::SetVolume(float volume)
+{
+	m_VideoPlayerAudio->SetVolume(volume);
+}
+
+void CGstPlayer::SetMute(bool bOnOff)
+{
+	m_VideoPlayerAudio->SetMute(bOnOff);
+}
+
+int CGstPlayer::GetAudioStreamCount()
+{
+	return m_VideoPlayerVideo->GetAudioStreamCount();
+}
+
+void CGstPlayer::SetAudioStream(int iStream)
+{
+	return m_VideoPlayerVideo->SetAudioStream(iStream);
+}
+
+int CGstPlayer::GetVideoStreamCount()
+{
+	return m_VideoPlayerVideo->GetVideoStreamCount();
+}
+
+int CGstPlayer::GetSubtitleCount()
+{
+	return m_VideoPlayerVideo->GetSubtitleCount();
+}
+
+int CGstPlayer::GetAudioStream()
+{
+	return m_VideoPlayerVideo->GetAudioStream();
+}
+
+/*bool CGstPlayer::GetStreamDetails(CStreamDetails &details)
+{
+	return m_VideoPlayerVideo->GetStreamDetails(details);
+}*/
+
+void CGstPlayer::GetVideoStreamInfo(int index, VideoStreamInfo &info)
+{
+	m_VideoPlayerVideo->GetVideoStreamInfo(index, info);
+}
+
+void CGstPlayer::GetAudioStreamInfo(int index, AudioStreamInfo &info)
+{
+	m_VideoPlayerVideo->GetAudioStreamInfo(index, info);
+}
+
+void CGstPlayer::GetSubtitleStreamInfo(int index, SubtitleStreamInfo &info)
+{
+	m_VideoPlayerVideo->GetSubtitleStreamInfo(index, info);
+}
+
+int CGstPlayer::GetVideoStream()
+{
+	return m_VideoPlayerVideo->GetVideoStream();
+}
+
+int CGstPlayer::GetSubtitle()
+{
+	return m_VideoPlayerVideo->GetSubtitle();
+}
+
+void CGstPlayer::SetSubtitle(int iStream)
+{
+	m_VideoPlayerVideo->SetSubtitle(iStream);
+}
+
+bool CGstPlayer::GetSubtitleVisible()
+{
+	return m_VideoPlayerVideo->GetSubtitleVisible();
+}
+
+void CGstPlayer::SetSubtitleVisible(bool bVisible)
+{
+	m_VideoPlayerVideo->SetSubtitleVisible(bVisible);
+}
+
+
+float CGstPlayer::GetRenderAspectRatio()
+{
+	return m_VideoPlayerVideo->GetRenderAspectRatio();
+}
+
+void CGstPlayer::OnPlaybackStarted(const CFileItem& file)
+{
+	CLog::Log(LOGINFO, "CGstPlayer::%s", __FUNCTION__);
+	
+	CURL Url(m_pInputStream->GetFileName());
+	
+	CLog::Log(LOGINFO, "CGstPlayer::%s: startpercent=%f starttime=%f", __FUNCTION__, m_PlayerOptions.startpercent, m_PlayerOptions.starttime);
+	
+	if (m_PlayerOptions.startpercent > 0)
+	{
+		//CLog::Log(LOGINFO, "CGstPlayer::%s: m_PlayerOptions.startpercent set", __FUNCTION__);
+		m_VideoPlayerVideo->SeekPercentage(m_PlayerOptions.startpercent/(float) 100);
+		m_PlayerOptions.startpercent = 0.0f;
+	}
+	else if (m_PlayerOptions.starttime > 0)
+	{
+		//CLog::Log(LOGINFO, "CGstPlayer::%s: m_PlayerOptions.starttime set", __FUNCTION__);
+		m_VideoPlayerVideo->SeekTimeRelative((int64_t) m_PlayerOptions.starttime * 1000);
+		m_PlayerOptions.starttime = 0.0f;
+	}
+	
+	if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER) && 
+		//Url.IsLocalHost() && !IsRecording())
+		Url.IsLocalHost() && !CServiceBroker::GetPVRManager().PlaybackState()->IsRecording())
+	{
+		FILE *f = fopen("/proc/stb/fp/led0_pattern", "w");
+		if (f)
+		{
+			if (fprintf(f, "%08x", 0xffffffff) == 0)
+				CLog::Log(LOGINFO, "CGstPlayer::%s: switch off fake record LED", __FUNCTION__);
+			fclose(f);
+		}
+	}
+	m_callback.OnPlayBackStarted(file);
+	m_callback.OnAVStarted(file);
+	//m_ready.Set();
+}
+
+bool CGstPlayer::OnAction(const CAction &action)
+{
+	CLog::Log(LOGINFO, "CGstPlayer::%s: id=%d", __FUNCTION__, action.GetID());
+	return false;
+}
+
+void CGstPlayer::GetVideoResolution(unsigned int &width, unsigned int &height)
+{
+	RESOLUTION_INFO res = CServiceBroker::GetWinSystem()->GetGfxContext().GetResInfo();
+	width = res.iWidth;
+	height = res.iHeight;
+	
+	CLog::Log(LOGINFO, "CGstPlayer::%s: width=%d height=%d", __FUNCTION__, width, height);
+}
+
+void CGstPlayer::FrameMove() 
+{ 
+	//CLog::Log(LOGINFO, "CGstPlayer::%s", __FUNCTION__ );
+	if (m_processInfo)
+		m_processInfo->SetPlayTimes(0, GetTime(), 0, GetTotalTime() );
+}
+
+bool CGstPlayer::IsPlaying() const
+{
+  return !m_bStop;
+}
+
+bool CGstPlayer::IsRenderingVideo()
+{
+	return IsPlaying();
+}
+
diff --git a/xbmc/cores/GstPlayer/GstPlayer.h b/xbmc/cores/GstPlayer/GstPlayer.h
new file mode 100644
index 00000000000..6d095855c30
--- /dev/null
+++ b/xbmc/cores/GstPlayer/GstPlayer.h
@@ -0,0 +1,186 @@
+
+/*
+ *      Copyright (C) 2005-2015 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with Kodi; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#pragma once
+
+#include <string>
+#include "system.h"
+
+#include "GstPlayerAudio.h"
+#include "GstPlayerVideo.h"
+#include "cores/IPlayer.h"
+#include "threads/Thread.h"
+#include "cores/VideoPlayer/VideoRenderers/RenderManager.h"
+#include "utils/log.h"
+#include "FileItem.h"
+#include "guilib/DispResource.h"
+
+#include "cores/VideoPlayer/IVideoPlayer.h"
+#include "cores/VideoPlayer/DVDInputStreams/DVDInputStream.h"
+
+class CProcessInfo;
+class CGstPlayerAudio;
+class CGstPlayerVideo;
+class CInputStreamPVRManager;
+
+using namespace PVR;
+
+class IGstPlayerCallback
+{
+public:
+	virtual void OnPlaybackStarted(const CFileItem& file) = 0;
+};
+
+class CGstPlayer : public IPlayer,
+		   public CThread,
+		   public IVideoPlayer,
+		   public IGstPlayerCallback,
+		   public IDispResource,
+		   public IRenderLoop
+{
+public:
+
+	int OnDiscNavResult(void* pData, int iMessage) { return 0; };
+	void GetVideoResolution(unsigned int &width, unsigned int &height);
+	
+	explicit CGstPlayer(IPlayerCallback& callback);
+	~CGstPlayer() override;
+	bool Initialize(TiXmlElement* pConfig);
+	bool OpenFile(const CFileItem& file, const CPlayerOptions &options) override;
+	bool CloseFile(bool reopen = false) override;
+	
+	//bool IsPlaying() const { return m_isPlaying; };
+	bool IsPlaying() const;
+	void Pause() override;
+	bool HasVideo() const;
+	bool HasAudio() const;
+	void ToggleOSD(); // empty
+	void SwitchToNextLanguage();
+	void ToggleSubtitles();
+	bool CanSeek();
+	void Seek(bool bPlus, bool bLargeStep, bool bChapterOverride);
+	void SeekPercentage(float iPercent);
+	float GetPercentage();
+	void SetVolume(float volume) override;
+	void SetMute(bool bOnOff) override;
+
+	bool HasMenu() const { return true; };
+	void SetDynamicRangeCompression(long drc) {}
+	void SetContrast(bool bPlus) {}
+	void SetBrightness(bool bPlus) {}
+	void SetHue(bool bPlus) {}
+	void SetSaturation(bool bPlus) {}
+	void SwitchToNextAudioLanguage();
+	bool CanRecord();
+	bool IsRecording();
+	bool Record(bool bOnOff) { return false; }
+	void SetAVDelay(float fValue = 0.0f);
+	float GetAVDelay();
+	
+	void FrameMove();
+	void Render(bool clear, uint32_t alpha, bool gui);
+	void FlushRenderer() { CLog::Log(LOGINFO, "%s: ", __FUNCTION__ ); };
+	
+	void SetRenderViewMode(int mode) { CLog::Log(LOGINFO, "%s: mode=%d", __FUNCTION__, mode); };
+	float GetRenderAspectRatio();
+	void TriggerUpdateResolution() { CLog::Log(LOGINFO, "%s: ", __FUNCTION__ ); };
+	
+	bool IsRenderingVideo();
+	bool IsRenderingGuiLayer() { return true; };
+	bool IsRenderingVideoLayer() { return true; };
+	
+	void SetSubTitleDelay(float fValue = 0.0f);
+	float GetSubTitleDelay();
+
+	void SeekTime(int64_t iTime);
+	bool SeekTimeRelative(int64_t iTime);
+	
+	int64_t GetTime();
+	int64_t GetTotalTime();
+	void SetSpeed(float iSpeed) override;
+	void ShowOSD(bool bOnoff);
+	void DoAudioWork() {};
+	
+	std::string GetPlayerState();
+	bool SetPlayerState(const std::string& state);
+	
+	int GetAudioStreamCount() override;
+	int GetVideoStreamCount();
+	int GetSubtitleCount() override;
+	
+	int GetAudioStream() override;
+	int GetVideoStream();
+	int GetSubtitle();
+  	void SetSubtitle(int iStream) override;
+  	bool GetSubtitleVisible() override;
+  	void SetSubtitleVisible(bool bVisible) override;
+
+
+//	virtual bool GetStreamDetails(CStreamDetails &details);
+
+	void SetAudioStream(int iStream) override;
+	void GetAudioStreamInfo(int index, AudioStreamInfo &info) override;
+	
+	void GetVideoStreamInfo(int index, VideoStreamInfo &info) override;
+
+	void GetSubtitleStreamInfo(int index, SubtitleStreamInfo &info) override;
+
+	bool SupportsTempo() { return m_canTempo; };
+	
+	void OnPlaybackStarted(const CFileItem& file) override;
+
+private:
+
+	void Process() override;
+	bool OnAction(const CAction &action);
+	
+	void CreatePlayers();
+	void DestroyPlayers();
+	
+	bool m_bAbortRequest;
+	bool m_isPlaying;
+	bool m_isRecording;
+	
+	int64_t m_playbackStartTime;
+	int m_speed;
+	int m_totalTime;
+	int m_time;
+	int m_playCountMinTime;
+	
+	CPlayerOptions m_PlayerOptions;
+	std::unique_ptr<CProcessInfo> m_processInfo;
+	
+//	CDVDMessageQueue m_messenger;		 // thread messenger
+ 
+	CGstPlayerAudio *m_VideoPlayerAudio;
+	CGstPlayerVideo *m_VideoPlayerVideo;
+	
+	CEvent m_ready;
+	
+protected:
+	bool OpenInputStream();
+	
+	friend class CSelectionStreams;
+	
+	CFileItem m_item;
+	std::atomic_bool m_canTempo;
+	std::shared_ptr<CDVDInputStream> m_pInputStream;  // input stream for current playing file
+};
diff --git a/xbmc/cores/GstPlayer/GstPlayerAudio.cpp b/xbmc/cores/GstPlayer/GstPlayerAudio.cpp
new file mode 100644
index 00000000000..7672a7cad6e
--- /dev/null
+++ b/xbmc/cores/GstPlayer/GstPlayerAudio.cpp
@@ -0,0 +1,151 @@
+/*
+ *      Copyright (C) 2005-2015 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with Kodi; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "threads/SingleLock.h"
+#include "utils/XMLUtils.h"
+
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <linux/dvb/audio.h>
+
+#include "system.h"
+#include "GstPlayerAudio.h"
+#include "utils/log.h"
+
+#include "threads/Thread.h"
+#include "threads/SystemClock.h"
+#include "ServiceBroker.h"
+#include "cores/AudioEngine/Engines/ActiveAE/ActiveAE.h"
+
+#define AUDIO_DEV "/dev/dvb/adapter0/audio0"
+
+CGstPlayerAudio::CGstPlayerAudio(CProcessInfo &processInfo): m_processInfo(processInfo)
+{
+	CLog::Log(LOGINFO, "CGstPlayerAudio::%s", __FUNCTION__ );
+	// magic value used when omxplayer is playing - want sink to be disabled
+	AEAudioFormat m_format;
+	m_format.m_dataFormat = AE_FMT_RAW;
+	m_format.m_streamInfo.m_type = CAEStreamInfo::STREAM_TYPE_AC3;
+	m_format.m_streamInfo.m_sampleRate = 16000;
+	m_format.m_streamInfo.m_channels = 2;
+	m_format.m_sampleRate = 16000;
+	m_format.m_frameSize = 1;
+	m_pAudioStream = CServiceBroker::GetActiveAE()->MakeStream(m_format);
+
+	m_processInfo.ResetAudioCodecInfo();
+#if 0
+	CServiceBroker::GetActiveAE()->Suspend();
+	/* wait for AE has completed suspended */
+	XbmcThreads::EndTime timer(1000);
+	while (!timer.IsTimePast() && !CServiceBroker::GetActiveAE()->IsSuspended())
+	{
+		usleep(80);
+	}
+	if (timer.IsTimePast())
+	{
+		CLog::Log(LOGERROR,"CGstPlayerAudio::%s: AudioEngine did not suspend before launching player", __FUNCTION__);
+	}
+#endif
+}
+
+CGstPlayerAudio::~CGstPlayerAudio()
+{
+#if 0
+	/* Resume AE processing of XBMC native audio */
+	if (!CServiceBroker::GetActiveAE()->Resume())
+	{
+		CLog::Log(LOGFATAL, "CGstPlayerAudio::%s: Failed to restart AudioEngine after return from player",__FUNCTION__);
+	}
+#endif
+	if (m_pAudioStream)
+		CServiceBroker::GetActiveAE()->FreeStream(m_pAudioStream, true);
+	CLog::Log(LOGINFO, "CGstPlayerAudio::%s", __FUNCTION__ );
+}
+
+void CGstPlayerAudio::SetVolume(float volume)
+{
+	int vol = checkVolume(int(volume * 100));
+	audio_mixer_t mixer;
+	
+	vol = 63 - vol * 63 / 100;
+	
+	mixer.volume_left = vol;
+	mixer.volume_right = vol;
+
+	int fd = openMixer();
+	if (fd >= 0)
+	{
+		ioctl(fd, AUDIO_SET_MIXER, &mixer);
+		closeMixer(fd);
+	}
+
+	FILE * stb = fopen("/proc/stb/avs/0/volume", "w");
+	if (stb != NULL)
+	{
+		fprintf(stb, "%d", vol);
+		fclose (stb);
+	}
+
+	CLog::Log(LOGDEBUG, "%s: volume:%f set:%d (-1db)", __FUNCTION__, volume, vol);
+}
+
+void CGstPlayerAudio::SetMute(bool bOnOff)
+{
+	int fd = openMixer();
+	if (fd >= 0)
+	{
+		bool mute = bOnOff; //!m_muted;
+		if (!ioctl(fd, AUDIO_SET_MUTE, mute) == 0)
+			CLog::Log(LOGERROR, "%s: ioctl AUDIO_SET_MUTE failed", __FUNCTION__);
+		
+		closeMixer(fd);
+	}
+	else
+			CLog::Log(LOGERROR, "%s: i/o AUDIO_SET_MUTE failed", __FUNCTION__);
+	
+	FILE * stb = fopen("/proc/stb/audio/j1_mute", "w");
+	if (stb != NULL)
+	{
+		fprintf(stb, "%d", (int) bOnOff);
+		fclose (stb);
+	}
+
+
+	CLog::Log(LOGDEBUG, "%s: bOnOff	:%s", __FUNCTION__, bOnOff == false ? "off":"on" ); 
+}
+
+int CGstPlayerAudio::openMixer()
+{
+	return open(AUDIO_DEV, O_RDWR);
+}
+
+void CGstPlayerAudio::closeMixer(int fd)
+{
+	if (fd >= 0) close(fd);
+}
+
+int CGstPlayerAudio::checkVolume(int vol)
+{
+	if (vol < 0)
+		vol = 0;
+	else if (vol > 100)
+		vol = 100;
+	return vol;
+}
diff --git a/xbmc/cores/GstPlayer/GstPlayerAudio.h b/xbmc/cores/GstPlayer/GstPlayerAudio.h
new file mode 100644
index 00000000000..aba881378d0
--- /dev/null
+++ b/xbmc/cores/GstPlayer/GstPlayerAudio.h
@@ -0,0 +1,44 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2015 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with Kodi; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "threads/Thread.h"
+
+#include "cores/AudioEngine/Interfaces/AEStream.h"
+#include "cores/VideoPlayer/Process/ProcessInfo.h"
+
+class CGstPlayerAudio
+{
+public:
+	CGstPlayerAudio(CProcessInfo &processInfo);
+	~CGstPlayerAudio();
+	void SetVolume(float volume);
+	void SetMute(bool bOnOff);
+
+private:
+	int openMixer();
+	int checkVolume(int vol);
+	void closeMixer(int fd);
+	IAEStream *m_pAudioStream;
+	
+protected:
+	CProcessInfo &m_processInfo;
+};
diff --git a/xbmc/cores/GstPlayer/GstPlayerVideo.cpp b/xbmc/cores/GstPlayer/GstPlayerVideo.cpp
new file mode 100644
index 00000000000..c093d5d2301
--- /dev/null
+++ b/xbmc/cores/GstPlayer/GstPlayerVideo.cpp
@@ -0,0 +1,1405 @@
+/*
+ *			Copyright (C) 2005-2015 Team Kodi
+ *			http://kodi.tv
+ *
+ *	This Program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2, or (at your option)
+ *	any later version.
+ *
+ *	This Program is distributed in the hope that it will be useful,
+ *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *	GNU General Public License for more details.
+ *
+ *	You should have received a copy of the GNU General Public License
+ *	along with Kodi; see the file COPYING.	If not, see
+ *	<http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <gst/gst.h>
+#include <gst/tag/tag.h>
+#include <gst/app/gstappsrc.h>
+#include <gst/pbutils/missing-plugins.h>
+
+#include "GstPlayerVideo.h"
+#include "system.h"
+#include "URL.h"
+#include "Util.h"
+#include "cores/DataCacheCore.h"
+#include "ServiceBroker.h"
+#include "filesystem/SpecialProtocol.h"
+#include "utils/StringUtils.h"
+#include "utils/URIUtils.h"
+#include "utils/XMLUtils.h"
+#include "utils/log.h"
+#include "settings/AdvancedSettings.h"
+#include "settings/Settings.h"
+#include "settings/SettingsComponent.h"
+#include "messaging/ApplicationMessenger.h"
+#include "utils/LangCodeExpander.h"
+#include "LangInfo.h"
+
+#define HTTP_TIMEOUT 10
+
+#define CHUNK_SIZE 4096
+
+CGstPlayerVideo::CGstPlayerVideo(IGstPlayerCallback *callback, CProcessInfo &processInfo): m_callback(callback)
+	,m_processInfo(processInfo)
+	,m_aspect(0)
+	,m_width(0)
+	,m_height(0)
+	,m_offset(0)
+	,m_length(0)
+	,m_framerate(0)
+	,m_progressive(0)
+	,m_time(0)
+	,m_video(0)
+	,m_audio(0)
+	,m_text(0)
+	,m_totalTime(1)
+	,m_uri(NULL)
+	,m_loop(NULL)
+	,m_playbin(NULL)
+	,m_appsrc(NULL)
+	,m_pInputStream(NULL)
+	,m_extra_headers("")
+	,m_download_buffer_path("")
+	,m_notify_source_handler_id(0)
+	,m_notify_source_id(0)
+	,m_notify_element_added_handler_id(0)
+	,m_ignore_buffering_messages(0)
+	,m_use_prefillbuffer(false)
+	,m_is_sub_visible(false)
+	,m_is_live(false)
+	
+{
+	gst_init (NULL, FALSE);
+	m_processInfo.SetVideoDecoderName(("Gstreamer Version: %s", (const char *)gst_version_string()), true);
+	m_processInfo.SetAudioDecoderName(("Gstreamer Version: %s", (const char *)gst_version_string()));
+	const std::shared_ptr<CAdvancedSettings> advancedSettings = CServiceBroker::GetSettingsComponent()->GetAdvancedSettings();
+	m_useragent = advancedSettings->m_userAgent.c_str();
+	m_buffer_size = 5LL * 1024LL * 1024LL;
+	m_sourceinfo.is_video = TRUE;
+	m_paused = false;
+	m_first_paused = false;
+}
+
+CGstPlayerVideo::~CGstPlayerVideo()
+{
+	CloseStream();
+	
+	if(m_pInputStream)
+		SAFE_DELETE(m_pInputStream);
+	
+	CLog::Log(LOGINFO, "CGstPlayerVideo::%s", __FUNCTION__ );
+}
+
+bool CGstPlayerVideo::OpenStream(CDVDStreamInfo &hints, const CFileItem &file)
+{
+	m_item = file;
+	m_processInfo.ResetVideoCodecInfo();
+
+	m_sourceinfo.is_streaming = FALSE;
+	m_sourceinfo.is_hls = TRUE;
+
+	m_totalTime = 1;
+	m_time = 0;
+	
+	if(m_pInputStream)
+		SAFE_DELETE(m_pInputStream);
+	
+	std::string url(hints.filename);
+	
+	if (url.empty())
+		return CreateFakePipeline();
+	
+	if(StringUtils::EndsWith(url, ".m3u8"))
+		m_sourceinfo.is_hls = TRUE;
+	
+	if(StringUtils::StartsWith(url, "smb://") || StringUtils::StartsWith(url, "upnp://") || StringUtils::StartsWith(url, "nfs://"))
+	{
+		//m_sourceinfo.is_streaming = TRUE;
+
+		m_pInputStream = new CDVDInputStreamFile(m_item, XFILE::READ_TRUNCATED | XFILE::READ_BITRATE | XFILE::READ_CHUNKED);
+		
+		m_uri = g_strdup((const gchar *) "appsrc://");
+	}
+	
+	else if(url.find("://") != std::string::npos)
+	{
+		m_sourceinfo.is_streaming = TRUE;
+		size_t pos = url.find('#');
+		
+		if (pos != std::string::npos && (StringUtils::StartsWith(url, "http") || StringUtils::StartsWith(url, "rtsp")))
+		{
+			m_extra_headers = url.substr(pos + 1);
+			pos = m_extra_headers.find("User-Agent=");
+			if (pos != std::string::npos)
+			{
+				size_t hpos_start = pos + 11;
+				size_t hpos_end = m_extra_headers.find('&', hpos_start);
+				if (hpos_end != std::string::npos)
+					m_useragent = m_extra_headers.substr(hpos_start, hpos_end - hpos_start);
+				else
+					m_useragent = m_extra_headers.substr(hpos_start);
+			}
+		}
+		m_uri = g_strdup((const gchar *) url.c_str());
+	}
+	
+	else if(StringUtils::StartsWith(url, "/"))
+		m_uri = g_filename_to_uri((const gchar *) url.c_str(), NULL, NULL);
+	
+	CLog::Log(LOGINFO, "CGstPlayerVideo::%s: is_streaming: %s", __FUNCTION__, m_sourceinfo.is_streaming ? "true" : "false");
+	
+	return CreatePipeline();
+}
+
+void CGstPlayerVideo::CloseStream()
+{
+	DestroyPipeline();
+}
+
+void CGstPlayerVideo::DestroyPipeline()
+{
+	if (m_playbin != NULL)
+	{
+		GstStateChangeReturn ret;
+		
+		if(m_notify_source_handler_id)
+		{
+			g_signal_handler_disconnect(m_playbin, m_notify_source_handler_id);
+			m_notify_source_handler_id = 0;
+		}
+		
+		if(m_notify_element_added_handler_id)
+		{
+			g_signal_handler_disconnect(m_playbin, m_notify_element_added_handler_id);
+			m_notify_element_added_handler_id = 0;
+		}
+		
+		GstBus *bus = gst_pipeline_get_bus(GST_PIPELINE (m_playbin));
+		gst_bus_set_sync_handler(bus, NULL, NULL, NULL);
+		gst_object_unref(bus);
+		
+		ret = gst_element_set_state(m_playbin, GST_STATE_NULL);
+		if (ret != GST_STATE_CHANGE_SUCCESS)
+			CLog::Log(LOGFATAL, "CGstPlayerVideo::%s: Failed to set pipeline to GST_STATE_NULL!", __FUNCTION__);
+		else
+			CLog::Log(LOGINFO, "CGstPlayerVideo::%s: set pipeline to GST_STATE_NULL!", __FUNCTION__);
+
+		gst_object_unref(GST_OBJECT(m_playbin));
+		m_appsrc = NULL;
+		m_playbin = NULL;
+	}
+	
+	if(m_pInputStream)
+	{
+		m_pInputStream->Close();
+		SAFE_DELETE(m_pInputStream);
+		printf("CGstPlayerVideo::%s: SAFE_DELETE m_pInputStream", __FUNCTION__);
+	}
+	
+	if (m_uri != NULL)
+	{
+		g_free(m_uri);
+		m_uri = NULL;
+	}
+	
+	if (m_loop != NULL)
+	{
+		g_main_loop_quit(m_loop);
+	}
+	
+	CLog::Log(LOGINFO, "CGstPlayerVideo::%s: clean", __FUNCTION__);
+}
+
+bool CGstPlayerVideo::CreateFakePipeline()
+{
+	CLog::Log(LOGINFO, "CGstPlayerVideo::%s: running Fake pipeline...", __FUNCTION__);
+	
+	m_callback->OnPlaybackStarted(m_item);
+	
+	m_loop = g_main_loop_new(NULL, FALSE);
+	g_main_loop_run(m_loop);
+	
+	g_main_loop_unref(m_loop);
+	m_loop = NULL;
+	
+	return true;
+}
+
+bool CGstPlayerVideo::CreatePipeline()
+{
+	m_loop = g_main_loop_new(NULL, FALSE);
+	m_playbin = gst_element_factory_make("playbin", "playbin");
+	
+	if(m_playbin)
+	{
+		CLog::Log(LOGINFO, "CGstPlayerVideo::%s: m_uri: '%s'", __FUNCTION__, m_uri);
+		CLog::Log(LOGINFO, "CGstPlayerVideo::%s: running pipeline...", __FUNCTION__);
+
+		subsink = gst_element_factory_make("subsink", NULL);
+		if(subsink)
+		{
+			gst_object_ref_sink(subsink);
+		}
+		else
+			CLog::Log(LOGINFO, "CGstPlayerVideo::%s: subsink NOT created missing plugin subsink",  __FUNCTION__);
+
+		int flags = GST_PLAY_FLAG_VIDEO | GST_PLAY_FLAG_AUDIO | GST_PLAY_FLAG_NATIVE_VIDEO | GST_PLAY_FLAG_TEXT;
+		if(m_pInputStream)
+		{
+			if (m_pInputStream->Open())
+			{
+				m_length = (gsize) m_item.m_dwSize;
+				//m_length = (gsize) abs(m_pInputStream->GetLength());
+				m_offset = 0;
+				m_pInputStream->Seek(0, SEEK_SET);
+				m_notify_source_handler_id = g_signal_connect(m_playbin, "deep-notify::source", G_CALLBACK (DeepNotifySource), this);
+				CLog::Log(LOGINFO, "CGstPlayerVideo::%s: m_length=%d m_pInputStream->GetLength()=%d\n", __FUNCTION__,(int)m_length, m_pInputStream->GetLength());
+				printf("CGstPlayerVideo::%s: m_pInputStream->GetLength() %d\n", __FUNCTION__,(int)m_length);
+			}
+			else
+			{
+				if (m_loop != NULL) 
+				{
+					g_main_loop_unref(m_loop);
+					m_loop = NULL;
+				}
+				printf("CGstPlayerVideo::%s: m_pInputStream->Open()  Can not open File!\n", __FUNCTION__);
+				CLog::Log(LOGERROR, "CGstPlayerVideo::%s: Can not open File!",__FUNCTION__);
+				return false;
+			}
+				
+		}
+		
+		else if ( m_sourceinfo.is_streaming )
+		{
+			m_download_buffer_path = CSpecialProtocol::TranslatePath(CUtil::GetNextFilename("special://temp/filecache%03d.cache", 999));
+			
+
+			m_notify_source_handler_id = g_signal_connect(m_playbin, "notify::source", G_CALLBACK (NotifySource), this);
+			
+			if (m_download_buffer_path.empty())
+			{
+				CLog::Log(LOGERROR, "CGstPlayerVideo::%s: - Unable to generate a new filename for cache file", __FUNCTION__);
+			}
+			else
+			{
+				CLog::Log(LOGINFO, "CGstPlayerVideo::%s: m_download_buffer_path: %s", __FUNCTION__, m_download_buffer_path.c_str());
+			
+				if (access(m_download_buffer_path.c_str(), X_OK) >= 0)
+				{
+					CLog::Log(LOGINFO, "CGstPlayerVideo::%s: using cache file (buffer): %s", __FUNCTION__, m_download_buffer_path.c_str());
+					/* It looks like /hdd points to a valid mount, so we can store a download buffer on it */
+					m_use_prefillbuffer = true;
+					flags |= GST_PLAY_FLAG_DOWNLOAD;
+					m_notify_element_added_handler_id = g_signal_connect(m_playbin, "element-added", G_CALLBACK(handleElementAdded), this);
+					/* limit file size */
+					g_object_set(m_playbin, "ring-buffer-max-size", (guint64)(8LL * 1024LL * 1024LL), NULL);
+				}
+				else
+				{
+					CLog::Log(LOGERROR, "CGstPlayerVideo::%s: - Unable to access cache file %s", __FUNCTION__, m_download_buffer_path.c_str());
+					m_download_buffer_path = "";
+				}
+			}
+		
+			flags |= GST_PLAY_FLAG_BUFFERING;
+			/* increase the default 2 second / 2 MB buffer limitations to 10s / 10MB */
+			g_object_set(m_playbin, "buffer-duration", (gint64)(5LL * GST_SECOND), NULL);
+			g_object_set(m_playbin, "buffer-size", m_buffer_size, NULL);
+		
+			if(m_sourceinfo.is_hls)
+				g_object_set(m_playbin, "connection-speed", (guint64)(4495000LL), NULL);
+		}
+		
+		g_object_set(G_OBJECT(m_playbin), "uri", m_uri, NULL);
+		g_object_set(G_OBJECT(m_playbin), "flags", flags, NULL);
+
+		GstBus* bus = gst_pipeline_get_bus(GST_PIPELINE(m_playbin));
+		gst_bus_set_sync_handler(bus, gstBusSyncHandler, this, NULL);
+		gst_object_unref(bus);
+
+		GstStateChangeReturn ready;
+		ready = gst_element_set_state (m_playbin, GST_STATE_READY);
+
+		switch(ready)
+		{
+		case GST_STATE_CHANGE_FAILURE:
+			CLog::Log(LOGFATAL, "CGstPlayerVideo::%s: failed to start pipeline",__FUNCTION__);
+			DestroyPipeline();
+			return false;
+			break;
+		case GST_STATE_CHANGE_SUCCESS:
+			gst_element_set_state (m_playbin, GST_STATE_PLAYING);
+			printf("CGstPlayerVideo::%s:GST_STATE_PLAYING\n", __FUNCTION__);
+			m_is_live = false;
+			m_first_paused = true;
+			break;
+		case GST_STATE_CHANGE_NO_PREROLL:
+			gst_element_set_state (m_playbin, GST_STATE_PLAYING);
+			printf("CGstPlayerVideo::%s: GST_STATE_PLAYING\n", __FUNCTION__);
+			m_is_live = true;
+			break;
+		default:
+			return false;
+			break;
+		}
+
+		g_main_loop_run(m_loop);
+		
+		g_main_loop_unref(m_loop);
+		m_loop = NULL;
+
+		DestroyPipeline();
+	}
+	else
+	{
+		if (m_loop != NULL) 
+		{
+			g_main_loop_unref(m_loop);
+			m_loop = NULL;
+		}
+		CLog::Log(LOGFATAL, "CGstPlayerVideo::%s: Failed to create pipeline!",__FUNCTION__);
+		return false;
+	}
+	
+	return true;
+}
+
+
+void CGstPlayerVideo::Pause()
+{
+	if(m_playbin)
+	{
+		GstState currentState;
+		
+		gst_element_get_state(GST_ELEMENT(m_playbin), &currentState, 0, 0);
+		
+		if(currentState == GST_STATE_PAUSED)
+		{
+			gst_element_set_state(GST_ELEMENT(m_playbin), GST_STATE_PLAYING);
+			CLog::Log(LOGINFO, "CGstPlayerVideo::%s: set play", __FUNCTION__ );
+		}
+		else
+		{
+			gst_element_set_state(GST_ELEMENT(m_playbin), GST_STATE_PAUSED);
+			CLog::Log(LOGINFO, "CGstPlayerVideo::%s: set pause", __FUNCTION__ );
+		}
+	}
+}
+
+void CGstPlayerVideo::SwitchToNextLanguage()
+{
+	CLog::Log(LOGINFO, "CGstPlayerVideo::%s", __FUNCTION__ );
+}
+
+void CGstPlayerVideo::ToggleSubtitles()
+{
+	CLog::Log(LOGINFO, "CGstPlayerVideo::%s", __FUNCTION__ );
+}
+
+bool CGstPlayerVideo::CanSeek()
+{
+	if(m_pInputStream)
+		return false;
+	//CLog::Log(LOGINFO, "CGstPlayerVideo::%s: true",	__FUNCTION__ );
+	return true;
+}
+
+void CGstPlayerVideo::Seek(bool bPlus, bool bLargeStep, bool bChapterOverride)
+{
+	if(m_playbin)
+	{
+		CLog::Log(LOGINFO, "CGstPlayerVideo::%s: bPlus=%s bLargeStep=%s bChapterOverride=%s", __FUNCTION__, bPlus == false ? "off":"on" , bLargeStep == false ? "off":"on" , bChapterOverride == false ? "off":"on" ); 
+	}
+}
+
+void CGstPlayerVideo::SwitchToNextAudioLanguage()
+{
+	CLog::Log(LOGINFO, "CGstPlayerVideo::%s", __FUNCTION__ );
+}
+
+void CGstPlayerVideo::SeekPercentage(float iPercent)
+{
+	CLog::Log(LOGERROR, "CGstPlayerVideo::%s: iPercent=%f", __FUNCTION__, iPercent);
+	
+	if(m_playbin)
+	{
+		
+		gint64 position;
+	
+		if (!gst_element_query_position (GST_ELEMENT(m_playbin), GST_FORMAT_TIME, &position))
+		{
+			CLog::Log(LOGERROR, "CGstPlayerVideo::%s: Position query failed...", __FUNCTION__);
+			
+			return;
+		}
+		/* no position, seek to 1 second, this could EOS */
+		if (position == -1)
+		{
+			CLog::Log(LOGINFO, "CGstPlayerVideo::%s: position=-1", __FUNCTION__);
+			
+			return;
+		}
+
+
+		int val = (int) GetTotalTime() * iPercent;
+		
+		CLog::Log(LOGINFO, "CGstPlayerVideo::%s: iPercent=%f seek to %d milliseconds", __FUNCTION__, iPercent, val);
+
+		if(val<0)
+			return;
+
+		GstClockTime nanoSec = (GstClockTime) (val * GST_MSECOND);
+		if (!gst_element_seek(m_playbin, 1.0, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH, GST_SEEK_TYPE_SET, nanoSec, GST_SEEK_TYPE_NONE, GST_CLOCK_TIME_NONE))
+			CLog::Log(LOGERROR, "CGstPlayerVideo::%s: seek", __FUNCTION__ );
+		//else:
+		//	m_callback.OnPlayBackSeek((int)abstime, iTime);
+	}
+}
+
+void CGstPlayerVideo::SetAVDelay(float fValue)
+{
+	CLog::Log(LOGINFO, "CGstPlayerVideo::%s", __FUNCTION__ );
+}
+
+float CGstPlayerVideo::GetAVDelay()
+{
+	//CLog::Log(LOGINFO, "CGstPlayerVideo::%s", __FUNCTION__ );
+	return 0.0f;
+}
+
+void CGstPlayerVideo::SetSubTitleDelay(float fValue)
+{
+	CLog::Log(LOGINFO, "CGstPlayerVideo::%s", __FUNCTION__ );
+}
+
+float CGstPlayerVideo::GetSubTitleDelay()
+{
+	//CLog::Log(LOGINFO, "CGstPlayerVideo::%s", __FUNCTION__ );
+	return 0.0f;
+}
+
+void CGstPlayerVideo::SeekTime(int64_t iTime)
+{
+	int seekOffset = (int)(iTime - GetTime());
+	
+	CLog::Log(LOGINFO, "CGstPlayerVideo::%s: seekOffset=%d", __FUNCTION__, seekOffset);
+	CLog::Log(LOGINFO, "CGstPlayerVideo::%s: iTime=%d", __FUNCTION__, iTime);
+	CLog::Log(LOGINFO, "CGstPlayerVideo::%s: GetTime()=%d", __FUNCTION__, GetTime());
+	
+	printf("CGstPlayerVideo::%s: seekOffset=%d", __FUNCTION__, seekOffset);
+	printf("CGstPlayerVideo::%s: iTime=%d", __FUNCTION__, iTime);
+	printf("CGstPlayerVideo::%s: GetTime()=%d", __FUNCTION__, GetTime());
+	
+	if (seekOffset >= 0)
+	{
+		GstClockTime nanoSec = (GstClockTime) ((int)seekOffset * GST_MSECOND);
+		if (!gst_element_seek(m_playbin, 1.0, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH, GST_SEEK_TYPE_SET, nanoSec, GST_SEEK_TYPE_NONE, GST_CLOCK_TIME_NONE))
+			CLog::Log(LOGERROR, "CGstPlayerVideo::%s: seek", __FUNCTION__ );
+	}
+}
+
+bool CGstPlayerVideo::SeekTimeRelative(int64_t iTime)
+{
+	int64_t abstime = GetTime() + iTime;
+	
+	CLog::Log(LOGINFO, "CGstPlayerVideo::%s: abstime=%d", __FUNCTION__, abstime);
+	CLog::Log(LOGINFO, "CGstPlayerVideo::%s: iTime=%d", __FUNCTION__, iTime);
+	CLog::Log(LOGINFO, "CGstPlayerVideo::%s: GetTime()=%d", __FUNCTION__, GetTime());
+	printf("CGstPlayerVideo::%s: abstime=%d", __FUNCTION__, abstime);
+	printf("CGstPlayerVideo::%s: iTime=%d", __FUNCTION__, iTime);
+	printf("CGstPlayerVideo::%s: GetTime()=%d", __FUNCTION__, GetTime());
+	
+	if (abstime >= 0)
+	{
+		GstClockTime nanoSec = (GstClockTime) ((int)abstime * GST_MSECOND);
+		if (!gst_element_seek(m_playbin, 1.0, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH, GST_SEEK_TYPE_SET, nanoSec, GST_SEEK_TYPE_NONE, GST_CLOCK_TIME_NONE))
+			CLog::Log(LOGERROR, "CGstPlayerVideo::%s: seek", __FUNCTION__ );
+
+		CLog::Log(LOGINFO, "CGstPlayerVideo::%s: abstime=%d", __FUNCTION__, abstime);
+	}
+	
+	return true;
+}
+
+int64_t CGstPlayerVideo::GetTime() // in milliseconds
+{
+	GstState currentState;
+	gst_element_get_state(GST_ELEMENT(m_playbin), &currentState, 0, 0);
+	int time=1000;
+
+	if (currentState == GST_STATE_PLAYING)
+	{
+		gint64 position;
+	
+		if (!gst_element_query_position (GST_ELEMENT(m_playbin), GST_FORMAT_TIME, &position))
+		{
+			time = (int64_t) 1000;
+			CLog::Log(LOGERROR, "CGstPlayerVideo::%s: Position query failed...", __FUNCTION__);
+		}
+		/* no position, seek to 1 second, this could EOS */
+		if (position == -1)
+		{
+			time = (int64_t) 1000;
+			CLog::Log(LOGINFO, "CGstPlayerVideo::%s: milliseconds=1000 position=-1", __FUNCTION__);
+		}
+		else
+		{
+			time = (int64_t) GST_TIME_AS_MSECONDS(position);
+		}
+		
+		if(m_pInputStream)
+		{
+			m_time = (int64_t) (((GetTotalTime() * 1000) / m_length) * m_offset) / 1000;
+			CLog::Log(LOGINFO, "CGstPlayerVideo::%s: (appsrc) m_offset=%d m_length=%d m_pInputStream->GetLength()=%d", __FUNCTION__, (int) m_offset, (int) m_length, m_pInputStream->GetLength());
+		return m_time;
+		}
+	}
+	if (time>1000)
+		m_time = time;	
+	return m_time;
+
+}
+
+int64_t CGstPlayerVideo::GetTotalTime() // in milliseconds
+{
+	GstState currentState;
+	gst_element_get_state(GST_ELEMENT(m_playbin), &currentState, 0, 0);
+	int time = 1;
+
+	if (currentState == GST_STATE_PLAYING)
+	{
+		gint64 duration = 0;
+	
+		if (!gst_element_query_duration(GST_ELEMENT(m_playbin), GST_FORMAT_TIME, &duration))
+		{
+			CLog::Log(LOGERROR, "CGstPlayerVideo::%s: Time duration query failed", __FUNCTION__);
+		
+			time = 1;
+		}
+		else
+		{
+			/* no duration, seek to 1 second, this could EOS */
+			if (duration != -1)
+				time = GST_TIME_AS_MSECONDS(duration)/1000;
+			else
+				time = 1;
+		}
+	}
+	if (time>1)
+		m_totalTime = time;
+	return (int64_t) m_totalTime * 1000;
+}
+
+std::string CGstPlayerVideo::GetPlayerState()
+{
+	CLog::Log(LOGINFO, "CGstPlayerVideo::%s", __FUNCTION__);
+	
+	return "";
+}
+
+void CGstPlayerVideo::OnPipelineStart()
+{
+	gint i, n;
+	GstTagList *tags;
+	gchar *str;
+	guint rate;
+
+	g_object_get (m_playbin, "n-video", &m_video, NULL);
+	g_object_get (m_playbin, "n-audio", &m_audio, NULL);
+	g_object_get (m_playbin, "n-text", &m_text, NULL);
+	
+	//m_processInfo.SetAudioChannels(m_audio);
+	//m_processInfo.SetAudioSampleRate(GST_TAG_NOMINAL_BITRATE)
+	
+	CLog::Log(LOGINFO, "CGstPlayerVideo::%s: %d video stream(s), %d audio stream(s), %d text stream(s)", 
+		 __FUNCTION__,
+		(int)m_video,
+		(int)m_audio,
+		(int)m_text);
+	
+	for (i = 0; i < m_video; i++) {
+		tags = NULL;
+		/* Retrieve the stream's video tags */
+		g_signal_emit_by_name (m_playbin, "get-video-tags", i, &tags);
+		if (tags) {
+			gst_tag_list_get_string (tags, GST_TAG_VIDEO_CODEC, &str);
+			CLog::Log(LOGINFO, "CGstPlayerVideo::%s: video stream: %d codec: %s", 
+				__FUNCTION__,
+				(int)i,
+				(char *) str ? str : "unknown");
+			g_free (str);
+			gst_tag_list_free (tags);
+		}
+	}
+	
+	for (i = 0; i < m_audio; i++) {
+		tags = NULL;
+		/* Retrieve the stream's audio tags */
+		g_signal_emit_by_name (m_playbin, "get-audio-tags", i, &tags);
+		if (tags) {
+			CLog::Log(LOGINFO, "CGstPlayerVideo::%s: audio stream: %d", 
+				__FUNCTION__,
+				(int)i);
+			if (gst_tag_list_get_string (tags, GST_TAG_AUDIO_CODEC, &str)) {
+				CLog::Log(LOGINFO, "	codec: %s", (char *)str);
+				g_free (str);
+			}
+			if (gst_tag_list_get_string (tags, GST_TAG_LANGUAGE_CODE, &str)) {
+				CLog::Log(LOGINFO, "	language: %s  - %s", g_LangCodeExpander.ConvertToISO6392B((char *)str), (char *)str);
+				const std::shared_ptr<CSettings> settings = CServiceBroker::GetSettingsComponent()->GetSettings();
+				if (!StringUtils::EqualsNoCase(settings->GetString(CSettings::SETTING_LOCALE_AUDIOLANGUAGE), "mediadefault"))
+				{
+					if (!StringUtils::EqualsNoCase(settings->GetString(CSettings::SETTING_LOCALE_AUDIOLANGUAGE), "original"))
+					{
+						std::string audio_language = g_langInfo.GetAudioLanguage();
+						if (g_LangCodeExpander.CompareISO639Codes(audio_language, g_LangCodeExpander.ConvertToISO6392B((char *)str)))
+						{
+							g_object_set (GST_ELEMENT(m_playbin), "current-audio", i, NULL);
+							m_current_audio = i;
+						}
+					}
+				}
+				g_free (str);
+			}
+			if (gst_tag_list_get_uint (tags, GST_TAG_BITRATE, &rate)) {
+				CLog::Log(LOGINFO, "	bitrate: %d", (int)rate);
+			}
+			gst_tag_list_free (tags);
+		}
+	}
+	
+	for (i = 0; i < m_text; i++) {
+		tags = NULL;
+		/* Retrieve the stream's subtitle tags */
+		g_signal_emit_by_name (m_playbin, "get-text-tags", i, &tags);
+		if (tags) {
+			CLog::Log(LOGINFO, "CGstPlayerVideo::%s: subtitle stream: %d", 
+				__FUNCTION__,
+				(int)i);
+
+			if (gst_tag_list_get_string (tags, GST_TAG_LANGUAGE_CODE, &str)) {
+				CLog::Log(LOGINFO, "	language: %s", (char *)str);
+				g_free (str);
+			}
+			if (gst_tag_list_get_string (tags, GST_TAG_CODEC, &str)) {
+				CLog::Log(LOGINFO, "	Codec: %s", (char *)str);
+				g_free (str);
+			}
+			gst_tag_list_free (tags);
+		}
+		if (subsink)
+		{
+//			m_subs_to_pull_handler_id = g_signal_connect (subsink, "new-buffer", G_CALLBACK (gstCBsubtitleAvail), this);
+			g_object_set (subsink, "caps", gst_caps_from_string("text/plain; text/x-plain; text/x-raw; text/x-pango-markup; subpicture/x-dvd; subpicture/x-pgs"), NULL);
+			g_object_set (m_playbin, "text-sink", subsink, NULL);
+			g_object_set (m_playbin, "current-text", m_current_text, NULL);
+			g_object_set (subsink, "sync", FALSE, NULL);
+		}
+
+
+/*		GstPad* pad = 0;
+		g_signal_emit_by_name (m_playbin, "get-text-pad", i, &pad);
+		GstCaps* caps = gst_pad_get_current_caps(pad);
+		gst_object_unref(pad);
+		for (i = 0; i < gst_caps_get_size (caps); i++) {
+			GstStructure *structure = gst_caps_get_structure (caps, i);
+
+			CLog::Log(LOGINFO,"     %s", (char *)gst_structure_get_name (structure));
+			gst_structure_foreach (structure, print_field, this);
+		}
+		gst_caps_unref(caps);*/
+	}
+	
+	g_object_get (m_playbin, "current-video", &m_current_video, NULL);
+	g_object_get (m_playbin, "current-audio", &m_current_audio, NULL);
+	g_object_get (m_playbin, "current-text", &m_current_text, NULL);
+	
+	CLog::Log(LOGINFO, "CGstPlayerVideo::%s: current video stream: %d, current audio stream: %d, current text stream: %d", 
+		 __FUNCTION__,
+		(int)m_current_video,
+		(int)m_current_audio,
+		(int)m_current_text);
+
+	CServiceBroker::GetDataCacheCore().SignalAudioInfoChange();
+	CServiceBroker::GetDataCacheCore().SignalVideoInfoChange();
+	CServiceBroker::GetDataCacheCore().SignalSubtitleInfoChange();
+	CDataCacheCore::GetInstance().SetPlayTimes(0, GetTime(), 0, GetTotalTime());
+
+}
+
+gboolean CGstPlayerVideo::print_field (GQuark field, const GValue * value, gpointer user_data) {
+  gchar *str = gst_value_serialize (value);
+
+  CLog::Log(LOGINFO, "       %15s: %s\n", (char *)g_quark_to_string (field), (char *)str);
+  g_free (str);
+  return TRUE;
+}
+
+float CGstPlayerVideo::GetRenderAspectRatio()
+{
+	CLog::Log(LOGINFO, "%s: m_aspect: %d.0f", __FUNCTION__, (int)m_aspect); 
+	return (float) (1.0f * (int)m_aspect);
+	
+}
+
+void CGstPlayerVideo::NotifySource(GObject *object, GParamSpec *unused, gpointer user_data)
+{
+	GstElement *source = NULL;
+	CGstPlayerVideo *_this = (CGstPlayerVideo*)user_data;
+	g_object_get(object, "source", &source, NULL);
+	if (source)
+	{
+		if (g_object_class_find_property(G_OBJECT_GET_CLASS(source), "timeout") != 0)
+		{
+			GstElementFactory *factory = gst_element_get_factory(source);
+			if (factory)
+			{
+				const gchar *sourcename = gst_plugin_feature_get_name(GST_PLUGIN_FEATURE(factory));
+				if (!strcmp(sourcename, "souphttpsrc"))
+				{
+					g_object_set(G_OBJECT(source), "timeout", HTTP_TIMEOUT, NULL);
+				}
+			}
+		}
+		if (g_object_class_find_property(G_OBJECT_GET_CLASS(source), "ssl-strict") != 0)
+		{
+			g_object_set(G_OBJECT(source), "ssl-strict", FALSE, NULL);
+		}
+		if (g_object_class_find_property(G_OBJECT_GET_CLASS(source), "user-agent") != 0 && !_this->m_useragent.empty())
+		{
+			g_object_set(G_OBJECT(source), "user-agent", _this->m_useragent.c_str(), NULL);
+		}
+		if (g_object_class_find_property(G_OBJECT_GET_CLASS(source), "extra-headers") != 0 && !_this->m_extra_headers.empty())
+		{
+			GstStructure *extras = gst_structure_new_empty("extras");
+			size_t pos = 0;
+			while (pos != std::string::npos)
+			{
+				std::string name, value;
+				size_t start = pos;
+				size_t len = std::string::npos;
+				pos = _this->m_extra_headers.find('=', pos);
+				if (pos != std::string::npos)
+				{
+					len = pos - start;
+					pos++;
+					name = _this->m_extra_headers.substr(start, len);
+					start = pos;
+					len = std::string::npos;
+					pos = _this->m_extra_headers.find('&', pos);
+					if (pos != std::string::npos)
+					{
+						len = pos - start;
+						pos++;
+					}
+					value = _this->m_extra_headers.substr(start, len);
+				}
+				if (!name.empty() && !value.empty())
+				{
+					GValue header;
+					CLog::Log(LOGINFO, "CGstPlayerVideo::%s: setting extra-header '%s:%s'",
+						  __FUNCTION__, 
+						name.c_str(), 
+						value.c_str());
+					memset(&header, 0, sizeof(GValue));
+					g_value_init(&header, G_TYPE_STRING);
+					g_value_set_string(&header, value.c_str());
+					gst_structure_set_value(extras, name.c_str(), &header);
+				}
+				else
+				{
+					CLog::Log(LOGINFO, "CGstPlayerVideo::%s: Invalid header format %s",
+								__FUNCTION__,
+								_this->m_extra_headers.c_str());
+					break;
+				}
+			}
+			if (gst_structure_n_fields(extras) > 0)
+			{
+				g_object_set(G_OBJECT(source), "extra-headers", extras, NULL);
+			}
+			gst_structure_free(extras);
+		}
+		gst_object_unref(source);
+	}
+}
+
+
+void CGstPlayerVideo::DeepNotifySource(GObject *object, GObject *orig, GParamSpec *pspec, gpointer user_data)
+{
+	CGstPlayerVideo *_this = (CGstPlayerVideo*)user_data;
+	
+	g_object_get (orig, pspec->name, &_this->m_appsrc, NULL);
+	printf("CGstPlayerVideo::%s: appsrc %p\n", __FUNCTION__, _this->m_appsrc);
+
+	g_object_set (_this->m_appsrc, "size", (gint64) _this->m_length, NULL);
+
+	gst_util_set_object_arg (G_OBJECT (_this->m_appsrc), "do-timestamp", "true");
+	//gst_util_set_object_arg (G_OBJECT (_this->m_appsrc), "format", "time");
+	gst_util_set_object_arg (G_OBJECT (_this->m_appsrc), "stream-type", "seekable");
+	
+	g_signal_connect (_this->m_appsrc, "need-data", G_CALLBACK (startFeed), user_data);
+	g_signal_connect (_this->m_appsrc, "seek-data", G_CALLBACK (seekData), user_data);
+	g_signal_connect (_this->m_appsrc, "enough-data", G_CALLBACK (stopFeed), user_data);
+}
+
+void CGstPlayerVideo::startFeed(GstElement * playbin, guint size, gpointer user_data)
+{
+	printf("CGstPlayerVideo::%s:", __FUNCTION__);
+	CGstPlayerVideo *_this = (CGstPlayerVideo*)user_data;
+	
+	if (_this->m_notify_source_id == 0)
+	{
+		_this->m_notify_source_id = g_idle_add ((GSourceFunc) readData, user_data);
+	}
+}
+
+/* This callback is called when appsrc has enough data and we can stop sending.
+ * We remove the idle handler from the mainloop */
+void CGstPlayerVideo::stopFeed(GstElement * playbin, gpointer user_data)
+{
+	printf("CGstPlayerVideo::%s:", __FUNCTION__);
+	CGstPlayerVideo *_this = (CGstPlayerVideo*)user_data;
+	
+	if (_this->m_notify_source_id != 0)
+	{
+		g_source_remove (_this->m_notify_source_id);
+		_this->m_notify_source_id = 0;
+	}
+}
+
+gboolean CGstPlayerVideo::seekData(GstElement * appsrc, guint64 position, gpointer user_data)
+{
+	CGstPlayerVideo *_this = (CGstPlayerVideo*)user_data;
+	
+	printf("CGstPlayerVideo::seekData: offset=%" G_GUINT64_FORMAT " m_offset=%d m_length=%d", position, _this->m_offset, _this->m_length);
+	CLog::Log(LOGINFO, "CGstPlayerVideo::seekData: offset=%" G_GUINT64_FORMAT " m_offset=%d m_length=%d", position, _this->m_offset, _this->m_length);
+	_this->m_offset = position;
+
+	return TRUE;
+}
+
+gboolean CGstPlayerVideo::readData(gpointer user_data)
+{
+	printf("CGstPlayerVideo::%s:", __FUNCTION__);
+	CGstPlayerVideo *_this = (CGstPlayerVideo*)user_data;
+	
+	GstMapInfo map;
+	GstBuffer *buffer = NULL;
+	guint len;
+	GstFlowReturn ret;
+
+	if (_this->m_offset >= _this->m_length) {
+		/* we are EOS, send end-of-stream and remove the source */
+		CLog::Log(LOGINFO, "CGstPlayerVideo::%s: end-of-stream", __FUNCTION__);
+		g_signal_emit_by_name (_this->m_appsrc, "end-of-stream", &ret);
+		return FALSE;
+	}
+
+	len = CHUNK_SIZE;
+	if (_this->m_offset + len > _this->m_length)
+		len = _this->m_length - _this->m_offset;
+	
+	/* read the next chunk */
+	buffer = gst_buffer_new_allocate(NULL, len, NULL);
+			
+	gst_buffer_map (buffer, &map, GST_MAP_WRITE);
+	
+	_this->m_pInputStream->Seek(_this->m_offset, SEEK_SET);
+	_this->m_pInputStream->Read(map.data, len);
+
+	printf("CGstPlayerVideo::%s:feed buffer %p, offset %" G_GUINT64_FORMAT "-%u", __FUNCTION__, buffer, _this->m_offset, len);
+	g_signal_emit_by_name (_this->m_appsrc, "push-buffer", buffer, &ret);
+	gst_buffer_unmap(buffer, &map);
+	if (ret != GST_FLOW_OK) {
+		/* some error, stop sending data */
+		return FALSE;
+	}
+
+	_this->m_offset += len;
+
+	return TRUE;
+}
+
+void CGstPlayerVideo::handleElementAdded(GstBin *bin, GstElement *element, gpointer user_data)
+{
+	CGstPlayerVideo *_this = (CGstPlayerVideo*)user_data;
+	if (_this)
+	{
+		gchar *elementname = gst_element_get_name(element);
+
+		if (g_str_has_prefix(elementname, "queue2"))
+		{
+			if (_this->m_download_buffer_path != "")
+			{
+				g_object_set(G_OBJECT(element), "temp-template", _this->m_download_buffer_path.c_str(), NULL);
+			}
+			else
+			{
+				g_object_set(G_OBJECT(element), "temp-template", NULL, NULL);
+			}
+		}
+		else if (g_str_has_prefix(elementname, "uridecodebin")
+			|| g_str_has_prefix(elementname, "decodebin"))
+		{
+			/*
+			 * Listen for queue2 element added to uridecodebin/decodebin2 as well.
+			 * Ignore other bins since they may have unrelated queues
+			 */
+			g_signal_connect(element, "element-added", G_CALLBACK(handleElementAdded), user_data);
+		}
+		g_free(elementname);
+	}
+}
+
+GstBusSyncReply CGstPlayerVideo::gstBusSyncHandler(GstBus *bus, GstMessage *msg, gpointer data)
+{
+	CGstPlayerVideo *_this = (CGstPlayerVideo *)data;
+	
+	if (_this) _this->handleMessage(msg);
+	
+	return GST_BUS_DROP;
+}
+
+void CGstPlayerVideo::SetAudioStream(int iStream)
+{
+	if (iStream != m_current_audio and iStream < m_audio)
+	{
+		SeekTimeRelative(-1000);
+		g_object_set (GST_ELEMENT(m_playbin), "current-audio", iStream, NULL);
+		int current_audio;
+		g_object_get (GST_ELEMENT(m_playbin), "current-audio", &current_audio, NULL);
+		if (current_audio == iStream)
+		{
+			CLog::Log(LOGINFO, "CGstPlayerVideo::%s switch to audio %s",__FUNCTION__,iStream);
+			m_current_audio = iStream;
+			CFileItem fileItem(m_item);
+			CServiceBroker::GetDataCacheCore().SignalAudioInfoChange();
+			CServiceBroker::GetDataCacheCore().SignalVideoInfoChange();
+		}
+	}
+}
+
+
+void CGstPlayerVideo::GetVideoStreamInfo(int index, VideoStreamInfo &info)
+{
+	if (index<0)
+		index = m_current_video;
+	GstTagList *tags=NULL;
+	g_signal_emit_by_name (m_playbin, "get-video-tags", index, &tags);
+	if (tags) {
+		gchar *str;
+		gst_tag_list_get_string (tags, GST_TAG_VIDEO_CODEC, &str);
+		info.codecName = (char *)str;
+		g_free (str);
+		gst_tag_list_free (tags);
+	}
+ 	info.valid = true;
+	GstPad* pad = 0;
+	g_signal_emit_by_name (m_playbin, "get-video-pad", index, &pad);
+	GstCaps* caps = gst_pad_get_current_caps(pad);
+	gst_object_unref(pad);
+	GstStructure* str = gst_caps_get_structure(caps, 0);
+	gint width = 0;
+	gint height = 0;
+	gst_structure_get_int (str, "width", &width);
+	gst_structure_get_int (str, "height", &height);
+	info.width = (int) width;
+	info.height = (int) height;
+}
+
+void CGstPlayerVideo::GetAudioStreamInfo(int index, AudioStreamInfo &info)
+{
+	if (index<0)
+		index = m_current_audio;
+	GstTagList *tags=NULL;
+	g_signal_emit_by_name (m_playbin, "get-audio-tags", index, &tags);
+	if (tags) {
+		gchar *str;
+		guint rate;
+		if (gst_tag_list_get_string (tags, GST_TAG_AUDIO_CODEC, &str)) {
+			info.codecName = (char *)str;
+			info.name = (char *)str;
+			g_free (str);
+		}
+		if (gst_tag_list_get_string (tags, GST_TAG_LANGUAGE_CODE, &str)) {
+			info.language = g_LangCodeExpander.ConvertToISO6392B((char *)str);
+			g_free (str);
+		}
+		if (gst_tag_list_get_uint (tags, GST_TAG_BITRATE, &rate)) {
+			info.bitrate = (int)rate;
+		}
+		gst_tag_list_free (tags);
+	}
+	GstPad* pad = 0;
+	g_signal_emit_by_name (m_playbin, "get-audio-pad", index, &pad);
+	GstCaps* caps = gst_pad_get_current_caps(pad);
+	gst_object_unref(pad);
+	GstStructure* str = gst_caps_get_structure(caps, 0);
+	gint ch = 0;
+	if (gst_structure_get_int (str, "channels", &ch)) {
+		CLog::Log(LOGINFO, "CGstPlayerVideo::audio: %d Channels: %d", index, (uint16_t) ch);
+		info.channels = (uint16_t) ch;
+		switch (info.channels)
+		{
+		case 2:
+			info.name += " 2.0";
+			break;
+		case 6:
+			info.name += " 5.1";
+			break;
+		case 8:
+			info.name += " 7.1";
+			break;
+		default:
+			break;
+		}
+	}
+	gst_caps_unref(caps);
+ 	info.valid = true;
+}
+
+void CGstPlayerVideo::GetSubtitleStreamInfo(int index, SubtitleStreamInfo &info)
+{
+	if (index<0)
+		index = m_current_text;
+	GstTagList *tags=NULL;
+	g_signal_emit_by_name (m_playbin, "get-text-tags", index, &tags);
+	if (tags) {
+		gchar *str;
+		if (gst_tag_list_get_string (tags, GST_TAG_LANGUAGE_CODE, &str)) {
+			info.language = g_LangCodeExpander.ConvertToISO6392B((char *)str);
+			g_free (str);
+		}
+		gst_tag_list_free (tags);
+	}
+ 	info.valid = true;
+}
+
+void CGstPlayerVideo::SetSubtitle(int iStream)
+{
+	if (iStream != m_current_text and iStream < m_text)
+	{
+		g_object_set (m_playbin, "current-text", -1, NULL);
+		m_current_text = iStream;
+		g_object_set (GST_ELEMENT(m_playbin), "current-text", iStream, NULL);
+		CLog::Log(LOGINFO, "CGstPlayerVideo::Set Subtitle track: %d", iStream);
+		CServiceBroker::GetDataCacheCore().SignalAudioInfoChange();
+		CServiceBroker::GetDataCacheCore().SignalVideoInfoChange();
+		CServiceBroker::GetDataCacheCore().SignalSubtitleInfoChange();
+
+	}
+}
+
+bool CGstPlayerVideo::GetSubtitleVisible()
+{
+	return m_is_sub_visible;
+}
+
+void CGstPlayerVideo::SetSubtitleVisible(bool bVisible)
+{
+	m_is_sub_visible = bVisible;
+	if (!bVisible)
+		g_object_set (m_playbin, "current-text", -1, NULL);
+	else
+		g_object_set (m_playbin, "current-text", m_current_text, NULL);
+}
+
+void CGstPlayerVideo::handleMessage(GstMessage *msg)
+{
+	if (!msg)
+		return;
+#if 0
+	gchar *sourceName;
+	GstObject *source;
+	source = GST_MESSAGE_SRC(msg);
+	if (!GST_IS_OBJECT(source))
+		return;
+	
+	sourceName = gst_object_get_name(source);
+#endif
+	GstState state, pending, old_state, new_state;
+	GstStateChangeReturn ret;
+	GstStateChange transition;
+	
+	switch (GST_MESSAGE_TYPE(msg))
+	{
+		case GST_MESSAGE_EOS:
+		{
+			g_print("CGstPlayerVideo::%s: End of stream\n", __FUNCTION__);
+			g_main_loop_quit(m_loop);
+			break;
+		}
+
+		case GST_MESSAGE_BUFFERING:
+		{
+			if (m_sourceinfo.is_streaming)
+			{
+				//GstBufferingMode mode;
+				gst_message_parse_buffering(msg, &(m_bufferInfo.bufferPercent));
+				// eDebug("[eServiceMP3] Buffering %u percent done", m_bufferInfo.bufferPercent);
+				//gst_message_parse_buffering_stats(msg, &mode, &(m_bufferInfo.avgInRate), &(m_bufferInfo.avgOutRate), &(m_bufferInfo.bufferingLeft));
+				//m_event((iPlayableService*)this, evBuffering);
+				/*
+				 * we don't react to buffer level messages, unless we are configured to use a prefill buffer
+				 * (even if we are not configured to, we still use the buffer, but we rely on it to remain at the
+				 * healthy level at all times, without ever having to pause the stream)
+				 *
+				 * Also, it does not make sense to pause the stream if it is a live stream
+				 * (in which case the sink will not produce data while paused, so we won't
+				 * recover from an empty buffer)
+				 */
+				if (m_use_prefillbuffer && !m_is_live && !m_sourceinfo.is_hls && --m_ignore_buffering_messages <= 0)
+				{
+					if (m_bufferInfo.bufferPercent == 100)
+					{
+						GstState state, pending;
+						/* avoid setting to play while still in async state change mode */
+						gst_element_get_state(m_playbin, &state, &pending, 5 * GST_SECOND);
+						if (state != GST_STATE_PLAYING && !m_first_paused)
+						{
+							g_print("CGstPlayerVideo::%s: *** PREFILL BUFFER action start playing *** pending state was %s", 
+								__FUNCTION__ , 
+								pending == GST_STATE_VOID_PENDING ? "NO_PENDING" : "A_PENDING_STATE" );
+							gst_element_set_state (m_playbin, GST_STATE_PLAYING);
+						}
+						/*
+						 * when we start the pipeline, the contents of the buffer will immediately drain
+						 * into the (hardware buffers of the) sinks, so we will receive low buffer level
+						 * messages right away.
+						 * Ignore the first few buffering messages, giving the buffer the chance to recover
+						 * a bit, before we start handling empty buffer states again.
+						 */
+						m_ignore_buffering_messages = 10;
+					}
+					else if (m_bufferInfo.bufferPercent == 0 && !m_first_paused)
+					{
+						g_print("CGstPlayerVideo::%s: *** PREFILLBUFFER action start pause ***", 
+							__FUNCTION__);
+						gst_element_set_state (m_playbin, GST_STATE_PAUSED);
+						m_ignore_buffering_messages = 0;
+					}
+					else
+					{
+						m_ignore_buffering_messages = 0;
+					}
+				}
+			}
+			break;
+		}
+#if 1
+		case GST_MESSAGE_STATE_CHANGED:
+		{
+			g_print("CGstPlayerVideo::%s: Message STATE_CHANGED\n", __FUNCTION__);
+			GstState old_state, new_state;
+			gst_message_parse_state_changed(msg, &old_state, &new_state, NULL);
+			
+			if (GST_MESSAGE_SRC (msg) == GST_OBJECT_CAST (m_playbin) && 
+				new_state == GST_STATE_PLAYING)
+			{
+				OnPipelineStart();
+				m_callback->OnPlaybackStarted(m_item);
+			}
+
+			g_print("CGstPlayerVideo::%s: Element %s changed state from %s to %s.\n", 
+				__FUNCTION__,
+				GST_OBJECT_NAME(msg->src),
+				gst_element_state_get_name (old_state),
+				gst_element_state_get_name (new_state));
+			break;
+		}
+#else
+		case GST_MESSAGE_STATE_CHANGED:
+		{
+			if(GST_MESSAGE_SRC(msg) != GST_OBJECT(m_playbin))
+				break;
+			
+			gst_message_parse_state_changed(msg, &old_state, &new_state, NULL);
+			
+			if(old_state == new_state)
+				break;
+			
+			g_print("CGstPlayerVideo::%s:  ****STATE TRANSITION %s -> %s ****\n",
+				__FUNCTION__,
+				gst_element_state_get_name(old_state), 
+				gst_element_state_get_name(new_state));
+			
+			transition = (GstStateChange)GST_STATE_TRANSITION(old_state, new_state);
+			
+			
+			g_print("CGstPlayerVideo::%s:  ****TRANSITION %d ****\n",
+				__FUNCTION__,
+				transition);
+			
+			switch(transition)
+			{
+				case GST_STATE_CHANGE_NULL_TO_READY:
+				{
+					g_print("CGstPlayerVideo::%s:  STATE IS: GST_STATE_CHANGE_NULL_TO_READY ****\n",
+						__FUNCTION__);
+
+				}	break;
+				
+				case GST_STATE_CHANGE_READY_TO_PAUSED:
+				{
+					g_print("CGstPlayerVideo::%s:  STATE IS: GST_STATE_CHANGE_READY_TO_PAUSED ****\n",
+						__FUNCTION__);
+				}	break;
+				
+				case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
+				{
+					g_print("CGstPlayerVideo::%s:  STATE IS: GST_STATE_CHANGE_PAUSED_TO_PLAYING ****\n",
+						__FUNCTION__);
+					m_paused = false;
+					if (!m_first_paused)
+					{
+						g_print("CGstPlayerVideo::%s: GST_STATE_CHANGE_PAUSED_TO_PLAYING !m_first_paused\n",
+						__FUNCTION__);
+					}
+					else
+					{
+						g_print("CGstPlayerVideo::%s: GST_STATE_CHANGE_PAUSED_TO_PLAYING m_first_paused\n",
+						__FUNCTION__);
+						OnPipelineStart();
+						m_callback->OnPlaybackStarted();
+					}
+					m_first_paused = false;
+				}	break;
+				
+				case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
+				{
+					m_paused = true;
+					g_print("CGstPlayerVideo::%s: GST_STATE_CHANGE_PLAYING_TO_PAUSED\n",
+						__FUNCTION__);
+				}	break;
+				
+				case GST_STATE_CHANGE_PAUSED_TO_READY:
+				{
+					g_print("CGstPlayerVideo::%s: GST_STATE_CHANGE_PAUSED_TO_READY\n",
+						__FUNCTION__);
+				}	break;
+				
+				case GST_STATE_CHANGE_READY_TO_NULL:
+				{
+					g_print("CGstPlayerVideo::%s: GST_STATE_CHANGE_READY_TO_NULL\n",
+						__FUNCTION__);
+				}	break;
+			}
+			break;
+		}
+#endif
+
+		case GST_MESSAGE_ELEMENT:
+		{
+			const GstStructure *msgstruct = gst_message_get_structure(msg);
+			if (msgstruct)
+			{
+				if ( gst_is_missing_plugin_message(msg) )
+				{
+					GstCaps *caps = NULL;
+					gst_structure_get (msgstruct, "detail", GST_TYPE_CAPS, &caps, NULL);
+					if (caps)
+					{
+						std::string codec = (const char*) gst_caps_to_string(caps);
+						gchar *description = gst_missing_plugin_message_get_description(msg);
+						if ( description )
+						{
+							CLog::Log(LOGERROR, "CGstPlayerVideo::%s: missing codec: %s",
+								__FUNCTION__,
+								codec.c_str());
+							CLog::Log(LOGERROR, "CGstPlayerVideo::%s: GStreamer plugin: %s not available!",
+								__FUNCTION__,
+								(const char*)description);
+							g_free(description);
+						}
+						gst_caps_unref(caps);
+					}
+				}
+				else
+				{
+					const gchar *eventname = gst_structure_get_name(msgstruct);
+					if ( eventname )
+					{
+						if (!strcmp(eventname, "eventSizeChanged") || !strcmp(eventname, "eventSizeAvail"))
+						{
+							gst_structure_get_int (msgstruct, "aspect_ratio", &m_aspect);
+							gst_structure_get_int (msgstruct, "width", &m_width);
+							gst_structure_get_int (msgstruct, "height", &m_height);
+							if (strstr(eventname, "Changed"))
+							{
+								m_processInfo.SetVideoDimensions((int)m_width, (int)m_height);
+							}
+						}
+						else if (!strcmp(eventname, "eventFrameRateChanged") || !strcmp(eventname, "eventFrameRateAvail"))
+						{
+							gst_structure_get_int (msgstruct, "frame_rate", &m_framerate);
+							if (strstr(eventname, "Changed"))
+								m_processInfo.SetVideoFps((float)m_framerate * 1.0f);
+						}
+						else if (!strcmp(eventname, "eventProgressiveChanged") || !strcmp(eventname, "eventProgressiveAvail"))
+						{
+							gst_structure_get_int (msgstruct, "progressive", &m_progressive);
+							//if (strstr(eventname, "Changed"))
+								//m_processInfo.SetVideoDeintMethod("progressive: %d", (int)m_progressive);
+						}
+						else if (!strcmp(eventname, "redirect"))
+						{
+							const char *uri = gst_structure_get_string(msgstruct, "new-location");
+							CLog::Log(LOGINFO, "CGstPlayerVideo::%s redirect to %s",
+								__FUNCTION__,
+								uri);
+							gst_element_set_state (m_playbin, GST_STATE_NULL);
+							g_object_set(m_playbin, "uri", uri, NULL);
+							gst_element_set_state (m_playbin, GST_STATE_PLAYING);
+						}
+					}
+				}
+			}
+			break;
+		}
+
+		case GST_MESSAGE_ERROR:
+		{
+			GError *err;
+			gst_message_parse_error (msg, &err, NULL);
+			if(err)
+			{
+				g_printerr ("CGstPlayerVideo::%s: Error - %s\n", __FUNCTION__, err->message);
+				g_error_free (err);
+				g_main_loop_quit(m_loop);
+			}
+			break;
+		}
+		
+		case GST_MESSAGE_TAG:
+		{
+			GstTagList *tags;
+			gst_message_parse_tag(msg, &tags);
+			
+			if(tags)
+			{
+				gchar *value;
+				if(gst_tag_list_get_string(tags, GST_TAG_TITLE, &value))
+				{
+					g_print("CGstPlayerVideo::%s: Info - %s\n", __FUNCTION__, value);
+					g_free(value);
+				}
+				gst_tag_list_free(tags);
+			}
+			break;
+		}
+			
+		default:
+			g_print("CGstPlayerVideo::%s: %" GST_PTR_FORMAT"\n", __FUNCTION__, msg);
+			break;
+	}
+	//g_free (sourceName);
+}
+
diff --git a/xbmc/cores/GstPlayer/GstPlayerVideo.h b/xbmc/cores/GstPlayer/GstPlayerVideo.h
new file mode 100644
index 00000000000..4e2a42b1043
--- /dev/null
+++ b/xbmc/cores/GstPlayer/GstPlayerVideo.h
@@ -0,0 +1,181 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2015 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with Kodi; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <string>
+#include <vector>
+#include <gst/gst.h>
+#include <gst/app/gstappsrc.h>
+
+#include "GstPlayerAudio.h"
+#include "utils/log.h"
+#include "cores/IPlayer.h"
+#include "GstPlayer.h"
+#include "cores/VideoPlayer/Process/ProcessInfo.h"
+//#include "cores/VideoPlayer/DVDInputStreams/DVDInputStreamMemory.h"
+#include "cores/VideoPlayer/DVDInputStreams/DVDInputStreamFile.h"
+#include "cores/VideoPlayer/DVDInputStreams/DVDInputStream.h"
+
+#include "DVDStreamInfo.h"
+//#include "DVDMessageQueue.h"
+
+#undef FALSE
+#define FALSE 0
+
+class CProcessInfo;
+class IGstPlayerCallback;
+
+typedef enum {
+	GST_PLAY_FLAG_VIDEO		= (1 << 0),
+	GST_PLAY_FLAG_AUDIO		= (1 << 1),
+	GST_PLAY_FLAG_TEXT		= (1 << 2),
+	GST_PLAY_FLAG_VIS		= (1 << 3),
+	GST_PLAY_FLAG_SOFT_VOLUME	= (1 << 4),
+	GST_PLAY_FLAG_NATIVE_AUDIO	= (1 << 5),
+	GST_PLAY_FLAG_NATIVE_VIDEO	= (1 << 6),
+	GST_PLAY_FLAG_DOWNLOAD		= (1 << 7),
+	GST_PLAY_FLAG_BUFFERING		= (1 << 8),
+	GST_PLAY_FLAG_DEINTERLACE	= (1 << 9)
+} GstPlayFlags;
+
+class CGstPlayerVideo
+{
+public:
+	CGstPlayerVideo(IGstPlayerCallback *callback, CProcessInfo &processInfo);
+	~CGstPlayerVideo();
+	bool OpenStream(CDVDStreamInfo &hints, const CFileItem& file);
+	void CloseStream();
+	void Pause();
+	void SwitchToNextLanguage();
+	void ToggleSubtitles();
+	bool CanSeek();
+	void Seek(bool bPlus, bool bLargeStep, bool bChapterOverride);
+	void SwitchToNextAudioLanguage();
+	void SeekPercentage(float iPercent);
+	void SetAVDelay(float fValue);
+	float GetAVDelay();
+	void SetSubTitleDelay(float fValue);
+	float GetSubTitleDelay();
+	void SeekTime(int64_t iTime);
+	bool SeekTimeRelative(int64_t iTime);
+	int64_t GetTime();
+	int64_t GetTotalTime();
+	std::string GetPlayerState();
+	float GetRenderAspectRatio();
+	
+	int GetAudioStreamCount() { CLog::Log(LOGINFO, "%s: m_audio: %d", __FUNCTION__, m_audio); return (int)m_audio; };
+	int GetVideoStreamCount() { CLog::Log(LOGINFO, "%s: m_video: %d", __FUNCTION__, m_video); return (int)m_video; };
+	int GetSubtitleCount()    { CLog::Log(LOGINFO, "%s: m_text: %d", __FUNCTION__, m_text); return (int)m_text; };
+	
+	int GetAudioStream() { CLog::Log(LOGINFO, "%s: m_current_audio: %d", __FUNCTION__, m_current_audio); return (int)m_current_audio; };
+	int GetVideoStream() { CLog::Log(LOGINFO, "%s: m_current_video: %d", __FUNCTION__, m_current_video); return (int)m_current_video; };
+	int GetSubtitle()    { CLog::Log(LOGINFO, "%s: m_current_text: %d", __FUNCTION__, m_current_text); return (int)m_current_text; };
+
+	void GetAudioStreamInfo(int index, AudioStreamInfo &info);
+	void SetAudioStream(int iStream);
+
+	void GetVideoStreamInfo(int index, VideoStreamInfo &info);
+
+	void GetSubtitleStreamInfo(int index, SubtitleStreamInfo &info);
+  	void SetSubtitle(int iStream);
+  	bool GetSubtitleVisible();
+  	void SetSubtitleVisible(bool bVisible);
+	
+	struct sourceStream
+	{
+//		audiotype_t audiotype;
+//		containertype_t containertype;
+		gboolean is_audio;
+		gboolean is_video;
+		gboolean is_streaming;
+		gboolean is_hls;
+		sourceStream()
+			: /*audiotype(atUnknown), containertype(ctNone), */is_audio(FALSE), is_video(FALSE), is_streaming(FALSE), is_hls(FALSE)
+		{
+		}
+	};
+	
+	struct bufferInfo
+	{
+		gint bufferPercent;
+		gint avgInRate;
+		gint avgOutRate;
+		gint64 bufferingLeft;
+		bufferInfo()
+			:bufferPercent(0), avgInRate(0), avgOutRate(0), bufferingLeft(-1)
+		{
+		}
+	};
+	
+private:
+	bool CreateFakePipeline();
+	bool CreatePipeline();
+	void DestroyPipeline();
+	
+	static gboolean print_field (GQuark field, const GValue * value, gpointer user_data);
+	static void handleElementAdded(GstBin *bin, GstElement *element, gpointer user_data);
+	static void NotifySource(GObject *object, GParamSpec *unused, gpointer user_data);
+	static void DeepNotifySource(GObject *object, GObject *orig, GParamSpec *pspec, gpointer user_data);
+	static void stopFeed(GstElement * playbin, gpointer user_data);
+	static void startFeed(GstElement * playbin, guint size, gpointer user_data);
+	static gboolean readData(gpointer user_data); 
+	static gboolean seekData(GstElement * appsrc, guint64 position, gpointer user_data);
+	static GstBusSyncReply gstBusSyncHandler(GstBus *bus, GstMessage *msg, gpointer data);
+	void handleMessage(GstMessage *msg);
+	void OnPipelineStart();
+	
+	int m_totalTime;
+	int m_time;
+	int m_playCountMinTime;
+	int m_buffer_size;
+	int m_ignore_buffering_messages;
+	
+	bufferInfo m_bufferInfo;
+	sourceStream m_sourceinfo;
+	
+	std::string m_useragent;
+	std::string m_extra_headers;
+	std::string m_download_buffer_path;
+	
+	bool m_use_prefillbuffer;
+	bool m_is_live;
+	bool m_first_paused;
+	bool m_paused;
+	bool m_is_sub_visible;
+	
+	IGstPlayerCallback *m_callback;
+
+	gchar *m_uri;
+	GMainLoop *m_loop;
+	GstElement *m_playbin, *m_appsrc, *subsink;
+	gint m_aspect, m_width, m_height, m_framerate, m_progressive, m_video, m_audio, m_text, m_current_video, m_current_audio, m_current_text;
+	gulong m_notify_source_handler_id;
+	guint m_notify_element_added_handler_id, m_notify_source_id;
+	gsize m_length;
+	
+	guint64 m_offset;
+	
+protected:
+	CFileItem m_item;
+	CProcessInfo &m_processInfo;
+	CDVDInputStreamFile *m_pInputStream;
+
+};
diff --git a/xbmc/cores/playercorefactory/PlayerCoreConfig.h b/xbmc/cores/playercorefactory/PlayerCoreConfig.h
index 0a7980e6ccd..7a6c3eae2e9 100644
--- a/xbmc/cores/playercorefactory/PlayerCoreConfig.h
+++ b/xbmc/cores/playercorefactory/PlayerCoreConfig.h
@@ -23,6 +23,9 @@
 #include <utility>
 
 #include "system.h"
+#if defined(HAVE_LIBGSTREAMER)
+#include "cores/GstPlayer/GstPlayer.h"
+#endif
 
 class CPlayerCoreConfig
 {
@@ -91,6 +94,12 @@ public:
     {
       pPlayer = new KODI::RETRO::CRetroPlayer(callback);
     }
+#if defined(HAVE_LIBGSTREAMER)
+    else if (m_type.compare("gstreamer") == 0)
+    {
+      pPlayer = new CGstPlayer(callback);
+    }
+#endif
     else if (m_type.compare("external") == 0)
     {
       pPlayer = new CExternalPlayer(callback);
diff --git a/xbmc/cores/playercorefactory/PlayerCoreFactory.cpp b/xbmc/cores/playercorefactory/PlayerCoreFactory.cpp
index bbc5c090d26..3cb642e24ac 100644
--- a/xbmc/cores/playercorefactory/PlayerCoreFactory.cpp
+++ b/xbmc/cores/playercorefactory/PlayerCoreFactory.cpp
@@ -28,6 +28,10 @@
 
 #include <sstream>
 
+#if defined(HAVE_LIBGSTREAMER)
+  #include "cores/GstPlayer/GstPlayer.h"
+#endif
+
 #define PLAYERCOREFACTORY_XML "playercorefactory.xml"
 
 CPlayerCoreFactory::CPlayerCoreFactory(const CProfileManager &profileManager) :
@@ -319,6 +323,13 @@ bool CPlayerCoreFactory::LoadConfiguration(const std::string &file, bool clear)
     m_vecCoreSelectionRules.clear();
 
     // Builtin players
+#if defined(HAVE_LIBGSTREAMER)
+    CPlayerCoreConfig* GstPlayer = new CPlayerCoreConfig("GstPlayer", "gstreamer", nullptr);
+    GstPlayer->m_bPlaysAudio = true;
+    GstPlayer->m_bPlaysVideo = true;
+    m_vecPlayerConfigs.push_back(GstPlayer);
+#endif
+
     CPlayerCoreConfig* VideoPlayer = new CPlayerCoreConfig("VideoPlayer", "video", nullptr);
     VideoPlayer->m_bPlaysAudio = true;
     VideoPlayer->m_bPlaysVideo = true;
@@ -359,6 +370,10 @@ bool CPlayerCoreFactory::LoadConfiguration(const std::string &file, bool clear)
         internaltype = "video";
       else if (type == "paplayer")
         internaltype = "music";
+#if defined(HAVE_LIBGSTREAMER)
+      else if (type == "gstplayer")
+        internaltype = "gstreamer";
+#endif
       else if (type == "externalplayer")
         internaltype = "external";
       else if (type == "enigma2player")
-- 
2.25.1


diff --git a/cmake/modules/FindFFMPEG.cmake b/cmake/modules/FindFFMPEG.cmake
index ef74671..dbe8a64 100644
--- a/cmake/modules/FindFFMPEG.cmake
+++ b/cmake/modules/FindFFMPEG.cmake
@@ -46,16 +46,22 @@ set(_postproc_ver ">=55.1.100")
 # Allows building with external ffmpeg not found in system paths,
 # without library version checks
 if(WITH_FFMPEG)
-  set(FFMPEG_PATH ${WITH_FFMPEG})
-  message(STATUS "Warning: FFmpeg version checking disabled")
-  set(REQUIRED_FFMPEG_VERSION undef)
-  unset(_avcodec_ver)
-  unset(_avfilter_ver)
-  unset(_avformat_ver)
-  unset(_avutil_ver)
-  unset(_swscale_ver)
-  unset(_swresample_ver)
-  unset(_postproc_ver)
+  if(WITH_FFMPEG STREQUAL stb)
+    set(FFMPEG_TARGET ${WITH_FFMPEG})
+    set(ENABLE_INTERNAL_FFMPEG ON)
+  else()
+    set(FFMPEG_TARGET "")
+    set(FFMPEG_PATH ${WITH_FFMPEG})
+    message(STATUS "Warning: FFmpeg version checking disabled")
+    set(REQUIRED_FFMPEG_VERSION undef)
+    unset(_avcodec_ver)
+    unset(_avfilter_ver)
+    unset(_avformat_ver)
+    unset(_avutil_ver)
+    unset(_swscale_ver)
+    unset(_swresample_ver)
+    unset(_postproc_ver)
+  endif()
 endif()
 
 # Allows building with external ffmpeg not found in system paths,
@@ -234,6 +240,12 @@ if(NOT FFMPEG_FOUND)
                      -DENABLE_VAAPI=${ENABLE_VAAPI}
                      -DENABLE_VDPAU=${ENABLE_VDPAU})
 
+  if(WITH_FFMPEG STREQUAL stb)
+    list(APPEND FFMPEG_OPTIONS -DFFMPEG_TARGET=${FFMPEG_TARGET})
+  endif()
+
+
+
   if(KODI_DEPENDSBUILD)
     set(CROSS_ARGS -DDEPENDS_PATH=${DEPENDS_PATH}
                    -DPKG_CONFIG_EXECUTABLE=${PKG_CONFIG_EXECUTABLE}
@@ -272,12 +284,12 @@ if(NOT FFMPEG_FOUND)
                                     ${CMAKE_SOURCE_DIR}/tools/depends/target/ffmpeg/FindGnuTls.cmake
                                     <SOURCE_DIR>)
 
-  find_program(BASH_COMMAND bash)
-  if(NOT BASH_COMMAND)
-    message(FATAL_ERROR "Internal FFmpeg requires bash.")
-  endif()
+#  find_program(BASH_COMMAND bash)
+#  if(NOT BASH_COMMAND)
+#    message(FATAL_ERROR "Internal FFmpeg requires bash.")
+#  endif()
   file(WRITE ${CMAKE_BINARY_DIR}/${CORE_BUILD_DIR}/ffmpeg/ffmpeg-link-wrapper
-"#!${BASH_COMMAND}
+"#!/bin/bash
 if [[ $@ == *${APP_NAME_LC}.bin* || $@ == *${APP_NAME_LC}${APP_BINARY_SUFFIX}* || $@ == *${APP_NAME_LC}.so* || $@ == *${APP_NAME_LC}-test* ]]
 then
   avformat=`PKG_CONFIG_PATH=${CMAKE_BINARY_DIR}/${CORE_BUILD_DIR}/lib/pkgconfig ${PKG_CONFIG_EXECUTABLE} --libs --static libavcodec`
@@ -291,6 +303,7 @@ then
 else
   $@
 fi")
+
   file(COPY ${CMAKE_BINARY_DIR}/${CORE_BUILD_DIR}/ffmpeg/ffmpeg-link-wrapper
        DESTINATION ${CMAKE_BINARY_DIR}/${CORE_BUILD_DIR}
        FILE_PERMISSIONS OWNER_READ OWNER_WRITE OWNER_EXECUTE)
diff --git a/cmake/platform/linux/stb.cmake b/cmake/platform/linux/stb.cmake
new file mode 100644
index 0000000..dd62eff
--- /dev/null
+++ b/cmake/platform/linux/stb.cmake
@@ -0,0 +1,69 @@
+set(PLATFORM_REQUIRED_DEPS EGL LibInput Xkbcommon)
+set(PLATFORM_OPTIONAL_DEPS VAAPI)
+
+set(STB_RENDER_SYSTEM "" CACHE STRING "Render system to use with STB: \"gl\" or \"gles\"")
+
+if(ENABLE_OPENGL STREQUAL "ON")
+  list(APPEND PLATFORM_REQUIRED_DEPS OpenGl)
+  set(APP_RENDER_SYSTEM gl)
+  message(STATUS "STB_RENDER_SYSTEM=GL")
+elseif(ENABLE_GLES STREQUAL "ON")
+  list(APPEND PLATFORM_REQUIRED_DEPS OpenGLES)
+  set(APP_RENDER_SYSTEM gles)
+  message(STATUS "STB_RENDER_SYSTEM=GLES")
+else()
+  message(SEND_ERROR "You need to decide whether you want to use GL- or GLES-based rendering in combination with the STB windowing system. Please set STB_RENDER_SYSTEM to either \"gl\" or \"gles\". For normal desktop systems, you will usually want to use \"gl\".")
+endif()
+
+if(WITH_PLATFORM STREQUAL "GB-cortexa15")
+  set(CPU cortexa15)
+  list(APPEND PLATFORM_DEFINES "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -DTARGET_STB -DTARGET_STB_EXTEND -DTARGET_V3D -DTARGET_GB")
+  list(APPEND DEPLIBS ${CMAKE_SOURCE_DIR}/xbmc/windowing/egl/gles_init.a EGL GLESv2 nxpl nexus nxclient)
+elseif(WITH_PLATFORM STREQUAL "dags-cortexa15")
+  set(CPU cortexa15)
+  list(APPEND PLATFORM_DEFINES "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -DTARGET_STB -DTARGET_STB_EXTEND -DTARGET_V3D -DTARGET_DAGS")
+  list(APPEND DEPLIBS EGL GLESv2 nxpl nexus nxclient)
+elseif(WITH_PLATFORM STREQUAL "dreambox-cortexa15")
+  set(CPU cortexa15)
+  list(APPEND PLATFORM_DEFINES "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -DTARGET_STB -DTARGET_STB_EXTEND -DTARGET_V3D -DTARGET_DREAMBOX")
+elseif(WITH_PLATFORM STREQUAL "dreambox-mipsel")
+  list(APPEND PLATFORM_DEFINES "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -DTARGET_STB -DTARGET_STB_EXTEND -DTARGET_V3D -DTARGET_DREAMBOX")
+elseif(WITH_PLATFORM STREQUAL "vuplus-cortexa15")
+  set(CPU cortexa15)
+  list(APPEND PLATFORM_DEFINES "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -DTARGET_STB -DTARGET_STB_EXTEND -DTARGET_V3D -DTARGET_VUPLUS -DTARGET_VUPLUS_ARM")
+  list(APPEND DEPLIBS EGL GLESv2 KodiGLESPL dvb_base nxpl dvb_client)
+elseif(WITH_PLATFORM STREQUAL "vuplus-mipsel")
+  list(APPEND PLATFORM_DEFINES "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -DTARGET_STB -DTARGET_STB_EXTEND -DTARGET_V3D -DTARGET_VUPLUS -DTARGET_VUPLUS_MIPSEL")
+  list(APPEND DEPLIBS ${CMAKE_SOURCE_DIR}/xbmc/windowing/egl/gles_init.a EGL GLESv2 dvb_base nxpl xbmc_base dvb_client)
+  list(APPEND SYSTEM_LDFLAGS -L${CMAKE_SOURCE_DIR}/../xbmc-support)
+elseif(WITH_PLATFORM STREQUAL "v3d-cortexa15")
+  set(CPU cortexa15)
+  list(APPEND PLATFORM_DEFINES "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -DTARGET_STB -DTARGET_STB_EXTEND -DTARGET_V3D -DTARGET_V3DNXPL")
+  list(APPEND DEPLIBS EGL GLESv2 nxpl nexus)
+elseif(WITH_PLATFORM STREQUAL "v3d-mipsel")
+  list(APPEND PLATFORM_DEFINES "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -DTARGET_STB -DTARGET_STB_EXTEND -DTARGET_V3D -DTARGET_V3DNXPL")
+  list(APPEND DEPLIBS EGL GLESv2 nxpl nexus)
+elseif(WITH_PLATFORM STREQUAL "xcore-mipsel")
+  list(APPEND PLATFORM_DEFINES "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -DTARGET_STB -DTARGET_STB_EXTEND -DTARGET_V3D -DTARGET_XCORE")
+  list(APPEND DEPLIBS EGL GLESv2 v3dplatform)
+elseif(WITH_PLATFORM STREQUAL "nextv-cortexa15")
+  set(CPU cortexa15)
+  list(APPEND PLATFORM_DEFINES "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -DTARGET_STB -DTARGET_STB_EXTEND -DTARGET_V3D -DTARGET_NEXTV")
+  list(APPEND DEPLIBS EGL GLESv2 nxpl nexus nxclient)
+elseif(WITH_PLATFORM STREQUAL "mali-cortexa15")
+  set(CPU cortexa15)
+  list(APPEND PLATFORM_DEFINES "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -DTARGET_STB -DTARGET_STB_EXTEND -DTARGET_MALI -DHAS_HIPLAYER")
+  list(APPEND DEPLIBS EGL GLESv2 mali)
+elseif(WITH_PLATFORM STREQUAL "edision-cortexa15")
+  list(APPEND PLATFORM_DEFINES "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -DTARGET_STB -DTARGET_STB_EXTEND -DTARGET_V3D -DTARGET_EDISION")
+  list(APPEND DEPLIBS EGL GLESv2 v3dplatform)
+elseif(WITH_PLATFORM STREQUAL "clap-cortexa15")
+  list(APPEND PLATFORM_DEFINES "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -DTARGET_STB -DTARGET_MALI -DUSE_HIPLAYER")
+#  list(APPEND DEPLIBS ${CMAKE_SOURCE_DIR}xbmc/cores/hiplayer/hiplayer.a ${CMAKE_SOURCE_DIR}xbmc/linux/hisi/hiadp.a)
+#  list(APPEND DEPLIBS EGL GLESv2 jpeg hi_common hi_msp)
+  list(APPEND DEPLIBS EGL GLESv2 jpeg)
+endif()
+
+
+
+list(APPEND PLATFORM_DEFINES -DMESA_EGL_NO_X11_HEADERS)
diff --git a/cmake/scripts/linux/ArchSetup.cmake b/cmake/scripts/linux/ArchSetup.cmake
index 624edf6..89cebb3 100644
--- a/cmake/scripts/linux/ArchSetup.cmake
+++ b/cmake/scripts/linux/ArchSetup.cmake
@@ -32,6 +32,10 @@ else()
   elseif(CPU MATCHES aarch64 OR CPU MATCHES arm64)
     set(ARCH aarch64)
     set(NEON True)
+  elseif(CPU MATCHES "cortexa15")
+    set(ARCH arm)
+    set(NEON True)
+    set(NEON_FLAGS "-Wno-psabi -Wa,-march=armv7ve -mtune=cortex-a15 -mfpu=neon-vfpv4 -mvectorize-with-neon-quad -fPIC -mcpu=cortex-a15 -mfloat-abi=hard")
   else()
     message(SEND_ERROR "Unknown CPU: ${CPU}")
   endif()
diff --git a/cmake/treedata/common/stb.txt b/cmake/treedata/common/stb.txt
new file mode 100644
index 0000000..2606a0f
--- /dev/null
+++ b/cmake/treedata/common/stb.txt
@@ -0,0 +1 @@
+xbmc/windowing/egl   windowing/egl    # STB
diff --git a/tools/depends/target/ffmpeg/CMakeLists.txt b/tools/depends/target/ffmpeg/CMakeLists.txt
index 4a26222..8ac70bb 100644
--- a/tools/depends/target/ffmpeg/CMakeLists.txt
+++ b/tools/depends/target/ffmpeg/CMakeLists.txt
@@ -10,6 +10,36 @@ else()
   set(ffmpeg_conf --cc=${CMAKE_C_COMPILER} --cxx=${CMAKE_CXX_COMPILER})
 endif()
 
+if(FFMPEG_TARGET STREQUAL "stb")
+  set(pkgconf "PKG_CONFIG_LIBDIR=${CMAKE_BINARY_DIR}/lib/pkgconfig")
+  list(APPEND ffmpeg_conf --pkg-config=${CMAKE_BINARY_DIR}/lib/pkgconfig --pkg-config-flags=--static)
+  list(APPEND ffmpeg_conf --enable-cross-compile --arch=generic --target-os=linux)
+  list(APPEND ffmpeg_conf --pkgconfigdir=${CMAKE_BINARY_DIR}/lib/pkgconfig) 
+  list(APPEND ffmpeg_conf --bindir=${CMAKE_INSTALL_PREFIX}/ffmpeg/bin --libdir=${CMAKE_INSTALL_PREFIX}/ffmpeg/lib --incdir=${CMAKE_INSTALL_PREFIX}/ffmpeg/include --datadir=${CMAKE_INSTALL_PREFIX}/ffmpeg/share/)
+  if(WITH_PLATFORM STREQUAL "GB-cortexa15")
+    set(CPU cortex-a15)
+    list(APPEND ffmpeg_conf --cpu=${CPU})
+  elseif(WITH_PLATFORM STREQUAL "dags-cortexa15")
+    set(CPU cortex-a15)
+    list(APPEND ffmpeg_conf --cpu=${CPU})
+  elseif(WITH_PLATFORM STREQUAL "dreambox-cortexa15")
+    set(CPU cortex-a15)
+    list(APPEND ffmpeg_conf --cpu=${CPU})
+  elseif(WITH_PLATFORM STREQUAL "vuplus-cortexa15")
+    set(CPU cortex-a15)
+    list(APPEND ffmpeg_conf --cpu=${CPU})
+  elseif(WITH_PLATFORM STREQUAL "v3d-cortexa15")
+    set(CPU cortex-a15)
+    list(APPEND ffmpeg_conf --cpu=${CPU})
+  elseif(WITH_PLATFORM STREQUAL "nextv-cortexa15")
+    set(CPU cortex-a15)
+    list(APPEND ffmpeg_conf --cpu=${CPU})
+  elseif(WITH_PLATFORM STREQUAL "mali-cortexa15")
+    set(CPU cortex-a15)
+    list(APPEND ffmpeg_conf --cpu=${CPU})
+  endif()
+endif()
+
 if(CROSSCOMPILING)
   set(pkgconf "PKG_CONFIG_LIBDIR=${DEPENDS_PATH}/lib/pkgconfig")
   list(APPEND ffmpeg_conf --pkg-config=${PKG_CONFIG_EXECUTABLE} --pkg-config-flags=--static)
diff --git a/xbmc/addons/AddonManager.cpp b/xbmc/addons/AddonManager.cpp
index 4d6e27e..28bdd38 100644
--- a/xbmc/addons/AddonManager.cpp
+++ b/xbmc/addons/AddonManager.cpp
@@ -1048,6 +1048,12 @@ bool CAddonMgr::PlatformSupportsAddon(const cp_plugin_info_t *plugin)
 #else
     #warning no architecture dependant platform tag
 #endif
+#elif defined(TARGET_MALI)
+    "mali",
+    "linux",
+#elif defined(TARGET_V3D)
+    "v3d",
+    "linux",
 #elif defined(TARGET_FREEBSD)
     "freebsd",
     "linux",
@@ -1157,6 +1163,12 @@ std::string CAddonMgr::GetPlatformLibraryName(cp_cfg_element_t *base) const
 #if defined(TARGET_FREEBSD)
   libraryName = GetExtValue(base, "@library_freebsd");
   if (libraryName.empty())
+#elif defined(TARGET_V3D)
+  libraryName = GetExtValue(base, "@library_v3d");
+  if (libraryName.empty())
+#elif defined(TARGET_MALI)
+  libraryName = GetExtValue(base, "@library_mali");
+  if (libraryName.empty())
 #endif
   libraryName = GetExtValue(base, "@library_linux");
 #elif defined(TARGET_WINDOWS_DESKTOP)
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/CMakeLists.txt b/xbmc/cores/VideoPlayer/VideoRenderers/CMakeLists.txt
index 2b9e17b..c853c02 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/CMakeLists.txt
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/CMakeLists.txt
@@ -46,6 +46,7 @@ if(OPENGLES_FOUND AND (CORE_PLATFORM_NAME_LC STREQUAL android OR
                        CORE_PLATFORM_NAME_LC STREQUAL ios OR
                        CORE_PLATFORM_NAME_LC STREQUAL aml OR
                        CORE_PLATFORM_NAME_LC STREQUAL gbm OR
+                       CORE_PLATFORM_NAME_LC STREQUAL stb OR
                        CORE_PLATFORM_NAME_LC STREQUAL wayland))
   list(APPEND SOURCES LinuxRendererGLES.cpp
                       FrameBufferObject.cpp)
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/VideoShaders/CMakeLists.txt b/xbmc/cores/VideoPlayer/VideoRenderers/VideoShaders/CMakeLists.txt
index 4987883..b21352e 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/VideoShaders/CMakeLists.txt
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/VideoShaders/CMakeLists.txt
@@ -26,6 +26,7 @@ if(OPENGLES_FOUND AND (CORE_PLATFORM_NAME_LC STREQUAL android OR
                        CORE_PLATFORM_NAME_LC STREQUAL ios OR
                        CORE_PLATFORM_NAME_LC STREQUAL aml OR
                        CORE_PLATFORM_NAME_LC STREQUAL gbm OR
+                       CORE_PLATFORM_NAME_LC STREQUAL stb OR
                        CORE_PLATFORM_NAME_LC STREQUAL wayland))
   list(APPEND SOURCES ConversionMatrix.cpp
                       VideoFilterShaderGLES.cpp
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/VideoShaders/VideoFilterShaderGLES.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/VideoShaders/VideoFilterShaderGLES.cpp
index a9aa0d6..2da8c57 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/VideoShaders/VideoFilterShaderGLES.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/VideoShaders/VideoFilterShaderGLES.cpp
@@ -96,6 +96,10 @@ ConvolutionFilterShader::ConvolutionFilterShader(ESCALINGMETHOD method)
     shadername = "gles_convolution-6x6.frag";
   }
 
+/*XCORE stb has an old gl2ext.h without GL_RGBA16F_EXT */
+#if defined (TARGET_XCORE) || defined (TARGET_VUPLUS_MIPSEL)
+  m_internalformat = GL_RGBA;
+#else
   if (m_floattex)
   {
     m_internalformat = GL_RGBA16F_EXT;
@@ -105,6 +109,7 @@ ConvolutionFilterShader::ConvolutionFilterShader(ESCALINGMETHOD method)
   {
     m_internalformat = GL_RGBA;
   }
+#endif
 
   CLog::Log(LOGDEBUG, "GL: ConvolutionFilterShader: using %s defines:\n%s", shadername.c_str(), defines.c_str());
   PixelShader()->LoadSource(shadername, defines);
diff --git a/xbmc/platform/linux/input/CMakeLists.txt b/xbmc/platform/linux/input/CMakeLists.txt
index b5a45d0..51f5347 100644
--- a/xbmc/platform/linux/input/CMakeLists.txt
+++ b/xbmc/platform/linux/input/CMakeLists.txt
@@ -6,7 +6,7 @@ if(LIRCCLIENT_FOUND)
   list(APPEND HEADERS LIRC.h)
 endif()
 
-if(CORE_PLATFORM_NAME_LC STREQUAL rbpi OR CORE_PLATFORM_NAME_LC STREQUAL gbm OR CORE_PLATFORM_NAME_LC STREQUAL aml)
+if(CORE_PLATFORM_NAME_LC STREQUAL rbpi OR CORE_PLATFORM_NAME_LC STREQUAL gbm OR CORE_PLATFORM_NAME_LC STREQUAL aml OR CORE_PLATFORM_NAME_LC STREQUAL stb)
   if(LIBINPUT_FOUND)
     list(APPEND SOURCES LibInputHandler.cpp
                         LibInputKeyboard.cpp
@@ -22,6 +22,12 @@ if(CORE_PLATFORM_NAME_LC STREQUAL rbpi OR CORE_PLATFORM_NAME_LC STREQUAL gbm OR
   endif()
 endif()
 
+if(CORE_PLATFORM_NAME_LC STREQUAL stb)
+    list(APPEND SOURCES LinuxInputDevices.cpp)
+    list(APPEND HEADERS LinuxInputDevices.h
+                        Keymap.h)
+endif()
+
 if(SOURCES)
   core_add_library(input_linux)
 endif()
diff --git a/xbmc/platform/linux/input/Keymap.h b/xbmc/platform/linux/input/Keymap.h
new file mode 100644
index 0000000..dda1758
--- /dev/null
+++ b/xbmc/platform/linux/input/Keymap.h
@@ -0,0 +1,36 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include "system.h"
+
+class ILinuxKeymap
+{
+public:
+
+  virtual ~ILinuxKeymap() {};
+  
+  virtual uint32_t KeysymForKeycode(uint32_t code) const = 0;
+  virtual void     UpdateMask(uint32_t depressed, uint32_t latched, uint32_t locked, uint32_t group) = 0;
+  virtual uint32_t CurrentModifiers() const = 0;
+  
+  virtual uint32_t XBMCKeysymForKeycode(uint32_t code) const = 0;
+  virtual uint32_t ActiveXBMCModifiers() const = 0;
+};
diff --git a/xbmc/platform/linux/input/LinuxInputDevices.cpp b/xbmc/platform/linux/input/LinuxInputDevices.cpp
new file mode 100644
index 0000000..987fe29
--- /dev/null
+++ b/xbmc/platform/linux/input/LinuxInputDevices.cpp
@@ -0,0 +1,1582 @@
+/*
+ *  Portions copied from DirectFB:
+ *      Copyright (C) 2001-2009  The world wide DirectFB Open Source Community (directfb.org)
+ *      Copyright (C) 2000-2004  Convergence (integrated media) GmbH
+ *      All rights reserved.
+ *      Written by Denis Oliver Kropp <dok@directfb.org>,
+ *      Andreas Hundt <andi@fischlustig.de>,
+ *      Sven Neumann <neo@directfb.org>,
+ *      Ville Syrjälä <syrjala@sci.fi> and
+ *      Claudio Ciccani <klan@users.sf.net>.
+ *
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#define VKEY_ENABLE (0)
+
+#include "system.h"
+#include "ServiceBroker.h"
+
+//#if defined(HAS_LINUX_EVENTS)
+
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+typedef unsigned long kernel_ulong_t;
+#define BITS_PER_LONG    (sizeof(long)*8)
+#endif
+
+#include <linux/input.h>
+
+#if defined(HAVE_LIBUDEV)
+#include <libudev.h>
+#endif
+
+#ifndef EV_CNT
+#define EV_CNT (EV_MAX+1)
+#define KEY_CNT (KEY_MAX+1)
+#define REL_CNT (REL_MAX+1)
+#define ABS_CNT (ABS_MAX+1)
+#define LED_CNT (LED_MAX+1)
+#endif
+
+/* compat defines for older kernel like 2.4.x */
+#ifndef EV_SYN
+#define EV_SYN			0x00
+#define SYN_REPORT              0
+#define SYN_CONFIG              1
+#define ABS_TOOL_WIDTH		0x1c
+#define BTN_TOOL_DOUBLETAP	0x14d
+#define BTN_TOOL_TRIPLETAP	0x14e
+#endif
+
+#ifndef EVIOCGLED
+#define EVIOCGLED(len) _IOC(_IOC_READ, 'E', 0x19, len)
+#endif
+
+#ifndef EVIOCGRAB
+#define EVIOCGRAB _IOW('E', 0x90, int)
+#endif
+
+#ifdef STANDALONE
+#define XBMC_BUTTON_LEFT    1
+#define XBMC_BUTTON_MIDDLE  2
+#define XBMC_BUTTON_RIGHT 3
+#define XBMC_BUTTON_WHEELUP 4
+#define XBMC_BUTTON_WHEELDOWN 5
+#endif
+
+#include <linux/keyboard.h>
+#include <linux/kd.h>
+
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <fcntl.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+#include "windowing/GraphicContext.h"
+#include "input/XBMC_keysym.h"
+#include "LinuxInputDevices.h"
+#include "input/mouse/MouseStat.h"
+#include "utils/log.h"
+#include "input/touch/generic/GenericTouchActionHandler.h"
+#include "input/touch/generic/GenericTouchInputHandler.h"
+#include "settings/Settings.h"
+#include "settings/AdvancedSettings.h"
+#include "settings/SettingsComponent.h"
+
+#ifndef BITS_PER_LONG
+#define BITS_PER_LONG        (sizeof(long) * 8)
+#endif
+#define NBITS(x)             ((((x)-1)/BITS_PER_LONG)+1)
+#define OFF(x)               ((x)%BITS_PER_LONG)
+#define BIT(x)               (1UL<<OFF(x))
+#define LONG(x)              ((x)/BITS_PER_LONG)
+#undef test_bit
+#define test_bit(bit, array) ((array[LONG(bit)] >> OFF(bit)) & 1)
+
+#define MAX_LINUX_INPUT_DEVICES 16
+
+typedef struct {
+  unsigned short Key;
+  XBMCKey xbmcKey;
+} KeyMap;
+
+static const
+KeyMap keyMap[] = {
+  { KEY_ESC           , XBMCK_ESCAPE      },
+  { KEY_1             , XBMCK_1           },
+  { KEY_2             , XBMCK_2           },
+  { KEY_3             , XBMCK_3           },
+  { KEY_4             , XBMCK_4           },
+  { KEY_5             , XBMCK_5           },
+  { KEY_6             , XBMCK_6           },
+  { KEY_7             , XBMCK_7           },
+  { KEY_8             , XBMCK_8           },
+  { KEY_9             , XBMCK_9           },
+  { KEY_0             , XBMCK_0           },
+  { KEY_MINUS         , XBMCK_MINUS       },
+  { KEY_EQUAL         , XBMCK_EQUALS      },
+  { KEY_BACKSPACE     , XBMCK_BACKSPACE   },
+  { KEY_TAB           , XBMCK_TAB         },
+  { KEY_Q             , XBMCK_q           },
+  { KEY_W             , XBMCK_w           },
+  { KEY_E             , XBMCK_e           },
+  { KEY_R             , XBMCK_r           },
+  { KEY_T             , XBMCK_t           },
+  { KEY_Y             , XBMCK_y           },
+  { KEY_U             , XBMCK_u           },
+  { KEY_I             , XBMCK_i           },
+  { KEY_O             , XBMCK_o           },
+  { KEY_P             , XBMCK_p           },
+  { KEY_LEFTBRACE     , XBMCK_LEFTBRACKET },
+  { KEY_RIGHTBRACE    , XBMCK_RIGHTBRACKET},
+  { KEY_ENTER         , XBMCK_RETURN      },
+  { KEY_LEFTCTRL      , XBMCK_LCTRL       },
+  { KEY_A             , XBMCK_a           },
+  { KEY_S             , XBMCK_s           },
+  { KEY_D             , XBMCK_d           },
+  { KEY_F             , XBMCK_f           },
+  { KEY_G             , XBMCK_g           },
+  { KEY_H             , XBMCK_h           },
+  { KEY_J             , XBMCK_j           },
+  { KEY_K             , XBMCK_k           },
+  { KEY_L             , XBMCK_l           },
+  { KEY_SEMICOLON     , XBMCK_SEMICOLON   },
+  { KEY_APOSTROPHE    , XBMCK_QUOTE       },
+  { KEY_GRAVE         , XBMCK_BACKQUOTE   },
+  { KEY_LEFTSHIFT     , XBMCK_LSHIFT      },
+  { KEY_BACKSLASH     , XBMCK_BACKSLASH   },
+  { KEY_Z             , XBMCK_z           },
+  { KEY_X             , XBMCK_x           },
+  { KEY_C             , XBMCK_c           },
+  { KEY_V             , XBMCK_v           },
+  { KEY_B             , XBMCK_b           },
+  { KEY_N             , XBMCK_n           },
+  { KEY_M             , XBMCK_m           },
+  { KEY_COMMA         , XBMCK_COMMA       },
+  { KEY_DOT           , XBMCK_PERIOD      },
+  { KEY_SLASH         , XBMCK_SLASH       },
+  { KEY_RIGHTSHIFT    , XBMCK_RSHIFT      },
+  { KEY_KPASTERISK    , XBMCK_KP_MULTIPLY },
+  { KEY_LEFTALT       , XBMCK_LALT        },
+  { KEY_SPACE         , XBMCK_SPACE       },
+  { KEY_CAPSLOCK      , XBMCK_CAPSLOCK    },
+  { KEY_F1            , XBMCK_F1          },
+  { KEY_F2            , XBMCK_F2          },
+  { KEY_F3            , XBMCK_F3          },
+  { KEY_F4            , XBMCK_F4          },
+  { KEY_F5            , XBMCK_F5          },
+  { KEY_F6            , XBMCK_F6          },
+  { KEY_F7            , XBMCK_F7          },
+  { KEY_F8            , XBMCK_F8          },
+  { KEY_F9            , XBMCK_F9          },
+  { KEY_F10           , XBMCK_F10         },
+  { KEY_NUMLOCK       , XBMCK_NUMLOCK     },
+  { KEY_SCROLLLOCK    , XBMCK_SCROLLOCK   },
+  { KEY_KP7           , XBMCK_KP7         },
+  { KEY_KP8           , XBMCK_KP8         },
+  { KEY_KP9           , XBMCK_KP9         },
+  { KEY_KPMINUS       , XBMCK_KP_MINUS    },
+  { KEY_KP4           , XBMCK_KP4         },
+  { KEY_KP5           , XBMCK_KP5         },
+  { KEY_KP6           , XBMCK_KP6         },
+  { KEY_KPPLUS        , XBMCK_KP_PLUS     },
+  { KEY_KP1           , XBMCK_KP1         },
+  { KEY_KP2           , XBMCK_KP2         },
+  { KEY_KP3           , XBMCK_KP3         },
+  { KEY_KP0           , XBMCK_KP0         },
+  { KEY_KPDOT         , XBMCK_KP_PERIOD   },
+  { 84                , XBMCK_BACKSLASH   },
+  { 85                , XBMCK_F13         },
+  { 86                , XBMCK_LESS        },
+  { KEY_F11           , XBMCK_F11         },
+  { KEY_F12           , XBMCK_F12         },
+  { 89                , XBMCK_F14         },
+  { 90                , XBMCK_F15         },
+  { KEY_KPENTER       , XBMCK_KP_ENTER    },
+  { KEY_RIGHTCTRL     , XBMCK_RCTRL       },
+  { KEY_KPSLASH       , XBMCK_KP_DIVIDE   },
+  { KEY_SYSRQ         , XBMCK_PRINT       },
+  { KEY_RIGHTALT      , XBMCK_MODE        },
+  { KEY_HOME          , XBMCK_HOME        },
+  { KEY_UP            , XBMCK_UP          },
+  { KEY_PAGEUP        , XBMCK_PAGEUP      },
+  { KEY_LEFT          , XBMCK_LEFT        },
+  { KEY_RIGHT         , XBMCK_RIGHT       },
+  { KEY_END           , XBMCK_END         },
+  { KEY_DOWN          , XBMCK_DOWN        },
+  { KEY_PAGEDOWN      , XBMCK_PAGEDOWN    },
+  { KEY_INSERT        , XBMCK_INSERT      },
+  { KEY_DELETE        , XBMCK_DELETE      },
+  { KEY_MUTE          , XBMCK_VOLUME_MUTE },
+  { KEY_VOLUMEDOWN    , XBMCK_VOLUME_DOWN },
+  { KEY_VOLUMEUP      , XBMCK_VOLUME_UP   },
+  { KEY_POWER         , XBMCK_POWER       },
+  { KEY_SLEEP         , XBMCK_POWER       },
+  { KEY_KPEQUAL       , XBMCK_KP_EQUALS   },
+  { KEY_PAUSE         , XBMCK_PAUSE       },
+  { KEY_PAUSECD       , XBMCK_PAUSE       },
+  { KEY_LEFTMETA      , XBMCK_LMETA       },
+  { KEY_RIGHTMETA     , XBMCK_RMETA       },
+  { KEY_COMPOSE       , XBMCK_LSUPER      },
+  { KEY_STOP          , XBMCK_MEDIA_STOP  },
+  { KEY_HELP          , XBMCK_HELP        },
+  { KEY_MENU          , XBMCK_MENU        },
+  { KEY_CLOSECD       , XBMCK_EJECT       },
+  { KEY_EJECTCD       , XBMCK_EJECT       },
+  { KEY_EJECTCLOSECD  , XBMCK_EJECT       },
+  { KEY_NEXTSONG      , XBMCK_MEDIA_NEXT_TRACK},
+  { KEY_PLAYPAUSE     , XBMCK_MEDIA_PLAY_PAUSE},
+  { KEY_PREVIOUSSONG  , XBMCK_MEDIA_PREV_TRACK},
+  { KEY_STOPCD        , XBMCK_MEDIA_STOP  },
+  { KEY_RECORD        , XBMCK_RECORD      },
+  { KEY_REWIND        , XBMCK_REWIND      },
+  { KEY_PHONE         , XBMCK_PHONE       },
+  { KEY_REFRESH       , XBMCK_SHUFFLE     },
+  { KEY_SCROLLUP      , XBMCK_PAGEUP      },
+  { KEY_SCROLLDOWN    , XBMCK_PAGEDOWN    },
+  { KEY_PLAY          , XBMCK_PLAY        },
+  { KEY_PLAYCD        , XBMCK_PLAY        },
+  { KEY_FASTFORWARD   , XBMCK_FASTFORWARD },
+  { KEY_PRINT         , XBMCK_PRINT       },
+  { KEY_QUESTION      , XBMCK_HELP        },
+  { KEY_BACK          , XBMCK_BACKSPACE   },
+  { KEY_ZOOM          , XBMCK_ZOOM        },
+  { KEY_TEXT          , XBMCK_TEXT        },
+  { KEY_FAVORITES     , XBMCK_FAVORITES   },
+  { KEY_RED           , XBMCK_RED         },
+  { KEY_GREEN         , XBMCK_GREEN       },
+  { KEY_YELLOW        , XBMCK_YELLOW      },
+  { KEY_BLUE          , XBMCK_BLUE        },
+  { KEY_HOMEPAGE      , XBMCK_HOMEPAGE    },
+  { KEY_MAIL          , XBMCK_LAUNCH_MAIL },
+  { KEY_SEARCH        , XBMCK_BROWSER_SEARCH},
+  { KEY_FILE          , XBMCK_LAUNCH_FILE_BROWSER},
+  { KEY_SELECT        , XBMCK_RETURN      },
+  { KEY_CONFIG        , XBMCK_CONFIG      },
+  { KEY_EPG           , XBMCK_EPG         },
+  // The Little Black Box Remote Additions
+  { 384               , XBMCK_LEFT        }, // Red
+  { 378               , XBMCK_RIGHT       }, // Green
+  { 381               , XBMCK_UP          }, // Yellow
+  { 366               , XBMCK_DOWN        }, // Blue
+#if defined(TARGET_STB)
+  { KEY_OK            , XBMCK_RETURN      }, // Ok
+  { KEY_EXIT          , XBMCK_ESCAPE      }, // EXIT
+  { KEY_INFO          , XBMCK_i           }, // Info
+  { KEY_SUBTITLE      , XBMCK_l           }, // Subtitle
+  { KEY_TV            , XBMCK_z           }, // TV
+  { KEY_TV2           , XBMCK_z           }, // TV/RADIO
+  { KEY_RADIO         , XBMCK_j           }, // Radio
+  { KEY_AUDIO         , XBMCK_a           }, // Audio
+  { 139               , XBMCK_MENU        }, // Menu
+  { 358               , XBMCK_e           }, // EPG
+  { 388               , XBMCK_y           }, // Teletext
+  { 393               , XBMCK_x           }, // Unknown
+  { KEY_CHANNELUP     , XBMCK_PAGEUP      }, // PageUp
+  { KEY_CHANNELDOWN   , XBMCK_PAGEDOWN    }, // PageDown
+  { KEY_NEXT          , XBMCK_MEDIA_NEXT_TRACK }, // Next
+  { KEY_PREVIOUS      , XBMCK_MEDIA_PREV_TRACK }, // Prev
+  { KEY_VIDEO         , XBMCK_c           }, // Playlist
+  { KEY_LIST          , XBMCK_c           }, // Playlist
+  { 438               , XBMCK_TAB         }, // Context
+  { KEY_BOOKMARKS     , XBMCK_TAB         }, // Portal
+  { 227               , XBMCK_z           }, // Aspectratio
+  { KEY_PROGRAM       , XBMCK_o           }, // Timer
+  { 398               , XBMCK_F1          }, // Red
+  { 399               , XBMCK_F2          }, // Green
+  { 400               , XBMCK_F3          }, // Yellow
+  { 401               , XBMCK_F4          }, // Blue
+#endif
+};
+
+typedef enum
+{
+  LI_DEVICE_NONE     = 0,
+  LI_DEVICE_MOUSE    = 1,
+  LI_DEVICE_JOYSTICK = 2,
+  LI_DEVICE_KEYBOARD = 4,
+  LI_DEVICE_REMOTE   = 8,
+  LI_DEVICE_MULTITOUCH = 16
+} LinuxInputDeviceType;
+
+typedef enum
+{
+  LI_CAPS_KEYS    = 1,
+  LI_CAPS_BUTTONS = 2,
+  LI_CAPS_AXES    = 4,
+} LinuxInputCapsType;
+
+static char remoteStatus = 0xFF; // paired, battery OK
+
+CLinuxInputDevice::CLinuxInputDevice(const std::string& fileName, int index):
+  m_fileName(fileName)
+{
+  m_fd = -1;
+  m_vt_fd = -1;
+  m_hasLeds = false;
+  m_ledState[0] = false;
+  m_ledState[1] = false;
+  m_ledState[2] = false;
+  m_mouseX = 0;
+  m_mouseY = 0;
+  m_deviceIndex = index;
+  m_keyMods = XBMCKMOD_NONE;
+  m_lastKeyMods = XBMCKMOD_NONE;
+  strcpy(m_deviceName, "");
+  m_deviceType = 0;
+  m_devicePreferredId = 0;
+  m_deviceCaps = 0;
+  m_deviceMinKeyCode = 0;
+  m_deviceMaxKeyCode = 0;
+  m_deviceMaxAxis = 0;
+  m_bUnplugged = false;
+  m_mt_currentSlot = 0;
+  memset(&m_mt_x, 0, sizeof(m_mt_x));
+  memset(&m_mt_y, 0, sizeof(m_mt_y));
+  memset(&m_mt_event, 0, sizeof(m_mt_event));
+
+  Open();
+}
+
+CLinuxInputDevice::~CLinuxInputDevice()
+{
+  Close();
+}
+
+/*
+ * Translates a Linux input keycode into an XBMC keycode.
+ */
+XBMCKey CLinuxInputDevice::TranslateKey(unsigned short code)
+{
+  for (size_t index = 0; index < sizeof(keyMap) / sizeof(KeyMap); index++)
+  {
+    if (code == keyMap[index].Key)
+      return keyMap[index].xbmcKey;
+  }
+
+  return XBMCK_UNKNOWN;
+}
+
+int CLinuxInputDevice::KeyboardGetSymbol(unsigned short value)
+{
+  unsigned char type = KTYP(value);
+  unsigned char index = KVAL(value);
+
+  switch (type)
+  {
+  case KT_FN:
+    if (index < 15)
+      return XBMCK_F1 + index;
+    break;
+  case KT_LETTER:
+  case KT_LATIN:
+    switch (index)
+    {
+    case 0x1c:
+      return XBMCK_PRINT;
+    case 0x7f:
+      return XBMCK_BACKSPACE;
+    case 0xa4:
+      return XBMCK_EURO; /* euro currency sign */
+    default:
+      return index;
+    }
+    break;
+
+/*
+  case KT_DEAD:
+    switch (value)
+    {
+    case K_DGRAVE:
+      return DIKS_DEAD_GRAVE;
+
+    case K_DACUTE:
+      return DIKS_DEAD_ACUTE;
+
+    case K_DCIRCM:
+      return DIKS_DEAD_CIRCUMFLEX;
+
+    case K_DTILDE:
+      return DIKS_DEAD_TILDE;
+
+    case K_DDIERE:
+      return DIKS_DEAD_DIAERESIS;
+
+    case K_DCEDIL:
+      return DIKS_DEAD_CEDILLA;
+
+    default:
+      break;
+    }
+    break;
+
+  case KT_PAD:
+    if (index <= 9 && level != DIKSI_BASE)
+      return (DFBInputDeviceKeySymbol) (DIKS_0 + index);
+    break;
+*/
+  }
+
+  return XBMCK_UNKNOWN;
+}
+
+unsigned short CLinuxInputDevice::KeyboardReadValue(unsigned char table, unsigned char index)
+{
+  struct kbentry entry;
+
+  entry.kb_table = table;
+  entry.kb_index = index;
+  entry.kb_value = 0;
+
+  if (ioctl(m_vt_fd, KDGKBENT, &entry))
+  {
+    CLog::Log(LOGWARNING, "CLinuxInputDevice::KeyboardReadValue: KDGKBENT (table: %d, index: %d) "
+        "failed!\n", table, index);
+    return 0;
+  }
+
+  return entry.kb_value;
+}
+
+XBMCMod CLinuxInputDevice::UpdateModifiers(XBMC_Event& devt)
+{
+  XBMCMod modifier = XBMCKMOD_NONE;
+  switch (devt.key.keysym.sym)
+  {
+    case XBMCK_LSHIFT: modifier = XBMCKMOD_LSHIFT; break;
+    case XBMCK_RSHIFT: modifier = XBMCKMOD_RSHIFT; break;
+    case XBMCK_LCTRL: modifier = XBMCKMOD_LCTRL; break;
+    case XBMCK_RCTRL: modifier = XBMCKMOD_RCTRL; break;
+    case XBMCK_LALT: modifier = XBMCKMOD_LALT; break;
+    case XBMCK_RALT: modifier = XBMCKMOD_RALT; break;
+    case XBMCK_LMETA: modifier = XBMCKMOD_LMETA; break;
+    case XBMCK_RMETA: modifier = XBMCKMOD_RMETA; break;
+    default: break;
+  }
+
+  if (devt.type == XBMC_KEYDOWN)
+  {
+    m_keyMods |= modifier;
+  }
+  else
+  {
+    m_keyMods &= ~modifier;
+  }
+
+  if (devt.type == XBMC_KEYDOWN)
+  {
+    modifier = XBMCKMOD_NONE;
+    switch (devt.key.keysym.sym)
+    {
+      case XBMCK_NUMLOCK: modifier = XBMCKMOD_NUM; break;
+      case XBMCK_CAPSLOCK: modifier = XBMCKMOD_CAPS; break;
+      default: break;
+    }
+
+    if (m_keyMods & modifier)
+    {
+      m_keyMods &= ~modifier;
+    }
+    else
+    {
+      m_keyMods |= modifier;
+    }
+  }
+
+  return (XBMCMod) m_keyMods;
+}
+
+/*
+ * Translates key and button events.
+ */
+bool CLinuxInputDevice::KeyEvent(const struct input_event& levt, XBMC_Event& devt)
+{
+  int code = levt.code;
+
+  /* map touchscreen and smartpad events to button mouse */
+  if (code == BTN_TOUCH || code == BTN_TOOL_FINGER)
+    code = BTN_MOUSE;
+
+  if ((code >= BTN_MOUSE && code < BTN_JOYSTICK) || code == BTN_TOUCH)
+  {
+    /* ignore repeat events for buttons */
+    if (levt.value == 2)
+      return false;
+
+    devt.type = levt.value ? XBMC_MOUSEBUTTONDOWN : XBMC_MOUSEBUTTONUP;
+    //devt.button.state = levt.value ? XBMC_PRESSED : XBMC_RELEASED;
+    //devt.button.type = devt.type;
+    devt.button.x = m_mouseX;
+    devt.button.y = m_mouseY;
+
+    switch (levt.code)
+    {
+      case BTN_RIGHT:
+        devt.button.button = XBMC_BUTTON_RIGHT;
+        break;
+
+      case BTN_LEFT:
+        devt.button.button = XBMC_BUTTON_LEFT;
+        break;
+
+      case BTN_MIDDLE:
+        devt.button.button = XBMC_BUTTON_RIGHT;
+        break;
+
+      case BTN_FORWARD:
+        devt.button.button = XBMC_BUTTON_WHEELDOWN;
+        break;
+
+      case BTN_BACK:
+        devt.button.button = XBMC_BUTTON_WHEELUP;
+        break;
+
+      case BTN_TOUCH:
+        devt.button.button = XBMC_BUTTON_LEFT;
+        break;
+
+      case BTN_TOOL_DOUBLETAP:
+        devt.button.button = XBMC_BUTTON_RIGHT;
+        break;
+
+      default:
+        CLog::Log(LOGWARNING, "CLinuxInputDevice::KeyEvent: Unknown mouse button code: %d\n", levt.code);
+        return false;
+    }
+  }
+  else
+  {
+    XBMCKey key = TranslateKey(code);
+
+    if (key == XBMCK_UNKNOWN)
+    {
+      CLog::Log(LOGDEBUG, "CLinuxInputDevice::KeyEvent: TranslateKey returned XBMCK_UNKNOWN from code(%d)", code);
+      return false;
+    }
+
+    devt.type = levt.value ? XBMC_KEYDOWN : XBMC_KEYUP;
+    //devt.key.type = devt.type;
+    // warning, key.keysym.scancode is unsigned char so 0 - 255 only
+    devt.key.keysym.scancode = code;
+    devt.key.keysym.sym = key;
+    devt.key.keysym.mod = UpdateModifiers(devt);
+    devt.key.keysym.unicode = 0;
+
+    KeymapEntry entry;
+    entry.code = code;
+
+    int keyMapValue;
+#if defined(TARGET_STB)
+    if (devt.key.keysym.mod & (XBMCKMOD_SHIFT | XBMCKMOD_CAPS)) keyMapValue = entry.shift;
+    else if (devt.key.keysym.mod & XBMCKMOD_ALT) keyMapValue = entry.alt;
+    else if (devt.key.keysym.mod & XBMCKMOD_META) keyMapValue = entry.altShift;
+    else keyMapValue = entry.base;
+    devt.key.keysym.unicode = devt.key.keysym.sym;
+#else
+    if (GetKeymapEntry(entry))
+    {
+      int keyMapValue;
+      if (devt.key.keysym.mod & (XBMCKMOD_SHIFT | XBMCKMOD_CAPS)) keyMapValue = entry.shift;
+      else if (devt.key.keysym.mod & XBMCKMOD_ALT) keyMapValue = entry.alt;
+      else if (devt.key.keysym.mod & XBMCKMOD_META) keyMapValue = entry.altShift;
+      else keyMapValue = entry.base;
+
+      if (keyMapValue != XBMCK_UNKNOWN)
+      {
+        devt.key.keysym.sym = (XBMCKey) keyMapValue;
+        if (keyMapValue > 0 && keyMapValue < 127)
+        {
+          devt.key.keysym.unicode = devt.key.keysym.sym;
+        }
+      }
+    }
+#endif
+  }
+
+  return true;
+}
+
+/*
+ * Translates relative axis events.
+ */
+bool CLinuxInputDevice::RelEvent(const struct input_event& levt, XBMC_Event& devt)
+{
+  bool motion = false;
+  bool wheel  = false;
+
+  switch (levt.code)
+  {
+  case REL_X:
+    m_mouseX += levt.value;
+    devt.motion.x = levt.value;
+    devt.motion.y = 0;
+    motion = true;
+    break;
+  case REL_Y:
+    m_mouseY += levt.value;
+    devt.motion.x = 0;
+    devt.motion.y = levt.value;
+    motion = true;
+    break;
+  case REL_WHEEL:
+    wheel = (levt.value != 0); // process wheel event only when there was some delta
+    break;
+  case REL_Z:
+  default:
+    CLog::Log(LOGWARNING, "CLinuxInputDevice::RelEvent: Unknown rel event code: %d\n", levt.code);
+    return false;
+  }
+
+  // limit the mouse to the screen width
+  m_mouseX = std::min(CServiceBroker::GetWinSystem()->GetGfxContext().GetWidth(), m_mouseX);
+  m_mouseX = std::max(0, m_mouseX);
+
+  // limit the mouse to the screen height
+  m_mouseY = std::min(CServiceBroker::GetWinSystem()->GetGfxContext().GetHeight(), m_mouseY);
+  m_mouseY = std::max(0, m_mouseY);
+
+
+  if (motion)
+  {
+    devt.type = XBMC_MOUSEMOTION;
+    //devt.motion.type = XBMC_MOUSEMOTION;
+    devt.motion.x = m_mouseX;
+    devt.motion.y = m_mouseY;
+    //devt.motion.state = 0;
+    //devt.motion.which = m_deviceIndex;
+  }
+  else if (wheel)
+  {
+     devt.type = XBMC_MOUSEBUTTONUP;
+     //devt.button.state = XBMC_RELEASED;
+     //devt.button.type = devt.type;
+     devt.button.x = m_mouseX;
+     devt.button.y = m_mouseY;
+     devt.button.button = (levt.value<0) ? XBMC_BUTTON_WHEELDOWN:XBMC_BUTTON_WHEELUP;
+
+     /* but WHEEL up enent to the queue */
+     m_equeue.push_back(devt);
+
+     /* prepare and return WHEEL down event */
+     //devt.button.state = XBMC_PRESSED;
+     devt.type = XBMC_MOUSEBUTTONDOWN;
+  }
+  else
+  {
+     return false;
+  }
+
+  return true;
+}
+
+/*
+ * Translates absolute axis events.
+ */
+bool CLinuxInputDevice::AbsEvent(const struct input_event& levt, XBMC_Event& devt)
+{
+  switch (levt.code)
+  {
+  case ABS_X:
+    m_mouseX = (int)((float)levt.value * CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_screenAlign_xStretchFactor) + CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_screenAlign_xOffset; // stretch and shift touch x coordinates
+    break;
+
+  case ABS_Y:
+    m_mouseY = (int)((float)levt.value * CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_screenAlign_yStretchFactor) + CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_screenAlign_yOffset; // stretch and shift touch y coordinates
+    break;
+
+  case ABS_MISC:
+    remoteStatus = levt.value & 0xFF;
+    break;
+
+  case ABS_Z:
+  default:
+    return false;
+  }
+
+  devt.type = XBMC_MOUSEMOTION;
+  //devt.motion.type = XBMC_MOUSEMOTION;
+  devt.motion.x = m_mouseX;
+  devt.motion.y = m_mouseY;
+  //devt.motion.state = 0;
+  //devt.motion.xrel = 0;
+  //devt.motion.yrel = 0;
+  //devt.motion.which = m_deviceIndex;
+
+  return true;
+}
+
+/*
+ * Process multi-touch absolute events
+ * Only store the information, do not fire event until we receive an EV_SYN
+ */
+bool CLinuxInputDevice::mtAbsEvent(const struct input_event& levt)
+{
+  switch (levt.code)
+  {
+  case ABS_MT_SLOT:
+    m_mt_currentSlot = levt.value;
+    break;
+
+  case ABS_MT_TRACKING_ID:
+    if (m_mt_currentSlot < CGenericTouchInputHandler::MAX_POINTERS)
+    {
+      if (levt.value == -1)
+        m_mt_event[m_mt_currentSlot] = TouchInputUp;
+      else
+        m_mt_event[m_mt_currentSlot] = TouchInputDown;
+    }
+    break;
+
+  case ABS_MT_POSITION_X:
+    if (m_mt_currentSlot < CGenericTouchInputHandler::MAX_POINTERS)
+    {
+      m_mt_x[m_mt_currentSlot] = (int)((float)levt.value * CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_screenAlign_xStretchFactor) + CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_screenAlign_xOffset; // stretch and shift touch x coordinates
+      if (m_mt_event[m_mt_currentSlot] == TouchInputUnchanged)
+        m_mt_event[m_mt_currentSlot] = TouchInputMove;
+    }
+    break;
+
+  case ABS_MT_POSITION_Y:
+    if (m_mt_currentSlot < CGenericTouchInputHandler::MAX_POINTERS)
+    {
+      m_mt_y[m_mt_currentSlot] = (int)((float)levt.value * CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_screenAlign_yStretchFactor) + CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_screenAlign_yOffset; // stretch and shift touch y coordinates;
+      if (m_mt_event[m_mt_currentSlot] == TouchInputUnchanged)
+        m_mt_event[m_mt_currentSlot] = TouchInputMove;
+    }
+    break;
+
+  default:
+    return false;
+  }
+
+  return true;
+}
+
+/*
+ * Process stored multi-touch events
+ */
+bool CLinuxInputDevice::mtSynEvent(const struct input_event& levt)
+{
+  float size = 10.0f;
+  int64_t nanotime = levt.time.tv_sec * 1000000000LL + levt.time.tv_usec * 1000LL;
+
+  for (int ptr=0; ptr < CGenericTouchInputHandler::MAX_POINTERS; ptr++)
+  {
+    /* While the comments of ITouchInputHandler::UpdateTouchPointer() say
+       "If there's an event for every touch action this method does not need to be called at all"
+       gesture detection currently doesn't work properly without this call. */
+    CGenericTouchInputHandler::GetInstance().UpdateTouchPointer(ptr, m_mt_x[ptr], m_mt_y[ptr], nanotime, size);
+  }
+
+  for (int ptr=0; ptr < CGenericTouchInputHandler::MAX_POINTERS; ptr++)
+  {
+    if (m_mt_event[ptr] != TouchInputUnchanged)
+    {
+      CGenericTouchInputHandler::GetInstance().HandleTouchInput(m_mt_event[ptr], m_mt_x[ptr], m_mt_y[ptr], nanotime, ptr, size);
+      m_mt_event[ptr] = TouchInputUnchanged;
+    }
+  }
+
+  return true;
+}
+
+/*
+ * Translates a Linux input event into a DirectFB input event.
+ */
+bool CLinuxInputDevice::TranslateEvent(const struct input_event& levt,
+    XBMC_Event& devt)
+{
+  if (m_devicePreferredId == LI_DEVICE_MULTITOUCH)
+  {
+    switch (levt.type)
+    {
+    case EV_ABS:
+      return mtAbsEvent(levt);
+
+    case EV_SYN:
+      return mtSynEvent(levt);
+
+    default:
+      // Ignore legacy (key) events
+      return false;
+    }
+  }
+
+  switch (levt.type)
+  {
+  case EV_KEY:
+    return KeyEvent(levt, devt);
+
+  case EV_REL:
+    if (m_bSkipNonKeyEvents)
+    {
+      CLog::Log(LOGINFO, "read a relative event which will be ignored (device name %s) (file name %s)", m_deviceName, m_fileName.c_str());
+      return false;
+    }
+
+    return RelEvent(levt, devt);
+
+  case EV_ABS:
+    if (m_bSkipNonKeyEvents)
+    {
+      CLog::Log(LOGINFO, "read an absolute event which will be ignored (device name %s) (file name %s)", m_deviceName, m_fileName.c_str());
+      return false;
+    }
+
+    return AbsEvent(levt, devt);
+
+  default:
+    ;
+  }
+
+  return false;
+}
+
+void CLinuxInputDevice::SetLed(int led, int state)
+{
+  struct input_event levt;
+
+  levt.type = EV_LED;
+  levt.code = led;
+  levt.value = !!state;
+
+  write(m_fd, &levt, sizeof(levt));
+}
+
+/*
+ * Input thread reading from device.
+ * Generates events on incoming data.
+ */
+XBMC_Event CLinuxInputDevice::ReadEvent()
+{
+  int readlen;
+  struct input_event levt;
+
+  XBMC_Event devt;
+
+  if (m_equeue.empty())
+  {
+    while (1)
+    {
+      bzero(&levt, sizeof(levt));
+
+      bzero(&devt, sizeof(devt));
+      devt.type = XBMC_NOEVENT;
+
+      if(m_devicePreferredId == LI_DEVICE_NONE)
+        return devt;
+
+      readlen = read(m_fd, &levt, sizeof(levt));
+
+      if (readlen <= 0)
+      {
+        if (errno == ENODEV)
+        {
+          CLog::Log(LOGINFO,"input device was unplugged %s",m_deviceName);
+          m_bUnplugged = true;
+        }
+
+        break;
+      }
+
+#if defined(TARGET_STB)
+      if (access("/tmp/playing.lock", F_OK) == 0) {
+        break;
+      }
+#endif
+
+      //printf("read event readlen = %d device name %s m_fileName %s\n", readlen, m_deviceName, m_fileName.c_str());
+
+      // sanity check if we realy read the event
+      if(readlen != sizeof(levt))
+      {
+        CLog::Log(LOGERROR,"CLinuxInputDevice: read error : %s\n", strerror(errno));
+        break;
+      }
+
+      if (!TranslateEvent(levt, devt))
+        continue;
+
+      /* Flush previous event with DIEF_FOLLOW? */
+      if (devt.type != XBMC_NOEVENT)
+      {
+        //printf("new event! type = %d\n", devt.type);
+        //printf("key: %d %d %d %c\n", devt.key.keysym.scancode, devt.key.keysym.sym, devt.key.keysym.mod, devt.key.keysym.unicode);
+
+        if (m_hasLeds && (m_keyMods != m_lastKeyMods))
+        {
+          SetLed(LED_NUML, m_keyMods & XBMCKMOD_NUM);
+          SetLed(LED_CAPSL, m_keyMods & XBMCKMOD_CAPS);
+          m_lastKeyMods = m_keyMods;
+        }
+
+        break;
+      }
+    }
+  }
+  else
+  {
+     devt = m_equeue.front();
+     m_equeue.pop_front();
+  }
+
+  return devt;
+}
+
+void CLinuxInputDevice::SetupKeyboardAutoRepeat(int fd)
+{
+  bool enable = true;
+
+  if (enable)
+  {
+    int kbdrep[2] = { 400, 80 };
+    ioctl(fd, EVIOCSREP, kbdrep);
+  }
+  else
+  {
+    struct input_event event;
+    memset(&event, 0, sizeof(event));
+
+    gettimeofday(&event.time, NULL);
+    event.type  = EV_REP;
+    event.code  = REP_DELAY;
+    event.value = 0;
+    write(fd, &event, sizeof(event));
+
+    gettimeofday(&event.time, NULL);
+    event.type  = EV_REP;
+    event.code  = REP_PERIOD;
+    event.value = 0;
+    write(fd, &event, sizeof(event));
+
+    CLog::Log(LOGINFO, "CLinuxInputDevice: auto key repeat disabled on device '%s'\n", m_deviceName);
+  }
+}
+
+/*
+ * Fill device information.
+ * Queries the input device and tries to classify it.
+ */
+void CLinuxInputDevice::GetInfo(int fd)
+{
+  unsigned int num_keys = 0;
+  unsigned int num_ext_keys = 0;
+  unsigned int num_buttons = 0;
+  unsigned int num_rels = 0;
+  unsigned int num_abs = 0;
+
+  unsigned long evbit[NBITS(EV_CNT)];
+  unsigned long keybit[NBITS(KEY_CNT)];
+
+  /* get device name */
+  bzero(m_deviceName, sizeof(m_deviceName));
+  ioctl(fd, EVIOCGNAME(sizeof(m_deviceName)-1), m_deviceName);
+
+  CLog::Log(LOGNOTICE, "Initializing Linux input device '%s'\n", m_deviceName);
+
+  if (strncmp(m_deviceName, "D-Link Boxee D-Link Boxee Receiver", strlen("D-Link Boxee D-Link Boxee Receiver")) == 0)
+  {
+    m_bSkipNonKeyEvents = true;
+  }
+  else
+  {
+    m_bSkipNonKeyEvents = false;
+  }
+  CLog::Log(LOGINFO, "opened device '%s' (file name %s), m_bSkipNonKeyEvents %d\n", m_deviceName, m_fileName.c_str(), m_bSkipNonKeyEvents);
+
+  /* get event type bits */
+  ioctl(fd, EVIOCGBIT(0, sizeof(evbit)), evbit);
+
+  if (test_bit( EV_KEY, evbit ))
+  {
+    int i;
+
+    /* get keyboard bits */
+    ioctl(fd, EVIOCGBIT(EV_KEY, sizeof(keybit)), keybit);
+
+    /**  count typical keyboard keys only */
+    for (i = KEY_Q; i <= KEY_M; i++)
+      if (test_bit( i, keybit ))
+        num_keys++;
+
+    for (i = KEY_OK; i < KEY_CNT; i++)
+      if (test_bit( i, keybit ))
+        num_ext_keys++;
+
+    for (i = BTN_MOUSE; i < BTN_JOYSTICK; i++)
+      if (test_bit( i, keybit ))
+        num_buttons++;
+  }
+
+#ifndef HAS_INTELCE
+  unsigned long relbit[NBITS(REL_CNT)];
+  unsigned long absbit[NBITS(ABS_CNT)];
+
+  if (test_bit( EV_REL, evbit ))
+  {
+    int i;
+
+    /* get bits for relative axes */
+    ioctl(fd, EVIOCGBIT(EV_REL, sizeof(relbit)), relbit);
+
+    for (i = 0; i < REL_CNT; i++)
+      if (test_bit( i, relbit ))
+        num_rels++;
+  }
+
+  if (test_bit( EV_ABS, evbit ))
+  {
+    int i;
+
+    /* get bits for absolute axes */
+    ioctl(fd, EVIOCGBIT(EV_ABS, sizeof(absbit)), absbit);
+
+    for (i = 0; i < ABS_PRESSURE; i++)
+      if (test_bit( i, absbit ))
+        num_abs++;
+
+    /* test if it is a multi-touch type B device */
+    if (test_bit(ABS_MT_SLOT, absbit))
+      m_deviceType |= LI_DEVICE_MULTITOUCH;
+  }
+
+  /* Mouse, Touchscreen or Smartpad ? */
+  if ((test_bit( EV_KEY, evbit ) && (test_bit( BTN_TOUCH, keybit )
+      || test_bit( BTN_TOOL_FINGER, keybit ))) || ((num_rels >= 2
+      && num_buttons) || (num_abs == 2 && (num_buttons == 1))))
+    m_deviceType |= LI_DEVICE_MOUSE;
+  else if (num_abs && num_buttons) /* Or a Joystick? */
+    m_deviceType |= LI_DEVICE_JOYSTICK;
+#endif
+
+  /* A Keyboard, do we have at least some letters? */
+  if (num_keys > 20)
+  {
+    m_deviceType |= LI_DEVICE_KEYBOARD;
+    m_deviceCaps |= LI_CAPS_KEYS;
+
+    m_deviceMinKeyCode = 0;
+    m_deviceMaxKeyCode = 127;
+  }
+
+  /* A Remote Control? */
+  if (num_ext_keys)
+  {
+    m_deviceType |= LI_DEVICE_REMOTE;
+    m_deviceCaps |= LI_CAPS_KEYS;
+  }
+
+  /* Buttons */
+  if (num_buttons)
+  {
+    m_deviceCaps |= LI_CAPS_BUTTONS;
+    m_deviceMaxKeyCode = num_buttons - 1;
+  }
+
+  /* Axes */
+  if (num_rels || num_abs)
+  {
+    m_deviceCaps |= LI_CAPS_AXES;
+    m_deviceMaxAxis = std::max(num_rels, num_abs) - 1;
+  }
+
+  /* Decide which primary input device to be. */
+  if (m_deviceType & LI_DEVICE_KEYBOARD)
+    m_devicePreferredId = LI_DEVICE_KEYBOARD;
+  else if (m_deviceType & LI_DEVICE_MULTITOUCH)
+  {
+    m_devicePreferredId = LI_DEVICE_MULTITOUCH;
+    CGenericTouchInputHandler::GetInstance().RegisterHandler(&CGenericTouchActionHandler::GetInstance());
+  }
+  else if (m_deviceType & LI_DEVICE_REMOTE)
+    m_devicePreferredId = LI_DEVICE_REMOTE;
+  else if (m_deviceType & LI_DEVICE_JOYSTICK)
+    m_devicePreferredId = LI_DEVICE_JOYSTICK;
+  else if (m_deviceType & LI_DEVICE_MOUSE)
+    m_devicePreferredId = LI_DEVICE_MOUSE;
+  else
+    m_devicePreferredId = LI_DEVICE_NONE;
+
+  //printf("type: %d\n", m_deviceType);
+  //printf("caps: %d\n", m_deviceCaps);
+  //printf("pref: %d\n", m_devicePreferredId);
+}
+
+const std::string& CLinuxInputDevice::GetFileName()
+{
+  return m_fileName;
+}
+
+bool CLinuxInputDevice::IsUnplugged()
+{
+  return m_bUnplugged;
+}
+
+CLinuxInputDevicesCheckHotplugged::CLinuxInputDevicesCheckHotplugged(CLinuxInputDevices &parent) :
+    CThread("CLinuxInputDevicesCheckHotplugged"), m_parent(parent)
+{
+  Create();
+  SetPriority(THREAD_PRIORITY_BELOW_NORMAL);
+}
+
+CLinuxInputDevicesCheckHotplugged::~CLinuxInputDevicesCheckHotplugged()
+{
+  m_bStop = true;
+  m_quitEvent.Set();
+  StopThread(true);
+}
+
+void CLinuxInputDevicesCheckHotplugged::Process()
+{
+  while (!m_bStop)
+  {
+    m_parent.CheckHotplugged();
+    // every ten seconds
+    m_quitEvent.WaitMSec(10000);
+  }
+}
+
+/*
+ * this function is not powerful because it reinitializes a new udev search each
+ * time it would be nicer to call this only one time + one time at each hotplug
+ * but it is already very fast, so, let's keep it simple and non intrusive
+ */
+bool CLinuxInputDevices::IsUdevJoystick(const char *devpath)
+{
+#if defined(HAVE_LIBUDEV)
+  struct udev *udev;
+  struct udev_enumerate *enumerate;
+  struct udev_list_entry *devices, *dev_list_entry;
+  struct udev_device *dev;
+  const char *path;
+  const char *devfoundpath;
+
+  udev = udev_new();
+  if (!udev)
+    return false; // can't create udev
+
+  enumerate = udev_enumerate_new(udev);
+  if (enumerate == NULL)
+  {
+    udev_unref(udev);
+    return false;
+  }
+
+  if (udev_enumerate_add_match_subsystem(enumerate, "input") == 0)
+  {
+    if (udev_enumerate_add_match_property(enumerate, "ID_INPUT_JOYSTICK", "1") == 0)
+    {
+      if (udev_enumerate_scan_devices(enumerate) >= 0)
+      {
+        devices = udev_enumerate_get_list_entry(enumerate);
+
+        udev_list_entry_foreach(dev_list_entry, devices)
+        {
+          path = udev_list_entry_get_name(dev_list_entry);
+          dev = udev_device_new_from_syspath(udev, path);
+          if (dev != NULL)
+          {
+            devfoundpath = udev_device_get_devnode(dev);
+            if (devfoundpath != NULL)
+            {
+              // found (finally !)
+              //printf("=> %s\n", devfoundpath);
+              if (strcmp(devfoundpath, devpath) == 0)
+              {
+                udev_device_unref(dev);
+                udev_enumerate_unref(enumerate);
+                udev_unref(udev);
+                return true;
+              }
+            }
+            udev_device_unref(dev);
+          }
+        }
+      }
+    }
+  }
+
+  udev_enumerate_unref(enumerate);
+  udev_unref(udev);
+#endif
+
+  return false;
+}
+
+bool CLinuxInputDevices::CheckDevice(const char *device)
+{
+  int fd;
+
+  // Does the device exists?
+  struct stat buffer;
+  if (stat(device, &buffer) != 0)
+    return false;
+
+  /* Check if we are able to open the device */
+  fd = open(device, O_RDWR);
+  if (fd < 0)
+    return false;
+
+  // let others handle joysticks
+  if (IsUdevJoystick(device))
+  {
+    close(fd);
+    return false;
+  }
+
+#if !defined(TARGET_STB_EXTEND)
+  if (ioctl(fd, EVIOCGRAB, 1) && errno != EINVAL)
+  {
+    close(fd);
+    return false;
+  }
+
+  ioctl(fd, EVIOCGRAB, 0);
+#endif
+
+  close(fd);
+
+  return true;
+}
+
+/* exported symbols */
+
+/*
+ * Return the number of available devices.
+ * Called once during initialization of DirectFB.
+ */
+void CLinuxInputDevices::InitAvailable()
+{
+  CSingleLock lock(m_devicesListLock);
+
+  /* Close any devices that may have been initialized previously */
+  for (size_t i = 0; i < m_devices.size(); i++)
+  {
+    delete m_devices[i];
+  }
+  m_devices.clear();
+
+  int deviceId = 0;
+
+  /* No devices specified. Try to guess some. */
+  for (int i = 0; i < MAX_LINUX_INPUT_DEVICES; i++)
+  {
+    char buf[32];
+
+    snprintf(buf, 32, "/dev/input/event%d", i);
+    if (CheckDevice(buf))
+    {
+      CLog::Log(LOGINFO, "Found input device %s", buf);
+      m_devices.push_back(new CLinuxInputDevice(buf, deviceId));
+      ++deviceId;
+    }
+  }
+}
+
+/*
+ * Check for hot plugged devices.
+ */
+void CLinuxInputDevices::CheckHotplugged()
+{
+  /* No devices specified. Try to guess some. */
+  for (int i = 0; i < MAX_LINUX_INPUT_DEVICES; i++)
+  {
+    char buf[32];
+    bool ispresent = false;
+
+    snprintf(buf, 32, "/dev/input/event%d", i);
+    {
+      CSingleLock lock(m_devicesListLock);
+      for (size_t j = 0; j < m_devices.size(); j++)
+      {
+        if (m_devices[j]->GetFileName().compare(buf) == 0)
+        {
+          ispresent = true;
+          break;
+        }
+      }
+    }
+
+    if (!ispresent && CheckDevice(buf))
+    {
+      CSingleLock lock(m_devicesListLock);
+      int deviceId = m_devices.size();
+      CLog::Log(LOGINFO, "Found input device %s", buf);
+      m_devices.push_back(new CLinuxInputDevice(buf, deviceId));
+      ++deviceId;
+    }
+  }
+}
+
+/*
+ * Open the device, fill out information about it,
+ * allocate and fill private data, start input thread.
+ */
+bool CLinuxInputDevice::Open()
+{
+  int fd, ret;
+  unsigned long ledbit[NBITS(LED_CNT)];
+
+  /* open device */
+  fd = open(m_fileName.c_str(), O_RDWR | O_NONBLOCK);
+  if (fd < 0)
+  {
+    CLog::Log(LOGERROR, "CLinuxInputDevice: could not open device: %s\n", m_fileName.c_str());
+    return false;
+  }
+
+#if !defined(TARGET_STB_EXTEND)
+  /* grab device */
+  ret = ioctl(fd, EVIOCGRAB, 1);
+  if (ret && errno != EINVAL)
+  {
+    CLog::Log(LOGERROR, "CLinuxInputDevice: could not grab device: %s\n", m_fileName.c_str());
+    close(fd);
+    return false;
+  }
+#endif
+
+  // Set the socket to non-blocking
+  int opts = 0;
+  if ((opts = fcntl(fd, F_GETFL)) < 0)
+  {
+    CLog::Log(LOGERROR, "CLinuxInputDevice %s: fcntl(F_GETFL) failed: %s", __FUNCTION__ , strerror(errno));
+    close(fd);
+    return false;
+  }
+
+  opts = (opts | O_NONBLOCK);
+  if (fcntl(fd, F_SETFL, opts) < 0)
+  {
+    CLog::Log(LOGERROR, "CLinuxInputDevice %s: fcntl(F_SETFL) failed: %s", __FUNCTION__, strerror(errno));
+    close(fd);
+    return false;
+  }
+
+  /* fill device info structure */
+  GetInfo(fd);
+
+  if (m_deviceType & LI_DEVICE_KEYBOARD)
+    SetupKeyboardAutoRepeat(fd);
+
+  m_fd = fd;
+  m_vt_fd = -1;
+
+  if (m_deviceMinKeyCode >= 0 && m_deviceMaxKeyCode >= m_deviceMinKeyCode)
+  {
+    if (m_vt_fd < 0)
+      m_vt_fd = open("/dev/tty0", O_RDWR | O_NOCTTY);
+ 
+    if (m_vt_fd < 0)
+      m_vt_fd = open("/dev/tty1", O_RDWR | O_NOCTTY);
+
+    if (m_vt_fd < 0)
+      CLog::Log(LOGWARNING, "no keymap support (requires /dev/tty0 - CONFIG_VT)");
+  }
+
+  /* check if the device has LEDs */
+  ret = ioctl(fd, EVIOCGBIT(EV_LED, sizeof(ledbit)), ledbit);
+  if (ret < 0)
+	  CLog::Log(LOGWARNING, "DirectFB/linux_input: could not get LED bits" );
+  else
+    m_hasLeds = test_bit( LED_SCROLLL, ledbit ) || test_bit( LED_NUML, ledbit )
+        || test_bit( LED_CAPSL, ledbit );
+
+  if (m_hasLeds)
+  {
+    /* get LED state */
+    ret = ioctl(fd, EVIOCGLED(sizeof(m_ledState)), m_ledState);
+    if (ret < 0)
+    {
+      CLog::Log(LOGERROR, "DirectFB/linux_input: could not get LED state");
+      goto driver_open_device_error;
+    }
+
+    /* turn off LEDs */
+    SetLed(LED_SCROLLL, 0);
+    SetLed(LED_NUML, 0);
+    SetLed(LED_CAPSL, 0);
+  }
+
+  return true;
+
+driver_open_device_error:
+
+#if !defined(TARGET_STB_EXTEND)
+  ioctl(fd, EVIOCGRAB, 0);
+#endif
+  if (m_vt_fd >= 0)
+  {
+    close(m_vt_fd);
+    m_vt_fd = -1;
+  }
+  close(fd);
+  m_fd = -1;
+
+  return false;
+}
+
+/*
+ * Fetch one entry from the kernel keymap.
+ */
+bool CLinuxInputDevice::GetKeymapEntry(KeymapEntry& entry)
+{
+  int code = entry.code;
+  unsigned short value;
+  //DFBInputDeviceKeyIdentifier identifier;
+
+  if (m_vt_fd < 0)
+    return false;
+
+  // to support '+'  and '/' with Boxee's remote control we do something ugly like this for now
+  if (KVAL(code) == 98)
+  {
+    code = K(KTYP(code),53);
+  }
+
+  /* fetch the base level */
+  value = KeyboardGetSymbol(KeyboardReadValue(K_NORMTAB, code));
+  //printf("base=%d typ=%d code %d\n", KVAL(value), KTYP(value), code);
+
+  /* write base level symbol to entry */
+  entry.base = value; //KeyboardGetSymbol(code, value, LI_KEYLEVEL_BASE);
+
+  /* fetch the shifted base level */
+  value = KeyboardGetSymbol(KeyboardReadValue(K_SHIFTTAB, entry.code));
+  //printf("shift=%d\n", value);
+
+  /* write shifted base level symbol to entry */
+  entry.shift = value; //KeyboardGetSymbol(code, value, LI_KEYLEVEL_SHIFT);
+
+  // to support '+'  and '/' with Boxee's remote control we could do ugly something like this for now
+  if (KVAL(code) == 78)
+  {
+    //code = K(KTYP(code),13);
+    //entry.code = K(KTYP(code),13);
+    entry.base = K(KTYP(code),43);
+  }
+
+  /* fetch the alternative level */
+  value = KeyboardGetSymbol(KeyboardReadValue(K_ALTTAB, entry.code));
+  //printf("alt=%d\n", value);
+
+  /* write alternative level symbol to entry */
+  entry.alt = value; //KeyboardGetSymbol(code, value, LI_KEYLEVEL_ALT);
+
+  /* fetch the shifted alternative level */
+  value = KeyboardGetSymbol(KeyboardReadValue(K_ALTSHIFTTAB, entry.code));
+  //printf("altshift=%d\n", value);
+
+  /* write shifted alternative level symbol to entry */
+  entry.altShift = value; //KeyboardGetSymbol(code, value, LI_KEYLEVEL_ALT_SHIFT);
+
+  return true;
+}
+
+/*
+ * End thread, close device and free private data.
+ */
+void CLinuxInputDevice::Close()
+{
+#if !defined(TARGET_STB_EXTEND)
+  /* release device */
+  ioctl(m_fd, EVIOCGRAB, 0);
+#endif
+
+  if (m_vt_fd >= 0)
+    close(m_vt_fd);
+
+  /* close file */
+  close(m_fd);
+}
+
+XBMC_Event CLinuxInputDevices::ReadEvent()
+{
+  if (m_bReInitialize)
+  {
+    InitAvailable();
+    m_bReInitialize = false;
+  }
+  CSingleLock lock(m_devicesListLock);
+
+  XBMC_Event event;
+  event.type = XBMC_NOEVENT;
+
+  for (size_t i = 0; i < m_devices.size(); i++)
+  {
+    event = m_devices[i]->ReadEvent();
+    if (event.type != XBMC_NOEVENT)
+    {
+      break;
+    }
+
+    if (m_devices[i]->IsUnplugged())
+    {
+      m_bReInitialize = true;
+      break;
+    }
+  }
+
+  return event;
+}
+
+/*
+   - 0x7F -> if not paired, battery OK
+   - 0xFF -> if paired, battery OK
+   - 0x00 -> if not paired, battery low
+   - 0x80 -> if paired, battery low
+*/
+bool CLinuxInputDevices::IsRemoteLowBattery()
+{
+  bool bLowBattery = !(remoteStatus & 0xF);
+  return bLowBattery;
+}
+
+bool CLinuxInputDevices::IsRemoteNotPaired()
+{
+  bool bRemoteNotPaired = !(remoteStatus & 0x70) || !(remoteStatus & 0x80);
+  return bRemoteNotPaired;
+}
+
+/*
+int main()
+{
+  CLinuxInputDevices devices;
+  devices.InitAvailable();
+  while (1)
+  {
+    XBMC_Event event = devices.ReadEvent();
+    if (event.type != XBMC_NOEVENT)
+    {
+      printf("%d\n", event.type);
+    }
+    usleep(1000);
+  }
+
+}
+*/
+//#endif
diff --git a/xbmc/platform/linux/input/LinuxInputDevices.h b/xbmc/platform/linux/input/LinuxInputDevices.h
new file mode 100644
index 0000000..23794ab
--- /dev/null
+++ b/xbmc/platform/linux/input/LinuxInputDevices.h
@@ -0,0 +1,125 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#ifndef LINUXINPUTDEVICES_H_
+#define LINUXINPUTDEVICES_H_
+
+#include <vector>
+#include <string>
+#include <deque>
+#include "windowing/XBMC_events.h"
+#include "input/XBMC_keyboard.h"
+#include "threads/SingleLock.h"
+#include "input/touch/ITouchInputHandler.h"
+#include "input/touch/generic/IGenericTouchGestureDetector.h"
+#include "input/touch/generic/GenericTouchInputHandler.h"
+#include "threads/Thread.h"
+
+struct KeymapEntry
+{
+  int code;
+  unsigned short base;
+  unsigned short shift;
+  unsigned short alt;
+  unsigned short altShift;
+};
+
+class CLinuxInputDevice
+{
+public:
+  CLinuxInputDevice(const std::string& fileName, int index);
+  ~CLinuxInputDevice();
+  XBMC_Event ReadEvent();
+  const std::string& GetFileName();
+  bool IsUnplugged();
+ 
+private:
+  void SetupKeyboardAutoRepeat(int fd);
+  XBMCKey TranslateKey(unsigned short code);
+  bool KeyEvent(const struct input_event& levt, XBMC_Event& devt);
+  bool RelEvent(const struct input_event& levt, XBMC_Event& devt);
+  bool AbsEvent(const struct input_event& levt, XBMC_Event& devt);
+  bool TranslateEvent(const struct input_event& levt, XBMC_Event& devt);
+  void SetLed(int led, int state);
+  void GetInfo(int fd);
+  bool Open();
+  void Close();
+  unsigned short KeyboardReadValue(unsigned char table, unsigned char index);
+  XBMCMod UpdateModifiers(XBMC_Event& devt);
+  bool GetKeymapEntry(KeymapEntry& entry);
+  int KeyboardGetSymbol(unsigned short value);
+  bool mtAbsEvent(const struct input_event& levt);
+  bool mtSynEvent(const struct input_event& levt);
+
+  int m_fd;
+  int m_vt_fd;
+  bool m_hasLeds;
+  std::string m_fileName;
+  bool m_ledState[3];
+  int m_mouseX;
+  int m_mouseY;
+  int m_deviceIndex;
+  int m_keyMods;
+  int m_lastKeyMods;
+  char m_deviceName[256];
+  int m_deviceType;
+  int m_devicePreferredId;
+  int m_deviceCaps;
+  int m_deviceMinKeyCode;
+  int m_deviceMaxKeyCode;
+  int m_deviceMaxAxis;
+  bool m_bSkipNonKeyEvents;
+  bool m_bUnplugged;
+  std::deque<XBMC_Event> m_equeue;
+  int m_mt_currentSlot;
+  int m_mt_x[CGenericTouchInputHandler::MAX_POINTERS];
+  int m_mt_y[CGenericTouchInputHandler::MAX_POINTERS];
+  TouchInput m_mt_event[CGenericTouchInputHandler::MAX_POINTERS];
+};
+
+class CLinuxInputDevices
+{
+public:
+  void InitAvailable();
+  void CheckHotplugged();
+  XBMC_Event ReadEvent();
+  bool IsRemoteLowBattery();
+  bool IsRemoteNotPaired();
+  size_t Size() { return m_devices.size(); }
+private:
+  CCriticalSection m_devicesListLock;
+  bool IsUdevJoystick(const char *devpath);
+  bool CheckDevice(const char *device);
+  std::vector<CLinuxInputDevice*> m_devices;
+  bool m_bReInitialize;
+};
+
+class CLinuxInputDevicesCheckHotplugged : protected CThread
+{
+public:
+  CLinuxInputDevicesCheckHotplugged(CLinuxInputDevices &parent);
+  ~CLinuxInputDevicesCheckHotplugged();
+private:
+  CLinuxInputDevices &m_parent;
+  CEvent m_quitEvent;
+protected:
+  virtual void Process();
+};
+
+#endif /* LINUXINPUTDEVICES_H_ */
diff --git a/xbmc/system_gl.h b/xbmc/system_gl.h
index 09dce65..ca76b65 100644
--- a/xbmc/system_gl.h
+++ b/xbmc/system_gl.h
@@ -29,6 +29,9 @@
   #if defined(TARGET_DARWIN)
     #include <OpenGLES/ES2/gl.h>
     #include <OpenGLES/ES2/glext.h>
+  #elif defined(TARGET_V3DNXPL)
+    #include <GLES3/gl31.h>
+    #include <GLES2/gl2ext.h>
   #else
     #include <GLES2/gl2.h>
     #include <GLES2/gl2ext.h>
diff --git a/xbmc/utils/CMakeLists.txt b/xbmc/utils/CMakeLists.txt
index 6dbee35..8e8ffcc 100644
--- a/xbmc/utils/CMakeLists.txt
+++ b/xbmc/utils/CMakeLists.txt
@@ -164,6 +164,11 @@ set(HEADERS ActorProtocol.h
             XBMCTinyXML.h
             XMLUtils.h)
 
+if (WITH_PLATFORM STREQUAL "dreambox-cortexa15" OR WITH_PLATFORM STREQUAL "dreambox-mipsel")
+  list(APPEND SOURCES DreamboxUtils.cpp)
+  list(APPEND HEADERS DreamboxUtils.h)
+endif()
+
 if(XSLT_FOUND)
   list(APPEND SOURCES XSLTUtils.cpp)
   list(APPEND HEADERS XSLTUtils.h)
diff --git a/xbmc/utils/DreamboxUtils.cpp b/xbmc/utils/DreamboxUtils.cpp
new file mode 100644
index 0000000..30e6ae3
--- /dev/null
+++ b/xbmc/utils/DreamboxUtils.cpp
@@ -0,0 +1,103 @@
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "DreamboxUtils.h"
+#include "guilib/gui3d.h"
+#include "utils/StringUtils.h"
+#include "windowing/GraphicContext.h"
+
+bool dreambox_mode_to_resolution(const char *mode, RESOLUTION_INFO *res)
+{
+  if (!res)
+    return false;
+
+  res->iWidth = 0;
+  res->iHeight = 0;
+  res->iScreenWidth = 0;
+  res->iScreenHeight = 0;
+
+  if (!mode)
+    return false;
+
+  std::string fromMode = mode;
+  StringUtils::Trim(fromMode);
+
+  const char types[] = { 'p', 'i', 'x' };
+  for (unsigned int i = 0; i < 3; i++) {
+    std::size_t pos = fromMode.find(types[i]);
+    if (pos == 0 || pos == std::string::npos)
+      continue;
+
+    std::string t1 = fromMode.substr(0, pos);
+    if (!StringUtils::IsInteger(t1))
+      return false;
+
+    std::string t2 = fromMode.substr(pos + 1);
+    if (types[i] == 'x') {
+      if (StringUtils::IsInteger(t2)) {
+        res->iScreenWidth = StringUtils::ReturnDigits(t1);
+        res->iScreenHeight = StringUtils::ReturnDigits(t2);
+      }
+    } else {
+      res->iScreenHeight = StringUtils::ReturnDigits(t1);
+
+      if (t2.empty())
+        res->fRefreshRate = 60;
+      else if (StringUtils::IsInteger(t2))
+        res->fRefreshRate = StringUtils::ReturnDigits(t2);
+
+      if (types[i] == 'p')
+        res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
+      else
+        res->dwFlags = D3DPRESENTFLAG_INTERLACED;
+
+      if (res->iScreenHeight == 480)
+        res->iScreenWidth = 640;
+      else if (res->iScreenHeight == 576)
+        res->iScreenWidth = 720;
+      else if (res->iScreenHeight == 720)
+        res->iScreenWidth = 1280;
+      else if (res->iScreenHeight == 1080)
+        res->iScreenWidth = 1920;
+      else if (res->iScreenHeight == 2160)
+        res->iScreenWidth = 3840;
+
+      break;
+    }
+  }
+
+  if (res->iScreenHeight > 1080) {
+    res->iWidth = 1920;
+    res->iHeight = 1080;
+  } else {
+    res->iWidth = res->iScreenWidth;
+    res->iHeight = res->iScreenHeight;
+  }
+
+  res->bFullScreen   = true;
+  res->iSubtitles    = (int)(0.965 * res->iHeight);
+  res->fPixelRatio   = 1.0f;
+  res->strId         = fromMode;
+  res->strMode       = StringUtils::Format("%dx%d @ %.2f%s - Full Screen", res->iScreenWidth, res->iScreenHeight, res->fRefreshRate,
+    res->dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+
+  return res->iWidth > 0 && res->iHeight> 0;
+}
+
diff --git a/xbmc/utils/DreamboxUtils.h b/xbmc/utils/DreamboxUtils.h
new file mode 100644
index 0000000..3f845cb
--- /dev/null
+++ b/xbmc/utils/DreamboxUtils.h
@@ -0,0 +1,25 @@
+#pragma once
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "windowing/Resolution.h"
+
+bool dreambox_mode_to_resolution(const char *mode, RESOLUTION_INFO *res);
+
diff --git a/xbmc/utils/EGLUtils.cpp b/xbmc/utils/EGLUtils.cpp
index 25d9398..d3ef850 100644
--- a/xbmc/utils/EGLUtils.cpp
+++ b/xbmc/utils/EGLUtils.cpp
@@ -98,7 +98,7 @@ std::map<EGLenum, const char*> eglErrors =
 std::map<EGLint, const char*> eglErrorType =
 {
 //! @todo remove when Raspberry Pi updates their EGL headers
-#if !defined(TARGET_RASPBERRY_PI)
+#if !defined(TARGET_RASPBERRY_PI) && !defined(TARGET_STB)
   X(EGL_DEBUG_MSG_CRITICAL_KHR),
   X(EGL_DEBUG_MSG_ERROR_KHR),
   X(EGL_DEBUG_MSG_WARN_KHR),
@@ -110,7 +110,7 @@ std::map<EGLint, const char*> eglErrorType =
 } // namespace
 
 //! @todo remove when Raspberry Pi updates their EGL headers
-#if !defined(TARGET_RASPBERRY_PI)
+#if !defined(TARGET_RASPBERRY_PI) && !defined(TARGET_STB)
 void EglErrorCallback(EGLenum error, const char *command, EGLint messageType, EGLLabelKHR threadLabel, EGLLabelKHR objectLabel, const char* message)
 {
   std::string errorStr;
@@ -190,7 +190,7 @@ CEGLContextUtils::CEGLContextUtils(EGLenum platform, std::string const& platform
 : m_platform{platform}
 {
 //! @todo remove when Raspberry Pi updates their EGL headers
-#if !defined(TARGET_RASPBERRY_PI)
+#if !defined(TARGET_RASPBERRY_PI) && !defined(TARGET_STB)
   if (CEGLUtils::HasClientExtension("EGL_KHR_debug"))
   {
     auto eglDebugMessageControl = CEGLUtils::GetRequiredProcAddress<PFNEGLDEBUGMESSAGECONTROLKHRPROC>("eglDebugMessageControlKHR");
@@ -405,7 +405,7 @@ bool CEGLContextUtils::CreateContext(CEGLAttributesVec contextAttribs)
     contextAttribs.Add({{EGL_CONTEXT_PRIORITY_LEVEL_IMG, EGL_CONTEXT_PRIORITY_HIGH_IMG}});
 
 //! @todo remove when Raspberry Pi updates their EGL headers
-#if !defined(TARGET_RASPBERRY_PI)
+#if !defined(TARGET_RASPBERRY_PI) && !defined(TARGET_STB)
   if (CEGLUtils::HasExtension(m_eglDisplay, "EGL_KHR_create_context") &&
       CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_openGlDebugging)
   {
diff --git a/xbmc/utils/GLUtils.cpp b/xbmc/utils/GLUtils.cpp
index e381fd6..bb03993 100644
--- a/xbmc/utils/GLUtils.cpp
+++ b/xbmc/utils/GLUtils.cpp
@@ -42,7 +42,7 @@ std::map<GLenum, const char*> glErrors =
 std::map<GLenum, const char*> glErrorSource =
 {
 //! @todo remove TARGET_RASPBERRY_PI when Raspberry Pi updates their GL headers
-#if defined(HAS_GLES) && defined(TARGET_LINUX) && !defined(TARGET_RASPBERRY_PI)
+#if defined(HAS_GLES) && defined(TARGET_LINUX) && !defined(TARGET_RASPBERRY_PI) && !defined(TARGET_STB)
   X(GL_DEBUG_SOURCE_API_KHR),
   X(GL_DEBUG_SOURCE_WINDOW_SYSTEM_KHR),
   X(GL_DEBUG_SOURCE_SHADER_COMPILER_KHR),
@@ -55,7 +55,7 @@ std::map<GLenum, const char*> glErrorSource =
 std::map<GLenum, const char*> glErrorType =
 {
 //! @todo remove TARGET_RASPBERRY_PI when Raspberry Pi updates their GL headers
-#if defined(HAS_GLES) && defined(TARGET_LINUX) && !defined(TARGET_RASPBERRY_PI)
+#if defined(HAS_GLES) && defined(TARGET_LINUX) && !defined(TARGET_RASPBERRY_PI) && !defined(TARGET_STB)
   X(GL_DEBUG_TYPE_ERROR_KHR),
   X(GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_KHR),
   X(GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_KHR),
@@ -69,7 +69,7 @@ std::map<GLenum, const char*> glErrorType =
 std::map<GLenum, const char*> glErrorSeverity =
 {
 //! @todo remove TARGET_RASPBERRY_PI when Raspberry Pi updates their GL headers
-#if defined(HAS_GLES) && defined(TARGET_LINUX) && !defined(TARGET_RASPBERRY_PI)
+#if defined(HAS_GLES) && defined(TARGET_LINUX) && !defined(TARGET_RASPBERRY_PI) && !defined(TARGET_STB)
   X(GL_DEBUG_SEVERITY_HIGH_KHR),
   X(GL_DEBUG_SEVERITY_MEDIUM_KHR),
   X(GL_DEBUG_SEVERITY_LOW_KHR),
diff --git a/xbmc/windowing/egl/CMakeLists.txt b/xbmc/windowing/egl/CMakeLists.txt
new file mode 100644
index 0000000..1ffa32a
--- /dev/null
+++ b/xbmc/windowing/egl/CMakeLists.txt
@@ -0,0 +1,62 @@
+set(SOURCES WinSystemSTBContext.cpp
+            WinSystemstb.cpp
+            EGLWrapper.cpp
+            WinEventsSTB.cpp)
+
+set(HEADERS EGLNativeType.h
+            EGLQuirks.h
+            EGLWrapper.h
+            WinSystemstb.h
+            WinSystemSTBContext.h
+            WinEventsSTB.h)
+
+if (WITH_PLATFORM STREQUAL "GB-cortexa15")
+  list(APPEND SOURCES EGLNativeTypeGB.cpp)
+  list(APPEND HEADERS EGLNativeTypeGB.h)
+endif()
+if (WITH_PLATFORM STREQUAL "dags-cortexa15")
+  list(APPEND SOURCES EGLNativeTypeDags.cpp)
+  list(APPEND HEADERS EGLNativeTypeDags.h)
+endif()
+if (WITH_PLATFORM STREQUAL "dreambox-cortexa15")
+  list(APPEND SOURCES EGLNativeTypeDreambox.cpp)
+  list(APPEND HEADERS EGLNativeTypeDreambox.h)
+endif()
+if (WITH_PLATFORM STREQUAL "dreambox-mipsel")
+  list(APPEND SOURCES EGLNativeTypeDreambox.cpp)
+  list(APPEND HEADERS EGLNativeTypeDreambox.h)
+endif()
+if (WITH_PLATFORM STREQUAL "vuplus-cortexa15")
+  list(APPEND SOURCES EGLNativeTypeVuplus.cpp)
+  list(APPEND HEADERS EGLNativeTypeVuplus.h)
+endif()
+if (WITH_PLATFORM STREQUAL "vuplus-mipsel")
+  list(APPEND SOURCES EGLNativeTypeVuplus.cpp)
+  list(APPEND HEADERS EGLNativeTypeVuplus.h)
+endif()
+if (WITH_PLATFORM STREQUAL "v3d-cortexa15")
+  list(APPEND SOURCES EGLNativeTypeV3DNXPL.cpp)
+  list(APPEND HEADERS EGLNativeTypeV3DNXPL.h)
+endif()
+if (WITH_PLATFORM STREQUAL "v3d-mipsel")
+  list(APPEND SOURCES EGLNativeTypeV3DNXPL.cpp)
+  list(APPEND HEADERS EGLNativeTypeV3DNXPL.h)
+endif()
+if (WITH_PLATFORM STREQUAL "xcore-mipsel")
+  list(APPEND SOURCES EGLNativeTypeV3D.cpp)
+  list(APPEND HEADERS EGLNativeTypeV3D.h)
+endif()
+if (WITH_PLATFORM STREQUAL "nextv-cortexa15")
+  list(APPEND SOURCES EGLNativeTypeNexTV.cpp)
+  list(APPEND HEADERS EGLNativeTypeNexTV.h)
+endif()
+if (WITH_PLATFORM STREQUAL "mali-cortexa15" OR WITH_PLATFORM STREQUAL "clap-cortexa15")
+  list(APPEND SOURCES EGLNativeTypeMali.cpp)
+  list(APPEND HEADERS EGLNativeTypeMali.h)
+endif()
+if (WITH_PLATFORM STREQUAL "edision-cortexa15")
+  list(APPEND SOURCES EGLNativeTypeEdision.cpp)
+  list(APPEND HEADERS EGLNativeTypeEdision.h)
+endif()
+
+core_add_library(windowing_egl)
diff --git a/xbmc/windowing/egl/EGLNativeType.h b/xbmc/windowing/egl/EGLNativeType.h
new file mode 100644
index 0000000..48987ad
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeType.h
@@ -0,0 +1,152 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <string>
+#include <vector>
+
+#include "windowing/Resolution.h"
+#include "EGLQuirks.h"
+
+typedef void* XBNativeDisplayType;
+typedef void* XBNativeWindowType;
+
+/*!
+This class provides extra functionality on top of EGL in order to facilitate
+the implementation-dependent functionality relating to creating, maintaining,
+and destroying screens and displays.
+
+Each implementation is required to implement each function, though it can
+simply return false to signify that the functionality does not exist.
+
+Internal state should be maintained by each implementation as little as possible.
+If any information needs to be saved outside of the NativeWindow and NativeDisplay
+for later retrieval, there is most likely a bug in the implementation, or in that
+platform's EGL implementation.
+
+Each implementation will be instantiated at runtime to see if it qualifies for use
+until one is found. For this reason, each should avoid operations in its ctors and
+dtors, instead using the provided Initialize() and Destroy() functions which are
+only called once the implementation has been selected.
+*/
+
+class CEGLNativeType
+{
+public:
+
+ /*! \brief Do NOT clean up in the destructor, use the Destroy function
+    instead.
+
+    \sa: Destroy() */
+  virtual ~CEGLNativeType(){};
+
+/*! \brief Unique identifier for this EGL implementation.
+
+   It should be unique enough to set it apart from other possible implementations
+   on a similar platform. */
+  virtual std::string GetNativeName() const = 0;
+
+/*! \brief A function for testing whether this implementation should be used.
+
+  On platforms where several implementations are possible, it should provide a
+  stringent test to rule out false-positives. */
+  virtual bool  CheckCompatibility() = 0;
+
+/*! \brief Initialize any local variables and/or structures here.
+
+    This is called after the implementation has been chosen, which is why this
+    should be used rather than the ctor. */
+  virtual void  Initialize() = 0;
+
+/*! \brief Destroy any local variables and/or structures here.
+
+    This is called when the WindowSystem has been destroyed. */
+  virtual void  Destroy() = 0;
+
+/*! \brief EGL implementation quirks.
+
+    Set any EGL oddities here so that they can be queried during the window's
+    life-cycle. */
+  virtual int   GetQuirks() = 0;
+
+/*! \brief Create the EGL Native Display
+
+    An Implementation-dependent method should be used to create a native
+    display and store it in m_nativeDisplay. XBMC will terminate if this
+    fails */
+  virtual bool  CreateNativeDisplay() = 0;
+
+/*! \brief Create the EGL Native Window
+
+    An Implementation-dependent method should be used to create a native
+    window and store it in m_nativeWindow. XBMC Will terminate if this fails.
+    If possible, the created window should use the current display's geometry
+    and allocate as needed so that it is immediately available for use.
+    If not, it must be made ready by SetNativeResolution(). */
+  virtual bool  CreateNativeWindow() = 0;
+
+/*! \brief Returns the current Native Display */
+  virtual bool  GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const = 0;
+
+/*! \brief Returns the current Native Window */
+  virtual bool  GetNativeWindow(XBNativeWindowType **nativeWindow) const = 0;
+
+/*! \brief Destroy the Native Window
+
+    An Implementation-dependent method should be used to destroy the current
+    Native Window */
+  virtual bool  DestroyNativeWindow() = 0;
+
+/*! \brief Destroy The Native Display
+
+    An Implementation-dependent method should be used to destroy the current
+    Native Display */
+  virtual bool  DestroyNativeDisplay() = 0;
+
+/*! \brief Return the current display's resolution
+
+    This is completely independent of XBMC's internal resolution */
+  virtual bool  GetNativeResolution(RESOLUTION_INFO *res) const = 0;
+
+/*! \brief Set the current display's resolution
+
+    This is completely independent of XBMC's internal resolution */
+  virtual bool  SetNativeResolution(const RESOLUTION_INFO &res) = 0;
+
+/*! \brief Query the display for all possible resolutions */
+  virtual bool  ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions) = 0;
+
+/*! \brief Provide a fall-back resolution
+
+    If all queried resolutions fail, this one is guaranteed to be compatible
+    with the display */
+  virtual bool  GetPreferredResolution(RESOLUTION_INFO *res) const = 0;
+
+/*! \brief Show/Hide the current window
+
+    A platform-independent way of hiding XBMC (for example blanking the current
+    framebuffer */
+  virtual bool  ShowWindow(bool show) = 0;
+
+protected:
+  XBNativeDisplayType  m_nativeDisplay;
+  XBNativeWindowType   m_nativeWindow;
+};
diff --git a/xbmc/windowing/egl/EGLNativeTypeDags.cpp b/xbmc/windowing/egl/EGLNativeTypeDags.cpp
new file mode 100644
index 0000000..850a0f5
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeDags.cpp
@@ -0,0 +1,336 @@
+/*
+ *      Copyright (C) 2011-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include "system.h"
+#include "EGLNativeTypeDags.h"
+#include "utils/StringUtils.h"
+#include "utils/SysfsUtils.h"
+#include "utils/log.h"
+#include "guilib/gui3d.h"
+//#include "linux/DllBCM.h"
+#include "windowing/GraphicContext.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <linux/fb.h>
+#include <sys/ioctl.h>
+#include <EGL/egl.h>
+
+CEGLNativeTypeDags::CEGLNativeTypeDags()
+{
+  m_nativeDisplay = NULL;
+  m_nativeWindow = NULL;
+}
+
+CEGLNativeTypeDags::~CEGLNativeTypeDags()
+{
+}  
+
+bool CEGLNativeTypeDags::CheckCompatibility()
+{
+  return true;
+}
+
+void CEGLNativeTypeDags::Initialize()
+{
+}
+
+void CEGLNativeTypeDags::Destroy()
+{
+}
+
+bool CEGLNativeTypeDags::CreateNativeDisplay()
+{
+  m_nativeDisplay = EGL_DEFAULT_DISPLAY;
+  return true;
+}
+
+bool CEGLNativeTypeDags::CreateNativeWindow()
+{
+  NxClient_Join(NULL);
+
+  NXPL_RegisterNexusDisplayPlatform(&nxpl_handle, nexus_display);
+  NXPL_NativeWindowInfoEXT nativeWindow;
+
+  NXPL_GetDefaultNativeWindowInfoEXT(&nativeWindow);
+
+  nativeWindow.x = 0;
+  nativeWindow.y = 0;
+  nativeWindow.width = 1280;
+  nativeWindow.height = 720;
+  nativeWindow.stretch = false;
+  nativeWindow.clientID = 0;
+  nativeWindow.zOrder = 0;
+  
+  m_nativeWindow = NXPL_CreateNativeWindowEXT(&nativeWindow);
+  if (!m_nativeWindow)
+    return false;
+  return true;
+}
+
+bool CEGLNativeTypeDags::GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const
+{
+  if (!nativeDisplay)	return false;
+  *nativeDisplay = (XBNativeDisplayType*) &m_nativeDisplay;
+  return true;
+}
+
+bool CEGLNativeTypeDags::GetNativeWindow(XBNativeDisplayType **nativeWindow) const
+{
+  if (!nativeWindow)	return false;
+  *nativeWindow = (XBNativeWindowType*) &m_nativeWindow;
+  return true;
+}
+
+bool CEGLNativeTypeDags::DestroyNativeDisplay()
+{
+    m_nativeDisplay = NULL;
+    return true;
+}
+
+bool CEGLNativeTypeDags::DestroyNativeWindow()
+{
+  NXPL_DestroyNativeWindow(m_nativeWindow);
+
+  NXPL_UnregisterNexusDisplayPlatform(nxpl_handle);
+  NxClient_Uninit();
+
+  return true;
+}
+
+bool CEGLNativeTypeDags::GetNativeResolution(RESOLUTION_INFO *res) const
+{
+  *res = m_desktopRes;
+  return true;
+}
+
+bool CEGLNativeTypeDags::SetNativeResolution(const RESOLUTION_INFO &res)
+{
+        m_desktopRes = res;
+        return true;
+}
+
+bool CEGLNativeTypeDags::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)
+{
+        int tmp_resolution = 0;
+        std::string mode;
+        SysfsUtils::GetString("/proc/stb/video/videomode", mode);
+
+        std::string fromMode = mode;        
+        StringUtils::Trim(fromMode);
+
+        const char types[] = { 'p', 'i', 'x' };
+        for (unsigned int i = 0; i < 3; i++) {
+                std::size_t pos = fromMode.find(types[i]);
+                if (pos == 0 || pos == std::string::npos)
+                        continue;
+                std::string t1 = fromMode.substr(0, pos);
+                if (!StringUtils::IsInteger(t1))
+                        return false;
+                tmp_resolution = StringUtils::ReturnDigits(t1);
+        }
+
+        resolutions.clear();
+
+        if ( tmp_resolution == 480 )
+                {
+                        m_desktopResAll[0].bFullScreen  = true;
+                        m_desktopResAll[0].iWidth       = 640;
+                        m_desktopResAll[0].iHeight      = 480;
+                        m_desktopResAll[0].iScreenWidth = 640;
+                        m_desktopResAll[0].iScreenHeight= 480;
+                        m_desktopResAll[0].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE;
+                        m_desktopResAll[0].fRefreshRate = 50;
+                        m_desktopResAll[0].fPixelRatio   = 1.0f;
+                        m_desktopResAll[0].strMode = StringUtils::Format("%dx%d", 640, 480);
+                        m_desktopResAll[0].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen", m_desktopResAll[0].strMode.c_str(), (float)50, m_desktopResAll[0].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+                        m_desktopResAll[0].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[0].iHeight);
+
+                        CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[0].strMode.c_str());
+
+                        resolutions.push_back(m_desktopResAll[0]);
+
+                        m_desktopResAll[1].bFullScreen  = true;
+                        m_desktopResAll[1].iWidth       = 640;
+                        m_desktopResAll[1].iHeight      = 480;
+                        m_desktopResAll[1].iScreenWidth = 640;
+                        m_desktopResAll[1].iScreenHeight= 480;
+                        m_desktopResAll[1].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE | D3DPRESENTFLAG_MODE3DSBS;
+                        m_desktopResAll[1].fRefreshRate = 50;
+                        m_desktopResAll[1].fPixelRatio   = 1.0f;
+                        m_desktopResAll[1].strMode = StringUtils::Format("%dx%d", 640, 480);
+                        m_desktopResAll[1].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen 3DSBS", m_desktopResAll[1].strMode.c_str(), (float)50, m_desktopResAll[1].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+                        m_desktopResAll[1].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[1].iHeight);
+
+                        CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[1].strMode.c_str());
+
+                        resolutions.push_back(m_desktopResAll[1]);
+
+                        m_desktopResAll[2].bFullScreen  = true;
+                        m_desktopResAll[2].iWidth       = 640;
+                        m_desktopResAll[2].iHeight      = 480;
+                        m_desktopResAll[2].iScreenWidth = 640;
+                        m_desktopResAll[2].iScreenHeight= 480;
+                        m_desktopResAll[2].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE | D3DPRESENTFLAG_MODE3DTB;
+                        m_desktopResAll[2].fRefreshRate = 50;
+                        m_desktopResAll[2].fPixelRatio   = 1.0f;
+                        m_desktopResAll[2].strMode = StringUtils::Format("%dx%d", 640, 480);
+                        m_desktopResAll[2].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen 3DTB", m_desktopResAll[2].strMode.c_str(), (float)50, m_desktopResAll[2].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+                        m_desktopResAll[2].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[2].iHeight);
+
+                        CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[2].strMode.c_str());
+
+                        resolutions.push_back(m_desktopResAll[2]);
+                }
+        else if ( tmp_resolution == 576 )
+                {
+                        m_desktopResAll[0].bFullScreen  = true;
+                        m_desktopResAll[0].iWidth       = 720;
+                        m_desktopResAll[0].iHeight      = 576;
+                        m_desktopResAll[0].iScreenWidth = 720;
+                        m_desktopResAll[0].iScreenHeight= 576;
+                        m_desktopResAll[0].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE;
+                        m_desktopResAll[0].fRefreshRate = 50;
+                        m_desktopResAll[0].fPixelRatio   = 1.0f;
+                        m_desktopResAll[0].strMode = StringUtils::Format("%dx%d", 720, 576);
+                        m_desktopResAll[0].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen", m_desktopResAll[0].strMode.c_str(), (float)50, m_desktopResAll[0].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+                        m_desktopResAll[0].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[0].iHeight);
+
+                        CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[0].strMode.c_str());
+
+                        resolutions.push_back(m_desktopResAll[0]);
+
+                        m_desktopResAll[1].bFullScreen  = true;
+                        m_desktopResAll[1].iWidth       = 720;
+                        m_desktopResAll[1].iHeight      = 576;
+                        m_desktopResAll[1].iScreenWidth = 720;
+                        m_desktopResAll[1].iScreenHeight= 576;
+                        m_desktopResAll[1].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE | D3DPRESENTFLAG_MODE3DSBS;
+                        m_desktopResAll[1].fRefreshRate = 50;
+                        m_desktopResAll[1].fPixelRatio   = 1.0f;
+                        m_desktopResAll[1].strMode = StringUtils::Format("%dx%d", 720, 576);
+                        m_desktopResAll[1].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen 3DSBS", m_desktopResAll[1].strMode.c_str(), (float)50, m_desktopResAll[1].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+                        m_desktopResAll[1].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[1].iHeight);
+
+                        CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[1].strMode.c_str());
+
+                        resolutions.push_back(m_desktopResAll[1]);
+
+                        m_desktopResAll[2].bFullScreen  = true;
+                        m_desktopResAll[2].iWidth       = 720;
+                        m_desktopResAll[2].iHeight      = 576;
+                        m_desktopResAll[2].iScreenWidth = 720;
+                        m_desktopResAll[2].iScreenHeight= 576;
+                        m_desktopResAll[2].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE | D3DPRESENTFLAG_MODE3DTB;
+                        m_desktopResAll[2].fRefreshRate = 50;
+                        m_desktopResAll[2].fPixelRatio   = 1.0f;
+                        m_desktopResAll[2].strMode = StringUtils::Format("%dx%d", 720, 576);
+                        m_desktopResAll[2].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen 3DTB", m_desktopResAll[2].strMode.c_str(), (float)50, m_desktopResAll[2].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+                        m_desktopResAll[2].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[2].iHeight);
+
+                        CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[2].strMode.c_str());
+
+                        resolutions.push_back(m_desktopResAll[2]);
+                }
+        else
+                {
+                        m_desktopResAll[0].bFullScreen  = true;
+                        m_desktopResAll[0].iWidth       = 1280;
+                        m_desktopResAll[0].iHeight      = 720;
+                        m_desktopResAll[0].iScreenWidth = 1280;
+                        m_desktopResAll[0].iScreenHeight= 720;
+                        m_desktopResAll[0].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE;
+                        m_desktopResAll[0].fRefreshRate = 50;
+                        m_desktopResAll[0].fPixelRatio   = 1.0f;
+                        m_desktopResAll[0].strMode = StringUtils::Format("%dx%d", 1280, 720);
+                        m_desktopResAll[0].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen", m_desktopResAll[0].strMode.c_str(), (float)50, m_desktopResAll[0].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+                        m_desktopResAll[0].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[0].iHeight);
+
+                        CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[0].strMode.c_str());
+
+                        resolutions.push_back(m_desktopResAll[0]);
+
+                        m_desktopResAll[1].bFullScreen  = true;
+                        m_desktopResAll[1].iWidth       = 1280;
+                        m_desktopResAll[1].iHeight      = 720;
+                        m_desktopResAll[1].iScreenWidth = 1280;
+                        m_desktopResAll[1].iScreenHeight= 720;
+                        m_desktopResAll[1].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE | D3DPRESENTFLAG_MODE3DSBS;
+                        m_desktopResAll[1].fRefreshRate = 50;
+                        m_desktopResAll[1].fPixelRatio   = 1.0f;
+                        m_desktopResAll[1].strMode = StringUtils::Format("%dx%d", 1280, 720);
+                        m_desktopResAll[1].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen 3DSBS", m_desktopResAll[1].strMode.c_str(), (float)50, m_desktopResAll[1].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+                        m_desktopResAll[1].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[1].iHeight);
+
+                        CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[1].strMode.c_str());
+
+                        resolutions.push_back(m_desktopResAll[1]);
+
+                        m_desktopResAll[2].bFullScreen  = true;
+                        m_desktopResAll[2].iWidth       = 1280;
+                        m_desktopResAll[2].iHeight      = 720;
+                        m_desktopResAll[2].iScreenWidth = 1280;
+                        m_desktopResAll[2].iScreenHeight= 720;
+                        m_desktopResAll[2].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE | D3DPRESENTFLAG_MODE3DTB;
+                        m_desktopResAll[2].fRefreshRate = 50;
+                        m_desktopResAll[2].fPixelRatio   = 1.0f;
+                        m_desktopResAll[2].strMode = StringUtils::Format("%dx%d", 1280, 720);
+                        m_desktopResAll[2].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen 3DTB", m_desktopResAll[2].strMode.c_str(), (float)50, m_desktopResAll[2].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+                        m_desktopResAll[2].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[2].iHeight);
+
+                        CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[2].strMode.c_str());
+
+                        resolutions.push_back(m_desktopResAll[2]);
+                }
+  
+        m_desktopRes = m_desktopResAll[0];
+
+        SetDisplayResolution(tmp_resolution);
+
+        return true;
+}
+
+bool CEGLNativeTypeDags::GetPreferredResolution(RESOLUTION_INFO *res) const
+{
+  *res = m_desktopResAll[0];
+  return true;
+}
+
+bool CEGLNativeTypeDags::ShowWindow(bool show)
+{
+  NXPL_ShowNativeWindowEXT(m_nativeWindow, show);
+  return true;
+}
+
+bool CEGLNativeTypeDags::SetDisplayResolution(int tmp_resolution)
+{
+        NXPL_NativeWindowInfoEXT nativeWindow;
+
+        NXPL_GetDefaultNativeWindowInfoEXT(&nativeWindow);
+        nativeWindow.x = nativeWindow.y = 0;
+        nativeWindow.width = m_desktopRes.iWidth;
+        nativeWindow.height = m_desktopRes.iHeight;
+
+        if (tmp_resolution == 1080 || tmp_resolution == 2160)
+                nativeWindow.stretch = true;
+        
+        NXPL_UpdateNativeWindowEXT(m_nativeWindow, &nativeWindow);
+
+        return true;
+}
diff --git a/xbmc/windowing/egl/EGLNativeTypeDags.h b/xbmc/windowing/egl/EGLNativeTypeDags.h
new file mode 100644
index 0000000..9d2176a
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeDags.h
@@ -0,0 +1,199 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "EGLNativeType.h"
+
+#include <vector>
+#include <string>
+
+#define NEXUS_DISPLAYHANDLE void*
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef void *NXPL_PlatformHandle;
+
+typedef enum NEXUS_BlendFactor
+{
+    NEXUS_BlendFactor_eZero
+} NEXUS_BlendFactor;
+
+typedef struct NEXUS_BlendEquation
+{
+    NEXUS_BlendFactor a;
+    NEXUS_BlendFactor b;
+    bool              subtract_cd;
+    NEXUS_BlendFactor c;
+    NEXUS_BlendFactor d;
+    bool              subtract_e;
+    NEXUS_BlendFactor e;
+} NEXUS_BlendEquation;
+
+typedef struct
+{
+   uint32_t             width;
+   uint32_t             height;
+   uint32_t             x;
+   uint32_t             y;
+   bool                 stretch;
+   uint32_t             clientID;
+   uint32_t             zOrder;
+   NEXUS_BlendEquation  colorBlend;
+   NEXUS_BlendEquation  alphaBlend;
+   uint32_t             magic;
+} NXPL_NativeWindowInfoEXT;
+
+/* FOR NXCLINET */
+typedef unsigned NEXUS_Error;
+
+#define NXCLIENT_MAX_NAME 32
+
+/***************************************************************************
+Summary:
+Autheticated ID for client/server communication.
+
+Description:
+For non-secure environments, the certificate could be a simple ID.
+For secure environments, this should use encrypted using standard public-key cryptography.
+***************************************************************************/
+typedef struct NEXUS_Certificate
+{
+    unsigned char data[256];
+    unsigned length;
+} NEXUS_Certificate;
+
+/**
+Summary:
+Client modes
+
+See nexus/docs/Nexus_MultiProcess.pdf for full discussion of process isolation and multi-process application design.
+**/
+typedef enum NEXUS_ClientMode
+{
+    NEXUS_ClientMode_eUnprotected, /* deprecated */
+    NEXUS_ClientMode_eVerified,    /* verify handle value, but not owner. unsynchronized caller may compromise nexus settings. */
+    NEXUS_ClientMode_eProtected,   /* full handle verification. access to full API. if client crashes, server is protected. */
+    NEXUS_ClientMode_eUntrusted,   /* full handle verification. access to limited API. see nexus/build/common/tools/nexus_untrusted_api.txt. if client crashes, server is protected. */
+    NEXUS_ClientMode_eMax
+} NEXUS_ClientMode;
+
+/**
+Summary:
+Join with Nexus server application (using app ipc) and Nexus driver (using Nexus multiprocess)
+
+Description:
+This dynamically registers a client with both nexus and the server app.
+NxClient_Join can be called from multiple processes, or multiple times from the same process.
+
+NxClient_Join is reference counted within the same process. You must call NxClient_Uninit an equal
+number of times to detach from nexus and the server app.
+**/
+typedef struct NxClient_JoinSettings
+{
+    char name[NXCLIENT_MAX_NAME];
+    bool tunnelCapable; /* deprecated */
+    unsigned timeout; /* in seconds. if unable to join, try again for this number of seconds. defaults to 0. */
+    unsigned session; /* set index to choose which session in a multi-session server configuration */
+    bool ignoreStandbyRequest; /* deprecated. see NxClient_RegisterAcknowledgeStandby() instead. */
+    NEXUS_ClientMode mode; /* requested client mode. server may reject the request. */
+    NEXUS_Certificate certificate; /* allows NEXUS_ClientMode_eProtected (aka trusted) status if server requires */
+} NxClient_JoinSettings;
+
+extern void NxClient_GetDefaultJoinSettings(NxClient_JoinSettings *pSettings);
+
+extern NEXUS_Error NxClient_Join(const NxClient_JoinSettings *pSettings);
+
+extern void NxClient_Uninit(void);
+
+
+/* Register a display for exclusive use. The client application should not use the display until
+ * calling NXPL_UnregisterNexusDisplayPlatform.
+ * It will register its own memory, h/w and display APIs suitable for basic exclusive mode rendering on
+ * a Nexus display.
+ * Fills in the NXPL platform handle, which must be passed back into the unregister function.
+ */
+void NXPL_RegisterNexusDisplayPlatform(NXPL_PlatformHandle *handle, NEXUS_DISPLAYHANDLE display);
+
+/* Unregister a display for exclusive use. The client application can the use the Nexus display again. */
+void NXPL_UnregisterNexusDisplayPlatform(NXPL_PlatformHandle handle);
+
+/* Generate a default NXPL_NativeWindowInfoEXT */
+void NXPL_GetDefaultNativeWindowInfoEXT(NXPL_NativeWindowInfoEXT *info);
+
+/* Create a 'native window' of the given size. This is really just a small structure that holds the size
+ * of the window that EGL will write into. */
+void *NXPL_CreateNativeWindowEXT(const NXPL_NativeWindowInfoEXT *info);
+
+/* Destroy a 'native window' */
+void NXPL_DestroyNativeWindow(void *nativeWin);
+
+/* Show/hide a 'native window' */
+void NXPL_ShowNativeWindowEXT(void *native,bool show);
+
+/* Update a 'native window' */
+void NXPL_UpdateNativeWindowEXT(void *native, NXPL_NativeWindowInfoEXT * nativeWindow);
+
+int NEXUS_Platform_AuthenticatedJoin(const void *settings);
+#define NEXUS_Platform_Join() NEXUS_Platform_AuthenticatedJoin(NULL)
+
+#ifdef __cplusplus
+}
+#endif
+
+class CEGLNativeTypeDags : public CEGLNativeType
+{
+public:
+  CEGLNativeTypeDags();
+  virtual ~CEGLNativeTypeDags();
+  virtual std::string GetNativeName() const { return "Dags"; };
+  virtual bool  CheckCompatibility();
+  virtual void  Initialize();
+  virtual void  Destroy();
+  virtual int   GetQuirks() { return EGL_QUIRK_NONE; };
+
+  virtual bool  CreateNativeDisplay();
+  virtual bool  CreateNativeWindow();
+  virtual bool  GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const;
+  virtual bool  GetNativeWindow(XBNativeWindowType **nativeWindow) const;
+
+  virtual bool  DestroyNativeWindow();
+  virtual bool  DestroyNativeDisplay();
+
+  virtual bool  GetNativeResolution(RESOLUTION_INFO *res) const;
+  virtual bool  SetNativeResolution(const RESOLUTION_INFO &res);
+  virtual bool  ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions);
+  virtual bool  GetPreferredResolution(RESOLUTION_INFO *res) const;
+
+  virtual bool  ShowWindow(bool show);
+
+private:
+  RESOLUTION_INFO m_desktopRes;
+  RESOLUTION_INFO m_desktopResAll[4];
+
+  NXPL_PlatformHandle nxpl_handle = 0;
+  NEXUS_DISPLAYHANDLE  nexus_display = 0;
+
+  bool SetDisplayResolution(int tmp_resolution);
+    /* bool */
+  bool dags_mode_to_resolution(const char *mode, RESOLUTION_INFO *res);
+};
diff --git a/xbmc/windowing/egl/EGLNativeTypeDreambox.cpp b/xbmc/windowing/egl/EGLNativeTypeDreambox.cpp
new file mode 100644
index 0000000..6c21fc44
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeDreambox.cpp
@@ -0,0 +1,192 @@
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "EGLNativeTypeDreambox.h"
+#include "guilib/gui3d.h"
+#include "utils/DreamboxUtils.h"
+#include "utils/StringUtils.h"
+#include "utils/SysfsUtils.h"
+
+#include <dlfcn.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <linux/fb.h>
+#include <sys/ioctl.h>
+#include <EGL/egl.h>
+
+CEGLNativeTypeDreambox::CEGLNativeTypeDreambox()
+{
+  m_nativeWindow = (XBNativeWindowType)0L;
+}
+
+CEGLNativeTypeDreambox::~CEGLNativeTypeDreambox()
+{
+}
+
+bool CEGLNativeTypeDreambox::CheckCompatibility()
+{
+  std::string name;
+  SysfsUtils::GetString("/proc/stb/info/model", name);
+  return name == "dm820" || name == "dm900" || name == "dm920" || name == "dm7080";
+}
+
+void CEGLNativeTypeDreambox::Initialize()
+{
+}
+
+void CEGLNativeTypeDreambox::Destroy()
+{
+}
+
+bool CEGLNativeTypeDreambox::CreateNativeDisplay()
+{
+  m_nativeDisplay = EGL_DEFAULT_DISPLAY;
+  return true;
+}
+
+bool CEGLNativeTypeDreambox::CreateNativeWindow()
+{
+  RESOLUTION_INFO res;
+  if (GetNativeResolution(&res))
+    SetFramebufferResolution(res.iWidth, res.iHeight);
+  else
+    SetFramebufferResolution(1280, 720);
+  return true;
+}
+
+bool CEGLNativeTypeDreambox::GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const
+{
+  if (!nativeDisplay)
+    return false;
+  *nativeDisplay = (XBNativeDisplayType *)&m_nativeDisplay;
+  return true;
+}
+
+bool CEGLNativeTypeDreambox::GetNativeWindow(XBNativeWindowType **nativeWindow) const
+{
+  if (!nativeWindow)
+    return false;
+  *nativeWindow = (XBNativeWindowType *)&m_nativeWindow;
+  return true;
+}
+
+bool CEGLNativeTypeDreambox::DestroyNativeDisplay()
+{
+  return true;
+}
+
+bool CEGLNativeTypeDreambox::DestroyNativeWindow()
+{
+  return true;
+}
+
+bool CEGLNativeTypeDreambox::GetNativeResolution(RESOLUTION_INFO *res) const
+{
+  std::string mode;
+  SysfsUtils::GetString("/proc/stb/video/videomode", mode);
+  return dreambox_mode_to_resolution(mode.c_str(), res);
+}
+
+bool CEGLNativeTypeDreambox::SetNativeResolution(const RESOLUTION_INFO &res)
+{
+  // Don't set the same mode as current
+  std::string mode;
+  SysfsUtils::GetString("/proc/stb/video/videomode", mode);
+  if (res.strId == mode)
+    return false;
+
+  return SetDisplayResolution(res.strId.c_str());
+}
+
+bool CEGLNativeTypeDreambox::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)
+{
+  std::string valstr;
+  SysfsUtils::GetString("/proc/stb/video/videomode_choices", valstr);
+  std::vector<std::string> probe_str = StringUtils::Split(valstr, " ");
+
+  resolutions.clear();
+  RESOLUTION_INFO res;
+  for (std::vector<std::string>::const_iterator i = probe_str.begin(); i != probe_str.end(); ++i)
+  {
+    if (dreambox_mode_to_resolution(i->c_str(), &res))
+      resolutions.push_back(res);
+  }
+
+  return resolutions.size() > 0;
+}
+
+bool CEGLNativeTypeDreambox::GetPreferredResolution(RESOLUTION_INFO *res) const
+{
+  // check display/mode, it gets defaulted at boot
+  if (!GetNativeResolution(res))
+  {
+    // punt to 720p if we get nothing
+    dreambox_mode_to_resolution("720p", res);
+  }
+
+  return true;
+}
+
+bool CEGLNativeTypeDreambox::ShowWindow(bool show)
+{
+  SysfsUtils::SetInt("/proc/stb/video/alpha", show ? 255 : 0);
+  return true;
+}
+
+bool CEGLNativeTypeDreambox::SetDisplayResolution(const char *mode)
+{
+  // switch display resolution
+  SysfsUtils::SetString("/proc/stb/video/videomode", mode);
+
+  RESOLUTION_INFO res;
+  dreambox_mode_to_resolution(mode, &res);
+  SetFramebufferResolution(res);
+
+  return true;
+}
+
+void CEGLNativeTypeDreambox::SetFramebufferResolution(const RESOLUTION_INFO &res) const
+{
+  SetFramebufferResolution(res.iScreenWidth, res.iScreenHeight);
+}
+
+void CEGLNativeTypeDreambox::SetFramebufferResolution(int width, int height) const
+{
+  const char fbdev[] = "/dev/fb0";
+  int fd;
+
+  fd = open(fbdev, O_RDWR | O_CLOEXEC);
+  if (fd >= 0)
+  {
+    struct fb_var_screeninfo vinfo;
+    if (ioctl(fd, FBIOGET_VSCREENINFO, &vinfo) == 0)
+    {
+      vinfo.xres = width;
+      vinfo.yres = height;
+      vinfo.xres_virtual = width;
+      vinfo.yres_virtual = height * 2;
+      vinfo.bits_per_pixel = 32;
+      vinfo.activate = FB_ACTIVATE_ALL;
+      ioctl(fd, FBIOPUT_VSCREENINFO, &vinfo);
+    }
+    close(fd);
+  }
+}
+
diff --git a/xbmc/windowing/egl/EGLNativeTypeDreambox.h b/xbmc/windowing/egl/EGLNativeTypeDreambox.h
new file mode 100644
index 0000000..eb03206
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeDreambox.h
@@ -0,0 +1,61 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <string>
+#include <vector>
+
+#include "EGLNativeType.h"
+class CEGLNativeTypeDreambox : public CEGLNativeType
+{
+public:
+  CEGLNativeTypeDreambox();
+  virtual ~CEGLNativeTypeDreambox();
+  virtual std::string GetNativeName() const { return "dreambox"; };
+  virtual bool  CheckCompatibility();
+  virtual void  Initialize();
+  virtual void  Destroy();
+  virtual int   GetQuirks() { return EGL_QUIRK_NONE; };
+
+  virtual bool  CreateNativeDisplay();
+  virtual bool  CreateNativeWindow();
+  virtual bool  GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const;
+  virtual bool  GetNativeWindow(XBNativeWindowType **nativeWindow) const;
+
+  virtual bool  DestroyNativeWindow();
+  virtual bool  DestroyNativeDisplay();
+
+  virtual bool  GetNativeResolution(RESOLUTION_INFO *res) const;
+  virtual bool  SetNativeResolution(const RESOLUTION_INFO &res);
+  virtual bool  ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions);
+  virtual bool  GetPreferredResolution(RESOLUTION_INFO *res) const;
+
+  virtual bool  ShowWindow(bool show);
+
+protected:
+  bool SetDisplayResolution(const char *resolution);
+  void SetupVideoScaling(const char *mode);
+  void DisableFreeScale();
+
+private:
+  void SetFramebufferResolution(const RESOLUTION_INFO &res) const;
+  void SetFramebufferResolution(int width, int height) const;
+};
diff --git a/xbmc/windowing/egl/EGLNativeTypeEdision.cpp b/xbmc/windowing/egl/EGLNativeTypeEdision.cpp
new file mode 100644
index 0000000..add5600
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeEdision.cpp
@@ -0,0 +1,174 @@
+/*
+ *      Copyright (C) 2011-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <EGL/egl.h>
+
+#include "system.h"
+#include "EGLNativeTypeEdision.h"
+#include "utils/StringUtils.h"
+#include "utils/log.h"
+#include "guilib/gui3d.h"
+//#include "linux/DllBCM.h"
+#include "windowing/GraphicContext.h"
+
+bool CEGLNativeTypeV3D::CheckCompatibility()
+{
+  return true;
+}
+
+void CEGLNativeTypeV3D::Initialize()
+{
+}
+
+void CEGLNativeTypeV3D::Destroy()
+{
+}
+
+bool CEGLNativeTypeV3D::CreateNativeDisplay()
+{
+  m_nativeDisplay = EGL_DEFAULT_DISPLAY;
+  return true;
+}
+
+bool CEGLNativeTypeV3D::CreateNativeWindow()
+{
+  V3D_RegisterDisplayPlatform(&m_platformHandle, m_nativeDisplay);
+  if (!m_platformHandle)
+    return false;
+
+  V3D_NativeWindowInfo info;
+
+  info.x = 0;
+  info.y = 0;
+  info.width = 1280;
+  info.height = 720;
+  info.stretch = false;
+  info.clientID = 0;
+  info.zOrder = 0;
+
+  m_nativeWindow = V3D_CreateNativeWindow(&info);
+  if (!m_nativeWindow)
+    return false;
+
+  return true;
+}
+
+bool CEGLNativeTypeV3D::GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const
+{
+  *nativeDisplay = (XBNativeDisplayType*) &m_nativeDisplay;
+  return true;
+}
+
+bool CEGLNativeTypeV3D::GetNativeWindow(XBNativeWindowType **nativeWindow) const
+{
+  *nativeWindow = (XBNativeWindowType*) &m_nativeWindow;
+  return true;
+}
+
+bool CEGLNativeTypeV3D::DestroyNativeDisplay()
+{
+  m_nativeDisplay = 0;
+  return true;
+}
+
+bool CEGLNativeTypeV3D::DestroyNativeWindow()
+{
+  V3D_DestroyNativeWindow(m_nativeWindow);
+  m_nativeWindow = 0;
+
+  V3D_UnregisterDisplayPlatform(m_platformHandle);
+  return true;
+}
+
+bool CEGLNativeTypeV3D::GetNativeResolution(RESOLUTION_INFO *res) const
+{
+  *res = m_desktopRes;
+  return true;
+}
+
+bool CEGLNativeTypeV3D::SetNativeResolution(const RESOLUTION_INFO &res)
+{
+  m_desktopRes = res;
+  return true;
+}
+
+bool CEGLNativeTypeV3D::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)
+{
+  resolutions.clear();
+
+  m_desktopResAll[0].bFullScreen  = true;
+  m_desktopResAll[0].iWidth       = 1280;
+  m_desktopResAll[0].iHeight      = 720;
+  m_desktopResAll[0].iScreenWidth = 1280;
+  m_desktopResAll[0].iScreenHeight= 720;
+  m_desktopResAll[0].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE;
+  m_desktopResAll[0].fRefreshRate = 50;
+  m_desktopResAll[0].strMode = StringUtils::Format("%dx%d", 1280, 720);
+  m_desktopResAll[0].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen", m_desktopRes.strMode.c_str(), 50., "");
+  m_desktopResAll[0].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[0].iHeight);
+
+  CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[0].strMode.c_str());
+
+  resolutions.push_back(m_desktopResAll[0]);
+
+  m_desktopResAll[1].bFullScreen  = true;
+  m_desktopResAll[1].iWidth       = 1280;
+  m_desktopResAll[1].iHeight      = 720;
+  m_desktopResAll[1].iScreenWidth = 1280;
+  m_desktopResAll[1].iScreenHeight= 720;
+  m_desktopResAll[1].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE | D3DPRESENTFLAG_MODE3DSBS;
+  m_desktopResAll[1].fRefreshRate = 50;
+  m_desktopResAll[1].strMode = StringUtils::Format("%dx%d", 1280, 720);
+  m_desktopResAll[1].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen 3DSBS", m_desktopResAll[1].strMode.c_str(), 50., "");
+  m_desktopResAll[1].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[1].iHeight);
+
+  CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[1].strMode.c_str());
+
+  resolutions.push_back(m_desktopResAll[1]);
+
+  m_desktopResAll[2].bFullScreen  = true;
+  m_desktopResAll[2].iWidth       = 1280;
+  m_desktopResAll[2].iHeight      = 720;
+  m_desktopResAll[2].iScreenWidth = 1280;
+  m_desktopResAll[2].iScreenHeight= 720;
+  m_desktopResAll[2].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE | D3DPRESENTFLAG_MODE3DTB;
+  m_desktopResAll[2].fRefreshRate = 50;
+  m_desktopResAll[2].strMode = StringUtils::Format("%dx%d", 1280, 720);
+  m_desktopResAll[2].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen 3DTB", m_desktopResAll[2].strMode.c_str(), 50., "");
+  m_desktopResAll[2].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[2].iHeight);
+
+  CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[2].strMode.c_str());
+
+  resolutions.push_back(m_desktopResAll[2]);
+
+  m_desktopRes = m_desktopResAll[0];
+
+  return true;
+}
+
+bool CEGLNativeTypeV3D::GetPreferredResolution(RESOLUTION_INFO *res) const
+{
+  *res = m_desktopResAll[0];
+  return true;
+}
+
+bool CEGLNativeTypeV3D::ShowWindow(bool show)
+{
+  return V3D_SetVisible(m_nativeWindow, show);
+}
diff --git a/xbmc/windowing/egl/EGLNativeTypeEdision.h b/xbmc/windowing/egl/EGLNativeTypeEdision.h
new file mode 100644
index 0000000..c3b7624
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeEdision.h
@@ -0,0 +1,61 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <vector>
+#include <string>
+#include <v3dplatform.h>
+
+#include "EGLNativeType.h"
+
+class CEGLNativeTypeV3D : public CEGLNativeType
+{
+public:
+  CEGLNativeTypeV3D() : m_platformHandle(0) {
+    m_nativeDisplay = 0;
+    m_nativeWindow = 0;
+  }
+  virtual ~CEGLNativeTypeV3D() {};
+  virtual std::string GetNativeName() const { return "V3D"; };
+  virtual bool  CheckCompatibility();
+  virtual void  Initialize();
+  virtual void  Destroy();
+  virtual int   GetQuirks() { return EGL_QUIRK_NONE; };
+
+  virtual bool  CreateNativeDisplay();
+  virtual bool  CreateNativeWindow();
+  virtual bool  GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const;
+  virtual bool  GetNativeWindow(XBNativeWindowType **nativeWindow) const;
+
+  virtual bool  DestroyNativeWindow();
+  virtual bool  DestroyNativeDisplay();
+
+  virtual bool  GetNativeResolution(RESOLUTION_INFO *res) const;
+  virtual bool  SetNativeResolution(const RESOLUTION_INFO &res);
+  virtual bool  ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions);
+  virtual bool  GetPreferredResolution(RESOLUTION_INFO *res) const;
+
+  virtual bool  ShowWindow(bool show);
+private:
+  RESOLUTION_INFO m_desktopRes;
+  RESOLUTION_INFO m_desktopResAll[3];
+  V3D_PlatformHandle m_platformHandle;
+};
diff --git a/xbmc/windowing/egl/EGLNativeTypeGB.cpp b/xbmc/windowing/egl/EGLNativeTypeGB.cpp
new file mode 100644
index 0000000..e567ce0
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeGB.cpp
@@ -0,0 +1,190 @@
+/*
+ *      Copyright (C) 2011-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include "system.h"
+#include "EGLNativeTypeGB.h"
+#include "utils/StringUtils.h"
+#include "utils/SysfsUtils.h"
+#include "utils/log.h"
+#include "guilib/gui3d.h"
+//#include "platform/linux/DllBCM.h"
+#include "windowing/GraphicContext.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <linux/fb.h>
+#include <sys/ioctl.h>
+#include <EGL/egl.h>
+
+#include "gles_init.h"
+
+CEGLNativeTypeGB::CEGLNativeTypeGB()
+{
+  m_nativeDisplay = NULL;
+  m_nativeWindow = NULL;
+}
+
+CEGLNativeTypeGB::~CEGLNativeTypeGB()
+{
+}  
+
+bool CEGLNativeTypeGB::CheckCompatibility()
+{
+  return true;
+}
+
+void CEGLNativeTypeGB::Initialize()
+{
+}
+
+void CEGLNativeTypeGB::Destroy()
+{
+}
+
+bool CEGLNativeTypeGB::CreateNativeDisplay()
+{
+
+  GLES_Native_Init();
+  return GLES_Native_CreateNativeDisplay(&m_nativeDisplay);
+
+}
+
+bool CEGLNativeTypeGB::CreateNativeWindow()
+{
+
+  m_nativeWindow = GLES_Native_CreateNativeWindow();
+   
+  if (!m_nativeWindow)
+    return false;
+  return true;
+}
+
+bool CEGLNativeTypeGB::GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const
+{
+  *nativeDisplay = (XBNativeDisplayType*) &m_nativeDisplay;
+  return true;
+}
+
+bool CEGLNativeTypeGB::GetNativeWindow(XBNativeDisplayType **nativeWindow) const
+{
+  *nativeWindow = (XBNativeWindowType*) &m_nativeWindow;
+  return true;
+}
+
+bool CEGLNativeTypeGB::DestroyNativeDisplay()
+{
+	GLES_Native_DestroyNativeDisplay();
+    m_nativeDisplay = NULL;
+    return true;
+}
+
+bool CEGLNativeTypeGB::DestroyNativeWindow()
+{
+  GLES_Native_DestroyNativeWindow();
+  m_nativeWindow = NULL;
+  return true;
+}
+
+bool CEGLNativeTypeGB::GetNativeResolution(RESOLUTION_INFO *res) const
+{
+  *res = m_desktopRes;
+  return true;
+}
+
+bool CEGLNativeTypeGB::SetNativeResolution(const RESOLUTION_INFO &res)
+{
+  m_desktopRes = res;
+  return true;
+}
+
+bool CEGLNativeTypeGB::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)
+{
+  resolutions.clear();
+
+  m_desktopResAll[0].bFullScreen  = true;
+  m_desktopResAll[0].iWidth       = 1280;
+  m_desktopResAll[0].iHeight      = 720;
+  m_desktopResAll[0].iScreenWidth = 1280;
+  m_desktopResAll[0].iScreenHeight= 720;
+  m_desktopResAll[0].dwFlags      =  D3DPRESENTFLAG_PROGRESSIVE;
+  m_desktopResAll[0].fRefreshRate = 50;
+  m_desktopResAll[0].fPixelRatio = 1.0f;
+  m_desktopResAll[0].strMode = StringUtils::Format("%dx%d", 1280, 720);
+  m_desktopResAll[0].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen", m_desktopRes.strMode.c_str(), (float)50,m_desktopRes.dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+
+  m_desktopResAll[0].iSubtitles   = (int)(0.965 * m_desktopResAll[0].iHeight);
+
+  CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[0].strMode.c_str());
+
+  resolutions.push_back(m_desktopResAll[0]);
+
+  m_desktopResAll[1].bFullScreen  = true;
+  m_desktopResAll[1].iWidth       = 1280;
+  m_desktopResAll[1].iHeight      = 720;
+  m_desktopResAll[1].iScreenWidth = 1280;
+  m_desktopResAll[1].iScreenHeight= 720;
+  m_desktopResAll[1].dwFlags      =  D3DPRESENTFLAG_PROGRESSIVE;
+
+  m_desktopResAll[1].dwFlags      |=  D3DPRESENTFLAG_MODE3DSBS;
+  m_desktopResAll[1].fRefreshRate = 50;
+  m_desktopResAll[1].fPixelRatio = 1.0f;
+  m_desktopResAll[1].strMode = StringUtils::Format("%dx%d", 1280, 720);
+  m_desktopResAll[1].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen 3DSBS", m_desktopResAll[1].strMode.c_str(), (float)50,m_desktopResAll[1].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+
+  m_desktopResAll[1].iSubtitles   = (int)(0.965 * m_desktopResAll[1].iHeight);
+
+  CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[1].strMode.c_str());
+
+  resolutions.push_back(m_desktopResAll[1]);
+
+  m_desktopResAll[2].bFullScreen  = true;
+  m_desktopResAll[2].iWidth       = 1280;
+  m_desktopResAll[2].iHeight      = 720;
+  m_desktopResAll[2].iScreenWidth = 1280;
+  m_desktopResAll[2].iScreenHeight= 720;
+  m_desktopResAll[2].dwFlags      =  D3DPRESENTFLAG_PROGRESSIVE;
+
+  m_desktopResAll[2].dwFlags      |=  D3DPRESENTFLAG_MODE3DTB;
+  m_desktopResAll[2].fRefreshRate = 50;
+  m_desktopResAll[2].fPixelRatio = 1.0f;
+  m_desktopResAll[2].strMode = StringUtils::Format("%dx%d", 1280, 720);
+  m_desktopResAll[2].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen 3DTB", m_desktopResAll[2].strMode.c_str(), (float)50,m_desktopResAll[2].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+
+  m_desktopResAll[2].iSubtitles   = (int)(0.965 * m_desktopResAll[2].iHeight);
+
+  CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[2].strMode.c_str());
+
+  resolutions.push_back(m_desktopResAll[2]);
+
+  m_desktopRes = m_desktopResAll[0];
+  
+  return true;
+}
+
+bool CEGLNativeTypeGB::GetPreferredResolution(RESOLUTION_INFO *res) const
+{
+  *res = m_desktopResAll[0];
+  return true;
+}
+
+bool CEGLNativeTypeGB::ShowWindow(bool show)
+{
+  GLES_Native_ShowWindow(m_nativeWindow, show);
+  return true;
+}
diff --git a/xbmc/windowing/egl/EGLNativeTypeGB.h b/xbmc/windowing/egl/EGLNativeTypeGB.h
new file mode 100644
index 0000000..ecf7881
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeGB.h
@@ -0,0 +1,56 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "EGLNativeType.h"
+
+#include <vector>
+#include <string>
+
+class CEGLNativeTypeGB : public CEGLNativeType
+{
+public:
+  CEGLNativeTypeGB();
+  virtual ~CEGLNativeTypeGB();
+  virtual std::string GetNativeName() const { return "GB"; };
+  virtual bool  CheckCompatibility();
+  virtual void  Initialize();
+  virtual void  Destroy();
+  virtual int   GetQuirks() { return EGL_QUIRK_NONE; };
+
+  virtual bool  CreateNativeDisplay();
+  virtual bool  CreateNativeWindow();
+  virtual bool  GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const;
+  virtual bool  GetNativeWindow(XBNativeWindowType **nativeWindow) const;
+
+  virtual bool  DestroyNativeWindow();
+  virtual bool  DestroyNativeDisplay();
+
+  virtual bool  GetNativeResolution(RESOLUTION_INFO *res) const;
+  virtual bool  SetNativeResolution(const RESOLUTION_INFO &res);
+  virtual bool  ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions);
+  virtual bool  GetPreferredResolution(RESOLUTION_INFO *res) const;
+
+  virtual bool  ShowWindow(bool show);
+private:
+  RESOLUTION_INFO m_desktopRes;
+  RESOLUTION_INFO m_desktopResAll[3];
+};
diff --git a/xbmc/windowing/egl/EGLNativeTypeMali.cpp b/xbmc/windowing/egl/EGLNativeTypeMali.cpp
new file mode 100644
index 0000000..2b39d2f
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeMali.cpp
@@ -0,0 +1,149 @@
+/*
+ *      Copyright (C) 2011-2015 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include "EGLNativeTypeMali.h"
+#include <EGL/egl.h>
+#include "utils/log.h"
+
+#include <linux/fb.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+
+bool CEGLNativeTypeMali::_GetNativeResolution(RESOLUTION_INFO *res) const {
+  struct fb_var_screeninfo vinfo;
+  int fd;
+  
+  fd = open("/dev/fb0", O_RDWR, 0);
+  if (fd < 0) {
+    return false;
+  }
+  
+  if (ioctl(fd, FBIOGET_VSCREENINFO, &vinfo) < 0) {
+    return false;
+  }
+  close(fd);
+
+  res->bFullScreen   = false;
+  res->dwFlags       = 0;
+  res->fRefreshRate  = 60;
+  res->iWidth        = vinfo.xres;
+  res->iHeight       = vinfo.yres;
+  res->iScreenWidth  = vinfo.xres;
+  res->iScreenHeight = vinfo.yres;
+  res->fPixelRatio   = 1;
+  res->iSubtitles    = (int)(0.965 * res->iHeight);
+
+  return true;
+}
+
+CEGLNativeTypeMali::CEGLNativeTypeMali() {
+  CLog::Log(LOGDEBUG, "CEGLNativeTypeMali::CEGLNativeTypeMali()\n");
+}
+
+CEGLNativeTypeMali::~CEGLNativeTypeMali() {
+  CLog::Log(LOGDEBUG, "CEGLNativeTypeMali::~CEGLNativeTypeMali()\n");
+}
+
+bool CEGLNativeTypeMali::CheckCompatibility() {
+  CLog::Log(LOGDEBUG, "CEGLNativeTypeMali::CheckCompatibility()\n");
+  return true;
+}
+
+void CEGLNativeTypeMali::Initialize() {
+  CLog::Log(LOGDEBUG, "CEGLNativeTypeMali::Initialize()\n");
+}
+
+void CEGLNativeTypeMali::Destroy() {
+  CLog::Log(LOGDEBUG, "CEGLNativeTypeMali::Destroy()\n");
+}
+
+bool CEGLNativeTypeMali::CreateNativeDisplay() {
+  CLog::Log(LOGDEBUG, "CEGLNativeTypeMali::CreateNativeDisplay()\n");
+  m_nativeDisplay = EGL_DEFAULT_DISPLAY;
+  return true;
+}
+
+bool CEGLNativeTypeMali::CreateNativeWindow() {
+  CLog::Log(LOGDEBUG, "CEGLNativeTypeMali::CreateNativeWindow()\n");
+  m_nativeWindow = EGL_DEFAULT_DISPLAY;
+  return true;
+}
+
+bool CEGLNativeTypeMali::GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const {
+  CLog::Log(LOGDEBUG, "CEGLNativeTypeMali::GetNativeDisplay()\n");
+  if (!nativeDisplay)
+    return false;
+  *nativeDisplay = (XBNativeDisplayType*) &m_nativeDisplay;
+  return true;
+}
+
+bool CEGLNativeTypeMali::GetNativeWindow(XBNativeWindowType **nativeWindow) const {
+  CLog::Log(LOGDEBUG, "CEGLNativeTypeMali::GetNativeWindow()\n");
+  if (!nativeWindow)
+    return false;
+  *nativeWindow = (XBNativeWindowType*) &m_nativeWindow;
+  return true;
+}
+
+bool CEGLNativeTypeMali::DestroyNativeWindow() {
+  CLog::Log(LOGDEBUG, "CEGLNativeTypeMali::DestroyNativeWindow()\n");
+  m_nativeWindow = NULL;
+  return true;
+}
+
+bool CEGLNativeTypeMali::DestroyNativeDisplay() {
+  CLog::Log(LOGDEBUG, "CEGLNativeTypeMali::DestroyNativeDisplay()\n");
+  m_nativeDisplay = NULL;
+  return true;
+}
+
+bool CEGLNativeTypeMali::GetNativeResolution(RESOLUTION_INFO *res) const {
+  CLog::Log(LOGDEBUG, "CEGLNativeTypeMali::GetNativeResolution()\n");
+  return _GetNativeResolution(res);
+}
+
+bool CEGLNativeTypeMali::SetNativeResolution(const RESOLUTION_INFO &res) {
+  CLog::Log(LOGDEBUG, "CEGLNativeTypeMali::SetNativeResolution()\n");
+  return true;
+}
+
+bool CEGLNativeTypeMali::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions) {
+  CLog::Log(LOGDEBUG, "CEGLNativeTypeMali::ProbeResolutions()\n");
+  resolutions.clear();
+
+  RESOLUTION_INFO res;
+  if(_GetNativeResolution(&res)) {
+    resolutions.push_back(res);
+    return true;
+  }
+  return true;
+}
+
+bool CEGLNativeTypeMali::GetPreferredResolution(RESOLUTION_INFO *res) const {
+  CLog::Log(LOGDEBUG, "CEGLNativeTypeMali::GetPreferredResolution()\n");
+  _GetNativeResolution(res);
+  return false;
+}
+
+bool CEGLNativeTypeMali::ShowWindow(bool show) {
+  CLog::Log(LOGDEBUG, "CEGLNativeTypeMali::ShowWindow()\n");
+  return false;
+}
+
diff --git a/xbmc/windowing/egl/EGLNativeTypeMali.h b/xbmc/windowing/egl/EGLNativeTypeMali.h
new file mode 100644
index 0000000..083749a
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeMali.h
@@ -0,0 +1,53 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "EGLNativeType.h"
+
+class CEGLNativeTypeMali : public CEGLNativeType
+{
+public:
+  CEGLNativeTypeMali();
+  virtual ~CEGLNativeTypeMali();
+  virtual std::string GetNativeName() const { return "mali"; };
+  virtual bool  CheckCompatibility();
+  virtual void  Initialize();
+  virtual void  Destroy();
+  virtual int   GetQuirks() { return EGL_QUIRK_NONE; };
+
+  virtual bool  CreateNativeDisplay();
+  virtual bool  CreateNativeWindow();
+  virtual bool  GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const;
+  virtual bool  GetNativeWindow(XBNativeWindowType **nativeWindow) const;
+
+  virtual bool  DestroyNativeWindow();
+  virtual bool  DestroyNativeDisplay();
+
+  virtual bool  GetNativeResolution(RESOLUTION_INFO *res) const;
+  virtual bool  SetNativeResolution(const RESOLUTION_INFO &res);
+  virtual bool  ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions);
+  virtual bool  GetPreferredResolution(RESOLUTION_INFO *res) const;
+
+  virtual bool  ShowWindow(bool show);
+
+ private:
+  bool _GetNativeResolution(RESOLUTION_INFO *res) const;
+};
diff --git a/xbmc/windowing/egl/EGLNativeTypeNexTV.cpp b/xbmc/windowing/egl/EGLNativeTypeNexTV.cpp
new file mode 100644
index 0000000..e0b5592
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeNexTV.cpp
@@ -0,0 +1,226 @@
+/*
+ *      Copyright (C) 2011-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include "system.h"
+#include "EGLNativeTypeNexTV.h"
+#include "utils/StringUtils.h"
+#include "utils/SysfsUtils.h"
+#include "utils/log.h"
+#include "guilib/gui3d.h"
+//#include "platform/linux/DllBCM.h"
+#include "windowing/GraphicContext.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <linux/fb.h>
+#include <sys/ioctl.h>
+#include <EGL/egl.h>
+
+CEGLNativeTypeNexTV::CEGLNativeTypeNexTV()
+{
+  m_nativeDisplay = NULL;
+  m_nativeWindow = NULL;
+}
+
+CEGLNativeTypeNexTV::~CEGLNativeTypeNexTV()
+{
+}  
+
+bool CEGLNativeTypeNexTV::CheckCompatibility()
+{
+  return true;
+}
+
+void CEGLNativeTypeNexTV::Initialize()
+{
+}
+
+void CEGLNativeTypeNexTV::Destroy()
+{
+}
+
+bool CEGLNativeTypeNexTV::CreateNativeDisplay()
+{
+  m_nativeDisplay = EGL_DEFAULT_DISPLAY;
+  return true;
+}
+
+bool CEGLNativeTypeNexTV::CreateNativeWindow()
+{
+  NxClient_Join(NULL);
+
+  NXPL_RegisterNexusDisplayPlatform(&nxpl_handle, nexus_display);
+  NXPL_NativeWindowInfoEXT nativeWindow;
+
+  NXPL_GetDefaultNativeWindowInfoEXT(&nativeWindow);
+
+  nativeWindow.x = 0;
+  nativeWindow.y = 0;
+  nativeWindow.width = 1280;
+  nativeWindow.height = 720;
+  nativeWindow.stretch = false;
+  nativeWindow.clientID = 0;
+  nativeWindow.zOrder = 0;
+
+  m_nativeWindow = NXPL_CreateNativeWindowEXT(&nativeWindow);
+  if (!m_nativeWindow)
+    return false;
+  return true;
+}
+
+bool CEGLNativeTypeNexTV::GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const
+{
+  if (!nativeDisplay)	return false;
+  *nativeDisplay = (XBNativeDisplayType*) &m_nativeDisplay;
+  return true;
+}
+
+bool CEGLNativeTypeNexTV::GetNativeWindow(XBNativeDisplayType **nativeWindow) const
+{
+  if (!nativeWindow)	return false;
+  *nativeWindow = (XBNativeWindowType*) &m_nativeWindow;
+  return true;
+}
+
+bool CEGLNativeTypeNexTV::DestroyNativeDisplay()
+{
+    m_nativeDisplay = NULL;
+    return true;
+}
+
+bool CEGLNativeTypeNexTV::DestroyNativeWindow()
+{
+  NXPL_DestroyNativeWindow(m_nativeWindow);
+
+  NXPL_UnregisterNexusDisplayPlatform(nxpl_handle);
+  NxClient_Uninit();
+
+  return true;
+}
+
+bool CEGLNativeTypeNexTV::GetNativeResolution(RESOLUTION_INFO *res) const
+{
+  *res = m_desktopRes;
+  return true;
+}
+
+bool CEGLNativeTypeNexTV::SetNativeResolution(const RESOLUTION_INFO &res)
+{
+  m_desktopRes = res;
+  return SetDisplayResolution();
+}
+
+bool CEGLNativeTypeNexTV::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)
+{
+  resolutions.clear();
+
+ m_desktopResAll[0].bFullScreen  = true;
+  m_desktopResAll[0].iWidth       = 1280;
+  m_desktopResAll[0].iHeight      = 720;
+  m_desktopResAll[0].iScreenWidth = 1280;
+  m_desktopResAll[0].iScreenHeight= 720;
+  m_desktopResAll[0].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE;
+  m_desktopResAll[0].fRefreshRate = 50;
+  m_desktopResAll[0].fPixelRatio   = 1.0f;
+  m_desktopResAll[0].strMode = StringUtils::Format("%dx%d", 1280, 720);
+  m_desktopResAll[0].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen", m_desktopResAll[0].strMode.c_str(), (float)50, m_desktopResAll[0].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+  m_desktopResAll[0].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[0].iHeight);
+
+  CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[0].strMode.c_str());
+
+  resolutions.push_back(m_desktopResAll[0]);
+
+  m_desktopResAll[1].bFullScreen  = true;
+  m_desktopResAll[1].iWidth       = 1280;
+  m_desktopResAll[1].iHeight      = 720;
+  m_desktopResAll[1].iScreenWidth = 1280;
+  m_desktopResAll[1].iScreenHeight= 720;
+  m_desktopResAll[1].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE | D3DPRESENTFLAG_MODE3DSBS;
+  m_desktopResAll[1].fRefreshRate = 50;
+  m_desktopResAll[1].fPixelRatio   = 1.0f;
+  m_desktopResAll[1].strMode = StringUtils::Format("%dx%d", 1280, 720);
+  m_desktopResAll[1].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen 3DSBS", m_desktopResAll[1].strMode.c_str(), (float)50, m_desktopResAll[1].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+  m_desktopResAll[1].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[1].iHeight);
+
+  CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[1].strMode.c_str());
+
+  resolutions.push_back(m_desktopResAll[1]);
+
+  m_desktopResAll[2].bFullScreen  = true;
+  m_desktopResAll[2].iWidth       = 1280;
+  m_desktopResAll[2].iHeight      = 720;
+  m_desktopResAll[2].iScreenWidth = 1280;
+  m_desktopResAll[2].iScreenHeight= 720;
+  m_desktopResAll[2].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE | D3DPRESENTFLAG_MODE3DTB;
+  m_desktopResAll[2].fRefreshRate = 50;
+  m_desktopResAll[2].fPixelRatio   = 1.0f;
+  m_desktopResAll[2].strMode = StringUtils::Format("%dx%d", 1280, 720);
+  m_desktopResAll[2].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen 3DTB", m_desktopResAll[2].strMode.c_str(), (float)50, m_desktopResAll[2].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+  m_desktopResAll[2].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[2].iHeight);
+
+  CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[2].strMode.c_str());
+
+  resolutions.push_back(m_desktopResAll[2]);
+
+  m_desktopResAll[3].bFullScreen  = true;
+  m_desktopResAll[3].iWidth       = 1280;
+  m_desktopResAll[3].iHeight      = 720;
+  m_desktopResAll[3].iScreenWidth = 1920;
+  m_desktopResAll[3].iScreenHeight= 1080;
+  m_desktopResAll[3].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE;
+  m_desktopResAll[3].fRefreshRate = 50;
+  m_desktopResAll[3].fPixelRatio   = 1.0f;
+  m_desktopResAll[3].strMode = StringUtils::Format("%dx%d", 1920, 1080);
+  m_desktopResAll[3].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen", m_desktopResAll[3].strMode.c_str(), (float)50, m_desktopResAll[3].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+  m_desktopResAll[3].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[3].iHeight);
+
+  CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[3].strMode.c_str());
+
+  resolutions.push_back(m_desktopResAll[3]);
+
+  m_desktopRes = m_desktopResAll[0];
+
+  return true;
+}
+
+bool CEGLNativeTypeNexTV::GetPreferredResolution(RESOLUTION_INFO *res) const
+{
+  *res = m_desktopResAll[0];
+  return true;
+}
+
+bool CEGLNativeTypeNexTV::ShowWindow(bool show)
+{
+  NXPL_ShowNativeWindowEXT(m_nativeWindow, show);
+  return true;
+}
+
+bool CEGLNativeTypeNexTV::SetDisplayResolution()
+{
+	NXPL_NativeWindowInfoEXT nativeWindow;
+
+	NXPL_GetDefaultNativeWindowInfoEXT(&nativeWindow);
+	nativeWindow.x = nativeWindow.y = 0;
+	nativeWindow.width = m_desktopRes.iWidth;
+	nativeWindow.height = m_desktopRes.iHeight;
+	
+	NXPL_UpdateNativeWindowEXT(m_nativeWindow, &nativeWindow);
+
+	return true;
+}
diff --git a/xbmc/windowing/egl/EGLNativeTypeNexTV.h b/xbmc/windowing/egl/EGLNativeTypeNexTV.h
new file mode 100644
index 0000000..4151347
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeNexTV.h
@@ -0,0 +1,196 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "EGLNativeType.h"
+
+#include <vector>
+#include <string>
+
+#define NEXUS_DISPLAYHANDLE void*
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef void *NXPL_PlatformHandle;
+
+typedef enum NEXUS_BlendFactor
+{
+    NEXUS_BlendFactor_eZero
+} NEXUS_BlendFactor;
+
+typedef struct NEXUS_BlendEquation
+{
+    NEXUS_BlendFactor a;
+    NEXUS_BlendFactor b;
+    bool              subtract_cd;
+    NEXUS_BlendFactor c;
+    NEXUS_BlendFactor d;
+    bool              subtract_e;
+    NEXUS_BlendFactor e;
+} NEXUS_BlendEquation;
+
+typedef struct
+{
+   uint32_t             width;
+   uint32_t             height;
+   uint32_t             x;
+   uint32_t             y;
+   bool                 stretch;
+   uint32_t             clientID;
+   uint32_t             zOrder;
+   NEXUS_BlendEquation  colorBlend;
+   NEXUS_BlendEquation  alphaBlend;
+   uint32_t             magic;
+} NXPL_NativeWindowInfoEXT;
+
+/* FOR NXCLINET */
+typedef unsigned NEXUS_Error;
+
+#define NXCLIENT_MAX_NAME 32
+
+/***************************************************************************
+Summary:
+Autheticated ID for client/server communication.
+
+Description:
+For non-secure environments, the certificate could be a simple ID.
+For secure environments, this should use encrypted using standard public-key cryptography.
+***************************************************************************/
+typedef struct NEXUS_Certificate
+{
+    unsigned char data[256];
+    unsigned length;
+} NEXUS_Certificate;
+
+/**
+Summary:
+Client modes
+
+See nexus/docs/Nexus_MultiProcess.pdf for full discussion of process isolation and multi-process application design.
+**/
+typedef enum NEXUS_ClientMode
+{
+    NEXUS_ClientMode_eUnprotected, /* deprecated */
+    NEXUS_ClientMode_eVerified,    /* verify handle value, but not owner. unsynchronized caller may compromise nexus settings. */
+    NEXUS_ClientMode_eProtected,   /* full handle verification. access to full API. if client crashes, server is protected. */
+    NEXUS_ClientMode_eUntrusted,   /* full handle verification. access to limited API. see nexus/build/common/tools/nexus_untrusted_api.txt. if client crashes, server is protected. */
+    NEXUS_ClientMode_eMax
+} NEXUS_ClientMode;
+
+/**
+Summary:
+Join with Nexus server application (using app ipc) and Nexus driver (using Nexus multiprocess)
+
+Description:
+This dynamically registers a client with both nexus and the server app.
+NxClient_Join can be called from multiple processes, or multiple times from the same process.
+
+NxClient_Join is reference counted within the same process. You must call NxClient_Uninit an equal
+number of times to detach from nexus and the server app.
+**/
+typedef struct NxClient_JoinSettings
+{
+    char name[NXCLIENT_MAX_NAME];
+    bool tunnelCapable; /* deprecated */
+    unsigned timeout; /* in seconds. if unable to join, try again for this number of seconds. defaults to 0. */
+    unsigned session; /* set index to choose which session in a multi-session server configuration */
+    bool ignoreStandbyRequest; /* deprecated. see NxClient_RegisterAcknowledgeStandby() instead. */
+    NEXUS_ClientMode mode; /* requested client mode. server may reject the request. */
+    NEXUS_Certificate certificate; /* allows NEXUS_ClientMode_eProtected (aka trusted) status if server requires */
+} NxClient_JoinSettings;
+
+extern void NxClient_GetDefaultJoinSettings(NxClient_JoinSettings *pSettings);
+
+extern NEXUS_Error NxClient_Join(const NxClient_JoinSettings *pSettings);
+
+extern void NxClient_Uninit(void);
+
+
+/* Register a display for exclusive use. The client application should not use the display until
+ * calling NXPL_UnregisterNexusDisplayPlatform.
+ * It will register its own memory, h/w and display APIs suitable for basic exclusive mode rendering on
+ * a Nexus display.
+ * Fills in the NXPL platform handle, which must be passed back into the unregister function.
+ */
+void NXPL_RegisterNexusDisplayPlatform(NXPL_PlatformHandle *handle, NEXUS_DISPLAYHANDLE display);
+
+/* Unregister a display for exclusive use. The client application can the use the Nexus display again. */
+void NXPL_UnregisterNexusDisplayPlatform(NXPL_PlatformHandle handle);
+
+/* Generate a default NXPL_NativeWindowInfoEXT */
+void NXPL_GetDefaultNativeWindowInfoEXT(NXPL_NativeWindowInfoEXT *info);
+
+/* Create a 'native window' of the given size. This is really just a small structure that holds the size
+ * of the window that EGL will write into. */
+void *NXPL_CreateNativeWindowEXT(const NXPL_NativeWindowInfoEXT *info);
+
+/* Destroy a 'native window' */
+void NXPL_DestroyNativeWindow(void *nativeWin);
+
+/* Show/hide a 'native window' */
+void NXPL_ShowNativeWindowEXT(void *native,bool show);
+
+/* Update a 'native window' */
+void NXPL_UpdateNativeWindowEXT(void *native, NXPL_NativeWindowInfoEXT * nativeWindow);
+
+int NEXUS_Platform_AuthenticatedJoin(const void *settings);
+#define NEXUS_Platform_Join() NEXUS_Platform_AuthenticatedJoin(NULL)
+
+#ifdef __cplusplus
+}
+#endif
+
+class CEGLNativeTypeNexTV : public CEGLNativeType
+{
+public:
+  CEGLNativeTypeNexTV();
+  virtual ~CEGLNativeTypeNexTV();
+  virtual std::string GetNativeName() const { return "NexTV"; };
+  virtual bool  CheckCompatibility();
+  virtual void  Initialize();
+  virtual void  Destroy();
+  virtual int   GetQuirks() { return EGL_QUIRK_NONE; };
+
+  virtual bool  CreateNativeDisplay();
+  virtual bool  CreateNativeWindow();
+  virtual bool  GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const;
+  virtual bool  GetNativeWindow(XBNativeWindowType **nativeWindow) const;
+
+  virtual bool  DestroyNativeWindow();
+  virtual bool  DestroyNativeDisplay();
+
+  virtual bool  GetNativeResolution(RESOLUTION_INFO *res) const;
+  virtual bool  SetNativeResolution(const RESOLUTION_INFO &res);
+  virtual bool  ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions);
+  virtual bool  GetPreferredResolution(RESOLUTION_INFO *res) const;
+
+  virtual bool  ShowWindow(bool show);
+private:
+  RESOLUTION_INFO m_desktopRes;
+  RESOLUTION_INFO m_desktopResAll[4];
+
+  NXPL_PlatformHandle nxpl_handle = 0;
+  NEXUS_DISPLAYHANDLE  nexus_display = 0;
+
+  bool SetDisplayResolution();
+};
diff --git a/xbmc/windowing/egl/EGLNativeTypeV3D.cpp b/xbmc/windowing/egl/EGLNativeTypeV3D.cpp
new file mode 100644
index 0000000..e517ae8
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeV3D.cpp
@@ -0,0 +1,174 @@
+/*
+ *      Copyright (C) 2011-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <EGL/egl.h>
+
+#include "system.h"
+#include "EGLNativeTypeV3D.h"
+#include "utils/StringUtils.h"
+#include "utils/log.h"
+#include "guilib/gui3d.h"
+//#include "platform/linux/DllBCM.h"
+#include "windowing/GraphicContext.h"
+
+bool CEGLNativeTypeV3D::CheckCompatibility()
+{
+  return true;
+}
+
+void CEGLNativeTypeV3D::Initialize()
+{
+}
+
+void CEGLNativeTypeV3D::Destroy()
+{
+}
+
+bool CEGLNativeTypeV3D::CreateNativeDisplay()
+{
+  m_nativeDisplay = EGL_DEFAULT_DISPLAY;
+  return true;
+}
+
+bool CEGLNativeTypeV3D::CreateNativeWindow()
+{
+  V3D_RegisterDisplayPlatform(&m_platformHandle, m_nativeDisplay);
+  if (!m_platformHandle)
+    return false;
+
+  V3D_NativeWindowInfo info;
+
+  info.x = 0;
+  info.y = 0;
+  info.width = 1280;
+  info.height = 720;
+  info.stretch = false;
+  info.clientID = 0;
+  info.zOrder = 0;
+
+  m_nativeWindow = V3D_CreateNativeWindow(&info);
+  if (!m_nativeWindow)
+    return false;
+
+  return true;
+}
+
+bool CEGLNativeTypeV3D::GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const
+{
+  *nativeDisplay = (XBNativeDisplayType*) &m_nativeDisplay;
+  return true;
+}
+
+bool CEGLNativeTypeV3D::GetNativeWindow(XBNativeWindowType **nativeWindow) const
+{
+  *nativeWindow = (XBNativeWindowType*) &m_nativeWindow;
+  return true;
+}
+
+bool CEGLNativeTypeV3D::DestroyNativeDisplay()
+{
+  m_nativeDisplay = 0;
+  return true;
+}
+
+bool CEGLNativeTypeV3D::DestroyNativeWindow()
+{
+  V3D_DestroyNativeWindow(m_nativeWindow);
+  m_nativeWindow = 0;
+
+  V3D_UnregisterDisplayPlatform(m_platformHandle);
+  return true;
+}
+
+bool CEGLNativeTypeV3D::GetNativeResolution(RESOLUTION_INFO *res) const
+{
+  *res = m_desktopRes;
+  return true;
+}
+
+bool CEGLNativeTypeV3D::SetNativeResolution(const RESOLUTION_INFO &res)
+{
+  m_desktopRes = res;
+  return true;
+}
+
+bool CEGLNativeTypeV3D::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)
+{
+  resolutions.clear();
+
+  m_desktopResAll[0].bFullScreen  = true;
+  m_desktopResAll[0].iWidth       = 1280;
+  m_desktopResAll[0].iHeight      = 720;
+  m_desktopResAll[0].iScreenWidth = 1280;
+  m_desktopResAll[0].iScreenHeight= 720;
+  m_desktopResAll[0].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE;
+  m_desktopResAll[0].fRefreshRate = 50;
+  m_desktopResAll[0].strMode = StringUtils::Format("%dx%d", 1280, 720);
+  m_desktopResAll[0].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen", m_desktopRes.strMode.c_str(), 50., "");
+  m_desktopResAll[0].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[0].iHeight);
+
+  CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[0].strMode.c_str());
+
+  resolutions.push_back(m_desktopResAll[0]);
+
+  m_desktopResAll[1].bFullScreen  = true;
+  m_desktopResAll[1].iWidth       = 1280;
+  m_desktopResAll[1].iHeight      = 720;
+  m_desktopResAll[1].iScreenWidth = 1280;
+  m_desktopResAll[1].iScreenHeight= 720;
+  m_desktopResAll[1].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE | D3DPRESENTFLAG_MODE3DSBS;
+  m_desktopResAll[1].fRefreshRate = 50;
+  m_desktopResAll[1].strMode = StringUtils::Format("%dx%d", 1280, 720);
+  m_desktopResAll[1].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen 3DSBS", m_desktopResAll[1].strMode.c_str(), 50., "");
+  m_desktopResAll[1].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[1].iHeight);
+
+  CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[1].strMode.c_str());
+
+  resolutions.push_back(m_desktopResAll[1]);
+
+  m_desktopResAll[2].bFullScreen  = true;
+  m_desktopResAll[2].iWidth       = 1280;
+  m_desktopResAll[2].iHeight      = 720;
+  m_desktopResAll[2].iScreenWidth = 1280;
+  m_desktopResAll[2].iScreenHeight= 720;
+  m_desktopResAll[2].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE | D3DPRESENTFLAG_MODE3DTB;
+  m_desktopResAll[2].fRefreshRate = 50;
+  m_desktopResAll[2].strMode = StringUtils::Format("%dx%d", 1280, 720);
+  m_desktopResAll[2].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen 3DTB", m_desktopResAll[2].strMode.c_str(), 50., "");
+  m_desktopResAll[2].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[2].iHeight);
+
+  CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[2].strMode.c_str());
+
+  resolutions.push_back(m_desktopResAll[2]);
+
+  m_desktopRes = m_desktopResAll[0];
+
+  return true;
+}
+
+bool CEGLNativeTypeV3D::GetPreferredResolution(RESOLUTION_INFO *res) const
+{
+  *res = m_desktopResAll[0];
+  return true;
+}
+
+bool CEGLNativeTypeV3D::ShowWindow(bool show)
+{
+  return V3D_SetVisible(m_platformHandle, show);
+}
diff --git a/xbmc/windowing/egl/EGLNativeTypeV3D.h b/xbmc/windowing/egl/EGLNativeTypeV3D.h
new file mode 100644
index 0000000..c3b7624
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeV3D.h
@@ -0,0 +1,61 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <vector>
+#include <string>
+#include <v3dplatform.h>
+
+#include "EGLNativeType.h"
+
+class CEGLNativeTypeV3D : public CEGLNativeType
+{
+public:
+  CEGLNativeTypeV3D() : m_platformHandle(0) {
+    m_nativeDisplay = 0;
+    m_nativeWindow = 0;
+  }
+  virtual ~CEGLNativeTypeV3D() {};
+  virtual std::string GetNativeName() const { return "V3D"; };
+  virtual bool  CheckCompatibility();
+  virtual void  Initialize();
+  virtual void  Destroy();
+  virtual int   GetQuirks() { return EGL_QUIRK_NONE; };
+
+  virtual bool  CreateNativeDisplay();
+  virtual bool  CreateNativeWindow();
+  virtual bool  GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const;
+  virtual bool  GetNativeWindow(XBNativeWindowType **nativeWindow) const;
+
+  virtual bool  DestroyNativeWindow();
+  virtual bool  DestroyNativeDisplay();
+
+  virtual bool  GetNativeResolution(RESOLUTION_INFO *res) const;
+  virtual bool  SetNativeResolution(const RESOLUTION_INFO &res);
+  virtual bool  ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions);
+  virtual bool  GetPreferredResolution(RESOLUTION_INFO *res) const;
+
+  virtual bool  ShowWindow(bool show);
+private:
+  RESOLUTION_INFO m_desktopRes;
+  RESOLUTION_INFO m_desktopResAll[3];
+  V3D_PlatformHandle m_platformHandle;
+};
diff --git a/xbmc/windowing/egl/EGLNativeTypeV3DNXPL.cpp b/xbmc/windowing/egl/EGLNativeTypeV3DNXPL.cpp
new file mode 100644
index 0000000..8061f23
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeV3DNXPL.cpp
@@ -0,0 +1,205 @@
+/*
+ *      Copyright (C) 2011-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include "system.h"
+#include "EGLNativeTypeV3DNXPL.h"
+#include "utils/StringUtils.h"
+#include "utils/SysfsUtils.h"
+#include "utils/log.h"
+#include "guilib/gui3d.h"
+//#include "platform/linux/DllBCM.h"
+#include "windowing/GraphicContext.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <linux/fb.h>
+#include <sys/ioctl.h>
+#include <EGL/egl.h>
+
+CEGLNativeTypeV3D::CEGLNativeTypeV3D()
+{
+  m_nativeDisplay = NULL;
+  m_nativeWindow = NULL;
+}
+
+CEGLNativeTypeV3D::~CEGLNativeTypeV3D()
+{
+}  
+
+bool CEGLNativeTypeV3D::CheckCompatibility()
+{
+  return true;
+}
+
+void CEGLNativeTypeV3D::Initialize()
+{
+}
+
+void CEGLNativeTypeV3D::Destroy()
+{
+}
+
+bool CEGLNativeTypeV3D::CreateNativeDisplay()
+{
+  m_nativeDisplay = EGL_DEFAULT_DISPLAY;
+  return true;
+}
+
+bool CEGLNativeTypeV3D::CreateNativeWindow()
+{
+  NEXUS_Platform_Join();
+  NXPL_RegisterNexusDisplayPlatform(&nxpl_handle, nexus_display);
+  NXPL_NativeWindowInfoEXT nativeWindow;
+
+  NXPL_GetDefaultNativeWindowInfoEXT(&nativeWindow);
+
+  nativeWindow.x = 0;
+  nativeWindow.y = 0;
+  nativeWindow.width = 1280;
+  nativeWindow.height = 720;
+  nativeWindow.stretch = false;
+  nativeWindow.clientID = 0;
+  nativeWindow.zOrder = 0;
+
+  m_nativeWindow = NXPL_CreateNativeWindowEXT(&nativeWindow);
+  if (!m_nativeWindow)
+    return false;
+  return true;
+}
+
+bool CEGLNativeTypeV3D::GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const
+{
+  *nativeDisplay = (XBNativeDisplayType*) &m_nativeDisplay;
+  return true;
+}
+
+bool CEGLNativeTypeV3D::GetNativeWindow(XBNativeDisplayType **nativeWindow) const
+{
+  *nativeWindow = (XBNativeWindowType*) &m_nativeWindow;
+  return true;
+}
+
+bool CEGLNativeTypeV3D::DestroyNativeDisplay()
+{
+    m_nativeDisplay = NULL;
+    return true;
+}
+
+bool CEGLNativeTypeV3D::DestroyNativeWindow()
+{
+  NXPL_DestroyNativeWindow(m_nativeWindow);
+  return true;
+}
+
+bool CEGLNativeTypeV3D::GetNativeResolution(RESOLUTION_INFO *res) const
+{
+  *res = m_desktopRes;
+  return true;
+}
+
+bool CEGLNativeTypeV3D::SetNativeResolution(const RESOLUTION_INFO &res)
+{
+  m_desktopRes = res;
+  return true;
+}
+
+bool CEGLNativeTypeV3D::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)
+{
+  resolutions.clear();
+
+  m_desktopResAll[0].bFullScreen  = true;
+  m_desktopResAll[0].iWidth       = 1280;
+  m_desktopResAll[0].iHeight      = 720;
+  m_desktopResAll[0].iScreenWidth = 1280;
+  m_desktopResAll[0].iScreenHeight= 720;
+  m_desktopResAll[0].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE;
+  m_desktopResAll[0].fRefreshRate = 50;
+  m_desktopResAll[0].fPixelRatio   = 1.0f;
+  m_desktopResAll[0].strMode = StringUtils::Format("%dx%d", 1280, 720);
+  m_desktopResAll[0].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen", m_desktopResAll[0].strMode.c_str(), (float)50, m_desktopResAll[0].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+  m_desktopResAll[0].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[0].iHeight);
+
+  CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[0].strMode.c_str());
+
+  resolutions.push_back(m_desktopResAll[0]);
+
+  m_desktopResAll[1].bFullScreen  = true;
+  m_desktopResAll[1].iWidth       = 1280;
+  m_desktopResAll[1].iHeight      = 720;
+  m_desktopResAll[1].iScreenWidth = 1280;
+  m_desktopResAll[1].iScreenHeight= 720;
+  m_desktopResAll[1].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE | D3DPRESENTFLAG_MODE3DSBS;
+  m_desktopResAll[1].fRefreshRate = 50;
+  m_desktopResAll[1].fPixelRatio   = 1.0f;
+  m_desktopResAll[1].strMode = StringUtils::Format("%dx%d", 1280, 720);
+  m_desktopResAll[1].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen 3DSBS", m_desktopResAll[1].strMode.c_str(), (float)50, m_desktopResAll[1].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+  m_desktopResAll[1].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[1].iHeight);
+
+  CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[1].strMode.c_str());
+
+  resolutions.push_back(m_desktopResAll[1]);
+
+  m_desktopResAll[2].bFullScreen  = true;
+  m_desktopResAll[2].iWidth       = 1280;
+  m_desktopResAll[2].iHeight      = 720;
+  m_desktopResAll[2].iScreenWidth = 1280;
+  m_desktopResAll[2].iScreenHeight= 720;
+  m_desktopResAll[2].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE | D3DPRESENTFLAG_MODE3DTB;
+  m_desktopResAll[2].fRefreshRate = 50;
+  m_desktopResAll[2].fPixelRatio   = 1.0f;
+  m_desktopResAll[2].strMode = StringUtils::Format("%dx%d", 1280, 720);
+  m_desktopResAll[2].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen 3DTB", m_desktopResAll[2].strMode.c_str(), (float)50, m_desktopResAll[2].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+  m_desktopResAll[2].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[2].iHeight);
+
+  CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[2].strMode.c_str());
+
+  resolutions.push_back(m_desktopResAll[2]);
+
+  m_desktopResAll[3].bFullScreen  = true;
+  m_desktopResAll[3].iWidth       = 1280;
+  m_desktopResAll[3].iHeight      = 720;
+  m_desktopResAll[3].iScreenWidth = 1920;
+  m_desktopResAll[3].iScreenHeight= 1080;
+  m_desktopResAll[3].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE;
+  m_desktopResAll[3].fRefreshRate = 50;
+  m_desktopResAll[3].fPixelRatio   = 1.0f;
+  m_desktopResAll[3].strMode = StringUtils::Format("%dx%d", 1920, 1080);
+  m_desktopResAll[3].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen", m_desktopResAll[3].strMode.c_str(), (float)50, m_desktopResAll[3].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+  m_desktopResAll[3].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[3].iHeight);
+
+  CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[3].strMode.c_str());
+
+  resolutions.push_back(m_desktopResAll[3]);
+
+  m_desktopRes = m_desktopResAll[0];
+
+  return true;
+}
+
+bool CEGLNativeTypeV3D::GetPreferredResolution(RESOLUTION_INFO *res) const
+{
+  *res = m_desktopResAll[0];
+  return true;
+}
+
+bool CEGLNativeTypeV3D::ShowWindow(bool show)
+{
+  NXPL_ShowNativeWindowEXT(m_nativeWindow, show);
+  return true;
+}
diff --git a/xbmc/windowing/egl/EGLNativeTypeV3DNXPL.h b/xbmc/windowing/egl/EGLNativeTypeV3DNXPL.h
new file mode 100644
index 0000000..a174510
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeV3DNXPL.h
@@ -0,0 +1,129 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "EGLNativeType.h"
+
+#include <vector>
+#include <string>
+
+#define NEXUS_DISPLAYHANDLE void*
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef void *NXPL_PlatformHandle;
+
+typedef enum NEXUS_BlendFactor
+{
+    NEXUS_BlendFactor_eZero
+} NEXUS_BlendFactor;
+
+typedef struct NEXUS_BlendEquation
+{
+    NEXUS_BlendFactor a;
+    NEXUS_BlendFactor b;
+    bool              subtract_cd;
+    NEXUS_BlendFactor c;
+    NEXUS_BlendFactor d;
+    bool              subtract_e;
+    NEXUS_BlendFactor e;
+} NEXUS_BlendEquation;
+
+typedef struct
+{
+   uint32_t             width;
+   uint32_t             height;
+   uint32_t             x;
+   uint32_t             y;
+   bool                 stretch;
+   uint32_t             clientID;
+   uint32_t             zOrder;
+   NEXUS_BlendEquation  colorBlend;
+   NEXUS_BlendEquation  alphaBlend;
+   uint32_t             magic;
+} NXPL_NativeWindowInfoEXT;
+
+/* Register a display for exclusive use. The client application should not use the display until
+ * calling NXPL_UnregisterNexusDisplayPlatform.
+ * It will register its own memory, h/w and display APIs suitable for basic exclusive mode rendering on
+ * a Nexus display.
+ * Fills in the NXPL platform handle, which must be passed back into the unregister function.
+ */
+void NXPL_RegisterNexusDisplayPlatform(NXPL_PlatformHandle *handle, NEXUS_DISPLAYHANDLE display);
+
+/* Unregister a display for exclusive use. The client application can the use the Nexus display again. */
+void NXPL_UnregisterNexusDisplayPlatform(NXPL_PlatformHandle handle);
+
+/* Generate a default NXPL_NativeWindowInfoEXT */
+void NXPL_GetDefaultNativeWindowInfoEXT(NXPL_NativeWindowInfoEXT *info);
+
+/* Create a 'native window' of the given size. This is really just a small structure that holds the size
+ * of the window that EGL will write into. */
+void *NXPL_CreateNativeWindowEXT(const NXPL_NativeWindowInfoEXT *info);
+
+/* Destroy a 'native window' */
+void NXPL_DestroyNativeWindow(void *nativeWin);
+
+/* Show/hide a 'native window' */
+void NXPL_ShowNativeWindowEXT(void *native,bool show);
+
+int NEXUS_Platform_AuthenticatedJoin(const void *settings);
+#define NEXUS_Platform_Join() NEXUS_Platform_AuthenticatedJoin(NULL)
+
+#ifdef __cplusplus
+}
+#endif
+
+class CEGLNativeTypeV3D : public CEGLNativeType
+{
+public:
+  CEGLNativeTypeV3D();
+  virtual ~CEGLNativeTypeV3D();
+  virtual std::string GetNativeName() const { return "V3D"; };
+  virtual bool  CheckCompatibility();
+  virtual void  Initialize();
+  virtual void  Destroy();
+  virtual int   GetQuirks() { return EGL_QUIRK_NONE; };
+
+  virtual bool  CreateNativeDisplay();
+  virtual bool  CreateNativeWindow();
+  virtual bool  GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const;
+  virtual bool  GetNativeWindow(XBNativeWindowType **nativeWindow) const;
+
+  virtual bool  DestroyNativeWindow();
+  virtual bool  DestroyNativeDisplay();
+
+  virtual bool  GetNativeResolution(RESOLUTION_INFO *res) const;
+  virtual bool  SetNativeResolution(const RESOLUTION_INFO &res);
+  virtual bool  ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions);
+  virtual bool  GetPreferredResolution(RESOLUTION_INFO *res) const;
+
+  virtual bool  ShowWindow(bool show);
+private:
+  RESOLUTION_INFO m_desktopRes;
+  RESOLUTION_INFO m_desktopResAll[4];
+
+  NXPL_PlatformHandle nxpl_handle = 0;
+  NEXUS_DISPLAYHANDLE  nexus_display = 0;
+
+};
diff --git a/xbmc/windowing/egl/EGLNativeTypeVuplus.cpp b/xbmc/windowing/egl/EGLNativeTypeVuplus.cpp
new file mode 100644
index 0000000..214e51f
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeVuplus.cpp
@@ -0,0 +1,177 @@
+/*
+ *      Copyright (C) 2011-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include "system.h"
+#include "EGLNativeTypeVuplus.h"
+#include "utils/StringUtils.h"
+#include "utils/log.h"
+#include "guilib/gui3d.h"
+//#include "linux/DllBCM.h"
+#include "windowing/GraphicContext.h"
+
+#include <stdio.h>
+#include <malloc.h>
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#if defined(TARGET_VUPLUS_ARM)
+#include "KodiGLESPL.h"
+#else
+#include "gles_init.h"
+#endif
+
+using namespace std;
+
+bool CEGLNativeTypeVuplus::CheckCompatibility()
+{
+  return true;
+}
+
+void CEGLNativeTypeVuplus::Initialize()
+{
+}
+
+void CEGLNativeTypeVuplus::Destroy()
+{
+}
+
+bool CEGLNativeTypeVuplus::CreateNativeDisplay()
+{
+  GLES_Native_Init();
+  return GLES_Native_CreateNativeDisplay(&m_nativeDisplay);
+}
+
+bool CEGLNativeTypeVuplus::CreateNativeWindow()
+{
+  m_nativeWindow = GLES_Native_CreateNativeWindow();
+  if (!m_nativeWindow) {
+	  return false;
+  }
+  return true;
+}
+
+bool CEGLNativeTypeVuplus::GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const
+{
+  *nativeDisplay = (XBNativeDisplayType*) &m_nativeDisplay;
+  return true;
+}
+
+bool CEGLNativeTypeVuplus::GetNativeWindow(XBNativeDisplayType **nativeWindow) const
+{
+  *nativeWindow = (XBNativeWindowType*) &m_nativeWindow;
+  return true;
+}  
+
+bool CEGLNativeTypeVuplus::DestroyNativeDisplay()
+{
+  GLES_Native_DestroyNativeDisplay();
+  return true;
+}
+
+bool CEGLNativeTypeVuplus::DestroyNativeWindow()
+{
+  GLES_Native_DestroyNativeWindow();
+  return true;
+}
+
+bool CEGLNativeTypeVuplus::GetNativeResolution(RESOLUTION_INFO *res) const
+{
+  *res = m_desktopRes;
+  return true;
+}
+
+bool CEGLNativeTypeVuplus::SetNativeResolution(const RESOLUTION_INFO &res)
+{
+  m_desktopRes = res;
+  return true;
+}
+
+bool CEGLNativeTypeVuplus::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)
+{
+  resolutions.clear();
+
+  m_desktopResAll[0].bFullScreen  = true;
+  m_desktopResAll[0].iWidth       = 1280;
+  m_desktopResAll[0].iHeight      = 720;
+  m_desktopResAll[0].iScreenWidth = 1280;
+  m_desktopResAll[0].iScreenHeight= 720;
+  m_desktopResAll[0].dwFlags      =  D3DPRESENTFLAG_PROGRESSIVE;
+  m_desktopResAll[0].fRefreshRate = 50;
+  m_desktopResAll[0].strMode = StringUtils::Format("%dx%d", 1280, 720);
+  m_desktopResAll[0].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen", m_desktopRes.strMode.c_str(), (float)50,m_desktopRes.dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+
+  m_desktopResAll[0].iSubtitles   = (int)(0.965 * m_desktopResAll[0].iHeight);
+
+  CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[0].strMode.c_str());
+
+  resolutions.push_back(m_desktopResAll[0]);
+
+  m_desktopResAll[1].bFullScreen  = true;
+  m_desktopResAll[1].iWidth       = 1280;
+  m_desktopResAll[1].iHeight      = 720;
+  m_desktopResAll[1].iScreenWidth = 1280;
+  m_desktopResAll[1].iScreenHeight= 720;
+  m_desktopResAll[1].dwFlags      =  D3DPRESENTFLAG_PROGRESSIVE;
+
+  m_desktopResAll[1].dwFlags      |=  D3DPRESENTFLAG_MODE3DSBS;
+  m_desktopResAll[1].fRefreshRate = 50;
+  m_desktopResAll[1].strMode = StringUtils::Format("%dx%d", 1280, 720);
+  m_desktopResAll[1].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen 3DSBS", m_desktopResAll[1].strMode.c_str(), (float)50,m_desktopResAll[1].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+
+  m_desktopResAll[1].iSubtitles   = (int)(0.965 * m_desktopResAll[1].iHeight);
+
+  CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[1].strMode.c_str());
+
+  resolutions.push_back(m_desktopResAll[1]);
+
+  m_desktopResAll[2].bFullScreen  = true;
+  m_desktopResAll[2].iWidth       = 1280;
+  m_desktopResAll[2].iHeight      = 720;
+  m_desktopResAll[2].iScreenWidth = 1280;
+  m_desktopResAll[2].iScreenHeight= 720;
+  m_desktopResAll[2].dwFlags      =  D3DPRESENTFLAG_PROGRESSIVE;
+
+  m_desktopResAll[2].dwFlags      |=  D3DPRESENTFLAG_MODE3DTB;
+  m_desktopResAll[2].fRefreshRate = 50;
+  m_desktopResAll[2].strMode = StringUtils::Format("%dx%d", 1280, 720);
+  m_desktopResAll[2].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen 3DTB", m_desktopResAll[2].strMode.c_str(), (float)50,m_desktopResAll[2].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+
+  m_desktopResAll[2].iSubtitles   = (int)(0.965 * m_desktopResAll[2].iHeight);
+
+  CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[2].strMode.c_str());
+
+  resolutions.push_back(m_desktopResAll[2]);
+
+  m_desktopRes = m_desktopResAll[0];
+
+  return true;
+}
+
+bool CEGLNativeTypeVuplus::GetPreferredResolution(RESOLUTION_INFO *res) const
+{
+  *res = m_desktopResAll[0];
+  return true;
+}
+
+bool CEGLNativeTypeVuplus::ShowWindow(bool show)
+{
+  return false;
+}
+
diff --git a/xbmc/windowing/egl/EGLNativeTypeVuplus.h b/xbmc/windowing/egl/EGLNativeTypeVuplus.h
new file mode 100644
index 0000000..9f0ff93
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeVuplus.h
@@ -0,0 +1,60 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "EGLNativeType.h"
+
+#include <vector>
+#include <string>
+
+class CEGLNativeTypeVuplus : public CEGLNativeType
+{
+public:
+  CEGLNativeTypeVuplus()
+  {
+	  m_nativeWindow = 0;
+	  m_nativeDisplay = 0;
+  };
+  virtual ~CEGLNativeTypeVuplus() {};
+  virtual std::string GetNativeName() const { return "vuplus"; };
+  virtual bool  CheckCompatibility();
+  virtual void  Initialize();
+  virtual void  Destroy();
+  virtual int   GetQuirks() { return EGL_QUIRK_NONE; };
+
+  virtual bool  CreateNativeDisplay();
+  virtual bool  CreateNativeWindow();
+  virtual bool  GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const;
+  virtual bool  GetNativeWindow(XBNativeWindowType **nativeWindow) const;
+
+  virtual bool  DestroyNativeWindow();
+  virtual bool  DestroyNativeDisplay();
+
+  virtual bool  GetNativeResolution(RESOLUTION_INFO *res) const;
+  virtual bool  SetNativeResolution(const RESOLUTION_INFO &res);
+  virtual bool  ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions);
+  virtual bool  GetPreferredResolution(RESOLUTION_INFO *res) const;
+
+  virtual bool  ShowWindow(bool show);
+private:
+  RESOLUTION_INFO m_desktopRes;
+  RESOLUTION_INFO m_desktopResAll[3];
+};
diff --git a/xbmc/windowing/egl/EGLQuirks.h b/xbmc/windowing/egl/EGLQuirks.h
new file mode 100644
index 0000000..6624f23
--- /dev/null
+++ b/xbmc/windowing/egl/EGLQuirks.h
@@ -0,0 +1,42 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#define EGL_QUIRK_NONE (0)
+
+/*! \brief Enable this if the implementation does not know its native
+     resolution until a surface has been created. Used, for example, on Android
+     where we have no control over the resolution, so we query it once the
+     surface exists.
+*/
+#define EGL_QUIRK_NEED_WINDOW_FOR_RES (1 << 0)
+
+/*! \brief Enable this if the implementation should have its native window
+     destroyed when the surface is destroyed. In practice this means that a new
+     native window will be created each time the main XBMC window is recreated.
+*/
+#define EGL_QUIRK_DESTROY_NATIVE_WINDOW_WITH_SURFACE (1 << 1)
+
+/*! \brief Some drivers destroy the native display on resolution change. xbmc's EGL
+    implementation is not aware of this change. In that case a Reinit of the display
+    needs to be done.
+*/
+#define EGL_QUIRK_RECREATE_DISPLAY_ON_CREATE_WINDOW (1 << 3)
diff --git a/xbmc/windowing/egl/EGLWrapper.cpp b/xbmc/windowing/egl/EGLWrapper.cpp
new file mode 100644
index 0000000..4ff33d5
--- /dev/null
+++ b/xbmc/windowing/egl/EGLWrapper.cpp
@@ -0,0 +1,451 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include "system.h"
+
+#ifdef HAS_EGL
+#include "utils/log.h"
+#include <assert.h>
+#if defined(HAS_IMXVPU)
+  #include "EGLNativeTypeIMX.h"
+#endif
+#if defined(TARGET_DREAMBOX) 
+  #include "EGLNativeTypeDreambox.h"
+#endif
+#if defined(TARGET_V3DNXPL)
+  #include "EGLNativeTypeV3DNXPL.h"
+#endif
+#if defined(TARGET_XCORE)
+  #include "EGLNativeTypeV3D.h"
+#endif
+#if defined(TARGET_VUPLUS)
+  #include "EGLNativeTypeVuplus.h"
+#endif
+#if defined(TARGET_NEXTV)
+  #include "EGLNativeTypeNexTV.h"
+#endif
+#if defined(TARGET_DAGS)
+  #include "EGLNativeTypeDags.h"
+#endif
+#if defined(TARGET_GB)
+  #include "EGLNativeTypeGB.h"
+#endif
+#if defined(TARGET_MALI)
+  #include "EGLNativeTypeMali.h"
+#endif
+#if defined(TARGET_EDISION)
+  #include "EGLNativeTypeEdision.h"
+#endif
+
+#include "EGLWrapper.h"
+
+#define CheckError() m_result = eglGetError(); if(m_result != EGL_SUCCESS) CLog::Log(LOGERROR, "EGL error in %s: %x",__FUNCTION__, m_result);
+
+CEGLWrapper::CEGLWrapper()
+{
+  m_nativeTypes = NULL;
+  m_result = EGL_SUCCESS;
+}
+
+CEGLWrapper::~CEGLWrapper()
+{
+  Destroy();
+}
+
+namespace
+{
+  bool
+  CorrectGuess(CEGLNativeType *guess,
+               const std::string &implementation)
+  {
+    assert(guess != NULL);
+
+    if(guess->CheckCompatibility())
+    {
+      if (implementation == guess->GetNativeName() ||
+          implementation == "auto")
+      {
+        return true;
+      }
+    }
+
+    return false;
+  }
+
+  template <class NativeType>
+  CEGLNativeType * CreateEGLNativeType(const std::string &implementation)
+  {
+    CEGLNativeType *guess = new NativeType;
+    if(CorrectGuess(guess, implementation))
+      return guess;
+
+    delete guess;
+    return NULL;
+  }
+}
+
+bool CEGLWrapper::Initialize(const std::string &implementation)
+{
+  CEGLNativeType *nativeGuess = NULL;
+
+  // Try to create each backend in sequence and go with the first one
+  // that we know will work
+  if (
+#if defined(HAS_IMXVPU)
+      (nativeGuess = CreateEGLNativeType<CEGLNativeTypeIMX>(implementation))
+#elif defined(TARGET_DREAMBOX) 
+      (nativeGuess = CreateEGLNativeType<CEGLNativeTypeDreambox>(implementation))
+#elif defined(TARGET_V3DNXPL)
+      (nativeGuess = CreateEGLNativeType<CEGLNativeTypeV3D>(implementation))
+#elif defined(TARGET_XCORE)
+      (nativeGuess = CreateEGLNativeType<CEGLNativeTypeV3D>(implementation))
+#elif defined(TARGET_VUPLUS)
+      (nativeGuess = CreateEGLNativeType<CEGLNativeTypeVuplus>(implementation))
+#elif defined(TARGET_NEXTV)
+      (nativeGuess = CreateEGLNativeType<CEGLNativeTypeNexTV>(implementation))
+#elif defined(TARGET_DAGS)
+      (nativeGuess = CreateEGLNativeType<CEGLNativeTypeDags>(implementation))
+#elif defined(TARGET_GB)
+      (nativeGuess = CreateEGLNativeType<CEGLNativeTypeGB>(implementation))
+#elif defined(TARGET_MALI)
+      (nativeGuess = CreateEGLNativeType<CEGLNativeTypeMali>(implementation))
+#elif defined(TARGET_EDISION)
+      (nativeGuess = CreateEGLNativeType<CEGLNativeTypeV3D>(implementation))
+#endif
+    )
+  {
+    m_nativeTypes = nativeGuess;
+
+    m_nativeTypes->Initialize();
+    return true;
+  }
+
+  return false;
+}
+
+bool CEGLWrapper::Destroy()
+{
+  if (!m_nativeTypes)
+    return false;
+
+  m_nativeTypes->Destroy();
+
+  delete m_nativeTypes;
+  m_nativeTypes = NULL;
+  return true;
+}
+
+std::string CEGLWrapper::GetNativeName()
+{
+  if (m_nativeTypes)
+    return m_nativeTypes->GetNativeName();
+  return "";
+}
+
+bool CEGLWrapper::CreateNativeDisplay()
+{
+  if(!m_nativeTypes)
+    return false;
+
+  return m_nativeTypes->CreateNativeDisplay();
+}
+
+bool CEGLWrapper::CreateNativeWindow()
+{
+  if(!m_nativeTypes)
+    return false;
+
+  return m_nativeTypes->CreateNativeWindow();
+}
+
+void CEGLWrapper::DestroyNativeDisplay()
+{
+  if(m_nativeTypes)
+    m_nativeTypes->DestroyNativeDisplay();
+}
+
+void CEGLWrapper::DestroyNativeWindow()
+{
+  if(m_nativeTypes)
+    m_nativeTypes->DestroyNativeWindow();
+}
+
+bool CEGLWrapper::SetNativeResolution(RESOLUTION_INFO& res)
+{
+  if (!m_nativeTypes)
+    return false;
+  return m_nativeTypes->SetNativeResolution(res);
+}
+
+bool CEGLWrapper::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)
+{
+  if (!m_nativeTypes)
+    return false;
+  return m_nativeTypes->ProbeResolutions(resolutions);
+}
+
+bool CEGLWrapper::GetPreferredResolution(RESOLUTION_INFO *res)
+{
+  if(!m_nativeTypes || !res)
+    return false;
+
+  return m_nativeTypes->GetPreferredResolution(res);
+}
+
+bool CEGLWrapper::GetNativeResolution(RESOLUTION_INFO *res)
+{
+  if(!m_nativeTypes || !res)
+    return false;
+
+  return m_nativeTypes->GetNativeResolution(res);
+}
+
+bool CEGLWrapper::ShowWindow(bool show)
+{
+  if (!m_nativeTypes)
+    return false;
+
+  return m_nativeTypes->ShowWindow(show);
+}
+
+bool CEGLWrapper::GetQuirks(int *quirks)
+{
+  if (!m_nativeTypes || !quirks)
+    return false;
+  *quirks = m_nativeTypes->GetQuirks();
+  return true;
+}
+
+bool CEGLWrapper::InitDisplay(EGLDisplay *display)
+{
+  if (!display || !m_nativeTypes)
+    return false;
+
+  //nativeDisplay can be (and usually is) NULL. Don't use if(nativeDisplay) as a test!
+  EGLint status;
+  EGLNativeDisplayType *nativeDisplay = NULL;
+  if (!m_nativeTypes->GetNativeDisplay((XBNativeDisplayType**)&nativeDisplay))
+    return false;
+
+  *display = eglGetDisplay(*nativeDisplay);
+  CheckError();
+  if (*display == EGL_NO_DISPLAY)
+  {
+    CLog::Log(LOGERROR, "EGL failed to obtain display");
+    return false;
+  }
+
+  status = eglInitialize(*display, 0, 0);
+  CheckError();
+  return status;
+}
+
+bool CEGLWrapper::ChooseConfig(EGLDisplay display, EGLint *configAttrs, EGLConfig *config)
+{
+  EGLint     configCount = 0;
+  EGLConfig* configList = NULL;
+
+  // Find out how many configurations suit our needs
+  EGLBoolean eglStatus = eglChooseConfig(display, configAttrs, NULL, 0, &configCount);
+  CheckError();
+
+  if (!eglStatus || !configCount)
+  {
+    CLog::Log(LOGERROR, "EGL failed to return any matching configurations: %i", configCount);
+    return false;
+  }
+
+  // Allocate room for the list of matching configurations
+  configList = (EGLConfig*)malloc(configCount * sizeof(EGLConfig));
+  if (!configList)
+  {
+    CLog::Log(LOGERROR, "EGL failure obtaining configuration list");
+    return false;
+  }
+
+  // Obtain the configuration list from EGL
+  eglStatus = eglChooseConfig(display, configAttrs, configList, configCount, &configCount);
+  CheckError();
+  if (!eglStatus || !configCount)
+  {
+    CLog::Log(LOGERROR, "EGL failed to populate configuration list: %d", eglStatus);
+    return false;
+  }
+
+  // Select an EGL configuration that matches the native window
+  *config = configList[0];
+
+  free(configList);
+  return m_result == EGL_SUCCESS;
+}
+
+bool CEGLWrapper::CreateContext(EGLDisplay display, EGLConfig config, EGLint *contextAttrs, EGLContext *context)
+{
+  if (!context)
+    return false;
+
+  *context = eglCreateContext(display, config, NULL, contextAttrs);
+  CheckError();
+  return *context != EGL_NO_CONTEXT;
+}
+
+bool CEGLWrapper::CreateSurface(EGLDisplay display, EGLConfig config, EGLSurface *surface)
+{
+  if (!surface || !m_nativeTypes)
+    return false;
+
+  EGLNativeWindowType *nativeWindow=NULL;
+  if (!m_nativeTypes->GetNativeWindow((XBNativeWindowType**)&nativeWindow))
+    return false;
+
+  *surface = eglCreateWindowSurface(display, config, *nativeWindow, NULL);
+  CheckError();
+  return *surface != EGL_NO_SURFACE;
+}
+
+bool CEGLWrapper::GetSurfaceSize(EGLDisplay display, EGLSurface surface, EGLint *width, EGLint *height)
+{
+  if (!width || !height)
+    return false;
+
+  const bool failedToQuerySurfaceSize =
+    !eglQuerySurface(display, surface, EGL_WIDTH, width) ||
+    !eglQuerySurface(display, surface, EGL_HEIGHT, height);
+  const bool invalidSurfaceSize =
+    *width <= 0 || *height <= 0;
+
+  if (failedToQuerySurfaceSize || invalidSurfaceSize)
+    return false;
+
+  return true;
+}
+
+bool CEGLWrapper::BindContext(EGLDisplay display, EGLSurface surface, EGLContext context)
+{
+  EGLBoolean status;
+  status = eglMakeCurrent(display, surface, surface, context);
+  CheckError();
+  return status;
+}
+
+bool CEGLWrapper::BindAPI(EGLint type)
+{
+  EGLBoolean status;
+  status = eglBindAPI(type);
+  CheckError();
+  return status && m_result == EGL_SUCCESS;
+}
+
+bool CEGLWrapper::ReleaseContext(EGLDisplay display)
+{
+  EGLBoolean status;
+  if (display == EGL_NO_DISPLAY)
+    return false;
+  status = eglMakeCurrent(display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+  CheckError();
+  return status;
+}
+
+bool CEGLWrapper::DestroyContext(EGLDisplay display, EGLContext context)
+{
+  EGLBoolean status;
+  if (display == EGL_NO_DISPLAY)
+    return false;
+  status = eglDestroyContext(display, context);
+  CheckError();
+  return status;
+}
+
+bool CEGLWrapper::DestroySurface(EGLSurface surface, EGLDisplay display)
+{
+  EGLBoolean status;
+
+  status = eglDestroySurface(display, surface);
+  CheckError();
+  return status;
+}
+
+bool CEGLWrapper::DestroyDisplay(EGLDisplay display)
+{
+  EGLBoolean eglStatus;
+
+  eglStatus = eglMakeCurrent(display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+  CheckError();
+  if (!eglStatus)
+    return false;
+
+  eglStatus = eglTerminate(display);
+  CheckError();
+  if (!eglStatus)
+    return false;
+
+  return true;
+}
+
+std::string CEGLWrapper::GetExtensions(EGLDisplay display)
+{
+  std::string extensions = eglQueryString(display, EGL_EXTENSIONS);
+  CheckError();
+  return " " + extensions + " ";
+}
+
+bool CEGLWrapper::SetVSync(EGLDisplay display, bool enable)
+{
+  EGLBoolean status;
+  // depending how buffers are setup, eglSwapInterval
+  // might fail so let caller decide if this is an error.
+  status = eglSwapInterval(display, enable ? 1 : 0);
+  CheckError();
+  return status;
+}
+
+void CEGLWrapper::SwapBuffers(EGLDisplay display, EGLSurface surface)
+{
+  if ((display == EGL_NO_DISPLAY) || (surface == EGL_NO_SURFACE))
+    return;
+  eglSwapBuffers(display, surface);
+}
+
+bool CEGLWrapper::GetConfigAttrib(EGLDisplay display, EGLConfig config, EGLint attribute, EGLint *value)
+{
+  if (display == EGL_NO_DISPLAY || !config || !attribute)
+    return eglGetConfigAttrib(display, config, attribute, value);
+  return false;
+}
+
+void* CEGLWrapper::GetProcAddress(const char* function)
+{
+  void* ext = (void*) eglGetProcAddress(function);
+  if (!ext)
+  {
+    CLog::Log(LOGERROR, "EGL error in %s - cannot get proc addr of %s", __FUNCTION__, function);
+    return NULL;
+  }
+
+  return ext;
+}
+
+bool CEGLWrapper::SurfaceAttrib(EGLDisplay display, EGLSurface surface, EGLint attribute, EGLint value)
+{
+  if ((display == EGL_NO_DISPLAY) || (surface == EGL_NO_SURFACE))
+    return false;
+  return eglSurfaceAttrib(display, surface, attribute, value);
+}
+#endif
+
diff --git a/xbmc/windowing/egl/EGLWrapper.h b/xbmc/windowing/egl/EGLWrapper.h
new file mode 100644
index 0000000..3a73b3e
--- /dev/null
+++ b/xbmc/windowing/egl/EGLWrapper.h
@@ -0,0 +1,76 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <string>
+#include <vector>
+
+#include "windowing/Resolution.h"
+#include <EGL/egl.h>
+class CEGLNativeType;
+class CEGLWrapper
+{
+public:
+  CEGLWrapper();
+  ~CEGLWrapper();
+
+  bool Initialize(const std::string &implementation = "auto");
+  bool Destroy();
+  std::string GetNativeName();
+
+  bool CreateNativeDisplay();
+  bool CreateNativeWindow();
+  void DestroyNativeDisplay();
+  void DestroyNativeWindow();
+
+  bool SetNativeResolution(RESOLUTION_INFO& res);
+  bool ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions);
+  bool ShowWindow(bool show);
+  bool GetQuirks(int *quirks);
+  bool GetPreferredResolution(RESOLUTION_INFO *res);
+  bool GetNativeResolution(RESOLUTION_INFO *res);
+
+  bool InitDisplay(EGLDisplay *display);
+  bool ChooseConfig(EGLDisplay display, EGLint *configAttrs, EGLConfig *config);
+  bool CreateContext(EGLDisplay display, EGLConfig config, EGLint *contextAttrs, EGLContext *context);
+  bool CreateSurface(EGLDisplay display, EGLConfig config, EGLSurface *surface);
+  bool GetSurfaceSize(EGLDisplay display, EGLSurface surface, EGLint *width, EGLint *height);
+  bool BindContext(EGLDisplay display, EGLSurface surface, EGLContext context);
+  bool BindAPI(EGLint type);
+  bool ReleaseContext(EGLDisplay display);
+  bool DestroyContext(EGLDisplay display, EGLContext context);
+  bool DestroySurface(EGLSurface surface, EGLDisplay display);
+  bool DestroyDisplay(EGLDisplay display);
+
+  std::string GetExtensions(EGLDisplay display);
+  void SwapBuffers(EGLDisplay display, EGLSurface surface);
+  bool SetVSync(EGLDisplay display, bool enable);
+  bool IsExtSupported(const char* extension);
+  bool GetConfigAttrib(EGLDisplay display, EGLConfig config, EGLint attribute, EGLint *value);
+  bool SurfaceAttrib(EGLDisplay display, EGLSurface surface, EGLint  attribute, EGLint  value);
+
+  static void* GetProcAddress(const char* function);
+
+private:
+
+  CEGLNativeType *m_nativeTypes;
+  EGLint         m_result;
+};
diff --git a/xbmc/windowing/egl/WinEventsSTB.cpp b/xbmc/windowing/egl/WinEventsSTB.cpp
new file mode 100644
index 0000000..24a9a75
--- /dev/null
+++ b/xbmc/windowing/egl/WinEventsSTB.cpp
@@ -0,0 +1,92 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include "system.h"
+
+#include "AppInboundProtocol.h"
+#include "WinEventsSTB.h"
+#include "windowing/WinEvents.h"
+#include "windowing/XBMC_events.h"
+#include "input/XBMC_keysym.h"
+#include "Application.h"
+#include "input/mouse/MouseStat.h"
+#include "utils/log.h"
+#include "powermanagement/PowerManager.h"
+#include "ServiceBroker.h"
+#include "platform/linux/input/LinuxInputDevices.h"
+
+
+bool CWinEventsSTB::m_initialized = false;
+CLinuxInputDevices CWinEventsSTB::m_devices;
+
+
+void CWinEventsSTB::RefreshDevices()
+{
+  m_devices.InitAvailable();
+}
+
+bool CWinEventsSTB::IsRemoteLowBattery()
+{
+  return m_devices.IsRemoteLowBattery();
+  return false;
+}
+
+bool CWinEventsSTB::MessagePump()
+{
+  std::shared_ptr<CAppInboundProtocol> appPort = CServiceBroker::GetAppPort();
+
+  if (!m_initialized)
+  {
+    m_devices.InitAvailable();
+    m_checkHotplug = std::unique_ptr<CLinuxInputDevicesCheckHotplugged>(new CLinuxInputDevicesCheckHotplugged(m_devices));
+    m_initialized = true;
+  }
+
+  bool ret = false;
+  XBMC_Event event = {0};
+  while (1)
+  {
+    event = m_devices.ReadEvent();
+    if (event.type != XBMC_NOEVENT)
+    {
+      if (appPort)
+         ret |= appPort->OnEvent(event);
+    }
+    else
+    {
+      break;
+    }
+  }
+
+  return ret;
+}
+
+size_t CWinEventsSTB::GetQueueSize()
+{
+  return m_devices.Size();
+}
+
+void CWinEventsSTB::MessagePush(XBMC_Event *ev)
+{
+  std::shared_ptr<CAppInboundProtocol> appPort = CServiceBroker::GetAppPort();
+  if (appPort)
+    appPort->OnEvent(*ev);
+}
+
+//#endif
diff --git a/xbmc/windowing/egl/WinEventsSTB.h b/xbmc/windowing/egl/WinEventsSTB.h
new file mode 100644
index 0000000..d154068
--- /dev/null
+++ b/xbmc/windowing/egl/WinEventsSTB.h
@@ -0,0 +1,47 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#pragma once
+#include <memory>
+#include "windowing/WinEvents.h"
+#include "platform/linux/input/LinuxInputDevices.h"
+#include "utils/Observer.h"
+
+class CWinEventsSTB : public IWinEvents
+{
+public:
+  bool MessagePump() override;
+  size_t GetQueueSize();
+  void MessagePush(XBMC_Event *ev);
+  void RefreshDevices();
+  void Notify(const Observable &obs, const ObservableMessage msg)
+  {
+    if (msg == ObservableMessagePeripheralsChanged)
+      RefreshDevices();
+  }
+  static bool IsRemoteLowBattery();
+
+private:
+  friend class CWinEventsSTB;
+  static bool m_initialized;
+  static CLinuxInputDevices m_devices;
+  std::unique_ptr<CLinuxInputDevicesCheckHotplugged> m_checkHotplug;
+};
+
diff --git a/xbmc/windowing/egl/WinSystemSTBContext.cpp b/xbmc/windowing/egl/WinSystemSTBContext.cpp
new file mode 100644
index 0000000..623de92
--- /dev/null
+++ b/xbmc/windowing/egl/WinSystemSTBContext.cpp
@@ -0,0 +1,112 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "WinSystemSTBContext.h"
+
+#include "Application.h"
+#include "ServiceBroker.h"
+#include "cores/VideoPlayer/VideoRenderers/RenderFactory.h"
+#include "cores/RetroPlayer/process/RPProcessInfo.h"
+
+#ifdef HAS_GLES
+#include "cores/RetroPlayer/rendering/VideoRenderers/RPRendererOpenGLES.h"
+#include "cores/VideoPlayer/VideoRenderers/LinuxRendererGLES.h"
+#else
+#include "cores/RetroPlayer/rendering/VideoRenderers/RPRendererOpenGL.h"
+#include "cores/VideoPlayer/VideoRenderers/LinuxRendererGL.h"
+#endif
+
+#include "cores/VideoPlayer/VideoRenderers/RenderFactory.h"
+#include "guilib/GUIComponent.h"
+#include "guilib/GUIWindowManager.h"
+#include "utils/log.h"
+
+
+using namespace KODI;
+
+std::unique_ptr<CWinSystemBase> CWinSystemBase::CreateWinSystem()
+{
+  std::unique_ptr<CWinSystemBase> winSystem(new CWinSystemSTBContext());
+  return winSystem;
+}
+
+bool CWinSystemSTBContext::InitWindowSystem()
+{
+  if (!CWinSystemstb::InitWindowSystem())
+  {
+    return false;
+  }
+
+
+  VIDEOPLAYER::CRendererFactory::ClearRenderer();
+#ifdef HAS_GLES
+  CLinuxRendererGLES::Register();
+  RETRO::CRPProcessInfo::RegisterRendererFactory(new RETRO::CRendererFactoryOpenGLES);
+#else
+  CLinuxRendererGL::Register();
+  RETRO::CRPProcessInfo::RegisterRendererFactory(new RETRO::CRendererFactoryOpenGL);
+#endif
+  return true;
+}
+
+bool CWinSystemSTBContext::CreateNewWindow(const std::string& name,
+                                               bool fullScreen,
+                                               RESOLUTION_INFO& res)
+{
+  CWinSystemstb::CreateNewWindow(name,fullScreen,res);
+
+  return true;
+}
+
+bool CWinSystemSTBContext::ResizeWindow(int newWidth, int newHeight, int newLeft, int newTop)
+{
+  CRenderSystemGLES::ResetRenderSystem(newWidth, newHeight);
+  return true;
+}
+
+bool CWinSystemSTBContext::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays)
+{
+  CreateNewWindow("", fullScreen, res);
+  CRenderSystemGLES::ResetRenderSystem(res.iWidth, res.iHeight);
+  return true;
+}
+
+void CWinSystemSTBContext::SetVSyncImpl(bool enable)
+{
+  m_bVSync = enable;
+  if (!CWinSystemstb::SetVSyncImpl(enable))
+      m_bVSync = 0;
+}
+
+void CWinSystemSTBContext::PresentRenderImpl(bool rendered)
+{
+  CWinSystemstb::PresentRenderImpl(rendered);
+}
+
+EGLDisplay CWinSystemSTBContext::GetEGLDisplay()
+{
+  return CWinSystemstb::GetEGLDisplay();
+}
+
+EGLContext CWinSystemSTBContext::GetEGLContext()
+{
+  return CWinSystemstb::GetEGLContext();
+}
+
+EGLConfig  CWinSystemSTBContext::GetEGLConfig()
+{
+  return CWinSystemstb::GetEGLConfig();
+}
+
+/*std::unique_ptr<CVideoSync> CWinSystemSTBContext::GetVideoSync(void *clock)
+{
+  std::unique_ptr<CVideoSync> pVSync(new CVideoSyncPi(clock));
+  return pVSync;
+    return false;
+}*/
+
diff --git a/xbmc/windowing/egl/WinSystemSTBContext.h b/xbmc/windowing/egl/WinSystemSTBContext.h
new file mode 100644
index 0000000..f8efc14
--- /dev/null
+++ b/xbmc/windowing/egl/WinSystemSTBContext.h
@@ -0,0 +1,43 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "WinSystemstb.h"
+#include "rendering/gles/RenderSystemGLES.h"
+#include "utils/EGLUtils.h"
+
+class CWinSystemSTBContext : public CWinSystemstb, public CRenderSystemGLES
+{
+public:
+  CWinSystemSTBContext() = default;
+  virtual ~CWinSystemSTBContext() = default;
+
+  // Implementation of CWinSystemBase
+  CRenderSystemBase *GetRenderSystem() override { return this; }
+  bool InitWindowSystem() override;
+  bool CreateNewWindow(const std::string& name,
+                       bool fullScreen,
+                       RESOLUTION_INFO& res) override;
+
+  bool ResizeWindow(int newWidth, int newHeight, int newLeft, int newTop) override;
+  bool SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays) override;
+
+  //virtual std::unique_ptr<CVideoSync> GetVideoSync(void *clock) override;
+
+  EGLDisplay GetEGLDisplay();
+  EGLContext GetEGLContext();
+  EGLConfig  GetEGLConfig();
+protected:
+  void SetVSyncImpl(bool enable) override;
+  void PresentRenderImpl(bool rendered) override;
+
+private:
+  CEGLContextUtils m_pGLContext;
+
+};
diff --git a/xbmc/windowing/egl/WinSystemstb.cpp b/xbmc/windowing/egl/WinSystemstb.cpp
new file mode 100644
index 0000000..b462b54
--- /dev/null
+++ b/xbmc/windowing/egl/WinSystemstb.cpp
@@ -0,0 +1,541 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "system.h"
+
+#include "WinSystemstb.h"
+
+#include "filesystem/SpecialProtocol.h"
+#include "ServiceBroker.h"
+#include "cores/AudioEngine/AESinkFactory.h"
+//#include "cores/AudioEngine/Sinks/AESinkPi.h"
+#include "guilib/DispResource.h"
+#include "settings/DisplaySettings.h"
+#include "settings/Settings.h"
+#include "settings/AdvancedSettings.h"
+#include "settings/SettingsComponent.h"
+#include "utils/log.h"
+#include "windowing/GraphicContext.h"
+#include "windowing/Resolution.h"
+
+//#include "platform/linux/DllBCM.h"
+//#include "platform/linux/RBP.h"
+#include "platform/linux/powermanagement/LinuxPowerSyscall.h"
+#include "guilib/IDirtyRegionSolver.h"
+#include "WinEventsSTB.h"
+
+#include <vector>
+#include <float.h>
+#include <string.h>
+
+#include "EGLWrapper.h"
+#include "EGLQuirks.h"
+
+#include <EGL/egl.h>
+#include <EGL/eglplatform.h>
+
+using namespace KODI;
+
+CWinSystemstb::CWinSystemstb():
+  m_libinput(new CLibInputHandler)
+{
+  m_display = EGL_NO_DISPLAY;
+  m_surface = EGL_NO_SURFACE;
+  m_context = EGL_NO_CONTEXT;
+
+  m_displayWidth = 0;
+  m_displayHeight = 0;
+
+  m_stereo_mode = RENDER_STEREO_MODE_OFF;
+  m_delayDispReset = false;
+
+  m_egl = new CEGLWrapper;
+
+//  AE::CAESinkFactory::ClearSinks();
+
+//  CAESinkPi::Register();
+  std::string envSink;
+  if (getenv("KODI_AE_SINK"))
+    envSink = getenv("KODI_AE_SINK");
+
+  if (StringUtils::EqualsNoCase(envSink, "PULSE"))
+  {
+    OPTIONALS::PulseAudioRegister();
+  }
+  else
+  {
+    OPTIONALS::ALSARegister();
+  }
+
+  CLinuxPowerSyscall::Register();
+  m_winEvents.reset(new CWinEventsSTB());
+  m_lirc.reset(OPTIONALS::LircRegister());
+  m_libinput->Start();
+}
+
+CWinSystemstb::~CWinSystemstb()
+{
+  delete m_egl;
+  m_egl = nullptr;
+ //if(m_nativeWindow)
+  //{
+  //  m_nativeWindow = nullptr;
+  //}
+}
+
+bool CWinSystemstb::InitWindowSystem()
+{
+  RESOLUTION_INFO preferred_resolution;
+  if (!m_egl)
+    m_egl = new CEGLWrapper;
+
+  if (!m_egl)
+  {
+    CLog::Log(LOGERROR, "%s: EGL not in a good state",__FUNCTION__);
+    return false;
+  }
+
+  if (!m_egl->Initialize("auto"))
+  {
+    CLog::Log(LOGERROR, "%s: Could not initialize",__FUNCTION__);
+    return false;
+  }
+
+  CLog::Log(LOGNOTICE, "%s: Using EGL Implementation: %s",__FUNCTION__,m_egl->GetNativeName().c_str());
+
+  if (!m_egl->CreateNativeDisplay())
+  {
+    CLog::Log(LOGERROR, "%s: Could not get native display",__FUNCTION__);
+    return false;
+  }
+
+  if (!m_egl->CreateNativeWindow())
+  {
+    CLog::Log(LOGERROR, "%s: Could not get native window",__FUNCTION__);
+    return false;
+  }
+
+  if (!m_egl->InitDisplay(&m_display))
+  {
+    CLog::Log(LOGERROR, "%s: Could not create display",__FUNCTION__);
+    return false;
+  }
+
+  EGLint surface_type = EGL_WINDOW_BIT;
+  // for the non-trivial dirty region modes, we need the EGL buffer to be preserved across updates
+  int guiAlgorithmDirtyRegions = CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_guiAlgorithmDirtyRegions;
+  if (guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_COST_REDUCTION ||
+      guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_UNION)
+    surface_type |= EGL_SWAP_BEHAVIOR_PRESERVED_BIT;
+
+  EGLint configAttrs [] = {
+        EGL_RED_SIZE,        8,
+        EGL_GREEN_SIZE,      8,
+        EGL_BLUE_SIZE,       8,
+        EGL_ALPHA_SIZE,      8,
+        EGL_DEPTH_SIZE,     16,
+        EGL_STENCIL_SIZE,    0,
+#if defined(TARGET_EDISION)
+        EGL_SAMPLE_BUFFERS,  1,
+        EGL_SAMPLES,         4,
+#else
+        EGL_SAMPLE_BUFFERS,  0,
+        EGL_SAMPLES,         0,
+#endif
+        EGL_SURFACE_TYPE,    surface_type,
+        EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
+        EGL_NONE
+  };
+
+  if (!m_egl->ChooseConfig(m_display, configAttrs, &m_config))
+  {
+    CLog::Log(LOGERROR, "%s: Could not find a compatible configuration",__FUNCTION__);
+    return false;
+  }
+
+
+  // Some platforms require a surface before we can probe the resolution.
+  // Create the window here, then the creation in CreateNewWindow() will be skipped.
+  int quirks;
+  m_egl->GetQuirks(&quirks);
+  if (quirks & EGL_QUIRK_NEED_WINDOW_FOR_RES)
+  {
+    RESOLUTION_INFO temp;
+    CreateWindow(temp);
+  }
+
+  m_extensions = m_egl->GetExtensions(m_display);
+  return CWinSystemBase::InitWindowSystem();
+}
+
+bool CWinSystemstb::DestroyWindowSystem()
+{
+  if (!m_egl)
+    return true;
+
+  DestroyWindow();
+
+  if (m_context != EGL_NO_CONTEXT)
+  {
+    m_egl->DestroyContext(m_display, m_context);
+  }
+  m_context = EGL_NO_CONTEXT;
+
+  if (m_display != EGL_NO_DISPLAY)
+    m_egl->DestroyDisplay(m_display);
+  m_display = EGL_NO_DISPLAY;
+
+  m_egl->DestroyNativeWindow();
+
+  m_egl->DestroyNativeDisplay();
+
+  m_egl->Destroy();
+  delete m_egl;
+  m_egl = NULL;
+
+  CWinSystemBase::DestroyWindowSystem();
+  //return true;
+}
+bool CWinSystemstb::CreateNewWindow(const std::string& name,
+                                    bool fullScreen,
+                                    RESOLUTION_INFO& res)
+{
+  RESOLUTION_INFO current_resolution;
+  current_resolution.iWidth = current_resolution.iHeight = 0;
+  RENDER_STEREO_MODE stereo_mode = CServiceBroker::GetWinSystem()->GetGfxContext().GetStereoMode();
+
+  m_nWidth        = res.iWidth;
+  m_nHeight       = res.iHeight;
+  m_displayWidth  = res.iScreenWidth;
+  m_displayHeight = res.iScreenHeight;
+  m_fRefreshRate  = res.fRefreshRate;
+
+  if ((m_bWindowCreated && m_egl && m_egl->GetNativeResolution(&current_resolution)) &&
+    current_resolution.iWidth == res.iWidth && current_resolution.iHeight == res.iHeight &&
+    current_resolution.iScreenWidth == res.iScreenWidth && current_resolution.iScreenHeight == res.iScreenHeight &&
+    m_bFullScreen == fullScreen && current_resolution.fRefreshRate == res.fRefreshRate &&
+    (current_resolution.dwFlags & D3DPRESENTFLAG_MODEMASK) == (res.dwFlags & D3DPRESENTFLAG_MODEMASK) &&
+    m_stereo_mode == stereo_mode)
+  {
+    CLog::Log(LOGDEBUG, "CWinSystemEGL::CreateNewWindow: No need to create a new window");
+    return true;
+  }
+
+  int delay = CServiceBroker::GetSettingsComponent()->GetSettings()->GetInt("videoscreen.delayrefreshchange");
+  if (delay > 0)
+  {
+    m_delayDispReset = true;
+    m_dispResetTimer.Set(delay * 100);
+  }
+
+  {
+    CSingleLock lock(m_resourceSection);
+    for (std::vector<IDispResource *>::iterator i = m_resources.begin(); i != m_resources.end(); ++i)
+      (*i)->OnLostDisplay();
+  }
+
+  m_stereo_mode = stereo_mode;
+  m_bFullScreen   = fullScreen;
+  // Destroy any existing window
+  if (m_surface != EGL_NO_SURFACE)
+    DestroyWindow();
+
+  // If we previously destroyed an existing window we need to create a new one
+  // (otherwise this is taken care of by InitWindowSystem())
+  if (!CreateWindow(res))
+  {
+    CLog::Log(LOGERROR, "%s: Could not create new window",__FUNCTION__);
+    return false;
+  }
+
+  if (!m_delayDispReset)
+  {
+    CSingleLock lock(m_resourceSection);
+    // tell any shared resources
+    for (std::vector<IDispResource *>::iterator i = m_resources.begin(); i != m_resources.end(); ++i)
+      (*i)->OnResetDisplay();
+  }
+
+  Show();
+  return true;
+}
+
+bool CWinSystemstb::CreateWindow(RESOLUTION_INFO &res)
+{
+  if (!m_egl)
+  {
+    CLog::Log(LOGERROR, "CWinSystemEGL::CreateWindow no EGL!");
+    return false;
+  }
+
+  if(m_egl)
+    m_egl->SetNativeResolution(res);
+
+  int quirks;
+  m_egl->GetQuirks(&quirks);
+  if (quirks & EGL_QUIRK_RECREATE_DISPLAY_ON_CREATE_WINDOW)
+  {
+    if (m_context != EGL_NO_CONTEXT)
+      if (!m_egl->InitDisplay(&m_display))
+      {
+        CLog::Log(LOGERROR, "%s: Could not reinit display",__FUNCTION__);
+        return false;
+      }
+  }
+
+  if (!m_egl->CreateSurface(m_display, m_config, &m_surface))
+  {
+    CLog::Log(LOGNOTICE, "%s: Could not create a surface. Trying with a fresh Native Window.",__FUNCTION__);
+    m_egl->DestroyNativeWindow();
+    if (!m_egl->CreateNativeWindow())
+    {
+      CLog::Log(LOGERROR, "%s: Could not get native window",__FUNCTION__);
+      return false;
+    }
+
+    if (!m_egl->CreateSurface(m_display, m_config, &m_surface))
+    {
+      CLog::Log(LOGERROR, "%s: Could not create surface",__FUNCTION__);
+      return false;
+    }
+  }
+
+  int width = 0, height = 0;
+  if (!m_egl->GetSurfaceSize(m_display, m_surface, &width, &height))
+  {
+    CLog::Log(LOGERROR, "%s: Surface is invalid",__FUNCTION__);
+    return false;
+  }
+  CLog::Log(LOGDEBUG, "%s: Created surface of size %ix%i",__FUNCTION__, width, height);
+
+  EGLint contextAttrs[] =
+  {
+    EGL_CONTEXT_CLIENT_VERSION, 2,
+    EGL_NONE
+  };
+
+  if (!m_egl->BindAPI(EGL_OPENGL_ES_API))
+  {
+    CLog::Log(LOGERROR, "%s: Could not bind %i api",__FUNCTION__, EGL_OPENGL_ES_API);
+    return false;
+  }
+
+  if (m_context == EGL_NO_CONTEXT)
+  {
+    if (!m_egl->CreateContext(m_display, m_config, contextAttrs, &m_context))
+    {
+      CLog::Log(LOGERROR, "%s: Could not create context",__FUNCTION__);
+      return false;
+    }
+  }
+
+  if (!m_egl->BindContext(m_display, m_surface, m_context))
+  {
+    CLog::Log(LOGERROR, "%s: Could not bind to context",__FUNCTION__);
+    return false;
+  }
+
+
+  // for the non-trivial dirty region modes, we need the EGL buffer to be preserved across updates
+  int guiAlgorithmDirtyRegions = CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_guiAlgorithmDirtyRegions;
+  if (guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_COST_REDUCTION ||
+      guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_UNION)
+  {
+    if (!m_egl->SurfaceAttrib(m_display, m_surface, EGL_SWAP_BEHAVIOR, EGL_BUFFER_PRESERVED))
+      CLog::Log(LOGDEBUG, "%s: Could not set EGL_SWAP_BEHAVIOR",__FUNCTION__);
+  }
+
+  m_bWindowCreated = true;
+
+  return true;
+}
+
+
+bool CWinSystemstb::DestroyWindow()
+{
+  if (!m_egl)
+    return false;
+
+  m_egl->ReleaseContext(m_display);
+  if (m_surface != EGL_NO_SURFACE)
+    m_egl->DestroySurface(m_surface, m_display);
+
+  int quirks;
+  m_egl->GetQuirks(&quirks);
+  if (quirks & EGL_QUIRK_DESTROY_NATIVE_WINDOW_WITH_SURFACE)
+    m_egl->DestroyNativeWindow();
+
+  m_surface = EGL_NO_SURFACE;
+  m_bWindowCreated = false;
+  return true;
+}
+
+void CWinSystemstb::UpdateResolutions()
+{
+  CWinSystemBase::UpdateResolutions();
+
+  RESOLUTION_INFO resDesktop, curDisplay;
+  std::vector<RESOLUTION_INFO> resolutions;
+
+  if (!m_egl->ProbeResolutions(resolutions) || resolutions.empty())
+  {
+    CLog::Log(LOGWARNING, "%s: ProbeResolutions failed. Trying safe default.",__FUNCTION__);
+
+    RESOLUTION_INFO fallback;
+    if (m_egl->GetPreferredResolution(&fallback))
+    {
+      resolutions.push_back(fallback);
+    }
+    else
+    {
+      CLog::Log(LOGERROR, "%s: Fatal Error, GetPreferredResolution failed",__FUNCTION__);
+      return;
+    }
+  }
+
+  /* ProbeResolutions includes already all resolutions.
+   * Only get desktop resolution so we can replace xbmc's desktop res
+   */
+  if (m_egl->GetNativeResolution(&curDisplay))
+    resDesktop = curDisplay;
+
+  RESOLUTION ResDesktop = RES_INVALID;
+  RESOLUTION res_index  = RES_DESKTOP;
+
+  for (size_t i = 0; i < resolutions.size(); i++)
+  {
+    // if this is a new setting,
+    // create a new empty setting to fill in.
+    if ((int)CDisplaySettings::GetInstance().ResolutionInfoSize() <= res_index)
+    {
+      RESOLUTION_INFO res;
+      CDisplaySettings::GetInstance().AddResolutionInfo(res);
+    }
+
+    CServiceBroker::GetWinSystem()->GetGfxContext().ResetOverscan(resolutions[i]);
+    CDisplaySettings::GetInstance().GetResolutionInfo(res_index) = resolutions[i];
+
+ /*   CLog::Log(LOGNOTICE, "Found resolution %d x %d for display %d with %d x %d%s @ %f Hz\n",
+      resolutions[i].iWidth,
+      resolutions[i].iHeight,
+      resolutions[i].iScreenWidth,
+      resolutions[i].iScreenHeight,
+      resolutions[i].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "",
+      resolutions[i].fRefreshRate);*/
+
+    if(resDesktop.iWidth == resolutions[i].iWidth &&
+       resDesktop.iHeight == resolutions[i].iHeight &&
+       resDesktop.iScreenWidth == resolutions[i].iScreenWidth &&
+       resDesktop.iScreenHeight == resolutions[i].iScreenHeight &&
+       (resDesktop.dwFlags & D3DPRESENTFLAG_MODEMASK) == (resolutions[i].dwFlags & D3DPRESENTFLAG_MODEMASK) &&
+       fabs(resDesktop.fRefreshRate - resolutions[i].fRefreshRate) < FLT_EPSILON)
+    {
+      ResDesktop = res_index;
+    }
+
+    res_index = (RESOLUTION)((int)res_index + 1);
+  }
+
+  // swap desktop index for desktop res if available
+  if (ResDesktop != RES_INVALID)
+  {
+    CLog::Log(LOGNOTICE, "Found (%dx%d%s@%f) at %d, setting to RES_DESKTOP at %d",
+      resDesktop.iWidth, resDesktop.iHeight,
+      resDesktop.dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "",
+      resDesktop.fRefreshRate,
+      (int)ResDesktop, (int)RES_DESKTOP);
+
+    RESOLUTION_INFO desktop = CDisplaySettings::GetInstance().GetResolutionInfo(RES_DESKTOP);
+    CDisplaySettings::GetInstance().GetResolutionInfo(RES_DESKTOP) = CDisplaySettings::GetInstance().GetResolutionInfo(ResDesktop);
+    CDisplaySettings::GetInstance().GetResolutionInfo(ResDesktop) = desktop;
+  }
+}
+
+bool CWinSystemstb::Hide()
+{
+  return m_egl->ShowWindow(false);
+}
+
+bool CWinSystemstb::Show(bool raise)
+{
+  return m_egl->ShowWindow(true);
+}
+
+void CWinSystemstb::SetVisible(bool visible)
+{
+  if (visible)
+	Show();
+  else
+	Hide();
+}
+
+void CWinSystemstb::Register(IDispResource *resource)
+{
+  CSingleLock lock(m_resourceSection);
+  m_resources.push_back(resource);
+}
+
+void CWinSystemstb::Unregister(IDispResource *resource)
+{
+  CSingleLock lock(m_resourceSection);
+  std::vector<IDispResource*>::iterator i = find(m_resources.begin(), m_resources.end(), resource);
+  if (i != m_resources.end())
+    m_resources.erase(i);
+}
+
+bool CWinSystemstb::SetVSyncImpl(bool enable)
+{
+  //m_bVSync = enable;
+  bool resp = true;
+  if (!m_egl->SetVSync(m_display, enable))
+  {
+    //m_bVSync = 0;
+    resp = false;
+    CLog::Log(LOGERROR, "%s,Could not set egl vsync", __FUNCTION__);
+  }
+#ifdef HAS_IMXVPU
+  g_IMXContext.SetVSync(enable);
+#endif
+  return resp;
+}
+
+void CWinSystemstb::PresentRenderImpl(bool rendered)
+{
+  if (m_delayDispReset && m_dispResetTimer.IsTimePast())
+  {
+    m_delayDispReset = false;
+    CSingleLock lock(m_resourceSection);
+    // tell any shared resources
+    for (std::vector<IDispResource *>::iterator i = m_resources.begin(); i != m_resources.end(); ++i)
+      (*i)->OnResetDisplay();
+  }
+  if (!rendered)
+    return;
+  m_egl->SwapBuffers(m_display, m_surface);
+}
+
+EGLDisplay CWinSystemstb::GetEGLDisplay()
+{
+  return m_display;
+}
+
+EGLContext CWinSystemstb::GetEGLContext()
+{
+  return m_context;
+}
+
+EGLConfig CWinSystemstb::GetEGLConfig()
+{
+  return m_config;
+}
+
+bool CWinSystemstb::MessagePump()
+{
+  return m_winEvents->MessagePump();
+}
+
diff --git a/xbmc/windowing/egl/WinSystemstb.h b/xbmc/windowing/egl/WinSystemstb.h
new file mode 100644
index 0000000..2ed66ba
--- /dev/null
+++ b/xbmc/windowing/egl/WinSystemstb.h
@@ -0,0 +1,79 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "rendering/gles/RenderSystemGLES.h"
+#include "threads/CriticalSection.h"
+#include "threads/SystemClock.h"
+#include "windowing/WinSystem.h"
+
+#include "platform/linux/OptionalsReg.h"
+#include "platform/linux/input/LibInputHandler.h"
+
+#include "cores/AudioEngine/Engines/ActiveAE/ActiveAE.h"
+
+#include <EGL/egl.h>
+#include "utils/EGLUtils.h"
+
+class CEGLWrapper;
+class IDispResource;
+
+class CWinSystemstb : public CWinSystemBase
+{
+public:
+  CWinSystemstb();
+  virtual ~CWinSystemstb();
+
+  bool InitWindowSystem() override;
+  bool DestroyWindowSystem() override;
+
+  bool CreateNewWindow(const std::string& name,
+                       bool fullScreen,
+                       RESOLUTION_INFO& res) override;
+
+  bool CreateWindow(RESOLUTION_INFO &res);
+  bool DestroyWindow() override;
+  void UpdateResolutions() override;
+
+  bool Hide() override;
+  bool Show(bool raise = true) override;
+  void SetVisible(bool visible);
+  virtual void Register(IDispResource *resource);
+  virtual void Unregister(IDispResource *resource);
+  EGLDisplay GetEGLDisplay();
+  EGLSurface GetEGLSurface();
+  EGLContext GetEGLContext();
+  EGLConfig  GetEGLConfig();
+
+  // winevents override
+  bool MessagePump() override;
+
+protected:
+  bool SetVSyncImpl(bool enable);
+  void PresentRenderImpl(bool rendered);
+  CEGLWrapper           *m_egl;
+  EGLDisplay            m_display;
+  EGLSurface            m_surface;
+  EGLContext            m_context;
+  EGLConfig             m_config;
+  RENDER_STEREO_MODE    m_stereo_mode;
+
+  std::string           m_extensions;
+
+  int m_displayWidth;
+  int m_displayHeight;
+
+  bool m_delayDispReset;
+  XbmcThreads::EndTime m_dispResetTimer;
+
+  CCriticalSection m_resourceSection;
+  std::vector<IDispResource*> m_resources;
+  std::unique_ptr<OPTIONALS::CLircContainer, OPTIONALS::delete_CLircContainer> m_lirc;
+  std::unique_ptr<CLibInputHandler> m_libinput;
+};

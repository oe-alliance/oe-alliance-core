diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/configure.in DirectFB-1.4.12+STM2011.09.27/configure.in
--- DirectFB/configure.in	2015-06-02 22:42:22.715792371 +0200
+++ DirectFB-1.4.12+STM2011.09.27/configure.in	2012-06-06 18:41:31.000000000 +0200
@@ -533,16 +533,20 @@
 
 AC_SUBST(DEP_VOODOO)
 
-dnl If we're not building a pure voodoo lib, we need the sqrt symbol
-dnl for src/media/idirectfbfont.c
-MEDIALIB=""
+dnl If we're not building a pure voodoo lib, we need sqrt sin cos for
+dnl various files
+LIBM=""
 if test "$enable_pure_voodoo" = "no"; then
-  AC_CHECK_LIB(m, sqrt,
-    MEDIALIB="-lm",
-    AC_MSG_ERROR([
-*** DirectFB requires libm.]))
+    safe_LIBS=$LIBS
+    AC_SEARCH_LIBS([sqrt], [m], [LIBM=$ac_cv_search_sqrt], [LIBM=no], [])
+    LIBS=$safe_LIBS
+    if test "$LIBM" = "none required" ; then
+        LIBM=""
+    elif test "$LIBM" = "no" ; then
+        AC_MSG_ERROR([*** DirectFB requires libm.])
+    fi
 fi
-AC_SUBST(MEDIALIB)
+AC_SUBST(LIBM)
 
 AM_CONDITIONAL(ENABLE_MULTI, test "$enable_multi" = "yes")
 
@@ -654,6 +658,30 @@
 
 
 
+dnl Test for STMicroelectronics frame buffer system
+AC_ARG_ENABLE(stmfbdev,
+              AC_HELP_STRING([--enable-stmfbdev],
+                             [build with STMicroelectronics stmfb system support @<:@default=auto@:>@]),
+              [], [enable_stmfbdev=yes])
+
+if test "$have_linux" = "no"; then
+  enable_stmfbdev=no
+  AC_MSG_WARN([
+*** no linux kernel -- building without STMicroelectronics stmfb system support.])
+fi
+
+if test "$enable_stmfbdev" = "yes"; then
+  AC_CHECK_HEADER([linux/stmfb.h], [enable_stmfbdev=yes], [enable_stmfbdev=no],
+		  [[#include <linux/fb.h>]])
+  if test "$enable_stmfbdev" = "yes"; then
+    AC_DEFINE(LINUX_INPUT_USE_STMFBDEV,1,[Define to 1 if Linux Input driver should use stmfbdev system module for console keymap queries.])
+  fi
+fi
+
+AM_CONDITIONAL(STMFBDEV_CORE, test "$enable_stmfbdev" = "yes")
+
+
+
 dnl Test for SDL
 AC_ARG_ENABLE(sdl,
               AC_HELP_STRING([--enable-sdl],
@@ -728,14 +756,74 @@
 AC_SUBST(SYSFS_LIBS)
 
 
+dnl test for MME
+MME=no
+mme_own_headers=no
+mme_own_transformers=no
+AC_ARG_ENABLE(mme,
+              AC_HELP_STRING([--enable-mme],
+			     [build with MME support @<:@default=yes@:>@]),
+              [], [enable_mme=yes])
+if test "$enable_mme" = "yes" ; then
+    MME=yes
+    AC_DEFINE(USE_MME, 1, [Define to 1 if MME should be used])
+
+    dnl use our own copy of mme.h and try to dlopen() libmme.so
+    AC_MSG_WARN([*** MME library not found. Will use dlopen().])
+    AC_DEFINE(MME_USE_DLOPEN, 1, [Define to 1 if dlopen() etc should be used for MME libraries])
+    LIBMME=
+
+    AC_CHECK_HEADER([mme.h], [mme_ok="yes"], [mme_ok="no"])
+    if test "$mme_ok" != "yes"; then
+        AC_MSG_WARN([*** MME header files not found. Will use own copy!])
+        AC_DEFINE(MME_USE_OWN_HEADERS, 1, [Define to 1 if builtin MME headers should be used])
+        mme_own_headers=yes
+    fi
+    AC_CHECK_HEADERS([JPEG_TransformerTypes.h JPEGDECHW_VideoTransformerTypes.h PNGDecode_interface.h RLEDecode_interface.h],
+		     [mme_ok="yes"], [mme_ok="no"])
+    if test "$mme_ok" != "yes"; then
+        AC_MSG_WARN([*** MME Transformer header files not found. Will use own copies!])
+        mme_own_transformers=yes
+    fi
+else
+    MME=no
+fi
+
+AM_CONDITIONAL(MME_USE_OWN_HEADERS, test "$mme_own_headers" = "yes")
+AM_CONDITIONAL(MME_USE_OWN_TRANSFORMERS, test "$mme_own_transformers" = "yes")
+AC_SUBST(LIBMME)
+
+
+dnl Test for RLE
+RLE=no
+RLE_HW=no
+AC_ARG_ENABLE(rle,
+              AC_HELP_STRING([--enable-rle],
+	                     [build RLE image provider @<:@default=yes@:>@]),
+              [], [enable_rle=yes])
+if test "$enable_rle" = "yes" ; then
+  RLE=yes
+  if test "$MME" = "yes" ; then
+    AC_DEFINE(RLE_PROVIDER_USE_MME, 1, [Define to 1 if RLE provider should use MME, too])
+    RLE_LIBMME=$LIBMME
+  fi
+fi
+AM_CONDITIONAL(RLE_PROVIDER, test "$RLE" = "yes")
+AC_SUBST(RLE_LIBMME)
+
 
 dnl Test for libjpeg
 JPEG=no
+JPEG_HW=no
 
 AC_ARG_ENABLE(jpeg,
               AC_HELP_STRING([--enable-jpeg],
                              [build JPEG image provider @<:@default=yes@:>@]),
               [], [enable_jpeg=yes])
+AC_ARG_ENABLE(hwjpeg,
+              AC_HELP_STRING([--enable-hwjpeg],
+                             [add hardware acceleration to JPEG image provider @<:@default=yes@:>@]),
+              [], [enable_hwjpeg=yes])
 
 if test "$enable_jpeg" = "yes"; then
   if test -z "$LIBJPEG"; then
@@ -764,11 +852,32 @@
   fi
 fi
 
+if test "$enable_hwjpeg" != "no"; then
+  if test "$JPEG" = "yes"; then
+    if test "$MME" = "yes" ; then
+      AC_DEFINE(JPEG_PROVIDER_USE_MME, 1, [Define to 1 to enable hardware JPEG decoder])
+      JPEG_HW=yes
+      JPEG_LIBMME=$LIBMME
+    else
+      AC_MSG_WARN([*** MME not found. Hardware JPEG image provider will not be built.])
+      JPEG_HW=no
+    fi
+  else
+    AC_MSG_WARN([*** JPEG decoding not enabled. Hardware JPEG image provider can not be built.])
+    JPEG_HW=no
+  fi
+else
+  JPEG_HW=no
+fi
+
 AM_CONDITIONAL(JPEG_PROVIDER, test "$JPEG" = "yes")
+AM_CONDITIONAL(JPEG_PROVIDER_HW, test "$JPEG_HW" = "yes")
 
-if test "$enable_jpeg" != "no" && test "$JPEG" != "yes"; then
-  jpeg_warning="
+if test "$JPEG" != "yes"; then
+  if test "$enable_jpeg" != "no" || test "$enable_hwjpeg" != "no" ; then
+    jpeg_warning="
 JPEG support is missing - many applications won't work correctly!"
+  fi
 fi
 
 
@@ -802,22 +911,49 @@
 
 dnl Test for libpng
 PNG=no
+PNG_HW=no
 
 AC_ARG_ENABLE(png,
               AC_HELP_STRING([--enable-png],
                              [build PNG image provider, @<:@default=yes@:>@]),
               [], [enable_png=yes])
+AC_ARG_ENABLE(hwpng,
+              AC_HELP_STRING([--enable-hwpng],
+	                     [add hardware acceleration to PNG image provider @<:@default=yes@:>@]),
+              [], enable_hwpng="yes")
+
 if test "$enable_png" = "yes"; then
   PKG_CHECK_MODULES([LIBPNG], [libpng >= 1.2.2], [PNG=yes], [PNG=no
     AC_MSG_WARN([*** PNG library not found. PNG image provider will not be built.])])
 fi
 
+if test "$enable_hwpng" != "no"; then
+  if test "$PNG" = "yes" ; then
+    if test "$MME" = "yes"; then
+      AC_DEFINE(PNG_PROVIDER_USE_MME, 1, [Define to 1 to enable hardware PNG decoder])
+      PNG_HW=yes
+      PNG_LIBMME=$LIBMME
+    else
+      AC_MSG_WARN([*** MME not found. Hardware PNG image provider will not be built.])
+      PNG_HW=no
+    fi
+  else
+    AC_MSG_WARN([*** PNG decoding not enabled. Hardware PNG image provider can not be built.])
+    PNG_HW=no
+  fi
+else
+  PNG_HW=no
+fi
+
 AM_CONDITIONAL(PNG_PROVIDER, test "$PNG" = "yes")
+AM_CONDITIONAL(PNG_PROVIDER_HW, test "$PNG_HW" = "yes")
 AM_CONDITIONAL(BUILD_DIRECTFB_CSOURCE, test "$PNG" = "yes")
 
-if test "$enable_png" != "no" && test "$PNG" != "yes"; then
-  png_warning="
+if test "$PNG" != "yes"; then
+  if test "$enable_png" != "no" || "$enable_hwpng" != "no" ; then
+    png_warning="
 PNG support is missing - many applications won't work correctly!"
+  fi
 fi
 
 
@@ -918,6 +1054,7 @@
 savage=no
 sh772x=no
 sis315=no
+stgfx=no
 tdfx=no
 unichrome=no
 vmware=no
@@ -932,7 +1069,7 @@
                            [drivers), none (builds none), ati128, cle266,]
                            [cyber5k, davinci, ep9x, gl, i810, i830, mach64,]
                            [matrox, neomagic, nsc, nvidia, omap, pxa3xx,]
-                           [radeon, savage, sh772x, sis315, tdfx, unichrome,]
+                           [radeon, savage, sh772x, sis315, stgfx, tdfx, unichrome,]
                            [vmware. @<:@default=all@:>@]),
             [gfxdrivers="$withval"], [gfxdrivers=all])
 if test "$gfxdrivers" = "all"; then
@@ -955,6 +1092,7 @@
   checkfor_savage=yes
   checkfor_sh772x=yes
   checkfor_sis315=yes
+  checkfor_stgfx=yes
   checkfor_tdfx=yes
   checkfor_unichrome=yes
   checkfor_vmware=yes
@@ -1023,6 +1161,9 @@
           sis315)
                   checkfor_sis315=yes
                   ;;
+          stgfx)
+                  checkfor_stgfx=yes
+                  ;;
           tdfx)
                   checkfor_tdfx=yes
                   ;;
@@ -1129,6 +1270,11 @@
   sis315=yes
 fi
 
+if test "$checkfor_stgfx" = "yes"; then
+  AC_CHECK_HEADER([linux/stmfb.h], [stgfx=yes], [stgfx=no],
+		  [[#include <linux/fb.h>]])
+fi
+
 if test "$checkfor_tdfx" = "yes"; then
   tdfx=yes
 fi
@@ -1579,6 +1725,7 @@
 AM_CONDITIONAL(GFX_SAVAGE, test "$savage" = "yes")
 AM_CONDITIONAL(GFX_SH772X, test "$sh772x" = "yes")
 AM_CONDITIONAL(GFX_SIS315, test "$sis315" = "yes")
+AM_CONDITIONAL(GFX_STGFX, test "$stgfx" = "yes")
 AM_CONDITIONAL(GFX_TDFX, test "$tdfx" = "yes")
 AM_CONDITIONAL(GFX_UNICHROME, test "$unichrome" = "yes")
 AM_CONDITIONAL(GFX_VMWARE, test "$vmware" = "yes")
@@ -1650,9 +1797,12 @@
 AC_SUBST(GIF_PROVIDER)
 AC_SUBST(JPEG_PROVIDER)
 AC_SUBST(LIBJPEG)
+AC_SUBST(JPEG_LIBMME)
 AC_SUBST(PNG_PROVIDER)
 AC_SUBST(LIBPNG_CFLAGS)
 AC_SUBST(LIBPNG_LIBS)
+AC_SUBST(PNG_LIBMME)
+AC_SUBST(RLE_PROVIDER)
 AC_SUBST(FREETYPE_PROVIDER)
 AC_SUBST(FREETYPE_CFLAGS)
 AC_SUBST(FREETYPE_LIBS)
@@ -1721,6 +1871,7 @@
 systems/osx/Makefile
 systems/sdl/Makefile
 systems/vnc/Makefile
+systems/stmfbdev/Makefile
 
 wm/Makefile
 wm/default/Makefile
@@ -1750,6 +1901,8 @@
 gfxdrivers/savage/Makefile
 gfxdrivers/sh772x/Makefile
 gfxdrivers/sis315/Makefile
+gfxdrivers/stgfx/Makefile
+gfxdrivers/stgfx2/Makefile
 gfxdrivers/tdfx/Makefile
 gfxdrivers/unichrome/Makefile
 gfxdrivers/vmware/Makefile
@@ -1844,6 +1997,7 @@
   OSX support               $enable_osx                 $OSX_CFLAGS $OSX_LIBS
   SDL support               $enable_sdl                 $SDL_CFLAGS $SDL_LIBS
   VNC support               $enable_vnc                 $VNC_CFLAGS $VNC_LIBS
+  STM stmfb support         $enable_stmfbdev
 
 Building Window Manager Modules:
   Default                   yes
@@ -1852,7 +2006,11 @@
 Building Image Provider Modules:
   GIF                       $enable_gif 
   JPEG                      $JPEG                 $LIBJPEG
+    - hardware              $JPEG_HW                 $JPEG_LIBMME
   PNG                       $PNG                 $LIBPNG_CFLAGS $LIBPNG_LIBS
+    - hardware              $PNG_HW                 $PNG_LIBMME
+  RLE                       $RLE                 $RLE_LIBMME
+    - hardware              $RLE_HW
 
 Building Video Provider Modules:
   GIF                       $enable_gif
@@ -1881,6 +2039,7 @@
   Renesas SH7722/SH7723     $sh772x
   S3 Savage                 $savage
   SiS 315                   $sis315
+  STM Gamma/BDispII         $stgfx
   TI Davinci                $davinci
   TI OMAP                   $omap
   TVIA CyberPro             $cyber5k
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/data/Makefile.am DirectFB-1.4.12+STM2011.09.27/data/Makefile.am
--- DirectFB/data/Makefile.am	2015-06-02 22:42:22.715792371 +0200
+++ DirectFB-1.4.12+STM2011.09.27/data/Makefile.am	2012-06-06 18:41:31.000000000 +0200
@@ -5,3 +5,10 @@
 miscdata_DATA = cursor.dat
 
 EXTRA_DIST = $(miscdata_DATA)
+
+noinst_MISCDATA = \
+	directfb.rle	\
+	directfb.png	\
+	directfb.bmp	\
+	BD-RLE8.tar.gz	\
+	README
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/directfb.pc.in DirectFB-1.4.12+STM2011.09.27/directfb.pc.in
--- DirectFB/directfb.pc.in	2015-06-02 22:42:22.715792371 +0200
+++ DirectFB-1.4.12+STM2011.09.27/directfb.pc.in	2012-06-06 18:41:31.000000000 +0200
@@ -8,5 +8,5 @@
 Version: @VERSION@
 Requires: @DEP_VOODOO@ fusion direct
 Libs: -L${libdir} -ldirectfb @THREADLIB@ @OSX_LIBS@
-Libs.private: -L${libdir} @MEDIALIB@ @DYNLIB@ @ZLIB_LIBS@
+Libs.private: -L${libdir} @LIBM@ @DYNLIB@ @ZLIB_LIBS@
 Cflags: @THREADFLAGS@ -I@INCLUDEDIR@
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/docs/Makefile.am DirectFB-1.4.12+STM2011.09.27/docs/Makefile.am
--- DirectFB/docs/Makefile.am	2015-06-02 22:40:08.103538106 +0200
+++ DirectFB-1.4.12+STM2011.09.27/docs/Makefile.am	2012-06-06 18:41:31.000000000 +0200
@@ -34,6 +34,8 @@
 
 
 EXTRA_DIST = \
+	DirectFB_Extensions_RLE_Image_Provider_Specs_and_Report.pdf \
+	README.rle		\
 	README.screenshots	\
 	dfbg.1.in		\
 	directfbrc.5.in		\
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/docs/README.rle DirectFB-1.4.12+STM2011.09.27/docs/README.rle
--- DirectFB/docs/README.rle	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/docs/README.rle	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,371 @@
+--------------------------------------------------------------------------------
+                            RLE Image Provider
+--------------------------------------------------------------------------------
+
+Support for RLE image format.
+
+
+
+*** CURRENT RLE IMAGE PROVIDER SPECIFICATIONS ***
+
+--------------------------------------------------------------------------------
+[A] Supported payload formats:
+
+  [1] Compressed:   [RLEIC_RLE8]
+
+  * RLE8      8 bits LUT-indexed / run-length-compressed / block mode
+
+  * BD-RLE8   8 bits LUT-indexed / run-length-compressed / block mode
+
+  [2] Uncompressed: [RLEIC_NONE] / backward compatibility
+
+  * Uncompressed 1/2/4/8 bits LUT-indexed / row mode
+
+  * Uncompressed 16/24 bits fixed RGB bit-field components / row mode
+
+
+  NB:  Single plane picture only
+       Provisions for extensions / RLE formats variants
+--------------------------------------------------------------------------------
+
+--------------------------------------------------------------------------------
+[B] Supported source buffer structure:
+
+  * Header : 54 bytes  (unoptimized - byte-packed, BMP standard layout)
+
+  * Palette: indexed RGB24 - (3x8 bits + 1x8 bits) x max_colors (2-256)
+
+  * Payload: encapsulated within packet at given offset location
+
+
+  NB:  Provisions for static memory/file access or streaming modes
+--------------------------------------------------------------------------------
+
+--------------------------------------------------------------------------------
+[C] Supported output surface:
+
+  * ARGB 32 surface - Opaque alpha channel (set to 0xff)
+
+  * LUT8 indexed support provision
+--------------------------------------------------------------------------------
+
+--------------------------------------------------------------------------------
+[D] Supported Image-Provider modes:
+
+  * Direct memory static DFB buffer
+
+  * Standard File loader
+
+  * No hardware acceleration
+
+  * Non optimized software fall-back only
+
+  NB:  Provisions for DFB streaming mode
+       Provisions for future hardware acceleration
+--------------------------------------------------------------------------------
+
+--------------------------------------------------------------------------------
+[E] Packaging:
+
+  * Ships with unit-test code
+    [1]  Unit-test (DirectFB sample code) :
+         Brief application source code showing how to use a DFB static memory
+         buffer issued Image-Provider instance in order to render the RLE
+         object stored in memory to some surface
+         - Packet build helper function provided (see rle_build_packet.c).
+
+--------------------------------------------------------------------------------
+
+--------------------------------------------------------------------------------
+[F] Standard Compliance:
+
+- Little Endian / byte alignment
+
+- BMP-Compliant - BMP packet/file header (see enclosed specs below)
+
+- RLE-8  - Run-Lenght RLE-8 decoder - Top or Bottom first (see enclosed specs)
+--------------------------------------------------------------------------------
+
+
+--------------------------------------------------------------------------------
+[G] Lisensing:
+
+- Released under the terms of the GNU General Public License version 2
+
+  NB:  Until further notice (TBD)
+
+--------------------------------------------------------------------------------
+
+
+================================================================================
+
+    ANNEX A    -    RLE-8 Specifications    (RLE-8 Payload data)
+
+================================================================================
+RLE-8 bitmaps are compressed by using a run-length encoding (rle) format for an
+8-bit bitmap. this format can be compressed in encoded or absolute modes. both
+modes can occur anywhere in the same bitmap.
+--------------------------------------------------------------------------------
+    * encoded mode consists of two bytes:
+
+        The first byte specifies the number of consecutive pixels to be drawn
+        using the color index contained in the second byte. in addition, the
+        first byte of the pair can be set to zero to indicate an escape that
+        denotes an end of line, end of bitmap, or delta. the interpretation
+        of the escape depends on the value of the second byte of the pair,
+        which can be one of the following:
+
+            0        end of line.
+
+            1        end of bitmap.
+
+            2        delta. the two bytes following the escape contain unsigned
+                    values indicating the horizontal and vertical offsets of the
+                    next pixel from the current position.
+--------------------------------------------------------------------------------
+    * absolute mode.
+
+        The first byte is zero and the second byte is a value in the range 03h
+        through ffh. the second byte represents the number of bytes that follow,
+        each of which contains the color index of a single pixel. when the
+        second byte is 2 or less, the escape has the same meaning as in encoded
+        mode. in absolute mode, each run must be aligned on a word boundary.
+--------------------------------------------------------------------------------
+    The following example shows the hexadecimal values of an 8-bit compressed
+    bitmap:
+
+        03 04 05 06 00 03 45 56 67 00 02 78 00 02 05 01 02 78 00 00 09 1e 00 01
+
+    This bitmap would expand as follows (two-digit values represent a color
+    index for a single pixel):
+        04 04 04
+        06 06 06 06 06
+        45 56 67
+        78 78
+
+    Move current position 5 right and 1 down
+        78 78
+
+    End of line
+        1e 1e 1e 1e 1e 1e 1e 1e 1e
+
+    End of rle bitmap
+================================================================================
+
+
+
+
+================================================================================
+
+    ANNEX B    -    PACKET/FILE FORMAT: (BMP specifications except identifier)
+
+================================================================================
+offset        field               size        contents
+================================================================================
+0000h       identifier             2 bytes  the signature identifying the bitmap.
+                                            Possible entries :  'BM' or 'RL'
+--------------------------------------------------------------------------------
+0002h        file/packet size      1 dword  complete file/packet size in bytes.
+--------------------------------------------------------------------------------
+0006h        reserved              1 dword  reserved for later use.
+--------------------------------------------------------------------------------
+000ah        bitmap data offset    1 dword  offset from beginning of file/packet
+                                            to the beginning of the bitmap data.
+--------------------------------------------------------------------------------
+000eh        bitmap header size    1 dword  length of the bitmap info header
+                                            used to describe the bitmap colors,
+                                            compression;
+                                            the following sizes are possible:
+                                             40 = 28h - Default
+                                             12 = 0ch - UNSUPPORTED
+                                            240 = f0h - UNSUPPORTED
+--------------------------------------------------------------------------------
+0012h        width                 1 dword  horizontal width of bitmap in pixels.
+0016h        height                1 dword  vertical height of bitmap in pixels.
+001ah        planes                1 word   number of planes in this bitmap.
+001ch        bits per pixel        1 word   bits per pixel used to store palette
+                                            entry information. this also
+                                            identifies in an indirect way the
+                                            number of possible colors.
+                                            possible values are:
+                                              1 - monochrome bitmap
+                                              4 - 16 color bitmap
+                                              8 - 256 color bitmap
+                                             16 - 16bit (high color) bitmap
+                                             24 - 24bit (true color) bitmap
+                                             32 - 32bit (true color) bitmap
+--------------------------------------------------------------------------------
+001eh        compression           1 dword  compression specifications.
+                                            the following values are possible:
+                                            0 - none       (ID: bi_rgb)
+                                            1 - rle 8-bit (bi_rle8)
+                                            2 - rle 4-bit (bi_rle4)  UNSUPPORTED
+                                            3 - fields (bi_bitfield) UNSUPPORTED
+--------------------------------------------------------------------------------
+0022h        bitmap data size      1 dword  size of the bitmap data in bytes.
+                                            this number must be rounded to the
+                                            next 4 byte boundary.
+--------------------------------------------------------------------------------
+0026h        hresolution           1 dword  horizontal resolution expressed in
+                                            pixel per meter.         UNSUPPORTED
+--------------------------------------------------------------------------------
+002ah        vresolution           1 dword  vertical resolution expressed in
+                                            pixels per meter.        UNSUPPORTED
+--------------------------------------------------------------------------------
+002eh        colors                1 dword  number of colors used by this bitmap.
+                                            for a 8-bit / pixel bitmap this will
+                                            be 100h or 256.
+--------------------------------------------------------------------------------
+0032h        important colors      1 dword  number of important colors. this
+                                            number will be equal to the number
+                                            of colors when any color is important.
+--------------------------------------------------------------------------------
+0036h        palette            n * 4 byte  colormap specification. for every
+                                            entry in the palette four bytes are
+                                            used to describe the rgb values of
+                                            the color in the following way:
+                                                1 byte for blue  component
+                                                1 byte for green component
+                                                1 byte for red   component
+                                                1 byte filler which is set to 0
+--------------------------------------------------------------------------------
+0436h        bitmap data           x bytes  depending on the compression specs,
+                                            this field contains all the bitmap
+                                            data bytes which represent indexes
+                                            in the color palette for indexed
+                                            formats.
+================================================================================
+
+
+
+
+================================================================================
+
+    ANNEX C    -    PACKET/FILE FORMAT: FIELDS DETAILS
+
+================================================================================
+
+height field:
+
+    the height field identifies the height of the bitmap in pixels. in other
+    words, it describes the number of scan lines of the bitmap. if this field
+    is negative, indicating a top-down dib, the compression field must be either
+    bi_rgb or bi_bitfields. top-down dibs cannot be compressed.
+
+bits per pixel field:
+
+    the bits per pixel (bbp) field of the bitmap file determines the number of
+    bits that define each pixel and the maximum number of colors in the bitmap.
+
+    * when this field is equal to 1.
+        the bitmap is monochrome, and the palette contains two entries. each bit
+        in the bitmap array represents a pixel. if the bit is clear, the pixel
+        is displayed with the color of the first entry in the palette; if the
+        bit is set, the pixel has the color of the second entry in the table.
+
+    * when this field is equal to 4.
+        the bitmap has a maximum of 16 colors, and the palette contains up to 16
+        entries. each pixel in the bitmap is represented by a 4-bit index into
+        the palette. for example, if the first byte in the bitmap is 1fh, the
+        byte represents two pixels. the first pixel contains the color in the
+        second palette entry, and the second pixel contains the color in the
+        sixteenth palette entry.
+
+    * when this field is equal to 8.
+        the bitmap has a maximum of 256 colors, and the palette contains up to
+        256 entries. in this case, each byte in the array represents a single
+        pixel.
+
+    * when this field is equal to 16.
+        the bitmap has a maximum of 2^16 colors. if the compression field of the
+        bitmap file is set to bi_rgb, the palette field does not contain any
+        entries. each word in the bitmap array represents a single pixel. the
+        relative intensities of red, green, and blue are represented with 5 bits
+        for each color component. the value for blue is in the least significant
+        5 bits, followed by 5 bits each for green and red, respectively. the
+        most significant bit is not used.
+
+    * when this field is equal to 24.
+        the bitmap has a maximum of 2^24 colors, and the palette field does not
+        contain any entries. each 3-byte triplet in the bitmap array represents
+        the relative intensities of blue, green, and red, respectively, for a
+        pixel.
+
+    * when this field is equal to 32.
+        the bitmap has a maximum of 2^32 colors. if the compression field of the
+        bitmap is set to bi_rgb, the palette field does not contain any entries.
+        each dword in the bitmap array represents the relative intensities of
+        blue, green, and red, respectively, for a pixel. the high byte in each
+        dword is not used.
+
+        NOTE:
+        if the compression field of the bitmap file is set to bi_bitfields, the
+        palette field contains three dword color masks that specify the red,
+        green, and blue components, respectively, of each pixel. each word in
+        the bitmap array represents a single pixel.
+
+compression field:
+
+    The compression field specifies the way the bitmap data is stored in the
+    file/packet. this information together with the bits per pixel (bpp) field
+    identifies the compression algorithm to follow.
+
+    The following values are possible in this field:
+
+    ============================================================================
+    value                meaning
+    ============================================================================
+
+    bi_rgb              An uncompressed format.
+
+    bi_rle8             A run-length encoded (rle) format for bitmaps with 8
+                        bits per pixel. the compression format is a two-byte
+                        format consisting of a count byte followed by a byte
+                        containing a color index. for more information, see the
+                        following remarks section.
+
+
+    bi_rle4             A rle format for bitmaps with 4 bits per pixel. the
+                        compression format is a two-byte format consisting of a
+        (UNSUPPORTED)   count byte followed by two word-length color indexes.
+                        for more information, see the following remarks section.
+
+
+    bi_bitfields        Specifies that the bitmap is not compressed and that the
+                        color table consists of three double word color masks
+        (UNSUPPORTED)   that specify the red, green, and blue components,
+                        respectively, of each pixel. this is valid when used
+                        with 16- and 32- bits-per-pixel bitmaps.
+                        UNSUPPORTED
+
+    ============================================================================
+
+colors field:
+
+    The colors field specifies the number of color indexes in the color table
+    that are actually used by the bitmap. if this value is zero, the bitmap uses
+    the maximum number of colors corresponding to the value of the bbp field for
+    the compression mode specified by the compression field.
+
+    if the colors field is nonzero and the bbp field less than 16, the colors
+    field specifies the actual number of colors the graphics engine or device
+    driver accesses.
+
+    if the bbp field is 16 or greater, then colors field specifies the size of
+    the color table used to optimize performance of windows color palettes.
+
+    if bbp equals 16 or 32, the optimal color palette starts immediately
+    following the three double word masks.
+
+    if the bitmap is a packed bitmap (a bitmap in which the bitmap array
+    immediately follows the bitmap header and which is referenced by a single
+    pointer), the colors field must be either 0 or the actual size of the color
+    table.
+
+important colors field:
+        (UNSUPPORTED)
+    The important colors field specifies the number of color indexes that are
+    considered important for displaying the bitmap. if this value is zero, all
+    colors are important.
+
+================================================================================
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/gfxdrivers/Makefile.am DirectFB-1.4.12+STM2011.09.27/gfxdrivers/Makefile.am
--- DirectFB/gfxdrivers/Makefile.am	2015-06-02 22:40:08.103538106 +0200
+++ DirectFB-1.4.12+STM2011.09.27/gfxdrivers/Makefile.am	2012-06-06 18:41:31.000000000 +0200
@@ -108,6 +108,12 @@
 SIS315_DIR =
 endif
 
+if GFX_STGFX
+STGFX_DIR = stgfx stgfx2
+else
+STGFX_DIR =
+endif
+
 if GFX_TDFX
 TDFX_DIR = tdfx
 else
@@ -153,6 +159,7 @@
 	$(SAVAGE_DIR)	\
 	$(SH772X_DIR)	\
 	$(SIS315_DIR)	\
+	$(STGFX_DIR)	\
 	$(TDFX_DIR)	\
 	$(UNICHROME_DIR) \
 	$(VMWARE_DIR)
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/gfxdrivers/stgfx/Makefile.am DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx/Makefile.am
--- DirectFB/gfxdrivers/stgfx/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx/Makefile.am	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,50 @@
+## Makefile.am for DirectFB/gfxdrivers/stgfx
+
+INCLUDES = \
+	-I$(top_builddir)/include \
+	-I$(top_builddir)/lib   \
+	-I$(top_srcdir)/include \
+	-I$(top_srcdir)/lib     \
+	-I$(top_srcdir)/src	\
+	-I$(top_srcdir)/systems	\
+	-I$(top_srcdir)/gfxdrivers
+
+AM_CPPFLAGS = -DSTGFX_DRIVER=1
+
+stgfx_LTLIBRARIES = libdirectfb_stgfx.la
+
+if BUILD_STATIC
+stgfx_DATA = $(stgfx_LTLIBRARIES:.la=.o)
+endif
+
+stgfxdir = $(MODULEDIR)/gfxdrivers
+
+libdirectfb_stgfx_la_SOURCES =	\
+	stgfx.c				\
+	stgfx.h				\
+	\
+	../stgfx2/stmfbdev_screen.c	\
+	../stgfx2/stmfbdev_layer.c	\
+	\
+	../stgfx2/surfacemanager.c	\
+	../stgfx2/surfacemanager.h	\
+	../stgfx2/stmfbdev_surface_pool.c	\
+	../stgfx2/bdisp_surface_pool.c	\
+	../stgfx2/bdisp_surface_pool.h	\
+	\
+	../stgfx2/stgfx_screen.c	\
+	../stgfx2/stgfx_screen.h	\
+	../stgfx2/stgfx_primary.c	\
+	../stgfx2/stgfx_primary.h
+
+libdirectfb_stgfx_la_LDFLAGS = \
+	-module			\
+	-avoid-version		\
+	$(DFB_LDFLAGS)
+
+libdirectfb_stgfx_la_LIBADD = \
+	$(top_builddir)/lib/direct/libdirect.la \
+	$(top_builddir)/src/libdirectfb.la
+
+
+include $(top_srcdir)/rules/libobject.make
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/gfxdrivers/stgfx/stgfx.c DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx/stgfx.c
--- DirectFB/gfxdrivers/stgfx/stgfx.c	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx/stgfx.c	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,1727 @@
+/*
+   (c) Copyright 2003, 2007, 2009, 2010  STMicroelectronics Ltd.
+
+   All rights reserved.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+
+#include <sys/mman.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+
+#include <linux/fb.h>
+#include <linux/stmfb.h>
+
+#include <directfb.h>
+#include <dfb_types.h>
+
+#include <core/coredefs.h>
+#include <core/coretypes.h>
+
+#include <core/core.h>
+#include <core/state.h>
+#include <core/gfxcard.h>
+#include <core/surface.h>
+#include <core/system.h>
+#include <core/palette.h>
+#include <core/layers.h>
+#include <core/screens.h>
+
+#include <fbdev/fbdev.h>
+#include <stmfbdev/stmfbdev.h>
+
+#include <gfx/convert.h>
+#include <gfx/util.h>
+
+#include <core/graphics_driver.h>
+
+#include "stgfx.h"
+#include "stgfx2/stgfx_screen.h"
+#include "stgfx2/stgfx_primary.h"
+#include "stgfx2/bdisp_surface_pool.h"
+
+DFB_GRAPHICS_DRIVER( stgfx );
+
+static const DFBSurfaceDrawingFlags STGFX_VALID_DRAWINGFLAGS_GAMMA = (
+  DSDRAW_BLEND           |
+  DSDRAW_DST_COLORKEY    |
+  DSDRAW_SRC_PREMULTIPLY);
+
+static const DFBSurfaceDrawingFlags STGFX_VALID_DRAWINGFLAGS_BDISP = (
+  DSDRAW_BLEND           |
+  DSDRAW_XOR             |
+  DSDRAW_SRC_PREMULTIPLY);
+
+static DFBSurfaceDrawingFlags STGFX_VALID_DRAWINGFLAGS;
+
+static const DFBAccelerationMask STGFX_VALID_DRAWINGFUNCTIONS = DFXL_FILLRECTANGLE |
+                                                                DFXL_DRAWRECTANGLE;
+
+static const DFBSurfaceDrawingFlags STGFX_VALID_BLITTINGFLAGS_GAMMA = (
+  DSBLIT_INDEX_TRANSLATION  |
+  DSBLIT_SRC_COLORKEY       |
+  DSBLIT_DST_COLORKEY       |
+  DSBLIT_BLEND_COLORALPHA   |
+  DSBLIT_BLEND_ALPHACHANNEL |
+  DSBLIT_SRC_PREMULTIPLY    |
+  DSBLIT_SRC_PREMULTCOLOR);
+
+static const DFBSurfaceDrawingFlags STGFX_VALID_BLITTINGFLAGS_BDISP = (
+  DSBLIT_INDEX_TRANSLATION  |
+  DSBLIT_SRC_COLORKEY       |
+  DSBLIT_BLEND_COLORALPHA   |
+  DSBLIT_BLEND_ALPHACHANNEL |
+  DSBLIT_SRC_PREMULTIPLY    |
+  DSBLIT_XOR                |
+  DSBLIT_COLORIZE           |
+  DSBLIT_SRC_PREMULTCOLOR);
+
+
+static DFBSurfaceDrawingFlags STGFX_VALID_BLITTINGFLAGS;
+
+static const DFBAccelerationMask STGFX_VALID_BLITTINGFUNCTIONS = (DFXL_BLIT | DFXL_STRETCHBLIT);
+
+static int stgfx_accel_type;
+
+static bool stgfxCheckPixelFormat(DFBSurfacePixelFormat dfbFmt, bool bSrc, bool *hasAlpha, bool *isClut);
+static unsigned long stgfxSetPixelFormat(DFBSurfacePixelFormat dfbFmt) __attribute__((pure));
+/* local typedefs */
+
+
+/*****************************************************************/
+/* Fill in the command data that is common to all draw functions */
+/*****************************************************************/
+static bool stgfxDraw
+(
+  STGFXDriverData*  pDrv,
+  STGFXDeviceData*  pDev,
+  DFBRectangle*     rect,
+  STMFBIO_BLT_DATA   *pBltData
+)
+{
+  pBltData->dstMemBase = pDev->dstMemBase;
+  pBltData->dstOffset  = pDev->dstOffset;
+  pBltData->dstPitch   = pDev->dstPitch;
+
+  pBltData->dstFormat  = pDev->dstFormat;
+
+  pBltData->dst_left   = (unsigned short)rect->x;
+  pBltData->dst_top    = (unsigned short)rect->y;
+  pBltData->dst_right  = (unsigned short)(rect->x + rect->w);
+  pBltData->dst_bottom = (unsigned short)(rect->y + rect->h);
+  pBltData->colour     = pDev->drawColour;
+
+  if (pDev->drawingFlags & DSDRAW_DST_COLORKEY)
+  {
+    pBltData->ulFlags   |= BLT_OP_FLAGS_DST_COLOR_KEY;
+    pBltData->colourKey  = pDev->dstColourKey;
+  }
+
+  if (pDev->drawingFlags & DSDRAW_BLEND)
+  {
+    if(pDev->srcBlendFunc == DSBF_ZERO && pDev->dstBlendFunc == DSBF_ZERO)
+    {
+      /*
+       * This is a clear, just fill with 0. Set the source format to the
+       * dest format to get a fast fill.
+       */
+      pBltData->colour    = 0;
+      pBltData->srcFormat = pBltData->dstFormat;
+    }
+    else if(pDev->srcBlendFunc == DSBF_ONE && pDev->dstBlendFunc == DSBF_ZERO)
+    {
+      /*
+       * This is just a src fill, but the colour is in ARGB8888 not the
+       * destination surface format. The hardware will convert for us.
+       */
+      pBltData->srcFormat = SURF_ARGB8888;
+    }
+    else if(pDev->srcBlendFunc == DSBF_ZERO && pDev->dstBlendFunc == DSBF_ONE)
+    {
+      /*
+       * This leaves the destination as is, i.e. a nop, because we do not
+       * support destination pre-multiplication.
+       */
+      return true;
+    }
+    else
+    {
+      /*
+       * This must be
+       *    (1) src func = 1.0  , dest func = 1-src alpha
+       * or (2) src func = src alpha, dest func = 1-src alpha
+       *
+       * because of the restrictions imposed in check state. We can
+       * only support (2) when the destination format has no alpha channel.
+       * This is because the hardware always calculates the destination alpha
+       * as Asrc + Adst*(1-Asrc), which is correct for (1) but for (2) we
+       * would require Asrc*Asrc + Adst*(1-Asrc).
+       */
+      pBltData->ulFlags    |= (pDev->srcBlendFunc == DSBF_SRCALPHA) ? BLT_OP_FLAGS_BLEND_SRC_ALPHA : BLT_OP_FLAGS_BLEND_SRC_ALPHA_PREMULT;
+      pBltData->ulFlags    |= BLT_OP_FLAGS_BLEND_DST_MEMORY;
+      pBltData->srcFormat   = SURF_ARGB8888;
+    }
+  }
+  else
+  {
+    if(pDev->drawingFlags & DSDRAW_XOR)
+      pBltData->ulFlags |= BLT_OP_FLAGS_XOR;
+
+    if(pBltData->dstFormat == SURF_YCBCR422R
+       || pBltData->dstFormat == SURF_ACRYCB8888
+       || pBltData->dstFormat == SURF_CRYCB888)
+    {
+      /*
+       * For 422R we let the hardware do the conversion, as direct fast fill
+       * in 422R has problems (probably due to two pixels being mixed up in a
+       * 32bit word).
+       */
+      pBltData->srcFormat = SURF_ARGB8888;
+    }
+    else
+    {
+      /*
+       * Simple fast fill, the colour is already in the destination colour format
+       */
+      pBltData->srcFormat = pBltData->dstFormat;
+    }
+  }
+
+  if (ioctl(pDrv->fd, STMFBIO_BLT, pBltData ) < 0)
+    return false;
+
+  return true;
+}
+
+/*****************************************************************/
+/* Fill in the command data that is common to all blit functions */
+/*****************************************************************/
+static bool stgfxCommonBlitData
+(
+  STGFXDriverData*  pDrv,
+  STGFXDeviceData  *pDev,
+  STMFBIO_BLT_DATA *pBltData
+)
+{
+  bool set_premultcolor = true;
+  pBltData->operation = BLT_OP_COPY;
+
+  if (pDev->blittingFlags & DSBLIT_SRC_COLORKEY)
+  {
+    pBltData->ulFlags    |= BLT_OP_FLAGS_SRC_COLOR_KEY;
+    pBltData->colourKey   = pDev->srcColourKey;
+  }
+
+  if (pDev->blittingFlags & DSBLIT_DST_COLORKEY)
+  {
+    pBltData->ulFlags   |= BLT_OP_FLAGS_DST_COLOR_KEY;
+    pBltData->colourKey  = pDev->dstColourKey;
+  }
+
+  pBltData->srcMemBase = pDev->srcMemBase;
+  pBltData->srcOffset  = pDev->srcOffset;
+  pBltData->srcPitch   = pDev->srcPitch;
+
+  pBltData->dstMemBase = pDev->dstMemBase;
+  pBltData->dstOffset  = pDev->dstOffset;
+  pBltData->dstPitch   = pDev->dstPitch;
+
+  pBltData->srcFormat = pDev->srcFormat;
+  pBltData->dstFormat = pDev->dstFormat;
+
+  pBltData->colour      = pDev->blitColour;
+  pBltData->globalAlpha = pDev->globalAlpha;
+
+  if (pDev->bBlendFromColorAlpha & !pDev->bBlendFromSrcAlpha)
+  {
+    if(pDev->srcBlendFunc == DSBF_ZERO && pDev->dstBlendFunc == DSBF_ZERO)
+    {
+      /* This is a clear, just fill with 0 */
+      pBltData->operation   = BLT_OP_FILL;
+      pBltData->colour      = 0;
+      /*
+       * Change the source format to match the dest so we get a fast fill,
+       * the other source surface parameters are ignored.
+       */
+      pBltData->srcFormat = pBltData->dstFormat;
+      set_premultcolor = false;
+    }
+    else if(pDev->srcBlendFunc == DSBF_ZERO && pDev->dstBlendFunc == DSBF_ONE)
+    {
+      /*
+       * This leaves the destination as is, i.e. a nop, because we do not
+       * support destination pre-multiplication.
+       */
+      return false;
+    }
+    else if(pDev->srcBlendFunc == DSBF_ONE && pDev->dstBlendFunc == DSBF_ZERO)
+    {
+      /*
+       * This is a copy (blend with a destination of (0,0,0,0)) after
+       * premultiplication with the colour alpha channel.
+       */
+      pBltData->ulFlags |= BLT_OP_FLAGS_GLOBAL_ALPHA | BLT_OP_FLAGS_BLEND_SRC_ALPHA | BLT_OP_FLAGS_BLEND_DST_ZERO;
+
+      if(pDev->bPremultColor && !pDev->bSrcPremultiply)
+        set_premultcolor = false;
+    }
+    else
+    {
+      /*
+       * Both of the real support blend combinations end up being the same
+       * operation.
+       */
+      pBltData->ulFlags |= BLT_OP_FLAGS_GLOBAL_ALPHA | BLT_OP_FLAGS_BLEND_SRC_ALPHA | BLT_OP_FLAGS_BLEND_DST_MEMORY;
+
+      if(pDev->bPremultColor && !pDev->bSrcPremultiply && (pDev->srcBlendFunc != DSBF_SRCALPHA))
+        set_premultcolor = false;
+    }
+  }
+  else if (pDev->bBlendFromSrcAlpha)
+  {
+    if(pDev->srcBlendFunc == DSBF_ZERO && pDev->dstBlendFunc == DSBF_ZERO)
+    {
+      /* This is a clear, just fill with 0 */
+      pBltData->operation   = BLT_OP_FILL;
+      pBltData->colour      = 0;
+      /*
+       * Change the source format to match the dest so we get a fast fill,
+       * the other source surface parameters are ignored.
+       */
+      pBltData->srcFormat = pBltData->dstFormat;
+      set_premultcolor = false;
+    }
+    else if(pDev->srcBlendFunc == DSBF_ONE && pDev->dstBlendFunc == DSBF_ZERO)
+    {
+      pBltData->ulFlags |= BLT_OP_FLAGS_BLEND_DST_ZERO;
+      pBltData->ulFlags |= pDev->bSrcPremultiply ? BLT_OP_FLAGS_BLEND_SRC_ALPHA : BLT_OP_FLAGS_BLEND_SRC_ALPHA_PREMULT;
+      if(pDev->bBlendFromColorAlpha)
+      {
+        pBltData->ulFlags |= BLT_OP_FLAGS_GLOBAL_ALPHA;
+        if(pDev->bPremultColor && !pDev->bSrcPremultiply)
+          set_premultcolor = false;
+      }
+    }
+    else if(pDev->srcBlendFunc == DSBF_ZERO && pDev->dstBlendFunc == DSBF_ONE)
+    {
+      /*
+       * This leaves the destination as is, i.e. a nop, because we do not
+       * support destination pre-multiplication.
+       */
+      return false;
+    }
+    else if(pDev->srcBlendFunc == DSBF_ONE && pDev->dstBlendFunc == DSBF_INVSRCALPHA)
+    {
+      /*
+       * The flags look the wrong way about, but they specifiy if the source
+       * is _already_ pre-multiplied or not rather than the operation required.
+       */
+      pBltData->ulFlags |= BLT_OP_FLAGS_BLEND_DST_MEMORY;
+      pBltData->ulFlags |= pDev->bSrcPremultiply ? BLT_OP_FLAGS_BLEND_SRC_ALPHA : BLT_OP_FLAGS_BLEND_SRC_ALPHA_PREMULT;
+      if(pDev->bBlendFromColorAlpha)
+      {
+        pBltData->ulFlags |= BLT_OP_FLAGS_GLOBAL_ALPHA;
+        if(pDev->bPremultColor && !pDev->bSrcPremultiply)
+          set_premultcolor = false;
+      }
+    }
+    else
+    {
+      /*
+       * Must be srcBlendFunc == DSBF_SRCALPHA, dstBlendFunc == DSBF_INVSRCALPHA,
+       * premultiply off, dest no alpha channel. Note that we use the blend flag
+       * that normally enables pre-multiplication to effectively do the DSBF_SRCALPHA
+       * blend maths.
+       */
+      pBltData->ulFlags |= BLT_OP_FLAGS_BLEND_DST_MEMORY;
+      pBltData->ulFlags |= BLT_OP_FLAGS_BLEND_SRC_ALPHA;
+      if(pDev->bBlendFromColorAlpha)
+      {
+        pBltData->ulFlags |= BLT_OP_FLAGS_GLOBAL_ALPHA;
+      }
+    }
+  }
+  else
+  {
+    if(pDev->blittingFlags & DSBLIT_XOR)
+    {
+      pBltData->ulFlags |= BLT_OP_FLAGS_XOR;
+    }
+    else if(pDev->blittingFlags & DSBLIT_SRC_PREMULTIPLY)
+    {
+      /*
+       * This is a copy (blend with a destination of (0,0,0,0)) after
+       * premultiplication with the colour alpha channel.
+       */
+      pBltData->ulFlags |= (BLT_OP_FLAGS_BLEND_SRC_ALPHA | BLT_OP_FLAGS_BLEND_DST_ZERO);
+    }
+  }
+
+  if(pDev->blittingFlags & DSBLIT_COLORIZE)
+    pBltData->ulFlags |= BLT_OP_FLAGS_COLORIZE;
+
+  /*
+   * If DSBLIT_SRC_PREMULTCOLOR is set, but this hasn't been done as part of an
+   * alpha blend operation already, do it explicitly using the
+   * input matrix transformation on hardware that has this available.
+   */
+  if(set_premultcolor && (pDev->blittingFlags & DSBLIT_SRC_PREMULTCOLOR))
+    pBltData->ulFlags |= BLT_OP_FLAGS_PREMULT_COLOUR_ALPHA;
+
+  return true;
+}
+
+/*********************************************************************/
+/* Update palette and enable CLUT blit operation if required         */
+/*********************************************************************/
+static bool stgfxUpdatePalette
+(
+  STGFXDriverData*  pDrv,
+  STGFXDeviceData  *pDev,
+  STMFBIO_BLT_DATA *pBltData
+)
+{
+  if(pDev->palette && (pDev->blittingFlags != DSBLIT_INDEX_TRANSLATION))
+  {
+    if(pDev->bNeedCLUTReload)
+    {
+      STMFBIO_PALETTE lut;
+      int i;
+      bzero(&lut, sizeof(STMFBIO_PALETTE));
+
+      lut.numEntries = pDev->palette->num_entries;
+
+      for(i=0; i < lut.numEntries; i++)
+      {
+        DFBColor *color = &pDev->palette->entries[i];
+        /* Note that the alpha range for the lut is 0-128 (note not 127!!) */
+        lut.entries[i] = PIXEL_ARGB((color->a+1)/2, color->r, color->g, color->b);
+      }
+
+      if (ioctl(pDrv->fd, STMFBIO_SET_BLITTER_PALETTE, &lut ) < 0 )
+        return false;
+    }
+
+    pBltData->ulFlags |= BLT_OP_FLAGS_CLUT_ENABLE;
+  }
+
+  return true;
+}
+
+
+/*********************************************************************/
+/* Store the destination surface state in the device state structure */
+/*********************************************************************/
+static void stgfxSetDestination
+(
+  STGFXDeviceData*  pDev,
+  CardState*        pState
+)
+{
+  int i;
+
+  pDev->dstFormat = stgfxSetPixelFormat (pState->dst.buffer->format);
+
+  pDev->dstPitch  = pState->dst.pitch;
+  pDev->dstOffset = pState->dst.offset;
+  pDev->dstPhys   = pState->dst.phys;
+
+  pDev->dstMemBase = STMFBGP_FRAMEBUFFER;
+  for (i = 0; i < D_ARRAY_SIZE (pDev->aux_pools); ++i)
+    if (pDev->aux_pools[i] == pState->dst.allocation->pool)
+      {
+        pDev->dstMemBase = STMFBGP_GFX0 + i;
+        break;
+      }
+}
+
+
+/**************************************************************/
+/* Set the source surface state in the device state structure */
+/**************************************************************/
+static void stgfxSetSource
+(
+  STGFXDriverData*  pDrv,
+  STGFXDeviceData*  pDev,
+  CardState*        pState
+)
+{
+  const CoreSurface           * const srcSurf = pState->source;
+  const CoreSurfaceBufferLock * const lock = &pState->src;
+  const CoreSurfaceBuffer     * const srcSurfBuf = lock->buffer;
+  int i;
+
+  if (!srcSurfBuf)
+  {
+    pDev->srcFormat = SURF_NULL_PAD;
+    pDev->srcOffset = 0;
+    pDev->srcPitch  = 0;
+    pDev->srcPhys   = 0;
+    return;
+  }
+
+  switch (srcSurfBuf->format)
+    {
+    case DSPF_LUT2:
+    case DSPF_LUT8:
+    case DSPF_ALUT44:
+      pDev->palette = srcSurf->palette;
+      pDev->bNeedCLUTReload = true;
+      break;
+
+    default:
+      pDev->palette = NULL;
+      break;
+    }
+
+  pDev->srcFormat = stgfxSetPixelFormat (srcSurfBuf->format);
+
+  pDev->srcPitch  = lock->pitch;
+  pDev->srcOffset = lock->offset;
+  pDev->srcPhys   = lock->phys;
+
+  pDev->srcMemBase = STMFBGP_FRAMEBUFFER;
+  for (i = 0; i < D_ARRAY_SIZE (pDev->aux_pools); ++i)
+    if (pDev->aux_pools[i] == lock->allocation->pool)
+      {
+        pDev->srcMemBase = STMFBGP_GFX0 + i;
+        break;
+      }
+}
+
+/******************************************************************************/
+/* Create a single int colour from the colour structure received from directFB*/
+/******************************************************************************/
+static void stgfxSetColour
+(
+  STGFXDeviceData*  pDev,
+  CardState*        pState
+)
+{
+unsigned int alpha  = (unsigned int)pState->color.a;
+unsigned int red    = (unsigned int)pState->color.r;
+unsigned int green  = (unsigned int)pState->color.g;
+unsigned int blue   = (unsigned int)pState->color.b;
+
+  pDev->blitColour = PIXEL_ARGB(alpha, red, green, blue);
+  /*
+   * Store the alpha for blended blits of non-alpha surfaces
+   */
+  pDev->globalAlpha = alpha;
+
+  if(pDev->drawingFlags & DSDRAW_SRC_PREMULTIPLY)
+  {
+    /*
+     * We do source alpha pre-multiplication now, rather in the hardware so
+     * we can support it regardless of the blend mode.
+     */
+    red   = (red  *(alpha+1)) >> 8;
+    green = (green*(alpha+1)) >> 8;
+    blue  = (blue *(alpha+1)) >> 8;
+  }
+
+  if (pDev->drawingFlags & DSDRAW_BLEND)
+  {
+    /*
+     * For blended fills we use ARGB8888, to get full alpha precision in the
+     * blend, the hardware does color conversion.
+     */
+    pDev->drawColour = PIXEL_ARGB(alpha, red, green, blue);
+    return;
+  }
+
+  switch (pState->dst.buffer->format)
+  {
+  case DSPF_ARGB1555:
+    pDev->drawColour = PIXEL_ARGB1555(alpha, red, green, blue);
+    break;
+
+  case DSPF_ARGB4444:
+    pDev->drawColour = PIXEL_ARGB4444(alpha, red, green, blue);
+    break;
+
+  case DSPF_RGB16:
+    pDev->drawColour = PIXEL_RGB16(red, green, blue);
+    break;
+
+  case DSPF_RGB24:
+    pDev->drawColour = PIXEL_RGB32(red, green, blue);
+    break;
+
+  case DSPF_ARGB8565:
+    pDev->drawColour = PIXEL_ARGB8565(alpha, red, green, blue);
+    break;
+
+  case DSPF_UYVY:
+  case DSPF_AVYU:
+  case DSPF_VYU:
+    /*
+     * Note we get the hardware to do the conversion from RGB to YUV
+     */
+  case DSPF_ARGB:
+    pDev->drawColour = PIXEL_ARGB(alpha, red, green, blue);
+    break;
+
+  case DSPF_LUT2:
+  case DSPF_LUT8:
+    pDev->drawColour = pState->color_index;
+    break;
+
+  case DSPF_ALUT44:
+    pDev->drawColour = (alpha & 0xF0) | (pState->color_index & 0x0F);
+    break;
+
+  case DSPF_A8:
+    pDev->drawColour = alpha;
+    break;
+
+  default:
+    D_ERROR("DirectFB/gfxdrivers/stgfx: Unexpected colour format\n");
+    return;
+  }
+}
+
+/*********************************************/
+/* Check that all graphics ops have completed*/
+/*********************************************/
+static DFBResult stgfxEngineSync
+(
+  void* drv,
+  void* dev
+)
+{
+  STGFXDriverData* pDrv = (STGFXDriverData*)drv;
+  if (ioctl(pDrv->fd, STMFBIO_SYNC_BLITTER, 0 ) < 0)
+  {
+    D_PERROR("DirectFB/gfxdrivers/stgfx: Sync Engine failed\n");
+    D_ERROR("DirectFB/gfxdrivers/stgfx: file descriptor = %d\n",pDrv->fd);
+  }
+
+  return DFB_OK;
+}
+
+/**************************************************************************/
+/* Check that the current state is ok for the operation indicated by accel*/
+/**************************************************************************/
+static void stgfxCheckState
+(
+  void*               drv,
+  void*               dev,
+  CardState*          state,
+  DFBAccelerationMask accel
+)
+{
+bool supportedBlend = false;
+bool srcHasAlpha    = false;
+bool dstHasAlpha    = false;
+bool srcIsClut      = false;
+bool dstIsClut      = false;
+bool canUseHWInputMatrix;
+
+
+  state->accel = 0;
+
+  /* Flag the blending maths we can support */
+  if (state->src_blend == DSBF_ZERO && state->dst_blend == DSBF_ZERO) /* Clear */
+    supportedBlend = true;
+
+  if (state->src_blend == DSBF_ONE && state->dst_blend == DSBF_ZERO) /* Copy */
+    supportedBlend = true;
+
+  if (state->src_blend == DSBF_ZERO && state->dst_blend == DSBF_ONE) /* Nop */
+    supportedBlend = true;
+
+  if (state->src_blend == DSBF_ONE && state->dst_blend == DSBF_INVSRCALPHA)
+    supportedBlend = true;
+
+  if (state->src_blend == DSBF_SRCALPHA && state->dst_blend == DSBF_INVSRCALPHA)
+    supportedBlend = true;
+
+  if(!stgfxCheckPixelFormat(state->destination->config.format, false, &dstHasAlpha, &dstIsClut))
+    return; /* unsupported destination format */
+
+  /* Check there are no other drawing flags than those that are supported */
+  if (!(state->drawingflags & ~STGFX_VALID_DRAWINGFLAGS))
+  {
+    if (state->drawingflags & DSDRAW_BLEND)
+    {
+      /*
+       * Cannot support blend and xor at the same time
+       */
+      if (state->drawingflags & DSDRAW_XOR)
+        goto blit_acceleration;
+
+      if(!supportedBlend || dstIsClut)
+      {
+        /*
+         * Don't allow blends to LUT surfaces, but we do allow fast fills in
+         * order to be able to do a "clear" to a specific index.
+         */
+        goto blit_acceleration;
+      }
+
+      if (dstHasAlpha && (state->src_blend == DSBF_SRCALPHA && state->dst_blend == DSBF_INVSRCALPHA))
+      {
+        /*
+         * src func = src alpha, dst func = 1-src alpha can only be accelerated
+         * when the destination does not have an alpha channel, becuase the
+         * correct calculation of the destination alpha cannot be acheived in
+         * the hardware. We go to the trouble of supporting it as the mode is
+         * used in the blended fill df_dok performance test.
+         */
+        goto blit_acceleration;
+
+      }
+    }
+
+    state->accel |= STGFX_VALID_DRAWINGFUNCTIONS;
+  }
+
+
+blit_acceleration:
+
+  if (!(state->blittingflags & ~STGFX_VALID_BLITTINGFLAGS))
+  {
+    if(!state->source)
+      goto exit; /* Cannot blit if there is no source surface */
+
+    canUseHWInputMatrix = (stgfx_accel_type == FB_ACCEL_ST_BDISP
+                           && ((state->source->config.format != DSPF_UYVY
+                                && state->destination->config.format != DSPF_UYVY)
+                               || state->source->config.format == state->destination->config.format)
+                           && ((state->source->config.format != DSPF_AVYU
+                                && state->destination->config.format != DSPF_AVYU)
+                               || state->source->config.format == state->destination->config.format)
+                           && ((state->source->config.format != DSPF_VYU
+                                && state->destination->config.format != DSPF_VYU)
+                               || state->source->config.format == state->destination->config.format)
+                           );
+
+    if((state->blittingflags & DSBLIT_COLORIZE) && !canUseHWInputMatrix)
+      goto exit;
+
+    /*
+     * Deal with a special case of LUT->LUT blits that do not go through
+     * a colour lookup, but instead do an index translation mapping. Note that
+     * we do not actually support anything other than a 1-1 mapping of the CLUT.
+     */
+    if (dstIsClut)
+    {
+      if( state->blittingflags == DSBLIT_INDEX_TRANSLATION &&
+          state->source && (state->source->config.format == state->destination->config.format) )
+      {
+        state->accel = DFXL_BLIT;
+      }
+      /*
+       * Note that blits are not supported to LUT destinations other than in
+       * the index translation case.
+       */
+      goto exit;
+    }
+
+    if((state->blittingflags & (DSBLIT_SRC_COLORKEY | DSBLIT_DST_COLORKEY)) == (DSBLIT_SRC_COLORKEY | DSBLIT_DST_COLORKEY))
+      goto exit; /* Cannot accelerate simultaneous source and destination colour keying */
+
+    if(!stgfxCheckPixelFormat(state->source->config.format, true, &srcHasAlpha, &srcIsClut))
+      goto exit; /* unsupported source pixel type */
+
+    if(state->blittingflags & DSBLIT_BLEND_ALPHACHANNEL)
+    {
+      if(!supportedBlend)
+        goto exit;
+
+      /*
+       * We cannot blend and XOR at the same time, what a silly idea
+       */
+      if(state->blittingflags & DSBLIT_XOR)
+        goto exit;
+
+      /*
+       * We cannot blend with a source of DSBF_RGB32 because the hardware cannot
+       * be made to ignore the top 8 bits and will use them as an alpha channel
+       */
+      if(state->source->config.format == DSPF_RGB32)
+        goto exit;
+
+      if(state->blittingflags & DSBLIT_BLEND_COLORALPHA)
+      {
+        /*
+         * If COLORALPHA is also specified then the constant alpha is multiplied
+         * with the src alpha, but not with the RGB components unless
+         * src premultiply, premultcolor or src blend DSBF_SRCALPHA is set.
+         * Unfortunately the hardware always multiplies RGB by the global alpha
+         * register.
+         */
+        if(!(state->blittingflags & (DSBLIT_SRC_PREMULTIPLY | DSBLIT_SRC_PREMULTCOLOR)) && (state->src_blend != DSBF_SRCALPHA))
+          goto exit;
+
+
+        if((state->blittingflags & DSBLIT_SRC_PREMULTCOLOR) && !canUseHWInputMatrix)
+        {
+          /*
+           * We can't do more than one multiply of alpha with color except on
+           * BDisp based parts when the source is RGB or expanded Clut data. In
+           * that case we can use the input matrix to do the premultcolor.
+           */
+          if((state->blittingflags & DSBLIT_SRC_PREMULTIPLY) || (state->src_blend == DSBF_SRCALPHA))
+            goto exit;
+        }
+
+      }
+      else if((state->blittingflags & DSBLIT_SRC_PREMULTCOLOR) && !canUseHWInputMatrix)
+      {
+        /*
+         * Premultcolor without coloralpha needs the BDisp input matrix
+         */
+        goto exit;
+      }
+
+
+      /*
+       * We can do blend from alpha channel on all surface formats as on formats
+       * without alpha the hardware fills in "full" alpha for us. However we
+       * can only do source premultiplication if the src func != DSBF_SRCALPHA
+       */
+      if((state->blittingflags & DSBLIT_SRC_PREMULTIPLY) && (state->src_blend == DSBF_SRCALPHA))
+          goto exit;
+
+      /*
+       * We can do src func = DSBF_SRCALPHA as long as there is no incompatible
+       * pre-multiply (src alpha or color alpha, which has already been tested
+       * for) and the destination does not have an alpha channel.
+       *
+       * This is becuase the hardware cannot calculate the correct alpha for
+       * the destination but can calculate the correct RGB values. This is
+       * supported to accelerate the blit-blend performance test in df_dok
+       * for the standard 16bit destination.
+       */
+      if(dstHasAlpha && (state->src_blend == DSBF_SRCALPHA))
+          goto exit;
+
+    }
+    else if(state->blittingflags & DSBLIT_BLEND_COLORALPHA)
+    {
+      /*
+       * color alpha on its own (i.e. no DSBLIT_BLEND_ALPHACHANNEL). Supported
+       * blend modes + flags:
+       *
+       * (1) src func = 0, dst func = 0 (clear)
+       * (2) src func = 0, dst func = 1 (nop)
+       * (3) src func = 1, dst func = 0 (copy), any dest surface, premultiply and/or premultcolor on
+       * (4) src func = 1, dst func = 1-alpha, any dest surface, premultiply and/or premultcolor on
+       * (5) src func = src alpha, dst func = 1-src alpha, no premultiply, non alpha dest surface
+       *
+       * The source must be an RGB surface with no existing alpha channel in
+       * the last three cases. Note that this doesn't include DSPF_RGB32 as the
+       * hardware will insist on using the top unused 8 bits as an alpha channel.
+       * We have no way of forcing the alpha channel to be fully opqaue.
+       *
+       * The reason for this is that COLORALPHA on its own replaces the src alpha
+       * channel with the alpha value from the colour register. Unfortunately the
+       * hardware cannot do this, it always multiplies the source alpha with
+       * its global alpha register. So we can only accelerate this when the
+       * source alpha is always 1.0f, i.e. surface formats that do not contain
+       * an alpha channel, or for those obscure blend modes where the src is
+       * discarded.
+       *
+       */
+      if(!supportedBlend)
+        goto exit;
+
+      if(state->blittingflags & DSBLIT_XOR)
+        goto exit;
+
+      if(state->src_blend == DSBF_ONE)
+      {
+        if(srcHasAlpha || !(state->blittingflags & (DSBLIT_SRC_PREMULTIPLY | DSBLIT_SRC_PREMULTCOLOR)))
+          goto exit;
+
+      }
+      else if(state->src_blend == DSBF_SRCALPHA && state->dst_blend == DSBF_INVSRCALPHA)
+      {
+        if(srcHasAlpha || dstHasAlpha || (state->blittingflags & DSBLIT_SRC_PREMULTIPLY))
+          goto exit;
+      }
+
+      if((state->blittingflags & DSBLIT_SRC_PREMULTCOLOR) && !canUseHWInputMatrix)
+      {
+        /*
+         * We can't do more than one multiply of alpha with color except on
+         * BDisp based parts when the source is RGB or expanded Clut data. In
+         * that case we can use the input matrix to do the premultcolor.
+         */
+        if((state->blittingflags & DSBLIT_SRC_PREMULTIPLY) || (state->src_blend != DSBF_SRCALPHA))
+          goto exit;
+      }
+
+    }
+    else
+    {
+      /*
+       * We can only format convert DSBF_RGB32 to other formats that do not
+       * have an alpha channel. We allow this to accelerate the df_dok
+       * performance test blit-convert. But these limitations make this
+       * surface format pretty useless.
+       */
+      if(state->source->config.format == DSPF_RGB32)
+      {
+        if(dstHasAlpha || (state->blittingflags & DSBLIT_SRC_PREMULTIPLY))
+          goto exit;
+      }
+
+      /*
+       * We cannot XOR and premultiply by src alpha at the same time
+       */
+      if((state->blittingflags & (DSBLIT_XOR|DSBLIT_SRC_PREMULTIPLY)) == (DSBLIT_XOR|DSBLIT_SRC_PREMULTIPLY))
+        goto exit;
+
+      /*
+       * In this case we need the input matrix on the BDisp to do premultcolor.
+       */
+      if((state->blittingflags & DSBLIT_SRC_PREMULTCOLOR) && !canUseHWInputMatrix)
+      {
+        goto exit;
+      }
+    }
+
+    state->accel |= STGFX_VALID_BLITTINGFUNCTIONS;
+  }
+
+exit:
+/*  printf("check state - state->accel = 0x%x\n",state->accel);*/
+  return;
+}
+
+typedef struct  _PIX_FMT_TBL {
+    unsigned long  stgBlitFmt;
+    const char    *string;
+    bool           supportedAsSrc;
+    bool           supportedAsDst;
+}PIX_FMT_TBL;
+
+
+static const PIX_FMT_TBL format_tbl_bdisp[DFB_NUM_PIXELFORMATS] = {
+    /*
+     * Note: we specify that LUT formats have an alpha channel, because as a source
+     * it does once the colour lookup has taken place; hence any blending
+     * restrictions will apply.
+     *
+     * Note2: CLUT2 is not supported as a target type on BDISP at the moment.
+     */
+    [DFB_PIXELFORMAT_INDEX (DSPF_ARGB1555)] = { SURF_ARGB1555,  "SURF_ARGB1555 16bpp alp",        true,  true },
+    [DFB_PIXELFORMAT_INDEX (DSPF_RGB16)]    = { SURF_RGB565,    "SURF_RGB565 16bpp",              true,  true },
+    [DFB_PIXELFORMAT_INDEX (DSPF_RGB24)]    = { SURF_RGB888,    "SURF_RGB888 24 bpp - packed",    true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_RGB32)]    = { SURF_ARGB8888,  "SURF_ARGB8888 32 bpp - no alpha",true,  false },
+    [DFB_PIXELFORMAT_INDEX (DSPF_ARGB)]     = { SURF_ARGB8888,  "SURF_ARGB8888 32bpp alp",        true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_A8)]       = { SURF_A8,        "SURF_A8",                        true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_YUY2)]     = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_RGB332)]   = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_UYVY)]     = { SURF_YCBCR422R, "SURF_YCBCR422R",                 true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_I420)]     = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_YV12)]     = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_LUT8)]     = { SURF_CLUT8,     "SURF_CLUT8",                     true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_ALUT44)]   = { SURF_ACLUT44,   "SURF_ACLUT44",                   true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_AiRGB)]    = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_A1)]       = { SURF_A1,        "SURF_A1",                        true,  false },
+    [DFB_PIXELFORMAT_INDEX (DSPF_NV12)]     = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_NV16)]     = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_ARGB2554)] = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_ARGB4444)] = { SURF_ARGB4444,  "SURF_ARGB4444 16bpp",            true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_RGBA4444)] = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_NV21)]     = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_AYUV)]     = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_A4)]       = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_ARGB1666)] = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_ARGB6666)] = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_RGB18)]    = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_LUT2)]     = { SURF_CLUT2,     "SURF_CLUT2",                     true,  false },
+    [DFB_PIXELFORMAT_INDEX (DSPF_RGB444)]   = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_RGB555)]   = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_BGR555)]   = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_RGBA5551)] = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_YUV444P)]  = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_ARGB8565)] = { SURF_ARGB8565,  "SURF_ARGB8565 24bpp alp",        true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_AVYU)]     = { SURF_ACRYCB8888,"SURF_ACRYCB8888 32bpp YUV alp",  true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_VYU)]      = { SURF_CRYCB888,  "SURF_CRYCB888 24bpp YUV",        true,  true  }
+};
+
+
+static const PIX_FMT_TBL format_tbl_gamma[DFB_NUM_PIXELFORMATS] = {
+    [DFB_PIXELFORMAT_INDEX (DSPF_ARGB1555)] = { SURF_ARGB1555,  "SURF_ARGB1555 16bpp alp",        true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_RGB16)]    = { SURF_RGB565,    "SURF_RGB565 16bpp",              true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_RGB24)]    = { SURF_RGB888,    "SURF_RGB888 24 bpp - packed",    true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_RGB32)]    = { SURF_ARGB8888,  "SURF_ARGB8888 32 bpp - no alpha",true,  false },
+    [DFB_PIXELFORMAT_INDEX (DSPF_ARGB)]     = { SURF_ARGB8888,  "SURF_ARGB8888 32bpp alp",        true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_A8)]       = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_YUY2)]     = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_RGB332)]   = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_UYVY)]     = { SURF_YCBCR422R, "SURF_YCBCR422R",                 true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_I420)]     = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_YV12)]     = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_LUT8)]     = { SURF_CLUT8,     "SURF_CLUT8",                     true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_ALUT44)]   = { SURF_ACLUT44,   "SURF_ACLUT44",                   true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_AiRGB)]    = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_A1)]       = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_NV12)]     = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_NV16)]     = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_ARGB2554)] = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_ARGB4444)] = { SURF_ARGB4444,  "SURF_ARGB4444 16bpp",            true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_RGBA4444)] = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_NV21)]     = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_AYUV)]     = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_A4)]       = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_ARGB1666)] = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_ARGB6666)] = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_RGB18)]    = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_LUT2)]     = { SURF_CLUT2,     "SURF_CLUT2",                     true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_RGB444)]   = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_RGB555)]   = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_BGR555)]   = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_RGBA5551)] = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_YUV444P)]  = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_ARGB8565)] = { SURF_ARGB8565,  "SURF_ARGB8565 24bpp alp",        true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_AVYU)]     = { SURF_ACRYCB8888,"SURF_ACRYCB8888 32bpp YUV alp",  true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_VYU)]      = { SURF_CRYCB888,  "SURF_CRYCB888 24bpp YUV",        true,  true  }
+};
+
+
+static const PIX_FMT_TBL *format_tbl;
+
+
+static bool stgfxCheckPixelFormat(DFBSurfacePixelFormat dfbFmt,
+                                  bool bSrc, bool *hasAlpha, bool *isClut)
+{
+  D_ASSERT (dfbFmt != DSPF_UNKNOWN);
+  if (!dfbFmt)
+    return false;
+
+  const PIX_FMT_TBL * const format = &format_tbl[DFB_PIXELFORMAT_INDEX (dfbFmt)];
+
+  *hasAlpha = DFB_PIXELFORMAT_HAS_ALPHA (dfbFmt);
+  *isClut   = DFB_PIXELFORMAT_IS_INDEXED (dfbFmt);
+
+  return bSrc ? format->supportedAsSrc : format->supportedAsDst;
+}
+
+
+static unsigned long stgfxSetPixelFormat(DFBSurfacePixelFormat dfbFmt)
+{
+  D_ASSERT (dfbFmt != DSPF_UNKNOWN);
+  if (!dfbFmt)
+    return 0;
+
+  return format_tbl[DFB_PIXELFORMAT_INDEX (dfbFmt)].stgBlitFmt;
+}
+
+
+static unsigned long stgfxGetPixelFormat(SURF_FMT fmt)
+{
+  switch (fmt)
+    {
+    case SURF_ARGB1555:   return DSPF_ARGB1555;
+    case SURF_RGB565  :   return DSPF_RGB16;
+    case SURF_RGB888  :   return DSPF_RGB24;
+    case SURF_ARGB8888:   return DSPF_ARGB;
+    case SURF_A8:         return DSPF_A8;
+    case SURF_YCBCR422R:  return DSPF_UYVY;
+    case SURF_CLUT8:      return DSPF_LUT8;
+    case SURF_ACLUT44:    return DSPF_ALUT44;
+    case SURF_A1:         return DSPF_A1;
+    case SURF_ARGB4444:   return DSPF_ARGB4444;
+    case SURF_CLUT2:      return DSPF_LUT2;
+    case SURF_ARGB8565:   return DSPF_ARGB8565;
+    case SURF_ACRYCB8888: return DSPF_AVYU;
+    case SURF_CRYCB888:   return DSPF_VYU;
+    default:
+      break;
+    }
+  return DSPF_UNKNOWN;
+}
+
+
+/**********************************************************************/
+/* DirectFB has requested a modified state.                           */
+/* Check which fields have been modified and then update the fields   */
+/* that are necessary for the operation indicated by accel            */
+/**********************************************************************/
+static void stgfxSetState
+(
+  void*                 drv,
+  void*                 dev,
+  GraphicsDeviceFuncs*  funcs,
+  CardState*            state,
+  DFBAccelerationMask   accel
+)
+{
+  STGFXDriverData *pDrv = (STGFXDriverData*) drv;
+  STGFXDeviceData *pDev = (STGFXDeviceData*) dev;
+
+  /*
+   * First update the flags, as the rest depends on these being
+   * correct.
+   */
+  if (state->mod_hw & SMF_DRAWING_FLAGS)
+    pDev->drawingFlags = state->drawingflags;
+
+  if (state->mod_hw & SMF_BLITTING_FLAGS)
+  {
+    pDev->blittingFlags        =  state->blittingflags;
+    pDev->bBlendFromColorAlpha = (state->blittingflags & DSBLIT_BLEND_COLORALPHA)   ? true : false;
+    pDev->bBlendFromSrcAlpha   = (state->blittingflags & DSBLIT_BLEND_ALPHACHANNEL) ? true : false;
+    pDev->bSrcPremultiply      = (state->blittingflags & DSBLIT_SRC_PREMULTIPLY)    ? true : false;
+    pDev->bPremultColor        = (state->blittingflags & DSBLIT_SRC_PREMULTCOLOR)   ? true : false;
+  }
+
+  if (state->mod_hw & SMF_DESTINATION)
+    stgfxSetDestination(pDev, state);
+
+  if (state->mod_hw & SMF_SOURCE)
+    stgfxSetSource(pDrv, pDev, state);
+
+  /*
+   * Make sure that the colour gets updated when the drawing or blitting flags
+   * or the destination surface format change, as we have to modify the colour
+   * for fills.
+   */
+  if (state->mod_hw & (SMF_COLOR | SMF_DRAWING_FLAGS | SMF_DESTINATION))
+    stgfxSetColour(pDev, state);
+
+  if (state->mod_hw & SMF_SRC_BLEND)
+    pDev->srcBlendFunc = state->src_blend;
+
+  if (state->mod_hw & SMF_DST_BLEND)
+    pDev->dstBlendFunc = state->dst_blend;
+
+  if (state->mod_hw & SMF_SRC_COLORKEY)
+    pDev->srcColourKey = state->src_colorkey;
+
+  if (state->mod_hw & SMF_DST_COLORKEY)
+    pDev->dstColourKey = state->dst_colorkey;
+
+  switch (accel)
+  {
+    case DFXL_FILLRECTANGLE:
+    case DFXL_DRAWRECTANGLE:
+      state->set |= (DFXL_FILLRECTANGLE | DFXL_DRAWRECTANGLE);
+      break;
+
+    case DFXL_BLIT:
+    case DFXL_STRETCHBLIT:
+      state->set |= (DFXL_BLIT | DFXL_STRETCHBLIT);
+      break;
+
+    default:
+      /* Should never happen as we have told DirectFB which functions we can support*/
+      D_ERROR( "DirectFB/gfxdrivers/stgfx: unexpected drawing/blitting function" );
+      break;
+  }
+
+  state->mod_hw = (StateModificationFlags)0;
+}
+
+static int
+_check_src_constraints (const STGFXDriverData * const pDrv,
+                        const STGFXDeviceData * const pDev,
+                        const DFBRectangle    * const rect,
+                        unsigned long         *base,
+                        unsigned long         *end)
+{
+  /* complain if sth crosses a 64MB bank boundary. */
+#define MEMORY64MB_SIZE         (1<<26)
+#define _ALIGN_DOWN(addr,size)	((addr)&(~((size)-1)))
+
+  DFBSurfacePixelFormat format = stgfxGetPixelFormat (pDev->srcFormat);
+
+  *base = pDev->srcPhys;
+  *base += rect->y * pDev->srcPitch
+           + (rect->x * DFB_BITS_PER_PIXEL (format) / 8);
+  *end = *base
+          + (rect->h - 1) * pDev->srcPitch
+          + (rect->w * DFB_BITS_PER_PIXEL (format) / 8);
+
+  return (_ALIGN_DOWN (*base, MEMORY64MB_SIZE) != _ALIGN_DOWN (*end, MEMORY64MB_SIZE));
+}
+
+static int
+_check_dst_constraints (const STGFXDriverData * const pDrv,
+                        const STGFXDeviceData * const pDev,
+                        const DFBRectangle    * const rect,
+                        unsigned long         *base,
+                        unsigned long         *end)
+{
+  DFBSurfacePixelFormat format = stgfxGetPixelFormat (pDev->dstFormat);
+
+  *base = pDev->dstPhys;
+  *base += rect->y * pDev->dstPitch
+           + (rect->x * DFB_BITS_PER_PIXEL (format) / 8);
+  *end = *base
+         + (rect->h - 1) * pDev->dstPitch
+         + (rect->w * DFB_BITS_PER_PIXEL (format) / 8);
+
+  return (_ALIGN_DOWN (*base, MEMORY64MB_SIZE) != _ALIGN_DOWN (*end, MEMORY64MB_SIZE));
+}
+
+/********************************************************************************************/
+/* Fill the rectangle 'rect' with the colour that has been previously specified in setstate */
+/********************************************************************************************/
+static bool stgfxFillRectangle
+(
+  void* drv,
+  void* dev,
+  DFBRectangle* rect
+)
+{
+  STGFXDriverData*  pDrv = (STGFXDriverData*) drv;
+  STGFXDeviceData*  pDev = (STGFXDeviceData*) dev;
+  STMFBIO_BLT_DATA  bltData;
+
+  bzero(&bltData, sizeof(STMFBIO_BLT_DATA));
+
+  bltData.operation = BLT_OP_FILL;
+  return stgfxDraw(pDrv, pDev, rect, &bltData);
+}
+
+static bool
+stgfxFillRectangle_slow (void         *drv,
+                         void         *dev,
+                         DFBRectangle *rect)
+{
+  const STGFXDriverData * const pDrv = (STGFXDriverData *) drv;
+  const STGFXDeviceData * const pDev = (STGFXDeviceData *) dev;
+
+  unsigned long base, end;
+  if (_check_dst_constraints (pDrv, pDev, rect, &base, &end))
+  {
+    fprintf (stderr, "%s: rect %d/%d/%d/%d (%#.8lx -> %#.8lx) crosses a bank boundary!\n",
+             __FUNCTION__, rect->x, rect->y, rect->w, rect->h, base, end);
+    return false;
+  }
+
+  return stgfxFillRectangle (drv, dev, rect);
+}
+
+
+/********************************************************************************************/
+/* Draw the rectangle 'rect' with the colour that has been previously specified in setstate */
+/********************************************************************************************/
+static bool stgfxDrawRectangle
+(
+  void* drv,
+  void* dev,
+  DFBRectangle* rect
+)
+{
+  STGFXDriverData*  pDrv = (STGFXDriverData*) drv;
+  STGFXDeviceData*  pDev = (STGFXDeviceData*) dev;
+  STMFBIO_BLT_DATA  bltData;
+
+  bzero(&bltData, sizeof(STMFBIO_BLT_DATA));
+
+  bltData.operation = BLT_OP_DRAW_RECTANGLE;
+  return stgfxDraw(pDrv, pDev, rect, &bltData);
+}
+
+static bool
+stgfxDrawRectangle_slow (void         *drv,
+                         void         *dev,
+                         DFBRectangle *rect)
+{
+  const STGFXDriverData * const pDrv = (STGFXDriverData *) drv;
+  const STGFXDeviceData * const pDev = (STGFXDeviceData *) dev;
+
+  unsigned long base, end;
+  if (_check_dst_constraints (pDrv, pDev, rect, &base, &end))
+  {
+    fprintf (stderr, "%s: rect %d/%d/%d/%d (%#.8lx -> %#.8lx) crosses a bank boundary!\n",
+             __FUNCTION__, rect->x, rect->y, rect->w, rect->h, base, end);
+    return false;
+  }
+
+  return stgfxDrawRectangle (drv, dev, rect);
+}
+
+
+/******************************/
+/* Blit from 'rect' to dx, dy */
+/******************************/
+static bool stgfxBlit
+(
+  void*         drv,
+  void*         dev,
+  DFBRectangle* rect,
+  int           dx,
+  int           dy
+)
+{
+  STGFXDriverData*  pDrv = (STGFXDriverData*) drv;
+  STGFXDeviceData*  pDev = (STGFXDeviceData*) dev;
+  STMFBIO_BLT_DATA  bltData;
+
+  bzero(&bltData, sizeof(STMFBIO_BLT_DATA));
+
+  if(!stgfxCommonBlitData(pDrv, pDev, &bltData))
+  {
+    /* We don't need to do the operation as it would be a nop */
+    return true;
+  }
+
+  if(!stgfxUpdatePalette(pDrv, pDev, &bltData))
+    return false;
+
+  bltData.src_left   = (unsigned short)rect->x;
+  bltData.src_top    = (unsigned short)rect->y;
+  bltData.src_right  = (unsigned short)(rect->x + rect->w);
+  bltData.src_bottom = (unsigned short)(rect->y + rect->h);
+
+  bltData.dst_left   = (unsigned short)dx;
+  bltData.dst_top    = (unsigned short)dy;
+  bltData.dst_right  = (unsigned short)(dx + rect->w);
+  bltData.dst_bottom = (unsigned short)(dy + rect->h);
+
+  if (ioctl(pDrv->fd, STMFBIO_BLT, &bltData ) < 0)
+  {
+    return false;
+  }
+
+  return true;
+}
+
+static bool
+stgfxBlit_slow (void         *drv,
+                void         *dev,
+                DFBRectangle *rect,
+                int           dx,
+                int           dy)
+{
+  const STGFXDriverData * const pDrv = (STGFXDriverData *) drv;
+  const STGFXDeviceData * const pDev = (STGFXDeviceData *) dev;
+
+  unsigned long base, end;
+  if (_check_src_constraints (pDrv, pDev, rect, &base, &end))
+  {
+    fprintf (stderr, "%s: srcrect %d/%d/%d/%d (%#.8lx -> %#.8lx) crosses a bank boundary!\n",
+             __FUNCTION__, rect->x, rect->y, rect->w, rect->h, base, end);
+    return false;
+  }
+  DFBRectangle dr = { .x = dx, .y = dy, .w = rect->w, .h = rect->h };
+  if (_check_dst_constraints (pDrv, pDev, &dr, &base, &end))
+  {
+    fprintf (stderr, "%s: dstrect %d/%d/%d/%d (%#.8lx -> %#.8lx) crosses a bank boundary!\n",
+             __FUNCTION__, dr.x, dr.y, dr.w, dr.h, base, end);
+    return false;
+  }
+
+  return stgfxBlit (drv, dev, rect, dx, dy);
+}
+
+
+/**************************/
+/* Blit from 'sr' to 'dr' */
+/**************************/
+static bool stgfxStretchBlit
+(
+  void*         drv,
+  void*         dev,
+  DFBRectangle* sr,
+  DFBRectangle* dr
+)
+{
+  STGFXDriverData*  pDrv = (STGFXDriverData*) drv;
+  STGFXDeviceData*  pDev = (STGFXDeviceData*) dev;
+  STMFBIO_BLT_DATA  bltData;
+
+  bzero(&bltData, sizeof(STMFBIO_BLT_DATA));
+
+  if(!stgfxCommonBlitData(pDrv, pDev, &bltData))
+  {
+    /* We don't need to do the operation as it would be a nop */
+    return true;
+  }
+
+  if(!stgfxUpdatePalette(pDrv, pDev, &bltData))
+    return false;
+
+  bltData.src_left   = (unsigned short)sr->x;
+  bltData.src_top    = (unsigned short)sr->y;
+  bltData.src_right  = (unsigned short)(sr->x + sr->w);
+  bltData.src_bottom = (unsigned short)(sr->y + sr->h);
+
+  bltData.dst_left   = (unsigned short)dr->x;
+  bltData.dst_top    = (unsigned short)dr->y;
+  bltData.dst_right  = (unsigned short)(dr->x + dr->w);
+  bltData.dst_bottom = (unsigned short)(dr->y + dr->h);
+
+  if (ioctl(pDrv->fd, STMFBIO_BLT, &bltData ) < 0)
+  {
+    return false;
+  }
+
+  return true;
+}
+
+static bool
+stgfxStretchBlit_slow (void         *drv,
+                       void         *dev,
+                       DFBRectangle *sr,
+                       DFBRectangle *dr)
+{
+  const STGFXDriverData * const pDrv = (STGFXDriverData *) drv;
+  const STGFXDeviceData * const pDev = (STGFXDeviceData *) dev;
+
+  unsigned long base, end;
+  if (_check_src_constraints (pDrv, pDev, sr, &base, &end))
+  {
+    fprintf (stderr, "%s: srcrect %d/%d/%d/%d (%#.8lx -> %#.8lx) crosses a bank boundary!\n",
+             __FUNCTION__, sr->x, sr->y, sr->w, sr->h, base, end);
+    return false;
+  }
+  if (_check_dst_constraints (pDrv, pDev, dr, &base, &end))
+  {
+    fprintf (stderr, "%s: dstrect %d/%d/%d/%d (%#.8lx -> %#.8lx) crosses a bank boundary!\n",
+             __FUNCTION__, dr->x, dr->y, dr->w, dr->h, base, end);
+    return false;
+  }
+
+  return stgfxStretchBlit (drv, dev, sr, dr);
+}
+
+
+static void
+stgfx_check_memory_constraints (CoreGraphicsDevice  * const device,
+                                GraphicsDeviceFuncs * const funcs)
+{
+  /* fbmem could in theory cross a 64MB boundary, stmfb doesn't go through any
+     efforts whatsoever to prevent such from happening. It should be changed
+     to add a check for configurations which end up crossing a boundary, but
+     even then I don't think I'll remove the check from here, since otherwise
+     we add a (soft) dependency on an up-to-date version of stmfb. */
+  unsigned long fb_base = dfb_system_video_memory_physical (0);
+  unsigned long fb_end  = fb_base + dfb_system_videoram_length () - 1;
+  if (_ALIGN_DOWN (fb_base, MEMORY64MB_SIZE) != _ALIGN_DOWN (fb_end, MEMORY64MB_SIZE))
+  {
+    fprintf (stderr,
+             "%s: Your framebuffer memory allocation is quite wrong!\n"
+             "  Can't use hardware acceleration to its full extent!\n"
+             "  Physical framebuffer memory must not cross a 64MB bank!\n"
+             "  Please fix your configuration!\n", __FUNCTION__);
+
+    funcs->FillRectangle = stgfxFillRectangle_slow;
+    funcs->DrawRectangle = stgfxDrawRectangle_slow;
+    funcs->Blit          = stgfxBlit_slow;
+    funcs->StretchBlit   = stgfxStretchBlit_slow;
+  }
+}
+
+/* exported symbols - These functions must be present */
+
+/************************************************************/
+/* Check if the hardware is ours by looking at the value    */
+/* returned in the accel field of the framebuffer fixed info*/
+/************************************************************/
+static int driver_probe(CoreGraphicsDevice* device)
+{
+  int result = 0;
+  int accel = dfb_gfxcard_get_accelerator( device );
+
+  switch (accel)
+  {
+  case FB_ACCEL_ST_GAMMA:
+    D_DEBUG( "DirectFB/STGFX: Found FB_ACCEL_ST_GAMMA\n" );
+    result = 1;
+    break;
+  case FB_ACCEL_ST_BDISP:
+    D_DEBUG( "DirectFB/STGFX: Found FB_ACCEL_ST_BDISP\n" );
+    result = 1;
+    break;
+  default:
+    D_DEBUG( "DirectFB/STGFX: unrecognised accelerator %d\n",accel );
+    break;
+  }
+
+  return result;
+}
+
+/***************************************************/
+/* Return some human readable info about our driver*/
+/***************************************************/
+static void driver_get_info(CoreGraphicsDevice *device, GraphicsDriverInfo *info)
+{
+  /* fill driver info structure */
+  int accel = dfb_gfxcard_get_accelerator( device );
+
+  switch (accel)
+  {
+    case FB_ACCEL_ST_GAMMA:
+      snprintf( info->name, DFB_GRAPHICS_DRIVER_INFO_NAME_LENGTH, "ST Microelectronics Gamma" );
+      break;
+    case FB_ACCEL_ST_BDISP:
+      snprintf( info->name, DFB_GRAPHICS_DRIVER_INFO_NAME_LENGTH, "ST Microelectronics BDisp" );
+      break;
+    default:
+      break;
+  }
+
+  snprintf( info->vendor, DFB_GRAPHICS_DRIVER_INFO_VENDOR_LENGTH, "ST Microelectronics" );
+
+  info->version.major = 1;
+  info->version.minor = 0;
+
+  /* Tell DirectFB how big our device and driver structures are */
+  info->driver_data_size = sizeof (STGFXDriverData);
+  info->device_data_size = sizeof (STGFXDeviceData);
+}
+
+/****************************************************************/
+/* Set the function pointers for the acceleration functions.    */
+/* This does not tell DirectFB what we support, this is done in */
+/* driver_init_device.                                          */
+/****************************************************************/
+static DFBResult driver_init_driver
+(
+  CoreGraphicsDevice*   device,
+  GraphicsDeviceFuncs*  funcs,
+  void*                 driver_data,
+  void*                 device_data,
+  CoreDFB*              core
+)
+{
+  STGFXDriverData * const pDrv = driver_data;
+  STGFXDeviceData * const pDev = device_data;
+
+  funcs->EngineSync         = stgfxEngineSync;
+  funcs->CheckState         = stgfxCheckState;
+  funcs->SetState           = stgfxSetState;
+  funcs->FillRectangle      = stgfxFillRectangle;
+  funcs->DrawRectangle      = stgfxDrawRectangle;
+  funcs->Blit               = stgfxBlit;
+  funcs->StretchBlit        = stgfxStretchBlit;
+
+  pDrv->core = core;
+  pDrv->device_data = device_data;
+
+  /*
+   * Get the framebuffer file descriptor. Because we successfully
+   * probed ourselves the system _must_ be a framebuffer device
+   */
+  pDrv->fd = -1;
+
+  if (dfb_system_type () == CORE_FBDEV)
+  {
+    const FBDev * const dfb_fbdev = dfb_system_data ();
+
+    if (dfb_fbdev)
+      pDrv->fd = dfb_fbdev->fd;
+  }
+  else if (dfb_system_type () == CORE_STMFBDEV)
+  {
+    const STMfbdev * const stmfbdev = dfb_system_data ();
+
+    D_MAGIC_ASSERT (stmfbdev, STMfbdev);
+    if (stmfbdev)
+      pDrv->fd = stmfbdev->fd;
+  }
+
+  if (pDrv->fd < 0)
+  {
+    D_ERROR("DirectFB/gfxdrivers/stgfx: Only supported on FBDev and STMfbdev systems");
+    return DFB_IO;
+  }
+
+  D_INFO("DirectFB/gfxdrivers/stgfx: FB file descriptor = %d\n",pDrv->fd);
+
+  /* adjust function pointers */
+  stgfx_check_memory_constraints (device, funcs);
+
+  /*
+   * Setup the driver state here. This cannot be done in probe as we need to
+   * do it for slaves in multiapp mode and probe is only called by the master
+   * application.
+   */
+  stgfx_accel_type = dfb_gfxcard_get_accelerator( device );
+
+  switch (stgfx_accel_type)
+  {
+  case FB_ACCEL_ST_GAMMA:
+    format_tbl = format_tbl_gamma;
+    STGFX_VALID_DRAWINGFLAGS  = STGFX_VALID_DRAWINGFLAGS_GAMMA;
+    STGFX_VALID_BLITTINGFLAGS = STGFX_VALID_BLITTINGFLAGS_GAMMA;
+    break;
+  case FB_ACCEL_ST_BDISP:
+    format_tbl = format_tbl_bdisp;
+    STGFX_VALID_DRAWINGFLAGS  = STGFX_VALID_DRAWINGFLAGS_BDISP;
+    STGFX_VALID_BLITTINGFLAGS = STGFX_VALID_BLITTINGFLAGS_BDISP;
+    break;
+  default:
+    return DFB_IO;
+  }
+
+  if (dfb_system_type () == CORE_STMFBDEV)
+  {
+    extern const SurfacePoolFuncs _g_stmfbdevSurfacePoolFuncs;
+    extern ScreenFuncs            _g_stmfbdevScreenFuncs;
+    extern DisplayLayerFuncs      _g_stmfbdevLayerFuncs;
+
+    STMfbdev   * const stmfbdev = dfb_system_data ();
+    CoreScreen *screen;
+
+    D_MAGIC_ASSERT (stmfbdev, STMfbdev);
+
+    if (!dfb_core_is_master (pDrv->core))
+      dfb_surface_pool_join (pDrv->core, pDev->pool,
+                             &_g_stmfbdevSurfacePoolFuncs);
+
+    /* Register primary screen functions */
+    screen = dfb_screens_register (NULL, stmfbdev,
+                                   &_g_stmfbdevScreenFuncs);
+
+    /* Register primary layer functions */
+    dfb_layers_register (screen, stmfbdev, &_g_stmfbdevLayerFuncs);
+  }
+  else if (dfb_system_type() == CORE_FBDEV)
+  {
+    dfb_screens_hook_primary( device, driver_data,
+                              &stgfxPrimaryScreenFuncs_stgfx1,
+                              &pDrv->screenData.orig_funcs,
+                              &pDrv->screenData.orig_data );
+
+    dfb_layers_hook_primary( device, driver_data,
+                             &stgfxPrimaryLayerFuncs_stgfx1,
+                             &pDrv->layerData.orig_funcs,
+                             &pDrv->layerData.orig_data );
+  }
+
+  if (!dfb_core_is_master (pDrv->core))
+    stgfx1_surface_pool_join (pDrv->core, pDev->aux_pools,
+                              D_ARRAY_SIZE (pDev->aux_pools));
+
+  return DFB_OK;
+}
+
+/***************************/
+/* Initialise the hardware */
+/***************************/
+static DFBResult driver_init_device
+(
+  CoreGraphicsDevice* device,
+  GraphicsDeviceInfo* device_info,
+  void*               driver_data,
+  void*               device_data
+)
+{
+  int              accel = dfb_gfxcard_get_accelerator( device );
+  STGFXDeviceData * const pDev = device_data;
+  STGFXDriverData * const pDrv = driver_data;
+
+  switch (accel)
+  {
+    case FB_ACCEL_ST_GAMMA:
+      snprintf( device_info->name, DFB_GRAPHICS_DEVICE_INFO_NAME_LENGTH, "Gamma" );
+      break;
+    case FB_ACCEL_ST_BDISP:
+      snprintf( device_info->name, DFB_GRAPHICS_DEVICE_INFO_NAME_LENGTH, "BDisp" );
+      break;
+    default:
+      break;
+  }
+
+  snprintf( device_info->vendor,
+    DFB_GRAPHICS_DEVICE_INFO_VENDOR_LENGTH,
+    "ST Microelectronics" );
+
+  dfb_config->pollvsync_after = true;
+
+  /* Tell DirectFB about what operations we may be able to do */
+  device_info->caps.flags    = CCF_NOTRIEMU;
+  device_info->caps.accel    = STGFX_VALID_DRAWINGFUNCTIONS | STGFX_VALID_BLITTINGFUNCTIONS;
+  device_info->caps.drawing  = STGFX_VALID_DRAWINGFLAGS;
+  device_info->caps.blitting = STGFX_VALID_BLITTINGFLAGS;
+
+  /* Give DirectFB info about our surface limitations */
+#if 0
+  /* real BDispII limitations */
+  device_info->limits.surface_byteoffset_alignment =  4;
+  device_info->limits.surface_bytepitch_alignment  =  2;
+#else
+  /* the 3D unit on 7108 has these limitations */
+  device_info->limits.surface_byteoffset_alignment = 64;
+  device_info->limits.surface_bytepitch_alignment  =  8;
+#endif
+  device_info->limits.surface_pixelpitch_alignment =  1;
+
+  if (dfb_system_type () == CORE_STMFBDEV)
+  {
+    extern const SurfacePoolFuncs _g_stmfbdevSurfacePoolFuncs;
+    STMfbdev     * const stmfbdev = dfb_system_data ();
+
+    D_MAGIC_ASSERT (stmfbdev, STMfbdev);
+
+    dfb_surface_pool_initialize (pDrv->core, &_g_stmfbdevSurfacePoolFuncs,
+                                 &pDev->pool);
+  }
+  /* aux pools */
+  stgfx1_surface_pool_init (pDrv->core, pDev->aux_pools,
+                            D_ARRAY_SIZE (pDev->aux_pools));
+
+  return DFB_OK;
+}
+
+
+/*************************************************/
+/* Do any hardware shutdown that may be required */
+/*************************************************/
+static void driver_close_device
+(
+  CoreGraphicsDevice* device,
+  void*               driver_data,
+  void*               device_data
+)
+{
+  STGFXDriverData *pDrv = (STGFXDriverData *) driver_data;
+  STGFXDeviceData *pDev = (STGFXDeviceData *) device_data;
+
+  if (dfb_system_type () == CORE_STMFBDEV)
+    dfb_surface_pool_destroy (pDev->pool);
+  stgfx1_surface_pool_destroy (pDrv->core, pDev->aux_pools,
+                               D_ARRAY_SIZE (pDev->aux_pools));
+}
+
+/*****************/
+/* Driver de-init*/
+/*****************/
+static void driver_close_driver
+(
+  CoreGraphicsDevice* device,
+  void*               driver_data
+)
+{
+  STGFXDriverData* pDrv = (STGFXDriverData*) driver_data;
+  STGFXDeviceData* pDev = pDrv->device_data;
+
+  if (!dfb_core_is_master (pDrv->core))
+  {
+    if (dfb_system_type () == CORE_STMFBDEV)
+      dfb_surface_pool_leave (pDev->pool);
+    stgfx1_surface_pool_leave (pDrv->core, pDev->aux_pools,
+                               D_ARRAY_SIZE (pDev->aux_pools));
+  }
+}
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/gfxdrivers/stgfx/stgfx.h DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx/stgfx.h
--- DirectFB/gfxdrivers/stgfx/stgfx.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx/stgfx.h	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,83 @@
+/*
+   (c) Copyright 2007,2009  STMicroelectronics.
+
+   All rights reserved.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <linux/stmfb.h>
+#include <core/coretypes.h>
+#include <core/screens.h>
+#include <core/layers.h>
+#include "stgfx2/stgfx_screen.h"
+#include "stgfx2/stgfx_primary.h"
+
+
+#define likely(x)       __builtin_expect(!!(x),1)
+#define unlikely(x)     __builtin_expect(!!(x),0)
+
+/* Structure for storing information about device state */
+typedef struct {
+  STMFB_GFXMEMORY_PARTITION srcMemBase;
+  unsigned long             srcPitch;
+  unsigned long             srcOffset;
+  SURF_FMT                  srcFormat;
+  unsigned long             srcPhys;
+  STMFB_GFXMEMORY_PARTITION dstMemBase;
+  unsigned long             dstPitch;
+  unsigned long             dstOffset;
+  SURF_FMT                  dstFormat;
+  unsigned long             dstPhys;
+  unsigned long blitColour;
+  unsigned long drawColour;
+  unsigned long srcColourKey;
+  unsigned long dstColourKey;
+  unsigned long globalAlpha;
+
+  DFBSurfaceBlendFunction srcBlendFunc;
+  DFBSurfaceBlendFunction dstBlendFunc;
+
+  DFBSurfaceDrawingFlags  drawingFlags;
+  DFBSurfaceBlittingFlags blittingFlags;
+
+  CorePalette   *palette;
+
+  bool           bBlendFromColorAlpha;
+  bool           bBlendFromSrcAlpha;
+  bool           bSrcPremultiply;
+  bool           bPremultColor;
+  bool           bNeedCLUTReload;
+
+  /* stmfbdev system */
+  CoreSurfacePool *pool;
+
+  CoreSurfacePool *aux_pools[STMFBGP_GFX_LAST - STMFBGP_GFX_FIRST + 1];
+  /* for exclusive use by bdisp_surface_pool.c */
+  unsigned int aux_pool_index;
+} STGFXDeviceData;
+
+
+/* Structure for storing information about driver state */
+typedef struct {
+  CoreDFB         *core;
+  STGFXDeviceData *device_data;
+  int              fd;
+
+  struct _STGFX2ScreenData screenData;
+  struct _STGFX2LayerData  layerData;
+
+} STGFXDriverData;
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/gfxdrivers/stgfx2/bdisp_accel.c DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/bdisp_accel.c
--- DirectFB/gfxdrivers/stgfx2/bdisp_accel.c	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/bdisp_accel.c	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,3971 @@
+/*
+   ST Microelectronics BDispII driver - hardware acceleration
+
+   (c) Copyright 2007-2010  STMicroelectronics Ltd.
+
+   All rights reserved.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+
+#include <string.h>
+#include <asm/unistd.h>
+
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+
+#include <linux/fb.h>
+#include <linux/stmfb.h>
+
+#include <directfb.h>
+#include <dfb_types.h>
+
+#include <core/coretypes.h>
+#include <core/gfxcard.h>
+#include <core/palette.h>
+#include <core/surface.h>
+
+#include <gfx/convert.h>
+
+
+#include "stgfx2_features.h"
+#include "bdisp_features.h"
+#include "bdisp_accel.h"
+#include "bdisp_accel_types.h"
+#define __IS_BDISP_ACCEL_C__
+#include "bdisp_tables.h"
+#undef __IS_BDISP_ACCEL_C__
+#include "bdisp_registers.h"
+#include "bdisp_state.h"
+#include "stm_gfxdriver.h"
+
+
+
+D_DEBUG_DOMAIN (BDISP_BLT,           "BDisp/blt",         "STM BDispII Drawing Engine");
+D_DEBUG_DOMAIN (BDISP_STRETCH,       "BDisp/strtch",      "STM BDispII stretch blits");
+D_DEBUG_DOMAIN (BDISP_STRETCH_SPANS, "BDisp/strtch/spns", "STM BDispII stretch blits (span generation)");
+D_DEBUG_DOMAIN (BDISP_STRETCH_FILT,  "BDisp/fltr",        "STM BDispII blit filters");
+D_DEBUG_DOMAIN (BDISP_NODES,         "BDisp/nodes",       "STM BDispII blit nodes");
+
+#if D_DEBUG_ENABLED
+#define DUMP_INFO() \
+  ( {                                                               \
+    const STMFBBDispSharedArea __attribute__((unused)) * const shared = stdrv->bdisp_shared; \
+    D_DEBUG_AT (BDISP_NODES,                                        \
+                "  -> %srunning CTL: %.8x IP/LNA/STA: %lu/%lu/%lu"  \
+                " next/last %lu/%lu\n",                             \
+                shared->bdisp_running ? "" : "not ",                \
+                bdisp_aq_GetAQReg (stdrv, stdev, BDISP_AQ_CTL),     \
+                (bdisp_aq_GetAQReg (stdrv, stdev, BDISP_AQ_IP) - shared->nodes_phys) / sizeof (struct _BltNode_Complete),  \
+                (bdisp_aq_GetAQReg (stdrv, stdev, BDISP_AQ_LNA) - shared->nodes_phys) / sizeof (struct _BltNode_Complete), \
+                (bdisp_aq_GetAQReg (stdrv, stdev, BDISP_AQ_STA) - shared->nodes_phys) / sizeof (struct _BltNode_Complete), \
+                shared->next_free, shared->last_free);              \
+  } )
+
+static void
+_dump_node (const struct _BltNodeGroup00 * const config_general)
+{
+  const struct _BltNodeGroup01 * const config_target =
+    (struct _BltNodeGroup01 *) (config_general + 1);
+  const void *pos = config_target + 1;
+
+  D_DEBUG_AT (BDISP_NODES,
+              "BLT_NIP  BLT_CIC  BLT_INS  BLT_ACK : %.8x %.8x %.8x %.8x\n",
+              config_general->BLT_NIP, config_general->BLT_CIC,
+              config_general->BLT_INS, config_general->BLT_ACK);
+  D_DEBUG_AT (BDISP_NODES,
+              "BLT_TBA  BLT_TTY  BLT_TXY  BLT_TSZ : %.8x %.8x %.8x %.8x\n",
+              config_target->BLT_TBA, config_target->BLT_TTY,
+              config_target->BLT_TXY, config_target->BLT_TSZ_S1SZ);
+
+  if (config_general->BLT_CIC & CIC_NODE_COLOR)
+    {
+      const struct _BltNodeGroup02 * const config_color = pos;
+      pos = config_color + 1;
+
+      D_DEBUG_AT (BDISP_NODES,
+                  "BLT_S1CF BLT_S2CF                  : %.8x %.8x\n",
+                  config_color->BLT_S1CF, config_color->BLT_S2CF);
+    }
+  if (config_general->BLT_CIC & CIC_NODE_SOURCE1)
+    {
+      const struct _BltNodeGroup03 * const config_source1 = pos;
+      pos = config_source1 + 1;
+
+      D_DEBUG_AT (BDISP_NODES,
+                  "BLT_S1BA BLT_S1TY BLT_S1XY         : %.8x %.8x %.8x\n",
+                  config_source1->BLT_S1BA, config_source1->BLT_S1TY,
+                  config_source1->BLT_S1XY);
+    }
+  if (config_general->BLT_CIC & CIC_NODE_SOURCE2)
+    {
+      const struct _BltNodeGroup04 * const config_source2 = pos;
+      pos = config_source2 + 1;
+
+      D_DEBUG_AT (BDISP_NODES,
+                  "BLT_S2BA BLT_S2TY BLT_S2XY BLT_S2SZ: %.8x %.8x %.8x %.8x\n",
+                  config_source2->BLT_S2BA, config_source2->BLT_S2TY,
+                  config_source2->BLT_S2XY, config_source2->BLT_S2SZ);
+    }
+  if (config_general->BLT_CIC & CIC_NODE_SOURCE3)
+    {
+      const struct _BltNodeGroup05 * const config_source3 = pos;
+      pos = config_source3 + 1;
+
+      D_DEBUG_AT (BDISP_NODES,
+                  "BLT_S3BA BLT_S3TY BLT_S3XY BLT_S3SZ: %.8x %.8x %.8x %.8x\n",
+                  config_source3->BLT_S3BA, config_source3->BLT_S3TY,
+                  config_source3->BLT_S3XY, config_source3->BLT_S3SZ);
+    }
+  if (config_general->BLT_CIC & CIC_NODE_CLIP)
+    {
+      const struct _BltNodeGroup06 * const config_clip = pos;
+      pos = config_clip + 1;
+
+      D_DEBUG_AT (BDISP_NODES,
+                  "BLT_CWO  BLT_CWS                   : %.8x %.8x\n",
+                  config_clip->BLT_CWO, config_clip->BLT_CWS);
+    }
+  if (config_general->BLT_CIC & CIC_NODE_CLUT)
+    {
+      const struct _BltNodeGroup07 * const config_clut = pos;
+      pos = config_clut + 1;
+
+      D_DEBUG_AT (BDISP_NODES,
+                  "BLT_CCO  BLT_CML                   : %.8x %.8x\n",
+                  config_clut->BLT_CCO, config_clut->BLT_CML);
+    }
+  if (config_general->BLT_CIC & CIC_NODE_FILTERS)
+    {
+      const struct _BltNodeGroup08 * const config_filters = pos;
+      pos = config_filters + 1;
+
+      D_DEBUG_AT (BDISP_NODES,
+                  "BLT_FCTL BLT_PMK                   : %.8x %.8x\n",
+                  config_filters->BLT_FCTL_RZC, config_filters->BLT_PMK);
+    }
+  if (config_general->BLT_CIC & CIC_NODE_2DFILTERSCHR)
+    {
+      const struct _BltNodeGroup09 * const config_2dfilterschr = pos;
+      pos = config_2dfilterschr + 1;
+
+      D_DEBUG_AT (BDISP_NODES,
+                  "BLT_RSF  BLT_RZI  BLT_HFP  BLT_VFP : %.8x %.8x %.8x %.8x\n",
+                  config_2dfilterschr->BLT_RSF, config_2dfilterschr->BLT_RZI,
+                  config_2dfilterschr->BLT_HFP, config_2dfilterschr->BLT_VFP);
+    }
+  if (config_general->BLT_CIC & CIC_NODE_2DFILTERSLUMA)
+    {
+      const struct _BltNodeGroup10 * const config_2dfiltersluma = pos;
+      pos = config_2dfiltersluma + 1;
+
+      D_DEBUG_AT (BDISP_NODES,
+                  "BLT_YRSF BLT_YRZI BLT_YHFP BLT_YVFP: %.8x %.8x %.8x %.8x\n",
+                  config_2dfiltersluma->BLT_Y_RSF, config_2dfiltersluma->BLT_Y_RZI,
+                  config_2dfiltersluma->BLT_Y_HFP, config_2dfiltersluma->BLT_Y_VFP);
+    }
+  if (config_general->BLT_CIC & CIC_NODE_FLICKER)
+    {
+      const struct _BltNodeGroup11 * const config_flicker = pos;
+      pos = config_flicker + 1;
+
+      D_DEBUG_AT (BDISP_NODES,
+                  "BLT_FF0  BLT_FF1  BLT_FF2  BLT_FF3 : %.8x %.8x %.8x %.8x\n",
+                  config_flicker->BLT_FF0, config_flicker->BLT_FF1,
+                  config_flicker->BLT_FF2, config_flicker->BLT_FF3);
+    }
+  if (config_general->BLT_CIC & CIC_NODE_COLORKEY)
+    {
+      const struct _BltNodeGroup12 * const config_ckey = pos;
+      pos = config_ckey + 1;
+
+      D_DEBUG_AT (BDISP_NODES,
+                  "BLT_KEY1 BLT_KEY2                  : %.8x %.8x\n",
+                  config_ckey->BLT_KEY1, config_ckey->BLT_KEY2);
+    }
+  if (config_general->BLT_CIC & CIC_NODE_STATIC)
+    {
+      const struct _BltNodeGroup14 * const config_static = pos;
+      pos = config_static + 1;
+
+      D_DEBUG_AT (BDISP_NODES,
+                  "BLT_SAR  BLT_USR                   : %.8x %.8x\n",
+                  config_static->BLT_SAR, config_static->BLT_USR);
+    }
+  if (config_general->BLT_CIC & CIC_NODE_IVMX)
+    {
+      const struct _BltNodeGroup15 * const config_ivmx = pos;
+      pos = config_ivmx + 1;
+
+      D_DEBUG_AT (BDISP_NODES,
+                  "BLT_IVMX BLT_IVMX BLT_IVMX BLT_IVMX: %.8x %.8x %.8x %.8x\n",
+                  config_ivmx->BLT_IVMX0, config_ivmx->BLT_IVMX1,
+                  config_ivmx->BLT_IVMX2, config_ivmx->BLT_IVMX3);
+    }
+  if (config_general->BLT_CIC & CIC_NODE_OVMX)
+    {
+      const struct _BltNodeGroup16 * const config_ovmx = pos;
+      pos = config_ovmx + 1;
+
+      D_DEBUG_AT (BDISP_NODES,
+                  "BLT_OVMX BLT_OVMX BLT_OVMX BLT_OVMX: %.8x %.8x %.8x %.8x\n",
+                  config_ovmx->BLT_OVMX0, config_ovmx->BLT_OVMX1,
+                  config_ovmx->BLT_OVMX2, config_ovmx->BLT_OVMX3);
+    }
+  if (config_general->BLT_CIC & CIC_NODE_VC1R)
+    {
+      const struct _BltNodeGroup18 * const config_vc1 = pos;
+      pos = config_vc1 + 1;
+
+      D_DEBUG_AT (BDISP_NODES,
+                  "BLT_VC1R                           : %.8x\n",
+                  config_vc1->BLT_VC1R);
+    }
+}
+#else
+#define DUMP_INFO() do {} while (0)
+static inline void
+_dump_node (const struct _BltNodeGroup00 * const config_general) { }
+#endif
+
+
+
+struct _BltNode_Common
+{
+  struct _BltNodeGroup00 ConfigGeneral; // 4 -> General
+  struct _BltNodeGroup01 ConfigTarget; // 4 -> Target
+  struct _BltNodeGroup02 ConfigColor; // 2 -> Color
+  struct _BltNodeGroup03 ConfigSource1; // 4 -> Source1
+  // total: 14 * 4 = 56
+#define CIC_BLT_NODE_COMMON   (0 \
+                               | CIC_NODE_COLOR   \
+                               | CIC_NODE_SOURCE1 \
+                              )
+};
+
+
+struct _BltNode_Fast
+{
+  struct _BltNode_Common common; // 14
+#ifdef STGFX2_IMPLEMENT_WAITSERIAL
+  struct _BltNodeGroup14 ConfigStatic; // 2
+#endif /* STGFX2_IMPLEMENT_WAITSERIAL */
+  // total: 14(+2) * 4 = 56(+8)
+#define CIC_BLT_NODE_FAST   (0 \
+                             | CIC_BLT_NODE_COMMON \
+                             | CIC_NODE_STATIC     \
+                            )
+};
+
+
+struct _BltNode_YCbCr422r_shortcut
+{
+  struct _BltNodeGroup00 ConfigGeneral;  // 4
+  struct _BltNodeGroup01 ConfigTarget;   // 4
+  struct _BltNodeGroup02 ConfigColor;    // 2
+  struct _BltNodeGroup04 ConfigSource2;  // 4
+#ifdef STGFX2_SUPPORT_HW_CLIPPING
+  struct _BltNodeGroup06 ConfigClip;     // 2
+#endif /* STGFX2_SUPPORT_HW_CLIPPING */
+#ifdef STGFX2_IMPLEMENT_WAITSERIAL
+  struct _BltNodeGroup14 ConfigStatic;   // 2
+#endif /* STGFX2_IMPLEMENT_WAITSERIAL */
+  struct _BltNodeGroup15 ConfigIVMX;     // 4
+  // total: 18(+2+2) * 4 = 72(+8+8)
+#define CIC_BLT_NODE_YCbCr422r_SHORTCUT (0 \
+                                         | CIC_NODE_COLOR   \
+                                         | CIC_NODE_SOURCE2 \
+                                         | CIC_NODE_CLIP    \
+                                         | CIC_NODE_STATIC  \
+                                         | CIC_NODE_IVMX    \
+                                        )
+};
+
+
+struct _BltNode_RGB32fixup
+{
+  struct _BltNodeGroup00 ConfigGeneral; // 4 -> General
+  struct _BltNodeGroup01 ConfigTarget; // 4 -> Target
+  struct _BltNodeGroup03 ConfigSource1; // 4 -> Source1
+  struct _BltNodeGroup08 ConfigFilters; // 2
+#ifdef STGFX2_IMPLEMENT_WAITSERIAL
+  struct _BltNodeGroup14 ConfigStatic; // 2
+#endif /* STGFX2_IMPLEMENT_WAITSERIAL */
+  // total: 11(+2) * 4 = 44(+8)
+#define CIC_BLT_NODE_RGB32fixup (0 \
+                                 | CIC_NODE_SOURCE1 \
+                                 | CIC_NODE_FILTERS \
+                                 | CIC_NODE_STATIC  \
+                                )
+};
+
+
+struct _BltNode_Complete
+{
+  struct _BltNode_Common common;  // 14
+
+  struct _BltNodeGroup04 ConfigSource2;     //  4
+  struct _BltNodeGroup05 ConfigSource3;     //  4
+  struct _BltNodeGroup06 ConfigClip;        //  2
+  struct _BltNodeGroup07 ConfigClut;        //  2
+  struct _BltNodeGroup08 ConfigFilters;     //  2
+  struct _BltNodeGroup09 ConfigFiltersChr;  //  4
+  struct _BltNodeGroup10 ConfigFiltersLuma; //  4
+  struct _BltNodeGroup11 ConfigFlicker;     //  4
+  struct _BltNodeGroup12 ConfigColorkey;    //  2
+  struct _BltNodeGroup13 ConfigXYL;         //  2
+  struct _BltNodeGroup14 ConfigStatic;      //  2
+  struct _BltNodeGroup15 ConfigIVMX;        //  4
+  struct _BltNodeGroup16 ConfigOVMX;        //  4
+  struct _BltNodeGroup17 ConfigPaceDot;     //  4
+  struct _BltNodeGroup18 ConfigVC1;         //  2
+  struct _BltNodeGroup19 ConfigGradient;    //  2
+  // total: 62 * 4 = 248
+};
+
+
+struct _BltNode_FullFill
+{
+  struct _BltNode_Common common; // 14
+
+  struct _BltNodeGroup04 ConfigSource2;  // 4
+  /* the following groups are not necessarily used, thus don't rely on
+     a 1:1 mapping of this struct in memory... */
+#ifdef STGFX2_SUPPORT_HW_CLIPPING
+  struct _BltNodeGroup06 ConfigClip;     // 2
+#endif /* STGFX2_SUPPORT_HW_CLIPPING */
+  struct _BltNodeGroup07 ConfigClut;     // 2
+  struct _BltNodeGroup08 ConfigFilters;  // 2
+  struct _BltNodeGroup12 ConfigColorkey; // 2
+#ifdef STGFX2_IMPLEMENT_WAITSERIAL
+  struct _BltNodeGroup14 ConfigStatic;   // 2
+#endif /* STGFX2_IMPLEMENT_WAITSERIAL */
+  struct _BltNodeGroup15 ConfigIVMX;     // 4
+  // max. total: 28(+2+2) * 4 = 112(+8+8)
+};
+
+
+static inline u32
+bdisp_aq_GetReg (const STGFX2DriverData * const stdrv,
+                 u16                     offset)
+{
+  return *(volatile u32 *) (stdrv->mmio_base + 0xa00 + offset);
+}
+
+static inline void
+bdisp_aq_SetReg (STGFX2DriverData * const stdrv,
+                 u16               offset,
+                 u32               value)
+{
+  *(volatile u32 *) (stdrv->mmio_base + 0xa00 + offset) = value;
+}
+
+static inline u32
+bdisp_aq_GetAQReg (const STGFX2DriverData * const stdrv,
+                   const STGFX2DeviceData * const stdev,
+                   u16                     offset)
+{
+  return bdisp_aq_GetReg (stdrv,
+                          offset + (BDISP_AQ1_BASE + (stdev->aq_index * 0x10))
+                         );
+}
+
+static inline void
+bdisp_aq_SetAQReg (STGFX2DriverData * const stdrv,
+                   const STGFX2DeviceData * const stdev,
+                   u16               offset,
+                   u32               value)
+{
+  bdisp_aq_SetReg (stdrv,
+                   offset + (BDISP_AQ1_BASE + (stdev->aq_index * 0x10)),
+                   value);
+}
+
+
+#define set_matrix(dst, src) \
+  ({ \
+    dst ## 0 = src[0]; \
+    dst ## 1 = src[1]; \
+    dst ## 2 = src[2]; \
+    dst ## 3 = src[3]; \
+  })
+
+DFBResult
+bdisp_aq_initialize (CoreGraphicsDevice * const device,
+                     GraphicsDeviceInfo * const device_info,
+                     STGFX2DriverData   * const stdrv,
+                     STGFX2DeviceData   * const stdev)
+{
+  struct _BltNode_Complete *node;
+  unsigned long             nip;
+  STMFBBDispSharedArea     *shared;
+
+  if (ioctl (stdrv->fd, STMFBIO_GET_SHARED_AREA, &stdev->bdisp_shared_info) < 0
+      || !stdev->bdisp_shared_info.physical
+      || !stdev->bdisp_shared_info.size)
+    return DFB_NOVIDEOMEMORY;
+
+  D_INFO ("BDisp/BLT: shared area phys/size: 0x%.8x/%u\n",
+          stdev->bdisp_shared_info.physical, stdev->bdisp_shared_info.size);
+
+  /* the actual shared area */
+  shared = stdrv->bdisp_shared = mmap (NULL,
+                                       sysconf (_SC_PAGESIZE),
+                                       PROT_READ | PROT_WRITE,
+                                       MAP_SHARED, stdrv->fd,
+                                       stdev->bdisp_shared_info.physical);
+  if (stdrv->bdisp_shared == MAP_FAILED)
+    {
+      D_PERROR ("BDisp/BLT: Could not map shared area!\n");
+      stdrv->bdisp_shared = NULL;
+      return DFB_INIT;
+    }
+
+  /* versions of stmfb < 0025 didn't report any version of the shared area
+     struct, but luckily initialized all the memory to 0xab. Thus we can check
+     for that and remain binary compatible with those versions of stmfb. */
+  if (shared->version == 0xabababab)
+    {
+      /* some trickery - we are not really allowed to do this... */
+      *((unsigned long *) &shared->version) = 0;
+      *((enum stm_blitter_device * ) &shared->device) = STM_BLITTER_VERSION_7200c2_7111_7141_7105;
+      /* those two were introduced in stmfb 0026, but luckily the layout of
+         the shared area struct changed, so we can just initialize them. */
+      shared->lock.counter = 0;
+      shared->locked_by = 0;
+    }
+
+  /* figure out available node size in bytes and align to a multiple of the
+     maximum size of a node */
+  stdev->usable_nodes_size = (shared->nodes_size / sizeof (*node)) * sizeof (*node);
+  stdev->node_irq_delay = (stdev->usable_nodes_size / sizeof (*node)) / 4;
+
+  /* figure out what specific implementation this is, and which features it
+     supports */
+  if (!bdisp_hw_features_set_bdisp (shared->device, &stdev->features))
+    {
+      D_INFO ("BDisp/BLT: blitter is %d (unknown)\n", shared->device);
+      return DFB_UNSUPPORTED;
+    }
+  D_INFO ("BDisp/BLT: blitter is a '%s' (%d)\n",
+          stdev->features.name, shared->device);
+
+  /* initialize shared area */
+  D_ASSUME (shared->bdisp_running == 0);
+  /* important stuff */
+  shared->bdisp_running
+    = shared->updating_lna = 0;
+  shared->prev_set_lna
+    = shared->last_lut = 0;
+  /* stats only */
+  shared->num_idle = shared->num_irqs = shared->num_lna_irqs
+    = shared->num_node_irqs = shared->num_ops_hi = shared->num_ops_lo
+    = shared->num_starts
+    = shared->num_wait_idle = shared->num_wait_next
+    = 0;
+
+
+  D_INFO ("BDisp/BLT: nodes area phys/size:  0x%.8lx/%lu (%lu usable -> %lu nodes)"
+          " -> ends @ 0x%.8lx\n",
+          shared->nodes_phys, shared->nodes_size, stdev->usable_nodes_size,
+          stdev->usable_nodes_size / sizeof (*node),
+          shared->nodes_phys + stdev->usable_nodes_size);
+
+  /* the DMA memory (nodelist, filters) */
+  stdrv->bdisp_nodes = mmap (NULL,
+                             (stdev->bdisp_shared_info.size
+                              - sysconf (_SC_PAGESIZE)),
+                             PROT_READ | PROT_WRITE,
+                             MAP_SHARED, stdrv->fd,
+                             (stdev->bdisp_shared_info.physical
+                              + sysconf (_SC_PAGESIZE)));
+  if (stdrv->bdisp_nodes == MAP_FAILED)
+    {
+      D_PERROR ("BDisp/BLT: Could not map nodes area!\n");
+      stdrv->bdisp_nodes = NULL;
+      return DFB_INIT;
+    }
+
+  D_INFO ("BDisp/BLT: shared area/nodes mmap()ed to %p / %p\n",
+          shared, stdrv->bdisp_nodes);
+
+  /* set nodelist to some sane defaults */
+  memset ((void *) stdrv->bdisp_nodes, 0, stdev->usable_nodes_size);
+  /* prelink all the buffer nodes around to make a circular list */
+  node = (void *) stdrv->bdisp_nodes;
+  nip = shared->nodes_phys + sizeof (*node);
+  while (((void *) node) < (stdrv->bdisp_nodes + stdev->usable_nodes_size - sizeof (*node)))
+    {
+      node->common.ConfigGeneral.BLT_NIP = nip;
+      node->common.ConfigGeneral.BLT_CIC = CIC_BLT_NODE_COMMON;
+      node->common.ConfigGeneral.BLT_INS = BLIT_INS_SRC1_MODE_DISABLED;
+
+      ++node;
+      nip += sizeof (*node);
+    }
+  /* last node points back to the first */
+  node->common.ConfigGeneral.BLT_NIP = shared->nodes_phys;
+  node->common.ConfigGeneral.BLT_CIC = CIC_BLT_NODE_COMMON;
+  node->common.ConfigGeneral.BLT_INS = BLIT_INS_SRC1_MODE_DISABLED;
+
+
+  /* we need some memory for some CLUTs and H/V filter coefficients, too.
+     The CLUTs need to be aligned to a 16byte address and the filters to an
+     8byte address. We have two types of CLUT here - a) a usual CLUT,
+     and b) CLUTs used for various types of color correction, e.g. for
+     supporting the RGB32 pixel format to force the alpha to be 0xff. */
+#define CLUT_SIZE (256 * sizeof (u32))
+  {
+  unsigned int   total_reserve;
+  unsigned int   siz_clut;
+  unsigned int   siz_8x8_filter;
+  unsigned int   siz_5x8_filter;
+
+  Stgfx2Clut     palette;
+  unsigned long *clut_virt;
+  int            ofs_clut;
+  unsigned char *filter_virt;
+  unsigned int   ofs_8x8_filter;
+  unsigned int   ofs_5x8_filter;
+
+  int            i;
+
+  siz_clut       = CLUT_SIZE * SG2C_COUNT;
+  siz_8x8_filter = D_ARRAY_SIZE (bdisp_aq_blitter_8x8_filters) * BDISP_AQ_BLIT_FILTER_8X8_TABLE_SIZE;
+  siz_5x8_filter = D_ARRAY_SIZE (bdisp_aq_blitter_5x8_filters) * BDISP_AQ_BLIT_FILTER_5X8_TABLE_SIZE;
+
+  total_reserve = siz_clut + siz_8x8_filter + siz_5x8_filter + 5;
+
+  /* CLUT needs to be 16byte aligned */
+  if (device_info->limits.surface_byteoffset_alignment < 16)
+    device_info->limits.surface_byteoffset_alignment = 16;
+
+  /* but else it's relatively simple, just reserve the memory... */
+  ofs_clut = dfb_gfxcard_reserve_memory (device, total_reserve);
+  if (ofs_clut <= 0)
+    {
+      D_ERROR ("BDisp/BLT: couldn't reserve %u bytes for CLUTs & H/V filter"
+               " memory!\n", total_reserve);
+      return DFB_NOVIDEOMEMORY;
+    }
+
+  D_INFO ("BDisp/BLT: reserved %u bytes for CLUT & filters @ "
+          "0x%.8lx + 0x%.8x = 0x%.8lx\n",
+          total_reserve,
+          dfb_gfxcard_memory_physical (device, 0), ofs_clut,
+          dfb_gfxcard_memory_physical (device, ofs_clut));
+
+  /* ...and prepare the color correction LUTs. The alpha range for LUTs is
+     0 ... 128 (not 127); this includes both, the lookup and the final value!
+
+  1) RGB32 -> Aout = 1, RGBout = RGBin */
+  stdev->clut_phys[SG2C_ONEALPHA_RGB] = dfb_gfxcard_memory_physical (device,
+                                                                     ofs_clut);
+  clut_virt = dfb_gfxcard_memory_virtual (device, ofs_clut);
+  for (i = 0; i <= 0x80; ++i)
+    clut_virt[i] = PIXEL_ARGB (0x80, i, i, i);
+  for (; i < 256; ++i)
+    clut_virt[i] = PIXEL_ARGB (0, i, i, i);
+  ofs_clut += CLUT_SIZE;
+
+  /* 2) Aout = 1 - Ain, RGBout = 0 */
+  stdev->clut_phys[SG2C_INVALPHA_ZERORGB] = dfb_gfxcard_memory_physical (device,
+                                                                         ofs_clut);
+  clut_virt = dfb_gfxcard_memory_virtual (device, ofs_clut);
+  for (i = 0; i <= 0x80; ++i)
+    clut_virt[i] = PIXEL_ARGB (0x80 - i, 0, 0, 0);
+  memset (&clut_virt[i], 0x00, CLUT_SIZE - (i * sizeof (u32)));
+  ofs_clut += CLUT_SIZE;
+
+  /* 3) Aout = Ain, RGBout = 0 */
+  stdev->clut_phys[SG2C_ALPHA_ZERORGB] = dfb_gfxcard_memory_physical (device,
+                                                                      ofs_clut);
+  clut_virt = dfb_gfxcard_memory_virtual (device, ofs_clut);
+  for (i = 0; i <= 0x80; ++i)
+    clut_virt[i] = PIXEL_ARGB (i, 0, 0, 0);
+  memset (&clut_virt[i], 0x00, CLUT_SIZE - (i * sizeof (u32)));
+  ofs_clut += CLUT_SIZE;
+
+  /* 4) Aout = 0, RGBout = RGBin */
+  stdev->clut_phys[SG2C_ZEROALPHA_RGB] = dfb_gfxcard_memory_physical (device,
+                                                                      ofs_clut);
+  clut_virt = dfb_gfxcard_memory_virtual (device, ofs_clut);
+  for (i = 0; i < 256; ++i)
+    clut_virt[i] = PIXEL_ARGB (0, i, i, i);
+  ofs_clut += CLUT_SIZE;
+
+  /* 5) Aout = 0, RGBout = 0 */
+  stdev->clut_phys[SG2C_ZEROALPHA_ZERORGB] = dfb_gfxcard_memory_physical (device,
+                                                                          ofs_clut);
+  clut_virt = dfb_gfxcard_memory_virtual (device, ofs_clut);
+  memset (clut_virt, 0, CLUT_SIZE);
+  ofs_clut += CLUT_SIZE;
+
+  /* 6) Aout = 1, RGBout = 0 */
+  stdev->clut_phys[SG2C_ONEALPHA_ZERORGB] = dfb_gfxcard_memory_physical (device,
+                                                                         ofs_clut);
+  clut_virt = dfb_gfxcard_memory_virtual (device, ofs_clut);
+  for (i = 0; i <= 0x80; ++i)
+    clut_virt[i] = PIXEL_ARGB (0x80, 0, 0, 0);
+  memset (&clut_virt[i], 0x00, CLUT_SIZE - (i * sizeof (u32)));
+  ofs_clut += CLUT_SIZE;
+
+
+  /* dynamic palettes */
+  /* Aout = coloralpha */
+  stdev->clut_offset[SG2C_COLORALPHA] = ofs_clut;
+  stdev->clut_phys[SG2C_COLORALPHA] = dfb_gfxcard_memory_physical (device,
+                                                                   ofs_clut);
+  stdrv->clut_virt[SG2C_COLORALPHA] = dfb_gfxcard_memory_virtual (device,
+                                                                  ofs_clut);
+  ofs_clut += CLUT_SIZE;
+
+  /* Aout = invcoloralpha */
+  stdev->clut_offset[SG2C_INVCOLORALPHA] = ofs_clut;
+  stdev->clut_phys[SG2C_INVCOLORALPHA] = dfb_gfxcard_memory_physical (device,
+                                                                      ofs_clut);
+  stdrv->clut_virt[SG2C_INVCOLORALPHA] = dfb_gfxcard_memory_virtual (device,
+                                                                     ofs_clut);
+  ofs_clut += CLUT_SIZE;
+
+  /* Aout = coloralpha */
+  stdev->clut_offset[SG2C_ALPHA_MUL_COLORALPHA] = ofs_clut;
+  stdev->clut_phys[SG2C_ALPHA_MUL_COLORALPHA] = dfb_gfxcard_memory_physical (device,
+                                                                             ofs_clut);
+  stdrv->clut_virt[SG2C_ALPHA_MUL_COLORALPHA] = dfb_gfxcard_memory_virtual (device,
+                                                                            ofs_clut);
+  ofs_clut += CLUT_SIZE;
+
+  /* Aout = invcoloralpha */
+  stdev->clut_offset[SG2C_INV_ALPHA_MUL_COLORALPHA] = ofs_clut;
+  stdev->clut_phys[SG2C_INV_ALPHA_MUL_COLORALPHA] = dfb_gfxcard_memory_physical (device,
+                                                                                 ofs_clut);
+  stdrv->clut_virt[SG2C_INV_ALPHA_MUL_COLORALPHA] = dfb_gfxcard_memory_virtual (device,
+                                                                                ofs_clut);
+  ofs_clut += CLUT_SIZE;
+
+  /* now for the 'normal' LUT. We need to remember the virtual address so we
+     can update it if necessary, of course. */
+  stdev->clut_offset[SG2C_NORMAL] = ofs_clut;
+  stdev->clut_phys[SG2C_NORMAL] = dfb_gfxcard_memory_physical (device,
+                                                               ofs_clut);
+  stdrv->clut_virt[SG2C_NORMAL] = dfb_gfxcard_memory_virtual (device, ofs_clut);
+  ofs_clut += CLUT_SIZE;
+
+  for (palette = SG2C_NORMAL; palette < SG2C_DYNAMIC_COUNT; ++palette)
+    D_INFO ("DirectFB/stgfx2: CLUT mmap()ed to %p\n",
+            stdrv->clut_virt[palette]);
+
+
+  /* the filter coeffs need to be copied into the filter area and later
+     don't ever need to be touched again. Except that we need to
+     remember the physical address to tell the BDisp later. */
+  ofs_8x8_filter = ofs_clut;
+  stdev->filter_8x8_phys = dfb_gfxcard_memory_physical (device, ofs_8x8_filter);
+  filter_virt = dfb_gfxcard_memory_virtual  (device, ofs_8x8_filter);
+  for (i = 0; i < D_ARRAY_SIZE (bdisp_aq_blitter_8x8_filters); ++i)
+    memcpy (&filter_virt[i * BDISP_AQ_BLIT_FILTER_8X8_TABLE_SIZE],
+            bdisp_aq_blitter_8x8_filters[i].filter_coeffs,
+            BDISP_AQ_BLIT_FILTER_8X8_TABLE_SIZE);
+
+  /* same for vertical filter coeffs. */
+  ofs_5x8_filter = ofs_8x8_filter + siz_8x8_filter;
+  stdev->filter_5x8_phys = dfb_gfxcard_memory_physical (device, ofs_5x8_filter);
+  filter_virt = dfb_gfxcard_memory_virtual  (device, ofs_5x8_filter);
+  for (i = 0; i < D_ARRAY_SIZE (bdisp_aq_blitter_5x8_filters); ++i)
+    memcpy (&filter_virt[i * BDISP_AQ_BLIT_FILTER_5X8_TABLE_SIZE],
+            bdisp_aq_blitter_5x8_filters[i].filter_coeffs,
+            BDISP_AQ_BLIT_FILTER_5X8_TABLE_SIZE);
+  }
+
+  /* the flicker filter coefficients don't ever change and are directly
+     mapped to registers, no physical memory is needed. */
+  stdev->ConfigFlicker = bdisp_aq_config_flicker_filter;
+
+  /* we don't use the static addresses registers, so we need to initialize
+     this one to 0, because we _do_ use the BLT_USR from the same register
+     group. */
+  stdev->ConfigStatic.BLT_SAR = 0;
+
+  stdev->ConfigColor.BLT_S1CF = 0;
+  stdev->ConfigColor.BLT_S2CF = 0;
+
+  stdev->ConfigFilters.BLT_PMK = 0x00ffffff;
+
+  set_matrix (stdev->ConfigOVMX.BLT_OVMX, bdisp_aq_RGB_2_VideoYCbCr601);
+
+  /* final init of shared area and BDisp registers */
+  shared->next_free = 0;
+  shared->last_free = stdev->usable_nodes_size - sizeof (*node);
+
+  stdev->aq_index = shared->aq_index;
+
+  bdisp_aq_SetAQReg (stdrv,
+                     stdev,
+                     BDISP_AQ_CTL,
+                     (3 - shared->aq_index) | (0
+                                               | BDISP_AQ_CTL_QUEUE_EN
+                                               | BDISP_AQ_CTL_EVENT_SUSPEND
+                                               | BDISP_AQ_CTL_IRQ_NODE_COMPLETED
+                                               | BDISP_AQ_CTL_IRQ_LNA_REACHED
+                                              )
+                    );
+
+  /* no blit will start until the LNA register is written to */
+  bdisp_aq_SetAQReg (stdrv, stdev, BDISP_AQ_IP, shared->nodes_phys);
+
+  return DFB_OK;
+}
+
+/*********************************************/
+/* Reset the device                          */
+/*********************************************/
+void
+bdisp_aq_EngineReset (void * const drv,
+                      void * const dev)
+{
+#if 0
+  printf("%s: drv/dev: %p/%p\n", __FUNCTION__, drv, dev);
+
+  /* don't do this! it resets too much! */
+  STGFX2DriverData * const stdrv = drv;
+
+  bdisp_aq_SetReg (stdrv, BDISP_CTL, (1 << 31) /* BDISP_CTL_GLOBAL_SOFT_RESET */ );
+  bdisp_aq_SetReg (stdrv, BDISP_CTL, 0);
+  while (!(bdisp_aq_GetReg (stdrv, BDISP_STA) & 0x1))
+    usleep (1);
+#endif
+}
+
+DFBResult
+bdisp_aq_EngineSync (void * const drv,
+                     void * const dev)
+{
+  STGFX2DriverData     * const stdrv = drv;
+  STGFX2DeviceData     * const stdev = dev;
+  STMFBBDispSharedArea * const shared = stdrv->bdisp_shared;
+  DFBResult             ret = DFB_OK;
+
+  D_DEBUG_AT (BDISP_BLT, "%s()\n", __FUNCTION__);
+
+  DUMP_INFO ();
+
+  /* can't lock here, because the ioctl() does another lock which might have
+     been taken by somebody else. */
+//  LOCK_ATOMIC_DEBUG_ONLY;
+
+  while (shared->bdisp_running && ioctl (stdrv->fd, STMFBIO_SYNC_BLITTER) < 0)
+    {
+      if (errno == EINTR)
+        continue;
+
+      ret = errno2result (errno);
+      D_PERROR ("BDisp/BLT: STMFBIO_SYNC_BLITTER failed!\n" );
+
+      direct_log_printf (NULL, "  -> %srunning, CTL: %.8x IP/LNA/STA: %lu/%lu/%lu"
+                         " next/last %lu/%lu\n",
+                         shared->bdisp_running ? "" : "not ",
+                         bdisp_aq_GetAQReg (stdrv, stdev, BDISP_AQ_CTL),
+                         (bdisp_aq_GetAQReg (stdrv, stdev, BDISP_AQ_IP) - shared->nodes_phys) / sizeof (struct _BltNode_Complete),
+                         (bdisp_aq_GetAQReg (stdrv, stdev, BDISP_AQ_LNA) - shared->nodes_phys) / sizeof (struct _BltNode_Complete),
+                         (bdisp_aq_GetAQReg (stdrv, stdev, BDISP_AQ_STA) - shared->nodes_phys) / sizeof (struct _BltNode_Complete),
+                         shared->next_free, shared->last_free);
+
+      break;
+    }
+
+  /* need the LOCK_ATOMIC around the ioctl() and this assertion */
+//  if (ret == DFB_OK)
+//    D_ASSERT (!shared->bdisp_running);
+
+//  UNLOCK_ATOMIC_DEBUG_ONLY;
+
+  return ret;
+}
+
+
+static void
+bdisp_aq_WaitSpace (STGFX2DriverData     * const stdrv,
+                    STGFX2DeviceData     * const stdev,
+                    STMFBBDispSharedArea * const shared)
+{
+  D_DEBUG_AT (BDISP_BLT, "%s()\n", __FUNCTION__);
+
+  DUMP_INFO ();
+
+  if (!shared->bdisp_running)
+    return;
+
+  while (ioctl (stdrv->fd, STMFBIO_WAIT_NEXT) < 0)
+    {
+      if (errno == EINTR)
+        continue;
+
+      D_PERROR ("BDisp/BLT: STMFBIO_WAIT_NEXT failed!\n" );
+
+//      direct_log_printf (NULL, "  -> %srunning, CTL: %.8x IP/LNA/STA: %lu/%lu/%lu"
+//                         " next/last %lu/%lu\n",
+//                         shared->bdisp_running ? "" : "not ",
+//                         bdisp_aq_GetAQReg (stdrv, stdev, BDISP_AQ_CTL),
+//                         (bdisp_aq_GetAQReg (stdrv, stdev, BDISP_AQ_IP) - shared->nodes_phys) / sizeof (struct _BltNode_Complete),
+//                         (bdisp_aq_GetAQReg (stdrv, stdev, BDISP_AQ_LNA) - shared->nodes_phys) / sizeof (struct _BltNode_Complete),
+//                         (bdisp_aq_GetAQReg (stdrv, stdev, BDISP_AQ_STA) - shared->nodes_phys) / sizeof (struct _BltNode_Complete),
+//                         shared->next_free, shared->last_free);
+
+      break;
+    }
+}
+
+/* FIXME: 'synco' is only available starting w/ ST-300 series, i.e.
+   not STb7109 and it is not understood by the STLinux-2.2 binutils! */
+#ifdef __SH4__
+#  define mb() __asm__ __volatile__ ("synco" : : : "memory")
+#else
+#  define mb() __asm__ __volatile__ ("" : : : "memory")
+#endif
+
+#if 1
+#define LOCK_ATOMIC \
+  { \
+  while (unlikely (!__sync_bool_compare_and_swap (&shared->lock.counter, 0, 1))) \
+    usleep(1); \
+  if (unlikely (shared->locked_by)) \
+    D_WARN ("locked an already locked lock by %x\n", shared->locked_by); \
+  shared->locked_by = 2; \
+  }
+
+#define UNLOCK_ATOMIC \
+  { \
+  if (unlikely (shared->locked_by != 2)) \
+    D_WARN ("shared->locked_by error (%x)!\n", shared->locked_by); \
+  shared->locked_by = 0 ; \
+  mb(); \
+  shared->lock.counter = 0; \
+  }
+//  __sync_fetch_and_sub (&shared->lock.counter, 1);
+//  while (unlikely (!__sync_bool_compare_and_swap (&shared->lock.counter, 1, 0))) {
+//    printf("sleeping2...\n");
+//  }
+#else
+#define LOCK_ATOMIC ({})
+#define UNLOCK_ATOMIC ({})
+#endif
+
+static void
+_bdisp_aq_EmitCommands (void * const drv,
+                        void * const dev,
+                        bool  is_locked)
+{
+  STGFX2DriverData     * const stdrv = drv;
+  STGFX2DeviceData     * const stdev = dev;
+  STMFBBDispSharedArea * const shared = stdrv->bdisp_shared;
+  unsigned long         new_last_valid;
+
+  if (!is_locked)
+    LOCK_ATOMIC;
+
+  new_last_valid = ((shared->next_free ? shared->next_free : stdev->usable_nodes_size)
+                    - sizeof (struct _BltNode_Complete)
+                    + shared->nodes_phys);
+
+  D_DEBUG_AT (BDISP_BLT, "%s() old/new last valid: %.8lx/%.8lx\n", __FUNCTION__,
+              shared->prev_set_lna, new_last_valid);
+
+  /* have any been added since last time we were called? This test is
+     necessary because an operation like FillRect() might fail, without
+     actually queueing _any_ node (or FillRect_nop() which intentionally
+     doesn't queue anything). Ignoring this case, we would set
+     bdisp_running to true, and at some later point wait for the interrupt
+     to signal completion. Since LNA wouldn't have changed, the interrupt
+     would never be fired, and the kernel driver would sleep forever
+     waiting for bdisp_running to be false again. */
+  if (new_last_valid != shared->prev_set_lna)
+    {
+      ++shared->num_starts;
+
+      /* signal to kernel driver that we are in the process of updating
+         BDISP_AQ_LNA and want bdisp_running to be left untouched, which is
+         important in case we are interrupted between setting bdisp_running
+         = true and the actual writing to the register. */
+      shared->updating_lna = true;
+      shared->prev_set_lna = new_last_valid;
+
+      /* Make sure updating_lna and prev_set_lna are set before
+         bdisp_running! */
+      mb ();
+
+#ifdef STGFX2_MEASURE_BLITLOAD
+      if (!shared->bdisp_running)
+        {
+          struct timespec currenttime;
+#define USEC_PER_SEC	1000000L
+          clock_gettime (CLOCK_MONOTONIC, &currenttime);
+          shared->bdisp_ops_start_time = (((unsigned long long) currenttime.tv_sec * USEC_PER_SEC)
+                                          + (currenttime.tv_nsec / 1000));
+        }
+#endif /* STGFX2_MEASURE_BLITLOAD */
+
+      shared->bdisp_running = true;
+
+#ifdef __SH4__
+      /* LMI write posting: make sure outstanding writes to LMI made it into
+         RAM, mb() doesn't help, because of the ST40 bandwidth limiter */
+      {
+      u32 offs = shared->prev_set_lna - shared->nodes_phys;
+      volatile struct _BltNodeGroup00 * const ConfigGeneral = (struct _BltNodeGroup00 *) (stdrv->bdisp_nodes + offs);
+      u32 nip = ConfigGeneral->BLT_NIP;
+      D_ASSERT (shared->next_free == nip - shared->nodes_phys);
+      shared->next_free = nip - shared->nodes_phys;
+      }
+#endif
+
+      /* The idea of this second barrier here is to make sure bdisp_running is
+         set before the register, just to make sure the IRQ is not fired for
+         this new command while bdisp_running gets set to true only later,
+         because of instruction scheduling. The probability of such a
+         situation happening should be around zero, but what the heck... */
+      mb ();
+
+      /* kick */
+      bdisp_aq_SetAQReg (stdrv, stdev, BDISP_AQ_LNA, new_last_valid);
+
+      /* we're done */
+      shared->updating_lna = false;
+    }
+
+  /* unconditionally unlock */
+  UNLOCK_ATOMIC;
+}
+
+void
+bdisp_aq_EmitCommands (void * const drv,
+                       void * const dev)
+{
+  _bdisp_aq_EmitCommands (drv, dev, false);
+}
+
+
+
+void
+bdisp_aq_GetSerial (void               * const drv,
+                    void               * const dev,
+                    CoreGraphicsSerial * const serial)
+{
+  const STMFBBDispSharedArea * const shared =
+                                     ((STGFX2DriverData *) drv)->bdisp_shared;
+
+//printf("getserial -> %lu\n", shared->num_ops_lo);
+
+  serial->generation = shared->num_ops_hi;
+  serial->serial     = shared->num_ops_lo;
+}
+
+
+DFBResult
+bdisp_aq_WaitSerial (void                     * const drv,
+                     void                     * const dev,
+                     const CoreGraphicsSerial * const serial)
+{
+  STGFX2DriverData     * const stdrv = drv;
+  STMFBBDispSharedArea * const shared = stdrv->bdisp_shared;
+
+  /* FIXME: make this work w/ num_ops_hi != 0, too */
+  if (!shared->num_ops_hi
+      || serial->serial >= shared->num_ops_lo)
+    {
+      u32 usr = bdisp_aq_GetReg (stdrv, 0x200 + 0xb4 /* BLT_USR */ );
+      while (usr < serial->serial)// shared->num_ops_lo && !shared->num_ops_hi)
+        {
+//printf("waitserial -> %lu, ops %lu", serial->serial, shared->num_ops_lo);
+//printf("   -> usr %lu\n", usr);
+//          bdisp_aq_WaitSpace (drv, dev, ((STGFX2DriverData *) drv)->bdisp_shared);
+          usr = bdisp_aq_GetReg (stdrv, 0x200 + 0xb4 /* BLT_USR */ );
+        }
+    }
+  else
+    bdisp_aq_EngineSync (drv, dev);
+
+  return DFB_OK;
+}
+
+
+
+
+
+#ifdef STGFX2_USE_BSEARCH
+#include <stdlib.h>
+static int
+_filter_table_lookup (const void * const key,
+                      const void * const member)
+{
+  const struct _bdisp_aq_blitfilter_coeffs_range * const range = member;
+  int                                             scale = (int) key;
+
+  if (scale <= range->scale_min)
+    return -1;
+
+  if (scale > range->scale_max)
+    return 1;
+
+  return 0;
+}
+
+static int
+CSTmBlitter__ChooseBlitter5x8FilterCoeffs (int scale)
+{
+  const struct _bdisp_aq_blitfilter_coeffs_5x8 * const res =
+    bsearch ((void *) scale,
+             bdisp_aq_blitter_5x8_filters,
+             D_ARRAY_SIZE (bdisp_aq_blitter_5x8_filters),
+             sizeof (*bdisp_aq_blitter_5x8_filters),
+             _filter_table_lookup);
+
+  if (!res)
+    return D_ARRAY_SIZE (bdisp_aq_blitter_5x8_filters) - 1;
+
+  return res - bdisp_aq_blitter_5x8_filters;
+}
+
+static int
+CSTmBlitter__ChooseBlitter8x8FilterCoeffs (int scale)
+{
+  const struct _bdisp_aq_blitfilter_coeffs_8x8 * const res =
+    bsearch ((void *) scale,
+             bdisp_aq_blitter_8x8_filters,
+             D_ARRAY_SIZE (bdisp_aq_blitter_8x8_filters),
+             sizeof (*bdisp_aq_blitter_8x8_filters),
+             _filter_table_lookup);
+
+  if (!res)
+    return D_ARRAY_SIZE (bdisp_aq_blitter_8x8_filters) - 1;
+
+  return res - bdisp_aq_blitter_8x8_filters;
+}
+#else
+static int
+CSTmBlitter__ChooseBlitter5x8FilterCoeffs (int scale)
+{
+  int i;
+
+  if (scale <= 0)
+    return -1;
+
+  for (i = 0; i < D_ARRAY_SIZE (bdisp_aq_blitter_5x8_filters); ++i)
+    if ((scale <= bdisp_aq_blitter_5x8_filters[i].range.scale_max)
+        && (scale > bdisp_aq_blitter_5x8_filters[i].range.scale_min))
+      return i;
+
+  return D_ARRAY_SIZE (bdisp_aq_blitter_5x8_filters) - 1;
+}
+
+static int
+CSTmBlitter__ChooseBlitter8x8FilterCoeffs (int scale)
+{
+  int i;
+
+  if (scale <= 0)
+    return -1;
+
+  for (i = 0; i < D_ARRAY_SIZE (bdisp_aq_blitter_8x8_filters); ++i)
+    if ((scale <= bdisp_aq_blitter_8x8_filters[i].range.scale_max)
+        && (scale > bdisp_aq_blitter_8x8_filters[i].range.scale_min))
+      return i;
+
+  return D_ARRAY_SIZE (bdisp_aq_blitter_8x8_filters) - 1;
+}
+#endif /* STGFX2_USE_BSEARCH */
+
+
+static void
+CSTmBlitter__SetCLUTOperation (const STGFX2DriverData * const stdrv,
+                               STGFX2DeviceData       * const stdev,
+                               bool                    do_expand,
+                               u32                    * const blt_cic,
+                               u32                    * const blt_ins,
+                               struct _BltNodeGroup07 * const config_clut)
+{
+  *blt_cic |= CIC_NODE_CLUT;
+  *blt_ins |= BLIT_INS_ENABLE_CLUT;
+
+#ifdef STGFX2_CLUT_UNSAFE_MULTISESSION
+  stdrv->bdisp_shared->last_lut = 1;
+#endif /* STGFX2_CLUT_UNSAFE_MULTISESSION */
+
+  config_clut->BLT_CCO &= ~BLIT_CCO_CLUT_MODE_MASK;
+  config_clut->BLT_CCO |= (do_expand ? BLIT_CCO_CLUT_EXPAND
+                                     : BLIT_CCO_CLUT_CORRECT);
+
+  config_clut->BLT_CCO |= BLIT_CCO_CLUT_UPDATE_EN;
+
+  config_clut->BLT_CML = stdev->clut_phys[stdev->palette_type];
+}
+
+
+
+#ifdef STGFX2_PRINT_NODE_WAIT_TIME
+
+  #define bdisp_aq_WaitSpace_start_timer() \
+            ({                             \
+              struct timeval start, end;   \
+              gettimeofday (&start, NULL);
+
+  #define bdisp_aq_WaitSpace_end_timer() \
+              gettimeofday (&end, NULL);                               \
+              timersub (&end, &start, &end);                           \
+              D_INFO ("BDisp/BLT: had to wait for space %lu.%06lus\n", \
+                      end.tv_sec, end.tv_usec);                        \
+            })
+
+#else /* STGFX2_PRINT_NODE_WAIT_TIME */
+
+  #define bdisp_aq_WaitSpace_start_timer() \
+            ({
+
+  #define bdisp_aq_WaitSpace_end_timer() \
+            })
+
+#endif /* STGFX2_PRINT_NODE_WAIT_TIME */
+
+
+/* get a pointer to the next unused node in the nodelist. Will _not_ mark
+   the returned node as being used. I.e. you must call
+   _bdisp_aq_finish_node() on this node before requesting another node. */
+static void *
+_bdisp_aq_get_new_node (STGFX2DriverData     * const stdrv,
+                        STGFX2DeviceData     * const stdev,
+                        STMFBBDispSharedArea * const shared)
+{
+  D_ASSERT (shared == stdrv->bdisp_shared);
+
+  LOCK_ATOMIC;
+
+  /* if this is the last free entry in the list, kick the bdisp and wait a
+     bit. Need to be careful to not create deadlocks. */
+  if (unlikely (shared->next_free == shared->last_free))
+    {
+      bdisp_aq_WaitSpace_start_timer ();
+
+restart:
+      _bdisp_aq_EmitCommands (stdrv, stdev, true);
+      /* _bdisp_aq_EmitCommands() unlocks the lock for us on exit */
+
+      bdisp_aq_WaitSpace (stdrv, stdev, shared);
+      LOCK_ATOMIC;
+
+      if (shared->next_free == shared->last_free)
+        goto restart;
+
+      bdisp_aq_WaitSpace_end_timer ();
+    }
+
+  return (void *) stdrv->bdisp_nodes + shared->next_free;
+}
+
+/* tell the node list handling, that we are done with this node, i.e. it is
+   valid and the next node should be used for new commands. Doesn't enqueue
+   the node to the hardware, just updates an 'internal' pointer. */
+static void
+_bdisp_aq_finish_node (STGFX2DriverData     * const stdrv,
+                       STGFX2DeviceData     * const stdev,
+                       STMFBBDispSharedArea * const shared,
+                       const void           * const node)
+{
+  D_ASSERT (shared == stdrv->bdisp_shared);
+  D_ASSERT (node == (stdrv->bdisp_nodes + shared->next_free));
+
+  _dump_node (node);
+
+  /* we need to update shared->next_free:
+     - either we could read back node->BLT_NIP and set
+       shared->next_free = nip - shared->nodes_phys
+       i.e.
+       volatile struct _BltNodeGroup00 * const ConfigGeneral = (struct _BltNodeGroup00 *) node;
+       u32 nip = ConfigGeneral->BLT_NIP;
+       shared->next_free = nip - shared->nodes_phys;
+
+     - or calculate shared->next_free, because we know the size of one node
+       (see bdisp_aq_initialize())
+
+     The former has the advantage of being a nice memory barrier in case the
+     nodelist area is mmap()ed cached (but currently we don't do so), while
+     the latter has the advantage of not having to read back from (at the
+     moment) uncached memory. So we calculate... In addition, on the ST40
+     due to write posting, we need a read from LMI in any case to make sure
+     any previous writes have been completed, but that read is done in another
+     place, namely in _bdisp_aq_EmitCommands(). */
+
+  /* advance to next */
+  shared->next_free += sizeof (struct _BltNode_Complete);
+  if (unlikely (shared->next_free == stdev->usable_nodes_size))
+    shared->next_free = 0;
+
+  DUMP_INFO ();
+
+  UNLOCK_ATOMIC;
+}
+
+
+#define COPY_TO_NODE_SZ(n, addr, size)    \
+            ({                            \
+              memcpy (n, (addr), (size)); \
+              n += (size);                \
+            })
+#define COPY_TO_NODE(n, strct)                      \
+            ({                                      \
+              memcpy (n, &(strct), sizeof (strct)); \
+              n += sizeof (strct);                  \
+            })
+
+
+#define bdisp_aq_update_num_ops(stdev, shared, blt_ins) \
+            ({ \
+              /* we have a counter for the number of total operations */     \
+              if (unlikely (! ++shared->num_ops_lo))                         \
+                ++shared->num_ops_hi;                                        \
+              /* every now and then we want to see a 'node completed'        \
+                 interrupt (in addition to the usual 'queue completed'       \
+                 interrupt), so we don't have to wait for the queue to be    \
+                 completely empty when adding a node. But it also shouldn't  \
+                 occur too often so as to not waste too much CPU time in the \
+                 interrupt handler... */                                     \
+              if (!(shared->num_ops_lo % stdev->node_irq_delay))             \
+                blt_ins |= BLIT_INS_ENABLE_BLITCOMPIRQ;                      \
+            })
+
+#ifdef STGFX2_IMPLEMENT_WAITSERIAL
+  #define bdisp_aq_update_config_static(shared, group14) \
+            ({ \
+              (group14)->BLT_SAR = 0;                  \
+              (group14)->BLT_USR = shared->num_ops_lo; \
+            })
+#else /* STGFX2_IMPLEMENT_WAITSERIAL */
+  #define bdisp_aq_update_config_static(shared, group14)
+#endif /* STGFX2_IMPLEMENT_WAITSERIAL */
+
+#ifdef STGFX2_CLUT_UNSAFE_MULTISESSION
+  #define bdisp_aq_clut_update_disable_if_unsafe(stdev) \
+        ({ \
+          if (!stdev->clut_disabled)                                        \
+            {                                                               \
+              stdev->ConfigGeneral.BLT_INS &= ~BLIT_INS_ENABLE_BLITCOMPIRQ; \
+              stdev->ConfigClut.BLT_CCO    &= ~BLIT_CCO_CLUT_UPDATE_EN;     \
+              stdev->clut_disabled = true;                                  \
+            }                                                               \
+        })
+#else /* STGFX2_CLUT_UNSAFE_MULTISESSION */
+  #define bdisp_aq_clut_update_disable_if_unsafe(stdev)
+#endif /* STGFX2_CLUT_UNSAFE_MULTISESSION */
+
+
+static void
+bdisp_aq_copy_n_push_node (STGFX2DriverData * const stdrv,
+                           STGFX2DeviceData * const stdev)
+{
+  unsigned char *node;
+  struct _BltNodeGroup00 *ConfigGeneral;
+  u32                     valid_groups;
+  STMFBBDispSharedArea   * const shared = stdrv->bdisp_shared;
+
+#ifdef STGFX2_IMPLEMENT_WAITSERIAL
+  stdev->ConfigGeneral.BLT_CIC |= CIC_NODE_STATIC;
+#endif /* STGFX2_IMPLEMENT_WAITSERIAL */
+
+  ConfigGeneral = _bdisp_aq_get_new_node (stdrv, stdev, shared);
+
+  stdev->ConfigGeneral.BLT_CIC |= stdev->all_states.extra_blt_cic;
+  stdev->ConfigGeneral.BLT_INS |= stdev->all_states.extra_blt_ins;
+  bdisp_aq_update_num_ops (stdev, shared, stdev->ConfigGeneral.BLT_INS);
+
+  valid_groups = stdev->ConfigGeneral.BLT_CIC;
+
+  /* now copy the individual groups into the free node item of the nodelist */
+  node = ((unsigned char *) ConfigGeneral) + sizeof (u32);
+  COPY_TO_NODE_SZ (node,
+                   ((void *) &stdev->ConfigGeneral) + sizeof (u32),
+                   sizeof (stdev->ConfigGeneral) - sizeof (u32));
+  stdev->ConfigGeneral.BLT_INS &= ~(BLIT_INS_ENABLE_BLITCOMPIRQ
+                                    | stdev->all_states.extra_blt_ins);
+  stdev->ConfigGeneral.BLT_CIC &= ~stdev->all_states.extra_blt_cic;
+
+  COPY_TO_NODE (node, stdev->ConfigTarget);
+
+  if (valid_groups & CIC_NODE_COLOR)
+    COPY_TO_NODE (node, stdev->ConfigColor);
+
+  if (valid_groups & CIC_NODE_SOURCE1)
+    COPY_TO_NODE (node, stdev->ConfigSource1);
+
+  if (valid_groups & CIC_NODE_SOURCE2)
+    COPY_TO_NODE (node, stdev->ConfigSource2);
+
+  if (valid_groups & CIC_NODE_SOURCE3)
+    COPY_TO_NODE (node, stdev->ConfigSource3);
+
+#ifdef STGFX2_SUPPORT_HW_CLIPPING
+  if (valid_groups & CIC_NODE_CLIP)
+    COPY_TO_NODE (node, stdev->ConfigClip);
+#endif
+
+  if (valid_groups & CIC_NODE_CLUT)
+    COPY_TO_NODE (node, stdev->ConfigClut);
+
+  if (valid_groups & CIC_NODE_FILTERS)
+    COPY_TO_NODE (node, stdev->ConfigFilters);
+
+  if (valid_groups & CIC_NODE_2DFILTERSCHR)
+    COPY_TO_NODE (node, stdev->ConfigFiltersChr);
+
+  if (valid_groups & CIC_NODE_2DFILTERSLUMA)
+    COPY_TO_NODE (node, stdev->ConfigFiltersLuma);
+
+  if (valid_groups & CIC_NODE_FLICKER)
+    COPY_TO_NODE (node, stdev->ConfigFlicker);
+
+  if (valid_groups & CIC_NODE_COLORKEY)
+    COPY_TO_NODE (node, stdev->ConfigColorkey);
+
+#ifdef STGFX2_IMPLEMENT_WAITSERIAL
+  if (likely (valid_groups & CIC_NODE_STATIC))
+    {
+      bdisp_aq_update_config_static (shared, &stdev->ConfigStatic);
+      COPY_TO_NODE (node, stdev->ConfigStatic);
+    }
+#endif
+
+  if (valid_groups & CIC_NODE_IVMX)
+    COPY_TO_NODE (node, stdev->ConfigIVMX);
+
+  if (valid_groups & CIC_NODE_OVMX)
+    COPY_TO_NODE (node, stdev->ConfigOVMX);
+
+#if 0
+  if (valid_groups & CIC_NODE_VC1R)
+    COPY_TO_NODE (node, stdev->ConfigVC1R);
+#endif
+
+  _bdisp_aq_finish_node (stdrv, stdev, shared, ConfigGeneral);
+}
+
+
+bool
+bdisp_aq_FillDraw_nop (void         * const drv,
+                       void         * const dev,
+                       DFBRectangle * const rect)
+{
+  const STGFX2DriverData __attribute__((unused)) * const stdrv = drv;
+  const STGFX2DeviceData __attribute__((unused)) * const stdev = dev;
+
+  D_DEBUG_AT (BDISP_BLT, "%s (%d, %d - %dx%d)\n", __FUNCTION__,
+              DFB_RECTANGLE_VALS (rect));
+  DUMP_INFO ();
+
+  return true;
+}
+
+
+
+#if 0
+static bool
+CSTmBDispAQ__SetPlaneMask (const enum STM_BLITTER_FLAGS  flags,
+                           const unsigned long           plane_mask,
+                           u32                          * const blt_cic,
+                           u32                          * const blt_ins,
+                           u32                          * const blt_pmk)
+{
+  if (!D_FLAGS_IS_SET (flags, STM_BLITTER_FLAGS_PLANE_MASK))
+    return true;
+
+  if (unlikely ((*blt_ins & BLIT_INS_SRC1_MODE_MASK) == BLIT_INS_SRC1_MODE_COLOR_FILL))
+    {
+      D_DEBUG ("%s(): cannot use plane masking and blend against a solid colour\n",
+               __FUNCTION__);
+      return false;
+    }
+
+  *blt_cic |= CIC_NODE_FILTERS;
+  *blt_ins &= ~BLIT_INS_SRC1_MODE_MASK;
+  *blt_ins |= BLIT_INS_ENABLE_PLANEMASK | BLIT_INS_SRC1_MODE_MEMORY;
+
+  *blt_pmk = plane_mask;
+
+  return true;
+}
+#endif
+
+
+#ifdef STGFX2_SUPPORT_HW_CLIPPING
+static void
+bdisp_aq_SetClip (const STGFX2DeviceData * const stdev,
+                  u32                    * const blt_cic,
+                  u32                    * const blt_ins,
+                  struct _BltNodeGroup06 * const config_clip)
+{
+  if (stdev->v_flags & 0x00000002 /* CLIP */)
+    {
+      *blt_cic |= CIC_NODE_CLIP;
+      *blt_ins |= BLIT_INS_ENABLE_RECTCLIP;
+      *config_clip = stdev->ConfigClip;
+    }
+}
+#else
+  #define bdisp_aq_SetClip(dev, cic, ins, clip)
+#endif
+
+
+void
+_bdisp_aq_prepare_upload_palette_hw (STGFX2DriverData * const stdrv,
+                                     STGFX2DeviceData * const stdev)
+{
+#ifndef STGFX2_CLUT_UNSAFE_MULTISESSION
+  /* before updating the LUT, we have to wait for the blitter to finish all
+     previous operations that would reload the LUT from memory. That's
+     rather difficult to find out - so we wait for the complete nodelist to
+     finish. */
+  /* FIXME: this is very inefficient! */
+#warning FIXME it is very inefficient to wait for the blitter to sync here!
+  bdisp_aq_EngineSync (stdrv, stdev);
+#else /* STGFX2_CLUT_UNSAFE_MULTISESSION */
+  /* before updating the LUT, we have to wait for the blitter to finish all
+     previous operations that would reload the LUT from memory. Rather than
+     waiting for the complete nodelist to finish, we just wait as long as the
+     blitter instruction involving the previous LUT has not been executed. */
+   /* FIXME: locking */
+  while (stdrv->bdisp_shared->last_lut)
+    /* the CLUT could have been updated between the check above and the call
+       to bdisp_aq_WaitSpace(). In that case we would be waiting
+       unnecessarily; we could create a new IOCTL specifically for waiting
+       for the CLUT to be updated, but we don't really care as no real harm
+       arises from waiting unnecessarily. */
+    bdisp_aq_WaitSpace (stdrv, stdev, stdrv->bdisp_shared);
+#endif /* STGFX2_CLUT_UNSAFE_MULTISESSION */
+}
+
+static void
+_bdisp_aq_upload_palette_hw (STGFX2DriverData * const stdrv,
+                             STGFX2DeviceData * const stdev)
+{
+  int i;
+
+  _bdisp_aq_prepare_upload_palette_hw (stdrv, stdev);
+
+  for (i = 0; i < stdev->palette->num_entries; ++i)
+    {
+      const DFBColor * const color = &stdev->palette->entries[i];
+      u16 alpha = color->a;
+      /* Note that the alpha range for the lut is 0-128 (not 127!) */
+      stdrv->clut_virt[SG2C_NORMAL][i] = PIXEL_ARGB ((alpha + 1) / 2, color->r,
+                                                     color->g, color->b);
+    }
+}
+
+
+/* get a node and also prepare it for a 'simple' drawing operation, so that
+   the only action which is left to the caller is to fill in the coordinates
+   and call _bdisp_aq_finish_node(). */
+static struct _BltNode_Fast *
+_bdisp_aq_get_new_node_prepared_simple (STGFX2DriverData     * const stdrv,
+                                        STGFX2DeviceData     * const stdev,
+                                        STMFBBDispSharedArea * const shared)
+{
+  struct _BltNode_Fast * const node = _bdisp_aq_get_new_node (stdrv, stdev,
+                                                              shared);
+  u32 blt_ins = BLIT_INS_SRC1_MODE_DIRECT_FILL;
+
+  D_ASSERT (shared == stdrv->bdisp_shared);
+
+  bdisp_aq_update_num_ops (stdev, shared, blt_ins);
+
+  node->common.ConfigTarget.BLT_TBA = stdev->ConfigTarget.BLT_TBA;
+  node->common.ConfigTarget.BLT_TTY = bdisp_ty_sanitise_direction (stdev->ConfigTarget.BLT_TTY);
+
+  /* source1 == destination */
+  node->common.ConfigSource1.BLT_S1TY = stdev->drawstate.color_ty;
+  node->common.ConfigColor.BLT_S1CF   = stdev->drawstate.color;
+
+  node->common.ConfigGeneral.BLT_CIC = CIC_BLT_NODE_FAST;
+  node->common.ConfigGeneral.BLT_INS = blt_ins;
+  /* BLT_ACK is ignored by the hardware in this case... */
+
+  bdisp_aq_update_config_static (shared, &node->ConfigStatic);
+
+  return node;
+}
+
+/* get a node and also prepare it for a drawing operation on the 'slow'
+   path, so that the only action which is left to the caller is to fill in
+   the coordinates and call _bdisp_aq_finish_node(). */
+static struct _BltNode_FullFill *
+_bdisp_aq_get_new_node_prepared_slow (STGFX2DriverData     * const stdrv,
+                                      STGFX2DeviceData     * const stdev,
+                                      STMFBBDispSharedArea * const shared)
+{
+  struct _BltNode_FullFill * const node = _bdisp_aq_get_new_node (stdrv,
+                                                                  stdev,
+                                                                  shared);
+  struct _BltNodeGroup08   *config_filters;
+  struct _BltNodeGroup12   *config_colorkey;
+  struct _BltNodeGroup14   *config_static;
+
+  u32 blt_cic = CIC_BLT_NODE_COMMON | CIC_NODE_SOURCE2 | CIC_NODE_STATIC;
+  u32 blt_ins;
+  u32 blt_ack;
+  u32 src2type = stdev->drawstate.color_ty | BLIT_TY_COLOR_EXPAND_MSB;
+
+  D_ASSERT (shared == stdrv->bdisp_shared);
+
+  blt_cic |= stdev->drawstate.ConfigGeneral.BLT_CIC | stdev->all_states.extra_blt_cic;
+  blt_ins  = stdev->drawstate.ConfigGeneral.BLT_INS | stdev->all_states.extra_blt_ins;
+  blt_ack  = stdev->drawstate.ConfigGeneral.BLT_ACK;
+
+  node->common.ConfigTarget.BLT_TBA = stdev->ConfigTarget.BLT_TBA;
+  node->common.ConfigTarget.BLT_TTY = bdisp_ty_sanitise_direction (stdev->ConfigTarget.BLT_TTY);
+
+  /* source1 == destination */
+  node->common.ConfigSource1.BLT_S1BA = stdev->ConfigTarget.BLT_TBA;
+  node->common.ConfigSource1.BLT_S1TY =
+    (bdisp_ty_sanitise_direction (stdev->ConfigTarget.BLT_TTY)
+     | BLIT_TY_COLOR_EXPAND_MSB);
+
+  node->common.ConfigColor.BLT_S2CF = stdev->drawstate.color;
+  node->ConfigSource2.BLT_S2TY = src2type;
+
+  /* if the clut is enabled, filters starts after the clut group, if
+     not, everything is moved up a bit */
+  if (blt_cic & CIC_NODE_CLUT)
+    {
+      node->ConfigClut = stdev->drawstate.ConfigClut;
+      config_filters = (struct _BltNodeGroup08 *) (&node->ConfigClut + 1);
+    }
+  else
+    {
+      /* avoid compiler warning: dereferencing type-punned pointer will break
+         strict-aliasing rules */
+      union {
+        struct _BltNodeGroup07 *clut;
+        struct _BltNodeGroup08 *filt;
+      } temp;
+      temp.clut = &node->ConfigClut;
+      config_filters = temp.filt;
+    }
+
+  /* if filters is enabled, colorkey starts after the filters group, if
+     not, everything is moved up a bit */
+  if (blt_cic & CIC_NODE_FILTERS)
+    {
+      node->ConfigFilters.BLT_FCTL_RZC = 0;
+      node->ConfigFilters.BLT_PMK = stdev->ConfigFilters.BLT_PMK;
+      config_colorkey = (struct _BltNodeGroup12 *) (config_filters + 1);
+    }
+  else
+    config_colorkey = (struct _BltNodeGroup12 *) config_filters;
+
+  /* if colorkeying is enabled, static starts after the colorkey group, if
+     not, everything is moved up a bit */
+  if (blt_cic & CIC_NODE_COLORKEY)
+    {
+      config_colorkey->BLT_KEY1
+        = config_colorkey->BLT_KEY2
+        = stdev->all_states.dst_ckey;
+
+      config_static = (struct _BltNodeGroup14 *) (config_colorkey + 1);
+    }
+  else
+    config_static = (struct _BltNodeGroup14 *) config_colorkey;
+
+  bdisp_aq_update_config_static (shared, config_static);
+
+  if (blt_cic & CIC_NODE_IVMX)
+    {
+      /* if we have the static group, ivmx starts after it, if not, everything
+         is moved up a bit */
+      struct _BltNodeGroup15 * const config_ivmx = (struct _BltNodeGroup15 *)
+        ((blt_cic & CIC_NODE_STATIC) ? (config_static + 1)
+                                     : config_static);
+
+      set_matrix (config_ivmx->BLT_IVMX, bdisp_aq_RGB_2_VideoYCbCr601);
+    }
+
+  bdisp_aq_SetClip (stdev, &blt_cic, &blt_ins, &node->ConfigClip);
+
+  bdisp_aq_update_num_ops (stdev, shared, blt_ins);
+
+  node->common.ConfigGeneral.BLT_CIC = blt_cic;
+  node->common.ConfigGeneral.BLT_INS = blt_ins;
+  node->common.ConfigGeneral.BLT_ACK = blt_ack;
+
+  return node;
+}
+
+
+
+
+void
+bdisp_aq_setup_blit_operation (STGFX2DriverData * const stdrv,
+                               STGFX2DeviceData * const stdev)
+{
+  stdev->ConfigGeneral.BLT_INS &= ~BLIT_INS_ENABLE_FLICKERFILTER;
+  if (stdev->blitstate.flags & STM_BLITTER_FLAGS_FLICKERFILTER)
+    stdev->ConfigGeneral.BLT_INS |= BLIT_INS_ENABLE_FLICKERFILTER;
+
+  /* we might have done a stretch blit before and do a normal blit
+     now, in which case make sure to disable the rescaling engine. */
+  stdev->ConfigGeneral.BLT_CIC &= ~(CIC_NODE_2DFILTERSCHR
+                                    | CIC_NODE_2DFILTERSLUMA);
+  if (!(stdev->ConfigGeneral.BLT_INS & BLIT_INS_ENABLE_PLANEMASK))
+    stdev->ConfigGeneral.BLT_CIC &= ~CIC_NODE_FILTERS;
+  stdev->ConfigGeneral.BLT_INS &= ~BLIT_INS_ENABLE_2DRESCALE;
+
+  if (!stdev->bIndexTranslation
+      && (stdev->palette
+          || stdev->palette_type != SG2C_NORMAL))
+    {
+      if (stdev->palette)
+        /* user palettes are written to the same memory location, so we need
+           to make sure not to overwrite any previous potentially different
+           palette while still in use. Therefore wait for the BDisp to be
+           idle. Color correction palettes are located at different places
+           in physical memory, which is why we can simply adjust the memory
+           pointer for those.
+           We will likely have to optimize this behaviour! */
+        _bdisp_aq_upload_palette_hw (stdrv, stdev);
+
+      CSTmBlitter__SetCLUTOperation (stdrv, stdev,
+                                     stdev->palette_type == SG2C_NORMAL,
+                                     &stdev->ConfigGeneral.BLT_CIC,
+                                     &stdev->ConfigGeneral.BLT_INS,
+                                     &stdev->ConfigClut);
+
+      D_DEBUG ("%s(): CLUT type: %#.8lx cco/cml: %#.8x %#.8x\n",
+               __FUNCTION__,
+               stdev->ConfigSource2.BLT_S2TY & (BLIT_TY_COLOR_FORM_MASK
+                                                | BLIT_TY_FULL_ALPHA_RANGE
+                                                | BLIT_TY_BIG_ENDIAN),
+               stdev->ConfigClut.BLT_CCO, stdev->ConfigClut.BLT_CML);
+
+#ifdef STGFX2_CLUT_UNSAFE_MULTISESSION
+      /* set this to false, so code elsewhere knows the CLUT upload
+         is enabled and can disable it. */
+      stdev->clut_disabled = false;
+#endif
+    }
+  else
+    {
+      stdev->ConfigGeneral.BLT_CIC &= ~CIC_NODE_CLUT;
+      stdev->ConfigGeneral.BLT_INS &= ~BLIT_INS_ENABLE_CLUT;
+    }
+}
+
+
+
+
+
+
+#define DFB_FIXED_POINT_TO_BDISP(f)  ((f) >> 6)
+
+static int
+FixedPointToInteger (int  f16,
+                     u32 * const fraction)
+{
+  int integer = DFB_FIXED_POINT_TO_INT (f16);
+
+  if (fraction)
+    *fraction = f16 - (DFB_FIXED_POINT_VAL (integer));
+
+  return integer;
+}
+
+
+static void
+GetXTapFilterSetup (int           this_src_x /* 16.16 */,
+                    int           real_src_x /* 16.16 */,
+                    int           total_src_width /* 16.16 */,
+                    int           h_src2_sign /* 1 or -1 */,
+                    bool          do_filter,
+                    u32          * const subpixelpos /* n.16 */,
+                    int          * const adjustedsrcx /* int */,
+                    int          * const srcspanwidth /* 16.16 */,
+                    unsigned int * const repeat /* int */,
+                    unsigned int  n_taps)
+{
+  int edgedistance /* int */;
+
+  /* we need some pixels to init and end the filter */
+  int _prefill, _postfill;
+
+  switch (n_taps)
+    {
+    case 8:
+      _prefill = 3;
+      _postfill = 4;
+      break;
+
+    case 5:
+      _prefill = 2;
+      _postfill = 2;
+      break;
+
+    default:
+      _prefill = (n_taps - 1) / 2;
+      _postfill = n_taps / 2;
+      break;
+    }
+
+  /* We need the subpixel position of the start, which is basically where the
+     filter left off on the previous span. */
+  *adjustedsrcx = FixedPointToInteger (this_src_x, subpixelpos);
+  if (h_src2_sign == -1)
+    {
+      /* This is not immediately obvious:
+         1. We have to flip around the subpixel position as the filter is being
+            filled with pixels in reverse.
+         2. Then if the subpixel position is not zero, we have to move our
+            first real pixel sample in the middle of the filter to the one on
+            the right of the current position.
+            This could make the edge distance go negative on the first span if
+            the subpixel position is not zero, but that is ok because we will
+            then end up with an extra repeated pixel to pad the filter taps. */
+      *subpixelpos = (DFB_FIXED_POINT_ONE - *subpixelpos) % DFB_FIXED_POINT_ONE;
+      if (*subpixelpos != 0)
+        {
+          ++(*adjustedsrcx);
+          *srcspanwidth += DFB_FIXED_POINT_ONE;
+        }
+    }
+
+  /* Adjust things to fill the first three filter taps either with real data
+     or a repeat of the first pixel. */
+  edgedistance = ((*adjustedsrcx - DFB_FIXED_POINT_TO_INT (real_src_x))
+                  * h_src2_sign
+                 );
+  D_DEBUG_AT (BDISP_STRETCH, "  -> span edgedistance: %d\n", edgedistance);
+
+  if (do_filter)
+    {
+      if (edgedistance >= _prefill)
+        {
+          *repeat        = 0;
+          *adjustedsrcx -= (_prefill * h_src2_sign);
+          *srcspanwidth += DFB_FIXED_POINT_VAL (_prefill);
+        }
+      else
+        {
+          *repeat        = _prefill - edgedistance;
+          *adjustedsrcx  = DFB_FIXED_POINT_TO_INT (real_src_x);
+          *srcspanwidth += DFB_FIXED_POINT_VAL (edgedistance);
+        }
+
+      /* Adjust for an extra number of pixels to be read to fill last filter
+         taps, or to repeat the last pixel if we have gone outside of the
+         source image... */
+      *srcspanwidth += DFB_FIXED_POINT_VAL (_postfill);
+    }
+  else
+    *repeat = 0;
+
+  /* ...by clamping the source width we program in the hardware. */
+  if (h_src2_sign == 1
+      && ((DFB_FIXED_POINT_VAL (*adjustedsrcx) - real_src_x + *srcspanwidth)
+          > total_src_width))
+    *srcspanwidth = total_src_width - (DFB_FIXED_POINT_VAL (*adjustedsrcx)
+                                       - real_src_x);
+  else if (h_src2_sign == -1
+           && ((real_src_x - total_src_width + *srcspanwidth)
+               > DFB_FIXED_POINT_VAL (*adjustedsrcx)))
+    *srcspanwidth = DFB_FIXED_POINT_VAL (*adjustedsrcx) - (real_src_x
+                                                           - total_src_width);
+
+  D_DEBUG_AT (BDISP_STRETCH,
+              "     adjsrcx/y: %d subpixelpos: %x (%d.%06d) srcspanwidth/height: %x (%d.%06d) repeat: %d\n",
+              *adjustedsrcx,
+              *subpixelpos, DFB_INT_VALf (*subpixelpos),
+              *srcspanwidth, DFB_INT_VALf (*srcspanwidth),
+              *repeat);
+}
+
+static void
+Get8TapFilterSetup (int           this_src_x /* 16.16 */,
+                    int           real_src_x /* 16.16 */,
+                    int           total_src_width /* 16.16 */,
+                    int           h_src2_sign /* 1 or -1 */,
+                    bool          do_filter,
+                    u32          * const subpixelpos /* n.16 */,
+                    int          * const adjustedsrcx /* int */,
+                    int          * const srcspanwidth /* 16.16 */,
+                    unsigned int * const repeat /* int */)
+{
+  GetXTapFilterSetup (this_src_x, real_src_x, total_src_width,
+                      h_src2_sign, do_filter,
+                      subpixelpos, adjustedsrcx, srcspanwidth, repeat,
+                      8);
+}
+
+static void
+Get5TapFilterSetup (int           this_src_y /* 16.16 */,
+                    int           real_src_y /* 16.16 */,
+                    int           total_src_height /* 16.16 */,
+                    int           v_src2_sign /* 1 or -1 */,
+                    bool          do_filter,
+                    u32          * const subpixelpos /* n.16 */,
+                    int          * const adjustedsrcy /* int */,
+                    int          * const srcspanheight /* 16.16 */,
+                    unsigned int * const repeat /* int */)
+{
+  GetXTapFilterSetup (this_src_y, real_src_y, total_src_height,
+                      v_src2_sign, do_filter,
+                      subpixelpos, adjustedsrcy, srcspanheight, repeat,
+                      5);
+}
+
+
+static void
+_bdisp_aq_Blit_using_spans (STGFX2DriverData   * const stdrv,
+                            STGFX2DeviceData   * const stdev,
+                            const DFBRectangle * const src,
+                            const DFBRectangle * const dst)
+{
+  /* The filter delay lines can hold 128 pixels (or more, depending on the
+   implementation), we want to process slightly less than that because we need
+   up to 4 pixels of overlap between spans to fill the filter taps properly
+   and not end up with stripes down the image at the edges of two adjoining
+   spans. */
+  unsigned long long max_filterstep = ((stdev->features.line_buffer_length - 8)
+                                       * DFB_FIXED_POINT_ONE);
+  int                hsrcinc = stdev->hsrcinc;
+
+  /* Calculate how many destination pixels will get generated from one
+     span of the source image. */
+  int this_dst_step = max_filterstep / hsrcinc;
+
+  /* Work the previous calculation backwards so we don't get rounding
+     errors causing bad filter positioning in the middle of the scaled
+     image. We deal with any left over pixels at the edge of the image
+     separately.
+     This puts srcstep into 16.16 fixed point. */
+  const int srcstep = this_dst_step * hsrcinc;
+  D_DEBUG_AT (BDISP_STRETCH_SPANS,
+              "%s: %d.%06d,%d.%06d-%d.%06dx%d.%06d -> %d.%06d,%d.%06d-%d.%06dx%d.%06d srcstep: 0x%x (%d.%06d) dststep: %d\n",
+              __FUNCTION__,
+              DFB_RECTANGLE_VALSf (src), DFB_RECTANGLE_VALSf (dst),
+              srcstep, DFB_INT_VALf (srcstep), this_dst_step);
+
+  /* the following combinations are possible:
+                              SRC2                     SRC1 (TARGET)
+     copy formwards    TopLeft -> BottomRight     TopLeft -> BottomRight
+     copy backwards    BottomRight -> TopLeft     BottomRight -> TopLeft
+         for SRC2 width >= SRC1
+     rotate 180       TopLeft -> BottomRight     BottomRight -> TopLeft
+     mirror against x  TopLeft -> BottomRight     BottomLeft -> TopRight
+     mirror against y  TopLeft -> BottomRight     TopRight -> BottomLeft
+         for SRC2 width < SRC1
+     rotate 180       BottomRight -> TopLeft     TopLeft -> BottomRight
+     mirror against x  BottomLeft -> TopRight     TopLeft -> BottomRight
+     mirror against y  TopRight -> BottomLeft     TopLeft -> BottomRight
+  */
+
+  /* because of rounding errors we might run out of source pixels (when
+     upscaling). To work around that, we calculate how many pixels we are
+     off and slightly move the source x such that we read this extra
+     amount of pixels per span. Chosing a span width small enough doesn't
+     cause any visible artifacts, but the code should be changed to select
+     the span width dynamically based on the resulting rounding error. In
+     addition, the latests chips have a big line buffer, and doing this
+     adjustment statically, without changing the span width will look
+     horrible. */
+  int error_adjust = 0;
+#if 0
+  {
+  int total = DFB_FIXED_POINT_VAL ((long long) src->w) / hsrcinc;
+//  total -= DFB_FIXED_POINT_VAL (3);
+  int error = (((long long) (dst->w - total)) * hsrcinc) / DFB_FIXED_POINT_ONE;
+  if (error > 0)
+    {
+      int spans = (src->w + max_filterstep/2) / max_filterstep;
+      error_adjust = error / spans;
+    }
+  }
+#endif
+
+  int this_src_x = src->x;
+  int this_dst_x = dst->x;
+  int _srcspanwidth = srcstep /* 16.16 */;
+
+  u32 s2sz = stdev->ConfigSource2.BLT_S2SZ & 0xffff0000;
+  u32 tsz  = stdev->ConfigTarget.BLT_TSZ_S1SZ & 0xffff0000;
+  u32 rzi = stdev->ConfigFiltersChr.BLT_RZI & ~(BLIT_RZI_H_REPEAT_MASK
+                                                | BLIT_RZI_H_INIT_MASK);
+
+  bool do_filter = (((stdev->ConfigFilters.BLT_FCTL_RZC & BLIT_RZC_2DHF_MODE_MASK)
+                     != BLIT_RZC_2DHF_MODE_RESIZE_ONLY)
+                    || ((stdev->ConfigFilters.BLT_FCTL_RZC & BLIT_RZC_FF_MODE_MASK)
+                        != BLIT_RZC_FF_MODE_FILTER0));
+
+  while (this_dst_step /* int */ > 0)
+    {
+      int adjustedsrcx /* int */, srcspanwidth = _srcspanwidth /* 16.16 */;
+      u32 subpixelpos /* n.16 */;
+      unsigned int repeat /* int */;
+
+      D_DEBUG_AT (BDISP_STRETCH,
+                  "     this_dst_x: %d.%06d this_dst_step: %d\n",
+                  DFB_INT_VALf (this_dst_x), this_dst_step);
+
+      Get8TapFilterSetup (this_src_x, src->x, src->w, stdev->h_src2_sign,
+                          do_filter,
+                          &subpixelpos, &adjustedsrcx, &srcspanwidth, &repeat);
+
+      stdev->ConfigFiltersChr.BLT_RZI  = rzi;
+      stdev->ConfigFiltersChr.BLT_RZI |= (repeat << BLIT_RZI_H_REPEAT_SHIFT);
+      stdev->ConfigFiltersChr.BLT_RZI |= DFB_FIXED_POINT_TO_BDISP (subpixelpos) << BLIT_RZI_H_INIT_SHIFT;
+
+      stdev->ConfigTarget.BLT_TXY  = DFB_FIXED_POINT_TO_INT (dst->y) << 16;
+      stdev->ConfigTarget.BLT_TXY |= DFB_FIXED_POINT_TO_INT (this_dst_x);
+
+      stdev->ConfigTarget.BLT_TSZ_S1SZ  = tsz;
+      stdev->ConfigTarget.BLT_TSZ_S1SZ |= (this_dst_step & 0x0fff);
+
+      if (!D_FLAGS_IS_SET (stdev->ConfigGeneral.BLT_CIC, CIC_NODE_SOURCE3))
+        {
+          stdev->ConfigSource1.BLT_S1XY = stdev->ConfigTarget.BLT_TXY;
+
+          stdev->ConfigSource2.BLT_S2XY  = DFB_FIXED_POINT_TO_INT (src->y) << 16;
+          stdev->ConfigSource2.BLT_S2XY |= adjustedsrcx;
+          stdev->ConfigSource2.BLT_S2SZ  = s2sz;
+          stdev->ConfigSource2.BLT_S2SZ |= (DFB_FIXED_POINT_TO_INT (srcspanwidth)
+                                            & 0x0fff);
+
+          D_DEBUG_AT (BDISP_STRETCH, "     S2XY: %.8x S2SZ: %.8x -> TXY %.8x TSZ %.8x (RZI %.8x)\n",
+                      stdev->ConfigSource2.BLT_S2XY, stdev->ConfigSource2.BLT_S2SZ,
+                      stdev->ConfigTarget.BLT_TXY, stdev->ConfigTarget.BLT_TSZ_S1SZ,
+                      stdev->ConfigFiltersChr.BLT_RZI);
+        }
+      else
+        {
+          stdev->ConfigFiltersLuma.BLT_Y_RZI = stdev->ConfigFiltersChr.BLT_RZI;
+
+          stdev->ConfigSource3.BLT_S3XY  = DFB_FIXED_POINT_TO_INT (src->y) << 16;
+          stdev->ConfigSource3.BLT_S3XY |= adjustedsrcx;
+          stdev->ConfigSource3.BLT_S3SZ  = s2sz;
+          stdev->ConfigSource3.BLT_S3SZ |= (DFB_FIXED_POINT_TO_INT (srcspanwidth)
+                                            & 0x0fff);
+
+          if (stdev->srcFactorH == 2
+              || stdev->srcFactorV == 2)
+            {
+              srcspanwidth = _srcspanwidth / stdev->srcFactorH;
+
+              Get8TapFilterSetup (this_src_x / stdev->srcFactorH,
+                                  src->x / stdev->srcFactorH,
+                                  src->w / stdev->srcFactorH,
+                                  stdev->h_src2_sign,
+                                  do_filter,
+                                  &subpixelpos,
+                                  &adjustedsrcx,
+                                  &srcspanwidth,
+                                  &repeat);
+
+              stdev->ConfigFiltersChr.BLT_RZI  = rzi;
+              stdev->ConfigFiltersChr.BLT_RZI |= (repeat << BLIT_RZI_H_REPEAT_SHIFT);
+              stdev->ConfigFiltersChr.BLT_RZI |= DFB_FIXED_POINT_TO_BDISP (subpixelpos) << BLIT_RZI_H_INIT_SHIFT;
+
+              stdev->ConfigSource2.BLT_S2XY  = (DFB_FIXED_POINT_TO_INT (src->y / stdev->srcFactorV) << 16) & 0x0fff0000;
+              stdev->ConfigSource2.BLT_S2XY |= adjustedsrcx;
+              stdev->ConfigSource2.BLT_S2SZ  = (s2sz / stdev->srcFactorV) & 0x0fff0000;
+              stdev->ConfigSource2.BLT_S2SZ |= (DFB_FIXED_POINT_TO_INT (srcspanwidth) & 0x0fff);
+
+              /* just to be safe in case we determined to blit 1 luma pixel (which
+                 could be 0.5 chroma pixels, i.e. 0) */
+              if (unlikely (!(stdev->ConfigSource2.BLT_S2SZ & 0x0fff0000)))
+                stdev->ConfigSource2.BLT_S2SZ |= 1 << 16;
+              if (unlikely (!(stdev->ConfigSource2.BLT_S2SZ & 0x0fff)))
+                stdev->ConfigSource2.BLT_S2SZ |= 1;
+            }
+          else /* if (stdev->srcFactorH == 1) */
+            {
+              stdev->ConfigSource2.BLT_S2XY = stdev->ConfigSource3.BLT_S3XY;
+              stdev->ConfigSource2.BLT_S2SZ = stdev->ConfigSource3.BLT_S3SZ;
+            }
+
+          stdev->ConfigSource1.BLT_S1XY = stdev->ConfigSource2.BLT_S2XY;
+
+          D_DEBUG_AT (BDISP_STRETCH, "     S3XY: %.8x S3SZ: %.8x S2XY: %.8x S2SZ: %.8x S1XY: %.8x -> TXY %.8x TSZ %.8x (RZI %.8x Y_RZI %.8x)\n",
+                      stdev->ConfigSource3.BLT_S3XY, stdev->ConfigSource3.BLT_S3SZ,
+                      stdev->ConfigSource2.BLT_S2XY, stdev->ConfigSource2.BLT_S2SZ,
+                      stdev->ConfigSource1.BLT_S1XY,
+                      stdev->ConfigTarget.BLT_TXY, stdev->ConfigTarget.BLT_TSZ_S1SZ,
+                      stdev->ConfigFiltersChr.BLT_RZI, stdev->ConfigFiltersLuma.BLT_Y_RZI);
+        }
+
+      bdisp_aq_copy_n_push_node (stdrv, stdev);
+
+      this_src_x += (srcstep * stdev->h_src2_sign);
+      this_src_x -= (error_adjust * stdev->h_src2_sign);
+      this_dst_x += (DFB_FIXED_POINT_VAL (this_dst_step) * stdev->h_trgt_sign);
+
+      /* Alter the span sizes for the "last" span where we have an
+         odd bit left over (i.e. the total destination is not a nice
+         multiple of this_dst_step). */
+      if (stdev->h_trgt_sign == 1)
+        {
+          /* Remember that x + w (== right) isn't in the destination rect */
+          int dst_right = dst->x + dst->w;
+          if ((dst_right - this_dst_x) < DFB_FIXED_POINT_VAL (this_dst_step))
+            this_dst_step = DFB_FIXED_POINT_TO_INT (dst_right - this_dst_x);
+        }
+      else
+        {
+          int dst_left = dst->x - dst->w + DFB_FIXED_POINT_ONE;
+          if (((this_dst_x - dst_left) + DFB_FIXED_POINT_ONE) < DFB_FIXED_POINT_VAL (this_dst_step))
+            this_dst_step = DFB_FIXED_POINT_TO_INT ((this_dst_x - dst_left) + DFB_FIXED_POINT_ONE);
+        }
+
+      /* to save bandwidth, we make sure to update the CLUT only
+         once. Also, we turn off the BLIT_INS_ENABLE_BLITCOMPIRQ
+         since we need it only once to notify us when the node
+         containing the CLUT update has been executed. */
+      bdisp_aq_clut_update_disable_if_unsafe (stdev);
+    }
+}
+
+
+static bool
+_bdisp_aq_rectangles_intersect (const DFBRectangle * __restrict rect1,
+                                const DFBRectangle * __restrict rect2)
+{
+  int right1  = rect1->x + rect1->w;
+  int bottom1 = rect1->y + rect1->h;
+  int right2  = rect2->x + rect2->w;
+  int bottom2 = rect2->y + rect2->h;
+
+  return !(rect1->x >= right2 || right1 <= rect2->x
+           || rect1->y >= bottom2 || bottom1 <= rect2->y);
+}
+
+static bool
+__attribute__((warn_unused_result))
+_bdisp_aq_Blit_setup_directions (STGFX2DeviceData   * const stdev,
+                                 const DFBRectangle * const src2,
+                                 const DFBRectangle * const src1,
+                                 const DFBRectangle * const dst)
+{
+  stdev->ConfigTarget.BLT_TTY   &= ~BLIT_TY_COPYDIR_MASK;
+  stdev->ConfigSource1.BLT_S1TY &= ~BLIT_TY_COPYDIR_MASK;
+  stdev->ConfigSource2.BLT_S2TY &= ~BLIT_TY_COPYDIR_MASK;
+  stdev->ConfigSource3.BLT_S3TY &= ~BLIT_TY_COPYDIR_MASK;
+
+  /* work out copy direction */
+
+  /* we don't support any overlap at all during rotation */
+  if (stdev->rotate
+      && stdev->ConfigSource2.BLT_S2BA == stdev->ConfigSource1.BLT_S1BA)
+    {
+      DFBRegion s1region = { .x1 = src1->x,
+                             .y1 = src1->y };
+      s1region.x2 = src1->x + src1->h - DFB_FIXED_POINT_ONE;
+      s1region.y2 = src1->y + src1->w - DFB_FIXED_POINT_ONE;
+      if (dfb_region_rectangle_intersect (&s1region, src2))
+        /* scary, by carefully checking we might be able to allow some of
+           these. but not today... */
+        return false;
+    }
+
+  /* we need to know the copy direction in various places */
+  stdev->h_trgt_sign
+    = stdev->h_src2_sign
+    = stdev->v_trgt_sign
+    = stdev->v_src2_sign
+    = 1;
+
+  switch (stdev->rotate)
+    {
+    case 0:
+      {
+      bool backwards;
+      u32  trgt_dir;
+
+      /* FIXME: for blit2 */
+      backwards = ((stdev->ConfigSource2.BLT_S2BA == stdev->ConfigSource1.BLT_S1BA)
+                   && ((src1->y > src2->y
+                        || ((src1->y == src2->y) && (src1->x > src2->x)))
+                       && _bdisp_aq_rectangles_intersect (src2, src1)
+                      )
+                  );
+
+      if (!backwards)
+        {
+          /* target from top left to bottom right */
+          /* source2 from top left to bottom right */
+          trgt_dir = (BLIT_TY_COPYDIR_TOPBOTTOM | BLIT_TY_COPYDIR_LEFTRIGHT);
+        }
+      else
+        {
+          /* target from bottom right to top left */
+          /* source2 from bottom right to top left */
+          trgt_dir = (BLIT_TY_COPYDIR_BOTTOMTOP | BLIT_TY_COPYDIR_RIGHTLEFT);
+          stdev->h_trgt_sign
+            = stdev->h_src2_sign
+            = stdev->v_trgt_sign
+            = stdev->v_src2_sign
+            = -1;
+        }
+      stdev->ConfigTarget.BLT_TTY |= trgt_dir;
+      stdev->ConfigSource2.BLT_S2TY |= trgt_dir;
+      stdev->ConfigSource3.BLT_S3TY |= trgt_dir;
+      }
+      break;
+
+    case 180: /* rotate 180 */
+      if ((src2->w + DFB_FIXED_POINT_VAL (7)) >= (src1->w + dst->w))
+        {
+          /* target from bottom right to top left */
+          /* source2 from top left to bottom right */
+          stdev->ConfigTarget.BLT_TTY |= (BLIT_TY_COPYDIR_BOTTOMTOP | BLIT_TY_COPYDIR_RIGHTLEFT);
+          stdev->ConfigSource2.BLT_S2TY |= (BLIT_TY_COPYDIR_TOPBOTTOM | BLIT_TY_COPYDIR_LEFTRIGHT);
+          stdev->h_trgt_sign = stdev->v_trgt_sign = -1;
+        }
+      else
+        {
+          /* target from top left to bottom right */
+          /* source2 from bottom right to top left */
+          stdev->ConfigTarget.BLT_TTY |= (BLIT_TY_COPYDIR_TOPBOTTOM | BLIT_TY_COPYDIR_LEFTRIGHT);
+          stdev->ConfigSource2.BLT_S2TY |= (BLIT_TY_COPYDIR_BOTTOMTOP | BLIT_TY_COPYDIR_RIGHTLEFT);
+          stdev->h_src2_sign = stdev->v_src2_sign = -1;
+        }
+      break;
+
+    case 181: /* reflection against x */
+      if ((src2->h + DFB_FIXED_POINT_VAL (4)) >= (src1->h + dst->h))
+        {
+          /* target from bottom left to top right */
+          /* source2 from top left to bottom right */
+          stdev->ConfigTarget.BLT_TTY |= (BLIT_TY_COPYDIR_BOTTOMTOP | BLIT_TY_COPYDIR_LEFTRIGHT);
+          stdev->ConfigSource2.BLT_S2TY |= (BLIT_TY_COPYDIR_TOPBOTTOM | BLIT_TY_COPYDIR_LEFTRIGHT);
+          stdev->v_trgt_sign = -1;
+        }
+      else
+        {
+          /* target from top left to bottom right */
+          /* source2 from bottom left to top right */
+          stdev->ConfigTarget.BLT_TTY |= (BLIT_TY_COPYDIR_TOPBOTTOM | BLIT_TY_COPYDIR_LEFTRIGHT);
+          stdev->ConfigSource2.BLT_S2TY |= (BLIT_TY_COPYDIR_BOTTOMTOP | BLIT_TY_COPYDIR_LEFTRIGHT);
+          stdev->v_src2_sign = -1;
+        }
+      break;
+
+    case 182: /* reflection against y */
+      if ((src2->w + DFB_FIXED_POINT_VAL (7)) >= (src1->w + dst->w))
+        {
+          /* target from top right to bottom left */
+          /* source2 from top left to bottom right */
+          stdev->ConfigTarget.BLT_TTY |= (BLIT_TY_COPYDIR_TOPBOTTOM | BLIT_TY_COPYDIR_RIGHTLEFT);
+          stdev->ConfigSource2.BLT_S2TY |= (BLIT_TY_COPYDIR_TOPBOTTOM | BLIT_TY_COPYDIR_LEFTRIGHT);
+          stdev->h_trgt_sign = -1;
+        }
+      else
+        {
+          /* target from top left to bottom right */
+          /* source2 from top right to bottom left */
+          stdev->ConfigTarget.BLT_TTY |= (BLIT_TY_COPYDIR_TOPBOTTOM | BLIT_TY_COPYDIR_LEFTRIGHT);
+          stdev->ConfigSource2.BLT_S2TY |= (BLIT_TY_COPYDIR_TOPBOTTOM | BLIT_TY_COPYDIR_RIGHTLEFT);
+          stdev->h_src2_sign = -1;
+        }
+      break;
+
+    default:
+      /* should not be reached */
+      return false;
+    }
+
+  /* FIXME: 3 buffer formats */
+  stdev->ConfigSource1.BLT_S1TY |= (stdev->ConfigTarget.BLT_TTY & BLIT_TY_COPYDIR_MASK);
+
+  D_DEBUG_AT (BDISP_BLT, "  -> Generating src2 blit %s & %s\n",
+              (stdev->h_src2_sign == 1) ? "left to right" : "right to left",
+              (stdev->v_src2_sign == 1) ? "top to bottom" : "bottom to top");
+  D_DEBUG_AT (BDISP_BLT, "  -> Generating trgt blit %s & %s\n",
+              (stdev->h_trgt_sign == 1) ? "left to right" : "right to left",
+              (stdev->v_trgt_sign == 1) ? "top to bottom" : "bottom to top");
+
+  return true;
+}
+
+static void
+_bdisp_aq_Blit_setup_locations (const STGFX2DriverData * const stdrv,
+                                STGFX2DeviceData       * const stdev,
+                                DFBRectangle           * const src2,
+                                DFBRectangle           * const src1,
+                                DFBRectangle           * const dst,
+                                bool                    requires_spans)
+{
+  /* FIXME: treat src1 */
+  if (stdev->h_trgt_sign == -1)
+    /* target/source1 from right to left */
+    dst->x += (dst->w - DFB_FIXED_POINT_ONE);
+  if (stdev->v_trgt_sign == -1)
+    /* target/source1 from bottom to top */
+    dst->y += (dst->h - DFB_FIXED_POINT_ONE);
+  if (stdev->h_src2_sign == -1)
+    /* source2 from right to left */
+    src2->x += (src2->w - DFB_FIXED_POINT_ONE);
+  if (stdev->v_src2_sign == -1)
+    /* source2 from bottom to top */
+    src2->y += (src2->h - DFB_FIXED_POINT_ONE);
+
+  if (!requires_spans)
+    {
+      /*
+       * This is a workaround for:
+       *     https://bugzilla.stlinux.com/show_bug.cgi?id=7084
+       */
+      if (unlikely (dst->w < DFB_FIXED_POINT_ONE))
+        dst->w = DFB_FIXED_POINT_ONE;
+      if (unlikely (dst->h < DFB_FIXED_POINT_ONE))
+        {
+          printf ("%s: dst->h %x (%d.%06d) < DFB_FIXED_POINT_ONE!\n",
+                  __FUNCTION__, dst->h, DFB_INT_VALf (dst->h));
+          dst->h = DFB_FIXED_POINT_ONE;
+        }
+      if (unlikely (src2->w < DFB_FIXED_POINT_ONE))
+        {
+          printf ("%s: src2->w %x (%d.%06d) < DFB_FIXED_POINT_ONE!\n",
+                  __FUNCTION__, src2->w, DFB_INT_VALf (src2->w));
+          src2->w = DFB_FIXED_POINT_ONE;
+        }
+      if (unlikely (src2->h < DFB_FIXED_POINT_ONE))
+        {
+          printf ("%s: src2->h %x (%d.%06d) < DFB_FIXED_POINT_ONE!\n",
+                  __FUNCTION__, src2->h, DFB_INT_VALf (src2->h));
+          src2->h = DFB_FIXED_POINT_ONE;
+        }
+
+      stdev->ConfigTarget.BLT_TXY   = ((DFB_FIXED_POINT_TO_INT (dst->y) << 16)
+                                       | DFB_FIXED_POINT_TO_INT (dst->x));
+      stdev->ConfigTarget.BLT_TSZ_S1SZ = (((DFB_FIXED_POINT_TO_INT (dst->h) & 0x0fff) << 16)
+                                          | (DFB_FIXED_POINT_TO_INT (dst->w) & 0x0fff));
+
+      stdev->ConfigSource1.BLT_S1XY = ((DFB_FIXED_POINT_TO_INT (src1->y) << 16)
+                                       | DFB_FIXED_POINT_TO_INT (src1->x));
+      stdev->ConfigSource2.BLT_S2XY = ((DFB_FIXED_POINT_TO_INT (src2->y) << 16)
+                                       | DFB_FIXED_POINT_TO_INT (src2->x));
+      stdev->ConfigSource2.BLT_S2SZ    = (((DFB_FIXED_POINT_TO_INT (src2->h) & 0x0fff) << 16)
+                                          | (DFB_FIXED_POINT_TO_INT (src2->w) & 0x0fff));
+
+      if (D_FLAGS_IS_SET (stdev->ConfigGeneral.BLT_CIC, CIC_NODE_SOURCE3))
+        {
+          int src2_x = DFB_FIXED_POINT_TO_INT (src2->x / stdev->srcFactorH);
+          int src2_y = DFB_FIXED_POINT_TO_INT (src2->y / stdev->srcFactorV) << 16;
+          int src2_w = DFB_FIXED_POINT_TO_INT (src2->w / stdev->srcFactorH) & 0x0fff;
+          int src2_h = (DFB_FIXED_POINT_TO_INT (src2->h / stdev->srcFactorV) & 0x0fff) << 16;
+
+          if (unlikely (stdev->srcFactorH != 1
+                        && !src2_w))
+            /* 1 luma pixel could be 0.5 chroma pixels, i.e. 0. That would
+               stall the BDisp. I am not sure if it is OK to make this case
+               work using this workaround, or if we rather should just deny
+               such blits, though. */
+            src2_w = 1;
+          if (unlikely (stdev->srcFactorV != 1
+                        && !src2_h))
+            src2_h = 1 << 16;
+
+          stdev->ConfigSource3.BLT_S3XY = stdev->ConfigSource2.BLT_S2XY;
+          stdev->ConfigSource3.BLT_S3SZ = stdev->ConfigSource2.BLT_S2SZ;
+
+          stdev->ConfigSource2.BLT_S2XY = src2_y | src2_x;
+          stdev->ConfigSource2.BLT_S2SZ = src2_h | src2_w;
+
+          stdev->ConfigSource1.BLT_S1XY = stdev->ConfigSource2.BLT_S2XY;
+
+          D_DEBUG_AT (BDISP_BLT, "   S3XY: %.8x S3SZ: %.8x S2XY: %.8x S2SZ: %.8x S1XY: %.8x -> TXY %.8x TSZ %.8x (RZI %.8x Y_RZI %.8x)\n",
+                      stdev->ConfigSource3.BLT_S3XY, stdev->ConfigSource3.BLT_S3SZ,
+                      stdev->ConfigSource2.BLT_S2XY, stdev->ConfigSource2.BLT_S2SZ,
+                      stdev->ConfigSource1.BLT_S1XY,
+                      stdev->ConfigTarget.BLT_TXY, stdev->ConfigTarget.BLT_TSZ_S1SZ,
+                      stdev->ConfigFiltersChr.BLT_RZI,
+                      stdev->ConfigFiltersLuma.BLT_Y_RZI);
+        }
+      else
+        D_DEBUG_AT (BDISP_BLT, "   S2XY: %.8x S2SZ: %.8x -> TXY %.8x TSZ %.8x (RZI %.8x)\n",
+                    stdev->ConfigSource2.BLT_S2XY, stdev->ConfigSource2.BLT_S2SZ,
+                    stdev->ConfigTarget.BLT_TXY, stdev->ConfigTarget.BLT_TSZ_S1SZ,
+                    stdev->ConfigFiltersChr.BLT_RZI);
+    }
+  else
+    {
+      /* Fill in the vertical sizes as they are constant for all spans and
+         it saves us from having to find out the values again. */
+      stdev->ConfigTarget.BLT_TSZ_S1SZ = (DFB_FIXED_POINT_TO_INT (dst->h) & 0x0fff) << 16;
+      stdev->ConfigSource2.BLT_S2SZ    = (DFB_FIXED_POINT_TO_INT (src2->h) & 0x0fff) << 16;
+    }
+}
+
+
+static bool
+bdisp_aq_flickerfilter_setup (STGFX2DeviceData * const stdev)
+{
+  if (likely (!D_FLAGS_IS_SET (stdev->ConfigGeneral.BLT_INS,
+                               BLIT_INS_ENABLE_FLICKERFILTER)))
+    /* FIXME: at the moment BLIT_INS_ENABLE_FLICKERFILTER is never set,
+       therefore the likely() is fine. Remove as soon as we make use of it. */
+    return false;
+
+  stdev->ConfigGeneral.BLT_CIC &= ~CIC_NODE_2DFILTERSLUMA;
+  stdev->ConfigGeneral.BLT_CIC |= (CIC_NODE_FILTERS
+                                   | CIC_NODE_2DFILTERSCHR
+                                   | CIC_NODE_FLICKER);
+  stdev->ConfigGeneral.BLT_INS |= (BLIT_INS_ENABLE_FLICKERFILTER
+                                   | BLIT_INS_ENABLE_2DRESCALE);
+
+  /* stdev->ConfigFlicker is initialized once and never changes */
+
+  /* We need to turn on the whole filter/resize pipeline to use the
+     flicker filter, even if we are not resizing as well. */
+  stdev->ConfigFilters.BLT_FCTL_RZC = (BLIT_RZC_FF_MODE_ADAPTIVE
+                                       | BLIT_RZC_2DHF_MODE_RESIZE_ONLY
+                                       | BLIT_RZC_2DVF_MODE_RESIZE_ONLY);
+
+  /* 1:1 scaling by default */
+  stdev->hsrcinc = stdev->vsrcinc = DFB_FIXED_POINT_ONE;
+  stdev->ConfigFiltersChr.BLT_RSF  = DFB_FIXED_POINT_TO_BDISP (stdev->vsrcinc) << 16;
+  stdev->ConfigFiltersChr.BLT_RSF |= DFB_FIXED_POINT_TO_BDISP (stdev->hsrcinc);
+  /* Default horizontal filter setup, repeat the first pixel 3 times to
+     pre-fill the 8 Tap filter. No initial phase shift is required. */
+  stdev->ConfigFiltersChr.BLT_RZI = (3 << BLIT_RZI_H_REPEAT_SHIFT);
+  stdev->ConfigFiltersChr.BLT_HFP = 0;
+  stdev->ConfigFiltersChr.BLT_VFP = 0;
+
+  return true;
+}
+
+static bool
+__attribute__((const))
+bdisp_aq_filter_need_spans (int srcwidth,
+                            u16 line_buffer_length)
+{
+  /* If the source width is >line_length pixels then we need to split the
+     operation up into <line_length pixel vertical spans. This is because the
+     filter pipeline only has line buffering for up to 128 pixels.
+     In addition, even if we don't require spans for an operation we apply
+     filtering and take surrounding pixels into account, similar to
+     _bdisp_aq_Blit_using_spans(). This means we need additional pixels and
+     therefore have to subtract 8 from the available line buffer length here,
+     too. */
+  return srcwidth > DFB_FIXED_POINT_VAL (line_buffer_length - 8);
+}
+
+static u32
+round_f16_to_f10 (u32 f16)
+{
+  f16 += (1 << 5);
+  f16 &= ~0x3f;
+
+  return f16;
+}
+
+static int
+__attribute__((const))
+divide_f16 (int dividend, int divisor)
+{
+  long long temp = DFB_FIXED_POINT_VAL ((long long) dividend);
+  return temp / divisor;
+}
+
+union _BltNodeGroup0910 {
+  struct _BltNodeGroup09 *chroma;
+  struct _BltNodeGroup10 *luma;
+};
+
+static void
+_bdisp_aq_filtering_setup (STGFX2DeviceData        * const stdev,
+                           int                      hsrcinc,
+                           int                      vsrcinc,
+                           union _BltNodeGroup0910 * const filter)
+{
+  struct _BltNodeGroup09 * __restrict flt = filter->chroma;
+  int                     filterIndex;
+
+  filterIndex = CSTmBlitter__ChooseBlitter8x8FilterCoeffs (hsrcinc);
+  flt->BLT_HFP = (stdev->filter_8x8_phys
+                  + filterIndex * BDISP_AQ_BLIT_FILTER_8X8_TABLE_SIZE);
+
+  filterIndex = CSTmBlitter__ChooseBlitter5x8FilterCoeffs (vsrcinc);
+  flt->BLT_VFP = (stdev->filter_5x8_phys
+                  + filterIndex * BDISP_AQ_BLIT_FILTER_5X8_TABLE_SIZE);
+
+  flt->BLT_RSF  = DFB_FIXED_POINT_TO_BDISP (vsrcinc) << 16;
+  flt->BLT_RSF |= DFB_FIXED_POINT_TO_BDISP (hsrcinc);
+
+  /* Vertical filter setup: repeat the first line twice to pre-fill the
+     filter. This is _not_ the same setup as used for 5 tap video filtering
+     which sets the filter phase to start at +1/2. */
+  flt->BLT_RZI = 2 << BLIT_RZI_V_REPEAT_SHIFT;
+
+  /* Default horizontal filter setup, repeat the first pixel 3 times to
+     pre-fill the 8 Tap filter. */
+  flt->BLT_RZI |= (3 << BLIT_RZI_H_REPEAT_SHIFT);
+}
+
+/* Setup a complex blit node, with the exception of XY and Size and filter
+   subposition.
+
+   This forms a template node, potentially used to create multiple nodes,
+   when doing a rescale that requires the operation to be split up into
+   smaller spans. */
+static bool
+__attribute__((warn_unused_result))
+_bdisp_aq_StretchBlit_setup (STGFX2DriverData * const stdrv,
+                             STGFX2DeviceData * const stdev,
+                             DFBRectangle     * const src,
+                             DFBRectangle     * const dst,
+                             bool             * const requires_spans)
+{
+  stdev->hsrcinc = divide_f16 (src->w / stdev->srcFactorH, dst->w);
+  stdev->vsrcinc = divide_f16 (src->h / stdev->srcFactorV, dst->h);
+
+  D_DEBUG_AT (BDISP_STRETCH, "StretchBlit_setup(): vsrcinc/hsrcinc: %.8x/%.8x -> %u.%06u/%u.%06u\n",
+              stdev->vsrcinc, stdev->hsrcinc,
+              DFB_INT_VALf (stdev->vsrcinc), DFB_INT_VALf (stdev->hsrcinc));
+
+  stdev->hsrcinc = round_f16_to_f10 (stdev->hsrcinc);
+  stdev->vsrcinc = round_f16_to_f10 (stdev->vsrcinc);
+
+  D_DEBUG_AT (BDISP_STRETCH, "  -> rounded to                       %.8x/%.8x -> %u.%06u/%u.%06u\n",
+              stdev->vsrcinc, stdev->hsrcinc,
+              DFB_INT_VALf (stdev->vsrcinc), DFB_INT_VALf (stdev->hsrcinc));
+
+  /* out of range */
+  if ((stdev->hsrcinc > (DFB_FIXED_POINT_VAL (63) + 0xffc0))
+      || (stdev->vsrcinc > (DFB_FIXED_POINT_VAL (63) + 0xffc0))
+      || (stdev->hsrcinc < 0x40)
+      || (stdev->vsrcinc < 0x40))
+    return false;
+
+  /* before setting up the resize filter, setup the flicker filter... */
+  bdisp_aq_flickerfilter_setup (stdev);
+
+  /* ...because the resize filter setup may override the default 1:1
+     resize configuration set by the flicker filter; this is fine the
+     vertical and flicker filters can be active at the same time. */
+  *requires_spans = bdisp_aq_filter_need_spans (src->w,
+                                                stdev->features.line_buffer_length);
+
+  stdev->ConfigGeneral.BLT_CIC |= CIC_NODE_FILTERS | CIC_NODE_2DFILTERSCHR;
+  stdev->ConfigGeneral.BLT_INS |= BLIT_INS_ENABLE_2DRESCALE;
+
+  union _BltNodeGroup0910 filters = { .chroma = &stdev->ConfigFiltersChr };
+  _bdisp_aq_filtering_setup (stdev, stdev->hsrcinc, stdev->vsrcinc, &filters);
+
+  /* FIXME: remove this at some point soon */
+  stdev->ConfigFilters.BLT_FCTL_RZC &= (BLIT_RZC_2DHF_MODE_MASK
+                                        | BLIT_RZC_2DVF_MODE_MASK
+                                        | BLIT_RZC_Y_2DHF_MODE_MASK
+                                        | BLIT_RZC_Y_2DVF_MODE_MASK);
+
+  /* FIXME: treat src1 */
+  if (!_bdisp_aq_Blit_setup_directions (stdev, src, dst, dst))
+    return false;
+
+  if (unlikely (D_FLAGS_IS_SET (stdev->ConfigGeneral.BLT_CIC, CIC_NODE_SOURCE3)))
+    {
+      stdev->ConfigGeneral.BLT_CIC |= CIC_NODE_2DFILTERSLUMA;
+
+      stdev->hsrcinc *= stdev->srcFactorH;
+      stdev->vsrcinc *= stdev->srcFactorV;
+
+      D_DEBUG_AT (BDISP_STRETCH, "StretchBlit_setup(): luma vsrcinc/hsrcinc: %.8x/%.8x -> %u.%06u/%u.%06u\n",
+                  stdev->vsrcinc, stdev->hsrcinc,
+                  DFB_INT_VALf (stdev->vsrcinc), DFB_INT_VALf (stdev->hsrcinc));
+
+      /* out of range */
+      if ((stdev->hsrcinc > (DFB_FIXED_POINT_VAL (63) + 0xffc0))
+          || (stdev->vsrcinc > (DFB_FIXED_POINT_VAL (63) + 0xffc0))
+          || (stdev->hsrcinc < 0x40)
+          || (stdev->vsrcinc < 0x40))
+        return false;
+
+      filters.luma = &stdev->ConfigFiltersLuma;
+      _bdisp_aq_filtering_setup (stdev, stdev->hsrcinc, stdev->vsrcinc,
+                                 &filters);
+
+      D_DEBUG_AT (BDISP_STRETCH, "Y_RSF: %.8x (v %d.%06d h %d.%06d) Y_RZI %.8x\n",
+                  stdev->ConfigFiltersLuma.BLT_Y_RSF,
+                  DFB_INT_VALf ((stdev->ConfigFiltersLuma.BLT_Y_RSF >> 16) << 6),
+                  DFB_INT_VALf ((stdev->ConfigFiltersLuma.BLT_Y_RSF & 0xffff) << 6),
+                  stdev->ConfigFiltersLuma.BLT_Y_RZI);
+
+      D_DEBUG_AT (BDISP_STRETCH, "RSF: %.8x (v %d.%06d h %d.%06d) RZI %.8x\n",
+                  stdev->ConfigFiltersChr.BLT_RSF,
+                  DFB_INT_VALf ((stdev->ConfigFiltersChr.BLT_RSF >> 16) << 6),
+                  DFB_INT_VALf ((stdev->ConfigFiltersChr.BLT_RSF & 0xffff) << 6),
+                  stdev->ConfigFiltersChr.BLT_RZI);
+
+      /* fixme: src1 for backwards blits */
+      _bdisp_aq_Blit_setup_locations (stdrv, stdev, src, dst, dst,
+                                      *requires_spans);
+    }
+  else
+    {
+      /* Vertical filter setup: repeat the first line twice to pre-fill the
+         filter and set the filter phase to start at +1/2. This is the same
+         setup used for 5 tap video filtering. */
+      u32 subpixelpos /* n.16 */;
+      unsigned int repeat /* int */;
+      int adjustedsrcy /* int */;
+      int srcspanheight /* 16.16 */;
+
+      /* let's have _bdisp_aq_Blit_setup_locations() only adjust src2/dst x/y
+         for backwards blits, it should not set write the coordinates yet,
+         because we'll either do that in _bdisp_aq_Blit_using_spans() (when
+         *requires_spans == true), or below. */
+      _bdisp_aq_Blit_setup_locations (stdrv, stdev, src, dst, dst,
+                                      true);
+
+      stdev->ConfigFiltersChr.BLT_RZI  = 0;
+
+      srcspanheight = src->h;
+      Get5TapFilterSetup (src->y,
+                          (stdev->v_src2_sign == 1) ? 0 : src->y,
+                          stdev->source_h,
+                          stdev->v_src2_sign,
+                          true,
+                          &subpixelpos, &adjustedsrcy, &srcspanheight,
+                          &repeat);
+      src->y = DFB_FIXED_POINT_VAL (adjustedsrcy);
+      src->h = srcspanheight;
+      stdev->ConfigSource2.BLT_S2SZ = (DFB_FIXED_POINT_TO_INT (src->h) & 0x0fff) << 16;
+
+      stdev->ConfigFiltersChr.BLT_RZI |= (repeat << BLIT_RZI_V_REPEAT_SHIFT);
+      stdev->ConfigFiltersChr.BLT_RZI |= (DFB_FIXED_POINT_TO_BDISP (subpixelpos)
+                                          << BLIT_RZI_V_INIT_SHIFT);
+
+      if (!*requires_spans)
+        {
+          int adjustedsrcx /* int */;
+          int srcspanwidth /* 16.16 */ = src->w;
+
+          /* assume we can use the whole source surface for filter
+             initialisation */
+          Get8TapFilterSetup (src->x,
+                              (stdev->h_src2_sign == 1) ? 0 : src->x,
+                              stdev->source_w,
+                              stdev->h_src2_sign,
+                              true,
+                              &subpixelpos,
+                              &adjustedsrcx,
+                              &srcspanwidth,
+                              &repeat);
+
+          stdev->ConfigFiltersChr.BLT_RZI |= (repeat << BLIT_RZI_H_REPEAT_SHIFT);
+          stdev->ConfigFiltersChr.BLT_RZI |= (DFB_FIXED_POINT_TO_BDISP (subpixelpos)
+                                              << BLIT_RZI_H_INIT_SHIFT);
+
+          stdev->ConfigTarget.BLT_TXY  = (DFB_FIXED_POINT_TO_INT (dst->y) & 0x0fff) << 16;
+          stdev->ConfigTarget.BLT_TXY |= (DFB_FIXED_POINT_TO_INT (dst->x) & 0x0fff);
+
+          stdev->ConfigTarget.BLT_TSZ_S1SZ  = (DFB_FIXED_POINT_TO_INT (dst->h) & 0x0fff) << 16;
+          stdev->ConfigTarget.BLT_TSZ_S1SZ |= DFB_FIXED_POINT_TO_INT (dst->w) & 0x0fff;
+
+          stdev->ConfigSource1.BLT_S1XY = stdev->ConfigTarget.BLT_TXY;
+
+          stdev->ConfigSource2.BLT_S2XY  = (adjustedsrcy & 0x0fff) << 16;
+          stdev->ConfigSource2.BLT_S2XY |= adjustedsrcx & 0x0fff;
+          stdev->ConfigSource2.BLT_S2SZ  = (DFB_FIXED_POINT_TO_INT (srcspanheight) & 0x0fff) << 16;
+          stdev->ConfigSource2.BLT_S2SZ |= DFB_FIXED_POINT_TO_INT (srcspanwidth) & 0x0fff;
+        }
+
+      D_DEBUG_AT (BDISP_STRETCH, "RSF: %.8x (v %d.%06d h %d.%06d) RZI %.8x\n",
+                  stdev->ConfigFiltersChr.BLT_RSF,
+                  DFB_INT_VALf ((stdev->ConfigFiltersChr.BLT_RSF >> 16) << 6),
+                  DFB_INT_VALf ((stdev->ConfigFiltersChr.BLT_RSF & 0xffff) << 6),
+                  stdev->ConfigFiltersChr.BLT_RZI);
+
+      if (!*requires_spans)
+        D_DEBUG_AT (BDISP_STRETCH, "     S2XY: %.8x S2SZ: %.8x -> TXY %.8x TSZ %.8x (RZI %.8x)\n",
+                    stdev->ConfigSource2.BLT_S2XY, stdev->ConfigSource2.BLT_S2SZ,
+                    stdev->ConfigTarget.BLT_TXY, stdev->ConfigTarget.BLT_TSZ_S1SZ,
+                    stdev->ConfigFiltersChr.BLT_RZI);
+    }
+
+  return true;
+}
+
+/* Setup a complex blit node, with the exception of XY and Size and filter
+   subposition.
+
+   This forms a template node, potentially used to create multiple nodes,
+   when doing a rescale that requires the operation to be split up into
+   smaller spans. */
+static bool
+__attribute__((warn_unused_result))
+_bdisp_aq_Blit_setup (STGFX2DriverData * const stdrv,
+                      STGFX2DeviceData * const stdev,
+                      DFBRectangle     * const src2,
+                      DFBRectangle     * const src1,
+                      DFBRectangle     * const dst,
+                      bool             * const requires_spans)
+{
+  if (unlikely (bdisp_aq_flickerfilter_setup (stdev)))
+    *requires_spans = bdisp_aq_filter_need_spans (src2->w,
+                                                  stdev->features.line_buffer_length);
+  else
+    {
+      /* we might have done a stretch blit before and do a normal blit now,
+         in which case make sure to disable the rescaling engine. In the
+         above case w/ the enabled flicker filter, this doesn't matter as the
+         rescaling factors are reset to 1 anyway. */
+      stdev->ConfigGeneral.BLT_CIC &= ~(CIC_NODE_2DFILTERSCHR
+                                        | CIC_NODE_2DFILTERSLUMA);
+      if (!(stdev->ConfigGeneral.BLT_INS & BLIT_INS_ENABLE_PLANEMASK))
+        stdev->ConfigGeneral.BLT_CIC &= ~CIC_NODE_FILTERS;
+      stdev->ConfigGeneral.BLT_INS &= ~BLIT_INS_ENABLE_2DRESCALE;
+
+      *requires_spans = false;
+    }
+
+  if (!_bdisp_aq_Blit_setup_directions (stdev, src2, src1, dst))
+    return false;
+
+  _bdisp_aq_Blit_setup_locations (stdrv, stdev, src2, src1, dst,
+                                  *requires_spans);
+
+  return true;
+}
+
+
+
+
+typedef struct _BDispAqNodeState
+{
+  CorePalette *palette;
+  Stgfx2Clut   palette_type;
+  struct _BltNodeGroup00 ConfigGeneral;
+} BDispAqNodeState;
+
+static void
+bdisp_aq_second_node_prepare (STGFX2DriverData * const stdrv,
+                              STGFX2DeviceData * const stdev,
+                              BDispAqNodeState * const state)
+{
+  D_ASSERT (state != NULL);
+
+  state->ConfigGeneral = stdev->ConfigGeneral;
+  stdev->ConfigGeneral = stdev->blitstate.extra_passes[0].ConfigGeneral;
+
+  state->palette      = stdev->palette;
+  state->palette_type = stdev->palette_type;
+
+  stdev->palette_type = stdev->blitstate.extra_passes[0].palette_type;
+  if (stdev->palette_type != SG2C_NORMAL)
+    stdev->palette = NULL;
+
+  bdisp_aq_setup_blit_operation (stdrv, stdev);
+}
+
+static void
+bdisp_aq_third_node_prepare (STGFX2DriverData * const stdrv,
+                             STGFX2DeviceData * const stdev)
+{
+  stdev->ConfigGeneral = stdev->blitstate.extra_passes[1].ConfigGeneral;
+
+  stdev->palette_type = stdev->blitstate.extra_passes[1].palette_type;
+  if (stdev->palette_type != SG2C_NORMAL)
+    stdev->palette = NULL;
+
+  bdisp_aq_setup_blit_operation (stdrv, stdev);
+}
+
+static void
+bdisp_aq_second_node_release (STGFX2DriverData * const stdrv,
+                              STGFX2DeviceData * const stdev,
+                              BDispAqNodeState * const state)
+{
+  D_ASSERT (state != NULL);
+
+  /* restore */
+  stdev->ConfigGeneral = state->ConfigGeneral;
+  stdev->palette = state->palette;
+  stdev->palette_type = state->palette_type;
+
+  bdisp_aq_setup_blit_operation (stdrv, stdev);
+}
+
+
+static bool
+_check_size_constraints (int x,
+                         int y,
+                         int w,
+                         int h)
+{
+  if (unlikely (x < -4096 || y < -4096))
+    return false;
+  if (unlikely (x > 4095 || y > 4095))
+    return false;
+  if (unlikely (w < 1 || h < 1))
+    return false;
+  if (unlikely (w > 4095 || h > 4095))
+    return false;
+
+  return true;
+}
+
+static bool
+_check_size_constraints_f16 (int x,
+                             int y,
+                             int w,
+                             int h)
+{
+  if (unlikely (x < DFB_FIXED_POINT_VAL (-4096)
+                || y < DFB_FIXED_POINT_VAL (-4096)))
+    return false;
+  if (unlikely (x > DFB_FIXED_POINT_VAL (4095)
+                || y > DFB_FIXED_POINT_VAL (4095)))
+    return false;
+  if (unlikely (w <= 0 || h <= 0))
+    return false;
+  if (unlikely (w > DFB_FIXED_POINT_VAL (4095)
+                || h > DFB_FIXED_POINT_VAL (4095)))
+    return false;
+
+  return true;
+}
+
+bool
+bdisp_aq_FillRectangle_simple (void         * const drv,
+                               void         * const dev,
+                               DFBRectangle * const rect)
+{
+  STGFX2DriverData     * const stdrv = drv;
+  STGFX2DeviceData     * const stdev = dev;
+  STMFBBDispSharedArea * const shared = stdrv->bdisp_shared;
+
+  D_DEBUG_AT (BDISP_BLT, "%s (%d, %d - %dx%d)\n", __FUNCTION__,
+              DFB_RECTANGLE_VALS (rect));
+  DUMP_INFO ();
+
+  if (unlikely (!rect->w || !rect->h))
+    return true;
+  if (!_check_size_constraints (rect->x, rect->y, rect->w, rect->h))
+    return false;
+
+  struct _BltNode_Fast * node =
+    _bdisp_aq_get_new_node_prepared_simple (stdrv, stdev, shared);
+
+  /* dimensions */
+  node->common.ConfigTarget.BLT_TXY
+    = (rect->y << 16) | rect->x;
+  node->common.ConfigTarget.BLT_TSZ_S1SZ
+    = (rect->h << 16) | rect->w;
+
+  _bdisp_aq_finish_node (stdrv, stdev, shared, node);
+
+  return true;
+}
+
+bool
+bdisp_aq_FillRectangle (void         * const drv,
+                        void         * const dev,
+                        DFBRectangle * const rect)
+{
+  STGFX2DriverData     * const stdrv = drv;
+  STGFX2DeviceData     * const stdev = dev;
+  STMFBBDispSharedArea * const shared = stdrv->bdisp_shared;
+
+  D_DEBUG_AT (BDISP_BLT, "%s (%d, %d - %dx%d)\n", __FUNCTION__,
+              DFB_RECTANGLE_VALS (rect));
+  DUMP_INFO ();
+
+  if (unlikely (!rect->w || !rect->h))
+    return true;
+  if (!_check_size_constraints (rect->x, rect->y, rect->w, rect->h))
+    return false;
+
+  struct _BltNode_FullFill * const node =
+    _bdisp_aq_get_new_node_prepared_slow (stdrv, stdev, shared);
+
+  /* dimensions */
+  node->common.ConfigTarget.BLT_TXY
+    = node->common.ConfigSource1.BLT_S1XY
+    = node->ConfigSource2.BLT_S2XY
+    = (rect->y << 16) | rect->x;
+  node->common.ConfigTarget.BLT_TSZ_S1SZ
+    = node->ConfigSource2.BLT_S2SZ
+    = (rect->h << 16) | rect->w;
+
+  _bdisp_aq_finish_node (stdrv, stdev, shared, node);
+
+  return true;
+}
+
+
+bool
+bdisp_aq_DrawRectangle_simple (void         * const drv,
+                               void         * const dev,
+                               DFBRectangle * const rect)
+{
+  STGFX2DriverData     * const stdrv = drv;
+  STGFX2DeviceData     * const stdev = dev;
+  STMFBBDispSharedArea * const shared = stdrv->bdisp_shared;
+
+  struct _BltNode_Fast *node;
+
+  D_DEBUG_AT (BDISP_BLT, "%s (%d, %d - %dx%d)\n", __FUNCTION__,
+              DFB_RECTANGLE_VALS (rect));
+  DUMP_INFO ();
+
+  if (unlikely (!rect->w || !rect->h))
+    return true;
+  if (!_check_size_constraints (rect->x, rect->y, rect->w, rect->h))
+    return false;
+
+  if (unlikely (rect->h == 2 || rect->w == 2))
+    return bdisp_aq_FillRectangle_simple (drv, dev, rect);
+
+  /* this is optimized for w >= h, we could optimize this for the case w < h,
+     or maybe do it in a more generic way. but we don't care. */
+  {
+  /* top line */
+  node = _bdisp_aq_get_new_node_prepared_simple (stdrv, stdev, shared);
+  node->common.ConfigTarget.BLT_TXY
+    = (rect->y << 16) | rect->x;
+  node->common.ConfigTarget.BLT_TSZ_S1SZ = (1 << 16) | rect->w;
+  _bdisp_aq_finish_node (stdrv, stdev, shared, node);
+  }
+
+  if (likely (rect->h > 1))
+    {
+      int y2 = rect->y + 1;
+      int h2 = rect->h - 2;
+
+      /* left line */
+      node = _bdisp_aq_get_new_node_prepared_simple (stdrv, stdev, shared);
+      node->common.ConfigTarget.BLT_TXY
+        = (y2 << 16) | rect->x;
+      node->common.ConfigTarget.BLT_TSZ_S1SZ = (h2 << 16) | 1;
+      _bdisp_aq_finish_node (stdrv, stdev, shared, node);
+
+      if (likely (rect->w > 1))
+        {
+          /* right line */
+          node = _bdisp_aq_get_new_node_prepared_simple (stdrv, stdev, shared);
+          node->common.ConfigTarget.BLT_TXY
+            = (y2 << 16) | (rect->x + rect->w - 1);
+          node->common.ConfigTarget.BLT_TSZ_S1SZ = (h2 << 16) | 1;
+          _bdisp_aq_finish_node (stdrv, stdev, shared, node);
+        }
+
+      /* bottom line */
+      node = _bdisp_aq_get_new_node_prepared_simple (stdrv, stdev, shared);
+      node->common.ConfigTarget.BLT_TXY
+        = ((rect->y + rect->h - 1) << 16) | rect->x;
+      node->common.ConfigTarget.BLT_TSZ_S1SZ = (1 << 16) | rect->w;
+      _bdisp_aq_finish_node (stdrv, stdev, shared, node);
+    }
+
+  return true;
+}
+
+
+bool
+bdisp_aq_DrawRectangle (void         * const drv,
+                        void         * const dev,
+                        DFBRectangle * const rect)
+{
+  STGFX2DriverData     * const stdrv = drv;
+  STGFX2DeviceData     * const stdev = dev;
+  STMFBBDispSharedArea * const shared = stdrv->bdisp_shared;
+
+  struct _BltNode_FullFill *node;
+
+  D_DEBUG_AT (BDISP_BLT, "%s (%d, %d - %dx%d)\n", __FUNCTION__,
+              DFB_RECTANGLE_VALS (rect));
+  DUMP_INFO ();
+
+  if (unlikely (!rect->w || !rect->h))
+    return true;
+  if (!_check_size_constraints (rect->x, rect->y, rect->w, rect->h))
+    return false;
+
+  if (unlikely (rect->h == 2 || rect->w == 2))
+    return bdisp_aq_FillRectangle (drv, dev, rect);
+
+  /* FIXME: instead of calling _bdisp_aq_get_new_node_prepared_slow() multiple
+     times, we could probably just memcpy() the first one, but then, the
+     source memory would be uncached, need to check which method is actually
+     faster... */
+  node = _bdisp_aq_get_new_node_prepared_slow (stdrv, stdev, shared);
+
+  /* this is optimized for w >= h, we could optimize this for the case w < h,
+     or maybe do it in a more generic way. but we don't care. */
+  {
+  /* top line */
+  node->common.ConfigTarget.BLT_TXY
+    = node->common.ConfigSource1.BLT_S1XY
+    = node->ConfigSource2.BLT_S2XY
+    = (rect->y << 16) | rect->x;
+  node->common.ConfigTarget.BLT_TSZ_S1SZ
+    = node->ConfigSource2.BLT_S2SZ
+    = (1 << 16) | rect->w;
+  _bdisp_aq_finish_node (stdrv, stdev, shared, node);
+  }
+
+  if (likely (rect->h > 1))
+    {
+      int y2 = rect->y + 1;
+      int h2 = rect->h - 2;
+
+      /* left line */
+      node = _bdisp_aq_get_new_node_prepared_slow (stdrv, stdev, shared);
+      node->common.ConfigTarget.BLT_TXY
+        = node->common.ConfigSource1.BLT_S1XY
+        = node->ConfigSource2.BLT_S2XY
+        = (y2 << 16) | rect->x;
+      node->common.ConfigTarget.BLT_TSZ_S1SZ
+        = node->ConfigSource2.BLT_S2SZ
+        = (h2 << 16) | 1;
+      _bdisp_aq_finish_node (stdrv, stdev, shared, node);
+
+      if (likely (rect->w > 1))
+        {
+          /* right line */
+          node = _bdisp_aq_get_new_node_prepared_slow (stdrv, stdev, shared);
+          node->common.ConfigTarget.BLT_TXY
+            = node->common.ConfigSource1.BLT_S1XY
+            = node->ConfigSource2.BLT_S2XY
+            = (y2 << 16) | (rect->x + rect->w - 1);
+          node->common.ConfigTarget.BLT_TSZ_S1SZ
+            = node->ConfigSource2.BLT_S2SZ
+            = (h2 << 16) | 1;
+          _bdisp_aq_finish_node (stdrv, stdev, shared, node);
+        }
+
+      /* bottom line */
+      node = _bdisp_aq_get_new_node_prepared_slow (stdrv, stdev, shared);
+      node->common.ConfigTarget.BLT_TXY
+        = node->common.ConfigSource1.BLT_S1XY
+        = node->ConfigSource2.BLT_S2XY
+        = ((rect->y + rect->h - 1) << 16) | rect->x;
+      node->common.ConfigTarget.BLT_TSZ_S1SZ
+        = node->ConfigSource2.BLT_S2SZ
+        = (1 << 16) | rect->w;
+      _bdisp_aq_finish_node (stdrv, stdev, shared, node);
+    }
+
+  return true;
+}
+
+
+bool
+bdisp_aq_Blit_simple (void         * const drv,
+                      void         * const dev,
+                      DFBRectangle * const rect,
+                      int           dx,
+                      int           dy)
+{
+  STGFX2DriverData     * const stdrv = drv;
+  STGFX2DeviceData     * const stdev = dev;
+  STMFBBDispSharedArea * const shared = stdrv->bdisp_shared;
+  bool                  copy_backwards;
+
+  if (!stdev->bFixedPoint)
+    D_DEBUG_AT (BDISP_BLT, "%s (%d,%d-%dx%d -> %d,%d)\n", __FUNCTION__,
+                DFB_RECTANGLE_VALS (rect), dx, dy);
+  else
+    {
+      D_DEBUG_AT (BDISP_BLT, "%s (%d,%d-%dx%d -> %d,%d)\n", __FUNCTION__,
+                  DFB_RECTANGLE_VALS (rect), dx, dy);
+      dfb_rectangle_downscale (rect);
+      dx /= DFB_FIXED_POINT_ONE;
+      dy /= DFB_FIXED_POINT_ONE;
+    }
+  DUMP_INFO ();
+
+  if (unlikely (!rect->w || !rect->h))
+    return true;
+  if (!_check_size_constraints (rect->x, rect->y, rect->w, rect->h))
+    goto error;
+  if (!_check_size_constraints (dx, dy, 1, 1))
+    goto error;
+
+  struct _BltNode_Fast * const node = _bdisp_aq_get_new_node (stdrv, stdev,
+                                                              shared);
+  u32 blt_cic = CIC_BLT_NODE_FAST;
+  u32 blt_ins = BLIT_INS_SRC1_MODE_DIRECT_COPY;
+  u32 tty;
+  u32 s1ty;
+
+  bdisp_aq_update_num_ops (stdev, shared, blt_ins);
+
+  /* target */
+  tty = bdisp_ty_sanitise_direction (stdev->ConfigTarget.BLT_TTY);
+  node->common.ConfigTarget.BLT_TBA = stdev->ConfigTarget.BLT_TBA;
+
+  /* source (taken from source2 setup) */
+  node->common.ConfigSource1.BLT_S1BA = stdev->ConfigSource2.BLT_S2BA;
+  s1ty = (bdisp_ty_sanitise_direction (stdev->ConfigSource2.BLT_S2TY)
+          & ~BLIT_TY_COLOR_EXPAND_MASK);
+
+  D_ASSUME ((s1ty & BLIT_TY_COLOR_FORM_MASK) == (tty & BLIT_TY_COLOR_FORM_MASK));
+
+  /* work out copy direction */
+  copy_backwards = false;
+  if (unlikely ((stdev->ConfigSource2.BLT_S2BA == stdev->ConfigTarget.BLT_TBA)
+                && (dy > rect->y
+                    || ((dy == rect->y) && (dx > rect->x)))))
+    {
+      DFBRectangle dst = { .x = dx, .y = dy, .w = rect->w, .h = rect->h };
+      copy_backwards = _bdisp_aq_rectangles_intersect (rect, &dst);
+    }
+
+  /* and set up coordinates & size */
+  if (!copy_backwards)
+    {
+      node->common.ConfigSource1.BLT_S1XY = (rect->y << 16) | rect->x;
+      node->common.ConfigTarget.BLT_TXY = (dy << 16) | dx;
+    }
+  else
+    {
+      s1ty |= (BLIT_TY_COPYDIR_BOTTOMTOP | BLIT_TY_COPYDIR_RIGHTLEFT);
+      tty  |= (BLIT_TY_COPYDIR_BOTTOMTOP | BLIT_TY_COPYDIR_RIGHTLEFT);
+
+      node->common.ConfigSource1.BLT_S1XY
+        = ((rect->y + rect->h - 1) << 16) | (rect->x + rect->w - 1);
+      node->common.ConfigTarget.BLT_TXY
+        = ((dy + rect->h - 1) << 16) | (dx + rect->w - 1);
+    }
+
+  node->common.ConfigTarget.BLT_TTY   = tty;
+  node->common.ConfigSource1.BLT_S1TY = s1ty;
+
+  node->common.ConfigTarget.BLT_TSZ_S1SZ = (rect->h << 16) | rect->w;
+
+  node->common.ConfigGeneral.BLT_CIC = blt_cic;
+  node->common.ConfigGeneral.BLT_INS = blt_ins;
+  /* BLT_ACK is ignored by the hardware in this case... */
+
+  bdisp_aq_update_config_static (shared, &node->ConfigStatic);
+
+  _bdisp_aq_finish_node (stdrv, stdev, shared, node);
+
+  return true;
+
+error:
+  if (stdev->bFixedPoint)
+    dfb_rectangle_upscale (rect);
+  return false;
+}
+
+bool
+bdisp_aq_Blit_simple_YCbCr422r (void         * const drv,
+                                void         * const dev,
+                                DFBRectangle * const rect,
+                                int           dx,
+                                int           dy)
+{
+  STGFX2DeviceData * const stdev = dev;
+  u32               tty = stdev->ConfigTarget.BLT_TTY;
+  u32               s2ty = stdev->ConfigSource2.BLT_S2TY;
+  bool              result;
+
+  stdev->ConfigTarget.BLT_TTY &= ~(BLIT_TY_COLOR_FORM_MASK | BLIT_TY_FULL_ALPHA_RANGE | BLIT_TY_BIG_ENDIAN);
+  stdev->ConfigTarget.BLT_TTY |= BLIT_COLOR_FORM_RGB565;
+  stdev->ConfigSource2.BLT_S2TY &= ~(BLIT_TY_COLOR_FORM_MASK | BLIT_TY_FULL_ALPHA_RANGE | BLIT_TY_BIG_ENDIAN);
+  stdev->ConfigSource2.BLT_S2TY |= BLIT_COLOR_FORM_RGB565;
+
+  result = bdisp_aq_Blit_simple (drv, dev, rect, dx, dy);
+
+  stdev->ConfigSource2.BLT_S2TY = s2ty;
+  stdev->ConfigTarget.BLT_TTY  = tty;
+
+  return result;
+}
+
+bool
+bdisp_aq_Blit (void         * const drv,
+               void         * const dev,
+               DFBRectangle * const rect,
+               int           dx,
+               int           dy)
+{
+  STGFX2DriverData * const stdrv = drv;
+  STGFX2DeviceData * const stdev = dev;
+  bool              requires_spans;
+
+  if (!stdev->bFixedPoint)
+    {
+      dfb_rectangle_upscale (rect);
+      dx *= DFB_FIXED_POINT_ONE;
+      dy *= DFB_FIXED_POINT_ONE;
+    }
+  D_DEBUG_AT (BDISP_BLT, "%s (%d.%06d,%d.%06d-%d.%06dx%d.%06d -> %d.%06d,%d.%06d)\n", __FUNCTION__,
+              DFB_RECTANGLE_VALSf (rect), DFB_INT_VALf (dx),
+              DFB_INT_VALf (dy));
+  DUMP_INFO ();
+
+  /* split buffer formats _always_ need the rescale engine enabled. */
+  D_ASSERT (!D_FLAGS_IS_SET (stdev->ConfigGeneral.BLT_CIC, CIC_NODE_SOURCE3));
+
+  if (unlikely (!rect->w || !rect->h))
+    return true;
+  if (!_check_size_constraints_f16 (rect->x, rect->y, rect->w, rect->h))
+    goto error;
+  if (!_check_size_constraints_f16 (dx, dy, 1, 1))
+    goto error;
+
+  DFBRectangle rect_backup;
+  if (stdev->blitstate.n_passes > 1)
+    rect_backup = *rect;
+
+  DFBRectangle dst = { dx, dy, rect->w, rect->h };
+  if (unlikely (!_bdisp_aq_Blit_setup (stdrv, stdev, rect, &dst, &dst,
+                                       &requires_spans)))
+    goto error;
+
+  if (likely (!requires_spans))
+    {
+      bdisp_aq_copy_n_push_node (stdrv, stdev);
+      bdisp_aq_clut_update_disable_if_unsafe (stdev);
+    }
+  else
+    _bdisp_aq_Blit_using_spans (stdrv, stdev, rect, &dst);
+
+
+  if (stdev->blitstate.n_passes > 1)
+    {
+      BDispAqNodeState state;
+      bool             dummy;
+
+      bdisp_aq_second_node_prepare (stdrv, stdev, &state);
+
+      *rect = rect_backup;
+      dst.x = dx; dst.y = dy; dst.w = rect->w; dst.h = rect->h;
+      /* setup did work earlier, so it just has to work a second time, too! */
+      dummy = _bdisp_aq_Blit_setup (stdrv, stdev, rect, &dst, &dst,
+                                    &requires_spans);
+      (void) dummy;
+
+      if (likely (!requires_spans))
+        {
+          bdisp_aq_copy_n_push_node (stdrv, stdev);
+          bdisp_aq_clut_update_disable_if_unsafe (stdev);
+        }
+      else
+        _bdisp_aq_Blit_using_spans (stdrv, stdev, rect, &dst);
+
+      if (stdev->blitstate.n_passes > 2)
+        {
+          bdisp_aq_third_node_prepare (stdrv, stdev);
+
+          *rect = rect_backup;
+          dst.x = dx; dst.y = dy; dst.w = rect->w; dst.h = rect->h;
+          /* setup did work earlier, so it just has to work a second time, too! */
+          dummy = _bdisp_aq_Blit_setup (stdrv, stdev, rect, &dst, &dst,
+                                        &requires_spans);
+          (void) dummy;
+
+          if (likely (!requires_spans))
+            {
+              bdisp_aq_copy_n_push_node (stdrv, stdev);
+              bdisp_aq_clut_update_disable_if_unsafe (stdev);
+            }
+          else
+            _bdisp_aq_Blit_using_spans (stdrv, stdev, rect, &dst);
+        }
+
+      bdisp_aq_second_node_release (stdrv, stdev, &state);
+    }
+
+
+  return true;
+
+error:
+  if (!stdev->bFixedPoint)
+    dfb_rectangle_downscale (rect);
+  return false;
+}
+
+
+bool
+bdisp_aq_StretchBlit (void         * const drv,
+                      void         * const dev,
+                      DFBRectangle * const srect,
+                      DFBRectangle * const drect)
+{
+  STGFX2DriverData * const stdrv = drv;
+  STGFX2DeviceData * const stdev = dev;
+  bool              requires_spans;
+
+  if (!stdev->bFixedPoint)
+    {
+      dfb_rectangle_upscale (srect);
+      dfb_rectangle_upscale (drect);
+    }
+  D_DEBUG_AT (BDISP_STRETCH, "%s (%d.%06d,%d.%06d-%d.%06dx%d.%06d -> %d.%06d,%d.%06d-%d.%06dx%d.%06d)\n", __FUNCTION__,
+              DFB_RECTANGLE_VALSf (srect), DFB_RECTANGLE_VALSf (drect));
+  DUMP_INFO ();
+
+  if (unlikely (!srect->w || !srect->h || !drect->w || !drect->h))
+    return true;
+  if (!_check_size_constraints_f16 (srect->x, srect->y, srect->w, srect->h))
+    goto error;
+  if (!_check_size_constraints_f16 (drect->x, drect->y, drect->w, drect->h))
+    goto error;
+  /* FIXME: something in WebKit/GTK+/Cairo ends up setting a stretchblit to
+     a destination size of 1x1. We should special case this by using just some
+     random pixel value in the input (maybe the top left one?) */
+
+  DFBRectangle srect_backup;
+  DFBRectangle drect_backup;
+  if (stdev->blitstate.n_passes > 1)
+    {
+      srect_backup = *srect;
+      drect_backup = *drect;
+    }
+
+  if (!_bdisp_aq_StretchBlit_setup (stdrv, stdev, srect, drect,
+                                    &requires_spans))
+    goto error;
+
+  if (!requires_spans)
+    {
+      bdisp_aq_copy_n_push_node (stdrv, stdev);
+      bdisp_aq_clut_update_disable_if_unsafe (stdev);
+    }
+  else
+    _bdisp_aq_Blit_using_spans (stdrv, stdev, srect, drect);
+
+
+  if (stdev->blitstate.n_passes > 1)
+    {
+      BDispAqNodeState state;
+      bool             dummy;
+
+      bdisp_aq_second_node_prepare (stdrv, stdev, &state);
+
+      *srect = srect_backup;
+      *drect = drect_backup;
+      /* setup did work earlier, so it just has to work a second time, too! */
+      dummy = _bdisp_aq_StretchBlit_setup (stdrv, stdev, srect, drect,
+                                           &requires_spans);
+      (void) dummy;
+
+      if (!requires_spans)
+        {
+          bdisp_aq_copy_n_push_node (stdrv, stdev);
+          bdisp_aq_clut_update_disable_if_unsafe (stdev);
+        }
+      else
+        _bdisp_aq_Blit_using_spans (stdrv, stdev, srect, drect);
+
+      if (stdev->blitstate.n_passes > 2)
+        {
+          bdisp_aq_third_node_prepare (stdrv, stdev);
+
+          *srect = srect_backup;
+          *drect = drect_backup;
+          /* setup did work earlier, so it just has to work a second time, too! */
+          dummy = _bdisp_aq_StretchBlit_setup (stdrv, stdev, srect, drect,
+                                               &requires_spans);
+          (void) dummy;
+
+          if (!requires_spans)
+            {
+              bdisp_aq_copy_n_push_node (stdrv, stdev);
+              bdisp_aq_clut_update_disable_if_unsafe (stdev);
+            }
+          else
+            _bdisp_aq_Blit_using_spans (stdrv, stdev, srect, drect);
+        }
+
+      bdisp_aq_second_node_release (stdrv, stdev, &state);
+    }
+
+  return true;
+
+error:
+  if (!stdev->bFixedPoint)
+    {
+      dfb_rectangle_downscale (srect);
+      dfb_rectangle_downscale (drect);
+    }
+  return false;
+}
+
+bool
+bdisp_aq_Blit_as_stretch (void         * const drv,
+                          void         * const dev,
+                          DFBRectangle * const rect,
+                          int           dx,
+                          int           dy)
+{
+  DFBRectangle drect = { .x = dx, .y = dy, .w = rect->w, .h = rect->h };
+  return bdisp_aq_StretchBlit (drv, dev, rect, &drect);
+}
+
+bool
+bdisp_aq_Blit2 (void         * const drv,
+                void         * const dev,
+                DFBRectangle * const rect,
+                int           dx,
+                int           dy,
+                int           sx2,
+                int           sy2)
+{
+  STGFX2DriverData * const stdrv = drv;
+  STGFX2DeviceData * const stdev = dev;
+  bool              requires_spans;
+
+  if (!stdev->bFixedPoint)
+    {
+      dfb_rectangle_upscale (rect);
+      dx *= DFB_FIXED_POINT_ONE;
+      dy *= DFB_FIXED_POINT_ONE;
+      sx2 *= DFB_FIXED_POINT_ONE;
+      sy2 *= DFB_FIXED_POINT_ONE;
+    }
+  D_DEBUG_AT (BDISP_BLT, "%s (%d.%06d,%d.%06d-%d.%06dx%d.%06d + %d.%06d,%d.%06d -> %d.%06d,%d.%06d)\n", __FUNCTION__,
+              DFB_RECTANGLE_VALSf (rect), DFB_INT_VALf (sx2),
+              DFB_INT_VALf (sy2), DFB_INT_VALf (dx), DFB_INT_VALf (dy));
+  DUMP_INFO ();
+
+  /* split buffer formats _always_ need the rescale engine enabled. */
+  D_ASSERT (!D_FLAGS_IS_SET (stdev->ConfigGeneral.BLT_CIC, CIC_NODE_SOURCE3));
+
+  if (unlikely (!rect->w || !rect->h))
+    return true;
+  if (!_check_size_constraints_f16 (rect->x, rect->y, rect->w, rect->h))
+    goto error;
+  if (!_check_size_constraints_f16 (dx, dy, 1, 1))
+    goto error;
+  if (!_check_size_constraints_f16 (sx2, sy2, 1, 1))
+    goto error;
+
+  DFBRectangle rect_backup;
+  if (stdev->blitstate.n_passes > 1)
+    rect_backup = *rect;
+
+  DFBRectangle src1 = { sx2, sy2, rect->w, rect->h };
+  DFBRectangle dst = { dx, dy, rect->w, rect->h };
+  if (unlikely (!_bdisp_aq_Blit_setup (stdrv, stdev, rect, &src1, &dst,
+                                       &requires_spans)))
+    goto error;
+
+  if (likely (!requires_spans))
+    {
+      bdisp_aq_copy_n_push_node (stdrv, stdev);
+      bdisp_aq_clut_update_disable_if_unsafe (stdev);
+    }
+  else
+    _bdisp_aq_Blit_using_spans (stdrv, stdev, rect, &dst);
+
+
+  if (stdev->blitstate.n_passes > 1)
+    {
+      BDispAqNodeState state;
+      bool             dummy;
+
+      bdisp_aq_second_node_prepare (stdrv, stdev, &state);
+
+      *rect = rect_backup;
+      src1.x = sx2; src1.y = sy2; src1.w = rect->w; src1.h = rect->h;
+      dst.x = dx; dst.y = dy; dst.w = rect->w; dst.h = rect->h;
+      /* setup did work earlier, so it just has to work a second time, too! */
+      dummy = _bdisp_aq_Blit_setup (stdrv, stdev, rect, &src1, &dst,
+                                    &requires_spans);
+      (void) dummy;
+
+      if (likely (!requires_spans))
+        {
+          bdisp_aq_copy_n_push_node (stdrv, stdev);
+          bdisp_aq_clut_update_disable_if_unsafe (stdev);
+        }
+      else
+        _bdisp_aq_Blit_using_spans (stdrv, stdev, rect, &dst);
+
+      if (stdev->blitstate.n_passes > 2)
+        {
+          bdisp_aq_third_node_prepare (stdrv, stdev);
+
+          *rect = rect_backup;
+          dst.x = dx; dst.y = dy; dst.w = rect->w; dst.h = rect->h;
+          src1.x = sx2; src1.y = sy2; src1.w = rect->w; src1.h = rect->h;
+          /* setup did work earlier, so it just has to work a second time, too! */
+          dummy = _bdisp_aq_Blit_setup (stdrv, stdev, rect, &src1, &dst,
+                                        &requires_spans);
+          (void) dummy;
+
+          if (likely (!requires_spans))
+            {
+              bdisp_aq_copy_n_push_node (stdrv, stdev);
+              bdisp_aq_clut_update_disable_if_unsafe (stdev);
+            }
+          else
+            _bdisp_aq_Blit_using_spans (stdrv, stdev, rect, &dst);
+        }
+
+      bdisp_aq_second_node_release (stdrv, stdev, &state);
+    }
+
+
+  return true;
+
+error:
+  if (!stdev->bFixedPoint)
+    dfb_rectangle_downscale (rect);
+  return false;
+}
+
+
+bool
+bdisp_aq_StretchBlit_RLE (void                        * const drv,
+                          void                        * const dev,
+                          unsigned long                src_address,
+                          unsigned long                src_length,
+                          const CoreSurfaceBufferLock * const dst,
+                          const DFBRectangle          * const drect)
+{
+  STGFX2DriverData     * const stdrv = drv;
+  STGFX2DeviceData     * const stdev = dev;
+  STMFBBDispSharedArea * const shared = stdrv->bdisp_shared;
+
+  D_DEBUG_AT (BDISP_BLT, "%s (%lu -> %d,%d-%dx%d)\n", __FUNCTION__,
+              src_length, DFB_RECTANGLE_VALS (drect));
+  DUMP_INFO ();
+
+  /* FIXME: FIXED_POINT support? */
+
+  if (unlikely (!src_length))
+    return true;
+  if (unlikely (src_length > 0x00ffffff))
+    return false;
+  if (!_check_size_constraints (drect->x, drect->y, drect->w, drect->h))
+    return false;
+  if (unlikely (!(stdev->features.blitflags & STM_BLITTER_FLAGS_RLE_DECODE)))
+    return false;
+
+  struct _BltNode_Fast * const node = _bdisp_aq_get_new_node (stdrv, stdev,
+                                                              shared);
+  u32 blt_ins = BLIT_INS_SRC1_MODE_MEMORY;
+
+  bdisp_aq_update_num_ops (stdev, shared, blt_ins);
+
+  /* target */
+  node->common.ConfigTarget.BLT_TBA = dst->phys;
+  _bdisp_state_set_buffer_type (stdev, &node->common.ConfigTarget.BLT_TTY,
+                                dst->buffer->format, dst->pitch);
+  node->common.ConfigTarget.BLT_TXY = (drect->y << 16) | drect->x;
+  node->common.ConfigTarget.BLT_TSZ_S1SZ = (drect->h << 16) | drect->w;
+
+  /* source */
+  node->common.ConfigSource1.BLT_S1BA = src_address;
+  node->common.ConfigSource1.BLT_S1TY = BLIT_COLOR_FORM_RLD_BD;
+  node->common.ConfigSource1.BLT_S1XY = src_length;
+
+  node->common.ConfigGeneral.BLT_CIC = CIC_BLT_NODE_FAST;
+  node->common.ConfigGeneral.BLT_INS = blt_ins;
+  node->common.ConfigGeneral.BLT_ACK = BLIT_ACK_BYPASSSOURCE1;
+
+  bdisp_aq_update_config_static (shared, &node->ConfigStatic);
+
+  _bdisp_aq_finish_node (stdrv, stdev, shared, node);
+
+  return true;
+}
+
+
+static bool
+bdisp_aq_Blit_shortcut_real (void         * const drv,
+                             void         * const dev,
+                             DFBRectangle * const rect,
+                             int           dx,
+                             int           dy,
+                             u32           color)
+{
+  STGFX2DriverData     * const stdrv = drv;
+  STGFX2DeviceData     * const stdev = dev;
+  STMFBBDispSharedArea * const shared = stdrv->bdisp_shared;
+
+  if (!stdev->bFixedPoint)
+    D_DEBUG_AT (BDISP_BLT, "%s (%d,%d-%dx%d -> %d,%d)\n", __FUNCTION__,
+                DFB_RECTANGLE_VALS (rect), dx, dy);
+  else
+    {
+      D_DEBUG_AT (BDISP_BLT, "%s (%d.%06d,%d.%06d-%d.%06dx%d.%06d -> %d.%06d,%d.%06d)\n",
+                  __FUNCTION__, DFB_RECTANGLE_VALSf (rect),
+                  DFB_INT_VALf (dx), DFB_INT_VALf (dy));
+      dfb_rectangle_downscale (rect);
+      dx /= DFB_FIXED_POINT_ONE;
+      dy /= DFB_FIXED_POINT_ONE;
+    }
+  DUMP_INFO ();
+
+  if (unlikely (!rect->w || !rect->h))
+    return true;
+  if (!_check_size_constraints (rect->x, rect->y, rect->w, rect->h))
+    goto error;
+  if (!_check_size_constraints (dx, dy, 1, 1))
+    goto error;
+
+  struct _BltNode_Fast * node =
+    _bdisp_aq_get_new_node_prepared_simple (stdrv, stdev, shared);
+
+  /* this must be DSPD_CLEAR, set source1 == destination. For YUV formats,
+     we let the hardware do conversion from ARGB, thus will not get here */
+  D_ASSERT (!BLIT_TY_COLOR_FORM_IS_YUV (stdev->ConfigTarget.BLT_TTY));
+
+  node->common.ConfigSource1.BLT_S1TY =
+    (bdisp_ty_sanitise_direction (stdev->ConfigTarget.BLT_TTY)
+     & ~BLIT_TY_BIG_ENDIAN);
+  node->common.ConfigColor.BLT_S1CF = color;
+
+  /* dimensions */
+  node->common.ConfigTarget.BLT_TXY
+    = (dy << 16) | dx;
+  node->common.ConfigTarget.BLT_TSZ_S1SZ
+    = (rect->h << 16) | rect->w;
+
+  _bdisp_aq_finish_node (stdrv, stdev, shared, node);
+
+  return true;
+error:
+  if (stdev->bFixedPoint)
+    dfb_rectangle_upscale (rect);
+  return false;
+}
+
+bool
+bdisp_aq_Blit_shortcut (void         * const drv,
+                        void         * const dev,
+                        DFBRectangle * const rect,
+                        int           dx,
+                        int           dy)
+{
+  return bdisp_aq_Blit_shortcut_real (drv, dev, rect, dx, dy, 0x00000000);
+}
+
+bool
+bdisp_aq_StretchBlit_shortcut (void         * const drv,
+                               void         * const dev,
+                               DFBRectangle * const srect,
+                               DFBRectangle * const drect)
+{
+  return bdisp_aq_Blit_shortcut (drv, dev, drect, drect->x, drect->y);
+}
+
+bool
+bdisp_aq_Blit2_shortcut (void         * const drv,
+                         void         * const dev,
+                         DFBRectangle * const rect,
+                         int           dx,
+                         int           dy,
+                         int           sx2,
+                         int           sy2)
+{
+  return bdisp_aq_Blit_shortcut (drv, dev, rect, dx, dy);
+}
+
+bool
+bdisp_aq_Blit_shortcut_YCbCr422r (void         * const drv,
+                                  void         * const dev,
+                                  DFBRectangle * const rect,
+                                  int           dx,
+                                  int           dy)
+{
+  STGFX2DriverData     * const stdrv = drv;
+  STGFX2DeviceData     * const stdev = dev;
+  STMFBBDispSharedArea * const shared = stdrv->bdisp_shared;
+
+  if (!stdev->bFixedPoint)
+    D_DEBUG_AT (BDISP_BLT, "%s (%d,%d-%dx%d -> %d,%d)\n", __FUNCTION__,
+                DFB_RECTANGLE_VALS (rect), dx, dy);
+  else
+    {
+      D_DEBUG_AT (BDISP_BLT, "%s (%d.%06d,%d.%06d-%d.%06dx%d.%06d -> %d.%06d,%d.%06d)\n",
+                  __FUNCTION__, DFB_RECTANGLE_VALSf (rect),
+                  DFB_INT_VALf (dx), DFB_INT_VALf (dy));
+      dfb_rectangle_downscale (rect);
+      dx /= DFB_FIXED_POINT_ONE;
+      dy /= DFB_FIXED_POINT_ONE;
+    }
+  DUMP_INFO ();
+
+  if (unlikely (!rect->w || !rect->h))
+    return true;
+  if (!_check_size_constraints (dx, dy, rect->w, rect->h))
+    goto error;
+
+  struct _BltNode_YCbCr422r_shortcut * node =
+    _bdisp_aq_get_new_node (stdrv, stdev, shared);
+
+  u32 blt_cic = CIC_BLT_NODE_YCbCr422r_SHORTCUT;
+  u32 blt_ins = (BLIT_INS_SRC1_MODE_DISABLED
+                 | BLIT_INS_SRC2_MODE_COLOR_FILL
+                 | BLIT_INS_ENABLE_IVMX);
+  u32 blt_ack = BLIT_ACK_BYPASSSOURCE2;
+
+  D_ASSERT (shared == stdrv->bdisp_shared);
+
+  node->ConfigTarget.BLT_TBA = stdev->ConfigTarget.BLT_TBA;
+  node->ConfigTarget.BLT_TTY = bdisp_ty_sanitise_direction (stdev->ConfigTarget.BLT_TTY);
+
+  node->ConfigColor.BLT_S2CF = 0x00000000;
+  node->ConfigSource2.BLT_S2TY = (BLIT_COLOR_FORM_ARGB8888
+                                  | BLIT_TY_COLOR_EXPAND_MSB);
+
+  node->ConfigTarget.BLT_TXY
+    = node->ConfigSource2.BLT_S2XY
+    = (dy << 16) | dx;
+  node->ConfigTarget.BLT_TSZ_S1SZ
+    = node->ConfigSource2.BLT_S2SZ
+    = (rect->h << 16) | rect->w;
+
+  bdisp_aq_SetClip (stdev, &blt_cic, &blt_ins, &node->ConfigClip);
+  bdisp_aq_update_config_static (shared, node->ConfigStatic);
+
+  set_matrix (node->ConfigIVMX.BLT_IVMX, bdisp_aq_RGB_2_VideoYCbCr601);
+
+  bdisp_aq_update_num_ops (stdev, shared, blt_ins);
+
+  node->ConfigGeneral.BLT_CIC = blt_cic;
+  node->ConfigGeneral.BLT_INS = blt_ins;
+  node->ConfigGeneral.BLT_ACK = blt_ack;
+
+  _bdisp_aq_finish_node (stdrv, stdev, shared, node);
+
+  return true;
+error:
+  if (stdev->bFixedPoint)
+    dfb_rectangle_upscale (rect);
+  return false;
+}
+
+bool
+bdisp_aq_StretchBlit_shortcut_YCbCr422r (void         * const drv,
+                                         void         * const dev,
+                                         DFBRectangle * const srect,
+                                         DFBRectangle * const drect)
+{
+  return bdisp_aq_Blit_shortcut_YCbCr422r (drv, dev, drect, drect->x, drect->y);
+}
+
+bool
+bdisp_aq_Blit2_shortcut_YCbCr422r (void         * const drv,
+                                   void         * const dev,
+                                   DFBRectangle * const rect,
+                                   int           dx,
+                                   int           dy,
+                                   int           sx2,
+                                   int           sy2)
+{
+  return bdisp_aq_Blit_shortcut_YCbCr422r (drv, dev, rect, dx, dy);
+}
+
+bool
+bdisp_aq_Blit_shortcut_rgb32 (void         * const drv,
+                              void         * const dev,
+                              DFBRectangle * const rect,
+                              int           dx,
+                              int           dy)
+{
+  return bdisp_aq_Blit_shortcut_real (drv, dev, rect, dx, dy, 0xff000000);
+}
+
+bool
+bdisp_aq_StretchBlit_shortcut_rgb32 (void         * const drv,
+                                     void         * const dev,
+                                     DFBRectangle * const srect,
+                                     DFBRectangle * const drect)
+{
+  return bdisp_aq_Blit_shortcut_rgb32 (drv, dev, drect, drect->x, drect->y);
+}
+
+bool
+bdisp_aq_Blit2_shortcut_rgb32 (void         * const drv,
+                               void         * const dev,
+                               DFBRectangle * const rect,
+                               int           dx,
+                               int           dy,
+                               int           sx2,
+                               int           sy2)
+{
+  return bdisp_aq_Blit_shortcut_rgb32 (drv, dev, rect, dx, dy);
+}
+
+
+static void
+_bdisp_aq_Blit_rotate_using_spans (STGFX2DriverData   * const stdrv,
+                                   STGFX2DeviceData   * const stdev,
+                                   const DFBRectangle * const src,
+                                   int                 dx,
+                                   int                 dy,
+                                   int                 dy_step)
+{
+  int w_remaining = src->w & 0x0fff;
+  int this_w = ABS (dy_step);
+  int src_x = src->x;
+  int src_y = src->y << 16;
+  int src_h = src->h & 0x0fff;
+
+  while (w_remaining)
+    {
+      stdev->ConfigTarget.BLT_TXY      = (dy << 16) | dx;
+      stdev->ConfigSource1.BLT_S1XY    = stdev->ConfigTarget.BLT_TXY;
+      stdev->ConfigTarget.BLT_TSZ_S1SZ = (this_w << 16) | src_h;
+
+      stdev->ConfigSource2.BLT_S2XY = src_y | src_x;
+      stdev->ConfigSource2.BLT_S2SZ = (src_h << 16) | this_w;
+
+      bdisp_aq_copy_n_push_node (stdrv, stdev);
+      bdisp_aq_clut_update_disable_if_unsafe (stdev);
+
+      dy += dy_step;
+      src_x += this_w;
+      w_remaining -= this_w;
+
+      this_w = MIN (ABS (dy_step), w_remaining);
+    }
+}
+
+bool
+bdisp_aq_Blit_rotate_90_270 (void         * const drv,
+                             void         * const dev,
+                             DFBRectangle * const rect,
+                             int           dx,
+                             int           dy)
+{
+  STGFX2DriverData * const stdrv = drv;
+  STGFX2DeviceData * const stdev = dev;
+
+  if (!stdev->bFixedPoint)
+    D_DEBUG_AT (BDISP_BLT, "%s (%d,%d-%dx%d -> %d,%d) %u\n", __FUNCTION__,
+                DFB_RECTANGLE_VALS (rect), dx, dy, stdev->rotate);
+  else
+    {
+      D_DEBUG_AT (BDISP_BLT, "%s (%d.%06d,%d.%06d-%d.%06dx%d.%06d -> %d.%06d,%d.%06d) %u\n", __FUNCTION__,
+                  DFB_RECTANGLE_VALSf (rect), DFB_INT_VALf (dx),
+                  DFB_INT_VALf (dy), stdev->rotate);
+      dfb_rectangle_downscale (rect);
+      dx /= DFB_FIXED_POINT_ONE;
+      dy /= DFB_FIXED_POINT_ONE;
+    }
+  DUMP_INFO ();
+
+  if (unlikely (!rect->w || !rect->h))
+    return true;
+  if (!_check_size_constraints (rect->x, rect->y, rect->w, rect->h))
+    return false;
+  if (!_check_size_constraints (dx, dy, 1, 1))
+    return false;
+
+  if (rect->w % 16
+     || rect->h % 16)
+    goto error;
+
+  bool requires_spans;
+
+  /* read from top left to bottom right
+     90: writes from bottom left to top right
+     270: writes from top right to bottom left */
+  int dy_step;
+
+  if (stdev->ConfigSource2.BLT_S2BA == stdev->ConfigTarget.BLT_TBA)
+    {
+      DFBRegion dregion;
+      dregion.x1 = dx;
+      dregion.y1 = dy;
+      dregion.x2 = dx + rect->h - 1;
+      dregion.y2 = dy + rect->w - 1;
+      if (dfb_region_rectangle_intersect (&dregion, rect))
+        goto error;
+    }
+
+  requires_spans = (rect->w > stdev->features.rotate_buffer_length);
+
+  if (stdev->rotate == 90)
+    {
+      dx = dx;
+      dy += rect->w - 1;
+      dy_step = -stdev->features.rotate_buffer_length;
+    }
+  else
+    {
+      dx += rect->h - 1;
+      dy = dy;
+      dy_step = stdev->features.rotate_buffer_length;
+    }
+
+  if (unlikely (!requires_spans))
+    {
+      stdev->ConfigTarget.BLT_TSZ_S1SZ = ((rect->w & 0x0fff) << 16) | (rect->h & 0x0fff);
+      stdev->ConfigTarget.BLT_TXY   = (dy << 16) | dx;
+      stdev->ConfigSource1.BLT_S1XY = stdev->ConfigTarget.BLT_TXY;
+      stdev->ConfigSource2.BLT_S2XY = (rect->y << 16) | rect->x;
+      stdev->ConfigSource2.BLT_S2SZ = ((rect->h & 0x0fff) << 16) | (rect->w & 0x0fff);
+
+      bdisp_aq_copy_n_push_node (stdrv, stdev);
+      bdisp_aq_clut_update_disable_if_unsafe (stdev);
+    }
+  else
+    _bdisp_aq_Blit_rotate_using_spans (stdrv, stdev, rect, dx, dy, dy_step);
+
+  return true;
+
+error:
+  if (stdev->bFixedPoint)
+    dfb_rectangle_upscale (rect);
+  return false;
+}
+
+
+bool
+bdisp_aq_Blit_nop (void         * const drv,
+                   void         * const dev,
+                   DFBRectangle * const rect,
+                   int           dx,
+                   int           dy)
+{
+  const STGFX2DriverData __attribute__((unused)) * const stdrv = drv;
+  const STGFX2DeviceData __attribute__((unused)) * const stdev = dev;
+
+  if (!stdev->bFixedPoint)
+    D_DEBUG_AT (BDISP_BLT, "%s (%d,%d-%dx%d -> %d,%d)\n", __FUNCTION__,
+                DFB_RECTANGLE_VALS (rect), dx, dy);
+  else
+    D_DEBUG_AT (BDISP_BLT, "%s (%d.%06d,%d.%06d-%d.%06dx%d.%06d -> %d.%06d,%d.%06d)\n",
+                __FUNCTION__, DFB_RECTANGLE_VALSf (rect),
+                DFB_INT_VALf (dx), DFB_INT_VALf (dy));
+  DUMP_INFO ();
+
+  return true;
+}
+
+bool
+bdisp_aq_StretchBlit_nop (void         * const drv,
+                          void         * const dev,
+                          DFBRectangle * const srect,
+                          DFBRectangle * const drect)
+{
+  const STGFX2DriverData __attribute__((unused)) * const stdrv = drv;
+  const STGFX2DeviceData __attribute__((unused)) * const stdev = dev;
+
+  if (!stdev->bFixedPoint)
+    D_DEBUG_AT (BDISP_STRETCH, "%s (%d,%d-%dx%d -> %d,%d-%dx%d)\n", __FUNCTION__,
+                DFB_RECTANGLE_VALS (srect), DFB_RECTANGLE_VALS (drect));
+  else
+    D_DEBUG_AT (BDISP_STRETCH, "%s (%d.%06d,%d.%06d-%d.%06dx%d.%06d -> %d.%06d,%d.%06d-%d.%06dx%d.%06d)\n", __FUNCTION__,
+                DFB_RECTANGLE_VALSf (srect), DFB_RECTANGLE_VALSf (drect));
+  DUMP_INFO ();
+
+  return true;
+}
+
+bool
+bdisp_aq_Blit2_nop (void         * const drv,
+                    void         * const dev,
+                    DFBRectangle * const rect,
+                    int           dx,
+                    int           dy,
+                    int           sx2,
+                    int           sy2)
+{
+  const STGFX2DriverData __attribute__((unused)) * const stdrv = drv;
+  const STGFX2DeviceData __attribute__((unused)) * const stdev = dev;
+
+  if (!stdev->bFixedPoint)
+    D_DEBUG_AT (BDISP_STRETCH, "%s (%d,%d-%dx%d + %d,%d -> %d,%d)\n", __FUNCTION__,
+                DFB_RECTANGLE_VALS (rect), sx2, sy2, dx, dy);
+  else
+    D_DEBUG_AT (BDISP_STRETCH, "%s (%d.%06d,%d.%06d-%d.%06dx%d.%06d + %d.%06d,%d.%06d -> %d.%06d,%d.%06d)\n", __FUNCTION__,
+                DFB_RECTANGLE_VALSf (rect), DFB_INT_VALf (sx2),
+                DFB_INT_VALf (sy2), DFB_INT_VALf (dx), DFB_INT_VALf (dy));
+  DUMP_INFO ();
+
+  return true;
+}
+
+
+void
+_bdisp_aq_RGB32_init (STGFX2DriverData * const stdrv,
+                      STGFX2DeviceData * const stdev,
+                      u32               blt_tba,
+                      u16               pitch,
+                      DFBRectangle     * const rect)
+{
+  D_DEBUG_AT (BDISP_BLT, "%s\n", __FUNCTION__);
+
+  /* save state */
+  u32 tba = stdev->ConfigTarget.BLT_TBA;
+  u32 tty = stdev->ConfigTarget.BLT_TTY;
+  u32 cty = stdev->drawstate.color_ty;
+  u32 col = stdev->drawstate.color;
+
+  stdev->ConfigTarget.BLT_TBA = blt_tba;
+  stdev->ConfigTarget.BLT_TTY = (BLIT_COLOR_FORM_ARGB8888
+                                 | BLIT_TY_FULL_ALPHA_RANGE) | pitch;
+  stdev->drawstate.color_ty = stdev->ConfigTarget.BLT_TTY;
+  stdev->drawstate.color    = 0xff000000;
+
+  bdisp_aq_FillRectangle_simple (stdrv, stdev, rect);
+
+  /* restore state */
+  stdev->drawstate.color = col;
+  stdev->drawstate.color_ty = cty;
+  stdev->ConfigTarget.BLT_TTY = tty;
+  stdev->ConfigTarget.BLT_TBA = tba;
+
+  bdisp_aq_EmitCommands (stdrv, stdev);
+}
+
+/* fixup for rgb32, force the alpha to all 0xff again. */
+void
+_bdisp_aq_RGB32_fixup (STGFX2DriverData * const stdrv,
+                       STGFX2DeviceData * const stdev,
+                       u32               blt_tba,
+                       u16               pitch,
+                       DFBRectangle     * const rect)
+{
+  D_DEBUG_AT (BDISP_BLT, "%s\n", __FUNCTION__);
+
+  STMFBBDispSharedArea * const shared = stdrv->bdisp_shared;
+
+  struct _BltNode_RGB32fixup * const node =
+    _bdisp_aq_get_new_node (stdrv, stdev, shared);
+
+  node->ConfigGeneral.BLT_CIC = CIC_BLT_NODE_RGB32fixup;
+  node->ConfigGeneral.BLT_INS = BLIT_INS_SRC1_MODE_MEMORY | BLIT_INS_ENABLE_PLANEMASK;
+  node->ConfigGeneral.BLT_ACK = BLIT_ACK_ROP | BLIT_ACK_ROP_SET;
+
+  node->ConfigTarget.BLT_TBA
+    = node->ConfigSource1.BLT_S1BA
+    = blt_tba;
+  node->ConfigTarget.BLT_TTY
+    = node->ConfigSource1.BLT_S1TY
+    = BLIT_COLOR_FORM_ARGB8888 | BLIT_TY_FULL_ALPHA_RANGE | pitch;
+  node->ConfigTarget.BLT_TXY
+    = node->ConfigSource1.BLT_S1XY
+    = (rect->y << 16) | rect->x;
+  node->ConfigTarget.BLT_TSZ_S1SZ = (rect->h << 16) | rect->w;
+
+  node->ConfigFilters.BLT_PMK = 0xff000000;
+
+  bdisp_aq_update_num_ops (stdev, shared, node->ConfigGeneral.BLT_INS);
+
+  bdisp_aq_update_config_static (shared, &node->ConfigStatic);
+
+  _bdisp_aq_finish_node (stdrv, stdev, shared, node);
+
+  bdisp_aq_EmitCommands (stdrv, stdev);
+  bdisp_aq_EngineSync (stdrv, stdev);
+}
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/gfxdrivers/stgfx2/bdisp_accel.h DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/bdisp_accel.h
--- DirectFB/gfxdrivers/stgfx2/bdisp_accel.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/bdisp_accel.h	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,212 @@
+/*
+   ST Microelectronics BDispII driver - hardware acceleration
+
+   (c) Copyright 2007-2009  STMicroelectronics Ltd.
+
+   All rights reserved.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#ifndef __BDISP_ACCEL_H__
+#define __BDISP_ACCEL_H__
+
+
+#include <dfb_types.h>
+
+#include "stm_types.h"
+
+
+
+DFBResult bdisp_aq_initialize (CoreGraphicsDevice * const device,
+                               GraphicsDeviceInfo * const device_info,
+                               STGFX2DriverData   * const stdrv,
+                               STGFX2DeviceData   * const stdev);
+
+void bdisp_aq_EngineReset (void * const drv,
+                           void * const dev);
+DFBResult bdisp_aq_EngineSync (void * const drv,
+                               void * const dev);
+
+void bdisp_aq_EmitCommands (void * const drv,
+                            void * const dev);
+
+void bdisp_aq_GetSerial (void               * const drv,
+                         void               * const dev,
+                         CoreGraphicsSerial * const serial);
+DFBResult bdisp_aq_WaitSerial (void                     * const drv,
+                               void                     * const dev,
+                               const CoreGraphicsSerial * const serial);
+
+
+bool bdisp_aq_FillRectangle_simple (void         * const drv,
+                                    void         * const dev,
+                                    DFBRectangle * const rect);
+bool bdisp_aq_DrawRectangle_simple (void         * const drv,
+                                    void         * const dev,
+                                    DFBRectangle * const rect);
+
+bool bdisp_aq_FillDraw_nop (void         * const drv,
+                            void         * const dev,
+                            DFBRectangle * const rect);
+
+bool bdisp_aq_FillRectangle (void         * const drv,
+                             void         * const dev,
+                             DFBRectangle * const rect);
+bool bdisp_aq_DrawRectangle (void         * const drv,
+                             void         * const dev,
+                             DFBRectangle * const rect);
+
+
+bool bdisp_aq_Blit_simple (void         * const drv,
+                           void         * const dev,
+                           DFBRectangle * const rect,
+                           int           dx,
+                           int           dy);
+bool bdisp_aq_Blit_simple_YCbCr422r (void         * const drv,
+                                     void         * const dev,
+                                     DFBRectangle * const rect,
+                                     int           dx,
+                                     int           dy);
+
+void bdisp_aq_setup_blit_operation (STGFX2DriverData * const stdrv,
+                                    STGFX2DeviceData * const stdev);
+
+bool bdisp_aq_Blit        (void         * const drv,
+                           void         * const dev,
+                           DFBRectangle * const rect,
+                           int           dx,
+                           int           dy);
+bool bdisp_aq_StretchBlit (void         * const drv,
+                           void         * const dev,
+                           DFBRectangle * const srect,
+                           DFBRectangle * const drect);
+bool bdisp_aq_Blit_as_stretch (void         * const drv,
+                               void         * const dev,
+                               DFBRectangle * const rect,
+                               int           dx,
+                               int           dy);
+bool bdisp_aq_Blit2       (void         * const drv,
+                           void         * const dev,
+                           DFBRectangle * const rect,
+                           int           dx,
+                           int           dy,
+                           int           sx2,
+                           int           sy2);
+
+bool
+bdisp_aq_StretchBlit_RLE (void                        * const drv,
+                          void                        * const dev,
+                          unsigned long                src_address,
+                          unsigned long                src_length,
+                          const CoreSurfaceBufferLock * const dst,
+                          const DFBRectangle          * const drect);
+
+bool bdisp_aq_Blit_shortcut        (void         * const drv,
+                                    void         * const dev,
+                                    DFBRectangle * const rect,
+                                    int           dx,
+                                    int           dy);
+bool bdisp_aq_StretchBlit_shortcut (void         * const drv,
+                                    void         * const dev,
+                                    DFBRectangle * const srect,
+                                    DFBRectangle * const drect);
+bool bdisp_aq_Blit2_shortcut       (void         * const drv,
+                                    void         * const dev,
+                                    DFBRectangle * const rect,
+                                    int           dx,
+                                    int           dy,
+                                    int           sx2,
+                                    int           sy2);
+bool bdisp_aq_Blit_shortcut_YCbCr422r        (void         * const drv,
+                                              void         * const dev,
+                                              DFBRectangle * const rect,
+                                              int           dx,
+                                              int           dy);
+bool bdisp_aq_StretchBlit_shortcut_YCbCr422r (void         * const drv,
+                                              void         * const dev,
+                                              DFBRectangle * const srect,
+                                              DFBRectangle * const drect);
+bool bdisp_aq_Blit2_shortcut_YCbCr422r       (void         * const drv,
+                                              void         * const dev,
+                                              DFBRectangle * const rect,
+                                              int           dx,
+                                              int           dy,
+                                              int           sx2,
+                                              int           sy2);
+bool bdisp_aq_Blit_shortcut_rgb32        (void         * const drv,
+                                          void         * const dev,
+                                          DFBRectangle * const rect,
+                                          int           dx,
+                                          int           dy);
+bool bdisp_aq_StretchBlit_shortcut_rgb32 (void         * const drv,
+                                          void         * const dev,
+                                          DFBRectangle * const srect,
+                                          DFBRectangle * const drect);
+bool bdisp_aq_Blit2_shortcut_rgb32       (void         * const drv,
+                                          void         * const dev,
+                                          DFBRectangle * const rect,
+                                          int           dx,
+                                          int           dy,
+                                          int           sx2,
+                                          int           sy2);
+
+bool bdisp_aq_Blit_rotate_90_270 (void         * const drv,
+                                  void         * const dev,
+                                  DFBRectangle * const rect,
+                                  int           dx,
+                                  int           dy);
+
+bool bdisp_aq_Blit_nop        (void         * const drv,
+                               void         * const dev,
+                               DFBRectangle * const rect,
+                               int           dx,
+                               int           dy);
+bool bdisp_aq_StretchBlit_nop (void         * const drv,
+                               void         * const dev,
+                               DFBRectangle * const srect,
+                               DFBRectangle * const drect);
+bool bdisp_aq_Blit2_nop       (void         * const drv,
+                               void         * const dev,
+                               DFBRectangle * const rect,
+                               int           dx,
+                               int           dy,
+                               int           sx2,
+                               int           sy2);
+
+
+void
+_bdisp_aq_prepare_upload_palette_hw (STGFX2DriverData * const stdrv,
+                                     STGFX2DeviceData * const stdev);
+
+
+void
+_bdisp_aq_RGB32_init (STGFX2DriverData * const stdrv,
+                      STGFX2DeviceData * const stdev,
+                      u32               blt_tba,
+                      u16               pitch,
+                      DFBRectangle     * const rect);
+
+void
+_bdisp_aq_RGB32_fixup (STGFX2DriverData * const stdrv,
+                       STGFX2DeviceData * const stdev,
+                       u32               blt_tba,
+                       u16               pitch,
+                       DFBRectangle     * const rect);
+
+
+
+#endif /* __BDISP_ACCEL_H__ */
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/gfxdrivers/stgfx2/bdisp_accel_types.h DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/bdisp_accel_types.h
--- DirectFB/gfxdrivers/stgfx2/bdisp_accel_types.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/bdisp_accel_types.h	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,156 @@
+/*
+   ST Microelectronics BDispII driver - hardware acceleration
+
+   (c) Copyright 2007/2008  STMicroelectronics Ltd.
+
+   All rights reserved.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#ifndef __BDISP_ACCEL_TYPES_H__
+#define __BDISP_ACCEL_TYPES_H__
+
+
+#include <dfb_types.h>
+
+
+
+
+/* general config */
+struct _BltNodeGroup00 {
+  u32 BLT_NIP;
+  u32 BLT_CIC;
+  u32 BLT_INS;
+  u32 BLT_ACK;
+};
+/* target config */
+struct _BltNodeGroup01 {
+  u32 BLT_TBA;
+  u32 BLT_TTY;
+  u32 BLT_TXY;
+  u32 BLT_TSZ_S1SZ;
+};
+/* color fill */
+struct _BltNodeGroup02 {
+  u32 BLT_S1CF;
+  u32 BLT_S2CF;
+};
+/* source 1 config */
+struct _BltNodeGroup03 {
+  u32 BLT_S1BA;
+  u32 BLT_S1TY;
+  u32 BLT_S1XY;
+  u32 dummy;
+};
+/* source 2 config */
+struct _BltNodeGroup04 {
+  u32 BLT_S2BA;
+  u32 BLT_S2TY;
+  u32 BLT_S2XY;
+  u32 BLT_S2SZ;
+};
+/* source 3 config */
+struct _BltNodeGroup05 {
+  u32 BLT_S3BA;
+  u32 BLT_S3TY;
+  u32 BLT_S3XY;
+  u32 BLT_S3SZ;
+};
+/* clip config */
+struct _BltNodeGroup06 {
+  u32 BLT_CWO;
+  u32 BLT_CWS;
+};
+/* clut & color space conversion */
+struct _BltNodeGroup07 {
+  u32 BLT_CCO;
+  u32 BLT_CML;
+};
+/* filters control and plane mask */
+struct _BltNodeGroup08 {
+  u32 BLT_FCTL_RZC;
+  u32 BLT_PMK;
+};
+/* 2D (chroma) filter control */
+struct _BltNodeGroup09 {
+  u32 BLT_RSF;
+  u32 BLT_RZI;
+  u32 BLT_HFP;
+  u32 BLT_VFP;
+};
+/* 2D (lumna) filter control */
+struct _BltNodeGroup10 {
+  u32 BLT_Y_RSF;
+  u32 BLT_Y_RZI;
+  u32 BLT_Y_HFP;
+  u32 BLT_Y_VFP;
+};
+/* flicker filter */
+struct _BltNodeGroup11 {
+  u32 BLT_FF0;
+  u32 BLT_FF1;
+  u32 BLT_FF2;
+  u32 BLT_FF3;
+};
+/* color key 1 and 2 */
+struct _BltNodeGroup12 {
+  u32 BLT_KEY1;
+  u32 BLT_KEY2;
+};
+/* XYL */
+struct _BltNodeGroup13 {
+  u32 BLT_XYL;
+  u32 BLT_XYP;
+};
+/* static addressing and user */
+struct _BltNodeGroup14 {
+  u32 BLT_SAR;
+  u32 BLT_USR;
+};
+/* input versatile matrix 0, 1, 2, 3 */
+struct _BltNodeGroup15 {
+  u32 BLT_IVMX0;
+  u32 BLT_IVMX1;
+  u32 BLT_IVMX2;
+  u32 BLT_IVMX3;
+};
+/* output versatile matrix 0, 1, 2, 3 */
+struct _BltNodeGroup16 {
+  u32 BLT_OVMX0;
+  u32 BLT_OVMX1;
+  u32 BLT_OVMX2;
+  u32 BLT_OVMX3;
+};
+/* Pace Dot */
+struct _BltNodeGroup17 {
+  u32 BLT_PACE;
+  u32 BLT_DOT;
+};
+/* VC1 range engine */
+struct _BltNodeGroup18 {
+  u32 BLT_VC1R;
+  u32 dummy;
+};
+/* Gradient fill */
+struct _BltNodeGroup19 {
+  u32 BLT_HGF;
+  u32 BLT_VGF;
+};
+
+
+
+#endif /* __BDISP_ACCEL_TYPES_H__ */
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/gfxdrivers/stgfx2/bdisp_features.c DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/bdisp_features.c
--- DirectFB/gfxdrivers/stgfx2/bdisp_features.c	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/bdisp_features.c	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,197 @@
+/*
+   ST Microelectronics BDispII driver - distinguishing hardware
+
+   (c) Copyright 2008       STMicroelectronics Ltd.
+
+   All rights reserved.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include "bdisp_features.h"
+
+#include "bdisp_registers.h"
+
+#include <direct/util.h>
+#include <string.h>
+
+/* the following are hardware features and they will be different depending
+   on the BDisp implementation we're running on. */
+#define BDISP_HW_FEATURES_BLIT_OPS (0                                        \
+                                    | STM_BLITTER_FLAGS_FLICKERFILTER        \
+                                   )
+
+#define FORMAT_YUV444P      (1 << 3)
+#define FORMAT_YCBCR42XMBN  (1 << 4)
+
+/* rotation and mirroring */
+#define STM_BLITTER_FLAGS_ROTATE90   (0x00000040)
+#define STM_BLITTER_FLAGS_ROTATE270  (0x00000100)
+
+/* this is the value for pre-7108 */
+#define BDISP_DEFAULT_MAX_SPANWIDTH   (128)
+#define BDISP_DEFAULT_MAX_ROTATEWIDTH ( 16)
+
+
+static struct _bdisp_hw_features bdisp_hw_features[] = {
+  /* other versions are not supported! */
+  [STM_BLITTER_VERSION_7109c2] =
+    { .name = "STb7109c2",
+      .blitflags = BDISP_HW_FEATURES_BLIT_OPS },
+  [STM_BLITTER_VERSION_7109c3] =
+    { .name = "STb7109c3",
+      .blitflags = BDISP_HW_FEATURES_BLIT_OPS },
+  [STM_BLITTER_VERSION_7200c1] =
+    { .name = "STi7200c1",
+      .blitflags = (BDISP_HW_FEATURES_BLIT_OPS
+                    | STM_BLITTER_FLAGS_RLE_DECODE) },
+  [STM_BLITTER_VERSION_7200c2_7111_7141_7105] =
+    { .name = "STi7200c2/7111/7141/7105",
+      .blitflags = (BDISP_HW_FEATURES_BLIT_OPS
+                    | STM_BLITTER_FLAGS_RLE_DECODE
+                    | STM_BLITTER_FLAGS_ROTATE90
+                    | STM_BLITTER_FLAGS_ROTATE270),
+      .extra_src_formats = (FORMAT_YUV444P
+                            | FORMAT_YCBCR42XMBN) },
+  [STM_BLITTER_VERSION_5197] =
+    /* don't know if destination color key works here - just a safe guess */
+    { .name = "STb5197",
+      .blitflags = (BDISP_HW_FEATURES_BLIT_OPS
+                    | STM_BLITTER_FLAGS_ROTATE90
+                    | STM_BLITTER_FLAGS_ROTATE270),
+      .extra_src_formats = (FORMAT_YUV444P
+                            | FORMAT_YCBCR42XMBN) },
+  [STM_BLITTER_VERSION_5206] =
+    { .name = "STi5206",
+      .line_buffer_length = 720,
+      .rotate_buffer_length = 64,
+      .blitflags = (BDISP_HW_FEATURES_BLIT_OPS
+                    | STM_BLITTER_FLAGS_ROTATE90
+                    | STM_BLITTER_FLAGS_ROTATE270),
+      .extra_src_formats = FORMAT_YUV444P },
+  [STM_BLITTER_VERSION_7106_7108] =
+    { .name = "STi7106/7108",
+      .line_buffer_length = 720,
+      .rotate_buffer_length = 64,
+      .blitflags = (BDISP_HW_FEATURES_BLIT_OPS
+                    | STM_BLITTER_FLAGS_RLE_DECODE
+                    | STM_BLITTER_FLAGS_ROTATE90
+                    | STM_BLITTER_FLAGS_ROTATE270),
+      .extra_src_formats = FORMAT_YUV444P },
+};
+
+
+static const struct _bdisp_pixelformat_table dspf_to_bdisp[DFB_NUM_PIXELFORMATS] = {
+  [DFB_PIXELFORMAT_INDEX (DSPF_ARGB1555)] = { BLIT_COLOR_FORM_ARGB1555,                              true, true },
+  [DFB_PIXELFORMAT_INDEX (DSPF_RGB16)]    = { BLIT_COLOR_FORM_RGB565,                                true, true },
+  [DFB_PIXELFORMAT_INDEX (DSPF_RGB24)]    = { BLIT_COLOR_FORM_RGB888,                                true, true },
+  [DFB_PIXELFORMAT_INDEX (DSPF_RGB32)]    = { BLIT_COLOR_FORM_ARGB8888 | BLIT_TY_FULL_ALPHA_RANGE,   true, true },
+  [DFB_PIXELFORMAT_INDEX (DSPF_ARGB)]     = { BLIT_COLOR_FORM_ARGB8888 | BLIT_TY_FULL_ALPHA_RANGE,   true, true },
+  [DFB_PIXELFORMAT_INDEX (DSPF_A8)]       = { BLIT_COLOR_FORM_A8 | BLIT_TY_FULL_ALPHA_RANGE,         true, true },
+  [DFB_PIXELFORMAT_INDEX (DSPF_YUY2)]     = { BLIT_COLOR_FORM_YCBCR422R | BLIT_TY_BIG_ENDIAN,        true, true },
+  [DFB_PIXELFORMAT_INDEX (DSPF_RGB332)]   = { -1, },
+  [DFB_PIXELFORMAT_INDEX (DSPF_UYVY)]     = { BLIT_COLOR_FORM_YCBCR422R,                             true, true },
+  [DFB_PIXELFORMAT_INDEX (DSPF_I420)]     = { BLIT_COLOR_FORM_YUV444P,                               true, false },
+  [DFB_PIXELFORMAT_INDEX (DSPF_YV12)]     = { BLIT_COLOR_FORM_YUV444P,                               true, false },
+  [DFB_PIXELFORMAT_INDEX (DSPF_LUT8)]     = { BLIT_COLOR_FORM_CLUT8,                                 true, true },
+  [DFB_PIXELFORMAT_INDEX (DSPF_ALUT44)]   = { BLIT_COLOR_FORM_ACLUT44,                               true, true },
+  [DFB_PIXELFORMAT_INDEX (DSPF_AiRGB)]    = { -1, },
+  [DFB_PIXELFORMAT_INDEX (DSPF_A1)]       = { BLIT_COLOR_FORM_A1,                                    true, false },
+/* Right now, JPEGDECHW/DeltaMu output an Omega2 MB YCbCr buffer. But future versions of JPEGDECHW
+   will/can be made (depends on the platform?) to output a raster buffer instead. DSPF_NV12 is actually
+   YCBCR420R2B, NV16 is YCBCR422R2B. But let's fake it for the moment. */
+#ifndef JPEGDECHW_DELTAMU_RASTER_BUFFERS /* Not defined. */
+  [DFB_PIXELFORMAT_INDEX (DSPF_NV12)]     = { BLIT_COLOR_FORM_YCBCR42XMB,                            true, false },
+  [DFB_PIXELFORMAT_INDEX (DSPF_NV16)]     = { BLIT_COLOR_FORM_YCBCR42XMB,                            true, false },
+#else
+  [DFB_PIXELFORMAT_INDEX (DSPF_NV12)]     = { BLIT_COLOR_FORM_YCBCR42XR2B,                           true, false },
+  [DFB_PIXELFORMAT_INDEX (DSPF_NV16)]     = { BLIT_COLOR_FORM_YCBCR42XR2B,                           true, false },
+#endif
+  [DFB_PIXELFORMAT_INDEX (DSPF_ARGB2554)] = { -1, },
+  [DFB_PIXELFORMAT_INDEX (DSPF_ARGB4444)] = { BLIT_COLOR_FORM_ARGB4444,                              true, true },
+  [DFB_PIXELFORMAT_INDEX (DSPF_RGBA4444)] = { -1, },
+  [DFB_PIXELFORMAT_INDEX (DSPF_NV21)]     = { -1, },
+  [DFB_PIXELFORMAT_INDEX (DSPF_AYUV)]     = { -1, },
+  [DFB_PIXELFORMAT_INDEX (DSPF_A4)]       = { -1, },
+  [DFB_PIXELFORMAT_INDEX (DSPF_ARGB1666)] = { -1, },
+  [DFB_PIXELFORMAT_INDEX (DSPF_ARGB6666)] = { -1, },
+  [DFB_PIXELFORMAT_INDEX (DSPF_RGB18)]    = { -1, },
+  /* CLUT2 is not supported as a target type on BDisp at the moment */
+  [DFB_PIXELFORMAT_INDEX (DSPF_LUT2)]     = { BLIT_COLOR_FORM_CLUT2,                                 true, false },
+  [DFB_PIXELFORMAT_INDEX (DSPF_RGB444)]   = { -1, },
+  [DFB_PIXELFORMAT_INDEX (DSPF_RGB555)]   = { -1, },
+  [DFB_PIXELFORMAT_INDEX (DSPF_BGR555)]   = { -1, },
+  [DFB_PIXELFORMAT_INDEX (DSPF_RGBA5551)] = { -1, },
+  [DFB_PIXELFORMAT_INDEX (DSPF_YUV444P)]  = { BLIT_COLOR_FORM_YUV444P,                               true, false },
+  [DFB_PIXELFORMAT_INDEX (DSPF_ARGB8565)] = { BLIT_COLOR_FORM_ARGB8565 | BLIT_TY_FULL_ALPHA_RANGE,   true, true },
+  [DFB_PIXELFORMAT_INDEX (DSPF_AVYU)]     = { BLIT_COLOR_FORM_AYCBCR8888 | BLIT_TY_FULL_ALPHA_RANGE, true, true },
+  [DFB_PIXELFORMAT_INDEX (DSPF_VYU)]      = { BLIT_COLOR_FORM_YCBCR888,                              true, true },
+  [DFB_PIXELFORMAT_INDEX (DSPF_A1_LSB)]   = { -1 },
+  [DFB_PIXELFORMAT_INDEX (DSPF_YV16)]     = { BLIT_COLOR_FORM_YUV444P,                               true, false },
+#if 0
+  /* unsupported for now */
+  [DFB_PIXELFORMAT_INDEX (DSPF_BGRA)]     = { BLIT_COLOR_FORM_ARGB8888 | BLIT_TY_FULL_ALPHA_RANGE | BLIT_TY_BIG_ENDIAN,
+  [DFB_PIXELFORMAT_INDEX (DSPF_LUT1)]     = { BLIT_COLOR_FORM_CLUT1,
+  [DFB_PIXELFORMAT_INDEX (DSPF_LUT4)]     = { BLIT_COLOR_FORM_CLUT4,
+  [DFB_PIXELFORMAT_INDEX (DSPF_ALUT88)]   = { BLIT_COLOR_FORM_ACLUT88 | BLIT_TY_FULL_ALPHA_RANGE,
+#endif
+};
+
+
+bool
+bdisp_hw_features_set_bdisp (enum stm_blitter_device    device,
+                             struct _bdisp_hw_features *ret_features)
+{
+  struct _bdisp_hw_features *features = &bdisp_hw_features[device];
+
+  if (device >= D_ARRAY_SIZE (bdisp_hw_features))
+    return false;
+
+  strncpy (ret_features->name, features->name, sizeof (ret_features->name));
+
+  ret_features->line_buffer_length = features->line_buffer_length;
+  ret_features->rotate_buffer_length = features->rotate_buffer_length;
+  if (!ret_features->line_buffer_length)
+    ret_features->line_buffer_length = BDISP_DEFAULT_MAX_SPANWIDTH;
+  if (!ret_features->rotate_buffer_length)
+    ret_features->rotate_buffer_length = BDISP_DEFAULT_MAX_ROTATEWIDTH;
+
+  ret_features->blitflags = features->blitflags;
+
+  ret_features->dfb_drawflags = STGFX2_VALID_DRAWINGFLAGS;
+  ret_features->dfb_blitflags = STGFX2_VALID_BLITTINGFLAGS;
+  ret_features->dfb_renderopts = STGFX2_VALID_RENDEROPTS;
+
+  /* rotation is not available on all platforms */
+  if (D_FLAGS_IS_SET (features->blitflags, STM_BLITTER_FLAGS_ROTATE90))
+    ret_features->dfb_blitflags |= DSBLIT_ROTATE90;
+  if (D_FLAGS_IS_SET (features->blitflags, STM_BLITTER_FLAGS_ROTATE270))
+    ret_features->dfb_blitflags |= DSBLIT_ROTATE270;
+
+  memcpy (ret_features->dfb_dspf_to_bdisp, dspf_to_bdisp,
+          sizeof (dspf_to_bdisp));
+  if (!D_FLAGS_IS_SET (features->extra_src_formats, FORMAT_YUV444P))
+    {
+      ret_features->dfb_dspf_to_bdisp[DFB_PIXELFORMAT_INDEX (DSPF_YUV444P)].supported_as_src = false;
+      ret_features->dfb_dspf_to_bdisp[DFB_PIXELFORMAT_INDEX (DSPF_I420)].supported_as_src = false;
+      ret_features->dfb_dspf_to_bdisp[DFB_PIXELFORMAT_INDEX (DSPF_YV12)].supported_as_src = false;
+      ret_features->dfb_dspf_to_bdisp[DFB_PIXELFORMAT_INDEX (DSPF_YV16)].supported_as_src = false;
+    }
+//  if (D_FLAGS_IS_SET (features->extra_src_formats, FORMAT_YCBCR42XMBN))
+//    ret_features->dfb_dspf_to_bdisp[DFB_PIXELFORMAT_INDEX (DSPF_YCBCR42XMBN)].supported_as_src = true;
+
+  return true;
+}
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/gfxdrivers/stgfx2/bdisp_features.h DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/bdisp_features.h
--- DirectFB/gfxdrivers/stgfx2/bdisp_features.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/bdisp_features.h	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,59 @@
+/*
+   ST Microelectronics BDispII driver - distinguishing hardware
+
+   (c) Copyright 2008       STMicroelectronics Ltd.
+
+   All rights reserved.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#ifndef __BDISP_FEATURES_H__
+#define __BDISP_FEATURES_H__
+
+#include <directfb.h>
+#include <linux/types.h>
+#include <linux/stmfb.h>
+
+#include "bdisp_registers.h"
+
+struct _bdisp_pixelformat_table {
+  u32  bdisp_type; /* BLIT_COLOR_FORM_RGB565 etc. */
+  bool supported_as_src : 1;
+  bool supported_as_dst : 1;
+};
+
+struct _bdisp_hw_features {
+  char                     name[28];
+  u32                      extra_src_formats; /* private */
+
+  u16                      line_buffer_length;
+  u16                      rotate_buffer_length;
+
+  enum STM_BLITTER_FLAGS   blitflags;
+
+  DFBSurfaceDrawingFlags   dfb_drawflags;
+  DFBSurfaceBlittingFlags  dfb_blitflags;
+  DFBSurfaceRenderOptions  dfb_renderopts;
+  struct _bdisp_pixelformat_table dfb_dspf_to_bdisp[DFB_NUM_PIXELFORMATS];
+};
+
+bool
+bdisp_hw_features_set_bdisp (enum stm_blitter_device    device,
+                             struct _bdisp_hw_features *ret_fetures);
+
+
+#endif /* __BDISP_FEATURES_H__ */
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/gfxdrivers/stgfx2/bdisp_registers.h DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/bdisp_registers.h
--- DirectFB/gfxdrivers/stgfx2/bdisp_registers.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/bdisp_registers.h	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,318 @@
+/*
+   ST Microelectronics BDispII driver - register & bit definitions
+
+   (c) Copyright 2007/2008  STMicroelectronics Ltd.
+
+   All rights reserved.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#ifndef __BDISP_REGISTERS_H__
+#define __BDISP_REGISTERS_H__
+
+#include "stgfx2_features.h"
+
+
+enum STM_BLITTER_FLAGS {
+  STM_BLITTER_FLAGS_FLICKERFILTER           = 0x00000800,
+  STM_BLITTER_FLAGS_RLE_DECODE              = 0x00080000,
+};
+
+
+
+
+#define BDISP_CTL      0x0
+#define BDISP_STA      0x8
+
+
+#define BDISP_AQ1_BASE 0x60
+
+/*
+ * Application queue offsets and defines
+ */
+#define BDISP_AQ_CTL      0x0
+#define BDISP_AQ_IP       0x4
+#define BDISP_AQ_LNA      0x8
+#define BDISP_AQ_STA      0xc
+
+#define BDISP_AQ_CTL_PRIORITY_MASK      (0x3 <<  0)
+#define BDISP_AQ_CTL_IRQ_MASK           (0xf << 20)
+#  define BDISP_AQ_CTL_IRQ_NODE_REPEAT    (0x1 << 20)
+#  define BDISP_AQ_CTL_IRQ_QUEUE_STOPPED  (0x2 << 20)
+#  define BDISP_AQ_CTL_IRQ_LNA_REACHED    (0x4 << 20)
+#  define BDISP_AQ_CTL_IRQ_NODE_COMPLETED (0x8 << 20)
+#define BDISP_AQ_CTL_EVENT_MASK         (0x7 << 24)
+#  define BDISP_AQ_CTL_EVENT_SUSPEND      (0x0 << 24)
+#  define BDISP_AQ_CTL_EVENT_ABORT_REPEAT (0x2 << 24)
+#  define BDISP_AQ_CTL_EVENT_STOP         (0x4 << 24)
+#define BDISP_AQ_CTL_QUEUE_EN           (0x1 << 31)
+
+
+
+/*
+ * Source/Dest type
+ */
+#define BLIT_TY_PIXMAP_PITCH_MASK             (0x0000ffff)
+#define BLIT_TY_COLOR_FORM_MASK               (0x001f0000)
+#  define BLIT_TY_COLOR_FORM_IS_RGB(ty)         (((ty) & (0x18 << 16)) == (0x00 << 16))
+#    define BLIT_COLOR_FORM_RGB565                (0x00 << 16)
+#    define BLIT_COLOR_FORM_RGB888                (0x01 << 16)
+#    define BLIT_COLOR_FORM_ARGB8565              (0x04 << 16)
+#    define BLIT_COLOR_FORM_ARGB8888              (0x05 << 16)
+#    define BLIT_COLOR_FORM_ARGB1555              (0x06 << 16)
+#    define BLIT_COLOR_FORM_ARGB4444              (0x07 << 16)
+#  define BLIT_TY_COLOR_FORM_IS_CLUT(ty)        ((((ty) & (0x18 << 16)) == (0x08 << 16)) && (((ty) & BLIT_TY_COLOR_FORM_MASK) != BLIT_COLOR_FORM_YCBCR42XMBN))
+#    define BLIT_COLOR_FORM_CLUT1                 (0x08 << 16)
+#    define BLIT_COLOR_FORM_CLUT2                 (0x09 << 16)
+#    define BLIT_COLOR_FORM_CLUT4                 (0x0a << 16)
+#    define BLIT_COLOR_FORM_CLUT8                 (0x0b << 16)
+#    define BLIT_COLOR_FORM_ACLUT44               (0x0c << 16)
+#    define BLIT_COLOR_FORM_ACLUT88               (0x0d << 16)
+#  define BLIT_TY_COLOR_FORM_IS_YUV(ty)         ((((ty) & (0x18 << 16)) == (0x10 << 16)) || (((ty) & (0x0f << 16)) == (0x0e << 16)))
+#  define BLIT_TY_COLOR_FORM_IS_YUVr(ty)        ((((ty) & (0x1f << 16)) == BLIT_COLOR_FORM_YCBCR888) || (((ty) & (0x1f << 16)) == BLIT_COLOR_FORM_YCBCR422R) || (((ty) & (0x1f << 16)) == BLIT_COLOR_FORM_AYCBCR8888))
+#    define BLIT_COLOR_FORM_YCBCR888              (0x10 << 16)
+#    define BLIT_COLOR_FORM_YCBCR422R             (0x12 << 16)
+#    define BLIT_COLOR_FORM_YCBCR42XMB            (0x14 << 16)
+#    define BLIT_COLOR_FORM_AYCBCR8888            (0x15 << 16)
+#    define BLIT_COLOR_FORM_YCBCR42XR2B           (0x16 << 16)
+#    define BLIT_COLOR_FORM_YCBCR42XMBN           (0x0e << 16)
+#    define BLIT_COLOR_FORM_YUV444P               (0x1e << 16)
+#  define BLIT_TY_COLOR_FORM_IS_MISC(ty)        (((ty) & (0x18 << 16)) == (0x18 << 16))
+#  define BLIT_TY_COLOR_FORM_IS_ALPHA(ty)       (((ty) & (0x1e << 16)) == (0x18 << 16))
+#    define BLIT_COLOR_FORM_A1                    (0x18 << 16)
+#    define BLIT_COLOR_FORM_A8                    (0x19 << 16)
+#    define BLIT_COLOR_FORM_RLD_BD                (0x1a << 16)
+#    define BLIT_COLOR_FORM_RLD_H2                (0x1b << 16)
+#    define BLIT_COLOR_FORM_RLD_H8                (0x1c << 16)
+
+#define BLIT_TY_FULL_ALPHA_RANGE              (1L << 21)
+#define BLIT_TY_ENABLE_DITHER_TTYONLY         (1L << 26)
+#define BLIT_TY_COPYDIR_MASK                  (3 << 24)
+#  define BLIT_TY_COPYDIR_MASK_VERT               (1 << 25)
+#    define BLIT_TY_COPYDIR_TOPBOTTOM             (0 << 25)
+#    define BLIT_TY_COPYDIR_BOTTOMTOP             (1 << 25)
+#  define BLIT_TY_COPYDIR_MASK_HORI               (1 << 24)
+#    define BLIT_TY_COPYDIR_LEFTRIGHT             (0 << 24)
+#    define BLIT_TY_COPYDIR_RIGHTLEFT             (1 << 24)
+
+/*
+ * NOTE: bit 29 is the opposite way around from the original Gamma blitter
+ *       documentation, which appears to be incorrect. It is documented
+ *       correctly for the BDisp blitter and works correctly on both.
+ */
+#define BLIT_TY_COLOR_EXPAND_MASK             (1L << 29)
+#define BLIT_TY_COLOR_EXPAND_MSB              (0L << 29)
+#define BLIT_TY_COLOR_EXPAND_ZEROS            (1L << 29)
+#define BLIT_TY_BIG_ENDIAN                    (1L << 30)
+
+
+/* the various BLT_xTY registers hold the type and pitch + some other flags
+   as can be seen above, add some helper macros to extract useful
+   information */
+/* these are the necessary bits to describe a pixelformat exactly */
+static inline u32
+__attribute__((const))
+bdisp_ty_get_format_from_ty (u32 ty)
+{
+  return ty & (BLIT_TY_COLOR_FORM_MASK | BLIT_TY_FULL_ALPHA_RANGE | BLIT_TY_BIG_ENDIAN);
+}
+
+/* when switching from blit to draw without any other state changes,
+   BLT_TTY might (and will!) still contain the copy direction, we have to
+   clear it for normal fills. */
+static inline u32
+__attribute__((const))
+bdisp_ty_sanitise_direction (u32 ty)
+{
+  return ty & ~BLIT_TY_COPYDIR_MASK;
+}
+
+static inline bool
+__attribute__((const))
+bdisp_ty_formats_identical (u32 ty1, u32 ty2)
+{
+  return bdisp_ty_get_format_from_ty (ty1) == bdisp_ty_get_format_from_ty (ty2);
+}
+
+
+/*
+ * Blit instruction control
+ */
+#define BLIT_INS_SRC1_MODE_MASK               (0x00000007)
+#  define BLIT_INS_SRC1_MODE_DISABLED           (0 << 0)
+#  define BLIT_INS_SRC1_MODE_MEMORY             (0x00000001)
+#  define BLIT_INS_SRC1_MODE_COLOR_FILL         (0x00000003)
+#  define BLIT_INS_SRC1_MODE_DIRECT_COPY        (0x00000004)
+#  define BLIT_INS_SRC1_MODE_DIRECT_FILL        (0x00000007)
+#define BLIT_INS_SRC2_MODE_MASK               (0x00000018)
+#  define BLIT_INS_SRC2_MODE_DISABLED           (0 << 3)
+#  define BLIT_INS_SRC2_MODE_MEMORY             (0x00000008)
+#  define BLIT_INS_SRC2_MODE_COLOR_FILL         (0x00000018)
+#define BLIT_INS_SRC3_MODE_MASK               (0x00000020)
+#  define BLIT_INS_SRC3_MODE_DISABLED           (0 << 5)
+#  define BLIT_INS_SRC3_MODE_MEMORY             (0x00000020)
+#define BLIT_INS_ENABLE_IVMX                  (0x00000040)
+#define BLIT_INS_ENABLE_CLUT                  (0x00000080)
+#define BLIT_INS_ENABLE_2DRESCALE             (0x00000100)
+#define BLIT_INS_ENABLE_FLICKERFILTER         (0x00000200)
+#define BLIT_INS_ENABLE_RECTCLIP              (0x00000400)
+#define BLIT_INS_ENABLE_COLORKEY              (0x00000800)
+#define BLIT_INS_ENABLE_OVMX                  (0x00001000)
+#define BLIT_INS_ENABLE_DEI                   (0x00002000)
+#define BLIT_INS_ENABLE_PLANEMASK             (0x00004000)
+#define BLIT_INS_ENABLE_VC1R                  (0x00020000)
+#define BLIT_INS_ENABLE_ROTATION              (0x00040000)
+#define BLIT_INS_ENABLE_BLITCOMPIRQ           (0x80000000)
+
+
+/* CICs */
+#define CIC_NODE_COLOR         (1 <<  2)
+#define CIC_NODE_SOURCE1       (1 <<  3)
+#define CIC_NODE_SOURCE2       (1 <<  4)
+#define CIC_NODE_SOURCE3       (1 <<  5)
+#ifdef STGFX2_SUPPORT_HW_CLIPPING
+  #define CIC_NODE_CLIP          (1 <<  6)
+#else
+  #define CIC_NODE_CLIP          (0 <<  6)
+#endif
+#define CIC_NODE_CLUT          (1 <<  7)
+#define CIC_NODE_FILTERS       (1 <<  8)
+#define CIC_NODE_2DFILTERSCHR  (1 <<  9)
+#define CIC_NODE_2DFILTERSLUMA (1 << 10)
+#define CIC_NODE_FLICKER       (1 << 11)
+#define CIC_NODE_COLORKEY      (1 << 12)
+// 13 doesn't exist
+#ifdef STGFX2_IMPLEMENT_WAITSERIAL
+  #define CIC_NODE_STATIC        (1 << 14)
+#else
+  #define CIC_NODE_STATIC        (0 << 14)
+#endif
+#define CIC_NODE_IVMX          (1 << 15)
+#define CIC_NODE_OVMX          (1 << 16)
+// 17 doesn't exist
+#define CIC_NODE_VC1R          (1 << 18)
+
+
+/* ALU and Colour key control */
+#define BLIT_ACK_MODE_MASK                    0x0f
+#  define BLIT_ACK_BYPASSSOURCE1                0x00
+#  define BLIT_ACK_ROP                          0x01
+#  define BLIT_ACK_BLEND_SRC2_N_PREMULT         0x02
+#  define BLIT_ACK_BLEND_SRC2_PREMULT           0x03
+#  define BLIT_ACK_BLEND_CLIPMASK_LOG_1ST       0x04
+#  define BLIT_ACK_BLEND_CLIPMASK_LOG_2ND       0x08
+#  define BLIT_ACK_BLEND_CLIPMASK_BLEND         0x05
+#  define BLIT_ACK_BYPASSSOURCE2                0x07
+
+#define BLIT_ACK_SWAP_FG_BG                   (0x01 << 4)
+
+#define BLIT_ACK_ROP_SHIFT                    8
+#define BLIT_ACK_ROP_MASK                     (0xff << BLIT_ACK_ROP_SHIFT)
+#  define BLIT_ACK_ROP_CLEAR                    ( 0 << BLIT_ACK_ROP_SHIFT) /* 0 */
+#  define BLIT_ACK_ROP_AND                      ( 1 << BLIT_ACK_ROP_SHIFT) /* S2 & S1 */
+#  define BLIT_ACK_ROP_ANDrev                   ( 2 << BLIT_ACK_ROP_SHIFT) /* S2 & !S1 */
+#  define BLIT_ACK_ROP_COPY                     ( 3 << BLIT_ACK_ROP_SHIFT) /* S2 */
+#  define BLIT_ACK_ROP_ANDinv                   ( 4 << BLIT_ACK_ROP_SHIFT) /* (!S2) & S1*/
+#  define BLIT_ACK_ROP_NOOP                     ( 5 << BLIT_ACK_ROP_SHIFT) /* S1 */
+#  define BLIT_ACK_ROP_XOR                      ( 6 << BLIT_ACK_ROP_SHIFT) /* S2 ^ S1 */
+#  define BLIT_ACK_ROP_OR                       ( 7 << BLIT_ACK_ROP_SHIFT) /* S2 | S1 */
+#  define BLIT_ACK_ROP_NOR                      ( 8 << BLIT_ACK_ROP_SHIFT) /* !S2 & !S1 */
+#  define BLIT_ACK_ROP_EQUIV                    ( 9 << BLIT_ACK_ROP_SHIFT) /* !S2 ^ S1 */
+#  define BLIT_ACK_ROP_INVERT                   (10 << BLIT_ACK_ROP_SHIFT) /* !S1 */
+#  define BLIT_ACK_ROP_ORrev                    (11 << BLIT_ACK_ROP_SHIFT) /* S2 | !S1 */
+#  define BLIT_ACK_ROP_COPYinv                  (12 << BLIT_ACK_ROP_SHIFT) /* !S2 */
+#  define BLIT_ACK_ROP_ORinvert                 (13 << BLIT_ACK_ROP_SHIFT) /* !S2 | S1 */
+#  define BLIT_ACK_ROP_NAND                     (14 << BLIT_ACK_ROP_SHIFT) /* !S2 | !S1 */
+#  define BLIT_ACK_ROP_SET                      (15 << BLIT_ACK_ROP_SHIFT) /* 1 */
+
+#define BLIT_ACK_GLOBAL_ALPHA_SHIFT           8
+#define BLIT_ACK_GLOBAL_ALPHA_MASK            (0xff << BLIT_ACK_GLOBAL_ALPHA_SHIFT)
+
+#define BLIT_ACK_CKEY_MASK                    (0x3f << 16)
+#  define BLIT_ACK_CKEY_BLUE_IGNORE             (0x0 << 16)
+#  define BLIT_ACK_CKEY_BLUE_ENABLE             (0x1 << 16)
+#  define BLIT_ACK_CKEY_BLUE_INV_ENABLE         (0x3 << 16)
+#  define BLIT_ACK_CKEY_GREEN_IGNORE            (0x0 << 18)
+#  define BLIT_ACK_CKEY_GREEN_ENABLE            (0x1 << 18)
+#  define BLIT_ACK_CKEY_GREEN_INV_ENABLE        (0x3 << 18)
+#  define BLIT_ACK_CKEY_RED_IGNORE              (0x0 << 20)
+#  define BLIT_ACK_CKEY_RED_ENABLE              (0x1 << 20)
+#  define BLIT_ACK_CKEY_RED_INV_ENABLE          (0x3 << 20)
+#  define BLIT_ACK_CKEY_RGB_ENABLE              (BLIT_ACK_CKEY_BLUE_ENABLE    \
+                                                 | BLIT_ACK_CKEY_GREEN_ENABLE \
+                                                 | BLIT_ACK_CKEY_RED_ENABLE   \
+                                                )
+#  define BLIT_ACK_CKEY_RGB_INV_ENABLE          (BLIT_ACK_CKEY_BLUE_INV_ENABLE    \
+                                                 | BLIT_ACK_CKEY_GREEN_INV_ENABLE \
+                                                 | BLIT_ACK_CKEY_RED_INV_ENABLE   \
+                                                )
+
+#define BLIT_ACK_COLORKEYING_MASK               (3 << 22)
+#  define BLIT_ACK_COLORKEYING_DEST               (0L << 22)
+#  define BLIT_ACK_COLORKEYING_SRC_BEFORE         (1L << 22)
+#  define BLIT_ACK_COLORKEYING_SRC_AFTER          (2L << 22)
+#  define BLIT_ACK_COLORKEYING_DEST_KEY_ZEROS_SRC_ALPHA  (3L << 22)
+
+
+/* colorspace conversion and CLUT control */
+#define BLIT_CCO_CLUT_NS2_S1_MASK             (1 << 15)
+#  define BLIT_CCO_CLUT_NS2_S1_ON_S2            (0 << 15)
+#  define BLIT_CCO_CLUT_NS2_S1_ON_S1            (1 << 15)
+#define BLIT_CCO_CLUT_MODE_MASK               (3 << 16)
+#  define BLIT_CCO_CLUT_EXPAND                  (0 << 16)
+#  define BLIT_CCO_CLUT_CORRECT                 (1 << 16)
+#define BLIT_CCO_CLUT_UPDATE_EN               (1 << 18)
+
+
+/* common resize and flicker filter control */
+#define BLIT_RZC_2DHF_MODE_MASK               (0x07 << 0)
+#  define BLIT_RZC_2DHF_MODE_DISABLED           (0x00 << 0)
+#  define BLIT_RZC_2DHF_MODE_RESIZE_ONLY        (0x04 << 0)
+#  define BLIT_RZC_2DHF_MODE_FILTER_COLOUR      (0x05 << 0)
+#  define BLIT_RZC_2DHF_MODE_FILTER_ALPHA       (0x06 << 0)
+#  define BLIT_RZC_2DHF_MODE_FILTER_BOTH        (0x07 << 0)
+#define BLIT_RZC_2DVF_MODE_MASK               (0x07 << 4)
+#  define BLIT_RZC_2DVF_MODE_DISABLED           (0x00 << 4)
+#  define BLIT_RZC_2DVF_MODE_RESIZE_ONLY        (0x04 << 4)
+#  define BLIT_RZC_2DVF_MODE_FILTER_COLOUR      (0x05 << 4)
+#  define BLIT_RZC_2DVF_MODE_FILTER_ALPHA       (0x06 << 4)
+#  define BLIT_RZC_2DVF_MODE_FILTER_BOTH        (0x07 << 4)
+#define BLIT_RZC_FF_MODE_MASK                 (0x01 << 8)
+#  define BLIT_RZC_FF_MODE_FILTER0              (0x00 << 8)
+#  define BLIT_RZC_FF_MODE_ADAPTIVE             (0x01 << 8)
+#define BLIT_RZC_Y_2DHF_MODE_MASK             (0x03 << 24)
+#  define BLIT_RZC_Y_2DHF_MODE_DISABLED         (0x00 << 24)
+#  define BLIT_RZC_Y_2DHF_MODE_RESIZE_ONLY      (0x02 << 24)
+#  define BLIT_RZC_Y_2DHF_MODE_FILTER_BOTH      (0x03 << 24)
+#define BLIT_RZC_Y_2DVF_MODE_MASK             (0x03 << 28)
+#  define BLIT_RZC_Y_2DVF_MODE_DISABLED         (0x00 << 28)
+#  define BLIT_RZC_Y_2DVF_MODE_RESIZE_ONLY      (0x02 << 28)
+#  define BLIT_RZC_Y_2DVF_MODE_FILTER_BOTH      (0x03 << 28)
+#define BLIT_RZC_BOUNDARY_BYPASS              (0x01 << 31)
+
+
+#define BLIT_RZI_H_INIT_SHIFT           (0)
+#define BLIT_RZI_H_INIT_MASK            (0x3FFL << BLIT_RZI_H_INIT_SHIFT)
+#define BLIT_RZI_H_REPEAT_SHIFT         (12)
+#define BLIT_RZI_H_REPEAT_MASK          (0x7L << BLIT_RZI_H_REPEAT_SHIFT)
+#define BLIT_RZI_V_INIT_SHIFT           (16)
+#define BLIT_RZI_V_INIT_MASK            (0x3FFL << BLIT_RZI_V_INIT_SHIFT)
+#define BLIT_RZI_V_REPEAT_SHIFT         (28)
+#define BLIT_RZI_V_REPEAT_MASK          (0x7L << BLIT_RZI_V_REPEAT_SHIFT)
+
+
+#endif /* __BDISP_REGISTERS_H__ */
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/gfxdrivers/stgfx2/bdisp_state.c DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/bdisp_state.c
--- DirectFB/gfxdrivers/stgfx2/bdisp_state.c	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/bdisp_state.c	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,3206 @@
+/*
+   ST Microelectronics BDispII driver - state handling
+
+   (c) Copyright 2008-2010  STMicroelectronics Ltd.
+
+   All rights reserved.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <asm/types.h>
+#include <direct/types.h>
+#include <core/coretypes.h>
+#include <core/state.h>
+#include <core/surface.h>
+
+#include <gfx/convert.h>
+
+
+#include "stgfx2_features.h"
+#include "stm_types.h"
+
+#include "bdisp_state.h"
+
+#include "bdisp_features.h"
+#include "bdisp_tables.h"
+#include "bdisp_registers.h"
+#include "stm_gfxdriver.h"
+#include "bdisp_accel.h"
+
+
+D_DEBUG_DOMAIN (BDisp_State,      "BDisp/State",      "BDispII state handling");
+D_DEBUG_DOMAIN (BDisp_StateCheck, "BDisp/StateCheck", "BDispII state testing");
+D_DEBUG_DOMAIN (BDisp_StateSet,   "BDisp/StateSet",   "BDispII state setting");
+
+
+/* state validation flags */
+enum {
+  DESTINATION        = 0x00000001,
+  CLIP               = 0x00000002,
+  FILLCOLOR          = 0x00000004,
+  BLITCOLOR          = 0x00000008,
+  DST_COLORKEY       = 0x00000010,
+
+  SOURCE             = 0x00000020,
+  SOURCE_SRC1_MODE   = 0x00000400, /* source 1 mode */
+  SRC_COLORKEY       = 0x00000040,
+  PALETTE_DRAW       = 0x00000080,
+  PALETTE_BLIT       = 0x00000100,
+
+  DRAWINGFLAGS       = 0x00000200,
+
+  BLITTINGFLAGS_CKEY = 0x00010000,
+  ROTATION           = 0x00020000,
+  RENDEROPTS         = 0x00040000,
+  BLITTINGFLAGS      = 0x00080000,
+  MATRIXCONVERSIONS  = 0x00100000,
+  INPUTMATRIX        = 0x00200000,
+
+  ALL                = 0x003f07ff
+};
+
+/* state handling macros */
+#define BDISP_STATE_VALIDATED(flags)       ( { stdev->v_flags |=  (flags); } )
+#define BDISP_STATE_INVALIDATE(flags)      ( { stdev->v_flags &= ~(flags); } )
+#define BDISP_STATE_FLAG_NEEDS_VALIDATE(flag)     (!(stdev->v_flags & flag))
+#define BDISP_STATE_CHECK_N_VALIDATE(flag) ( {                                                    \
+                                             if (BDISP_STATE_FLAG_NEEDS_VALIDATE(flag))           \
+                                               bdisp_state_validate_##flag (stdrv, stdev, state); \
+                                           } )
+#define BDISP_STATE_CHECK_N_VALIDATE2(flag) ( {                                                   \
+                                             if (BDISP_STATE_FLAG_NEEDS_VALIDATE(flag))           \
+                                               bdisp_state_validate_##flag (stdrv, stdev, state, funcs); \
+                                           } )
+#define BDISP_STATE_CHECK_N_VALIDATE3(flag) ( {                                                   \
+                                             if (BDISP_STATE_FLAG_NEEDS_VALIDATE(flag))           \
+                                               bdisp_state_validate_##flag (stdrv, stdev, state, accel); \
+                                           } )
+
+
+/******** SetState() ********************************************************/
+#if defined(STGFX2_DUMP_CHECK_STATE) \
+    || defined(STGFX2_DUMP_CHECK_STATE_FAILED) \
+    || defined(STGFX2_DUMP_SET_STATE)
+static const char *_state_strs[] = {
+  "DSBF_UNKNOWN",
+  "DSBF_ZERO",
+  "DSBF_ONE",
+  "DSBF_SRCCOLOR",
+  "DSBF_INVSRCCOLOR",
+  "DSBF_SRCALPHA",
+  "DSBF_INVSRCALPHA",
+  "DSBF_DESTALPHA",
+  "DSBF_INVDESTALPHA",
+  "DSBF_DESTCOLOR",
+  "DSBF_INVDESTCOLOR",
+  "DSBF_SRCALPHASAT"
+};
+
+static char *
+_get_accel_string (DFBAccelerationMask accel)
+{
+  char *str = malloc (220);
+  int pos = 0;
+
+  pos += sprintf (str + pos, "%.8x ->", accel);
+  if (accel == DFXL_NONE)
+    pos += sprintf (str + pos, " NONE");
+  else if (accel == DFXL_ALL)
+    pos += sprintf (str + pos, " ALL");
+  else if (accel == DFXL_ALL_DRAW)
+    pos += sprintf (str + pos, " ALL_DRAW");
+  else if (accel == DFXL_ALL_BLIT)
+    pos += sprintf (str + pos, " ALL_BLIT");
+  else
+    {
+      if (accel & DFXL_FILLRECTANGLE)
+        pos += sprintf (str + pos, " FILLRECTANGLE");
+      if (accel & DFXL_DRAWRECTANGLE)
+        pos += sprintf (str + pos, " DRAWRECTANGLE");
+      if (accel & DFXL_DRAWLINE)
+        pos += sprintf (str + pos, " DRAWLINE");
+      if (accel & DFXL_FILLTRIANGLE)
+        pos += sprintf (str + pos, " FILLTRIANGLE");
+      if (accel & DFXL_BLIT)
+        pos += sprintf (str + pos, " BLIT");
+      if (accel & DFXL_STRETCHBLIT)
+        pos += sprintf (str + pos, " STRETCHBLIT");
+      if (accel & DFXL_TEXTRIANGLES)
+        pos += sprintf (str + pos, " TEXTRIANGLES");
+      if (accel & DFXL_BLIT2)
+        pos += sprintf (str + pos, " BLIT2");
+      if (accel & DFXL_DRAWSTRING)
+        pos += sprintf (str + pos, " DRAWSTRING");
+    }
+
+  return str;
+}
+
+static char *
+_get_modified_string (StateModificationFlags modified)
+{
+  char *str = malloc (220);
+  int pos = 0;
+
+  pos += sprintf (str + pos, "%.8x ->", modified);
+  if (!modified)
+    pos += sprintf (str + pos, " none");
+  else if (modified == SMF_ALL)
+    pos += sprintf (str + pos, " ALL");
+  else
+    {
+      if (modified & SMF_DRAWING_FLAGS)
+        pos += sprintf (str + pos, " DRAWING_FLAGS");
+      if (modified & SMF_BLITTING_FLAGS)
+        pos += sprintf (str + pos, " BLITTING_FLAGS");
+      if (modified & SMF_CLIP)
+        pos += sprintf (str + pos, " CLIP");
+      if (modified & SMF_COLOR)
+        pos += sprintf (str + pos, " COLOR");
+      if (modified & SMF_SRC_BLEND)
+        pos += sprintf (str + pos, " SRC_BLEND");
+      if (modified & SMF_DST_BLEND)
+        pos += sprintf (str + pos, " DST_BLEND");
+      if (modified & SMF_SRC_COLORKEY)
+        pos += sprintf (str + pos, " SRC_COLORKEY");
+      if (modified & SMF_DST_COLORKEY)
+        pos += sprintf (str + pos, " DST_COLORKEY");
+      if (modified & SMF_DESTINATION)
+        pos += sprintf (str + pos, " DESTINATION");
+      if (modified & SMF_SOURCE)
+        pos += sprintf (str + pos, " SOURCE");
+      if (modified & SMF_SOURCE_MASK)
+        pos += sprintf (str + pos, " SOURCE_MASK");
+      if (modified & SMF_SOURCE_MASK_VALS)
+        pos += sprintf (str + pos, " SOURCE_MASK_VALS");
+      if (modified & SMF_INDEX_TRANSLATION)
+        pos += sprintf (str + pos, " INDEX_TRANSLATION");
+      if (modified & SMF_COLORKEY)
+        pos += sprintf (str + pos, " COLORKEY");
+      if (modified & SMF_RENDER_OPTIONS)
+        pos += sprintf (str + pos, " RENDER_OPTIONS");
+      if (modified & SMF_MATRIX)
+        pos += sprintf (str + pos, " MATRIX");
+      if (modified & SMF_SOURCE2)
+        pos += sprintf (str + pos, " SOURCE2");
+    }
+
+  return str;
+}
+
+static char *
+_get_drawflags_string (DFBSurfaceDrawingFlags flags)
+{
+  char *str = malloc (220);
+  int pos = 0;
+
+  pos += sprintf (str + pos, "%.8x ->", flags);
+  if (flags == DSDRAW_NOFX)
+    pos += sprintf (str + pos, " NOFX");
+  else
+    {
+      if (flags & DSDRAW_BLEND)
+        pos += sprintf (str + pos, " BLEND");
+      if (flags & DSDRAW_DST_COLORKEY)
+        pos += sprintf (str + pos, " DST_COLORKEY");
+      if (flags & DSDRAW_SRC_PREMULTIPLY)
+        pos += sprintf (str + pos, " SRC_PREMULTIPLY");
+      if (flags & DSDRAW_DST_PREMULTIPLY)
+        pos += sprintf (str + pos, " DST_PREMULTIPLY");
+      if (flags & DSDRAW_DEMULTIPLY)
+        pos += sprintf (str + pos, " DEMULTIPLY");
+      if (flags & DSDRAW_XOR)
+        pos += sprintf (str + pos, " XOR");
+    }
+
+  return str;
+}
+
+static char *
+_get_blitflags_string (DFBSurfaceBlittingFlags flags)
+{
+  char *str = malloc (220);
+  int pos = 0;
+
+  pos += sprintf (str + pos, "%.8x ->", flags);
+  if (flags == DSBLIT_NOFX)
+    pos += sprintf (str + pos, " NOFX");
+  else
+    {
+      if (flags & DSBLIT_BLEND_ALPHACHANNEL)
+        pos += sprintf (str + pos, " BLEND_ALPHACHANNEL");
+      if (flags & DSBLIT_BLEND_COLORALPHA)
+        pos += sprintf (str + pos, " BLEND_COLORALPHA");
+      if (flags & DSBLIT_COLORIZE)
+        pos += sprintf (str + pos, " COLORIZE");
+      if (flags & DSBLIT_SRC_COLORKEY)
+        pos += sprintf (str + pos, " SRC_COLORKEY");
+      if (flags & DSBLIT_DST_COLORKEY)
+        pos += sprintf (str + pos, " DST_COLORKEY");
+      if (flags & DSBLIT_SRC_PREMULTIPLY)
+        pos += sprintf (str + pos, " SRC_PREMULTIPLY");
+      if (flags & DSBLIT_DST_PREMULTIPLY)
+        pos += sprintf (str + pos, " DST_PREMULTIPLY");
+      if (flags & DSBLIT_DEMULTIPLY)
+        pos += sprintf (str + pos, " DEMULTIPLY");
+      if (flags & DSBLIT_DEINTERLACE)
+        pos += sprintf (str + pos, " DEINTERLACE");
+      if (flags & DSBLIT_SRC_PREMULTCOLOR)
+        pos += sprintf (str + pos, " SRC_PREMULTCOLOR");
+      if (flags & DSBLIT_XOR)
+        pos += sprintf (str + pos, " XOR");
+      if (flags & DSBLIT_INDEX_TRANSLATION)
+        pos += sprintf (str + pos, " INDEX_TRANSLATION");
+      if (flags & DSBLIT_ROTATE90)
+        pos += sprintf (str + pos, " ROTATE90");
+      if (flags & DSBLIT_ROTATE180)
+        pos += sprintf (str + pos, " ROTATE180");
+      if (flags & DSBLIT_ROTATE270)
+        pos += sprintf (str + pos, " ROTATE270");
+      if (flags & DSBLIT_COLORKEY_PROTECT)
+        pos += sprintf (str + pos, " COLORKEY_PROTECT");
+      if (flags & DSBLIT_SRC_MASK_ALPHA)
+        pos += sprintf (str + pos, " SRC_MASK_ALPHA");
+      if (flags & DSBLIT_SRC_MASK_COLOR)
+        pos += sprintf (str + pos, " SRC_MASK_COLOR");
+      if (flags & DSBLIT_SOURCE2)
+        pos += sprintf (str + pos, " SOURCE2");
+      if (flags & DSBLIT_FLIP_HORIZONTAL)
+        pos += sprintf (str + pos, " FLIP_HORIZONTAL");
+      if (flags & DSBLIT_FLIP_VERTICAL)
+        pos += sprintf (str + pos, " FLIP_VERTICAL");
+      if (flags & DSBLIT_FIXEDPOINT)
+        pos += sprintf (str + pos, " FIXEDPOINT");
+    }
+
+  return str;
+}
+
+static char *
+_get_renderoptions_string (DFBSurfaceRenderOptions opts)
+{
+  char *str = malloc (220);
+  int pos = 0;
+
+  pos += sprintf (str + pos, "%.8x ->", opts);
+  if (opts == DSRO_NONE)
+    pos += sprintf (str + pos, " NONE");
+  else
+    {
+      if (opts & DSRO_SMOOTH_UPSCALE)
+        pos += sprintf (str + pos, " SMOOTH_UPSCALE");
+      if (opts & DSRO_SMOOTH_DOWNSCALE)
+        pos += sprintf (str + pos, " SMOOTH_DOWNSCALE");
+      if (opts & DSRO_MATRIX)
+        pos += sprintf (str + pos, " MATRIX");
+      if (opts & DSRO_ANTIALIAS)
+        pos += sprintf (str + pos, " ANTIALIAS");
+    }
+
+  return str;
+}
+
+static char *
+_get_matrix_string (const s32 *matrix)
+{
+  char *str = malloc (220);
+  int pos = 0, i;
+
+  for (i = 0; i < 3; ++i, ++matrix)
+    pos += sprintf (str + pos, "[%.3x.%.3x] ", (*matrix) >> 16, (*matrix) & 0xffff);
+  pos += sprintf (str + pos, "\n            ");
+  for (i = 0; i < 3; ++i, ++matrix)
+    pos += sprintf (str + pos, "[%.3x.%.3x] ", (*matrix) >> 16, (*matrix) & 0xffff);
+  pos += sprintf (str + pos, "\n            ");
+  for (i = 0; i < 3; ++i, ++matrix)
+    pos += sprintf (str + pos, "[%.3x.%.3x] ", (*matrix) >> 16, (*matrix) & 0xffff);
+  pos += sprintf (str + pos, "\n");
+
+  return str;
+}
+
+static void
+_dump_state (const char          * const prefix,
+             const CardState     * const state,
+             DFBAccelerationMask  accel)
+{
+  char * const accel_str = _get_accel_string (accel);
+  char * const modified_str = _get_modified_string (state->mod_hw);
+  char * const drawflags_str = _get_drawflags_string (state->drawingflags);
+  char * const blitflags_str = _get_blitflags_string (state->blittingflags);
+  char * const renderopts_str = _get_renderoptions_string (state->render_options);
+  char * const matrix_str = _get_matrix_string (state->matrix);
+
+  printf ("%s: accel: %s\n"
+          "    state: modified: %s, flags draw/blit: %s/%s\n"
+          "    blendfunc src/dst: %u(%s)/%u(%s)\n"
+          "    format src/dst: '%s'/'%s'\n"
+          "    color/index: %.2x%.2x%.2x%.2x/%.8x colorkey src/dst: %.8x/%.8x   clip: %d,%d-%d,%d\n"
+          "    render_opts: %s\n"
+          "    matrix: %s\n",
+          prefix,
+          accel_str, modified_str, drawflags_str, blitflags_str,
+          state->src_blend, (state->src_blend <= DSBF_SRCALPHASAT) ? _state_strs[state->src_blend] : _state_strs[0],
+          state->dst_blend, (state->dst_blend <= DSBF_SRCALPHASAT) ? _state_strs[state->dst_blend] : _state_strs[0],
+          state->source ? dfb_pixelformat_name (state->source->config.format) : "no source",
+          state->destination ? dfb_pixelformat_name (state->destination->config.format) : "no dest",
+          state->color.a, state->color.r, state->color.g, state->color.b, state->color_index,
+          state->src_colorkey, state->dst_colorkey, DFB_REGION_VALS (&state->clip),
+          renderopts_str, matrix_str);
+
+  free (matrix_str);
+  free (renderopts_str);
+  free (blitflags_str);
+  free (drawflags_str);
+  free (modified_str);
+  free (accel_str);
+}
+#endif /* STGFX2_DUMP_CHECK_STATE || STGFX2_DUMP_CHECK_STATE_FAILED || STGFX2_DUMP_SET_STATE */
+#ifdef STGFX2_DUMP_CHECK_STATE
+  #define _dump_check_state(p, s, a) _dump_state(p, s, a)
+#else /* STGFX2_DUMP_CHECK_STATE */
+  #define _dump_check_state(p, s, a)
+#endif /* STGFX2_DUMP_CHECK_STATE */
+
+#ifdef STGFX2_DUMP_CHECK_STATE_FAILED
+  #ifndef STGFX2_DUMP_CHECK_STATE
+    #define _dump_check_state_failed(p, s, a) ( { char t[100];               \
+                                                  snprintf (t, sizeof (t),   \
+                                                            "%s: failed", p);\
+                                                  _dump_state(t, s, a);      \
+                                              } )
+  #else /* STGFX2_DUMP_CHECK_STATE_FAILED */
+    #define _dump_check_state_failed(p, s, a) printf("... %s: failed\n", p);
+  #endif /* STGFX2_DUMP_CHECK_STATE_FAILED */
+#else /* STGFX2_DUMP_CHECK_STATE */
+  #define _dump_check_state_failed(p, s, a)
+#endif /* STGFX2_DUMP_CHECK_STATE */
+
+#ifdef STGFX2_DUMP_SET_STATE
+  #define _dump_set_state(p, s, a) _dump_state(p, s, a)
+#else /* STGFX2_DUMP_SET_STATE */
+  #define _dump_set_state(p, s, a)
+#endif /* STGFX2_DUMP_SET_STATE */
+
+
+
+
+#define DSPD_SATURATE          (DSPD_DST + 1)
+#define DSPD_UNSUPPORTED       (DSPD_SATURATE + 1)
+static DFBSurfacePorterDuffRule
+__attribute__((warn_unused_result))
+bdisp_aq_convert_to_supported_porterduff (const CardState * const state)
+{
+  /* the blending maths we can support */
+  switch (state->src_blend)
+    {
+    case DSBF_ZERO:
+      if (state->dst_blend == DSBF_ZERO)
+        return DSPD_CLEAR;
+      if (state->dst_blend == DSBF_SRCALPHA)
+        return DSPD_DST_IN;
+      if (state->dst_blend == DSBF_INVSRCALPHA)
+        return DSPD_DST_OUT;
+      if (state->dst_blend == DSBF_ONE)
+        return DSPD_DST;
+      break;
+
+    case DSBF_ONE:
+      if (state->dst_blend == DSBF_ZERO)
+        return DSPD_SRC;
+      if (state->dst_blend == DSBF_INVSRCALPHA)
+        return DSPD_SRC_OVER;
+      break;
+
+    case DSBF_INVDESTALPHA:
+      if (state->dst_blend == DSBF_ONE)
+        return DSPD_DST_OVER;
+      break;
+
+    case DSBF_SRCALPHA:
+      if (state->dst_blend == DSBF_INVSRCALPHA)
+        return DSPD_NONE;
+      break;
+
+    default:
+      break;
+    }
+
+  return DSPD_UNSUPPORTED;
+}
+
+static bool
+stgfx2SupportedSrcPixelFormat (const STGFX2DeviceData * const stdev,
+                               DFBSurfacePixelFormat   dfbFmt)
+{
+  const struct _bdisp_pixelformat_table * const dspf_to_bdisp
+    = stdev->features.dfb_dspf_to_bdisp;
+
+  D_ASSERT (dfbFmt != DSPF_UNKNOWN);
+  if (unlikely (!dfbFmt))
+    return false;
+
+  return dspf_to_bdisp[DFB_PIXELFORMAT_INDEX (dfbFmt)].supported_as_src;
+}
+
+static bool
+stgfx2SupportedDstPixelFormat (const STGFX2DeviceData * const stdev,
+                               DFBSurfacePixelFormat   dfbFmt)
+{
+  const struct _bdisp_pixelformat_table * const dspf_to_bdisp
+    = stdev->features.dfb_dspf_to_bdisp;
+
+  D_ASSERT (dfbFmt != DSPF_UNKNOWN);
+  if (unlikely (!dfbFmt))
+    return false;
+
+  return dspf_to_bdisp[DFB_PIXELFORMAT_INDEX (dfbFmt)].supported_as_dst;
+}
+
+static int
+bdisp_aq_convert_to_supported_rotation (const CardState     * const state,
+                                        DFBAccelerationMask  accel,
+                                        const s32 *matrix)
+{
+  if (state)
+    _dump_check_state (__FUNCTION__, state, accel);
+
+  /* we (can) only support a handful of matrices:
+     - 1:1 translation
+     - rotation 90 180 270 degrees
+     - reflection on X or Y axis
+
+     in theory, support for scaling and rotation could be added as well, I
+     guess. But we deny that for complexity reasons.
+
+     matrix formula:
+     X' = (X * v0 + Y * v1 + v2) / (X * v6 + Y * v7 + v8)
+     Y' = (X * v3 + Y * v4 + v5) / (X * v6 + Y * v7 + v8) */
+#define fixedpointONE  (1L << 16)           /* 1 in 16.16 fixed point */
+#define fixedpointHALF (fixedpointONE / 2)  /* 1/2 in 16.16 fixed point */
+#define fractionMASK   (fixedpointONE - 1)
+  if (state && !state->affine_matrix)
+    return -1;
+
+  if (matrix[2] != 0 || matrix[5] != 0)
+    return -1;
+
+  if (matrix[0] == 1 * fixedpointONE && matrix[1] == 0
+      && matrix[3] == 0 && matrix[4] == -1 * fixedpointONE)
+    return 181; /* reflection against x */
+
+  if (matrix[0] == -1 * fixedpointONE && matrix[1] == 0
+      && matrix[3] == 0 && matrix[4] == 1 * fixedpointONE)
+    return 182; /* reflection against y */
+
+  if (matrix[0] == -1 * fixedpointONE && matrix[1] == 0
+      && matrix[3] == 0 && matrix[4] == -1 * fixedpointONE)
+    return 180; /* counter clock wise */
+
+  if (matrix[0] == 0 && matrix[1] == 1 * fixedpointONE
+      && matrix[3] == -1 * fixedpointONE && matrix[4] == 0)
+    return 270; /* counter clock wise */
+
+  if (matrix[0] == 0 && matrix[1] == -1 * fixedpointONE
+      && matrix[3] == 1 * fixedpointONE && matrix[4] == 0)
+    return 90; /* counter clock wise */
+
+  if (matrix[0] == 1 * fixedpointONE && matrix[1] == 0
+      && matrix[3] == 0 && matrix[4] == 1 * fixedpointONE)
+    return 0; /* nothing */
+
+  return -1;
+}
+
+
+/**************************************************************************/
+/* Check that the current state is ok for the operation indicated by accel*/
+/**************************************************************************/
+  #define BDISP_AQ_DRAW_PIXELFORMAT_HAS_ALPHA(fmt) (DFB_PIXELFORMAT_HAS_ALPHA (fmt))
+
+  #define BDISP_AQ_BLIT_PIXELFORMAT_HAS_ALPHA(fmt) (DFB_PIXELFORMAT_HAS_ALPHA (fmt))
+
+#define BDISP_AQ_MULTIPASS_PORTER_DUFF_RULE(pd) \
+         (((pd) == DSPD_DST_IN)         \
+          || ((pd) == DSPD_DST_OUT)     \
+/*          || ((pd) == DSPD_SRC_IN)      \
+          || ((pd) == DSPD_SRC_OUT)     \
+          || ((pd) == DSPD_SRC_ATOP)    \
+          || ((pd) == DSPD_DST_ATOP)    \
+*/         )
+
+#define BDISP_AQ_PORTER_DUFF_RULE_NEEDS_LUT(pd) \
+         (((pd) == DSPD_DST_IN)         \
+          || ((pd) == DSPD_DST_OUT)     \
+/*          || ((pd) == DSPD_SRC_IN)      \
+          || ((pd) == DSPD_SRC_OUT)     \
+          || ((pd) == DSPD_SRC_ATOP)    \
+          || ((pd) == DSPD_DST_ATOP)    \
+*/         )
+
+void
+bdisp_aq_CheckState (void                * const drv,
+                     void                * const dev,
+                     CardState           * const state,
+                     DFBAccelerationMask  accel)
+{
+  const STGFX2DeviceData * const stdev = dev;
+
+  _dump_check_state (__FUNCTION__, state, accel);
+
+  /* return if the desired function is not supported at all. */
+  if (D_FLAGS_INVALID (accel, (STGFX2_VALID_DRAWINGFUNCTIONS
+                               | STGFX2_VALID_BLITTINGFUNCTIONS)))
+    return;
+
+  if (!stgfx2SupportedDstPixelFormat (stdev, state->destination->config.format))
+    goto out; /* unsupported destination format */
+
+  if (D_FLAGS_INVALID (state->render_options,
+                       stdev->features.dfb_renderopts))
+    goto out;
+
+  int rotation = 0;
+  if (D_FLAGS_IS_SET (state->render_options, DSRO_MATRIX))
+    {
+      rotation = bdisp_aq_convert_to_supported_rotation (state,
+                                                         accel,
+                                                         state->matrix);
+      if (rotation == -1)
+        goto out;
+    }
+
+  if (DFB_DRAWING_FUNCTION (accel))
+    {
+      /* check there are no other drawing flags than those supported */
+      if (D_FLAGS_INVALID (state->drawingflags, stdev->features.dfb_drawflags))
+        goto out;
+
+      /* check blend restrictions */
+      if (D_FLAGS_IS_SET (state->drawingflags, DSDRAW_BLEND))
+        {
+          DFBSurfacePorterDuffRule pd =
+            bdisp_aq_convert_to_supported_porterduff (state);
+
+          if (pd == DSPD_UNSUPPORTED
+              /* can't support multi node drawing ops */
+              || BDISP_AQ_MULTIPASS_PORTER_DUFF_RULE (pd)
+             )
+            goto out;
+
+          if (state->destination->config.format == DSPF_RGB32)
+            {
+              switch (pd)
+                {
+                /* we can support a few operations involving RGB32 without much
+                   effort. Fortunately, those are the ones that are used by
+                   graphics libraries like cairo. */
+                case DSPD_DST_OVER:
+                case DSPD_SRC_OVER:
+                case DSPD_CLEAR:
+                case DSPD_DST:
+                case DSPD_SRC:
+                case DSPD_NONE:
+                  /* supported */
+                  break;
+                default:
+                  goto out;
+                }
+            }
+
+          /* don't allow blends to LUT surfaces, but we do allow fast fills in
+             order to be able to do a "clear" to a specific index. */
+          if (DFB_PIXELFORMAT_IS_INDEXED (state->destination->config.format))
+            goto out;
+
+          /* can not support blend and xor at the same time */
+          if (state->drawingflags & DSDRAW_XOR)
+            goto out;
+
+          /* DSPD_NONE can only be accelerated when the destination does not
+             have an alpha channel, because the correct calculation of the
+             destination alpha cannot be achieved in the hardware. We go to
+             the trouble of supporting it for pure RGB surfaces as the mode
+             is used in the blended fill df_dok performance test. */
+          if (BDISP_AQ_DRAW_PIXELFORMAT_HAS_ALPHA (state->destination->config.format)
+              && pd == DSPD_NONE)
+            goto out;
+        }
+
+      state->accel |= STGFX2_VALID_DRAWINGFUNCTIONS;
+    }
+  else /* if (DFB_BLITTING_FUNCTION (accel)) */
+    {
+      bool canUseHWInputMatrix;
+      bool isRotate;
+      DFBSurfaceBlittingFlags blitflags_norotate;
+
+      /* check there are no other drawing flags than those supported */
+      if (D_FLAGS_INVALID (state->blittingflags, stdev->features.dfb_blitflags))
+        goto out;
+
+      if (!stgfx2SupportedSrcPixelFormat (stdev, state->source->config.format))
+        goto out; /* unsupported source format */
+
+      isRotate = (D_FLAGS_IS_SET (state->blittingflags, (DSBLIT_ROTATE90
+                                                         | DSBLIT_ROTATE270))
+                  || rotation == 90
+                  || rotation == 270);
+      /* rotation is supported only when no other flag is requested (apart
+         from DSBLIT_INDEX_TRANSLATION, which just tells us to do a 1:1 copy
+         of LUT surfaces) */
+      blitflags_norotate = state->blittingflags & ~(DSBLIT_ROTATE90
+                                                    | DSBLIT_ROTATE270);
+
+      /* some pixelformat checks */
+      switch (state->source->config.format)
+        {
+        case DSPF_NV12:
+        case DSPF_NV16:
+           if ((state->source->config.size.w & 0xf)
+               || (state->source->config.size.h & 0xf)
+               || ((state->source->config.size.h >> 4) & 1L))
+             {
+               /* must be an even multiple of 16. */
+               D_WARN ("%s(): nv12 and nv16 width and height must be "
+                       "multiples (even for the height) of 16. Got %dx%d.\n",
+                       __FUNCTION__,
+                       state->source->config.size.w, state->source->config.size.h);
+               goto out;
+             }
+        case DSPF_I420: case DSPF_YV12: case DSPF_YV16: case DSPF_YUV444P:
+          /* we don't (can't) support YUV formats w/ any blittingflags set,
+             we could support SOURCE colorkeying and SOURCE2 probably */
+          if (state->blittingflags)
+            goto out;
+
+          /* we don't support format conversion to RGB32, support could be
+             added, though... */
+          if (state->destination->config.format == DSPF_RGB32)
+            goto out;
+
+        default:
+          break;
+        }
+
+      bool src_is_ycbcr = false, dst_is_ycbcr = false;
+      switch (state->source->config.format)
+        {
+        case DSPF_I420:
+        case DSPF_YV12:
+        case DSPF_YV16:
+        case DSPF_YUV444P:
+          if (D_FLAGS_IS_SET (state->blittingflags, DSBLIT_SOURCE2)
+              || D_FLAGS_IS_SET (accel, DFXL_BLIT2))
+            goto out;
+          /* fall through */
+        case DSPF_UYVY:
+        case DSPF_YUY2:
+        case DSPF_AVYU:
+        case DSPF_VYU:
+        case DSPF_NV12:
+        case DSPF_NV16:
+          if (D_FLAGS_IS_SET (state->blittingflags, (DSBLIT_SRC_PREMULTCOLOR
+                                                     | DSBLIT_SRC_PREMULTIPLY)))
+            /* These are RGB source modulations so fail if the source is YUV. */
+            goto out;
+          src_is_ycbcr = true;
+          /* fall through */
+
+        default:
+          break;
+        }
+
+      switch (state->destination->config.format)
+        {
+        case DSPF_UYVY:
+        case DSPF_YUY2:
+        case DSPF_AVYU:
+        case DSPF_VYU:
+        case DSPF_I420:
+        case DSPF_YV12:
+        case DSPF_YV16:
+        case DSPF_YUV444P:
+        case DSPF_NV12:
+        case DSPF_NV16:
+          dst_is_ycbcr = true;
+          /* fall through */
+
+        default:
+          break;
+        }
+
+      canUseHWInputMatrix = (src_is_ycbcr == dst_is_ycbcr);
+
+      /* deal with a special case of LUT->LUT blits that do not go through a
+         colour lookup, but instead do an index translation mapping. Note
+         that we do not actually support anything other than a 1:1 mapping
+         of the LUT.
+         We do support blitting to a LUT surface in case of rotation (see below
+         for explanation on rotation). */
+      if (DFB_PIXELFORMAT_IS_INDEXED (state->destination->config.format))
+        {
+          /* note that blits are not supported to LUT destinations other than
+             in the index translation case. */
+          if (state->source->config.format == state->destination->config.format
+              && blitflags_norotate == DSBLIT_INDEX_TRANSLATION
+              && !D_FLAGS_IS_SET (state->render_options, DSRO_ANTIALIAS))
+            {
+              state->accel |= DFXL_BLIT;
+              if (!D_FLAGS_IS_SET (state->render_options, (DSRO_SMOOTH_UPSCALE
+                                                           | DSRO_SMOOTH_DOWNSCALE)))
+                state->accel |= DFXL_STRETCHBLIT;
+              return;
+            }
+
+          goto out;
+        }
+
+      /* rotation is supported only when no other flag is requested (apart
+         from DSBLIT_INDEX_TRANSLATION, which just tells us to do a 1:1 copy
+         of LUT surfaces) */
+      if (unlikely (isRotate))
+        {
+          if (blitflags_norotate || !canUseHWInputMatrix)
+            goto out;
+
+          switch (state->source->config.format)
+            {
+            case DSPF_YUY2: case DSPF_UYVY: case DSPF_AVYU: case DSPF_VYU:
+            case DSPF_I420: case DSPF_YV12: case DSPF_YV16: case DSPF_YUV444P:
+            case DSPF_NV12: case DSPF_NV16:
+              goto out;
+
+            default:
+              break;
+            }
+          switch (state->destination->config.format)
+            {
+            case DSPF_YUY2: case DSPF_UYVY: case DSPF_AVYU: case DSPF_VYU:
+              goto out;
+
+            default:
+              break;
+            }
+
+          if (DFB_PIXELFORMAT_IS_INDEXED (state->source->config.format)
+              && state->source->config.format != state->destination->config.format)
+            goto out;
+
+          state->accel |= DFXL_BLIT;
+          return;
+        }
+
+
+      /* can not accelerate simultaneous source and destination colour key */
+      if (D_FLAGS_ARE_SET (state->blittingflags, (DSBLIT_SRC_COLORKEY
+                                                  | DSBLIT_DST_COLORKEY)))
+        goto out;
+
+      /* smooth upscale and smooth downscale must be set the same */
+      if (D_FLAGS_IS_SET (state->render_options, (DSRO_SMOOTH_UPSCALE
+                                                  | DSRO_SMOOTH_DOWNSCALE)))
+        {
+          bool u = !!(state->render_options & DSRO_SMOOTH_UPSCALE);
+          bool d = !!(state->render_options & DSRO_SMOOTH_DOWNSCALE);
+          if (u != d)
+            goto out;
+        }
+
+      bool src_premultcolor = D_FLAGS_IS_SET (state->blittingflags,
+                                              DSBLIT_SRC_PREMULTCOLOR);
+      bool needs_blend = false;
+
+      if (D_FLAGS_IS_SET (state->blittingflags, (DSBLIT_BLEND_COLORALPHA
+                                                 | DSBLIT_BLEND_ALPHACHANNEL)))
+        {
+          DFBSurfacePorterDuffRule pd =
+            bdisp_aq_convert_to_supported_porterduff (state);
+
+          bool src_premultiply;
+
+          if (pd == DSPD_UNSUPPORTED)
+            goto out;
+
+          /* we cannot blend and XOR at the same time, what a silly idea */
+          if (D_FLAGS_IS_SET (state->blittingflags, DSBLIT_XOR))
+            /* XOR needs the ROP unit and blending needs the blend unit - they
+               can not be used simultaneously. */
+            goto out;
+
+          if (state->destination->config.format == DSPF_RGB32)
+            {
+              if (state->source->config.format == DSPF_RGB32
+                  || DFB_PIXELFORMAT_IS_INDEXED (state->source->config.format))
+                /* can't do this for:
+                   RGB32 because we can only use the LUT to correct the alpha
+                         either on S1 or S2, but not on both.
+                   INDEXED because we only have one LUT, either to use for color
+                           lookup or color correction */
+                goto out;
+            }
+
+          src_premultiply = D_FLAGS_IS_SET (state->blittingflags,
+                                            DSBLIT_SRC_PREMULTIPLY);
+
+          switch (state->blittingflags & (DSBLIT_BLEND_ALPHACHANNEL
+                                          | DSBLIT_BLEND_COLORALPHA))
+            {
+            default:
+            case DSBLIT_NOFX:
+            case DSBLIT_BLEND_ALPHACHANNEL:
+              break;
+
+            case DSBLIT_BLEND_COLORALPHA:
+              switch (pd)
+                {
+                case DSPD_DST:
+                  if (D_FLAGS_IS_SET (state->blittingflags,
+                                      DSBLIT_DST_PREMULTIPLY))
+                    break;
+                  /* fall through */
+
+                case DSPD_CLEAR:
+                  break;
+
+                case DSPD_SRC:
+                case DSPD_SRC_OVER:
+                  switch (state->blittingflags & (DSBLIT_SRC_PREMULTCOLOR
+                                                  | DSBLIT_SRC_PREMULTIPLY))
+                    {
+                    case DSBLIT_NOFX:
+                      break;
+
+                    case (DSBLIT_SRC_PREMULTCOLOR | DSBLIT_SRC_PREMULTIPLY):
+                      if (!canUseHWInputMatrix)
+                        break;
+                      /* fall through */
+
+                    case DSBLIT_SRC_PREMULTCOLOR:
+                      if (!src_premultiply)
+                        src_premultcolor = false;
+                      /* fall through */
+
+                    case DSBLIT_SRC_PREMULTIPLY:
+                      needs_blend = true;
+                      src_premultiply = false;
+                      break;
+                    }
+                  break;
+
+                case DSPD_NONE:
+                case DSPD_DST_OVER:
+                case DSPD_DST_IN:
+                case DSPD_DST_OUT:
+                  break;
+
+                default:
+                  /* not reached */
+                  break;
+                }
+              break;
+
+            case (DSBLIT_BLEND_ALPHACHANNEL | DSBLIT_BLEND_COLORALPHA):
+              switch (pd)
+                {
+                case DSPD_DST_OVER:
+                case DSPD_DST_IN:
+                case DSPD_DST_OUT:
+                  break;
+
+                case DSPD_DST:
+                case DSPD_CLEAR:
+                  /* no ops. */
+                  break;
+
+                case DSPD_SRC:
+                case DSPD_SRC_OVER:
+                  if (!D_FLAGS_IS_SET (state->blittingflags,
+                                       (DSBLIT_SRC_PREMULTCOLOR
+                                        | DSBLIT_SRC_PREMULTIPLY)))
+                    break;
+                  /* fall through */
+
+                case DSPD_NONE:
+                  if (D_FLAGS_IS_SET (state->blittingflags,
+                                      DSBLIT_SRC_PREMULTCOLOR)
+                      && !canUseHWInputMatrix)
+                    {
+                      if (D_FLAGS_IS_SET (state->blittingflags,
+                                          DSBLIT_SRC_PREMULTIPLY)
+                          || pd == DSPD_NONE)
+                        break;
+                    }
+
+                  needs_blend = true;
+                  if (src_premultcolor
+                      && !src_premultiply
+                      && pd != DSPD_NONE)
+                    {
+                      src_premultcolor = false;
+                    }
+                  break;
+
+                default:
+                  /* not reached */
+                  break;
+                }
+              break;
+            }
+
+          switch (pd)
+            {
+            case DSPD_SRC:
+              if (src_premultiply)
+                {
+                  needs_blend = true;
+                  if (D_FLAGS_IS_SET (state->blittingflags,
+                                      DSBLIT_DST_COLORKEY
+                                      | DSBLIT_SOURCE2))
+                    /* the SRC_PREMULTIPLY is done using a blend with 0.0.0.0
+                       coming from S1 color fill, so we can not DST_COLORKEY at
+                       the same time */
+                    goto out;
+                }
+
+            case DSPD_DST:
+              if (D_FLAGS_IS_SET (state->blittingflags, DSBLIT_DST_PREMULTIPLY))
+                needs_blend = true;
+              break;
+
+            case DSPD_SRC_OVER:
+              if (D_FLAGS_IS_SET (state->blittingflags, DSBLIT_DST_PREMULTIPLY))
+                goto out;
+              needs_blend = true;
+              break;
+
+            case DSPD_DST_OVER:
+              if (D_FLAGS_IS_SET (state->blittingflags, DSBLIT_SRC_PREMULTIPLY))
+                /* in this case we end up with a destination premultiply, because
+                   we swap FG/BG in the ALU, whereas DirectFB (correctly) still
+                   does a source premultiply.
+                   FIXME: this probably means we could support
+                   DSBLIT_DST_PREMULTIPLY | DSBLIT_DST_PREMULTCOLOR in this
+                   case. */
+                goto out;
+              needs_blend = true;
+              break;
+
+            case DSPD_DST_IN:
+            case DSPD_DST_OUT:
+              if (D_FLAGS_IS_SET (state->blittingflags, DSBLIT_DST_PREMULTIPLY))
+                goto out;
+              needs_blend = true;
+              break;
+
+            case DSPD_NONE:
+              if (D_FLAGS_IS_SET (state->blittingflags, DSBLIT_SRC_PREMULTIPLY))
+                /* We can only do source premultiplication if the
+                   src func != DSBF_SRCALPHA.
+                   We only have one premultiplication unit, and need it for
+                   DSBF_SRCALPHA already. */
+                goto out;
+              /* We can do src func = DSBF_SRCALPHA as long as the destination
+                 does not have an alpha channel.
+
+                 This is because the hardware cannot calculate the correct alpha
+                 for the destination but can calculate the correct RGB values.
+                 This is supported to accelerate the blit-blend performance test
+                 in df_dok for the standard 16bit destination. */
+              if (DFB_PIXELFORMAT_HAS_ALPHA (state->destination->config.format))
+                goto out;
+              needs_blend = true;
+              break;
+
+            default:
+              if (D_FLAGS_IS_SET (state->blittingflags, DSBLIT_DST_PREMULTIPLY))
+                goto out;
+              break;
+            }
+        }
+      else /* not a blend operation */
+        {
+          if (D_FLAGS_IS_SET (state->blittingflags, DSBLIT_SRC_PREMULTIPLY))
+            {
+              /* 1) we cannot XOR and premultiply by src alpha at the same time
+                 2) we cannot DST colourkey and SRC premultiply at the same time
+                 3) we cannot DST and SRC premultiply at the same time.
+
+                 XOR needs the ROP unit and premultiply the blend unit - they
+                 can not be used simultaneously.
+                 We do the SRC_PREMULTIPLY using a blend with 0.0.0.0 coming
+                 from S1 color fill, so we can not read the destination.
+                 SRC and DST premultiply are exclusive - we can only premultiply
+                 on S2, which can be either SRC or DST, depending on
+                 BLIT_ACK_SWAP_FG_BG. */
+              if (D_FLAGS_IS_SET (state->blittingflags,
+                                  (DSBLIT_XOR | DSBLIT_DST_COLORKEY
+                                   | DSBLIT_DST_PREMULTIPLY
+                                   | DSBLIT_SOURCE2)))
+                goto out;
+
+              needs_blend = true;
+            }
+        }
+
+      if (D_FLAGS_IS_SET (state->blittingflags, DSBLIT_COLORIZE)
+          || src_premultcolor)
+        {
+          /* this works only if formats are equal or if we don't convert
+             YCbCr <-> RGB, as we need the input matrix on the BDisp to do
+             premultcolor / colorize. */
+          if (!src_is_ycbcr && dst_is_ycbcr)
+            {
+              /* We can still do this if the target is YUV, by doing the
+                 colourspace conversion in the output matrix, but only if the
+                 ALU is not being used to blend or xor source and destination.
+                 That needs the conversion to be done in the input matrix, but
+                 we want to use that matrix to do the RGB modulation, we can't
+                 do both! */
+              if (D_FLAGS_IS_SET (state->blittingflags, DSBLIT_XOR)
+                  || needs_blend)
+                goto out;
+            }
+        }
+
+
+      state->accel |= STGFX2_VALID_BLITTINGFUNCTIONS;
+    }
+
+  return;
+
+out:
+  _dump_check_state_failed (__FUNCTION__, state, accel);
+#if 0
+  if (!(DFB_BLITTING_FUNCTION (accel)
+        && state->src_blend == DSBF_ZERO
+        && state->dst_blend == DSBF_SRCALPHA))
+    raise (SIGINT);
+#endif
+
+  return;
+}
+
+
+
+/******** SetState() related things -> helpers ******************************/
+bool
+_bdisp_state_set_buffer_type (const STGFX2DeviceData * const stdev,
+                              u32                    * const ty,
+                              DFBSurfacePixelFormat   format,
+                              u16                     pitch)
+{
+  const struct _bdisp_pixelformat_table * const dspf_to_bdisp
+    = stdev->features.dfb_dspf_to_bdisp;
+
+  D_ASSERT (format != DSPF_UNKNOWN);
+
+  D_DEBUG_AT (BDisp_State, "  -> %s format: %s pitch: %hu\n", __FUNCTION__,
+              dfb_pixelformat_name (format), pitch);
+
+  if (!format)
+    return 0;
+
+  *ty = dspf_to_bdisp[DFB_PIXELFORMAT_INDEX (format)].bdisp_type;
+  switch (*ty)
+    {
+    case -1:
+      D_ASSERT ("BDisp/BLT: _bdisp_state_set_buffer_type() unsupported pixelformat\n" == NULL);
+      return false;
+
+    default:
+      *ty |= pitch;
+      break;
+    }
+
+  return true;
+}
+
+static void
+_bdisp_state_set_key_color (DFBSurfacePixelFormat  format,
+                            u32                    colorkey,
+                            u32                   * const reg)
+{
+  unsigned long tmp;
+
+  D_DEBUG_AT (BDisp_State, "  -> %s colorkey: %.8x\n", __FUNCTION__,
+              colorkey);
+
+  /* convert colorkey into a 32bit RGB as required by the hardware. We do
+     this by padding the missing LSBs with the MSBs to match the hardware
+     expansion mode we use for subbyte color formats. */
+  switch (format)
+  {
+    case DSPF_RGB16:
+    case DSPF_ARGB8565:
+      tmp = RGB16_TO_RGB32 (colorkey) | ((colorkey & 0xe000) << 3)
+                                      | ((colorkey & 0x0600) >> 1)
+                                      | ((colorkey & 0x001c) >> 2);
+      break;
+
+    case DSPF_ARGB1555:
+      tmp = ARGB1555_TO_RGB32 (colorkey) | ((colorkey & 0x7000) << 4)
+                                         | ((colorkey & 0x0380) << 1)
+                                         | ((colorkey & 0x001c) >> 2);
+      break;
+
+    case DSPF_ARGB4444:
+      /* ARGB4444_TO_RGB32() already color expands for us */
+      tmp = ARGB4444_TO_RGB32 (colorkey);
+      break;
+
+    case DSPF_RGB24:
+    case DSPF_RGB32:
+    case DSPF_ARGB:
+    case DSPF_A8:
+    case DSPF_YUY2:
+    case DSPF_UYVY:
+    case DSPF_LUT8:
+    case DSPF_ALUT44:
+    case DSPF_A1:
+    case DSPF_LUT2:
+    case DSPF_AVYU:
+    case DSPF_VYU:
+    case DSPF_NV12:
+    case DSPF_NV16:
+    case DSPF_I420:
+    case DSPF_YV12:
+    case DSPF_YV16:
+    case DSPF_YUV444P:
+      tmp = colorkey & 0x00ffffff;
+      break;
+
+    default:
+      D_ASSERT ("BDisp/BLT: bdisp_aq_SetKeyColor(): unknown pixelformat?!\n" == NULL);
+      tmp = colorkey & 0x00ffffff;
+      break;
+  }
+
+  /* preserve the alpha in the destination as it may be significant for 1bit
+     alpha modes. */
+  *reg = (*reg & 0xff000000) | tmp;
+
+  if (colorkey != *reg)
+    D_DEBUG_AT (BDisp_State, "    -> %.8x\n", *reg);
+}
+
+static void
+bdisp_state_validate_PALETTE_DRAW (const STGFX2DriverData * const stdrv,
+                                   STGFX2DeviceData       * const stdev,
+                                   const CardState        * const state)
+{
+  D_DEBUG_AT (BDisp_State, "%s\n", __FUNCTION__);
+
+  if (state->dst.buffer->format == DSPF_RGB32)
+    {
+      /* need a palette to make RGB32 usable */
+      stdev->drawstate.ConfigGeneral.BLT_CIC |= CIC_NODE_CLUT;
+      stdev->drawstate.ConfigGeneral.BLT_INS |= BLIT_INS_ENABLE_CLUT;
+      /* use a palette to 'correct' all x in xRGB32 to 0xff */
+      stdev->drawstate.ConfigClut.BLT_CCO = BLIT_CCO_CLUT_CORRECT;
+      /* palette works on source 1, as we read from there */
+      stdev->drawstate.ConfigClut.BLT_CCO |= BLIT_CCO_CLUT_NS2_S1_ON_S1;
+      stdev->drawstate.ConfigClut.BLT_CCO |= BLIT_CCO_CLUT_UPDATE_EN;
+      stdev->drawstate.ConfigClut.BLT_CML = stdev->clut_phys[SG2C_ONEALPHA_RGB];
+    }
+  else
+    {
+      stdev->drawstate.ConfigGeneral.BLT_CIC &= ~CIC_NODE_CLUT;
+      stdev->drawstate.ConfigGeneral.BLT_INS &= ~BLIT_INS_ENABLE_CLUT;
+    }
+
+  /* done */
+  BDISP_STATE_VALIDATED (PALETTE_DRAW);
+}
+
+/*********************************************************************/
+/* Store the destination surface state in the device state structure */
+/*********************************************************************/
+static void
+bdisp_state_validate_DESTINATION (const STGFX2DriverData * const stdrv,
+                                  STGFX2DeviceData       * const stdev,
+                                  const CardState        * const state)
+{
+  D_DEBUG_AT (BDisp_State, "%s phys+offset: %.8lx + %.8lx = %.8lx\n",
+              __FUNCTION__, state->dst.phys - state->dst.offset,
+              state->dst.offset, state->dst.phys);
+
+  _bdisp_state_set_buffer_type (stdev, &stdev->ConfigTarget.BLT_TTY,
+                                state->dst.buffer->format, state->dst.pitch);
+  stdev->ConfigTarget.BLT_TBA = state->dst.phys;
+
+  stdev->all_states.extra_blt_ins = 0;
+  stdev->all_states.extra_blt_cic = 0;
+  if (state->dst.buffer->format == DSPF_RGB32)
+    {
+      stdev->all_states.extra_blt_ins = BLIT_INS_ENABLE_PLANEMASK;
+      stdev->all_states.extra_blt_cic = CIC_NODE_FILTERS;
+    }
+
+  /* need to invalidate the source flag, which will cause S1 to be updated
+     correctly */
+  BDISP_STATE_INVALIDATE (SOURCE_SRC1_MODE);
+  BDISP_STATE_INVALIDATE (ROTATION); /* configure copy direction */
+  BDISP_STATE_INVALIDATE (INPUTMATRIX);
+  BDISP_STATE_INVALIDATE (MATRIXCONVERSIONS);
+
+  /* done */
+  BDISP_STATE_VALIDATED (DESTINATION);
+}
+
+#ifdef STGFX2_SUPPORT_HW_CLIPPING
+static bool
+bdisp_state_validate_CLIP (const STGFX2DriverData * const stdrv,
+                           STGFX2DeviceData       * const stdev,
+                           const CardState        * const state)
+{
+  D_DEBUG_AT (BDisp_State, "%s %d,%d - %dx%d\n",
+              __FUNCTION__, DFB_REGION_VALS (&state->clip));
+
+  stdev->ConfigClip.BLT_CWO = (0 << 31) | (state->clip.y1 << 16) | state->clip.x1;
+  stdev->ConfigClip.BLT_CWS = (state->clip.y2 << 16) | state->clip.x2;
+
+  /* done */
+  BDISP_STATE_VALIDATED (CLIP);
+
+  return true;
+}
+#endif
+
+/**************************************************************/
+/* Set the source surface state in the device state structure */
+/**************************************************************/
+static void
+bdisp_state_validate_PALETTE_BLIT (const STGFX2DriverData * const stdrv,
+                                   STGFX2DeviceData       * const stdev,
+                                   const CardState        * const state)
+{
+  D_DEBUG_AT (BDisp_State, "%s\n", __FUNCTION__);
+
+  /* for blitting op */
+  switch (state->source->config.format)
+    {
+    case DSPF_LUT2:
+    case DSPF_LUT8:
+    case DSPF_ALUT44:
+      stdev->palette = state->source->palette;
+      stdev->palette_type = SG2C_NORMAL;
+      break;
+
+    default:
+      stdev->palette = NULL;
+      stdev->palette_type = SG2C_NORMAL;
+      break;
+    }
+
+  /* done */
+  BDISP_STATE_VALIDATED (PALETTE_BLIT);
+}
+
+static void
+bdisp_state_validate_SOURCE_SRC1_MODE (const STGFX2DriverData * const stdrv,
+                                       STGFX2DeviceData       * const stdev,
+                                       const CardState        * const state,
+                                       DFBAccelerationMask     accel)
+{
+  D_DEBUG_AT (BDisp_State, "%s\n", __FUNCTION__);
+
+  stdev->ConfigGeneral.BLT_CIC |= CIC_NODE_SOURCE1;
+  stdev->ConfigGeneral.BLT_INS &= ~BLIT_INS_SRC1_MODE_MASK;
+
+  switch (state->source->config.format)
+    {
+    case DSPF_I420:
+      stdev->ConfigGeneral.BLT_INS |= BLIT_INS_SRC1_MODE_MEMORY;
+      stdev->ConfigSource1.BLT_S1BA = (stdev->ConfigSource2.BLT_S2BA
+                                       + ((state->src.pitch
+                                           / stdev->srcFactorH)
+                                          * (state->source->config.size.h
+                                             / stdev->srcFactorV))
+                                      );
+      stdev->ConfigSource1.BLT_S1TY = stdev->ConfigSource2.BLT_S2TY;
+      break;
+
+    case DSPF_YV12:
+      /* fall through */
+    case DSPF_YV16:
+      stdev->ConfigGeneral.BLT_INS |= BLIT_INS_SRC1_MODE_MEMORY;
+      stdev->ConfigSource1.BLT_S1BA = (stdev->ConfigSource2.BLT_S2BA
+                                       - ((state->src.pitch
+                                           / stdev->srcFactorH)
+                                          * (state->source->config.size.h
+                                             / stdev->srcFactorV))
+                                      );
+      stdev->ConfigSource1.BLT_S1TY = stdev->ConfigSource2.BLT_S2TY;
+      break;
+
+    case DSPF_YUV444P:
+      stdev->ConfigGeneral.BLT_INS |= BLIT_INS_SRC1_MODE_MEMORY;
+      stdev->ConfigSource1.BLT_S1BA = (stdev->ConfigSource2.BLT_S2BA
+                                       + (state->src.pitch
+                                          * state->source->config.size.h)
+                                      );
+      stdev->ConfigSource1.BLT_S1TY = stdev->ConfigSource2.BLT_S2TY;
+      break;
+
+    case DSPF_NV12:
+    case DSPF_NV16:
+    default:
+      /* for the formats that don't need S1 (BLIT_INS_SRC1_MODE_DISABLED) we
+         obviously still need to set correct data into ConfigSource1 as it might
+         get enabled due to some blitting flags, e.g. blend. */
+      if (!D_FLAGS_IS_SET (state->blittingflags, DSBLIT_SOURCE2)
+          && !D_FLAGS_IS_SET (accel, DFXL_BLIT2))
+        {
+          stdev->ConfigGeneral.BLT_INS |= (BLIT_INS_SRC1_MODE_DISABLED
+                                           | stdev->blitstate.blt_ins_src1_mode);
+          stdev->ConfigSource1.BLT_S1BA = stdev->ConfigTarget.BLT_TBA;
+          stdev->ConfigSource1.BLT_S1TY = (stdev->ConfigTarget.BLT_TTY
+                                           | BLIT_TY_COLOR_EXPAND_MSB);
+        }
+      else
+        {
+          D_ASSERT ((stdev->blitstate.blt_ins_src1_mode == BLIT_INS_SRC1_MODE_MEMORY)
+                    || (stdev->blitstate.blt_ins_src1_mode == BLIT_INS_SRC1_MODE_DISABLED));
+
+          stdev->ConfigGeneral.BLT_INS |= BLIT_INS_SRC1_MODE_MEMORY;
+          stdev->ConfigSource1.BLT_S1BA = state->src2.phys;
+          _bdisp_state_set_buffer_type (stdev, &stdev->ConfigSource1.BLT_S1TY,
+                                        state->src2.buffer->format,
+                                        state->src2.pitch);
+          stdev->ConfigSource1.BLT_S1TY |= BLIT_TY_COLOR_EXPAND_MSB;
+        }
+      break;
+    }
+
+  /* done */
+  BDISP_STATE_VALIDATED (SOURCE_SRC1_MODE);
+}
+
+static void
+bdisp_state_validate_SOURCE (const STGFX2DriverData * const stdrv,
+                             STGFX2DeviceData       * const stdev,
+                             const CardState        * const state)
+{
+  D_DEBUG_AT (BDisp_State, "%s phys+offset: %.8lx + %.8lx = %.8lx\n",
+              __FUNCTION__, state->src.phys - state->src.offset,
+              state->src.offset, state->src.phys);
+
+  D_ASSERT (state->source != NULL);
+  stdev->source_w = DFB_FIXED_POINT_VAL (state->source->config.size.w);
+  stdev->source_h = DFB_FIXED_POINT_VAL (state->source->config.size.h);
+
+  stdev->ConfigGeneral.BLT_CIC &= ~(CIC_NODE_SOURCE2
+                                    | CIC_NODE_SOURCE3);
+  stdev->ConfigGeneral.BLT_INS &= ~(BLIT_INS_SRC2_MODE_MASK
+                                    | BLIT_INS_SRC3_MODE_MASK);
+  /* previously, NV12 and NV16 did not have CIC_NODE_SOURCE1 set. As we don't
+     allow any blending involving these two formats that should not have
+     mattered, but setting it shouldn't do any harm either. */
+  stdev->ConfigGeneral.BLT_CIC |= CIC_NODE_SOURCE2;
+  stdev->ConfigGeneral.BLT_INS |= BLIT_INS_SRC2_MODE_MEMORY;
+
+  stdev->srcFactorH = stdev->srcFactorV = 1;
+
+  switch (state->source->config.format)
+    {
+    case DSPF_I420:
+      stdev->srcFactorH = stdev->srcFactorV = 2;
+      stdev->ConfigGeneral.BLT_CIC |= CIC_NODE_SOURCE3;
+      stdev->ConfigGeneral.BLT_INS |= BLIT_INS_SRC3_MODE_MEMORY;
+
+      stdev->ConfigSource3.BLT_S3BA = state->src.phys;
+      stdev->ConfigSource2.BLT_S2BA = (stdev->ConfigSource3.BLT_S3BA
+                                       + (state->src.pitch
+                                          * state->source->config.size.h));
+
+      _bdisp_state_set_buffer_type (stdev, &stdev->ConfigSource3.BLT_S3TY,
+                                    state->src.buffer->format,
+                                    state->src.pitch);
+      stdev->ConfigSource3.BLT_S3TY |= BLIT_TY_COLOR_EXPAND_MSB;
+      stdev->ConfigSource2.BLT_S2TY
+        = ((stdev->ConfigSource3.BLT_S3TY & ~BLIT_TY_PIXMAP_PITCH_MASK)
+           | (state->src.pitch / stdev->srcFactorH));
+      break;
+
+    case DSPF_YV12:
+      stdev->srcFactorV = 2;
+      /* fall through */
+    case DSPF_YV16:
+      stdev->srcFactorH = 2;
+      stdev->ConfigGeneral.BLT_CIC |= CIC_NODE_SOURCE3;
+      stdev->ConfigGeneral.BLT_INS |= BLIT_INS_SRC3_MODE_MEMORY;
+
+      stdev->ConfigSource3.BLT_S3BA = state->src.phys;
+      stdev->ConfigSource2.BLT_S2BA = (stdev->ConfigSource3.BLT_S3BA
+                                       + (state->src.pitch
+                                          * state->source->config.size.h)
+                                       + ((state->src.pitch
+                                           / stdev->srcFactorH)
+                                          * (state->source->config.size.h
+                                             / stdev->srcFactorV))
+                                      );
+
+      _bdisp_state_set_buffer_type (stdev, &stdev->ConfigSource3.BLT_S3TY,
+                                    state->src.buffer->format,
+                                    state->src.pitch);
+      stdev->ConfigSource3.BLT_S3TY |= BLIT_TY_COLOR_EXPAND_MSB;
+      stdev->ConfigSource2.BLT_S2TY
+        = ((stdev->ConfigSource3.BLT_S3TY & ~BLIT_TY_PIXMAP_PITCH_MASK)
+           | (state->src.pitch / stdev->srcFactorH));
+      break;
+
+    case DSPF_YUV444P:
+      stdev->ConfigGeneral.BLT_CIC |= CIC_NODE_SOURCE3;
+      stdev->ConfigGeneral.BLT_INS |= BLIT_INS_SRC3_MODE_MEMORY;
+
+      stdev->ConfigSource3.BLT_S3BA = state->src.phys;
+      stdev->ConfigSource2.BLT_S2BA = (stdev->ConfigSource3.BLT_S3BA
+                                       + (state->src.pitch
+                                          * state->source->config.size.h));
+
+      _bdisp_state_set_buffer_type (stdev, &stdev->ConfigSource3.BLT_S3TY,
+                                    state->src.buffer->format,
+                                    state->src.pitch);
+      stdev->ConfigSource3.BLT_S3TY |= BLIT_TY_COLOR_EXPAND_MSB;
+      stdev->ConfigSource2.BLT_S2TY
+        = stdev->ConfigSource3.BLT_S3TY;
+      break;
+
+    case DSPF_NV12:
+      stdev->srcFactorV = 2;
+      /* fall through */
+    case DSPF_NV16:
+      stdev->srcFactorH = 2;
+      stdev->ConfigGeneral.BLT_CIC |= CIC_NODE_SOURCE3;
+      stdev->ConfigGeneral.BLT_INS |= BLIT_INS_SRC3_MODE_MEMORY;
+
+      stdev->ConfigSource3.BLT_S3BA = state->src.phys;
+      stdev->ConfigSource2.BLT_S2BA = (stdev->ConfigSource3.BLT_S3BA
+                                       + (state->src.pitch
+                                          * state->source->config.size.h));
+
+      _bdisp_state_set_buffer_type (stdev, &stdev->ConfigSource3.BLT_S3TY,
+                                    state->src.buffer->format,
+                                    state->src.pitch);
+      stdev->ConfigSource3.BLT_S3TY |= BLIT_TY_COLOR_EXPAND_MSB;
+      stdev->ConfigSource2.BLT_S2TY = stdev->ConfigSource3.BLT_S3TY;
+      break;
+
+    default:
+      stdev->ConfigGeneral.BLT_INS |= BLIT_INS_SRC3_MODE_DISABLED;
+
+      stdev->ConfigSource3.BLT_S3BA = 0xdeadba5e;
+      stdev->ConfigSource2.BLT_S2BA = state->src.phys;
+
+      stdev->ConfigSource3.BLT_S3TY = 0xf0011eef;
+      _bdisp_state_set_buffer_type (stdev, &stdev->ConfigSource2.BLT_S2TY,
+                                    state->src.buffer->format,
+                                    state->src.pitch);
+      stdev->ConfigSource2.BLT_S2TY |= BLIT_TY_COLOR_EXPAND_MSB;
+      break;
+    }
+
+  /* as we touch the source1 mode, make sure it stays correct. */
+  BDISP_STATE_INVALIDATE (SOURCE_SRC1_MODE);
+  BDISP_STATE_INVALIDATE (BLITTINGFLAGS);
+  BDISP_STATE_INVALIDATE (ROTATION); /* configure copy direction */
+  BDISP_STATE_INVALIDATE (INPUTMATRIX);
+  BDISP_STATE_INVALIDATE (MATRIXCONVERSIONS);
+
+  /* done */
+  BDISP_STATE_VALIDATED (SOURCE);
+}
+
+static void
+bdisp_state_validate_FILLCOLOR (const STGFX2DriverData * const stdrv,
+                                STGFX2DeviceData       * const stdev,
+                                const CardState        * const state)
+{
+  u32 alpha = state->color.a;
+  u32 red   = state->color.r;
+  u32 green = state->color.g;
+  u32 blue  = state->color.b;
+
+  D_DEBUG_AT (BDisp_State, "%s rgb %.2x%s%.2x%.2x%.2x%s\n",
+              __FUNCTION__,
+              alpha,
+              (state->drawingflags & DSDRAW_SRC_PREMULTIPLY) ? "*" : "",
+              red, green, blue,
+              (state->drawingflags & DSDRAW_BLEND) ? " (blend)" : "");
+
+  if (state->drawingflags & DSDRAW_SRC_PREMULTIPLY)
+    {
+      /* we do source alpha pre-multiplication now, rather in the hardware
+         so we can support it regardless of the blend mode. */
+      red   = (red   * (alpha + 1)) >> 8;
+      green = (green * (alpha + 1)) >> 8;
+      blue  = (blue  * (alpha + 1)) >> 8;
+    }
+
+  if (state->drawingflags & DSDRAW_BLEND)
+    {
+      switch (stdev->porter_duff_rule)
+        {
+        case DSPD_CLEAR:
+          /* Just fill with 0. Set the source format to the dest format to get
+             a fast fill. */
+          stdev->drawstate.color = 0;
+          switch (state->destination->config.format)
+            {
+            case DSPF_YUY2:
+            case DSPF_UYVY:
+            case DSPF_AVYU:
+            case DSPF_VYU:
+              /* full alpha ange doesn't matter here as it's 0 anyway */
+              stdev->drawstate.color_ty = BLIT_COLOR_FORM_ARGB8888;
+              break;
+
+            case DSPF_RGB32:
+              stdev->drawstate.color = PIXEL_ARGB (0xff, 0x00, 0x00, 0x00);
+              /* fall through */
+            default:
+              /* FIXME - unsetting big endian here means that further down
+                 when the function pointers are updated a clear to a big
+                 endian surface (BGRA8888) will end up in the slow path, as
+                 BLT_TTY and color_ty will not be identical anymore. That's
+                 not an issue right now, as BGRA8888 is not a supported
+                 DirectFB format at the moment, and it is the only non YUV
+                 format with the big endian flag set. */
+              stdev->drawstate.color_ty =
+                (bdisp_ty_get_format_from_ty (stdev->ConfigTarget.BLT_TTY)
+                 & ~BLIT_TY_BIG_ENDIAN);
+              break;
+            }
+          break;
+
+        case DSPD_SRC: /* FIXME: why not the destination format??? */
+          if (unlikely (state->destination->config.format == DSPF_RGB32))
+            alpha = 0xff;
+        case DSPD_DST_OVER:
+        case DSPD_SRC_OVER:
+        case DSPD_NONE:
+          /* for blended fills we use ARGB8888, to get full alpha precision in the
+             blend, the hardware does color conversion. */
+          stdev->drawstate.color = PIXEL_ARGB (alpha, red, green, blue);
+          stdev->drawstate.color_ty = (BLIT_COLOR_FORM_ARGB8888
+                                       | BLIT_TY_FULL_ALPHA_RANGE);
+          break;
+
+        case DSPD_DST:
+          /* This leaves the destination as is, i.e. a nop, because we do not
+             support destination pre-multiplication. */
+        default:
+          /* not supported */
+          break;
+        }
+    }
+  else
+    {
+      stdev->drawstate.color_ty
+        = bdisp_ty_get_format_from_ty (stdev->ConfigTarget.BLT_TTY);
+
+      switch (state->destination->config.format)
+        {
+        case DSPF_ARGB1555:
+          stdev->drawstate.color = PIXEL_ARGB1555 (alpha, red, green, blue);
+          break;
+
+        case DSPF_ARGB4444:
+          stdev->drawstate.color = PIXEL_ARGB4444 (alpha, red, green, blue);
+          break;
+
+        case DSPF_RGB16:
+          stdev->drawstate.color = PIXEL_RGB16 (red, green, blue);
+          break;
+
+        case DSPF_RGB24:
+          stdev->drawstate.color = PIXEL_RGB32 (red, green, blue);
+          break;
+
+        case DSPF_RGB32:
+          stdev->drawstate.color = PIXEL_ARGB (0xff, red, green, blue);
+          break;
+
+        case DSPF_ARGB8565:
+          stdev->drawstate.color = PIXEL_ARGB8565 (alpha, red, green, blue);
+          break;
+
+        /* For 422R we let the hardware do the conversion, as direct fast fill
+           in 422R has problems (probably due to two pixels being mixed up in
+           a 32bit word). The other reason we are using the hardware is that
+           this way the conversion RGB->YCbCr will be consistent (DirectFB
+           has no way to specify the color space). */
+        case DSPF_YUY2:
+        case DSPF_UYVY:
+        case DSPF_AVYU:
+        case DSPF_VYU:
+          /* let the blitter do the color conversion (on the slow path) */
+          stdev->drawstate.color_ty = (BLIT_COLOR_FORM_ARGB8888
+                                       | BLIT_TY_FULL_ALPHA_RANGE);
+          /* fall through */
+        case DSPF_ARGB:
+          stdev->drawstate.color = PIXEL_ARGB (alpha, red, green, blue);
+          break;
+
+        case DSPF_LUT2:
+        case DSPF_LUT8:
+          stdev->drawstate.color = state->color_index;
+          break;
+
+        case DSPF_ALUT44:
+          stdev->drawstate.color = (alpha & 0xf0) | (state->color_index & 0x0f);
+          break;
+
+        case DSPF_A8:
+          stdev->drawstate.color = alpha;
+          break;
+
+        default:
+          D_ERROR ("stgfx2/state: Unexpected color format %x\n",
+                   state->destination->config.format);
+          break;
+        }
+    }
+
+
+  stdev->drawstate.ConfigGeneral.BLT_CIC &= ~CIC_NODE_IVMX;
+  stdev->drawstate.ConfigGeneral.BLT_INS &= ~BLIT_INS_ENABLE_IVMX;
+  if (BLIT_TY_COLOR_FORM_IS_YUV (stdev->ConfigTarget.BLT_TTY)
+      && !BLIT_TY_COLOR_FORM_IS_YUV (stdev->drawstate.color_ty))
+    {
+      D_DEBUG ("%s(): Input RGB->YUV\n", __FUNCTION__);
+
+      stdev->drawstate.ConfigGeneral.BLT_CIC |= CIC_NODE_IVMX;
+      stdev->drawstate.ConfigGeneral.BLT_INS |= BLIT_INS_ENABLE_IVMX;
+    }
+
+  /* done */
+  BDISP_STATE_VALIDATED (FILLCOLOR);
+}
+
+static void
+bdisp_state_validate_DRAWINGFLAGS (STGFX2DriverData * const stdrv,
+                                   STGFX2DeviceData * const stdev,
+                                   const CardState  * const state)
+{
+  static const u32 global_alpha = 128;
+  u32              blt_ins;
+  u32              blt_ack;
+
+  D_DEBUG_AT (BDisp_State, "%s drawflags %.2x\n",
+              __FUNCTION__, state->drawingflags);
+
+  blt_ins = stdev->drawstate.ConfigGeneral.BLT_INS;
+  blt_ack = stdev->drawstate.ConfigGeneral.BLT_ACK;
+
+  blt_ins &= ~(BLIT_INS_SRC1_MODE_MASK | BLIT_INS_SRC2_MODE_MASK);
+  blt_ack &= ~BLIT_ACK_SWAP_FG_BG;
+  blt_ack &= ~(BLIT_ACK_MODE_MASK
+               | BLIT_ACK_GLOBAL_ALPHA_MASK | BLIT_ACK_ROP_MASK
+               | BLIT_ACK_CKEY_MASK | BLIT_ACK_COLORKEYING_MASK
+              );
+
+  if (state->drawingflags & DSDRAW_BLEND)
+    {
+      switch (stdev->porter_duff_rule)
+        {
+        case DSPD_DST:
+          return;
+
+        case DSPD_DST_OVER:
+          /* src func = 1-dst alpha, dest func = 1.0   (DSPD_DST_OVER) */
+          blt_ack |= BLIT_ACK_SWAP_FG_BG;
+          /* fall through */
+        case DSPD_SRC_OVER:
+          /* src func = 1.0  , dest func = 1-src alpha (DSPD_SRC_OVER) */
+          blt_ack |= ((global_alpha << BLIT_ACK_GLOBAL_ALPHA_SHIFT)
+                      | BLIT_ACK_BLEND_SRC2_PREMULT);
+          blt_ins |= BLIT_INS_SRC1_MODE_MEMORY | BLIT_INS_SRC2_MODE_COLOR_FILL;
+          break;
+        case DSPD_NONE:
+          /* src func = src alpha, dest func = 1-src alpha (DSPD_NONE)
+             We can only support this when the destination format has no alpha
+             channel. This is because the hardware always calculates the
+             destination alpha as Asrc + Adst*(1-Asrc) but we would require
+             Asrc*Asrc + Adst*(1-Asrc). */
+          D_DEBUG ("%s(): setting src as NOT pre-multiplied\n", __FUNCTION__);
+          blt_ack |= ((global_alpha << BLIT_ACK_GLOBAL_ALPHA_SHIFT)
+                      | BLIT_ACK_BLEND_SRC2_N_PREMULT);
+          blt_ins |= BLIT_INS_SRC1_MODE_MEMORY | BLIT_INS_SRC2_MODE_COLOR_FILL;
+          break;
+
+        case DSPD_CLEAR:
+          /* for clear, we would normally just use a direct (fast) fill, but
+             we can't for YUV formats as the blitter needs to convert ARGB
+             0x00000000 into YUV space */
+          if (bdisp_ty_formats_identical (stdev->drawstate.color_ty,
+                                          stdev->ConfigTarget.BLT_TTY))
+            {
+              blt_ins |= BLIT_INS_SRC1_MODE_DIRECT_FILL;
+              if (state->destination->config.format == DSPF_RGB32)
+                {
+                  stdev->drawstate.ConfigGeneral.BLT_CIC &= ~CIC_NODE_CLUT;
+                  blt_ins &= ~BLIT_INS_ENABLE_CLUT;
+                }
+              else
+                {
+                  D_ASSUME ((blt_ins & BLIT_INS_ENABLE_CLUT) == 0);
+                  D_ASSUME ((stdev->drawstate.ConfigGeneral.BLT_CIC
+                             & CIC_NODE_CLUT) == 0);
+                }
+            }
+          else
+            {
+              /* let the blitter do the color conversion (on the slow path) */
+              blt_ack |= BLIT_ACK_BYPASSSOURCE2;
+              blt_ins |= BLIT_INS_SRC1_MODE_DISABLED | BLIT_INS_SRC2_MODE_COLOR_FILL;
+            }
+          break;
+
+        case DSPD_SRC:
+          /* color is in ARGB, see FIXME above */
+          if (bdisp_ty_formats_identical (stdev->drawstate.color_ty,
+                                          stdev->ConfigTarget.BLT_TTY))
+            {
+              blt_ins |= BLIT_INS_SRC1_MODE_DIRECT_FILL;
+              if (state->destination->config.format == DSPF_RGB32)
+                {
+                  stdev->drawstate.ConfigGeneral.BLT_CIC &= ~CIC_NODE_CLUT;
+                  blt_ins &= ~BLIT_INS_ENABLE_CLUT;
+                }
+              else
+                {
+                  D_ASSUME ((blt_ins & BLIT_INS_ENABLE_CLUT) == 0);
+                  D_ASSUME ((stdev->drawstate.ConfigGeneral.BLT_CIC
+                             & CIC_NODE_CLUT) == 0);
+                }
+            }
+          else
+            {
+              /* need the slow path for a blend */
+              blt_ack |= BLIT_ACK_BYPASSSOURCE2;
+              blt_ins |= BLIT_INS_SRC1_MODE_DISABLED | BLIT_INS_SRC2_MODE_COLOR_FILL;
+            }
+          break;
+
+        default:
+          D_WARN ("%s: unexpected Porter/Duff rule: %d\n", __FUNCTION__,
+                  stdev->porter_duff_rule);
+          return;
+        }
+    }
+  else if (state->drawingflags & DSDRAW_XOR)
+    {
+      D_DEBUG ("%s(): XOR\n", __FUNCTION__);
+      blt_ack |= (0
+                  | BLIT_ACK_ROP
+                  | BLIT_ACK_ROP_XOR
+                 );
+      blt_ins |= BLIT_INS_SRC1_MODE_MEMORY | BLIT_INS_SRC2_MODE_COLOR_FILL;
+    }
+  else if (!(state->drawingflags & DSDRAW_DST_COLORKEY))
+    {
+      /* fast path */
+      blt_ack |= BLIT_ACK_BYPASSSOURCE2;
+      if (bdisp_ty_formats_identical (stdev->drawstate.color_ty,
+                                      stdev->ConfigTarget.BLT_TTY)
+          && !(blt_ins & BLIT_INS_ENABLE_CLUT))
+
+        {
+          D_DEBUG ("%s(): fast path\n", __FUNCTION__);
+          blt_ins |= BLIT_INS_SRC1_MODE_DIRECT_FILL;
+        }
+      else
+        {
+          blt_ack |= BLIT_ACK_BYPASSSOURCE2;
+          blt_ins |= BLIT_INS_SRC1_MODE_DISABLED | BLIT_INS_SRC2_MODE_COLOR_FILL;
+        }
+    }
+
+  if (state->drawingflags & DSDRAW_DST_COLORKEY)
+    {
+      stdev->drawstate.ConfigGeneral.BLT_CIC |= CIC_NODE_COLORKEY;
+      blt_ins |= BLIT_INS_ENABLE_COLORKEY;
+
+      blt_ack |= BLIT_ACK_CKEY_RGB_ENABLE;
+      if (blt_ins & BLIT_INS_SRC1_MODE_MEMORY)
+        blt_ack |= BLIT_ACK_COLORKEYING_DEST_KEY_ZEROS_SRC_ALPHA;
+      else
+        blt_ack |= (0
+                    | BLIT_ACK_ROP
+                    | BLIT_ACK_ROP_COPY
+                    | BLIT_ACK_COLORKEYING_DEST
+                   );
+
+      /* clear potential BLIT_INS_SRC1_MODE_DIRECT_FILL */
+      blt_ins &= ~BLIT_INS_SRC1_MODE_MASK;
+      blt_ins |= BLIT_INS_SRC1_MODE_MEMORY;
+    }
+  else
+    {
+      stdev->drawstate.ConfigGeneral.BLT_CIC &= ~CIC_NODE_COLORKEY;
+      blt_ins &= ~BLIT_INS_ENABLE_COLORKEY;
+    }
+
+  stdev->drawstate.ConfigGeneral.BLT_INS = blt_ins;
+  stdev->drawstate.ConfigGeneral.BLT_ACK = blt_ack;
+
+  /* done */
+  BDISP_STATE_VALIDATED (DRAWINGFLAGS);
+}
+
+#define CLUT_SIZE (256 * sizeof (u32))
+static void
+bdisp_state_validate_BLITCOLOR (STGFX2DriverData * const stdrv,
+                                STGFX2DeviceData * const stdev,
+                                const CardState  * const state)
+{
+  D_DEBUG_AT (BDisp_State, "%s rgb %.2x%.2x%.2x%.2x\n",
+              __FUNCTION__, state->color.a, state->color.r, state->color.g,
+              state->color.b);
+
+  if (D_FLAGS_IS_SET (state->blittingflags, (DSBLIT_BLEND_COLORALPHA
+                                             | DSBLIT_BLEND_ALPHACHANNEL)))
+    {
+      u32         palette1[256];
+      u32        *palette_pass1 = palette1;
+      Stgfx2Clut  palette_type1 = SG2C_NORMAL;
+      int         i;
+      /* scale 0..255 to 0..128 (not 127!) */
+      u32 alpha = (state->color.a + 1) / 2;
+
+      switch (state->blittingflags & (DSBLIT_BLEND_COLORALPHA
+                                      | DSBLIT_BLEND_ALPHACHANNEL))
+        {
+        case DSBLIT_NOFX:
+        case DSBLIT_BLEND_ALPHACHANNEL:
+          break;
+
+        case DSBLIT_BLEND_COLORALPHA:
+          D_DEBUG_AT (BDisp_State,
+                      "  -> BLEND_COLORALPHA:  %.2x\n", state->color.a);
+          if (stdev->blitstate.isOptimisedModulation)
+            {
+              D_DEBUG_AT (BDisp_State, "    -> optimised using global \n");
+
+              if (DFB_PIXELFORMAT_HAS_ALPHA (state->source->config.format))
+                stdev->palette_type = SG2C_ONEALPHA_RGB;
+
+              stdev->ConfigGeneral.BLT_ACK &= ~BLIT_ACK_GLOBAL_ALPHA_MASK;
+              stdev->ConfigGeneral.BLT_ACK |= ((alpha & 0xff) << BLIT_ACK_GLOBAL_ALPHA_SHIFT);
+            }
+          else
+            {
+              /* replace alpha using clut */
+              D_DEBUG_AT (BDisp_State, "    -> slow (palette replacement)\n");
+
+              for (i = 0; i <= 0x80; ++i)
+                palette1[i] = PIXEL_ARGB (alpha, i, i, i);
+              for (; i < 256; ++i)
+                palette1[i] = PIXEL_ARGB (0, i, i, i);
+              palette_type1 = SG2C_COLORALPHA;
+            }
+          break;
+
+        case (DSBLIT_BLEND_ALPHACHANNEL | DSBLIT_BLEND_COLORALPHA):
+          D_DEBUG_AT (BDisp_State,
+                      "  -> BLEND_COLORALPHA | BLEND_ALPHACHANNEL:  %.2x\n",
+                      state->color.a);
+          if (stdev->blitstate.isOptimisedModulation)
+            {
+              D_DEBUG_AT (BDisp_State, "    -> optimised using global \n");
+
+              stdev->ConfigGeneral.BLT_ACK &= ~BLIT_ACK_GLOBAL_ALPHA_MASK;
+              stdev->ConfigGeneral.BLT_ACK |= ((alpha & 0xff) << BLIT_ACK_GLOBAL_ALPHA_SHIFT);
+            }
+          else
+            {
+              /* replace alpha using clut */
+              D_DEBUG_AT (BDisp_State, "    -> slow (palette replacement)\n");
+
+              for (i = 0; i <= 0x80; ++i)
+                palette1[i] = PIXEL_ARGB ((i * alpha / 0x80), i, i, i);
+              for (; i < 256; ++i)
+                palette1[i] = PIXEL_ARGB (0, i, i, i);
+              palette_type1 = SG2C_ALPHA_MUL_COLORALPHA;
+            }
+          break;
+        }
+
+      if (palette_type1 != SG2C_NORMAL)
+        {
+          u32         palette2[256];
+          u32        *palette_pass2 = palette2;
+          Stgfx2Clut  palette_type2 = SG2C_NORMAL;
+
+#if D_DEBUG_ENABLED
+          const char *
+          palette_to_string (Stgfx2Clut palette)
+          {
+            #define _CMP(p)     \
+              if (palette == p) \
+                return #p;
+
+            _CMP(SG2C_NORMAL);
+            _CMP(SG2C_COLORALPHA);
+            _CMP(SG2C_INVCOLORALPHA);
+            _CMP(SG2C_ALPHA_MUL_COLORALPHA);
+            _CMP(SG2C_INV_ALPHA_MUL_COLORALPHA);
+            _CMP(SG2C_ONEALPHA_RGB);
+            _CMP(SG2C_INVALPHA_ZERORGB);
+            _CMP(SG2C_ALPHA_ZERORGB);
+            _CMP(SG2C_ZEROALPHA_RGB);
+            _CMP(SG2C_ZEROALPHA_ZERORGB);
+            _CMP(SG2C_ONEALPHA_ZERORGB);
+            _CMP(SG2C_COUNT);
+
+            #undef _CMP
+
+            return "unknown";
+          }
+#endif
+
+          D_DEBUG_AT (BDisp_State, "    -> palette1: %s\n",
+                      palette_to_string (palette_type1));
+
+          if (stdev->porter_duff_rule == DSPD_DST_IN
+              || stdev->porter_duff_rule == DSPD_DST_OUT)
+            {
+              D_DEBUG_AT (BDisp_State,
+                          "  -> DSPD_DST_IN/OUT/ATOP: mod'ing palette(s)\n");
+
+              for (i = 0; i <= 0x80; ++i)
+                palette2[i] = (0x80 - (palette1[i] >> 24)) << 24;
+              memset (&palette2[i], 0x00, CLUT_SIZE - (i * sizeof (u32)));
+
+              if (stdev->porter_duff_rule == DSPD_DST_IN)
+                {
+                  D_DEBUG_AT (BDisp_State,
+                              "  -> DSPD_DST_IN: palette1 before: %s\n",
+                              palette_to_string (palette_type1));
+
+                  if (palette_type1 == SG2C_COLORALPHA)
+                    {
+                      palette_type1 = SG2C_INVCOLORALPHA;
+                      palette_type2 = SG2C_COLORALPHA;
+                    }
+                  else if (palette_type1 == SG2C_ALPHA_MUL_COLORALPHA)
+                    {
+                      palette_type1 = SG2C_INV_ALPHA_MUL_COLORALPHA;
+                      palette_type2 = SG2C_ALPHA_MUL_COLORALPHA;
+                    }
+
+                  palette_pass1 = palette2;
+                  palette_pass2 = palette1;
+
+                  D_DEBUG_AT (BDisp_State,
+                              "  -> DSPD_DST_IN: palettes after: %s/%s\n",
+                              palette_to_string (palette_type1),
+                              palette_to_string (palette_type2));
+                }
+              else if (stdev->porter_duff_rule == DSPD_DST_OUT)
+                {
+                  for (i = 0; i <= 0x80; ++i)
+                    palette1[i] &= 0xff000000;
+                  memset (&palette1[i], 0x00, CLUT_SIZE - (i * sizeof (u32)));
+
+                  D_DEBUG_AT (BDisp_State,
+                              "  -> DSPD_DST_OUT: palette1 before: %s\n",
+                              palette_to_string (palette_type1));
+
+                  if (palette_type1 == SG2C_COLORALPHA)
+                    palette_type2 = SG2C_INVCOLORALPHA;
+                  else if (palette_type1 == SG2C_ALPHA_MUL_COLORALPHA)
+                    palette_type2 = SG2C_INV_ALPHA_MUL_COLORALPHA;
+
+                  D_DEBUG_AT (BDisp_State,
+                              "  -> DSPD_DST_OUT: palettes after: %s/%s\n",
+                              palette_to_string (palette_type1),
+                              palette_to_string (palette_type2));
+                }
+            }
+
+          /* upload palette(s) into hardware. We must make sure they are not
+             used at the moment, which is why we have to wait until the
+             hardware is idle. */
+          _bdisp_aq_prepare_upload_palette_hw (stdrv, stdev);
+
+          memcpy (stdrv->clut_virt[palette_type1], palette_pass1, CLUT_SIZE);
+          stdev->palette_type = palette_type1;
+
+          if (palette_type2 != SG2C_NORMAL)
+            {
+              memcpy (stdrv->clut_virt[palette_type2], palette_pass2, CLUT_SIZE);
+              stdev->blitstate.extra_passes[0].palette_type = palette_type2;
+            }
+        }
+    }
+
+  /* done */
+  BDISP_STATE_VALIDATED (BLITCOLOR);
+}
+
+static void
+bdisp_state_validate_DST_COLORKEY (STGFX2DriverData * const stdrv,
+                                   STGFX2DeviceData * const stdev,
+                                   const CardState  * const state)
+{
+  D_DEBUG_AT (BDisp_State, "%s %.8x\n", __FUNCTION__, state->dst_colorkey);
+
+  _bdisp_state_set_key_color (state->destination->config.format,
+                              state->dst_colorkey, &stdev->all_states.dst_ckey);
+
+  if (D_FLAGS_IS_SET (state->blittingflags, DSBLIT_DST_COLORKEY))
+    {
+      stdev->ConfigColorkey.BLT_KEY1 = stdev->all_states.dst_ckey;
+      stdev->ConfigColorkey.BLT_KEY2 = stdev->all_states.dst_ckey;
+    }
+
+  /* done */
+  BDISP_STATE_VALIDATED (DST_COLORKEY);
+}
+
+static void
+bdisp_state_validate_SRC_COLORKEY (STGFX2DriverData * const stdrv,
+                                   STGFX2DeviceData * const stdev,
+                                   const CardState  * const state)
+{
+  D_DEBUG_AT (BDisp_State, "%s %.8x\n", __FUNCTION__, state->src_colorkey);
+
+  _bdisp_state_set_key_color (state->source->config.format,
+                              state->src_colorkey,
+                              &stdev->blitstate.src_ckey);
+
+  if (D_FLAGS_IS_SET (state->blittingflags, DSBLIT_SRC_COLORKEY))
+    {
+      stdev->ConfigColorkey.BLT_KEY1 = stdev->blitstate.src_ckey;
+      stdev->ConfigColorkey.BLT_KEY2 = stdev->blitstate.src_ckey;
+    }
+
+  /* done */
+  BDISP_STATE_VALIDATED (SRC_COLORKEY);
+}
+
+static void
+bdisp_state_validate_ROTATION (STGFX2DriverData    * const stdrv,
+                               STGFX2DeviceData    * const stdev,
+                               const CardState     * const state,
+                               GraphicsDeviceFuncs * const funcs)
+{
+  D_DEBUG_AT (BDisp_State, "%s\n", __FUNCTION__);
+
+  u32 blt_ins  = stdev->ConfigGeneral.BLT_INS;
+  u32 blt_tty  = bdisp_ty_sanitise_direction (stdev->ConfigTarget.BLT_TTY);
+  u32 blt_s1ty = bdisp_ty_sanitise_direction (stdev->ConfigSource1.BLT_S1TY);
+  u32 blt_s2ty = bdisp_ty_sanitise_direction (stdev->ConfigSource2.BLT_S2TY);
+
+  stdev->rotate = 0;
+
+  if (D_FLAGS_ARE_SET (state->blittingflags, (DSBLIT_FLIP_HORIZONTAL
+                                              | DSBLIT_FLIP_VERTICAL))
+      || D_FLAGS_IS_SET (state->blittingflags, DSBLIT_ROTATE180))
+    stdev->rotate = 180;
+  else if (D_FLAGS_IS_SET (state->blittingflags, DSBLIT_FLIP_VERTICAL))
+    stdev->rotate = 181;
+  else if (D_FLAGS_IS_SET (state->blittingflags, DSBLIT_FLIP_HORIZONTAL))
+    stdev->rotate = 182;
+  else if (D_FLAGS_IS_SET (state->blittingflags, DSBLIT_ROTATE90))
+    stdev->rotate = 90;
+  else if (D_FLAGS_IS_SET (state->blittingflags, DSBLIT_ROTATE270))
+    stdev->rotate = 270;
+  else if (D_FLAGS_IS_SET (state->render_options, DSRO_MATRIX))
+    stdev->rotate = bdisp_aq_convert_to_supported_rotation (NULL, 0, state->matrix);
+
+  D_DEBUG_AT (BDisp_State, "  -> %d\n", stdev->rotate);
+
+  switch (stdev->rotate)
+    {
+    case 90: /* rotate 90 counter clock wise */
+      blt_ins |= BLIT_INS_ENABLE_ROTATION;
+      /* read from top left to bottom right */
+      blt_s2ty |= (BLIT_TY_COPYDIR_TOPBOTTOM | BLIT_TY_COPYDIR_LEFTRIGHT);
+      /* write from bottom left to top right */
+      blt_tty |= (BLIT_TY_COPYDIR_BOTTOMTOP | BLIT_TY_COPYDIR_LEFTRIGHT);
+      blt_s1ty |= (BLIT_TY_COPYDIR_BOTTOMTOP | BLIT_TY_COPYDIR_LEFTRIGHT);
+      break;
+
+    case 270: /* rotate 270 counter clock wise */
+      blt_ins |= BLIT_INS_ENABLE_ROTATION;
+      /* read from top left to bottom right */
+      blt_s2ty |= (BLIT_TY_COPYDIR_TOPBOTTOM | BLIT_TY_COPYDIR_LEFTRIGHT);
+      /* write from top right to bottom left */
+      blt_tty |= (BLIT_TY_COPYDIR_TOPBOTTOM | BLIT_TY_COPYDIR_RIGHTLEFT);
+      blt_s1ty |= (BLIT_TY_COPYDIR_TOPBOTTOM | BLIT_TY_COPYDIR_RIGHTLEFT);
+      break;
+
+    default:
+      blt_ins &= ~BLIT_INS_ENABLE_ROTATION;
+      /* the rest will be updated later in _bdisp_aq_Blit_setup_directions() */
+      break;
+    }
+
+  stdev->ConfigGeneral.BLT_INS = blt_ins;
+  stdev->ConfigTarget.BLT_TTY = blt_tty;
+  stdev->ConfigSource1.BLT_S1TY = blt_s1ty;
+  stdev->ConfigSource2.BLT_S2TY = blt_s2ty;
+  /* rotation for 3 buffer formats is never supported, so always sanitise it */
+  stdev->ConfigSource3.BLT_S3TY = bdisp_ty_sanitise_direction (stdev->ConfigSource3.BLT_S3TY);
+
+  /* done */
+  BDISP_STATE_VALIDATED (ROTATION);
+}
+
+static void
+bdisp_state_validate_RENDEROPTS (STGFX2DriverData * const stdrv,
+                                 STGFX2DeviceData * const stdev,
+                                 const CardState  * const state)
+{
+  D_DEBUG_AT (BDisp_State, "%s\n", __FUNCTION__);
+
+  /* smooth value must be the same for up- and downscale */
+  stdev->ConfigFilters.BLT_FCTL_RZC &= ~(BLIT_RZC_2DHF_MODE_MASK
+                                         | BLIT_RZC_2DVF_MODE_MASK
+                                         | BLIT_RZC_Y_2DHF_MODE_MASK
+                                         | BLIT_RZC_Y_2DVF_MODE_MASK);
+//  stdev->ConfigFilters.BLT_FCTL_RZC &= ~BLIT_RZC_BOUNDARY_BYPASS;
+
+#ifndef STGFX2_FORCE_SMOOTH_SCALE
+  if (D_FLAGS_IS_SET (state->render_options, (DSRO_SMOOTH_UPSCALE
+                                              | DSRO_SMOOTH_DOWNSCALE)))
+    {
+      D_DEBUG_AT (BDisp_State, "  -> smooth rescale\n");
+
+      D_ASSERT (D_FLAGS_ARE_SET (state->render_options,
+                                 (DSRO_SMOOTH_UPSCALE | DSRO_SMOOTH_DOWNSCALE)));
+
+      stdev->ConfigFilters.BLT_FCTL_RZC |= (0
+                                            | BLIT_RZC_2DHF_MODE_FILTER_BOTH
+                                            | BLIT_RZC_2DVF_MODE_FILTER_BOTH
+                                           );
+      if (D_FLAGS_IS_SET (stdev->ConfigGeneral.BLT_CIC, CIC_NODE_SOURCE3))
+        stdev->ConfigFilters.BLT_FCTL_RZC |= (0
+                                              | BLIT_RZC_Y_2DHF_MODE_FILTER_BOTH
+                                              | BLIT_RZC_Y_2DVF_MODE_FILTER_BOTH
+                                             );
+//      stdev->ConfigFilters.BLT_FCTL_RZC |= BLIT_RZC_BOUNDARY_BYPASS;
+    }
+  else
+    {
+      D_DEBUG_AT (BDisp_State, "  -> resize only rescale\n");
+
+      D_ASSERT (!D_FLAGS_IS_SET (state->render_options,
+                                 (DSRO_SMOOTH_UPSCALE | DSRO_SMOOTH_DOWNSCALE)));
+
+      stdev->ConfigFilters.BLT_FCTL_RZC |= (0
+                                            | BLIT_RZC_2DHF_MODE_RESIZE_ONLY
+                                            | BLIT_RZC_2DVF_MODE_RESIZE_ONLY
+                                           );
+      if (D_FLAGS_IS_SET (stdev->ConfigGeneral.BLT_CIC, CIC_NODE_SOURCE3))
+        stdev->ConfigFilters.BLT_FCTL_RZC |= (0
+                                              | BLIT_RZC_Y_2DHF_MODE_RESIZE_ONLY
+                                              | BLIT_RZC_Y_2DVF_MODE_RESIZE_ONLY
+                                             );
+    }
+#else /* STGFX2_FORCE_SMOOTH_SCALE */
+  stdev->ConfigFilters.BLT_FCTL_RZC |= (0
+                                        | BLIT_RZC_2DHF_MODE_FILTER_BOTH
+                                        | BLIT_RZC_2DVF_MODE_FILTER_BOTH
+                                       );
+  if (D_FLAGS_IS_SET (stdev->ConfigGeneral.BLT_CIC, CIC_NODE_SOURCE3))
+    stdev->ConfigFilters.BLT_FCTL_RZC |= (0
+                                          | BLIT_RZC_Y_2DHF_MODE_FILTER_BOTH
+                                          | BLIT_RZC_Y_2DVF_MODE_FILTER_BOTH
+                                         );
+#endif /* STGFX2_FORCE_SMOOTH_SCALE */
+
+  /* done */
+  BDISP_STATE_VALIDATED (RENDEROPTS);
+}
+
+static void
+bdisp_state_validate_BLITTINGFLAGS_CKEY (STGFX2DriverData * const stdrv,
+                                         STGFX2DeviceData * const stdev,
+                                         const CardState  * const state)
+{
+  D_DEBUG_AT (BDisp_State, "%s\n", __FUNCTION__);
+
+  u32 blt_cic = stdev->ConfigGeneral.BLT_CIC;
+  u32 blt_ins = stdev->ConfigGeneral.BLT_INS;
+  u32 blt_ack = stdev->ConfigGeneral.BLT_ACK;
+
+  blt_ack &= ~(BLIT_ACK_CKEY_MASK
+               | BLIT_ACK_COLORKEYING_MASK);
+
+  if (D_FLAGS_IS_SET (state->blittingflags, (DSBLIT_DST_COLORKEY
+                                             | DSBLIT_SRC_COLORKEY)))
+    {
+      /* can't have both, source and destination color key set */
+      D_ASSERT (!D_FLAGS_ARE_SET (state->blittingflags,
+                                  (DSBLIT_DST_COLORKEY | DSBLIT_SRC_COLORKEY)));
+
+      blt_cic |= CIC_NODE_COLORKEY;
+      blt_ins |= BLIT_INS_ENABLE_COLORKEY;
+
+      if (D_FLAGS_IS_SET (state->blittingflags, DSBLIT_SRC_COLORKEY))
+        {
+          D_DEBUG_AT (BDisp_State, "  -> SRC_COLORKEY\n");
+
+          /* for source color keying, we have to set up the mode (before or
+             after the CLUT translation) depending on the pixelformat.
+             Normally, we wouldn't have to worry, but in CLUT correction
+             mode, which we use for supporting RGB32, color keying only works
+             if done after the CLUT translation. Don't know why, maybe I just
+             didn't see the note about that in the documentation. */
+          if (!DFB_PIXELFORMAT_IS_INDEXED (state->source->config.format))
+            blt_ack |= (BLIT_ACK_CKEY_RGB_ENABLE
+                        | BLIT_ACK_COLORKEYING_SRC_AFTER);
+          else
+            /* for LUT formats, the color key (i.e. the index) is specified
+               in the 'blue' bits of the color key register. */
+            blt_ack |= (BLIT_ACK_CKEY_BLUE_ENABLE
+                        | BLIT_ACK_COLORKEYING_SRC_BEFORE);
+
+          stdev->ConfigColorkey.BLT_KEY1 = stdev->blitstate.src_ckey;
+          stdev->ConfigColorkey.BLT_KEY2 = stdev->blitstate.src_ckey;
+        }
+      else
+        {
+          D_DEBUG_AT (BDisp_State, "  -> DST_COLORKEY??\n");
+
+          blt_ack |= BLIT_ACK_COLORKEYING_DEST;
+          blt_ack |= BLIT_ACK_CKEY_RGB_ENABLE;
+
+          blt_ack &= ~(BLIT_ACK_ROP_MASK | BLIT_ACK_MODE_MASK);
+          blt_ack |= BLIT_ACK_ROP_COPY | BLIT_ACK_ROP;
+//          blt_ins &= ~BLIT_INS_SRC1_MODE_MASK;
+//          blt_ins |= BLIT_INS_SRC1_MODE_MEMORY;
+          blt_ins &= ~BLIT_INS_SRC2_MODE_MASK;
+          blt_ins |= BLIT_INS_SRC2_MODE_MEMORY;
+
+          stdev->ConfigColorkey.BLT_KEY1 = stdev->all_states.dst_ckey;
+          stdev->ConfigColorkey.BLT_KEY2 = stdev->all_states.dst_ckey;
+        }
+    }
+  else
+    {
+      blt_cic &= ~CIC_NODE_COLORKEY;
+      blt_ins &= ~BLIT_INS_ENABLE_COLORKEY;
+    }
+
+  stdev->ConfigGeneral.BLT_CIC = blt_cic;
+  stdev->ConfigGeneral.BLT_INS = blt_ins;
+  stdev->ConfigGeneral.BLT_ACK = blt_ack;
+
+  /* done */
+  BDISP_STATE_VALIDATED (BLITTINGFLAGS_CKEY);
+}
+
+static void
+bdisp_state_validate_BLITTINGFLAGS (STGFX2DriverData    * const stdrv,
+                                    STGFX2DeviceData    * const stdev,
+                                    const CardState     * const state,
+                                    GraphicsDeviceFuncs * const funcs)
+{
+  D_DEBUG_AT (BDisp_State, "%s\n", __FUNCTION__);
+
+  stdev->bIndexTranslation = !!(state->blittingflags & DSBLIT_INDEX_TRANSLATION);
+  stdev->bFixedPoint       = !!(state->blittingflags & DSBLIT_FIXEDPOINT);
+
+  u32 blt_cic = stdev->ConfigGeneral.BLT_CIC;
+  u32 blt_ins = stdev->ConfigGeneral.BLT_INS;
+  u32 blt_ack = stdev->ConfigGeneral.BLT_ACK;
+
+  u32 msk_blt_cic[2];
+  u32 msk_blt_ins[2];
+  u32 msk_blt_ack[2];
+
+  blt_cic &= ~CIC_NODE_COLOR;
+  blt_ack &= (BLIT_ACK_CKEY_MASK
+              | BLIT_ACK_COLORKEYING_MASK);
+  blt_ack &= ~BLIT_ACK_SWAP_FG_BG;
+
+  stdev->blitstate.blt_ins_src1_mode = BLIT_INS_SRC1_MODE_DISABLED;
+  BDISP_STATE_INVALIDATE (SOURCE_SRC1_MODE);
+
+  blt_cic &= ~CIC_NODE_FILTERS;
+  blt_ins &= ~BLIT_INS_ENABLE_PLANEMASK;
+
+  blt_cic &= ~(CIC_NODE_IVMX | CIC_NODE_OVMX);
+  blt_ins &= ~(BLIT_INS_ENABLE_IVMX | BLIT_INS_ENABLE_OVMX);
+
+  stdev->blitstate.flags = 0;
+
+  static const DFBSurfaceBlittingFlags MODULATION_FLAGS =
+    (0
+     | DSBLIT_BLEND_ALPHACHANNEL
+     | DSBLIT_BLEND_COLORALPHA
+     | DSBLIT_DST_PREMULTIPLY /* Might be possible for BLIT_ACK_SWAP_FG_BG */
+     | DSBLIT_SRC_PREMULTIPLY
+     | DSBLIT_SRC_PREMULTCOLOR
+    );
+  DFBSurfaceBlittingFlags modulation = state->blittingflags & MODULATION_FLAGS;
+
+  funcs->Blit        = NULL;
+  funcs->StretchBlit = NULL;
+  funcs->Blit2       = NULL;
+
+  stdev->ConfigClut.BLT_CCO &= ~BLIT_CCO_CLUT_NS2_S1_MASK;
+
+  stdev->blitstate.n_passes = 1;
+
+  stdev->blitstate.src_premultcolor = D_FLAGS_IS_SET (state->blittingflags,
+                                                      DSBLIT_SRC_PREMULTCOLOR);
+
+  if (modulation)
+    {
+      blt_ack &= ~BLIT_ACK_GLOBAL_ALPHA_MASK;
+      blt_ack |= ((0x80 & 0xff) << BLIT_ACK_GLOBAL_ALPHA_SHIFT);
+
+      bool needs_blend = false;
+      bool src_premultiply = D_FLAGS_IS_SET (state->blittingflags,
+                                             DSBLIT_SRC_PREMULTIPLY);
+
+      if (D_FLAGS_IS_SET (state->blittingflags, (DSBLIT_BLEND_COLORALPHA
+                                                 | DSBLIT_BLEND_ALPHACHANNEL)))
+        {
+          stdev->blitstate.isOptimisedModulation = true;
+
+          switch (state->blittingflags & (DSBLIT_BLEND_ALPHACHANNEL
+                                          | DSBLIT_BLEND_COLORALPHA))
+            {
+            default:
+            case DSBLIT_NOFX:
+            case DSBLIT_BLEND_ALPHACHANNEL:
+              break;
+
+            case DSBLIT_BLEND_COLORALPHA:
+              /* If we do a premultiply (with colour or source alpha, but not
+                 both!), we can simply use the global alpha if the source alpha
+                 is 1.0f. It is 1.0f for all surface formats that do not contain
+                 an alpha channel as the hardware fills in the alpha for us
+                 and for those formats that do have an alpha channel, we can
+                 use a (static, hence fast) palette to replace the source alpha
+                 by 1.0f. We can also do the optimisation for those obscure
+                 blend modes where the source is discarded. */
+              switch (stdev->porter_duff_rule)
+                {
+                case DSPD_DST:
+                  if (D_FLAGS_IS_SET (state->blittingflags,
+                                      DSBLIT_DST_PREMULTIPLY))
+                    {
+                      stdev->blitstate.isOptimisedModulation = false;
+                      break;
+                    }
+                  /* fall through */
+
+                case DSPD_CLEAR:
+                  break;
+
+                case DSPD_SRC:
+                case DSPD_SRC_OVER:
+                  switch (state->blittingflags & (DSBLIT_SRC_PREMULTCOLOR
+                                                  | DSBLIT_SRC_PREMULTIPLY))
+                    {
+                    case DSBLIT_NOFX:
+                      stdev->blitstate.isOptimisedModulation = false;
+                      break;
+
+                    case (DSBLIT_SRC_PREMULTCOLOR | DSBLIT_SRC_PREMULTIPLY):
+                      if (!stdev->blitstate.canUseHWInputMatrix)
+                        {
+                          stdev->blitstate.isOptimisedModulation = false;
+                          break;
+                        }
+                      /* fall through */
+
+                    case DSBLIT_SRC_PREMULTCOLOR:
+                      if (!src_premultiply)
+                        {
+                          stdev->blitstate.src_premultcolor = false;
+                          BDISP_STATE_INVALIDATE (MATRIXCONVERSIONS);
+                        }
+                      /* fall through */
+
+                    case DSBLIT_SRC_PREMULTIPLY:
+                      needs_blend = true;
+                      src_premultiply = false;
+                      break;
+                    }
+                  break;
+
+                case DSPD_NONE:
+                case DSPD_DST_OVER:
+                case DSPD_DST_IN:
+                case DSPD_DST_OUT:
+                default:
+                  stdev->blitstate.isOptimisedModulation = false;
+                  break;
+                }
+
+              /* this will set up blt_ack or the palette as needed */
+              BDISP_STATE_INVALIDATE (BLITCOLOR);
+              break;
+
+            case (DSBLIT_BLEND_ALPHACHANNEL | DSBLIT_BLEND_COLORALPHA):
+              /* as an optimisation, we can use the global alpha if we do
+                 SRC_PREMULTIPLY or SRC_PREMULTCOLOR or if the source blend
+                 function is DSBF_SRCALPHA. */
+              switch (stdev->porter_duff_rule)
+                {
+                case DSPD_DST_OVER:
+                case DSPD_DST_IN:
+                case DSPD_DST_OUT:
+                  stdev->blitstate.isOptimisedModulation = false;
+                  break;
+
+                default:
+                  if (!D_FLAGS_IS_SET (state->blittingflags,
+                                       (DSBLIT_SRC_PREMULTCOLOR
+                                        | DSBLIT_SRC_PREMULTIPLY)))
+                    {
+                      stdev->blitstate.isOptimisedModulation = false;
+                      break;
+                    }
+                  /* fall through */
+
+                case DSPD_NONE:
+                  if (stdev->blitstate.src_premultcolor
+                      && !stdev->blitstate.canUseHWInputMatrix)
+                    {
+                      if (src_premultiply
+                          || stdev->porter_duff_rule == DSPD_NONE)
+                        {
+                          stdev->blitstate.isOptimisedModulation = false;
+                          break;
+                        }
+                    }
+
+                  needs_blend = true;
+                  if (stdev->blitstate.src_premultcolor
+                      && !src_premultiply
+                      && stdev->porter_duff_rule != DSPD_NONE)
+                    {
+                      stdev->blitstate.src_premultcolor = false;
+                      BDISP_STATE_INVALIDATE (MATRIXCONVERSIONS);
+                    }
+                  break;
+                }
+
+              /* this will set up blt_ack or the palette as needed */
+              BDISP_STATE_INVALIDATE (BLITCOLOR);
+              break;
+            }
+
+          switch (stdev->porter_duff_rule)
+            {
+            case DSPD_CLEAR:
+              D_DEBUG_AT (BDisp_State, "  -> fast direct fill (DSPD_CLEAR)\n");
+              /* This is a clear, just fill with 0 */
+              funcs->Blit        = bdisp_aq_Blit_shortcut;
+              funcs->StretchBlit = bdisp_aq_StretchBlit_shortcut;
+              funcs->Blit2       = bdisp_aq_Blit2_shortcut;
+              goto out;
+
+            case DSPD_DST:
+              if (D_FLAGS_IS_SET (state->blittingflags, DSBLIT_DST_PREMULTIPLY))
+                {
+                  /* FIXME: untested! */
+                  blt_ack |= BLIT_ACK_SWAP_FG_BG;
+
+                  D_DEBUG_AT (BDisp_State,
+                              "  -> blend dst with src colour zero (DSPD_DST)\n");
+                  blt_ins &= ~BLIT_INS_SRC2_MODE_MASK;
+                  blt_ins |= BLIT_INS_SRC2_MODE_COLOR_FILL;
+                  BDISP_STATE_INVALIDATE (SOURCE);
+
+                  stdev->blitstate.blt_ins_src1_mode = BLIT_INS_SRC1_MODE_MEMORY;
+
+                  needs_blend = true;
+                  /* FIXME: don't overwrite palette type here? */
+                  stdev->palette_type = SG2C_NORMAL;
+                }
+              else
+                {
+                  funcs->Blit        = bdisp_aq_Blit_nop;
+                  funcs->StretchBlit = bdisp_aq_StretchBlit_nop;
+                  funcs->Blit2       = bdisp_aq_Blit2_nop;
+                  goto out;
+                }
+              break;
+
+            case DSPD_SRC:
+              if (src_premultiply
+                  || needs_blend)
+                {
+                  /* This is a copy (blend with a destination of (0,0,0,0))
+                     after premultiplication with the colour alpha channel. */
+                  D_DEBUG_AT (BDisp_State,
+                              "  -> blend src with dst colour zero (DSPD_SRC)\n");
+                  blt_cic |= CIC_NODE_COLOR;
+                  stdev->blitstate.blt_ins_src1_mode = BLIT_INS_SRC1_MODE_COLOR_FILL;
+                  needs_blend = true;
+                }
+              break;
+
+            case DSPD_DST_OVER:
+              blt_ack |= BLIT_ACK_SWAP_FG_BG;
+            case DSPD_SRC_OVER:
+              D_DEBUG_AT (BDisp_State, "  -> blend with dst memory (DSPD_%s_OVER)\n",
+                          (stdev->porter_duff_rule == DSPD_SRC_OVER) ? "SRC" : "DST");
+              stdev->blitstate.blt_ins_src1_mode = BLIT_INS_SRC1_MODE_MEMORY;
+              needs_blend = true;
+              break;
+
+            case DSPD_DST_IN:
+              D_DEBUG_AT (BDisp_State, "  -> blend with dst memory (DSPD_DST_IN)\n");
+              stdev->blitstate.blt_ins_src1_mode = BLIT_INS_SRC1_MODE_MEMORY;
+              if (!stdev->blitstate.isOptimisedModulation)
+                BDISP_STATE_INVALIDATE (BLITCOLOR);
+              else
+                {
+                  D_DEBUG_AT (BDisp_State, "    -> SG2C_INVALPHA_ZERORGB\n");
+                  if (stdev->palette_type == SG2C_ONEALPHA_RGB)
+                    {
+                      stdev->palette_type = SG2C_ZEROALPHA_ZERORGB;
+                      stdev->blitstate.extra_passes[0].palette_type = SG2C_ONEALPHA_RGB;
+                    }
+                  else
+                    {
+                      stdev->palette_type = SG2C_INVALPHA_ZERORGB;
+                      stdev->blitstate.extra_passes[0].palette_type = SG2C_NORMAL;
+                    }
+                }
+              needs_blend = true;
+              /* need the plane mask in the first pass */
+              stdev->blitstate.extra_passes[0].ConfigGeneral.BLT_CIC = 0;
+              stdev->blitstate.extra_passes[0].ConfigGeneral.BLT_INS = 0;
+              stdev->blitstate.extra_passes[0].ConfigGeneral.BLT_ACK = BLIT_ACK_BLEND_CLIPMASK_BLEND;
+              blt_cic |= CIC_NODE_FILTERS;
+              blt_ins |= BLIT_INS_ENABLE_PLANEMASK;
+              msk_blt_cic[0] = ~CIC_NODE_FILTERS;
+              msk_blt_ins[0] = ~BLIT_INS_ENABLE_PLANEMASK;
+              msk_blt_ack[0] = ~BLIT_ACK_MODE_MASK;
+              stdev->blitstate.n_passes = 2;
+              break;
+
+            case DSPD_DST_OUT:
+              D_DEBUG_AT (BDisp_State, "  -> blend with dst memory (DSPD_DST_OUT)\n");
+              stdev->blitstate.blt_ins_src1_mode = BLIT_INS_SRC1_MODE_MEMORY;
+              if (!stdev->blitstate.isOptimisedModulation)
+                BDISP_STATE_INVALIDATE (BLITCOLOR);
+              else
+                {
+                  D_DEBUG_AT (BDisp_State, "    -> normal palettes\n");
+                  if (stdev->palette_type == SG2C_ONEALPHA_RGB)
+                    {
+                      stdev->palette_type = SG2C_ONEALPHA_ZERORGB;
+                      stdev->blitstate.extra_passes[0].palette_type = SG2C_ZEROALPHA_ZERORGB;
+                    }
+                  else
+                    {
+                      stdev->palette_type = SG2C_ALPHA_ZERORGB;
+                      stdev->blitstate.extra_passes[0].palette_type = SG2C_INVALPHA_ZERORGB;
+                    }
+                }
+              needs_blend = true;
+              /* need the plane mask in the first pass */
+              stdev->blitstate.extra_passes[0].ConfigGeneral.BLT_CIC = 0;
+              stdev->blitstate.extra_passes[0].ConfigGeneral.BLT_INS = 0;
+              stdev->blitstate.extra_passes[0].ConfigGeneral.BLT_ACK = BLIT_ACK_BLEND_CLIPMASK_BLEND;
+              blt_cic |= CIC_NODE_FILTERS;
+              blt_ins |= BLIT_INS_ENABLE_PLANEMASK;
+              msk_blt_cic[0] = ~CIC_NODE_FILTERS;
+              msk_blt_ins[0] = ~BLIT_INS_ENABLE_PLANEMASK;
+              msk_blt_ack[0] = ~BLIT_ACK_MODE_MASK;
+              stdev->blitstate.n_passes = 2;
+              break;
+
+            case DSPD_NONE:
+              /* Must be premulitply off, dest no alpha channel. */
+              D_DEBUG_AT (BDisp_State, "  -> blend with dst memory (DSPD_NONE)\n");
+              stdev->blitstate.blt_ins_src1_mode = BLIT_INS_SRC1_MODE_MEMORY;
+              needs_blend = true;
+              break;
+
+            default:
+              D_WARN ("unsupported Porter/Duff rule: %d flags: %.8x",
+                      stdev->porter_duff_rule, state->blittingflags);
+              needs_blend = true;
+              break;
+            }
+        }
+      else if (D_FLAGS_IS_SET (state->blittingflags,
+                               (DSBLIT_SRC_PREMULTIPLY
+                                | DSBLIT_DST_PREMULTIPLY)))
+        {
+          /* This is a copy (blend with a destination of (0,0,0,0))
+             after premultiplication with the colour alpha channel. */
+          if (D_FLAGS_IS_SET (state->blittingflags, DSBLIT_DST_PREMULTIPLY))
+            /* FIXME: see DSPD_DST case. */
+            blt_ack |= BLIT_ACK_SWAP_FG_BG;
+
+          D_DEBUG_AT (BDisp_State, "  -> %s premultiply\n",
+                      (state->blittingflags & DSBLIT_SRC_PREMULTIPLY) ? "src" : "dst");
+          blt_cic |= CIC_NODE_COLOR;
+          stdev->blitstate.blt_ins_src1_mode = BLIT_INS_SRC1_MODE_COLOR_FILL;
+          needs_blend = true;
+        }
+
+      if (needs_blend)
+        {
+          /* CheckState guarantees that only one of SRC_PREMULTIPLY
+             DST_PREMULTIPLY is set, depending on BLIT_ACK_SWAP_FG_BG */
+          blt_ack |= ((src_premultiply
+                       || (state->blittingflags & DSBLIT_DST_PREMULTIPLY)
+                       || (stdev->porter_duff_rule == DSPD_NONE))
+                       ? BLIT_ACK_BLEND_SRC2_N_PREMULT
+                       : BLIT_ACK_BLEND_SRC2_PREMULT);
+        }
+    }
+
+  if (D_FLAGS_IS_SET (state->blittingflags, DSBLIT_XOR))
+    {
+      D_DEBUG_AT (BDisp_State, "  -> XOR\n");
+      blt_ack &= ~BLIT_ACK_ROP_MASK;
+      blt_ack |= (0
+                  | BLIT_ACK_ROP
+                  | BLIT_ACK_ROP_XOR
+                 );
+      stdev->blitstate.blt_ins_src1_mode = BLIT_INS_SRC1_MODE_MEMORY;
+    }
+
+  if (D_FLAGS_IS_SET (state->blittingflags, DSBLIT_SOURCE2))
+    {
+      D_DEBUG_AT (BDisp_State, "  -> SOURCE2\n");
+
+      D_ASSERT (stdev->blitstate.blt_ins_src1_mode !=
+                BLIT_INS_SRC1_MODE_COLOR_FILL);
+      stdev->blitstate.blt_ins_src1_mode = BLIT_INS_SRC1_MODE_MEMORY;
+    }
+
+  if (!(blt_ack & BLIT_ACK_MODE_MASK))
+    blt_ack |= BLIT_ACK_BYPASSSOURCE2;
+  stdev->ConfigGeneral.BLT_CIC = blt_cic;
+  stdev->ConfigGeneral.BLT_INS = blt_ins;
+  stdev->ConfigGeneral.BLT_ACK = blt_ack;
+
+  int i;
+  for (i = 0; i < (stdev->blitstate.n_passes - 1); ++i)
+    {
+      blt_cic &= msk_blt_cic[i];
+      blt_ins &= msk_blt_ins[i];
+      blt_ack &= msk_blt_ack[i];
+
+      blt_cic &= ~stdev->blitstate.extra_passes[i].ConfigGeneral.BLT_CIC;
+      blt_ins &= ~stdev->blitstate.extra_passes[i].ConfigGeneral.BLT_INS;
+      blt_ack &= ~stdev->blitstate.extra_passes[i].ConfigGeneral.BLT_ACK;
+
+      stdev->blitstate.extra_passes[i].ConfigGeneral.BLT_CIC |= blt_cic;
+      stdev->blitstate.extra_passes[i].ConfigGeneral.BLT_INS |= blt_ins;
+      stdev->blitstate.extra_passes[i].ConfigGeneral.BLT_INS |= stdev->blitstate.blt_ins_src1_mode;
+      stdev->blitstate.extra_passes[i].ConfigGeneral.BLT_ACK |= blt_ack;
+    }
+
+out:
+  /* done */
+  BDISP_STATE_VALIDATED (BLITTINGFLAGS);
+}
+
+#define set_matrix(dst, src) \
+  ({ \
+    dst ## 0 = src[0]; \
+    dst ## 1 = src[1]; \
+    dst ## 2 = src[2]; \
+    dst ## 3 = src[3]; \
+  })
+
+
+static void
+bdisp_state_validate_INPUTMATRIX (STGFX2DriverData * const stdrv,
+                                  STGFX2DeviceData * const stdev,
+                                  CardState        * const state)
+{
+  bool t_is_YCbCr = !!BLIT_TY_COLOR_FORM_IS_YUV (stdev->ConfigTarget.BLT_TTY);
+  bool s2_is_YCbCr = !!BLIT_TY_COLOR_FORM_IS_YUV (stdev->ConfigSource2.BLT_S2TY);
+
+  D_DEBUG_AT (BDisp_State, "%s\n", __FUNCTION__);
+
+  stdev->blitstate.canUseHWInputMatrix = (t_is_YCbCr == s2_is_YCbCr);
+
+  /* done */
+  BDISP_STATE_VALIDATED (INPUTMATRIX);
+}
+
+static void
+bdisp_state_validate_MATRIXCONVERSIONS (STGFX2DriverData * const stdrv,
+                                        STGFX2DeviceData * const stdev,
+                                        CardState        * const state)
+{
+  u32 blt_cic = stdev->ConfigGeneral.BLT_CIC;
+  u32 blt_ins = stdev->ConfigGeneral.BLT_INS;
+
+  D_DEBUG_AT (BDisp_State, "%s\n", __FUNCTION__);
+
+  blt_cic &= ~(CIC_NODE_IVMX | CIC_NODE_OVMX);
+  blt_ins &= ~(BLIT_INS_ENABLE_IVMX | BLIT_INS_ENABLE_OVMX);
+
+  if (BLIT_TY_COLOR_FORM_IS_ALPHA (stdev->ConfigSource2.BLT_S2TY)
+      || D_FLAGS_IS_SET (state->blittingflags, DSBLIT_COLORIZE)
+      || stdev->blitstate.src_premultcolor)
+    {
+      if (!BLIT_TY_COLOR_FORM_IS_YUV (stdev->ConfigSource2.BLT_S2TY))
+        if (BLIT_TY_COLOR_FORM_IS_YUV (stdev->ConfigTarget.BLT_TTY))
+          {
+            D_DEBUG_AT (BDisp_State, "  -> Output RGB->YCbCr601\n");
+
+            blt_cic |= CIC_NODE_OVMX;
+            blt_ins |= BLIT_INS_ENABLE_OVMX;
+          }
+
+      u32 red, green, blue;
+      u32 extra = 0;
+
+      blt_cic |= CIC_NODE_IVMX;
+      blt_ins |= BLIT_INS_ENABLE_IVMX;
+
+      if (D_FLAGS_IS_SET (state->blittingflags, DSBLIT_COLORIZE))
+        {
+          D_DEBUG_AT (BDisp_State, "  -> COLORIZE: %.2x%.2x%.2x\n",
+                      state->color.r, state->color.g, state->color.b);
+
+          red   = (state->color.r * 256) / 255;
+          green = (state->color.g * 256) / 255;
+          blue  = (state->color.b * 256) / 255;
+
+          if (BLIT_TY_COLOR_FORM_IS_YUV (stdev->ConfigSource2.BLT_S2TY))
+            {
+              int cr = red;
+              int y  = green;
+              int cb = blue;
+
+              /* this is for brightness, contrast and saturation:
+                 - brigthness is adjusted by passing 0 <= brighness <= 255,
+                   with Y (green) = brightness and R = B = 255
+                 - contrast by passing in 0 <= contrast <= 255,
+                   with R = G = B = contrast
+                 - saturation by passing in 0 <= saturation <= 255,
+                   with G = 255 and R = B = saturation
+                 This does not allow to increase any of these above the
+                 original values.
+
+                 For contrast, what we need is
+                 Y  = Contrast * (Y  - 128) + 128
+                 Cb = Contrast * (Cb - 128) + 128
+                 Cr = Contrast * (Cr - 128) + 128
+
+                 which can be re-written as
+                 Cb = Contrast * Cb - 128 * Contrast + 128 etc.
+
+                 This is what happens here - the Contrast * Cb is done using
+                 the xVMX2, prepared above, and -128 * Contrast + 128 we
+                 prepare here (xVMX3).
+
+                 The same goes for saturation and brightness.
+              */
+              int extra_cr = (((-128 * cr / 256) + 128) & 0x3ff) << 20;
+              int extra_y  = (((-128 *  y / 256) + 128) & 0x3ff) << 10;
+              int extra_cb = (((-128 * cb / 256) + 128) & 0x3ff) <<  0;
+
+              extra = extra_cr | extra_y | extra_cb;
+            }
+        }
+      else
+        red = green = blue = 256;
+
+      if (stdev->blitstate.src_premultcolor)
+        {
+          /* scale 0..255 to 0..256 */
+          u32 alpha = (state->color.a * 256) / 255;
+
+          D_DEBUG_AT (BDisp_State, "  -> SRC_PREMULTCOLOR : %.2x\n", alpha);
+
+          red   = (red   * alpha) / 256;
+          green = (green * alpha) / 256;
+          blue  = (blue  * alpha) / 256;
+        }
+
+      if (BLIT_TY_COLOR_FORM_IS_ALPHA (stdev->ConfigSource2.BLT_S2TY))
+        {
+          /* A8 and A1 surface types, we need to add the calculated colour as
+             the hardware always expands to black with alpha (what use is
+             that?!) */
+          D_DEBUG_AT (BDisp_State,
+                      "  -> Input  x RGB replacement (%.2x%.2x%.2x)\n",
+                      red, green, blue);
+
+          stdev->ConfigIVMX.BLT_IVMX0 = 0;
+          stdev->ConfigIVMX.BLT_IVMX1 = 0;
+          stdev->ConfigIVMX.BLT_IVMX2 = 0;
+          stdev->ConfigIVMX.BLT_IVMX3 = (red << 20) | (green << 10) | blue;
+        }
+      else /* if (!BLIT_TY_COLOR_FORM_IS_MISC (stdev->ConfigSource2.BLT_S2TY)) */
+        {
+          /* RGB surface types, do a real modulation */
+          D_DEBUG_AT (BDisp_State,
+                      "  -> Input RGB modulation (%.2x%.2x%.2x)\n",
+                      red, green, blue);
+
+          stdev->ConfigIVMX.BLT_IVMX0 = red   << 21;
+          stdev->ConfigIVMX.BLT_IVMX1 = green << 10;
+          stdev->ConfigIVMX.BLT_IVMX2 = blue;
+          stdev->ConfigIVMX.BLT_IVMX3 = extra;
+        }
+      /* else RLE - not reached (hopefully :-) */
+    }
+  else
+    {
+      if (BLIT_TY_COLOR_FORM_IS_YUV (stdev->ConfigTarget.BLT_TTY)
+          && !BLIT_TY_COLOR_FORM_IS_YUV (stdev->ConfigSource2.BLT_S2TY))
+        {
+          D_DEBUG_AT (BDisp_State, "  -> Input RGB->YCbCr601\n");
+
+          blt_cic |= CIC_NODE_IVMX;
+          blt_ins |= BLIT_INS_ENABLE_IVMX;
+
+          set_matrix (stdev->ConfigIVMX.BLT_IVMX, bdisp_aq_RGB_2_VideoYCbCr601);
+        }
+      else if (!BLIT_TY_COLOR_FORM_IS_YUV (stdev->ConfigTarget.BLT_TTY)
+               && BLIT_TY_COLOR_FORM_IS_YUV (stdev->ConfigSource2.BLT_S2TY))
+        {
+          D_DEBUG_AT (BDisp_State, "  -> Input YCbCr601->RGB\n");
+
+          blt_cic |= CIC_NODE_IVMX;
+          blt_ins |= BLIT_INS_ENABLE_IVMX;
+
+          set_matrix (stdev->ConfigIVMX.BLT_IVMX, bdisp_aq_VideoYCbCr601_2_RGB);
+        }
+    }
+
+  stdev->ConfigGeneral.BLT_CIC = blt_cic;
+  stdev->ConfigGeneral.BLT_INS = blt_ins;
+
+  BDISP_STATE_VALIDATED (MATRIXCONVERSIONS);
+}
+
+
+void
+bdisp_aq_SetState (void                * const drv,
+                   void                * const dev,
+                   GraphicsDeviceFuncs * const funcs,
+                   CardState           * const state,
+                   DFBAccelerationMask   accel)
+{
+  STGFX2DriverData       * const stdrv = drv;
+  STGFX2DeviceData       * const stdev = dev;
+  StateModificationFlags  modified = state->mod_hw;
+
+  bool support_hw_clip = false;
+
+  _dump_set_state (__FUNCTION__, state, accel);
+
+  D_DEBUG_AT (BDisp_State, "%s: %.8x\n", __FUNCTION__, state->mod_hw);
+
+  /* Simply invalidate all? */
+  if (modified == SMF_ALL)
+    BDISP_STATE_INVALIDATE (ALL);
+  else if (likely (modified))
+    {
+      /* Invalidate destination registers. */
+      if (modified & SMF_DESTINATION)
+        {
+          /* make sure that the color gets updated when the destination
+             surface format changes, as we have to modify the color for
+             fills. */
+          BDISP_STATE_INVALIDATE (DESTINATION | SOURCE_SRC1_MODE
+                                  | FILLCOLOR | DST_COLORKEY
+                                  | PALETTE_DRAW | PALETTE_BLIT
+                                  | DRAWINGFLAGS
+                                  | BLITTINGFLAGS);
+        }
+      else
+        {
+          if (modified & (SMF_DRAWING_FLAGS
+                          | SMF_SRC_BLEND | SMF_DST_BLEND))
+            /* make sure that the color gets updated when the drawing
+               flags change, as we have to modify the color for fills. */
+            BDISP_STATE_INVALIDATE (FILLCOLOR | DRAWINGFLAGS | PALETTE_DRAW);
+
+          if (modified & SMF_DST_COLORKEY)
+            BDISP_STATE_INVALIDATE (DST_COLORKEY);
+
+          if (modified & (SMF_BLITTING_FLAGS
+                          | SMF_SRC_BLEND | SMF_DST_BLEND))
+            BDISP_STATE_INVALIDATE (PALETTE_BLIT);
+        }
+
+      if (modified & SMF_COLOR)
+        BDISP_STATE_INVALIDATE (FILLCOLOR | BLITCOLOR | MATRIXCONVERSIONS);
+      else if (modified & SMF_BLITTING_FLAGS)
+        BDISP_STATE_INVALIDATE (BLITCOLOR | MATRIXCONVERSIONS);
+
+      /* Invalidate clipping registers. */
+      if (modified & SMF_CLIP)
+        BDISP_STATE_INVALIDATE (CLIP);
+
+      if (modified & SMF_SOURCE)
+        BDISP_STATE_INVALIDATE (SOURCE | SOURCE_SRC1_MODE
+                                | SRC_COLORKEY
+                                | PALETTE_BLIT
+                                | BLITTINGFLAGS | BLITTINGFLAGS_CKEY
+                                | RENDEROPTS);
+      else
+        {
+          if (modified & SMF_SRC_COLORKEY)
+            BDISP_STATE_INVALIDATE (SRC_COLORKEY);
+
+          if (modified & SMF_RENDER_OPTIONS)
+            BDISP_STATE_INVALIDATE (RENDEROPTS);
+
+          if (modified & SMF_BLITTING_FLAGS)
+            BDISP_STATE_INVALIDATE (SOURCE_SRC1_MODE
+                                    | BLITTINGFLAGS | BLITTINGFLAGS_CKEY);
+          else if (modified & (SMF_SRC_BLEND | SMF_DST_BLEND))
+            BDISP_STATE_INVALIDATE (BLITTINGFLAGS | BLITTINGFLAGS_CKEY);
+
+          if (modified & SMF_SOURCE2)
+            BDISP_STATE_INVALIDATE (SOURCE_SRC1_MODE);
+        }
+
+      if (modified & (SMF_BLITTING_FLAGS | SMF_MATRIX | SMF_RENDER_OPTIONS))
+        BDISP_STATE_INVALIDATE (ROTATION);
+    }
+
+  if (modified & (SMF_SRC_BLEND | SMF_DST_BLEND))
+    stdev->porter_duff_rule = bdisp_aq_convert_to_supported_porterduff (state);
+
+  BDISP_STATE_CHECK_N_VALIDATE (DESTINATION);
+
+  BDISP_STATE_CHECK_N_VALIDATE (FILLCOLOR);
+
+  BDISP_STATE_CHECK_N_VALIDATE (DST_COLORKEY);
+
+  switch (accel)
+    {
+    case DFXL_FILLRECTANGLE:
+    case DFXL_DRAWRECTANGLE:
+      BDISP_STATE_CHECK_N_VALIDATE (PALETTE_DRAW);
+      BDISP_STATE_CHECK_N_VALIDATE (DRAWINGFLAGS);
+
+      if (stdev->drawstate.ConfigGeneral.BLT_INS == BLIT_INS_SRC1_MODE_DIRECT_FILL)
+        {
+          /* this is a simple solid fill that can use the 64bit fast path
+             in the blitter, which supports the output of multiple pixels
+             per blitter clock cycle. */
+          D_DEBUG_AT (BDisp_State, "%s(): fast direct fill/draw\n", __FUNCTION__);
+
+          funcs->FillRectangle = bdisp_aq_FillRectangle_simple;
+          funcs->DrawRectangle = bdisp_aq_DrawRectangle_simple;
+        }
+      else if (unlikely (((stdev->drawstate.ConfigGeneral.BLT_INS & BLIT_INS_SRC2_MODE_MASK)
+                          == BLIT_INS_SRC2_MODE_DISABLED)
+                         && ((stdev->drawstate.ConfigGeneral.BLT_INS & BLIT_INS_SRC1_MODE_MASK)
+                             == BLIT_INS_SRC1_MODE_DISABLED)))
+        {
+          /* We don't need to do the operation as it would be a nop... */
+          funcs->FillRectangle = bdisp_aq_FillDraw_nop;
+          funcs->DrawRectangle = bdisp_aq_FillDraw_nop;
+
+          /* ...hence we might as well announce support for clipping. */
+          support_hw_clip = true;
+        }
+      else
+        {
+          /* this is a fill which needs to use the source 2 data path for
+             the fill color. This path is limited to one pixel output per
+             blitter clock cycle... */
+          D_DEBUG_AT (BDisp_State, "%s(): complex fill/draw\n", __FUNCTION__);
+
+          D_ASSUME ((stdev->drawstate.ConfigGeneral.BLT_INS & BLIT_INS_SRC1_MODE_MASK) != BLIT_INS_SRC1_MODE_DIRECT_FILL);
+
+          funcs->FillRectangle = bdisp_aq_FillRectangle;
+          funcs->DrawRectangle = bdisp_aq_DrawRectangle;
+
+          /* ...but it supports clipping. */
+          support_hw_clip = true;
+        }
+
+      state->set |= (DFXL_FILLRECTANGLE | DFXL_DRAWRECTANGLE);
+      break;
+
+    case DFXL_BLIT:
+    case DFXL_BLIT2:
+    case DFXL_STRETCHBLIT:
+      /* SRC1 mode depends on the acceleration function in addition to the
+         blitting flags, therefore we need to invalidate this every time! */
+      BDISP_STATE_INVALIDATE (SOURCE_SRC1_MODE);
+      BDISP_STATE_CHECK_N_VALIDATE (SOURCE);
+      BDISP_STATE_CHECK_N_VALIDATE (INPUTMATRIX);
+      BDISP_STATE_CHECK_N_VALIDATE (SRC_COLORKEY);
+      BDISP_STATE_CHECK_N_VALIDATE (RENDEROPTS);
+      BDISP_STATE_CHECK_N_VALIDATE (PALETTE_BLIT);
+      BDISP_STATE_CHECK_N_VALIDATE2 (BLITTINGFLAGS);
+      BDISP_STATE_CHECK_N_VALIDATE (BLITTINGFLAGS_CKEY);
+      BDISP_STATE_CHECK_N_VALIDATE (BLITCOLOR);
+      BDISP_STATE_CHECK_N_VALIDATE3 (SOURCE_SRC1_MODE);
+      BDISP_STATE_CHECK_N_VALIDATE (MATRIXCONVERSIONS);
+      BDISP_STATE_CHECK_N_VALIDATE2 (ROTATION);
+
+      if (unlikely (funcs->Blit == bdisp_aq_Blit_nop))
+        {
+          /* DSPD_DST blend was requested. */
+          D_ASSERT (funcs->StretchBlit == bdisp_aq_StretchBlit_nop);
+          D_ASSERT (funcs->Blit2 == bdisp_aq_Blit2_nop);
+          state->set |= (DFXL_BLIT | DFXL_STRETCHBLIT | DFXL_BLIT2);
+        }
+      else if (unlikely (funcs->Blit == bdisp_aq_Blit_shortcut))
+        {
+          /* DSPD_CLEAR 'blend' was requested. */
+          D_ASSERT (funcs->StretchBlit == bdisp_aq_StretchBlit_shortcut);
+          D_ASSERT (funcs->Blit2 == bdisp_aq_Blit2_shortcut);
+          switch (state->destination->config.format)
+            {
+            case DSPF_YUY2:
+            case DSPF_UYVY:
+              funcs->Blit = bdisp_aq_Blit_shortcut_YCbCr422r;
+              funcs->StretchBlit = bdisp_aq_StretchBlit_shortcut_YCbCr422r;
+              funcs->Blit2 = bdisp_aq_Blit2_shortcut_YCbCr422r;
+              break;
+
+            case DSPF_RGB32:
+              funcs->Blit = bdisp_aq_Blit_shortcut_rgb32;
+              funcs->StretchBlit = bdisp_aq_StretchBlit_shortcut_rgb32;
+              funcs->Blit2 = bdisp_aq_Blit2_shortcut_rgb32;
+              break;
+
+            default:
+              /* nothing */
+              break;
+            }
+          state->set |= (DFXL_BLIT | DFXL_STRETCHBLIT | DFXL_BLIT2);
+        }
+      else if (unlikely (stdev->rotate == 90
+                         || stdev->rotate == 270))
+        {
+          D_DEBUG_AT (BDisp_State, "%s(): rotated blit\n", __FUNCTION__);
+          state->set |= DFXL_BLIT;
+          state->set &= ~(DFXL_STRETCHBLIT | DFXL_BLIT2);
+          funcs->Blit = bdisp_aq_Blit_rotate_90_270;
+          bdisp_aq_setup_blit_operation (stdrv, stdev);
+        }
+      else
+        {
+          state->set |= (DFXL_BLIT | DFXL_STRETCHBLIT);
+          /* if this is a stretchblit, or a blit of a subbyte format, or
+             a blit with format conversion, or a blit with any blitting
+             flags set, we have to use the slow path... */
+          if (state->source->config.format == state->destination->config.format
+              && D_FLAGS_ARE_IN (state->blittingflags,
+                                 DSBLIT_INDEX_TRANSLATION)
+              /* this caters for 180 degrees and mirroring */
+              && !stdev->rotate)
+            {
+              D_DEBUG_AT (BDisp_State, "%s(): fast blit\n", __FUNCTION__);
+
+              switch (state->destination->config.format)
+                {
+                case DSPF_YUY2:
+                case DSPF_UYVY:
+                  /* for some reason a fast UYVY -> UYVY blit has problems, we
+                     can use the fast path, but have to change the pixelformat!
+                     RGB16 just works fine, and it doesn't matter as the BDisp
+                     does not care about the actual data. */
+                  funcs->Blit = bdisp_aq_Blit_simple_YCbCr422r;
+                  break;
+
+                default:
+                  funcs->Blit = bdisp_aq_Blit_simple;
+                  break;
+                }
+            }
+          else if (DFB_PLANAR_PIXELFORMAT (state->source->config.format))
+            {
+              D_DEBUG_AT (BDisp_State, "%s(): planar blit\n", __FUNCTION__);
+              funcs->Blit = bdisp_aq_Blit_as_stretch;
+              support_hw_clip = true;
+            }
+          else
+            {
+              D_DEBUG_AT (BDisp_State, "%s(): complex blit\n", __FUNCTION__);
+              funcs->Blit = bdisp_aq_Blit;
+              support_hw_clip = true;
+            }
+
+          if (D_FLAGS_IS_SET (accel, DFXL_BLIT2))
+            {
+              funcs->Blit2 = bdisp_aq_Blit2;
+              state->set |= DFXL_BLIT2;
+            }
+          else
+            {
+              funcs->Blit2 = bdisp_aq_Blit2_nop;
+              state->set &= ~DFXL_BLIT2;
+            }
+
+          funcs->StretchBlit = bdisp_aq_StretchBlit;
+          bdisp_aq_setup_blit_operation (stdrv, stdev);
+        }
+      break;
+
+    default:
+      /* Should never happen as we have told DirectFB which functions we can
+         support */
+      D_ERROR ("DirectFB/gfxdrivers/stgfx2: unexpected acceleration function");
+      state->set &= ~(DFXL_BLIT | DFXL_STRETCHBLIT | DFXL_BLIT2);
+      break;
+  }
+
+
+#ifdef STGFX2_SUPPORT_HW_CLIPPING
+  if (support_hw_clip)
+    {
+      BDISP_STATE_CHECK_N_VALIDATE (CLIP);
+      *flags |= CCF_CLIPPING;
+
+      stdev->ConfigGeneral.BLT_CIC |= CIC_NODE_CLIP;
+      stdev->ConfigGeneral.BLT_INS |= BLIT_INS_ENABLE_RECTCLIP;
+
+      /* multi pass operations */
+      stdev->blitstate.extra_passes[0].ConfigGeneral.BLT_CIC |= CIC_NODE_CLIP;
+      stdev->blitstate.extra_passes[0].ConfigGeneral.BLT_INS |= BLIT_INS_ENABLE_RECTCLIP;
+      stdev->blitstate.extra_passes[1].ConfigGeneral.BLT_CIC |= CIC_NODE_CLIP;
+      stdev->blitstate.extra_passes[1].ConfigGeneral.BLT_INS |= BLIT_INS_ENABLE_RECTCLIP;
+    }
+  else
+    {
+      /* fast path, hence no HW clipping */
+      *flags &= ~CCF_CLIPPING;
+
+      stdev->ConfigGeneral.BLT_CIC &= ~CIC_NODE_CLIP;
+      stdev->ConfigGeneral.BLT_INS &= ~BLIT_INS_ENABLE_RECTCLIP;
+
+      /* multi pass operations */
+      stdev->blitstate.extra_passes[0].ConfigGeneral.BLT_CIC &= ~CIC_NODE_CLIP;
+      stdev->blitstate.extra_passes[0].ConfigGeneral.BLT_INS &= ~BLIT_INS_ENABLE_RECTCLIP;
+      stdev->blitstate.extra_passes[1].ConfigGeneral.BLT_CIC &= ~CIC_NODE_CLIP;
+      stdev->blitstate.extra_passes[1].ConfigGeneral.BLT_INS &= ~BLIT_INS_ENABLE_RECTCLIP;
+    }
+#endif
+
+
+  state->mod_hw = 0;
+}
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/gfxdrivers/stgfx2/bdisp_state.h DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/bdisp_state.h
--- DirectFB/gfxdrivers/stgfx2/bdisp_state.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/bdisp_state.h	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,48 @@
+/*
+   ST Microelectronics BDispII driver - state handling
+
+   (c) Copyright 2007/2008  STMicroelectronics Ltd.
+
+   All rights reserved.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#ifndef __BDISP_STATE_H__
+#define __BDISP_STATE_H__
+
+
+#include <directfb.h>
+#include <core/coretypes.h>
+
+
+bool _bdisp_state_set_buffer_type (const STGFX2DeviceData * const stdev,
+                                   u32                    * const reg,
+                                   DFBSurfacePixelFormat   format,
+                                   u16                     pitch);
+
+void bdisp_aq_CheckState (void                * const drv,
+                          void                * const dev,
+                          CardState           * const state,
+                          DFBAccelerationMask  accel);
+
+void bdisp_aq_SetState (void                * const drv,
+                        void                * const dev,
+                        GraphicsDeviceFuncs * const funcs,
+                        CardState           * const state,
+                        DFBAccelerationMask   accel);
+
+#endif /* __BDISP_STATE_H__ */
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/gfxdrivers/stgfx2/bdisp_surface_pool.c DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/bdisp_surface_pool.c
--- DirectFB/gfxdrivers/stgfx2/bdisp_surface_pool.c	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/bdisp_surface_pool.c	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,721 @@
+/*
+   ST Microelectronics BDispII driver - surface pool memory (auxmem)
+
+   (c) Copyright 2009-2010  STMicroelectronics Ltd.
+
+   Written by Andr Draszik <andre.draszik@st.com>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+
+#include <asm/types.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+
+#include <directfb_util.h>
+
+#include <direct/debug.h>
+#include <direct/mem.h>
+
+#include <core/core.h>
+#include <core/gfxcard.h>
+#include <core/surface_pool.h>
+
+#include <gfx/convert.h>
+
+#include <misc/conf.h>
+
+#include "surfacemanager.h"
+
+#if STGFX_DRIVER == 2
+  #include <core/system.h>
+  #include "stm_gfxdriver.h"
+  #include "bdisp_accel.h"
+  typedef struct _STGFX2DriverData STGFXDriverData;
+  typedef struct _STGFX2DeviceData STGFXDeviceData;
+#elif STGFX_DRIVER == 1
+  #include "stgfx.h"
+#else
+  #error unknown stgfx driver version
+#endif
+#include "bdisp_surface_pool.h"
+
+
+D_DEBUG_DOMAIN (BDISP_Surfaces, "BDisp/Surfaces", "BDisp Surface Pool");
+D_DEBUG_DOMAIN (BDISP_SurfLock, "BDisp/SurfLock", "BDisp Surface Pool Locks");
+
+/****************************************************************************/
+
+typedef struct
+{
+  int             magic;
+
+  SurfaceManager *manager;
+
+  unsigned long   part_base;
+  unsigned int    aux_part;
+} BDispSurfacePoolData;
+
+typedef struct
+{
+  int      magic;
+
+  CoreDFB *core;
+  void    *mem;
+} BDispSurfacePoolLocalData;
+
+typedef struct
+{
+  int    magic;
+
+  Chunk *chunk;
+} BDispSurfacePoolAllocationData;
+
+/****************************************************************************/
+
+static int
+bdispPoolDataSize (void)
+{
+  return sizeof (BDispSurfacePoolData);
+}
+
+static int
+bdispPoolLocalDataSize (void)
+{
+  return sizeof (BDispSurfacePoolLocalData);
+}
+
+static int
+bdispAllocationDataSize (void)
+{
+  return sizeof (BDispSurfacePoolAllocationData);
+}
+
+static DFBResult
+bdispLeavePool (CoreSurfacePool *pool,
+                void            *pool_data,
+                void            *pool_local)
+{
+  BDispSurfacePoolData      * const data = pool_data;
+  BDispSurfacePoolLocalData * const local = pool_local;
+
+  D_DEBUG_AT (BDISP_Surfaces, "%s (%d)\n", __FUNCTION__, data->aux_part);
+
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_MAGIC_ASSERT (data, BDispSurfacePoolData);
+  D_MAGIC_ASSERT (local, BDispSurfacePoolLocalData);
+
+  (void) data; /* prevent warning if debug is disabled */
+
+  if (local->mem && local->mem != MAP_FAILED)
+    {
+      munmap (local->mem, pool->desc.size);
+      local->mem = NULL;
+    }
+
+  D_MAGIC_CLEAR (local);
+
+  return DFB_OK;
+}
+
+static DFBResult
+bdispJoinPool (CoreDFB         *core,
+               CoreSurfacePool *pool,
+               void            *pool_data,
+               void            *pool_local,
+               void            *system_data)
+{
+  BDispSurfacePoolData      * const data  = pool_data;
+  BDispSurfacePoolLocalData * const local = pool_local;
+  STGFXDriverData           * const stdrv = dfb_gfxcard_get_driver_data ();
+
+  D_DEBUG_AT (BDISP_Surfaces, "%s (%d)\n", __FUNCTION__, data->aux_part);
+
+  D_ASSERT (core != NULL);
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_MAGIC_ASSERT (data, BDispSurfacePoolData);
+  D_ASSERT (local != NULL);
+
+  D_MAGIC_SET (local, BDispSurfacePoolLocalData);
+
+  local->mem = mmap (NULL, pool->desc.size, PROT_READ | PROT_WRITE,
+                     MAP_SHARED, stdrv->fd, data->part_base);
+  if (local->mem == MAP_FAILED)
+    {
+      D_PERROR ("BDisp/Surfaces: Could not mmap gfx part %d!\n",
+                data->aux_part);
+      return DFB_INIT;
+    }
+
+  local->core = core;
+
+  return DFB_OK;
+}
+
+static DFBResult
+bdispDestroyPool (CoreSurfacePool *pool,
+                  void            *pool_data,
+                  void            *pool_local)
+{
+  BDispSurfacePoolData      * const data  = pool_data;
+  BDispSurfacePoolLocalData * const local = pool_local;
+
+  D_DEBUG_AT (BDISP_Surfaces, "%s (%d)\n", __FUNCTION__, data->aux_part);
+
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_MAGIC_ASSERT (data, BDispSurfacePoolData);
+  D_MAGIC_ASSERT (local, BDispSurfacePoolLocalData);
+
+  (void) local; /* prevent warning if debug is disabled */
+
+  bdispLeavePool (pool, pool_data, pool_local);
+
+  dfb_surfacemanager_destroy (data->manager);
+
+  D_MAGIC_CLEAR (data);
+
+  return DFB_OK;
+}
+
+static DFBResult
+bdispInitPool (CoreDFB                    *core,
+               CoreSurfacePool            *pool,
+               void                       *pool_data,
+               void                       *pool_local,
+               void                       *system_data,
+               CoreSurfacePoolDescription *ret_desc)
+{
+  DFBResult                  ret;
+  BDispSurfacePoolData      * const data  = pool_data;
+  BDispSurfacePoolLocalData * const local = pool_local;
+  STGFXDriverData           * const stdrv = dfb_gfxcard_get_driver_data ();
+  STGFXDeviceData           * const stdev = dfb_gfxcard_get_device_data ();
+  struct stmfbio_auxmem2     auxmem;
+
+  D_DEBUG_AT (BDISP_Surfaces, "%s (%d)\n", __FUNCTION__,
+              stdev->aux_pool_index);
+
+  D_ASSERT (core != NULL);
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_ASSERT (data != NULL);
+  D_ASSERT (local != NULL);
+  D_ASSERT (ret_desc != NULL);
+
+  (void) local; /* prevent warning if debug is disabled */
+
+  D_MAGIC_SET (data, BDispSurfacePoolData);
+
+  auxmem.index = stdev->aux_pool_index;
+
+  snprintf (ret_desc->name, DFB_SURFACE_POOL_DESC_NAME_LENGTH,
+            "BDispII AuxMemory %d", auxmem.index);
+
+  /* query auxmem */
+  if (ioctl (stdrv->fd, STMFBIO_GET_AUXMEMORY2, &auxmem) != 0)
+    return DFB_IO;
+
+  if (!auxmem.size)
+    return DFB_ITEMNOTFOUND;
+
+  D_INFO ("BDisp/Surfaces: found auxmem @ %.8x (%ukB)!\n",
+          auxmem.physical, auxmem.size / 1024);
+  /* auxmem partitions will never cross a 64MB boundary, stmfb should make
+     sure that's the case. And it does in fact :-), which is why we don't need
+     to check for configuration errors. */
+
+  ret = dfb_surfacemanager_create (core, auxmem.size, &data->manager);
+  if (ret)
+    return ret;
+
+  data->aux_part  = auxmem.index;
+  data->part_base = auxmem.physical;
+
+  ret_desc->caps              = CSPCAPS_PHYSICAL | CSPCAPS_VIRTUAL;
+  ret_desc->access[CSAID_CPU] = CSAF_READ | CSAF_WRITE | CSAF_SHARED;
+  ret_desc->access[CSAID_GPU] = CSAF_READ | CSAF_WRITE | CSAF_SHARED;
+  ret_desc->types             = (0
+                                 | CSTF_WINDOW | CSTF_CURSOR | CSTF_FONT
+                                 | CSTF_SHARED | CSTF_EXTERNAL
+                                );
+  ret_desc->priority          = CSPP_PREFERED;
+  ret_desc->size              = auxmem.size;
+
+  /* other accelerators */
+  ret_desc->access[CSAID_ACCEL0] = CSAF_READ | CSAF_WRITE;
+  ret_desc->access[CSAID_ACCEL1] = CSAF_READ | CSAF_WRITE;
+  ret_desc->access[CSAID_ACCEL2] = CSAF_READ | CSAF_WRITE;
+  ret_desc->access[CSAID_ACCEL3] = CSAF_READ | CSAF_WRITE;
+  ret_desc->access[CSAID_ACCEL4] = CSAF_READ | CSAF_WRITE;
+  ret_desc->access[CSAID_ACCEL5] = CSAF_READ | CSAF_WRITE;
+
+#if 0
+  /* FIXME: this depends on the hardware, but we have no interface at the
+     moment anyway... */
+  ret_desc->access[CSAID_LAYER0] = CSAF_READ;
+  ret_desc->access[CSAID_LAYER1] = CSAF_READ;
+  ret_desc->access[CSAID_LAYER2] = CSAF_READ;
+  ret_desc->access[CSAID_LAYER3] = CSAF_READ;
+  ret_desc->access[CSAID_LAYER4] = CSAF_READ;
+  ret_desc->access[CSAID_LAYER5] = CSAF_READ;
+  ret_desc->access[CSAID_LAYER6] = CSAF_READ;
+  ret_desc->access[CSAID_LAYER7] = CSAF_READ;
+  ret_desc->access[CSAID_LAYER8] = CSAF_READ;
+  ret_desc->access[CSAID_LAYER9] = CSAF_READ;
+  ret_desc->access[CSAID_LAYER10] = CSAF_READ;
+  ret_desc->access[CSAID_LAYER11] = CSAF_READ;
+  ret_desc->access[CSAID_LAYER12] = CSAF_READ;
+  ret_desc->access[CSAID_LAYER13] = CSAF_READ;
+  ret_desc->access[CSAID_LAYER14] = CSAF_READ;
+  ret_desc->access[CSAID_LAYER15] = CSAF_READ;
+#endif
+
+  ret = bdispJoinPool (core, pool, pool_data, pool_local, system_data);
+  if (ret)
+    {
+      bdispDestroyPool (pool, pool_data, pool_local);
+      return ret;
+    }
+
+  return DFB_OK;
+}
+
+static DFBResult
+bdispTestConfig (CoreSurfacePool         *pool,
+                 void                    *pool_data,
+                 void                    *pool_local,
+                 CoreSurfaceBuffer       *buffer,
+                 const CoreSurfaceConfig *config)
+{
+  CoreSurface               *surface;
+  BDispSurfacePoolData      * const data  = pool_data;
+  BDispSurfacePoolLocalData * const local = pool_local;
+  DFBResult                  ret;
+
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_MAGIC_ASSERT (data, BDispSurfacePoolData);
+  D_MAGIC_ASSERT (local, BDispSurfacePoolLocalData);
+  D_MAGIC_ASSERT (buffer, CoreSurfaceBuffer);
+  D_ASSERT (config != NULL);
+
+  surface = buffer->surface;
+  D_MAGIC_ASSERT (surface, CoreSurface);
+
+  D_DEBUG_AT (BDISP_Surfaces, "%s (part/buffer/type/id: %u/%p/0x%x/%lu)\n",
+              __FUNCTION__, data->aux_part, buffer,
+              surface->type, surface->resource_id);
+
+  /* FIXME: this depends on the hardware, but we have no interface at the
+     moment anyway... */
+  if (surface->type & CSTF_LAYER)
+    return DFB_BUG;
+
+  ret = dfb_surfacemanager_allocate (local->core, data->manager,
+                                     buffer, NULL, NULL);
+
+  D_DEBUG_AT (BDISP_Surfaces, "  -> %s\n", DirectFBErrorString (ret));
+
+  return ret;
+}
+
+static DFBResult
+bdispAllocateBuffer (CoreSurfacePool       *pool,
+                     void                  *pool_data,
+                     void                  *pool_local,
+                     CoreSurfaceBuffer     *buffer,
+                     CoreSurfaceAllocation *allocation,
+                     void                  *alloc_data)
+{
+  CoreSurface                    *surface;
+  BDispSurfacePoolData           * const data  = pool_data;
+  BDispSurfacePoolLocalData      * const local = pool_local;
+  BDispSurfacePoolAllocationData * const alloc = alloc_data;
+  DFBResult                       ret;
+  Chunk                          *chunk;
+
+  D_DEBUG_AT (BDISP_Surfaces, "%s (%d, %p)\n", __FUNCTION__,
+              data->aux_part, buffer);
+
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_MAGIC_ASSERT (data, BDispSurfacePoolData);
+  D_MAGIC_ASSERT (local, BDispSurfacePoolLocalData);
+  D_MAGIC_ASSERT (buffer, CoreSurfaceBuffer);
+  D_MAGIC_ASSERT (allocation, CoreSurfaceAllocation);
+
+  surface = buffer->surface;
+  D_MAGIC_ASSERT (surface, CoreSurface);
+
+  /* FIXME: this depends on the hardware, but we have no interface at the
+     moment anyway... */
+  if (surface->type & CSTF_LAYER)
+    return DFB_BUG;
+
+  ret = dfb_surfacemanager_allocate (local->core, data->manager, buffer,
+                                     allocation, &chunk);
+  if (ret)
+    return ret;
+
+  D_MAGIC_ASSERT (chunk, Chunk);
+
+  alloc->chunk = chunk;
+
+  D_DEBUG_AT (BDISP_Surfaces,
+              "  -> offset 0x%.8x (%u), format: %s, pitch %d, size %d\n",
+              chunk->offset, chunk->offset,
+              dfb_pixelformat_name (buffer->format), chunk->pitch,
+              chunk->length);
+
+  allocation->size   = chunk->length;
+  allocation->offset = chunk->offset;
+
+#if STGFX_DRIVER == 2
+  if (unlikely (buffer->format == DSPF_RGB32))
+    {
+      /* for RGB32, we need to set the alpha to 0xff */
+      STGFX2DriverData * const stdrv = dfb_gfxcard_get_driver_data ();
+      STGFX2DeviceData * const stdev = dfb_gfxcard_get_device_data ();
+      DFBRectangle      rect = { .x = 0, .y = 0,
+                                 .w = buffer->surface->config.size.w,
+                                 .h = buffer->surface->config.size.h };
+
+      D_WARN ("BDisp/Surfaces: RGB32 support is experimental and slow!");
+      if (dfb_system_type () != CORE_STMFBDEV)
+        D_WARN ("BDisp/Surfaces: RGB32 is only supported in STMfbdev system!");
+
+      D_DEBUG_AT (BDISP_Surfaces, "  -> rgb32 allocation!\n");
+      dfb_gfxcard_lock (GDLF_WAIT);
+
+      _bdisp_aq_RGB32_init (stdrv, stdev,
+                            data->part_base + chunk->offset, chunk->pitch,
+                            &rect);
+      dfb_gfxcard_unlock ();
+    }
+#endif
+
+  D_MAGIC_SET (alloc, BDispSurfacePoolAllocationData);
+
+  return DFB_OK;
+}
+
+static DFBResult
+bdispDeallocateBuffer (CoreSurfacePool       *pool,
+                       void                  *pool_data,
+                       void                  *pool_local,
+                       CoreSurfaceBuffer     *buffer,
+                       CoreSurfaceAllocation *allocation,
+                       void                  *alloc_data)
+{
+  BDispSurfacePoolData            * const data  = pool_data;
+  const BDispSurfacePoolLocalData * const local = pool_local;
+  BDispSurfacePoolAllocationData  * const alloc = alloc_data;
+
+  D_DEBUG_AT (BDISP_Surfaces, "%s (%d, %p)\n", __FUNCTION__,
+              data->aux_part, buffer);
+
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_MAGIC_ASSERT (data, BDispSurfacePoolData);
+  D_MAGIC_ASSERT (local, BDispSurfacePoolLocalData);
+  D_MAGIC_ASSERT (buffer, CoreSurfaceBuffer);
+  D_MAGIC_ASSERT (allocation, CoreSurfaceAllocation);
+  D_MAGIC_ASSERT (alloc, BDispSurfacePoolAllocationData);
+
+  (void) local;
+
+  D_ASSERT (alloc->chunk != NULL);
+  dfb_surfacemanager_deallocate (data->manager, alloc->chunk);
+
+  D_MAGIC_CLEAR (alloc);
+
+  return DFB_OK;
+}
+
+static DFBResult
+bdispMuckOut (CoreSurfacePool   *pool,
+              void              *pool_data,
+              void              *pool_local,
+              CoreSurfaceBuffer *buffer )
+{
+  BDispSurfacePoolData            * const data  = pool_data;
+  const BDispSurfacePoolLocalData * const local = pool_local;
+
+  D_DEBUG_AT (BDISP_Surfaces, "%s (%p)\n", __FUNCTION__, buffer);
+
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_MAGIC_ASSERT (data, BDispSurfacePoolData);
+  D_MAGIC_ASSERT (local, BDispSurfacePoolLocalData);
+  D_MAGIC_ASSERT (buffer, CoreSurfaceBuffer);
+
+  return dfb_surfacemanager_displace (local->core, data->manager, buffer);
+}
+
+static DFBResult
+bdispLock (CoreSurfacePool       *pool,
+           void                  *pool_data,
+           void                  *pool_local,
+           CoreSurfaceAllocation *allocation,
+           void                  *alloc_data,
+           CoreSurfaceBufferLock *lock)
+{
+  const BDispSurfacePoolData           * const data  = pool_data;
+  const BDispSurfacePoolLocalData      * const local = pool_local;
+  const BDispSurfacePoolAllocationData * const alloc = alloc_data;
+  const Chunk                          *chunk;
+
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_MAGIC_ASSERT (data, BDispSurfacePoolData);
+  D_MAGIC_ASSERT (local, BDispSurfacePoolLocalData);
+  D_MAGIC_ASSERT (allocation, CoreSurfaceAllocation);
+  D_MAGIC_ASSERT (alloc, BDispSurfacePoolAllocationData);
+  D_MAGIC_ASSERT (lock, CoreSurfaceBufferLock);
+
+  D_DEBUG_AT (BDISP_SurfLock, "%s (%d, %p)\n", __FUNCTION__,
+              data->aux_part, lock->buffer);
+
+  D_MAGIC_ASSERT (alloc->chunk, Chunk);
+  chunk = alloc->chunk;
+
+  lock->pitch  = chunk->pitch;
+  lock->offset = chunk->offset;
+  lock->addr   = local->mem + chunk->offset;
+  lock->phys   = data->part_base + chunk->offset;
+
+  D_DEBUG_AT (BDISP_SurfLock,
+              "  -> offset 0x%.8lx (%lu), pitch %d, addr %p, phys 0x%.8lx\n",
+              lock->offset, lock->offset, lock->pitch, lock->addr, lock->phys);
+
+  return DFB_OK;
+}
+
+static DFBResult
+bdispUnlock (CoreSurfacePool       *pool,
+             void                  *pool_data,
+             void                  *pool_local,
+             CoreSurfaceAllocation *allocation,
+             void                  *alloc_data,
+             CoreSurfaceBufferLock *lock)
+{
+  const BDispSurfacePoolData           * const data  = pool_data;
+  const BDispSurfacePoolLocalData      * const local = pool_local;
+  const BDispSurfacePoolAllocationData * const alloc = alloc_data;
+
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_MAGIC_ASSERT (data, BDispSurfacePoolData);
+  D_MAGIC_ASSERT (local, BDispSurfacePoolLocalData);
+  D_MAGIC_ASSERT (allocation, CoreSurfaceAllocation);
+  D_MAGIC_ASSERT (alloc, BDispSurfacePoolAllocationData);
+  D_MAGIC_ASSERT (lock, CoreSurfaceBufferLock);
+
+  D_DEBUG_AT (BDISP_SurfLock, "%s (%d, %p)\n", __FUNCTION__,
+              data->aux_part, lock->buffer);
+
+  (void) data;
+  (void) local;
+  (void) alloc;
+
+#if STGFX_DRIVER == 2
+  if (unlikely (lock->buffer->format == DSPF_RGB32
+                && lock->accessor != CSAID_GPU
+                && lock->access & CSAF_WRITE))
+    {
+      /* if a non-GPU accessor did a write access to an RGB32 surface, we
+         should make sure the alpha is forced to 0xff, as the BDisp doesn't
+         support this format natively */
+      STGFX2DriverData * const stdrv = dfb_gfxcard_get_driver_data ();
+      STGFX2DeviceData * const stdev = dfb_gfxcard_get_device_data ();
+      DFBRectangle      rect = { .x = 0, .y = 0,
+                                 .w = lock->buffer->surface->config.size.w,
+                                 .h = lock->buffer->surface->config.size.h };
+
+      D_DEBUG_AT (BDISP_SurfLock, "  -> rgb32 write release!\n");
+      dfb_gfxcard_lock (GDLF_WAIT);
+      _bdisp_aq_RGB32_fixup (stdrv, stdev,
+                             lock->phys, lock->pitch,
+                             &rect);
+      dfb_gfxcard_unlock ();
+    }
+#endif
+
+  return DFB_OK;
+}
+
+static const SurfacePoolFuncs bdispSurfacePoolFuncs = {
+  .PoolDataSize       = bdispPoolDataSize,
+  .PoolLocalDataSize  = bdispPoolLocalDataSize,
+  .AllocationDataSize = bdispAllocationDataSize,
+
+  .InitPool    = bdispInitPool,
+  .JoinPool    = bdispJoinPool,
+  .DestroyPool = bdispDestroyPool,
+  .LeavePool   = bdispLeavePool,
+
+  .TestConfig       = bdispTestConfig,
+  .AllocateBuffer   = bdispAllocateBuffer,
+  .DeallocateBuffer = bdispDeallocateBuffer,
+
+  .MuckOut = bdispMuckOut,
+
+  .Lock   = bdispLock,
+  .Unlock = bdispUnlock,
+};
+
+static inline void
+bdisp_surface_pool_init (CoreDFB          * const core,
+                         CoreSurfacePool ** const aux_pools,
+                         int               max_pools)
+{
+  unsigned long           total_auxmem = 0;
+  STGFXDriverData        * const stdrv = dfb_gfxcard_get_driver_data ();
+  STGFXDeviceData        * const stdev = dfb_gfxcard_get_device_data ();
+  struct stmfbio_auxmem2  auxmem;
+  int                     i;
+
+  D_ASSERT (dfb_core_is_master (core));
+
+  for (i = -1, auxmem.index = 0; auxmem.index < max_pools; ++auxmem.index)
+    {
+      CoreSurfacePool *pool;
+
+      if (ioctl (stdrv->fd, STMFBIO_GET_AUXMEMORY2, &auxmem) != 0)
+        break;
+
+      if (!auxmem.size)
+        continue;
+
+      stdev->aux_pool_index = auxmem.index;
+
+      if (unlikely (dfb_surface_pool_initialize (core,
+                                                 &bdispSurfacePoolFuncs,
+                                                 &pool)))
+        continue;
+
+      aux_pools[++i] = pool;
+      total_auxmem += pool->desc.size;
+    }
+
+  if (total_auxmem)
+    D_INFO ("BDisp/Surfaces: %lukB of auxmem!\n", total_auxmem / 1024);
+  else
+    D_INFO ("BDisp/Surfaces: no auxmem available!\n");
+}
+
+static inline void
+bdisp_surface_pool_destroy (CoreDFB          * const core,
+                            CoreSurfacePool ** const aux_pools,
+                            int               n_pools)
+{
+  int i;
+
+  D_ASSERT (dfb_core_is_master (core));
+
+  for (i = 0; i < n_pools; ++i)
+    {
+      CoreSurfacePool * const pool = aux_pools[i];
+      if (!pool)
+        continue;
+
+      if (unlikely (dfb_surface_pool_destroy (pool)))
+        continue;
+
+      aux_pools[i] = NULL;
+    }
+}
+
+static inline void
+bdisp_surface_pool_join (CoreDFB                 * const core,
+                         CoreSurfacePool * const * const aux_pools,
+                         int                      n_pools)
+{
+  unsigned long total_auxmem = 0;
+  int           i;
+
+  D_ASSERT (!dfb_core_is_master (core));
+
+  for (i = 0; i < n_pools; ++i)
+    {
+      CoreSurfacePool * const pool = aux_pools[i];
+      if (!pool)
+        continue;
+
+      if (unlikely (dfb_surface_pool_join (core, pool,
+                                           &bdispSurfacePoolFuncs)))
+        continue;
+
+      total_auxmem += pool->desc.size;
+    }
+
+  if (total_auxmem)
+    D_INFO ("BDisp/Surfaces: %lukB of auxmem!\n", total_auxmem / 1024);
+  else
+    D_INFO ("BDisp/Surfaces: no auxmem available!\n");
+}
+
+static inline void
+bdisp_surface_pool_leave (CoreDFB                 * const core,
+                          CoreSurfacePool * const * const aux_pools,
+                          int                      n_pools)
+{
+  int i;
+
+  D_ASSERT (!dfb_core_is_master (core));
+
+  for (i = 0; i < n_pools; ++i)
+    {
+      CoreSurfacePool * const pool = aux_pools[i];
+      if (!pool)
+        continue;
+
+      dfb_surface_pool_leave (pool);
+    }
+}
+
+
+#define _bdisp_surface_pool_funcs(v) \
+void \
+stgfx##v##_surface_pool_init (CoreDFB          * const core,  \
+                              CoreSurfacePool ** const pools, \
+                              int               max_pools)    \
+{ \
+  bdisp_surface_pool_init (core, pools, max_pools); \
+} \
+\
+void \
+stgfx##v##_surface_pool_destroy (CoreDFB          * const core,  \
+                                 CoreSurfacePool ** const pools, \
+                                 int               n_pools)      \
+{ \
+  bdisp_surface_pool_destroy (core, pools, n_pools); \
+} \
+\
+void \
+stgfx##v##_surface_pool_join (CoreDFB                 * const core,  \
+                              CoreSurfacePool * const * const pools, \
+                              int                      n_pools)      \
+{ \
+  bdisp_surface_pool_join (core, pools, n_pools); \
+} \
+\
+void \
+stgfx##v##_surface_pool_leave (CoreDFB                 * const core,  \
+                               CoreSurfacePool * const * const pools, \
+                               int                      n_pools)      \
+{ \
+  bdisp_surface_pool_leave (core, pools, n_pools); \
+}
+
+#define bdisp_surface_pool_funcs(driver) _bdisp_surface_pool_funcs(driver)
+
+bdisp_surface_pool_funcs (STGFX_DRIVER);
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/gfxdrivers/stgfx2/bdisp_surface_pool.h DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/bdisp_surface_pool.h
--- DirectFB/gfxdrivers/stgfx2/bdisp_surface_pool.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/bdisp_surface_pool.h	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,62 @@
+/*
+   ST Microelectronics BDispII driver - surface pool memory (auxmem)
+
+   (c) Copyright 2009       STMicroelectronics Ltd.
+
+   Written by Andr Draszik <andre.draszik@st.com>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#ifndef __BDISP_SURFACE_POOL_H__
+#define __BDISP_SURFACE_POOL_H__
+
+#include <core/coretypes.h>
+
+#ifndef STGFX_DRIVER
+#  error Please define STGFX_DRIVER
+#endif
+
+#define _bdisp_surface_pool_funcs(v) \
+extern void \
+stgfx##v##_surface_pool_init (CoreDFB          * const core,  \
+                              CoreSurfacePool ** const pools, \
+                              int               max_pools);   \
+  \
+extern void \
+stgfx##v##_surface_pool_destroy (CoreDFB          * const core,  \
+                                 CoreSurfacePool ** const pools, \
+                                 int               n_pools);     \
+  \
+extern void \
+stgfx##v##_surface_pool_join (CoreDFB                 * const core,  \
+                              CoreSurfacePool * const * const pools, \
+                              int                      n_pools);     \
+  \
+extern void \
+stgfx##v##_surface_pool_leave (CoreDFB                 * const core,  \
+                               CoreSurfacePool * const * const pools, \
+                               int                      n_pools);
+
+#define bdisp_surface_pool_funcs(driver) _bdisp_surface_pool_funcs(driver)
+
+bdisp_surface_pool_funcs (STGFX_DRIVER);
+
+#undef  bdisp_surface_pool_funcs
+#undef _bdisp_surface_pool_funcs
+
+
+#endif /* __BDISP_SURFACE_POOL_H__ */
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/gfxdrivers/stgfx2/bdisp_tables.h DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/bdisp_tables.h
--- DirectFB/gfxdrivers/stgfx2/bdisp_tables.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/bdisp_tables.h	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,333 @@
+/*
+   ST Microelectronics BDispII driver - filters etc.
+
+   (c) Copyright 2007/2008  STMicroelectronics Ltd.
+
+   All rights reserved.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#ifndef __BDISP_TABLES_H__
+#define __BDISP_TABLES_H__
+
+#ifdef __IS_BDISP_ACCEL_C__
+#include "bdisp_accel_types.h"
+
+
+/* 5x8 and 8x8 Filter coefficients for both H & V resize. */
+#define BDISP_AQ_BLIT_FILTER_8X8_TABLE_SIZE   64
+#define BDISP_AQ_BLIT_FILTER_5X8_TABLE_SIZE   40
+
+struct _bdisp_aq_blitfilter_coeffs_range
+{
+  int scale_min; /* 16.16 format */
+  int scale_max; /* 16.16 format */
+};
+
+struct _bdisp_aq_blitfilter_coeffs_8x8
+{
+  struct _bdisp_aq_blitfilter_coeffs_range range;
+  unsigned char filter_coeffs[BDISP_AQ_BLIT_FILTER_8X8_TABLE_SIZE];
+};
+
+struct _bdisp_aq_blitfilter_coeffs_5x8
+{
+  struct _bdisp_aq_blitfilter_coeffs_range range;
+  unsigned char filter_coeffs[BDISP_AQ_BLIT_FILTER_5X8_TABLE_SIZE];
+};
+
+
+static const struct _bdisp_aq_blitfilter_coeffs_8x8 bdisp_aq_blitter_8x8_filters[] =
+{
+  { { 0x00000, 0x0e640 }, // { 0, 921 },
+    { 0x00,  0x00,  0x00,  0x00,  0x40,  0x00,  0x00,  0x00,
+      0x00,  0x00,  0xff,  0x07,  0x3d,  0xfc,  0x01,  0x00,
+      0x00,  0x01,  0xfd,  0x11,  0x36,  0xf9,  0x02,  0x00,
+      0x00,  0x01,  0xfb,  0x1b,  0x2e,  0xf9,  0x02,  0x00,
+      0x00,  0x01,  0xf9,  0x26,  0x26,  0xf9,  0x01,  0x00,
+      0x00,  0x02,  0xf9,  0x30,  0x19,  0xfb,  0x01,  0x00,
+      0x00,  0x02,  0xf9,  0x39,  0x0e,  0xfd,  0x01,  0x00,
+      0x00,  0x01,  0xfc,  0x3e,  0x06,  0xff,  0x00,  0x00 }
+  },
+  { { 0x0e640, 0x10000 }, // { 921, 1024 },
+    { 0x00,  0x00,  0x00,  0x00,  0x40,  0x00,  0x00,  0x00,
+      0xff,  0x03,  0xfd,  0x08,  0x3e,  0xf9,  0x04,  0xfe,
+      0xfd,  0x06,  0xf8,  0x13,  0x3b,  0xf4,  0x07,  0xfc,
+      0xfb,  0x08,  0xf5,  0x1f,  0x34,  0xf1,  0x09,  0xfb,
+      0xfb,  0x09,  0xf2,  0x2b,  0x2a,  0xf1,  0x09,  0xfb,
+      0xfb,  0x09,  0xf2,  0x35,  0x1e,  0xf4,  0x08,  0xfb,
+      0xfc,  0x07,  0xf5,  0x3c,  0x12,  0xf7,  0x06,  0xfd,
+      0xfe,  0x04,  0xfa,  0x3f,  0x07,  0xfc,  0x03,  0xff }
+  },
+  { { 0x10000, 0x11980 }, // { 1024, 1126 },
+    { 0x00,  0x00,  0x00,  0x00,  0x40,  0x00,  0x00,  0x00,
+      0xff,  0x03,  0xfd,  0x08,  0x3e,  0xf9,  0x04,  0xfe,
+      0xfd,  0x06,  0xf8,  0x13,  0x3b,  0xf4,  0x07,  0xfc,
+      0xfb,  0x08,  0xf5,  0x1f,  0x34,  0xf1,  0x09,  0xfb,
+      0xfb,  0x09,  0xf2,  0x2b,  0x2a,  0xf1,  0x09,  0xfb,
+      0xfb,  0x09,  0xf2,  0x35,  0x1e,  0xf4,  0x08,  0xfb,
+      0xfc,  0x07,  0xf5,  0x3c,  0x12,  0xf7,  0x06,  0xfd,
+      0xfe,  0x04,  0xfa,  0x3f,  0x07,  0xfc,  0x03,  0xff }
+  },
+  { { 0x11980, 0x13300 }, // { 1126, 1228 },
+    { 0x00,  0x00,  0x00,  0x00,  0x40,  0x00,  0x00,  0x00,
+      0xff,  0x03,  0xfd,  0x08,  0x3e,  0xf9,  0x04,  0xfe,
+      0xfd,  0x06,  0xf8,  0x13,  0x3b,  0xf4,  0x07,  0xfc,
+      0xfb,  0x08,  0xf5,  0x1f,  0x34,  0xf1,  0x09,  0xfb,
+      0xfb,  0x09,  0xf2,  0x2b,  0x2a,  0xf1,  0x09,  0xfb,
+      0xfb,  0x09,  0xf2,  0x35,  0x1e,  0xf4,  0x08,  0xfb,
+      0xfc,  0x07,  0xf5,  0x3c,  0x12,  0xf7,  0x06,  0xfd,
+      0xfe,  0x04,  0xfa,  0x3f,  0x07,  0xfc,  0x03,  0xff }
+  },
+  { { 0x13300, 0x14cc0 }, // { 1228, 1331 },
+    { 0xfd,  0x04,  0xfc,  0x05,  0x39,  0x05,  0xfc,  0x04,
+      0xfc,  0x06,  0xf9,  0x0c,  0x39,  0xfe,  0x00,  0x02,
+      0xfb,  0x08,  0xf6,  0x17,  0x35,  0xf9,  0x02,  0x00,
+      0xfc,  0x08,  0xf4,  0x20,  0x30,  0xf4,  0x05,  0xff,
+      0xfd,  0x07,  0xf4,  0x29,  0x28,  0xf3,  0x07,  0xfd,
+      0xff,  0x05,  0xf5,  0x31,  0x1f,  0xf3,  0x08,  0xfc,
+      0x00,  0x02,  0xf9,  0x38,  0x14,  0xf6,  0x08,  0xfb,
+      0x02,  0x00,  0xff,  0x3a,  0x0b,  0xf8,  0x06,  0xfc }
+  },
+  { { 0x14cc0, 0x16640 }, // { 1331, 1433 },
+    { 0xfc,  0x06,  0xf9,  0x09,  0x34,  0x09,  0xf9,  0x06,
+      0xfd,  0x07,  0xf7,  0x10,  0x32,  0x02,  0xfc,  0x05,
+      0xfe,  0x07,  0xf6,  0x17,  0x2f,  0xfc,  0xff,  0x04,
+      0xff,  0x06,  0xf5,  0x20,  0x2a,  0xf9,  0x01,  0x02,
+      0x00,  0x04,  0xf6,  0x27,  0x25,  0xf6,  0x04,  0x00,
+      0x02,  0x01,  0xf9,  0x2d,  0x1d,  0xf5,  0x06,  0xff,
+      0x04,  0xff,  0xfd,  0x31,  0x15,  0xf5,  0x07,  0xfe,
+      0x05,  0xfc,  0x02,  0x35,  0x0d,  0xf7,  0x07,  0xfd }
+  },
+  { { 0x16640, 0x18000 }, // { 1433, 1536 },
+    { 0xfe,  0x06,  0xf8,  0x0b,  0x30,  0x0b,  0xf8,  0x06,
+      0xff,  0x06,  0xf7,  0x12,  0x2d,  0x05,  0xfa,  0x06,
+      0x00,  0x04,  0xf6,  0x18,  0x2c,  0x00,  0xfc,  0x06,
+      0x01,  0x02,  0xf7,  0x1f,  0x27,  0xfd,  0xff,  0x04,
+      0x03,  0x00,  0xf9,  0x24,  0x24,  0xf9,  0x00,  0x03,
+      0x04,  0xff,  0xfd,  0x29,  0x1d,  0xf7,  0x02,  0x01,
+      0x06,  0xfc,  0x00,  0x2d,  0x17,  0xf6,  0x04,  0x00,
+      0x06,  0xfa,  0x05,  0x30,  0x0f,  0xf7,  0x06,  0xff }
+  },
+  { { 0x18000, 0x20000 }, // { 1536, 2048 },
+    { 0x05,  0xfd,  0xfb,  0x13,  0x25,  0x13,  0xfb,  0xfd,
+      0x05,  0xfc,  0xfd,  0x17,  0x24,  0x0f,  0xf9,  0xff,
+      0x04,  0xfa,  0xff,  0x1b,  0x24,  0x0b,  0xf9,  0x00,
+      0x03,  0xf9,  0x01,  0x1f,  0x23,  0x08,  0xf8,  0x01,
+      0x02,  0xf9,  0x04,  0x22,  0x20,  0x04,  0xf9,  0x02,
+      0x01,  0xf8,  0x08,  0x25,  0x1d,  0x01,  0xf9,  0x03,
+      0x00,  0xf9,  0x0c,  0x25,  0x1a,  0xfe,  0xfa,  0x04,
+      0xff,  0xf9,  0x10,  0x26,  0x15,  0xfc,  0xfc,  0x05 }
+  },
+  { { 0x20000, 0x30000 }, // { 2048, 3072 },
+    { 0xfc,  0xfd,  0x06,  0x13,  0x18,  0x13,  0x06,  0xfd,
+      0xfc,  0xfe,  0x08,  0x15,  0x17,  0x12,  0x04,  0xfc,
+      0xfb,  0xfe,  0x0a,  0x16,  0x18,  0x10,  0x03,  0xfc,
+      0xfb,  0x00,  0x0b,  0x18,  0x17,  0x0f,  0x01,  0xfb,
+      0xfb,  0x00,  0x0d,  0x19,  0x17,  0x0d,  0x00,  0xfb,
+      0xfb,  0x01,  0x0f,  0x19,  0x16,  0x0b,  0x00,  0xfb,
+      0xfc,  0x03,  0x11,  0x19,  0x15,  0x09,  0xfe,  0xfb,
+      0xfc,  0x04,  0x12,  0x1a,  0x12,  0x08,  0xfe,  0xfc }
+  },
+  { { 0x30000, 0x40000 }, // { 3072, 4096 },
+    { 0xfe,  0x02,  0x09,  0x0f,  0x0e,  0x0f,  0x09,  0x02,
+      0xff,  0x02,  0x09,  0x0f,  0x10,  0x0e,  0x08,  0x01,
+      0xff,  0x03,  0x0a,  0x10,  0x10,  0x0d,  0x07,  0x00,
+      0x00,  0x04,  0x0b,  0x10,  0x0f,  0x0c,  0x06,  0x00,
+      0x00,  0x05,  0x0c,  0x10,  0x0e,  0x0c,  0x05,  0x00,
+      0x00,  0x06,  0x0c,  0x11,  0x0e,  0x0b,  0x04,  0x00,
+      0x00,  0x07,  0x0d,  0x11,  0x0f,  0x0a,  0x03,  0xff,
+      0x01,  0x08,  0x0e,  0x11,  0x0e,  0x09,  0x02,  0xff }
+  },
+  { { 0x40000, 0x50000 }, // { 4096, 5120 },
+    { 0x00,  0x04,  0x09,  0x0c,  0x0e,  0x0c,  0x09,  0x04,
+      0x01,  0x05,  0x09,  0x0c,  0x0d,  0x0c,  0x08,  0x04,
+      0x01,  0x05,  0x0a,  0x0c,  0x0e,  0x0b,  0x08,  0x03,
+      0x02,  0x06,  0x0a,  0x0d,  0x0c,  0x0b,  0x07,  0x03,
+      0x02,  0x07,  0x0a,  0x0d,  0x0d,  0x0a,  0x07,  0x02,
+      0x03,  0x07,  0x0b,  0x0d,  0x0c,  0x0a,  0x06,  0x02,
+      0x03,  0x08,  0x0b,  0x0d,  0x0d,  0x0a,  0x05,  0x01,
+      0x04,  0x08,  0x0c,  0x0d,  0x0c,  0x09,  0x05,  0x01 }
+  },
+  { { 0x50000, 0x60000 }, // { 5120, 6144 },
+    { 0x03,  0x06,  0x09,  0x0b,  0x09,  0x0b,  0x09,  0x06,
+      0x03,  0x06,  0x09,  0x0b,  0x0c,  0x0a,  0x08,  0x05,
+      0x03,  0x06,  0x09,  0x0b,  0x0c,  0x0a,  0x08,  0x05,
+      0x04,  0x07,  0x09,  0x0b,  0x0b,  0x0a,  0x08,  0x04,
+      0x04,  0x07,  0x0a,  0x0b,  0x0b,  0x0a,  0x07,  0x04,
+      0x04,  0x08,  0x0a,  0x0b,  0x0b,  0x09,  0x07,  0x04,
+      0x05,  0x08,  0x0a,  0x0b,  0x0c,  0x09,  0x06,  0x03,
+      0x05,  0x08,  0x0a,  0x0b,  0x0c,  0x09,  0x06,  0x03 }
+  }
+};
+
+static const struct _bdisp_aq_blitfilter_coeffs_5x8 bdisp_aq_blitter_5x8_filters[] =
+{
+#if 0
+  { { 0x00000, 0x0e640 }, // { 0, 921 },
+    { 0x00,  0x00,  0x40,  0x00,  0x00, /*  0.000000  0.000000 1.000000  0.000000 0.000000 */
+      0x00,  0x05,  0x3d,  0xfe,  0x00, /*  0.000000  0.078125 0.953125 -0.031250 0.000000 */
+      0x00,  0x0d,  0x36,  0xfd,  0x00, /*  0.000000  0.203125 0.843750 -0.046875 0.000000 */
+      0xff,  0x17,  0x2d,  0xfd,  0x00, /* -0.015625  0.359375 0.703125 -0.046875 0.000000 */
+      0xfe,  0x23,  0x21,  0xfe,  0x00, /* -0.031250  0.546875 0.515625 -0.031250 0.000000 */
+      0xfd,  0x2e,  0x16,  0xff,  0x00, /* -0.046875  0.718750 0.343750 -0.015625 0.000000 */
+      0xfd,  0x37,  0x0c,  0x00,  0x00, /* -0.046875  0.859375 0.187500  0.000000 0.000000 */
+      0xfe,  0x3e,  0x04,  0x00,  0x00  /* -0.031250  0.968750 0.062500  0.000000 0.000000 */ }
+  },
+  { { 0x0e640, 0x13300 }, // { 921, 1228 },
+    { 0x00,  0x00,  0x40,  0x00,  0x00, /*  0.000000  0.000000 1.000000  0.000000 0.000000 */
+      0xfd,  0x09,  0x3c,  0xfa,  0x04, /* -0.046875  0.140625 0.937500 -0.093750 0.062500 */
+      0xf9,  0x13,  0x39,  0xf5,  0x06, /* -0.109375  0.296875 0.890625 -0.171875 0.093750 */
+      0xf5,  0x1f,  0x31,  0xf3,  0x08, /* -0.171875  0.484375 0.765625 -0.203125 0.125000 */
+      0xf3,  0x2a,  0x28,  0xf3,  0x08, /* -0.203125  0.656250 0.625000 -0.203125 0.125000 */
+      0xf3,  0x34,  0x1d,  0xf5,  0x07, /* -0.203125  0.812500 0.453125 -0.171875 0.109375 */
+      0xf5,  0x3b,  0x12,  0xf9,  0x05, /* -0.171875  0.921875 0.281250 -0.109375 0.078125 */
+      0xfa,  0x3f,  0x07,  0xfd,  0x03  /* -0.093750  0.984375 0.109375 -0.046875 0.046875 */ }
+  },
+  { { 0x13300, 0x14cc0 }, // { 1228, 1331 },
+#else
+  { { 0x00000, 0x10000 }, // { 0, 1024 },
+    /* bicubic */
+    { 0x00,  0x00,  0x40,  0x00,  0x00, /*  0.000000  0.000000 1.000000  0.000000 0.000000 */
+      0x00,  0x06,  0x3d,  0xfd,  0x00, /*  0.000000  0.093750 0.953125 -0.046875 0.000000 */
+      0xfe,  0x0f,  0x38,  0xfb,  0x00,
+      0xfd,  0x19,  0x2f,  0xfb,  0x00,
+      0xfc,  0x24,  0x24,  0xfc,  0x00,
+      0xfb,  0x2f,  0x19,  0xfd,  0x00,
+      0xfb,  0x38,  0x0f,  0xfe,  0x00,
+      0xfd,  0x3d,  0x06,  0x00,  0x00 }
+  },
+  { { 0x10000, 0x14cc0 }, // { 1024, 1331 },
+#endif
+    { 0xfc,  0x05,  0x3e,  0x05,  0xfc,
+      0xf8,  0x0e,  0x3b,  0xff,  0x00,
+      0xf5,  0x18,  0x38,  0xf9,  0x02,
+      0xf4,  0x21,  0x31,  0xf5,  0x05,
+      0xf4,  0x2a,  0x27,  0xf4,  0x07,
+      0xf6,  0x30,  0x1e,  0xf4,  0x08,
+      0xf9,  0x35,  0x15,  0xf6,  0x07,
+      0xff,  0x37,  0x0b,  0xf9,  0x06 }
+  },
+  { { 0x14cc0, 0x16640 }, // { 1331, 1433 },
+    { 0xf8,  0x0a,  0x3c,  0x0a,  0xf8,
+      0xf6,  0x12,  0x3b,  0x02,  0xfb,
+      0xf4,  0x1b,  0x35,  0xfd,  0xff,
+      0xf4,  0x23,  0x30,  0xf8,  0x01,
+      0xf6,  0x29,  0x27,  0xf6,  0x04,
+      0xf9,  0x2e,  0x1e,  0xf5,  0x06,
+      0xfd,  0x31,  0x16,  0xf6,  0x06,
+      0x02,  0x32,  0x0d,  0xf8,  0x07 }
+  },
+  { { 0x16640, 0x18000 }, // { 1433, 1536 },
+    { 0xf6,  0x0e,  0x38,  0x0e,  0xf6,
+      0xf5,  0x15,  0x38,  0x06,  0xf8,
+      0xf5,  0x1d,  0x33,  0x00,  0xfb,
+      0xf6,  0x23,  0x2d,  0xfc,  0xfe,
+      0xf9,  0x28,  0x26,  0xf9,  0x00,
+      0xfc,  0x2c,  0x1e,  0xf7,  0x03,
+      0x00,  0x2e,  0x18,  0xf6,  0x04,
+      0x05,  0x2e,  0x11,  0xf7,  0x05 }
+  },
+  { { 0x18000, 0x20000 }, // { 1536, 2048 },
+    { 0xfb,  0x13,  0x24,  0x13,  0xfb,
+      0xfd,  0x17,  0x23,  0x0f,  0xfa,
+      0xff,  0x1a,  0x23,  0x0b,  0xf9,
+      0x01,  0x1d,  0x22,  0x07,  0xf9,
+      0x04,  0x20,  0x1f,  0x04,  0xf9,
+      0x07,  0x22,  0x1c,  0x01,  0xfa,
+      0x0b,  0x24,  0x17,  0xff,  0xfb,
+      0x0f,  0x24,  0x14,  0xfd,  0xfc }
+  },
+  { { 0x20000, 0x30000 }, // { 2048, 3072 },
+    { 0x05,  0x10,  0x16,  0x10,  0x05,
+      0x06,  0x11,  0x16,  0x0f,  0x04,
+      0x08,  0x13,  0x15,  0x0e,  0x02,
+      0x09,  0x14,  0x16,  0x0c,  0x01,
+      0x0b,  0x15,  0x15,  0x0b,  0x00,
+      0x0d,  0x16,  0x13,  0x0a,  0x00,
+      0x0f,  0x17,  0x13,  0x08,  0xff,
+      0x11,  0x18,  0x12,  0x07,  0xfe }
+  },
+  { { 0x30000, 0x40000 }, // { 3072, 4096 },
+    { 0x09,  0x0f,  0x10,  0x0f,  0x09,
+      0x09,  0x0f,  0x12,  0x0e,  0x08,
+      0x0a,  0x10,  0x11,  0x0e,  0x07,
+      0x0b,  0x11,  0x11,  0x0d,  0x06,
+      0x0c,  0x11,  0x12,  0x0c,  0x05,
+      0x0d,  0x12,  0x11,  0x0c,  0x04,
+      0x0e,  0x12,  0x11,  0x0b,  0x04,
+      0x0f,  0x13,  0x11,  0x0a,  0x03 }
+  },
+  { { 0x40000, 0x50000 }, // { 4096, 5120 },
+    { 0x0a,  0x0e,  0x10,  0x0e,  0x0a,
+      0x0b,  0x0e,  0x0f,  0x0e,  0x0a,
+      0x0b,  0x0f,  0x10,  0x0d,  0x09,
+      0x0c,  0x0f,  0x10,  0x0d,  0x08,
+      0x0d,  0x0f,  0x0f,  0x0d,  0x08,
+      0x0d,  0x10,  0x10,  0x0c,  0x07,
+      0x0e,  0x10,  0x0f,  0x0c,  0x07,
+      0x0f,  0x10,  0x10,  0x0b,  0x06 }
+  },
+  { { 0x50000, 0x60000 }, // { 5120, 6144 },
+    { 0x0b,  0x0e,  0x0e,  0x0e,  0x0b,
+      0x0b,  0x0e,  0x0f,  0x0d,  0x0b,
+      0x0c,  0x0e,  0x0f,  0x0d,  0x0a,
+      0x0c,  0x0e,  0x0f,  0x0d,  0x0a,
+      0x0d,  0x0f,  0x0e,  0x0d,  0x09,
+      0x0d,  0x0f,  0x0f,  0x0c,  0x09,
+      0x0e,  0x0f,  0x0e,  0x0c,  0x09,
+      0x0e,  0x0f,  0x0f,  0x0c,  0x08 }
+  }
+};
+
+
+/* These magic numbers define a good filter */
+static const struct _BltNodeGroup11 bdisp_aq_config_flicker_filter =
+{
+  .BLT_FF0 = 0x04008000,
+  .BLT_FF1 = 0x06106010,
+  .BLT_FF2 = 0x08185018,
+  .BLT_FF3 = 0x00204020
+};
+
+
+const u32 bdisp_aq_VideoYCbCr601_2_RGB[4] = { 0x2c440000, 0xe9a403aa, 0x0004013f, 0x34f21322 };
+static const u32 bdisp_aq_GfxYCbCr601_2_RGB[4]   = { 0x3324a800, 0xe604ab9c, 0x0004a957, 0x32121eeb };
+static const u32 bdisp_aq_VideoYCbCr709_2_RGB[4] = { 0x31440000, 0xf16403d1, 0x00040145, 0x33b14b18 };
+static const u32 bdisp_aq_GfxYCbCr709_2_RGB[4]   = { 0x3964a800, 0xef04abc9, 0x0004a95f, 0x307132df };
+
+const u32 bdisp_aq_RGB_2_VideoYCbCr601[4] = { 0x107e4beb, 0x0982581d, 0xfa9ea483, 0x08000080 };
+static const u32 bdisp_aq_RGB_2_GfxYCbCr601[4]   = { 0x0e1e8bee, 0x08420419, 0xfb5ed471, 0x08004080 };
+static const u32 bdisp_aq_RGB_2_VideoYCbCr709[4] = { 0x107e27f4, 0x06e2dc13, 0xfc5e6c83, 0x08000080 };
+static const u32 bdisp_aq_RGB_2_GfxYCbCr709[4]   = { 0x0e3e6bf5, 0x05e27410, 0xfcdea471, 0x08004080 };
+
+static const u32 bdisp_aq_YCbCr601_2_YCbCr709[4] = { 0x20c00013, 0xf94403e2, 0x03a00102, 0x3f30abef };
+#else /* __IS_BDISP_ACCEL_C__ */
+extern const u32 bdisp_aq_VideoYCbCr601_2_RGB[4];
+//extern const u32 bdisp_aq_GfxYCbCr601_2_RGB[4];
+//extern const u32 bdisp_aq_VideoYCbCr709_2_RGB[4];
+//extern const u32 bdisp_aq_GfxYCbCr709_2_RGB[4];
+
+extern const u32 bdisp_aq_RGB_2_VideoYCbCr601[4];
+//extern const u32 bdisp_aq_RGB_2_GfxYCbCr601[4];
+//extern const u32 bdisp_aq_RGB_2_VideoYCbCr709[4];
+//extern const u32 bdisp_aq_RGB_2_GfxYCbCr709[4];
+
+//extern const u32 bdisp_aq_YCbCr601_2_YCbCr709[4];
+#endif /* __IS_BDISP_ACCEL_C__ */
+
+#endif /* __BDISP_TABLES_H__ */
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/gfxdrivers/stgfx2/Makefile.am DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/Makefile.am
--- DirectFB/gfxdrivers/stgfx2/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/Makefile.am	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,68 @@
+## Makefile.am for DirectFB/gfxdrivers/stgfx2
+
+INCLUDES = \
+	-I$(top_builddir)/include \
+	-I$(top_builddir)/lib   \
+	-I$(top_srcdir)/include \
+	-I$(top_srcdir)/lib     \
+	-I$(top_srcdir)/src	\
+	-I$(top_srcdir)/systems
+
+AM_CPPFLAGS = -DSTGFX_DRIVER=2
+
+internalincludedir = $(INTERNALINCLUDEDIR)/stgfx2
+internalinclude_HEADERS = \
+	bdisp_accel.h
+
+stgfx2_LTLIBRARIES = libdirectfb_stgfx2.la
+
+if BUILD_STATIC
+stgfx2_DATA = $(stgfx2_LTLIBRARIES:.la=.o)
+endif
+
+stgfx2dir = $(MODULEDIR)/gfxdrivers
+
+libdirectfb_stgfx2_la_SOURCES =	\
+	stgfx2_features.h	\
+	stm_types.h		\
+	\
+	stm_gfxdriver.c		\
+	stm_gfxdriver.h		\
+	\
+	bdisp_registers.h	\
+	bdisp_tables.h		\
+	bdisp_features.h	\
+	bdisp_features.c	\
+	bdisp_state.c		\
+	bdisp_state.h		\
+	bdisp_accel.c		\
+	bdisp_accel.h		\
+	bdisp_accel_types.h	\
+	\
+	stmfbdev_screen.c	\
+	stmfbdev_layer.c	\
+	\
+	surfacemanager.c	\
+	surfacemanager.h	\
+	stmfbdev_surface_pool.c	\
+	bdisp_surface_pool.c	\
+	bdisp_surface_pool.h	\
+	\
+	stgfx_screen.c		\
+	stgfx_screen.h		\
+	stgfx_primary.c		\
+	stgfx_primary.h
+
+libdirectfb_stgfx2_la_LDFLAGS = \
+	-module			\
+	-avoid-version		\
+	-export-symbols-regex bdisp_aq_StretchBlit_RLE	\
+	$(DFB_LDFLAGS)
+
+libdirectfb_stgfx2_la_LIBADD = \
+	-lrt \
+	$(top_builddir)/lib/direct/libdirect.la \
+	$(top_builddir)/src/libdirectfb.la
+
+
+include $(top_srcdir)/rules/libobject.make
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/gfxdrivers/stgfx2/stgfx2_features.h DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/stgfx2_features.h
--- DirectFB/gfxdrivers/stgfx2/stgfx2_features.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/stgfx2_features.h	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,144 @@
+/*
+   ST Microelectronics BDispII driver - features of the driver
+
+   (c) Copyright 2008       STMicroelectronics Ltd.
+
+   All rights reserved.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#ifndef __STGFX2_FEATURES_H__
+#define __STGFX2_FEATURES_H__
+
+
+/**************************** performance flags *****************************/
+/* GraphicsDeviceFuncs::GetSerial() and  GraphicsDeviceFuncs::WaitSerial
+   give DirectFB some more fine grained control around flipping, which is
+   useful in windowing environments.
+   Unfortunately, CPU usage in the stretch blit tests in df_dok goes up from
+   sth around 2-3% to > 60% when using a size of 512x512.
+   Also, at the moment this is not correctly implemented for multiple
+   independent DirectFB instances (on different framebuffers), so disabled
+   for now! */
+#undef STGFX2_IMPLEMENT_WAITSERIAL
+
+
+/* use bsearch() when trying to figure out the filter table's base address
+   we need to use when scaling (instead of iterating over the list).
+   Seems to be faster. */
+#define STGFX2_USE_BSEARCH
+
+
+/***************************** some debug/stats *****************************/
+/* define to measure the blitter load. Only makes sense if stmfb
+   framebuffer driver's STMCommon/stmbdispaq.cpp was compiled with
+   STM_BDISP_MEASURE_BLITLOAD #define'd (see top of that file), too.
+
+   Necessary, if you want df_bltload to display something useful! */
+#define STGFX2_MEASURE_BLITLOAD
+
+
+/* should we printf() the time we had to wait for an entry in the nodelist
+   to be available? */
+#undef STGFX2_PRINT_NODE_WAIT_TIME
+
+
+/* should we printf() all the CheckState and SetState operations? */
+#undef STGFX2_DUMP_CHECK_STATE
+#undef STGFX2_DUMP_CHECK_STATE_FAILED
+#undef STGFX2_DUMP_SET_STATE
+
+
+/************************** implementation details **************************/
+/* the following are basically implementation details of this driver and you
+   should not need to touch them. */
+#define STGFX2_VALID_DRAWINGFLAGS (0                        \
+                                   | DSDRAW_BLEND           \
+                                   | DSDRAW_XOR             \
+                                   | DSDRAW_SRC_PREMULTIPLY \
+                                  )
+
+/* we used to accelerate DRAWLINE just for being able to draw horizontal
+   and vertical lines in hardware, which is what happens in a
+   cairo/gtk/webkit environment. But nowadays DirectFB is intelligent enough
+   to draw rectangles instead in this case, so that code was removed. */
+#define STGFX2_VALID_DRAWINGFUNCTIONS (0 \
+                                       | DFXL_FILLRECTANGLE \
+                                       | DFXL_DRAWRECTANGLE \
+                                      )
+
+#define STGFX2_VALID_BLITTINGFLAGS (0                            \
+                                    | DSBLIT_INDEX_TRANSLATION   \
+                                    | DSBLIT_SRC_COLORKEY        \
+                                    | DSBLIT_BLEND_COLORALPHA    \
+                                    | DSBLIT_BLEND_ALPHACHANNEL  \
+                                    | DSBLIT_SRC_PREMULTIPLY     \
+                                    | DSBLIT_XOR                 \
+                                    | DSBLIT_COLORIZE            \
+                                    | DSBLIT_SRC_PREMULTCOLOR    \
+                                    \
+                                    | DSBLIT_SOURCE2             \
+                                    \
+                                    | DSBLIT_FIXEDPOINT          \
+                                    \
+                                    | DSBLIT_ROTATE180           \
+                                    | DSBLIT_FLIP_HORIZONTAL     \
+                                    | DSBLIT_FLIP_VERTICAL       \
+                                   )
+
+#define STGFX2_VALID_BLITTINGFUNCTIONS (DFXL_BLIT \
+                                        | DFXL_STRETCHBLIT \
+                                        | DFXL_BLIT2)
+
+/* we always interpolate stretch blits */
+#define STGFX2_VALID_RENDEROPTS (0                        \
+                                 | DSRO_SMOOTH_UPSCALE    \
+                                 | DSRO_SMOOTH_DOWNSCALE  \
+                                 | DSRO_MATRIX            \
+                                )
+
+/* We can support DirectFB's DSRO_SMOOTH_UPSCALE | DSRO_SMOOTH_DOWNSCALE render
+   options.
+   As this is a (relatively) new flag in DirectFB, we used to behave as if it
+   was set to give best image quality.
+   Now if we honor this flag applications will actually have to specify whether
+   or not they want good looking rescales, which is a major change in default
+   behaviour and as such can be tweaked.
+
+   Non-smooth rescale is not well tested and therefore disabled. */
+#define STGFX2_FORCE_SMOOTH_SCALE
+
+/* Do we want clipping to be done in hardware? This is needed for better
+   looking stretch blit support (at the edges) but it can significantly
+   increase CPU and blitter usage because operations are still executed,
+   just the result is not written.
+   On current SoCs this might also lead to the BDisp accessing memory beyond
+   a 64MB bank boundary, thus this should never be enabled! */
+#undef STGFX2_SUPPORT_HW_CLIPPING
+
+/* If this is defined, the CLUT will be uploaded only once into the BDisp
+   and will be assumed not to change anytime after outside our control.
+   So if multiple applications using different CLUTs on different BDisp AQs
+   are active (or if somebody is using the kernel interface in parallel) the
+   CLUT feature will not work correctly. This feature is therefore disabled
+   by default. In earlier versions of this driver we gained a little
+   performance increase, but this is not the case anymore, so there's no
+   point in enabling this option... */
+#undef STGFX2_CLUT_UNSAFE_MULTISESSION
+
+
+#endif /* __STGFX2_FEATURES_H__ */
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/gfxdrivers/stgfx2/stgfx_primary.c DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/stgfx_primary.c
--- DirectFB/gfxdrivers/stgfx2/stgfx_primary.c	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/stgfx_primary.c	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,533 @@
+/*
+   ST Microelectronics BDispII driver - primary layer implementation
+
+   (c) Copyright 2007,2009-2010  STMicroelectronics Ltd.
+   (c) Copyright 2000-2002       convergence integrated media GmbH.
+   (c) Copyright 2002            convergence GmbH.
+
+   All rights reserved.
+
+   Based on the cle266 driver implementation:
+
+   Written by Denis Oliver Kropp <dok@directfb.org>,
+              Andreas Hundt <andi@fischlustig.de> and
+              Sven Neumann <sven@convergence.de>.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+
+#include <string.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <sys/ioctl.h>
+
+#include <linux/fb.h>
+#include <linux/stmfb.h>
+
+#include <directfb.h>
+
+#include <core/layers.h>
+#include <core/system.h>
+#include <direct/debug.h>
+#include <misc/conf.h>
+#include <gfx/convert.h>
+
+#if STGFX_DRIVER == 2
+  #include "stm_gfxdriver.h"
+  typedef struct _STGFX2DriverData STGFXDriverData;
+#elif STGFX_DRIVER == 1
+  #include "stgfx.h"
+#else
+  #error unknown stgfx driver version
+#endif
+#include "stgfx_primary.h"
+
+
+D_DEBUG_DOMAIN (STGFX_Primary, "STGFX/Primary", "STM Primary (hook)");
+
+
+typedef struct {
+  u32                     originalVarCaps;
+  DFBDisplayLayerOptions  supported_options;
+  DFBColorAdjustmentFlags supported_adjustments;
+} STGFXPrimarySharedData;
+
+
+static int
+stgfxPrimaryLayerDataSize (void)
+{
+  D_DEBUG_AT (STGFX_Primary, "%s (%u)\n",
+              __FUNCTION__, sizeof (STGFXPrimarySharedData));
+
+  return sizeof (STGFXPrimarySharedData);
+}
+
+
+static DFBResult
+stgfxPrimaryInitLayer (CoreLayer                  *layer,
+                       void                       *driver_data,
+                       void                       *layer_data,
+                       DFBDisplayLayerDescription *description,
+                       DFBDisplayLayerConfig      *config,
+                       DFBColorAdjustment         *adjustment)
+{
+  STGFXDriverData        * const drv = driver_data;
+  STGFXPrimarySharedData * const shd = layer_data;
+  DFBResult               ret;
+
+  D_DEBUG_AT (STGFX_Primary, "%s\n", __FUNCTION__);
+
+  D_ASSERT (dfb_system_type() == CORE_FBDEV);
+
+  /* call the original initialization function first */
+  ret = drv->layerData.orig_funcs.InitLayer (layer,
+                                             drv->layerData.orig_data,
+                                             layer_data, description,
+                                             config, adjustment);
+  if (ret)
+    return ret;
+
+  /*
+   * Note we cannot use dfb_layer_id_translated because it requires state that
+   * will not be setup until this hook has completed.
+   */
+  drv->layerData.startup_var.layerid = dfb_config->primary_layer;
+
+  if (ioctl (drv->fd,
+             STMFBIO_GET_VAR_SCREENINFO_EX, &drv->layerData.startup_var) < 0)
+  {
+    /*
+     * We have a framebuffer driver that doesn't support the extended var
+     * stuff, so ignore it, it will be as if we are a dumb framebuffer.
+     */
+    drv->layerData.startup_var.caps = STMFBIO_VAR_CAPS_NONE;
+    shd->originalVarCaps            = STMFBIO_VAR_CAPS_NONE;
+    return DFB_OK;
+  }
+
+  /* Duplicate originalVar.caps into Shared Memory for Fusion Slaves. */
+  shd->originalVarCaps = drv->layerData.startup_var.caps;
+
+  D_DEBUG ("DirectFB/gfxdrivers/stgfx_primary: got extended var caps: 0x%08x\n",
+           shd->originalVarCaps);
+
+  /* set name */
+  snprintf (description->name,
+            DFB_DISPLAY_LAYER_DESC_NAME_LENGTH, "STM Graphics Plane");
+
+  shd->supported_options     = DLOP_NONE;
+  shd->supported_adjustments = DCAF_NONE;
+
+  /* add support alphachannel, we always do this */
+  config->flags          |= DLCONF_OPTIONS;
+  config->options         = DLOP_ALPHACHANNEL;
+  shd->supported_options  = DLOP_ALPHACHANNEL;
+  description->caps      |= DLCAPS_ALPHACHANNEL;
+
+  if (drv->layerData.startup_var.caps & STMFBIO_VAR_CAPS_COLOURKEY)
+    {
+      D_DEBUG ("DirectFB/gfxdrivers/stgfx_primary: supports src colourkey\n");
+      shd->supported_options |= DLOP_SRC_COLORKEY;
+      description->caps      |= DLCAPS_SRC_COLORKEY;
+    }
+
+  if (drv->layerData.startup_var.caps & STMFBIO_VAR_CAPS_FLICKER_FILTER)
+    {
+      D_DEBUG ("DirectFB/gfxdrivers/stgfx_primary: supports flicker filtering\n");
+      shd->supported_options |= DLOP_FLICKER_FILTERING;
+      description->caps      |= DLCAPS_FLICKER_FILTERING;
+    }
+
+  if (drv->layerData.startup_var.caps & STMFBIO_VAR_CAPS_PREMULTIPLIED)
+    {
+      D_DEBUG ("DirectFB/gfxdrivers/stgfx_primary: supports pre-multiplied alpha\n");
+      config->flags        |= DLCONF_SURFACE_CAPS;
+      config->surface_caps  = DSCAPS_PREMULTIPLIED;
+      description->caps    |= DLCAPS_PREMULTIPLIED;
+    }
+
+  if (drv->layerData.startup_var.caps & STMFBIO_VAR_CAPS_OPACITY)
+    {
+      D_DEBUG ("DirectFB/gfxdrivers/stgfx_primary: supports opacity\n");
+      config->options        |= DLOP_OPACITY;
+      /* Strangely we cannot specify the default layer opacity, lets hope its
+         fully opaque! */
+      shd->supported_options |= DLOP_OPACITY;
+      description->caps      |= DLCAPS_OPACITY;
+    }
+
+  /* clear the adjustments added by the fbdev system, we can't support the
+     gamma ramp approach, so override with the plane capabilities instead. */
+  adjustment->flags = 0;
+
+  if (drv->layerData.startup_var.caps & (STMFBIO_VAR_CAPS_GAIN
+                                         | STMFBIO_VAR_CAPS_BRIGHTNESS))
+    {
+      D_DEBUG ("DirectFB/gfxdrivers/stgfx_primary: supports gain/brightness adjustment\n");
+      shd->supported_adjustments |= DCAF_BRIGHTNESS;
+      adjustment->flags          |= DCAF_BRIGHTNESS;
+      adjustment->brightness      = 0x8000;
+      description->caps          |= DLCAPS_BRIGHTNESS;
+    }
+  else
+    {
+      adjustment->flags &= ~DCAF_BRIGHTNESS;
+      description->caps &= ~DLCAPS_BRIGHTNESS;
+    }
+
+  if (drv->layerData.startup_var.caps & STMFBIO_VAR_CAPS_CONTRAST)
+    {
+      D_DEBUG ("DirectFB/gfxdrivers/stgfx_primary: supports contrast adjustment\n");
+      shd->supported_adjustments |= DCAF_CONTRAST;
+      adjustment->flags          |= DCAF_CONTRAST;
+      adjustment->contrast        = 0x8000;
+      description->caps          |= DLCAPS_CONTRAST;
+    }
+  else
+    {
+      adjustment->flags &= ~DCAF_CONTRAST;
+      description->caps &= ~DLCAPS_CONTRAST;
+    }
+
+  if (drv->layerData.startup_var.caps & STMFBIO_VAR_CAPS_TINT)
+    {
+      D_DEBUG ("DirectFB/gfxdrivers/stgfx_primary: supports tint adjustment\n");
+      shd->supported_adjustments |= DCAF_HUE;
+      adjustment->flags          |= DCAF_HUE;
+      adjustment->hue             = 0x8000;
+      description->caps          |= DLCAPS_HUE;
+    }
+  else
+    {
+      adjustment->flags &= ~DCAF_HUE;
+      description->caps &= ~DLCAPS_HUE;
+    }
+
+  if (drv->layerData.startup_var.caps & STMFBIO_VAR_CAPS_SATURATION)
+    {
+      D_DEBUG ("DirectFB/gfxdrivers/stgfx_primary: supports saturation adjustment\n");
+      shd->supported_adjustments |= DCAF_SATURATION;
+      adjustment->flags          |= DCAF_SATURATION;
+      adjustment->saturation      = 0x8000;
+      description->caps          |= DLCAPS_SATURATION;
+    }
+  else
+    {
+      adjustment->flags &= ~DCAF_SATURATION;
+      description->caps &= ~DLCAPS_SATURATION;
+    }
+
+  if (drv->layerData.startup_var.caps & STMFBIO_VAR_CAPS_ALPHA_RAMP)
+    {
+      D_DEBUG ("DirectFB/gfxdrivers/stgfx_primary: supports RGB1555 alpha ramp\n");
+      description->caps |= DLCAPS_ALPHA_RAMP;
+    }
+
+  if (drv->layerData.startup_var.caps & STMFBIO_VAR_CAPS_ZPOSITION)
+    {
+      D_DEBUG ("DirectFB/gfxdrivers/stgfx_primary: supports plane re-ordering\n");
+      description->caps |= DLCAPS_LEVELS;
+      description->level = drv->layerData.startup_var.z_position;
+    }
+
+  return DFB_OK;
+}
+
+static DFBResult
+stgfxPrimaryShutdownLayer (CoreLayer *layer,
+                           void      *driver_data,
+                           void      *layer_data)
+{
+  STGFXDriverData * const drv = driver_data;
+
+  /* try and restore the framebuffer's extended state. */
+  drv->layerData.startup_var.activate = STMFBIO_ACTIVATE_IMMEDIATE;
+  if (ioctl (drv->fd,
+             STMFBIO_SET_VAR_SCREENINFO_EX, &drv->layerData.startup_var) < 0)
+    return DFB_IO;
+
+  return DFB_OK;
+}
+
+
+static DFBResult
+stgfxPrimaryTestRegion (CoreLayer                  *layer,
+                        void                       *driver_data,
+                        void                       *layer_data,
+                        CoreLayerRegionConfig      *config,
+                        CoreLayerRegionConfigFlags *failed)
+{
+  const STGFXDriverData        * const drv = driver_data;
+  const STGFXPrimarySharedData * const shd = layer_data;
+  DFBResult                     ret;
+  CoreLayerRegionConfigFlags    fail = 0;
+  DFBDisplayLayerOptions        options = config->options;
+
+  /* remove options before calling the original function */
+  config->options = DLOP_NONE;
+
+  ret = drv->layerData.orig_funcs.TestRegion (layer,
+                                              drv->layerData.orig_data,
+                                              layer_data, config, &fail);
+
+  /* restore options */
+  config->options = options;
+
+  /* check options if specified */
+  if (options && ((options & ~shd->supported_options) != 0))
+    fail |= CLRCF_OPTIONS;
+
+  if ((config->surface_caps & DSCAPS_PREMULTIPLIED)
+      && !(shd->originalVarCaps & STMFBIO_VAR_CAPS_PREMULTIPLIED))
+    fail |= CLRCF_SURFACE_CAPS;
+
+  if (failed)
+    *failed = fail;
+
+  if (fail)
+    return DFB_UNSUPPORTED;
+
+  return ret;
+}
+
+
+static DFBResult
+stgfxPrimarySetRegion (CoreLayer                  *layer,
+                       void                       *driver_data,
+                       void                       *layer_data,
+                       void                       *region_data,
+                       CoreLayerRegionConfig      *config,
+                       CoreLayerRegionConfigFlags  updated,
+                       CoreSurface                *surface,
+                       CorePalette                *palette,
+                       CoreSurfaceBufferLock      *lock)
+{
+  const STGFXDriverData            * const drv = driver_data;
+  const STGFXPrimarySharedData     * const shd = layer_data;
+  DFBResult                         ret;
+  struct stmfbio_var_screeninfo_ex  tmp = { 0 };
+
+  D_DEBUG ("DirectFB/gfxdrivers/stgfx_primary: set region layer %p config %p "
+           "surface %p\n", layer, config, surface);
+
+  /* call the original function */
+  ret = drv->layerData.orig_funcs.SetRegion (layer, drv->layerData.orig_data,
+                                             layer_data, region_data,
+                                             config, updated, surface,
+                                             palette, lock);
+  if (ret)
+    return ret;
+
+  if (shd->originalVarCaps == STMFBIO_VAR_CAPS_NONE)
+    return DFB_OK;
+
+  D_DEBUG ("DirectFB/gfxdrivers/stgfx_primary: set extended layer options\n");
+
+  tmp.layerid  = dfb_layer_id_translated (layer);
+  tmp.activate = STMFBIO_ACTIVATE_IMMEDIATE;
+
+  if ((updated & (CLRCF_OPTIONS | CLRCF_SRCKEY))
+      && (shd->originalVarCaps & STMFBIO_VAR_CAPS_COLOURKEY))
+    {
+      tmp.caps          |= STMFBIO_VAR_CAPS_COLOURKEY;
+      tmp.colourKeyFlags = ((config->options & DLOP_SRC_COLORKEY)
+                            ? STMFBIO_COLOURKEY_FLAGS_ENABLE
+                            : 0
+                           );
+      tmp.min_colour_key = PIXEL_ARGB (0, config->src_key.r,
+                                       config->src_key.g, config->src_key.b);
+      tmp.max_colour_key = tmp.min_colour_key;
+    }
+
+  if ((updated & CLRCF_OPTIONS)
+      && (shd->originalVarCaps & STMFBIO_VAR_CAPS_FLICKER_FILTER))
+    {
+      tmp.caps    |= STMFBIO_VAR_CAPS_FLICKER_FILTER;
+      tmp.ff_state = ((config->options & DLOP_FLICKER_FILTERING)
+                      ? STMFBIO_FF_ADAPTIVE
+                      : STMFBIO_FF_OFF
+                     );
+    }
+
+  if ((updated & CLRCF_SURFACE_CAPS)
+      && (shd->originalVarCaps & STMFBIO_VAR_CAPS_PREMULTIPLIED))
+    {
+      tmp.caps |= STMFBIO_VAR_CAPS_PREMULTIPLIED;
+      tmp.premultiplied_alpha = ((config->surface_caps & DSCAPS_PREMULTIPLIED)
+                                 ? 1
+                                 : 0
+                                );
+      D_DEBUG ("DirectFB/gfxdrivers/stgfx_primary: premultiplied alpha: %u\n",
+               tmp.premultiplied_alpha);
+    }
+
+  if ((updated & CLRCF_OPACITY)
+      && (shd->originalVarCaps & STMFBIO_VAR_CAPS_OPACITY))
+    {
+      tmp.caps   |= STMFBIO_VAR_CAPS_OPACITY;
+      tmp.opacity = ((config->options & DLOP_OPACITY)
+                     ? config->opacity
+                     : 255
+                    );
+      D_DEBUG ("DirectFB/gfxdrivers/stgfx_primary: opacity: %u\n",
+               tmp.opacity);
+    }
+
+  if ((updated & CLRCF_ALPHA_RAMP)
+      && (shd->originalVarCaps & STMFBIO_VAR_CAPS_ALPHA_RAMP))
+    {
+      tmp.caps         |= STMFBIO_VAR_CAPS_ALPHA_RAMP;
+      tmp.alpha_ramp[0] = config->alpha_ramp[0];
+      tmp.alpha_ramp[1] = config->alpha_ramp[3];
+    }
+
+  if (tmp.caps
+      && ioctl (drv->fd, STMFBIO_SET_VAR_SCREENINFO_EX, &tmp) < 0)
+    return DFB_IO;
+
+  return DFB_OK;
+}
+
+
+static DFBResult
+stgfxPrimaryGetLevel (CoreLayer              *layer,
+                      void                   *driver_data,
+                      void                   *layer_data,
+                      int                    *level)
+{
+  const STGFXDriverData            * const drv = driver_data;
+  const STGFXPrimarySharedData     * const shd = layer_data;
+  struct stmfbio_var_screeninfo_ex  tmp = { 0 };
+
+  if (!(shd->originalVarCaps & STMFBIO_VAR_CAPS_ZPOSITION))
+    return DFB_UNSUPPORTED;
+
+  tmp.layerid = dfb_layer_id_translated (layer);
+
+  if (ioctl (drv->fd, STMFBIO_GET_VAR_SCREENINFO_EX, &tmp) < 0)
+    return DFB_IO;
+
+  *level = (int) tmp.z_position;
+
+  return DFB_OK;
+}
+
+
+static DFBResult
+stgfxPrimarySetLevel (CoreLayer              *layer,
+                      void                   *driver_data,
+                      void                   *layer_data,
+                      int                     level)
+{
+  const STGFXDriverData            * const drv = driver_data;
+  const STGFXPrimarySharedData     * const shd = layer_data;
+  struct stmfbio_var_screeninfo_ex  tmp = { 0 };
+
+  if (!(shd->originalVarCaps & STMFBIO_VAR_CAPS_ZPOSITION))
+    return DFB_UNSUPPORTED;
+
+  tmp.layerid    = dfb_layer_id_translated (layer);
+  tmp.activate   = STMFBIO_ACTIVATE_IMMEDIATE;
+  tmp.caps       = STMFBIO_VAR_CAPS_ZPOSITION;
+  tmp.z_position = (level < 0) ? 0 : level;
+
+  if (ioctl (drv->fd, STMFBIO_SET_VAR_SCREENINFO_EX, &tmp) < 0)
+    return (errno == EINVAL) ? DFB_INVARG : DFB_IO;
+
+  return DFB_OK;
+}
+
+
+static DFBResult
+stgfxPrimarySetColorAdjustment (CoreLayer          *layer,
+                                void               *driver_data,
+                                void               *layer_data,
+                                DFBColorAdjustment *adjustment)
+{
+  const STGFXDriverData            * const drv = driver_data;
+  const STGFXPrimarySharedData     * const shd = layer_data;
+  struct stmfbio_var_screeninfo_ex  tmp = { 0 };
+
+//  if ((adjustment->flags & ~shd->supported_adjustments) != 0)
+//    return DFB_INVARG;
+
+  tmp.layerid  = dfb_layer_id_translated (layer);
+  tmp.activate = STMFBIO_ACTIVATE_IMMEDIATE;
+
+  if (adjustment->flags & DCAF_BRIGHTNESS)
+    {
+      if (shd->originalVarCaps & STMFBIO_VAR_CAPS_BRIGHTNESS)
+        {
+          tmp.caps |= STMFBIO_VAR_CAPS_BRIGHTNESS;
+          tmp.brightness = adjustment->brightness >> 8;
+        }
+      else
+        {
+          tmp.caps |= STMFBIO_VAR_CAPS_GAIN;
+          /* 0-0x8000 -> 0-255 */
+          tmp.gain = ((adjustment->brightness > 0x8000)
+                      ? 255
+                      : (((adjustment->brightness >> 8) * 255) / 128)
+                     );
+        }
+    }
+
+  if (adjustment->flags & DCAF_CONTRAST)
+    {
+      tmp.caps |= STMFBIO_VAR_CAPS_CONTRAST;
+      tmp.contrast = adjustment->contrast >> 8;
+    }
+
+  if (adjustment->flags & DCAF_HUE)
+    {
+      tmp.caps |= STMFBIO_VAR_CAPS_TINT;
+      tmp.tint = adjustment->hue >> 8;
+    }
+
+  if (adjustment->flags & DCAF_SATURATION)
+    {
+      tmp.caps |= STMFBIO_VAR_CAPS_SATURATION;
+      tmp.saturation = adjustment->saturation >> 8;
+    }
+
+  if (ioctl (drv->fd, STMFBIO_SET_VAR_SCREENINFO_EX, &tmp) < 0)
+    return (errno == EINVAL) ? DFB_INVARG : DFB_IO;
+
+  return DFB_OK;
+}
+
+
+#define _stgfxPrimaryLayerFuncs(driver) \
+DisplayLayerFuncs stgfxPrimaryLayerFuncs_stgfx ##driver = { \
+  .LayerDataSize      = stgfxPrimaryLayerDataSize,     \
+                                                       \
+  .InitLayer          = stgfxPrimaryInitLayer,         \
+  .ShutdownLayer      = stgfxPrimaryShutdownLayer,     \
+                                                       \
+  .TestRegion         = stgfxPrimaryTestRegion,        \
+  .SetRegion          = stgfxPrimarySetRegion,         \
+                                                       \
+  .GetLevel           = stgfxPrimaryGetLevel,          \
+  .SetLevel           = stgfxPrimarySetLevel,          \
+                                                       \
+  .SetColorAdjustment = stgfxPrimarySetColorAdjustment \
+}
+
+#define stgfxPrimaryLayerFuncs(driver) _stgfxPrimaryLayerFuncs(driver)
+
+stgfxPrimaryLayerFuncs(STGFX_DRIVER);
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/gfxdrivers/stgfx2/stgfx_primary.h DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/stgfx_primary.h
--- DirectFB/gfxdrivers/stgfx2/stgfx_primary.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/stgfx_primary.h	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,51 @@
+/*
+   ST Microelectronics BDispII driver - primary layer implementation
+
+   (c) Copyright 2007-2009  STMicroelectronics Ltd.
+
+   All rights reserved.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#ifndef __STGFX_PRIMARY_H__
+#define __STGFX_PRIMARY_H__
+
+#include <linux/stmfb.h>
+#include <core/layers.h>
+
+#ifndef STGFX_DRIVER
+#  error Please define STGFX_DRIVER
+#endif
+
+struct _STGFX2LayerData
+{
+  void                             *orig_data;
+  DisplayLayerFuncs                 orig_funcs;
+  struct stmfbio_var_screeninfo_ex  startup_var;
+};
+
+#define _stgfxPrimaryLayerFuncs(driver) \
+DisplayLayerFuncs stgfxPrimaryLayerFuncs_stgfx ##driver
+
+#define stgfxPrimaryLayerFuncs(driver) _stgfxPrimaryLayerFuncs(driver)
+
+extern stgfxPrimaryLayerFuncs (STGFX_DRIVER);
+
+#undef _stgfxPrimaryLayerFuncs
+#undef stgfxPrimaryLayerFuncs
+
+#endif /* __STGFX_PRIMARY_H__ */
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/gfxdrivers/stgfx2/stgfx_screen.c DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/stgfx_screen.c
--- DirectFB/gfxdrivers/stgfx2/stgfx_screen.c	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/stgfx_screen.c	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,877 @@
+/*
+   ST Microelectronics BDispII driver - primary screen implementation
+
+   (c) Copyright 2007,2009-2010  STMicroelectronics Ltd.
+   (c) Copyright 2000-2002       convergence integrated media GmbH.
+   (c) Copyright 2002            convergence GmbH.
+
+   All rights reserved.
+
+   Based on the cle266 driver implementation:
+
+   Written by Denis Oliver Kropp <dok@directfb.org>,
+              Andreas Hundt <andi@fischlustig.de> and
+              Sven Neumann <sven@convergence.de>.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+
+#include <directfb.h>
+
+#include <core/core.h>
+#include <core/coredefs.h>
+#include <core/coretypes.h>
+#include <core/screens.h>
+#include <core/system.h>
+
+#include <fbdev/fbdev.h>
+
+#include <misc/conf.h>
+
+#include <direct/messages.h>
+
+#include <linux/fb.h>
+#include <linux/stmfb.h>
+
+#if STGFX_DRIVER == 2
+  #include "stm_gfxdriver.h"
+  typedef struct _STGFX2DriverData STGFXDriverData;
+#elif STGFX_DRIVER == 1
+  #include "stgfx.h"
+#else
+  #error unknown stgfx driver version
+#endif
+#include "stgfx_screen.h"
+
+
+D_DEBUG_DOMAIN (STGFX_Screen, "STGFX/Screen", "STM Screen (hook)");
+
+
+enum _stm_outputs {
+  STM_OUTPUT_ANALOG,
+  STM_OUTPUT_HDMI,
+  STM_OUTPUT_DVO,
+
+  STM_OUTPUT_COUNT
+};
+
+typedef struct {
+  u32 originalOutputCaps;
+} STGFXScreenSharedData;
+
+
+static int
+stgfxScreenDataSize (void)
+{
+  D_DEBUG_AT (STGFX_Screen, "%s (%u)\n",
+              __FUNCTION__, sizeof (STGFXScreenSharedData));
+
+  return sizeof (STGFXScreenSharedData);
+}
+
+
+static DFBResult
+stgfxInitScreen (CoreScreen           *screen,
+                 CoreGraphicsDevice   *device,
+                 void                 *driver_data,
+                 void                 *screen_data,
+                 DFBScreenDescription *description)
+{
+  STGFXDriverData       * const drv = driver_data;
+  STGFXScreenSharedData * const shd = screen_data;
+  const FBDev           * const fbdev = dfb_system_data ();
+  DFBResult              ret;
+
+  D_DEBUG_AT (STGFX_Screen, "%s @ %p\n", __FUNCTION__, screen_data);
+
+  D_ASSERT (dfb_system_type() == CORE_FBDEV);
+
+  ret = drv->screenData.orig_funcs.InitScreen (screen, device,
+                                               drv->screenData.orig_data,
+                                               screen_data,
+                                               description);
+  if (ret != DFB_OK)
+    return ret;
+
+  drv->screenData.startup_config.outputid = STMFBIO_OUTPUTID_MAIN;
+  if (ioctl (drv->fd, STMFBIO_GET_OUTPUT_CONFIG,
+             &drv->screenData.startup_config) < 0)
+    {
+      D_INFO ("BDisp/screen: no stmfb or wrong version?\n");
+      drv->screenData.startup_config.caps = STMFBIO_OUTPUT_CAPS_NONE;
+      shd->originalOutputCaps             = STMFBIO_OUTPUT_CAPS_NONE;
+      return DFB_OK;
+    }
+
+  snprintf (description->name,
+            DFB_SCREEN_DESC_NAME_LENGTH, "%s", fbdev->shared->fix.id);
+
+  /* As we are talking to TVs there is no VESA power management control of the
+     display implemented. */
+  description->caps &= ~DSCCAPS_POWER_MANAGEMENT;
+
+  shd->originalOutputCaps = drv->screenData.startup_config.caps;
+
+  if (shd->originalOutputCaps & STMFBIO_OUTPUT_CAPS_MIXER_BACKGROUND)
+    {
+      D_DEBUG_AT (STGFX_Screen, "  => have mixer background\n");
+      description->caps |= DSCCAPS_MIXERS;
+      ++description->mixers;
+    }
+
+  if (shd->originalOutputCaps & STMFBIO_OUTPUT_CAPS_SDTV_ENCODING)
+    {
+      D_DEBUG_AT (STGFX_Screen, "  => have denc\n");
+      description->caps |= DSCCAPS_ENCODERS;
+      ++description->encoders;
+    }
+
+  description->caps |= DSCCAPS_OUTPUTS;
+  description->outputs = STM_OUTPUT_COUNT;
+
+  return DFB_OK;
+}
+
+static DFBResult
+stgfxShutdownScreen (CoreScreen *screen,
+                     void       *driver_data,
+                     void       *screen_data)
+{
+  STGFXDriverData * const drv = driver_data;
+  DFBResult        ret = DFB_OK;
+
+  D_DEBUG_AT (STGFX_Screen, "%s\n", __FUNCTION__);
+
+  if (drv->screenData.orig_funcs.ShutdownScreen)
+    ret = drv->screenData.orig_funcs.ShutdownScreen (screen,
+                                                     drv->screenData.orig_data,
+                                                     screen_data);
+
+  /* try and restore the framebuffer's extended state. */
+  drv->screenData.startup_config.activate = STMFBIO_ACTIVATE_IMMEDIATE;
+  ioctl (drv->fd, STMFBIO_SET_OUTPUT_CONFIG, &drv->screenData.startup_config);
+
+  return ret;
+}
+
+
+/** Mixer configuration **/
+static DFBResult
+stgfxInitMixer (CoreScreen                *screen,
+                void                      *driver_data,
+                void                      *screen_data,
+                int                        mixer,
+                DFBScreenMixerDescription *description,
+                DFBScreenMixerConfig      *config)
+{
+  const STGFXDriverData * const drv = driver_data;
+
+  D_DEBUG_AT (STGFX_Screen, "%s\n", __FUNCTION__);
+
+  description->caps = DSMCAPS_FULL | DSMCAPS_BACKGROUND;
+
+  DFB_DISPLAYLAYER_IDS_ADD (description->layers, DLID_PRIMARY);
+
+  snprintf (description->name,
+            DFB_SCREEN_MIXER_DESC_NAME_LENGTH, "STM Mixer");
+
+  config->flags = DSMCONF_TREE | DSMCONF_BACKGROUND;
+  config->tree = DSMT_FULL;
+  config->background.a = (drv->screenData.startup_config.mixer_background >> 24) & 0xff;
+  config->background.r = (drv->screenData.startup_config.mixer_background >> 16) & 0xff;
+  config->background.g = (drv->screenData.startup_config.mixer_background >> 8)  & 0xff;
+  config->background.b = (drv->screenData.startup_config.mixer_background >> 0)  & 0xff;
+
+  D_DEBUG_AT (STGFX_Screen, " => background colour: 0x%08x\n",
+              drv->screenData.startup_config.mixer_background);
+
+  return DFB_OK;
+}
+
+static DFBResult
+stgfxDoMixerConfig (CoreScreen                 *screen,
+                    void                       *driver_data,
+                    void                       *screen_data,
+                    int                         mixer,
+                    const DFBScreenMixerConfig *config,
+                    DFBScreenMixerConfigFlags  *failed,
+                    bool                        test)
+{
+  const STGFXDriverData               * const drv = driver_data;
+  const STGFXScreenSharedData         * const shd = screen_data;
+  struct stmfbio_output_configuration  cfg = { 0 };
+
+  D_DEBUG_AT (STGFX_Screen, "%s%s\n", __FUNCTION__, test ? " (test)" : "");
+
+  *failed = 0;
+  if ((config->flags & DSMCONF_BACKGROUND)
+      && !(shd->originalOutputCaps & STMFBIO_OUTPUT_CAPS_MIXER_BACKGROUND))
+    *failed = DSMCONF_BACKGROUND;
+
+  if (config->flags & DSMCONF_TREE && config->tree != DSMT_FULL)
+    *failed |= DSMT_FULL;
+
+  if (config->flags & ~(DSMCONF_TREE | DSMCONF_BACKGROUND))
+    *failed |= config->flags & ~(DSMCONF_TREE | DSMCONF_BACKGROUND);
+
+  if (*failed)
+    return DFB_INVARG;
+
+  cfg.outputid = STMFBIO_OUTPUTID_MAIN;
+  cfg.caps     = STMFBIO_OUTPUT_CAPS_MIXER_BACKGROUND;
+  cfg.activate = test ? STMFBIO_ACTIVATE_TEST : STMFBIO_ACTIVATE_IMMEDIATE;
+  cfg.mixer_background = (0
+                          | (config->background.a << 24)
+                          | (config->background.r << 16)
+                          | (config->background.g <<  8)
+                          | (config->background.b <<  0)
+                         );
+
+  if (ioctl (drv->fd, STMFBIO_SET_OUTPUT_CONFIG, &cfg) < 0)
+    {
+      *failed = config->flags;
+      return (cfg.failed != 0) ? DFB_INVARG : DFB_IO;
+    }
+
+  return DFB_OK;
+}
+
+static DFBResult
+stgfxTestMixerConfig (CoreScreen                 *screen,
+                      void                       *driver_data,
+                      void                       *screen_data,
+                      int                         mixer,
+                      const DFBScreenMixerConfig *config,
+                      DFBScreenMixerConfigFlags  *failed)
+{
+  return stgfxDoMixerConfig (screen, driver_data, screen_data, mixer,
+                             config, failed, true);
+}
+
+static DFBResult
+stgfxSetMixerConfig (CoreScreen                 *screen,
+                     void                       *driver_data,
+                     void                       *screen_data,
+                     int                         mixer,
+                     const DFBScreenMixerConfig *config)
+{
+  DFBScreenMixerConfigFlags dummy;
+  return stgfxDoMixerConfig (screen, driver_data, screen_data, mixer,
+                             config, &dummy, false);
+}
+
+
+/** Encoder configuration **/
+typedef unsigned int stmfbio_output_std;
+#define STMFBIO_OUTPUT_STD_NONE 0xffffffff
+#define STMFBIO_OUTPUT_STD_DIGITAL 0x80000000
+struct _output_standard
+{
+  stmfbio_output_std          stmfb_std;
+  DFBScreenEncoderScanMode    scanmode;
+  DFBScreenEncoderFrequency   frequency;
+  DFBScreenOutputResolution   resolution;
+  DFBScreenEncoderTVStandards sdtv_encoding;
+};
+
+static const struct _output_standard standards_table[] = 
+{
+  { STMFBIO_OUTPUT_STD_NTSC_M,   DSESM_INTERLACED, DSEF_60HZ, DSOR_720_480, DSETV_NTSC },
+  { STMFBIO_OUTPUT_STD_NTSC_J,   DSESM_INTERLACED, DSEF_60HZ, DSOR_720_480, DSETV_NTSC_M_JPN },
+  { STMFBIO_OUTPUT_STD_NTSC_443, DSESM_INTERLACED, DSEF_60HZ, DSOR_720_480, DSETV_NTSC_443 },
+  { STMFBIO_OUTPUT_STD_PAL_M,    DSESM_INTERLACED, DSEF_60HZ, DSOR_720_480, DSETV_PAL_M },
+  { STMFBIO_OUTPUT_STD_PAL_60,   DSESM_INTERLACED, DSEF_60HZ, DSOR_720_480, DSETV_PAL_60 },
+
+  { STMFBIO_OUTPUT_STD_PAL_BDGHI, DSESM_INTERLACED, DSEF_50HZ, DSOR_720_576, DSETV_PAL },
+  { STMFBIO_OUTPUT_STD_PAL_N,     DSESM_INTERLACED, DSEF_50HZ, DSOR_720_576, DSETV_PAL_N },
+  { STMFBIO_OUTPUT_STD_PAL_Nc,    DSESM_INTERLACED, DSEF_50HZ, DSOR_720_576, DSETV_PAL_NC },
+  { STMFBIO_OUTPUT_STD_SECAM,     DSESM_INTERLACED, DSEF_50HZ, DSOR_720_576, DSETV_SECAM },
+
+};
+
+
+static DFBScreenEncoderTVStandards
+__attribute__((pure))
+stmfb_sdstd_to_dfb (stmfbio_output_std stmfb_std)
+{
+  int i;
+
+  for (i = 0; i < D_ARRAY_SIZE (standards_table); ++i)
+    {
+      if (standards_table[i].stmfb_std == stmfb_std
+          && !(standards_table[i].sdtv_encoding & DSETV_DIGITAL))
+        return standards_table[i].sdtv_encoding;
+    }
+
+  D_WARN ("%s: invalid sdtv encoding %d (0x%x) from kernel\n",
+          __FUNCTION__, stmfb_std, stmfb_std);
+
+  return DSETV_UNKNOWN;
+}
+
+static DFBResult
+stgfxInitEncoder (CoreScreen                  *screen,
+                  void                        *driver_data,
+                  void                        *screen_data,
+                  int                          encoder,
+                  DFBScreenEncoderDescription *description,
+                  DFBScreenEncoderConfig      *config)
+{
+  const STGFXDriverData       * const drv = driver_data;
+  const STGFXScreenSharedData * const shd = screen_data;
+
+  D_DEBUG_AT (STGFX_Screen, "%s (%d)\n", __FUNCTION__, encoder);
+
+  if (!(shd->originalOutputCaps & STMFBIO_OUTPUT_CAPS_SDTV_ENCODING))
+    return DFB_BUG;
+
+  description->caps = DSECAPS_TV_STANDARDS | DSECAPS_SCANMODE;
+  description->type = DSET_TV;
+  description->tv_standards = (DSETV_PAL | DSETV_NTSC | DSETV_SECAM
+                               | DSETV_PAL_60 | DSETV_PAL_BG | DSETV_PAL_I
+                               | DSETV_PAL_M  | DSETV_PAL_N | DSETV_PAL_NC
+                               | DSETV_NTSC_M_JPN | DSETV_NTSC_443);
+
+  snprintf (description->name,
+            DFB_SCREEN_ENCODER_DESC_NAME_LENGTH, "STM DENC");
+
+  config->flags = DSECONF_NONE;
+
+  config->tv_standard = stmfb_sdstd_to_dfb (drv->screenData.startup_config.sdtv_encoding);
+  if (config->tv_standard != DSETV_UNKNOWN)
+    config->flags |= DSECONF_TV_STANDARD;
+
+  D_DEBUG_AT (STGFX_Screen, "  => tv encoding: %u\n", config->tv_standard);
+
+  config->flags |= DSECONF_SCANMODE;
+  config->scanmode = DSESM_INTERLACED;
+
+  if (shd->originalOutputCaps & STMFBIO_OUTPUT_CAPS_BRIGHTNESS)
+    {
+      description->caps |= DSECAPS_BRIGHTNESS;
+      config->flags |= DSECONF_ADJUSTMENT;
+      config->adjustment.flags |= DCAF_BRIGHTNESS;
+      config->adjustment.brightness = ((u16) drv->screenData.startup_config.brightness) << 8;
+      D_DEBUG_AT (STGFX_Screen, "  => brightness: %u\n",
+                  config->adjustment.brightness);
+    }
+
+  if (shd->originalOutputCaps & STMFBIO_OUTPUT_CAPS_CONTRAST)
+    {
+      description->caps |= DSECAPS_CONTRAST;
+      config->flags |= DSECONF_ADJUSTMENT;
+      config->adjustment.flags |= DCAF_CONTRAST;
+      config->adjustment.contrast = ((u16) drv->screenData.startup_config.contrast) << 8;
+      D_DEBUG_AT (STGFX_Screen, "  => contrast: %u\n",
+                  config->adjustment.contrast);
+  }
+
+  if (shd->originalOutputCaps & STMFBIO_OUTPUT_CAPS_SATURATION)
+    {
+      description->caps |= DSECAPS_SATURATION;
+      config->flags |= DSECONF_ADJUSTMENT;
+      config->adjustment.flags |= DCAF_SATURATION;
+      config->adjustment.saturation = ((u16) drv->screenData.startup_config.saturation) << 8;
+      D_DEBUG_AT (STGFX_Screen, "  => saturation: %u\n",
+                  config->adjustment.saturation);
+  }
+
+  if (shd->originalOutputCaps & STMFBIO_OUTPUT_CAPS_HUE)
+    {
+      description->caps |= DSECAPS_HUE;
+      config->flags |= DSECONF_ADJUSTMENT;
+      config->adjustment.flags |= DCAF_HUE;
+      config->adjustment.hue = ((u16) drv->screenData.startup_config.hue) << 8;
+      D_DEBUG_AT (STGFX_Screen, "  => hue: %u\n",
+                  config->adjustment.hue);
+    }
+
+  return DFB_OK;
+}
+
+static DFBResult
+stgfxDoEncoderConfig (CoreScreen                  *screen,
+                      void                        *driver_data,
+                      void                        *screen_data,
+                      int                          encoder,
+                      DFBScreenEncoderConfig      *config,
+                      DFBScreenEncoderConfigFlags *failed,
+                      bool                         test)
+{
+  const STGFXDriverData               * const drv = driver_data;
+  struct stmfbio_output_configuration  cfg = { 0 };
+
+  D_DEBUG_AT (STGFX_Screen, "%s%s\n", __FUNCTION__, test ? " (test)" : "");
+
+  cfg.outputid = STMFBIO_OUTPUTID_MAIN;
+  cfg.activate = test ? STMFBIO_ACTIVATE_TEST : STMFBIO_ACTIVATE_IMMEDIATE;
+
+  *failed = config->flags & ~(DSECONF_SCANMODE
+                              | DSECONF_TV_STANDARD
+                              | DSECONF_ADJUSTMENT);
+
+  if ((config->flags & DSECONF_SCANMODE)
+      && (config->scanmode != DSESM_INTERLACED))
+    {
+      D_DEBUG_AT (STGFX_Screen, " => encoder scanmode must be interlaced\n");
+      *failed |= DSECONF_SCANMODE;
+    }
+
+  if (*failed)
+    {
+      D_DEBUG_AT (STGFX_Screen, " => encoder config failed: 0x%08x\n",
+                  *failed);
+      return DFB_INVARG;
+    }
+
+  if (config->flags & DSECONF_TV_STANDARD)
+    {
+      int i;
+
+      for (i = 0; i < D_ARRAY_SIZE (standards_table); ++i)
+        {
+          if (standards_table[i].sdtv_encoding == config->tv_standard)
+            {
+              cfg.caps |= STMFBIO_OUTPUT_CAPS_SDTV_ENCODING;
+              cfg.sdtv_encoding = standards_table[i].stmfb_std;
+              break;
+            }
+        }
+
+      if (!(cfg.caps & STMFBIO_OUTPUT_CAPS_SDTV_ENCODING)
+          || cfg.sdtv_encoding & STMFBIO_OUTPUT_STD_DIGITAL)
+        {
+          D_DEBUG_AT (STGFX_Screen, " => unknown tv encoding 0x%08x\n",
+                      config->tv_standard);
+          *failed |= DSECONF_TV_STANDARD;
+          return DFB_INVARG;
+        }
+    }
+
+  if (config->flags & DSECONF_ADJUSTMENT)
+    {
+      if (config->adjustment.flags & DCAF_BRIGHTNESS)
+        {
+          cfg.caps |= STMFBIO_OUTPUT_CAPS_BRIGHTNESS;
+          cfg.brightness = config->adjustment.brightness >> 8;
+        }
+
+      if (config->adjustment.flags & DCAF_SATURATION)
+        {
+          cfg.caps |= STMFBIO_OUTPUT_CAPS_SATURATION;
+          cfg.saturation = config->adjustment.saturation >> 8;
+        }
+
+      if (config->adjustment.flags & DCAF_CONTRAST)
+        {
+          cfg.caps |= STMFBIO_OUTPUT_CAPS_CONTRAST;
+          cfg.contrast = config->adjustment.contrast >> 8;
+        }
+
+      if (config->adjustment.flags & DCAF_HUE)
+        {
+          cfg.caps |= STMFBIO_OUTPUT_CAPS_HUE;
+          cfg.hue = config->adjustment.hue >> 8;
+        }
+    }
+
+  if (ioctl (drv->fd, STMFBIO_SET_OUTPUT_CONFIG, &cfg) < 0)
+    {
+      if(cfg.failed != 0)
+        {
+          /* Only report failures on test. If this was a set then we read back
+             the actual config and pass that back. This avoids unnecessary
+             failures when trying to set a tv standard in a mode that doesn't
+             support it.
+
+             Unfortunately even just changing an adjustment control will also
+             try and set the tv standard as well. This is where the DirectFB
+             semantics don't exactly match the way the hardware works. */
+          if (test)
+            {
+              D_DEBUG_AT (STGFX_Screen, " => output config ioctl failed 0x%08x\n",
+                          cfg.failed);
+              if (cfg.failed & STMFBIO_OUTPUT_CAPS_SDTV_ENCODING)
+                *failed |= DSECONF_TV_STANDARD;
+
+              if (cfg.failed & STMFBIO_OUTPUT_CAPS_PSI_MASK)
+                *failed |= DSECONF_ADJUSTMENT;
+
+              return DFB_INVARG;
+            }
+        }
+      else
+        {
+          D_DEBUG_AT (STGFX_Screen, " => ioctl IO error\n");
+          *failed = config->flags;
+          return DFB_IO;
+        }
+    }
+
+  if (!test)
+    {
+      struct stmfbio_output_configuration cfg = { .outputid = STMFBIO_OUTPUTID_MAIN };
+      /* Read back configuration */
+      if (ioctl (drv->fd, STMFBIO_GET_OUTPUT_CONFIG, &cfg) < 0)
+        {
+          D_DEBUG_AT (STGFX_Screen, " => do encoder, reading back output config failed!\n");
+          return DFB_IO;
+        }
+
+      if (cfg.caps & STMFBIO_OUTPUT_CAPS_SDTV_ENCODING)
+        config->tv_standard = stmfb_sdstd_to_dfb (cfg.sdtv_encoding);
+
+      if (cfg.caps & STMFBIO_OUTPUT_CAPS_BRIGHTNESS)
+        {
+          config->adjustment.flags |= DCAF_BRIGHTNESS;
+          config->adjustment.brightness = (u16)cfg.brightness << 8;
+        }
+
+      if (cfg.caps & STMFBIO_OUTPUT_CAPS_SATURATION)
+        {
+          config->adjustment.flags |= DCAF_SATURATION;
+          config->adjustment.saturation = (u16)cfg.saturation << 8;
+        }
+
+      if (cfg.caps & STMFBIO_OUTPUT_CAPS_CONTRAST)
+        {
+          config->adjustment.flags |= DCAF_CONTRAST;
+          config->adjustment.contrast = (u16)cfg.contrast << 8;
+        }
+
+      if (cfg.caps & STMFBIO_OUTPUT_CAPS_HUE)
+        {
+          config->adjustment.flags |= DCAF_HUE;
+          config->adjustment.hue = (u16)cfg.hue << 8;
+        }
+    }
+
+  return DFB_OK;
+}
+
+static DFBResult
+stgfxTestEncoderConfig (CoreScreen                   *screen,
+                        void                         *driver_data,
+                        void                         *screen_data,
+                        int                           encoder,
+                        const DFBScreenEncoderConfig *config,
+                        DFBScreenEncoderConfigFlags  *failed)
+{
+  DFBScreenEncoderConfig tmp = *config;
+
+  return stgfxDoEncoderConfig (screen, driver_data, screen_data, encoder,
+                               &tmp, failed, true);
+}
+
+static DFBResult
+stgfxSetEncoderConfig (CoreScreen                   *screen,
+                       void                         *driver_data,
+                       void                         *screen_data,
+                       int                           encoder,
+                       const DFBScreenEncoderConfig *config)
+{
+  DFBScreenEncoderConfigFlags dummy;
+
+  return stgfxDoEncoderConfig (screen, driver_data, screen_data, encoder,
+                               (DFBScreenEncoderConfig *) config, &dummy,
+                               false);
+}
+
+
+/** Output configuration **/
+static DFBResult
+stgfxInitOutput (CoreScreen                 *screen,
+                 void                       *driver_data,
+                 void                       *screen_data,
+                 int                         output,
+                 DFBScreenOutputDescription *description,
+                 DFBScreenOutputConfig      *config)
+{
+  const STGFXDriverData       * const drv = driver_data;
+  const STGFXScreenSharedData * const shd = screen_data;
+
+  switch (output)
+    {
+    case STM_OUTPUT_ANALOG:
+      if (shd->originalOutputCaps & STMFBIO_OUTPUT_CAPS_ANALOGUE_CONFIG)
+        {
+          description->caps = DSOCAPS_SIGNAL_SEL;
+          description->all_signals = DSOS_RGB | DSOS_YCBCR;
+          if (shd->originalOutputCaps & STMFBIO_OUTPUT_CAPS_SDTV_ENCODING)
+            description->all_signals |= DSOS_CVBS | DSOS_YC;
+
+          snprintf (description->name, DFB_SCREEN_OUTPUT_DESC_NAME_LENGTH,
+                    "STM Analogue Output");
+
+          config->flags = DSOCONF_SIGNALS;
+          config->out_signals = 0;
+          if (drv->screenData.startup_config.analogue_config & STMFBIO_OUTPUT_ANALOGUE_RGB)
+            config->out_signals |= DSOS_RGB;
+
+          if (drv->screenData.startup_config.analogue_config & STMFBIO_OUTPUT_ANALOGUE_YPrPb)
+            config->out_signals |= DSOS_YCBCR;
+
+          if (drv->screenData.startup_config.analogue_config & STMFBIO_OUTPUT_ANALOGUE_YC)
+            config->out_signals |= DSOS_YC;
+
+          if (drv->screenData.startup_config.analogue_config & STMFBIO_OUTPUT_ANALOGUE_CVBS)
+            config->out_signals |= DSOS_CVBS;
+        }
+      break;
+
+    case STM_OUTPUT_HDMI:
+      if(shd->originalOutputCaps & STMFBIO_OUTPUT_CAPS_HDMI_CONFIG)
+        {
+          description->caps = DSOCAPS_SIGNAL_SEL;
+          description->all_signals = DSOS_HDMI | DSOS_RGB | DSOS_YCBCR;
+
+          snprintf (description->name, DFB_SCREEN_OUTPUT_DESC_NAME_LENGTH,
+                    "STM HDMI Output");
+
+          config->flags = DSOCONF_SIGNALS;
+          if (drv->screenData.startup_config.hdmi_config & STMFBIO_OUTPUT_HDMI_DISABLED)
+            config->out_signals = DSOS_NONE;
+          else
+            {
+              config->out_signals = DSOS_HDMI;
+              /* A bit of bending the interface to specify the HDMI colourspace */
+              if(drv->screenData.startup_config.hdmi_config & STMFBIO_OUTPUT_HDMI_YUV)
+                config->out_signals |= DSOS_YCBCR;
+              else
+                config->out_signals |= DSOS_RGB;
+            }
+        }
+      break;
+
+    case STM_OUTPUT_DVO:
+      if(shd->originalOutputCaps & STMFBIO_OUTPUT_CAPS_DVO_CONFIG)
+        {
+          description->caps = DSOCAPS_SIGNAL_SEL;
+          description->all_signals = DSOS_656;
+
+          snprintf (description->name, DFB_SCREEN_OUTPUT_DESC_NAME_LENGTH,
+                    "STM DVO Output");
+
+          config->flags = DSOCONF_SIGNALS;
+          if(drv->screenData.startup_config.dvo_config & STMFBIO_OUTPUT_DVO_DISABLED)
+            config->out_signals = DSOS_NONE;
+          else
+            config->out_signals = DSOS_656;
+        }
+      break;
+
+    default:
+      return DFB_INVARG;
+  }
+
+  return DFB_OK;
+}
+
+static DFBResult
+stgfxDoOutputConfig (CoreScreen                  *screen,
+                     void                        *driver_data,
+                     void                        *screen_data,
+                     int                          output,
+                     const DFBScreenOutputConfig *config,
+                     DFBScreenOutputConfigFlags  *failed,
+                     bool                         test)
+{
+  const STGFXDriverData               * const drv = driver_data;
+  const STGFXScreenSharedData         * const shd = screen_data;
+  struct stmfbio_output_configuration  cfg = { 0 };
+
+  cfg.outputid = STMFBIO_OUTPUTID_MAIN;
+  if (ioctl (drv->fd, STMFBIO_GET_OUTPUT_CONFIG, &cfg) < 0)
+    {
+      *failed = config->flags;
+      return DFB_IO;
+    }
+
+  cfg.activate = test ? STMFBIO_ACTIVATE_TEST : STMFBIO_ACTIVATE_IMMEDIATE;
+
+  *failed = config->flags & ~DSOCONF_SIGNALS;
+  if (*failed)
+    return DFB_INVARG;
+
+  switch (output)
+    {
+    case STM_OUTPUT_ANALOG:
+      if (config->out_signals & ~(DSOS_RGB | DSOS_YCBCR | DSOS_CVBS | DSOS_YC))
+        *failed = config->flags;
+
+      if (!(shd->originalOutputCaps & STMFBIO_OUTPUT_CAPS_ANALOGUE_CONFIG))
+        {
+          if(config->out_signals == DSOS_NONE)
+            return DFB_OK;
+          else
+            {
+              *failed = config->flags;
+              return DFB_INVARG;
+            }
+        }
+      else
+        {
+          cfg.caps = STMFBIO_OUTPUT_CAPS_ANALOGUE_CONFIG;
+
+          cfg.analogue_config &= ~STMFBIO_OUTPUT_ANALOGUE_MASK;
+          if (config->out_signals & DSOS_RGB)
+            cfg.analogue_config |= STMFBIO_OUTPUT_ANALOGUE_RGB;
+          if (config->out_signals & DSOS_YCBCR)
+            cfg.analogue_config |= STMFBIO_OUTPUT_ANALOGUE_YPrPb;
+          if (config->out_signals & DSOS_CVBS)
+            cfg.analogue_config |= STMFBIO_OUTPUT_ANALOGUE_CVBS;
+          if (config->out_signals & DSOS_YC)
+            cfg.analogue_config |= STMFBIO_OUTPUT_ANALOGUE_YC;
+        }
+      break;
+
+    case STM_OUTPUT_HDMI:
+      if (config->out_signals & ~(DSOS_HDMI | DSOS_RGB | DSOS_YCBCR))
+        *failed = config->flags;
+
+      if ((config->out_signals & (DSOS_RGB | DSOS_YCBCR)) == (DSOS_RGB | DSOS_YCBCR))
+        *failed = config->flags;
+
+      if (!(shd->originalOutputCaps & STMFBIO_OUTPUT_CAPS_HDMI_CONFIG))
+        {
+          if(config->out_signals == DSOS_NONE)
+            return DFB_OK;
+          else
+            {
+              *failed = config->flags;
+              return DFB_INVARG;
+            }
+        }
+      else
+        {
+          cfg.caps = STMFBIO_OUTPUT_CAPS_HDMI_CONFIG;
+
+          cfg.hdmi_config &= ~(STMFBIO_OUTPUT_HDMI_DISABLED
+                               | STMFBIO_OUTPUT_HDMI_YUV);
+
+          if (config->out_signals & DSOS_HDMI)
+            {
+              cfg.hdmi_config |= STMFBIO_OUTPUT_HDMI_ENABLED;
+              /* HDMI colourspace is RGB by default, only change it when YCBCR
+                 is specified. */
+              if(config->out_signals & DSOS_YCBCR)
+                cfg.hdmi_config |= STMFBIO_OUTPUT_HDMI_YUV;
+            }
+          else
+            cfg.hdmi_config |= STMFBIO_OUTPUT_HDMI_DISABLED;
+        }
+      break;
+
+    case STM_OUTPUT_DVO:
+      if (config->out_signals & ~DSOS_656)
+        *failed = config->flags;
+
+      if (!(shd->originalOutputCaps & STMFBIO_OUTPUT_CAPS_DVO_CONFIG))
+        {
+          if (config->out_signals == DSOS_NONE)
+            return DFB_OK;
+          else
+            {
+              *failed = config->flags;
+              return DFB_INVARG;
+            }
+        }
+      else
+        {
+          cfg.caps = STMFBIO_OUTPUT_CAPS_DVO_CONFIG;
+
+          cfg.dvo_config &= ~STMFBIO_OUTPUT_DVO_DISABLED;
+
+          if(config->out_signals == DSOS_656)
+            cfg.dvo_config |= STMFBIO_OUTPUT_DVO_ENABLED;
+          else
+            cfg.dvo_config |= STMFBIO_OUTPUT_DVO_DISABLED;
+        }
+      break;
+
+    default:
+      *failed = config->flags;
+      return DFB_INVARG;
+    }
+
+  if (*failed)
+    return DFB_INVARG;
+
+  if (ioctl (drv->fd, STMFBIO_SET_OUTPUT_CONFIG, &cfg) < 0)
+    {
+      *failed = config->flags;
+      return (cfg.failed != 0) ? DFB_INVARG : DFB_IO;
+    }
+
+  return DFB_OK;
+}
+
+static DFBResult
+stgfxTestOutputConfig (CoreScreen                  *screen,
+                       void                        *driver_data,
+                       void                        *screen_data,
+                       int                          output,
+                       const DFBScreenOutputConfig *config,
+                       DFBScreenOutputConfigFlags  *failed)
+{
+  return stgfxDoOutputConfig (screen, driver_data, screen_data, output,
+                              config, failed, true);
+}
+
+static DFBResult
+stgfxSetOutputConfig (CoreScreen                  *screen,
+                      void                        *driver_data,
+                      void                        *screen_data,
+                      int                          output,
+                      const DFBScreenOutputConfig *config)
+{
+  DFBScreenOutputConfigFlags dummy;
+
+  return stgfxDoOutputConfig (screen, driver_data, screen_data, output,
+                              config, &dummy, false);
+}
+
+
+#define _stgfxPrimaryScreenFuncs(driver) \
+ScreenFuncs stgfxPrimaryScreenFuncs_stgfx ##driver = { \
+  .ScreenDataSize    = stgfxScreenDataSize,       \
+                                                  \
+  .InitScreen        = stgfxInitScreen,           \
+  .ShutdownScreen    = stgfxShutdownScreen,       \
+                                                  \
+  .InitMixer         = stgfxInitMixer,            \
+  .TestMixerConfig   = stgfxTestMixerConfig,      \
+  .SetMixerConfig    = stgfxSetMixerConfig,       \
+                                                  \
+  .InitEncoder       = stgfxInitEncoder,          \
+  .TestEncoderConfig = stgfxTestEncoderConfig,    \
+  .SetEncoderConfig  = stgfxSetEncoderConfig,     \
+                                                  \
+  .InitOutput        = stgfxInitOutput,           \
+  .TestOutputConfig  = stgfxTestOutputConfig,     \
+  .SetOutputConfig   = stgfxSetOutputConfig,      \
+}
+
+#define stgfxPrimaryScreenFuncs(driver) _stgfxPrimaryScreenFuncs(driver)
+
+stgfxPrimaryScreenFuncs(STGFX_DRIVER);
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/gfxdrivers/stgfx2/stgfx_screen.h DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/stgfx_screen.h
--- DirectFB/gfxdrivers/stgfx2/stgfx_screen.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/stgfx_screen.h	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,50 @@
+/*
+   ST Microelectronics BDispII driver - primary screen implementation
+
+   (c) Copyright 2009       STMicroelectronics Ltd.
+
+   All rights reserved.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#ifndef __STGFX_SCREEN_H__
+#define __STGFX_SCREEN_H__
+
+#include <linux/stmfb.h>
+#include <core/screens.h>
+
+#ifndef STGFX_DRIVER
+#  error Please define STGFX_DRIVER
+#endif
+
+struct _STGFX2ScreenData {
+  void                                *orig_data;
+  ScreenFuncs                          orig_funcs;
+  struct stmfbio_output_configuration  startup_config;
+};
+
+#define _stgfxPrimaryScreenFuncs(driver) \
+ScreenFuncs stgfxPrimaryScreenFuncs_stgfx ##driver
+
+#define stgfxPrimaryScreenFuncs(driver) _stgfxPrimaryScreenFuncs(driver)
+
+extern stgfxPrimaryScreenFuncs (STGFX_DRIVER);
+
+#undef _stgfxPrimaryScreenFuncs
+#undef stgfxPrimaryScreenFuncs
+
+#endif /* __STGFX_SCREEN_H__ */
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/gfxdrivers/stgfx2/stmfbdev_layer.c DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/stmfbdev_layer.c
--- DirectFB/gfxdrivers/stgfx2/stmfbdev_layer.c	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/stmfbdev_layer.c	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,984 @@
+/*
+   (c) Copyright 2010       STMicroelectronics (R&D) Ltd.
+   (c) Copyright 2001-2009  The world wide DirectFB Open Source Community (directfb.org)
+   (c) Copyright 2000-2004  Convergence (integrated media) GmbH
+
+   All rights reserved.
+
+   Written by Andr Draszik <andre.draszik@st.com>.
+
+   Based on work by Denis Oliver Kropp <dok@directfb.org>,
+                    Andreas Hundt <andi@fischlustig.de>,
+                    Sven Neumann <neo@directfb.org>,
+                    Ville Syrjl <syrjala@sci.fi> and
+                    Claudio Ciccani <klan@users.sf.net>.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+
+#include <sys/ioctl.h>
+
+#include <asm/types.h>
+#include <linux/stmfb.h>
+
+#include <directfb.h>
+#include <directfb_util.h>
+
+#include <core/coretypes.h>
+#include <core/core.h>
+#include <core/layers.h>
+#include <core/layers_internal.h>
+#include <core/palette.h>
+#include <core/screen.h>
+#include <core/screens.h>
+
+#include <gfx/convert.h>
+
+#include <misc/conf.h>
+
+#include "stmfbdev/stmfbdev.h"
+
+D_DEBUG_DOMAIN( STMfbdev_Layer, "STMfbdev/Layer", "STMfb System Module Layer Handling" );
+
+
+typedef struct {
+     int magic;
+
+     int                      layerid;
+     DFBDisplayLayerOptions   supported_options;
+     DFBSurfaceCapabilities   supported_surfacecaps;
+
+     struct stmfbio_planeinfo cur_planeinfo;
+
+     struct fb_cmap           current_cmap;
+
+     DFBColorAdjustmentFlags  supported_adjustments;
+
+     struct stmfbio_planeinfo         orig_planeinfo;
+     struct stmfbio_var_screeninfo_ex orig_varex;
+     struct fb_cmap                   orig_cmap;
+     void                            *cmap_memory[2]; /* orig and current */
+     FusionSHMPoolShared             *shmpool_data;
+} STMfbdevLayerSharedData;
+
+
+
+/* supported surface formats */
+#define STM_supported_pixelformat \
+  DSPF_ARGB1555: case DSPF_RGB16: case DSPF_RGB24: case DSPF_ARGB: \
+  case DSPF_A8: case DSPF_UYVY: case DSPF_LUT8: \
+  case DSPF_ALUT44: case DSPF_A1: case DSPF_ARGB4444: case DSPF_LUT2: \
+  case DSPF_ARGB8565: case DSPF_AVYU: case DSPF_VYU
+
+static const SURF_FMT dspf_to_stmfb[DFB_NUM_PIXELFORMATS] = {
+     [DFB_PIXELFORMAT_INDEX (DSPF_UNKNOWN)]  = SURF_NULL_PAD,
+     [DFB_PIXELFORMAT_INDEX (DSPF_ARGB1555)] = SURF_ARGB1555,
+     [DFB_PIXELFORMAT_INDEX (DSPF_RGB16)]    = SURF_RGB565,
+     [DFB_PIXELFORMAT_INDEX (DSPF_RGB24)]    = SURF_RGB888,
+     [DFB_PIXELFORMAT_INDEX (DSPF_RGB32)]    = SURF_NULL_PAD,
+     [DFB_PIXELFORMAT_INDEX (DSPF_ARGB)]     = SURF_ARGB8888,
+     [DFB_PIXELFORMAT_INDEX (DSPF_A8)]       = SURF_A8,
+     [DFB_PIXELFORMAT_INDEX (DSPF_YUY2)]     = SURF_NULL_PAD,
+     [DFB_PIXELFORMAT_INDEX (DSPF_RGB332)]   = SURF_NULL_PAD,
+     [DFB_PIXELFORMAT_INDEX (DSPF_UYVY)]     = SURF_YCBCR422R,
+     [DFB_PIXELFORMAT_INDEX (DSPF_I420)]     = SURF_NULL_PAD,
+     [DFB_PIXELFORMAT_INDEX (DSPF_YV12)]     = SURF_NULL_PAD,
+     [DFB_PIXELFORMAT_INDEX (DSPF_LUT8)]     = SURF_CLUT8,
+     [DFB_PIXELFORMAT_INDEX (DSPF_ALUT44)]   = SURF_ACLUT44,
+     [DFB_PIXELFORMAT_INDEX (DSPF_AiRGB)]    = SURF_NULL_PAD,
+     [DFB_PIXELFORMAT_INDEX (DSPF_A1)]       = SURF_A1,
+     [DFB_PIXELFORMAT_INDEX (DSPF_NV12)]     = SURF_NULL_PAD,
+     [DFB_PIXELFORMAT_INDEX (DSPF_NV16)]     = SURF_NULL_PAD,
+     [DFB_PIXELFORMAT_INDEX (DSPF_ARGB2554)] = SURF_NULL_PAD,
+     [DFB_PIXELFORMAT_INDEX (DSPF_ARGB4444)] = SURF_ARGB4444,
+     [DFB_PIXELFORMAT_INDEX (DSPF_RGBA4444)] = SURF_NULL_PAD,
+     [DFB_PIXELFORMAT_INDEX (DSPF_NV21)]     = SURF_NULL_PAD,
+     [DFB_PIXELFORMAT_INDEX (DSPF_AYUV)]     = SURF_NULL_PAD,
+     [DFB_PIXELFORMAT_INDEX (DSPF_A4)]       = SURF_NULL_PAD,
+     [DFB_PIXELFORMAT_INDEX (DSPF_ARGB1666)] = SURF_NULL_PAD,
+     [DFB_PIXELFORMAT_INDEX (DSPF_ARGB6666)] = SURF_NULL_PAD,
+     [DFB_PIXELFORMAT_INDEX (DSPF_RGB18)]    = SURF_NULL_PAD,
+     [DFB_PIXELFORMAT_INDEX (DSPF_LUT2)]     = SURF_CLUT2,
+     [DFB_PIXELFORMAT_INDEX (DSPF_RGB444)]   = SURF_NULL_PAD,
+     [DFB_PIXELFORMAT_INDEX (DSPF_RGB555)]   = SURF_NULL_PAD,
+     [DFB_PIXELFORMAT_INDEX (DSPF_BGR555)]   = SURF_NULL_PAD,
+     [DFB_PIXELFORMAT_INDEX (DSPF_RGBA5551)] = SURF_NULL_PAD,
+     [DFB_PIXELFORMAT_INDEX (DSPF_YUV444P)]  = SURF_NULL_PAD,
+     [DFB_PIXELFORMAT_INDEX (DSPF_ARGB8565)] = SURF_ARGB8565,
+     [DFB_PIXELFORMAT_INDEX (DSPF_AVYU)]     = SURF_ACRYCB8888,
+     [DFB_PIXELFORMAT_INDEX (DSPF_VYU)]      = SURF_CRYCB888,
+     [DFB_PIXELFORMAT_INDEX (DSPF_A1_LSB)]   = SURF_NULL_PAD,
+     [DFB_PIXELFORMAT_INDEX (DSPF_YV16)]     = SURF_NULL_PAD,
+#if 0
+     /* unsupported in DirectFB */
+     [DFB_PIXELFORMAT_INDEX (DSPF_BGRA)]     = { SURF_BGRA8888,
+     [DFB_PIXELFORMAT_INDEX (DSPF_LUT1)]     = { SURF_CLUT1,
+     [DFB_PIXELFORMAT_INDEX (DSPF_LUT4)]     = { SURF_CLUT4,
+     [DFB_PIXELFORMAT_INDEX (DSPF_ALUT88)]   = { SURF_ACLUT88,
+#endif
+};
+
+static DFBSurfacePixelFormat
+stmfb_to_dsbf( SURF_FMT fmt )
+{
+     switch (fmt) {
+          case SURF_ARGB1555:   return DSPF_ARGB1555;
+          case SURF_RGB565:     return DSPF_RGB16;
+          case SURF_RGB888:     return DSPF_RGB24;
+          case SURF_ARGB8888:   return DSPF_ARGB;
+          case SURF_A8:         return DSPF_A8;
+          case SURF_YCBCR422R:  return DSPF_UYVY;
+          case SURF_CLUT8:      return DSPF_LUT8;
+          case SURF_ACLUT44:    return DSPF_ALUT44;
+          case SURF_A1:         return DSPF_A1;
+          case SURF_ARGB4444:   return DSPF_ARGB4444;
+          case SURF_CLUT2:      return DSPF_LUT2;
+          case SURF_ARGB8565:   return DSPF_ARGB8565;
+          case SURF_ACRYCB8888: return DSPF_AVYU;
+          case SURF_CRYCB888:   return DSPF_VYU;
+          default:
+               break;
+     }
+     return DSPF_UNKNOWN;
+};
+
+
+/******************************************************************************/
+
+static int
+stmfbdevLayerDataSize( void )
+{
+     D_DEBUG_AT( STMfbdev_Layer, "%s() <- %u\n",
+                 __FUNCTION__, sizeof(STMfbdevLayerSharedData) );
+
+     return sizeof(STMfbdevLayerSharedData);
+}
+
+static int
+stmfbdevRegionDataSize( void )
+{
+     return 0;
+}
+
+static DFBResult
+stmfbdevInitLayer( CoreLayer                  *layer,
+                   void                       *driver_data,
+                   void                       *layer_data,
+                   DFBDisplayLayerDescription *description,
+                   DFBDisplayLayerConfig      *config,
+                   DFBColorAdjustment         *adjustment )
+{
+     const STMfbdev                    * const stmfbdev = driver_data;
+     STMfbdevLayerSharedData           * const shared = layer_data;
+     const struct stmfbio_plane_config *pc;
+     u32                                hw_caps;
+
+     D_DEBUG_AT( STMfbdev_Layer, "%s( %p %d )\n",
+                 __FUNCTION__, layer, stmfbdev->shared->num_layers + 1 );
+
+     D_MAGIC_ASSERT( stmfbdev, STMfbdev );
+     D_MAGIC_ASSERT( stmfbdev->shared, STMfbdevSharedData );
+
+     D_MAGIC_SET( shared, STMfbdevLayerSharedData );
+
+     shared->layerid = stmfbdev->shared->num_layers++;
+
+     shared->shmpool_data = dfb_core_shmpool_data( stmfbdev->core );
+
+     /* remember startup config, so we can restore it on shutdown */
+     shared->orig_planeinfo.layerid = shared->layerid;
+     if (ioctl( stmfbdev->fd, STMFBIO_GET_PLANEMODE, &shared->orig_planeinfo ) < 0) {
+          D_PERROR( "STMfbdev/Layer: Could not get planeinfo!\n" );
+          return errno2result( errno );
+     }
+     shared->orig_planeinfo.activate = STMFBIO_ACTIVATE_IMMEDIATE;
+     shared->cur_planeinfo = shared->orig_planeinfo;
+     pc = &shared->cur_planeinfo.config;
+
+     D_DEBUG_AT( STMfbdev_Layer,
+                 "  -> current: %dx%d @ %d,%d-%dx%d (%d: %s) %ubpp pitch %u @ 0x%08lx\n",
+                 pc->source.w, pc->source.h, pc->dest.x, pc->dest.y,
+                 pc->dest.dim.w, pc->dest.dim.h, pc->format,
+                 dfb_pixelformat_name( stmfb_to_dsbf( pc->format ) ),
+                 pc->bitdepth, pc->pitch, pc->baseaddr );
+
+     /* same for stmfb's extended var */
+     shared->orig_varex.layerid = shared->layerid;
+     if (ioctl( stmfbdev->fd,
+                STMFBIO_GET_VAR_SCREENINFO_EX, &shared->orig_varex ) < 0) {
+          D_PERROR( "STMfbdev/Layer: Could not get extended planeinfo!\n" );
+          return errno2result( errno );
+     }
+     shared->orig_varex.activate = STMFBIO_ACTIVATE_IMMEDIATE;
+     hw_caps = shared->orig_varex.caps;
+     D_DEBUG_AT( STMfbdev_Layer, "  -> extended caps: 0x%08x\n", hw_caps );
+
+     /* allocate space for two colormaps - one to work with ... */
+     shared->cmap_memory[0] = SHMALLOC( shared->shmpool_data, 256 * 2 * 4 );
+     if (!shared->cmap_memory[0])
+          return D_OOSHM();
+     shared->current_cmap.start  = 0;
+     shared->current_cmap.len    = 256;
+     shared->current_cmap.red    = shared->cmap_memory[0] + 256 * 2 * 0;
+     shared->current_cmap.green  = shared->cmap_memory[0] + 256 * 2 * 1;
+     shared->current_cmap.blue   = shared->cmap_memory[0] + 256 * 2 * 2;
+     shared->current_cmap.transp = shared->cmap_memory[0] + 256 * 2 * 3;
+
+     /* ... and one to store the original colormap */
+     shared->cmap_memory[1] = SHMALLOC( shared->shmpool_data, 256 * 2 * 4 );
+     if (!shared->cmap_memory[1]) {
+          SHFREE( shared->shmpool_data, shared->cmap_memory[0] );
+          shared->cmap_memory[0] = NULL;
+          shared->current_cmap.len = 0;
+          return D_OOSHM();
+     }
+     shared->orig_cmap.start  = 0;
+     shared->orig_cmap.len    = 256;
+     shared->orig_cmap.red    = shared->cmap_memory[1] + 256 * 2 * 0;
+     shared->orig_cmap.green  = shared->cmap_memory[1] + 256 * 2 * 1;
+     shared->orig_cmap.blue   = shared->cmap_memory[1] + 256 * 2 * 2;
+     shared->orig_cmap.transp = shared->cmap_memory[1] + 256 * 2 * 3;
+
+     if (ioctl( stmfbdev->fd, FBIOGETCMAP, &shared->orig_cmap ) < 0) {
+          D_DEBUG( "STMfbdev/Layer: Could not retrieve palette for backup!\n" );
+
+          memset( &shared->orig_cmap, 0, sizeof(shared->orig_cmap) );
+
+          SHFREE( shared->shmpool_data, shared->cmap_memory[1] );
+          shared->cmap_memory[1] = NULL;
+     }
+
+
+     /* set name */
+     snprintf( description->name, sizeof (description->name),
+               "STM Layer %d", shared->cur_planeinfo.layerid );
+
+     /* set capabilities and type */
+     description->caps = (DLCAPS_SURFACE
+                          | DLCAPS_SCREEN_POSITION | DLCAPS_SCREEN_SIZE
+                          | DLCAPS_SCREEN_LOCATION
+                          | DLCAPS_ALPHACHANNEL
+                         );
+     description->type = DLTF_GRAPHICS;
+     description->regions = 1;
+
+     /* fill out the default configuration */
+     config->flags      = (DLCONF_WIDTH | DLCONF_HEIGHT | DLCONF_PIXELFORMAT
+                           | DLCONF_BUFFERMODE
+                           | DLCONF_OPTIONS
+                          );
+     config->buffermode = DLBM_FRONTONLY;
+     if (D_FLAGS_ARE_SET (dfb_config->layers[shared->layerid].config.flags,
+                          (DLCONF_WIDTH | DLCONF_HEIGHT))) {
+          config->width = dfb_config->layers[shared->layerid].config.width;
+          config->height = dfb_config->layers[shared->layerid].config.height;
+     }
+     else if (dfb_config->mode.width && dfb_config->mode.height) {
+          config->width = dfb_config->mode.width;
+          config->height = dfb_config->mode.height;
+     }
+     else {
+          config->width = pc->source.w;
+          config->height = pc->source.h;
+     }
+     if (D_FLAGS_ARE_SET (dfb_config->layers[shared->layerid].config.flags,
+                          DLCONF_PIXELFORMAT))
+          config->pixelformat = dfb_config->layers[shared->layerid].config.pixelformat;
+     else if (dfb_config->mode.format)
+          config->pixelformat = dfb_config->mode.format;
+     else
+          config->pixelformat = stmfb_to_dsbf( pc->format );
+
+     config->options = DLOP_ALPHACHANNEL;
+
+     adjustment->flags = DCAF_NONE;
+
+     shared->supported_options     = DLOP_ALPHACHANNEL;
+     shared->supported_adjustments = DCAF_NONE;
+     shared->supported_surfacecaps = DSCAPS_NONE;
+
+     if (D_FLAGS_IS_SET( hw_caps, STMFBIO_VAR_CAPS_COLOURKEY )) {
+          D_DEBUG_AT( STMfbdev_Layer, "    +> src colorkey\n" );
+          description->caps |= DLCAPS_SRC_COLORKEY;
+          shared->supported_options |= DLOP_SRC_COLORKEY;
+     }
+     if (D_FLAGS_IS_SET( hw_caps, STMFBIO_VAR_CAPS_FLICKER_FILTER )) {
+          D_DEBUG_AT( STMfbdev_Layer, "    +> flicker filtering (state: %d)\n",
+                      shared->orig_varex.ff_state );
+          description->caps |= DLCAPS_FLICKER_FILTERING;
+          shared->supported_options |= DLOP_FLICKER_FILTERING;
+     }
+     if (D_FLAGS_IS_SET( hw_caps, STMFBIO_VAR_CAPS_PREMULTIPLIED )) {
+          D_DEBUG_AT( STMfbdev_Layer, "    +> pre-multiplied alpha (state: %d)\n",
+                      shared->orig_varex.premultiplied_alpha );
+          description->caps |= DLCAPS_PREMULTIPLIED;
+          shared->supported_surfacecaps |= DSCAPS_PREMULTIPLIED;
+
+          /* we force this to on! */
+          config->flags |= DLCONF_SURFACE_CAPS;
+          config->surface_caps = DSCAPS_PREMULTIPLIED;
+     }
+     if (D_FLAGS_IS_SET( hw_caps, STMFBIO_VAR_CAPS_OPACITY )) {
+          D_DEBUG_AT( STMfbdev_Layer, "    +> opacity (%d)\n",
+                      shared->orig_varex.opacity );
+          description->caps |= DLCAPS_OPACITY;
+          shared->supported_options |= DLOP_OPACITY;
+
+          config->options |= DLOP_OPACITY;
+          /* Strangely we cannot specify the default layer opacity, lets hope
+             it's fully opaque! */
+     }
+     if (D_FLAGS_IS_SET( hw_caps, (STMFBIO_VAR_CAPS_GAIN
+                                   | STMFBIO_VAR_CAPS_BRIGHTNESS ))) {
+          D_DEBUG_AT( STMfbdev_Layer, "    +> brightness/gain adjustment (%d %d)\n",
+                      shared->orig_varex.brightness, shared->orig_varex.gain );
+          description->caps |= DLCAPS_BRIGHTNESS;
+          shared->supported_adjustments |= DCAF_BRIGHTNESS;
+
+          adjustment->flags |= DCAF_BRIGHTNESS;
+          adjustment->brightness = 0x8000;
+     }
+     if (D_FLAGS_IS_SET( hw_caps, STMFBIO_VAR_CAPS_CONTRAST )) {
+          D_DEBUG_AT( STMfbdev_Layer, "    +> contrast adjustment (%d)\n",
+                      shared->orig_varex.contrast );
+          description->caps |= DLCAPS_CONTRAST;
+          shared->supported_adjustments |= DCAF_CONTRAST;
+
+          adjustment->flags |= DCAF_CONTRAST;
+          adjustment->contrast = 0x8000;
+     }
+     if (D_FLAGS_IS_SET( hw_caps, STMFBIO_VAR_CAPS_TINT )) {
+          D_DEBUG_AT( STMfbdev_Layer, "    +> tint adjustment (%d)\n",
+                      shared->orig_varex.tint );
+          description->caps |= DLCAPS_HUE;
+          shared->supported_adjustments |= DCAF_HUE;
+
+          adjustment->flags |= DCAF_HUE;
+          adjustment->hue = 0x8000;
+     }
+     if (D_FLAGS_IS_SET( hw_caps, STMFBIO_VAR_CAPS_SATURATION )) {
+          D_DEBUG_AT( STMfbdev_Layer, "    +> saturation adjustment (%d)\n",
+                      shared->orig_varex.saturation );
+          description->caps |= DLCAPS_SATURATION;
+          shared->supported_adjustments |= DCAF_SATURATION;
+
+          adjustment->flags |= DCAF_SATURATION;
+          adjustment->saturation = 0x8000;
+     }
+     if (D_FLAGS_IS_SET( hw_caps, STMFBIO_VAR_CAPS_ALPHA_RAMP )) {
+          D_DEBUG_AT( STMfbdev_Layer, "    +> RGB1555 alpha ramp\n" );
+          description->caps |= DLCAPS_ALPHA_RAMP;
+     }
+     if (D_FLAGS_IS_SET( hw_caps, STMFBIO_VAR_CAPS_ZPOSITION )) {
+          D_DEBUG_AT( STMfbdev_Layer, "    +> plane re-ordering (%d)\n",
+                      shared->orig_varex.z_position );
+          description->caps |= DLCAPS_LEVELS;
+          description->level = shared->orig_varex.z_position;
+       }
+
+     return DFB_OK;
+}
+
+static DFBResult
+stmfbdevShutdownLayer( CoreLayer *layer,
+                       void      *driver_data,
+                       void      *layer_data )
+{
+     const STMfbdev          * const stmfbdev = driver_data;
+     STMfbdevLayerSharedData * const shared = layer_data;
+
+     D_DEBUG_AT( STMfbdev_Layer, "%s()\n", __FUNCTION__ );
+
+     D_MAGIC_ASSERT( stmfbdev, STMfbdev );
+     D_MAGIC_ASSERT( shared, STMfbdevLayerSharedData );
+
+     if (shared->cmap_memory[1]) {
+          if (ioctl( stmfbdev->fd, FBIOPUTCMAP, &shared->orig_cmap ) < 0)
+               D_DEBUG( "STMfbdev/Layer: "
+                        "Could not restore palette!\n" );
+
+          SHFREE( shared->shmpool_data, shared->cmap_memory[1] );
+     }
+
+     if (shared->cmap_memory[0])
+          SHFREE( shared->shmpool_data, shared->cmap_memory[0] );
+
+     /* restore the original plane configuration */
+     if (ioctl( stmfbdev->fd, STMFBIO_SET_PLANEMODE, &shared->orig_planeinfo ) < 0)
+          D_PERROR( "STMfbdev/Layer: Could not restore planeinfo\n" );
+
+     /* restore the extended state */
+     if (ioctl( stmfbdev->fd, STMFBIO_SET_VAR_SCREENINFO_EX, &shared->orig_varex ) < 0)
+          D_PERROR( "STMfbdev/Layer: Could not restore extended state\n" );
+
+     D_MAGIC_CLEAR( shared );
+
+     return DFB_OK;
+}
+
+static DFBResult
+stmfbdevTestRegion( CoreLayer                  *layer,
+                    void                       *driver_data,
+                    void                       *layer_data,
+                    CoreLayerRegionConfig      *config,
+                    CoreLayerRegionConfigFlags *failed )
+{
+     const STMfbdev             * const stmfbdev = driver_data;
+     STMfbdevLayerSharedData    * const shared = layer_data;
+     struct stmfbio_planeinfo    plane;
+     CoreLayerRegionConfigFlags  fail = CLRCF_NONE;
+
+     D_DEBUG_AT( STMfbdev_Layer, "%s()\n", __FUNCTION__ );
+
+     D_MAGIC_ASSERT( stmfbdev, STMfbdev );
+     D_MAGIC_ASSERT( shared, STMfbdevLayerSharedData );
+     D_ASSERT( config != NULL );
+
+     (void) stmfbdev;
+
+     DFB_CORE_LAYER_REGION_CONFIG_DEBUG_AT( STMfbdev_Layer, config );
+
+     if (D_FLAGS_INVALID( config->options, shared->supported_options ))
+          fail |= CLRCF_OPTIONS;
+
+     /* some defaults - the original base address should always be ok, as it
+        should be at the beginning of the framebuffer, thus any plane should
+        fit. */
+     plane.layerid = shared->orig_planeinfo.layerid;
+     plane.config.baseaddr = shared->orig_planeinfo.config.baseaddr;
+
+     /* we can't (and don't want to) test these individually, as the driver
+        does some comprehensive checking on the parameters, and they must
+        all be consistent, e.g. size/pitch/memory/scaling etc. */
+     plane.activate = STMFBIO_ACTIVATE_TEST;
+     plane.config.source.w = config->width;
+     plane.config.source.h = config->height;
+     plane.config.dest.x = config->dest.x;
+     plane.config.dest.y = config->dest.y;
+     plane.config.dest.dim.w = config->dest.w;
+     plane.config.dest.dim.h = config->dest.h;
+     plane.config.format = dspf_to_stmfb[DFB_PIXELFORMAT_INDEX( config->format )];
+     plane.config.pitch = DFB_BYTES_PER_LINE( config->format, config->width );
+     if (ioctl( stmfbdev->fd, STMFBIO_SET_PLANEMODE, &plane ) < 0)
+          fail |= CLRCF_FORMAT | CLRCF_WIDTH | CLRCF_HEIGHT | CLRCF_DEST;
+
+     /* can there be more flags set? */
+     if (D_FLAGS_IS_SET( config->surface_caps, DSCAPS_PREMULTIPLIED )
+         && !D_FLAGS_IS_SET( shared->supported_surfacecaps,
+                             DSCAPS_PREMULTIPLIED ))
+          fail |= CLRCF_SURFACE_CAPS;
+
+     if (failed)
+          *failed = fail;
+
+     if (fail) {
+          D_DEBUG_AT( STMfbdev_Layer, "  => FAILED!\n" );
+          return DFB_UNSUPPORTED;
+     }
+
+     D_DEBUG_AT( STMfbdev_Layer, "  => SUCCESS\n" );
+
+     return DFB_OK;
+}
+
+static DFBResult
+stmfbdevAddRegion( CoreLayer             *layer,
+                   void                  *driver_data,
+                   void                  *layer_data,
+                   void                  *region_data,
+                   CoreLayerRegionConfig *config )
+{
+     const STMfbdev          * const stmfbdev = driver_data;
+     STMfbdevLayerSharedData * const shared = layer_data;
+
+     D_DEBUG_AT( STMfbdev_Layer, "%s()\n", __FUNCTION__ );
+
+     D_MAGIC_ASSERT( stmfbdev, STMfbdev );
+     D_MAGIC_ASSERT( shared, STMfbdevLayerSharedData );
+     D_ASSERT( config != NULL );
+
+     (void) stmfbdev;
+     (void) shared;
+
+     return DFB_OK;
+}
+
+static DFBResult
+stmfbdevSetRegion( CoreLayer                  *layer,
+                   void                       *driver_data,
+                   void                       *layer_data,
+                   void                       *region_data,
+                   CoreLayerRegionConfig      *config,
+                   CoreLayerRegionConfigFlags  updated,
+                   CoreSurface                *surface,
+                   CorePalette                *palette,
+                   CoreSurfaceBufferLock      *lock )
+{
+     const STMfbdev                   * const stmfbdev = driver_data;
+     STMfbdevLayerSharedData          * const shared = layer_data;
+     struct stmfbio_planeinfo          plane;
+     struct stmfbio_var_screeninfo_ex  var_ex;
+     u32                               hw_caps;
+     bool                              need_update = false;
+
+     D_DEBUG_AT( STMfbdev_Layer, "%s()\n", __FUNCTION__ );
+
+     D_MAGIC_ASSERT( stmfbdev, STMfbdev );
+     D_MAGIC_ASSERT( shared, STMfbdevLayerSharedData );
+     D_ASSERT( config != NULL );
+
+     (void) stmfbdev;
+
+     if (updated)
+          DFB_CORE_LAYER_REGION_CONFIG_DEBUG_AT( STMfbdev_Layer, config );
+
+     D_DEBUG_AT( STMfbdev_Layer, "  -> updated: %x\n", updated);
+
+     plane.layerid = shared->cur_planeinfo.layerid;
+     plane.activate = STMFBIO_ACTIVATE_IMMEDIATE;
+     plane.config = shared->cur_planeinfo.config;
+
+     /* Update position? */
+     if (D_FLAGS_IS_SET( updated, CLRCF_DEST )) {
+          /* Set horizontal and vertical offset & size. */
+          D_DEBUG_AT( STMfbdev_Layer, "    +> destination: %d,%d - %dx%d\n",
+                      config->dest.x, config->dest.y,
+                      config->dest.w, config->dest.h );
+
+          need_update = true;
+
+          plane.config.dest.x = config->dest.x;
+          plane.config.dest.y = config->dest.y;
+          plane.config.dest.dim.w = config->dest.w;
+          plane.config.dest.dim.h = config->dest.h;
+     }
+
+     /* Update size? */
+     if (D_FLAGS_IS_SET( updated, (CLRCF_WIDTH | CLRCF_HEIGHT) )) {
+          /* Set width and height. */
+          D_DEBUG_AT( STMfbdev_Layer, "    +> width/height: %dx%d, vp: %d,%d - %dx%d\n",
+                      config->width, config->height,
+                      config->source.x, config->source.y,
+                      config->source.w, config->source.h);
+
+          need_update = true;
+
+          /* FIXME: stmfb driver API is incomplete! Should be updated to
+             support a real source 'viewport' inside a source surface. */
+          plane.config.source.w = config->width;
+          plane.config.source.h = config->height;
+
+          /* fixme: clipping? */
+#if 0
+          if (config->dest.x + config->width > screen_width)
+               plane.config.source.w = screen_width - config->dest.x;
+
+          if (config->dest.y + config->height > screen_height)
+               plane.config.source.h = screen_height - config->dest.y;
+#endif
+     }
+     D_ASSUME (config->width == config->source.w);
+     D_ASSUME (config->height == config->source.h);
+     D_ASSUME (config->source.x == 0);
+     D_ASSUME (config->source.y == 0);
+
+     /* Update surface? */
+     if (D_FLAGS_IS_SET( updated, CLRCF_SURFACE )) {
+          /* Set buffer base address and pitch. */
+          D_DEBUG_AT( STMfbdev_Layer,
+                      "    +> offset 0x%.8lx, pitch %d, addr %p, phys 0x%.8lx\n",
+                      lock->offset, lock->pitch, lock->addr, lock->phys);
+
+          need_update = true;
+
+          plane.config.baseaddr = lock->phys;
+          plane.config.pitch = lock->pitch;
+     }
+
+     /* Update format? */
+     if (D_FLAGS_IS_SET( updated, CLRCF_FORMAT )) {
+          /* Set pixel format. */
+          switch (config->format) {
+               case STM_supported_pixelformat:
+                    plane.config.format = dspf_to_stmfb[DFB_PIXELFORMAT_INDEX( config->format )];
+                    need_update = true;
+                    break;
+
+               default:
+                    break;
+          }
+
+          D_DEBUG_AT( STMfbdev_Layer, "    +> pixelformat: %x (%s) -> %d\n",
+                      config->format, dfb_pixelformat_name( config->format ),
+                      plane.config.format );
+     }
+     D_ASSUME( surface->config.format == config->format );
+
+
+     /* now for the extended state stuff */
+     hw_caps = shared->orig_varex.caps;
+     var_ex.layerid = shared->orig_varex.layerid;
+     var_ex.activate = STMFBIO_ACTIVATE_IMMEDIATE;
+     var_ex.caps = 0;
+
+     if (D_FLAGS_IS_SET( updated, CLRCF_OPTIONS )) {
+          D_DEBUG_AT( STMfbdev_Layer, "    +> options: 0x%.8x %s%s%s%s%s%s%s\n",
+                      config->options,
+                      (config->options & DLOP_ALPHACHANNEL) ? "ALPHA " : "",
+                      (config->options & DLOP_FLICKER_FILTERING) ? "FLICKER " : "",
+                      (config->options & DLOP_DEINTERLACING) ? "DEI " : "",
+                      (config->options & DLOP_SRC_COLORKEY) ? "SRCKEY " : "",
+                      (config->options & DLOP_DST_COLORKEY) ? "DSTKEY " : "",
+                      (config->options & DLOP_OPACITY) ? "OPACITY " : "",
+                      (config->options & DLOP_FIELD_PARITY) ? "PARITY " : "" );
+
+          D_ASSUME( D_FLAGS_IS_SET( config->options, DLOP_ALPHACHANNEL ));
+
+          if (D_FLAGS_IS_SET( hw_caps, STMFBIO_VAR_CAPS_FLICKER_FILTER )) {
+               var_ex.caps |= STMFBIO_VAR_CAPS_FLICKER_FILTER;
+               var_ex.ff_state = ((config->options & DLOP_FLICKER_FILTERING)
+                                  ? STMFBIO_FF_ADAPTIVE
+                                  : STMFBIO_FF_OFF
+                                 );
+          }
+     }
+
+     if (D_FLAGS_IS_SET( updated, (CLRCF_OPTIONS | CLRCF_SRCKEY) )) {
+          D_DEBUG_AT( STMfbdev_Layer, "    +> srckey: %02x%02x%02x\n",
+                      config->src_key.r, config->src_key.g, config->src_key.b );
+
+          if (D_FLAGS_IS_SET( hw_caps, STMFBIO_VAR_CAPS_COLOURKEY )) {
+
+               var_ex.caps |= STMFBIO_VAR_CAPS_COLOURKEY;
+               var_ex.colourKeyFlags = ((config->options & DLOP_SRC_COLORKEY)
+                                        ? STMFBIO_COLOURKEY_FLAGS_ENABLE
+                                        : 0
+                                       );
+               var_ex.min_colour_key
+                    = var_ex.max_colour_key
+                    = PIXEL_ARGB (0, config->src_key.r, config->src_key.g,
+                                  config->src_key.b);
+          }
+     }
+
+     if (D_FLAGS_IS_SET( updated, CLRCF_SURFACE_CAPS )) {
+          D_DEBUG_AT( STMfbdev_Layer, "    +> surface caps: %spremultiplied alpha\n",
+                      ((config->surface_caps & DSCAPS_PREMULTIPLIED)
+                       ? "" : "non-") );
+
+          D_ASSUME( D_FLAGS_IS_SET( hw_caps, STMFBIO_VAR_CAPS_PREMULTIPLIED ));
+
+          var_ex.caps |= STMFBIO_VAR_CAPS_PREMULTIPLIED;
+          var_ex.premultiplied_alpha = ((config->surface_caps & DSCAPS_PREMULTIPLIED)
+                                        ? 1
+                                        : 0
+                                       );
+     }
+
+     if (D_FLAGS_IS_SET( updated, CLRCF_OPACITY )) {
+          D_DEBUG_AT( STMfbdev_Layer, "    +> opacity: %d\n", config->opacity );
+
+          D_ASSUME( D_FLAGS_IS_SET( hw_caps, STMFBIO_VAR_CAPS_OPACITY ));
+
+          var_ex.caps |= STMFBIO_VAR_CAPS_OPACITY;
+          var_ex.opacity = ((config->options & DLOP_OPACITY)
+                            ? config->opacity
+                            : 255
+                           );
+     }
+
+     if (D_FLAGS_IS_SET( updated, CLRCF_ALPHA_RAMP )) {
+          D_DEBUG_AT( STMfbdev_Layer, "    +> alpha ramp: 0x%02x 0x%02x 0x%02x 0x%02x\n",
+                      config->alpha_ramp[0], config->alpha_ramp[1],
+                      config->alpha_ramp[2], config->alpha_ramp[3] );
+
+          D_ASSUME( D_FLAGS_IS_SET( hw_caps, STMFBIO_VAR_CAPS_ALPHA_RAMP ));
+
+          var_ex.caps |= STMFBIO_VAR_CAPS_ALPHA_RAMP;
+          var_ex.alpha_ramp[0] = config->alpha_ramp[0];
+          var_ex.alpha_ramp[1] = config->alpha_ramp[3];
+     }
+
+     if (need_update) {
+          if (ioctl( stmfbdev->fd, STMFBIO_SET_PLANEMODE, &plane ) < 0) {
+               D_PERROR( "  => STMFBIO_SET_PLANEINFO failed\n" );
+
+               /* not being able to set the new configuration is fatal, I
+                  would say. */
+               return errno2result( errno );
+          }
+
+          shared->cur_planeinfo = plane;
+     }
+
+     if (var_ex.caps
+         && ioctl( stmfbdev->fd, STMFBIO_SET_VAR_SCREENINFO_EX, &var_ex) < 0)
+          D_PERROR( "  => STMFBIO_SET_VAR_SCREENINFO_EX failed\n" );
+
+     /* Update CLUT? */
+     if (D_FLAGS_IS_SET( updated, CLRCF_PALETTE ) && palette) {
+          struct fb_cmap *cmap = &shared->current_cmap;
+          unsigned int    i;
+
+          cmap->len = ((palette->num_entries <= 256)
+                       ? palette->num_entries : 256);
+
+          D_DEBUG_AT( STMfbdev_Layer, "    +> palette (%u entries)\n", cmap->len);
+
+          for (i = 0; i < cmap->len; ++i) {
+               /* expand to 16 bit */
+               cmap->red[i]    = palette->entries[i].r * 0x0101;
+               cmap->green[i]  = palette->entries[i].g * 0x0101;
+               cmap->blue[i]   = palette->entries[i].b * 0x0101;
+               cmap->transp[i] = (0xff - palette->entries[i].a) * 0x0101;
+          }
+
+          if (ioctl( stmfbdev->fd, FBIOPUTCMAP, cmap ) < 0)
+               D_PERROR( "STMfbdev/Layer: Could not set the palette!\n" );
+     }
+
+     return DFB_OK;
+}
+
+static DFBResult
+stmfbdevRemoveRegion( CoreLayer *layer,
+                      void      *driver_data,
+                      void      *layer_data,
+                      void      *region_data )
+{
+     const STMfbdev          * const stmfbdev = driver_data;
+     STMfbdevLayerSharedData * const shared = layer_data;
+
+     D_DEBUG_AT( STMfbdev_Layer, "%s()\n", __FUNCTION__ );
+
+     D_MAGIC_ASSERT( stmfbdev, STMfbdev );
+     D_MAGIC_ASSERT( shared, STMfbdevLayerSharedData );
+
+     (void) stmfbdev;
+     (void) shared;
+
+     return DFB_OK;
+}
+
+static DFBResult
+stmfbdevFlipRegion( CoreLayer             *layer,
+                    void                  *driver_data,
+                    void                  *layer_data,
+                    void                  *region_data,
+                    CoreSurface           *surface,
+                    DFBSurfaceFlipFlags    flags,
+                    CoreSurfaceBufferLock *lock )
+{
+     const STMfbdev           * const stmfbdev = driver_data;
+     STMfbdevLayerSharedData  * const shared = layer_data;
+     struct stmfbio_plane_pan  pan;
+
+     D_DEBUG_AT( STMfbdev_Layer, "%s()\n", __FUNCTION__ );
+
+     D_MAGIC_ASSERT( stmfbdev, STMfbdev );
+     D_MAGIC_ASSERT( shared, STMfbdevLayerSharedData );
+
+     D_DEBUG_AT( STMfbdev_Layer, "  -> buffer: %p\n", lock->buffer );
+     D_DEBUG_AT( STMfbdev_Layer,
+                 "  -> offset 0x%.8lx, pitch %d, addr %p, phys 0x%.8lx\n",
+                 lock->offset, lock->pitch, lock->addr, lock->phys);
+
+     pan.layerid = shared->cur_planeinfo.layerid;
+     pan.activate = (((flags & DSFLIP_WAITFORSYNC) == DSFLIP_ONSYNC)
+                     ? STMFBIO_ACTIVATE_VBL : STMFBIO_ACTIVATE_IMMEDIATE);
+     pan.baseaddr = lock->phys;
+
+     if (((flags & DSFLIP_WAITFORSYNC) == DSFLIP_WAITFORSYNC)
+         && !dfb_config->pollvsync_after)
+          dfb_screen_wait_vsync( layer->screen );
+
+     if (ioctl( stmfbdev->fd, STMFBIO_PAN_PLANE, &pan ) < 0) {
+          D_PERROR( "STMfbdev/Layer: Panning display to %lx (%s) failed\n",
+                    pan.baseaddr,
+                    (pan.activate & STMFBIO_ACTIVATE_VBL) ? "vbl" : "now");
+
+          return errno2result( errno );
+     }
+
+     if ((flags & DSFLIP_WAIT)
+         && (dfb_config->pollvsync_after || !(flags & DSFLIP_ONSYNC)))
+          dfb_screen_wait_vsync( dfb_screens_at( DSCID_PRIMARY ) );
+
+     dfb_surface_flip( surface, false );
+
+     shared->cur_planeinfo.config.baseaddr = pan.baseaddr;
+
+     return DFB_OK;
+}
+
+static DFBResult
+stmfbdevGetLevel( CoreLayer *layer,
+                  void      *driver_data,
+                  void      *layer_data,
+                  int       *level )
+{
+     const STMfbdev                   * const stmfbdev = driver_data;
+     const STMfbdevLayerSharedData    * const shared = layer_data;
+     struct stmfbio_var_screeninfo_ex  var_ex;
+
+     D_DEBUG_AT( STMfbdev_Layer, "%s()\n", __FUNCTION__ );
+
+     D_MAGIC_ASSERT( stmfbdev, STMfbdev );
+     D_MAGIC_ASSERT( shared, STMfbdevLayerSharedData );
+
+     (void) stmfbdev;
+
+     if (!D_FLAGS_IS_SET( shared->orig_varex.caps, STMFBIO_VAR_CAPS_ZPOSITION ))
+          return DFB_UNSUPPORTED;
+
+     var_ex.layerid = shared->orig_varex.layerid;
+     if (ioctl( stmfbdev->fd, STMFBIO_GET_VAR_SCREENINFO_EX, &var_ex ) < 0 )
+          return errno2result( errno );
+
+     *level = (int) var_ex.z_position;
+
+     return DFB_OK;
+}
+
+static DFBResult
+stmfbdevSetLevel( CoreLayer *layer,
+                  void      *driver_data,
+                  void      *layer_data,
+                  int        level )
+{
+     const STMfbdev                   * const stmfbdev = driver_data;
+     const STMfbdevLayerSharedData    * const shared = layer_data;
+     struct stmfbio_var_screeninfo_ex  var_ex;
+
+     D_DEBUG_AT( STMfbdev_Layer, "%s()\n", __FUNCTION__ );
+
+     D_MAGIC_ASSERT( stmfbdev, STMfbdev );
+     D_MAGIC_ASSERT( shared, STMfbdevLayerSharedData );
+
+     (void) stmfbdev;
+
+     D_DEBUG_AT( STMfbdev_Layer, "  -> %d\n", level );
+
+     if (!D_FLAGS_IS_SET( shared->orig_varex.caps, STMFBIO_VAR_CAPS_ZPOSITION ))
+          return DFB_UNSUPPORTED;
+
+     var_ex.layerid = shared->orig_varex.layerid;
+     var_ex.activate = STMFBIO_ACTIVATE_IMMEDIATE;
+     var_ex.caps = STMFBIO_VAR_CAPS_ZPOSITION;
+     var_ex.z_position = (level < 0) ? 0 : level;
+
+     if (ioctl( stmfbdev->fd, STMFBIO_SET_VAR_SCREENINFO_EX, &var_ex ) < 0 )
+          return errno2result( errno );
+
+     return DFB_OK;
+}
+
+static DFBResult
+stmfbdevSetColorAdjustment( CoreLayer          *layer,
+                            void               *driver_data,
+                            void               *layer_data,
+                            DFBColorAdjustment *adjustment )
+{
+     const STMfbdev                   * const stmfbdev = driver_data;
+     const STMfbdevLayerSharedData    * const shared = layer_data;
+     struct stmfbio_var_screeninfo_ex  var_ex;
+
+     D_DEBUG_AT( STMfbdev_Layer, "%s()\n", __FUNCTION__ );
+
+     D_MAGIC_ASSERT( stmfbdev, STMfbdev );
+     D_MAGIC_ASSERT( shared, STMfbdevLayerSharedData );
+
+     (void) stmfbdev;
+
+     if (D_FLAGS_INVALID( adjustment->flags, shared->supported_adjustments ))
+          return DFB_INVARG;
+
+     var_ex.layerid = shared->orig_varex.layerid;
+     var_ex.activate = STMFBIO_ACTIVATE_IMMEDIATE;
+     var_ex.caps = 0;
+
+     D_DEBUG_AT( STMfbdev_Layer, "  -> flags: %x\n", adjustment->flags );
+
+     if (D_FLAGS_IS_SET( adjustment->flags, DCAF_BRIGHTNESS )) {
+          D_DEBUG_AT( STMfbdev_Layer, "    +> brightness: 0x%04x\n",
+                      adjustment->brightness );
+
+          if (D_FLAGS_IS_SET( shared->orig_varex.caps,
+                              STMFBIO_VAR_CAPS_BRIGHTNESS )) {
+               var_ex.caps |= STMFBIO_VAR_CAPS_BRIGHTNESS;
+               var_ex.brightness = adjustment->brightness >> 8;
+          }
+          else {
+               var_ex.caps |= STMFBIO_VAR_CAPS_GAIN;
+               /* 0-0x8000 -> 0-255 */
+               var_ex.gain = ((adjustment->brightness > 0x8000)
+                              ? 255
+                              : (((adjustment->brightness >> 8) * 255) / 128)
+                             );
+          }
+     }
+
+     if (D_FLAGS_IS_SET( adjustment->flags, DCAF_CONTRAST )) {
+          D_DEBUG_AT( STMfbdev_Layer, "    +> contrast: 0x%04x\n",
+                      adjustment->contrast );
+
+          var_ex.caps |= STMFBIO_VAR_CAPS_CONTRAST;
+          var_ex.contrast = adjustment->contrast >> 8;
+     }
+
+     if (D_FLAGS_IS_SET( adjustment->flags, DCAF_HUE )) {
+          D_DEBUG_AT( STMfbdev_Layer, "    +> hue: 0x%04x\n",
+                      adjustment->hue );
+
+          var_ex.caps |= STMFBIO_VAR_CAPS_TINT;
+          var_ex.tint = adjustment->hue >> 8;
+     }
+
+     if (D_FLAGS_IS_SET( adjustment->flags, DCAF_SATURATION )) {
+          D_DEBUG_AT( STMfbdev_Layer, "    +> saturation: 0x%04x\n",
+                      adjustment->saturation );
+
+          var_ex.caps |= STMFBIO_VAR_CAPS_SATURATION;
+          var_ex.saturation = adjustment->saturation >> 8;
+     }
+
+     if (ioctl( stmfbdev->fd, STMFBIO_SET_VAR_SCREENINFO_EX, &var_ex ) < 0 )
+          return errno2result( errno );
+
+     return DFB_OK;
+}
+
+
+DisplayLayerFuncs _g_stmfbdevLayerFuncs = {
+     .LayerDataSize  = stmfbdevLayerDataSize,
+     .RegionDataSize = stmfbdevRegionDataSize,
+
+     .InitLayer     = stmfbdevInitLayer,
+     .ShutdownLayer = stmfbdevShutdownLayer,
+
+     .TestRegion   = stmfbdevTestRegion,
+     .AddRegion    = stmfbdevAddRegion,
+     .SetRegion    = stmfbdevSetRegion,
+     .RemoveRegion = stmfbdevRemoveRegion,
+     .FlipRegion   = stmfbdevFlipRegion,
+
+     .GetLevel = stmfbdevGetLevel,
+     .SetLevel = stmfbdevSetLevel,
+
+     .SetColorAdjustment = stmfbdevSetColorAdjustment,
+};
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/gfxdrivers/stgfx2/stmfbdev_screen.c DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/stmfbdev_screen.c
--- DirectFB/gfxdrivers/stgfx2/stmfbdev_screen.c	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/stmfbdev_screen.c	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,1269 @@
+/*
+   (c) Copyright 2010       STMicroelectronics (R&D) Ltd.
+   (c) Copyright 2001-2009  The world wide DirectFB Open Source Community (directfb.org)
+   (c) Copyright 2000-2004  Convergence (integrated media) GmbH
+
+   All rights reserved.
+
+   Written by Andr Draszik <andre.draszik@st.com>.
+
+   Based on work by Denis Oliver Kropp <dok@directfb.org>,
+                    Andreas Hundt <andi@fischlustig.de>,
+                    Sven Neumann <neo@directfb.org>,
+                    Ville Syrjl <syrjala@sci.fi> and
+                    Claudio Ciccani <klan@users.sf.net>.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+
+#include <sys/ioctl.h>
+#include <string.h>
+
+#include <asm/types.h>
+#include <linux/stmfb.h>
+
+#include <directfb.h>
+
+#include <direct/memcpy.h>
+
+#include <core/coretypes.h>
+#include <core/screens.h>
+
+#include <misc/conf.h>
+
+#include "stmfbdev/stmfbdev.h"
+#include "stmfbdev/fb.h"
+#ifndef FBIO_WAITFORVSYNC
+#define FBIO_WAITFORVSYNC	_IOW('F', 0x20, u_int32_t)
+#endif
+
+D_DEBUG_DOMAIN( STMfbdev_Screen, "STMfbdev/Screen", "STMfb System Module Screen Handling" );
+
+
+typedef struct __attribute__((__aligned__(32))) _STMfbdevScreenVideoMode {
+     enum stmfbio_output_standard stm_standard;
+
+     DFBScreenOutputResolution    resolution;
+     DFBScreenEncoderScanMode     scanmode;
+     DFBScreenEncoderFrequency    frequency;
+     DFBScreenEncoderTVStandards  tv_standard;
+
+     struct _STMfbdevScreenVideoMode *next;
+
+#if D_DEBUG_ENABLED
+     const char *frequency_str;
+     const char *resolution_str;
+     const char *scanmode_str;
+     const char *tv_standard_str;
+#endif
+} STMfbdevScreenVideoMode;
+
+#if D_DEBUG_ENABLED
+#  define ASSIGN(x,y) x = y, x##_str = #y
+#else /* D_DEBUG_ENABLED */
+#  define ASSIGN(x,y) x = y
+#endif /* D_DEBUG_ENABLED */
+
+typedef struct {
+     int magic;
+
+     int screenid;
+     /* the DirectFB indexes, assigned to these encoders */
+     unsigned int encoder_main;
+     unsigned int encoder_sd;
+     unsigned int encoder_analog;
+     unsigned int encoder_hdmi;
+     unsigned int encoder_dvo;
+
+     STMfbdevScreenVideoMode             *modes; /* list of modes supported */
+     STMfbdevScreenVideoMode              mode; /* current mode */
+
+     struct stmfbio_outputinfo            orig_info; /* startup */
+     struct stmfbio_output_configuration  orig_config; /* startup */
+
+     FusionSHMPoolShared *shmpool;
+} STMfbdevScreenSharedData;
+
+/******************************************************************************/
+/* Parallel Count carries out bit counting in a parallel fashion. Consider n
+   after the first line has finished executing. Imagine splitting n into
+   pairs of bits. Each pair contains the number of ones in those two bit
+   positions in the original n. After the second line has finished executing,
+   each nibble contains the number of ones in those four bits positions in
+   the original n. Continuing this for five iterations, the 64 bits contain
+   the number of ones among these sixty-four bit positions in the original n.
+   That is what we wanted to compute. */
+
+#define TWO64(c) (0x1llu << (c))
+#define MASK64(c) (((unsigned long long)(-1)) / (TWO64(TWO64(c)) + 1llu))
+#define COUNT64(x,c) ((x) & MASK64(c)) + (((x) >> (TWO64(c))) & MASK64(c))
+static unsigned int
+_bitcount64 (unsigned long long n)
+{
+    n = COUNT64 (n, 0);
+    n = COUNT64 (n, 1);
+    n = COUNT64 (n, 2);
+    n = COUNT64 (n, 3);
+    n = COUNT64 (n, 4);
+    n = COUNT64 (n, 5);
+    return n ;
+}
+
+
+static void
+stmfbdevScreen_build_full_videomode( STMfbdevScreenVideoMode * const m )
+{
+     D_ASSERT( _bitcount64( m->stm_standard ) == 1 );
+
+     /* resolution */
+     if (D_FLAGS_IS_SET( m->stm_standard, STMFBIO_STD_SMPTE274M ))
+          ASSIGN( m->resolution, DSOR_1920_1080 );
+     else if (D_FLAGS_IS_SET( m->stm_standard, STMFBIO_STD_SMPTE296M ))
+          ASSIGN( m->resolution, DSOR_1280_720 );
+     else if (D_FLAGS_IS_SET( m->stm_standard, (STMFBIO_STD_576P_50
+                                                | STMFBIO_STD_625_50) ))
+          ASSIGN( m->resolution, DSOR_720_576 );
+     else if (D_FLAGS_IS_SET( m->stm_standard, (STMFBIO_STD_480P_60
+                                                | STMFBIO_STD_480P_59_94
+                                                | STMFBIO_STD_525_60) ))
+          ASSIGN( m->resolution, DSOR_720_480 );
+     else if (D_FLAGS_IS_SET( m->stm_standard, STMFBIO_STD_VESA ))
+          ASSIGN( m->resolution, DSOR_640_480 );
+     else
+          ASSIGN( m->resolution, DSOR_UNKNOWN );
+
+     /* scanmode */
+     if (D_FLAGS_IS_SET( m->stm_standard, STMFBIO_STD_PROGRESSIVE ))
+          ASSIGN( m->scanmode, DSESM_PROGRESSIVE );
+     else if (D_FLAGS_IS_SET( m->stm_standard, STMFBIO_STD_INTERLACED ))
+          ASSIGN( m->scanmode, DSESM_INTERLACED );
+     else
+          ASSIGN( m->scanmode, DSESM_UNKNOWN );
+
+     /* frequency */
+     if (D_FLAGS_IS_SET( m->stm_standard, STMFBIO_STD_1080P_23_976 ))
+          ASSIGN( m->frequency, DSEF_23_976HZ );
+     else if (D_FLAGS_IS_SET( m->stm_standard, STMFBIO_STD_1080P_24 ))
+          ASSIGN( m->frequency, DSEF_24HZ );
+     else if (D_FLAGS_IS_SET( m->stm_standard, STMFBIO_STD_1080P_25 ))
+          ASSIGN( m->frequency, DSEF_25HZ );
+     else if (D_FLAGS_IS_SET( m->stm_standard, STMFBIO_STD_1080P_29_97 ))
+          ASSIGN( m->frequency, DSEF_29_97HZ );
+     else if (D_FLAGS_IS_SET( m->stm_standard, STMFBIO_STD_1080P_30 ))
+          ASSIGN( m->frequency, DSEF_30HZ );
+     else if (D_FLAGS_IS_SET( m->stm_standard, (STMFBIO_STD_1080P_50
+                                                | STMFBIO_STD_1080I_50
+                                                | STMFBIO_STD_720P_50
+                                                | STMFBIO_STD_576P_50
+                                                | STMFBIO_STD_625_50) ))
+          ASSIGN( m->frequency, DSEF_50HZ );
+     else if (D_FLAGS_IS_SET( m->stm_standard, (STMFBIO_STD_1080P_59_94
+                                                | STMFBIO_STD_1080I_59_94
+                                                | STMFBIO_STD_720P_59_94
+                                                | STMFBIO_STD_480P_59_94
+                                                | STMFBIO_STD_VGA_59_94
+                                                | STMFBIO_STD_525_60) ))
+          ASSIGN( m->frequency, DSEF_59_94HZ );
+     else if (D_FLAGS_IS_SET( m->stm_standard, (STMFBIO_STD_1080P_60
+                                                | STMFBIO_STD_1080I_60
+                                                | STMFBIO_STD_720P_60
+                                                | STMFBIO_STD_480P_60
+                                                | STMFBIO_STD_VGA_60) ))
+          ASSIGN( m->frequency, DSEF_60HZ );
+     else
+          ASSIGN( m->frequency, DSEF_UNKNOWN );
+
+     /* analogue standard - DSETV_PAL and DSETV_NTSC denote _any_ specific
+        compatible standard */
+     if (D_FLAGS_IS_SET( m->stm_standard, STMFBIO_STD_PAL_BDGHI ))
+          ASSIGN( m->tv_standard, DSETV_PAL | DSETV_PAL_BG | DSETV_PAL_I );
+     else if (D_FLAGS_IS_SET( m->stm_standard, STMFBIO_STD_PAL_M ))
+          ASSIGN( m->tv_standard, DSETV_PAL | DSETV_PAL_M );
+     else if (D_FLAGS_IS_SET( m->stm_standard, STMFBIO_STD_PAL_N ))
+          ASSIGN( m->tv_standard, DSETV_PAL | DSETV_PAL_N );
+     else if (D_FLAGS_IS_SET( m->stm_standard, STMFBIO_STD_PAL_Nc ))
+          ASSIGN( m->tv_standard, DSETV_PAL | DSETV_PAL_NC );
+     else if (D_FLAGS_IS_SET( m->stm_standard, STMFBIO_STD_PAL_60 ))
+          ASSIGN( m->tv_standard, DSETV_PAL_60 );
+     else if (D_FLAGS_IS_SET( m->stm_standard, STMFBIO_STD_SECAM ))
+          ASSIGN( m->tv_standard, DSETV_SECAM );
+     else if (D_FLAGS_IS_SET( m->stm_standard, STMFBIO_STD_NTSC_M ))
+          ASSIGN( m->tv_standard, DSETV_NTSC );
+     else if (D_FLAGS_IS_SET( m->stm_standard, STMFBIO_STD_NTSC_M_JP ))
+          ASSIGN( m->tv_standard, DSETV_NTSC | DSETV_NTSC_M_JPN );
+     else if (D_FLAGS_IS_SET( m->stm_standard, STMFBIO_STD_NTSC_443 ))
+          ASSIGN( m->tv_standard, DSETV_NTSC | DSETV_NTSC_443 );
+     else
+          ASSIGN( m->tv_standard, DSETV_DIGITAL );
+}
+
+static DFBResult
+stmfbdevScreen_set_mode( const STMfbdev                * const stmfbdev,
+                         STMfbdevScreenSharedData      * const shared,
+                         const STMfbdevScreenVideoMode * const m,
+                         bool                           test )
+{
+     struct stmfbio_outputinfo info;
+
+     D_DEBUG_AT( STMfbdev_Screen, "%s( mode: %p )\n", __FUNCTION__, m );
+
+     D_MAGIC_ASSERT( shared, STMfbdevScreenSharedData );
+     D_ASSERT( m != NULL );
+
+     /* start with current config */
+     info.outputid = shared->orig_info.outputid;
+
+     info.activate = test ? STMFBIO_ACTIVATE_TEST : STMFBIO_ACTIVATE_IMMEDIATE;
+     info.standard = m->stm_standard;
+
+     D_DEBUG_AT( STMfbdev_Screen, "  -> %.16llx\n", info.standard );
+
+     if (ioctl( stmfbdev->fd, STMFBIO_SET_OUTPUTINFO, &info ) < 0) {
+          D_DEBUG_AT( STMfbdev_Screen, "  => FAILED (%d %m)!\n", errno );
+          return errno2result( errno );
+     }
+
+     D_DEBUG_AT( STMfbdev_Screen, "  => SUCCESS\n" );
+
+     /* remember new config */
+     if (!test) {
+          shared->orig_info.standard = info.standard;
+
+          if (&shared->mode != m)
+               shared->mode = *m;
+     }
+
+     return DFB_OK;
+}
+
+static DFBResult
+stmfbdevScreen_get_supported_modes( const STMfbdev           * const stmfbdev,
+                                    STMfbdevScreenSharedData *shared )
+{
+     struct stmfbio_outputstandards  standards;
+     unsigned int                    n_modes;
+
+     D_DEBUG_AT( STMfbdev_Screen, "%s()\n", __FUNCTION__ );
+
+     D_MAGIC_ASSERT( shared, STMfbdevScreenSharedData );
+
+     /* get output standards supported on the current platform */
+     standards.outputid = shared->orig_info.outputid;
+     if (ioctl( stmfbdev->fd, STMFBIO_GET_OUTPUTSTANDARDS, &standards ) < 0) {
+          D_PERROR( "STMfbdev/Screen: Could not get supported output mode!\n" );
+          return errno2result( errno );
+     }
+
+     n_modes = _bitcount64( standards.all_standards );
+     D_DEBUG_AT( STMfbdev_Screen, "  -> %u modes\n", n_modes );
+
+     shared->modes = SHCALLOC( shared->shmpool, n_modes ? : 1,
+                               sizeof(STMfbdevScreenVideoMode) );
+     if (!shared->modes)
+          return D_OOSHM();
+
+     /* in the (unlikely) case no modes where reported, try the current
+        mode, and if that is not possible, fail. */
+     if (!n_modes) {
+          *shared->modes = shared->mode;
+          if (!stmfbdevScreen_set_mode( stmfbdev, shared, shared->modes, true )) {
+               D_ERROR( "STMfbdev/Screen: "
+                        "No modes announced and current mode not supported!\n" );
+
+               return DFB_INIT;
+          }
+
+          D_DEBUG_AT( STMfbdev_Screen, "  -> Modelist\n" );
+          D_DEBUG_AT( STMfbdev_Screen, "    +> %.16llx: %s %s %s %s\n",
+                      shared->mode.stm_standard, shared->mode.resolution_str,
+                      shared->mode.scanmode_str, shared->mode.frequency_str,
+                      shared->mode.tv_standard_str );
+
+          return DFB_OK;
+     }
+
+     {
+     STMfbdevScreenVideoMode *m = shared->modes;
+
+     D_DEBUG_AT( STMfbdev_Screen, "  -> Modelist\n" );
+     do {
+          m->stm_standard = standards.all_standards & -standards.all_standards;
+          standards.all_standards &= ~m->stm_standard;
+
+          stmfbdevScreen_build_full_videomode( m );
+          D_DEBUG_AT( STMfbdev_Screen, "    +> %.16llx: %.2x %.2x %.2x %.3x %s %s %s %s\n",
+                      m->stm_standard, m->resolution, m->scanmode,
+                      m->frequency, m->tv_standard,
+                      m->resolution_str, m->scanmode_str,
+                      m->frequency_str, m->tv_standard_str );
+
+          m->next = m+1;
+          ++m;
+     } while (--n_modes > 0);
+     --m; m->next = NULL;
+     }
+
+     D_ASSUME( n_modes == 0 );
+     D_ASSUME( standards.all_standards == STMFBIO_STD_UNKNOWN );
+
+     return DFB_OK;
+}
+
+static const STMfbdevScreenVideoMode *
+stmfbdevScreen_find_mode (const STMfbdevScreenSharedData * const shared,
+                          const DFBScreenEncoderConfig   * const config)
+{
+     const STMfbdevScreenVideoMode *m, *best_match;
+
+     D_MAGIC_ASSERT( shared, STMfbdevScreenSharedData );
+     D_ASSERT( config != NULL );
+
+     if (!D_FLAGS_ARE_SET (config->flags, (DSECONF_SCANMODE
+                                           | DSECONF_FREQUENCY
+                                           | DSECONF_RESOLUTION)))
+          return NULL;
+
+     D_DEBUG_AT( STMfbdev_Screen, "%s: %.2x %.2x %.2x %s%.3x%s\n",
+                 __FUNCTION__,
+                 config->resolution, config->scanmode, config->frequency,
+                 (config->flags & DSECONF_TV_STANDARD) ? "" : " (",
+                  config->tv_standard,
+                 (config->flags & DSECONF_TV_STANDARD) ? "" : ")" );
+
+     for (best_match = NULL, m = shared->modes; m; m = m->next) {
+          if (config->frequency != m->frequency)
+               continue;
+          if (config->scanmode != m->scanmode)
+               continue;
+          if (config->resolution != m->resolution)
+               continue;
+
+          if (!(config->flags & DSECONF_TV_STANDARD)) {
+               D_DEBUG_AT( STMfbdev_Screen, "  -> exact: %s %s %s (%s)\n",
+                           m->resolution_str, m->scanmode_str,
+                           m->frequency_str, m->tv_standard_str );
+               return m;
+          }
+
+          if (config->tv_standard == DSETV_ALL)
+               best_match = m;
+          else if ((config->tv_standard & m->tv_standard) == config->tv_standard) {
+               /* exact match */
+               D_DEBUG_AT( STMfbdev_Screen, "  -> exact: %s %s %s %s\n",
+                           m->resolution_str, m->scanmode_str,
+                           m->frequency_str, m->tv_standard_str );
+               return m;
+          }
+     }
+
+     if (!best_match)
+          D_WARN( "  -> couldn't find a matching output standard for res/scan/hz/tv: %.2x %.2x %.2x %s%.3x%s\n",
+                  config->resolution, config->scanmode, config->frequency,
+                  (config->flags & DSECONF_TV_STANDARD) ? "" : "(",
+                  config->tv_standard,
+                  (config->flags & DSECONF_TV_STANDARD) ? "" : ")" );
+     else
+          D_DEBUG_AT( STMfbdev_Screen,
+                      "  -> best match: %s %s %s %s\n",
+                      best_match->resolution_str, best_match->scanmode_str,
+                      best_match->frequency_str,
+                      best_match->tv_standard_str );
+
+     return best_match;
+}
+
+/******************************************************************************/
+
+static int
+stmfbdevScreenDataSize( void )
+{
+     D_DEBUG_AT( STMfbdev_Screen, "%s() <- %u\n",
+                 __FUNCTION__, sizeof(STMfbdevScreenSharedData) );
+
+     return sizeof(STMfbdevScreenSharedData);
+}
+
+static DFBResult
+stmfbdevInitScreen( CoreScreen           *screen,
+                    CoreGraphicsDevice   *device,
+                    void                 *driver_data,
+                    void                 *screen_data,
+                    DFBScreenDescription *description )
+{
+     const STMfbdev           * const stmfbdev = driver_data;
+     STMfbdevScreenSharedData * const shared = screen_data;
+     u32                       hw_caps;
+     int                       n_outputs = -1;
+     int                       n_encoders = -1;
+
+     D_DEBUG_AT( STMfbdev_Screen, "%s( %p %d )\n", __FUNCTION__, screen,
+                 stmfbdev->shared->num_screens + 1 );
+
+     D_MAGIC_ASSERT( stmfbdev, STMfbdev );
+     D_ASSERT( shared != NULL );
+
+     D_MAGIC_SET( shared, STMfbdevScreenSharedData );
+
+     shared->screenid = stmfbdev->shared->num_screens++;
+
+     shared->shmpool = stmfbdev->shared->shmpool;
+
+     shared->encoder_main
+          = shared->encoder_sd
+          = shared->encoder_analog
+          = shared->encoder_hdmi
+          = shared->encoder_dvo
+          = -1;
+
+     /* remember startup output info, so we can restore it on shutdown*/
+     shared->orig_info.outputid = STMFBIO_OUTPUTID_MAIN;
+     if (ioctl( stmfbdev->fd, STMFBIO_GET_OUTPUTINFO, &shared->orig_info ) < 0) {
+          D_PERROR( "STMfbdev/Screen: Could not get current output mode\n" );
+          return errno2result( errno );
+     }
+
+/*     D_DEBUG_AT( STMfbdev_Screen,
+                 "  -> current: %dx%d @ %d,%d-%dx%d (%d: %s) %ubpp pitch %u @ 0x%08lx\n",
+                 pc->source.w, pc->source.h, pc->dest.x, pc->dest.y,
+                 pc->dest.dim.w, pc->dest.dim.h, pc->format,
+                 dfb_pixelformat_name( stmfb_to_dsbf( pc->format ) ),
+                 pc->bitdepth, pc->pitch, pc->baseaddr );
+*/
+     D_DEBUG_AT( STMfbdev_Screen, "  -> current mode: 0x%.16llx\n",
+                  shared->orig_info.standard );
+
+     /* remember stmfb's output config */
+     shared->orig_config.outputid = STMFBIO_OUTPUTID_MAIN;
+     if (ioctl( stmfbdev->fd,
+                STMFBIO_GET_OUTPUT_CONFIG, &shared->orig_config ) < 0) {
+          D_PERROR( "STMfbdev/Screen: Could not get current output config\n" );
+          return errno2result( errno );
+     }
+     hw_caps = shared->orig_config.caps;
+     D_DEBUG_AT( STMfbdev_Screen, "  -> extended caps: 0x%08x\n", hw_caps );
+
+     /* Set the screen name */
+     snprintf( description->name, sizeof (description->name),
+               "STMfbdev Screen %d", shared->screenid );
+
+     /* Set the screen capabilities. */
+     description->caps = DSCCAPS_VSYNC;
+
+     if (D_FLAGS_IS_SET( hw_caps, STMFBIO_OUTPUT_CAPS_MIXER_BACKGROUND )) {
+          D_DEBUG_AT( STMfbdev_Screen, "    +> have mixer background\n" );
+         description->caps |= DSCCAPS_MIXERS;
+         ++description->mixers;
+     }
+
+     if (D_FLAGS_IS_SET( hw_caps, (STMFBIO_OUTPUT_CAPS_ANALOGUE_CONFIG
+                                   | STMFBIO_OUTPUT_CAPS_HDMI_CONFIG
+                                   | STMFBIO_OUTPUT_CAPS_DVO_CONFIG) )) {
+          D_DEBUG_AT( STMfbdev_Screen, "    +> have main encoder\n" );
+          description->caps |= DSCCAPS_ENCODERS;
+          shared->encoder_main = ++n_encoders;
+     }
+     /* all additional encoders are slaved off the main one */
+     if (D_FLAGS_IS_SET( hw_caps, STMFBIO_OUTPUT_CAPS_ANALOGUE_CONFIG )) {
+          D_DEBUG_AT( STMfbdev_Screen, "    +> have analogue\n" );
+          if (D_FLAGS_IS_SET( hw_caps, STMFBIO_OUTPUT_CAPS_SDTV_ENCODING ))
+               D_DEBUG_AT( STMfbdev_Screen, "      +> with SDTV\n" );
+          shared->encoder_analog = ++n_encoders;
+     }
+     if (D_FLAGS_IS_SET( hw_caps, STMFBIO_OUTPUT_CAPS_HDMI_CONFIG )) {
+          D_DEBUG_AT( STMfbdev_Screen, "    +> have HDMI\n" );
+          shared->encoder_hdmi = ++n_encoders;
+     }
+     if (D_FLAGS_IS_SET( hw_caps, STMFBIO_OUTPUT_CAPS_DVO_CONFIG )) {
+          D_DEBUG_AT( STMfbdev_Screen, "    +> have DVO\n" );
+          shared->encoder_dvo = ++n_encoders;
+     }
+     if (D_FLAGS_IS_SET( hw_caps, STMFBIO_OUTPUT_CAPS_PSI_MASK )) {
+          D_DEBUG_AT( STMfbdev_Screen, "    +> have PSI\n" );
+          description->caps |= DSCCAPS_ENCODERS;
+          shared->encoder_sd = ++n_encoders;
+     }
+
+     description->outputs = ++n_outputs;
+     description->encoders = ++n_encoders;
+
+     return DFB_OK;
+}
+
+static DFBResult
+stmfbdevShutdownScreen( CoreScreen *screen,
+                        void       *driver_data,
+                        void       *screen_data )
+{
+     const STMfbdev           * const stmfbdev = driver_data;
+     STMfbdevScreenSharedData * const shared = screen_data;
+
+     D_DEBUG_AT( STMfbdev_Screen, "%s( %p )\n", __FUNCTION__, screen );
+
+     D_MAGIC_ASSERT( stmfbdev, STMfbdev );
+     D_MAGIC_ASSERT( shared, STMfbdevScreenSharedData );
+
+     /* try and restore the driver's state. */
+     shared->orig_info.activate = STMFBIO_ACTIVATE_IMMEDIATE;
+     if (ioctl( stmfbdev->fd, STMFBIO_SET_OUTPUTINFO, &shared->orig_info ) < 0)
+          D_PERROR( "STMfbdev/Screen: Could not restore output mode\n" );
+
+     shared->orig_config.activate = STMFBIO_ACTIVATE_IMMEDIATE;
+     if (ioctl( stmfbdev->fd, STMFBIO_SET_OUTPUT_CONFIG, &shared->orig_config ) < 0)
+          D_PERROR( "STMfbdev/Screen: Could not restore output config\n" );
+
+     SHFREE( shared->shmpool, shared->modes );
+
+     D_MAGIC_CLEAR( shared );
+
+     return DFB_OK;
+}
+
+/* Mixer configuration */
+static DFBResult
+stmfbdevInitMixer( CoreScreen                *screen,
+                   void                      *driver_data,
+                   void                      *screen_data,
+                   int                        mixer,
+                   DFBScreenMixerDescription *description,
+                   DFBScreenMixerConfig      *config )
+{
+     const STMfbdev                 * const stmfbdev = driver_data;
+     const STMfbdevScreenSharedData * const shared = screen_data;
+     const struct stmfbio_output_configuration *oc;
+
+     D_DEBUG_AT( STMfbdev_Screen, "%s( %p %d )\n",
+                 __FUNCTION__, screen, mixer );
+
+     D_MAGIC_ASSERT( stmfbdev, STMfbdev );
+     D_MAGIC_ASSERT( shared, STMfbdevScreenSharedData );
+
+     (void) stmfbdev;
+
+     description->caps = DSMCAPS_FULL | DSMCAPS_BACKGROUND;
+
+     DFB_DISPLAYLAYER_IDS_ADD( description->layers, DLID_PRIMARY );
+
+     snprintf( description->name, sizeof (description->name),
+               "STMfbdev Mixer" );
+
+     config->flags = DSMCONF_TREE | DSMCONF_BACKGROUND;
+     config->tree = DSMT_FULL;
+
+     oc = &shared->orig_config;
+     config->background.a = (oc->mixer_background >> 24) & 0xff;
+     config->background.r = (oc->mixer_background >> 16) & 0xff;
+     config->background.g = (oc->mixer_background >>  8) & 0xff;
+     config->background.b = (oc->mixer_background >>  0) & 0xff;
+
+     D_DEBUG_AT( STMfbdev_Screen, "  -> background colour: 0x%08x\n",
+                 oc->mixer_background );
+
+     return DFB_OK;
+}
+
+static DFBResult
+stmfbdevDoMixerConfig( CoreScreen                     *screen,
+                       const STMfbdev                 * const stmfbdev,
+                       const STMfbdevScreenSharedData * const shared,
+                       int                             mixer,
+                       const DFBScreenMixerConfig     *config,
+                       DFBScreenMixerConfigFlags      *failed,
+                       bool                            test )
+{
+     DFBScreenMixerConfigFlags           fail = DSMCONF_NONE;
+     struct stmfbio_output_configuration cfg;
+
+     D_DEBUG_AT( STMfbdev_Screen, "%s( %p %d ) test: %c\n",
+                 __FUNCTION__, screen, mixer, test ? 'y' : 'n' );
+
+     D_MAGIC_ASSERT( stmfbdev, STMfbdev );
+     D_MAGIC_ASSERT( shared, STMfbdevScreenSharedData );
+
+     if (!D_FLAGS_ARE_IN( config->flags, DSMCONF_TREE | DSMCONF_BACKGROUND ))
+          fail |= (config->flags & ~(DSMCONF_TREE | DSMCONF_BACKGROUND));
+
+     cfg.outputid = STMFBIO_OUTPUTID_MAIN;
+     cfg.activate = test ? STMFBIO_ACTIVATE_TEST : STMFBIO_ACTIVATE_IMMEDIATE;
+     cfg.caps = 0;
+
+     if (D_FLAGS_IS_SET( config->flags, DSMCONF_BACKGROUND )) {
+          D_DEBUG_AT( STMfbdev_Screen, "  -> background %.2x%.2x%.2x%.2x\n",
+                      config->background.a, config->background.r,
+                      config->background.g, config->background.b );
+
+          cfg.caps |= STMFBIO_OUTPUT_CAPS_MIXER_BACKGROUND;
+          cfg.mixer_background = (0
+                                  | (config->background.a << 24)
+                                  | (config->background.r << 16)
+                                  | (config->background.g <<  8)
+                                  | (config->background.b <<  0));
+     }
+
+     if (ioctl( stmfbdev->fd, STMFBIO_SET_OUTPUT_CONFIG, &cfg ) < 0)
+          fail |= DSMCONF_BACKGROUND;
+
+     if (D_FLAGS_IS_SET( config->flags, DSMCONF_TREE )
+         && D_FLAGS_INVALID( config->tree, DSMT_FULL ))
+          fail |= (config->tree & ~DSMT_FULL);
+
+     if (failed)
+          *failed = fail;
+
+     if (fail) {
+          D_DEBUG_AT( STMfbdev_Screen, "  => FAILED!\n" );
+          return DFB_UNSUPPORTED;
+     }
+
+     D_DEBUG_AT( STMfbdev_Screen, "  => SUCCESS\n" );
+
+     return DFB_OK;
+}
+
+static DFBResult
+stmfbdevTestMixerConfig( CoreScreen                 *screen,
+                         void                       *driver_data,
+                         void                       *screen_data,
+                         int                         mixer,
+                         const DFBScreenMixerConfig *config,
+                         DFBScreenMixerConfigFlags  *failed )
+{
+     return stmfbdevDoMixerConfig (screen, driver_data, screen_data, mixer,
+                                   config, failed, true);
+}
+
+static DFBResult
+stmfbdevSetMixerConfig( CoreScreen                 *screen,
+                        void                       *driver_data,
+                        void                       *screen_data,
+                        int                         mixer,
+                        const DFBScreenMixerConfig *config )
+{
+     return stmfbdevDoMixerConfig (screen, driver_data, screen_data, mixer,
+                                   config, NULL, false);
+}
+
+
+/* Encoder configuration */
+static DFBResult
+stmfbdevInitEncoder( CoreScreen                   *screen,
+                     void                         *driver_data,
+                     void                         *screen_data,
+                     int                           encoder,
+                     DFBScreenEncoderDescription  *description,
+                     DFBScreenEncoderConfig       *config )
+{
+     const STMfbdev           * const stmfbdev = driver_data;
+     STMfbdevScreenSharedData * const shared = screen_data;
+     DFBResult                 res;
+     const struct stmfbio_output_configuration *oc;
+     u32                                        hw_caps;
+     const STMfbdevScreenVideoMode             *m;
+
+     D_DEBUG_AT( STMfbdev_Screen, "%s( %p %d )\n",
+                 __FUNCTION__, screen, encoder );
+
+     D_MAGIC_ASSERT( stmfbdev, STMfbdev );
+     D_MAGIC_ASSERT( shared, STMfbdevScreenSharedData );
+
+     oc = &shared->orig_config;
+     hw_caps = oc->caps;
+
+     if (encoder == shared->encoder_main) {
+          /* current mode */
+          shared->mode.stm_standard = shared->orig_info.standard;
+          stmfbdevScreen_build_full_videomode( &shared->mode );
+
+          res = stmfbdevScreen_get_supported_modes( stmfbdev, shared );
+          if (res != DFB_OK)
+               return res;
+
+          /* master DFBScreenEncoder - signals and connectors can not be
+             changed on this one - only the output standard. */
+          snprintf( description->name, sizeof (description->name),
+                    "STMfbdev master output" );
+
+          D_ASSUME( D_FLAGS_IS_SET( hw_caps,
+                                    (STMFBIO_OUTPUT_CAPS_ANALOGUE_CONFIG
+                                     | STMFBIO_OUTPUT_CAPS_HDMI_CONFIG
+                                     | STMFBIO_OUTPUT_CAPS_DVO_CONFIG) ));
+
+          description->type = DSET_DIGITAL;
+
+          /* supported resolutions */
+          for (m = shared->modes; m; m = m->next)
+               description->all_resolutions |= m->resolution;
+          if (description->all_resolutions)
+               description->caps = (DSECAPS_SCANMODE | DSECAPS_FREQUENCY
+                                    | DSECAPS_RESOLUTION);
+
+          if (D_FLAGS_IS_SET( oc->caps, STMFBIO_OUTPUT_CAPS_ANALOGUE_CONFIG )) {
+               D_DEBUG_AT( STMfbdev_Screen, "    +> have analogue (slave)\n" );
+               description->caps |= (DSECAPS_CONNECTORS
+                                     | DSECAPS_OUT_SIGNALS);
+
+               description->all_connectors |= DSOC_COMPONENT;
+               description->out_signals |= DSOS_RGB | DSOS_YCBCR;
+
+               if (D_FLAGS_IS_SET( oc->caps, STMFBIO_OUTPUT_CAPS_SDTV_ENCODING )) {
+                    D_DEBUG_AT( STMfbdev_Screen, "      +> with SDTV\n" );
+                    description->type |= DSET_TV;
+                    /* add in supported TV standards */
+                    for (m = shared->modes; m; m = m->next)
+                         description->tv_standards |= m->tv_standard;
+                    D_FLAGS_CLEAR( description->tv_standards, DSETV_DIGITAL );
+                    if (description->tv_standards)
+                         D_FLAGS_SET( description->caps, DSECAPS_TV_STANDARDS );
+
+                    description->all_connectors |= DSOC_SCART | DSOC_YC | DSOC_CVBS;
+                    description->out_signals |= DSOS_RGB | DSOS_YC | DSOS_CVBS;
+               }
+          }
+          if (D_FLAGS_IS_SET( oc->caps, STMFBIO_OUTPUT_CAPS_HDMI_CONFIG )) {
+               D_DEBUG_AT( STMfbdev_Screen, "    +> have HDMI (slave)\n" );
+               description->caps |= (DSECAPS_CONNECTORS
+                                     | DSECAPS_OUT_SIGNALS);
+
+               description->all_connectors |= DSOC_HDMI;
+               description->out_signals |= DSOS_HDMI | DSOS_RGB | DSOS_YCBCR;
+          }
+          if (D_FLAGS_IS_SET( oc->caps, STMFBIO_OUTPUT_CAPS_DVO_CONFIG )) {
+               D_DEBUG_AT( STMfbdev_Screen, "    +> have DVO (slave)\n" );
+               description->caps |= (DSECAPS_CONNECTORS
+                                     | DSECAPS_OUT_SIGNALS);
+
+               description->all_connectors |= DSOC_656;
+               description->out_signals |= DSOS_656;
+          }
+
+          /* current config */
+          m = &shared->mode;
+          config->resolution = m->resolution;
+          config->scanmode = m->scanmode;
+          config->frequency = m->frequency;
+          config->tv_standard = m->tv_standard;
+
+          config->flags |= (m->resolution != DSOR_UNKNOWN) ? DSECONF_RESOLUTION : 0;
+          config->flags |= (m->scanmode != DSESM_UNKNOWN) ? DSECONF_SCANMODE : 0;
+          config->flags |= (m->frequency != DSEF_UNKNOWN) ? DSECONF_FREQUENCY : 0;
+          config->flags |= (m->tv_standard != DSETV_UNKNOWN) ? DSECONF_TV_STANDARD : 0;
+     }
+     else if (encoder == shared->encoder_analog) {
+          D_ASSUME( D_FLAGS_IS_SET( hw_caps, STMFBIO_OUTPUT_CAPS_ANALOGUE_CONFIG ) );
+
+          snprintf( description->name, sizeof (description->name),
+                    "STMfbdev Analogue slave" );
+
+          /* caps */
+          description->caps |= DSECAPS_OUT_SIGNALS | DSECAPS_CONNECTORS;
+          description->all_connectors |= DSOC_COMPONENT;
+          description->out_signals = DSOS_RGB | DSOS_YCBCR;
+          if (D_FLAGS_IS_SET( hw_caps, STMFBIO_OUTPUT_CAPS_SDTV_ENCODING )) {
+               description->all_connectors |= DSOC_SCART | DSOC_YC | DSOC_CVBS;
+               description->out_signals |= DSOS_CVBS | DSOS_YC;
+          }
+
+          /* current config */
+          D_FLAGS_SET( config->flags, DSECONF_OUT_SIGNALS | DSECONF_CONNECTORS );
+          D_FLAGS_SET( config->out_connectors, DSOC_COMPONENT );
+          if (D_FLAGS_IS_SET( hw_caps, STMFBIO_OUTPUT_CAPS_SDTV_ENCODING ))
+               config->out_connectors |= DSOC_SCART | DSOC_YC | DSOC_CVBS;
+
+          D_FLAGS_SET( config->out_signals, DSOS_NONE );
+          if (D_FLAGS_IS_SET( oc->analogue_config, STMFBIO_OUTPUT_ANALOGUE_RGB ))
+               D_FLAGS_SET( config->out_signals, DSOS_RGB );
+          if (D_FLAGS_IS_SET( oc->analogue_config, STMFBIO_OUTPUT_ANALOGUE_YPrPb ))
+               D_FLAGS_SET( config->out_signals, DSOS_YCBCR );
+          if (D_FLAGS_IS_SET( oc->analogue_config, STMFBIO_OUTPUT_ANALOGUE_YC ))
+               D_FLAGS_SET( config->out_signals, DSOS_YC );
+          if (D_FLAGS_IS_SET( oc->analogue_config, STMFBIO_OUTPUT_ANALOGUE_CVBS ))
+               D_FLAGS_SET( config->out_signals, DSOS_CVBS );
+     }
+     else if (encoder == shared->encoder_hdmi) {
+          D_ASSUME( D_FLAGS_IS_SET( hw_caps, STMFBIO_OUTPUT_CAPS_HDMI_CONFIG ) );
+
+          snprintf( description->name, sizeof (description->name),
+                    "STMfbdev HDMI slave" );
+
+          /* caps */
+          description->caps |= DSECAPS_OUT_SIGNALS | DSECAPS_CONNECTORS;
+          description->all_connectors |= DSOC_HDMI;
+          description->out_signals |= DSOS_HDMI | DSOS_RGB | DSOS_YCBCR;
+
+          /* current config */
+          D_FLAGS_SET( config->flags, DSECONF_OUT_SIGNALS | DSECONF_CONNECTORS );
+          D_FLAGS_SET( config->out_connectors, DSOC_HDMI );
+
+          if (D_FLAGS_IS_SET( oc->hdmi_config, STMFBIO_OUTPUT_HDMI_DISABLED ))
+               D_FLAGS_SET( config->out_signals, DSOS_NONE );
+          else {
+               D_FLAGS_SET( config->out_signals, DSOS_HDMI );
+               /* A bit of bending the interface to specify the HDMI
+                  colourspace */
+               if (D_FLAGS_IS_SET( oc->hdmi_config, STMFBIO_OUTPUT_HDMI_YUV ))
+                    D_FLAGS_SET( config->out_signals, DSOS_YCBCR );
+               else
+                    D_FLAGS_SET( config->out_signals, DSOS_RGB );
+          }
+     }
+     else if (encoder == shared->encoder_dvo) {
+          D_ASSUME( D_FLAGS_IS_SET( hw_caps, STMFBIO_OUTPUT_CAPS_DVO_CONFIG ) );
+
+          snprintf( description->name, sizeof (description->name),
+                    "STMfbdev DVO slave" );
+
+          /* caps */
+          description->caps |= DSECAPS_OUT_SIGNALS | DSECAPS_CONNECTORS;
+          description->all_connectors |= DSOC_656;
+          description->out_signals |= DSOS_656;
+
+          /* current config */
+          D_FLAGS_SET( config->flags, DSECONF_OUT_SIGNALS | DSECONF_CONNECTORS );
+          D_FLAGS_SET( config->out_connectors, DSOC_656 );
+
+          if (D_FLAGS_IS_SET( oc->dvo_config, STMFBIO_OUTPUT_DVO_DISABLED ))
+               D_FLAGS_SET( config->out_signals, DSOS_NONE );
+          else
+               D_FLAGS_SET( config->out_signals, DSOS_656 );
+     }
+     else if (encoder == shared->encoder_sd) {
+          D_ASSUME( D_FLAGS_IS_SET( oc->caps, STMFBIO_OUTPUT_CAPS_SDTV_ENCODING ));
+          D_ASSUME( D_FLAGS_IS_SET( oc->caps, STMFBIO_OUTPUT_CAPS_PSI_MASK ));
+
+          /* the outputs and signals are handled by the main analogue
+             DFBScreenEncoder, this one just adds in the colour
+             adjustments. */
+          snprintf( description->name, sizeof (description->name),
+                    "STMfbdev DENC slave" );
+
+          /* caps and current config in one go */
+          if (D_FLAGS_IS_SET( hw_caps, STMFBIO_OUTPUT_CAPS_BRIGHTNESS )) {
+               /* caps */
+               description->caps |= DSECAPS_BRIGHTNESS;
+               /* current config */
+               config->flags |= DSECONF_ADJUSTMENT;
+               config->adjustment.flags |= DCAF_BRIGHTNESS;
+               config->adjustment.brightness = ((u16) oc->brightness) << 8;
+               D_DEBUG_AT( STMfbdev_Screen, "  => brightness: %u\n",
+                           config->adjustment.brightness );
+          }
+          if (D_FLAGS_IS_SET( hw_caps, STMFBIO_OUTPUT_CAPS_CONTRAST )) {
+               /* caps */
+               description->caps |= DSECAPS_CONTRAST;
+               /* current config */
+               config->flags |= DSECONF_ADJUSTMENT;
+               config->adjustment.flags |= DCAF_CONTRAST;
+               config->adjustment.contrast = ((u16) oc->contrast) << 8;
+               D_DEBUG_AT( STMfbdev_Screen, "  => contrast: %u\n",
+                           config->adjustment.contrast );
+          }
+          if (D_FLAGS_IS_SET( hw_caps, STMFBIO_OUTPUT_CAPS_SATURATION )) {
+               /* caps */
+               description->caps |= DSECAPS_SATURATION;
+               /* current config */
+               config->flags |= DSECONF_ADJUSTMENT;
+               config->adjustment.flags |= DCAF_SATURATION;
+               config->adjustment.saturation = ((u16) oc->saturation) << 8;
+               D_DEBUG_AT( STMfbdev_Screen, "  => saturation: %u\n",
+                           config->adjustment.saturation );
+          }
+          if (D_FLAGS_IS_SET( hw_caps, STMFBIO_OUTPUT_CAPS_HUE )) {
+               /* caps */
+               description->caps |= DSECAPS_HUE;
+               /* current config */
+               config->flags |= DSECONF_ADJUSTMENT;
+               config->adjustment.flags |= DCAF_HUE;
+               config->adjustment.hue = ((u16) oc->hue) << 8;
+               D_DEBUG_AT( STMfbdev_Screen, "  => hue: %u\n",
+                           config->adjustment.hue );
+          }
+     }
+     else
+          return DFB_BUG;
+
+     return DFB_OK;
+}
+
+static DFBResult
+stmfbdevDoEncoderConfig( CoreScreen                   *screen,
+                         void                         *driver_data,
+                         void                         *screen_data,
+                         int                           encoder,
+                         const DFBScreenEncoderConfig *config,
+                         DFBScreenEncoderConfigFlags  *failed,
+                         bool                          test )
+{
+     const STMfbdev           * const stmfbdev = driver_data;
+     STMfbdevScreenSharedData * const shared = screen_data;
+     u32                                 hw_caps;
+     struct stmfbio_output_configuration cfg;
+
+     D_DEBUG_AT( STMfbdev_Screen, "%s( %p %d ) test: %c\n",
+                 __FUNCTION__, screen, encoder, test ? 'y' : 'n' );
+
+     D_MAGIC_ASSERT( stmfbdev, STMfbdev );
+     D_MAGIC_ASSERT( shared, STMfbdevScreenSharedData );
+
+     cfg.outputid = STMFBIO_OUTPUTID_MAIN;
+     if ( ioctl( stmfbdev->fd, STMFBIO_GET_OUTPUT_CONFIG, &cfg ) < 0 ) {
+          *failed = config->flags;
+          return DFB_IO;
+     }
+
+     hw_caps = shared->orig_config.caps;
+     cfg.activate = test ? STMFBIO_ACTIVATE_TEST : STMFBIO_ACTIVATE_IMMEDIATE;
+     cfg.caps = 0;
+
+     if (encoder == shared->encoder_main) {
+          const STMfbdevScreenVideoMode *mode;
+
+          *failed |= config->flags & ~(DSECONF_SCANMODE | DSECONF_FREQUENCY
+                                       | DSECONF_RESOLUTION
+                                       | DSECONF_TV_STANDARD);
+          if (!*failed) {
+               mode = stmfbdevScreen_find_mode( shared, config );
+               if (!mode
+                   || stmfbdevScreen_set_mode( stmfbdev, shared, mode,
+                                               test ) != DFB_OK) {
+                    *failed |= (DSECONF_SCANMODE | DSECONF_FREQUENCY
+                                | DSECONF_RESOLUTION);
+                    *failed |= (config->flags & DSECONF_TV_STANDARD);
+               }
+          }
+     }
+     else if (encoder == shared->encoder_analog) {
+          D_DEBUG_AT( STMfbdev_Screen, "  -> analogue 0x%.2x (outsig %x flg %x conn %x)\n",
+                      config->out_signals, config->out_signals,
+                      config->flags, config->out_connectors );
+
+          *failed |= config->flags & ~(DSECONF_CONNECTORS
+                                       | DSECONF_OUT_SIGNALS);
+          if (config->flags & DSECONF_OUT_SIGNALS
+              && D_FLAGS_INVALID( config->out_signals, (DSOS_RGB
+                                                        | DSOS_YCBCR
+                                                        | DSOS_CVBS
+                                                        | DSOS_YC) ))
+               *failed |= DSECONF_OUT_SIGNALS;
+          /* it's not allowed to change connectors, they merely serve an
+             informational purpose. */
+          if (config->flags & DSECONF_CONNECTORS
+              && config->out_connectors != (DSOC_SCART | DSOC_YC
+                                            | DSOC_CVBS | DSOC_COMPONENT) )
+               *failed |= DSECONF_CONNECTORS;
+
+          /* you can change the signals coming out of the connectors,
+             though. */
+          if (!*failed) {
+               if (!D_FLAGS_IS_SET( hw_caps, STMFBIO_OUTPUT_CAPS_ANALOGUE_CONFIG )) {
+                    if (config->out_signals != DSOS_NONE)
+                         *failed |= DSECONF_OUT_SIGNALS;
+               }
+               else {
+                    cfg.caps = STMFBIO_OUTPUT_CAPS_ANALOGUE_CONFIG;
+
+                    D_FLAGS_CLEAR( cfg.analogue_config,
+                                   STMFBIO_OUTPUT_ANALOGUE_MASK );
+
+                    if (!config->out_signals)
+                         D_DEBUG_AT( STMfbdev_Screen, "    +> off\n" );
+                    if (D_FLAGS_IS_SET( config->out_signals, DSOS_RGB )) {
+                         D_DEBUG_AT( STMfbdev_Screen, "    +> RGB\n" );
+                         cfg.analogue_config |= STMFBIO_OUTPUT_ANALOGUE_RGB;
+                    }
+                    if (D_FLAGS_IS_SET( config->out_signals, DSOS_YCBCR )) {
+                         D_DEBUG_AT( STMfbdev_Screen, "    +> YPrPb\n" );
+                         cfg.analogue_config |= STMFBIO_OUTPUT_ANALOGUE_YPrPb;
+                    }
+                    if (D_FLAGS_IS_SET( config->out_signals, DSOS_CVBS )) {
+                         D_DEBUG_AT( STMfbdev_Screen, "    +> CVBS\n" );
+                         cfg.analogue_config |= STMFBIO_OUTPUT_ANALOGUE_CVBS;
+                    }
+                    if (D_FLAGS_IS_SET( config->out_signals, DSOS_YC )) {
+                         D_DEBUG_AT( STMfbdev_Screen, "    +> Y/C\n" );
+                         cfg.analogue_config |= STMFBIO_OUTPUT_ANALOGUE_YC;
+                    }
+               }
+          }
+     }
+     else if (encoder == shared->encoder_hdmi) {
+          D_DEBUG_AT( STMfbdev_Screen, "  -> HDMI 0x%.2x\n",
+                      config->out_signals );
+
+          *failed |= config->flags & ~(DSECONF_CONNECTORS
+                                       | DSECONF_OUT_SIGNALS);
+          if (config->flags & DSECONF_OUT_SIGNALS
+              /* only HDMI + (RGB or YCbCr) supported */
+              && (D_FLAGS_INVALID( config->out_signals, (DSOS_HDMI
+                                                         | DSOS_RGB
+                                                         | DSOS_YCBCR) )
+                  /* can't have both, RGB and YCbCr */
+                  || D_FLAGS_ARE_SET( config->out_signals, (DSOS_RGB
+                                                            | DSOS_YCBCR) )))
+               *failed |= DSECONF_OUT_SIGNALS;
+          /* it's not allowed to change connectors, they merely serve an
+             informational purpose. */
+          if (config->flags & DSECONF_CONNECTORS
+              && config->out_connectors != DSOC_HDMI)
+               *failed |= DSECONF_CONNECTORS;
+
+          if (!*failed) {
+               if (!D_FLAGS_IS_SET( hw_caps, STMFBIO_OUTPUT_CAPS_HDMI_CONFIG )) {
+                    if (config->out_signals != DSOS_NONE)
+                         *failed |= DSECONF_OUT_SIGNALS;
+               }
+               else {
+                    cfg.caps = STMFBIO_OUTPUT_CAPS_HDMI_CONFIG;
+
+                    D_FLAGS_CLEAR( cfg.hdmi_config,
+                                   (STMFBIO_OUTPUT_HDMI_DISABLED
+                                    | STMFBIO_OUTPUT_HDMI_YUV) );
+
+                    if (D_FLAGS_IS_SET( config->out_signals, DSOS_HDMI )) {
+                         cfg.hdmi_config |= STMFBIO_OUTPUT_HDMI_ENABLED;
+                         /* HDMI colourspace is RGB by default, only change it
+                            when YCBCR is specified. */
+                         if (D_FLAGS_IS_SET( config->out_signals, DSOS_YCBCR )) {
+                              D_DEBUG_AT( STMfbdev_Screen, "    +> YCbCr\n" );
+                              cfg.hdmi_config |= STMFBIO_OUTPUT_HDMI_YUV;
+                         }
+                         else if (D_FLAGS_IS_SET( config->out_signals,
+                                                  DSOS_RGB ))
+                              D_DEBUG_AT( STMfbdev_Screen, "    +> RGB\n" );
+                         else {
+                              D_DEBUG_AT( STMfbdev_Screen, "    +> unknown\n" );
+                              *failed |= DSECONF_OUT_SIGNALS;
+                         }
+                    }
+                    else if (config->out_signals == DSOS_NONE) {
+                         D_DEBUG_AT( STMfbdev_Screen, "    +> off\n" );
+                         cfg.hdmi_config |= STMFBIO_OUTPUT_HDMI_DISABLED;
+                    }
+               }
+          }
+     }
+     else if (encoder == shared->encoder_dvo) {
+          D_DEBUG_AT( STMfbdev_Screen, "  -> DVO 0x%.2x\n",
+                      config->out_signals );
+
+          *failed |= config->flags & ~(DSECONF_CONNECTORS
+                                       | DSECONF_OUT_SIGNALS);
+          if (config->flags & DSECONF_OUT_SIGNALS
+              && D_FLAGS_INVALID( config->out_signals, DSOS_656 ))
+               *failed |= DSECONF_OUT_SIGNALS;
+          /* it's not allowed to change connectors, they merely serve an
+             informational purpose. */
+          if (config->flags & DSECONF_CONNECTORS
+              && config->out_connectors != DSOC_HDMI)
+               *failed |= DSECONF_CONNECTORS;
+
+
+          if (!*failed) {
+               if (!D_FLAGS_IS_SET( hw_caps, STMFBIO_OUTPUT_CAPS_DVO_CONFIG )) {
+                    if (config->out_signals != DSOS_NONE)
+                         *failed |= DSECONF_OUT_SIGNALS;
+               }
+               else {
+                    cfg.caps = STMFBIO_OUTPUT_CAPS_DVO_CONFIG;
+
+                    D_FLAGS_CLEAR( cfg.dvo_config, STMFBIO_OUTPUT_DVO_DISABLED );
+
+                    if (config->out_signals == DSOS_656) {
+                         D_DEBUG_AT( STMfbdev_Screen, "    +> enabled\n" );
+                         cfg.dvo_config |= STMFBIO_OUTPUT_DVO_ENABLED;
+                    }
+                    else {
+                         D_DEBUG_AT( STMfbdev_Screen, "    +> off\n" );
+                         cfg.dvo_config |= STMFBIO_OUTPUT_DVO_DISABLED;
+                    }
+               }
+          }
+     }
+     else if (encoder == shared->encoder_sd) {
+          D_DEBUG_AT( STMfbdev_Screen, "  -> DENC adjustment 0x%.2x\n",
+                      config->out_signals );
+
+          *failed = config->flags & ~DSECONF_ADJUSTMENT;
+          if (!*failed) {
+               if (config->adjustment.flags & DCAF_BRIGHTNESS) {
+                    cfg.caps |= STMFBIO_OUTPUT_CAPS_BRIGHTNESS;
+                    cfg.brightness = config->adjustment.brightness >> 8;
+               }
+               if (config->adjustment.flags & DCAF_SATURATION) {
+                    cfg.caps |= STMFBIO_OUTPUT_CAPS_SATURATION;
+                    cfg.saturation = config->adjustment.saturation >> 8;
+               }
+               if (config->adjustment.flags & DCAF_CONTRAST) {
+                    cfg.caps |= STMFBIO_OUTPUT_CAPS_CONTRAST;
+                    cfg.contrast = config->adjustment.contrast >> 8;
+               }
+               if (config->adjustment.flags & DCAF_HUE) {
+                    cfg.caps |= STMFBIO_OUTPUT_CAPS_HUE;
+                    cfg.hue = config->adjustment.hue >> 8;
+               }
+          }
+     }
+     else
+          return DFB_BUG;
+
+     if (!*failed && cfg.caps
+         && ioctl( stmfbdev->fd, STMFBIO_SET_OUTPUT_CONFIG, &cfg ) < 0)
+          *failed = config->flags;
+
+     if (*failed) {
+          D_DEBUG_AT( STMfbdev_Screen, "  => FAILED (0x%.8x)\n", *failed );
+          return DFB_INVARG;
+     }
+
+     D_DEBUG_AT( STMfbdev_Screen, "  => SUCCESS\n" );
+     return DFB_OK;
+}
+
+static DFBResult
+stmfbdevTestEncoderConfig( CoreScreen                   *screen,
+                           void                         *driver_data,
+                           void                         *screen_data,
+                           int                           encoder,
+                           const DFBScreenEncoderConfig *config,
+                           DFBScreenEncoderConfigFlags  *failed )
+{
+     return stmfbdevDoEncoderConfig( screen, driver_data, screen_data,
+                                     encoder, config, failed, true );
+}
+
+static DFBResult
+stmfbdevSetEncoderConfig( CoreScreen                   *screen,
+                          void                         *driver_data,
+                          void                         *screen_data,
+                          int                           encoder,
+                          const DFBScreenEncoderConfig *config )
+{
+     DFBScreenEncoderConfigFlags dummy = DSECONF_NONE;
+     return stmfbdevDoEncoderConfig( screen, driver_data, screen_data,
+                                     encoder, config, &dummy, false );
+}
+
+/* remaining screen things */
+static DFBResult
+stmfbdevWaitVSync( CoreScreen *screen,
+                   void       *driver_data,
+                   void       *screen_data )
+{
+     STMfbdev                 * const stmfbdev = driver_data;
+     STMfbdevScreenSharedData * const shared = screen_data;
+     static const int          zero = 0;
+
+     D_DEBUG_AT( STMfbdev_Screen, "%s( %p )\n", __FUNCTION__, screen );
+
+     D_MAGIC_ASSERT( stmfbdev, STMfbdev );
+     D_MAGIC_ASSERT( shared, STMfbdevScreenSharedData );
+     (void) shared;
+
+     if (dfb_config->pollvsync_none)
+          return DFB_OK;
+
+     if (ioctl( stmfbdev->fd, FBIO_WAITFORVSYNC, &zero ))
+          return errno2result( errno );
+
+     return DFB_OK;
+}
+
+static DFBResult
+stmfbdevGetVSyncCount( CoreScreen    *screen,
+                       void          *driver_data,
+                       void          *screen_data,
+                       unsigned long *ret_count )
+{
+     STMfbdev                 * const stmfbdev = driver_data;
+     STMfbdevScreenSharedData * const shared = screen_data;
+     struct fb_vblank          vblank;
+
+     D_DEBUG_AT( STMfbdev_Screen, "%s( %p )\n", __FUNCTION__, screen );
+
+     D_MAGIC_ASSERT( stmfbdev, STMfbdev );
+     D_MAGIC_ASSERT( shared, STMfbdevScreenSharedData );
+     D_ASSERT( ret_count != NULL );
+     (void) shared;
+
+     if (!ret_count)
+          return DFB_INVARG;
+
+     if (ioctl( stmfbdev->fd, FBIOGET_VBLANK, &vblank ))
+          return errno2result( errno );
+
+     if (!D_FLAGS_IS_SET( vblank.flags, FB_VBLANK_HAVE_COUNT ))
+          return DFB_UNSUPPORTED;
+
+     *ret_count = vblank.count;
+
+     return DFB_OK;
+}
+
+static DFBResult
+stmfbdevGetScreenSize( CoreScreen *screen,
+                       void       *driver_data,
+                       void       *screen_data,
+                       int        *ret_width,
+                       int        *ret_height )
+{
+     STMfbdev                 * const stmfbdev = driver_data;
+     STMfbdevScreenSharedData * const shared = screen_data;
+
+     D_DEBUG_AT( STMfbdev_Screen, "%s( %p )\n", __FUNCTION__, screen );
+
+     D_MAGIC_ASSERT( stmfbdev, STMfbdev );
+     D_MAGIC_ASSERT( shared, STMfbdevScreenSharedData );
+
+     (void) stmfbdev;
+
+     switch (shared->mode.resolution) {
+          case DSOR_1920_1080:
+               *ret_width = 1920; *ret_height = 1080; break;
+          case DSOR_1280_720:
+               *ret_width = 1280; *ret_height =  720; break;
+          case DSOR_720_576:
+               *ret_width =  720; *ret_height =  576; break;
+          case DSOR_720_480:
+               *ret_width =  720; *ret_height =  480; break;
+          case DSOR_640_480:
+               *ret_width =  640; *ret_height =  480; break;
+
+          default:
+               return DFB_FAILURE;
+     }
+
+     return DFB_OK;
+}
+
+
+ScreenFuncs _g_stmfbdevScreenFuncs = {
+     .ScreenDataSize = stmfbdevScreenDataSize,
+
+     .InitScreen     = stmfbdevInitScreen,
+     .ShutdownScreen = stmfbdevShutdownScreen,
+
+     .InitMixer       = stmfbdevInitMixer,
+     .TestMixerConfig = stmfbdevTestMixerConfig,
+     .SetMixerConfig  = stmfbdevSetMixerConfig,
+
+     .InitEncoder       = stmfbdevInitEncoder,
+     .TestEncoderConfig = stmfbdevTestEncoderConfig,
+     .SetEncoderConfig  = stmfbdevSetEncoderConfig,
+
+     .WaitVSync      = stmfbdevWaitVSync,
+     .GetVSyncCount  = stmfbdevGetVSyncCount,
+     .GetScreenSize  = stmfbdevGetScreenSize,
+};
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/gfxdrivers/stgfx2/stmfbdev_surface_pool.c DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/stmfbdev_surface_pool.c
--- DirectFB/gfxdrivers/stgfx2/stmfbdev_surface_pool.c	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/stmfbdev_surface_pool.c	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,633 @@
+/*
+   (c) Copyright 2010       STMicroelectronics (R&D) Ltd.
+   (c) Copyright 2001-2009  The world wide DirectFB Open Source Community (directfb.org)
+   (c) Copyright 2000-2004  Convergence (integrated media) GmbH
+
+   All rights reserved.
+
+   Written by Andr Draszik <andre.draszik@st.com>.
+
+   Based on work by Denis Oliver Kropp <dok@directfb.org>,
+                    Andreas Hundt <andi@fischlustig.de>,
+                    Sven Neumann <neo@directfb.org>,
+                    Ville Syrjl <syrjala@sci.fi> and
+                    Claudio Ciccani <klan@users.sf.net>.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <asm/types.h>
+
+#include <config.h>
+
+#include <directfb_util.h>
+
+#include <direct/debug.h>
+#include <direct/mem.h>
+
+#include <core/surface_pool.h>
+#include <core/gfxcard.h>
+
+#include <gfx/convert.h>
+
+#include "stmfbdev/stmfbdev.h"
+#include "surfacemanager.h"
+#if STGFX_DRIVER == 2
+  #include <core/system.h>
+  #include "stm_types.h"
+  #include "bdisp_accel.h"
+#elif STGFX_DRIVER == 1
+#else
+  #error unknown stgfx driver version
+#endif
+
+D_DEBUG_DOMAIN (STMfbdev_Surfaces, "STMfbdev/Surfaces", "STMfb Surface Pool");
+D_DEBUG_DOMAIN (STMfbdev_SurfLock, "STMfbdev/SurfLock", "STMfb Surface Pool Locks");
+
+/****************************************************************************/
+
+typedef struct
+{
+  int             magic;
+
+  SurfaceManager *manager;
+
+  unsigned long   physical;
+} STMfbdevPoolData;
+
+typedef struct
+{
+  int            magic;
+
+  CoreDFB       *core;
+  void          *mem;
+} STMfbdevPoolLocalData;
+
+typedef struct
+{
+  int   magic;
+
+  Chunk *chunk;
+} STMfbdevPoolAllocationData;
+
+/****************************************************************************/
+
+static int
+stmfbdevPoolDataSize (void)
+{
+  return sizeof (STMfbdevPoolData);
+}
+
+static int
+stmfbdevPoolLocalDataSize (void)
+{
+  return sizeof (STMfbdevPoolLocalData);
+}
+
+static int
+stmfbdevAllocationDataSize (void)
+{
+  return sizeof (STMfbdevPoolAllocationData);
+}
+
+static DFBResult
+stmfbdevLeavePool (CoreSurfacePool *pool,
+                   void            *pool_data,
+                   void            *pool_local)
+{
+  STMfbdevPoolData      * const data  = pool_data;
+  STMfbdevPoolLocalData * const local = pool_local;
+
+  D_DEBUG_AT (STMfbdev_Surfaces, "%s()\n", __FUNCTION__);
+
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_MAGIC_ASSERT (data, STMfbdevPoolData);
+  D_MAGIC_ASSERT (local, STMfbdevPoolLocalData);
+
+  (void) data;
+
+  local->mem = NULL;
+
+  D_MAGIC_CLEAR (local);
+
+  return DFB_OK;
+}
+
+static DFBResult
+stmfbdevJoinPool (CoreDFB                    *core,
+                  CoreSurfacePool            *pool,
+                  void                       *pool_data,
+                  void                       *pool_local,
+                  void                       *system_data)
+{
+  STMfbdevPoolData      * const data  = pool_data;
+  STMfbdevPoolLocalData * const local = pool_local;
+  STMfbdev              * const stmfbdev = dfb_system_data ();
+
+  D_DEBUG_AT (STMfbdev_Surfaces, "%s()\n", __FUNCTION__);
+
+  D_ASSERT (core != NULL);
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_MAGIC_ASSERT (data, STMfbdevPoolData);
+  D_ASSERT (local != NULL);
+  D_MAGIC_ASSERT (stmfbdev, STMfbdev);
+
+  (void) data;
+
+  D_MAGIC_SET (local, STMfbdevPoolLocalData);
+
+  local->mem = stmfbdev->framebuffer_base;
+  D_ASSERT (local->mem != NULL);
+
+  local->core = core;
+
+  return DFB_OK;
+}
+
+static DFBResult
+stmfbdevDestroyPool (CoreSurfacePool *pool,
+                     void            *pool_data,
+                     void            *pool_local)
+{
+  STMfbdevPoolData      * const data  = pool_data;
+  STMfbdevPoolLocalData * const local = pool_local;
+
+  D_DEBUG_AT (STMfbdev_Surfaces, "%s()\n", __FUNCTION__);
+
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_MAGIC_ASSERT (data, STMfbdevPoolData);
+  D_MAGIC_ASSERT (local, STMfbdevPoolLocalData);
+
+  (void) local;
+
+  stmfbdevLeavePool (pool, pool_data, pool_local);
+
+  dfb_surfacemanager_destroy (data->manager);
+
+  D_MAGIC_CLEAR (data);
+
+  return DFB_OK;
+}
+
+static DFBResult
+stmfbdevInitPool (CoreDFB                    *core,
+                  CoreSurfacePool            *pool,
+                  void                       *pool_data,
+                  void                       *pool_local,
+                  void                       *system_data,
+                  CoreSurfacePoolDescription *ret_desc)
+{
+  DFBResult              ret;
+  STMfbdevPoolData      * const data  = pool_data;
+  STMfbdevPoolLocalData * const local = pool_local;
+  STMfbdev              * const stmfbdev = dfb_system_data ();
+  unsigned int           video_len;
+
+  D_DEBUG_AT (STMfbdev_Surfaces, "%s()\n", __FUNCTION__);
+
+  D_ASSERT (core != NULL);
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_ASSERT (data != NULL);
+  D_ASSERT (local != NULL);
+  D_ASSERT (ret_desc != NULL);
+
+  (void) local;
+
+  D_MAGIC_ASSERT (stmfbdev, STMfbdev);
+  D_MAGIC_ASSERT (stmfbdev->shared, STMfbdevSharedData);
+
+  D_MAGIC_SET (data, STMfbdevPoolData);
+
+  snprintf (ret_desc->name,
+            DFB_SURFACE_POOL_DESC_NAME_LENGTH, "STMfb Memory");
+
+  /* the gfxdriver might have reserved video memory - in which case we have to
+     make sure that the reserved memory is not seen/used by the surface
+     manager */
+  video_len = dfb_gfxcard_memory_length ();
+  D_INFO ("BDisp/Surfaces: using %ukB of video memory (%d bytes reserved)!\n",
+          video_len / 1024, stmfbdev->shared->fix.smem_len - video_len);
+  ret = dfb_surfacemanager_create (core, video_len, &data->manager);
+
+  if (ret)
+    return ret;
+
+  data->physical = stmfbdev->shared->fix.smem_start;
+
+  ret_desc->caps              = CSPCAPS_PHYSICAL | CSPCAPS_VIRTUAL;
+  ret_desc->access[CSAID_CPU] = CSAF_READ | CSAF_WRITE | CSAF_SHARED;
+  ret_desc->access[CSAID_GPU] = CSAF_READ | CSAF_WRITE | CSAF_SHARED;
+  ret_desc->types             = (0
+                                 | CSTF_LAYER
+                                 | CSTF_WINDOW | CSTF_CURSOR | CSTF_FONT
+                                 | CSTF_SHARED | CSTF_EXTERNAL
+                                );
+  ret_desc->priority          = CSPP_DEFAULT;
+  ret_desc->size              = video_len;
+
+  /* other accelerators */
+  ret_desc->access[CSAID_ACCEL0] = CSAF_READ | CSAF_WRITE;
+  ret_desc->access[CSAID_ACCEL1] = CSAF_READ | CSAF_WRITE;
+  ret_desc->access[CSAID_ACCEL2] = CSAF_READ | CSAF_WRITE;
+  ret_desc->access[CSAID_ACCEL3] = CSAF_READ | CSAF_WRITE;
+  ret_desc->access[CSAID_ACCEL4] = CSAF_READ | CSAF_WRITE;
+  ret_desc->access[CSAID_ACCEL5] = CSAF_READ | CSAF_WRITE;
+
+  /* For hardware layers */
+  ret_desc->access[CSAID_LAYER0] = CSAF_READ;
+  ret_desc->access[CSAID_LAYER1] = CSAF_READ;
+  ret_desc->access[CSAID_LAYER2] = CSAF_READ;
+  ret_desc->access[CSAID_LAYER3] = CSAF_READ;
+  ret_desc->access[CSAID_LAYER4] = CSAF_READ;
+  ret_desc->access[CSAID_LAYER5] = CSAF_READ;
+  ret_desc->access[CSAID_LAYER6] = CSAF_READ;
+  ret_desc->access[CSAID_LAYER7] = CSAF_READ;
+  ret_desc->access[CSAID_LAYER8] = CSAF_READ;
+  ret_desc->access[CSAID_LAYER9] = CSAF_READ;
+  ret_desc->access[CSAID_LAYER10] = CSAF_READ;
+  ret_desc->access[CSAID_LAYER11] = CSAF_READ;
+  ret_desc->access[CSAID_LAYER12] = CSAF_READ;
+  ret_desc->access[CSAID_LAYER13] = CSAF_READ;
+  ret_desc->access[CSAID_LAYER14] = CSAF_READ;
+  ret_desc->access[CSAID_LAYER15] = CSAF_READ;
+
+  ret = stmfbdevJoinPool (core, pool, pool_data, pool_local, system_data);
+  if (ret)
+    {
+      stmfbdevDestroyPool (pool, pool_data, pool_local);
+      return ret;
+    }
+
+  return DFB_OK;
+}
+
+static DFBResult
+stmfbdevTestConfig (CoreSurfacePool         *pool,
+                    void                    *pool_data,
+                    void                    *pool_local,
+                    CoreSurfaceBuffer       *buffer,
+                    const CoreSurfaceConfig *config)
+{
+  CoreSurface           *surface;
+  STMfbdevPoolData      * const data  = pool_data;
+  STMfbdevPoolLocalData * const local = pool_local;
+  DFBResult              ret;
+
+  D_DEBUG_AT (STMfbdev_Surfaces, "%s (%p)\n", __FUNCTION__, buffer);
+
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_MAGIC_ASSERT (data, STMfbdevPoolData);
+  D_MAGIC_ASSERT (local, STMfbdevPoolLocalData);
+  D_MAGIC_ASSERT (buffer, CoreSurfaceBuffer);
+  D_ASSERT (config != NULL);
+
+  surface = buffer->surface;
+  D_MAGIC_ASSERT (surface, CoreSurface);
+
+  D_DEBUG_AT (STMfbdev_Surfaces, "  -> buffer/type/id %p/0x%x/%lu\n",
+              buffer, surface->type, surface->resource_id);
+
+  ret = dfb_surfacemanager_allocate (local->core, data->manager,
+                                     buffer, NULL, NULL);
+
+  D_DEBUG_AT (STMfbdev_Surfaces, "  -> %s\n", DirectFBErrorString (ret));
+
+  return ret;
+}
+
+static DFBResult
+stmfbdevAllocateBuffer (CoreSurfacePool       *pool,
+                        void                  *pool_data,
+                        void                  *pool_local,
+                        CoreSurfaceBuffer     *buffer,
+                        CoreSurfaceAllocation *allocation,
+                        void                  *alloc_data)
+{
+  CoreSurface                *surface;
+  STMfbdevPoolData           * const data  = pool_data;
+  STMfbdevPoolLocalData      * const local = pool_local;
+  STMfbdevPoolAllocationData * const alloc = alloc_data;
+  DFBResult                   ret;
+  Chunk                      *chunk;
+
+  D_DEBUG_AT (STMfbdev_Surfaces, "%s (%p)\n", __FUNCTION__, buffer);
+
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_MAGIC_ASSERT (data, STMfbdevPoolData);
+  D_MAGIC_ASSERT (local, STMfbdevPoolLocalData);
+  D_MAGIC_ASSERT (buffer, CoreSurfaceBuffer);
+  D_MAGIC_ASSERT (allocation, CoreSurfaceAllocation);
+
+  surface = buffer->surface;
+  D_MAGIC_ASSERT (surface, CoreSurface);
+
+  ret = dfb_surfacemanager_allocate (local->core, data->manager, buffer,
+                                     allocation, &chunk);
+  if (ret)
+    return ret;
+
+  D_MAGIC_ASSERT (chunk, Chunk);
+
+  alloc->chunk = chunk;
+
+  D_DEBUG_AT (STMfbdev_Surfaces,
+              "  -> offset 0x%.8x (%u), format: %s, pitch %d, size %d\n",
+              chunk->offset, chunk->offset,
+              dfb_pixelformat_name (buffer->format), chunk->pitch,
+              chunk->length);
+
+  allocation->size   = chunk->length;
+  allocation->offset = chunk->offset;
+
+#if STGFX_DRIVER == 2
+  if (unlikely (buffer->format == DSPF_RGB32))
+    {
+      /* for RGB32, we need to set the alpha to 0xff */
+      STGFX2DriverData * const stdrv = dfb_gfxcard_get_driver_data ();
+      STGFX2DeviceData * const stdev = dfb_gfxcard_get_device_data ();
+      DFBRectangle      rect = { .x = 0, .y = 0,
+                                 .w = buffer->surface->config.size.w,
+                                 .h = buffer->surface->config.size.h };
+
+      D_WARN ("BDisp/Surfaces: RGB32 support is experimental and slow!");
+      if (dfb_system_type () != CORE_STMFBDEV)
+        D_WARN ("BDisp/Surfaces: RGB32 is only supported in STMfbdev system!");
+
+      D_DEBUG_AT (STMfbdev_Surfaces, "  -> rgb32 allocation!\n");
+      dfb_gfxcard_lock (GDLF_WAIT);
+
+      _bdisp_aq_RGB32_init (stdrv, stdev,
+                            data->physical + chunk->offset, chunk->pitch,
+                            &rect);
+      dfb_gfxcard_unlock ();
+    }
+#endif
+
+  D_MAGIC_SET (alloc, STMfbdevPoolAllocationData);
+
+  return DFB_OK;
+}
+
+static DFBResult
+stmfbdevDeallocateBuffer (CoreSurfacePool       *pool,
+                          void                  *pool_data,
+                          void                  *pool_local,
+                          CoreSurfaceBuffer     *buffer,
+                          CoreSurfaceAllocation *allocation,
+                          void                  *alloc_data)
+{
+  STMfbdevPoolData            * const data  = pool_data;
+  const STMfbdevPoolLocalData * const local = pool_local;
+  STMfbdevPoolAllocationData  * const alloc = alloc_data;
+
+  D_DEBUG_AT (STMfbdev_Surfaces, "%s (%p)\n", __FUNCTION__, buffer);
+
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_MAGIC_ASSERT (data, STMfbdevPoolData);
+  D_MAGIC_ASSERT (local, STMfbdevPoolLocalData);
+  D_MAGIC_ASSERT (buffer, CoreSurfaceBuffer);
+  D_MAGIC_ASSERT (allocation, CoreSurfaceAllocation);
+  D_MAGIC_ASSERT (alloc, STMfbdevPoolAllocationData);
+
+  (void) local;
+
+  D_ASSERT (alloc->chunk != NULL);
+  dfb_surfacemanager_deallocate (data->manager, alloc->chunk);
+
+  D_MAGIC_CLEAR (alloc);
+
+  return DFB_OK;
+}
+
+static DFBResult
+stmfbdevMuckOut (CoreSurfacePool   *pool,
+                 void              *pool_data,
+                 void              *pool_local,
+                 CoreSurfaceBuffer *buffer )
+{
+  STMfbdevPoolData            * const data  = pool_data;
+  const STMfbdevPoolLocalData * const local = pool_local;
+
+  D_DEBUG_AT (STMfbdev_Surfaces, "%s (%p)\n", __FUNCTION__, buffer);
+
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_MAGIC_ASSERT (data, STMfbdevPoolData);
+  D_MAGIC_ASSERT (local, STMfbdevPoolLocalData);
+  D_MAGIC_ASSERT (buffer, CoreSurfaceBuffer);
+
+  return dfb_surfacemanager_displace (local->core, data->manager, buffer);
+}
+
+#if D_DEBUG_ENABLED
+static char *
+_accessor_str (CoreSurfaceAccessorID accessor)
+{
+  char *str = malloc (220);
+  int pos = 0;
+
+  pos += sprintf (str + pos, "%.8x -> ", accessor);
+  if (accessor == CSAID_NONE)
+    pos += sprintf (str + pos, "NONE");
+  else if (accessor == CSAID_CPU)
+    pos += sprintf (str + pos, "CPU");
+  else if (accessor == CSAID_GPU)
+    pos += sprintf (str + pos, "GPU");
+  else if (accessor == CSAID_ACCEL0)
+    pos += sprintf (str + pos, "ACCEL0");
+  else if (accessor == CSAID_ACCEL1)
+    pos += sprintf (str + pos, "ACCEL1");
+  else if (accessor == CSAID_ACCEL2)
+    pos += sprintf (str + pos, "ACCEL2");
+  else if (accessor == CSAID_ACCEL3)
+    pos += sprintf (str + pos, "ACCEL3");
+  else if (accessor == CSAID_ACCEL4)
+    pos += sprintf (str + pos, "ACCEL4");
+  else if (accessor == CSAID_ACCEL5)
+    pos += sprintf (str + pos, "ACCEL5");
+  else if (accessor == CSAID_LAYER0)
+    pos += sprintf (str + pos, "LAYER0");
+  else if (accessor == CSAID_LAYER1)
+    pos += sprintf (str + pos, "LAYER1");
+  else if (accessor == CSAID_LAYER2)
+    pos += sprintf (str + pos, "LAYER2");
+  else if (accessor == CSAID_LAYER3)
+    pos += sprintf (str + pos, "LAYER3");
+  else if (accessor == CSAID_LAYER4)
+    pos += sprintf (str + pos, "LAYER4");
+  else if (accessor == CSAID_LAYER5)
+    pos += sprintf (str + pos, "LAYER5");
+  else if (accessor == CSAID_LAYER6)
+    pos += sprintf (str + pos, "LAYER6");
+  else if (accessor == CSAID_LAYER7)
+    pos += sprintf (str + pos, "LAYER7");
+  else
+    pos += sprintf (str + pos, "UNKNOWN");
+
+  return str;
+}
+
+static char *
+_access_str (CoreSurfaceAccessFlags access)
+{
+  char *str = malloc (220);
+  int pos = 0;
+
+  pos += sprintf (str + pos, "%.8x ->", access);
+  if (access == CSAF_NONE)
+    pos += sprintf (str + pos, " NONE");
+  else
+    {
+      if (access & CSAF_READ)
+        pos += sprintf (str + pos, " READ");
+      if (access & CSAF_WRITE)
+        pos += sprintf (str + pos, " WRITE");
+      if (access & CSAF_SHARED)
+        pos += sprintf (str + pos, " SHARED");
+    }
+
+  return str;
+}
+#endif
+
+static DFBResult
+stmfbdevLock (CoreSurfacePool       *pool,
+              void                  *pool_data,
+              void                  *pool_local,
+              CoreSurfaceAllocation *allocation,
+              void                  *alloc_data,
+              CoreSurfaceBufferLock *lock)
+{
+  const STMfbdevPoolData           * const data  = pool_data;
+  const STMfbdevPoolLocalData      * const local = pool_local;
+  const STMfbdevPoolAllocationData * const alloc = alloc_data;
+  const Chunk                      *chunk;
+
+  D_DEBUG_AT (STMfbdev_SurfLock, "%s (%p)\n", __FUNCTION__, lock->buffer);
+
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_MAGIC_ASSERT (data, STMfbdevPoolData);
+  D_MAGIC_ASSERT (local, STMfbdevPoolLocalData);
+  D_MAGIC_ASSERT (allocation, CoreSurfaceAllocation);
+  D_MAGIC_ASSERT (alloc, STMfbdevPoolAllocationData);
+  D_MAGIC_ASSERT (lock, CoreSurfaceBufferLock);
+
+  D_MAGIC_ASSERT (alloc->chunk, Chunk);
+  chunk = alloc->chunk;
+
+#if D_DEBUG_ENABLED
+  {
+  /* heavy performance hit */
+  char *accessor = _accessor_str (lock->accessor);
+  char *access   = _access_str (lock->access);
+  D_DEBUG_AT (STMfbdev_SurfLock, "  -> by %s for %s\n", accessor,  access);
+  free (access);
+  free (accessor);
+  }
+#endif
+
+  lock->pitch  = chunk->pitch;
+  lock->offset = chunk->offset;
+  lock->addr   = local->mem + chunk->offset;
+  lock->phys   = data->physical + chunk->offset;
+
+  D_DEBUG_AT (STMfbdev_SurfLock,
+              "  -> offset 0x%.8lx (%lu), pitch %d, addr %p, phys 0x%.8lx\n",
+              lock->offset, lock->offset, lock->pitch, lock->addr, lock->phys);
+
+  return DFB_OK;
+}
+
+static DFBResult
+stmfbdevUnlock (CoreSurfacePool       *pool,
+                void                  *pool_data,
+                void                  *pool_local,
+                CoreSurfaceAllocation *allocation,
+                void                  *alloc_data,
+                CoreSurfaceBufferLock *lock)
+{
+  const STMfbdevPoolData           * const data = pool_data;
+  const STMfbdevPoolLocalData      * const local = pool_local;
+  const STMfbdevPoolAllocationData * const alloc = alloc_data;
+
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_MAGIC_ASSERT (data, STMfbdevPoolData);
+  D_MAGIC_ASSERT (local, STMfbdevPoolLocalData);
+  D_MAGIC_ASSERT (allocation, CoreSurfaceAllocation);
+  D_MAGIC_ASSERT (alloc, STMfbdevPoolAllocationData);
+  D_MAGIC_ASSERT (lock, CoreSurfaceBufferLock);
+
+  D_DEBUG_AT (STMfbdev_SurfLock, "%s (%p)\n", __FUNCTION__, lock->buffer);
+
+  (void) data;
+  (void) local;
+  (void) alloc;
+
+#if D_DEBUG_ENABLED
+  {
+  /* heavy performance hit */
+  char *accessor = _accessor_str (lock->accessor);
+  char *access   = _access_str (lock->access);
+  D_DEBUG_AT (STMfbdev_SurfLock, "  -> by %s for %s\n", accessor,  access);
+  free (access);
+  free (accessor);
+  }
+#endif
+
+#if STGFX_DRIVER == 2
+  if (unlikely (lock->buffer->format == DSPF_RGB32
+                && lock->accessor != CSAID_GPU
+                && lock->access & CSAF_WRITE))
+    {
+      /* if a non-GPU accessor did a write access to an RGB32 surface, we
+         should make sure the alpha is forced to 0xff, as the BDisp doesn't
+         support this format natively */
+      STGFX2DriverData * const stdrv = dfb_gfxcard_get_driver_data ();
+      STGFX2DeviceData * const stdev = dfb_gfxcard_get_device_data ();
+      DFBRectangle      rect = { .x = 0, .y = 0,
+                                 .w = lock->buffer->surface->config.size.w,
+                                 .h = lock->buffer->surface->config.size.h };
+
+      D_DEBUG_AT (STMfbdev_SurfLock, "  -> rgb32 write release!\n");
+      dfb_gfxcard_lock (GDLF_WAIT);
+      _bdisp_aq_RGB32_fixup (stdrv, stdev,
+                             lock->phys, lock->pitch,
+                             &rect);
+      dfb_gfxcard_unlock ();
+    }
+#endif
+
+  return DFB_OK;
+}
+
+const SurfacePoolFuncs _g_stmfbdevSurfacePoolFuncs = {
+  .PoolDataSize       = stmfbdevPoolDataSize,
+  .PoolLocalDataSize  = stmfbdevPoolLocalDataSize,
+  .AllocationDataSize = stmfbdevAllocationDataSize,
+
+  .InitPool    = stmfbdevInitPool,
+  .JoinPool    = stmfbdevJoinPool,
+  .DestroyPool = stmfbdevDestroyPool,
+  .LeavePool   = stmfbdevLeavePool,
+
+  .TestConfig       = stmfbdevTestConfig,
+  .AllocateBuffer   = stmfbdevAllocateBuffer,
+  .DeallocateBuffer = stmfbdevDeallocateBuffer,
+
+  .MuckOut = stmfbdevMuckOut,
+
+  .Lock   = stmfbdevLock,
+  .Unlock = stmfbdevUnlock,
+};
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/gfxdrivers/stgfx2/stm_gfxdriver.c DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/stm_gfxdriver.c
--- DirectFB/gfxdrivers/stgfx2/stm_gfxdriver.c	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/stm_gfxdriver.c	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,485 @@
+/*
+   ST Microelectronics BDispII driver - the DirectFB interface
+
+   (c) Copyright 2003, 2007-2010   STMicroelectronics Ltd.
+
+   All rights reserved.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+
+#include <sys/mman.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+
+#include <linux/fb.h>
+#include <linux/stmfb.h>
+
+#include <directfb.h>
+#include <dfb_types.h>
+
+#include <core/coredefs.h>
+#include <core/coretypes.h>
+
+#include <core/core.h>
+#include <core/state.h>
+#include <core/gfxcard.h>
+#include <core/surface.h>
+#include <core/system.h>
+#include <core/palette.h>
+
+#include <fbdev/fbdev.h>
+#include <stmfbdev/stmfbdev.h>
+
+#include <gfx/convert.h>
+#include <gfx/util.h>
+
+#include <core/graphics_driver.h>
+
+#include "stgfx2_features.h"
+
+#include "stm_gfxdriver.h"
+
+#include "bdisp_features.h"
+#include "bdisp_state.h"
+#include "bdisp_accel.h"
+#include "stgfx_screen.h"
+#include "stgfx_primary.h"
+#include "bdisp_surface_pool.h"
+
+
+
+DFB_GRAPHICS_DRIVER (stgfx2);
+
+
+
+
+#define MEMORY64MB_SIZE         (1<<26)
+#define _ALIGN_DOWN(addr,size)	((addr)&(~((size)-1)))
+
+static bool
+__attribute__((warn_unused_result))
+stgfx2_check_memory_constraints (CoreGraphicsDevice     * const device,
+                                 const STGFX2DeviceData * const stdev)
+{
+  /* fbmem could in theory cross a 64MB boundary, stmfb doesn't go through any
+     efforts whatsoever to prevent such from happening. It should be changed
+     to add a check for configurations which end up crossing a boundary, but
+     even then I don't think I'll remove the check from here, since otherwise
+     we add a (soft) dependency on an up-to-date version of stmfb. */
+  unsigned long fb_base = dfb_gfxcard_memory_physical (device, 0);
+  unsigned long fb_end  = fb_base + dfb_gfxcard_memory_length () - 1;
+  if (_ALIGN_DOWN (fb_base, MEMORY64MB_SIZE) != _ALIGN_DOWN (fb_end, MEMORY64MB_SIZE))
+    {
+      fprintf (stderr,
+               "BDisp/BLT: Your framebuffer memory configuration"
+               " is incorrect!\n"
+               "  Can't use hardware acceleration at all!\n"
+               "  Physical framebuffer memory must not cross a 64MB bank!\n"
+               "  Please fix your configuration!\n");
+
+      return false;
+    }
+
+  return true;
+}
+
+
+static int
+driver_probe (CoreGraphicsDevice * const device)
+{
+  switch (dfb_system_type ())
+    {
+    case CORE_FBDEV:
+    case CORE_STMFBDEV:
+      if (dfb_gfxcard_get_accelerator (device) != FB_ACCEL_ST_BDISP_USER)
+        break;
+
+      D_DEBUG ("DirectFB/stgfx2: Found STM BDispII w/ user space AQs\n");
+      return 1;
+
+    default:
+      break;
+    }
+
+  return 0;
+}
+
+static void
+driver_get_info (CoreGraphicsDevice * const device,
+                 GraphicsDriverInfo * const info)
+{
+  /* fill driver info structure */
+  snprintf (info->name, DFB_GRAPHICS_DRIVER_INFO_NAME_LENGTH,
+            "STM BDispII w/ user space AQs");
+
+  snprintf (info->vendor, DFB_GRAPHICS_DRIVER_INFO_VENDOR_LENGTH,
+            "ST Microelectronics");
+
+  info->version.major = 0;
+  info->version.minor = 9;
+
+  /* Tell DirectFB how big our device and driver structures are */
+  info->driver_data_size = sizeof (STGFX2DriverData);
+  info->device_data_size = sizeof (STGFX2DeviceData);
+}
+
+
+static DFBResult
+driver_init_driver (CoreGraphicsDevice  * const device,
+                    GraphicsDeviceFuncs * const funcs,
+                    void                * const driver_data,
+                    void                * const device_data,
+                    CoreDFB             * const core)
+{
+  STGFX2DeviceData * const stdev = device_data;
+  STGFX2DriverData * const stdrv = driver_data;
+  DFBResult         res;
+
+  stdrv->core        = core;
+  stdrv->device      = device;
+  stdrv->device_data = device_data;
+
+  D_INFO ("DirectFB/stgfx2: stdev/stdrv: %p / %p\n", stdev, stdrv);
+
+  /* check memory constraints */
+  if (!stgfx2_check_memory_constraints (device, stdev))
+    return DFB_UNSUPPORTED;
+
+  stdrv->mmio_base = dfb_gfxcard_map_mmio (device, 0, -1);
+  if (!stdrv->mmio_base)
+    {
+      D_ERROR ("DirectFB/stgfx2: couldn't mmap mmio!\n");
+      return DFB_IO;
+    }
+
+  /* we will need the framebuffer file descriptor. */
+  stdrv->fd = -1;
+  if (dfb_system_type () == CORE_FBDEV)
+    {
+      const FBDev * const dfb_fbdev = dfb_system_data ();
+      D_INFO ("DirectFB/stgfx2: running in fbdev\n");
+
+      if (!dfb_fbdev)
+        {
+          D_ERROR ("DirectFB/stgfx2: No System data?!\n");
+          res = DFB_NOCONTEXT;
+          goto out1;
+        }
+
+      stdrv->fd = dfb_fbdev->fd;
+    }
+  else if (dfb_system_type () == CORE_STMFBDEV)
+    {
+      const STMfbdev * const stmfbdev = dfb_system_data ();
+      D_INFO ("DirectFB/stgfx2: running in stmfbdev\n");
+
+      D_MAGIC_ASSERT (stmfbdev, STMfbdev);
+      if (!stmfbdev)
+        {
+          D_ERROR ("DirectFB/stgfx2: No System data?!\n");
+          res = DFB_NOCONTEXT;
+          goto out1;
+        }
+
+      stdrv->fd = stmfbdev->fd;
+    }
+  else
+    {
+      /* shouldn't be reached, though. Because of our driver_probe(). */
+      D_ERROR ("DirectFB/stgfx2: Only supported on FBDev and STMfbdev systems\n");
+      res = DFB_UNSUPPORTED;
+      goto out1;
+    }
+
+  if (stdrv->fd < 0)
+    {
+      D_ERROR ("DirectFB/stgfx2: No fd?!");
+      res = DFB_IO;
+      goto out1;
+    }
+
+  stdrv->accel_type = dfb_gfxcard_get_accelerator (device);
+
+  if (!dfb_core_is_master (core))
+    {
+      Stgfx2Clut palette;
+
+      /* map BDisp kernel driver's shared area... */
+      stdrv->bdisp_shared = mmap (NULL,
+                                  sysconf (_SC_PAGESIZE),
+                                  PROT_READ | PROT_WRITE,
+                                  MAP_SHARED, stdrv->fd,
+                                  stdev->bdisp_shared_info.physical);
+      if (stdrv->bdisp_shared == MAP_FAILED)
+        {
+          D_PERROR ("DirectFB/stgfx2: Could not map shared area!\n");
+          stdrv->bdisp_shared = NULL;
+          res = DFB_FAILURE;
+          goto out1;
+        }
+
+      /* ...and the node list... */
+      stdrv->bdisp_nodes = mmap (NULL,
+                                 (stdev->bdisp_shared_info.size
+                                  - sysconf (_SC_PAGESIZE)),
+                                 PROT_READ | PROT_WRITE,
+                                 MAP_SHARED, stdrv->fd,
+                                 (stdev->bdisp_shared_info.physical
+                                  + sysconf (_SC_PAGESIZE)));
+      if (stdrv->bdisp_nodes == MAP_FAILED)
+        {
+          D_PERROR ("DirectFB/stgfx2: Could not map nodes area!\n");
+          stdrv->bdisp_nodes = NULL;
+          res = DFB_FAILURE;
+          goto out2;
+        }
+      D_INFO ("DirectFB/stgfx2: shared area/nodes mmap()ed to %p / %p\n",
+              stdrv->bdisp_shared, stdrv->bdisp_nodes);
+
+      /* ...and the CLUTs. */
+      for (palette = SG2C_NORMAL; palette < SG2C_DYNAMIC_COUNT; ++palette)
+        {
+          stdrv->clut_virt[palette]
+            = dfb_gfxcard_memory_virtual (device, stdev->clut_offset[palette]);
+          D_INFO ("DirectFB/stgfx2: CLUT mmap()ed to %p\n",
+                  stdrv->clut_virt[palette]);
+        }
+    }
+
+
+  /* setup the driver state */
+  funcs->EngineReset   = bdisp_aq_EngineReset;
+  funcs->EngineSync    = bdisp_aq_EngineSync;
+  funcs->CheckState    = bdisp_aq_CheckState;
+  funcs->SetState      = bdisp_aq_SetState;
+  funcs->EmitCommands  = bdisp_aq_EmitCommands;
+#ifdef STGFX2_IMPLEMENT_WAITSERIAL
+  funcs->GetSerial     = bdisp_aq_GetSerial;
+  funcs->WaitSerial    = bdisp_aq_WaitSerial;
+#endif
+  funcs->FillRectangle = bdisp_aq_FillRectangle;
+  funcs->DrawRectangle = bdisp_aq_DrawRectangle;
+  funcs->Blit          = bdisp_aq_Blit;
+  funcs->StretchBlit   = bdisp_aq_StretchBlit;
+  funcs->Blit2         = bdisp_aq_Blit2_nop;
+
+  if (dfb_system_type () == CORE_STMFBDEV)
+    {
+      extern const SurfacePoolFuncs _g_stmfbdevSurfacePoolFuncs;
+      extern ScreenFuncs            _g_stmfbdevScreenFuncs;
+      extern DisplayLayerFuncs      _g_stmfbdevLayerFuncs;
+
+      STMfbdev   * const stmfbdev = dfb_system_data ();
+      CoreScreen *screen;
+
+      D_MAGIC_ASSERT (stmfbdev, STMfbdev);
+
+      if (!dfb_core_is_master (stdrv->core))
+        dfb_surface_pool_join (stdrv->core, stdev->pool,
+                               &_g_stmfbdevSurfacePoolFuncs);
+
+      /* Register primary screen functions */
+      screen = dfb_screens_register (NULL, stmfbdev,
+                                     &_g_stmfbdevScreenFuncs);
+
+      /* Register primary layer functions */
+      dfb_layers_register (screen, stmfbdev, &_g_stmfbdevLayerFuncs);
+    }
+  else if (dfb_system_type() == CORE_FBDEV)
+    {
+      dfb_screens_hook_primary (device, driver_data,
+                                &stgfxPrimaryScreenFuncs_stgfx2,
+                                &stdrv->screenData.orig_funcs,
+                                &stdrv->screenData.orig_data);
+
+      dfb_layers_hook_primary (device, driver_data,
+                               &stgfxPrimaryLayerFuncs_stgfx2,
+                               &stdrv->layerData.orig_funcs,
+                               &stdrv->layerData.orig_data);
+    }
+
+  if (!dfb_core_is_master (stdrv->core))
+    stgfx2_surface_pool_join (stdrv->core, stdev->aux_pools,
+                              D_ARRAY_SIZE (stdev->aux_pools));
+
+  return DFB_OK;
+
+out2:
+  if (!dfb_core_is_master (core))
+    munmap ((void *) stdrv->bdisp_shared, 4096);
+out1:
+  dfb_gfxcard_unmap_mmio (device, stdrv->mmio_base, -1);
+  return res;
+}
+
+static DFBResult
+driver_init_device (CoreGraphicsDevice * const device,
+                    GraphicsDeviceInfo * const device_info,
+                    void               * const driver_data,
+                    void               * const device_data)
+{
+  STGFX2DeviceData * const stdev = device_data;
+  STGFX2DriverData * const stdrv = driver_data;
+  DFBResult         res;
+
+  snprintf (device_info->name, DFB_GRAPHICS_DEVICE_INFO_NAME_LENGTH,
+            "BDispII w/ user space AQs");
+
+  snprintf (device_info->vendor, DFB_GRAPHICS_DEVICE_INFO_VENDOR_LENGTH,
+            "ST Microelectronics");
+
+  dfb_config->pollvsync_after = true;
+
+  /* give DirectFB info about our surface limitations. need to do this
+     before bdisp_aq_initialize(), because it has its own limitations, which
+     are different, depending on the platform. FIXME: should really make
+     this dependent on the platform, i.e. without an #if 0... */
+#if 0
+  /* real BDispII limitations */
+  device_info->limits.surface_byteoffset_alignment =  4;
+  device_info->limits.surface_bytepitch_alignment  =  2;
+#else
+  /* the 3D unit on 7108 has these limitations */
+  device_info->limits.surface_byteoffset_alignment = 64;
+  device_info->limits.surface_bytepitch_alignment  =  8;
+  /* JPEGHWDEC requires surfaces aligned on 256-bytes boundaries. Surfaces
+     for uncompressed BMP must have a pitch which is a multiple of 4. */
+  device_info->limits.surface_byteoffset_alignment = 256;
+#endif
+  /* for YUV 4:2:x formats, the pitch must be even, so that we can safely
+     deduct the chroma pitch by dividing the luma pitch by two. */
+  device_info->limits.surface_pixelpitch_alignment =  2;
+
+  res = bdisp_aq_initialize (device,
+                             device_info,
+                             (STGFX2DriverData *) driver_data,
+                             (STGFX2DeviceData *) device_data);
+  if (res != DFB_OK)
+    return res;
+
+  /* Tell DirectFB about what operations we may be able to do. */
+  device_info->caps.accel    = (STGFX2_VALID_DRAWINGFUNCTIONS
+                                | STGFX2_VALID_BLITTINGFUNCTIONS);
+  device_info->caps.drawing  = stdev->features.dfb_drawflags;
+  device_info->caps.blitting = stdev->features.dfb_blitflags;
+#ifdef STGFX2_SUPPORT_HW_CLIPPING
+  device_info->caps.flags    = CCF_CLIPPING;
+  device_info->caps.clip     = DFXL_STRETCHBLIT;
+#endif
+  device_info->caps.flags |= CCF_RENDEROPTS;
+  device_info->limits.src_max.w
+    = device_info->limits.src_max.h
+    = device_info->limits.dst_max.w
+    = device_info->limits.dst_max.h
+    = 4095;
+
+  /* Need to update the surface limitations again, because
+     bdisp_aq_initialize() might have changed them, depending on the platform.
+     FIXME: should really make this dependent on the platform, i.e. without an
+     #if 0... */
+#if 0
+  /* real BDispII limitations */
+  device_info->limits.surface_byteoffset_alignment =  4;
+  device_info->limits.surface_bytepitch_alignment  =  2;
+#else
+  /* the 3D unit on 7108 has these limitations */
+  device_info->limits.surface_byteoffset_alignment = 64;
+  device_info->limits.surface_bytepitch_alignment  =  8;
+  /* JPEGHWDEC requires surfaces aligned on 256-bytes boundaries. Surfaces
+     for uncompressed BMP must have a pitch which is a multiple of 4. */
+  device_info->limits.surface_byteoffset_alignment = 256;
+#endif
+  /* for YUV 4:2:x formats, the pitch must be even, so that we can safely
+     deduct the chroma pitch by dividing the luma pitch by two. */
+  device_info->limits.surface_pixelpitch_alignment =  2;
+
+  if (dfb_system_type () == CORE_STMFBDEV)
+    {
+      extern const SurfacePoolFuncs _g_stmfbdevSurfacePoolFuncs;
+      dfb_surface_pool_initialize (stdrv->core, &_g_stmfbdevSurfacePoolFuncs,
+                                   &stdev->pool);
+    }
+  /* aux pools */
+  stgfx2_surface_pool_init (stdrv->core, stdev->aux_pools,
+                            D_ARRAY_SIZE (stdev->aux_pools));
+
+  return DFB_OK;
+}
+
+
+static void
+driver_close_device (CoreGraphicsDevice * const device,
+                     void               * const driver_data,
+                     void               * const device_data)
+{
+  STGFX2DriverData * const stdrv = driver_data;
+  STGFX2DeviceData * const stdev = device_data;
+
+  if (dfb_system_type () == CORE_STMFBDEV)
+    dfb_surface_pool_destroy (stdev->pool);
+  stgfx2_surface_pool_destroy (stdrv->core, stdev->aux_pools,
+                               D_ARRAY_SIZE (stdev->aux_pools));
+}
+
+static void
+driver_close_driver (CoreGraphicsDevice * const device,
+                     void               * const driver_data)
+{
+  STGFX2DriverData * const stdrv = driver_data;
+  STGFX2DeviceData * const stdev = stdrv->device_data;
+
+  if (!dfb_core_is_master (stdrv->core))
+    {
+      if (dfb_system_type () == CORE_STMFBDEV)
+        dfb_surface_pool_leave (stdev->pool);
+      stgfx2_surface_pool_leave (stdrv->core, stdev->aux_pools,
+                                 D_ARRAY_SIZE (stdev->aux_pools));
+    }
+
+  if (stdrv->bdisp_shared)
+    {
+      const STMFBBDispSharedArea __attribute__((unused)) * const shared
+        = stdrv->bdisp_shared;
+      unsigned long long ops;
+
+      D_INFO ("DirectFB/stgfx2: %u starts, %u (%u/%u) interrupts, %u wait_idle, %u wait_next, %u idle\n",
+              shared->num_starts, shared->num_irqs, shared->num_node_irqs,
+              shared->num_lna_irqs,
+              shared->num_wait_idle, shared->num_wait_next, shared->num_idle);
+
+      ops = ((unsigned long long) shared->num_ops_hi) << 32;
+      ops += shared->num_ops_lo;
+      D_INFO ("DirectFB/stgfx2: %llu ops, %llu ops/start, %llu ops/idle, %u starts/idle\n",
+              ops,
+              shared->num_starts ? ops / shared->num_starts : 0,
+              shared->num_idle   ? ops / shared->num_idle   : 0,
+              shared->num_idle   ? shared->num_starts / shared->num_idle : 0);
+
+      munmap ((void *) stdrv->bdisp_shared, 4096);
+    }
+  if (stdrv->bdisp_nodes)
+    munmap ((void *) stdrv->bdisp_nodes,
+            stdrv->device_data->bdisp_shared_info.size - 4096);
+
+  dfb_gfxcard_unmap_mmio (device, stdrv->mmio_base, -1);
+}
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/gfxdrivers/stgfx2/stm_gfxdriver.h DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/stm_gfxdriver.h
--- DirectFB/gfxdrivers/stgfx2/stm_gfxdriver.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/stm_gfxdriver.h	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,207 @@
+/*
+   ST Microelectronics BDispII driver - the DirectFB interface
+
+   (c) Copyright 2007-2010  STMicroelectronics Ltd.
+
+   All rights reserved.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#ifndef __STM_GFXDRIVER_H__
+#define __STM_GFXDRIVER_H__
+
+
+#include <dfb_types.h>
+#include <core/state.h>
+#include <core/screens.h>
+#include <core/layers.h>
+#include <core/surface_pool.h>
+
+#include <linux/stmfb.h>
+
+#include "stm_types.h"
+#include "bdisp_accel_types.h"
+#include "bdisp_registers.h"
+#include "bdisp_features.h"
+
+#include "stgfx_screen.h"
+#include "stgfx_primary.h"
+
+
+/* Structures for storing information about graphics state */
+typedef enum
+{
+  SG2C_NORMAL,
+  SG2C_COLORALPHA               /* out = color, RGBout = RGBin */,
+  SG2C_INVCOLORALPHA            /* out = 1-color, RGBout = RGBin */,
+  SG2C_ALPHA_MUL_COLORALPHA     /* out =  * color, RGBout = RGBin */,
+  SG2C_INV_ALPHA_MUL_COLORALPHA /* out = 1-( * color), RGBout = RGBin */,
+  SG2C_DYNAMIC_COUNT            /* number of dynamic palettes */,
+
+  SG2C_ONEALPHA_RGB      /* out = 1, RGBout = RGBin */ = SG2C_DYNAMIC_COUNT,
+  SG2C_INVALPHA_ZERORGB  /* out = 1 - Ain, RGBout = 0 */,
+  SG2C_ALPHA_ZERORGB     /* out = Ain, RGBout = 0 */,
+  SG2C_ZEROALPHA_RGB     /* out = 0, RGBout = RGBin */,
+  SG2C_ZEROALPHA_ZERORGB /* out = 0, RGBout = 0 */,
+  SG2C_ONEALPHA_ZERORGB  /* out = 1, RGBout = 0 */,
+
+  SG2C_COUNT
+} Stgfx2Clut;
+
+
+/* Structure for storing information about device state */
+struct _STGFX2DeviceData
+{
+  int aq_index;
+
+  /* physical address and size of STMFBBDispSharedArea */
+  struct stmfbio_shared bdisp_shared_info;
+  unsigned long usable_nodes_size; /* shared->nodes_size may not be a multiple
+                                      of our sizeof (<biggest_node>) */
+  unsigned long node_irq_delay; /* every now and then, we want to see a node
+                                   completed interrupt, so a) we don't have to
+                                   wait for a complete list to finish, and b)
+                                   we don't want them to happen too often. */
+
+  /* validation flags */
+  int v_flags;
+
+  struct _BltNodeGroup00  ConfigGeneral;
+  struct _BltNodeGroup01  ConfigTarget;
+  struct _BltNodeGroup02  ConfigColor;
+  struct _BltNodeGroup03  ConfigSource1;
+  struct _BltNodeGroup04  ConfigSource2;
+  struct _BltNodeGroup05  ConfigSource3;
+#ifdef STGFX2_SUPPORT_HW_CLIPPING
+  struct _BltNodeGroup06  ConfigClip;
+#endif
+  struct _BltNodeGroup07  ConfigClut;
+  struct _BltNodeGroup08  ConfigFilters;
+  struct _BltNodeGroup09  ConfigFiltersChr;
+  struct _BltNodeGroup10  ConfigFiltersLuma;
+  struct _BltNodeGroup11  ConfigFlicker;
+  struct _BltNodeGroup12  ConfigColorkey;
+  struct _BltNodeGroup14  ConfigStatic;
+  struct _BltNodeGroup15  ConfigIVMX;
+  struct _BltNodeGroup16  ConfigOVMX;
+  struct _BltNodeGroup18  ConfigVC1R;
+
+  /* drawing state */
+  struct {
+    struct _BltNodeGroup00 ConfigGeneral;
+    unsigned long          color;
+    unsigned long          color_ty;
+    struct _BltNodeGroup07 ConfigClut;
+  } drawstate;
+
+  struct {
+    u32 src_ckey;
+
+    bool canUseHWInputMatrix;
+    bool isOptimisedModulation;
+    bool src_premultcolor;
+    u32  blt_ins_src1_mode;
+
+    int n_passes;
+    struct {
+      struct _BltNodeGroup00 ConfigGeneral;
+      Stgfx2Clut             palette_type;
+    } extra_passes[2];
+
+    enum STM_BLITTER_FLAGS flags; /* FIXME: remove soon! */
+  } blitstate;
+
+  /* shared between both draw and blit states */
+  struct {
+    u32 dst_ckey;
+    u32 extra_blt_ins; /* for RGB32 to always enable plane mask */
+    u32 extra_blt_cic; /* for RGB32 to always enable plane mask */
+  } all_states;
+
+
+  unsigned long clut_phys[SG2C_COUNT];
+  int  clut_offset[SG2C_DYNAMIC_COUNT];
+#ifdef STGFX2_CLUT_UNSAFE_MULTISESSION
+  bool clut_disabled;
+#endif
+
+
+  unsigned long filter_8x8_phys;
+  unsigned long filter_5x8_phys;
+
+
+  /* state etc */
+  u32 srcFactorH; /* factors for source1 and source2 coordinate increment,
+                     will normally be == 1. For certain YCbCr pixel formats it
+                     will be == 2, though. */
+  u32 srcFactorV;
+
+  DFBSurfacePorterDuffRule porter_duff_rule;
+
+  CorePalette *palette;
+  Stgfx2Clut   palette_type;
+
+  bool bIndexTranslation    : 1;
+  bool bFixedPoint          : 1;
+  int  rotate; /* degree counter clockwise. Only 90 180 270 */
+
+  int h_trgt_sign, h_src2_sign, v_trgt_sign, v_src2_sign;
+  int source_w; /* the total width of the surface in 16.16 */
+  int source_h; /* the total height of the surface in 16.16 */
+  u32 hsrcinc; /* in 16.16 */
+  u32 vsrcinc; /* in 16.16 */
+
+  struct _bdisp_hw_features features;
+
+  /* stmfbdev system */
+  CoreSurfacePool *pool;
+
+  CoreSurfacePool *aux_pools[STMFBGP_GFX_LAST - STMFBGP_GFX_FIRST + 1];
+  /* for exclusive use by bdisp_surface_pool.c */
+  unsigned int aux_pool_index;
+};
+
+
+struct _STGFX2DriverData
+{
+  CoreDFB            *core;
+
+  CoreGraphicsDevice *device;
+  STGFX2DeviceData   *device_data;
+  int                 fd;
+
+  int accel_type;
+
+  /* blit nodes */
+  STMFBBDispSharedArea *bdisp_shared; /* shared area */
+  volatile void        *bdisp_nodes;  /* node list   */
+
+  /* BDisp base */
+  volatile void *mmio_base;
+
+  /* clut */
+  unsigned long *clut_virt[SG2C_DYNAMIC_COUNT];
+
+
+  struct _STGFX2ScreenData screenData;
+  struct _STGFX2LayerData  layerData;
+};
+
+
+
+
+#endif /* __STM_GFXDRIVER_H__ */
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/gfxdrivers/stgfx2/stm_types.h DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/stm_types.h
--- DirectFB/gfxdrivers/stgfx2/stm_types.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/stm_types.h	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,76 @@
+/*
+   ST Microelectronics BDispII driver - some types we use
+
+   (c) Copyright 2008       STMicroelectronics Ltd.
+
+   All rights reserved.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#ifndef __STM_TYPES_H__
+#define __STM_TYPES_H__
+
+
+
+#define likely(x)       __builtin_expect(!!(x),1)
+#define unlikely(x)     __builtin_expect(!!(x),0)
+
+/* general driver stuff */
+typedef struct _STGFX2DeviceData STGFX2DeviceData;
+typedef struct _STGFX2DriverData STGFX2DriverData;
+
+
+
+
+/* BDisp stuff */
+/* general config */
+typedef struct _BltNodeGroup00 BltNodeGroup00;
+/* target config */
+typedef struct _BltNodeGroup01 BltNodeGroup01;
+/* color fill */
+typedef struct _BltNodeGroup02 BltNodeGroup02;
+/* source 1 config */
+typedef struct _BltNodeGroup03 BltNodeGroup03;
+/* source 2 config */
+typedef struct _BltNodeGroup04 BltNodeGroup04;
+/* source 3 config */
+typedef struct _BltNodeGroup05 BltNodeGroup05;
+/* clip config */
+typedef struct _BltNodeGroup06 BltNodeGroup06;
+/* clut & color space conversion */
+typedef struct _BltNodeGroup07 BltNodeGroup07;
+/* filters control and plane mask */
+typedef struct _BltNodeGroup08 BltNodeGroup08;
+/* 2D (chroma) filter control */
+typedef struct _BltNodeGroup09 BltNodeGroup09;
+/* 2D (lumna) filter control */
+typedef struct _BltNodeGroup10 BltNodeGroup10;
+/* flicker filter */
+typedef struct _BltNodeGroup11 BltNodeGroup11;
+/* color key 1 and 2 */
+typedef struct _BltNodeGroup12 BltNodeGroup12;
+/* static addressing and user */
+typedef struct _BltNodeGroup14 BltNodeGroup14;
+/* input versatile matrix 0, 1, 2, 3 */
+typedef struct _BltNodeGroup15 BltNodeGroup15;
+/* output versatile matrix 0, 1, 2, 3 */
+typedef struct _BltNodeGroup16 BltNodeGroup16;
+/* VC1 range engine */
+typedef struct _BltNodeGroup18 BltNodeGroup18;
+
+
+#endif /* __STM_TYPES_H__ */
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/gfxdrivers/stgfx2/surfacemanager.c DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/surfacemanager.c
--- DirectFB/gfxdrivers/stgfx2/surfacemanager.c	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/surfacemanager.c	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,566 @@
+/*
+   (c) Copyright 2010       STMicroelectronics (R&D) Ltd.
+   (c) Copyright 2001-2009  The world wide DirectFB Open Source Community (directfb.org)
+   (c) Copyright 2000-2004  Convergence (integrated media) GmbH
+
+   All rights reserved.
+
+   Written by Andr Draszik <andre.draszik@st.com>.
+ 
+   Based on work by Denis Oliver Kropp <dok@directfb.org>,
+                    Andreas Hundt <andi@fischlustig.de>,
+                    Sven Neumann <neo@directfb.org>,
+                    Ville Syrjl <syrjala@sci.fi> and
+                    Claudio Ciccani <klan@users.sf.net>.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+
+#include <fusion/shmalloc.h>
+
+#include <directfb.h>
+#include <directfb_util.h>
+
+#include <core/core.h>
+
+#include <core/gfxcard.h>
+#include <core/surface.h>
+#include <core/surface_buffer.h>
+
+#include <direct/debug.h>
+#include <direct/messages.h>
+#include <direct/util.h>
+
+#include <gfx/convert.h>
+
+#include "surfacemanager.h"
+
+D_DEBUG_DOMAIN( SurfMan, "SurfaceManager", "DirectFB Surface Manager" );
+
+
+static Chunk *split_chunk ( SurfaceManager *manager,
+                            Chunk          *chunk,
+                            int             length );
+
+static Chunk *free_chunk  ( SurfaceManager *manager,
+                            Chunk          *chunk );
+
+static Chunk *occupy_chunk( SurfaceManager        *manager,
+                            Chunk                 *chunk,
+                            CoreSurfaceAllocation *allocation,
+                            int                    length,
+                            int                    pitch );
+
+
+DFBResult
+dfb_surfacemanager_create( CoreDFB         *core,
+                           unsigned int     length,
+                           SurfaceManager **ret_manager )
+{
+     FusionSHMPoolShared *pool;
+     SurfaceManager      *manager;
+     Chunk               *chunk;
+
+     D_DEBUG_AT( SurfMan, "%s( %p, %d )\n", __FUNCTION__, core, length );
+
+     D_ASSERT( core != NULL );
+     D_ASSERT( ret_manager != NULL );
+
+     pool = dfb_core_shmpool( core );
+
+     manager = SHCALLOC( pool, 1, sizeof(SurfaceManager) );
+     if (!manager)
+          return D_OOSHM();
+
+     chunk = SHCALLOC( pool, 1, sizeof(Chunk) );
+     if (!chunk) {
+          D_OOSHM();
+          SHFREE( pool, manager );
+          return DFB_NOSHAREDMEMORY;
+     }
+
+     manager->shmpool = pool;
+     manager->chunks  = chunk;
+     manager->offset  = 0;
+     manager->length  = length;
+     manager->avail   = manager->length - manager->offset;
+
+     D_MAGIC_SET( manager, SurfaceManager );
+
+     chunk->offset    = manager->offset;
+     chunk->length    = manager->avail;
+
+     D_MAGIC_SET( chunk, Chunk );
+
+     D_DEBUG_AT( SurfMan, "  -> %p\n", manager );
+
+     *ret_manager = manager;
+
+     return DFB_OK;
+}
+
+void
+dfb_surfacemanager_destroy( SurfaceManager *manager )
+{
+     Chunk *chunk;
+     void  *next;
+
+     D_DEBUG_AT( SurfMan, "%s( %p )\n", __FUNCTION__, manager );
+
+     D_MAGIC_ASSERT( manager, SurfaceManager );
+
+     /* Deallocate all video chunks. */
+     chunk = manager->chunks;
+     while (chunk) {
+          next = chunk->next;
+
+          D_MAGIC_CLEAR( chunk );
+
+          SHFREE( manager->shmpool, chunk );
+
+          chunk = next;
+     }
+
+     D_MAGIC_CLEAR( manager );
+
+     /* Deallocate manager struct. */
+     SHFREE( manager->shmpool, manager );
+}
+
+/** public functions NOT locking the surfacemanger theirself,
+    to be called between lock/unlock of surfacemanager **/
+
+DFBResult dfb_surfacemanager_allocate( CoreDFB                *core,
+                                       SurfaceManager         *manager,
+                                       CoreSurfaceBuffer      *buffer,
+                                       CoreSurfaceAllocation  *allocation,
+                                       Chunk                 **ret_chunk )
+{
+     int pitch;
+     int length;
+     Chunk *c;
+     CoreGraphicsDevice *device;
+
+     Chunk *best_free = NULL;
+
+     D_MAGIC_ASSERT( manager, SurfaceManager );
+     D_MAGIC_ASSERT( buffer, CoreSurfaceBuffer );
+     D_MAGIC_ASSERT( buffer->surface, CoreSurface );
+
+     if (ret_chunk)
+          D_MAGIC_ASSERT( allocation, CoreSurfaceAllocation );
+     else
+          D_ASSUME( allocation == NULL );
+
+     D_DEBUG_AT( SurfMan, "%s( %p ) <- %dx%d %s\n", __FUNCTION__, buffer,
+                 buffer->surface->config.size.w, buffer->surface->config.size.h,
+                 dfb_pixelformat_name( buffer->surface->config.format ) );
+
+     if (manager->suspended)
+          return DFB_SUSPENDED;
+
+     /* FIXME: Only one global device at the moment. */
+     device = dfb_core_get_part( core, DFCP_GRAPHICS );
+     D_ASSERT( device != NULL );
+
+     dfb_gfxcard_calc_buffer_size( device, buffer, &pitch, &length );
+
+     D_DEBUG_AT( SurfMan, "  -> pitch %d, length %d, available %d\n", pitch, length, manager->avail );
+
+     if (manager->avail < length)
+          return DFB_TEMPUNAVAIL;
+
+     /* examine chunks */
+     c = manager->chunks;
+     D_MAGIC_ASSERT( c, Chunk );
+
+     while (c) {
+          D_MAGIC_ASSERT( c, Chunk );
+
+          if (!c->buffer && c->length >= length) {
+               /* NULL means check only. */
+               if (!ret_chunk)
+                    return DFB_OK;
+
+               /* found a nice place to chill */
+               if (!best_free  ||  best_free->length > c->length)
+                    /* first found or better one? */
+                    best_free = c;
+
+               if (c->length == length)
+                    break;
+          }
+
+          c = c->next;
+     }
+
+     /* if we found a place */
+     if (best_free) {
+          D_DEBUG_AT( SurfMan, "  -> found free (%d)\n", best_free->length );
+
+          /* NULL means check only. */
+          if (ret_chunk)
+               *ret_chunk = occupy_chunk( manager, best_free, allocation, length, pitch );
+
+          return DFB_OK;
+     }
+
+     D_DEBUG_AT( SurfMan, "  -> failed (%d/%d avail)\n", manager->avail, manager->length );
+
+     /* no luck */
+     return DFB_NOVIDEOMEMORY;
+}
+
+DFBResult dfb_surfacemanager_displace( CoreDFB           *core,
+                                       SurfaceManager    *manager,
+                                       CoreSurfaceBuffer *buffer )
+{
+     int                    length;
+     Chunk                 *multi_start = NULL;
+     int                    multi_size  = 0;
+     int                    multi_tsize = 0;
+     int                    multi_count = 0;
+     Chunk                 *bestm_start = NULL;
+     int                    bestm_count = 0;
+     int                    bestm_size  = 0;
+     int                    min_toleration;
+     Chunk                 *chunk;
+     CoreGraphicsDevice    *device;
+     CoreSurfaceAllocation *smallest = NULL;
+
+     D_MAGIC_ASSERT( manager, SurfaceManager );
+     D_MAGIC_ASSERT( buffer, CoreSurfaceBuffer );
+     D_MAGIC_ASSERT( buffer->surface, CoreSurface );
+
+     D_DEBUG_AT( SurfMan, "%s( %p ) <- %dx%d %s\n", __FUNCTION__, buffer,
+                 buffer->surface->config.size.w, buffer->surface->config.size.h,
+                 dfb_pixelformat_name( buffer->surface->config.format ) );
+
+     /* FIXME: Only one global device at the moment. */
+     device = dfb_core_get_part( core, DFCP_GRAPHICS );
+     D_ASSERT( device != NULL );
+
+     dfb_gfxcard_calc_buffer_size( dfb_core_get_part( core, DFCP_GRAPHICS ), buffer, NULL, &length );
+
+     min_toleration = manager->min_toleration/8 + 2;
+
+     D_DEBUG_AT( SurfMan, "  -> %7d required, min toleration %d\n", length, min_toleration );
+
+     chunk = manager->chunks;
+     while (chunk) {
+          CoreSurfaceAllocation *allocation;
+
+          D_MAGIC_ASSERT( chunk, Chunk );
+
+          allocation = chunk->allocation;
+          if (allocation) {
+               CoreSurfaceBuffer *other;
+               int                size;
+
+               D_MAGIC_ASSERT( allocation, CoreSurfaceAllocation );
+               D_ASSERT( chunk->buffer == allocation->buffer );
+               D_ASSERT( chunk->length >= allocation->size );
+
+               other = allocation->buffer;
+               D_MAGIC_ASSERT( other, CoreSurfaceBuffer );
+
+               if (other->locked) {
+                    D_DEBUG_AT( SurfMan, "  ++ %7d locked %dx\n", allocation->size, other->locked );
+                    goto next_reset;
+               }
+
+               if (other->policy > buffer->policy) {
+                    D_DEBUG_AT( SurfMan, "  ++ %7d policy %d > %d\n", allocation->size, other->policy, buffer->policy );
+                    goto next_reset;
+               }
+
+               if (other->policy == CSP_VIDEOONLY) {
+                    D_DEBUG_AT( SurfMan, "  ++ %7d policy videoonly\n", allocation->size );
+                    goto next_reset;
+               }
+
+               chunk->tolerations++;
+               if (chunk->tolerations > 0xff)
+                    chunk->tolerations = 0xff;
+
+               if (other->policy == buffer->policy && chunk->tolerations < min_toleration) {
+                    D_DEBUG_AT( SurfMan, "  ++ %7d tolerations %d/%d\n",
+                                allocation->size, chunk->tolerations, min_toleration );
+                    goto next_reset;
+               }
+
+               size = allocation->size;
+
+               if (chunk->prev && !chunk->prev->allocation)
+                    size += chunk->prev->length;
+
+               if (chunk->next && !chunk->next->allocation)
+                    size += chunk->next->length;
+
+               if (size >= length) {
+                    if (!smallest || smallest->size > allocation->size) {
+                         D_DEBUG_AT( SurfMan, "  => %7d [%d] < %d, tolerations %d\n",
+                                     allocation->size, size, smallest ? smallest->size : 0, chunk->tolerations );
+
+                         smallest = allocation;
+                    }
+                    else
+                         D_DEBUG_AT( SurfMan, "  -> %7d [%d] > %d\n", allocation->size, size, smallest->size );
+               }
+               else
+                    D_DEBUG_AT( SurfMan, "  -> %7d [%d]\n", allocation->size, size );
+          }
+          else
+               D_DEBUG_AT( SurfMan, "  -  %7d free\n", chunk->length );
+
+
+          if (!smallest) {
+               if (!multi_start) {
+                    multi_start = chunk;
+                    multi_tsize = chunk->length;
+                    multi_size  = chunk->allocation ? chunk->length : 0;
+                    multi_count = chunk->allocation ? 1 : 0;
+               }
+               else {
+                    multi_tsize += chunk->length;
+                    multi_size  += chunk->allocation ? chunk->length : 0;
+                    multi_count += chunk->allocation ? 1 : 0;
+
+                    while (multi_tsize >= length && multi_count > 1) {
+                         if (!bestm_start || bestm_size > multi_size * multi_count / bestm_count) {
+                              D_DEBUG_AT( SurfMan, "                =====> %7d, %7d %2d used [%7d %2d]\n",
+                                          multi_tsize, multi_size, multi_count, bestm_size, bestm_count );
+
+                              bestm_size  = multi_size;
+                              bestm_start = multi_start;
+                              bestm_count = multi_count;
+                         }
+                         else
+                              D_DEBUG_AT( SurfMan, "                -----> %7d, %7d %2d used\n",
+                                          multi_tsize, multi_size, multi_count );
+
+                         if (multi_count <= 2)
+                              break;
+
+                         if (!multi_start->allocation) {
+                              multi_tsize -= multi_start->length;
+                              multi_start  = multi_start->next;
+                         }
+
+                         D_ASSUME( multi_start->allocation != NULL );
+
+                         multi_tsize -= multi_start->length;
+                         multi_size  -= multi_start->allocation ? multi_start->length : 0;
+                         multi_count -= multi_start->allocation ? 1 : 0;
+                         multi_start  = multi_start->next;
+                    }
+               }
+          }
+
+          chunk = chunk->next;
+
+          continue;
+
+
+next_reset:
+          multi_start = NULL;
+
+          chunk = chunk->next;
+     }
+
+     if (smallest) {
+          D_MAGIC_ASSERT( smallest, CoreSurfaceAllocation );
+          D_MAGIC_ASSERT( smallest->buffer, CoreSurfaceBuffer );
+
+          smallest->flags |= CSALF_MUCKOUT;
+
+          D_DEBUG_AT( SurfMan, "  -> offset %lu, size %d\n", smallest->offset, smallest->size );
+
+          return DFB_OK;
+     }
+
+     if (bestm_start) {
+          chunk = bestm_start;
+
+          while (bestm_count) {
+               CoreSurfaceAllocation *allocation = chunk->allocation;
+
+               if (allocation) {
+                    D_MAGIC_ASSERT( allocation, CoreSurfaceAllocation );
+                    D_MAGIC_ASSERT( allocation->buffer, CoreSurfaceBuffer );
+
+                    allocation->flags |= CSALF_MUCKOUT;
+
+                    bestm_count--;
+               }
+
+               D_DEBUG_AT( SurfMan, "  ---> offset %d, length %d\n", chunk->offset, chunk->length );
+
+               chunk = chunk->next;
+          }
+
+          return DFB_OK;
+     }
+
+     return DFB_NOVIDEOMEMORY;
+}
+
+DFBResult dfb_surfacemanager_deallocate( SurfaceManager *manager,
+                                         Chunk          *chunk )
+{
+     CoreSurfaceBuffer *buffer;
+
+     D_MAGIC_ASSERT( manager, SurfaceManager );
+     D_MAGIC_ASSERT( chunk, Chunk );
+
+     buffer = chunk->buffer;
+     D_MAGIC_ASSERT( buffer, CoreSurfaceBuffer );
+     D_MAGIC_ASSERT( buffer->surface, CoreSurface );
+
+     D_DEBUG_AT( SurfMan, "%s( %p ) <- %dx%d %s\n", __FUNCTION__, buffer,
+                 buffer->surface->config.size.w, buffer->surface->config.size.h,
+                 dfb_pixelformat_name( buffer->surface->config.format ) );
+
+     free_chunk( manager, chunk );
+
+     return DFB_OK;
+}
+
+/** internal functions NOT locking the surfacemanager **/
+
+static Chunk *
+split_chunk( SurfaceManager *manager, Chunk *c, int length )
+{
+     Chunk *newchunk;
+
+     D_MAGIC_ASSERT( c, Chunk );
+
+     if (c->length == length)          /* does not need be splitted */
+          return c;
+
+     newchunk = (Chunk*) SHCALLOC( manager->shmpool, 1, sizeof(Chunk) );
+     if (!newchunk) {
+          D_OOSHM();
+          return NULL;
+     }
+
+     /* calculate offsets and lengths of resulting chunks */
+     newchunk->offset = c->offset + c->length - length;
+     newchunk->length = length;
+     c->length -= newchunk->length;
+
+     /* insert newchunk after chunk c */
+     newchunk->prev = c;
+     newchunk->next = c->next;
+     if (c->next)
+          c->next->prev = newchunk;
+     c->next = newchunk;
+
+     D_MAGIC_SET( newchunk, Chunk );
+
+     return newchunk;
+}
+
+static Chunk *
+free_chunk( SurfaceManager *manager, Chunk *chunk )
+{
+     D_MAGIC_ASSERT( manager, SurfaceManager );
+     D_MAGIC_ASSERT( chunk, Chunk );
+
+     if (!chunk->buffer) {
+          D_BUG( "freeing free chunk" );
+          return chunk;
+     }
+
+     D_DEBUG_AT( SurfMan, "%s( %d bytes at offset %d )\n", __FUNCTION__, chunk->length, chunk->offset );
+
+     if (chunk->buffer->policy == CSP_VIDEOONLY)
+          manager->avail += chunk->length;
+
+     D_DEBUG_AT( SurfMan, "  -> freed %d, available %d\n", chunk->length, manager->avail );
+
+     chunk->allocation = NULL;
+     chunk->buffer     = NULL;
+
+     manager->min_toleration--;
+
+     if (chunk->prev  &&  !chunk->prev->buffer) {
+          Chunk *prev = chunk->prev;
+
+          //D_DEBUG_AT( SurfMan, "  -> merging with previous chunk at %d\n", prev->offset );
+
+          prev->length += chunk->length;
+
+          prev->next = chunk->next;
+          if (prev->next)
+               prev->next->prev = prev;
+
+          //D_DEBUG_AT( SurfMan, "  -> freeing %p (prev %p, next %p)\n", chunk, chunk->prev, chunk->next);
+
+          D_MAGIC_CLEAR( chunk );
+
+          SHFREE( manager->shmpool, chunk );
+          chunk = prev;
+     }
+
+     if (chunk->next  &&  !chunk->next->buffer) {
+          Chunk *next = chunk->next;
+
+          //D_DEBUG_AT( SurfMan, "  -> merging with next chunk at %d\n", next->offset );
+
+          chunk->length += next->length;
+
+          chunk->next = next->next;
+          if (chunk->next)
+               chunk->next->prev = chunk;
+
+          D_MAGIC_CLEAR( next );
+
+          SHFREE( manager->shmpool, next );
+     }
+
+     return chunk;
+}
+
+static Chunk *
+occupy_chunk( SurfaceManager *manager, Chunk *chunk, CoreSurfaceAllocation *allocation, int length, int pitch )
+{
+     D_MAGIC_ASSERT( manager, SurfaceManager );
+     D_MAGIC_ASSERT( chunk, Chunk );
+     D_MAGIC_ASSERT( allocation, CoreSurfaceAllocation );
+     D_MAGIC_ASSERT( allocation->buffer, CoreSurfaceBuffer );
+
+     if (allocation->buffer->policy == CSP_VIDEOONLY)
+          manager->avail -= length;
+
+     chunk = split_chunk( manager, chunk, length );
+     if (!chunk)
+          return NULL;
+
+     D_DEBUG_AT( SurfMan, "%s( %d bytes at offset %d )\n", __FUNCTION__, chunk->length, chunk->offset );
+
+     D_DEBUG_AT( SurfMan, "  -> occupied %d, available %d\n", chunk->length, manager->avail );
+
+     chunk->allocation = allocation;
+     chunk->buffer     = allocation->buffer;
+     chunk->pitch      = pitch;
+
+     manager->min_toleration++;
+
+     return chunk;
+}
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/gfxdrivers/stgfx2/surfacemanager.h DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/surfacemanager.h
--- DirectFB/gfxdrivers/stgfx2/surfacemanager.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/gfxdrivers/stgfx2/surfacemanager.h	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,110 @@
+/*
+   (c) Copyright 2001-2009  The world wide DirectFB Open Source Community (directfb.org)
+   (c) Copyright 2000-2004  Convergence (integrated media) GmbH
+
+   All rights reserved.
+
+   Written by Denis Oliver Kropp <dok@directfb.org>,
+              Andreas Hundt <andi@fischlustig.de>,
+              Sven Neumann <neo@directfb.org>,
+              Ville Syrjl <syrjala@sci.fi> and
+              Claudio Ciccani <klan@users.sf.net>.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#ifndef __SURFACEMANAGER_H__
+#define __SURFACEMANAGER_H__
+
+#include <directfb.h>
+
+#include <core/coretypes.h>
+
+typedef struct _SurfaceManager SurfaceManager;
+typedef struct _Chunk          Chunk;
+
+/*
+ * initially there is one big free chunk,
+ * chunks are splitted into a free and an occupied chunk if memory is allocated,
+ * two chunks are merged to one free chunk if memory is deallocated
+ */
+struct _Chunk {
+     int                  magic;
+
+     int                  offset;      /* offset in memory,
+                                          is greater or equal to the heap offset */
+     int                  length;      /* length of this chunk in bytes */
+
+     int                  pitch;
+     
+     CoreSurfaceBuffer   *buffer;      /* pointer to surface buffer occupying
+                                          this chunk, or NULL if chunk is free */
+     CoreSurfaceAllocation *allocation;
+
+     int                  tolerations; /* number of times this chunk was scanned
+                                          occupied, resetted in assure_video */
+
+     Chunk               *prev;
+     Chunk               *next;
+};
+
+struct _SurfaceManager {
+     int                  magic;
+
+     FusionSHMPoolShared *shmpool;
+
+     Chunk               *chunks;
+
+     int                  offset;
+     int                  length;         /* length of the heap in bytes */
+     int                  avail;          /* amount of available memory in bytes */
+
+     int                  min_toleration;
+     
+     bool                 suspended;
+};
+
+
+DFBResult dfb_surfacemanager_create ( CoreDFB             *core,
+                                      unsigned int         length,
+                                      SurfaceManager     **ret_manager );
+
+void      dfb_surfacemanager_destroy( SurfaceManager      *manager );
+
+/*
+ * finds and allocates one for the surface or fails,
+ * after success the video health is CSH_RESTORE.
+ * NOTE: this does not notify the listeners
+ */
+DFBResult dfb_surfacemanager_allocate( CoreDFB                *core,
+                                       SurfaceManager         *manager,
+                                       CoreSurfaceBuffer      *buffer,
+                                       CoreSurfaceAllocation  *allocation,
+                                       Chunk                 **ret_chunk );
+
+DFBResult dfb_surfacemanager_displace( CoreDFB           *core,
+                                       SurfaceManager    *manager,
+                                       CoreSurfaceBuffer *buffer );
+
+/*
+ * sets the video health to CSH_INVALID frees the chunk and
+ * notifies the listeners
+ */
+DFBResult dfb_surfacemanager_deallocate( SurfaceManager *manager,
+                                         Chunk          *chunk );
+
+#endif
+
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/include/directfb.h DirectFB-1.4.12+STM2011.09.27/include/directfb.h
--- DirectFB/include/directfb.h	2015-06-02 22:40:08.123540618 +0200
+++ DirectFB-1.4.12+STM2011.09.27/include/directfb.h	2012-06-06 18:41:31.000000000 +0200
@@ -760,6 +760,14 @@
      DSBLIT_SOURCE2            = 0x00400000, /* use secondary source instead of destination for reading */
      DSBLIT_FLIP_HORIZONTAL    = 0x01000000, /* flip the image horizontally */
      DSBLIT_FLIP_VERTICAL      = 0x02000000, /* flip the image vertically */
+#define DFB_FIXED_POINT_ONE            (1 << 16)                   /* 1 in 16.16 format */
+#define DFB_FIXED_POINT_HALF           (DFB_FIXED_POINT_ONE / 2)   /* 1/2 in 16.16 format */
+#define DFB_FIXED_POINT_FRACTION_MASK  (DFB_FIXED_POINT_ONE - 1)
+#define DFB_FIXED_POINT_VAL(x)         ((x) << 16) /* convert x to fixed point */
+#define DFB_FIXED_POINT_TO_INT(x)      ((x) >> 16) /* convert fixed point to int */
+     DSBLIT_FIXEDPOINT         = 0x00800000, /* use subpixel precision, i.e.
+                                                all x/y/w/h coordinates are in
+                                                fixed point 16.16 format */
 } DFBSurfaceBlittingFlags;
 
 /*
@@ -1617,9 +1625,13 @@
 typedef enum {
      DVPLAY_NOFX        = 0x00000000, /* normal playback           */
      DVPLAY_REWIND      = 0x00000001, /* reverse playback          */
-     DVPLAY_LOOPING     = 0x00000002  /* automatically restart
+     DVPLAY_LOOPING     = 0x00000002, /* automatically restart
                                          playback when end-of-stream
                                          is reached (gapless).     */
+     DVPLAY_PACED       = 0x00000004  /* decoding pace is controlled
+                                         by the caller, the decoder
+                                         won't wait on its own while
+                                         decoding frames. */
 } DFBVideoProviderPlaybackFlags;
 
 /*
@@ -4253,6 +4265,22 @@
           const DFBTrapezoid       *traps,
           unsigned int              num
      );
+
+   /** Blitting functions **/
+
+     /*
+      * Blit a bunch of areas scaled from the source to the destination
+      * rectangles.
+      *
+      * <b>source_rects</b> and <b>dest_rects</b> will be modified!
+      */
+     DFBResult (*BatchStretchBlit) (
+          IDirectFBSurface         *thiz,
+          IDirectFBSurface         *source,
+          DFBRectangle             *source_rects,
+          DFBRectangle             *dest_rects,
+          int                       num
+     );
 )
 
 
@@ -6013,6 +6041,19 @@
 )
 
 /*
+ * Flags for image providers.
+ */
+typedef enum {
+    DIPFLAGS_NONE,
+    DIPFLAGS_BACKGROUND_DECODE
+} DFBImageProviderFlags;
+
+typedef enum {
+    DIPSYNCFLAGS_SYNC, /* sync, i.e. wait for the image provider to finish */
+    DIPSYNCFLAGS_TRYSYNC /* figure out if image provider is finished or still busy */
+} DFBImageProviderSyncFlags;
+
+/*
  * Capabilities of an image.
  */
 typedef enum {
@@ -6109,6 +6150,10 @@
       * Registers a callback for progressive image loading.
       *
       * The function is called each time a chunk of the image is decoded.
+      *
+      * In case of an image provider working in the background, the
+      * callback could be called in a different thread context! So you
+      * might have to take appropriate actions to handle this.
       */
      DFBResult (*SetRenderCallback) (
           IDirectFBImageProvider   *thiz,
@@ -6128,6 +6173,57 @@
           const DFBRectangle       *src_rect,
           const char               *filename
      );
+
+
+   /** Set Flags **/
+
+     /*
+      * Set image provider flags.
+      *
+      * This allows one to switch an image provider's mode of
+      * operation, between default and background.
+      *
+      * In default (which is also the traditional) mode, a call to
+      * RenderTo() will block until the image provider has finished
+      * decoding the image. This is also the behaviour if this API
+      * is not used at all.
+      *
+      * In background mode, the image is being decoded in the background,
+      * i.e. the call to RenderTo() will return almost immediately. The
+      * application may do other useful processing while the image is being
+      * decoded. In most implementations, background decode will just use
+      * a worker thread.
+      *
+      * Not all image providers support background mode and will return
+      * DFB_UNSUPPORTED in that case.
+      *
+      * Calling SetFlags() after RenderTo() makes no sense and is
+      * unsupported.
+      *
+      */
+     DFBResult (*SetFlags) (
+          IDirectFBImageProvider *thiz,
+          DFBImageProviderFlags   flags
+     );
+
+
+   /** Rendering **/
+
+     /*
+      * For a background image provider, waits for it to finish
+      * decoding the image.
+      *
+      * For a default image provider, does nothing.
+      *
+      * This needs to be called for background image providers
+      * before accessing the destination surface (using either the
+      * software or the hardware), to make sure that the image has been
+      * completely decoded.
+      */
+     DFBResult (*Sync) (
+          IDirectFBImageProvider    *thiz,
+          DFBImageProviderSyncFlags  flags
+     );
 )
 
 /*
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/include/directfb_util.h DirectFB-1.4.12+STM2011.09.27/include/directfb_util.h
--- DirectFB/include/directfb_util.h	2015-06-02 22:40:08.127541120 +0200
+++ DirectFB-1.4.12+STM2011.09.27/include/directfb_util.h	2012-06-06 18:41:31.000000000 +0200
@@ -88,8 +88,11 @@
           }                                  \
      } while (0)
 
+#define DFB_INT_VALf(x)                      (x) >> 16, (int) (((((long long) x) & 0xffff) * 1000000) / DFB_FIXED_POINT_ONE)
 #define DFB_RECTANGLE_VALS(r)                (r)->x, (r)->y, (r)->w, (r)->h
+#define DFB_RECTANGLE_VALSf(r)               DFB_INT_VALf((r)->x), DFB_INT_VALf((r)->y), DFB_INT_VALf((r)->w), DFB_INT_VALf((r)->h)
 #define DFB_RECTANGLE_VALS_FROM_REGION(r)    (r)->x1, (r)->y1, (r)->x2-(r)->x1+1, (r)->y2-(r)->y1+1
+#define DFB_RECTANGLE_VALSf_FROM_REGION(r)   DFB_INT_VALf((r)->x1), DFB_INT_VALf((r)->y1), DFB_INT_VALf((r)->x2-(r)->x1+DFB_FIXED_POINT_ONE), DFB_INT_VALf((r)->y2-(r)->y1+DFB_FIXED_POINT_ONE)
 #define DFB_RECTANGLE_INIT_FROM_REGION(r)    (DFBRectangle){ DFB_RECTANGLE_VALS_FROM_REGION(r) }
 #define DFB_RECTANGLE_CONTAINS_POINT(r,X,Y)  (((X) >= (r)->x) && ((X) < (r)->x + (r)->w) && \
                                               ((Y) >= (r)->y) && ((Y) < (r)->y + (r)->h))
@@ -134,6 +137,7 @@
 
 
 #define DFB_REGION_VALS(r)                   (r)->x1, (r)->y1, (r)->x2, (r)->y2
+#define DFB_REGION_VALSf(r)                  DFB_INT_VALf((r)->x1), DFB_INT_VALf((r)->y1), DFB_INT_VALf((r)->x2), DFB_INT_VALf((r)->y2)
 
 #define DFB_REGION_VALS_FROM_DIMENSION(d)    0, 0, (d)->w-1, (d)->h-1
 #define DFB_REGION_INIT_FROM_DIMENSION(d)    (DFBRegion){ DFB_REGION_VALS_FROM_DIMENSION(d) }
@@ -396,6 +400,82 @@
                                  int             *y );
 
 
+static inline void dfb_rectangle_upscale( DFBRectangle *rect )
+{
+     rect->x *= DFB_FIXED_POINT_ONE;
+     rect->y *= DFB_FIXED_POINT_ONE;
+     rect->w *= DFB_FIXED_POINT_ONE;
+     rect->h *= DFB_FIXED_POINT_ONE;
+}
+
+static inline void dfb_rectangle_downscale( DFBRectangle *rect )
+{
+     rect->x /= DFB_FIXED_POINT_ONE;
+     rect->y /= DFB_FIXED_POINT_ONE;
+     rect->w /= DFB_FIXED_POINT_ONE;
+     rect->h /= DFB_FIXED_POINT_ONE;
+}
+
+static inline void dfb_region_upscale( DFBRegion *region )
+{
+     region->x1 *= DFB_FIXED_POINT_ONE;
+     region->y1 *= DFB_FIXED_POINT_ONE;
+     region->x2 *= DFB_FIXED_POINT_ONE;
+     region->y2 *= DFB_FIXED_POINT_ONE;
+}
+
+static inline void dfb_region_downscale( DFBRegion *region )
+{
+     region->x1 /= DFB_FIXED_POINT_ONE;
+     region->y1 /= DFB_FIXED_POINT_ONE;
+     region->x2 /= DFB_FIXED_POINT_ONE;
+     region->y2 /= DFB_FIXED_POINT_ONE;
+}
+
+static inline void dfb_triangle_upscale( DFBTriangle *tri )
+{
+     tri->x1 *= DFB_FIXED_POINT_ONE;
+     tri->y1 *= DFB_FIXED_POINT_ONE;
+     tri->x2 *= DFB_FIXED_POINT_ONE;
+     tri->y2 *= DFB_FIXED_POINT_ONE;
+     tri->x3 *= DFB_FIXED_POINT_ONE;
+     tri->y3 *= DFB_FIXED_POINT_ONE;
+}
+
+static inline void dfb_triangle_downscale( DFBTriangle *tri )
+{
+     tri->x1 /= DFB_FIXED_POINT_ONE;
+     tri->y1 /= DFB_FIXED_POINT_ONE;
+     tri->x2 /= DFB_FIXED_POINT_ONE;
+     tri->y2 /= DFB_FIXED_POINT_ONE;
+     tri->x3 /= DFB_FIXED_POINT_ONE;
+     tri->y3 /= DFB_FIXED_POINT_ONE;
+}
+
+static inline void dfb_point_upscale( DFBPoint *point )
+{
+     point->x *= DFB_FIXED_POINT_ONE;
+     point->y *= DFB_FIXED_POINT_ONE;
+}
+
+static inline void dfb_point_downscale( DFBPoint *point )
+{
+     point->x /= DFB_FIXED_POINT_ONE;
+     point->y /= DFB_FIXED_POINT_ONE;
+}
+
+static inline void dfb_dimension_upscale( DFBDimension *dim )
+{
+     dim->w *= DFB_FIXED_POINT_ONE;
+     dim->h *= DFB_FIXED_POINT_ONE;
+}
+
+static inline void dfb_dimension_downscale( DFBDimension *dim )
+{
+     dim->w /= DFB_FIXED_POINT_ONE;
+     dim->h /= DFB_FIXED_POINT_ONE;
+}
+
 /*
  * Copied declaration of DFBPixelFormatName from directfb_strings.h
  */
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/inputdrivers/linux_input/linux_input.c DirectFB-1.4.12+STM2011.09.27/inputdrivers/linux_input/linux_input.c
--- DirectFB/inputdrivers/linux_input/linux_input.c	2015-06-02 22:40:08.127541120 +0200
+++ DirectFB-1.4.12+STM2011.09.27/inputdrivers/linux_input/linux_input.c	2012-06-06 18:41:31.000000000 +0200
@@ -113,6 +113,9 @@
 #ifdef LINUX_INPUT_USE_FBDEV
 #include <fbdev/fbdev.h>
 #endif
+#ifdef LINUX_INPUT_USE_STMFBDEV
+#include <stmfbdev/stmfbdev.h>
+#endif
 
 #include <core/input_driver.h>
 
@@ -1219,11 +1222,17 @@
      int   i;
      char *tsdev;
 
-#ifdef LINUX_INPUT_USE_FBDEV
-     if (dfb_system_type() != CORE_FBDEV)
+#if defined(LINUX_INPUT_USE_FBDEV) && defined(LINUX_INPUT_USE_STMFBDEV)
+     if (dfb_system_type() != CORE_FBDEV
+         && dfb_system_type() != CORE_STMFBDEV)
           return 0;
+#endif
+#if defined(LINUX_INPUT_USE_FBDEV)
+     if (dfb_system_type() != CORE_FBDEV)
+          goto next1;
 
-     FBDev *dfb_fbdev = (FBDev*) dfb_system_data();
+     {
+     const FBDev * const dfb_fbdev = (FBDev*) dfb_system_data();
      D_ASSERT( dfb_fbdev );
 
      // Only allow USB keyboard and mouse support if the systems driver has
@@ -1231,8 +1240,29 @@
      // FIXME:  Additional logic needed for system drivers not similar to fbdev?
      if (!dfb_fbdev->vt || dfb_fbdev->vt->fd < 0)
           return 0;
+     }
+     goto success;
 #endif
+next1:
+#if defined(LINUX_INPUT_USE_STMFBDEV)
+     if (dfb_system_type() != CORE_STMFBDEV)
+          goto next2;
+
+     {
+     const STMfbdev * const stmfb_dev = dfb_system_data();
+     D_ASSERT( stmfb_dev );
 
+     // Only allow USB keyboard and mouse support if the systems driver has
+     // the Virtual Terminal file ("/dev/tty0") open and available for use.
+     if (!stmfb_dev->vt || stmfb_dev->vt->fd < 0)
+          return 0;
+     }
+     goto success;
+#endif
+next2:
+     return 0;
+
+success:
      /* Use the devices specified in the configuration. */
      if (fusion_vector_has_elements( &dfb_config->linux_input_devices )) {
           const char *device;
@@ -1437,12 +1467,11 @@
      InputDriverCapability   capabilities = IDC_NONE;
 
 #ifdef LINUX_INPUT_USE_FBDEV
-     FBDev *dfb_fbdev;
-
      if (dfb_system_type() != CORE_FBDEV)
-          return 0;
+          goto next1;
 
-     dfb_fbdev = (FBDev*) dfb_system_data();
+     {
+     const FBDev * const dfb_fbdev = (FBDev*) dfb_system_data();
      D_ASSERT( dfb_fbdev );
 
      // Only allow USB keyboard and mouse support if the systems driver has
@@ -1450,7 +1479,32 @@
      // FIXME:  Additional logic needed for system drivers not similar to fbdev?
      if (!dfb_fbdev->vt || dfb_fbdev->vt->fd < 0)
           goto exit;
+     }
+     goto success;
 #endif
+next1:
+#ifdef LINUX_INPUT_USE_STMFBDEV
+     if (dfb_system_type() != CORE_STMFBDEV)
+          goto next2;
+
+     {
+     const STMfbdev * const stmfb_dev = dfb_system_data();
+     D_ASSERT( stmfb_dev );
+
+     // Only allow USB keyboard and mouse support if the systems driver has
+     // the Virtual Terminal file ("/dev/tty0") open and available for use.
+     // FIXME:  Additional logic needed for system drivers not similar to fbdev?
+     if (!stmfb_dev->vt || stmfb_dev->vt->fd < 0)
+          goto exit;
+     }
+     goto success;
+#endif
+next2:
+#if defined(LINUX_INPUT_USE_FBDEV) || defined(LINUX_INPUT_USE_STMFBDEV)
+     goto exit;
+#endif
+
+success:
 
      capabilities |= IDC_HOTPLUG;
 
@@ -1788,11 +1842,21 @@
       data->index = number;
 
      if (info->desc.min_keycode >= 0 && info->desc.max_keycode >= info->desc.min_keycode) {
-#ifdef LINUX_INPUT_USE_FBDEV
-          FBDev *dfb_fbdev = dfb_system_data();
+#if defined(LINUX_INPUT_USE_FBDEV)
+          if (dfb_system_type() == CORE_FBDEV) {
+               const FBDev * const dfb_fbdev = dfb_system_data();
 
-          if (dfb_fbdev->vt)
-               data->vt_fd = dup( dfb_fbdev->vt->fd );
+               if (dfb_fbdev->vt)
+                    data->vt_fd = dup( dfb_fbdev->vt->fd );
+          }
+#endif
+#if defined(LINUX_INPUT_USE_STMFBDEV)
+          if (dfb_system_type() == CORE_STMFBDEV) {
+               const STMfbdev * const stmfb_dev = dfb_system_data();
+
+               if (stmfb_dev->vt)
+                    data->vt_fd = dup( stmfb_dev->vt->fd );
+          }
 #endif
           if (data->vt_fd < 0)
                data->vt_fd = open( "/dev/tty0", O_RDWR | O_NOCTTY );
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/inputdrivers/lirc/lirc.c DirectFB-1.4.12+STM2011.09.27/inputdrivers/lirc/lirc.c
--- DirectFB/inputdrivers/lirc/lirc.c	2015-06-02 22:40:08.127541120 +0200
+++ DirectFB-1.4.12+STM2011.09.27/inputdrivers/lirc/lirc.c	2012-06-06 18:41:31.000000000 +0200
@@ -242,8 +242,15 @@
           return 0;
 
      if (connect( fd, (struct sockaddr*)&addr, sizeof(addr) ) < 0) {
-          close( fd );
-          return 0;
+          /*
+           *  for LIRC version >= 0.8.6 the Unix socket is no more created
+           *  under /dev/lircd but under /var/run/lirc/lircd
+           */
+          direct_snputs( addr.sun_path, "/var/run/lirc/lircd", sizeof(addr.sun_path) );
+          if (connect( fd, (struct sockaddr*)&addr, sizeof(addr) ) < 0) {
+               close( fd );
+               return 0;
+          }
      }
 
      close( fd );
@@ -287,9 +294,16 @@
 
      /* initiate connection */
      if (connect( fd, (struct sockaddr*)&sa, sizeof(sa) ) < 0) {
-          D_PERROR( "DirectFB/LIRC: connect" );
-          close( fd );
-          return DFB_INIT;
+          /*
+           * try "/var/run/lirc/lircd"
+           */
+          direct_snputs( sa.sun_path, "/var/run/lirc/lircd", sizeof(sa.sun_path) );
+
+          if (connect( fd, (struct sockaddr*)&sa, sizeof(sa) ) < 0) {
+               D_PERROR( "DirectFB/LIRC: connect" );
+               close( fd );
+               return DFB_INIT;
+          }
      }
 
      /* fill driver info structure */
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/interfaces/IDirectFBFont/Makefile.am DirectFB-1.4.12+STM2011.09.27/interfaces/IDirectFBFont/Makefile.am
--- DirectFB/interfaces/IDirectFBFont/Makefile.am	2015-06-02 22:40:08.131541622 +0200
+++ DirectFB-1.4.12+STM2011.09.27/interfaces/IDirectFBFont/Makefile.am	2012-06-06 18:41:31.000000000 +0200
@@ -49,7 +49,8 @@
 libidirectfbfont_ft2_la_LIBADD = \
 	$(top_builddir)/lib/direct/libdirect.la \
 	$(top_builddir)/src/libdirectfb.la \
-	$(FREETYPE_LIBS)
+	$(FREETYPE_LIBS) \
+	$(LIBM)
 
 libidirectfbfont_ft2_la_LDFLAGS = -avoid-version -module
 
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/interfaces/IDirectFBImageProvider/debug_helper.h DirectFB-1.4.12+STM2011.09.27/interfaces/IDirectFBImageProvider/debug_helper.h
--- DirectFB/interfaces/IDirectFBImageProvider/debug_helper.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/interfaces/IDirectFBImageProvider/debug_helper.h	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,53 @@
+#ifndef __DEBUG_HELPER_H__
+#define __DEBUG_HELPER_H__
+
+
+/* Some colour for debug */
+#define BLACK   "\033[22;30m"
+#define RED     "\033[22;31m"
+#define GREEN   "\033[22;32m"
+#define BROWN   "\033[22;33m"
+
+
+
+/* These messages should be provided through DirectFB's error and warning */
+#define DEBUG_ERROR(x)          D_ERROR x
+#define DEBUG_WARNING(x)        D_WARN x
+
+
+#ifdef DEBUG
+/* *Very* Verbose */
+#  define DEBUG_INFO(x)           D_PRINTF x
+/* Outputs various Buffer and surface sizes */
+#  define DEBUG_SCALE(x)          D_PRINTF x
+/* Outputs Timing Information */
+#  define DEBUG_PERFORMANCE(x)    D_PRINTF x
+
+#else
+
+#  define DEBUG_INFO(x)   __debug_msg x
+#  define DEBUG_SCALE(x)  __debug_msg x
+static inline int __attribute__ ((format (printf, 1, 2)))
+__debug_msg (const char *format, ...)
+{
+  return 0;
+}
+
+#endif
+
+
+#ifdef DIRECT_BUILD_DEBUG
+
+#  define deb_gettimeofday(tv,tz)  gettimeofday(tv, tz)
+#  define deb_timersub(a,b,res)    timersub(a, b, res)
+
+#else
+
+#  define deb_gettimeofday(tv,tz)  ( { } )
+#  define deb_timersub(a,b,res)    ( { } )
+
+#endif
+
+
+
+#endif /* __DEBUG_HELPER_H__ */
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/interfaces/IDirectFBImageProvider/idirectfbimageprovider_jpeg.c DirectFB-1.4.12+STM2011.09.27/interfaces/IDirectFBImageProvider/idirectfbimageprovider_jpeg.c
--- DirectFB/interfaces/IDirectFBImageProvider/idirectfbimageprovider_jpeg.c	2015-06-02 22:40:08.131541622 +0200
+++ DirectFB-1.4.12+STM2011.09.27/interfaces/IDirectFBImageProvider/idirectfbimageprovider_jpeg.c	2012-06-06 18:41:31.000000000 +0200
@@ -1,4 +1,7 @@
 /*
+   (c) Copyright 2006-2010  ST Microelectronics R&D
+
+based on code:
    (c) Copyright 2001-2010  The world wide DirectFB Open Source Community (directfb.org)
    (c) Copyright 2000-2004  Convergence (integrated media) GmbH
 
@@ -52,6 +55,7 @@
 #include <direct/interface.h>
 #include <direct/mem.h>
 #include <direct/memcpy.h>
+#include <direct/thread.h>
 #include <direct/messages.h>
 
 #include <setjmp.h>
@@ -60,6 +64,36 @@
 #undef HAVE_STDLIB_H
 #include <jpeglib.h>
 
+#if !defined(JPEG_PROVIDER_USE_MME)
+#undef USE_MME
+#endif
+
+
+#include "debug_helper.h"
+
+D_DEBUG_DOMAIN (JPEG,      "JPEG",      "STM JPEG decoder");
+D_DEBUG_DOMAIN (JPEG_RAW,  "JPEG/raw",  "STM JPEG decoder (raw decode)");
+D_DEBUG_DOMAIN (JPEG_MME,  "JPEG/MME",  "STM JPEG decoder (MME)");
+D_DEBUG_DOMAIN (JPEG_SEMA, "JPEG/SEMA", "STM JPEG decoder (semaphores");
+D_DEBUG_DOMAIN (JPEG_TIME, "JPEG/Time", "STM JPEG decoder (timing");
+#define MME_DEBUG_DOMAIN  JPEG_MME
+#define SEMA_DEBUG_DOMAIN JPEG_SEMA
+#define MME_TEXT_DOMAIN "JPEG"
+
+#include "mme_helper.h"
+#include "idirectfbimageprovider_jpeg.h"
+#if defined(JPEG_PROVIDER_USE_MME)
+#include "sema_helper.h"
+static DFBResult JPEG_HardwareRenderTo( IDirectFBImageProvider_JPEG_data *data,
+                                        CoreSurface                      *dst_surface,
+                                        DFBSurfacePixelFormat             format,
+                                        DFBRectangle                     *rect,
+                                        const DFBRegion                  *clip );
+#else /* JPEG_PROVIDER_USE_MME */
+#define JPEG_HardwareRenderTo(data,dst_surface, \
+                              format,rect,clip) DFB_NOSUCHINSTANCE
+#endif /* JPEG_PROVIDER_USE_MME */
+
 
 static DFBResult
 Probe( IDirectFBImageProvider_ProbeContext *ctx );
@@ -70,22 +104,16 @@
 
 #include <direct/interface_implementation.h>
 
-DIRECT_INTERFACE_IMPLEMENTATION( IDirectFBImageProvider, JPEG )
-
-/*
- * private data struct of IDirectFBImageProvider_JPEG
- */
-typedef struct {
-     IDirectFBImageProvider_data base;
-
-     int                  width;    /*  width of the JPEG image   */
-     int                  height;   /*  height of the JPEG image  */
+#if defined(JPEG_PROVIDER_USE_MME)
+DIRECT_INTERFACE_IMPLEMENTATION( IDirectFBImageProvider, hwJPEG )
+#else /* JPEG_PROVIDER_USE_MME */
+DIRECT_INTERFACE_IMPLEMENTATION( IDirectFBImageProvider, swJPEG )
+#endif /* JPEG_PROVIDER_USE_MME */
 
-     u32                 *image;        /*  decoded image data    */
-     int                  image_width;  /*  width of image data   */
-     int                  image_height; /*  height of image data  */
-} IDirectFBImageProvider_JPEG_data;
 
+static DFBResult
+IDirectFBImageProvider_JPEG_SetFlags ( IDirectFBImageProvider *thiz,
+                                       DFBImageProviderFlags   flags );
 
 static DFBResult
 IDirectFBImageProvider_JPEG_RenderTo( IDirectFBImageProvider *thiz,
@@ -93,6 +121,10 @@
                                       const DFBRectangle     *destination_rect );
 
 static DFBResult
+IDirectFBImageProvider_JPEG_Sync( IDirectFBImageProvider    *thiz,
+                                  DFBImageProviderSyncFlags  flags );
+
+static DFBResult
 IDirectFBImageProvider_JPEG_GetSurfaceDescription( IDirectFBImageProvider *thiz,
                                                    DFBSurfaceDescription  *dsc);
 
@@ -100,6 +132,9 @@
 IDirectFBImageProvider_JPEG_GetImageDescription( IDirectFBImageProvider *thiz,
                                                  DFBImageDescription    *dsc );
 
+static void *
+JPEGrenderThread( DirectThread *thread, void *driver_data );
+
 
 #define JPEG_PROG_BUF_SIZE    0x10000
 
@@ -143,7 +178,7 @@
      else {
           ret = buffer->GetData( buffer, JPEG_PROG_BUF_SIZE, src->data, &nbytes );
      }
-     
+
      if (ret || nbytes <= 0) {
           /* Insert a fake EOI marker */
           src->data[0] = (JOCTET) 0xFF;
@@ -271,8 +306,23 @@
      IDirectFBImageProvider_JPEG_data *data =
                               (IDirectFBImageProvider_JPEG_data*)thiz->priv;
 
-     if (data->image)
-          D_FREE( data->image );
+     if (data->thread) {
+          /* terminate the decoding thread, if necessary... */
+          direct_thread_cancel( data->thread );
+          direct_thread_join( data->thread );
+          direct_thread_destroy( data->thread );
+
+          pthread_mutex_destroy( &data->lock );
+          pthread_cond_destroy( &data->cond );
+     }
+
+     if (data->common.image)
+          D_FREE( data->common.image );
+
+     if (data->common.decode_surface) {
+          dfb_gfxcard_wait_serial( &data->common.serial );
+          dfb_surface_unref( data->common.decode_surface );
+     }
 }
 
 static DFBResult
@@ -298,7 +348,7 @@
 {
      struct jpeg_decompress_struct cinfo;
      struct my_error_mgr jerr;
-     
+
      IDirectFBDataBuffer *buffer;
      CoreDFB             *core;
      va_list              tag;
@@ -310,9 +360,9 @@
      core = va_arg( tag, CoreDFB * );
      va_end( tag );
 
-     data->base.ref    = 1;
-     data->base.buffer = buffer;
-     data->base.core   = core;
+     data->common.base.ref    = 1;
+     data->common.base.buffer = buffer;
+     data->common.base.core   = core;
 
      buffer->AddRef( buffer );
 
@@ -332,16 +382,23 @@
      jpeg_buffer_src(&cinfo, buffer, 1);
      jpeg_read_header(&cinfo, TRUE);
      jpeg_start_decompress(&cinfo);
-     
-     data->width = cinfo.output_width;
-     data->height = cinfo.output_height;
-     
+
+     data->common.width = cinfo.output_width;
+     data->common.height = cinfo.output_height;
+
+#if defined(JPEG_PROVIDER_USE_MME)
+     data->num_components = cinfo.num_components;
+     data->progressive_mode = cinfo.progressive_mode;
+#endif
+
      jpeg_abort_decompress(&cinfo);
      jpeg_destroy_decompress(&cinfo);
 
-     data->base.Destruct = IDirectFBImageProvider_JPEG_Destruct;
+     data->common.base.Destruct = IDirectFBImageProvider_JPEG_Destruct;
 
+     thiz->SetFlags = IDirectFBImageProvider_JPEG_SetFlags;
      thiz->RenderTo = IDirectFBImageProvider_JPEG_RenderTo;
+     thiz->Sync = IDirectFBImageProvider_JPEG_Sync;
      thiz->GetImageDescription =IDirectFBImageProvider_JPEG_GetImageDescription;
      thiz->GetSurfaceDescription =
      IDirectFBImageProvider_JPEG_GetSurfaceDescription;
@@ -350,65 +407,483 @@
 }
 
 static DFBResult
-IDirectFBImageProvider_JPEG_RenderTo( IDirectFBImageProvider *thiz,
-                                      IDirectFBSurface       *destination,
-                                      const DFBRectangle     *dest_rect )
+IDirectFBImageProvider_JPEG_SetFlags( IDirectFBImageProvider *thiz,
+                                      DFBImageProviderFlags   flags )
 {
-     DFBResult              ret;
-     bool                   direct = false;
-     DFBRegion              clip;
-     DFBRectangle           rect;
-     DFBSurfacePixelFormat  format;
-     IDirectFBSurface_data *dst_data;
-     CoreSurface           *dst_surface;
-     CoreSurfaceBufferLock  lock;
-     DIRenderCallbackResult cb_result = DIRCR_OK;
-
      DIRECT_INTERFACE_GET_DATA(IDirectFBImageProvider_JPEG)
 
-     dst_data = (IDirectFBSurface_data*) destination->priv;
-     if (!dst_data)
-          return DFB_DEAD;
+     /* if we have decoded the image already, don't do anything... */
+     if (data->common.image
+         || data->common.decode_surface
+        )
+          return DFB_UNSUPPORTED;
+
+     if (flags == DIPFLAGS_NONE && data->thread) {
+          /* terminate the decoding thread, if necessary... */
+          direct_thread_cancel( data->thread );
+          direct_thread_join( data->thread );
+          direct_thread_destroy( data->thread );
+          data->thread = NULL;
 
-     dst_surface = dst_data->surface;
-     if (!dst_surface)
-          return DFB_DESTROYED;
+          pthread_cond_destroy( &data->cond );
+          pthread_mutex_destroy( &data->lock );
+     }
+     else if (flags == DIPFLAGS_BACKGROUND_DECODE && !data->thread) {
+          /* or create it */
+          pthread_cond_init( &data->cond, NULL );
+          pthread_mutex_init( &data->lock, NULL );
+          /* as long as we haven't even started yet, we are in INIT state */
+          data->thread_res = DFB_INIT;
+          data->thread = direct_thread_create( DTT_DEFAULT, JPEGrenderThread,
+                                               thiz, "JPEG_DECODER?" );
+     }
+     data->flags = flags;
 
-     ret = destination->GetPixelFormat( destination, &format );
-     if (ret)
-          return ret;
+     return DFB_OK;
+}
 
-     dfb_region_from_rectangle( &clip, &dst_data->area.current );
+static void
+JPEG_stretchblit (IDirectFBImageProvider_JPEG_data *data,
+                  CardState                        *state,
+                  DFBRectangle                     *src_rect,
+                  DFBRectangle                     *dst_rect)
+{
+  D_DEBUG_AT (JPEG, "StretchBlit %dx%d -> %dx%d (%s -> %s)\n",
+              src_rect->w, src_rect->h, dst_rect->w, dst_rect->h,
+              dfb_pixelformat_name (state->source->config.format),
+              dfb_pixelformat_name (state->destination->config.format));
+
+  /* thankfully this is intelligent enough to do a simple blit if possible */
+  dfb_gfxcard_stretchblit (src_rect, dst_rect, state);
+  /* we need to remember the serial in case a new surface is created
+     (and written to) at the same address as the decode_surface before the
+     blit operation is finihsed. This can happen if we get into the destructor
+     before the blit operation is finished, which can happen on fast CPUs. */
+  data->common.serial = state->serial;
+}
 
-     if (dest_rect) {
-          if (dest_rect->w < 1 || dest_rect->h < 1)
-               return DFB_INVARG;
-          
-          rect = *dest_rect;
-          rect.x += dst_data->area.wanted.x;
-          rect.y += dst_data->area.wanted.y;
+#define _ROUND_UP_8(x)  (((x)+ 7) & ~ 7)
+#define _ROUND_UP_16(x) (((x)+15) & ~15)
+static void
+JPEG_setup_yuv444p( const struct jpeg_decompress_struct *cinfo,
+                    CoreSurfaceConfig                   *config,
+                    int                                 *pitch_y,
+                    int                                 *pitch_cb,
+                    int                                 *pitch_cr,
+                    int                                 *offset_cb,
+                    int                                 *offset_cr )
+{
+     config->format = DSPF_YUV444P;
 
-          if (!dfb_rectangle_region_intersects( &rect, &clip ))
-               return DFB_OK;
+     config->size.w = _ROUND_UP_8 (cinfo->cur_comp_info[0]
+                                                      ->downsampled_width);
+     config->size.h = _ROUND_UP_8 (cinfo->cur_comp_info[0]
+                                                     ->downsampled_height);
+
+     /* pad an extra (decimated) MCU row for the iDCT write-out as required by libjpeg */
+#if JPEG_LIB_VERSION >= 70
+     config->size.h += cinfo->max_v_samp_factor * cinfo->min_DCT_v_scaled_size;
+#else
+     config->size.h += cinfo->max_v_samp_factor * cinfo->min_DCT_scaled_size;
+#endif
+
+     *pitch_y  = config->size.w;
+     *pitch_cb = _ROUND_UP_8 (cinfo->cur_comp_info[1]->downsampled_width);
+     *pitch_cr = _ROUND_UP_8 (cinfo->cur_comp_info[2]->downsampled_width);
+
+     *offset_cb
+          = *offset_cr
+          = *pitch_y * config->size.h;
+}
+
+static DFBResult
+JPEG_raw_decode( IDirectFBImageProvider_JPEG_data *data,
+                 CoreSurface                      *dst_surface,
+                 DFBRectangle                     *rect,
+                 struct jpeg_decompress_struct    *cinfo,
+                 CardState                        *state,
+                 CoreSurfaceBufferLock            *lock )
+{
+     /* can we do a raw decode? */
+     if (cinfo->num_components != 3
+         || cinfo->jpeg_color_space != JCS_YCbCr
+         || cinfo->data_precision != 8)
+          return DFB_UNSUPPORTED;
+
+     CoreSurfaceConfig config;
+     int pitch_y, pitch_cb, pitch_cr;
+     int offset_cb; /* cb from y */
+     int offset_cr; /* cr from cb */
+     int y_v_sampl = 1;
+     int cb_v_sampl = 1;
+     int cr_v_sampl = 1;
+
+     const int v_samp[3] = { cinfo->cur_comp_info[0]->v_samp_factor,
+                             cinfo->cur_comp_info[1]->v_samp_factor,
+                             cinfo->cur_comp_info[2]->v_samp_factor };
+
+#if JPEG_LIB_VERSION >= 70
+     int idct_window_size = cinfo->max_v_samp_factor * cinfo->min_DCT_v_scaled_size;
+#else
+     int idct_window_size = cinfo->max_v_samp_factor * cinfo->min_DCT_scaled_size;
+#endif
+
+     /* Worst case, is 4x4 chroma subsampling where an MCU is 32 lines. libjpeg
+        won't decode more than one MCU in any one go. */
+#undef _NO_STACK
+#ifndef _NO_STACK
+     JSAMPROW Yrows [idct_window_size];
+     JSAMPROW Cbrows[idct_window_size];
+     JSAMPROW Crrows[idct_window_size];
+     JSAMPARRAY jpeg_buffer[3] = {
+          [0] = Yrows,
+          [1] = Cbrows,
+          [2] = Crrows,
+     };
+#else
+     /* valgrind can't check stack variables */
+#warning this is not for production use, as we do not clean up on errors
+     JSAMPROW *Yrows, *Cbrows, *Crrows;
+     JSAMPARRAY *jpeg_buffer;
+
+     /* over allocate, least trouble */
+     Yrows = malloc (sizeof (JSAMPROW) * idct_window_size);
+     Cbrows = malloc (sizeof (JSAMPROW) * idct_window_size);
+     Crrows = malloc (sizeof (JSAMPROW) * idct_window_size);
+
+     jpeg_buffer = malloc (3 * sizeof (JSAMPARRAY));
+     jpeg_buffer[0] = Yrows;
+     jpeg_buffer[1] = Cbrows;
+     jpeg_buffer[2] = Crrows;
+#endif
+     void *yaddr, *cbaddr, *craddr;
+     unsigned int i;
+
+     DIRenderCallbackResult cb_result = DIRCR_OK;
+
+     D_DEBUG_AT (JPEG_RAW, "trying raw decode\n");
+
+     if (cinfo->max_h_samp_factor == 1
+         && cinfo->max_v_samp_factor == 1
+         && cinfo->cur_comp_info[0]->h_samp_factor == 1
+         && v_samp[0] == 1
+         && cinfo->cur_comp_info[1]->h_samp_factor == 1
+         && v_samp[1] == 1
+         && cinfo->cur_comp_info[2]->h_samp_factor == 1
+         && v_samp[2] == 1) {
+          /* The image is YCbCr 4:4:4 */
+          D_DEBUG_AT (JPEG_RAW, "  -> 4:4:4 image\n");
+
+          JPEG_setup_yuv444p (cinfo, &config, &pitch_y, &pitch_cb, &pitch_cr,
+                              &offset_cb, &offset_cr);
+     }
+     else if (cinfo->max_h_samp_factor == 2
+              && cinfo->max_v_samp_factor == 2
+              && cinfo->cur_comp_info[0]->h_samp_factor == 2
+              && v_samp[0] == 2
+              && cinfo->cur_comp_info[1]->h_samp_factor == 1
+              && v_samp[1] == 1
+              && cinfo->cur_comp_info[2]->h_samp_factor == 1
+              && v_samp[2] == 1) {
+          /* The image is YCbCr 4:2:0 ... */
+          D_DEBUG_AT (JPEG_RAW, "  -> 4:2:0 (I420) image\n");
+
+          if ((cinfo->scale_num != cinfo->scale_denom)
+              && ((((float)cinfo->scale_denom / cinfo->scale_num)
+                    == (float)(cinfo->scale_denom / cinfo->scale_num))
+                  || (cinfo->scale_num < 4 && cinfo->scale_num != 1)) /* only when JPEG_LIB_VERSION >= 70 */
+              && (cinfo->cur_comp_info[1]->downsampled_width
+                  == cinfo->cur_comp_info[0]->downsampled_width)
+              && (cinfo->cur_comp_info[2]->downsampled_width
+                  == cinfo->cur_comp_info[0]->downsampled_width)) {
+               /* ... but because we are iDCT scaling during decompression it
+                  might end up scaled to 4:4:4, as libjpeg can (and will) apply
+                  different scaling factors for the three components. */
+               D_DEBUG_AT (JPEG_RAW, "    -> iDCT %u/%u scaled to 4:4:4\n",
+                           cinfo->scale_num, cinfo->scale_denom);
+
+               JPEG_setup_yuv444p (cinfo, &config, &pitch_y, &pitch_cb, &pitch_cr,
+                                   &offset_cb, &offset_cr);
+          }
+          else if ((cinfo->scale_num == cinfo->scale_denom)
+                   || (((float)cinfo->scale_denom / cinfo->scale_num)
+                       != (float)(cinfo->scale_denom / cinfo->scale_num))
+                   || ((cinfo->cur_comp_info[1]->downsampled_width
+                        == ((cinfo->cur_comp_info[0]->downsampled_width + 1)
+                            / 2))
+                       && (cinfo->cur_comp_info[2]->downsampled_width
+                           == ((cinfo->cur_comp_info[0]->downsampled_width + 1)
+                               / 2)))) {
+               /* ... no iDCT scaling, which means it really ends up
+                  as 4:2:0. */
+               config.format = DSPF_I420;
+
+               config.size.w = _ROUND_UP_16 (cinfo->cur_comp_info[0]
+                                                           ->downsampled_width);
+               config.size.h = _ROUND_UP_16 (cinfo->cur_comp_info[0]
+                                                          ->downsampled_height);
+
+               /* pad an extra (decimated) MCU row for the iDCT write-out as required by libjpeg */
+               config.size.h += idct_window_size;
+
+               pitch_y = config.size.w;
+               pitch_cb
+                    = pitch_cr
+                    = pitch_y / 2;
+
+               offset_cb = pitch_y  * config.size.h;
+               offset_cr = pitch_cb * config.size.h / 2;
+
+               cb_v_sampl
+                    = cr_v_sampl
+                    = 2;
+          }
+          else {
+               /* shouldn't happen, really */
+               D_DEBUG_AT (JPEG_RAW, "  -> unsupported (unexpected)!\n");
+               return DFB_UNSUPPORTED;
+          }
+     }
+     else if (cinfo->max_h_samp_factor == 2
+              && cinfo->max_v_samp_factor == 1
+              && cinfo->cur_comp_info[0]->h_samp_factor == 2
+              && v_samp[0] == 1
+              && cinfo->cur_comp_info[1]->h_samp_factor == 1
+              && v_samp[1] == 1
+              && cinfo->cur_comp_info[2]->h_samp_factor == 1
+              && v_samp[2] == 1) {
+          /* The image is YCbCr 4:2:2 ... */
+          D_DEBUG_AT (JPEG_RAW, "  -> 4:2:2 (YV16) image\n");
+
+          if ((cinfo->scale_num != cinfo->scale_denom)
+              && ((((float)cinfo->scale_denom / cinfo->scale_num)
+                    == (float)(cinfo->scale_denom / cinfo->scale_num))
+                  || (cinfo->scale_num < 4 && cinfo->scale_num != 1)) /* only when JPEG_LIB_VERSION >= 70 */
+              && (cinfo->cur_comp_info[1]->downsampled_width
+                  == cinfo->cur_comp_info[0]->downsampled_width)
+              && (cinfo->cur_comp_info[2]->downsampled_width
+                  == cinfo->cur_comp_info[0]->downsampled_width)) {
+               /* ... iDCT scaling again, as above. */
+               D_DEBUG_AT (JPEG_RAW, "    -> iDCT %u/%u scaled to 4:4:4\n",
+                           cinfo->scale_num, cinfo->scale_denom);
+
+               JPEG_setup_yuv444p (cinfo, &config, &pitch_y, &pitch_cb, &pitch_cr,
+                                   &offset_cb, &offset_cr);
+          }
+          else if ((cinfo->scale_num == cinfo->scale_denom)
+                   || (((float)cinfo->scale_denom / cinfo->scale_num)
+                       != (float)(cinfo->scale_denom / cinfo->scale_num))
+                   || ((cinfo->cur_comp_info[1]->downsampled_width
+                        == ((cinfo->cur_comp_info[0]->downsampled_width + 1)
+                            / 2))
+                       && (cinfo->cur_comp_info[2]->downsampled_width
+                           == ((cinfo->cur_comp_info[0]->downsampled_width + 1)
+                               / 2)))) {
+               /* ... no iDCT scaling, as above. */
+               config.format = DSPF_YV16;
+
+               config.size.w = _ROUND_UP_16 (cinfo->cur_comp_info[0]
+                                                           ->downsampled_width);
+               config.size.h = _ROUND_UP_16 (cinfo->cur_comp_info[0]
+                                                          ->downsampled_height);
+
+               /* pad an extra (decimated) MCU row for the iDCT write-out as required by libjpeg */
+               config.size.h += idct_window_size;
+
+               pitch_y = config.size.w;
+               pitch_cb
+                    = pitch_cr
+                    = pitch_y / 2;
+
+               /* YV16 has Cr/Cb planes not Cb/Cr */
+               offset_cb = (pitch_y + pitch_cr) * config.size.h;
+               offset_cr = -pitch_cr * config.size.h;
+          }
+          else {
+               /* shouldn't happen, really */
+               D_DEBUG_AT (JPEG_RAW, "  -> unsupported (unexpected)!\n");
+               return DFB_UNSUPPORTED;
+          }
      }
      else {
-          rect = dst_data->area.wanted;
+          D_DEBUG_AT (JPEG_RAW, "  -> unsupported!\n");
+          return DFB_UNSUPPORTED;
      }
 
-     ret = dfb_surface_lock_buffer( dst_surface, CSBR_BACK, CSAID_CPU, CSAF_WRITE, &lock );
-     if (ret)
-          return ret;
+     /* yes, we can handle this raw format! */
+
+     config.flags = CSCONF_SIZE | CSCONF_FORMAT | CSCONF_CAPS;
+     #ifdef __SH4__
+     config.caps = DSCAPS_VIDEOONLY;
+     #else
+     config.caps = 0;
+     #endif
+     #ifdef DIRECT_BUILD_DEBUG
+     config.caps |= DSCAPS_SHARED;
+     #endif
+     if (dfb_surface_create (data->common.base.core, &config, CSTF_NONE, 0, NULL,
+                             &data->common.decode_surface)) {
+          D_ERROR ("failed to create temporary decode surface\n");
+          return DFB_UNSUPPORTED;
+     }
+
+     if (dfb_surface_lock_buffer (data->common.decode_surface,
+                                  CSBR_BACK, CSAID_CPU, CSAF_WRITE, lock)) {
+          dfb_surface_unref (data->common.decode_surface);
+          data->common.decode_surface = NULL;
+          return DFB_UNSUPPORTED;
+     }
+
+     cinfo->raw_data_out = true;
+     jpeg_start_decompress (cinfo);
+
+     dfb_state_set_source (state, data->common.decode_surface);
+
+     /* Initialize the various pointers to build a planar YUV buffer. */
+     yaddr  = lock->addr;
+     cbaddr = yaddr  + offset_cb;
+     craddr = cbaddr + offset_cr;
+
+     /* init. */
+     for (i = 0; i < idct_window_size; ++i) {
+          Yrows[i] = yaddr + i * pitch_y;
+          Cbrows[i] = cbaddr + i * pitch_cb;
+          Crrows[i] = craddr + i * pitch_cr;
+     }
+
+     while (cinfo->output_scanline < data->common.decoded_height
+            && cb_result == DIRCR_OK) {
+          int x = jpeg_read_raw_data (cinfo, jpeg_buffer,
+                                      idct_window_size);
+          if (x <= 0)
+               /* Actually, x == 0 means that we don't have enough data to
+                  continue decoding the picture. */
+               break;
+
+          D_DEBUG_AT (JPEG_RAW, "  -> decoded %d scanlines (out of %d (%d))\n",
+                      cinfo->output_scanline, data->common.decoded_height,
+                      config.size.h);
+
+          /* increment the pointers by the number of decoded (luma)
+             scanlines. */
+          for (i = 0; i < idct_window_size; ++i) {
+               Yrows[i] += (x * pitch_y) / y_v_sampl;
+               Cbrows[i] += (x * pitch_cb) / cb_v_sampl;
+               Crrows[i] += (x * pitch_cr) / cr_v_sampl;
+          }
+
+          if (data->common.base.render_callback) {
+               DFBRectangle src_rect = {
+                    .x = 0,
+                    .y = cinfo->output_scanline - x,
+                    .w = data->common.decoded_width,
+                    .h = x,
+               };
+               DFBRectangle r = src_rect;
+               float factor = (rect->h / (float) data->common.decoded_height);
+               DFBRectangle dst_rect = {
+                    .x = rect->x,
+                    .y = (int) (src_rect.y * factor),
+                    .w = rect->w,
+                    .h = (int) (src_rect.h * factor),
+               };
+
+               D_DEBUG_AT (JPEG_RAW,
+                           "  -> render callback %d,%d %dx%d -> %d,%d %dx%d\n",
+                           src_rect.x, src_rect.y, src_rect.w,
+                           src_rect.h, dst_rect.x, dst_rect.y,
+                           dst_rect.w, dst_rect.h);
+
+               JPEG_stretchblit (data, state, &src_rect, &dst_rect);
+
+               cb_result = data->common.base.render_callback (&r,
+                                                              data->common.base.render_callback_context);
+          }
+     }
+
+     D_DEBUG_AT (JPEG_RAW, "  -> decoded %d scanlines (out of %d)\n",
+                 cinfo->output_scanline, data->common.decoded_height);
+
+     if (cinfo->output_scanline < data->common.decoded_height
+         || cb_result != DIRCR_OK) {
+          if (cb_result != DIRCR_OK)
+               D_ERROR ("raw decode failed after %d of %d scanlines, "
+                        "trying pure software\n",
+                        cinfo->output_scanline, cinfo->output_height);
+          jpeg_abort_decompress (cinfo);
+          jpeg_destroy_decompress (cinfo);
+          dfb_surface_unlock_buffer (data->common.decode_surface, lock);
+          lock->pitch = 0;
+          dfb_surface_unref (data->common.decode_surface);
+          data->common.decode_surface = NULL;
 
-     if (data->image &&
-         (rect.x || rect.y || rect.w != data->image_width || rect.h != data->image_height)) {
-           D_FREE( data->image );
-           data->image        = NULL;
-           data->image_width  = 0;
-           data->image_height = 0;
+          if (cb_result != DIRCR_OK)
+               return DFB_INTERRUPTED;
+
+          return DFB_FAILURE; /* restart */
+     }
+
+     jpeg_finish_decompress (cinfo);
+     jpeg_destroy_decompress (cinfo);
+
+     dfb_surface_unlock_buffer (data->common.decode_surface, lock);
+     lock->pitch = 0;
+
+     /* use DFB to convert raw YUV to destination format, and apply any
+        necessary additional clip/stretch */
+     {
+     DFBRectangle src_rect = {
+          .x = 0,
+          .y = 0,
+          .w = data->common.decoded_width,
+          .h = data->common.decoded_height
+     };
+
+     JPEG_stretchblit (data, state, &src_rect, rect);
+
+     if (data->common.base.render_callback)
+          data->common.base.render_callback (&src_rect,
+                                             data->common.base.render_callback_context);
+     }
+
+#ifdef _NO_STACK
+     free (Yrows);
+     free (Cbrows);
+     free (Crrows);
+     free (jpeg_buffer);
+#endif
+     return DFB_OK;
+}
+
+static DFBResult
+JPEG_SoftwareRenderTo( IDirectFBImageProvider_JPEG_data *data,
+                       CoreSurface                      *dst_surface,
+                       DFBSurfacePixelFormat             format,
+                       DFBRectangle                     *rect,
+                       const DFBRegion                  *clip )
+{
+     DFBResult              ret;
+     bool                   direct = false;
+     CoreSurfaceBufferLock  lock = { .pitch = 0 };
+     DIRenderCallbackResult cb_result = DIRCR_OK;
+     bool                   try_raw = true;
+
+     D_ASSERT( data != NULL );
+     D_ASSERT( dst_surface != NULL );
+     D_ASSERT( clip != NULL );
+     D_ASSERT( rect != NULL );
+
+     if (data->common.image &&
+         (rect->x || rect->y || rect->w != data->common.decoded_width || rect->h != data->common.decoded_height)) {
+           D_FREE( data->common.image );
+           data->common.image          = NULL;
+           data->common.decoded_width  = 0;
+           data->common.decoded_height = 0;
      }
 
      /* actual loading and rendering */
-     if (!data->image) {
+     if (!data->common.image
+         && !data->common.decode_surface) {
           struct jpeg_decompress_struct cinfo;
           struct my_error_mgr jerr;
           JSAMPARRAY buffer;      /* Output row buffer */
@@ -416,6 +891,8 @@
           u32 *row_ptr;
           int y = 0;
           int uv_offset = 0;
+          CardState state;
+          CoreSurfaceBufferLock lock_raw = { .pitch = 0 };
 
           cinfo.err = jpeg_std_error(&jerr.pub);
           jerr.pub.error_exit = jpeglib_panic;
@@ -425,28 +902,42 @@
 
                jpeg_destroy_decompress(&cinfo);
 
-               if (data->image) {
-                    dfb_scale_linear_32( data->image, data->image_width, data->image_height,
-                                         lock.addr, lock.pitch, &rect, dst_surface, &clip );
-                    dfb_surface_unlock_buffer( dst_surface, &lock );
-                    if (data->base.render_callback) {
-                         DFBRectangle r = { 0, 0, data->image_width, data->image_height };
+               if (try_raw) {
+                    dfb_state_set_source (&state, NULL);
+                    dfb_state_set_destination (&state, NULL);
+                    dfb_state_destroy (&state);
+               }
+               if (data->common.decode_surface) {
+                    if (lock_raw.pitch)
+                         dfb_surface_unlock_buffer (data->common.decode_surface,
+                                                    &lock_raw);
+                    dfb_surface_unref (data->common.decode_surface);
+                    data->common.decode_surface = NULL;
+               }
+
+               if (data->common.image) {
+                    dfb_scale_linear_32( data->common.image, data->common.decoded_width, data->common.decoded_height,
+                                         lock.addr, lock.pitch, rect, dst_surface, clip );
+                    if (lock.pitch)
+                         dfb_surface_unlock_buffer( dst_surface, &lock );
+                    if (data->common.base.render_callback) {
+                         DFBRectangle r = { 0, 0, data->common.decoded_width, data->common.decoded_height };
 
-                         if (data->base.render_callback( &r,
-                                                         data->base.render_callback_context ) != DIRCR_OK)
+                         if (data->common.base.render_callback( &r, data->common.base.render_callback_context ) != DIRCR_OK)
                               return DFB_INTERRUPTED;
                     }
 
                     return DFB_INCOMPLETE;
                }
-               else
+               else if (lock.pitch)
                     dfb_surface_unlock_buffer( dst_surface, &lock );
 
                return DFB_FAILURE;
           }
 
+restart:
           jpeg_create_decompress(&cinfo);
-          jpeg_buffer_src(&cinfo, data->base.buffer, 0);
+          jpeg_buffer_src(&cinfo, data->common.base.buffer, 0);
           jpeg_read_header(&cinfo, TRUE);
 
 #if JPEG_LIB_VERSION >= 70
@@ -458,24 +949,21 @@
 #endif
           jpeg_calc_output_dimensions(&cinfo);
 
-          if (cinfo.output_width == rect.w && cinfo.output_height == rect.h) {
-               direct = true;
-          }
-          else if (rect.x == 0 && rect.y == 0) {
+          if (rect->x == 0 && rect->y == 0) {
 #if JPEG_LIB_VERSION >= 70
-               cinfo.scale_num = 16;
+               cinfo.scale_num = 8;
                while (cinfo.scale_num > 1) {
                     jpeg_calc_output_dimensions (&cinfo);
-                    if (cinfo.output_width <= rect.w
-                        || cinfo.output_height <= rect.h)
+                    if (cinfo.output_width <= rect->w
+                        || cinfo.output_height <= rect->h)
                          break;
                     --cinfo.scale_num;
                }
                jpeg_calc_output_dimensions (&cinfo);
 #else
                while (cinfo.scale_denom < 8
-                      && ((cinfo.output_width >> 1) >= rect.w)
-                      && ((cinfo.output_height >> 1) >= rect.h)) {
+                      && ((cinfo.output_width >> 1) >= rect->w)
+                      && ((cinfo.output_height >> 1) >= rect->h)) {
                     cinfo.scale_denom <<= 1;
                     jpeg_calc_output_dimensions (&cinfo);
                }
@@ -484,19 +972,81 @@
 
           cinfo.output_components = 3;
 
+          data->common.decoded_width = cinfo.output_width;
+          data->common.decoded_height = cinfo.output_height;
+
+          cinfo.do_fancy_upsampling = FALSE;
+          cinfo.do_block_smoothing = FALSE;
+
+          if (try_raw) {
+               /* init a state, so that we can use gfxcard/blit to convert YUV to
+                  requested destination format */
+               dfb_state_init (&state, data->common.base.core);
+               dfb_state_set_destination (&state, dst_surface);
+               dfb_state_set_clip (&state, clip);
+
+               ret = JPEG_raw_decode (data, dst_surface, rect, &cinfo,
+                                      &state, &lock_raw);
+
+               /* remove the state */
+               dfb_state_set_source (&state, NULL);
+               dfb_state_set_destination (&state, NULL);
+               dfb_state_destroy (&state);
+
+               switch (ret) {
+                    case DFB_OK:
+                    case DFB_INTERRUPTED:
+                         /* All ok, or callback signalled abort. */
+                         return ret;
+
+                    case DFB_UNSUPPORTED:
+                         /* Not enough video memory or source image format not
+                            supported. jpeg_start_decompress() was not yet
+                            called, so we can just break.
+                            We have to reset try_raw, in case the software
+                            decode throws an exception, though. */
+                         try_raw = false;
+                         break;
+
+                    default:
+                         D_BUG ("JPEG_raw_decode() returned unknown "
+                                "result %d\n", ret);
+                    case DFB_FAILURE:
+                         /* General failure during compression, we restart
+                            trying a software decoding and in for that have to
+                            reinitialise cinfo. */
+                         try_raw = false;
+                         goto restart;
+               }
+          }
+
+
+          /* start using the full software decode path */
+          D_WARN ("slow JPEG decode path");
+
+          ret = dfb_surface_lock_buffer( dst_surface, CSBR_BACK, CSAID_CPU, CSAF_WRITE, &lock );
+          if (ret) {
+               jpeg_abort_decompress(&cinfo);
+               jpeg_destroy_decompress(&cinfo);
+               return ret;
+          }
+
+          if (cinfo.output_width == rect->w && cinfo.output_height == rect->h)
+               direct = true;
+
           switch (dst_surface->config.format) {
                case DSPF_NV16:
                     uv_offset = dst_surface->config.size.h * lock.pitch;
 
-                    if (direct && !rect.x && !rect.y) {
+                    if (direct && !rect->x && !rect->y) {
                          D_INFO( "JPEG: Using YCbCr color space directly! (%dx%d)\n",
                                  cinfo.output_width, cinfo.output_height );
                          cinfo.out_color_space = JCS_YCbCr;
                          break;
                     }
                     D_INFO( "JPEG: Going through RGB color space! (%dx%d -> %dx%d @%d,%d)\n",
-                            cinfo.output_width, cinfo.output_height, rect.w, rect.h, rect.x, rect.y );
-               
+                            cinfo.output_width, cinfo.output_height, rect->w, rect->h, rect->x, rect->y );
+
                default:
                     cinfo.out_color_space = JCS_RGB;
                     break;
@@ -504,20 +1054,19 @@
 
           jpeg_start_decompress(&cinfo);
 
-          data->image_width = cinfo.output_width;
-          data->image_height = cinfo.output_height;
-
           row_stride = cinfo.output_width * 3;
 
           buffer = (*cinfo.mem->alloc_sarray)((j_common_ptr) &cinfo,
                                               JPOOL_IMAGE, row_stride, 1);
 
-          data->image = D_CALLOC( data->image_height, data->image_width * 4 );
-          if (!data->image) {
+          data->common.image = D_CALLOC( data->common.decoded_height, data->common.decoded_width * 4 );
+          if (!data->common.image) {
                dfb_surface_unlock_buffer( dst_surface, &lock );
+               jpeg_abort_decompress(&cinfo);
+               jpeg_destroy_decompress(&cinfo);
                return D_OOM();
           }
-          row_ptr = data->image;
+          row_ptr = data->common.image;
 
           while (cinfo.output_scanline < cinfo.output_height && cb_result == DIRCR_OK) {
                jpeg_read_scanlines(&cinfo, buffer, 1);
@@ -525,86 +1074,284 @@
                switch (dst_surface->config.format) {
                     case DSPF_NV16:
                          if (direct) {
-                              copy_line_nv16( lock.addr, lock.addr + uv_offset, *buffer, rect.w );
+                              copy_line_nv16( lock.addr, lock.addr + uv_offset, *buffer, rect->w );
 
                               lock.addr += lock.pitch;
 
-                              if (data->base.render_callback) {
-                                   DFBRectangle r = { 0, y, data->image_width, 1 };
+                              if (data->common.base.render_callback) {
+                                   DFBRectangle r = { 0, y, data->common.decoded_width, 1 };
 
-                                   cb_result = data->base.render_callback( &r,
-                                                                           data->base.render_callback_context );
+                                   cb_result = data->common.base.render_callback( &r,
+                                                                                  data->common.base.render_callback_context );
                               }
                               break;
                          }
 
                     default:
-                         copy_line32( row_ptr, *buffer, data->image_width );
+                         copy_line32( row_ptr, *buffer, data->common.decoded_width );
 
                          if (direct) {
-                              DFBRectangle r = { rect.x, rect.y+y, rect.w, 1 };
+                              DFBRectangle r = { rect->x, rect->y+y, rect->w, 1 };
+
                               dfb_copy_buffer_32( row_ptr, lock.addr, lock.pitch,
-                                                  &r, dst_surface, &clip );
-                              if (data->base.render_callback) {
-                                   r = (DFBRectangle){ 0, y, data->image_width, 1 };
-                                   cb_result = data->base.render_callback( &r,
-                                                                           data->base.render_callback_context );
+                                                  &r, dst_surface, clip );
+                              if (data->common.base.render_callback) {
+                                   r = (DFBRectangle){ 0, y, data->common.decoded_width, 1 };
+                                   cb_result = data->common.base.render_callback( &r,
+                                                                                  data->common.base.render_callback_context );
                               }
                          }
                          break;
                }
 
-               row_ptr += data->image_width;
+               row_ptr += data->common.decoded_width;
                y++;
           }
 
           if (!direct) {
-               dfb_scale_linear_32( data->image, data->image_width, data->image_height,
-                                    lock.addr, lock.pitch, &rect, dst_surface, &clip );
-               if (data->base.render_callback) {
-                    DFBRectangle r = { 0, 0, data->image_width, data->image_height };
-                    cb_result = data->base.render_callback( &r,
-                                                            data->base.render_callback_context );
+               dfb_scale_linear_32( data->common.image, data->common.decoded_width, data->common.decoded_height,
+                                    lock.addr, lock.pitch, rect, dst_surface, clip );
+               if (data->common.base.render_callback) {
+                    DFBRectangle r = { 0, 0, data->common.decoded_width, data->common.decoded_height };
+                    cb_result = data->common.base.render_callback( &r, data->common.base.render_callback_context );
                }
           }
 
           if (cb_result != DIRCR_OK) {
                jpeg_abort_decompress(&cinfo);
-               D_FREE( data->image );
-               data->image = NULL;
+               D_FREE( data->common.image );
+               data->common.image = NULL;
           }
           else {
                jpeg_finish_decompress(&cinfo);
           }
           jpeg_destroy_decompress(&cinfo);
+
+          dfb_surface_unlock_buffer( dst_surface, &lock );
+     }
+     else if (data->common.decode_surface) {
+          CardState    state;
+          DFBRectangle src_rect = {
+               .x = 0,
+               .y = 0,
+               .w = data->common.decoded_width,
+               .h = data->common.decoded_height
+          };
+
+          /* use DFB to convert raw YUV to destination format, and
+             apply any necessary additional clip/stretch */
+          dfb_state_init (&state, data->common.base.core);
+          dfb_state_set_source (&state, data->common.decode_surface);
+          dfb_state_set_destination (&state, dst_surface);
+          dfb_state_set_clip (&state, clip);
+
+          JPEG_stretchblit (data, &state, &src_rect, rect);
+
+          /* remove the state */
+          dfb_state_set_source (&state, NULL);
+          dfb_state_set_destination (&state, NULL);
+          dfb_state_destroy (&state);
+
+          if (data->common.base.render_callback) {
+               DFBRectangle r = { 0, 0, data->common.decoded_width, data->common.decoded_height };
+               data->common.base.render_callback (&r,
+                                                  data->common.base.render_callback_context);
+          }
      }
      else {
-          dfb_scale_linear_32( data->image, data->image_width, data->image_height,
-                               lock.addr, lock.pitch, &rect, dst_surface, &clip );
-          if (data->base.render_callback) {
-               DFBRectangle r = { 0, 0, data->image_width, data->image_height };
-               data->base.render_callback( &r,
-                                           data->base.render_callback_context );
+          ret = dfb_surface_lock_buffer( dst_surface, CSBR_BACK, CSAID_CPU, CSAF_WRITE, &lock );
+          if (ret)
+               return ret;
+
+          dfb_scale_linear_32( data->common.image, data->common.decoded_width, data->common.decoded_height,
+                               lock.addr, lock.pitch, rect, dst_surface, clip );
+          if (data->common.base.render_callback) {
+               DFBRectangle r = { 0, 0, data->common.decoded_width, data->common.decoded_height };
+               data->common.base.render_callback( &r,
+                                                  data->common.base.render_callback_context );
           }
+
+          dfb_surface_unlock_buffer( dst_surface, &lock );
      }
-     
-     dfb_surface_unlock_buffer( dst_surface, &lock );
+
+     D_DEBUG_AT (JPEG, "software decoding finished\n");
 
      if (cb_result != DIRCR_OK)
-         return DFB_INTERRUPTED;
+          return DFB_INTERRUPTED;
+
+     return DFB_OK;
+}
+
+
+
+static DFBResult
+JPEG_RenderTo( IDirectFBImageProvider_JPEG_data *data,
+               CoreSurface                      *dst_surface,
+               DFBSurfacePixelFormat             format,
+               DFBRectangle                     *rect,
+               const DFBRegion                  *clip )
+{
+     DFBResult res;
+
+     D_ASSERT( data != NULL );
+     D_ASSERT( dst_surface != NULL );
+     D_ASSERT( clip != NULL );
+     D_ASSERT( rect != NULL );
+
+     res = JPEG_HardwareRenderTo (data, dst_surface, format, rect, clip);
+     if (res != DFB_OK) {
+          if (res == DFB_IO) {
+               /* IO error - there's no point in retrying */
+               D_DEBUG_AT (JPEG, "hardware decode failed: %d (%s)\n",
+                           res, DirectFBErrorString (res));
+               return res;
+          }
+
+          D_DEBUG_AT (JPEG, "hardware decode failed: %d (%s) - "
+                      "attempting software fallback\n",
+                      res, DirectFBErrorString (res));
+
+          res = JPEG_SoftwareRenderTo (data, dst_surface, format, rect, clip);
+          if (unlikely (res != DFB_OK))
+               D_DEBUG_AT (JPEG, "software decode failed: %d (%s)\n",
+                           res, DirectFBErrorString (res));
+     }
+
+     return res;
+}
+
+static DFBResult
+IDirectFBImageProvider_JPEG_RenderTo( IDirectFBImageProvider *thiz,
+                                      IDirectFBSurface       *destination,
+                                      const DFBRectangle     *dest_rect )
+{
+     IDirectFBSurface_data *dst_data;
+     CoreSurface           *dst_surface;
+     DFBSurfacePixelFormat  format;
+     DFBResult              ret;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBImageProvider_JPEG)
+
+     dst_data = (IDirectFBSurface_data*) destination->priv;
+     if (!dst_data)
+          return DFB_DEAD;
+
+     dst_surface = dst_data->surface;
+     if (!dst_surface)
+          return DFB_DESTROYED;
+
+     ret = destination->GetPixelFormat( destination, &format );
+     if (ret)
+          return ret;
+
+     if (data->thread)
+          pthread_mutex_lock( &data->lock );
+
+     dfb_region_from_rectangle( &data->clip, &dst_data->area.current );
+
+     if (dest_rect) {
+          if (dest_rect->w < 1 || dest_rect->h < 1) {
+               if (data->thread)
+                    pthread_mutex_unlock( &data->lock );
+               return DFB_INVARG;
+          }
+
+          data->rect = *dest_rect;
+          data->rect.x += dst_data->area.wanted.x;
+          data->rect.y += dst_data->area.wanted.y;
+
+          if (!dfb_rectangle_region_intersects( &data->rect, &data->clip )) {
+               if (data->thread)
+                    pthread_mutex_unlock( &data->lock );
+               return DFB_OK;
+          }
+     }
+     else {
+          data->rect = dst_data->area.wanted;
+     }
+
+     if (!D_FLAGS_IS_SET (data->flags, DIPFLAGS_BACKGROUND_DECODE)) {
+          /* threaded operation was not requested */
+          data->thread_res = JPEG_RenderTo( data, dst_surface, format,
+                                            &data->rect, &data->clip );
+          if (data->thread)
+               pthread_mutex_unlock( &data->lock );
+          return data->thread_res;
+     }
+
+     if (!data->thread) {
+          /* for the case that somebody does a RenderTo() twice on us, we
+             have to create new thread, because the initial thread will have
+             finished already */
+
+          D_ASSERT( data->destination == NULL );
+
+          /* as long as we haven't even started yet, we are in INIT state */
+          data->thread_res = DFB_INIT;
+          data->thread = direct_thread_create( DTT_DEFAULT, JPEGrenderThread,
+                                               thiz, "JPEG" );
+     }
+
+     D_ASSERT( data->destination == NULL );
+
+     destination->AddRef( destination );
+     data->destination = destination;
+
+     pthread_cond_signal( &data->cond );
+     pthread_mutex_unlock( &data->lock );
 
      return DFB_OK;
 }
 
 static DFBResult
+IDirectFBImageProvider_JPEG_Sync( IDirectFBImageProvider    *thiz,
+                                  DFBImageProviderSyncFlags  flags )
+{
+     DFBResult res;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBImageProvider_JPEG)
+
+     switch (flags)
+       {
+       case DIPSYNCFLAGS_TRYSYNC:
+            if (data->thread) {
+                 if (data->thread_res == DFB_INIT
+                     || data->thread_res == DFB_BUSY) {
+                      /* DFB_INIT (user didn't call RenderTo() yet)
+                         DFB_BUSY (still busy decoding) */
+                      return data->thread_res;
+                 }
+                 /* else we are done, either because of some error or because
+                    we have processed all the data already */
+            }
+            /* fall through */
+
+       case DIPSYNCFLAGS_SYNC:
+            if (data->thread) {
+                 direct_thread_join( data->thread );
+                 direct_thread_destroy( data->thread );
+                 data->thread = NULL;
+            }
+            break;
+
+       default:
+            return DFB_OK;
+       }
+
+     res = data->thread_res;
+     data->thread_res = DFB_OK;
+     return res;
+}
+
+static DFBResult
 IDirectFBImageProvider_JPEG_GetSurfaceDescription( IDirectFBImageProvider *thiz,
                                                    DFBSurfaceDescription  *dsc )
 {
      DIRECT_INTERFACE_GET_DATA(IDirectFBImageProvider_JPEG)
-     
+
      dsc->flags  = DSDESC_WIDTH |  DSDESC_HEIGHT | DSDESC_PIXELFORMAT;
-     dsc->height = data->height;
-     dsc->width  = data->width;
+     dsc->width  = data->common.width;
+     dsc->height = data->common.height;
      dsc->pixelformat = dfb_primary_layer_pixelformat();
 
      return DFB_OK;
@@ -623,3 +1370,1138 @@
 
      return DFB_OK;
 }
+
+static void
+render_cleanup( void *cleanup_data )
+{
+     IDirectFBImageProvider           *thiz = cleanup_data;
+     IDirectFBImageProvider_JPEG_data *data;
+
+     D_MAGIC_ASSERT( (IAny*)thiz, DirectInterface );
+     data = (IDirectFBImageProvider_JPEG_data *) thiz->priv;
+     D_ASSERT( data != NULL );
+
+     if (data->destination) {
+          data->destination->Release( data->destination );
+          data->destination = NULL;
+     }
+
+     /* in case we get terminated from outside, set the state to DFB_DEAD */
+     data->thread_res = DFB_DEAD;
+
+     pthread_mutex_unlock( &data->lock );
+}
+
+static void *
+JPEGrenderThread( DirectThread *thread, void *driver_data )
+{
+     IDirectFBImageProvider           *thiz = driver_data;
+     IDirectFBImageProvider_JPEG_data *data;
+     IDirectFBSurface_data            *dst_data;
+     CoreSurface                      *dst_surface;
+     DFBSurfacePixelFormat             format;
+     DFBResult                         res;
+
+     D_MAGIC_ASSERT( (IAny*)thiz, DirectInterface );
+     data = (IDirectFBImageProvider_JPEG_data *) thiz->priv;
+     D_ASSERT( data != NULL );
+
+     pthread_mutex_lock( &data->lock );
+
+     pthread_cleanup_push( render_cleanup, thiz );
+
+     while (!data->destination) {
+          pthread_cond_wait( &data->cond, &data->lock );
+     }
+
+     dst_data = (IDirectFBSurface_data*) data->destination->priv;
+     D_ASSERT( dst_data != NULL );
+
+     dst_surface = dst_data->surface;
+     D_ASSERT( dst_surface != NULL );
+
+     res = data->destination->GetPixelFormat( data->destination, &format );
+     D_ASSERT( res == DFB_OK );
+
+     /* as long as we haven't finished decoding we are busy */
+     data->thread_res = DFB_BUSY;
+
+     res = JPEG_RenderTo( data, dst_surface, format, &data->rect, &data->clip );
+
+     pthread_cleanup_pop( 1 );
+
+     /* in case we exit normally, apply the real return value */
+     data->thread_res = res;
+
+     return NULL;
+}
+
+
+#if defined(JPEG_PROVIDER_USE_MME)
+static DFBResult
+fetch_data (IDirectFBDataBuffer *buffer,
+            MME_DataBuffer_t    *dbuf,
+            int                  len)
+{
+  dbuf->ScatterPages_p[0].BytesUsed = 0;
+  dbuf->ScatterPages_p[0].FlagsIn   = 0;
+  dbuf->ScatterPages_p[0].FlagsOut  = 0;
+
+  return buffer_to_ptr_copy (buffer, dbuf->ScatterPages_p[0].Page_p, len);
+}
+
+
+static void
+TransformerCallback (MME_Event_t    Event,
+                     MME_Command_t *CallbackData,
+                     void          *UserData)
+{
+  const JPEGDEC_TransformReturnParams_t *transform_result =
+    CallbackData->CmdStatus.AdditionalInfo_p;
+//  const JPEGDECHW_VideoDecodeReturnParams_t *transform_result_hw =
+//    CallbackData->CmdStatus.AdditionalInfo_p;
+  struct _MMECommon * const mme = (struct _MMECommon *) UserData;
+  IDirectFBImageProvider_JPEG_data * const jpeg =
+    container_of (mme, IDirectFBImageProvider_JPEG_data, common);
+
+//  if (CallbackData->CmdStatus.AdditionalInfo_p == &jpeg->hw_return_params)
+//    {
+//      transform_result_hw = CallbackData->CmdStatus.AdditionalInfo_p;
+//      transform_result = NULL;
+//    }
+//  else
+    {
+      transform_result = CallbackData->CmdStatus.AdditionalInfo_p;
+//      transform_result_hw = NULL;
+    }
+
+  if (!mme->name_set)
+    {
+      char name[25];
+      snprintf (name, sizeof (name), "MME (%s)", mme->transformer_name);
+      direct_thread_set_name (name);
+      mme->name_set = true;
+    }
+
+  D_DEBUG_AT (JPEG_MME, "%sTransformerCallback: Event: %d: (%s)%s\n",
+              RED, Event, get_mme_event_string (Event), BLACK);
+  D_DEBUG_AT (JPEG_MME, "  -> CallbackData->CmdStatus.State: %d (%s)\n",
+              CallbackData->CmdStatus.State,
+              get_mme_state_string (CallbackData->CmdStatus.State));
+  D_DEBUG_AT (JPEG_MME, "  -> CallbackData->CmdStatus.CmdId: %u (%.8x)\n",
+              CallbackData->CmdStatus.CmdId,
+              CallbackData->CmdStatus.CmdId);
+  D_DEBUG_AT (JPEG_MME, "  -> CallbackData->CmdStatus.AdditionalInfoSize: %u\n",
+              CallbackData->CmdStatus.AdditionalInfoSize);
+  D_DEBUG_AT (JPEG_MME, "  -> mme->decode_success: %d\n", mme->decode_success);
+
+  switch (Event)
+    {
+    case MME_COMMAND_COMPLETED_EVT:
+      pthread_mutex_lock (&mme->pending_commands_lock);
+      direct_hash_remove (mme->pending_commands,
+                          CallbackData->CmdStatus.CmdId);
+      if (likely (CallbackData->CmdStatus.CmdId != mme->TransformCommand.CmdStatus.CmdId))
+        --mme->n_pending_buffers;
+      pthread_mutex_unlock (&mme->pending_commands_lock);
+
+      switch (CallbackData->CmdStatus.State)
+        {
+        case MME_COMMAND_COMPLETED:
+          if (unlikely (CallbackData->CmdStatus.CmdId
+                        == mme->TransformCommand.CmdStatus.CmdId))
+            {
+              deb_gettimeofday (&mme->endtime, NULL);
+              deb_timersub (&mme->endtime, &mme->starttime, &mme->endtime);
+              D_DEBUG_AT (JPEG_TIME, "  -> total time %lu.%06lu\n",
+                          mme->endtime.tv_sec, mme->endtime.tv_usec);
+
+              /* This info is available as data->ReturnParams. too!
+                 mme->decoded_bytes  = (unsigned int) transform_result->bytes_written;
+                 mme->decoded_height = (int) transform_result->decodedImageHeight;
+                 mme->decoded_width  = (int) transform_result->decodedImageWidth; */
+
+              if (transform_result)
+                {
+                  D_DEBUG_AT (JPEG_MME, "  -> expanded bytes: %u\n",
+                              transform_result->bytes_written);
+                  D_DEBUG_AT (JPEG_MME, "  -> decoded w/h: %dx%d\n",
+                              transform_result->decodedImageWidth,
+                              transform_result->decodedImageHeight);
+
+                  if (jpeg->progressive_mode)
+                    {
+                      mme->width = transform_result->decodedImageWidth;
+                      mme->height = transform_result->decodedImageHeight;
+                    }
+
+                  if (transform_result->Total_cycle)
+                    D_DEBUG_AT (JPEG_MME,
+                                "  -> cycles: total/dmiss/imiss: %u/%u/%u\n",
+                                transform_result->Total_cycle,
+                                transform_result->DMiss_Cycle,
+                                transform_result->IMiss_Cycle);
+                  D_DEBUG_AT (JPEG_MME, "  -> JPEG result code: %d (%s)\n",
+                              transform_result->ErrorType,
+                              get_jpeg_error_string (transform_result->ErrorType));
+                }
+//              else
+//                {
+//                  D_DEBUG_AT (JPEG_MME, "  -> cycles/dmiss/imiss: %u/%u/%u\n",
+//                              transform_result_hw->pm_cycles,
+//                              transform_result_hw->pm_dmiss,
+//                              transform_result_hw->pm_imiss);
+//                  D_DEBUG_AT (JPEG_MME, "  -> bundles/prefetches: %u/%u\n",
+//                              transform_result_hw->pm_bundles,
+//                              transform_result_hw->pm_pft);
+//
+//                  D_DEBUG_AT (JPEG_MME, "  -> JPEGHW result code: %d (%s)\n",
+//                              transform_result_hw->ErrorCode,
+//                              get_jpeghw_error_string (transform_result_hw->ErrorCode));
+//                }
+
+              mme->decode_success = 1;
+              sema_signal_event (&mme->decode_event);
+
+              /* in case of bogus data (too much), abort pending data
+                 buffers */
+              abort_transformer (mme);
+            }
+          else
+            {
+              /* buffer completed */
+              struct _MMEHelper_buffer *buf =
+                container_of (CallbackData->DataBuffers_p,
+                              struct _MMEHelper_buffer, buffer);
+
+              D_DEBUG_AT (JPEG_MME, "  -> buffer %p completed (container @ %p)\n",
+                          CallbackData->DataBuffers_p[0], buf);
+
+              sema_signal_event (&buf->sema);
+            }
+          break; /* MME_COMMAND_COMPLETED */
+
+        case MME_COMMAND_FAILED:
+          D_WARN ("(%5d) %s: command %u (%.8x) failed: error %d (%s)",
+                  direct_gettid (), mme->name,
+                  CallbackData->CmdStatus.CmdId,
+                  CallbackData->CmdStatus.CmdId,
+                  CallbackData->CmdStatus.Error,
+                  get_mme_error_string (CallbackData->CmdStatus.Error));
+
+          if (likely (CallbackData->CmdStatus.CmdId
+                      == mme->TransformCommand.CmdStatus.CmdId))
+            {
+              /* transform command failed */
+              D_WARN ("(%5d) %s: jpeg failure code: %d (%s)",
+                      direct_gettid (), mme->name, transform_result->ErrorType,
+                      get_jpeg_error_string (transform_result->ErrorType));
+              switch (transform_result->ErrorType)
+                {
+                case UNSUPPORTED_COLORSPACE:
+                case UNABLE_ALLOCATE_MEMORY:
+                case UNSUPPORTED_SCALING:
+                case INSUFFICIENT_OUTPUTBUFFER_SIZE:
+                  /* the transformer doesn't support this, but pure libjpeg
+                     should. */
+                  mme->decode_success = -1;
+                  break;
+
+                case UNSUPPORTED_ROTATION_ANGLE:
+                default:
+                  /* fake a success, there's no point in retrying libjpeg, as
+                     it already failed via MME. */
+                  mme->decode_success = 1;
+                  D_DEBUG_AT (JPEG_MME, "  -> faking success\n");
+                  break;
+              }
+
+              sema_signal_event (&mme->decode_event);
+            }
+          else
+            {
+              /* buffer failed */
+              struct _MMEHelper_buffer *buf =
+                container_of (CallbackData->DataBuffers_p,
+                              struct _MMEHelper_buffer, buffer);
+              if (mme->decode_success == 0)
+                /* only if we didn't succeed yet */
+                mme->decode_success = -1;
+              sema_signal_event (&buf->sema);
+            }
+          break; /* MME_COMMAND_FAILED */
+
+        case MME_COMMAND_IDLE:
+        case MME_COMMAND_PENDING:
+        case MME_COMMAND_EXECUTING:
+        default:
+          D_WARN ("(%5d) %s: command %u (%.8x) completed in unknown state: %d (%s)",
+                  direct_gettid (), mme->name,
+                  CallbackData->CmdStatus.CmdId, CallbackData->CmdStatus.CmdId,
+                  CallbackData->CmdStatus.State,
+                  get_mme_state_string (CallbackData->CmdStatus.State));
+          break;
+        }
+      break; /* MME_COMMAND_COMPLETED_EVT */
+
+    case MME_DATA_UNDERFLOW_EVT:
+      /* because of the way the transformer works (and how we communicate
+         with it), we get exactly one underflow event on startup */
+      D_DEBUG_AT (JPEG_MME, "  -> %sdata underflow on command %u (%.8x)\n",
+                  (mme->n_underflows == 0) ? "(anticipated) " : "",
+                  CallbackData->CmdStatus.CmdId, CallbackData->CmdStatus.CmdId);
+      if (++mme->n_underflows > 1)
+        {
+          /* check if the IDirectFBDataBuffer definitely(!) hit an EOF and
+             we have no buffers queued */
+          bool end_of_data;
+          char tmp;
+          pthread_mutex_lock (&mme->pending_commands_lock);
+          DFBResult has_data = mme->base.buffer->PeekData (mme->base.buffer,
+                                                           1, 0, &tmp, NULL);
+          /* n_pending_buffers is checked to be == 0 because the
+             TransformCommand itself is not stored in there. */
+          end_of_data = (has_data == DFB_EOF
+                         && mme->n_pending_buffers == 0);
+          pthread_mutex_unlock (&mme->pending_commands_lock);
+
+          /* if so, signal completion */
+          if (end_of_data)
+            {
+              D_DEBUG_AT (JPEG_MME, "  -> no more data available, signalling fail\n");
+              mme->decode_success = -2;
+              sema_signal_event (&mme->decode_event);
+            }
+        }
+      break; /* MME_DATA_UNDERFLOW_EVT */
+
+    case MME_NOT_ENOUGH_MEMORY_EVT:
+    case MME_NEW_COMMAND_EVT:
+    default:
+      D_WARN ("(%5d) %s: unhandled event %d (%s) occured on command %u (%.8x)",
+              direct_gettid (), mme->name, Event,
+              get_mme_event_string (Event), CallbackData->CmdStatus.CmdId,
+              CallbackData->CmdStatus.CmdId);
+
+      D_WARN ("(%5d) %s: CallbackData->CmdStatus.AdditionalInfoSize: %u",
+              direct_gettid (), mme->name, CallbackData->CmdStatus.AdditionalInfoSize);
+
+      if (CallbackData->CmdStatus.CmdId == mme->TransformCommand.CmdStatus.CmdId)
+        {
+          if (transform_result)
+            {
+              D_WARN ("(%5d) %s: transform_result->bytes_written: %u",
+                      direct_gettid (), mme->name, transform_result->bytes_written);
+              D_WARN ("(%5d) %s: transform_result->decodedImageHeight: %d",
+                      direct_gettid (), mme->name, transform_result->decodedImageHeight);
+              D_WARN ("(%5d) %s: transform_result->decodedImageWidth: %d",
+                      direct_gettid (), mme->name, transform_result->decodedImageWidth);
+              if (transform_result->Total_cycle)
+                D_WARN ("(%5d) %s: transform_result->cycles: total/dmiss/imiss: %u/%u/%u\n",
+                        direct_gettid (), mme->name,
+                        transform_result->Total_cycle,
+                        transform_result->DMiss_Cycle,
+                        transform_result->IMiss_Cycle);
+              D_WARN ("(%5d) %s: result code: %d (%s)\n", direct_gettid (),
+                      mme->name, transform_result->ErrorType,
+                      get_jpeg_error_string (transform_result->ErrorType));
+            }
+//          else if (transform_result_hw)
+//            {
+//              D_WARN ("(%5d) %s: transform_result->cycles/dmiss/imiss: %u/%u/%u\n",
+//                      direct_gettid (), mme->name,
+//                      transform_result_hw->pm_cycles,
+//                      transform_result_hw->pm_dmiss,
+//                      transform_result_hw->pm_imiss);
+//              D_WARN ("(%5d) %s: transform_result->bundles/prefetches: %u/%u\n",
+//                          direct_gettid (), mme->name,
+//                          transform_result_hw->pm_bundles,
+//                          transform_result_hw->pm_pft);
+//
+//              D_WARN ("(%5d) %s: transform_result->JPEGHW result code: %d (%s)\n",
+//                          direct_gettid (), mme->name,
+//                          transform_result_hw->ErrorCode,
+//                          get_jpeghw_error_string (transform_result_hw->ErrorCode));
+//            }
+        }
+      break;
+    }
+}
+
+#if 0
+static void
+TransformerCallback2 (MME_Event_t    Event,
+                      MME_Command_t *CallbackData,
+                      void          *UserData)
+{
+  const JPEGDECHW_VideoDecodeReturnParams_t * const transform_result_hw =
+    CallbackData->CmdStatus.AdditionalInfo_p;
+  struct _MMECommon * const mme = (struct _MMECommon *) UserData;
+
+  if (!mme->name_set)
+    {
+      direct_thread_set_name ("MME (hwjpeg)");
+      mme->name_set = true;
+    }
+
+  D_DEBUG_AT (JPEG_MME, "%sTransformerCallback2: Event: %d: (%s)%s\n",
+              RED, Event, get_mme_event_string (Event), BLACK);
+  D_DEBUG_AT (JPEG_MME, "  -> CallbackData->CmdStatus.State: %d (%s)\n",
+              CallbackData->CmdStatus.State,
+              get_mme_state_string (CallbackData->CmdStatus.State));
+  D_DEBUG_AT (JPEG_MME, "  -> CallbackData->CmdStatus.CmdId: %u (%.8x)\n",
+              CallbackData->CmdStatus.CmdId, CallbackData->CmdStatus.CmdId);
+  D_DEBUG_AT (JPEG_MME, "  -> CallbackData->CmdStatus.AdditionalInfoSize: %u\n",
+              CallbackData->CmdStatus.AdditionalInfoSize);
+  D_DEBUG_AT (JPEG_MME, "  -> mme->decode_success: %d\n", mme->decode_success);
+}
+#endif
+
+
+/* Pre-Scaling Calculations for JPEG Hardware Scaling
+ * These functions should be used anywhere where SOURCE width and height are
+   referenced */
+static unsigned int
+pre_scale_value (const IDirectFBImageProvider_JPEG_data *data,
+                 const DFBRectangle                     *dest_rect)
+{
+  unsigned int scale;
+
+  D_ASSERT( data != NULL );
+
+#ifdef PRE_SCALE_SPEED_SPACE_OPTIMISED
+  /* Speed and Space */
+  if (data->common.width <= dest_rect->w || data->common.height <= dest_rect->h)
+    scale = 1;
+  else if ((data->common.width / 2 <= dest_rect->w) && (data->common.height / 2 <= dest_rect->h))
+    scale = 2;
+  else if ((data->common.width / 4 <= dest_rect->w) && (data->common.height / 4 <= dest_rect->h))
+    scale = 4;
+  else if ((data->common.width / 8 <= dest_rect->w) && (data->common.height / 8 <= dest_rect->h))
+    scale = 8;
+  else
+    scale = 1;
+#endif
+
+#ifdef PRE_SCALE_QUALITY_OPTIMISED
+  /* Quality */
+  if ((data->common.width / 8 >= dest_rect->w) && (data->common.height / 8 >= dest_rect->h))
+    scale = 8;
+  else if ((data->common.width / 4 >= dest_rect->w) && (data->common.height / 4 >= dest_rect->h))
+    scale = 4;
+  else if ((data->common.width / 2 >= dest_rect->w) && (data->common.height / 2 >= dest_rect->h))
+    scale = 2;
+  else
+    scale = 1;
+#endif
+
+#if !defined(PRE_SCALE_SPEED_SPACE_OPTIMISED) && !defined(PRE_SCALE_QUALITY_OPTIMISED)
+  scale = 1;
+#endif
+
+  return scale;
+}
+
+static inline unsigned int
+pre_scaled_width (const IDirectFBImageProvider_JPEG_data *data,
+                  const DFBRectangle                     *dest_rect)
+{
+  D_ASSERT( data != NULL );
+
+  unsigned int w = (data->common.width + 15) & ~15; /* Macro Block Rounding */
+  return w / pre_scale_value (data, dest_rect);
+}
+
+static inline unsigned int
+pre_scaled_height (const IDirectFBImageProvider_JPEG_data *data,
+                   const DFBRectangle                     *dest_rect)
+{
+  D_ASSERT( data != NULL );
+
+  unsigned int h = (data->common.height + 15) & ~15; /* Macro Block Rounding */
+  return h / pre_scale_value (data, dest_rect);
+}
+
+/* warning: MME_AbortCommand() works only for the MME_TRANSFORM command;
+   individual buffers can be aborted, too, but MME_TermTransformer() will
+   not work afterwards anymore! */
+static bool
+pending_fe_func (DirectHash    *hash,
+                 unsigned long  key,
+                 void          *value,
+                 void          *ctx)
+{
+  struct _MMECommon * const mme = ctx;
+  MME_CommandId_t    CmdId = key;
+
+  if (key != mme->TransformCommand.CmdStatus.CmdId)
+    {
+      if (direct_hash_lookup (hash, mme->TransformCommand.CmdStatus.CmdId))
+        D_WARN ("(%5d) aborting MME command %u (%.8x) can lead to a crash "
+                "somewhere in the JPEG transformer!",
+                direct_gettid (), CmdId, CmdId);
+    }
+  else
+    D_DEBUG_AT (JPEG_MME, "aborting (main transform) command %u (%.8x)\n",
+                CmdId, CmdId);
+
+  MME_ERROR res = MME_AbortCommand (mme->Handle, CmdId);
+  if (res != MME_SUCCESS)
+    D_WARN ("(%5d) MME_AbortCommand(%x, %.8x) for %s failed: %d (%s)\n",
+            direct_gettid (), mme->Handle, CmdId,
+            mme->name, res, get_mme_error_string (res));
+
+  /* continue iterating */
+  return true;
+}
+
+static DFBResult
+abort_transformer (struct _MMECommon * const mme)
+{
+  if (!mme)
+       return DFB_THIZNULL;
+
+  /* FIXME: what about locking? */
+  direct_hash_iterate (mme->pending_commands,
+                       pending_fe_func,
+                       mme);
+
+  return DFB_OK;
+}
+
+
+static void
+_imageprovider_update_transform_params (struct _MMECommon           * const mme,
+                                        void                        * const params,
+                                        const CoreSurfaceBufferLock * const lock)
+{
+  IDirectFBImageProvider_JPEG_data * const data =
+    container_of (mme, IDirectFBImageProvider_JPEG_data, common);
+
+  data->OutputParams.outputSettings.Pitch = lock->pitch;
+  data->OutputParams.outputSettings.ROTATEFLAG |= 0x80000000;
+}
+
+/*
+ *  Set up JPEG transform command
+ *  Establish Decode Parameters,
+ *  and prepare destination surface
+ *
+ */
+static DFBResult
+jpeg_start_transformer (IDirectFBImageProvider_JPEG_data *data,
+                        CoreSurface                      *dst_surface,
+                        CoreSurfaceBufferLock            *lock)
+{
+  DFBResult res;
+
+  /* If height and width are NOT values divisible by 16 - then decode will not work as expected. */
+  data->OutputParams.outputSettings.xvalue0 = 0;
+  data->OutputParams.outputSettings.xvalue1 = 0;
+  data->OutputParams.outputSettings.yvalue0 = 0;
+  data->OutputParams.outputSettings.yvalue1 = 0;
+
+  data->OutputParams.outputSettings.outputWidth = 0;  //Buffersize used to prevent bufferoverflows;
+  data->OutputParams.outputSettings.outputHeight = 0; //Buffersize used to prevent bufferoverflows;
+  data->OutputParams.outputSettings.ROTATEFLAG = 0;
+  data->OutputParams.outputSettings.Rotatedegree = 0;
+  data->OutputParams.outputSettings.HorizantalFlip = 0;
+  data->OutputParams.outputSettings.VerticalFlip = 0;
+
+  res = _mme_helper_start_transformer_core (&data->common,
+                                            sizeof (data->ReturnParams),
+                                            &data->ReturnParams,
+                                            sizeof (data->OutputParams),
+                                            &data->OutputParams,
+                                            dst_surface, lock);
+  if (res != DFB_OK)
+    return res;
+
+  _imageprovider_update_transform_params (&data->common,
+                                          &data->OutputParams, lock);
+
+  /* if pitch != width - we'll have issues with the hardware decode */
+  /* FIXME: the comment makes no sense. And the D_ASSUME() does sth
+     different... */
+  D_ASSUME (lock->pitch != dst_surface->config.size.w);
+
+  D_DEBUG_AT (MME_DEBUG_DOMAIN, "issuing MME_TRANSFORM\n");
+
+  /* lock access to hash, because otherwise the callback could be called
+     before we've had a chance to put the command id into the hash */
+  D_ASSERT (&data->common.pending_commands != NULL);
+  pthread_mutex_lock (&data->common.pending_commands_lock);
+
+  res = MME_SendCommand (data->common.Handle, &data->common.TransformCommand);
+  if (res != MME_SUCCESS)
+    {
+      pthread_mutex_unlock (&data->common.pending_commands_lock);
+
+      D_WARN ("(%5d) %s: starting transformer failed: %d (%s)",
+              direct_gettid (), data->common.name,
+              res, get_mme_error_string (res));
+
+      dfb_surface_unlock_buffer (dst_surface, lock);
+
+      D_FREE (data->common.OutDataBuffers);
+      data->common.OutDataBuffers = NULL;
+
+      return DFB_FAILURE;
+    }
+
+  direct_hash_insert (data->common.pending_commands,
+                      data->common.TransformCommand.CmdStatus.CmdId,
+                      (void *) 1);
+  D_DEBUG_AT (JPEG_MME, "sent packet's CmdId is %u (%.8x)\n",
+              data->common.TransformCommand.CmdStatus.CmdId,
+              data->common.TransformCommand.CmdStatus.CmdId);
+
+  deb_gettimeofday (&data->common.starttime, NULL);
+
+  pthread_mutex_unlock (&data->common.pending_commands_lock);
+
+  return DFB_OK;
+}
+
+#if 0
+#include <../gfxdrivers/stgfx/stgfx.h>
+#include <../gfxdrivers/stgfx2/stm_gfxdriver.h>
+static STMFB_GFXMEMORY_PARTITION
+bdisp_surface_pool_get_partition (const CoreSurfacePool * const pool)
+{
+  unsigned i;
+
+  switch (dfb_system_get_accelerator ())
+    {
+    case FB_ACCEL_ST_GAMMA:
+    case FB_ACCEL_ST_BDISP:
+      {
+      const STGFXDeviceData * const stdev = dfb_gfxcard_get_device_data ();
+      for (i = 0; i < D_ARRAY_SIZE (stdev->aux_pools); ++i)
+        if (stdev->aux_pools[i] == pool)
+          return STMFBGP_GFX0 + i;
+      }
+      break;
+
+    case FB_ACCEL_ST_BDISP_USER:
+      {
+      const STGFX2DeviceData * const stdev = dfb_gfxcard_get_device_data ();
+      for (i = 0; i < D_ARRAY_SIZE (stdev->aux_pools); ++i)
+        if (stdev->aux_pools[i] == pool)
+          return STMFBGP_GFX0 + i;
+      }
+      break;
+
+    default:
+      return STMFBGP_FRAMEBUFFER;
+    }
+
+  return STMFBGP_FRAMEBUFFER;
+}
+#endif
+
+#if 0
+static DFBResult
+jpeg_start_transformer2 (IDirectFBImageProvider_JPEG_data *data,
+                         CoreSurface                      *dst_surface,
+                         CoreSurfaceBufferLock            *lock)
+{
+  DFBResult             res;
+  CoreSurfaceBufferLock raw_lock;
+  CoreSurfaceBufferLock chr_lock;
+
+
+  /* src surface */
+  CoreSurface *raw_surface;
+
+  /* FIXME: this is BAD (tm) -> think streaming media! */
+  data->common.buffer->SeekTo (data->common.buffer, 0);
+  /* find out the length of the buffer */
+  unsigned int src_bytes;
+  data->common.buffer->GetLength (data->common.buffer, &src_bytes);
+
+  {
+  CoreSurfaceConfig config = { .size.w = src_bytes,
+                               .size.h = 1 };
+  /* create temporary surface to store the compressed data in. */
+  config.flags = CSCONF_SIZE | CSCONF_FORMAT | CSCONF_CAPS;
+  config.format = DSPF_LUT8;
+  config.caps   = DSCAPS_VIDEOONLY;
+  #ifdef DIRECT_BUILD_DEBUG
+  config.caps   |= DSCAPS_SHARED;
+  #endif
+  if ((res = dfb_surface_create (data->common.core,
+                                 &config,
+                                 CSTF_NONE,
+                                 0,
+                                 NULL,
+                                 &raw_surface)) != DFB_OK)
+    goto out1;
+  if ((res = dfb_surface_lock_buffer (raw_surface, CSBR_BACK, CSAID_CPU,
+                                      CSAF_WRITE, &raw_lock)) != DFB_OK)
+    goto out2;
+  }
+
+  {
+  unsigned int sz;
+  u8 *addr = raw_lock.addr;
+  res = data->common.buffer->GetData (data->common.buffer, src_bytes, addr, &sz);
+  if (sz != src_bytes)
+    goto out3;
+  printf("src data @ %.8lx\n", lock->phys);
+  }
+  /* FIXME: this is BAD (tm) -> think streaming media! */
+  data->common.buffer->SeekTo (data->common.buffer, 0);
+  res = dfb_surface_unlock_buffer (raw_surface, &raw_lock);
+
+
+  CoreSurface *chr_surface;
+  {
+  CoreSurfaceConfig config = { .size.w = data->common.width,
+                               .size.h = data->common.height };
+  config.size.h += 2;
+  /* create temporary surface to store the compressed data in. */
+  config.flags = CSCONF_SIZE | CSCONF_FORMAT | CSCONF_CAPS;
+  config.format = DSPF_ARGB;
+  config.caps   = DSCAPS_VIDEOONLY;
+  #ifdef DIRECT_BUILD_DEBUG
+  config.caps   |= DSCAPS_SHARED;
+  #endif
+  if ((res = dfb_surface_create (data->common.core,
+                                 &config,
+                                 CSTF_NONE,
+                                 0,
+                                 NULL,
+                                 &chr_surface)) != DFB_OK)
+    goto out4;
+  }
+
+
+  res = dfb_surface_lock_buffer (raw_surface, CSBR_FRONT, CSAID_ACCEL0,
+                                 CSAF_READ, &raw_lock);
+  res = dfb_surface_lock_buffer (data->common.decode_surface, CSBR_BACK, CSAID_ACCEL0,
+                                 CSAF_WRITE, lock);
+  res = dfb_surface_lock_buffer (chr_surface, CSBR_BACK, CSAID_ACCEL0,
+                                 CSAF_WRITE, &chr_lock);
+
+  /* should be aligned on 256byte boundary */
+  D_ASSUME ((chr_lock.phys & 0xff) == 0);
+  D_ASSUME ((lock->phys & 0xff) == 0);
+  printf ("raw/dst/chr phys: 0x%.8lx 0x%.8lx 0x%.8lx\n",
+          raw_lock.phys, lock->phys, chr_lock.phys);
+
+  u32 raw_phys = raw_lock.phys;
+  u32 dst_phys = (lock->phys + 255) & 0xffffff00;
+  printf("dst_phys %.8x\n", dst_phys);
+  u32 chr_phys = (chr_lock.phys + 255) & 0xffffff00;
+  printf("chr_phys %.8x\n", chr_phys);
+
+  raw_phys += 0x10000000;
+  dst_phys += 0x10000000;
+  chr_phys += 0x10000000;
+
+  /* If height and width are NOT values divisible by 16 - then decode will not work as expected. */
+  data->hw_decode_params.PictureStartAddr_p = (void *) raw_phys;
+  data->hw_decode_params.PictureEndAddr_p   = (void *) (raw_phys + src_bytes);
+  data->hw_decode_params.DecodedBufferAddr.Luma_p            = (void *) dst_phys;
+  data->hw_decode_params.DecodedBufferAddr.Chroma_p          = (void *) chr_phys;
+  data->hw_decode_params.DecodedBufferAddr.LumaDecimated_p   = (void *) (dst_phys + 512);
+  data->hw_decode_params.DecodedBufferAddr.ChromaDecimated_p = (void *) (chr_phys + 512);
+  data->hw_decode_params.MainAuxEnable = JPEGDECHW_MAINOUT_EN;
+  data->hw_decode_params.HorizontalDecimationFactor = JPEGDECHW_HDEC_1;
+  data->hw_decode_params.VerticalDecimationFactor   = JPEGDECHW_VDEC_1;
+  data->hw_decode_params.xvalue0 = 0;
+  data->hw_decode_params.yvalue0 = 0;
+  data->hw_decode_params.xvalue1 = 0;
+  data->hw_decode_params.yvalue1 = 0;
+  data->hw_decode_params.DecodingMode = JPEGDECHW_NORMAL_DECODE;
+  data->hw_decode_params.AdditionalFlags = JPEGDECHW_ADDITIONAL_FLAG_NONE;
+
+  data->hw_decode_params.MainAuxEnable = JPEGDECHW_AUXOUT_EN;
+  data->hw_decode_params.AdditionalFlags = 64; /* raster */
+
+  /* set up the transform command */
+  data->common.TransformCommand.StructSize = sizeof (MME_Command_t);
+  data->common.TransformCommand.CmdCode    = MME_TRANSFORM;
+  data->common.TransformCommand.CmdEnd     = MME_COMMAND_END_RETURN_NOTIFY;
+  data->common.TransformCommand.DueTime    = (MME_Time_t) 0;
+  data->common.TransformCommand.NumberInputBuffers  = 0;
+  data->common.TransformCommand.NumberOutputBuffers = 0;
+  data->common.TransformCommand.DataBuffers_p = NULL;
+  data->common.TransformCommand.ParamSize  = sizeof (data->hw_decode_params);
+  data->common.TransformCommand.Param_p    = &data->hw_decode_params;
+
+  /* init the transform command */
+  memset (&(data->common.TransformCommand.CmdStatus), 0, sizeof (MME_CommandStatus_t));
+  data->common.TransformCommand.CmdStatus.AdditionalInfoSize = sizeof (data->hw_return_params);
+  data->common.TransformCommand.CmdStatus.AdditionalInfo_p = &data->hw_return_params;
+
+  D_DEBUG_AT (MME_DEBUG_DOMAIN, "issuing MME_TRANSFORM\n");
+
+  /* lock access to hash, because otherwise the callback could be called
+     before we've had a chance to put the command id into the hash */
+  D_ASSERT (&data->common.pending_commands != NULL);
+  pthread_mutex_lock (&data->common.pending_commands_lock);
+
+  res = MME_SendCommand (data->common.Handle, &data->common.TransformCommand);
+  if (res != MME_SUCCESS)
+    {
+      pthread_mutex_unlock (&data->common.pending_commands_lock);
+
+      D_WARN ("(%5d) %s: starting transformer failed: %d (%s)",
+              direct_gettid (), data->common.name,
+              res, get_mme_error_string (res));
+
+      res = DFB_FAILURE;
+
+      goto out5;
+    }
+
+  direct_hash_insert (data->common.pending_commands,
+                      data->common.TransformCommand.CmdStatus.CmdId,
+                      (void *) 1);
+  D_DEBUG_AT (JPEG_MME, "sent packet's CmdId is %u (%.8x)\n",
+              data->common.TransformCommand.CmdStatus.CmdId,
+              data->common.TransformCommand.CmdStatus.CmdId);
+
+  deb_gettimeofday (&data->common.starttime, NULL);
+
+  pthread_mutex_unlock (&data->common.pending_commands_lock);
+
+
+  /* wait until the decode is complete (or until the abort was
+     acknowledged) */
+  D_DEBUG_AT (JPEG_MME, "waiting for completion\n");
+  while ((sema_wait_event (&data->common.decode_event) == -1)
+         && errno == EINTR)
+    ;
+  if (data->common.decode_success != 1)
+    res = DFB_FAILURE;
+
+
+  mme_helper_deinit_transformer (&data->common);
+
+
+out5:
+  dfb_surface_unlock_buffer (chr_surface, &chr_lock);
+  dfb_surface_unref (chr_surface);
+  dfb_surface_unlock_buffer (data->common.decode_surface, lock);
+
+
+out4:
+out3:
+  dfb_surface_unlock_buffer (raw_surface, &raw_lock);
+out2:
+  dfb_surface_unref (raw_surface);
+out1:
+  return res;
+}
+#endif
+
+
+static DFBResult
+JPEG_HardwareRenderTo( IDirectFBImageProvider_JPEG_data *data,
+                       CoreSurface                      *dst_surface,
+                       DFBSurfacePixelFormat             format,
+                       DFBRectangle                     *rect,
+                       const DFBRegion                  *clip )
+{
+  DFBResult              dfbret = dfbret;
+  CoreSurfaceBufferLock  lock;
+
+  D_ASSERT( data != NULL );
+  D_ASSERT( dst_surface != NULL );
+  D_ASSERT( rect != NULL );
+  D_ASSERT( clip != NULL );
+
+  CoreSurfaceConfig config;
+
+  config.size.w = pre_scaled_width (data, rect);
+  config.size.h = pre_scaled_height (data, rect);
+
+  if (unlikely (data->progressive_mode))
+    {
+      int src_width  = (data->common.width + 15) & ~15;
+      int src_height = (data->common.height + 15) & ~15;
+      int totalsize = data->num_components * src_width * src_height;
+      int scale;
+
+#define MAX_MEMORY_FOR_PROGRESSIVE_IMAGE  (1 * 1024 * 1024)
+      if (totalsize < MAX_MEMORY_FOR_PROGRESSIVE_IMAGE)
+        scale = 1;
+      else if (totalsize/4 < MAX_MEMORY_FOR_PROGRESSIVE_IMAGE)
+        scale = 2;
+      else if (totalsize/16 < MAX_MEMORY_FOR_PROGRESSIVE_IMAGE)
+        scale = 4;
+      else if (totalsize/64 < MAX_MEMORY_FOR_PROGRESSIVE_IMAGE)
+        scale = 8;
+      else
+        return DFB_UNSUPPORTED;
+
+      data->common.width /= scale;
+      data->common.height /= scale;
+//      data->common.width = src_width / scale;
+//      data->common.height = src_height / scale;
+
+      config.size.w = src_width / scale;
+      config.size.h = src_height / scale;
+    }
+  else
+    {
+      int pre_scale = pre_scale_value (data, rect);
+
+      config.size.w = pre_scaled_width (data, rect);
+      config.size.h = pre_scaled_height (data, rect);
+      data->common.width /= pre_scale;
+      data->common.height /= pre_scale;
+    }
+
+  /* FIXME: check if the image is big enough to warrant a HW decode */
+  if (!data->common.decode_surface
+      || config.size.w != data->common.decode_surface->config.size.w
+      || config.size.h != data->common.decode_surface->config.size.h)
+    {
+      /* create destination surface to MME-decode the image onto before
+         stretchblit ... and if we can't create a surface in video memory then
+         we can't blit */
+      /* Also, decide on the decode size.
+         Limitations are:
+          - closest match to a 1/1 1/2 1/4 1/8 reduction
+          - AND a 16 pixel macroblock size. */
+      config.flags = CSCONF_SIZE | CSCONF_FORMAT | CSCONF_CAPS;
+      config.format = DSPF_UYVY;
+#ifdef __SH4__
+      config.caps = DSCAPS_VIDEOONLY;
+#else
+      config.caps = 0;
+#endif
+      #ifdef DIRECT_BUILD_DEBUG
+      config.caps   |= DSCAPS_SHARED;
+      #endif
+
+      D_DEBUG_AT (JPEG_MME, "%dx%d prescaled to %dx%d\n",
+                  rect->w, rect->h, config.size.w, config.size.h);
+
+      if (data->common.decode_surface)
+        dfb_surface_unref (data->common.decode_surface);
+
+      if (dfb_surface_create (data->common.base.core,
+                              &config,
+                              CSTF_NONE,
+                              0,
+                              NULL,
+                              &data->common.decode_surface))
+        {
+          data->common.decode_surface = NULL;
+          return DFB_NOVIDEOMEMORY;
+        }
+
+      data->common.decode_success = 0;
+    }
+
+  if (data->common.decode_success <= 0)
+    {
+      data->common.name = "hwJPEG";
+      data->common.decode_success = 0;
+
+#if 0
+      data->common.name = "hwJPEGHW";
+      {
+      static const char * const transformers[] = { "JPEG_DECODER_HW1",
+                                                   "JPEG_DECODER_HW0",
+                                                   "JPEG_DECODER_HW4",
+                                                   "JPEG_DECODER_HW3",
+                                                   "JPEG_DECODER_HW2",
+                                                   "JPEG_DECODER_HW",
+                                                   NULL };
+      unsigned int index;
+      JPEGDECHW_VideoDecodeInitParams_t init;
+      /* we should probably allocate some mme memory 2048*2048 */
+      init.CircularBufferBeginAddr_p = (JPEGDECHW_CompressedData_t) 0x00000000;
+      init.CircularBufferEndAddr_p   = (JPEGDECHW_CompressedData_t) 0xfffffff8;
+//      init.CircularBufferBeginAddr_p = 0;
+//      init.CircularBufferEndAddr_p   = 0;
+      dfbret = mme_helper_init_transformer2 (&data->common, transformers,
+                                             sizeof (init), &init, &index,
+                                             &TransformerCallback);
+      if (dfbret != DFB_OK)
+        goto cont;
+
+      MME_TransformerCapability_t cap;
+      _mme_helper_get_capability (&data->common, transformers[index], &cap);
+
+      if (data->flags & DIPFLAGS_BACKGROUND_DECODE)
+        direct_thread_set_name (transformers[index]);
+
+      /* store the current data buffer position for software fallback
+         should we not succeed */
+      unsigned int bufpos;
+      data->common.buffer->GetPosition (data->common.buffer, &bufpos);
+
+      sema_init_event (&data->common.decode_event, 0);
+
+      /* Tell the transformer what to do and where to put result. depending on dst - may need to consider pitch!*/
+      dfbret = jpeg_start_transformer2 (data, data->common.decode_surface,
+                                        &lock);
+      goto stretch;
+      }
+
+cont: ;
+#endif
+
+      static const char * const transformers[] = { JPEGDEC_MME_TRANSFORMER_NAME"0",
+                                                   JPEGDEC_MME_TRANSFORMER_NAME"1",
+                                                   JPEGDEC_MME_TRANSFORMER_NAME"2",
+                                                   JPEGDEC_MME_TRANSFORMER_NAME"3",
+                                                   JPEGDEC_MME_TRANSFORMER_NAME"4",
+                                                   JPEGDEC_MME_TRANSFORMER_NAME,
+                                                   NULL };
+      unsigned int index;
+      dfbret = mme_helper_init_transformer (&data->common, transformers,
+                                            0, NULL, &index);
+      if (dfbret == DFB_OK)
+        {
+           MME_TransformerCapability_t cap;
+          _mme_helper_get_capability (&data->common,
+                                      transformers[index], &cap);
+
+#if 0
+          if (cap.Version != 2)
+            {
+              /* incompatible with old transformer, it has just way too
+                 many bugs! */
+              mme_helper_deinit_transformer (&data->common);
+              dfbret = DFB_FAILURE;
+              continue;
+            }
+
+          data->common.transformer_name = *transformers[transformer_index];
+          if (data->flags & DIPFLAGS_BACKGROUND_DECODE)
+            direct_thread_set_name (*transformers[transformer_index]);
+
+          break;
+#endif
+        }
+
+      if (dfbret == DFB_OK)
+        {
+          bool locked = false;
+
+          data->common.transformer_name = transformers[index];
+          if (data->flags & DIPFLAGS_BACKGROUND_DECODE)
+            direct_thread_set_name (transformers[index]);
+
+          /* store the current data buffer position for software fallback
+             should we not succeed */
+          unsigned int bufpos;
+          data->common.base.buffer->GetPosition (data->common.base.buffer,
+                                                 &bufpos);
+
+          sema_init_event (&data->common.decode_event, 0);
+
+          /* Tell the transformer what to do and where to put result. depending on dst - may need to consider pitch!*/
+          dfbret = jpeg_start_transformer (data, data->common.decode_surface,
+                                           &lock);
+          if (dfbret == DFB_OK)
+            {
+              locked = true;
+
+              D_DEBUG_AT (JPEG_MME, "Transform sent, sending data buffers now\n");
+
+              mme_helper_calculate_packets (&data->common);
+              dfbret = mme_helper_send_packets (&data->common, -1);
+              if (dfbret != DFB_OK)
+                {
+                  D_DEBUG_AT (JPEG_MME, "aborting (main) transform command %u (%.8x)\n",
+                              data->common.TransformCommand.CmdStatus.CmdId,
+                              data->common.TransformCommand.CmdStatus.CmdId);
+                  MME_ERROR res = MME_AbortCommand (data->common.Handle,
+                                                    data->common.TransformCommand.CmdStatus.CmdId);
+                  if (res != MME_SUCCESS)
+                    D_WARN ("(%5d) MME_AbortCommand(%x, %.8x) for %s failed: %d (%s)\n",
+                            direct_gettid (), data->common.Handle,
+                            data->common.TransformCommand.CmdStatus.CmdId,
+                            data->common.name, res, get_mme_error_string (res));
+                }
+
+              /* wait until the decode is complete (or until the abort was
+                 acknowledged) */
+              D_DEBUG_AT (JPEG_MME, "waiting for completion\n");
+              while ((sema_wait_event (&data->common.decode_event) == -1)
+                     && errno == EINTR)
+                ;
+              if (data->common.decode_success != 1)
+                dfbret = DFB_FAILURE;
+            }
+          else
+            {
+              if (data->common.decode_success < 0)
+                dfbret = DFB_FAILURE;
+              D_DEBUG_AT (JPEG_MME, "couldn't start transformer\n");
+            }
+
+          /* we always get an underflow on startup at the moment - update the
+             value so only interesting underflow get printed ... */
+          if (data->common.n_underflows)
+            --data->common.n_underflows;
+
+          abort_transformer (&data->common);
+          /* wait till all commands are aborted and acknowledged */
+          while (data->common.n_pending_buffers
+                 || direct_hash_lookup (data->common.pending_commands,
+                                        data->common.TransformCommand.CmdStatus.CmdId))
+            usleep (1);
+
+          mme_helper_deinit_transformer (&data->common);
+
+          if (likely (locked))
+            dfb_surface_unlock_buffer (data->common.decode_surface, &lock);
+
+          if (data->common.OutDataBuffers)
+            {
+              D_FREE (data->common.OutDataBuffers);
+              data->common.OutDataBuffers = NULL;
+            }
+
+          unsigned int i;
+          for (i = 0; i < D_ARRAY_SIZE (data->common.SendDataBuffers); ++i)
+            {
+              if (data->common.SendDataBuffers[i].buffer)
+                {
+                  MME_FreeDataBuffer (data->common.SendDataBuffers[i].buffer);
+                  data->common.SendDataBuffers[i].buffer = NULL;
+
+                  sema_close_event (&data->common.SendDataBuffers[i].sema);
+                }
+            }
+
+          sema_close_event (&data->common.decode_event);
+
+          data->common.base.buffer->SeekTo (data->common.base.buffer,
+                                            bufpos);
+        }
+      else
+        {
+          D_ASSUME (data->common.decode_surface != NULL);
+          dfb_surface_unref (data->common.decode_surface);
+          data->common.decode_surface = NULL;
+        }
+    }
+
+  if (data->common.decode_success == 1)
+    {
+      /* stretch blit the decoded image to the destination surface and size */
+      mme_helper_stretch_blit (&data->common, data->common.decode_surface,
+                               dst_surface, rect);
+      dfbret = DFB_OK;
+    }
+  else
+    {
+      if (data->common.decode_surface)
+        dfb_surface_unref (data->common.decode_surface);
+      data->common.decode_surface = NULL;
+    }
+
+  return dfbret;
+}
+#endif /* JPEG_PROVIDER_USE_MME */
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/interfaces/IDirectFBImageProvider/idirectfbimageprovider_jpeg.h DirectFB-1.4.12+STM2011.09.27/interfaces/IDirectFBImageProvider/idirectfbimageprovider_jpeg.h
--- DirectFB/interfaces/IDirectFBImageProvider/idirectfbimageprovider_jpeg.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/interfaces/IDirectFBImageProvider/idirectfbimageprovider_jpeg.h	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,113 @@
+#ifndef __IDIRECTFBIMAGEPROVIDER_JPEG_H__
+#define __IDIRECTFBIMAGEPROVIDER_JPEG_H__
+
+#if defined(JPEG_PROVIDER_USE_MME)
+/* HW Decode Requirements */
+#include <mme.h>
+#include <semaphore.h>
+
+#include <JPEG_VideoTransformerTypes.h>
+//#include <JPEGDECHW_VideoTransformerTypes.h>
+#endif /* JPEG_PROVIDER_USE_MME */
+
+/* The following define controls prescaling
+ *
+ * PRE_SCALE_QUALITY_OPTIMISED : Better Quality
+ * When defined pre-scale will scale to larger than the requested
+ * size and use the blitter to reduce down.
+ * - This option will take precedence if both options are defined.
+ *
+ * PRE_SCALE_SPACE_OPTIMISED : Faster and Less Memory
+ * When defined pre-scale will scale below requested size, and
+ * use the blitter to enlarge
+ *
+ * Removing both defines will safely disable the pre-scaler
+ */
+#define PRE_SCALE_QUALITY_OPTIMISED
+//#define PRE_SCALE_SPEED_SPACE_OPTIMISED
+
+
+
+/* private data struct of IDirectFBImageProvider_JPEG */
+typedef struct
+{
+  /* hardware decode specifics */
+  struct _MMECommon common;
+
+  DFBRectangle      rect;
+  DFBRegion         clip;
+
+  /* thread stuff */
+  DFBImageProviderFlags flags;
+  pthread_mutex_t   lock;
+  pthread_cond_t    cond;
+  DirectThread     *thread;
+  IDirectFBSurface *destination;
+  DFBResult         thread_res;
+
+#if defined(JPEG_PROVIDER_USE_MME)
+  int  num_components;
+  bool progressive_mode;
+
+  JPEGDEC_TransformParams_t       OutputParams;
+  JPEGDEC_TransformReturnParams_t ReturnParams;
+
+//  JPEGDECHW_VideoDecodeParams_t       hw_decode_params;
+//  JPEGDECHW_VideoDecodeReturnParams_t hw_return_params;
+#endif /* JPEG_PROVIDER_USE_MME */
+} IDirectFBImageProvider_JPEG_data;
+
+
+#if defined(JPEG_PROVIDER_USE_MME)
+static inline const char *
+get_jpeg_error_string (unsigned int e)
+{
+  static const char *JpegErrorType_strings[] = {
+    "Successfully Decoded", /* JPEG_NO_ERROR */
+    "UNDEFINED_HUFF_TABLE",
+    "UNSUPPORTED_MARKER",
+    "UNABLE_ALLOCATE_MEMORY",
+    "NON_SUPPORTED_SAMP_FACTORS",
+    "BAD_PARAMETER",
+    "DECODE_ERROR",
+    "BAD_RESTART_MARKER",
+    "UNSUPPORTED_COLORSPACE",
+    "BAD_SOS_SPECTRAL",
+    "BAD_SOS_SUCCESSIVE",
+    "BAD_HEADER_LENGTH",
+    "BAD_COUNT_VALUE",
+    "BAD_DHT_MARKER",
+    "BAD_INDEX_VALUE",
+    "BAD_NUMBER_HUFFMAN_TABLES",
+    "BAD_QUANT_TABLE_LENGHT",
+    "BAD_NUMBER_QUANT_TABLES",
+    "BAD_COMPONENT_COUNT",
+    "DIVIDE_BY_ZERO_ERROR",
+    "NOT_JPG_IMAGE",
+    "UNSUPPORTED_ROTATION_ANGLE",
+    "UNSUPPORTED_SCALING",
+    "INSUFFICIENT_OUTPUTBUFFER_SIZE"
+  };
+
+  return ((e < D_ARRAY_SIZE (JpegErrorType_strings))
+          ? JpegErrorType_strings[e]
+          : "* Unknown JpegError code *");
+}
+
+static inline const char *
+get_jpeghw_error_string (unsigned int e)
+{
+  static const char *JpegHWErrorType_strings[] = {
+    "Successfully Decoded", /* JPEG_DECODER_NO_ERROR */
+    "", "", "", "", "", "", "", "",
+    "JPEG_DECODER_ERROR_TASK_TIMEOUT"
+  };
+
+  return ((e < D_ARRAY_SIZE (JpegHWErrorType_strings))
+          ? JpegHWErrorType_strings[e]
+          : "* Unknown JpegHWError code *");
+}
+#endif /* JPEG_PROVIDER_USE_MME */
+
+
+#endif /* __IDIRECTFBIMAGEPROVIDER_JPEG_H__ */
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/interfaces/IDirectFBImageProvider/idirectfbimageprovider_png.c DirectFB-1.4.12+STM2011.09.27/interfaces/IDirectFBImageProvider/idirectfbimageprovider_png.c
--- DirectFB/interfaces/IDirectFBImageProvider/idirectfbimageprovider_png.c	2015-06-02 22:40:08.131541622 +0200
+++ DirectFB-1.4.12+STM2011.09.27/interfaces/IDirectFBImageProvider/idirectfbimageprovider_png.c	2012-06-06 18:41:31.000000000 +0200
@@ -1,4 +1,7 @@
 /*
+   (c) Copyright 2006-2010  ST Microelectronics R&D
+
+based on code:
    (c) Copyright 2001-2010  The world wide DirectFB Open Source Community (directfb.org)
    (c) Copyright 2000-2004  Convergence (integrated media) GmbH
 
@@ -58,10 +61,40 @@
 #include <direct/interface.h>
 #include <direct/mem.h>
 #include <direct/memcpy.h>
+#include <direct/thread.h>
 #include <direct/messages.h>
 #include <direct/util.h>
 
-#include "config.h"
+#if !defined(PNG_PROVIDER_USE_MME)
+#undef USE_MME
+#endif
+
+
+#include "debug_helper.h"
+
+D_DEBUG_DOMAIN (HWPNG,      "PNG",      "STM MME-based PNG decoder");
+D_DEBUG_DOMAIN (HWPNG_MME,  "PNG/MME",  "STM MME-based PNG decoder (MME)");
+D_DEBUG_DOMAIN (HWPNG_SEMA, "PNG/SEMA", "STM MME-based PNG decoder (semaphores");
+D_DEBUG_DOMAIN (HWPNG_TIME, "PNG/Time", "STM MME-based PNG decoder (timing");
+#define MME_DEBUG_DOMAIN  HWPNG_MME
+#define SEMA_DEBUG_DOMAIN HWPNG_SEMA
+#define MME_TEXT_DOMAIN "PNG"
+
+#define fetch_data   buffer_to_mme_copy
+#include "mme_helper.h"
+#include "idirectfbimageprovider_png.h"
+#if defined(PNG_PROVIDER_USE_MME)
+#include "sema_helper.h"
+static DFBResult PNG_HardwareRenderTo( IDirectFBImageProvider_PNG_data *data,
+                                       CoreSurface                     *dst_surface,
+                                       DFBSurfacePixelFormat            format,
+                                       DFBRectangle                    *rect,
+                                       const DFBRegion                 *clip );
+#else /* PNG_PROVIDER_USE_MME */
+#define PNG_HardwareRenderTo(data,dst_surface, \
+                             format, rect, clip) DFB_NOSUCHINSTANCE
+#endif /* PNG_PROVIDER_USE_MME */
+
 
 #if PNG_LIBPNG_VER < 10400 
 #define trans_color  trans_values
@@ -77,8 +110,11 @@
 
 #include <direct/interface_implementation.h>
 
-DIRECT_INTERFACE_IMPLEMENTATION( IDirectFBImageProvider, PNG )
-
+#if defined(PNG_PROVIDER_USE_MME)
+DIRECT_INTERFACE_IMPLEMENTATION( IDirectFBImageProvider, hwPNG )
+#else /* PNG_PROVIDER_USE_MME */
+DIRECT_INTERFACE_IMPLEMENTATION( IDirectFBImageProvider, swPNG )
+#endif /* PNG_PROVIDER_USE_MME */
 
 enum {
      STAGE_ABORT = -2,
@@ -89,31 +125,10 @@
      STAGE_END
 };
 
-/*
- * private data struct of IDirectFBImageProvider_PNG
- */
-typedef struct {
-     IDirectFBImageProvider_data base;
-
-     int                  stage;
-     int                  rows;
-
-     png_structp          png_ptr;
-     png_infop            info_ptr;
-
-     png_uint_32          width;
-     png_uint_32          height;
-     int                  bpp;
-     int                  color_type;
-     png_uint_32          color_key;
-     bool                 color_keyed;
-
-     void                *image;
-     int                  pitch;
-     u32                  palette[256];
-     DFBColor             colors[256];
-} IDirectFBImageProvider_PNG_data;
 
+static DFBResult
+IDirectFBImageProvider_PNG_SetFlags ( IDirectFBImageProvider *thiz,
+                                      DFBImageProviderFlags   flags );
 
 static DFBResult
 IDirectFBImageProvider_PNG_RenderTo( IDirectFBImageProvider *thiz,
@@ -121,6 +136,10 @@
                                      const DFBRectangle     *destination_rect );
 
 static DFBResult
+IDirectFBImageProvider_PNG_Sync( IDirectFBImageProvider    *thiz,
+                                 DFBImageProviderSyncFlags  flags );
+
+static DFBResult
 IDirectFBImageProvider_PNG_GetSurfaceDescription( IDirectFBImageProvider *thiz,
                                                   DFBSurfaceDescription  *dsc );
 
@@ -128,6 +147,10 @@
 IDirectFBImageProvider_PNG_GetImageDescription( IDirectFBImageProvider *thiz,
                                                 DFBImageDescription    *dsc );
 
+static void *
+PNGrenderThread( DirectThread *thread, void *driver_data );
+
+
 /* Called at the start of the progressive load, once we have image info */
 static void
 png_info_callback (png_structp png_read_ptr,
@@ -160,11 +183,31 @@
      IDirectFBImageProvider_PNG_data *data =
                               (IDirectFBImageProvider_PNG_data*)thiz->priv;
 
-     png_destroy_read_struct( &data->png_ptr, &data->info_ptr, NULL );
+     if (data->thread) {
+          /* terminate the decoding thread, if necessary... */
+          direct_thread_cancel( data->thread );
+          direct_thread_join( data->thread );
+          direct_thread_destroy( data->thread );
+
+          pthread_mutex_destroy( &data->lock );
+          pthread_cond_destroy( &data->cond );
+     }
+
+     if (data->png_ptr) {
+          png_destroy_read_struct( &data->png_ptr, &data->info_ptr, NULL );
+          data->png_ptr = NULL;
+     }
 
      /* Deallocate image data. */
-     if (data->image)
-          D_FREE( data->image );
+     if (data->common.image)
+          D_FREE( data->common.image );
+
+#if defined(PNG_PROVIDER_USE_MME)
+     if (data->common.decode_surface) {
+       dfb_gfxcard_wait_serial( &data->common.serial );
+       dfb_surface_unref( data->common.decode_surface );
+     }
+#endif
 }
 
 /**********************************************************************************************************************/
@@ -195,9 +238,9 @@
      core = va_arg( tag, CoreDFB * );
      va_end( tag );
 
-     data->base.ref    = 1;
-     data->base.buffer = buffer;
-     data->base.core   = core;
+     data->common.base.ref    = 1;
+     data->common.base.buffer = buffer;
+     data->common.base.core   = core;
 
      buffer->AddRef( buffer );
 
@@ -223,15 +266,16 @@
                                   png_row_callback,
                                   png_end_callback );
 
-
      /* Read until info callback is called. */
      ret = push_data_until_stage( data, STAGE_INFO, 64 );
      if (ret)
           goto error;
 
-     data->base.Destruct = IDirectFBImageProvider_PNG_Destruct;
+     data->common.base.Destruct = IDirectFBImageProvider_PNG_Destruct;
 
+     thiz->SetFlags              = IDirectFBImageProvider_PNG_SetFlags;
      thiz->RenderTo              = IDirectFBImageProvider_PNG_RenderTo;
+     thiz->Sync                  = IDirectFBImageProvider_PNG_Sync;
      thiz->GetImageDescription   = IDirectFBImageProvider_PNG_GetImageDescription;
      thiz->GetSurfaceDescription = IDirectFBImageProvider_PNG_GetSurfaceDescription;
 
@@ -243,8 +287,8 @@
 
      buffer->Release( buffer );
 
-     if (data->image)
-          D_FREE( data->image );
+     if (data->common.image)
+          D_FREE( data->common.image );
 
      DIRECT_DEALLOCATE_INTERFACE(thiz);
 
@@ -254,43 +298,63 @@
 /**********************************************************************************************************************/
 
 static DFBResult
-IDirectFBImageProvider_PNG_RenderTo( IDirectFBImageProvider *thiz,
-                                     IDirectFBSurface       *destination,
-                                     const DFBRectangle     *dest_rect )
+IDirectFBImageProvider_PNG_SetFlags( IDirectFBImageProvider *thiz,
+                                     DFBImageProviderFlags   flags )
 {
-     DFBResult              ret = DFB_OK;
-     IDirectFBSurface_data *dst_data;
-     CoreSurface           *dst_surface;
-     DFBRegion              clip;
-     DFBRectangle           rect;
-     png_infop              info;
-     int                    x, y;
-     DFBRectangle           clipped;
+     DIRECT_INTERFACE_GET_DATA(IDirectFBImageProvider_PNG)
 
-     DIRECT_INTERFACE_GET_DATA (IDirectFBImageProvider_PNG)
+     /* if we have decoded the image already, don't do anything... */
+     if (data->common.image
+#if defined(PNG_PROVIDER_USE_MME)
+         || data->common.decode_surface
+#endif /* PNG_PROVIDER_USE_MME */
+        )
+          return DFB_UNSUPPORTED;
+
+     if (flags == DIPFLAGS_NONE && data->thread) {
+          /* terminate the decoding thread, if necessary... */
+          direct_thread_cancel( data->thread );
+          direct_thread_join( data->thread );
+          direct_thread_destroy( data->thread );
+          data->thread = NULL;
 
-     info = data->info_ptr;
+          pthread_cond_destroy( &data->cond );
+          pthread_mutex_destroy( &data->lock );
+     }
+     else if (flags == DIPFLAGS_BACKGROUND_DECODE && !data->thread) {
+          /* or create it */
+          pthread_cond_init( &data->cond, NULL );
+          pthread_mutex_init( &data->lock, NULL );
+          /* as long as we haven't even started yet, we are in INIT state */
+          data->thread_res = DFB_INIT;
+          data->thread = direct_thread_create( DTT_DEFAULT, PNGrenderThread,
+                                               thiz, "PNG_DECODER?" );
+     }
+     data->flags = flags;
 
-     dst_data = (IDirectFBSurface_data*) destination->priv;
-     if (!dst_data)
-          return DFB_DEAD;
+     return DFB_OK;
+}
 
-     dst_surface = dst_data->surface;
-     if (!dst_surface)
-          return DFB_DESTROYED;
 
-     dfb_region_from_rectangle( &clip, &dst_data->area.current );
+static DFBResult
+PNG_SoftwareRenderTo( IDirectFBImageProvider_PNG_data *data,
+                      CoreSurface                     *dst_surface,
+                      DFBSurfacePixelFormat            format,
+                      DFBRectangle                    *rect,
+                      const DFBRegion                 *clip )
+{
 
-     if (dest_rect) {
-          if (dest_rect->w < 1 || dest_rect->h < 1)
-               return DFB_INVARG;
-          rect = *dest_rect;
-          rect.x += dst_data->area.wanted.x;
-          rect.y += dst_data->area.wanted.y;
-     }
-     else {
-          rect = dst_data->area.wanted;
-     }
+     DFBResult    ret = DFB_OK;
+     png_infop    info;
+     int          x, y;
+     DFBRectangle clipped;
+
+     D_ASSERT( data != NULL );
+     D_ASSERT( dst_surface != NULL );
+     D_ASSERT( clip != NULL );
+     D_ASSERT( rect != NULL );
+
+     info = data->info_ptr;
 
      if (setjmp( data->png_ptr->jmpbuf )) {
           D_ERROR( "ImageProvider/PNG: Error during decoding!\n" );
@@ -308,22 +372,22 @@
                return ret;
      }
 
-     clipped = rect;
+     clipped = *rect;
 
-     if (!dfb_rectangle_intersect_by_region( &clipped, &clip ))
+     if (!dfb_rectangle_intersect_by_region( &clipped, clip ))
           return DFB_INVAREA;
 
      /* actual rendering */
-     if (rect.w == data->width && rect.h == data->height &&
+     if (rect->w == data->common.width && rect->h == data->common.height &&
          (data->color_type == PNG_COLOR_TYPE_RGB || data->color_type == PNG_COLOR_TYPE_RGBA) &&
          (dst_surface->config.format == DSPF_RGB32 || dst_surface->config.format == DSPF_ARGB) &&
          !(dst_surface->config.caps & DSCAPS_PREMULTIPLIED))
      {
           ret = dfb_surface_write_buffer( dst_surface, CSBR_BACK,
-                                          data->image +
-                                             (clipped.x - rect.x) * 4 +
-                                             (clipped.y - rect.y) * data->width * 4,
-                                          data->width * 4, &clipped );
+                                          data->common.image +
+                                             (clipped.x - rect->x) * 4 +
+                                             (clipped.y - rect->y) * data->common.width * 4,
+                                          data->common.width * 4, &clipped );
      }
      else {
           CoreSurfaceBufferLock lock;
@@ -340,17 +404,17 @@
                           */
 
                          /* FIXME: Limitation for LUT8 is to load complete surface only. */
-                         dfb_clip_rectangle( &clip, &rect );
-                         if (rect.x == 0 && rect.y == 0 &&
-                             rect.w == dst_surface->config.size.w  &&
-                             rect.h == dst_surface->config.size.h &&
-                             rect.w == data->width         &&
-                             rect.h == data->height)
+                         dfb_clip_rectangle( clip, rect );
+                         if (rect->x == 0 && rect->y == 0 &&
+                             rect->w == dst_surface->config.size.w  &&
+                             rect->h == dst_surface->config.size.h &&
+                             rect->w == data->common.width         &&
+                             rect->h == data->common.height)
                          {
-                              for (y=0; y<data->height; y++)
+                              for (y=0; y<data->common.height; y++)
                                    direct_memcpy( lock.addr + lock.pitch * y,
-                                                  data->image + data->pitch * y,
-                                                  data->width );
+                                                  data->common.image + data->pitch * y,
+                                                  data->common.width );
 
                               break;
                          }
@@ -364,8 +428,8 @@
 
                     // FIXME: allocates four additional bytes because the scaling functions
                     //        in src/misc/gfx_util.c have an off-by-one bug which causes
-                    //        segfaults on darwin/osx (not on linux)                
-                    int size = data->width * data->height * 4 + 4;
+                    //        segfaults on darwin/osx (not on linux)
+                    int size = data->common.width * data->common.height * 4 + 4;
 
                     /* allocate image data */
                     void *image_argb = D_MALLOC( size );
@@ -379,7 +443,7 @@
                          if (data->color_type == PNG_COLOR_TYPE_GRAY) {
                               int num = 1 << data->info_ptr->bit_depth;
 
-                              for (x=0; x<num; x++) {
+                              for (x = 0; x < num; x++) {
                                    int value = x * 255 / (num - 1);
 
                                    data->palette[x] = 0xff000000 | (value << 16) | (value << 8) | value;
@@ -388,21 +452,21 @@
 
                          switch (data->info_ptr->bit_depth) {
                               case 8:
-                                   for (y=0; y<data->height; y++) {
-                                        u8  *S = data->image + data->pitch * y;
-                                        u32 *D = image_argb  + data->width * y * 4;
+                                   for (y = 0; y < data->common.height; y++) {
+                                        u8  *S = data->common.image + data->pitch * y;
+                                        u32 *D = image_argb + data->common.width * y * 4;
 
-                                        for (x=0; x<data->width; x++)
+                                        for (x = 0; x < data->common.width; x++)
                                              D[x] = data->palette[ S[x] ];
                                    }
                                    break;
 
                               case 4:
-                                   for (y=0; y<data->height; y++) {
-                                        u8  *S = data->image + data->pitch * y;
-                                        u32 *D = image_argb  + data->width * y * 4;
+                                   for (y = 0; y < data->common.height; y++) {
+                                        u8  *S = data->common.image + data->pitch * y;
+                                        u32 *D = image_argb + data->common.width * y * 4;
 
-                                        for (x=0; x<data->width; x++) {
+                                        for (x = 0; x < data->common.width; x++) {
                                              if (x & 1)
                                                   D[x] = data->palette[ S[x>>1] & 0xf ];
                                              else
@@ -412,12 +476,12 @@
                                    break;
 
                               case 2:
-                                   for (y=0; y<data->height; y++) {
+                                   for (y = 0; y < data->common.height; y++) {
                                         int  n = 6;
-                                        u8  *S = data->image + data->pitch * y;
-                                        u32 *D = image_argb  + data->width * y * 4;
+                                        u8  *S = data->common.image + data->pitch * y;
+                                        u32 *D = image_argb + data->common.width * y * 4;
 
-                                        for (x=0; x<data->width; x++) {
+                                        for (x=0; x < data->common.width; x++) {
                                              D[x] = data->palette[ (S[x>>2] >> n) & 3 ];
 
                                              n = (n ? n - 2 : 6);
@@ -426,12 +490,12 @@
                                    break;
 
                               case 1:
-                                   for (y=0; y<data->height; y++) {
+                                   for (y = 0; y < data->common.height; y++) {
                                         int  n = 7;
-                                        u8  *S = data->image + data->pitch * y;
-                                        u32 *D = image_argb  + data->width * y * 4;
+                                        u8  *S = data->common.image + data->pitch * y;
+                                        u32 *D = image_argb + data->common.width * y * 4;
 
-                                        for (x=0; x<data->width; x++) {
+                                        for (x = 0; x < data->common.width; x++) {
                                              D[x] = data->palette[ (S[x>>3] >> n) & 1 ];
 
                                              n = (n ? n - 1 : 7);
@@ -444,19 +508,20 @@
                                             data->info_ptr->bit_depth );
                          }
 
-                         dfb_scale_linear_32( image_argb, data->width, data->height,
-                                              lock.addr, lock.pitch, &rect, dst_surface, &clip );
- 
+                         dfb_scale_linear_32( image_argb, data->common.width, data->common.height,
+                                              lock.addr, lock.pitch, rect, dst_surface, clip );
+
                          D_FREE( image_argb );
                     }
                     break;
                }
+
                default:
                     /*
                      * Generic loading code.
                      */
-                    dfb_scale_linear_32( data->image, data->width, data->height,
-                                         lock.addr, lock.pitch, &rect, dst_surface, &clip );
+                    dfb_scale_linear_32( data->common.image, data->common.width, data->common.height,
+                                         lock.addr, lock.pitch, rect, dst_surface, clip );
                     break;
           }
 
@@ -469,25 +534,183 @@
      return ret;
 }
 
+
+static DFBResult
+PNG_RenderTo( IDirectFBImageProvider_PNG_data *data,
+              CoreSurface                     *dst_surface,
+              DFBSurfacePixelFormat            format,
+              DFBRectangle                    *rect,
+              const DFBRegion                 *clip )
+{
+     DFBResult res;
+
+     D_ASSERT( data != NULL );
+     D_ASSERT( dst_surface != NULL );
+     D_ASSERT( clip != NULL );
+     D_ASSERT( rect != NULL );
+
+     res = PNG_HardwareRenderTo (data, dst_surface, format, rect, clip);
+     if (res != DFB_OK) {
+          if (unlikely (res == DFB_IO)) {
+               /* IO error - there's no point in retrying */
+               D_DEBUG_AT (HWPNG, "hardware decode failed: %d (%s)\n",
+                           res, DirectFBErrorString (res));
+               return res;
+          }
+
+          if (res == DFB_UNSUPPORTED)
+               D_DEBUG_AT (HWPNG, "doing software decode since it's faster "
+                                  "than hardware for this image\n");
+          else
+               D_DEBUG_AT (HWPNG, "hardware decode failed: %d (%s) - "
+                           "attempting software fallback\n",
+                           res, DirectFBErrorString (res));
+
+          res = PNG_SoftwareRenderTo (data, dst_surface, format, rect, clip);
+          if (unlikely (res != DFB_OK))
+               D_DEBUG_AT (HWPNG, "software decode failed: %d (%s)\n",
+                           res, DirectFBErrorString (res));
+     }
+
+     return res;
+}
+
+static DFBResult
+IDirectFBImageProvider_PNG_RenderTo( IDirectFBImageProvider *thiz,
+                                     IDirectFBSurface       *destination,
+                                     const DFBRectangle     *dest_rect )
+{
+     IDirectFBSurface_data *dst_data;
+     CoreSurface           *dst_surface;
+     DFBSurfacePixelFormat  format;
+     DFBResult              ret;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBImageProvider_PNG)
+
+     dst_data = (IDirectFBSurface_data*) destination->priv;
+     if (!dst_data)
+          return DFB_DEAD;
+
+     dst_surface = dst_data->surface;
+     if (!dst_surface)
+          return DFB_DESTROYED;
+
+     ret = destination->GetPixelFormat( destination, &format );
+     if (ret)
+          return ret;
+
+     if (data->thread)
+          pthread_mutex_lock( &data->lock );
+
+     dfb_region_from_rectangle( &data->clip, &dst_data->area.current );
+
+     if (dest_rect) {
+          if (dest_rect->w < 1 || dest_rect->h < 1) {
+               if (data->thread)
+                    pthread_mutex_unlock (&data->lock);
+               return DFB_INVARG;
+          }
+
+          data->rect = *dest_rect;
+          data->rect.x += dst_data->area.wanted.x;
+          data->rect.y += dst_data->area.wanted.y;
+     }
+     else {
+          data->rect = dst_data->area.wanted;
+     }
+
+     if (!D_FLAGS_IS_SET (data->flags, DIPFLAGS_BACKGROUND_DECODE)) {
+          /* threaded operation was not requested */
+          data->thread_res = PNG_RenderTo( data, dst_surface, format,
+                                           &data->rect, &data->clip );
+          if (data->thread)
+               pthread_mutex_unlock( &data->lock );
+          return data->thread_res;
+     }
+
+     if (!data->thread) {
+          /* for the case that somebody does a RenderTo() twice on us, we
+             have to create new thread, because the initial thread will have
+             finished already */
+
+          D_ASSERT( data->destination == NULL );
+
+          /* as long as we haven't even started yet, we are in INIT state */
+          data->thread_res = DFB_INIT;
+          data->thread = direct_thread_create( DTT_DEFAULT, PNGrenderThread,
+                                               thiz, "PNG" );
+     }
+
+     D_ASSERT( data->destination == NULL );
+
+     destination->AddRef( destination );
+     data->destination = destination;
+
+     pthread_cond_signal( &data->cond );
+     pthread_mutex_unlock( &data->lock );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBImageProvider_PNG_Sync( IDirectFBImageProvider    *thiz,
+                                 DFBImageProviderSyncFlags  flags )
+{
+     DFBResult res;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBImageProvider_PNG)
+
+     switch (flags)
+       {
+       case DIPSYNCFLAGS_TRYSYNC:
+            if (data->thread) {
+                 if (data->thread_res == DFB_INIT
+                     || data->thread_res == DFB_BUSY) {
+                      /* DFB_INIT (user didn't call RenderTo() yet)
+                         DFB_BUSY (still busy decoding) */
+                      return data->thread_res;
+                 }
+                 /* else we are done, either because of some error or because
+                    we have processed all the data already */
+            }
+            /* fall through */
+
+       case DIPSYNCFLAGS_SYNC:
+            if (data->thread) {
+                 direct_thread_join( data->thread );
+                 direct_thread_destroy( data->thread );
+                 data->thread = NULL;
+            }
+            break;
+
+       default:
+            return DFB_OK;
+       }
+
+     res = data->thread_res;
+     data->thread_res = DFB_OK;
+     return res;
+}
+
 static DFBResult
 IDirectFBImageProvider_PNG_GetSurfaceDescription( IDirectFBImageProvider *thiz,
-                                                  DFBSurfaceDescription *dsc )
+                                                  DFBSurfaceDescription  *dsc )
 {
      DFBSurfacePixelFormat primary_format = dfb_primary_layer_pixelformat();
 
      DIRECT_INTERFACE_GET_DATA (IDirectFBImageProvider_PNG)
 
      dsc->flags  = DSDESC_WIDTH | DSDESC_HEIGHT | DSDESC_PIXELFORMAT;
-     dsc->width  = data->width;
-     dsc->height = data->height;
+     dsc->width  = data->common.width;
+     dsc->height = data->common.height;
 
      if (data->color_type & PNG_COLOR_MASK_ALPHA)
           dsc->pixelformat = DFB_PIXELFORMAT_HAS_ALPHA(primary_format) ? primary_format : DSPF_ARGB;
      else
-          dsc->pixelformat = primary_format;
+          dsc->pixelformat = DSPF_RGB24;
 
      if (data->color_type == PNG_COLOR_TYPE_PALETTE) {
-          dsc->flags  |= DSDESC_PALETTE;
+          dsc->flags |= DSDESC_PALETTE;
 
           dsc->palette.entries = data->colors;  /* FIXME */
           dsc->palette.size    = 256;
@@ -521,6 +744,71 @@
      return DFB_OK;
 }
 
+static void
+render_cleanup( void *cleanup_data )
+{
+     IDirectFBImageProvider           *thiz = cleanup_data;
+     IDirectFBImageProvider_PNG_data *data;
+
+     D_MAGIC_ASSERT( (IAny*)thiz, DirectInterface );
+     data = (IDirectFBImageProvider_PNG_data *) thiz->priv;
+     D_ASSERT( data != NULL );
+
+     if (data->destination) {
+          data->destination->Release( data->destination );
+          data->destination = NULL;
+     }
+
+     /* in case we get terminated from outside, set the state to DFB_DEAD */
+     data->thread_res = DFB_DEAD;
+
+     pthread_mutex_unlock( &data->lock );
+}
+
+static void *
+PNGrenderThread( DirectThread *thread, void *driver_data )
+{
+     IDirectFBImageProvider          *thiz = driver_data;
+     IDirectFBImageProvider_PNG_data *data;
+     IDirectFBSurface_data           *dst_data;
+     CoreSurface                     *dst_surface;
+     DFBSurfacePixelFormat            format;
+     DFBResult                        res;
+
+     D_MAGIC_ASSERT( (IAny*)thiz, DirectInterface );
+     data = (IDirectFBImageProvider_PNG_data *) thiz->priv;
+     D_ASSERT( data != NULL );
+
+     pthread_mutex_lock( &data->lock );
+
+     pthread_cleanup_push( render_cleanup, thiz );
+
+     while (!data->destination) {
+          pthread_cond_wait( &data->cond, &data->lock );
+     }
+
+     dst_data = (IDirectFBSurface_data*) data->destination->priv;
+     D_ASSERT( dst_data != NULL );
+
+     dst_surface = dst_data->surface;
+     D_ASSERT( dst_surface != NULL );
+
+     res = data->destination->GetPixelFormat( data->destination, &format );
+     D_ASSERT( res == DFB_OK );
+
+     /* as long as we haven't finished decoding we are busy */
+     data->thread_res = DFB_BUSY;
+
+     res = PNG_RenderTo( data, dst_surface, format, &data->rect, &data->clip );
+
+     pthread_cleanup_pop( 1 );
+
+     /* in case we exit normally, apply the real return value */
+     data->thread_res = res;
+
+     return NULL;
+}
+
 /**********************************************************************************************************************/
 
 #define MAXCOLORMAPSIZE 256
@@ -579,6 +867,8 @@
 {
      int                              i;
      IDirectFBImageProvider_PNG_data *data;
+     png_uint_32 width;
+     png_uint_32 height;
 
      data = png_get_progressive_ptr( png_read_ptr );
 
@@ -590,8 +880,10 @@
      data->stage = STAGE_INFO;
 
      png_get_IHDR( data->png_ptr, data->info_ptr,
-                   &data->width, &data->height, &data->bpp, &data->color_type,
+                   &width, &height, &data->bpp, &data->color_type,
                    NULL, NULL, NULL );
+     data->common.width = width;
+     data->common.height = height;
 
      if (png_get_valid( data->png_ptr, data->info_ptr, PNG_INFO_tRNS )) {
           data->color_keyed = true;
@@ -605,7 +897,7 @@
                                             data->info_ptr->num_palette );
                u8         cmap[3][num_colors];
 
-               for (i=0; i<num_colors; i++) {
+               for (i = 0; i < num_colors; i++) {
                     cmap[0][i] = palette[i].red;
                     cmap[1][i] = palette[i].green;
                     cmap[2][i] = palette[i].blue;
@@ -613,7 +905,7 @@
 
                key = FindColorKey( num_colors, &cmap[0][0] );
 
-               for (i=0; i<data->info_ptr->num_trans; i++) {
+               for (i = 0; i < data->info_ptr->num_trans; i++) {
                     if (!trans[i]) {
                          palette[i].red   = (key & 0xff0000) >> 16;
                          palette[i].green = (key & 0x00ff00) >>  8;
@@ -627,9 +919,9 @@
                /* ...or based on trans rgb value */
                png_color_16p trans = &data->info_ptr->trans_color;
 
-               data->color_key = (((trans->red & 0xff00) << 8) |
-                                  ((trans->green & 0xff00)) |
-                                  ((trans->blue & 0xff00) >> 8));
+               data->color_key = (((trans->red   & 0xff00) << 8) |
+                                  ((trans->green & 0xff00)     ) |
+                                  ((trans->blue  & 0xff00) >> 8));
           }
      }
 
@@ -640,7 +932,7 @@
                int        num_trans  = data->info_ptr->num_trans;
                int        num_colors = MIN( MAXCOLORMAPSIZE, data->info_ptr->num_palette );
 
-               for (i=0; i<num_colors; i++) {
+               for (i = 0; i < num_colors; i++) {
                     data->colors[i].a = (i < num_trans) ? trans[i] : 0xff;
                     data->colors[i].r = palette[i].red;
                     data->colors[i].g = palette[i].green;
@@ -652,12 +944,12 @@
                                                    data->colors[i].b );
                }
 
-               data->pitch = (data->width + 7) & ~7;
+               data->pitch = (data->common.width + 7) & ~7;
                break;
           }
 
           case PNG_COLOR_TYPE_GRAY:
-               data->pitch = data->width;
+               data->pitch = data->common.width;
 
                if (data->bpp == 16)
                     png_set_strip_16( data->png_ptr );
@@ -669,7 +961,7 @@
                /* fall through */
 
           default:
-               data->pitch = data->width * 4;
+               data->pitch = data->common.width * 4;
 
                if (data->bpp == 16)
                     png_set_strip_16( data->png_ptr );
@@ -714,17 +1006,17 @@
      data->stage = STAGE_IMAGE;
 
      /* check image data pointer */
-     if (!data->image) {
+     if (!data->common.image) {
           // FIXME: allocates four additional bytes because the scaling functions
           //        in src/misc/gfx_util.c have an off-by-one bug which causes
-          //        segfaults on darwin/osx (not on linux)                
-          int size = data->pitch * data->height + 4;
+          //        segfaults on darwin/osx (not on linux)
+          int size = data->pitch * data->common.height + 4;
 
           /* allocate image data */
-          data->image = D_CALLOC( 1, size );
-          if (!data->image) {
-               D_ERROR("DirectFB/ImageProvider_PNG: Could not "
-                        "allocate %d bytes of system memory!\n", size);
+          data->common.image = D_CALLOC( 1, size );
+          if (!data->common.image) {
+               D_ERROR( "DirectFB/ImageProvider_PNG: Could not "
+                        "allocate %d bytes of system memory!\n", size );
 
                /* set error stage */
                data->stage = STAGE_ERROR;
@@ -734,20 +1026,20 @@
      }
 
      /* write to image data */
-     png_progressive_combine_row( data->png_ptr, (png_bytep) (data->image +
+     png_progressive_combine_row( data->png_ptr, (png_bytep) (data->common.image +
                                   row_num * data->pitch), new_row );
 
      /* increase row counter, FIXME: interlaced? */
      data->rows++;
 
-     if (data->base.render_callback) {
+     if (data->common.base.render_callback) {
           DIRenderCallbackResult r;
-          DFBRectangle rect = { 0, row_num, data->width, 1 };
+          DFBRectangle rect = { 0, row_num, data->common.width, 1 };
 
-          r = data->base.render_callback( &rect,
-                                          data->base.render_callback_context );
+          r = data->common.base.render_callback( &rect,
+                                                 data->common.base.render_callback_context );
           if (r != DIRCR_OK)
-              data->stage = STAGE_ABORT;
+               data->stage = STAGE_ABORT;
      }
 }
 
@@ -775,7 +1067,7 @@
                        int                              buffer_size)
 {
      DFBResult            ret;
-     IDirectFBDataBuffer *buffer = data->base.buffer;
+     IDirectFBDataBuffer *buffer = data->common.base.buffer;
 
      while (data->stage < stage) {
           unsigned int  len;
@@ -799,11 +1091,11 @@
 
                /* are we there yet? */
                if (data->stage < 0 || data->stage >= stage) {
-                   switch (data->stage) {
-                        case STAGE_ABORT: return DFB_INTERRUPTED;
-                        case STAGE_ERROR: return DFB_FAILURE;
-                        default:          return DFB_OK;
-                   }
+                    switch (data->stage) {
+                         case STAGE_ABORT: return DFB_INTERRUPTED;
+                         case STAGE_ERROR: return DFB_FAILURE;
+                         default:          return DFB_OK;
+                    }
                }
           }
 
@@ -815,3 +1107,710 @@
 
      return DFB_OK;
 }
+
+
+
+#if defined(PNG_PROVIDER_USE_MME)
+static void
+TransformerCallback (MME_Event_t    Event,
+                     MME_Command_t *CallbackData,
+                     void          *UserData)
+{
+  static const char *color_types[] = { "gray", "?", "rgb", "palette",
+                                       "alpha", "?", "rgba" };
+  static const char *interlace_types[] = { "none", "adam7" };
+
+  const PNGDecode_TransformReturnParams_t * const transform_result =
+    CallbackData->CmdStatus.AdditionalInfo_p;
+  const PNGDecode_GlobalTransformReturnParams_t * const global_transform_result =
+    CallbackData->CmdStatus.AdditionalInfo_p;
+  struct _MMECommon * const mme = (struct _MMECommon *) UserData;
+  IDirectFBImageProvider_PNG_data * const data =
+    container_of (mme, IDirectFBImageProvider_PNG_data, common);
+
+  if (!mme->name_set)
+    {
+      char name[20];
+      snprintf (name, sizeof (name), "MME (%s)", mme->transformer_name);
+      direct_thread_set_name (name);
+      mme->name_set = true;
+    }
+
+  D_DEBUG_AT (HWPNG, "%sTransformerCallback: Event: %d: (%s)%s\n",
+              RED, Event, get_mme_event_string (Event), BLACK);
+  D_DEBUG_AT (HWPNG, "  -> CallbackData->CmdStatus.State: %d (%s)\n",
+              CallbackData->CmdStatus.State,
+              get_mme_state_string (CallbackData->CmdStatus.State));
+  D_DEBUG_AT (HWPNG, "  -> CallbackData->CmdStatus.CmdId: %u (%.8x)\n",
+              CallbackData->CmdStatus.CmdId,
+              CallbackData->CmdStatus.CmdId);
+  D_DEBUG_AT (HWPNG, "  -> CallbackData->CmdStatus.Error: %d (%s)\n",
+              CallbackData->CmdStatus.Error,
+              get_mme_error_string (CallbackData->CmdStatus.Error));
+  D_DEBUG_AT (HWPNG, "  -> CallbackData->CmdStatus.AdditionalInfoSize: %u\n",
+              CallbackData->CmdStatus.AdditionalInfoSize);
+  D_DEBUG_AT (HWPNG, "  -> mme->decode_success: %d\n", mme->decode_success);
+
+  switch (Event)
+    {
+    case MME_COMMAND_COMPLETED_EVT:
+      pthread_mutex_lock (&mme->pending_commands_lock);
+      direct_hash_remove (mme->pending_commands,
+                          CallbackData->CmdStatus.CmdId);
+      if (likely (CallbackData->CmdStatus.CmdId != mme->TransformCommand.CmdStatus.CmdId
+                  && CallbackData->CmdStatus.CmdId != data->SetGlobalCommand.CmdStatus.CmdId))
+        --mme->n_pending_buffers;
+      pthread_mutex_unlock (&mme->pending_commands_lock);
+
+      switch (CallbackData->CmdStatus.State)
+        {
+        case MME_COMMAND_COMPLETED:
+          if (unlikely (CallbackData->CmdStatus.CmdId
+                        == mme->TransformCommand.CmdStatus.CmdId))
+            {
+              deb_gettimeofday (&mme->endtime, NULL);
+              deb_timersub (&mme->endtime, &mme->starttime, &mme->endtime);
+              D_DEBUG_AT (HWPNG_TIME, "  -> total time %lu.%06lu\n",
+                          mme->endtime.tv_sec, mme->endtime.tv_usec);
+
+              D_DEBUG_AT (HWPNG, "  -> expanded bytes: %u\n",
+                          transform_result->BytesWritten);
+
+              D_DEBUG_AT (HWPNG, "  -> PNG result code: %d (%s)\n",
+                          transform_result->ErrorType,
+                          get_png_error_string (transform_result->ErrorType));
+
+              if (transform_result->Cycles)
+                {
+                  D_DEBUG_AT (HWPNG, "  -> profiling data: cyc/bu/i/d/n: "
+                                     "%u/%u/%u/%u/%u\n",
+                              transform_result->Cycles,
+                              transform_result->Bundles,
+                              transform_result->ICacheMiss,
+                              transform_result->DCacheMiss,
+                              transform_result->NopBundles);
+                }
+
+              mme->decode_success = 1;
+              sema_signal_event (&mme->decode_event);
+
+              /* in case of bogus data (too much), abort pending data
+                 buffers */
+              abort_transformer (mme);
+            }
+          else if (unlikely (CallbackData->CmdStatus.CmdId
+                             == data->SetGlobalCommand.CmdStatus.CmdId))
+            {
+              D_DEBUG_AT (HWPNG, "  -> size: %ux%u @ %ubpp\n",
+                          global_transform_result->PictureWidth,
+                          global_transform_result->PictureHeight,
+                          global_transform_result->BitDepth);
+              D_DEBUG_AT (HWPNG, "  -> ColorType      : %d (%s)\n",
+                          global_transform_result->ColorType,
+                          (global_transform_result->ColorType
+                           < D_ARRAY_SIZE (color_types))
+                          ? color_types[global_transform_result->ColorType]
+                          : "?" );
+              D_DEBUG_AT (HWPNG, "  -> InterlaceType  : %d (%s)\n",
+                          global_transform_result->InterlaceType,
+                          (global_transform_result->InterlaceType
+                           < D_ARRAY_SIZE (interlace_types))
+                          ? interlace_types[global_transform_result->InterlaceType]
+                          : "?");
+              D_DEBUG_AT (HWPNG, "  -> CompressionType: %d\n", global_transform_result->CompressionType);
+              D_DEBUG_AT (HWPNG, "  -> FilterMethod   : %d\n", global_transform_result->FilterMethod);
+              D_DEBUG_AT (HWPNG, "  -> ErrorType      : %d (%s)\n", global_transform_result->ErrorType, get_png_error_string (global_transform_result->ErrorType));
+
+              D_DEBUG_AT (HWPNG, "  -> ColorFormatOutput: %d\n", global_transform_result->ColorFormatOutput);
+              D_DEBUG_AT (HWPNG, "  -> ColorKey: %c\n", global_transform_result->HaveColorKey ? 'y' : 'n');
+              if (global_transform_result->HaveColorKey)
+                  D_DEBUG_AT (HWPNG, "  -> ColorKey (xRGB): %.6x\n", global_transform_result->ColorKey);
+              D_DEBUG_AT (HWPNG, "  -> pitch: %d\n", global_transform_result->pitch);
+
+              sema_signal_event (&data->global_event);
+            }
+          else
+            {
+              /* buffer completed */
+              struct _MMEHelper_buffer *buf =
+                container_of (CallbackData->DataBuffers_p,
+                              struct _MMEHelper_buffer, buffer);
+
+              D_DEBUG_AT (HWPNG, "  -> buffer %p completed (container @ %p)\n",
+                          CallbackData->DataBuffers_p[0], buf);
+
+              sema_signal_event (&buf->sema);
+            }
+          break; /* MME_COMMAND_COMPLETED */
+
+        case MME_COMMAND_FAILED:
+          if (CallbackData->CmdStatus.Error != MME_COMMAND_ABORTED)
+            D_WARN ("(%5d) %s: command %u (%.8x) failed: error %d (%s)",
+                    direct_gettid (), mme->name,
+                    CallbackData->CmdStatus.CmdId,
+                    CallbackData->CmdStatus.CmdId,
+                    CallbackData->CmdStatus.Error,
+                    get_mme_error_string (CallbackData->CmdStatus.Error));
+
+          if (likely (CallbackData->CmdStatus.CmdId
+                      == mme->TransformCommand.CmdStatus.CmdId))
+            {
+              /* transform command failed */
+              D_DEBUG_AT (HWPNG, "  -> transform->ErrorType: %d (%s)\n",
+                          transform_result->ErrorType,
+                          get_png_error_string (transform_result->ErrorType));
+
+              mme->decode_success = -1;
+              sema_signal_event (&mme->decode_event);
+            }
+          else if (likely (CallbackData->CmdStatus.CmdId
+                   == data->SetGlobalCommand.CmdStatus.CmdId))
+            {
+              /* global transform params command failed */
+              D_DEBUG_AT (HWPNG, "  -> global->ErrorType: %d (%s)\n",
+                          global_transform_result->ErrorType,
+                          get_png_error_string (global_transform_result->ErrorType));
+
+              mme->decode_success = -1;
+              sema_signal_event (&data->global_event);
+            }
+          else
+            {
+              /* buffer failed */
+              struct _MMEHelper_buffer *buf =
+                container_of (CallbackData->DataBuffers_p,
+                              struct _MMEHelper_buffer, buffer);
+              if (mme->decode_success == 0)
+                /* only if we didn't succeed yet */
+                mme->decode_success = -1;
+              sema_signal_event (&buf->sema);
+            }
+          break; /* MME_COMMAND_FAILED */
+
+        case MME_COMMAND_IDLE:
+        case MME_COMMAND_PENDING:
+        case MME_COMMAND_EXECUTING:
+        default:
+          D_WARN ("(%5d) %s: command %u (%.8x) completed in unknown state: %d (%s)",
+                  direct_gettid (), mme->name,
+                  CallbackData->CmdStatus.CmdId, CallbackData->CmdStatus.CmdId,
+                  CallbackData->CmdStatus.State,
+                  get_mme_state_string (CallbackData->CmdStatus.State));
+          break;
+        }
+      break; /* MME_COMMAND_COMPLETED_EVT */
+
+    case MME_DATA_UNDERFLOW_EVT:
+      ++mme->n_underflows;
+      {
+      /* check if the IDirectFBDataBuffer definitely(!) hit an EOF and
+         we have no buffers queued */
+      bool end_of_data;
+      char tmp;
+      pthread_mutex_lock (&mme->pending_commands_lock);
+      DFBResult has_data = mme->base.buffer->PeekData (mme->base.buffer,
+                                                       1, 0, &tmp, NULL);
+      /* n_pending_buffers is checked to be == 0 because the
+         TransformCommand itself is not stored in there. */
+      end_of_data = (has_data == DFB_EOF
+                     && mme->n_pending_buffers == 0);
+      pthread_mutex_unlock (&mme->pending_commands_lock);
+
+      /* if so, signal completion */
+      if (end_of_data)
+        {
+          D_DEBUG_AT (HWPNG, "  -> no more data available, signalling fail\n");
+          mme->decode_success = -2;
+          sema_signal_event (&mme->decode_event);
+        }
+      }
+      break; /* MME_DATA_UNDERFLOW_EVT */
+
+    case MME_NOT_ENOUGH_MEMORY_EVT:
+    case MME_NEW_COMMAND_EVT:
+    default:
+      D_WARN ("(%5d) %s: unhandled event %d (%s) occured on command %u (%.8x)",
+              direct_gettid (), mme->name, Event,
+              get_mme_event_string (Event), CallbackData->CmdStatus.CmdId,
+              CallbackData->CmdStatus.CmdId);
+
+      D_WARN ("(%5d) %s: CallbackData->CmdStatus.AdditionalInfoSize: %u",
+              direct_gettid (), mme->name, CallbackData->CmdStatus.AdditionalInfoSize);
+
+      if (CallbackData->CmdStatus.CmdId == mme->TransformCommand.CmdStatus.CmdId)
+        {
+          D_WARN ("(%5d) %s: transform_result->bytes_written: %u",
+                  direct_gettid (), mme->name, transform_result->BytesWritten);
+          D_WARN ("(%5d) %s: result code: %d (%s)\n", direct_gettid (),
+                  mme->name, transform_result->ErrorType,
+                  get_png_error_string (transform_result->ErrorType));
+        }
+      else if (CallbackData->CmdStatus.CmdId == data->SetGlobalCommand.CmdStatus.CmdId)
+        {
+          D_WARN ("(%5d) %s: size: %ux%u @ %ubpp\n",
+                  direct_gettid (), mme->name,
+                  global_transform_result->PictureWidth,
+                  global_transform_result->PictureHeight,
+                  global_transform_result->BitDepth);
+          D_WARN ("(%5d) %s: ColorType      : %d (%s)\n",
+                  direct_gettid (), mme->name,
+                  global_transform_result->ColorType,
+                  (global_transform_result->ColorType
+                   < D_ARRAY_SIZE (color_types))
+                  ? color_types[global_transform_result->ColorType]
+                  : "?" );
+          D_WARN ("(%5d) %s: InterlaceType  : %d (%s)\n",
+                  direct_gettid (), mme->name,
+                  global_transform_result->InterlaceType,
+                      (global_transform_result->InterlaceType
+                       < D_ARRAY_SIZE (interlace_types))
+                      ? interlace_types[global_transform_result->InterlaceType]
+                      : "?");
+          D_WARN ("(%5d) %s: CompressionType: %d\n", direct_gettid (), mme->name, global_transform_result->CompressionType);
+          D_WARN ("(%5d) %s: FilterMethod   : %d\n", direct_gettid (), mme->name, global_transform_result->FilterMethod);
+          D_WARN ("(%5d) %s: ErrorType      : %d (%s)\n", direct_gettid (), mme->name, global_transform_result->ErrorType, get_png_error_string (global_transform_result->ErrorType));
+
+          D_DEBUG_AT (HWPNG, "  -> ColorFormatOutput: %d\n", global_transform_result->ColorFormatOutput);
+          D_DEBUG_AT (HWPNG, "  -> ColorKey: %c\n", global_transform_result->HaveColorKey ? 'y' : 'n');
+          if (global_transform_result->HaveColorKey)
+              D_DEBUG_AT (HWPNG, "  -> ColorKey (xRGB): %.6x\n", global_transform_result->ColorKey);
+          D_DEBUG_AT (HWPNG, "  -> pitch: %d\n", global_transform_result->pitch);
+        }
+      break;
+    }
+}
+
+
+/* warning: MME_AbortCommand() works only for the MME_TRANSFORM command;
+   individual buffers can be aborted, too, but MME_TermTransformer() will
+   not work afterwards anymore! */
+static bool
+pending_fe_func (DirectHash    *hash,
+                 unsigned long  key,
+                 void          *value,
+                 void          *ctx)
+{
+  struct _MMECommon * const mme = ctx;
+  IDirectFBImageProvider_PNG_data * const data =
+    container_of (mme, IDirectFBImageProvider_PNG_data, common);
+  MME_CommandId_t    CmdId = key;
+
+  D_DEBUG_AT (HWPNG, "aborting %s command %u (%.8x)\n",
+              ((CmdId == mme->TransformCommand.CmdStatus.CmdId)
+               ? "(main transform)"
+               : ((CmdId == data->SetGlobalCommand.CmdStatus.CmdId)
+                  ? "(global)"
+                  : "(buffer)"
+                 )
+              ), CmdId, CmdId);
+
+  MME_ERROR res = MME_AbortCommand (mme->Handle, CmdId);
+  if (res != MME_SUCCESS)
+    {
+      /* this would mean the command is about to finish, but we didn't
+         notice yet... */
+      D_WARN ("(%5d) MME_AbortCommand(%x, %.8x) for %s failed: %d (%s)\n",
+              direct_gettid (), mme->Handle, CmdId,
+              mme->name, res, get_mme_error_string (res));
+    }
+
+  /* continue iterating */
+  return true;
+}
+
+static DFBResult
+abort_transformer (struct _MMECommon * const mme)
+{
+  if (!mme)
+       return DFB_THIZNULL;
+
+  /* FIXME: what about locking? */
+  direct_hash_iterate (mme->pending_commands,
+                       pending_fe_func,
+                       mme);
+
+  return DFB_OK;
+}
+
+
+static DFBResult
+set_global_transform_params (IDirectFBImageProvider_PNG_data *data)
+{
+  MME_ERROR ret;
+
+  data->SetGlobalCommand.StructSize          = sizeof (MME_Command_t);
+  data->SetGlobalCommand.CmdCode             = MME_SET_GLOBAL_TRANSFORM_PARAMS;
+  data->SetGlobalCommand.CmdEnd              = MME_COMMAND_END_RETURN_NOTIFY;
+  data->SetGlobalCommand.DueTime             = (MME_Time_t) 0;
+  data->SetGlobalCommand.NumberInputBuffers  = 0;
+  data->SetGlobalCommand.NumberOutputBuffers = 0;
+  data->SetGlobalCommand.DataBuffers_p       = NULL;
+
+  /* clear the commandstatus from the previous run */
+  memset (&( data->SetGlobalCommand.CmdStatus), 0, sizeof (MME_CommandStatus_t));
+
+  data->SetGlobalCommand.CmdStatus.AdditionalInfoSize = sizeof (PNGDecode_GlobalTransformReturnParams_t);
+  data->SetGlobalCommand.CmdStatus.AdditionalInfo_p = &data->GlobalReturnParams;
+
+  data->SetGlobalCommand.NumberInputBuffers = 0;
+  data->SetGlobalCommand.NumberOutputBuffers = 0;
+
+  /* set parameters - just settings flags to 0 should make this compatible
+     with old transformer versions, 0 means PNGDECODE_OF_EXPAND */
+//  data->GlobalParams.flags = PNGDECODE_PARAM_FORMAT;
+//  data->GlobalParams.format = PNGDECODE_OF_EXPAND;
+//  data->SetGlobalCommand.ParamSize = sizeof (PNGDecode_GlobalParams_t);
+//  data->SetGlobalCommand.Param_p   = &data->GlobalParams;
+  data->SetGlobalCommand.ParamSize = 0;
+  data->SetGlobalCommand.Param_p   = NULL;
+
+  D_DEBUG_AT (HWPNG, "sending global command\n");
+
+  pthread_mutex_lock (&data->common.pending_commands_lock);
+  ret = MME_SendCommand (data->common.Handle, &data->SetGlobalCommand);
+  if (ret != MME_SUCCESS)
+    {
+      pthread_mutex_unlock (&data->common.pending_commands_lock);
+      D_INFO ("%s: MME_SendCommand() failed: %d (%s)\n",
+              data->common.name, ret, get_mme_error_string (ret));
+      return DFB_FAILURE;
+    }
+
+  direct_hash_insert (data->common.pending_commands,
+                      data->SetGlobalCommand.CmdStatus.CmdId,
+                      (void *) 1);
+  D_DEBUG_AT (HWPNG, "sent packet's CmdId is %u (%.8x)\n",
+              data->SetGlobalCommand.CmdStatus.CmdId,
+              data->SetGlobalCommand.CmdStatus.CmdId);
+  pthread_mutex_unlock (&data->common.pending_commands_lock);
+
+  return DFB_OK;
+}
+
+
+static void
+_imageprovider_update_transform_params (struct _MMECommon           * const mme,
+                                        void                        * const params,
+                                        const CoreSurfaceBufferLock * const lock)
+{
+  IDirectFBImageProvider_PNG_data * const data =
+    container_of (mme, IDirectFBImageProvider_PNG_data, common);
+
+  if (data->GlobalReturnParams.pitch != lock->pitch)
+    {
+      PNGDecode_TransformParams_t * const p = params;
+
+      p->flags |= PNGDECODE_PARAM_PITCH;
+      p->pitch = lock->pitch;
+    }
+}
+
+
+#define HWREND_THRESHOLD 20000
+
+static pthread_mutex_t transformer_index_mutex = PTHREAD_MUTEX_INITIALIZER;
+static unsigned int transformer_index;
+static DFBResult
+PNG_HardwareRenderTo( IDirectFBImageProvider_PNG_data *data,
+                      CoreSurface                     *dst_surface,
+                      DFBSurfacePixelFormat            format,
+                      DFBRectangle                    *rect,
+                      const DFBRegion                 *clip )
+{
+  DFBResult              dfbret = dfbret;
+  CoreSurfaceBufferLock  lock;
+  unsigned int           bufpos = 0;
+
+  D_ASSERT( data != NULL );
+  D_ASSERT( dst_surface != NULL);
+  D_ASSERT( rect != NULL );
+  D_ASSERT( clip != NULL );
+
+  /* FIXME: check if the image is big enough to warrant a HW decode */
+  if ((dst_surface->config.size.w * dst_surface->config.size.h) < HWREND_THRESHOLD)
+    return DFB_UNSUPPORTED;
+
+  /* only decode if we haven't decoded before */
+  if (data->common.decode_success <= 0)
+    {
+      MME_TransformerCapability_t cap;
+      bool                        surface_locked = false;
+
+      data->common.name = "hwPNG";
+      static const char  *transformers0[] = { PNGDECODER_MME_TRANSFORMER_NAME"0", NULL };
+      static const char  *transformers1[] = { PNGDECODER_MME_TRANSFORMER_NAME"1", NULL };
+      static const char  *transformers2[] = { PNGDECODER_MME_TRANSFORMER_NAME"2", NULL };
+      static const char  *transformers3[] = { PNGDECODER_MME_TRANSFORMER_NAME"3", NULL };
+      static const char  *transformers4[] = { PNGDECODER_MME_TRANSFORMER_NAME"4", NULL };
+      static const char  *transformers5[] = { PNGDECODER_MME_TRANSFORMER_NAME, NULL };
+      static const char **transformers[] = { transformers0, transformers1,
+                                             transformers2, transformers3,
+                                             transformers4, transformers5 };
+
+      unsigned i;
+      transformer_index = -1;
+      pthread_mutex_lock (&transformer_index_mutex);
+      for (i = 0; i < D_ARRAY_SIZE (transformers); ++i)
+        {
+          ++transformer_index;
+          transformer_index %= D_ARRAY_SIZE (transformers);
+
+          PNGDecode_InitTransformerParams_t png_init;
+          png_init.flags = PNGDECODE_PARAM_FORMAT;
+          png_init.format = PNGDECODE_OF_EXPAND;
+          dfbret = mme_helper_init_transformer (&data->common,
+                                                transformers[transformer_index],
+                                                sizeof (png_init),
+                                                &png_init, NULL);
+          if (dfbret == DFB_OK)
+            {
+              /* need to init this because old transformer versions didn't
+                 touch it at all. */
+              cap.Version = 0;
+              _mme_helper_get_capability (&data->common,
+                                          *transformers[transformer_index],
+                                          &cap);
+
+              if (cap.Version != 11)
+                {
+                  /* incompatible with old transformer, it has just way too
+                     many bugs! */
+                  mme_helper_deinit_transformer (&data->common);
+                  dfbret = DFB_FAILURE;
+                  continue;
+                }
+
+              data->common.transformer_name = *transformers[transformer_index];
+              if (data->flags & DIPFLAGS_BACKGROUND_DECODE)
+                direct_thread_set_name (*transformers[transformer_index]);
+
+              break;
+            }
+        }
+      pthread_mutex_unlock (&transformer_index_mutex);
+
+      if (dfbret != DFB_OK)
+        return dfbret;
+
+      sema_init_event (&data->common.decode_event, 0); /* Alerts to completion */
+      sema_init_event (&data->global_event, 0);
+
+      {
+      /* store the current data buffer position for software fallback should
+         we not succeed */
+      data->common.base.buffer->GetPosition (data->common.base.buffer,
+                                             &bufpos);
+
+      /* as an optimization we first send one packet, otherwise
+         SET_GLOBAL_TRANSFORM_COMMAND would through a data underflow event */
+      mme_helper_calculate_packets (&data->common);
+      dfbret = mme_helper_send_packets (&data->common, 1);
+      if (dfbret != DFB_OK)
+        goto err_abort_commands;
+
+      dfbret = set_global_transform_params (data);
+      if (dfbret != DFB_OK)
+        goto err_abort_commands;
+
+      D_DEBUG_AT (HWPNG, "  -> waiting for global transform to finish\n");
+      while ((sema_wait_event (&data->global_event) == -1)
+             && errno == EINTR)
+        ;
+      D_DEBUG_AT (HWPNG, "    -> global transform finished (failed: %c)\n",
+                  (data->common.decode_success != 0) ? 'y' : 'n');
+
+      /* the transformer encountered an error */
+      if (data->common.decode_success != 0)
+        {
+          dfbret = DFB_FAILURE;
+          goto err_abort_commands;
+        }
+
+      if (!data->common.decode_surface)
+        {
+          /* create a destination surface to MME-decode the image onto before
+             stretchblit ... and if we can't create a surface in video
+             memory then we can't blit */
+          CoreSurfaceConfig  config;
+          CorePalette       *palette = NULL;
+
+          switch (data->GlobalReturnParams.ColorFormatOutput)
+            {
+            case PNGDECODE_COLOR_TYPE_PALETTE:
+              config.format = DSPF_LUT8;
+
+              dfbret = dfb_palette_create (data->common.base.core,
+                                           256, &palette);
+              if (dfbret != DFB_OK)
+                goto err_abort_commands;
+
+              direct_memcpy (palette->entries,
+                             data->GlobalReturnParams.palette,
+                             256 * sizeof (DFBColor));
+              dfb_palette_update (palette, 0, 256 - 1);
+              break;
+
+            case PNGDECODE_COLOR_TYPE_RGB:
+              config.format = DSPF_RGB24;
+              break;
+
+            case PNGDECODE_COLOR_TYPE_RGB_ALPHA:
+            default:
+              config.format = DSPF_ARGB;
+              break;
+            }
+          config.flags = CSCONF_SIZE | CSCONF_FORMAT | CSCONF_CAPS;
+          config.size.w = data->common.width;
+          config.size.h = data->common.height;
+          config.caps   = DSCAPS_VIDEOONLY;
+          #ifdef DIRECT_BUILD_DEBUG
+          config.caps   |= DSCAPS_SHARED;
+          #endif
+
+          dfbret = dfb_surface_create (data->common.base.core, &config,
+                                       CSTF_NONE, 0, palette,
+                                       &data->common.decode_surface);
+          if (palette)
+            dfb_palette_unref (palette);
+
+          if (dfbret != DFB_OK)
+            goto err_abort_commands;
+        }
+
+      /* tell the transformer what to do and where to put the result */
+      data->TransformParams.flags = 0;
+      dfbret = mme_helper_start_transformer (&data->common,
+                                             sizeof (data->ReturnParams),
+                                             &data->ReturnParams,
+                                             sizeof (data->TransformParams),
+                                             &data->TransformParams,
+                                             data->common.decode_surface,
+                                             &lock);
+      if (dfbret != DFB_OK)
+        {
+          D_DEBUG_AT (HWPNG, "couldn't start transformer\n");
+          goto err_abort_commands;
+        }
+
+      surface_locked = true;
+
+      /* Now send the rest of the data */
+      D_DEBUG_AT (HWPNG, "Transform sent, sending data buffers now\n");
+      dfbret = mme_helper_send_packets (&data->common, -1);
+      if (dfbret != DFB_OK)
+        {
+          D_DEBUG_AT (HWPNG, "couldn't send all buffers\n");
+          goto err_abort_commands;
+        }
+
+      /* wait until the decode is complete */
+      D_DEBUG_AT (HWPNG, "waiting for completion\n");
+      while ((sema_wait_event (&data->common.decode_event) == -1)
+             && errno == EINTR)
+        ;
+      /* the transformer encountered an error */
+      if (data->common.decode_success != 1)
+        {
+          dfbret = DFB_FAILURE;
+          goto err_abort_commands;
+        }
+      }
+
+err_abort_commands:
+      {
+        /* we need to do this explicitly here because the generic code will
+           not call abort_transformer() if no TransformCommand is pending.
+           Unfortunately in the PNG case, we always send a buffer before the
+           transform command. This buffer would otherwise not be aborted.
+           Should probably change the code to be more in line with JPEG. */
+        abort_transformer (&data->common);
+        /* wait till all commands are aborted and acknowledged */
+        while (data->common.n_pending_buffers
+               || direct_hash_lookup (data->common.pending_commands,
+                                      data->common.TransformCommand.CmdStatus.CmdId))
+          usleep (1);
+
+      if (surface_locked)
+        {
+          mme_helper_deinit_transformer (&data->common);
+
+          dfb_surface_unlock_buffer (data->common.decode_surface, &lock);
+        }
+
+
+      if (data->common.OutDataBuffers)
+        {
+          D_FREE (data->common.OutDataBuffers);
+          data->common.OutDataBuffers = NULL;
+        }
+
+      unsigned int i;
+      for (i = 0; i < D_ARRAY_SIZE (data->common.SendDataBuffers); ++i)
+        {
+          if (data->common.SendDataBuffers[i].buffer)
+            {
+              MME_FreeDataBuffer (data->common.SendDataBuffers[i].buffer);
+              data->common.SendDataBuffers[i].buffer = NULL;
+
+              sema_close_event (&data->common.SendDataBuffers[i].sema);
+            }
+        }
+
+      sema_close_event (&data->common.decode_event);
+      sema_close_event (&data->global_event);
+
+      if (data->common.decode_success != 1)
+        {
+          /* if we saw corrupt data, there's no point in trying libpng, just
+             display the result as far as possible. */
+          if (data->common.TransformCommand.CmdStatus.State == MME_COMMAND_FAILED
+              && data->common.TransformCommand.CmdStatus.Error == MME_INVALID_ARGUMENT)
+            {
+              const PNGDecode_TransformReturnParams_t * __restrict r =
+                &data->ReturnParams;
+
+              switch (r->ErrorType)
+                {
+                case PNGDECODE_CRC_ERROR:
+                case PNGDECODE_INVALID_STREAM:
+                case PNGDECODE_STREAM_ERROR:
+                  /* just assume invalid data and display what we have */
+                  D_DEBUG_AT (HWPNG, "faking success due to corrupt data\n");
+                  data->common.decode_success = 1;
+
+                default:
+                  break;
+                }
+            }
+          else if (dfbret == DFB_IO)
+            {
+              D_DEBUG_AT (HWPNG, "faking success due to EOF\n");
+              dfbret = DFB_OK;
+              data->common.decode_success = 1;
+            }
+
+          if (data->common.decode_success != 1)
+            data->common.base.buffer->SeekTo (data->common.base.buffer,
+                                              bufpos);
+        }
+      }
+    }
+
+
+  if (data->common.decode_success == 1)
+    {
+      /* stretch blit the decoded image to the destination surface and size */
+      mme_helper_stretch_blit (&data->common, data->common.decode_surface,
+                               dst_surface, rect);
+      dfbret = DFB_OK;
+
+      if (data->GlobalReturnParams.HaveColorKey)
+        {
+          data->color_keyed = true;
+          data->color_key = data->GlobalReturnParams.ColorKey;
+        }
+    }
+
+  return dfbret;
+}
+#endif /* PNG_PROVIDER_USE_MME */
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/interfaces/IDirectFBImageProvider/idirectfbimageprovider_png.h DirectFB-1.4.12+STM2011.09.27/interfaces/IDirectFBImageProvider/idirectfbimageprovider_png.h
--- DirectFB/interfaces/IDirectFBImageProvider/idirectfbimageprovider_png.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/interfaces/IDirectFBImageProvider/idirectfbimageprovider_png.h	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,83 @@
+#ifndef __IDIRECTFBIMAGEPROVIDER_PNG_H__
+#define __IDIRECTFBIMAGEPROVIDER_PNG_H__
+
+#if defined(PNG_PROVIDER_USE_MME)
+/* HW Decode Requirements */
+#include <mme.h>
+#include <semaphore.h>
+
+#define PNGDEC_MME_VERSION 11
+#define PNGDECODE_PROFILING_ENABLE
+#include <PNGDecode_interface.h>
+#endif /* PNG_PROVIDER_USE_MME */
+
+
+/* private data struct of IDirectFBImageProvider_PNG */
+typedef struct
+{
+  struct _MMECommon common;
+
+  png_structp       png_ptr;
+  png_infop         info_ptr;
+
+  int               stage;
+  int               rows;
+
+  int               bpp;
+  int               color_type;
+  png_uint_32       color_key;
+  bool              color_keyed;
+
+  int               pitch;
+  u32               palette[256];
+  DFBColor          colors[256];
+
+  DFBRectangle      rect;
+  DFBRegion         clip;
+
+  /* thread stuff */
+  DFBImageProviderFlags flags;
+  pthread_mutex_t   lock;
+  pthread_cond_t    cond;
+  DirectThread     *thread;
+  IDirectFBSurface *destination;
+  DFBResult         thread_res;
+
+#if defined(PNG_PROVIDER_USE_MME)
+  PNGDecode_TransformParams_t       TransformParams;
+  PNGDecode_TransformReturnParams_t ReturnParams;
+
+  PNGDecode_GlobalTransformReturnParams_t GlobalReturnParams;
+
+  MME_Command_t SetGlobalCommand;
+
+  sem_t global_event;
+#endif /* PNG_PROVIDER_USE_MME */
+} IDirectFBImageProvider_PNG_data;
+
+
+
+#if defined(PNG_PROVIDER_USE_MME)
+/****************************************************************************/
+static inline const char *
+get_png_error_string (PNGDecode_ErrorCodes_t e)
+{
+  static const char *PNGErrorType_strings[] = {
+    "PNGDECODE_NO_ERROR",
+    "PNGDECODE_MEMEORY_ALLOCATION_ERROR",
+    "PNGDECODE_CRC_ERROR",
+    "PNGDECODE_INVALID_STREAM",
+    "PNGDECODE_INTERNAL_ERROR",
+    "PNGDECODE_INVALID_ARGUMENT",
+    "PNGDECODE_STREAM_ERROR"
+  };
+
+  return (((unsigned int) e) < D_ARRAY_SIZE (PNGErrorType_strings))
+         ? PNGErrorType_strings[e]
+         : "* Unknown PngError code *";
+}
+#endif /* PNG_PROVIDER_USE_MME */
+
+
+
+#endif /* __IDIRECTFBIMAGEPROVIDER_PNG_H__ */
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/interfaces/IDirectFBImageProvider/idirectfbimageprovider_rle.c DirectFB-1.4.12+STM2011.09.27/interfaces/IDirectFBImageProvider/idirectfbimageprovider_rle.c
--- DirectFB/interfaces/IDirectFBImageProvider/idirectfbimageprovider_rle.c	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/interfaces/IDirectFBImageProvider/idirectfbimageprovider_rle.c	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,2259 @@
+/*
+ * Copyright (C) 2006-2009 ST-Microelectronics R&D
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+//#define DIRECT_ENABLE_DEBUG
+
+#include <config.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <directfb.h>
+
+#include <core/coredefs.h>
+#include <core/coretypes.h>
+
+#include <gfx/convert.h>
+
+#include <misc/gfx_util.h>
+#include <misc/util.h>
+
+#include <direct/types.h>
+#include <direct/messages.h>
+#include <direct/mem.h>
+#include <direct/memcpy.h>
+#include <direct/interface.h>
+
+#include <display/idirectfbsurface.h>
+#include <media/idirectfbimageprovider.h>
+
+#if defined(RLE_PROVIDER_HW)
+#include <sys/ioctl.h>
+#include <fbdev/fbdev.h>
+#include <linux/stmfb.h>
+#endif
+
+/*******************************************************************************
+ *
+ *                      TYPES DEFINITION SECTION
+ *
+ *******************************************************************************/
+//#define PERFORMANCE_MONITORING
+#define ALLOW_FORCE_SOFTWARE
+#define ALLOW_DUMP_RAW_TO_FILE
+
+#define MAX_STREAMING_COMMANDS          1
+#define MME_STREAMING_BUFFERSIZE        (1024 * 1024) /* Maximum size */
+
+D_DEBUG_DOMAIN (HWRLE,      "RLE",      "STM hardware-/MME- based RLE decoder");
+D_DEBUG_DOMAIN (HWRLE_MME,  "RLE/MME",  "STM MME-based RLE decoder (MME)");
+D_DEBUG_DOMAIN (HWRLE_SEMA, "RLE/SEMA", "STM MME-based RLE decoder (semaphores");
+D_DEBUG_DOMAIN (HWRLE_TIME, "RLE/Time", "STM MME-based RLE decoder (timing");
+#define MME_DEBUG_DOMAIN  HWRLE_MME
+#define SEMA_DEBUG_DOMAIN HWRLE_SEMA
+#define MME_TEXT_DOMAIN "RLE"
+
+#include "debug_helper.h"
+#define fetch_data   buffer_to_mme_copy
+struct _MMECommon;
+static void
+_imageprovider_update_transform_params (struct _MMECommon           * const mme,
+                                        void                        * const params,
+                                        const CoreSurfaceBufferLock * const lock)
+{
+}
+#include "mme_helper.h"
+#include "sema_helper.h"
+#include "idirectfbimageprovider_rle.h"
+
+
+/*******************************************************************************
+ *
+ *                      INTERFACE DEFINITION SECTION
+ *
+ *******************************************************************************/
+
+static DFBResult Probe( IDirectFBImageProvider_ProbeContext *ctx );
+
+static DFBResult Construct( IDirectFBImageProvider *thiz,
+                            ... );
+
+#include <direct/interface_implementation.h>
+
+DIRECT_INTERFACE_IMPLEMENTATION( IDirectFBImageProvider, RLE )
+
+
+/*******************************************************************************
+ *
+ *                      PRIVATE STATIC SECTION     (Little-Endian specific code)
+ *
+ *******************************************************************************/
+
+static u8
+rle_input_byte (const u8 ** const pptr,
+                const u8  * const end)
+{
+  return (*pptr < end) ? *(*pptr)++ : 0;
+}
+
+static void
+rle_output_byte (u8       ** const pptr,
+                 const u8  * const end,
+                 u8         byte)
+{
+  if (*pptr < end)
+    *(*pptr)++ = byte;
+}
+
+static u8 *
+rle_set_position (u8   * const ptr,
+                  uint  x,
+                  uint  y,
+                  uint  w,
+                  uint  h,
+                  uint  top)
+{
+  return &ptr[( x + (top ? y : (h-1-y)) * w)];
+}
+
+
+
+static u16
+read_le_16 (const u8 ** const pptr)
+{
+  const u8 * const ptr = *pptr;
+  *pptr += 2;
+  return (ptr[1] << 8) | ptr[0];
+}
+
+static u32
+read_le_32 (const u8 ** const pptr)
+{
+  const u8 * const ptr = *pptr;
+  *pptr += 4;
+  return (ptr[3] << 24) | (ptr[2] << 16) | (ptr[1] << 8) | ptr[0];
+}
+
+static void
+__attribute__((unused))
+write_le_16 (u8  ** const pptr,
+             u16   data)
+{
+  u8 * const ptr = *pptr;
+  *pptr += 2;
+  ptr[0] = (data >> 0) & 0xff;
+  ptr[1] = (data >> 8) & 0xff;
+}
+
+static void
+__attribute__((unused))
+write_le_32 (u8  ** const pptr,
+             u32   data)
+{
+  u8 * const ptr = *pptr;
+  *pptr += 4;
+  ptr[0] = (data >>  0) & 0xff;
+  ptr[1] = (data >>  8) & 0xff;
+  ptr[2] = (data >> 16) & 0xff;
+  ptr[3] = (data >> 24) & 0xff;
+}
+
+/*******************************************************************************
+ *
+ *                      PRIVATE STATIC SECTION      (RLE/RGB specific code)
+ *
+ *******************************************************************************/
+static DFBResult
+rle_decode_header (IDirectFBImageProvider_RLE_data *data)
+{
+#   define READ_LE_16(ptr,data)    {data=read_le_16(&ptr);TRACE(data);}
+#   define READ_LE_32(ptr,data)    {data=read_le_32(&ptr);TRACE(data);}
+#   define WRITE_LE_16(ptr,data)   write_le_16    (&ptr,(u16)data)
+#   define WRITE_LE_32(ptr,data)   write_le_32    (&ptr,(u32)data)
+#   define IS_MAGIC(ptr,l,h)       ((ptr[0]==l) &&  (ptr[1]==h))
+#   define SET_MAGIC(ptr,l,h)      {ptr[0]=(u8)l; ptr[1]=(u8)h;}
+
+  DFBResult  ret;
+  u8         preamble[RLE_PREAMBLE_SIZE];
+  u8         header[RLE_BIHEADER_SIZE];
+  const u8  *hptr;
+  u32        bihsize;
+
+  /* Preamble section */
+  memset (preamble, 0, RLE_PREAMBLE_SIZE);
+  ret = buffer_to_ptr_copy (data->common.base.buffer, preamble,
+                            RLE_PREAMBLE_SIZE);
+  if (ret)
+    return ret;
+  hptr = preamble;
+
+  /* Check first 2 bytes: Magic */
+  if (!IS_MAGIC (hptr, 'R', 'L') && !IS_MAGIC (hptr, 'B', 'M'))
+    {
+      D_ERROR ("Invalid magic (%c%c)!\n", hptr[0], hptr[1]);
+      return DFB_UNSUPPORTED;
+    }
+
+  /* Offset:00 --- 2 bytes: Magic */
+  READ_LE_16 (hptr, data->magic);
+
+  /* Offset:02 --- 4 bytes: FileSize */
+  READ_LE_32 (hptr, data->file_size);
+
+  /* Offset:06 --- 4 bytes: Reserved */
+  READ_LE_32 (hptr, data->reserved);
+
+  /* Offset:10 --- 4 bytes: DataOffset */
+  READ_LE_32 (hptr, data->img_offset);
+  if (data->img_offset < 54)
+    {
+      D_ERROR ("Invalid offset %08x!\n", data->img_offset);
+      return DFB_UNSUPPORTED;
+    }
+
+
+  /* Header section */
+  memset (header, 0, RLE_BIHEADER_SIZE);
+  ret = buffer_to_ptr_copy (data->common.base.buffer, header,
+                            RLE_BIHEADER_SIZE);
+  if (ret)
+    return ret;
+  hptr = header;
+
+  /* Offset:14 --- 4 bytes: HeaderSize */
+  READ_LE_32 (hptr, bihsize);
+  if (bihsize < 40)
+    {
+      D_ERROR ("Invalid image header size %d!\n", bihsize);
+      return DFB_UNSUPPORTED;
+    }
+
+  /* Offset:18 --- 4 bytes: Width */
+  READ_LE_32 (hptr, data->width);
+  if (data->width < 1 || data->width > 0xffff)
+    {
+      D_ERROR ("Invalid width %d!\n", data->width);
+      return DFB_UNSUPPORTED;
+    }
+
+  /* Offset:22 --- 4 bytes: Height */
+  READ_LE_32 (hptr, data->height_dib);
+  /* Deal with top-first mode DIB (negative height means just that ...) */
+  data->topfirst = data->height_dib < 0;
+  data->height   = data->topfirst ? -data->height_dib : data->height_dib;
+  if (data->height < 1 || data->height > 0xffff)
+    {
+      D_ERROR ("Invalid height %d!\n", data->height);
+      return DFB_UNSUPPORTED;
+    }
+
+  /* Offset:26 --- 2 bytes: Planes */
+  READ_LE_16 (hptr, data->num_planes);
+  if (data->num_planes != 1)
+    {
+      D_ERROR ("Unsupported number of planes %d!\n", data->num_planes);
+      return DFB_UNSUPPORTED;
+    }
+
+  /* Offset:28 --- 2 bytes: Depth */
+  READ_LE_16 (hptr, data->depth);
+  switch (data->depth)
+    {
+    case 1:
+    case 4:
+    case 8:
+      data->indexed = true;
+      /* fall through */
+    case 16:
+    case 24:
+    case 32:
+      break;
+
+    default:
+      D_ERROR ("Unsupported depth %d!\n", data->depth);
+      return DFB_UNSUPPORTED;
+    }
+
+  /* Offset:30 --- 4 bytes: Compression */
+  READ_LE_32 (hptr, data->compression);
+  switch (data->compression)
+    {
+    case RLEIC_NONE:
+      data->compressed = false;
+      break;
+
+    case RLEIC_BD_RLE8:
+      if (data->depth != 8)
+        {
+          D_ERROR ("Unsupported compression %d with depth %d!\n",
+                   data->compression, data->depth);
+          return DFB_UNSUPPORTED;
+        }
+      data->compressed = true;
+      break;
+
+    case RLEIC_RLE8:
+      if (data->depth != 8)
+        {
+          D_ERROR ("Unsupported compression %d with depth %d!\n",
+                   data->compression, data->depth);
+          return DFB_UNSUPPORTED;
+        }
+      data->compressed = true;
+      break;
+
+    case RLEIC_H2_DVD:
+      if (data->depth != 8)
+        {
+          D_ERROR ("Unsupported compression %d with depth %d!\n",
+                   data->compression, data->depth);
+          return DFB_UNSUPPORTED;
+        }
+      data->compressed = true;
+      D_INFO ("Detected H2DVD File\n");
+      break;
+
+    case RLEIC_H8_DVD:
+      if (data->depth != 8)
+        {
+          D_ERROR ("Unsupported compression %d with depth %d!\n",
+                   data->compression, data->depth);
+          return DFB_UNSUPPORTED;
+        }
+      data->compressed = true;
+      D_INFO ("Detected H8-DVD File\n");
+      break;
+
+    case RLEIC_RLE4:        /* Unimplemented as of version 1.1.0    */
+      if (data->depth != 4)
+        {
+          D_ERROR ("Unsupported compression %d with depth %d!\n",
+                   data->compression, data->depth);
+          return DFB_UNSUPPORTED;
+        }
+      data->compressed = true;
+      //break;
+
+    case RLEIC_BITFIELDS:   /* Unimplemented (no plans for support) */
+      data->compressed = false;
+
+    default:
+      D_ERROR ("Unsupported compression - %d!\n", data->compression);
+      return DFB_UNSUPPORTED;
+    }
+
+  /* Offset:34 --- 4 bytes: CompressedSize */
+  READ_LE_32 (hptr, data->payload_size);
+
+  /* Offset:38 --- 4 bytes: HorizontalResolution */
+  READ_LE_32 (hptr, data->h_resolution);
+
+  /* Offset:42 --- 4 bytes: VerticalResolution */
+  READ_LE_32 (hptr, data->v_resolution);
+
+  /* Offset:46 --- 4 bytes: UsedColors */
+  READ_LE_32 (hptr, data->num_colors);
+
+  /* Offset:50 --- 4 bytes: ImportantColors (don't care ...) */
+  READ_LE_32 (hptr, data->imp_colors);
+
+  /* Offset:54 --- bihsize-40 bytes: Skip remaining bytes */
+  if (bihsize > 40)
+    {
+      bihsize -= 40;
+      while (bihsize--)
+        {
+          u8 b;
+          ret = buffer_to_ptr_copy (data->common.base.buffer, &b, 1);
+          if (ret)
+            return ret;
+        }
+    }
+
+
+  /* Fixup source data pitch - used for any source raster-scan image */
+  data->pitch        = (((data->width*data->depth + 7) >> 3) + 3) & ~3;
+
+  /* Special mode colormap-less indexed source picture */
+  data->no_palette   = data->indexed && (data->img_offset == RLE_PALETTE_IMAGE_OFFSET);
+
+  /* Setup number of colors anyway ... */
+  if (data->num_colors == 0)
+    data->num_colors = 1 << data->depth;
+
+
+  /* Offset:16+bihsize     --- 4 x num_colors bytes: Palette management*/
+  if (data->indexed && !data->no_palette)
+    {
+      uint      pal_size = data->num_colors;
+      void     *src;
+      DFBColor  c;
+      int       i;
+
+      data->palette = src = D_MALLOC (pal_size * 4);
+      if (!data->palette)
+        return D_OOM ();
+
+      ret = buffer_to_ptr_copy (data->common.base.buffer, src,
+                                data->num_colors * 4);
+      if (ret)
+        return ret;
+
+      for (i = 0; i < data->num_colors; ++i)
+        {
+          c.a = 0xff;
+          c.r = ((u8 *) src)[i * 4 + 2];
+          c.g = ((u8 *) src)[i * 4 + 1];
+          c.b = ((u8 *) src)[i * 4 + 0];
+
+          data->palette[i] = c;
+        }
+    }
+
+  return DFB_OK;
+}
+
+static DFBResult
+rle_decode_rgb_row (IDirectFBImageProvider_RLE_data *data,
+                    int                              row)
+{
+  DFBResult  ret;
+  u8         local_buf[data->pitch];
+  const u8  *buf;
+  u32       * const dst = data->common.image + row * data->width;
+  int        i;
+
+  if (data->indexed && data->no_palette)
+    return DFB_INVARG;
+
+  switch (data->compression)
+    {
+    case RLEIC_NONE:
+    case RLEIC_RLE4:
+    case RLEIC_RLE8:
+    case RLEIC_BD_RLE8:
+    case RLEIC_H2_DVD:
+    case RLEIC_H8_DVD:
+      break;
+
+    case RLEIC_BITFIELDS: /* Unimplemented */
+    default:
+      D_ERROR ("Unsupported compression %d!\n", data->compression);
+      return DFB_UNSUPPORTED;
+    }
+
+  if (data->indexed)
+    {
+      /* Source indexes picked up indirectly from decomp. buffer */
+      D_ASSERT (data->image_indexes != NULL);
+      if (data->depth > 8)
+        return DFB_INVARG;
+      buf = data->image_indexes + row * data->width;
+    }
+  else
+    {
+      /* Source (RGB or indexes) picked up directly from payload */
+      D_ASSERT (data->common.base.buffer != NULL);
+      ret = buffer_to_ptr_copy (data->common.base.buffer, local_buf,
+                                data->pitch);
+      if (ret)
+        return ret;
+      buf = local_buf;
+    }
+
+  D_ASSERT (data->common.image != NULL);
+
+  switch (data->depth)
+    {
+    case 1:
+    case 4:
+    case 8:
+      for (i = 0; i < data->width; ++i)
+        {
+          u8 byte = buf[i];
+          DFBColor c = data->palette[byte];
+          dst[i] = c.b | (c.g << 8) | (c.r << 16) | (c.a << 24);
+        }
+      break;
+
+    case 16:
+      for (i = 0; i < data->width; i++)
+        {
+          u32 r, g, b;
+          u16 c;
+
+          c = buf[i*2+0] | (buf[i*2+1]<<8);
+          r = (c >> 10) & 0x1f;
+          g = (c >>  5) & 0x1f;
+          b = (c      ) & 0x1f;
+          r = (r << 3) | (r >> 2);
+          g = (g << 3) | (g >> 2);
+          b = (b << 3) | (b >> 2);
+
+          dst[i] = b | (g<<8) | (r<<16) | 0xff000000;
+        }
+      break;
+
+    case 24:
+      for (i = 0; i < data->width; i++)
+        dst[i] = (0
+                  | 0xff000000
+                  | (buf[i * 3 + 2] << 16)
+                  | (buf[i * 3 + 1] <<  8)
+                  | (buf[i * 3 + 0]      )
+                 );
+      break;
+
+    case 32:
+      for (i = 0; i < data->width; i++)
+        dst[i] = (0
+                  | 0xff000000
+                  | (buf[i * 4 + 2] << 16)
+                  | (buf[i * 4 + 1] <<  8)
+                  | (buf[i * 4 + 0]      )
+                 );
+      break;
+
+    default:
+      return DFB_UNSUPPORTED;
+    }
+
+  return DFB_OK;
+}
+
+
+
+static DFBResult
+rle_expand_image_indexes (IDirectFBImageProvider_RLE_data *data)
+{
+  DFBResult ret;
+  u8        buf[data->pitch];
+  int       row;
+
+  switch (data->compression)
+    {
+    case RLEIC_NONE:
+      break;
+
+    case RLEIC_RLE4:
+    case RLEIC_RLE8:
+    case RLEIC_BD_RLE8:
+    case RLEIC_BITFIELDS: /* Unimplemented */
+    default:
+      D_ERROR ("Unsupported compression %d!\n", data->compression);
+      return DFB_UNSUPPORTED;
+    }
+
+  D_ASSERT (data->common.base.buffer != NULL);
+  D_ASSERT (data->image_indexes != NULL);
+
+
+  for (row = 0; row < data->height; ++row)
+    {
+      int y = data->topfirst ? row : data->height-1-row;
+      u8 * const dst = data->image_indexes + y * data->width;
+
+      /* Source (RGB or indexes) picked up directly from payload */
+      ret = buffer_to_ptr_copy (data->common.base.buffer, buf, data->pitch);
+      if (ret)
+        return ret;
+
+      switch (data->depth)
+        {
+        int i;
+
+        case 1:
+          for (i = 0; data->width; ++i)
+            dst[i] = buf[i >> 3] & (0x80 >> (i & 7));
+          break;
+
+        case 4:
+          for (i = 0; i < data->width; ++i)
+            dst[i] = buf[i >> 1] & (0xf0 >> (i & 1));
+          break;
+
+        case 8:
+          for (i = 0; i < data->width; ++i)
+            dst[i] = buf[i];
+          break;
+
+        default:
+          return DFB_UNSUPPORTED;
+        }
+    }
+
+  return DFB_OK;
+}
+
+
+
+static DFBResult
+rle_decode_BI_RLE8 (const u8 * const buffer,
+                    uint      size,
+                    u8       * const image,
+                    uint      w,
+                    uint      h,
+                    uint      top)
+{
+  const u8 *buffer_ptr = buffer;
+  const u8 * const buffer_end = buffer + size;
+
+  u16  run_length;
+  u8   byte;
+  u8   pixel;
+
+  u16  x = 0;
+  u16  y = 0;
+
+  u8       *image_ptr = rle_set_position (image, 0, y, w, h, top);
+  const u8 * const image_end = image + (h * w);
+
+  D_DEBUG_AT (HWRLE, "%s: input: %u bytes, output: %ux%u pixels\n",
+              __FUNCTION__, size, w, h);
+
+  while (buffer_ptr < buffer_end)
+    {
+      byte = rle_input_byte (&buffer_ptr, buffer_end);
+
+      if (byte > 0)
+        {
+          pixel = rle_input_byte (&buffer_ptr, buffer_end);
+
+          for (run_length = byte; run_length > 0 && x < w; --run_length, ++x)
+            rle_output_byte (&image_ptr, image_end, pixel);
+
+          continue;
+        }
+
+      byte = rle_input_byte (&buffer_ptr, buffer_end);
+
+      switch (byte)
+        {
+        case 0:
+          x = 0;
+          ++y;
+          image_ptr = rle_set_position (image, x, y, w, h, top);
+          break;
+
+        case 1:
+          buffer_ptr = buffer_end;
+          break;
+
+        case 2:
+          x += rle_input_byte (&buffer_ptr, buffer_end);
+          y += rle_input_byte (&buffer_ptr, buffer_end);
+          image_ptr = rle_set_position (image, x, y, w, h, top);
+          break;
+
+        default:
+          for (run_length = byte; run_length > 0 && x < w; --run_length, ++x)
+            {
+              pixel = rle_input_byte (&buffer_ptr, buffer_end);
+              rle_output_byte (&image_ptr, image_end, pixel);
+            }
+          buffer_ptr += run_length;
+          if (byte & 1)
+            rle_input_byte (&buffer_ptr, buffer_end);
+        }
+    }
+
+  return DFB_OK;
+}
+
+
+static unsigned int
+rle_get_n_bits (const u8       ** const buffer_ptr_ptr,
+                const u8        * const buffer_end,
+                unsigned short   n)
+{
+  unsigned int dest = 0;
+  static unsigned short currentbit = 7; /* Start at left most bit */
+  static unsigned short srcbyte;
+
+  if (!n)
+    return 0; /* 0 bits == 0 */
+
+  /* Re-Align to Byte Boundary */
+  if (n > sizeof (unsigned int) * 8)
+    {
+      currentbit = 7;
+      return 0;
+    }
+
+  for ( ; n; --n) /* iterate until n or currentbit runs out */
+    {
+      unsigned int tmp;
+
+      if (currentbit == 7)
+        srcbyte = rle_input_byte (buffer_ptr_ptr, buffer_end);
+
+      //printf(".");
+      tmp = (srcbyte & (1 << currentbit));
+      tmp = tmp >> currentbit;
+      tmp = tmp << (n - 1);
+
+      if (currentbit)
+        --currentbit;
+      else
+        currentbit = 7;
+
+      dest |= tmp;
+    }
+
+  //printf("dest = %x : n = %d, currentbit = %d\n", dest, n, currentbit);
+
+  return dest;
+}
+
+
+static u8
+__attribute__((unused))
+rle_fetch_half_byte (const u8 ** const buffer_ptr_ptr,
+                     const u8  * const buffer_end)
+{
+  static bool top = 1;
+  static u8   byte = 0;
+
+  if (top)
+    {
+      byte = rle_input_byte (buffer_ptr_ptr, buffer_end);
+      D_DEBUG_AT (HWRLE, "%s: byte: {%x}\n", __FUNCTION__, byte);
+      top = 0;
+      return byte >> 4;
+    }
+  else
+    {
+      top = 1;
+      return byte & 0x0f;
+    }
+}
+
+static DFBResult
+rle_decode_H2_DVD (const u8 * const buffer,
+                   uint      size,
+                   u8       * const image,
+                   uint      w,
+                   uint      h)
+{
+  const u8 *buffer_ptr = buffer;
+  const u8 * const buffer_end = buffer + size;
+
+  u16 run_length;
+  u8  pixel;
+
+  uint x = 0;
+  uint y = 0;
+
+  u8       *image_ptr = image;
+  const u8 * const image_end = image + (h * w);
+
+  D_DEBUG_AT (HWRLE, "%s: input: %u bytes, output: %ux%u pixels\n",
+              __FUNCTION__, size, w, h);
+
+  while (buffer_ptr < buffer_end)
+    {
+      unsigned int v, t;
+
+      v = 0;
+
+      for (t = 1; v < t && t <= 0x40; t <<= 2)
+        v = (v << 4) | rle_get_n_bits (&buffer_ptr, buffer_end, 4);
+
+      pixel = v & 3;
+
+      if (v < 4)  /* Code for fill rest of line */
+        run_length = w - x;
+      else
+        run_length = v >> 2;
+
+
+      //run_length = MIN( w - x, run_length );
+
+      //printf("[x:%d r:%d p:%d]", x, run_length, pixel);
+
+      while (run_length--)
+        {
+          rle_output_byte (&image_ptr, image_end, pixel);
+          ++x;
+
+          /* EOL Check */
+          if (x >= w)
+            {
+              //D_ERROR ("Run passed EOL x=%d, w=%d, y=%d\n",x, w, y);
+              x = 0;
+              ++y;
+            }
+
+          if (y > h)
+            {
+              D_ERROR ("%s: Run passed EOF y/h: %d/%d, run_length: %d\n",
+                       __FUNCTION__, y, h, run_length);
+              return DFB_OK;
+            }
+        }
+    }
+
+  return DFB_OK;
+}
+
+
+
+static DFBResult
+rle_decode_H8_DVD (const u8 * const buffer,
+                   uint      size,
+                   u8       * const image,
+                   uint      w,
+                   uint      h)
+{
+  const u8 *buffer_ptr = buffer;
+  const u8 * const buffer_end = buffer + size;
+
+  uint x = 0;
+  uint y = 0;
+
+  u8       *image_ptr = image;
+  const u8 * const image_end = image + (h * w);
+
+  D_DEBUG_AT (HWRLE, "%s: input: %u bytes, output: %ux%u pixels\n",
+              __FUNCTION__, size, w, h);
+
+  while (buffer_ptr < buffer_end)
+    {
+      u8  pixel;
+      u32 run_length;
+
+      bool run = rle_get_n_bits (&buffer_ptr, buffer_end, 1);
+
+      /* Read Pixel Value */
+      bool eightbit = rle_get_n_bits (&buffer_ptr, buffer_end, 1);
+
+      if (eightbit)
+        pixel = rle_get_n_bits (&buffer_ptr, buffer_end, 8);
+      else
+        pixel = rle_get_n_bits (&buffer_ptr, buffer_end, 2);
+
+      /* Establish Run-Length */
+      if (run)
+        {
+          if (rle_get_n_bits (&buffer_ptr, buffer_end, 1) /* b4 or b10 */)
+            {
+              run_length = rle_get_n_bits (&buffer_ptr, buffer_end, 7);
+              if (run_length)
+                run_length += 9;
+              else
+                /* Run till EOL */
+                run_length = w - x;
+            }
+          else
+            run_length = rle_get_n_bits (&buffer_ptr, buffer_end, 3) + 2;
+        }
+      else
+        run_length = 1;
+
+      //printf("[x:%d y:%d r:0x%x p:%d]", x, y, run_length, pixel);
+
+      run_length = MIN (w - x, run_length); /* Run shouldn't over run a line! */
+
+      while (run_length-- > 0)
+        {
+          rle_output_byte (&image_ptr, image_end, pixel);
+          ++x;
+
+          /* EOL Check */
+          if (x >= w)
+            {
+              //D_ERROR ("Run passed EOL x=%d, w=%d, y=%d\n",x, w, y);
+              x = 0;
+              ++y;
+
+              /* Align bit stream */
+              rle_get_n_bits (&buffer_ptr, buffer_end, -1);
+            }
+
+          if (y >= h)
+            {
+              D_ERROR ("%s: Run passed EOF y/h: %d/%d, run_length: %d\n",
+                       __FUNCTION__, y, h, run_length);
+              return DFB_OK;
+            }
+        }
+    }
+
+  D_DEBUG_AT (HWRLE, "%s: decode completed @ x/y: %u/%u\n",
+              __FUNCTION__, x , y);
+
+  return DFB_OK;
+}
+
+
+static DFBResult
+rle_decode_BD_RLE8 (const u8 * const buffer,
+                    uint      size,
+                    u8       * const image,
+                    uint      w,
+                    uint      h)
+{
+  const u8 *buffer_ptr = buffer;
+  const u8 * const buffer_end = buffer + size;
+
+  const u8 long_run_length = 0x40;
+  const u8 non_zero_run    = 0x80;
+
+  uint x = 0;
+  uint y = 0;
+
+  u8       *image_ptr = image;
+  const u8 * const image_end = image + (h * w);
+
+  D_DEBUG_AT (HWRLE, "%s: input: %u bytes, output: %ux%u pixels\n",
+              __FUNCTION__, size, w, h);
+
+  while (buffer_ptr < buffer_end)
+    {
+      u8  pixel;
+      u8  byte;
+      u16 run_length;
+
+      pixel = rle_input_byte (&buffer_ptr, buffer_end);
+      if (pixel > 0)
+        {
+          rle_output_byte (&image_ptr, image_end, pixel);
+          ++x;
+          continue;
+        }
+
+      byte = rle_input_byte (&buffer_ptr, buffer_end);
+      if (byte == 0)
+        {
+          if (y < h)
+            {
+              x = 0;
+              ++y;
+              image_ptr = image + (w * y);
+              continue;
+            }
+          else
+            break;
+        }
+
+      if (byte & long_run_length)
+        {
+          run_length   = byte & 0x3f;
+          run_length <<= 8;
+          run_length  |= rle_input_byte (&buffer_ptr, buffer_end);
+        }
+      else
+        run_length = byte & 0x3f;
+
+      if (byte & non_zero_run)
+        pixel = rle_input_byte (&buffer_ptr, buffer_end);
+      else
+        pixel = 0;
+
+      while (run_length--)
+        {
+          rle_output_byte (&image_ptr, image_end, pixel);
+          ++x;
+        }
+    }
+
+  return DFB_OK;
+}
+
+
+static DFBResult
+rle_decode_BI_RLE4 (const u8 * const buffer,
+                    uint      size,
+                    u8       * const data_ptr,
+                    uint      w,
+                    uint      h,
+                    uint      top)
+{
+  D_WARN ("Unimplemented compression format in %s!\n", __FUNCTION__);
+
+  return DFB_UNIMPLEMENTED;
+}
+
+
+
+static DFBResult
+rle_decode_index_block (IDirectFBImageProvider_RLE_data *data)
+{
+  DFBResult  ret    = DFB_OK;
+  uint       size   = data->payload_size;
+  u8        *dst    = data->image_indexes;
+  uint       width  = data->width;
+  uint       height = data->height;
+  uint       top    = data->topfirst ? 1 : 0;
+  u8         buf[size];
+
+  switch (data->compression)
+    {
+    case RLEIC_NONE:
+      switch (data->depth)
+        {
+        case 1:
+        case 4:
+        case 8:
+          break;
+
+        default:
+          return DFB_UNSUPPORTED;
+        }
+
+      ret = rle_expand_image_indexes (data);
+      break;
+
+    case RLEIC_RLE8:
+      ret = buffer_to_ptr_copy (data->common.base.buffer, buf, size);
+      if (ret)
+        return ret;
+
+      if (data->depth != 8)
+        {
+          D_ERROR ("%s: Unsupported compression %d with depth %d!\n",
+                   __FUNCTION__, data->compression, data->depth);
+          return DFB_UNSUPPORTED;
+        }
+
+      ret = rle_decode_BI_RLE8 (buf, size, dst, width, height, top);
+      break;
+
+    case RLEIC_BD_RLE8:
+      ret = buffer_to_ptr_copy (data->common.base.buffer, buf, size);
+      if (ret)
+        return ret;
+
+      if (data->depth != 8)
+        {
+          D_ERROR ("%s: Unsupported compression %d with depth %d!\n",
+                   __FUNCTION__, data->compression, data->depth);
+          return DFB_UNSUPPORTED;
+        }
+
+      ret = rle_decode_BD_RLE8 (buf, size, dst, width, height);
+      break;
+
+    case RLEIC_H2_DVD:
+      ret = buffer_to_ptr_copy (data->common.base.buffer, buf, size);
+      if (ret)
+        return ret;
+
+      if (data->depth != 8)
+        {
+          D_ERROR ("%s: Unsupported compression %d with depth %d!\n",
+                   __FUNCTION__, data->compression, data->depth);
+          return DFB_UNSUPPORTED;
+        }
+
+      ret = rle_decode_H2_DVD (buf, size, dst, width, height);
+      break;
+
+    case RLEIC_H8_DVD:
+      ret = buffer_to_ptr_copy (data->common.base.buffer, buf, size);
+      if (ret)
+        return ret;
+
+      if (data->depth != 8)
+        {
+          D_ERROR ("%s: Unsupported compression %d with depth %d!\n",
+                   __FUNCTION__, data->compression, data->depth);
+          return DFB_UNSUPPORTED;
+        }
+
+      ret = rle_decode_H8_DVD (buf, size, dst, width, height);
+      break;
+
+    case RLEIC_RLE4:      /* Unimplemented as of version 1.0.0 */
+      ret = buffer_to_ptr_copy (data->common.base.buffer, buf, size);
+      if (ret)
+        return ret;
+
+      if (data->depth != 4)
+        {
+          D_ERROR ("%s: Unsupported compression %d with depth %d!\n",
+                   __FUNCTION__, data->compression, data->depth);
+          return DFB_UNSUPPORTED;
+        }
+
+      ret = rle_decode_BI_RLE4 (buf, size, dst, width, height, top);
+      break;
+
+    default:
+      D_ERROR ("%s: Unsupported compression %d!\n",
+               __FUNCTION__, data->compression);
+      return DFB_UNSUPPORTED;
+    }
+
+  return ret;
+}
+
+
+/*******************************************************************************
+ *
+ *                      PRIVATE STATIC SECTION     (Hardware Decode Section)
+ *
+ *******************************************************************************/
+
+#if defined(RLE_PROVIDER_HW)
+#include <../gfxdrivers/stgfx/stgfx.h>
+#include <../gfxdrivers/stgfx2/stm_gfxdriver.h>
+#include <dlfcn.h>
+static STMFB_GFXMEMORY_PARTITION
+bdisp_surface_pool_get_partition (const CoreSurfacePool * const pool)
+{
+  unsigned i;
+
+  switch (dfb_system_get_accelerator ())
+    {
+    case FB_ACCEL_ST_GAMMA:
+    case FB_ACCEL_ST_BDISP:
+      {
+      const STGFXDeviceData * const stdev = dfb_gfxcard_get_device_data ();
+      for (i = 0; i < D_ARRAY_SIZE (stdev->aux_pools); ++i)
+        if (stdev->aux_pools[i] == pool)
+          return STMFBGP_GFX0 + i;
+      }
+      break;
+
+    case FB_ACCEL_ST_BDISP_USER:
+      {
+      const STGFX2DeviceData * const stdev = dfb_gfxcard_get_device_data ();
+      for (i = 0; i < D_ARRAY_SIZE (stdev->aux_pools); ++i)
+        if (stdev->aux_pools[i] == pool)
+          return STMFBGP_GFX0 + i;
+      }
+      break;
+
+    default:
+      return STMFBGP_FRAMEBUFFER;
+    }
+
+  return STMFBGP_FRAMEBUFFER;
+}
+
+
+static DFBResult
+stgfb_hardware_rle_decode (IDirectFBImageProvider * const thiz,
+                           IDirectFBSurface       * const destination,
+                           DFBRectangle           * const dest_rect)
+{
+  DFBResult             dfbret;
+  CoreSurfaceBufferLock lock;
+
+  DIRECT_INTERFACE_GET_DATA (IDirectFBImageProvider_RLE)
+
+  IDirectFBSurface_data * const dst_data = destination->priv;
+
+  switch (data->compression)
+    {
+    case RLEIC_BD_RLE8:
+      /* Supported BDisp Decode */
+      break;
+
+    case RLEIC_H2_DVD:	/* Currently Unsupported in BDisp */
+    case RLEIC_H8_DVD:  /* Move when available */
+    default:
+      return DFB_UNSUPPORTED;
+    }
+
+  /* BDisp decode follows ... */
+  D_DEBUG_AT (HWRLE, "%s: attempting BDisp decode\n", __FUNCTION__);
+
+  /* We must ensure the parameters are correct for the Blit, or the blitter
+     will hang */
+
+  /* Ensure dest_rect matches the appropriate width and height */
+  if (dest_rect->w != data->width
+      || dest_rect->h != data->height)
+    {
+      D_ERROR ("%s: invalid arguments: dest w/h: %d/%d, w/h: %u/%u\n",
+               __FUNCTION__, 
+               dest_rect->w, dest_rect->h, data->width, data->height);
+      return DFB_INVARG;
+    }
+
+  /* We only need to create and load the raw RLE data once. After that, we
+     can just blit this quickly to dest. */
+  if (!data->compressed_data)
+    {
+      CoreSurfaceConfig config;
+
+      config.flags = CSCONF_SIZE | CSCONF_FORMAT | CSCONF_CAPS;
+      config.size.w = data->payload_size;
+      config.size.h = 1;
+      config.format = DSPF_A8; /* any 8bpp format would work here */
+      config.caps   = DSCAPS_VIDEOONLY;
+      #ifdef DIRECT_BUILD_DEBUG
+      config.caps   |= DSCAPS_SHARED;
+      #endif
+
+      if (dfb_surface_create (data->common.core,
+                              &config,
+                              CSTF_NONE,
+                              0,
+                              NULL,
+                              &data->compressed_data))
+        return DFB_NOVIDEOMEMORY;
+
+      /**** copy data onto raw surface ****/
+
+      /* Set Data Buffer pointer ... */
+      data->common.buffer->SeekTo (data->common.buffer, data->img_offset);
+
+      dfbret = dfb_surface_lock_buffer (data->compressed_data, CSBR_BACK,
+                                        CSAID_CPU, CSAF_WRITE, &lock);
+      if (dfbret)
+        return dfbret;
+
+      dfbret = buffer_to_ptr_copy (data->common.buffer, lock.addr,
+                                   data->payload_size);
+      dfb_surface_unlock_buffer (data->compressed_data, &lock);
+      if (dfbret)
+        return dfbret;
+    }
+
+  /* the following code tries to do the stretch blit through stgfx2, if that
+     fails, the normal approach through the ioctl() interface is done for the
+     kernel based driver */
+  bool direct_success = false;
+  CoreSurfaceBufferLock lock_src, lock_dst;
+
+  dfbret = dfb_surface_lock_buffer (data->compressed_data, CSBR_BACK,
+                                    CSAID_GPU, CSAF_READ, &lock_src);
+  if (dfbret)
+    return dfbret;
+  dfbret = dfb_surface_lock_buffer (dst_data->surface, CSBR_BACK,
+                                    CSAID_GPU, CSAF_WRITE, &lock_dst);
+  if (dfbret)
+    {
+      dfb_surface_unlock_buffer (data->compressed_data, &lock_src);
+      return dfbret;
+    }
+
+  if (likely (data->rle_stretch))
+    direct_success = data->rle_stretch (dfb_gfxcard_get_driver_data (),
+                                        dfb_gfxcard_get_device_data (),
+                                        lock_src.phys,
+                                        data->compressed_data->config.size.w,
+                                        &lock_dst,
+                                        dest_rect);
+  if (likely (direct_success))
+    ;
+  else
+    {
+      static const SURF_FMT  rleic_to_surf[] = { SURF_RLD_BD, SURF_RLD_H2,
+                                                 SURF_RLD_H8 };
+      STMFBIO_BLT_DATA       blit;
+      /* this is needed to obtain framebuffer fd */
+      const FBDev           * const dfb_fbdev = (FBDev *) dfb_system_data ();
+
+      /* Create command structure to send to FBDev */
+      /* Request decode operation to destination surface */
+
+      /* Perform a Copy Blit. STGFB will treat RLE as a surface type. */
+      blit.operation = BLT_OP_COPY;
+
+      /* Inform copy complex that this is an RLE Decode */
+      blit.ulFlags = BLT_OP_FLAGS_RLE_DECODE;
+
+      blit.srcMemBase = bdisp_surface_pool_get_partition (lock_src.allocation->pool);
+      blit.srcOffset  = lock_src.offset;
+      blit.srcPitch   = data->compressed_data->config.size.w;
+      blit.srcFormat  = rleic_to_surf[data->compression - RLEIC_BD_RLE8];
+
+      blit.dstMemBase = bdisp_surface_pool_get_partition (lock_dst.allocation->pool);
+      blit.dstOffset  = lock_dst.offset;
+      blit.dstPitch   = lock_dst.pitch;
+
+      blit.src_top    = 0;
+      blit.src_bottom = data->compressed_data->config.size.h;
+      blit.src_left   = 0;
+      blit.src_right  = 0;
+
+      /* (data->indexed) ? DSPF_LUT8 : DSPF_RGB32; */
+      blit.dstFormat  = (data->indexed) ? SURF_CLUT8 : SURF_ARGB8888;
+
+      if (dest_rect)
+        {
+          blit.dst_left   = dest_rect->x;
+          blit.dst_top    = dest_rect->y;
+          blit.dst_right  = dest_rect->x + dest_rect->w;
+          blit.dst_bottom = dest_rect->y + dest_rect->h;
+        }
+      else
+        {
+          blit.dst_left   = 0;
+          blit.dst_top    = 0;
+          blit.dst_right  = dst_data->surface->config.size.w;
+          blit.dst_bottom = dst_data->surface->config.size.h;
+        }
+
+      /* Send the ioctl */
+      D_DEBUG_AT (HWRLE,
+                  "%s: flags: %.8lx src base/l/r/t/b: %d/%hu/%hu/%hu/%hu "
+                  "dst base/l/r/t/b: %d/%hu/%hu/%hu/%hu\n", __FUNCTION__,
+                  blit.ulFlags,
+                  blit.srcMemBase, blit.src_left, blit.src_right,
+                  blit.src_top, blit.src_bottom,
+                  blit.dstMemBase, blit.dst_left, blit.dst_right,
+                  blit.dst_top, blit.dst_bottom);
+      D_DEBUG_AT (HWRLE, "%s: src offs/pitch/fmt: %.8lx/%lu/%d "
+                  "dst offs/pitch/fmt: %.8lx/%lu/%d\n", __FUNCTION__,
+                  blit.srcOffset, blit.srcPitch, blit.srcFormat,
+                  blit.dstOffset, blit.dstPitch, blit.dstFormat);
+
+#ifdef ALLOW_DUMP_RAW_TO_FILE
+      if (getenv ("RLE_DUMP_RAW_TO_FILE"))
+        {
+          char fn[1024];
+          FILE *f;
+          const STMFBIO_BLT_DATA * const r = &blit;
+
+          snprintf (fn, sizeof (fn), "/tmp/rle/raw_%05d.txt", data->idx);
+          if ((f = fopen (fn, "w+")) != NULL)
+            {
+              fprintf (f,
+                       "op %d, flg %.8lx, col %.8lx, alph %.8lx, key %.8lx, msk %.8lx\n"
+                       "src: %u + %lu, pitch %lu\n"
+                       "dst: %u + %lu, pitch %lu\n"
+                       "src/dst fmt %d/%d"
+                       "src: t/p/l/r %hu %hu %hu %hu"
+                       "dst: t/p/l/r %hu %hu %hu %hu\n",
+                       r->operation, r->ulFlags,
+                       r->colour, r->globalAlpha, r->colourKey, r->planeMask,
+                       r->srcMemBase, r->srcOffset, r->srcPitch,
+                       r->dstMemBase, r->dstOffset, r->dstPitch,
+                       r->srcFormat, r->dstFormat,
+                       r->src_top, r->src_bottom, r->src_left, r->src_right,
+                       r->dst_top, r->dst_bottom, r->dst_left, r->dst_right);
+              fflush (f);
+              fclose (f);
+            }
+          else
+            fprintf (stderr, "Failed to open file %05d\n", data->idx);
+        }
+#endif /* ALLOW_DUMP_RAW_TO_FILE */
+
+      int ret;
+      if ((ret = ioctl (dfb_fbdev->fd, STMFBIO_BLT, &blit)) == 0)
+        {
+          D_DEBUG_AT (HWRLE,
+                      "%s: success: input: %d bytes, output: %dx%d pixels\n",
+                      __FUNCTION__, data->compressed_data->config.size.w,
+                      dst_data->surface->config.size.w,
+                      dst_data->surface->config.size.h);
+          dfbret = DFB_OK;
+        }
+      else
+        {
+          D_DEBUG_AT (HWRLE,
+                      "%s: failed: %d input: %d bytes, output: %dx%d pixels\n",
+                      __FUNCTION__, errno, data->compressed_data->config.size.w,
+                      dst_data->surface->config.size.w,
+                      dst_data->surface->config.size.h);
+          dfbret = DFB_FAILURE;
+        }
+    }
+  dfb_surface_unlock_buffer (dst_data->surface, &lock_dst);
+  dfb_surface_unlock_buffer (data->compressed_data, &lock_src);
+
+  if (dfbret == DFB_OK)
+    {
+      deb_gettimeofday (&data->common.endtime, NULL);
+      deb_timersub (&data->common.endtime, &data->common.starttime,
+                    &data->common.endtime);
+      D_DEBUG_AT (HWRLE_TIME, "  -> BDispII RLE decode total time %lu.%06lu\n",
+                  data->common.endtime.tv_sec, data->common.endtime.tv_usec);
+    }
+
+  return dfbret;
+}
+#else /* RLE_PROVIDER_HW */
+#define stgfb_hardware_rle_decode(thiz,destination,dest_rect) DFB_UNIMPLEMENTED
+#endif /* RLE_PROVIDER_HW */
+
+
+
+#if defined(RLE_PROVIDER_USE_MME)
+static void
+TransformerCallback (MME_Event_t    Event,
+                     MME_Command_t *CallbackData,
+                     void          *UserData)
+{
+  const RLEDecode_TransformReturnParams_t * const transform_result =
+    CallbackData->CmdStatus.AdditionalInfo_p;
+  struct _MMECommon * const mme = (struct _MMECommon *) UserData;
+
+  D_DEBUG_AT (HWRLE, "%sTransformerCallback: Event: %d: (%s)%s\n",
+              RED, Event, get_mme_event_string (Event), BLACK);
+  D_DEBUG_AT (HWRLE, "  -> CallbackData->CmdStatus.State: %d (%s)\n",
+              CallbackData->CmdStatus.State,
+              get_mme_state_string (CallbackData->CmdStatus.State));
+  D_DEBUG_AT (HWRLE, "  -> CallbackData->CmdStatus.CmdId: %u (%.8x)\n",
+              CallbackData->CmdStatus.CmdId,
+              CallbackData->CmdStatus.CmdId);
+  D_DEBUG_AT (HWRLE, "  -> CallbackData->CmdStatus.Error: %d (%s)\n",
+              CallbackData->CmdStatus.Error,
+              get_mme_error_string (CallbackData->CmdStatus.Error));
+  D_DEBUG_AT (HWRLE, "  -> CallbackData->CmdStatus.AdditionalInfoSize: %u\n",
+              CallbackData->CmdStatus.AdditionalInfoSize);
+  D_DEBUG_AT (HWRLE, "  -> mme->decode_success: %d\n", mme->decode_success);
+
+  switch (Event)
+    {
+    case MME_COMMAND_COMPLETED_EVT:
+      switch (CallbackData->CmdStatus.State)
+        {
+        case MME_COMMAND_COMPLETED:
+          if (CallbackData->CmdStatus.CmdId
+              == mme->TransformCommand.CmdStatus.CmdId)
+            {
+              deb_gettimeofday (&mme->endtime, NULL);
+              deb_timersub (&mme->endtime, &mme->starttime, &mme->endtime);
+              D_DEBUG_AT (HWRLE_TIME, "  -> MME decode total time %lu.%06lu\n",
+                          mme->endtime.tv_sec, mme->endtime.tv_usec);
+
+              D_DEBUG_AT (HWRLE, "  -> expanded bytes: %u\n",
+                          transform_result->BytesWritten);
+
+              D_DEBUG_AT (HWRLE, "  -> RLE result code: %d (%s)\n",
+                          transform_result->ErrorType,
+                          get_rle_error_string (transform_result->ErrorType));
+
+              mme->decode_success = 1;
+              sema_signal_event (&mme->decode_event);
+            }
+          else
+            {
+              /* buffer completed */
+              struct _MMEHelper_buffer *buf =
+                container_of (CallbackData->DataBuffers_p,
+                              struct _MMEHelper_buffer, buffer);
+
+              D_DEBUG_AT (HWRLE, "  -> buffer %p completed (container @ %p)\n",
+                          CallbackData->DataBuffers_p[0], buf);
+
+              sema_signal_event (&buf->sema);
+            }
+          break;
+
+        case MME_COMMAND_FAILED:
+          D_WARN ("(%5d) %s: command %u (%.8x) failed: error %d (%s)",
+                  direct_gettid (), mme->name,
+                  CallbackData->CmdStatus.CmdId,
+                  CallbackData->CmdStatus.CmdId,
+                  CallbackData->CmdStatus.Error,
+                  get_mme_error_string (CallbackData->CmdStatus.Error));
+
+          if (CallbackData->CmdStatus.CmdId
+              == mme->TransformCommand.CmdStatus.CmdId)
+            {
+              mme->decode_success = -1;
+
+              /* On Failure allow main flow to continue and tidy up */
+              sema_signal_event (&mme->decode_event);
+            }
+          break;
+
+        case MME_COMMAND_IDLE:
+        case MME_COMMAND_PENDING:
+        case MME_COMMAND_EXECUTING:
+        default:
+          D_WARN ("(%5d) %s: command %u (%.8x) completed in unknown state: %d (%s)",
+                  direct_gettid (), mme->name,
+                  CallbackData->CmdStatus.CmdId, CallbackData->CmdStatus.CmdId,
+                  CallbackData->CmdStatus.State,
+                  get_mme_state_string (CallbackData->CmdStatus.State));
+          break;
+        }
+      break; /* MME_COMMAND_COMPLETED_EVT */
+
+    case MME_DATA_UNDERFLOW_EVT:
+      ++mme->n_underflows;
+      break; /* MME_DATA_UNDERFLOW_EVT */
+
+    case MME_NOT_ENOUGH_MEMORY_EVT:
+    case MME_NEW_COMMAND_EVT:
+    default:
+      D_WARN ("(%5d) %s: unhandled event %d (%s) occured on command %u (%.8x)",
+              direct_gettid (), mme->name, Event,
+              get_mme_event_string (Event), CallbackData->CmdStatus.CmdId,
+              CallbackData->CmdStatus.CmdId);
+
+      D_WARN ("(%5d) %s: CallbackData->CmdStatus.AdditionalInfoSize: %u",
+              direct_gettid (), mme->name, CallbackData->CmdStatus.AdditionalInfoSize);
+
+      if (CallbackData->CmdStatus.CmdId == mme->TransformCommand.CmdStatus.CmdId)
+        {
+          D_WARN ("(%5d) %s: transform_result->bytes_written: %u",
+                  direct_gettid (), mme->name, transform_result->BytesWritten);
+          D_WARN ("(%5d) %s: result code: %d (%s)\n", direct_gettid (),
+                  mme->name, transform_result->ErrorType,
+                  get_rle_error_string (transform_result->ErrorType));
+        }
+      break;
+    } /* switch (Event) */
+}
+
+
+static DFBResult
+abort_transformer (struct _MMECommon * const mme)
+{
+  IDirectFBImageProvider_RLE_data * const data =
+    container_of (mme, IDirectFBImageProvider_RLE_data, common);
+
+  if (!mme)
+       return DFB_THIZNULL;
+
+  if (!data)
+       return DFB_DEAD;
+
+  return DFB_OK;
+}
+
+
+
+static DFBResult
+send_rle_image (struct _MMECommon * const data)
+{
+  DFBResult res = MME_SUCCESS;
+
+  unsigned int i;
+
+  mme_helper_calculate_packets (data);
+  D_ASSERT (data->packets == 1);
+
+  /* Clean buffer pointers, as we create based on them being empty! */
+  memset (&data->SendDataBuffers, 0, sizeof (data->SendDataBuffers));
+
+  D_DEBUG_AT (HWRLE, "%s: iterating %d packets for %f chunks of data out of "
+              "%d bytes\n", __FUNCTION__,
+              data->packets,
+              (float) ((float) data->bytes / (float) MME_STREAMING_BUFFERSIZE),
+              data->bytes);
+  //data->InDataBuffers = (MME_DataBuffer_t **)D_MALLOC(sizeof(MME_DataBuffer_t *) * MAX_STREAMING_BUFFERS);
+
+  for (i = 0; i < data->packets; ++i)
+    {
+      unsigned int this_read = MIN (data->bytes, MME_STREAMING_BUFFERSIZE);
+      unsigned int currentbuffer = i % MAX_STREAMING_COMMANDS;
+      struct _MMEHelper_buffer * const buffer =
+        &data->SendDataBuffers[currentbuffer];
+
+      D_DEBUG_AT (HWRLE, "%s sending packet %u through buffer %u\n",
+                  __FUNCTION__, i, currentbuffer);
+
+      if (!buffer->buffer)
+        {
+          res = _alloc_send_buffer (data->Handle, this_read, buffer);
+          if (res != DFB_OK)
+            return res;
+        }
+      else
+        {
+          /* Wait for a buffer to be available (maybe in streaming version!) */
+          while ((sema_wait_event (&buffer->sema) == -1)
+                 && errno == EINTR)
+            ;
+        }
+
+      /* Some checking - We've waited ... should we continue ...*/
+      if (data->decode_success < 0)
+        {
+          D_WARN ("(%5d) ImageProvider/%s: error sending data. Transform "
+                  "error reported from callback",
+                  direct_gettid (), data->name);
+          sema_signal_event (&buffer->sema);
+          return DFB_FAILURE;
+        }
+
+      if (buffer_to_mme_copy (data->base.buffer, buffer->buffer,
+                              this_read) != DFB_OK)
+        {
+          D_WARN ("(%5d) Fetching %u bytes of data failed: res: %d",
+                  direct_gettid (), this_read, res);
+          sema_signal_event (&buffer->sema);
+          /* hm, DirectFB (always?) returns DFB_FAILURE here... */
+          return DFB_IO;
+        }
+
+      /* Subtract read data amount */
+      data->bytes -= this_read;
+
+      /* send the command */
+      D_DEBUG_AT (HWRLE, "%s: Send Data Command\n", __FUNCTION__);
+
+      res = MME_SendCommand (data->Handle, &buffer->command);
+
+      D_DEBUG_AT (HWRLE, "%s: sent data: %d bytes remaining\n",
+                  __FUNCTION__, data->bytes);
+
+      if (res != MME_SUCCESS)
+        {
+          D_ERROR ("%s: MME_SendCommand failed: buffer %u: %s\n",
+                   __FUNCTION__, currentbuffer, get_mme_error_string (res));
+          res = DFB_FAILURE;
+        }
+    }
+
+  return res;
+}
+
+static DFBResult
+lx_multicom_rle_decode (IDirectFBImageProvider *thiz,
+                        IDirectFBSurface       *destination,
+                        const DFBRectangle     *dest_rect)
+{
+  int                    err;
+
+  DFBRegion              clip;
+  DFBRectangle           rect;
+  DFBSurfacePixelFormat  format;
+  IDirectFBSurface_data *dst_data;
+  CoreSurface           *dst_surface;
+  CoreSurfaceBufferLock  lock;
+
+  DFBResult              ret;
+
+  dst_data = (IDirectFBSurface_data *) destination->priv;
+  DIRECT_INTERFACE_GET_DATA (IDirectFBImageProvider_RLE)
+
+  /* Initialise Multicom */
+  /* Send *WHOLE FILE* (LXRLEDecode has no streaming support) */
+  /* Request Transform (with output buffer) */
+  /* Hope it works */
+
+  /* Any problems - just bail out and let something else do it */
+
+  if (!dst_data)
+    return DFB_DEAD;
+
+  dst_surface = dst_data->surface;
+
+  if (!dst_surface)
+    return DFB_DESTROYED;
+
+  /* Need to check the pitch is the same as the width - or we'll be writing in the wrong buffer space */
+  /* If the pitch is not the same as the width - let SH4 handle it until the LX decoder is more advanced ! */
+
+  err = destination->GetPixelFormat (destination, &format);
+  if (err)
+    return err;
+
+  dfb_region_from_rectangle (&clip, &dst_data->area.current);
+
+  if (dest_rect)
+    {
+      if (dest_rect->w < 1 || dest_rect->h < 1)
+        return DFB_INVARG;
+
+      rect = *dest_rect;
+      rect.x += dst_data->area.wanted.x;
+      rect.y += dst_data->area.wanted.y;
+
+      if (!dfb_rectangle_region_intersects (&rect, &clip))
+        return DFB_OK;
+    }
+  else
+    rect = dst_data->area.wanted;
+
+  data->common.name = "hwRLE";
+  static const char * const transformers[] = { "RLE_DECODER",
+                                               "RLE_DECODER4",
+                                               "RLE_DECODER3",
+                                               "RLE_DECODER2",
+                                               "RLE_DECODER1",
+                                               "RLE_DECODER0",
+                                               NULL };
+  ret = mme_helper_init_transformer (&data->common, transformers, 0, NULL, NULL);
+  if (ret == DFB_OK)
+    {
+      bool locked = false;
+
+      sema_init_event (&data->common.decode_event, 0); /* Alerts to completion */
+
+      ret = send_rle_image (&data->common);
+      if (ret == DFB_OK)
+        {
+          ret = mme_helper_start_transformer (&data->common,
+                                              sizeof (RLEDecode_TransformReturnParams_t),
+                                              &data->ReturnParams,
+                                              0, NULL,
+                                              dst_surface, &lock);
+          if (ret == DFB_OK)
+            {
+              D_DEBUG_AT (HWRLE, "%s: waiting for completion\n", __FUNCTION__);
+
+              locked = true;
+
+              /* Wait until the decode is complete */
+              while ((sema_wait_event (&data->common.decode_event) == -1)
+                     && errno == EINTR)
+                ;
+
+              D_DEBUG_AT (HWRLE, "%s: performed LX decode\n", __FUNCTION__);
+            }
+        }
+
+      mme_helper_deinit_transformer (&data->common);
+
+      if (likely (locked))
+        dfb_surface_unlock_buffer (dst_surface, &lock);
+
+      if (data->common.OutDataBuffers)
+        {
+          D_FREE (data->common.OutDataBuffers);
+          data->common.OutDataBuffers = NULL;
+        }
+
+      unsigned i;
+      for (i = 0; i < D_ARRAY_SIZE (data->common.SendDataBuffers); ++i)
+        {
+          if (data->common.SendDataBuffers[i].buffer)
+            {
+              MME_FreeDataBuffer (data->common.SendDataBuffers[i].buffer);
+              data->common.SendDataBuffers[i].buffer = NULL;
+
+              sema_close_event (&data->common.SendDataBuffers[i].sema);
+            }
+        }
+
+      sema_close_event (&data->common.decode_event);
+    }
+
+  return ret;
+}
+#else /* RLE_PROVIDER_USE_MME */
+#define lx_multicom_rle_decode(thiz,destination,dest_rect) DFB_UNIMPLEMENTED
+#endif
+
+#if defined(RLE_PROVIDER_HW) || defined(RLE_PROVIDER_USE_MME)
+static DFBResult
+hardware_rle_decode (IDirectFBImageProvider * const thiz,
+                     IDirectFBSurface       * const destination,
+                     DFBRectangle           * const dest_rect)
+
+{
+  DFBResult ret;
+
+  DIRECT_INTERFACE_GET_DATA (IDirectFBImageProvider_RLE)
+
+  /* 1) try the BDisp in STGFB.
+     2) Then where supported try an LX ...
+     3) Finally - return - and let the image provider deal with the image
+        on the SH4
+  */
+
+  /* store the current data buffer position for software fallback should we
+     not succeed */
+  unsigned int bufpos;
+  data->common.base.buffer->GetPosition (data->common.base.buffer,
+                                         &bufpos);
+
+  deb_gettimeofday (&data->common.starttime, NULL);
+
+  switch (data->compression)
+    {
+    case RLEIC_BD_RLE8:
+#ifdef ALLOW_FORCE_SOFTWARE
+      if (getenv ("RLE_FORCE_SOFTWARE"))
+        {
+          ret = -1;
+          break;
+        }
+#endif /* ALLOW_FORCE_SOFTWARE */
+
+      ret = stgfb_hardware_rle_decode (thiz, destination, dest_rect);
+      break;
+
+      /* BD_RLE8 decoding seems to be b0rken on the LX */
+    case RLEIC_H2_DVD:
+    case RLEIC_H8_DVD:
+      ret = stgfb_hardware_rle_decode (thiz, destination, dest_rect);
+      if (unlikely (ret))
+        ret = lx_multicom_rle_decode (thiz, destination, dest_rect );
+      break;
+
+    default:
+      ret = DFB_UNSUPPORTED;
+      break;
+    }
+
+  /* Restore Buffer location to continue software decode */
+  data->common.base.buffer->SeekTo (data->common.base.buffer, bufpos);
+
+  return ret;
+}
+#else /* RLE_PROVIDER_HW || RLE_PROVIDER_USE_MME */
+#define hardware_rle_decode(thiz,destination,dest_rect) DFB_UNIMPLEMENTED
+#endif /* RLE_PROVIDER_HW || RLE_PROVIDER_USE_MME */
+
+
+/*******************************************************************************
+ *
+ *                      PUBLIC INTERFACE STATIC SECTION
+ *
+ *******************************************************************************/
+
+static DFBResult
+IDirectFBImageProvider_RLE_RenderTo (IDirectFBImageProvider *thiz,
+                                     IDirectFBSurface       *destination,
+                                     const DFBRectangle     *dest_rect)
+{
+  IDirectFBSurface_data  *dst_data;
+  CoreSurface            *dst_surface;
+  DFBRectangle            rect;
+  DFBRegion               clip;
+  CoreSurfaceBufferLock   lock;
+  DIRenderCallbackResult  cb_result = DIRCR_OK;
+  DFBResult               ret       = DFB_OK;
+
+  DIRECT_INTERFACE_GET_DATA (IDirectFBImageProvider_RLE)
+
+  if (!destination)
+    return DFB_INVARG;
+
+  dst_data = destination->priv;
+  if (!dst_data || !dst_data->surface)
+    return DFB_DESTROYED;
+
+  dst_surface = dst_data->surface;
+
+  if (dest_rect)
+    {
+      if (dest_rect->w < 1 || dest_rect->h < 1)
+        return DFB_INVARG;
+      rect = *dest_rect;
+      rect.x += dst_data->area.wanted.x;
+      rect.y += dst_data->area.wanted.y;
+    }
+  else
+    rect = dst_data->area.wanted;
+
+  dfb_region_from_rectangle (&clip, &dst_data->area.current);
+  if (!dfb_rectangle_region_intersects (&rect, &clip))
+    return DFB_OK;
+
+  /* Attempt a decode using the Any hardware acceleration available */
+  if (DFB_OK == hardware_rle_decode (thiz, destination, &rect))
+    return DFB_OK;
+
+  /* Hardware wasn't capable or happy. Lets try ourselves */
+
+  /* Software Decode */
+  ret = dfb_surface_lock_buffer (dst_surface, CSBR_BACK, CSAID_CPU,
+                                 CSAF_WRITE, &lock);
+  if (ret)
+    return ret;
+
+
+  /* Decompress RLE coded data to packed indexes into local buffer. */
+  if (data->indexed && !data->image_indexes)
+    {
+      struct timeval __attribute__ ((unused)) start, end;
+
+      data->image_indexes = D_MALLOC (data->width*data->height);
+
+      if (!data->image_indexes)
+        {
+          dfb_surface_unlock_buffer (dst_surface, &lock);
+          return D_OOM ();
+        }
+
+      /* Source indexes will be picked up indirectly from decomp. buffer */
+      data->common.base.buffer->SeekTo (data->common.base.buffer,
+                                        data->img_offset);
+
+      deb_gettimeofday (&start, NULL);
+
+      ret = rle_decode_index_block (data);
+      if (ret)
+        {
+          dfb_surface_unlock_buffer (dst_surface, &lock);
+          return ret;
+        }
+
+      deb_gettimeofday (&end, NULL);
+      deb_timersub (&end, &start, &end);
+      D_DEBUG_AT (HWRLE_TIME, "%s: SW RLE decode took %lu.%06lus\n",
+                  __FUNCTION__, end.tv_sec, end.tv_usec);
+    }
+
+  /* Special indexed to LUT8 loading. */
+  if (data->indexed && dst_surface->config.format == DSPF_LUT8)
+    {
+      bool direct;
+
+      if (!data->no_palette)
+        {
+          IDirectFBPalette *palette;
+          ret = destination->GetPalette (destination, &palette);
+          if (ret)
+            {
+              dfb_surface_unlock_buffer (dst_surface, &lock);
+              return ret;
+            }
+          palette->SetEntries (palette, data->palette, data->num_colors, 0);
+          palette->Release (palette);
+        }
+
+      /* Limitation for direct LUT8 access is to blit complete surface only */
+      direct = (rect.x == 0
+                && rect.y == 0
+                && rect.w == dst_surface->config.size.w
+                && rect.h == dst_surface->config.size.h
+                && rect.w == data->width
+                && rect.h == data->height);
+
+      if (direct)
+        {
+          int  y, row;
+
+          for (row = 0; row < data->height && cb_result == DIRCR_OK; ++row)
+            {
+              y = data->topfirst ? row : data->height-1-row;
+
+              direct_memcpy (lock.addr + lock.pitch * y,
+                             data->image_indexes + data->width * y,
+                             data->width);
+
+              if (data->common.base.render_callback)
+                {
+                  DFBRectangle r = (DFBRectangle) { 0, y, data->width, 1 };
+
+                  cb_result = data->common.base.render_callback (&r,
+                                                                 data->common.base.render_callback_context);
+                }
+            }
+
+          if (cb_result != DIRCR_OK)
+            ret = DFB_INTERRUPTED;
+
+          dfb_surface_unlock_buffer (dst_surface, &lock);
+          return ret;
+        }
+    }
+
+
+  /* Invalid indexed to non-direct LUT8 loading without attached colormap. */
+  if (data->indexed && data->no_palette)
+    {
+      dfb_surface_unlock_buffer (dst_surface, &lock);
+      return DFB_INVARG;
+    }
+
+
+  /* Convert to ARGB and use generic loading code. */
+  if (!data->common.image)
+    {
+      bool direct = (rect.w == data->width
+                     && rect.h == data->height
+                     && data->common.base.render_callback);
+      int  y, row;
+
+      data->common.image = D_MALLOC (data->width*data->height * 4);
+      if (!data->common.image)
+        {
+          dfb_surface_unlock_buffer (dst_surface, &lock);
+          return D_OOM ();
+        }
+
+      if (!data->indexed)
+        /* Source (RGB or indexes) picked up directly from payload */
+        data->common.base.buffer->SeekTo (data->common.base.buffer,
+                                          data->img_offset);
+
+      for (row = 0; row < data->height && cb_result == DIRCR_OK; ++row)
+        {
+          y = data->topfirst ? row : data->height-1-row;
+
+          ret = rle_decode_rgb_row (data, y);
+          if (ret)
+            break;
+
+          if (direct)
+            {
+              DFBRectangle r = { rect.x, rect.y+y, data->width, 1 };
+
+              dfb_copy_buffer_32 (data->common.image + y * data->width,
+                                  lock.addr, lock.pitch, &r, dst_surface,
+                                  &clip );
+
+              if (data->common.base.render_callback)
+                {
+                  r = (DFBRectangle) { 0, y, data->width, 1 };
+                  cb_result = data->common.base.render_callback (&r,
+                                                                 data->common.base.render_callback_context);
+                }
+            }
+        }
+
+      if (!direct)
+        {
+          dfb_scale_linear_32 (data->common.image, data->width, data->height,
+                               lock.addr, lock.pitch, &rect, dst_surface,
+                               &clip);
+
+          if (data->common.base.render_callback)
+            {
+              DFBRectangle r = { 0, 0, data->width, data->height };
+
+              data->common.base.render_callback (&r,
+                                                 data->common.base.render_callback_context);
+            }
+        }
+
+      if (cb_result != DIRCR_OK)
+        {
+          D_FREE (data->common.image);
+          data->common.image = NULL;
+          ret = DFB_INTERRUPTED;
+        }
+    }
+  else
+    {
+      dfb_scale_linear_32 (data->common.image, data->width, data->height,
+                           lock.addr, lock.pitch, &rect, dst_surface, &clip);
+
+      if (data->common.base.render_callback)
+        {
+          DFBRectangle r = {0, 0, data->width, data->height};
+          data->common.base.render_callback (&r,
+                                             data->common.base.render_callback_context);
+        }
+    }
+
+  //dfb_surface_dump (data->common.core, dst_surface, "results", "RLE-H2");
+
+  dfb_surface_unlock_buffer (dst_surface, &lock);
+  return ret;
+}
+
+static void
+IDirectFBImageProvider_RLE_Destruct (IDirectFBImageProvider *thiz)
+{
+  IDirectFBImageProvider_RLE_data *data = thiz->priv;
+
+#if defined(RLE_PROVIDER_HW)
+  dlclose (data->stgfx2_handle);
+#endif /* RLE_PROVIDER_HW */
+
+  if (data->common.image)
+    D_FREE (data->common.image);
+  if (data->image_indexes)
+    D_FREE (data->image_indexes);
+  if (data->palette)
+    D_FREE (data->palette);
+
+#if defined(RLE_PROVIDER_HW)
+  if (data->compressed_data)
+    {
+      dfb_surface_unref (data->compressed_data);
+      data->compressed_data = NULL;
+    }
+#endif
+
+#if defined(RLE_PROVIDER_USE_MME)
+  if (data->common.decode_surface)
+    dfb_surface_unref( data->common.decode_surface );
+#endif
+}
+
+static DFBResult
+IDirectFBImageProvider_RLE_GetSurfaceDescription (IDirectFBImageProvider *thiz,
+                                                  DFBSurfaceDescription  *desc)
+{
+  DIRECT_INTERFACE_GET_DATA (IDirectFBImageProvider_RLE)
+
+  if (!desc)
+    return DFB_INVARG;
+
+  desc->flags       = DSDESC_WIDTH | DSDESC_HEIGHT | DSDESC_PIXELFORMAT | DSDESC_CAPS;
+  desc->width       = data->width;
+  desc->height      = data->height;
+  desc->pixelformat = (data->indexed) ? DSPF_LUT8 : DSPF_RGB32;
+  desc->caps        = DSCAPS_NONE;
+
+  return DFB_OK;
+}
+
+static DFBResult
+IDirectFBImageProvider_RLE_GetImageDescription (IDirectFBImageProvider *thiz,
+                                                DFBImageDescription    *desc)
+{
+  DIRECT_INTERFACE_GET_DATA (IDirectFBImageProvider_RLE)
+
+  if (!desc)
+    return DFB_INVARG;
+
+  desc->caps = DICAPS_NONE;
+
+  return DFB_OK;
+}
+
+/*******************************************************************************
+ *
+ *              PUBLIC INTERFACE EXPORTED SYMBOLS SECTION
+ *
+ *******************************************************************************/
+
+static DFBResult
+Probe (IDirectFBImageProvider_ProbeContext *ctx)
+{
+  /* 2 bytes of Magic */
+  if (IS_MAGIC (ctx->header,'R','L')
+      || IS_MAGIC (ctx->header,'B','M'))
+    return DFB_OK;
+
+  return DFB_UNSUPPORTED;
+}
+
+#ifdef ALLOW_DUMP_RAW_TO_FILE
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+static char filename[4096];
+static const char *
+_get_filename (const char * const directory,
+               const char * const prefix,
+               int        * const idx)
+{
+  unsigned int num = 0;
+
+  if (prefix)
+    {
+      /* find the lowest unused index */
+      int found = false;
+      while (!found && ++num < 100000)
+        {
+          snprintf (filename, sizeof (filename),
+                    "%s/%s_%05d.rle", directory, prefix, num);
+          if (access (filename, F_OK) != 0)
+            /* found an available filename */
+            found = true;
+        }
+
+      if (!found)
+        {
+          D_ERROR ("DirectFBImageProvider_RLE:: "
+                   "couldn't find an unused index for RLE dump!\n");
+          return NULL;
+        }
+    }
+
+  if (idx)
+    *idx = num;
+
+  return filename;
+}
+#endif /* ALLOW_DUMP_RAW_TO_FILE */
+
+static DFBResult
+Construct (IDirectFBImageProvider *thiz,
+           ...)
+{
+  DFBResult ret;
+
+  IDirectFBDataBuffer *buffer;
+  CoreDFB             *core;
+  va_list              tag;
+
+  DIRECT_ALLOCATE_INTERFACE_DATA (thiz, IDirectFBImageProvider_RLE)
+
+  va_start (tag, thiz);
+  buffer = va_arg (tag, IDirectFBDataBuffer *);
+  core = va_arg (tag, CoreDFB *);
+  va_end (tag);
+
+  data->common.base.ref    = 1;
+  data->common.base.buffer = buffer;
+  data->common.base.core   = core;
+
+#if defined(RLE_PROVIDER_HW)
+  if (dfb_system_get_accelerator () == FB_ACCEL_ST_BDISP_USER)
+    {
+      data->stgfx2_handle = dlopen ("libdirectfb_stgfx2.so", RTLD_LAZY);
+      data->rle_stretch = dlsym (data->stgfx2_handle,
+                                 "bdisp_aq_StretchBlit_RLE");
+    }
+#endif
+
+  buffer->AddRef (buffer);
+
+#ifdef ALLOW_DUMP_RAW_TO_FILE
+  if (getenv ("RLE_DUMP_RAW_TO_FILE"))
+  {
+  const char * const fn = _get_filename ("/tmp/rle", "raw", &data->idx);
+  if (fn)
+    {
+      unsigned char buf[1024];
+      unsigned int len = sizeof (buf);
+
+      int dump_fd = open (fn, O_RDWR | O_CREAT | O_TRUNC, 0644);
+      if (dump_fd != -1)
+        {
+          DFBResult res;
+          unsigned int ret_len = len;
+          unsigned int total = 0;
+
+          while (len)
+            {
+              res = buffer->WaitForData (buffer, len);
+              if (res == DFB_OK)
+                res = buffer->GetData (buffer, len, buf, &ret_len);
+
+              if (res)
+                break;
+
+              write (dump_fd, buf, ret_len);
+
+              len = ret_len;
+
+              total += ret_len;
+            }
+          D_DEBUG_AT (HWRLE, "%s: wrote %d bytes to %d\n",
+                      __FUNCTION__, total, data->idx);
+
+          fsync (dump_fd);
+          close (dump_fd);
+          buffer->SeekTo (buffer, 0);
+        }
+    }
+  sync ();
+  sync ();
+  sync ();
+  }
+#endif /* ALLOW_DUMP_RAW_TO_FILE */
+
+  ret = rle_decode_header (data);
+  if (ret)
+    {
+      IDirectFBImageProvider_RLE_Destruct (thiz);
+      return ret;
+    }
+
+  data->common.base.Destruct = IDirectFBImageProvider_RLE_Destruct;
+
+  thiz->RenderTo              = IDirectFBImageProvider_RLE_RenderTo;
+  thiz->GetImageDescription   = IDirectFBImageProvider_RLE_GetImageDescription;
+  thiz->GetSurfaceDescription = IDirectFBImageProvider_RLE_GetSurfaceDescription;
+
+  return DFB_OK;
+}
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/interfaces/IDirectFBImageProvider/idirectfbimageprovider_rle.h DirectFB-1.4.12+STM2011.09.27/interfaces/IDirectFBImageProvider/idirectfbimageprovider_rle.h
--- DirectFB/interfaces/IDirectFBImageProvider/idirectfbimageprovider_rle.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/interfaces/IDirectFBImageProvider/idirectfbimageprovider_rle.h	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,135 @@
+#ifndef __IDIRECTFBIMAGEPROVIDER_RLE_H__
+#define __IDIRECTFBIMAGEPROVIDER_RLE_H__
+
+#include <stdarg.h>
+
+#include <direct/messages.h>
+
+
+#if defined(RLE_PROVIDER_USE_MME)
+/* HW Decode Requirements */
+#include <mme.h>
+#include <semaphore.h>
+
+#include <RLEDecode_interface.h>
+#endif /* RLE_PROVIDER_USE_MME */
+#if defined(RLE_PROVIDER_HW)
+#include <../gfxdrivers/stgfx2/bdisp_accel.h>
+#endif
+
+#define THIS_MODULE         "IDirectFBImageProvider_RLE"
+
+
+#ifdef  USE_MEDIA_TRACE
+#define TRACE(data) \
+    D_INFO(THIS_MODULE": %4.2xh (%6.2d) -> "#data"\n", (int)(data), (int)(data))
+#else
+#define TRACE(data)
+#endif
+
+
+/* local types */
+typedef        unsigned char    uchar;
+typedef        unsigned int     uint;
+typedef        unsigned long    ulong;
+typedef        unsigned short   ushort;
+
+
+
+/*
+ * RLE Compression identifier (see BMP/RLE header - Offset:30 --- DWORD)
+ */
+typedef enum {
+  RLEIC_NONE      = 0,   /* Implemented      as of version 1.0.0 */
+  RLEIC_RLE8      = 1,   /* Implemented      as of version 1.0.0 */
+  RLEIC_RLE4      = 2,   /* Unimplemented */
+  RLEIC_BITFIELDS = 3,   /* Unimplemented */
+  RLEIC_BD_RLE8   = 4,   /* Implemented      as of version 1.1.0 */
+  RLEIC_H2_DVD    = 5,   /* Implemented      as of version 1.1.3-7 */
+  RLEIC_H8_DVD    = 6    /* Implemented      as of version 1.1.3-7 */
+} RLEImageCompression;
+
+
+
+/*
+ * Header info
+ */
+#define RLE_PREAMBLE_SIZE         (14)
+#define RLE_BIHEADER_SIZE         (40)
+#define RLE_HEADER_SIZE           (RLE_PREAMBLE_SIZE+RLE_BIHEADER_SIZE)
+#define RLE_PALETTE_IMAGE_OFFSET  (0x36)
+
+/*
+ * Private service data structure
+ */
+typedef struct IDirectFBImageProvider_RLE_data_t
+{
+  struct _MMECommon common;
+
+  uint                   magic;
+  uint                   file_size;
+  uint                   reserved;
+  uint                   img_offset;
+  uint                   payload_size;
+
+  uint                   width;
+  uint                   height;
+  uint                   depth;
+  uint                   num_planes;
+  uint                   num_colors;
+  uint                   imp_colors;
+  RLEImageCompression    compression;
+  uint                   h_resolution;
+  uint                   v_resolution;
+
+  bool                   indexed;
+  bool                   topfirst;
+  bool                   no_palette;
+  bool                   compressed;
+
+  int                    height_dib;
+  int                    pitch;
+
+  DFBColor              *palette;
+  u8                    *image_indexes;
+
+#if defined(RLE_PROVIDER_HW)
+  void                          *stgfx2_handle;
+  bdisp_aq_StretchBlit_RLE_func  rle_stretch;
+  CoreSurface           *compressed_data;
+#endif
+
+#if defined(RLE_PROVIDER_USE_MME)
+  /* Hardware Variables */
+  RLEDecode_TransformReturnParams_t ReturnParams;
+#endif /* RLE_PROVIDER_USE_MME */
+
+#ifdef ALLOW_DUMP_RAW_TO_FILE
+  int idx;
+#endif /* DUMP_RAW_TO_FILE */
+} IDirectFBImageProvider_RLE_data;
+
+
+
+#if defined(RLE_PROVIDER_USE_MME)
+/****************************************************************************/
+static inline const char *
+get_rle_error_string (RLEDecode_ErrorCodes_t e)
+{
+  static const char *RLEErrorType_strings[] = {
+    "RLEDECODE_NO_ERROR",
+    "RLEDECODE_MEMEORY_ALLOCATION_ERROR",
+    "RLEDECODE_CRC_ERROR",
+    "RLEDECODE_INVALID_STREAM",
+    "RLEDECODE_INTERNAL_ERROR"
+  };
+
+  return (((unsigned int) e) < D_ARRAY_SIZE (RLEErrorType_strings))
+         ? RLEErrorType_strings[e]
+         : "* Unknown RleError code *";
+}
+#endif /* RLE_PROVIDER_USE_MME */
+
+
+
+#endif /* __IDIRECTFBIMAGEPROVIDER_RLE_H__ */
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/interfaces/IDirectFBImageProvider/Makefile.am DirectFB-1.4.12+STM2011.09.27/interfaces/IDirectFBImageProvider/Makefile.am
--- DirectFB/interfaces/IDirectFBImageProvider/Makefile.am	2015-06-02 22:40:08.131541622 +0200
+++ DirectFB-1.4.12+STM2011.09.27/interfaces/IDirectFBImageProvider/Makefile.am	2012-06-06 18:41:31.000000000 +0200
@@ -20,13 +20,33 @@
 PNG_PROVIDER_LTLIB = 
 endif
 
+if RLE_PROVIDER
+RLE_PROVIDER_LTLIB = libidirectfbimageprovider_rle.la
+else
+RLE_PROVIDER_LTLIB =
+endif
+
+
+if MME_USE_OWN_HEADERS
+MME_INCLUDE_PATH = -I$(top_srcdir)/interfaces/IDirectFBImageProvider/mme
+else
+MME_INCLUDE_PATH =
+endif
+if MME_USE_OWN_TRANSFORMERS
+TRANSFORMER_INCLUDE_PATH = -I$(top_srcdir)/interfaces/IDirectFBImageProvider/mme/transform
+else
+TRANSFORMER_INCLUDE_PATH =
+endif
 
 INCLUDES = \
 	-I$(top_builddir)/include	\
 	-I$(top_builddir)/lib	\
 	-I$(top_srcdir)/include	\
 	-I$(top_srcdir)/lib	\
-	-I$(top_srcdir)/src
+	-I$(top_srcdir)/src	\
+	-I$(top_srcdir)/systems	\
+	$(MME_INCLUDE_PATH)	\
+	$(TRANSFORMER_INCLUDE_PATH)
 
 AM_CPPFLAGS = -DDATADIR=\"${RUNTIME_SYSROOT}@DATADIR@\" $(LIBJPEG_CFLAGS) $(LIBPNG_CFLAGS)
 
@@ -34,7 +54,8 @@
 	libidirectfbimageprovider_dfiff.la	\
 	$(GIF_PROVIDER_LTLIB)			\
 	$(JPEG_PROVIDER_LTLIB)			\
-	$(PNG_PROVIDER_LTLIB)
+	$(PNG_PROVIDER_LTLIB)			\
+	$(RLE_PROVIDER_LTLIB)
 
 if BUILD_STATIC
 idirectfbimageprovider_DATA = $(idirectfbimageprovider_LTLIBRARIES:.la=.o)
@@ -46,7 +67,8 @@
 libidirectfbimageprovider_png_la_LIBADD = \
 	$(top_builddir)/lib/direct/libdirect.la \
 	$(top_builddir)/src/libdirectfb.la \
-	$(LIBPNG_LIBS)
+	$(LIBPNG_LIBS) \
+	$(PNG_LIBMME)
 
 libidirectfbimageprovider_png_la_LDFLAGS = -avoid-version -module
 
@@ -74,9 +96,20 @@
 libidirectfbimageprovider_jpeg_la_LIBADD = \
 	$(top_builddir)/lib/direct/libdirect.la \
 	$(top_builddir)/src/libdirectfb.la \
-	$(LIBJPEG)
+	$(LIBJPEG) \
+	$(JPEG_LIBMME)
 
 libidirectfbimageprovider_jpeg_la_LDFLAGS = -avoid-version -module
 
 
+libidirectfbimageprovider_rle_la_SOURCES = idirectfbimageprovider_rle.c
+
+libidirectfbimageprovider_rle_la_LIBADD = \
+	$(top_builddir)/lib/direct/libdirect.la \
+	$(top_builddir)/src/libdirectfb.la \
+	$(RLE_LIBMME)
+
+libidirectfbimageprovider_rle_la_LDFLAGS = -avoid-version -module
+
+
 include $(top_srcdir)/rules/libobject.make
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/interfaces/IDirectFBImageProvider/mme/mme.h DirectFB-1.4.12+STM2011.09.27/interfaces/IDirectFBImageProvider/mme/mme.h
--- DirectFB/interfaces/IDirectFBImageProvider/mme/mme.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/interfaces/IDirectFBImageProvider/mme/mme.h	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,507 @@
+/*******************************************************************/
+/* Copyright 2004 STMicroelectronics R&D Ltd. All rights reserved. */
+/*                                                                 */
+/* File: mme.h                                                     */
+/*                                                                 */
+/* Description:                                                    */
+/*         Public export header for the MME API.                   */
+/*                                                                 */
+/*******************************************************************/
+
+#ifndef _MME_H
+#define _MME_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif				/* __cplusplus */
+
+/* Constants */
+
+#define MME_MAX_TRANSFORMER_NAME ((unsigned int) 128)
+
+#define MME_MAX_CACHE_LINE		32
+#define MME_CACHE_LINE_ALIGN(X)		((void*)(((unsigned) (X) + (MME_MAX_CACHE_LINE-1)) & ~(MME_MAX_CACHE_LINE-1)))
+#define MME_CACHE_LINE_ALIGNED(X)	(((unsigned) (X) & (MME_MAX_CACHE_LINE-1)) == 0)
+
+/* Aliased names for some of the inconstantly named (or simply overly long) identifiers */
+
+#define MME_Deinit     MME_Term
+#define MME_Error_t    MME_ERROR
+#define MME_NO_MEMORY  MME_NOMEM
+#define MME_SET_PARAMS MME_SET_GLOBAL_TRANSFORM_PARAMS
+
+/* Version info */
+
+#define __MULTICOM_VERSION__          "multicom : 3.2.4 (RC3)"
+#define __MULTICOM_VERSION_MAJOR__    (3)
+#define __MULTICOM_VERSION_MINOR__    (2)
+#define __MULTICOM_VERSION_PATCH__    (4)
+
+/* Version macros like the ones found in Linux */
+#define MULTICOM_VERSION(a,b,c)       (((a) << 16) + ((b) << 8) + (c))
+#define MULTICOM_VERSION_CODE	      MULTICOM_VERSION(__MULTICOM_VERSION_MAJOR__, __MULTICOM_VERSION_MINOR__, __MULTICOM_VERSION_PATCH__)
+
+/* Enumerations */
+
+/* MME_AllocationFlags_t: 
+ * Used to qualify memory allocation
+ */
+typedef enum MME_AllocationFlags_t {
+	MME_ALLOCATION_PHYSICAL = 1,
+	MME_ALLOCATION_CACHED = 2,
+	MME_ALLOCATION_UNCACHED = 4
+} MME_AllocationFlags_t;
+
+/* MME_CommandCode_t: 
+ * Used to specify a command to a transfomer
+ */
+typedef enum MME_CommandCode_t {
+	MME_SET_GLOBAL_TRANSFORM_PARAMS,
+	MME_TRANSFORM,
+	MME_SEND_BUFFERS
+} MME_CommandCode_t;
+
+/* MME_CommandState_t:
+ * Used to specify the current state of a submitted command
+ */
+typedef enum MME_CommandState_t {
+	MME_COMMAND_IDLE,
+	MME_COMMAND_PENDING,
+	MME_COMMAND_EXECUTING,
+	MME_COMMAND_COMPLETED,
+	MME_COMMAND_FAILED
+} MME_CommandState_t;
+
+/* MME_CommandEndType_t:
+ * Used to specify whether the host callback should be
+ * called on command completion
+ */
+typedef enum MME_CommandEndType_t {
+	MME_COMMAND_END_RETURN_NO_INFO,
+	MME_COMMAND_END_RETURN_NOTIFY
+} MME_CommandEndType_t;
+
+/* MME_Event_t:
+ * Used to indicate a transform event type to the host callback
+ */
+typedef enum MME_Event_t {
+	MME_COMMAND_COMPLETED_EVT,
+	MME_DATA_UNDERFLOW_EVT,
+	MME_NOT_ENOUGH_MEMORY_EVT,
+	MME_NEW_COMMAND_EVT,
+	MME_TRANSFORMER_TIMEOUT
+} MME_Event_t;
+
+
+/* MME_ERROR:
+ * The errors that may be returned by MME API functions or by
+ * transformer entry point functions
+ */
+typedef enum MME_ERROR {
+	MME_SUCCESS = 0,
+	MME_DRIVER_NOT_INITIALIZED,
+	MME_DRIVER_ALREADY_INITIALIZED,
+	MME_NOMEM,
+	MME_INVALID_TRANSPORT,
+	MME_INVALID_HANDLE,
+	MME_INVALID_ARGUMENT,
+	MME_UNKNOWN_TRANSFORMER,
+	MME_TRANSFORMER_NOT_RESPONDING,
+	MME_HANDLES_STILL_OPEN,
+	MME_COMMAND_STILL_EXECUTING,
+	MME_COMMAND_ABORTED,
+	MME_DATA_UNDERFLOW,
+	MME_DATA_OVERFLOW,
+	MME_TRANSFORM_DEFERRED,
+	MME_SYSTEM_INTERRUPT,
+        MME_EMBX_ERROR,
+	MME_INTERNAL_ERROR,
+        MME_NOT_IMPLEMENTED
+} MME_ERROR;
+
+/* MME_CacheFlags_t
+ * Cache management flags used allow domain specific communication optimizations to be applied
+ */
+typedef enum MME_CacheFlags_t {
+	MME_DATA_CACHE_COHERENT = (int) ((unsigned) 1 << 31),
+	MME_DATA_TRANSIENT = (1 << 30),
+	MME_REMOTE_CACHE_COHERENT = (1 << 29),
+	MME_DATA_PHYSICAL = (1 << 28)
+} MME_CacheFlags_t;
+
+/* MME_Tuneable_t:
+ * Keys used to modify tuneable parameters
+ */
+typedef enum {
+	/* no need to MME_THREAD_STACK_SIZE, this is managed by the EMBX call */
+	MME_TUNEABLE_MANAGER_THREAD_PRIORITY,
+	MME_TUNEABLE_TRANSFORMER_THREAD_PRIORITY,
+	MME_TUNEABLE_EXECUTION_LOOP_HIGHEST_PRIORITY,
+	MME_TUNEABLE_EXECUTION_LOOP_ABOVE_NORMAL_PRIORITY,
+	MME_TUNEABLE_EXECUTION_LOOP_NORMAL_PRIORITY,
+	MME_TUNEABLE_EXECUTION_LOOP_BELOW_NORMAL_PRIORITY,
+	MME_TUNEABLE_EXECUTION_LOOP_LOWEST_PRIORITY,
+	/* TIMEOUT SUPPORT - allow default timeout to be modified */
+	MME_TUNEABLE_TRANSFORMER_TIMEOUT,
+
+	MME_TUNEABLE_MAX
+} MME_Tuneable_t;
+		
+/* MME_Priority_t:
+ * The MME scheduler priority at which a transform is executed
+ */
+typedef enum MME_Priority_t {
+	MME_PRIORITY_HIGHEST = 5000,
+	MME_PRIORITY_ABOVE_NORMAL = 4000,
+	MME_PRIORITY_NORMAL = 3000,
+	MME_PRIORITY_BELOW_NORMAL = 2000,
+	MME_PRIORITY_LOWEST = 1000
+} MME_Priority_t;
+
+/* Types: simple */
+
+/* CPU architecture-specfic */
+
+#if defined __SH4__ || defined __sh__
+/* SH4/ST40 */
+typedef unsigned int MME_UINT;
+typedef double       MME_GENERIC64;
+#define              MME_MaxTime_c 0xffffffff
+#elif defined __CORE__
+/* ST20 */
+typedef unsigned int MME_UINT;
+typedef double       MME_GENERIC64;
+#define              MME_MaxTime_c 0xffffffff
+#elif defined __ST200__ || defined __st200__
+/* ST200 */
+typedef unsigned int MME_UINT;
+typedef double       MME_GENERIC64;
+#define              MME_MaxTime_c 0xffffffff
+#elif defined __IA32__ || defined __i386__
+typedef unsigned int MME_UINT;
+typedef double       MME_GENERIC64;
+#define              MME_MaxTime_c 0xffffffff
+#else
+#error Unsupported CPU type
+#endif
+
+/* TIMEOUT SUPPORT: Maximum timeout value which basically means don't timeout */
+#define MME_TIMEOUT_INFINITE	MME_MaxTime_c
+
+/* Arhitecture neutral */
+/* MME_Time_t: 
+ * MME time
+ */
+typedef MME_UINT MME_Time_t;
+
+/* MME_GenericParams_t: 
+ * A transformer specific parameter
+ */
+typedef void* MME_GenericParams_t;
+
+/* MME_CommandId_t: 
+ * The identifier assigned by MME to a submitted command
+ */
+typedef MME_UINT MME_CommandId_t;
+
+/* MME_TransformerHandle_t: 
+ * The handle of a transformer instance assigned by MME
+ */
+typedef MME_UINT MME_TransformerHandle_t;
+
+/* Types: structures */
+
+/* MME_CommandStatus_t:
+ * Structure containing state associated with a command
+ */
+typedef struct MME_CommandStatus_t {
+	MME_CommandId_t      CmdId;
+	MME_CommandState_t   State;
+	MME_Time_t           ProcessedTime;
+	MME_ERROR            Error;
+	MME_UINT             AdditionalInfoSize;
+	MME_GenericParams_t  AdditionalInfo_p;
+} MME_CommandStatus_t;
+
+/* MME_ScatterPage_t:
+ * Structure describing a single scatter page - see MME_DataBuffer_t
+ */
+typedef struct MME_ScatterPage_t {
+	void*    Page_p;
+	MME_UINT Size;
+	MME_UINT BytesUsed;
+	MME_UINT FlagsIn;
+	MME_UINT FlagsOut;
+} MME_ScatterPage_t;
+
+/* MME_DataBuffer_t:
+ * Structure describing a data buffer
+ */
+typedef struct MME_DataBuffer_t {
+	MME_UINT              StructSize;
+	void*                 UserData_p;
+	MME_UINT              Flags;
+	MME_UINT              StreamNumber;
+	MME_UINT              NumberOfScatterPages;
+	MME_ScatterPage_t*    ScatterPages_p;
+	MME_UINT              TotalSize;
+	MME_UINT              StartOffset;
+} MME_DataBuffer_t;
+
+/* MME_Command_t:
+ * Structure to pass a command to a transformer
+ */
+typedef struct MME_Command_t {
+	MME_UINT                  StructSize;
+	MME_CommandCode_t         CmdCode;
+	MME_CommandEndType_t      CmdEnd;
+	MME_Time_t                DueTime;
+	MME_UINT                  NumberInputBuffers;
+	MME_UINT                  NumberOutputBuffers;
+	MME_DataBuffer_t**        DataBuffers_p;
+	MME_CommandStatus_t	  CmdStatus;
+	MME_UINT                  ParamSize;
+	MME_GenericParams_t       Param_p;
+} MME_Command_t;
+
+/* MME_DataFormat_t:
+ * Structure describing the data format that a transformer supports
+ */
+typedef struct MME_DataFormat_t {
+	unsigned char FourCC[4];
+} MME_DataFormat_t;
+
+
+/* MME_TransformerCapability_t:
+ * Structure containg information pertaining to a transformers capability
+ */
+typedef struct MME_TransformerCapability_t {
+	MME_UINT             StructSize;
+	MME_UINT             Version;
+	MME_DataFormat_t     InputType;
+	MME_DataFormat_t     OutputType;
+	MME_UINT             TransformerInfoSize;
+	MME_GenericParams_t  TransformerInfo_p;
+} MME_TransformerCapability_t;
+
+
+/* Host callback function */
+typedef void (*MME_GenericCallback_t) (MME_Event_t Event, MME_Command_t * CallbackData, void *UserData);
+
+/* MME_TransformerInitParams_t:
+ * The paramters with which to initialize a transformer
+ */
+typedef struct MME_TransformerInitParams_t {
+	MME_UINT		StructSize;
+	MME_Priority_t		Priority;
+	MME_GenericCallback_t	Callback;
+	void*			CallbackUserData;
+	MME_UINT		TransformerInitParamsSize;
+	MME_GenericParams_t	TransformerInitParams_p;
+} MME_TransformerInitParams_t;
+
+/* Types: functions */
+
+/* Transformer: AbortCommand entry point */
+typedef MME_ERROR (*MME_AbortCommand_t) (void *context, MME_CommandId_t commandId);
+
+/* Transformer: GetTransformerCapability entry point */
+typedef MME_ERROR (*MME_GetTransformerCapability_t) (MME_TransformerCapability_t * capability);
+
+/* Transformer: InitTransformer entry point */
+typedef MME_ERROR (*MME_InitTransformer_t) (MME_UINT initParamsLength, MME_GenericParams_t initParams, void **context);
+
+/* Transformer: ProcessCommand entry point */
+typedef MME_ERROR (*MME_ProcessCommand_t) (void *context, MME_Command_t * commandInfo);
+
+/* Transformer: TermTransformer entry point */
+typedef MME_ERROR (*MME_TermTransformer_t) (void *context);
+
+/* Macros */
+
+/* These macros are shown in their most simplistic form. On mixed endian   
+ * systems these macros can use (sizeof(field) == n) if networks to cope.
+ * Since such a network can be solved at compile time this would not impact
+ * runtime performance.
+ */
+
+/* MME_PARAM has a different implementation of machines with a different
+ * endiannes. This permits the MME implementation on a big endian machine
+ * to perform a 64-bit byte swap
+ */
+
+#if defined (__CORE__) || defined(__SH4__) || defined(__ST200__) || defined(__IA32__) || defined(__i386__)
+/* this is the definition of MME_PARAM for little endian machines */
+#define _MME_PARAM_ADDRESS(p, f)   ((MME_TYPE_##f*)(((MME_GENERIC64*)p)+MME_OFFSET_##f))
+
+#else
+/* this is the definition of MME_PARAM for big endian machines */
+#define _MME_PARAM_ADDRESS(p, f)   \
+        ((MME_TYPE_##f *)(((char *)((MME_GENERIC64*)p+MME_OFFSET_##f))+(sizeof(MME_GENERIC64)-sizeof(MME_TYPE_##f))))
+
+/* At the moment we do not support BE machines */
+#error Unsupported CPU type
+#endif
+
+/* A parameter */
+#define MME_PARAM(p, f)            (*_MME_PARAM_ADDRESS(p, f))
+
+/* A parameter sublist */
+#define MME_PARAM_SUBLIST(p, f)    _MME_PARAM_ADDRESS(p, f)
+
+/* Access a parameter at a given index */
+#define MME_INDEXED_PARAM(p, f, i) (*((MME_TYPE_##f*)(((MME_GENERIC64*)p)+MME_OFFSET_##f+(i))))
+
+/* Get number of paramters */
+#define MME_LENGTH(id)             (MME_LENGTH_##id)
+
+/* Get number of paramters */
+#define MME_LENGTH_BYTES(id)       ((MME_LENGTH_##id)*sizeof(MME_GENERIC64))
+
+/* Function declarations */
+
+/* MME_AbortCommand()
+ * Attempt to abort a submitted command 
+ */
+MME_ERROR MME_AbortCommand(MME_TransformerHandle_t Handle, MME_CommandId_t CmdId);
+
+/* MME_KillCommand()
+ * Abort a command without communicating with the remote processor. Should only be used 
+ * when we know the transformer processor has definitely crashed
+ */
+MME_ERROR MME_KillCommand(MME_TransformerHandle_t Handle, MME_CommandId_t CmdId);
+
+/* MME_KillCommandAll()
+ * Abort all commands without communicating with the remote processor. Should only be used 
+ * when we know the transformer processor has definitely crashed
+ */
+MME_ERROR MME_KillCommandAll(MME_TransformerHandle_t Handle);
+
+/* MME_AllocDataBuffer()
+ * Allocate a data buffer that is optimal for the transformer instantiation
+ * to pass between a host and companion
+ */
+MME_ERROR MME_AllocDataBuffer(  MME_TransformerHandle_t handle,
+				MME_UINT size,
+				MME_AllocationFlags_t flags,
+				MME_DataBuffer_t ** dataBuffer_p);
+
+/* MME_DeregisterTransformer()
+ * Deregister a transformer that has been registered
+ */
+MME_ERROR MME_DeregisterTransformer(const char *name);
+
+/* MME_DeregisterTransport()
+ * Deregister an EMBX transport being used by MME
+ */
+MME_ERROR MME_DeregisterTransport(const char *name);
+
+/* MME_FreeDataBuffer()
+ * Free a buffer previously allocated with MME_AllocDataBuffer 
+ */
+MME_ERROR MME_FreeDataBuffer(MME_DataBuffer_t * DataBuffer_p);
+
+/* MME_GetTransformerCapability()
+ * Obtain the capabilities of a transformer 
+ */
+MME_ERROR MME_GetTransformerCapability(const char *TransformerName,
+					       MME_TransformerCapability_t * TransformerCapability_p);
+
+/* MME_Init()
+ * Initialize MME 
+ */
+MME_ERROR MME_Init(void);
+
+/* MME_InitTransformer()
+ * Create a transformer instance on a companion 
+ */
+MME_ERROR MME_InitTransformer(const char *Name,
+        		      MME_TransformerInitParams_t * Params_p, 
+                              MME_TransformerHandle_t * Handle_p);
+  
+/* MME_InitTransformer()
+ * Create a transformer instance on a companion (using Callbacks on the host)
+ */
+MME_ERROR MME_InitTransformer_Callback(const char *Name,
+				       MME_TransformerInitParams_t * Params_p, 
+				       MME_TransformerHandle_t * Handle_p);
+
+/* MME_ModifyTuneable()
+ * Modify system wide configuration parameters such as thread priority.
+ */
+MME_ERROR MME_ModifyTuneable(MME_Tuneable_t key, MME_UINT value);
+
+/* MME_NotifyHost()
+ * Notify the host that a transformer event has occurred
+ */
+MME_ERROR MME_NotifyHost(MME_Event_t event, MME_Command_t * commandInfo, MME_ERROR errorCode);
+
+/* MME_RegisterTransformer()
+ * Register a transformer after which instantiations may be made
+ */
+MME_ERROR MME_RegisterTransformer(const char *name,
+				  MME_AbortCommand_t abortFunc,
+				  MME_GetTransformerCapability_t getTransformerCapabilityFunc,
+				  MME_InitTransformer_t initTransformerFunc,
+				  MME_ProcessCommand_t processCommandFunc,
+				  MME_TermTransformer_t termTransformerFunc);
+
+/* MME_RegisterTransformer_Callback() - using callbacks rather than helper threads
+ * Register a transformer after which instantiations may be made
+ */
+MME_ERROR MME_RegisterTransformer_Callback(const char *name,
+					   MME_AbortCommand_t abortFunc,
+					   MME_GetTransformerCapability_t getTransformerCapabilityFunc,
+					   MME_InitTransformer_t initTransformerFunc,
+					   MME_ProcessCommand_t processCommandFunc,
+					   MME_TermTransformer_t termTransformerFunc);
+
+/* MME_RegisterTransport()
+ * Register an existing EMBX transport for use by MME
+ */
+MME_ERROR MME_RegisterTransport(const char *name);
+
+/* MME_Run()
+ * Run the MME message loop on a companion CPU
+ */
+MME_ERROR MME_Run(void);
+
+/* MME_SendCommand()
+ * Send a transformer command to a transformer instance
+ */
+MME_ERROR MME_SendCommand(MME_TransformerHandle_t Handle, MME_Command_t * CmdInfo_p);
+
+/* MME_Term()
+ * Terminate MME
+ */
+MME_ERROR MME_Term(void);
+
+/* MME_TermTransformer()
+ * Terminate a transformer instance
+ */
+MME_ERROR MME_TermTransformer(MME_TransformerHandle_t handle);
+
+/* MME_KillTransformer()
+ * Terminate a transformer instance, without communicating 
+ * with the remote processor, which we assume has crashed
+ */
+MME_ERROR MME_KillTransformer(MME_TransformerHandle_t handle);
+
+/* MME_IsStillAlive()
+ * Ping a remote transformer to see if it's still running
+ * Sets alive to be non zero if it replies, zero otherwise
+ */
+MME_ERROR MME_IsStillAlive(MME_TransformerHandle_t handle, MME_UINT* alive);
+
+/*
+ * Multihost extensions
+ */
+MME_ERROR MME_HostRegisterTransport(const char *name);
+MME_ERROR MME_HostDeregisterTransport(const char* name);
+MME_ERROR MME_HostInit(void);
+MME_ERROR MME_HostTerm(void);
+
+#ifdef __cplusplus
+}
+#endif				/* __cplusplus */
+#endif				/* _MME_H */
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/interfaces/IDirectFBImageProvider/mme/transform/JPEGDECHW_VideoTransformerTypes.h DirectFB-1.4.12+STM2011.09.27/interfaces/IDirectFBImageProvider/mme/transform/JPEGDECHW_VideoTransformerTypes.h
--- DirectFB/interfaces/IDirectFBImageProvider/mme/transform/JPEGDECHW_VideoTransformerTypes.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/interfaces/IDirectFBImageProvider/mme/transform/JPEGDECHW_VideoTransformerTypes.h	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,211 @@
+///
+/// @file     : JPEGDECHW_VideoTransformerTypes.h
+///
+/// @brief    : JPEG Video Decoder specific types for MME
+///
+/// @par OWNER: 
+///
+/// @author   : Prabhat Awasthi
+///
+/// @par SCOPE:
+///
+/// @date     : 2008-08-01
+///
+/// &copy; 2006 ST Microelectronics. All Rights Reserved.
+///
+
+#ifndef _JPEGDECHW_VIDEOTRANSFORMERTYPES_H_
+#define _JPEGDECHW_VIDEOTRANSFORMERTYPES_H_
+
+#include "mme.h"
+#define OS21_TASKS
+
+/*===============================================
+               JPEG_DECODER
+===============================================*/
+
+#define JPEGHWDEC_MME_TRANSFORMER_NAME    "JPEG_DECODER_HW"
+
+#define JPEGHWDEC_MME_VERSION 1.1
+#define JPEGDECHW_NUMBER_OF_CEH_INTERVALS 32
+
+/*
+** JPEGDECHW_CompressedData_t :
+**   Defines the address type for the JPEGDECHW compressed data
+*/
+typedef MME_UINT *JPEGDECHW_CompressedData_t;
+
+
+/*
+** JPEGDECHW_LumaAddress_t :
+**   Defines the address type for the JPEGDECHW decoded Luma datas
+**   Bits 0 to 7 shall be set to 0 
+*/
+typedef MME_UINT *JPEGDECHW_LumaAddress_t;
+
+
+/*
+** JPEGDECHW_ChromaAddress_t :
+**   Defines the address type for the JPEGDECHW decoded Chroma datas 
+**   Bits 0 to 7 shall be set to 0
+*/
+typedef MME_UINT *JPEGDECHW_ChromaAddress_t;
+
+
+/*
+** JPEGDECHW_DecodedBufferAddress_t :
+**   Defines the addresses where the decoded picture/additional info related to the block 
+**   structures will be stored 
+*/
+typedef struct _JPEGDECHWDECODEDBUFFERADDRESS_T_
+{
+	JPEGDECHW_LumaAddress_t Luma_p;
+	JPEGDECHW_ChromaAddress_t Chroma_p;
+	JPEGDECHW_LumaAddress_t LumaDecimated_p;
+	JPEGDECHW_ChromaAddress_t ChromaDecimated_p;
+}	JPEGDECHW_DecodedBufferAddress_t;
+
+
+/*
+** JPEGDECHW_MainAuxEnable_t :
+** Used for enabling Main/Aux outputs
+*/
+typedef enum _JPEGDECHW_MAINAUXENABLE_T_
+{
+	JPEGDECHW_AUXOUT_EN       = 0x00000010, /* enable decimated reconstruction */
+	JPEGDECHW_MAINOUT_EN      = 0x00000020, /* enable main reconstruction */
+	JPEGDECHW_AUX_MAIN_OUT_EN = 0x00000030 /* enable both main & decimated reconstruction */
+}	JPEGDECHW_MainAuxEnable_t;
+
+
+/*
+** JPEGDECHW_HorizontalDeciFactor _t :
+** Identifies the horizontal decimation factor
+*/
+typedef enum _JPEGDECHW_HORIZONTALDECIFACTOR_T_
+{
+	JPEGDECHW_HDEC_1 = 0x00000000, /* no resize */
+    JPEGDECHW_HDEC_ADVANCED_2 = 0x00000101, /* Advanced H/2 resize using improved 8-tap filters */
+    JPEGDECHW_HDEC_ADVANCED_4 = 0x00000102  /* Advanced H/4 resize using improved 8-tap filters */
+}	JPEGDECHW_HorizontalDeciFactor_t;
+
+
+/*
+** JPEGDECHW_VerticalDeciFactor _t :
+** Identifies the vertical decimation factor
+*/
+typedef enum _JPEGDECHW_VERTICALDECIFACTOR_T_
+{
+	JPEGDECHW_VDEC_1 = 0x00000000, /* no resize */
+	JPEGDECHW_VDEC_ADVANCED_2_PROG = 0x00000204, /* V/2 , progressive resize */
+	JPEGDECHW_VDEC_ADVANCED_2_INT = 0x000000208 /* V/2 , interlaced resize */
+}	JPEGDECHW_VerticalDeciFactor_t;
+
+
+/*
+** JPEGDECHW_VideoDecodeInitParams_t :
+** Identifies the Initialization parameters for the transformer.
+*/
+typedef struct _JPEGDECHW_VIDEODECODEINITPARAMS_T_
+{
+	JPEGDECHW_CompressedData_t CircularBufferBeginAddr_p;
+	JPEGDECHW_CompressedData_t CircularBufferEndAddr_p;
+}	JPEGDECHW_VideoDecodeInitParams_t;
+
+
+/*
+** JPEGDECHW_DecodingError_t :
+** Status of the decoding process
+*/
+typedef enum
+{
+	/* The firmware has been sucessful */
+	JPEG_DECODER_NO_ERROR = 0,
+    JPEG_DECODER_ERROR_TASK_TIMEOUT = 8
+}	JPEGDECHW_DecodingError_t;
+
+
+/*
+** JPEGDECHW_DecodingMode_t :
+** Identifies the decoding mode.
+*/
+typedef enum
+{
+    JPEGDECHW_NORMAL_DECODE = 0,
+    /* Other values to be added later */
+}	JPEGDECHW_DecodingMode_t;
+
+
+/*
+** JPEGDECHW_AdditionalFlags_t :
+** Identifies the different flags that will be passed to JPEG firmware
+*/
+typedef enum
+{
+    JPEGDECHW_ADDITIONAL_FLAG_NONE = 0,
+    JPEGDECHW_ADDITIONAL_FLAG_CEH  = 1 /* Request firmware to return values of the CEH registers */
+}	JPEGDECHW_AdditionalFlags_t;
+
+
+/*
+** JPEGDECHW_VideoDecodeReturnParams_t :
+** Identifies the parameters to be returned back to the driver by decoder.
+*/
+typedef struct _JPEGDECHWVIDEODECODERETURNPARAMS_T_
+{
+	/* profiling info */
+	MME_UINT pm_cycles;
+	MME_UINT pm_dmiss;
+	MME_UINT pm_imiss;
+	MME_UINT pm_bundles;
+	MME_UINT pm_pft;
+	JPEGDECHW_DecodingError_t ErrorCode;
+#ifdef OS21_TASKS
+    MME_UINT DecodeTimeInMicros;
+#endif
+#ifdef CEH_SUPPORT
+    // CEHRegisters[] is an array where values of the
+    // Contrast Enhancement Histogram (CEH) registers will be stored.
+    // CEHRegisters[0] will correspond to register MBE_CEH_0_7, CEHRegisters[1] will
+    // correspond to register MBE_CEH_8_15., CEHRegisters[2], correspond to register
+    // MBE_CEH_16_23.
+    // Note that elements of this array will be updated only if
+    // VC9_TransformParam_t.AdditionalFlags will have the flag
+    // VC9_ADDITIONAL_FLAG_CEH set. They will remain unchanged otherwise.
+	MME_UINT CEHRegisters[JPEGDECHW_NUMBER_OF_CEH_INTERVALS];
+#endif
+}	JPEGDECHW_VideoDecodeReturnParams_t;
+
+
+/*
+** JPEGDECHW_VideoDecodeCapabilityParams_t :
+** Transformer capability parameters.
+*/
+typedef struct _JPEGDECHW_VIDEODECODECAPABILITYPARAMS_T_
+{
+	MME_UINT api_version;	// Omega2 frame buffer size (luma+chroma)
+}	JPEGDECHW_VideoDecodeCapabilityParams_t;
+
+
+/*
+** JPEGDECHW_VideoDecodeParams_t :
+** Parameters to be sent along with the Transform command
+*/
+typedef struct _JPEGDECHW_VIDEODECODEPARAMS_T_
+{
+	JPEGDECHW_CompressedData_t		PictureStartAddr_p;
+	JPEGDECHW_CompressedData_t		PictureEndAddr_p;
+	JPEGDECHW_DecodedBufferAddress_t DecodedBufferAddr;
+	JPEGDECHW_MainAuxEnable_t		MainAuxEnable;
+	JPEGDECHW_HorizontalDeciFactor_t HorizontalDecimationFactor;
+	JPEGDECHW_VerticalDeciFactor_t	VerticalDecimationFactor;
+	MME_UINT	xvalue0;				/* The X(0) coordinate for subregion decoding                                                 */
+	MME_UINT	xvalue1;				/* The X(1) coordinate for subregion decoding                                                 */
+	MME_UINT	yvalue0;				/* The Y(0) coordinate for subregion decoding                                                 */
+	MME_UINT	yvalue1;				/* The Y(1) coordinate for subregion decoding                                                */
+	JPEGDECHW_DecodingMode_t		DecodingMode;
+    JPEGDECHW_AdditionalFlags_t     AdditionalFlags; /* Additonal Flags for CEH */
+}	JPEGDECHW_VideoDecodeParams_t;
+
+#endif /* _JPEGDECHW_VIDEOTRANSFORMERTYPES_H_ */
+
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/interfaces/IDirectFBImageProvider/mme/transform/JPEG_VideoTransformerTypes.h DirectFB-1.4.12+STM2011.09.27/interfaces/IDirectFBImageProvider/mme/transform/JPEG_VideoTransformerTypes.h
--- DirectFB/interfaces/IDirectFBImageProvider/mme/transform/JPEG_VideoTransformerTypes.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/interfaces/IDirectFBImageProvider/mme/transform/JPEG_VideoTransformerTypes.h	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,122 @@
+/**
+*** @file     : Dvd_driver/MMEplus/Interface/Transformer/JPEG_DecoderTypes.h
+***
+*** @brief    : Structures and types for the MME JPEG decoder
+***
+*** @par OWNER: ST Microelectronics, JPEG Decoder Team
+***
+*** @author   : Sudipto Paul, Roland Schaufler
+***
+*** @par SCOPE:
+***
+*** @date     : 2003-09-24
+***
+*** &copy; 2003 ST Microelectronics. All Rights Reserved.
+**/
+
+
+#ifndef JPEG_DECODERTYPES_H
+#define JPEG_DECODERTYPES_H
+
+#include "mme.h"
+
+
+/* Common driver error constants */
+#define JPEGDEC_ERROR_ID   0
+#define JPEGDEC_ERROR_BASE (JPEG_ERROR_ID << 16)
+
+#define JPEGDEC_MME_TRANSFORMER_NAME "JPEG_Transformer" 
+
+#define JPEGDEC_MME_API_VERSION "1.0"
+
+
+
+
+/* Structure for GetTransformerCapability()                       */
+/* This structure is currently not used on the target because its */
+/* implemenation of the MME API layer does not support it yet!    */
+typedef struct
+	{
+	unsigned int 		dummy;                             /* For further expansion... */
+	} JPEGDEC_TransformerInfo_t;
+
+
+
+/* Structure for the Transformer Initialization */
+typedef struct
+	{
+	unsigned int		xvalue0;				/* The X(0) coardinate for subregion decoding                                                 */
+	unsigned int		xvalue1;				/* The X(1) coardinate for subregion decoding                                                 */
+	unsigned int		yvalue0;				/* The Y(0) coardinate for subregion decoding                                                 */
+	unsigned int		yvalue1;				/* The Y(1) coardinate for subregion decoding                                                 */
+	int					outputWidth;			/* Output width of the decoded image;used for IDCT select and resizing(if done in the core )  */
+	int					outputHeight;			/* Output height of the decoded image;used for IDCT select and resizing(if done in the core ) */
+	int                ROTATEFLAG;			    /* TRUE if rotatedegree is other than zero degree/ Rotation clockwise/anticlockwise is required */ 
+	int                 Rotatedegree;			/* degree of rotation clockwise/anti-clockwise || 90 | 180 | 270 */ 
+	int                VerticalFlip;           /* Flag set TRUE when vertical flip of the picture is required */
+	int                 HorizantalFlip;			/* Flag set TRUE when vertical flip of the picture is required */
+    int                 Pitch;                  /* the pitch. Valid only if ROTATEFLAG & 0x80000000 */
+	} JPEGDEC_InitParams_t;
+
+
+
+
+
+/* Structure for the databuffers passed with TRANSFORM commands */
+typedef struct
+	{
+	JPEGDEC_InitParams_t outputSettings;						 /* Steering of size/widht/height of output picture */
+	} JPEGDEC_TransformParams_t;
+
+
+typedef enum 
+	{
+	JPEG_NO_ERROR,
+	UNDEFINED_HUFF_TABLE, 
+	UNSUPPORTED_MARKER,
+	UNABLE_ALLOCATE_MEMORY,		
+	NON_SUPPORTED_SAMP_FACTORS,	
+	BAD_PARAMETER,				
+	DECODE_ERROR,
+	BAD_RESTART_MARKER,			
+	UNSUPPORTED_COLORSPACE,		
+	BAD_SOS_SPECTRAL,			
+	BAD_SOS_SUCCESSIVE,			
+	BAD_HEADER_LENGHT,			
+	BAD_COUNT_VALUE,			
+	BAD_DHT_MARKER,				
+	BAD_INDEX_VALUE,				
+	BAD_NUMBER_HUFFMAN_TABLES,	
+	BAD_QUANT_TABLE_LENGHT,		
+	BAD_NUMBER_QUANT_TABLES,		
+	BAD_COMPONENT_COUNT,
+	DIVIDE_BY_ZERO_ERROR,
+	NOT_JPG_IMAGE,
+	UNSUPPORTED_ROTATION_ANGLE,
+	UNSUPPORTED_SCALING,
+	INSUFFICIENT_OUTPUTBUFFER_SIZE
+	}JPEGDEC_ErrorCodes_t;
+
+
+/* Structure for return parameters of TRANSFORM commands */
+typedef struct
+	{
+	unsigned int		bytes_written;                   /* Bytes written to the o/p buffer sent back to the host */
+	int					decodedImageHeight;              /* Scaled image output height                            */
+	int					decodedImageWidth;               /* Scaled image output width                             */
+	unsigned int        Total_cycle;
+	unsigned int        DMiss_Cycle;
+	unsigned int        IMiss_Cycle;
+	JPEGDEC_ErrorCodes_t  ErrorType; 
+	} JPEGDEC_TransformReturnParams_t;
+
+
+
+typedef struct
+	{
+	unsigned int caps_len;
+	}JPEGDEC_Capability_t;
+
+
+
+#endif /* JPEG_DECODERTYPES_H */
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/interfaces/IDirectFBImageProvider/mme/transform/PNGDecode_interface.h DirectFB-1.4.12+STM2011.09.27/interfaces/IDirectFBImageProvider/mme/transform/PNGDecode_interface.h
--- DirectFB/interfaces/IDirectFBImageProvider/mme/transform/PNGDecode_interface.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/interfaces/IDirectFBImageProvider/mme/transform/PNGDecode_interface.h	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,191 @@
+#ifndef PNGDECODERINTERFACE_H
+#define PNGDECODERINTERFACE_H
+
+#define PNGDECODER_MME_TRANSFORMER_NAME "PNGDECODER"
+
+#if (PNGDEC_MME_VERSION == 11)
+    #define PNGDECODER_MME_API_VERSION "1.1"
+#elif (PNGDEC_MME_VERSION == 10)
+    #define PNGDECODER_MME_API_VERSION "1.0"
+#else
+    #define PNGDECODER_MME_API_VERSION "undefined"
+#endif
+
+#define PNGDECODE_COLOR_MASK_PALETTE    1
+#define PNGDECODE_COLOR_MASK_COLOR       2
+#define PNGDECODE_COLOR_MASK_ALPHA       4
+
+#define PNGDECODE_MAX_PALETTE  256
+
+typedef enum
+{
+	PNGDECODE_COLOR_TYPE_GRAY = 0 /* PNG_COLOR_TYPE_GRAY */,
+	PNGDECODE_COLOR_TYPE_PALETTE = PNGDECODE_COLOR_MASK_COLOR | PNGDECODE_COLOR_MASK_PALETTE /* PNG_COLOR_TYPE_PALETTE */,
+	PNGDECODE_COLOR_TYPE_RGB =  PNGDECODE_COLOR_MASK_COLOR /* PNG_COLOR_TYPE_RGB */,
+	PNGDECODE_COLOR_TYPE_RGB_ALPHA = PNGDECODE_COLOR_MASK_COLOR | PNGDECODE_COLOR_MASK_ALPHA /* PNG_COLOR_TYPE_RGB_ALPHA */,
+	PNGDECODE_COLOR_TYPE_GRAY_ALPHA = PNGDECODE_COLOR_MASK_ALPHA /* PNG_COLOR_TYPE_GRAY_ALPHA*/ 
+}PNGDecode_ColorType_t;
+
+typedef enum
+{
+	PNGDECODE_INTERLACE_NONE = 0 /* PNG_INTERLACE_NONE */,
+	PNGDECODE_INTERLACE_ADAM7 = 1 /* PNG_INTERLACE_ADAM7 */
+}PNGDecode_InterlaceType_t;
+
+typedef enum
+{
+	PNGDECODE_COMPRESSION_TYPE_BASE = 0 /* PNG_COMPRESSION_TYPE_BASE */
+}PNGDecode_CompressionType_t;
+
+
+typedef enum
+{
+	PNGDECODE_FILTER_TYPE_BASE = 0 /* PNG_FILTER_TYPE_BASE */
+}PNGDecode_FilterMethod_t;
+
+/* for an MME_TRANSFORM command the ones marked with a star or plus denote
+   possibly corrupt data when seen together with MME_INVALID_ARGUMENT. A plus
+   is given for PNGDEC_MME_VERSION == 10 and a star for
+   PNGDEC_MME_VERSION == 11. In theory, PNGDECODE_MEMORY_ALLOCATION_ERROR
+   could denote corrupt data, too, but it's unlikely any data was decoded
+   at all, thus it doesn't make sense to display the result, either try
+   again or use libpng on the host! For version 10,
+   PNGDECODE_INTERNAL_ERROR is returned in more occasions than just data
+   corruption. */
+typedef enum
+{
+	PNGDECODE_NO_ERROR,
+	PNGDECODE_MEMORY_ALLOCATION_ERROR,
+	PNGDECODE_CRC_ERROR               /* +* */,
+	PNGDECODE_INVALID_STREAM          /* +* */,
+	PNGDECODE_INTERNAL_ERROR          /* + */
+#if (PNGDEC_MME_VERSION > 10)
+	,PNGDECODE_INVALID_ARGUMENT
+    ,PNGDECODE_STREAM_ERROR           /* * */
+#endif
+} PNGDecode_ErrorCodes_t;
+
+
+typedef struct 
+{
+    /* Picture Width in pixels */
+	unsigned int  PictureWidth;
+	
+	/* Picture Height in pixels */ 
+	unsigned int  PictureHeight;
+	
+    /* bitstream information: */
+	/* Number of bits per sample or palette index */ 
+	unsigned int  BitDepth;
+	/* Color type as encoded in the bitstream */
+	PNGDecode_ColorType_t ColorType;	
+	/* Transmission order of image data */
+	PNGDecode_InterlaceType_t InterlaceType;
+	/* Only compression type 0 is supported */ 
+	PNGDecode_CompressionType_t CompressionType;
+	/* Only Filter method 0 is supported */
+	PNGDecode_FilterMethod_t FilterMethod; 
+	
+	PNGDecode_ErrorCodes_t ErrorType;
+
+#if (PNGDEC_MME_VERSION > 10)
+    /* transformer return params: */
+    /* Color type as returned by the transformer:
+       - PNGDECODE_COLOR_TYPE_PALETTE (LUT8)
+       - PNGDECODE_COLOR_TYPE_RGB (RGB24)
+       - PNGDECODE_COLOR_TYPE_RGB_ALPHA (ARGB32) */
+    PNGDecode_ColorType_t ColorFormatOutput;
+
+    int HaveColorKey;
+    unsigned int ColorKey; /* 32 bit xRGB */
+
+    unsigned int pitch;
+
+    unsigned char palette[4 * PNGDECODE_MAX_PALETTE]; /* ARGB ARGB ARGB */
+#endif
+} PNGDecode_GlobalTransformReturnParams_t;
+
+
+#if (PNGDEC_MME_VERSION == 10)
+
+typedef enum
+{
+    /* always ARGB */
+    PNGDECODE_OUTPUTFORMAT_ARGB = 0
+} PNGDecode_OutputFormat_t;
+
+typedef struct
+{
+    /* indicates seven step display in case of interlaced pictures */
+    unsigned int             ProgressiveDisplayFlag;
+    PNGDecode_OutputFormat_t OutputFormat;
+} PNGDecode_GlobalParams_t;
+
+typedef struct
+{
+    unsigned int caps_len;
+} caps_len_t;
+
+typedef struct
+{
+    unsigned char *caps;
+} caps_t;
+
+#elif (PNGDEC_MME_VERSION > 10)
+
+typedef enum
+{
+    /* PNGDecode_OutputFormat_t, valid in PNGDecode_GlobalParams_t and
+       PNGDecode_InitTransformerParams_t */
+    PNGDECODE_PARAM_FORMAT      = 0x00000001,
+    /* pitch, only valid in PNGDecode_TransformParams_t */
+    PNGDECODE_PARAM_PITCH       = 0x00000002
+} PNGDecode_Params_Flags_t;
+
+typedef enum
+{
+    /* expand everything to RGB24 (if the image has no alpha components, else
+       to ARGB32) */
+    PNGDECODE_OF_EXPAND,
+    /* keep indexed images:
+       - LUT8 for all (non alpha) greyscale (any bitdepth) and 8bit palette
+         images
+       - RGB24 for all other non alpha images
+       - ARGB32 for alpha images */
+    PNGDECODE_OF_COMPRESSED,
+    /* always expand to ARGB32 */
+    PNGDECODE_OF_EXPAND_FORCE_ALPHA
+} PNGDecode_OutputFormat_t;
+
+typedef struct
+{
+    PNGDecode_Params_Flags_t flags;
+    /* if not specified, PNGDECODE_OF_EXPAND is assumed */
+    PNGDecode_OutputFormat_t format;
+    /* if not specified, the pitch will be as returned in
+       PNGDecode_GlobalTransformReturnParams_t */
+    int pitch;
+} PNGDecode_InitTransformerParams_t,
+  PNGDecode_TransformParams_t,
+  PNGDecode_GlobalParams_t;
+
+#endif
+
+
+typedef struct
+{	/* Number of bytes written by the decoder into the output buffer*/
+	unsigned int BytesWritten;
+	/* Error encountered while decoding the picture */
+	PNGDecode_ErrorCodes_t ErrorType;
+
+#if defined(PNGDECODE_PROFILING_ENABLE)
+	unsigned int Cycles;
+	unsigned int Bundles;
+	unsigned int ICacheMiss;
+	unsigned int DCacheMiss;
+	unsigned int NopBundles;
+#endif
+} PNGDecode_TransformReturnParams_t;
+
+
+#endif /* PNGDECODERINTERFACE_H */
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/interfaces/IDirectFBImageProvider/mme/transform/RLEDecode_interface.h DirectFB-1.4.12+STM2011.09.27/interfaces/IDirectFBImageProvider/mme/transform/RLEDecode_interface.h
--- DirectFB/interfaces/IDirectFBImageProvider/mme/transform/RLEDecode_interface.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/interfaces/IDirectFBImageProvider/mme/transform/RLEDecode_interface.h	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,119 @@
+
+#ifndef RLEDECODERINTERFACE_H
+#define RLEDECODERINTERFACE_H
+
+#define RLEDECODER_MME_TRANSFORMER_NAME "RLEDECODER"
+
+#if (RLEDECODER_MME_VERSION==10)
+    #define RLEDECODER_MME_API_VERSION "1.0"
+#else
+    #define RLEDECODER_MME_API_VERSION "undefined"
+#endif
+
+#define RLEDECODE_COLOR_MASK_PALETTE    1
+#define RLEDECODE_COLOR_MASK_COLOR       2
+#define RLEDECODE_COLOR_MASK_ALPHA       4
+
+typedef enum
+{
+	RLEDECODE_COLOR_TYPE_GRAY = 0,
+	RLEDECODE_COLOR_TYPE_PALETTE =  (RLEDECODE_COLOR_MASK_COLOR | RLEDECODE_COLOR_MASK_PALETTE),
+	RLEDECODE_COLOR_TYPE_RGB =  (RLEDECODE_COLOR_MASK_COLOR),
+	RLEDECODE_COLOR_TYPE_RGB_ALPHA = (RLEDECODE_COLOR_MASK_COLOR | RLEDECODE_COLOR_MASK_ALPHA),
+	RLEDECODE_COLOR_TYPE_GRAY_ALPHA =  (RLEDECODE_COLOR_MASK_ALPHA)
+}RLEDecode_ColorType_t;
+
+typedef enum
+{
+	RLEDECODE_INTERLACE_NONE = 0,
+	RLEDECODE_INTERLACE_ADAM7 = 1
+}RLEDecode_InterlaceType_t;
+
+typedef enum
+{
+	RLEDECODE_COMPRESSION_TYPE_BASE = 0
+}RLEDecode_CompressionType_t;
+
+
+typedef enum
+{
+	RLEDECODE_FILTER_TYPE_BASE = 0
+}RLEDecode_FilterMethod_t;
+
+typedef enum
+{
+	RLEDECODE_OUTPUTFORMAT_ARGB = 0
+}RLEDecode_OutputFormat_t;
+
+typedef enum
+{
+	RLEDECODE_NO_ERROR,
+	RLEDECODE_MEMEORY_ALLOCATION_ERROR,
+	RLEDECODE_CRC_ERROR,
+	RLEDECODE_INVALID_STREAM,
+	RLEDECODE_INTERNAL_ERROR
+} RLEDecode_ErrorCodes_t;
+
+
+typedef struct 
+{	/* Picture Width in pixels */
+	unsigned int  PictureWidth;
+	
+	/* Picture Height in pixels */ 
+	unsigned int  PictureHeight;
+	
+	/* Number of bits per sample or palette index */ 
+	unsigned int  BitDepth;
+ 	
+	/* Color type as encoded in the bitstream */
+	RLEDecode_ColorType_t ColorType;	
+	 
+	/* Transmission order of image data */
+	RLEDecode_InterlaceType_t InterlaceType;
+
+	/* Only compression type 0 is supported */ 
+	RLEDecode_CompressionType_t CompressionType;
+
+	/* Only Filter method 0 is supported */
+	RLEDecode_FilterMethod_t FilterMethod; 
+	
+	RLEDecode_ErrorCodes_t ErrorType;
+
+} RLEDecode_GlobalTransformReturnParams_t; 
+
+
+typedef struct 
+{	/* Indicates seven step display in case if interlaced 	pictures */
+  	unsigned int		ProgressiveDisplayFlag;
+	RLEDecode_OutputFormat_t OutputFormat;
+	
+} RLEDecode_GlobalParams_t;
+
+typedef struct 
+{	/* Number of bytes written by the decoder into the output 	buffer*/
+  	unsigned int	BytesWritten;
+	/* Error encountered while decoding the picture */
+	RLEDecode_ErrorCodes_t ErrorType;
+
+#ifdef RLEDECODE_PROFILING_ENABLE
+	unsigned int Cycles;
+	unsigned int Bundles;
+	unsigned int ICacheMiss;
+	unsigned int DCacheMiss;
+	unsigned int NopBundles;
+#endif
+
+}RLEDecode_TransformReturnParams_t;
+
+typedef struct
+{
+	unsigned int caps_len;
+}caps_len_t;
+
+typedef struct
+{
+	unsigned char *caps;
+}caps_t;
+
+#endif /* RLEDECODERINTERFACE_H */
+
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/interfaces/IDirectFBImageProvider/mme_helper.h DirectFB-1.4.12+STM2011.09.27/interfaces/IDirectFBImageProvider/mme_helper.h
--- DirectFB/interfaces/IDirectFBImageProvider/mme_helper.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/interfaces/IDirectFBImageProvider/mme_helper.h	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,1037 @@
+#ifndef __MME_HELPER_H__
+#define __MME_HELPER_H__
+
+
+#if defined(USE_MME)
+#include <semaphore.h>
+#include <mme.h>
+#include <direct/hash.h>
+#endif /* USE_MME */
+#include <direct/util.h>
+#include "sema_helper.h"
+
+#define likely(x)       __builtin_expect(!!(x),1)
+#define unlikely(x)     __builtin_expect(!!(x),0)
+
+#define container_of(ptr, type, member) ({ \
+    const typeof( ((type *)0)->member ) *__mptr = (ptr); \
+    (type *)( (char *)__mptr - offsetof(type,member) );})
+
+#ifndef MAX_STREAMING_COMMANDS
+  #define MAX_STREAMING_COMMANDS    5
+#endif
+#ifndef MME_STREAMING_BUFFERSIZE
+  #define MME_STREAMING_BUFFERSIZE  (32 * 1024) /* this must _not_ be less
+                                                   than 8 k */
+#endif
+
+
+#if defined(USE_MME)
+struct _MMEHelper_buffer {
+  MME_DataBuffer_t *buffer;
+  MME_Command_t     command;
+  sem_t             sema;
+};
+#endif /* USE_MME */
+
+typedef struct _MMECommon
+{
+  IDirectFBImageProvider_data base;
+
+  const char *name;
+
+  void         *image; /* decoded image data */
+  unsigned int  width; /* width of the JPEG/PNG image */
+  unsigned int  height; /* height of the JPEG/PNG image */
+
+#ifdef DIRECT_BUILD_DEBUG
+  /* performance monitoring */
+  struct timeval starttime, endtime;
+#endif /* DIRECT_BUILD_DEBUG */
+
+  CoreSurface        *decode_surface;
+  CoreGraphicsSerial  serial;
+
+  unsigned int decoded_width;
+  unsigned int decoded_height;
+
+#if defined(USE_MME)
+  bool name_set;
+  const char *transformer_name;
+
+  /* hardware decode specifics */
+  MME_TransformerHandle_t Handle;
+
+  MME_DataBuffer_t  **OutDataBuffers;
+  MME_ScatterPage_t   OutDataBufferScatterPage;
+  MME_DataBuffer_t    OutDataBuffer;
+
+  struct _MMEHelper_buffer SendDataBuffers[MAX_STREAMING_COMMANDS];
+
+  MME_Command_t TransformCommand; /* provide the output buffer and request
+                                     transform */
+
+  pthread_mutex_t  pending_commands_lock;
+  DirectHash      *pending_commands;
+  unsigned int     n_pending_buffers;
+
+  sem_t decode_event;
+
+  int decode_success;
+
+  /* bytes remaining to be decoded */
+  unsigned int  bytes;
+  unsigned int  packets;
+
+  /* just for statistics */
+  unsigned int  n_underflows;
+#endif /* USE_MME */
+} MMECommon;
+
+
+#if defined(USE_MME)
+/* every user should provide those... */
+static void TransformerCallback( MME_Event_t    Event,
+                                 MME_Command_t *CallbackData,
+                                 void          *UserData );
+static DFBResult abort_transformer( struct _MMECommon *mme );
+static DFBResult fetch_data( IDirectFBDataBuffer *buffer,
+                             MME_DataBuffer_t    *dbuf,
+                             int                  len );
+static void
+_imageprovider_update_transform_params (MMECommon                   * const mme,
+                                        void                        * const params,
+                                        const CoreSurfaceBufferLock * const lock);
+#endif /* USE_MME */
+
+
+static DFBResult
+buffer_to_ptr_copy (IDirectFBDataBuffer * const buffer,
+                    void                * ptr,
+                    int                  len)
+{
+  DFBResult ret;
+
+  while (len > 0)
+    {
+      unsigned int read;
+
+      ret = buffer->WaitForData (buffer, len);
+      if (ret == DFB_OK)
+        ret = buffer->GetData (buffer, len, ptr, &read);
+
+      if (ret)
+        return ret;
+
+      ptr += read;
+      len -= read;
+    }
+
+  return DFB_OK;
+}
+
+
+#if !defined(USE_MME)
+
+#define mme_helper_LoadLib (data) DFB_FILENOTFOUND
+#define mme_helper_UnloadLib (struct _MMECommon * const data) {( )}
+
+#else /* USE_MME */
+
+/* Some Error and Debug Management */
+
+
+static inline const char *
+get_mme_event_string (MME_Event_t ev)
+{
+  static const char *mme_event_strings[] = {
+    "MME_COMMAND_COMPLETED_EVT",
+    "MME_DATA_UNDERFLOW_EVT",
+    "MME_NOT_ENOUGH_MEMORY_EVT",
+    "MME_NEW_COMMAND_EVT",
+  };
+
+  return (((unsigned int) ev) < D_ARRAY_SIZE (mme_event_strings))
+         ? mme_event_strings[ev]
+         : "* Unknown Event code *";
+}
+
+static inline const char *
+get_mme_state_string (MME_CommandState_t s)
+{
+  static const char *mme_command_state_strings[] ={
+    "MME_COMMAND_IDLE",
+    "MME_COMMAND_PENDING",
+    "MME_COMMAND_EXECUTING",
+    "MME_COMMAND_COMPLETED",
+    "MME_COMMAND_FAILED"
+  };
+
+  return (((unsigned int) s) < D_ARRAY_SIZE (mme_command_state_strings))
+         ? mme_command_state_strings[s]
+         : "* Unknown State code *";
+}
+
+static inline const char *
+get_mme_error_string (MME_ERROR e)
+{
+  static const char *mme_error_type_strings[] = {
+    "MME_SUCCESS",
+    "MME_DRIVER_NOT_INITIALIZED",
+    "MME_DRIVER_ALREADY_INITIALIZED",
+    "MME_NOMEM",
+    "MME_INVALID_TRANSPORT",
+    "MME_INVALID_HANDLE",
+    "MME_INVALID_ARGUMENT",
+    "MME_UNKNOWN_TRANSFORMER",
+    "MME_TRANSFORMER_NOT_RESPONDING",
+    "MME_HANDLES_STILL_OPEN",
+    "MME_COMMAND_STILL_EXECUTING",
+    "MME_COMMAND_ABORTED",
+    "MME_DATA_UNDERFLOW",
+    "MME_DATA_OVERFLOW",
+    "MME_TRANSFORM_DEFERRED",
+    "MME_SYSTEM_INTERRUPT",
+    "MME_EMBX_ERROR",
+    "MME_INTERNAL_ERROR",
+    "MME_NOT_IMPLEMENTED"
+  };
+
+  return (((unsigned int) e) < D_ARRAY_SIZE (mme_error_type_strings))
+         ? mme_error_type_strings[e]
+         : "* Unknown Error code *";
+}
+
+
+#if defined(MME_USE_DLOPEN)
+#include <dlfcn.h>
+typedef MME_ERROR (*MME_Init_func) (void);
+typedef MME_ERROR (*MME_Term_func) (void);
+typedef MME_ERROR (*MME_SendCommand_func) (MME_TransformerHandle_t  Handle,
+                                           MME_Command_t           *CmdInfo_p);
+typedef MME_ERROR (*MME_AbortCommand_func) (MME_TransformerHandle_t Handle,
+                                            MME_CommandId_t         CmdId);
+typedef MME_ERROR (*MME_AllocDataBuffer_func) (MME_TransformerHandle_t  handle,
+                                               MME_UINT                 size,
+                                               MME_AllocationFlags_t    flags,
+                                               MME_DataBuffer_t        **dataBuffer_p);
+typedef MME_ERROR (*MME_FreeDataBuffer_func)  (MME_DataBuffer_t         *DataBuffer_p);
+typedef MME_ERROR (*MME_GetTransformerCapability_func) (const char                  *TransformerName,
+                                                        MME_TransformerCapability_t *TransformerCapability_p);
+typedef MME_ERROR (*MME_InitTransformer_func) (const char *Name,
+                                               MME_TransformerInitParams_t *Params_p,
+                                               MME_TransformerHandle_t     *Handle_p);
+typedef MME_ERROR (*MME_IsTransformerRegistered_func) (const char *name);
+typedef MME_ERROR (*MME_TermTransformer_func) (MME_TransformerHandle_t handle);
+typedef const char (*MME_Version_func) (void);
+
+static MME_ERROR _mme_helper_MME_func (void)
+{
+  return MME_DRIVER_NOT_INITIALIZED;
+}
+
+static MME_Init_func _MME_Init = (MME_Init_func) _mme_helper_MME_func;
+static MME_Term_func _MME_Term = (MME_Term_func) _mme_helper_MME_func;
+static MME_SendCommand_func  _MME_SendCommand = (MME_SendCommand_func) _mme_helper_MME_func;
+static MME_AbortCommand_func _MME_AbortCommand = (MME_AbortCommand_func) _mme_helper_MME_func;
+static MME_AllocDataBuffer_func _MME_AllocDataBuffer = (MME_AllocDataBuffer_func) _mme_helper_MME_func;
+static MME_FreeDataBuffer_func  _MME_FreeDataBuffer  = (MME_FreeDataBuffer_func) _mme_helper_MME_func;
+static MME_GetTransformerCapability_func _MME_GetTransformerCapability = (MME_GetTransformerCapability_func) _mme_helper_MME_func;
+static MME_InitTransformer_func _MME_InitTransformer = (MME_InitTransformer_func) _mme_helper_MME_func;
+static MME_IsTransformerRegistered_func _MME_IsTransformerRegistered = (MME_IsTransformerRegistered_func) _mme_helper_MME_func;
+static MME_TermTransformer_func _MME_TermTransformer = (MME_TermTransformer_func) _mme_helper_MME_func;
+static MME_Version_func _MME_Version = (MME_Version_func) _mme_helper_MME_func;
+#define MME_Init _MME_Init
+#define MME_Term _MME_Term
+#define MME_SendCommand  _MME_SendCommand
+#define MME_AbortCommand _MME_AbortCommand
+#define MME_AllocDataBuffer _MME_AllocDataBuffer
+#define MME_FreeDataBuffer _MME_FreeDataBuffer
+#define MME_GetTransformerCapability _MME_GetTransformerCapability
+#define MME_InitTransformer _MME_InitTransformer
+#define MME_IsTransformerRegistered _MME_IsTransformerRegistered
+#define MME_TermTransformer _MME_TermTransformer
+#define MME_Version _MME_Version
+
+static void *mme_helper_libmme;
+#endif /* MME_USE_DLOPEN */
+
+static bool mme_lib_inited;
+
+
+static void
+__attribute__((constructor))
+mme_helper_ctor(void)
+{
+#if defined(MME_USE_DLOPEN)
+  if ((mme_helper_libmme = dlopen ("libmme.so", RTLD_LAZY)) != NULL
+      || (mme_helper_libmme = dlopen ("libmme_host.so", RTLD_LAZY)) != NULL)
+    {
+      _MME_Init = dlsym (mme_helper_libmme, "MME_Init");
+      _MME_Term = dlsym (mme_helper_libmme, "MME_Term");
+      _MME_SendCommand  = dlsym (mme_helper_libmme, "MME_SendCommand");
+      _MME_AbortCommand = dlsym (mme_helper_libmme, "MME_AbortCommand");
+      _MME_AllocDataBuffer = dlsym (mme_helper_libmme, "MME_AllocDataBuffer");
+      _MME_FreeDataBuffer  = dlsym (mme_helper_libmme, "MME_FreeDataBuffer");
+      _MME_GetTransformerCapability = dlsym (mme_helper_libmme, "MME_GetTransformerCapability");
+      _MME_InitTransformer = dlsym (mme_helper_libmme, "MME_InitTransformer");
+
+      /* only available in Multicom 4 and onward */
+      _MME_Version = dlsym (mme_helper_libmme, "MME_Version");
+      if (_MME_Version)
+        _MME_IsTransformerRegistered = dlsym (mme_helper_libmme, "MME_IsTransformerRegistered");
+
+      _MME_TermTransformer = dlsym (mme_helper_libmme, "MME_TermTransformer");
+
+      if (unlikely (!_MME_Init || !_MME_Term
+                    || !_MME_SendCommand || !_MME_AbortCommand
+                    || !_MME_AllocDataBuffer || !_MME_FreeDataBuffer
+                    || !_MME_GetTransformerCapability
+                    || (_MME_Version && !_MME_IsTransformerRegistered)
+                    || !_MME_InitTransformer || !_MME_TermTransformer))
+        {
+          _MME_Init = (MME_Init_func) _mme_helper_MME_func;
+          _MME_Term = (MME_Term_func) _mme_helper_MME_func;
+          _MME_SendCommand = (MME_SendCommand_func) _mme_helper_MME_func;
+          _MME_AbortCommand = (MME_AbortCommand_func) _mme_helper_MME_func;
+          _MME_AllocDataBuffer = (MME_AllocDataBuffer_func) _mme_helper_MME_func;
+          _MME_FreeDataBuffer  = (MME_FreeDataBuffer_func) _mme_helper_MME_func;
+          _MME_GetTransformerCapability = (MME_GetTransformerCapability_func) _mme_helper_MME_func;
+          _MME_InitTransformer = (MME_InitTransformer_func) _mme_helper_MME_func;
+          _MME_IsTransformerRegistered = (MME_IsTransformerRegistered_func) _mme_helper_MME_func;
+          _MME_TermTransformer = (MME_TermTransformer_func) _mme_helper_MME_func;
+          _MME_Version = (MME_Version_func) _mme_helper_MME_func;
+
+          dlclose (mme_helper_libmme);
+          mme_helper_libmme = NULL;
+
+          D_WARN ("Unable to use libmme.so for "MME_TEXT_DOMAIN": (%s)",
+                  dlerror ());
+        }
+      else
+#endif /* MME_USE_DLOPEN */
+        {
+          MME_ERROR mme_res = MME_Init ();
+          D_DEBUG_AT (MME_DEBUG_DOMAIN, "MME_Init() returned %d (%s)\n",
+                      mme_res, get_mme_error_string (mme_res));
+          switch (mme_res)
+            {
+            case MME_DRIVER_ALREADY_INITIALIZED:
+              mme_res = MME_SUCCESS;
+            case MME_SUCCESS:
+              break;
+
+            default:
+              /* probably kernel module or /dev node required */
+              D_ONCE ("failed to initialize MME for "MME_TEXT_DOMAIN": %d (%s)",
+                      mme_res, get_mme_error_string (mme_res));
+              break;
+            }
+
+          mme_lib_inited = (mme_res == MME_SUCCESS);
+          D_DEBUG_AT (MME_DEBUG_DOMAIN, "mme_lib_inited %d\n", mme_lib_inited);
+        }
+#if defined(MME_USE_DLOPEN)
+    }
+  else
+    D_INFO ("Couldn't resolve libmme.so for "MME_TEXT_DOMAIN", can't "
+            "use MME for hw accelerated decoding\n");
+#endif /* MME_USE_DLOPEN */
+}
+
+static void
+__attribute__((destructor))
+mme_helper_dtor(void)
+{
+  fprintf(stderr, "%s\n", __FUNCTION__);
+
+  /* we can't MME_Term() here - there might be other users of MME still
+     active. MME should implement some use counters instead. */
+//  MME_ERROR mme_res = MME_Term ();
+//  D_DEBUG_AT (MME_DEBUG_DOMAIN, "MME_Term() returned %d (%s)\n",
+//              mme_res, get_mme_error_string (mme_res));
+  mme_lib_inited = false;
+
+#if defined(MME_USE_DLOPEN)
+  if (mme_helper_libmme)
+    {
+      _MME_Init = (MME_Init_func) _mme_helper_MME_func;
+      _MME_Term = (MME_Term_func) _mme_helper_MME_func;
+      _MME_SendCommand = (MME_SendCommand_func) _mme_helper_MME_func;
+      _MME_AbortCommand = (MME_AbortCommand_func) _mme_helper_MME_func;
+      _MME_AllocDataBuffer = (MME_AllocDataBuffer_func) _mme_helper_MME_func;
+      _MME_FreeDataBuffer  = (MME_FreeDataBuffer_func) _mme_helper_MME_func;
+      _MME_InitTransformer = (MME_InitTransformer_func) _mme_helper_MME_func;
+      _MME_IsTransformerRegistered = (MME_IsTransformerRegistered_func) _mme_helper_MME_func;
+      _MME_TermTransformer = (MME_TermTransformer_func) _mme_helper_MME_func;
+      _MME_Version = (MME_Version_func) _mme_helper_MME_func;
+
+      dlclose (mme_helper_libmme);
+      mme_helper_libmme = NULL;
+    }
+#endif /* MME_USE_DLOPEN */
+}
+
+
+/***************************************/
+
+static DFBResult
+__attribute__((unused))
+_mme_helper_get_capability (struct _MMECommon           * const data,
+                            const char                  * const name,
+                            MME_TransformerCapability_t * const cap)
+{
+  volatile u32 _len = 0;
+  MME_ERROR res;
+
+  cap->TransformerInfoSize = sizeof (_len);
+  cap->TransformerInfo_p = (u32 *) &_len;
+
+  cap->StructSize = sizeof (*cap);
+
+  res = MME_GetTransformerCapability (name, cap);
+  if (res != MME_SUCCESS)
+    return DFB_FAILURE;
+
+  D_DEBUG_AT (MME_DEBUG_DOMAIN,
+              "'%s' 1: sz/v/it/ot/is/p: %u, %u (%x), %.2x%.2x%.2x%.2x, "
+              "%.2x%.2x%.2x%.2x, %u, %p (%u bytes)\n",
+              name,
+              cap->StructSize, cap->Version, cap->Version,
+              cap->InputType.FourCC[0], cap->InputType.FourCC[1],
+              cap->InputType.FourCC[2], cap->InputType.FourCC[3],
+              cap->OutputType.FourCC[0], cap->OutputType.FourCC[1],
+              cap->OutputType.FourCC[2], cap->OutputType.FourCC[3],
+              cap->TransformerInfoSize, cap->TransformerInfo_p, _len);
+  if (_len)
+    {
+      char *buf = D_CALLOC (1, _len);
+
+      cap->TransformerInfo_p = buf;
+      cap->TransformerInfoSize = _len;
+
+      res = MME_GetTransformerCapability (name, cap);
+      if (res != MME_SUCCESS)
+        {
+          D_FREE (buf);
+          return DFB_FAILURE;
+        }
+
+      D_DEBUG_AT (MME_DEBUG_DOMAIN,
+                  "'%s' 2: sz/v/it/ot/is/p: %u, %u (%x), '%c%c%c%c' "
+                  "(%.2x%.2x%.2x%.2x), '%c%c%c%c' (%.2x%.2x%.2x%.2x), %u, "
+                  "%p (%u bytes)\n",
+                  name,
+                  cap->StructSize, cap->Version, cap->Version,
+                  cap->InputType.FourCC[0], cap->InputType.FourCC[1],
+                  cap->InputType.FourCC[2], cap->InputType.FourCC[3],
+                  cap->InputType.FourCC[0], cap->InputType.FourCC[1],
+                  cap->InputType.FourCC[2], cap->InputType.FourCC[3],
+                  cap->OutputType.FourCC[0], cap->OutputType.FourCC[1],
+                  cap->OutputType.FourCC[2], cap->OutputType.FourCC[3],
+                  cap->OutputType.FourCC[0], cap->OutputType.FourCC[1],
+                  cap->OutputType.FourCC[2], cap->OutputType.FourCC[3],
+                  cap->TransformerInfoSize, cap->TransformerInfo_p, _len);
+      D_DEBUG_AT (MME_DEBUG_DOMAIN, "caps: '%s'\n", buf);
+
+      D_FREE (buf);
+      cap->TransformerInfo_p = NULL;
+    }
+
+  return DFB_OK;
+}
+
+static DFBResult
+mme_helper_deinit_transformer (struct _MMECommon * const data)
+{
+  MME_ERROR ret;
+
+  if (!data->Handle)
+    return DFB_OK;
+
+  D_DEBUG_AT (MME_DEBUG_DOMAIN, "terminating %s transformer w/ handle %x\n",
+              data->name, data->Handle);
+
+  /* if we are still waiting for the main decode command to finish (because
+     we ran out of data but the transformer is still waiting), abort it.
+     JPEG needs this. */
+  /* FIXME: what about locking? */
+  if (direct_hash_lookup (data->pending_commands,
+                          data->TransformCommand.CmdStatus.CmdId))
+    {
+      abort_transformer (data);
+      while ((sema_wait_event (&data->decode_event) == -1)
+             && errno == EINTR)
+        ;
+    }
+
+  if (data->n_underflows)
+    {
+      D_INFO ("%s: %d data underflow(s) during decode\n",
+              data->name, data->n_underflows);
+      data->n_underflows = 0;
+    }
+
+  ret = MME_TermTransformer (data->Handle);
+  if (ret != MME_SUCCESS)
+    {
+      D_WARN ("(%5d) Couldn't terminate %s transformer w/ handle %x: %d (%s)",
+              direct_gettid (), data->name, data->Handle, ret,
+              get_mme_error_string (ret));
+      return DFB_FAILURE;
+    }
+
+  D_DEBUG_AT (MME_DEBUG_DOMAIN, "  -> terminated %s transformer w/ handle %x\n",
+              data->name, data->Handle);
+
+  if (data->pending_commands)
+    {
+      pthread_mutex_destroy (&data->pending_commands_lock);
+      direct_hash_destroy (data->pending_commands);
+      data->pending_commands = NULL;
+    }
+
+  data->Handle = 0;
+  return DFB_OK;
+}
+
+static DFBResult
+mme_helper_init_transformer2 (struct _MMECommon * const data,
+                              const char const  * const transformer_names[],
+                              size_t             transformer_params_size,
+                              void              * const transformer_params,
+                              unsigned int      * const ret_index,
+                              MME_GenericCallback_t Callback)
+{
+  unsigned int index;
+
+  MME_ERROR ret;
+  MME_TransformerInitParams_t params;
+
+  D_ASSUME (data->Handle == 0);
+  D_ASSUME ((transformer_params_size == 0 && transformer_params == NULL)
+            || (transformer_params_size && transformer_params));
+
+  if (!mme_lib_inited)
+    return DFB_NOSUCHINSTANCE;
+
+  params.StructSize = sizeof (params);
+  params.Priority   = MME_PRIORITY_BELOW_NORMAL;
+  params.Callback         = Callback;
+  params.CallbackUserData = data;
+  params.TransformerInitParamsSize = transformer_params_size;
+  params.TransformerInitParams_p   = transformer_params;
+
+  D_DEBUG_AT (MME_DEBUG_DOMAIN, "initializing %s tranformer:\n", data->name);
+
+  index = 0;
+  do
+    {
+      D_DEBUG_AT (MME_DEBUG_DOMAIN, "  -> %s\n", transformer_names[index]);
+
+      if (MME_IsTransformerRegistered != (MME_IsTransformerRegistered_func) _mme_helper_MME_func)
+        {
+          ret = MME_IsTransformerRegistered (transformer_names[index]);
+          if (ret != MME_SUCCESS)
+            continue;
+        }
+
+      ret = MME_InitTransformer (transformer_names[index],
+                                 &params, &data->Handle);
+    }
+  while (ret != MME_SUCCESS && transformer_names[++index] != NULL);
+
+  if (ret != MME_SUCCESS)
+    {
+      if (ret != MME_DRIVER_NOT_INITIALIZED
+          && ret != MME_DRIVER_ALREADY_INITIALIZED
+          && ret != MME_UNKNOWN_TRANSFORMER)
+        D_WARN ("(%5d) %s transformer initialisation failed: %s",
+                direct_gettid (), data->name, get_mme_error_string (ret));
+      data->Handle = 0;
+      return DFB_IDNOTFOUND;
+    }
+
+  D_DEBUG_AT (MME_DEBUG_DOMAIN, "    -> OK (handle %x)\n", data->Handle);
+
+  D_ASSUME (data->n_pending_buffers == 0);
+  data->n_pending_buffers = 0;
+  pthread_mutex_init (&data->pending_commands_lock, NULL);
+  if ((ret = direct_hash_create (17, &data->pending_commands)) != DFB_OK)
+    {
+      data->pending_commands = NULL;
+      mme_helper_deinit_transformer (data);
+    }
+
+  if (ret_index)
+    *ret_index = index;
+
+  return ret;
+}
+
+static DFBResult
+mme_helper_init_transformer (struct _MMECommon * const data,
+                             const char const  * const transformer_names[],
+                             size_t             transformer_params_size,
+                             void              * const transformer_params,
+                             unsigned int      * const ret_index)
+{
+  return mme_helper_init_transformer2 (data, transformer_names,
+                                       transformer_params_size,
+                                       transformer_params,
+                                       ret_index,
+                                       &TransformerCallback);
+}
+
+
+/* Create MME_DataBuffer Structures required to map an Existing Buffer */
+static void
+create_MME_output_data_buffer (struct _MMECommon * const data,
+                               MME_DataBuffer_t  * const buf,
+                               unsigned int       flags,
+                               void              * const dstbuf,
+                               unsigned int       size)
+{
+  buf->StructSize           = sizeof (MME_DataBuffer_t);
+  buf->Flags                = flags;
+  buf->StreamNumber         = 0;
+  buf->NumberOfScatterPages = 1;
+
+  /* create scatter page detail */
+  buf->ScatterPages_p  = &data->OutDataBufferScatterPage;
+  buf->TotalSize       = size;
+  buf->StartOffset     = 0;
+
+  /* scatter page for the data buffer passed in */
+  buf->ScatterPages_p[0].Page_p    = dstbuf;
+  buf->ScatterPages_p[0].Size      = size;
+  buf->ScatterPages_p[0].BytesUsed = 0;
+  buf->ScatterPages_p[0].FlagsIn   = 0;
+  buf->ScatterPages_p[0].FlagsOut  = 0;
+}
+
+
+static inline DFBResult
+buffer_to_mme_copy (IDirectFBDataBuffer * const buffer,
+                    MME_DataBuffer_t    * const dbuf,
+                    int                  len)
+{
+  dbuf->ScatterPages_p[0].BytesUsed = len;
+
+  return buffer_to_ptr_copy (buffer, dbuf->ScatterPages_p[0].Page_p, len);
+}
+
+
+
+
+static DFBResult
+_mme_helper_start_transformer_core (struct _MMECommon     * const data,
+                                    size_t                 return_params_size,
+                                    void                  * const return_params,
+                                    size_t                 params_size,
+                                    void                  * const params,
+                                    CoreSurface           * const dst_surface,
+                                    CoreSurfaceBufferLock * const lock)
+{
+  DFBResult    res;
+  unsigned int buffersize;
+
+  D_ASSERT (data->OutDataBuffers == NULL);
+
+  res = dfb_surface_lock_buffer (dst_surface, CSBR_BACK, CSAID_ACCEL0,
+                                 CSAF_WRITE, lock);
+  if (res != DFB_OK)
+    return res;
+
+  buffersize = lock->pitch * dst_surface->config.size.h;
+
+  data->OutDataBuffers = (MME_DataBuffer_t **) D_MALLOC (sizeof (MME_DataBuffer_t *));
+  if (!data->OutDataBuffers)
+    goto out;
+  create_MME_output_data_buffer (data, &data->OutDataBuffer,
+                                 MME_ALLOCATION_PHYSICAL,
+                                 lock->addr, buffersize);
+  data->OutDataBuffers[0] = &data->OutDataBuffer;
+
+  data->TransformCommand.DataBuffers_p = data->OutDataBuffers;
+
+  D_DEBUG_AT (MME_DEBUG_DOMAIN, "surface locked @ %p (pitch %u)\n",
+              lock->addr, lock->pitch);
+
+  /* init the commandstatus */
+  memset (&(data->TransformCommand.CmdStatus), 0, sizeof (MME_CommandStatus_t));
+  data->TransformCommand.CmdStatus.AdditionalInfoSize = return_params_size;
+  data->TransformCommand.CmdStatus.AdditionalInfo_p = return_params;
+
+  /* Setting up the command */
+  data->TransformCommand.StructSize = sizeof (MME_Command_t);
+  data->TransformCommand.CmdCode    = MME_TRANSFORM;
+  data->TransformCommand.CmdEnd     = MME_COMMAND_END_RETURN_NOTIFY;
+  data->TransformCommand.DueTime    = (MME_Time_t) 0;
+  data->TransformCommand.NumberInputBuffers  = 0;
+  data->TransformCommand.NumberOutputBuffers = 1;
+  data->TransformCommand.ParamSize  = params_size;
+  data->TransformCommand.Param_p    = params;
+
+  data->TransformCommand.DataBuffers_p[0]->ScatterPages_p[0].Size
+    = data->TransformCommand.DataBuffers_p[0]->TotalSize;
+  data->TransformCommand.DataBuffers_p[0]->ScatterPages_p[0].BytesUsed = 0;
+  data->TransformCommand.DataBuffers_p[0]->ScatterPages_p[0].FlagsIn = 0;
+  data->TransformCommand.DataBuffers_p[0]->ScatterPages_p[0].FlagsOut = 0;
+
+  return DFB_OK;
+
+out:
+  dfb_surface_unlock_buffer (dst_surface, lock);
+  return D_OOM ();
+}
+
+
+static DFBResult
+__attribute__((unused))
+mme_helper_start_transformer (struct _MMECommon     * const data,
+                              size_t                 return_params_size,
+                              void                  * const return_params,
+                              size_t                 params_size,
+                              void                  * const params,
+                              CoreSurface           * const dst_surface,
+                              CoreSurfaceBufferLock * const lock)
+{
+  MME_ERROR res;
+
+  /* setup transform command */
+  res = _mme_helper_start_transformer_core (data,
+                                            return_params_size, return_params,
+                                            params_size, params,
+                                            dst_surface, lock);
+  if (res != DFB_OK)
+    return res;
+
+  _imageprovider_update_transform_params (data, params, lock);
+
+  D_DEBUG_AT (MME_DEBUG_DOMAIN, "issuing MME_TRANSFORM\n");
+
+  /* lock access to hash, because otherwise the callback could be called
+     before we've had a chance to put the command id into the hash */
+  D_ASSERT (data->pending_commands != NULL);
+  pthread_mutex_lock (&data->pending_commands_lock);
+
+  res = MME_SendCommand (data->Handle, &data->TransformCommand);
+  if (res != MME_SUCCESS)
+    {
+      pthread_mutex_unlock (&data->pending_commands_lock);
+
+      D_WARN ("(%5d) %s: starting transformer failed: %d (%s)",
+              direct_gettid (), data->name, res, get_mme_error_string (res));
+
+      dfb_surface_unlock_buffer (dst_surface, lock);
+
+      D_FREE (data->OutDataBuffers);
+      data->OutDataBuffers = NULL;
+
+      return DFB_FAILURE;
+    }
+
+  direct_hash_insert (data->pending_commands,
+                      data->TransformCommand.CmdStatus.CmdId,
+                      (void *) 1);
+  D_DEBUG_AT (MME_DEBUG_DOMAIN, "sent packet's CmdId is %u (%.8x)\n",
+              data->TransformCommand.CmdStatus.CmdId,
+              data->TransformCommand.CmdStatus.CmdId);
+
+  deb_gettimeofday (&data->starttime, NULL);
+
+  pthread_mutex_unlock (&data->pending_commands_lock);
+
+  return DFB_OK;
+}
+
+
+static DFBResult
+_alloc_send_buffer (MME_TransformerHandle_t   handle,
+                    size_t                    size,
+                    struct _MMEHelper_buffer * const buffer)
+{
+  MME_ERROR res;
+  size_t    this_size = MIN (size, MME_STREAMING_BUFFERSIZE);
+
+  D_ASSERT (buffer != NULL);
+  D_ASSUME (size != 0);
+  D_ASSERT (buffer->buffer == NULL);
+
+  D_DEBUG_AT (MME_DEBUG_DOMAIN, "    -> allocating MME buffer for %u bytes\n",
+              this_size);
+
+  res = MME_AllocDataBuffer (handle, this_size, MME_ALLOCATION_PHYSICAL,
+                             &buffer->buffer);
+  if (unlikely (res))
+    {
+      D_WARN ("(%5d) MME_AllocDataBuffer() for %u bytes failed: %s",
+              direct_gettid (), this_size, get_mme_error_string (res));
+
+      return DFB_NOSYSTEMMEMORY;
+    }
+
+  buffer->command.StructSize = sizeof (MME_Command_t);
+  buffer->command.CmdCode = MME_SEND_BUFFERS;
+  buffer->command.CmdEnd  = MME_COMMAND_END_RETURN_NOTIFY;
+  buffer->command.DueTime = (MME_Time_t) 0;
+  buffer->command.NumberInputBuffers  = 1;
+  buffer->command.NumberOutputBuffers = 0;
+  buffer->command.DataBuffers_p = &buffer->buffer;
+  buffer->command.ParamSize = 0;
+  buffer->command.Param_p   = NULL;
+
+  sema_init_event (&buffer->sema, 0);
+
+  D_DEBUG_AT (MME_DEBUG_DOMAIN, "      -> @ %p (%p)\n",
+              buffer, buffer->buffer);
+
+  return DFB_OK;
+}
+
+
+static void
+mme_helper_calculate_packets (struct _MMECommon * const data)
+{
+  D_ASSUME (data->bytes == 0);
+
+  /* FIXME: this is BAD (tm) -> think streaming media! */
+  data->base.buffer->SeekTo (data->base.buffer, 0);
+
+  /* find out the length of the buffer */
+  data->base.buffer->GetLength (data->base.buffer, &data->bytes);
+
+  data->packets = data->bytes / MME_STREAMING_BUFFERSIZE;
+  if ((data->packets * MME_STREAMING_BUFFERSIZE) < data->bytes)
+    ++data->packets;
+
+  D_DEBUG_AT (MME_DEBUG_DOMAIN,
+              "calculated transfer: %u bytes (%u packets, %u bytes each)\n",
+              data->bytes, data->packets, MME_STREAMING_BUFFERSIZE);
+}
+
+static DFBResult
+__attribute__((unused))
+mme_helper_send_packets (struct _MMECommon * const data,
+                         unsigned int       n_packets)
+{
+  unsigned int orig_packets;
+  unsigned int currentbuffer = currentbuffer;
+
+  D_ASSUME (n_packets != 0);
+
+  if (!data->packets && !data->bytes)
+    return DFB_OK;
+
+  D_ASSUME (data->packets != 0);
+  D_ASSUME (data->bytes != 0);
+
+  DFBResult res = DFB_OK;
+
+  orig_packets = n_packets = MIN (n_packets, data->packets);
+  D_DEBUG_AT (MME_DEBUG_DOMAIN, "Sending %u buffers (out of %u remaining)\n",
+              n_packets, data->packets);
+
+//#define MME_OOM
+//#define MME_IOERR
+//#define MME_SENDFAIL
+//#define MME_DATA_CORRUPTION
+#if defined(MME_OOM) || defined(MME_IOERR) || defined(MME_SENDFAIL) || defined(MME_DATA_CORRUPTION)
+int i = 0;
+#endif
+  for (; n_packets && data->packets; --data->packets, --n_packets)
+    {
+      struct _MMEHelper_buffer *buffer;
+      unsigned int this_read = MIN (data->bytes, MME_STREAMING_BUFFERSIZE);
+
+      ++currentbuffer;
+      currentbuffer %= MAX_STREAMING_COMMANDS;
+
+      buffer = &data->SendDataBuffers[currentbuffer];
+
+      /* some checking - We've waited ... should we continue ... */
+      if (data->decode_success == -1)
+        {
+          D_WARN ("(%5d) ImageProvider/%s: error sending data. Transform "
+                  "error reported from callback",
+                  direct_gettid (), data->name);
+          return DFB_FAILURE;
+        }
+
+      /* if we are allocating a new buffer, we don't have to wait on the
+         semaphore, as the new buffer will not yet be known to mme, and thus
+         not in use, of course */
+      if (!buffer->buffer)
+        {
+#ifdef MME_OOM
+if (++i == 4)
+  {
+    fprintf (stderr, "emulating MME_AllocDataBuffer() failure (MME OOM)\n");
+    res = DFB_NOSYSTEMMEMORY;
+  }
+else
+#endif
+          res = _alloc_send_buffer (data->Handle, this_read, buffer);
+          if (res != DFB_OK)
+            return res;
+        }
+      else
+        {
+          /* wait for some buffer to be available */
+          if (unlikely (sema_trywait (&buffer->sema) == -1))
+            {
+              ++data->packets;
+              ++n_packets;
+              usleep (1);
+              continue;
+            }
+        }
+
+      D_DEBUG_AT (MME_DEBUG_DOMAIN, "  -> sending packet %u, using buffer %u @ %p (%p)\n",
+                  orig_packets - n_packets, currentbuffer, buffer,
+                  buffer->buffer);
+      D_DEBUG_AT (MME_DEBUG_DOMAIN, "  -> %u bytes remaining (this read: %u)\n",
+                  data->bytes, this_read);
+
+      /* lock access to hash, because otherwise the callback could be called
+         before we've had a chance to put the command id into the hash */
+      /* it also locks acces to data->buffer, because otherwise the callback
+         might determine we ran out of data if called between fetch_data()
+         and actually sending the MME_SendCommand() below. */
+      D_ASSERT (data->pending_commands != NULL);
+      pthread_mutex_lock (&data->pending_commands_lock);
+
+      /* don't move the abort out of the pending_commands lock! The JPEG
+         transformer might deadlock otherwise */
+      if (data->decode_success == 1)
+        {
+          /* corrupt data -> file can be bigger than actual JPEG data */
+          pthread_mutex_unlock (&data->pending_commands_lock);
+          return DFB_OK;
+        }
+
+#ifdef MME_IOERR
+if (++i == 8)
+  {
+    fprintf (stderr, "emulating IO (read) error\n");
+    res = DFB_FAILURE;
+    usleep (1 * 1000 * 1000);
+  }
+else
+#endif
+      res = fetch_data (data->base.buffer, buffer->buffer, this_read);
+      if (res != DFB_OK)
+        {
+          pthread_mutex_unlock (&data->pending_commands_lock);
+
+          D_WARN ("(%5d) Fetching %u bytes of data failed: res: %d",
+                  direct_gettid (), this_read, res);
+          sema_signal_event (&buffer->sema);
+          /* hm, DirectFB (always?) returns DFB_FAILURE here... */
+          return DFB_IO;
+        }
+#ifdef MME_DATA_CORRUPTION
+if (++i == 2)
+  {
+    fprintf (stderr, "emulating data corruption\n");
+    memset (&buffer->buffer->ScatterPages_p[0].Page_p[15], 0x15, 10);
+  }
+#endif
+
+      /* we just read data, nobody should have determined that we ran into
+         an EOF! */
+      D_ASSERT (data->decode_success != -2);
+
+      data->bytes -= this_read;
+
+      D_DEBUG_AT (MME_DEBUG_DOMAIN, "  -> sending command in buffer %u\n",
+                  currentbuffer);
+
+      /* send the command */
+#ifdef MME_SENDFAIL
+if (++i == 4)
+  {
+    fprintf (stderr, "emulating MME_SendCommand() failure\n");
+    res = MME_NOMEM;
+  }
+else
+#endif
+      res = MME_SendCommand (data->Handle, &buffer->command);
+      if (res != MME_SUCCESS)
+        {
+          pthread_mutex_unlock (&data->pending_commands_lock);
+
+          D_WARN ("(%5d) send DataCommand failed: %s",
+                  direct_gettid (), get_mme_error_string (res));
+          res = DFB_FAILURE;
+          return DFB_FAILURE;
+        }
+
+      direct_hash_insert (data->pending_commands,
+                          buffer->command.CmdStatus.CmdId, (void *) 1);
+      ++data->n_pending_buffers;
+      D_DEBUG_AT (MME_DEBUG_DOMAIN, "sent packet's CmdId is %u (%.8x), %u packets pending now\n",
+                  buffer->command.CmdStatus.CmdId,
+                  buffer->command.CmdStatus.CmdId,
+                  data->n_pending_buffers);
+      pthread_mutex_unlock (&data->pending_commands_lock);
+    }
+
+  D_DEBUG_AT (MME_DEBUG_DOMAIN, "done sending packets (%u remaining)\n",
+              data->packets);
+
+  return res;
+}
+
+
+static DFBResult
+__attribute__((unused))
+mme_helper_stretch_blit (struct _MMECommon * const data,
+                         CoreSurface       * const src,
+                         CoreSurface       * const dst,
+                         DFBRectangle      * const dst_rect)
+{
+  CardState    state;
+  DFBRectangle src_rect;
+
+  dfb_state_init (&state, data->base.core);
+
+  /* set clipping and sizes */
+  state.clip.x1 = 0;
+  state.clip.y1 = 0;
+  state.clip.x2 = dst_rect->w - 1;
+  state.clip.y2 = dst_rect->h - 1;
+
+  state.modified |= SMF_CLIP;
+
+  src_rect.x = 0;
+  src_rect.y = 0;
+  src_rect.w = data->width;
+  src_rect.h = data->height;
+
+  dfb_state_set_source (&state, src);
+  dfb_state_set_destination (&state, dst);
+
+  extern const char *dfb_pixelformat_name( DFBSurfacePixelFormat format );
+  D_DEBUG_AT (MME_DEBUG_DOMAIN, "StretchBlit %dx%d (%dx%d) -> %dx%d (%s -> %s)\n",
+              data->width, data->height, src_rect.w, src_rect.h,
+              dst_rect->w, dst_rect->h,
+              dfb_pixelformat_name (src->config.format),
+              dfb_pixelformat_name (dst->config.format));
+
+  /* thankfully this is intelligent enough to do a simple blit if possible */
+  dfb_gfxcard_stretchblit (&src_rect, dst_rect, &state);
+  data->serial = state.serial;
+
+  /* remove the state */
+  dfb_state_set_source (&state, NULL);
+  dfb_state_set_destination (&state, NULL);
+  dfb_state_destroy (&state);
+
+  return DFB_OK;
+}
+#endif /* USE_MME */
+
+
+#endif /* __MME_HELPER_H__ */
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/interfaces/IDirectFBImageProvider/sema_helper.h DirectFB-1.4.12+STM2011.09.27/interfaces/IDirectFBImageProvider/sema_helper.h
--- DirectFB/interfaces/IDirectFBImageProvider/sema_helper.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/interfaces/IDirectFBImageProvider/sema_helper.h	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,61 @@
+#ifndef __SEMA_HELPER_H__
+#define __SEMA_HELPER_H__
+
+#include <semaphore.h>
+
+
+static inline unsigned int
+__attribute__((warn_unused_result))
+sema_get_event_val (sem_t * const sema)
+{
+  int semval;
+
+  sem_getvalue (sema, &semval);
+
+  return semval;
+}
+
+static inline int
+__attribute__((warn_unused_result))
+sema_wait_event (sem_t * const sema)
+{
+  D_DEBUG_AT (SEMA_DEBUG_DOMAIN, "waiting on %p (val: %u)\n", sema, sema_get_event_val (sema));
+
+  return sem_wait (sema);
+}
+
+static inline int
+__attribute__((warn_unused_result))
+sema_trywait (sem_t * const sema)
+{
+  D_DEBUG_AT (SEMA_DEBUG_DOMAIN, "trywait on %p (val: %u)\n", sema, sema_get_event_val (sema));
+
+  return sem_trywait (sema);
+}
+
+static inline void
+sema_signal_event (sem_t * const sema)
+{
+  D_DEBUG_AT (SEMA_DEBUG_DOMAIN, "signalling %p (val: %u)\n", sema, sema_get_event_val (sema));
+
+  sem_post (sema);
+}
+
+static inline void
+sema_init_event (sem_t        * const sema,
+                 unsigned int  val)
+{
+  D_DEBUG_AT (SEMA_DEBUG_DOMAIN, "init'ing sema %p to %u\n", sema, val);
+
+  sem_init (sema, 0, val);
+}
+
+static inline void
+sema_close_event (sem_t * const sema)
+{
+  D_DEBUG_AT (SEMA_DEBUG_DOMAIN, "destroying sema %p\n", sema);
+
+  sem_destroy (sema);
+}
+
+#endif /* __SEMA_HELPER_H__ */
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/interfaces/IDirectFBVideoProvider/idirectfbvideoprovider_gif.c DirectFB-1.4.12+STM2011.09.27/interfaces/IDirectFBVideoProvider/idirectfbvideoprovider_gif.c
--- DirectFB/interfaces/IDirectFBVideoProvider/idirectfbvideoprovider_gif.c	2015-06-02 22:40:08.131541622 +0200
+++ DirectFB-1.4.12+STM2011.09.27/interfaces/IDirectFBVideoProvider/idirectfbvideoprovider_gif.c	2012-06-06 18:41:31.000000000 +0200
@@ -32,6 +32,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <stdarg.h>
 #include <sys/time.h>
 
 #include <pthread.h>
@@ -56,11 +57,10 @@
 
 #include <misc/gfx_util.h>
 
-
 static DFBResult Probe( IDirectFBVideoProvider_ProbeContext *ctx );
 
 static DFBResult Construct( IDirectFBVideoProvider *thiz,
-                            IDirectFBDataBuffer    *buffer );
+                            ... );
 
 
 #include <direct/interface_implementation.h>
@@ -89,21 +89,29 @@
 
      IDirectFBDataBuffer           *buffer;
      DFBBoolean                     seekable;
-     
+
      IDirectFBSurface              *destination;
      IDirectFBSurface_data         *dst_data;
      DFBRectangle                   dst_rect;
-     
-     u32                           *image;
-     
+
+     int                            direct;
+     int                            direct_clut8;
+
+     DFBColor                       palette[MAXCOLORMAPSIZE];
+
+     CoreSurface                   *decode_surface;
+     CoreSurfaceBufferLock          buffer_lock;
+
      DirectThread                  *thread;
      pthread_mutex_t                lock;
      pthread_cond_t                 cond;
-     
+
+     int                            paused;
+
      DFBVideoProviderStatus         status;
      DFBVideoProviderPlaybackFlags  flags;
      double                         speed;
-     
+
      unsigned int                   start_pos;
 
      char                           Version[4];
@@ -133,6 +141,8 @@
 
      DVFrameCallback                callback;
      void                          *callback_ctx;
+
+     CoreDFB                       *core;
 } IDirectFBVideoProvider_GIF_data;
 
 #define GIFERRORMSG(x, ...) \
@@ -152,37 +162,38 @@
 
      do {
           unsigned int read = 0;
-          
+
           ret = buffer->WaitForData( buffer, len );
           if (ret == DFB_OK)
                ret = buffer->GetData( buffer, len, data, &read );
           if (ret)
                break;
-               
+
           data += read;
           len  -= read;
      } while (len);
-     
+
      return ret;
 }
 
 static int ReadColorMap( IDirectFBDataBuffer *buffer, int number,
-                         u8 buf[3][MAXCOLORMAPSIZE] )
+                         DFBColor palette[MAXCOLORMAPSIZE] )
 {
      int  i;
      u8   rgb[3*number];
-     
+
      if (FetchData( buffer, rgb, sizeof(rgb) )) {
           GIFERRORMSG("bad colormap");
           return -1;
      }
 
      for (i = 0; i < number; ++i) {
-          buf[CM_RED][i]   = rgb[i*3+0];
-          buf[CM_GREEN][i] = rgb[i*3+1];
-          buf[CM_BLUE][i]  = rgb[i*3+2];
+          palette[i].r = rgb[i*3+0];
+          palette[i].g = rgb[i*3+1];
+          palette[i].b = rgb[i*3+2];
+          palette[i].a = 0xff;
      }
-     
+
      return 0;
 }
 
@@ -401,14 +412,17 @@
      return code;
 }
 
-static int ReadImage( IDirectFBVideoProvider_GIF_data *data, 
-                      int left, int top, int width, int height,
-                      u8 cmap[3][MAXCOLORMAPSIZE], bool interlace, bool ignore )
+static int ReadImage( IDirectFBVideoProvider_GIF_data *data,
+                      int left, int top, int width, int height, int pitch,
+                      DFBColor palette[MAXCOLORMAPSIZE], bool interlace, bool ignore )
 {
      u8   c;
      int  v;
-     int  xpos = 0, ypos = 0, pass = 0;
-     u32 *image, *dst;
+     int  xpos = 0;
+     int  ypos = 0;
+     int  pass = 0;
+     u32 *image = 0, *dst = 0;
+     u8  *lut_image = 0, *lut_dst = 0;
 
      /*
      **  Initialize the decompression routines
@@ -429,11 +443,11 @@
                ;
           return 0;
      }
-     
+
      switch (data->disposal) {
           case 2:
                GIFDEBUGMSG("restoring to background color...");
-               memset( data->image, 0, data->Width * data->Height * 4 );
+               //REMOVEME: memset( data->image, 0, data->Width * data->Height * 4 );
                break;
           case 3:
                GIFERRORMSG("restoring to previous frame is unsupported");
@@ -441,18 +455,26 @@
           default:
                break;
      }
-     
-     dst = image = data->image + (top * data->Width + left);
+
+     if (data->direct_clut8)
+          lut_dst = lut_image = (u8 *)(data->buffer_lock.addr) + (top * pitch + left);
+     else
+          dst = image = (u32 *)(data->buffer_lock.addr) + (top * (pitch >> 2) + left);
 
      GIFDEBUGMSG("reading %dx%d at %dx%d %sGIF image",
                  width, height, left, top, interlace ? " interlaced " : "" );
 
      while ((v = LWZReadByte( data, false, c )) >= 0 ) {
           if (v != data->transparent) {
-               dst[xpos] = (0xFF000000              |
-                            cmap[CM_RED][v]   << 16 |
-                            cmap[CM_GREEN][v] << 8  |
-                            cmap[CM_BLUE][v]);
+               if (data->direct_clut8) {
+                    lut_dst[xpos] = v;
+               }
+               else {
+                    dst[xpos] = (0xFF000000         |
+                                 palette[v].r << 16 |
+                                 palette[v].g << 8  |
+                                 palette[v].b);
+               }
           }
 
           ++xpos;
@@ -492,8 +514,14 @@
                else {
                     ++ypos;
                }
-               dst = image + ypos * data->Width;
-          } 
+
+               if (data->direct_clut8) {
+                    lut_dst = lut_image + ypos * pitch;
+               }
+               else {
+                    dst = image + ypos * (pitch >> 2);
+               }
+          }
           if (ypos >= height) {
                break;
           }
@@ -515,16 +543,13 @@
      data->delayTime   = 1000000; /* default: 1s */
      data->inputFlag   = -1;
      data->disposal    = 0;
-     
-     if (data->image)
-          memset( data->image, 0, data->Width*data->Height*4 );
 }
 
 static DFBResult GIFReadHeader( IDirectFBVideoProvider_GIF_data *data )
 {
      DFBResult ret;
      u8        buf[7];
-     
+
      ret = FetchData( data->buffer, buf, 6 );
      if (ret) {
           GIFERRORMSG("error reading header");
@@ -535,10 +560,10 @@
           GIFERRORMSG("bad magic");
           return DFB_UNSUPPORTED;
      }
-     
+
      memcpy( data->Version, &buf[3], 3 );
      data->Version[3] = '\0';
-     
+
      ret = FetchData( data->buffer, buf, 7 );
      if (ret) {
           GIFERRORMSG("error reading screen descriptor");
@@ -557,63 +582,71 @@
           data->AspectRatio = (data->Width << 8) / data->Height;
 
      if (BitSet(buf[4], LOCALCOLORMAP)) {    /* Global Colormap */
-          if (ReadColorMap( data->buffer, data->BitPixel, data->ColorMap )) {
+          if (ReadColorMap( data->buffer, data->BitPixel, data->palette )) {
                GIFERRORMSG("error reading global colormap");
                return DFB_FAILURE;
           }
      }
-     
+
      return DFB_OK;
 }
 
 static DFBResult GIFReadFrame( IDirectFBVideoProvider_GIF_data *data )
 {
-     u8    buf[16], c;
-     int   top, left;
-     int   width, height;
-     u8    localColorMap[3][MAXCOLORMAPSIZE];
-     bool  useGlobalColormap;
+     u8         buf[16], c;
+     int       top, left;
+     int       width, height;
+     DFBColor  local_palette[MAXCOLORMAPSIZE];
+     bool      useGlobalColormap;
 
      data->curbit = data->lastbit = data->done = data->last_byte = 0;
 
-     data->fresh = 
+     data->fresh =
      data->code_size = data->set_code_size =
-     data->max_code = data->max_code_size = 
+     data->max_code = data->max_code_size =
      data->firstcode = data->oldcode =
      data->clear_code = data->end_code = 0;
 
+     dfb_surface_lock_buffer(data->decode_surface, CSBR_FRONT,
+                             CSAID_CPU, CSAF_WRITE, &(data->buffer_lock));
+
      for (;;) {
           DFBResult ret;
-          
+
           ret = FetchData( data->buffer, &c, 1);
           if (ret) {
                GIFERRORMSG("EOF / read error on image data" );
+               dfb_surface_unlock_buffer(data->decode_surface, &(data->buffer_lock));
                return DFB_EOF;
           }
 
-          if (c == ';') /* GIF terminator */
+          if (c == ';') { /* GIF terminator */
+               dfb_surface_unlock_buffer(data->decode_surface, &(data->buffer_lock));
                return DFB_EOF;
+          }
 
           if (c == '!') { /* Extension */
                if (FetchData( data->buffer, &c, 1)) {
                     GIFERRORMSG("EOF / read error on extention function code");
+                    dfb_surface_unlock_buffer(data->decode_surface, &(data->buffer_lock));
                     return DFB_EOF;
                }
                DoExtension( data, c );
                continue;
-          } 
+          }
 
           if (c != ',') { /* Not a valid start character */
                GIFERRORMSG("bogus character 0x%02x, ignoring", (int) c );
                continue;
           }
-               
+
           ret = FetchData( data->buffer, buf, 9 );
           if (ret) {
                GIFERRORMSG("couldn't read left/top/width/height");
+               dfb_surface_unlock_buffer(data->decode_surface, &(data->buffer_lock));
                return ret;
           }
-               
+
           left   = LM_to_uint( buf[0], buf[1] );
           top    = LM_to_uint( buf[2], buf[3] );
           width  = LM_to_uint( buf[4], buf[5] );
@@ -623,21 +656,40 @@
 
           if (!useGlobalColormap) {
                int bitPixel = 2 << (buf[8] & 0x07);
-               if (ReadColorMap( data->buffer, bitPixel, localColorMap ))
+               if (ReadColorMap( data->buffer, bitPixel, local_palette ))
                     GIFERRORMSG("error reading local colormap");
+
+               if (data->direct_clut8) {
+                   IDirectFBPalette *palette;
+
+                   data->destination->GetPalette (data->destination, &palette);
+                   palette->SetEntries (palette, local_palette, data->BitPixel, 0);
+                   palette->Release(palette);
+               }
+          } else {
+               if (data->direct_clut8) {
+                   IDirectFBPalette *palette;
+
+                   data->destination->GetPalette (data->destination, &palette);
+                   palette->SetEntries (palette, data->palette, data->BitPixel, 0);
+                   palette->Release(palette);
+               }
           }
 
           if (ReadImage( data, left, top, width, height,
-                        (useGlobalColormap ?
-                         data->ColorMap : localColorMap),
+                         data->buffer_lock.pitch,
+                         (useGlobalColormap ?
+                         data->palette : local_palette),
                          BitSet( buf[8], INTERLACE ), 0 )) {
                GIFERRORMSG("error reading image");
+               dfb_surface_unlock_buffer(data->decode_surface, &(data->buffer_lock));
                return DFB_FAILURE;
           }
-          
+
           break;
      }
-     
+
+     dfb_surface_unlock_buffer(data->decode_surface, &(data->buffer_lock));
      return DFB_OK;
 }
 
@@ -647,18 +699,37 @@
 IDirectFBVideoProvider_GIF_Destruct( IDirectFBVideoProvider *thiz )
 {
      IDirectFBVideoProvider_GIF_data *data = thiz->priv;
-     
+
      thiz->Stop( thiz );
-     
-     if (data->image)
-          D_FREE( data->image );
-     
+
      if (data->buffer)
           data->buffer->Release( data->buffer );
-    
+
+     if (data->thread) {
+          direct_thread_cancel( data->thread );
+          pthread_mutex_lock( &data->lock );
+          pthread_cond_signal( &data->cond );
+          pthread_mutex_unlock( &data->lock );
+          direct_thread_join( data->thread );
+          direct_thread_destroy( data->thread );
+          data->thread = NULL;
+     }
+
+     if (data->destination) {
+          data->destination->Release( data->destination );
+          data->destination = NULL;
+          data->dst_data    = NULL;
+     }
+
+     if (data->decode_surface && !data->direct) {
+          dfb_surface_destroy_buffers(data->decode_surface);
+          dfb_surface_unref(data->decode_surface);
+          data->decode_surface = 0;
+     }
+
      pthread_cond_destroy( &data->cond );
      pthread_mutex_destroy( &data->lock );
-          
+
      DIRECT_DEALLOCATE_INTERFACE( thiz );
 }
 
@@ -688,12 +759,12 @@
                                             DFBVideoProviderCapabilities *caps )
 {
      DIRECT_INTERFACE_GET_DATA( IDirectFBVideoProvider_GIF )
-     
+
      if (!caps)
           return DFB_INVARG;
-          
+
      *caps = DVCAPS_BASIC | DVCAPS_SCALE | DVCAPS_SPEED;
-     
+
      return DFB_OK;
 }
 
@@ -702,15 +773,30 @@
                                                   DFBSurfaceDescription  *desc )
 {
      DIRECT_INTERFACE_GET_DATA( IDirectFBVideoProvider_GIF )
-     
+
      if (!desc)
           return DFB_INVARG;
-          
-     desc->flags       = DSDESC_WIDTH | DSDESC_HEIGHT | DSDESC_PIXELFORMAT;
-     desc->width       = data->Width;
-     desc->height      = data->Height;
-     desc->pixelformat = DSPF_ARGB;
-     
+
+     desc->width = data->Width;
+     desc->height = data->Height;
+
+     switch (data->BitPixel) {
+     case 256:
+          desc->pixelformat = DSPF_LUT8;
+          break;
+     case 4:
+          desc->pixelformat = DSPF_LUT2;
+          break;
+#if DSPF_LUT4_PATCH_INTEGRATED
+     case 16:
+          desc->pixelformat = DSPF_LUT4;
+          break;
+#endif
+     default:
+         desc->pixelformat = DSPF_ARGB;
+         break;
+     }
+
      return DFB_OK;
 }
 
@@ -719,22 +805,22 @@
                                                  DFBStreamDescription   *desc )
 {
      DIRECT_INTERFACE_GET_DATA( IDirectFBVideoProvider_GIF )
-     
+
      if (!desc)
           return DFB_INVARG;
-          
+
      desc->caps = DVSCAPS_VIDEO;
-     
+
      snprintf( desc->video.encoding,
                DFB_STREAM_DESC_ENCODING_LENGTH, "GIF %s", data->Version );
      desc->video.framerate = 0;
      desc->video.aspect    = (double)data->AspectRatio/256.0;
      desc->video.bitrate   = 0;
-     
-     desc->title[0] = desc->author[0] = 
+
+     desc->title[0] = desc->author[0] =
      desc->album[0] = desc->genre[0] = desc->comment[0] = 0;
      desc->year = 0;
-     
+
      return DFB_OK;
 }
 
@@ -742,25 +828,23 @@
 GIFVideo( DirectThread *self, void *arg )
 {
      IDirectFBVideoProvider_GIF_data *data = arg;
-     
+
      pthread_setcancelstate( PTHREAD_CANCEL_DISABLE, NULL );
-     
+
      while (!direct_thread_is_canceled( self )) {
           DFBResult              ret;
           DFBRectangle           rect;
           DFBRegion              clip;
-          CoreSurface           *surface;
-          CoreSurfaceBufferLock  lock;
-          
+
           pthread_mutex_lock( &data->lock );
-          
+
           if (direct_thread_is_canceled( self )) {
                pthread_mutex_unlock( &data->lock );
                break;
           }
-          
+
           ret = GIFReadFrame( data );
-          if (ret) { 
+          if (ret) {
                if (ret == DFB_EOF) {
                     GIFReset( data );
                     if (data->flags & DVPLAY_LOOPING) {
@@ -775,50 +859,77 @@
                pthread_mutex_unlock( &data->lock );
                continue;
           }
-          
+
           rect = (data->dst_rect.w == 0)
-                 ? data->dst_data->area.wanted : data->dst_rect;          
+                 ? data->dst_data->area.wanted : data->dst_rect;
+
           dfb_region_from_rectangle( &clip, &data->dst_data->area.current );
-          
-          surface = data->dst_data->surface;
-          D_MAGIC_ASSERT( surface, CoreSurface );
 
-          if (dfb_rectangle_region_intersects( &rect, &clip ) &&
-              dfb_surface_lock_buffer( surface, CSBR_BACK, CSAID_CPU, CSAF_WRITE, &lock ) == DFB_OK)
-          {
-               dfb_scale_linear_32( data->image, data->Width, data->Height,
-                                    lock.addr, lock.pitch, &rect, data->dst_data->surface, &clip );
-                                    
-               dfb_surface_unlock_buffer( surface, &lock );
-               
-               if (data->callback)
-                    data->callback( data->callback_ctx );
+          if (!data->direct) {
+               CardState              state;
+               DFBRectangle           srect;
+               CoreSurface           *dst_surface;
+
+               dst_surface = data->dst_data->surface;
+
+               dfb_state_init(&state, data->core);
+
+               state.modified |= SMF_CLIP;
+
+               state.clip.x1 = rect.x;
+               state.clip.y1 = rect.y;
+               state.clip.x2 = rect.x + rect.w - 1;
+               state.clip.y2 = rect.y + rect.h - 1;
+
+               srect.x = 0;
+               srect.y = 0;
+               srect.w = data->Width;
+               srect.h = data->Height;
+
+               dfb_state_set_source(&state, data->decode_surface);
+               dfb_state_set_destination(&state, dst_surface);
+               dfb_gfxcard_stretchblit(&srect, &rect, &state);
+
+               dfb_state_set_source(&state, NULL);
+               dfb_state_set_destination(&state, NULL);
+
+               dfb_state_destroy(&state);
           }
 
-          if (!data->speed) {
+          if (data->callback)
+               data->callback( data->callback_ctx );
+
+          if (!(data->flags & DVPLAY_PACED))
+          {
+               if (!data->speed)
+                    pthread_cond_wait( &data->cond, &data->lock );
+               else {
+                    struct timespec ts;
+                    struct timeval  tv;
+                    unsigned long   us;
+
+                    gettimeofday( &tv, NULL );
+
+                    us = data->delayTime;
+                    if (data->speed != 1.0)
+                         us = ((double)us / data->speed + .5);
+                    us += tv.tv_usec;
+
+                    ts.tv_sec  = tv.tv_sec + us/1000000;
+                    ts.tv_nsec = (us%1000000) * 1000;
+
+                    pthread_cond_timedwait( &data->cond, &data->lock, &ts );
+               }
+          } else {
+               data->status = DVSTATE_STOP;
+
+               // Wait for the next call to PlayTo() to resume decoding
                pthread_cond_wait( &data->cond, &data->lock );
           }
-          else {
-               struct timespec ts;
-               struct timeval  tv;
-               unsigned long   us;
-               
-               gettimeofday( &tv, NULL );
-                    
-               us = data->delayTime;
-               if (data->speed != 1.0)
-                    us = ((double)us / data->speed + .5);
-               us += tv.tv_usec;                 
-                    
-               ts.tv_sec  = tv.tv_sec + us/1000000;
-               ts.tv_nsec = (us%1000000) * 1000;
-                    
-               pthread_cond_timedwait( &data->cond, &data->lock, &ts );
-          }
-          
+
           pthread_mutex_unlock( &data->lock );
      }
-     
+
      return (void*)0;
 }
 
@@ -832,27 +943,31 @@
      IDirectFBSurface_data *dst_data;
      DFBRectangle           rect = { 0, 0, 0, 0 };
      DFBResult              ret;
-     
+
+     CoreSurface           *dst_surface;
+
      DIRECT_INTERFACE_GET_DATA( IDirectFBVideoProvider_GIF )
-     
+
      if (!destination)
           return DFB_INVARG;
-          
+
      dst_data = destination->priv;
      if (!dst_data || !dst_data->surface)
           return DFB_DESTROYED;
-          
+
+     dst_surface = dst_data->surface;
+
      if (dest_rect) {
           if (dest_rect->w < 1 || dest_rect->h < 1)
                return DFB_INVARG;
-          
+
           rect = *dest_rect;
           rect.x += dst_data->area.wanted.x;
           rect.y += dst_data->area.wanted.y;
-     }          
-     
+     }
+
      pthread_mutex_lock( &data->lock );
-     
+
      if (data->status == DVSTATE_FINISHED) {
           ret = data->buffer->SeekTo( data->buffer, data->start_pos );
           if (ret) {
@@ -861,33 +976,56 @@
           }
      }
      data->status = DVSTATE_PLAY;
-     
-     if (!data->image) {          
-          data->image = D_CALLOC( 4, data->Width * data->Height );
-          if (!data->image) {
-               pthread_mutex_unlock( &data->lock );
-               return D_OOM();
-          }
-     }
-     
+
      if (data->destination)
           data->destination->Release( data->destination );
-     
+
      destination->AddRef( destination );
      data->destination = destination;
      data->dst_data    = dst_data;
      data->dst_rect    = rect;
-     
+
+     data->direct = (dst_surface->config.format == DSPF_LUT8
+                     || dst_surface->config.format == DSPF_ARGB)
+                    && (dst_surface->config.size.w == data->Width)
+                    && (dst_surface->config.size.h == data->Height);
+
      data->callback     = callback;
      data->callback_ctx = ctx;
-     
+
+     if (data->direct) {
+          data->decode_surface = dst_data->surface;
+          if (dst_surface->config.format == DSPF_LUT8)
+               data->direct_clut8 = 1;
+     }
+     else {
+          if (!data->decode_surface) {
+               ret = dfb_surface_create_simple (data->core, data->Width,
+                                                data->Height, DSPF_ARGB,
+                                                DSCAPS_VIDEOONLY, CSTF_NONE, 0,
+                                                NULL, &(data->decode_surface));
+               if (ret != DFB_OK) {
+                    pthread_mutex_unlock( &data->lock );
+                    return ret;
+               }
+          }
+     }
+
+     // Playback has already been started by a previous call to PlayTo()
+     if (data->thread && (data->flags & DVPLAY_PACED)) {
+          data->paused = 0;
+          pthread_mutex_unlock( &data->lock );
+          pthread_cond_signal( &data->cond );
+          return DFB_OK;
+     }
+
      if (!data->thread) {
           data->thread = direct_thread_create( DTT_DEFAULT, GIFVideo,
                                               (void*)data, "GIF Video" );
      }
-     
+
      pthread_mutex_unlock( &data->lock );
-     
+
      return DFB_OK;
 }
 
@@ -895,25 +1033,29 @@
 IDirectFBVideoProvider_GIF_Stop( IDirectFBVideoProvider *thiz )
 {
      DIRECT_INTERFACE_GET_DATA( IDirectFBVideoProvider_GIF )
-     
-     if (data->thread) {
-          direct_thread_cancel( data->thread );
-          pthread_mutex_lock( &data->lock );
-          pthread_cond_signal( &data->cond );
-          pthread_mutex_unlock( &data->lock );
-          direct_thread_join( data->thread );
-          direct_thread_destroy( data->thread );
-          data->thread = NULL;
-     }
-     
-     if (data->destination) {
-          data->destination->Release( data->destination );
-          data->destination = NULL;
-          data->dst_data    = NULL;
+
+     if (data->flags & DVPLAY_PACED)
+        data->paused = 1;
+     else {
+          if (data->thread) {
+               direct_thread_cancel( data->thread );
+               pthread_mutex_lock( &data->lock );
+               pthread_cond_signal( &data->cond );
+               pthread_mutex_unlock( &data->lock );
+               direct_thread_join( data->thread );
+               direct_thread_destroy( data->thread );
+               data->thread = NULL;
+          }
+
+          if (data->destination) {
+               data->destination->Release( data->destination );
+               data->destination = NULL;
+               data->dst_data = NULL;
+          }
+
+          data->status = DVSTATE_STOP;
      }
-     
-     data->status = DVSTATE_STOP;
-     
+
      return DFB_OK;
 }
 
@@ -922,12 +1064,12 @@
                                       DFBVideoProviderStatus *status )
 {
      DIRECT_INTERFACE_GET_DATA( IDirectFBVideoProvider_GIF )
-     
+
      if (!status)
           return DFB_INVARG;
-          
+
      *status = data->status;
-     
+
      return DFB_OK;
 }
 
@@ -936,10 +1078,10 @@
                                    double                  seconds )
 {
      DIRECT_INTERFACE_GET_DATA( IDirectFBVideoProvider_GIF )
-     
+
      if (seconds < 0.0)
           return DFB_INVARG;
-          
+
      return DFB_UNSUPPORTED;
 }
 
@@ -948,12 +1090,12 @@
                                    double                 *seconds )
 {
      DIRECT_INTERFACE_GET_DATA( IDirectFBVideoProvider_GIF )
-     
+
      if (!seconds)
           return DFB_INVARG;
-          
+
      *seconds = 0.0;
-          
+
      return DFB_UNSUPPORTED;
 }
 
@@ -962,12 +1104,12 @@
                                       double                 *seconds )
 {
      DIRECT_INTERFACE_GET_DATA( IDirectFBVideoProvider_GIF )
-     
+
      if (!seconds)
           return DFB_INVARG;
-          
+
      *seconds = 0.0;
-          
+
      return DFB_UNSUPPORTED;
 }
 
@@ -976,15 +1118,15 @@
                                              DFBVideoProviderPlaybackFlags  flags )
 {
      DIRECT_INTERFACE_GET_DATA( IDirectFBVideoProvider_GIF )
-     
-     if (flags & ~DVPLAY_LOOPING)
+
+     if (flags & ~(DVPLAY_LOOPING | DVPLAY_PACED))
           return DFB_UNSUPPORTED;
-          
+
      if (flags & DVPLAY_LOOPING && !data->seekable)
           return DFB_UNSUPPORTED;
-          
+
      data->flags = flags;
-     
+
      return DFB_OK;
 }
 
@@ -993,17 +1135,17 @@
                                      double                  multiplier )
 {
      DIRECT_INTERFACE_GET_DATA( IDirectFBVideoProvider_GIF )
-     
+
      if (multiplier < 0.0)
           return DFB_INVARG;
-    
+
      if (data->speed != multiplier) {
-          pthread_mutex_lock( &data->lock ); 
+          pthread_mutex_lock( &data->lock );
           data->speed = multiplier;
           pthread_cond_signal( &data->cond );
           pthread_mutex_unlock( &data->lock );
      }
-     
+
      return DFB_OK;
 }
 
@@ -1012,12 +1154,12 @@
                                      double                 *multiplier )
 {
      DIRECT_INTERFACE_GET_DATA( IDirectFBVideoProvider_GIF )
-     
+
      if (!multiplier)
           return DFB_INVARG;
-          
+
      *multiplier = data->speed;
-     
+
      return DFB_OK;
 }
 
@@ -1027,38 +1169,51 @@
 {
      if (!memcmp( ctx->header, "GIF89", 5 ))
           return DFB_OK;
-          
+
      return DFB_UNSUPPORTED;
 }
 
 static DFBResult
 Construct( IDirectFBVideoProvider *thiz,
-           IDirectFBDataBuffer    *buffer )
+           ... )
 {
      DFBResult ret;
 
+     IDirectFBDataBuffer *buffer;
+     CoreDFB             *core;
+     va_list              tag;
+
      DIRECT_ALLOCATE_INTERFACE_DATA( thiz, IDirectFBVideoProvider_GIF )
 
+     va_start( tag, thiz );
+     buffer = va_arg( tag, IDirectFBDataBuffer * );
+     core = va_arg( tag, CoreDFB * );
+     va_end( tag );
+
+     data->core   = core;
      data->ref    = 1;
      data->status = DVSTATE_STOP;
      data->buffer = buffer;
      data->speed  = 1.0;
-     
+
      buffer->AddRef( buffer );
      data->seekable = (buffer->SeekTo( buffer, 0 ) == DFB_OK);
-     
+
      GIFReset( data );
      ret = GIFReadHeader( data );
      if (ret) {
           IDirectFBVideoProvider_GIF_Destruct( thiz );
           return ret;
      }
-     
+
      data->buffer->GetPosition( data->buffer, &data->start_pos );
-     
-     direct_util_recursive_pthread_mutex_init( &data->lock );
+
+     pthread_mutex_init( &data->lock, NULL );
      pthread_cond_init( &data->cond, NULL );
-     
+
+     data->paused = 0;
+     data->decode_surface = 0;
+
      thiz->AddRef                = IDirectFBVideoProvider_GIF_AddRef;
      thiz->Release               = IDirectFBVideoProvider_GIF_Release;
      thiz->GetCapabilities       = IDirectFBVideoProvider_GIF_GetCapabilities;
@@ -1073,6 +1228,6 @@
      thiz->SetPlaybackFlags      = IDirectFBVideoProvider_GIF_SetPlaybackFlags;
      thiz->SetSpeed              = IDirectFBVideoProvider_GIF_SetSpeed;
      thiz->GetSpeed              = IDirectFBVideoProvider_GIF_GetSpeed;
-     
+
      return DFB_OK;
 }
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/lib/direct/interface.c DirectFB-1.4.12+STM2011.09.27/lib/direct/interface.c
--- DirectFB/lib/direct/interface.c	2015-06-02 22:40:08.135542124 +0200
+++ DirectFB-1.4.12+STM2011.09.27/lib/direct/interface.c	2012-06-06 18:41:31.000000000 +0200
@@ -263,12 +263,6 @@
                }
 
                /*
-                * Keep filename and module handle.
-                */
-               impl->filename      = D_STRDUP( buf );
-               impl->module_handle = handle;
-
-               /*
                 * Almost the same stuff like above, TODO: make function.
                 */
                if (strcmp( type, impl->type ))
@@ -282,6 +276,13 @@
                     continue;
                }
                else {
+                    /*
+                     * Keep filename and module handle.
+                     */
+                    impl->filename      = D_STRDUP( buf );
+                    impl->module_handle = handle;
+
+
                     D_INFO( "Direct/Interface: Loaded '%s' implementation of '%s'.\n",
                             impl->implementation, impl->type );
 
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/lib/fusion/fusion.c DirectFB-1.4.12+STM2011.09.27/lib/fusion/fusion.c
--- DirectFB/lib/fusion/fusion.c	2015-06-02 22:40:08.143543128 +0200
+++ DirectFB-1.4.12+STM2011.09.27/lib/fusion/fusion.c	2012-06-06 18:41:31.000000000 +0200
@@ -435,8 +435,13 @@
 
 
 
+#if defined(__SH4__)
+#  define shm_align_mask  (0x3fff)
+#else
+#  define shm_align_mask  (0xffff)
+#endif
      /* Map shared area. */
-     map = mmap( shm_base + 0x10000 * world_index, sizeof(FusionWorldShared),
+     map = mmap( shm_base + (shm_align_mask + 1) * world_index, sizeof(FusionWorldShared),
                  PROT_READ | PROT_WRITE, MAP_FIXED | MAP_SHARED, fd, 0 );
      if (map == MAP_FAILED) {
           ret = errno2result(errno);
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/lib/fusion/shm/heap.c DirectFB-1.4.12+STM2011.09.27/lib/fusion/shm/heap.c
--- DirectFB/lib/fusion/shm/heap.c	2015-06-02 22:40:08.147543631 +0200
+++ DirectFB-1.4.12+STM2011.09.27/lib/fusion/shm/heap.c	2012-06-06 18:41:31.000000000 +0200
@@ -640,7 +640,7 @@
      fchmod( fd, 0660 );
      ftruncate( fd, size );
 
-     D_DEBUG_AT( Fusion_SHMHeap, "  -> mmaping shared memory file... (%d bytes)\n", size );
+     D_DEBUG_AT( Fusion_SHMHeap, "  -> mmaping shared memory file... (%p %d bytes)\n", addr_base, size );
 
      /* map it shared */
      heap = mmap( addr_base, size + space, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_FIXED, fd, 0 );
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/lib/fusion/shm/pool.c DirectFB-1.4.12+STM2011.09.27/lib/fusion/shm/pool.c
--- DirectFB/lib/fusion/shm/pool.c	2015-06-02 22:40:08.147543631 +0200
+++ DirectFB-1.4.12+STM2011.09.27/lib/fusion/shm/pool.c	2012-06-06 18:41:31.000000000 +0200
@@ -721,7 +721,12 @@
                                 BLOCKALIGN( (max_size + BLOCKSIZE-1) / BLOCKSIZE * sizeof(shmalloc_info) );
 
      pool_addr_base = world->shared->pool_base;
-     world->shared->pool_base += ((pool_max_size + page_size - 1) & ~(page_size - 1)) + page_size;
+#ifdef __SH4__
+  #define SHM_ALIGN_SIZE 0x4000
+#else
+  #define SHM_ALIGN_SIZE page_size
+#endif
+     world->shared->pool_base += ((pool_max_size + page_size - 1) & ~(SHM_ALIGN_SIZE - 1)) + SHM_ALIGN_SIZE;
      /* Exceeded limit? */
      if (world->shared->pool_base > world->shared->pool_max)
           return DR_NOSHAREDMEMORY;
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/proxy/dispatcher/idirectfbsurface_dispatcher.c DirectFB-1.4.12+STM2011.09.27/proxy/dispatcher/idirectfbsurface_dispatcher.c
--- DirectFB/proxy/dispatcher/idirectfbsurface_dispatcher.c	2015-06-02 22:40:08.151544133 +0200
+++ DirectFB-1.4.12+STM2011.09.27/proxy/dispatcher/idirectfbsurface_dispatcher.c	2012-06-06 18:41:31.000000000 +0200
@@ -602,6 +602,21 @@
 }
 
 static DFBResult
+IDirectFBSurface_Dispatcher_BatchStretchBlit( IDirectFBSurface   *thiz,
+                                              IDirectFBSurface   *source,
+                                              DFBRectangle       *source_rects,
+                                              DFBRectangle       *destination_rects,
+                                              int                 num )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface_Dispatcher)
+
+     if (!source)
+          return DFB_INVARG;
+
+     return DFB_UNIMPLEMENTED;
+}
+
+static DFBResult
 IDirectFBSurface_Dispatcher_TextureTriangles( IDirectFBSurface     *thiz,
                                               IDirectFBSurface     *source,
                                               const DFBVertex      *vertices,
@@ -1172,6 +1187,37 @@
 }
 
 static DirectResult
+Dispatch_BatchStretchBlit( IDirectFBSurface *thiz, IDirectFBSurface *real,
+                           VoodooManager *manager, VoodooRequestMessage *msg )
+{
+     DirectResult         ret;
+     VoodooMessageParser  parser;
+     VoodooInstanceID     instance;
+     unsigned int         num;
+     const DFBRectangle  *source_rects;
+     const DFBRectangle  *dest_rects;
+     void                *surface;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface_Dispatcher)
+
+     VOODOO_PARSER_BEGIN( parser, msg );
+     VOODOO_PARSER_GET_ID( parser, instance );
+     VOODOO_PARSER_GET_UINT( parser, num );
+     VOODOO_PARSER_GET_DATA( parser, source_rects );
+     VOODOO_PARSER_GET_DATA( parser, dest_rects );
+     VOODOO_PARSER_END( parser );
+
+     ret = voodoo_manager_lookup_local( manager, instance, NULL, &surface );
+     if (ret)
+          return ret;
+
+     real->BatchStretchBlit( real, surface, (DFBRectangle *) source_rects,
+                             (DFBRectangle *) dest_rects, num );
+
+     return DFB_OK;
+}
+
+static DirectResult
 Dispatch_TextureTriangles( IDirectFBSurface *thiz, IDirectFBSurface *real,
                            VoodooManager *manager, VoodooRequestMessage *msg )
 {
@@ -1766,6 +1812,9 @@
           case IDIRECTFBSURFACE_METHOD_ID_StretchBlit:
                return Dispatch_StretchBlit( dispatcher, real, manager, msg );
 
+          case IDIRECTFBSURFACE_METHOD_ID_BatchStretchBlit:
+               return Dispatch_BatchStretchBlit( dispatcher, real, manager, msg );
+
           case IDIRECTFBSURFACE_METHOD_ID_TextureTriangles:
                return Dispatch_TextureTriangles( dispatcher, real, manager, msg );
 
@@ -1899,6 +1948,7 @@
      thiz->TileBlit = IDirectFBSurface_Dispatcher_TileBlit;
      thiz->BatchBlit = IDirectFBSurface_Dispatcher_BatchBlit;
      thiz->StretchBlit = IDirectFBSurface_Dispatcher_StretchBlit;
+     thiz->BatchStretchBlit = IDirectFBSurface_Dispatcher_BatchStretchBlit;
      thiz->TextureTriangles = IDirectFBSurface_Dispatcher_TextureTriangles;
 
      thiz->SetDrawingFlags = IDirectFBSurface_Dispatcher_SetDrawingFlags;
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/proxy/dispatcher/idirectfbsurface_dispatcher.h DirectFB-1.4.12+STM2011.09.27/proxy/dispatcher/idirectfbsurface_dispatcher.h
--- DirectFB/proxy/dispatcher/idirectfbsurface_dispatcher.h	2015-06-02 22:40:08.155544635 +0200
+++ DirectFB-1.4.12+STM2011.09.27/proxy/dispatcher/idirectfbsurface_dispatcher.h	2012-06-06 18:41:31.000000000 +0200
@@ -87,5 +87,6 @@
 #define IDIRECTFBSURFACE_METHOD_ID_Read                      56
 #define IDIRECTFBSURFACE_METHOD_ID_SetColors                 57
 #define IDIRECTFBSURFACE_METHOD_ID_BatchBlit2                58
+#define IDIRECTFBSURFACE_METHOD_ID_BatchStretchBlit          59
 
 #endif
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/proxy/requestor/idirectfbsurface_requestor.c DirectFB-1.4.12+STM2011.09.27/proxy/requestor/idirectfbsurface_requestor.c
--- DirectFB/proxy/requestor/idirectfbsurface_requestor.c	2015-06-02 22:40:08.155544635 +0200
+++ DirectFB-1.4.12+STM2011.09.27/proxy/requestor/idirectfbsurface_requestor.c	2012-06-06 18:41:31.000000000 +0200
@@ -924,6 +924,31 @@
 }
 
 static DFBResult
+IDirectFBSurface_Requestor_BatchStretchBlit( IDirectFBSurface   *thiz,
+                                             IDirectFBSurface   *source,
+                                             DFBRectangle       *source_rects,
+                                             DFBRectangle       *dest_rects,
+                                             int                 num )
+{
+     IDirectFBSurface_Requestor_data *source_data;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface_Requestor)
+
+     if (!source)
+          return DFB_INVARG;
+
+     DIRECT_INTERFACE_GET_DATA_FROM( source, source_data, IDirectFBSurface_Requestor );
+
+     return voodoo_manager_request( data->manager, data->instance,
+                                    IDIRECTFBSURFACE_METHOD_ID_BatchStretchBlit, VREQ_QUEUE, NULL,
+                                    VMBT_ID, source_data->instance,
+                                    VMBT_UINT, num,
+                                    VMBT_DATA, num * sizeof(DFBRectangle), source_rects,
+                                    VMBT_DATA, num * sizeof(DFBRectangle), dest_rects,
+                                    VMBT_NONE );
+}
+
+static DFBResult
 IDirectFBSurface_Requestor_TextureTriangles( IDirectFBSurface     *thiz,
                                              IDirectFBSurface     *source,
                                              const DFBVertex      *vertices,
@@ -1574,6 +1599,7 @@
      thiz->TileBlit = IDirectFBSurface_Requestor_TileBlit;
      thiz->BatchBlit = IDirectFBSurface_Requestor_BatchBlit;
      thiz->StretchBlit = IDirectFBSurface_Requestor_StretchBlit;
+     thiz->BatchStretchBlit = IDirectFBSurface_Requestor_BatchStretchBlit;
      thiz->TextureTriangles = IDirectFBSurface_Requestor_TextureTriangles;
 
      thiz->SetDrawingFlags = IDirectFBSurface_Requestor_SetDrawingFlags;
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/SPECS/stm-target-directfb.spec DirectFB-1.4.12+STM2011.09.27/SPECS/stm-target-directfb.spec
--- DirectFB/SPECS/stm-target-directfb.spec	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/SPECS/stm-target-directfb.spec	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,409 @@
+%define _dfb_build_config	x@BUILD_CONFIG@
+
+Name:		%{_stm_pkg_prefix}-target-directfb@BUILD_CONFIG@
+Summary:	Hardware graphics acceleration library
+Group:		DirectFB/Libraries
+%define _dfbversion	1.4.12
+%define _abiversion	1.4-5
+%define _stmversion	+STM2011.09.27
+Version:	%{_dfbversion}%{_stmversion}
+Release:	1
+Epoch: 1
+License:	LGPL
+# created by:
+# git archive --format=tar --prefix=DirectFB-1.4.12+STM2011.09.27/ DIRECTFB_1_4_12_STM2011.09.27 | bzip2 --best > DirectFB-1.4.12+STM2011.09.27.tar.bz2
+Source0:	DirectFB-%{version}.tar.bz2
+
+URL:		http://www.directfb.org
+Buildroot:	%(mktemp -ud %{_tmppath}/%{name}-%{version}-%{release}-%{_stm_target_arch}-XXXXXX)
+Prefix:		%{_stm_cross_target_dir}
+
+BuildRequires:	%{_stm_pkg_prefix}-%{_stm_target_arch}-libpng-dev
+%if_target_cpu sh
+BuildRequires:	%{_stm_pkg_prefix}-%{_stm_target_arch}-stmfb-headers >= 3.1_stm24_0101
+%define _dfb_gfxdrivers stgfx
+%define _mme_enabled yes
+%else
+%define _dfb_gfxdrivers none
+%define _mme_enabled no
+%endif
+%if "%{_dfb_build_config}" == "x-multi"
+BuildRequires: %{_stm_pkg_prefix}-%{_stm_target_arch}-linux-fusion-headers >= 8.2.0
+%define _dfb_multiapp --enable-multi
+%else
+%define _dfb_multiapp --disable-multi
+%endif
+
+%define _pkgname	%{_stm_pkg_prefix}-%{_stm_target_arch}-directfb
+%define _fullname	directfb-%{_abiversion}
+%define _docdir		%{_stm_cross_target_dir}%{_stm_target_doc_dir}
+
+
+#
+#  SRPM Package
+#
+%description
+The source package for directfb.
+
+#
+#  RPMS
+#
+%package -n %{_pkgname}@BUILD_CONFIG@
+Summary:	Hardware graphics acceleration library
+Group:		DirectFB/Libraries
+Provides:	%{_pkgname} = %{version}-%{release}
+%if "%{_dfb_build_config}" == "x-multi"
+Provides:	%{_pkgname}-multi = %{version}-%{release}
+Conflicts:	%{_pkgname}-single
+%else
+Provides:	%{_pkgname}-single = %{version}-%{release}
+Conflicts:	%{_pkgname}-multi
+%endif
+%description -n %{_pkgname}@BUILD_CONFIG@
+DirectFB is a thin library that provides developers with hardware graphics
+acceleration, input device handling and abstraction, an integrated windowing
+system with support for translucent windows and multiple display layers on top
+of the Linux frame buffer device. It is a complete hardware abstraction layer
+with software fallbacks for every graphics operation that is not supported by
+the underlying hardware.
+%if "%{_dfb_build_config}" == "x-multi"
+This version has been built with the Multi Application Core.
+%else
+This version has been built with the Single Application Core.
+%endif
+
+%package -n %{_pkgname}@BUILD_CONFIG@-dev
+Summary:	Hardware graphics acceleration library - development
+Group:		DirectFB/Development
+AutoReq:	no
+Provides:	%{_pkgname}-dev = %{version}-%{release}
+%if "%{_dfb_build_config}" == "x-multi"
+Requires:	%{_pkgname}-multi = %{version}-%{release}
+Provides:	%{_pkgname}-multi-dev = %{version}-%{release}
+%else
+Requires:	%{_pkgname}-single = %{version}-%{release}
+Provides:	%{_pkgname}-single-dev = %{version}-%{release}
+%endif
+%description -n %{_pkgname}@BUILD_CONFIG@-dev
+DirectFB header files needed for building DirectFB applications.
+
+%package -n %{_pkgname}@BUILD_CONFIG@-dbg
+Summary:	Hardware graphics acceleration library - debug info
+Group:		DirectFB/Development
+AutoReq:	no
+Provides:	%{_pkgname}-dbg = %{version}-%{release}
+%if "%{_dfb_build_config}" == "x-multi"
+Requires:	%{_pkgname}-multi = %{version}-%{release}
+Provides:	%{_pkgname}-multi-dbg = %{version}-%{release}
+%else
+Requires:	%{_pkgname}-single = %{version}-%{release}
+Provides:	%{_pkgname}-single-dbg = %{version}-%{release}
+%endif
+%description -n %{_pkgname}@BUILD_CONFIG@-dbg
+This package provides debug information for DirectFB. Debug information
+is useful for providing meaningful backtraces in case of bugs.
+
+
+%prep
+%target_setup
+%setup -q -n DirectFB-%{version}
+%target_autoreconf
+
+%build
+%target_setup
+# the st231 compiler emits a warning when it encounters multiple -O statements,
+# which makes auto* assume that some of its tests failed. Strip out existing -O
+# and add -O3
+_stripped_flags=
+for _this_flag in $CFLAGS ; do
+  _stripped_flags="${_stripped_flags} `echo $_this_flag | sed -e 's,-O.,,'`"
+done
+export CFLAGS="${_stripped_flags} -O3"
+export CPPFLAGS="$CPPFLAGS -DDIRECTFB_VERSION_VENDOR=\\\"%{_stmversion}\\\""
+# add -g for debug package
+export CFLAGS="${CFLAGS} -g3"
+
+%target_do_configure \
+	--enable-static \
+	\
+	--disable-devmem \
+	--disable-sdl \
+	\
+	--with-gfxdrivers=%{_dfb_gfxdrivers} \
+	--enable-mme=%{_mme_enabled} \
+	\
+	%{_dfb_multiapp}
+%pmake
+
+
+%install
+%target_setup
+%target_makeinstall_destdir
+
+# build directfb-config for host environment
+# we assume that _stm_target_lib_dir is in the default search path of both the cross
+# and target dynamic linkers, to suppres spurious -L/usr/lib in *.la files
+mkdir -p %{buildroot}%{_stm_cross_bin_dir}
+sed -e "s,libs=-L%{_stm_target_lib_dir},libs=,g" \
+    -e "s,%{_stm_target_prefix},%{_stm_cross_target_dir}%{_stm_target_prefix},g" \
+    < %{buildroot}%{_stm_cross_target_dir}%{_stm_target_bin_dir}/directfb-config \
+    > %{buildroot}%{_stm_cross_bin_dir}/%{_stm_target_toolprefix}directfb-config
+chmod +x %{buildroot}%{_stm_cross_bin_dir}/%{_stm_target_toolprefix}directfb-config
+
+%target_install_fixup
+# Process target .pc files so they are useful in a cross environment
+for f in %{buildroot}%{_stm_cross_target_dir}%{_stm_target_pkgconfig_dir}/*.pc ; do
+  sed -i '/^prefix=/!s,%{_stm_target_prefix},${prefix},' $f
+done
+
+
+cd ..
+cp COPYING LICENSE
+
+
+# pull debug from solibs out into separate files, to be packaged in the -dbg package
+# have to be careful to not include files like libdirectfb_sonypi.la or shell scripts
+rm -f dfb-debuginfo.filelist
+files=`find %{buildroot}%{_stm_cross_target_dir}%{_stm_target_bin_dir} -type f | grep -v directfb-config`
+files="${files} `find %{buildroot}%{_stm_cross_target_dir}%{_stm_target_lib_dir} -name 'lib*so*' -type f | egrep -v '\.debug$' | egrep '(\.so$|\.so\.)'`"
+for solib in ${files} ; do
+  debugfile=%{_stm_cross_target_dir}%{_stm_target_debug_dir}`echo ${solib} | sed -e s,%{buildroot}%{_stm_cross_target_dir},,`.debug
+  mkdir -p `dirname %{buildroot}${debugfile}`
+  %{_stm_target_toolprefix}objcopy --only-keep-debug ${solib} %{buildroot}${debugfile}
+  %{_stm_target_toolprefix}objcopy --strip-debug ${solib}
+  %{_stm_target_toolprefix}objcopy --add-gnu-debuglink=%{buildroot}${debugfile} ${solib}
+  echo ${debugfile} >> dfb-debuginfo.filelist
+done
+
+
+%clean
+rm -rf %{buildroot}
+
+
+%files -n %{_pkgname}@BUILD_CONFIG@
+%defattr(-,root,root)
+%{_stm_cross_target_dir}%{_stm_target_lib_dir}/lib*.so.*
+%dir %{_stm_cross_target_dir}%{_stm_target_lib_dir}/%{_fullname}
+%dir %{_stm_cross_target_dir}%{_stm_target_lib_dir}/%{_fullname}/*
+%{_stm_cross_target_dir}%{_stm_target_lib_dir}/%{_fullname}/*/lib*.so
+%dir %{_stm_cross_target_dir}%{_stm_target_lib_dir}/%{_fullname}/interfaces/*
+%{_stm_cross_target_dir}%{_stm_target_lib_dir}/%{_fullname}/interfaces/*/lib*.so
+%dir %{_stm_cross_target_dir}%{_stm_target_data_dir}/directfb-%{_dfbversion}
+%{_stm_cross_target_dir}%{_stm_target_data_dir}/directfb-%{_dfbversion}/cursor.dat
+%{_stm_cross_target_dir}%{_stm_target_data_dir}/man/man5/directfbrc*5*
+%doc AUTHORS ChangeLog LICENSE NEWS README TODO
+
+%files -n %{_pkgname}@BUILD_CONFIG@-dev
+%defattr(-,root,root)
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/*
+%{_stm_cross_target_dir}%{_stm_target_include_dir}/directfb
+%{_stm_cross_target_dir}%{_stm_target_include_dir}/directfb-internal
+%{_stm_cross_target_dir}%{_stm_target_lib_dir}/lib*.so
+%{_stm_cross_target_dir}%{_stm_target_lib_dir}/lib*.a
+%{_stm_cross_target_dir}%{_stm_target_lib_dir}/lib*.la
+%{_stm_cross_target_dir}%{_stm_target_lib_dir}/%{_fullname}/*/lib*.a
+%{_stm_cross_target_dir}%{_stm_target_lib_dir}/%{_fullname}/*/lib*.la
+%{_stm_cross_target_dir}%{_stm_target_lib_dir}/%{_fullname}/*/lib*.o
+%{_stm_cross_target_dir}%{_stm_target_lib_dir}/%{_fullname}/interfaces/*/lib*.a
+%{_stm_cross_target_dir}%{_stm_target_lib_dir}/%{_fullname}/interfaces/*/lib*.la
+%{_stm_cross_target_dir}%{_stm_target_lib_dir}/%{_fullname}/interfaces/*/lib*.o
+%{_stm_cross_target_dir}%{_stm_target_pkgconfig_dir}/*.pc
+%{_stm_cross_target_dir}%{_stm_target_data_dir}/man/man1/dfbg*1*
+%{_stm_cross_target_dir}%{_stm_target_data_dir}/man/man1/directfb-csource*1*
+%{_stm_cross_bin_dir}/*
+%doc AUTHORS ChangeLog LICENSE NEWS README TODO
+
+%files -n %{_pkgname}@BUILD_CONFIG@-dbg -f dfb-debuginfo.filelist
+%defattr(-,root,root)
+%doc AUTHORS ChangeLog LICENSE NEWS README TODO
+
+
+%changelog
+* Tue Sep 27 2011 Andr Draszik <andre.draszik@st.com> - 1:1.4.12+STM2011.09.27-1
+- [Bugzilla: 14222] subpixel based backwards blits don't look perfect
+- [Delete patch:
+   DirectFB-1.4.12+STM2011.05.05-bdisp2_accel-fix-directions-for-backwards-copy.patch,
+   DirectFB-1.4.12+STM2011.05.05-bdisp_accel-hot-fix-for-backwards-blits-than-don-t-r.patch]
+  not needed anymore
+
+* Fri Sep 16 2011 Andr Draszik <andre.draszik@st.com> - 1:1.4.12+STM2011.05.05-3
+- [Bugzilla: 14177; Add patch:
+   DirectFB-1.4.12+STM2011.05.05-bdisp2_accel-fix-directions-for-backwards-copy.patch,
+   DirectFB-1.4.12+STM2011.05.05-bdisp_accel-hot-fix-for-backwards-blits-than-don-t-r.patch]
+  hotfix for STLinux bugzilla 14177
+
+* Wed Aug 31 2011 Giuseppe Condorelli <giuseppe.condorelli@st.com> 1:1.4.12+STM2011.05.05-2
+- [Spec] Add libpng BuildRequires, also rebuilding package against updated libpng
+
+* Thu May 05 2011 Andr Draszik <andre.draszik@st.com> 1:1.4.12+STM2011.05.05-1
+- [Bugzilla: 11922] really fix raw jpeg decoding for libjpeg >= v7
+- [Bugzilla: 10850, 12050] clipping in "fb_gfxcard_drawstring" not checked correctly
+- fix small memory leak in DirectGetInterface()
+
+* Thu Apr 14 2011 Andr Draszik <andre.draszik@st.com> 1:1.4.12+STM2011.04.14-1
+- [Update: 1.4.12+STM2011.04.14] update to DirectFB 1.4.12 and latest STM version
+- [Bugzilla: 11689] inputdrivers: support lirc>=0.8.6
+- [Bugzilla: 11884] build: libidirectfbfont_ft2 must be linked against libm
+- [Delete patch: DirectFB-1.4.11-non-mme-hotfix.patch] not needed anymore
+- [Bugzilla: 11922] fix raw jpeg decoding for libjpeg >= v7
+
+* Tue Apr 05 2011 Andr Draszik <andre.draszik@st.com> 1:1.4.11+STM2010.12.15-4
+- [Bugzilla: 11825; Spec] add debug info package
+- [Spec] update summary of -dev package
+
+* Thu Jan 06 2011 Andr Draszik <andre.draszik@st.com> 1:1.4.11+STM2010.12.15-3
+- [Add patch: DirectFB-1.4.11-non-mme-hotfix.patch] hotfix for builds with
+  disabled MME
+- Breaks binary compatibility with Mali drivers (Mali drivers need to be rebuilt)
+
+* Wed Jan 05 2011 Andr Draszik <andre.draszik@st.com> 1:1.4.11+STM2010.12.15-2
+- [Spec] disable MME use for image decoding for non sh4 builds during configure
+  to fix build failures on ARM
+
+* Wed Dec 15 2010 Andr Draszik <andre.draszik@st.com> 1:1.4.11+STM2010.12.15-1
+- [Update: 1.4.11+STM2010.12.15] new release based on 1.4.11 + git 811a8c0
+- [Bugzilla: 10320] don't set any output resolution on startup
+- [Bugzilla: 10344] take DirectFB's init-layer=<x> option into account
+- [Bugzilla: 10769] want SOURCE2 support in DirectFB BDisp driver
+- image providers: accelerate JPEG and PNG using MME
+- fixed point fixes
+- [Delete patch: DirectFB-1.4.3-0001-stgfx2-version-bump.patch] integrated upstream
+- [Spec] Bump BuildRequires for linux-fusion to 8.2.0
+- [Spec] drop setting of LIBPNG_CONFIG - it's not needed anymore
+
+* Thu Oct 21 2010 Andr Draszik <andre.draszik@st.com> 1:1.4.3+STM2010.10.15-1
+- [Add patch: DirectFB-1.4.3-0001-stgfx2-version-bump.patch] bump stgfx2 version
+  to 0.8
+
+* Fri Oct 15 2010 Andr Draszik <andre.draszik@st.com> 1:1.4.3+STM2010.10.15-1
+- [Update: 1.4.3+STM2010.10.15] new release
+- [Bugzilla: 10253] jpeg: fix raw decode error paths
+- [Bugzilla: 10242] stgfx2: DSBLIT_XOR does not work
+- [Bugzilla: 10254] stgfx2: incorrect use of line filters for 'slim' stretch blits
+- [Bugzilla: 10228] stgfx2: disable use of hw based clipping
+- [Bugzilla: 10226] stgfx2: full DSBLIT_BLEND_COLORALPHA support
+- [Bugzilla: 10227] stgfx2: fix some 'unusual' PorterDuff blends
+- [Bugzilaa: 10247] stgfx2: DSPD_CLEAR crashes the BDisp in 422r modes
+- stgfx2 cleanup: blit state rewrite, compiler warnings, debug for DirectFB 1.4.3,
+  fixes for RGB32
+- [Spec] some changes so as to make future updates easier
+
+* Thu Aug 26 2010 Andr Draszik <andre.draszik@st.com> 1:1.4.3+STM2010.06.22-2
+- [Spec] fix build requires to reference correct stmfb headers package version
+  on sh4
+
+* Wed Aug 25 2010 Andr Draszik <andre.draszik@st.com> 1:1.4.3+STM2010.06.22-1
+- [Update: 1.4.3+STM2010.06.22] new release
+- [Delete patch: DirectFB-1.4.3+STM2010.06.16-stmfb0029.patch] we have an up to
+  date stmfb in STLinux 2.4 now, so this patch is a) harmful for STi7108 support
+  and b) not needed anymore anyway
+- stgfx2: fix clip validation
+
+* Wed Jun 16 2010 Andr Draszik <andre.draszik@st.com> 1:1.4.3+STM2010.06.16-1
+- [Update: 1.4.3.STM2010.06.16] new release
+- [Delete patch: DirectFB-1.4.3.STM2010.03.10-libjpeg7.patch, 
+   DirectFB-1.4.3.STM2010.03.10-libjpeg7_2.patch]
+  jpeg problems correctly fixed upstream
+- [Delete patch: DirectFB-1.4-Revert-versioned-DirectFB-libraries.patch]
+  not needed anymore
+- [Add patch: DirectFB-1.4.3+STM2010.06.16-stmfb0029.patch] needed now
+
+* Tue Apr 27 2010 Andr Draszik <andre.draszik@st.com> 1.4.3.STM2010.03.10-4
+- [Bugzilla: 8912; Add patch: DirectFB-1.4.3.STM2010.03.10-libjpeg7.patch,
+   DirectFB-1.4.3.STM2010.03.10-libjpeg7_2.patch]
+  fix libjpeg usage for libjpeg versions >= 7
+- [Spec] simplify file ownership list
+- [Spec] bump version to rebuild against updated libjpeg
+
+* Tue Apr 13 2010 Andr Draszik <andre.draszik@st.com> 1.4.3.STM2010.03.10-3
+- [Spec] fix source package name
+
+* Wed Mar 31 2010 Stuart Menefy <stuart.menefy@st.com> 2
+- [Spec] Bump the release number for 2.4 product release.
+- [Spec] Update BuildRoot to use %%(mktemp ...) to guarantee a unique name.
+
+* Wed Mar 09 2010 Andr Draszik <andre.draszik@st.com> 1.4.3.STM2010.03.10-1
+- [Spec] add some more files to main package's documentation
+- merge in latest updates from DirectFB/master branch
+- input: handle button devices with just up/down keys as keyboards, too
+- stgfx2: fix shutdown error path
+- stgfx2: big cleanup regarding the destination address
+- stgfx2: slightly smaller cleanup regarding the s3 address & type
+- stgfx2: cleanup regarding s2 address & type
+- stgfx2: huge cleanup regarding drawing state
+- the above four changes yield in about 10% less CPU usage on fills!
+- [Bugzilla: 8256] XOR doesn't work as expected
+- [Bugzilla: 8406] prevent BDisp crash when doing YCbCr422R fast blit
+- [Bugzilla: 8366] desaturation of YCbCr surfaces
+- stgfx2: back to bdisp_aq_VideoYCbCr601_2_RGB matrix for YCbCr->RGB conversions
+- stgfx2: allow 'other' accelerators to access our surface pools
+- stgfx2: RGB32 updates
+
+* Fri Feb 05 2010 Andr Draszik <andre.draszik@st.com> 1.4.3.STM2010.02.08-1
+- [Bugzilla: 8193] do necessary changes (pollvsync_after)
+- [Bugzilla: 7360, 8077] subpixel vertical filter setup has been
+  greatly simplified and corrected
+
+* Fri Feb 05 2010 Andr Draszik <andre.draszik@st.com> 1.4.3.STM2010.02.05-1
+- stgfx stgfx2: fix shutdown when not running in stmfbdev system
+- linux_input: fix compilation if stmfbdev is disabled
+
+* Sun Jan 31 2010 Andr Draszik <andre.draszik@st.com> 1.4.3.STM2010.01.31-1
+- merge in latest updates from DirectFB/master branch
+- stmfbdev: address compiler warnings in non debug builds
+- stmfbdev: fix crash in shutdown
+- stmfbdev: optimize ioctl handling
+- stmfbdev: don't instanciate screens, layers & surface pools anymore
+- stgfx/stgfx2: move instanciation of the above here, this gets us rid of more of DirectFB's startup warnings
+
+* Fri Jan 29 2010 Andr Draszik <andre.draszik@st.com> 1.4.3.STM2010.01.29-1
+- [Bugzilla: 7995] new system: 'stmfbdev' for many new features reg. screen control
+- stgfx2:
+  + some fixes for blit and fill if destination is YUV
+  + WA for https://bugzilla.stlinux.com/show_bug.cgi?id=7084
+  + update alignment restrictions for STi7108
+  + stgfx surface pools: prevent confusing startup message
+- stgfx:
+  + update alignment restrictions for STi7108
+  + stgfx surface pools: prevent confusing startup message
+- misc:
+  + dfbscreen: little fixes
+  + generic: LUT8 is not a YUV format
+  + screen: NTSC and PAL60 standards are defined as 59.94Hz not 60Hz
+  + IDirectFBScreen: add IDirectFBScreen::GetVSyncCount()
+  + directfb.h: add a DVO 656 'connector'
+  + dfblayer: allow to set layer position and size using command line
+  + dfbinspector: add DSPF_AVYU and DSPF_VYU pixelformats
+- [Delete patch: DirectFB-1.4.3.STM2009.12.11-CLUT8_fix.patch] integrated upstream
+
+* Fri Jan 29 2010 Andr Draszik <andre.draszik@st.com> 1.4.3.STM2009.12.11-4
+- [Add patch: DirectFB-1.4.3.STM2009.12.11-CLUT8_fix.patch] fix CLUT8 issue in
+  software renderer
+
+* Mon Jan 11 2010 Andr Draszik <andre.draszik@st.com> 1.4.3.STM2009.12.11-3
+- [Spec] unify multi app and single app spec files
+
+* Wed Dec 16 2009 Andr Draszik <andre.draszik@st.com> 1.4.3.STM2009.12.11-2
+- [Add patch: DirectFB-1.4.3.STM2009.12.11-autoconf259.patch] so as to enable
+  successful build on arm with old autotools in STLinux-2.3
+
+* Fri Dec 11 2009 Andr Draszik <andre.draszik@st.com> 1.4.3.STM2009.12.11-1
+- [update: 2009-12.11] update to DirectFB 1.4.3
+- misc: use pkgconfig to detect X11
+- misc: surface: replace GetFramebufferOffset() with GetPhysicalAddress()
+- stgfx2: pick up all updates from 1.0.1 branch
+- stgfx2: release surface pools on shutdown
+- [Bugzilla: 7776] stgfx2: cleanup draw/blitting wrt flags
+- stgfx: release surface pools on shutdown
+- [Bugzilla: 7570] jpeg: implement decimated decode for software JPEG decoder
+- [Bugzilla: 7636] jpeg: implement raw libjpeg decode for possible HW acceleration (using stgfx2)
+
+* Fri Aug 21 2009 Andr Draszik <andre.draszik@st.com> 1.4.1.STM2009.08.21-1
+- [update: 2009-08-21]
+  allow source widths and heights < 1.0 (but > 0) in BatchStretchBlit()
+
+* Tue Aug 18 2009 Andr Draszik <andre.draszik@st.com> 1.4.1.STM2009.08.18-1
+- [update: 2009-08-18]
+
+* Tue Jul 29 2009 Andr Draszik <andre.draszik@st.com> 1
+- [update: 1.4.1] new upstream version with all the STM patches
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/src/core/gfxcard.c DirectFB-1.4.12+STM2011.09.27/src/core/gfxcard.c
--- DirectFB/src/core/gfxcard.c	2015-06-02 22:40:08.159545138 +0200
+++ DirectFB-1.4.12+STM2011.09.27/src/core/gfxcard.c	2012-06-06 18:41:31.000000000 +0200
@@ -177,6 +177,12 @@
      if (!shared->device_info.limits.dst_max.h)
           shared->device_info.limits.dst_max.h = INT_MAX;
 
+     if (!shared->device_info.limits.src_max.w)
+          shared->device_info.limits.src_max.w = INT_MAX;
+
+     if (!shared->device_info.limits.src_max.h)
+          shared->device_info.limits.src_max.h = INT_MAX;
+
      /* Limit video ram length */
      videoram_length = dfb_system_videoram_length();
      if (videoram_length) {
@@ -1016,6 +1022,9 @@
                 * Now everything is prepared for execution of the
                 * FillRectangle driver function.
                 */
+               bool need_clip = (!D_FLAGS_IS_SET( card->caps.flags, CCF_CLIPPING )
+                                 && !D_FLAGS_IS_SET( card->caps.clip, DFXL_FILLRECTANGLE ));
+
                for (; i<num; i++) {
                     if (!(state->render_options & DSRO_MATRIX) &&
                         !dfb_rectangle_region_intersects( &rects[i], &state->clip ))
@@ -1023,15 +1032,14 @@
 
                     rect = rects[i];
 
-                    if (rect.w > card->limits.dst_max.w || rect.h > card->limits.dst_max.h) {
+                    if (need_clip
+                        || rect.w > card->limits.dst_max.w
+                        || rect.h > card->limits.dst_max.h)
                          dfb_clip_rectangle( &state->clip, &rect );
 
-                         if (rect.w > card->limits.dst_max.w || rect.h > card->limits.dst_max.h)
-                              break;
-                    }
-                    else if (!D_FLAGS_IS_SET( card->caps.flags, CCF_CLIPPING ) &&
-                             !D_FLAGS_IS_SET( card->caps.clip, DFXL_FILLRECTANGLE ))
-                         dfb_clip_rectangle( &state->clip, &rect );
+                    if (rect.w > card->limits.dst_max.w
+                        || rect.h > card->limits.dst_max.h)
+                         break;
 
                     if (!card->funcs.FillRectangle( card->driver_data,
                                                     card->device_data, &rect ))
@@ -1332,10 +1340,11 @@
      if (dfb_gfxcard_state_check( state, DFXL_DRAWLINE ) &&
          dfb_gfxcard_state_acquire( state, DFXL_DRAWLINE ))
      {
+          bool need_clip = (!D_FLAGS_IS_SET( card->caps.flags, CCF_CLIPPING )
+                            && !D_FLAGS_IS_SET( card->caps.clip, DFXL_DRAWLINE ));
+
           for (; i<num_lines; i++) {
-               if (!D_FLAGS_IS_SET( card->caps.flags, CCF_CLIPPING ) &&
-                   !D_FLAGS_IS_SET( card->caps.clip, DFXL_DRAWLINE ) &&
-                   !dfb_clip_line( &state->clip, &lines[i] ))
+               if (need_clip && !dfb_clip_line( &state->clip, &lines[i] ))
                     continue;
 
                if (!card->funcs.DrawLine( card->driver_data,
@@ -1386,20 +1395,20 @@
      if (dfb_gfxcard_state_check( state, DFXL_FILLRECTANGLE ) &&
          dfb_gfxcard_state_acquire( state, DFXL_FILLRECTANGLE ))
      {
+          bool need_clip = (!D_FLAGS_IS_SET( card->caps.flags, CCF_CLIPPING )
+                            && !D_FLAGS_IS_SET( card->caps.clip, DFXL_FILLRECTANGLE ));
+
           for (; i<num_spans; i++) {
                DFBRectangle rect = { spans[i].x, y + i, spans[i].w, 1 };
 
-               if (rect.w > card->limits.dst_max.w || rect.h > card->limits.dst_max.h) {
-                    if (!dfb_clip_rectangle( &state->clip, &rect ))
-                         continue;
+               if ((need_clip
+                    || rect.w > card->limits.dst_max.w
+                    || rect.h > card->limits.dst_max.h)
+                   && !dfb_clip_rectangle( &state->clip, &rect ))
+                    continue;
 
-                    if (rect.w > card->limits.dst_max.w || rect.h > card->limits.dst_max.h)
-                         break;
-               }
-               else if (!D_FLAGS_IS_SET( card->caps.flags, CCF_CLIPPING ) &&
-                        !D_FLAGS_IS_SET( card->caps.clip, DFXL_FILLRECTANGLE ) &&
-                        !dfb_clip_rectangle( &state->clip, &rect ))
-                         continue;
+               if (rect.w > card->limits.dst_max.w || rect.h > card->limits.dst_max.h)
+                    break;
 
                if (!card->funcs.FillRectangle( card->driver_data,
                                                card->device_data, &rect ))
@@ -1941,8 +1950,12 @@
           srect->w  = drect->h;
           srect->h  = drect->w;
 
-          D_DEBUG_AT( Core_GraphicsOps, "  => %4d,%4d-%4dx%4d -> %4d,%4d-%4dx%4d (90)\n",
-                      DFB_RECTANGLE_VALS(srect), DFB_RECTANGLE_VALS(drect) );
+          if (!(flags & DSBLIT_FIXEDPOINT))
+               D_DEBUG_AT( Core_GraphicsOps, "  => %4d,%4d-%4dx%4d -> %4d,%4d-%4dx%4d (90)\n",
+                           DFB_RECTANGLE_VALS(srect), DFB_RECTANGLE_VALS(drect) );
+          else
+               D_DEBUG_AT( Core_GraphicsOps, "  => %4d.%06d,%4d.%06d-%4d.%06dx%4d.%06d -> %4d.%06d,%4d.%06d-%4d.%06dx%4d.%06d (90)\n",
+                           DFB_RECTANGLE_VALSf(srect), DFB_RECTANGLE_VALSf(drect) );
      }
      else if (flags & DSBLIT_ROTATE180) {
           srect->x += dest.x2 - clipped.x2;
@@ -1950,8 +1963,12 @@
           srect->w  = drect->w;
           srect->h  = drect->h;
 
-          D_DEBUG_AT( Core_GraphicsOps, "  => %4d,%4d-%4dx%4d -> %4d,%4d-%4dx%4d (180)\n",
-                      DFB_RECTANGLE_VALS(srect), DFB_RECTANGLE_VALS(drect) );
+          if (!(flags & DSBLIT_FIXEDPOINT))
+               D_DEBUG_AT( Core_GraphicsOps, "  => %4d,%4d-%4dx%4d -> %4d,%4d-%4dx%4d (180)\n",
+                           DFB_RECTANGLE_VALS(srect), DFB_RECTANGLE_VALS(drect) );
+          else
+               D_DEBUG_AT( Core_GraphicsOps, "  => %4d.%06d,%4d.%06d-%4d.%06dx%4d.%06d -> %4d.%06d,%4d.%06d-%4d.%06dx%4d.%06d (180)\n",
+                           DFB_RECTANGLE_VALSf(srect), DFB_RECTANGLE_VALSf(drect) );
      }
      else if (flags & DSBLIT_ROTATE270) {
           srect->x += clipped.y1 - dest.y1;
@@ -1959,8 +1976,12 @@
           srect->w  = drect->h;
           srect->h  = drect->w;
 
-          D_DEBUG_AT( Core_GraphicsOps, "  => %4d,%4d-%4dx%4d -> %4d,%4d-%4dx%4d (270)\n",
-                      DFB_RECTANGLE_VALS(srect), DFB_RECTANGLE_VALS(drect) );
+          if (!(flags & DSBLIT_FIXEDPOINT))
+               D_DEBUG_AT( Core_GraphicsOps, "  => %4d,%4d-%4dx%4d -> %4d,%4d-%4dx%4d (270)\n",
+                           DFB_RECTANGLE_VALS(srect), DFB_RECTANGLE_VALS(drect) );
+          else
+               D_DEBUG_AT( Core_GraphicsOps, "  => %4d.%06d,%4d.%06d-%4d.%06dx%4d.%06d -> %4d.%06d,%4d.%06d-%4d.%06dx%4d.%06d (270)\n",
+                           DFB_RECTANGLE_VALSf(srect), DFB_RECTANGLE_VALSf(drect) );
      }
      else if (flags & (DSBLIT_FLIP_HORIZONTAL | DSBLIT_FLIP_VERTICAL)) {
           // FIXME: rotation and FLIP_ should be supported together, it is not the case in the software driver,
@@ -1988,8 +2009,12 @@
           srect->w  = drect->w;
           srect->h  = drect->h;
 
-          D_DEBUG_AT( Core_GraphicsOps, "  => %4d,%4d-%4dx%4d -> %4d,%4d-%4dx%4d\n",
-                      DFB_RECTANGLE_VALS(srect), DFB_RECTANGLE_VALS(drect) );
+          if (!(flags & DSBLIT_FIXEDPOINT))
+               D_DEBUG_AT( Core_GraphicsOps, "  => %4d,%4d-%4dx%4d -> %4d,%4d-%4dx%4d\n",
+                           DFB_RECTANGLE_VALS(srect), DFB_RECTANGLE_VALS(drect) );
+          else
+               D_DEBUG_AT( Core_GraphicsOps, "  => %4d.%06d,%4d.%06d-%4d.%06dx%4d.%06d -> %4d.%06d,%4d.%06d-%4d.%06dx%4d.%06d\n",
+                           DFB_RECTANGLE_VALSf(srect), DFB_RECTANGLE_VALSf(drect) );
      }
 }
 
@@ -1997,12 +2022,19 @@
 {
      bool         hw    = false;
      DFBRectangle drect = { dx, dy, rect->w, rect->h };
+     DFBRegion    scaled_clip;
+
+     bool fixed_point = !!(state->blittingflags & DSBLIT_FIXEDPOINT);
 
      if (state->blittingflags & (DSBLIT_ROTATE90 | DSBLIT_ROTATE270))
           D_UTIL_SWAP( drect.w, drect.h );
 
-     D_DEBUG_AT( Core_GraphicsOps, "%s( %4d,%4d-%4dx%4d -> %4d,%4d-%4dx%4d, %p )\n",
-                 __FUNCTION__, DFB_RECTANGLE_VALS(rect), DFB_RECTANGLE_VALS(&drect), state );
+     if (!fixed_point)
+          D_DEBUG_AT( Core_GraphicsOps, "%s( %4d,%4d-%4dx%4d -> %4d,%4d-%4dx%4d, %p )\n",
+                      __FUNCTION__, DFB_RECTANGLE_VALS(rect), DFB_RECTANGLE_VALS(&drect), state );
+     else
+          D_DEBUG_AT( Core_GraphicsOps, "%s( %4d.%06d,%4d.%06d-%4d.%06dx%4d.%06d -> %4d.%06d,%4d.%06d-%4d.%06dx%4d.%06d, %p )\n",
+                      __FUNCTION__, DFB_RECTANGLE_VALSf(rect), DFB_RECTANGLE_VALSf(&drect), state );
 
      D_ASSERT( card != NULL );
      D_ASSERT( card->shared != NULL );
@@ -2011,19 +2043,32 @@
      D_ASSERT( rect != NULL );
      D_ASSERT( rect->x >= 0 );
      D_ASSERT( rect->y >= 0 );
-     D_ASSERT( rect->x < state->source->config.size.w );
-     D_ASSERT( rect->y < state->source->config.size.h );
-     D_ASSERT( rect->x + rect->w - 1 < state->source->config.size.w );
-     D_ASSERT( rect->y + rect->h - 1 < state->source->config.size.h );
+     if (fixed_point) {
+          D_ASSERT( rect->x < DFB_FIXED_POINT_VAL( state->source->config.size.w ) );
+          D_ASSERT( rect->y < DFB_FIXED_POINT_VAL( state->source->config.size.h ) );
+          D_ASSERT( rect->x + rect->w - DFB_FIXED_POINT_VAL( 1 ) < DFB_FIXED_POINT_VAL( state->source->config.size.w ) );
+          D_ASSERT( rect->y + rect->h - DFB_FIXED_POINT_VAL( 1 ) < DFB_FIXED_POINT_VAL( state->source->config.size.h ) );
+     }
+     else {
+          D_ASSERT( rect->x < state->source->config.size.w );
+          D_ASSERT( rect->y < state->source->config.size.h );
+          D_ASSERT( rect->x + rect->w - 1 < state->source->config.size.w );
+          D_ASSERT( rect->y + rect->h - 1 < state->source->config.size.h );
+     }
 
      /* The state is locked during graphics operations. */
      dfb_state_lock( state );
 
+     scaled_clip = state->clip;
+     if (fixed_point)
+          dfb_region_upscale( &scaled_clip );
+
      /* Signal beginning of sequence of operations if not already done. */
      dfb_state_start_drawing( state, card );
 
      if (!(state->render_options & DSRO_MATRIX) &&
-         !dfb_clip_blit_precheck( &state->clip, drect.w, drect.h, drect.x, drect.y ))
+         !dfb_clip_blit_precheck_f( &scaled_clip, drect.w, drect.h, drect.x, drect.y,
+                                    fixed_point ) )
      {
           /* no work at all */
           dfb_state_unlock( state );
@@ -2033,17 +2078,36 @@
      if (dfb_gfxcard_state_check( state, DFXL_BLIT ) &&
          dfb_gfxcard_state_acquire( state, DFXL_BLIT ))
      {
-          if (!D_FLAGS_IS_SET( card->caps.flags, CCF_CLIPPING ) &&
-              !D_FLAGS_IS_SET( card->caps.clip, DFXL_BLIT ))
-               clip_blit_rotated( rect, &drect, &state->clip, state->blittingflags );
+          DFBDimension dst_max = card->limits.dst_max;
+          DFBDimension src_max = card->limits.src_max;
 
-          hw = card->funcs.Blit( card->driver_data, card->device_data, rect, drect.x, drect.y );
+          if (fixed_point) {
+               dfb_dimension_upscale( &dst_max );
+               dfb_dimension_upscale( &src_max );
+          }
+
+          if ((!D_FLAGS_IS_SET( card->caps.flags, CCF_CLIPPING ) &&
+               !D_FLAGS_IS_SET( card->caps.clip, DFXL_BLIT ))
+              || rect->w > dst_max.w || rect->h > dst_max.h
+              || rect->w > src_max.w || rect->h > src_max.h)
+               clip_blit_rotated( rect, &drect, &scaled_clip, state->blittingflags );
+
+          if (rect->w <= dst_max.w && rect->h <= dst_max.h
+              && rect->w <= src_max.w && rect->h <= src_max.h)
+               hw = card->funcs.Blit( card->driver_data, card->device_data, rect, drect.x, drect.y );
 
           dfb_gfxcard_state_release( state );
      }
 
      if (!hw) {
           /* Use software fallback. */
+
+          /* no fixed point support in software rasterizer yet */
+          if (fixed_point) {
+               dfb_rectangle_downscale( rect );
+               dfb_rectangle_downscale( &drect );
+          }
+
           if (!(state->render_options & DSRO_MATRIX)) {
                if (gAcquire( state, DFXL_BLIT )) {
                     clip_blit_rotated( rect, &drect, &state->clip, state->blittingflags );
@@ -2120,19 +2184,42 @@
      if (dfb_gfxcard_state_check( state, DFXL_BLIT ) &&
          dfb_gfxcard_state_acquire( state, DFXL_BLIT ))
      {
+          DFBRegion scaled_clip = state->clip;
+          bool fixed_point = !!(state->blittingflags & DSBLIT_FIXEDPOINT);
+          bool need_clip = (!D_FLAGS_IS_SET( card->caps.flags, CCF_CLIPPING )
+                            && !D_FLAGS_IS_SET( card->caps.clip, DFXL_BLIT ));
+
+          DFBDimension dst_max = card->limits.dst_max;
+          DFBDimension src_max = card->limits.src_max;
+
+          if (fixed_point) {
+               dfb_region_upscale( &scaled_clip );
+               dfb_dimension_upscale( &dst_max );
+               dfb_dimension_upscale( &src_max );
+          }
+
           for (; i<num; i++) {
+               DFBRectangle * __restrict rect = &rects[i];
+
                if ((state->render_options & DSRO_MATRIX) ||
-                   dfb_clip_blit_precheck( &state->clip,
-                                           rects[i].w, rects[i].h,
-                                           points[i].x, points[i].y ))
+                   dfb_clip_blit_precheck_f( &scaled_clip,
+                                             rect->w, rect->h,
+                                             points[i].x, points[i].y,
+                                             fixed_point ))
                {
-                    if (!D_FLAGS_IS_SET( card->caps.flags, CCF_CLIPPING ) &&
-                        !D_FLAGS_IS_SET( card->caps.clip, DFXL_BLIT ))
-                         dfb_clip_blit( &state->clip, &rects[i],
-                                        &points[i].x, &points[i].y );
+                    if (need_clip
+                        || rect->w > dst_max.w || rect->h > dst_max.h
+                        || rect->w > src_max.w || rect->h > src_max.h)
+                         dfb_clip_blit_f( &scaled_clip, rect,
+                                          &points[i].x, &points[i].y,
+                                          fixed_point );
+
+                    if (rect->w > dst_max.w || rect->h > dst_max.h
+                        || rect->w > src_max.w || rect->h > src_max.h)
+                         break;
 
                     if (!card->funcs.Blit( card->driver_data, card->device_data,
-                                           &rects[i], points[i].x, points[i].y ))
+                                           rect, points[i].x, points[i].y ))
                          break;
                }
           }
@@ -2155,6 +2242,13 @@
                          DFBRectangle drect;
                          int          x1, y1, x2, y2;
 
+                         /* no fixed point support in software rasterizer yet */
+                         if (state->blittingflags & DSBLIT_FIXEDPOINT) {
+                              dfb_rectangle_downscale( &rects[i] );
+                              points[i].x /= DFB_FIXED_POINT_ONE;
+                              points[i].y /= DFB_FIXED_POINT_ONE;
+                         }
+
                          x1 = points[i].x;   y1 = points[i].y;
                          x2 = x1+rects[i].w; y2 = y1+rects[i].h;
                          DFB_TRANSFORM(x1, y1, state->matrix, state->affine_matrix);
@@ -2172,6 +2266,13 @@
           else {
                if (gAcquire( state, DFXL_BLIT )) {
                     for (; i<num; i++) {
+                         /* no fixed point support in software rasterizer yet */
+                         if (state->blittingflags & DSBLIT_FIXEDPOINT) {
+                              dfb_rectangle_downscale( &rects[i] );
+                              points[i].x /= DFB_FIXED_POINT_ONE;
+                              points[i].y /= DFB_FIXED_POINT_ONE;
+                         }
+
                          if (dfb_clip_blit_precheck( &state->clip,
                                                      rects[i].w, rects[i].h,
                                                      points[i].x, points[i].y ))
@@ -2206,6 +2307,8 @@
      D_ASSERT( points2 != NULL );
      D_ASSERT( num > 0 );
 
+     D_ASSERT( !(state->blittingflags & DSBLIT_FIXEDPOINT) );
+
      /* The state is locked during graphics operations. */
      dfb_state_lock( state );
 
@@ -2277,19 +2380,34 @@
      int           x, y;
      int           odx;
      DFBRectangle  srect;
-     DFBRegion    *clip;
-
-     D_DEBUG_AT( Core_GraphicsOps, "%s( %d,%d - %d,%d, %p )\n", __FUNCTION__, dx1, dy1, dx2, dy2, state );
+     DFBRegion     clip;
 
      D_ASSERT( card != NULL );
      D_ASSERT( card->shared != NULL );
      D_MAGIC_ASSERT( state, CardState );
      D_ASSERT( rect != NULL );
 
-     /* If called with an invalid rectangle, the algorithm goes into an
-        infinite loop. This should never happen but it's safer to check. */
-     D_ASSERT( rect->w >= 1 );
-     D_ASSERT( rect->h >= 1 );
+     if (!(state->blittingflags & DSBLIT_FIXEDPOINT)) {
+          D_DEBUG_AT( Core_GraphicsOps, "%s( %d,%d - %d,%d, %p )\n",
+                      __FUNCTION__, dx1, dy1, dx2, dy2, state );
+
+          /* If called with an invalid rectangle, the algorithm goes into an
+             infinite loop. This should never happen but it's safer to
+             check. */
+          D_ASSERT( rect->w >= 1 );
+          D_ASSERT( rect->h >= 1 );
+     }
+     else {
+          D_DEBUG_AT( Core_GraphicsOps, "%s( %d.%06d,%d.%06d - %d.%06d,%d.%06d, %p )\n",
+                      __FUNCTION__, DFB_INT_VALf( dx1 ), DFB_INT_VALf( dy1 ),
+                      DFB_INT_VALf( dx2 ), DFB_INT_VALf( dy2 ), state );
+
+          /* If called with an invalid rectangle, the algorithm goes into an
+             infinite loop. This should never happen but it's safer to
+             check. */
+          D_ASSERT( rect->w >= DFB_FIXED_POINT_VAL( 1 ) );
+          D_ASSERT( rect->h >= DFB_FIXED_POINT_VAL( 1 ) );
+     }
 
      /* The state is locked during graphics operations. */
      dfb_state_lock( state );
@@ -2297,36 +2415,43 @@
      /* Signal beginning of sequence of operations if not already done. */
      dfb_state_start_drawing( state, card );
 
-     clip = &state->clip;
+     clip = state->clip;
+     if (state->blittingflags & DSBLIT_FIXEDPOINT)
+          dfb_region_upscale( &clip );
 
      /* Check if anything is drawn at all. */
-     if (!(state->render_options & DSRO_MATRIX) &&
-         !dfb_clip_blit_precheck( clip, dx2-dx1+1, dy2-dy1+1, dx1, dy1 )) {
-          dfb_state_unlock( state );
-          return;
+     if (!(state->render_options & DSRO_MATRIX)) {
+          int offs = ((state->blittingflags & DSBLIT_FIXEDPOINT)
+                      ? DFB_FIXED_POINT_ONE : 1);
+
+          if (!dfb_clip_blit_precheck_f( &clip, dx2-dx1+offs, dy2-dy1+offs, dx1, dy1,
+                                         !!(state->blittingflags & DSBLIT_FIXEDPOINT) )) {
+               dfb_state_unlock( state );
+               return;
+          }
      }
 
      /* Remove clipped tiles. */
-     if (dx1 < clip->x1) {
-          int outer = clip->x1 - dx1;
+     if (dx1 < clip.x1) {
+          int outer = clip.x1 - dx1;
 
           dx1 += outer - (outer % rect->w);
      }
 
-     if (dy1 < clip->y1) {
-          int outer = clip->y1 - dy1;
+     if (dy1 < clip.y1) {
+          int outer = clip.y1 - dy1;
 
           dy1 += outer - (outer % rect->h);
      }
 
-     if (dx2 > clip->x2) {
-          int outer = clip->x2 - dx2;
+     if (dx2 > clip.x2) {
+          int outer = clip.x2 - dx2;
 
           dx2 -= outer - (outer % rect->w);
      }
 
-     if (dy2 > clip->y2) {
-          int outer = clip->y2 - dy2;
+     if (dy2 > clip.y2) {
+          int outer = clip.y2 - dy2;
 
           dy2 -= outer - (outer % rect->h);
      }
@@ -2336,11 +2461,12 @@
      if (dfb_gfxcard_state_check( state, DFXL_BLIT ) &&
          dfb_gfxcard_state_acquire( state, DFXL_BLIT )) {
           bool hw = true;
+          bool fixed_point = !!(state->blittingflags & DSBLIT_FIXEDPOINT);
 
           for (; dy1 < dy2; dy1 += rect->h) {
                for (; dx1 < dx2; dx1 += rect->w) {
-
-                    if (!dfb_clip_blit_precheck( clip, rect->w, rect->h, dx1, dy1 ))
+                    if (!dfb_clip_blit_precheck_f( &clip, rect->w, rect->h, dx1, dy1,
+                                                   fixed_point ))
                          continue;
 
                     x = dx1;
@@ -2349,7 +2475,7 @@
 
                     if (!D_FLAGS_IS_SET( card->caps.flags, CCF_CLIPPING ) &&
                         !D_FLAGS_IS_SET( card->caps.clip, DFXL_BLIT ))
-                         dfb_clip_blit( clip, &srect, &x, &y );
+                         dfb_clip_blit_f( &clip, &srect, &x, &y, fixed_point );
 
                     hw = card->funcs.Blit( card->driver_data,
                                            card->device_data, &srect, x, y );
@@ -2365,6 +2491,14 @@
      }
 
      if (dy1 < dy2) {
+          if (state->blittingflags & DSBLIT_FIXEDPOINT) {
+               dfb_rectangle_downscale( rect );
+               dx1 /= DFB_FIXED_POINT_ONE;
+               dy1 /= DFB_FIXED_POINT_ONE;
+               dx2 /= DFB_FIXED_POINT_ONE;
+               dy2 /= DFB_FIXED_POINT_ONE;
+          }
+
           if (state->render_options & DSRO_MATRIX) {
                if (state->matrix[0] < 0  || state->matrix[1] != 0 ||
                    state->matrix[3] != 0 || state->matrix[4] < 0  ||
@@ -2401,14 +2535,14 @@
                     for (; dy1 < dy2; dy1 += rect->h) {
                          for (; dx1 < dx2; dx1 += rect->w) {
 
-                              if (!dfb_clip_blit_precheck( clip, rect->w, rect->h, dx1, dy1 ))
+                              if (!dfb_clip_blit_precheck( &state->clip, rect->w, rect->h, dx1, dy1 ))
                                    continue;
 
                               x = dx1;
                               y = dy1;
                               srect = *rect;
 
-                              dfb_clip_blit( clip, &srect, &x, &y );
+                              dfb_clip_blit( &state->clip, &srect, &x, &y );
 
                               gBlit( state, &srect, x, y );
                          }
@@ -2423,32 +2557,22 @@
      dfb_state_unlock( state );
 }
 
-void dfb_gfxcard_stretchblit( DFBRectangle *srect, DFBRectangle *drect,
-                              CardState *state )
+void dfb_gfxcard_batchstretchblit( DFBRectangle *srects,
+                                   DFBRectangle *drects,
+                                   int num, CardState *state )
 {
-     bool hw = false;
+     int i = 0;
+     bool fixed_point;
+
+     D_DEBUG_AT( Core_GraphicsOps, "%s( %p, %p [%d], %p )\n", __FUNCTION__,
+                 srects, drects, num, state );
 
      D_ASSERT( card != NULL );
      D_ASSERT( card->shared != NULL );
      D_MAGIC_ASSERT( state, CardState );
-     D_ASSERT( srect != NULL );
-     D_ASSERT( drect != NULL );
-
-     D_DEBUG_AT( Core_GraphicsOps, "%s( %d,%d - %dx%d -> %d,%d - %dx%d, %p )\n",
-                 __FUNCTION__, DFB_RECTANGLE_VALS(srect), DFB_RECTANGLE_VALS(drect), state );
-
-     if (state->blittingflags & (DSBLIT_ROTATE90 | DSBLIT_ROTATE270)) {
-          if (srect->w == drect->h && srect->h == drect->w) {
-               dfb_gfxcard_blit( srect, drect->x, drect->y, state );
-               return;
-          }
-     }
-     else {
-          if (srect->w == drect->w && srect->h == drect->h) {
-               dfb_gfxcard_blit( srect, drect->x, drect->y, state );
-               return;
-          }
-     }
+     D_ASSERT( srects != NULL );
+     D_ASSERT( drects != NULL );
+     D_ASSERT( num > 0 );
 
      /* The state is locked during graphics operations. */
      dfb_state_lock( state );
@@ -2456,55 +2580,106 @@
      /* Signal beginning of sequence of operations if not already done. */
      dfb_state_start_drawing( state, card );
 
-     if (!(state->render_options & DSRO_MATRIX) &&
-         !dfb_clip_blit_precheck( &state->clip, drect->w, drect->h,
-                                  drect->x, drect->y ))
-     {
-          dfb_state_unlock( state );
-          return;
-     }
+     fixed_point = !!(state->blittingflags & DSBLIT_FIXEDPOINT);
 
      if (dfb_gfxcard_state_check( state, DFXL_STRETCHBLIT ) &&
          dfb_gfxcard_state_acquire( state, DFXL_STRETCHBLIT ))
      {
-          if (!D_FLAGS_IS_SET( card->caps.flags, CCF_CLIPPING ) &&
-              !D_FLAGS_IS_SET( card->caps.clip, DFXL_STRETCHBLIT ))
-               dfb_clip_stretchblit( &state->clip, srect, drect );
+          DFBRegion scaled_clip = state->clip;
+          bool need_clip = (!D_FLAGS_IS_SET( card->caps.flags, CCF_CLIPPING )
+                            && !D_FLAGS_IS_SET( card->caps.clip, DFXL_STRETCHBLIT ));
+
+          DFBDimension dst_max = card->limits.dst_max;
+          DFBDimension src_max = card->limits.src_max;
+
+          if (fixed_point) {
+               dfb_region_upscale( &scaled_clip );
+               dfb_dimension_upscale( &dst_max );
+               dfb_dimension_upscale( &src_max );
+          }
+
+          for (; i<num; i++) {
+               DFBRectangle * __restrict srect = &srects[i];
+               DFBRectangle * __restrict drect = &drects[i];
 
-          hw = card->funcs.StretchBlit( card->driver_data, card->device_data, srect, drect );
+               if (!fixed_point)
+                    D_DEBUG_AT( Core_GraphicsOps,
+                                "  -> %d,%d - %dx%d -> %d,%d - %dx%d\n",
+                                DFB_RECTANGLE_VALS(srect),
+                                DFB_RECTANGLE_VALS(drect) );
+               else
+                    D_DEBUG_AT( Core_GraphicsOps,
+                                "  -> %d.%06d,%d.%06d - %d.%06dx%d.%06d -> %d.%06d,%d.%06d - %d.%06dx%d.%06d\n",
+                                DFB_RECTANGLE_VALSf(srect),
+                                DFB_RECTANGLE_VALSf(drect) );
+
+               if ((state->blittingflags & (DSBLIT_ROTATE90 | DSBLIT_ROTATE270)
+                    && (srect->w == drect->h && srect->h == drect->w))
+                   || (srect->w == drect->w && srect->h == drect->h)) {
+                    dfb_gfxcard_state_release( state );
+                    dfb_gfxcard_blit( srect, drect->x, drect->y, state );
+                    if (!dfb_gfxcard_state_check( state, DFXL_STRETCHBLIT )
+                        || !dfb_gfxcard_state_acquire( state, DFXL_STRETCHBLIT ))
+                         break;
+               }
+               else if ((state->render_options & DSRO_MATRIX)
+                        || dfb_clip_blit_precheck_f( &scaled_clip, drect->w, drect->h,
+                                                     drect->x, drect->y,
+                                                     fixed_point )) {
+                    if (need_clip
+                        || drect->w > dst_max.w || drect->h > dst_max.h
+                        || srect->w > src_max.w || srect->h > src_max.h)
+                         dfb_clip_stretchblit_f( &scaled_clip, srect, drect, fixed_point );
+
+                    if (drect->w > dst_max.w || drect->h > dst_max.h
+                        || srect->w > src_max.w || srect->h > src_max.h
+                        || !card->funcs.StretchBlit( card->driver_data,
+                                                     card->device_data,
+                                                     srect, drect ))
+                         break;
+               }
+          }
 
           dfb_gfxcard_state_release( state );
      }
 
-     if (!hw) {
-          if (state->render_options & DSRO_MATRIX) {
-               int x1, y1, x2, y2;
+     if (i < num) {
+          if (gAcquire( state, DFXL_STRETCHBLIT )) {
+               for (; i<num; i++) {
+                    DFBRectangle * __restrict srect = &srects[i];
+                    DFBRectangle * __restrict drect = &drects[i];
 
-               if (state->matrix[0] < 0  || state->matrix[1] != 0 ||
-                   state->matrix[3] != 0 || state->matrix[4] < 0  ||
-                   state->matrix[6] != 0 || state->matrix[7] != 0) {
-                    D_WARN( "rotation not yet implemented" );
-                    dfb_state_unlock( state );
-                    return;
-               }
+                    /* no fixed point support in software rasterizer yet */
+                    if (fixed_point) {
+                         dfb_rectangle_downscale( srect );
+                         dfb_rectangle_downscale( drect );
+                    }
 
-               x1 = drect->x;    y1 = drect->y;
-               x2 = x1+drect->w; y2 = y1+drect->h;
-               DFB_TRANSFORM(x1, y1, state->matrix, state->affine_matrix);
-               DFB_TRANSFORM(x2, y2, state->matrix, state->affine_matrix);
-               drect->x = x1;    drect->y = y1;
-               drect->w = x2-x1; drect->h = y2-y1;
+                    if (state->render_options & DSRO_MATRIX) {
+                         int x1, y1, x2, y2;
 
-               if (!dfb_clip_blit_precheck( &state->clip,
-                                            drect->w, drect->h, drect->x, drect->y )) {
-                    dfb_state_unlock( state );
-                    return;
+                         if (state->matrix[0] < 0  || state->matrix[1] != 0 ||
+                             state->matrix[3] != 0 || state->matrix[4] < 0  ||
+                             state->matrix[6] != 0 || state->matrix[7] != 0) {
+                              D_WARN( "rotation not yet implemented" );
+                              continue;
+                         }
+
+                         x1 = drect->x;    y1 = drect->y;
+                         x2 = x1+drect->w; y2 = y1+drect->h;
+                         DFB_TRANSFORM(x1, y1, state->matrix, state->affine_matrix);
+                         DFB_TRANSFORM(x2, y2, state->matrix, state->affine_matrix);
+                         drect->x = x1;    drect->y = y1;
+                         drect->w = x2-x1; drect->h = y2-y1;
+
+                         if (!dfb_clip_blit_precheck( &state->clip,
+                                                      drect->w, drect->h, drect->x, drect->y ))
+                              continue;
+                    }
+
+                    gStretchBlit( state, srect, drect );
                }
-          }
 
-          if (gAcquire( state, DFXL_STRETCHBLIT )) {
-               /* Clipping is performed in the following function. */
-               gStretchBlit( state, srect, drect );
                gRelease( state );
           }
      }
@@ -2512,6 +2687,14 @@
      dfb_state_unlock( state );
 }
 
+void dfb_gfxcard_stretchblit( DFBRectangle *srect, DFBRectangle *drect,
+                              CardState *state )
+{
+     D_ONCE ("dfb_gfxcard_batchstretchblit() should be used!");
+
+     dfb_gfxcard_batchstretchblit( srect, drect, 1, state);
+}
+
 void dfb_gfxcard_texture_triangles( DFBVertex *vertices, int num,
                                     DFBTriangleFormation formation,
                                     CardState *state )
@@ -2601,6 +2784,8 @@
                dfb_state_set_dst_blend( state, DSBF_INVSRCALPHA );
           }
 
+          flags |= (state->blittingflags & DSBLIT_FIXEDPOINT);
+
           dfb_state_set_blitting_flags( state, flags );
      }
      else {
@@ -2640,12 +2825,30 @@
      int           ox = x;
      int           oy = y;
 
-     if (encoding == DTEID_UTF8)
-          D_DEBUG_AT( Core_GraphicsOps, "%s( '%s' [%d], %d,%d, %p, %p )\n",
-                      __FUNCTION__, text, bytes, x, y, font, state );
-     else
-          D_DEBUG_AT( Core_GraphicsOps, "%s( %p [%d], %d, %d,%d, %p, %p )\n",
-                      __FUNCTION__, text, bytes, encoding, x, y, font, state );
+     bool          fixed_point;
+     DFBRegion     scaled_clip;
+     int           scaled_fontheight;
+
+     fixed_point = !!(state->blittingflags & DSBLIT_FIXEDPOINT);
+
+     if (encoding == DTEID_UTF8) {
+          if (fixed_point)
+               D_DEBUG_AT( Core_GraphicsOps, "%s( '%s' [%d], %d.%06d,%d.%06d, %p, %p )\n",
+                           __FUNCTION__, text, bytes, DFB_INT_VALf( x ),
+                           DFB_INT_VALf( y ), font, state );
+          else
+               D_DEBUG_AT( Core_GraphicsOps, "%s( '%s' [%d], %d,%d, %p, %p )\n",
+                           __FUNCTION__, text, bytes, x, y, font, state );
+     }
+     else {
+          if (fixed_point)
+               D_DEBUG_AT( Core_GraphicsOps, "%s( %p [%d], %d, %d.%06d,%d.%06d, %p, %p )\n",
+                           __FUNCTION__, text, bytes, encoding, DFB_INT_VALf( x ),
+                           DFB_INT_VALf( y ), font, state );
+          else
+               D_DEBUG_AT( Core_GraphicsOps, "%s( %p [%d], %d, %d,%d, %p, %p )\n",
+                           __FUNCTION__, text, bytes, encoding, x, y, font, state );
+     }
 
      D_ASSERT( card != NULL );
      D_ASSERT( card->shared != NULL );
@@ -2657,10 +2860,17 @@
      surface = state->destination;
      D_MAGIC_ASSERT( surface, CoreSurface );
 
+     scaled_clip = state->clip;
+     scaled_fontheight = font->height;
+     if (fixed_point) {
+          dfb_region_upscale( &scaled_clip );
+          scaled_fontheight *= DFB_FIXED_POINT_ONE;
+     }
+
      /* simple prechecks */
      if (!(state->render_options & DSRO_MATRIX) &&
-         (x > state->clip.x2 || y > state->clip.y2 + font->ascender ||
-          y - font->descender <= state->clip.y1)) {
+         (x > scaled_clip.x2 || y > scaled_clip.y2 ||
+          y + scaled_fontheight <= scaled_clip.y1)) {
           return;
      }
 
@@ -2694,8 +2904,14 @@
                }
 
                if (prev && font->GetKerning && font->GetKerning( font, prev, current, &kern_x, &kern_y) == DFB_OK) {
-                    x += kern_x;
-                    y += kern_y;
+                    if (!fixed_point) {
+                         x += kern_x;
+                         y += kern_y;
+                    }
+                    else {
+                         x += DFB_FIXED_POINT_VAL( kern_x );
+                         y += DFB_FIXED_POINT_VAL( kern_y );
+                    }
                }
 
                if (glyph->width) {
@@ -2709,14 +2925,20 @@
                               dfb_state_set_source( state, glyph->surface );
                     }
 
-                    points[num_blits] = (DFBPoint){ x + glyph->left, y + glyph->top };
-                    rects[num_blits]  = (DFBRectangle){ glyph->start, 0, glyph->width, glyph->height };
+                    if (!fixed_point) {
+                         points[num_blits] = (DFBPoint){ x + glyph->left, y + glyph->top };
+                         rects[num_blits]  = (DFBRectangle){ glyph->start, 0, glyph->width, glyph->height };
+                    }
+                    else {
+                         points[num_blits] = (DFBPoint){ x + DFB_FIXED_POINT_VAL( glyph->left ), y + DFB_FIXED_POINT_VAL( glyph->top ) };
+                         rects[num_blits]  = (DFBRectangle){ DFB_FIXED_POINT_VAL( glyph->start ), 0, DFB_FIXED_POINT_VAL( glyph->width ), DFB_FIXED_POINT_VAL( glyph->height ) };
+                    }
 
                     num_blits++;
                }
 
-               x   += glyph->xadvance;
-               y   += glyph->yadvance;
+               x   += (!fixed_point ? glyph->xadvance : DFB_FIXED_POINT_VAL( glyph->xadvance ));
+               y   += (!fixed_point ? glyph->yadvance : DFB_FIXED_POINT_VAL( glyph->yadvance ));
                prev = current;
           }
 
@@ -2738,8 +2960,11 @@
      CoreSurface *surface;
      CardState    state_backup;
 
-     D_DEBUG_AT( Core_GraphicsOps, "%s( %d,%d, %u, %p, %p )\n",
-                 __FUNCTION__, x, y, layers, font, state );
+     bool         fixed_point;
+
+     D_DEBUG_AT( Core_GraphicsOps, "%s( %d.%06d,%d.%06d, %u, %p, %p )\n",
+                 __FUNCTION__, DFB_INT_VALf( x ), DFB_INT_VALf( y ),
+                 layers, font, state );
 
      D_ASSERT( card != NULL );
      D_ASSERT( card->shared != NULL );
@@ -2749,6 +2974,8 @@
      surface = state->destination;
      D_MAGIC_ASSERT( surface, CoreSurface );
 
+     fixed_point = !!(state->blittingflags & DSBLIT_FIXEDPOINT);
+
      font_state_prepare( state, &state_backup, font, surface );
 
      for (l=layers-1; l>=0; l--) {
@@ -2761,7 +2988,13 @@
 
                dfb_state_set_source( state, glyph[l]->surface );
 
-               dfb_gfxcard_blit( &rect, x + glyph[l]->left, y + glyph[l]->top, state );
+               if (!fixed_point) {
+                    dfb_gfxcard_blit( &rect, x + glyph[l]->left, y + glyph[l]->top, state );
+               }
+               else {
+                    dfb_rectangle_upscale( &rect );
+                    dfb_gfxcard_blit( &rect, x + DFB_FIXED_POINT_VAL( glyph[l]->left ), y + DFB_FIXED_POINT_VAL( glyph[l]->top ), state );
+               }
           }
      }
 
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/src/core/gfxcard.h DirectFB-1.4.12+STM2011.09.27/src/core/gfxcard.h
--- DirectFB/src/core/gfxcard.h	2015-06-02 22:40:08.159545138 +0200
+++ DirectFB-1.4.12+STM2011.09.27/src/core/gfxcard.h	2012-06-06 18:41:31.000000000 +0200
@@ -381,6 +381,11 @@
                                           DFBRectangle         *drect,
                                           CardState            *state );
 
+void dfb_gfxcard_batchstretchblit       ( DFBRectangle         *srects,
+                                          DFBRectangle         *drects,
+                                          int                   num,
+                                          CardState            *state );
+
 void dfb_gfxcard_texture_triangles      ( DFBVertex            *vertices,
                                           int                   num,
                                           DFBTriangleFormation  formation,
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/src/core/system.h DirectFB-1.4.12+STM2011.09.27/src/core/system.h
--- DirectFB/src/core/system.h	2015-06-02 22:40:08.167546142 +0200
+++ DirectFB-1.4.12+STM2011.09.27/src/core/system.h	2012-06-06 18:41:31.000000000 +0200
@@ -45,7 +45,8 @@
      CORE_SDL,
      CORE_VNC,
      CORE_DEVMEM,
-     CORE_TI_CMEM
+     CORE_TI_CMEM,
+     CORE_STMFBDEV,
 } CoreSystemType;
 
 typedef enum {
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/src/display/idirectfbpalette.c DirectFB-1.4.12+STM2011.09.27/src/display/idirectfbpalette.c
--- DirectFB/src/display/idirectfbpalette.c	2015-06-02 22:40:08.171546644 +0200
+++ DirectFB-1.4.12+STM2011.09.27/src/display/idirectfbpalette.c	2012-06-06 18:41:31.000000000 +0200
@@ -222,7 +222,7 @@
      if (!interface)
           return DFB_INVARG;
 
-     ret = dfb_palette_create( NULL,    /* FIXME */
+     ret = dfb_palette_create( data->core,
                                data->palette->num_entries, &palette );
      if (ret)
           return ret;
@@ -235,7 +235,7 @@
 
      DIRECT_ALLOCATE_INTERFACE( iface, IDirectFBPalette );
 
-     ret = IDirectFBPalette_Construct( iface, palette );
+     ret = IDirectFBPalette_Construct( iface, palette, data->core );
 
      dfb_palette_unref( palette );
 
@@ -331,7 +331,8 @@
 /******/
 
 DFBResult IDirectFBPalette_Construct( IDirectFBPalette *thiz,
-                                      CorePalette      *palette )
+                                      CorePalette      *palette,
+                                      CoreDFB          *core )
 {
      DIRECT_ALLOCATE_INTERFACE_DATA(thiz, IDirectFBPalette)
 
@@ -342,7 +343,7 @@
 
      data->ref     = 1;
      data->palette = palette;
-
+     data->core    = core;
 
      thiz->AddRef           = IDirectFBPalette_AddRef;
      thiz->Release          = IDirectFBPalette_Release;
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/src/display/idirectfbpalette.h DirectFB-1.4.12+STM2011.09.27/src/display/idirectfbpalette.h
--- DirectFB/src/display/idirectfbpalette.h	2015-06-02 22:40:08.171546644 +0200
+++ DirectFB-1.4.12+STM2011.09.27/src/display/idirectfbpalette.h	2012-06-06 18:41:31.000000000 +0200
@@ -39,13 +39,16 @@
      int                     ref;            /* reference counter */
 
      CorePalette            *palette;        /* the palette object */
+
+     CoreDFB                *core;
 } IDirectFBPalette_data;
 
 /*
  * initializes interface struct and private data
  */
 DFBResult IDirectFBPalette_Construct( IDirectFBPalette *thiz,
-                                      CorePalette      *palette );
+                                      CorePalette      *palette,
+                                      CoreDFB          *core );
 
 
 #endif
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/src/display/idirectfbsurface.c DirectFB-1.4.12+STM2011.09.27/src/display/idirectfbsurface.c
--- DirectFB/src/display/idirectfbsurface.c	2015-06-02 22:40:08.171546644 +0200
+++ DirectFB-1.4.12+STM2011.09.27/src/display/idirectfbsurface.c	2012-06-06 18:41:31.000000000 +0200
@@ -357,7 +357,7 @@
 
      DIRECT_ALLOCATE_INTERFACE( palette, IDirectFBPalette );
 
-     ret = IDirectFBPalette_Construct( palette, surface->palette );
+     ret = IDirectFBPalette_Construct( palette, surface->palette, data->core );
      if (ret)
           return ret;
 
@@ -695,6 +695,7 @@
      DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
 
      D_DEBUG_AT( Surface, "%s( %p, 0x%08x )\n", __FUNCTION__, thiz, PIXEL_ARGB(a,r,g,b) );
+     D_DEBUG_AT( Surface, "  ->      %4d,%4d-%4dx%4d\n", DFB_RECTANGLE_VALS(&data->area.current) );
 
      surface = data->surface;
      if (!surface)
@@ -1738,14 +1739,14 @@
 {
      DFBRectangle srect;
      IDirectFBSurface_data *src_data;
+     const DFBRectangle    *cur_area;
+     DFBRectangle           temp;
+     int                    scaled_one;
 
      DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
 
      D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
 
-     if (sr)
-          D_DEBUG_AT( Surface, "  -> [%2d] %4d,%4d-%4dx%4d <- %4d,%4d\n", 0, dx, dy, sr->w, sr->h, sr->x, sr->y );
-
      if (!data->surface)
           return DFB_DESTROYED;
 
@@ -1764,26 +1765,51 @@
      if (!src_data->area.current.w || !src_data->area.current.h)
           return DFB_INVAREA;
 
+     int x_wanted = data->area.wanted.x;
+     int y_wanted = data->area.wanted.y;
+     int x_wanted_src = src_data->area.wanted.x;
+     int y_wanted_src = src_data->area.wanted.y;
+     if (!(data->state.blittingflags & DSBLIT_FIXEDPOINT)) {
+          cur_area = &src_data->area.current;
+
+          scaled_one = 1;
+     }
+     else {
+          temp.x = DFB_FIXED_POINT_VAL( src_data->area.current.x );
+          temp.y = DFB_FIXED_POINT_VAL( src_data->area.current.y );
+          temp.w = DFB_FIXED_POINT_VAL( src_data->area.current.w );
+          temp.h = DFB_FIXED_POINT_VAL( src_data->area.current.h );
+          cur_area = &temp;
+
+          x_wanted *= DFB_FIXED_POINT_ONE;
+          y_wanted *= DFB_FIXED_POINT_ONE;
+
+          x_wanted_src *= DFB_FIXED_POINT_ONE;
+          y_wanted_src *= DFB_FIXED_POINT_ONE;
+
+          scaled_one = DFB_FIXED_POINT_ONE;
+     }
+
      if (sr) {
-          if (sr->w < 1  ||  sr->h < 1)
+          if (sr->w < scaled_one || sr->h < scaled_one)
                return DFB_OK;
 
           srect = *sr;
 
-          srect.x += src_data->area.wanted.x;
-          srect.y += src_data->area.wanted.y;
+          srect.x += x_wanted_src;
+          srect.y += y_wanted_src;
 
-          if (!dfb_rectangle_intersect( &srect, &src_data->area.current ))
+          if (!dfb_rectangle_intersect( &srect, cur_area ))
                return DFB_INVAREA;
 
-          dx += srect.x - (sr->x + src_data->area.wanted.x);
-          dy += srect.y - (sr->y + src_data->area.wanted.y);
+          dx += srect.x - (sr->x + x_wanted_src);
+          dy += srect.y - (sr->y + y_wanted_src);
      }
      else {
-          srect = src_data->area.current;
+          srect = *cur_area;
 
-          dx += srect.x - src_data->area.wanted.x;
-          dy += srect.y - src_data->area.wanted.y;
+          dx += srect.x - x_wanted_src;
+          dy += srect.y - y_wanted_src;
      }
 
      dfb_state_set_source( &data->state, src_data->surface );
@@ -1792,9 +1818,18 @@
      if (data->state.blittingflags & DSBLIT_SRC_COLORKEY)
           dfb_state_set_src_colorkey( &data->state, src_data->src_key.value );
 
-     dfb_gfxcard_blit( &srect,
-                       data->area.wanted.x + dx,
-                       data->area.wanted.y + dy, &data->state );
+     if (!(data->state.blittingflags & DSBLIT_FIXEDPOINT))
+          D_DEBUG_AT( Surface, "  -> [%2d] %4d,%4d-%4dx%4d <- %4d,%4d\n",
+                      0, x_wanted + dx, y_wanted + dy, srect.w, srect.h,
+                      srect.x, srect.y );
+     else
+          D_DEBUG_AT( Surface, "  -> [%2d] %4d.%06d,%4d.%06d-%4d.%06dx%4d.%06d <- %4d.%06d,%4d.%06d\n",
+                      0,
+                      DFB_INT_VALf( x_wanted + dx ), DFB_INT_VALf( y_wanted + dy ),
+                      DFB_INT_VALf( srect.w ), DFB_INT_VALf( srect.h ),
+                      DFB_INT_VALf( srect.x ), DFB_INT_VALf( srect.y ) );
+
+     dfb_gfxcard_blit( &srect, x_wanted + dx, y_wanted + dy, &data->state );
 
      return DFB_OK;
 }
@@ -1807,13 +1842,27 @@
 {
      DFBRectangle srect;
      IDirectFBSurface_data *src_data;
+     const DFBRectangle    *scaled_wanted;
+     DFBRectangle           temp;
+     int                    scaled_one;
+     int                    x_wanted_src;
+     int                    y_wanted_src;
 
      DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
 
      D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
 
-     if (sr)
-          D_DEBUG_AT( Surface, "  -> [%2d] %4d,%4d-%4dx%4d <- %4d,%4d\n", 0, dx, dy, sr->w, sr->h, sr->x, sr->y );
+     if (sr) {
+          if (!(data->state.blittingflags & DSBLIT_FIXEDPOINT))
+               D_DEBUG_AT( Surface, "  -> [%2d] %4d,%4d-%4dx%4d <- %4d,%4d\n",
+                           0, dx, dy, sr->w, sr->h, sr->x, sr->y );
+          else
+               D_DEBUG_AT( Surface, "  -> [%2d] %4d.%06d,%4d.%06d-%4d.%06dx%4d.%06d <- %4d.%06d,%4d.%06d\n",
+                           0,
+                           DFB_INT_VALf( dx ), DFB_INT_VALf( dy ),
+                           DFB_INT_VALf( sr->w ), DFB_INT_VALf( sr->h ),
+                           DFB_INT_VALf( sr->x ), DFB_INT_VALf( sr->y ) );
+     }
 
      if (!data->surface)
           return DFB_DESTROYED;
@@ -1835,26 +1884,63 @@
           return DFB_INVAREA;
 
 
+     if (!(data->state.blittingflags & DSBLIT_FIXEDPOINT)) {
+          scaled_wanted = &data->area.wanted;
+
+          x_wanted_src = src_data->area.wanted.x;
+          y_wanted_src = src_data->area.wanted.y;
+
+          scaled_one = 1;
+     }
+     else {
+          temp.x = DFB_FIXED_POINT_VAL( data->area.wanted.x );
+          temp.y = DFB_FIXED_POINT_VAL( data->area.wanted.y );
+          temp.w = DFB_FIXED_POINT_VAL( data->area.wanted.w );
+          temp.h = DFB_FIXED_POINT_VAL( data->area.wanted.h );
+          scaled_wanted = &temp;
+
+          x_wanted_src = DFB_FIXED_POINT_VAL( src_data->area.wanted.x );
+          y_wanted_src = DFB_FIXED_POINT_VAL( src_data->area.wanted.y );
+
+          scaled_one = DFB_FIXED_POINT_ONE;
+     }
+
      if (sr) {
-          if (sr->w < 1  ||  sr->h < 1)
-               return DFB_OK;
+          if (sr->w < scaled_one || sr->h < scaled_one)
+                    return DFB_OK;
 
           srect = *sr;
 
-          srect.x += src_data->area.wanted.x;
-          srect.y += src_data->area.wanted.y;
+          srect.x += x_wanted_src;
+          srect.y += y_wanted_src;
 
-          if (!dfb_rectangle_intersect( &srect, &src_data->area.current ))
-               return DFB_INVAREA;
+          if (!(data->state.blittingflags & DSBLIT_FIXEDPOINT)) {
+               if (!dfb_rectangle_intersect( &srect, &src_data->area.current ))
+                    return DFB_INVAREA;
+          }
+          else {
+               DFBRectangle current_src;
+
+               current_src.x = DFB_FIXED_POINT_VAL( src_data->area.current.x );
+               current_src.y = DFB_FIXED_POINT_VAL( src_data->area.current.y );
+               current_src.w = DFB_FIXED_POINT_VAL( src_data->area.current.w );
+               current_src.h = DFB_FIXED_POINT_VAL( src_data->area.current.h );
+
+               if (!dfb_rectangle_intersect( &srect, &current_src ))
+                    return DFB_INVAREA;
+          }
 
-          dx += srect.x - (sr->x + src_data->area.wanted.x);
-          dy += srect.y - (sr->y + src_data->area.wanted.y);
+          dx += srect.x - (sr->x + x_wanted_src);
+          dy += srect.y - (sr->y + y_wanted_src);
      }
      else {
           srect = src_data->area.current;
 
-          dx += srect.x - src_data->area.wanted.x;
-          dy += srect.y - src_data->area.wanted.y;
+          if (data->state.blittingflags & DSBLIT_FIXEDPOINT)
+               dfb_rectangle_upscale( &srect );
+
+          dx += srect.x - x_wanted_src;
+          dy += srect.y - y_wanted_src;
      }
 
      dfb_state_set_source( &data->state, src_data->surface );
@@ -1871,12 +1957,13 @@
      if (dy > 0)
           dy -= srect.h;
 
-     dx += data->area.wanted.x;
-     dy += data->area.wanted.y;
+     dx += scaled_wanted->x;
+     dy += scaled_wanted->y;
 
      dfb_gfxcard_tileblit( &srect, dx, dy,
-                           dx + data->area.wanted.w + srect.w - 1,
-                           dy + data->area.wanted.h + srect.h - 1, &data->state );
+                           dx + scaled_wanted->w + srect.w - scaled_one,
+                           dy + scaled_wanted->h + srect.h - scaled_one,
+                           &data->state );
 
      return DFB_OK;
 }
@@ -1892,6 +1979,8 @@
      DFBRectangle          *rects;
      DFBPoint              *points;
      IDirectFBSurface_data *src_data;
+     const DFBRectangle    *scaled_current_src;
+     DFBRectangle           temp;
 
      DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
 
@@ -1915,11 +2004,28 @@
      if (!src_data->area.current.w || !src_data->area.current.h)
           return DFB_INVAREA;
 
-     dx = data->area.wanted.x;
-     dy = data->area.wanted.y;
+     if (!(data->state.blittingflags & DSBLIT_FIXEDPOINT)) {
+          scaled_current_src = &src_data->area.current;
 
-     sx = src_data->area.wanted.x;
-     sy = src_data->area.wanted.y;
+          dx = data->area.wanted.x;
+          dy = data->area.wanted.y;
+
+          sx = src_data->area.wanted.x;
+          sy = src_data->area.wanted.y;
+     }
+     else {
+          temp.x = DFB_FIXED_POINT_VAL( src_data->area.current.x );
+          temp.y = DFB_FIXED_POINT_VAL( src_data->area.current.y );
+          temp.w = DFB_FIXED_POINT_VAL( src_data->area.current.w );
+          temp.h = DFB_FIXED_POINT_VAL( src_data->area.current.h );
+          scaled_current_src = &temp;
+
+          dx = DFB_FIXED_POINT_VAL( data->area.wanted.x );
+          dy = DFB_FIXED_POINT_VAL( data->area.wanted.y );
+
+          sx = DFB_FIXED_POINT_VAL( src_data->area.wanted.x );
+          sy = DFB_FIXED_POINT_VAL( src_data->area.wanted.y );
+     }
 
      rects  = alloca( sizeof(DFBRectangle) * num );
      points = alloca( sizeof(DFBPoint) * num );
@@ -1934,11 +2040,12 @@
           points[i].x += dx;
           points[i].y += dy;
 
-          if (!dfb_rectangle_intersect( &rects[i], &src_data->area.current ))
+          if (!dfb_rectangle_intersect( &rects[i], scaled_current_src ))
                rects[i].w = rects[i].h = 0;
-
-          points[i].x += rects[i].x - (source_rects[i].x + sx);
-          points[i].y += rects[i].y - (source_rects[i].y + sy);
+          else {
+               points[i].x += rects[i].x - (source_rects[i].x + sx);
+               points[i].y += rects[i].y - (source_rects[i].y + sy);
+          }
      }
 
      dfb_state_set_source( &data->state, src_data->surface );
@@ -2064,18 +2171,78 @@
      return DFB_OK;
 }
 
+static bool
+clip_StretchBlit( DFBRectangle       * __restrict src,
+                  const DFBRectangle * __restrict current_area_src,
+                  DFBRectangle       * __restrict dst,
+                  bool                fixed_point )
+{
+     DFBRectangle orig_src = *src;
+
+     if (!dfb_rectangle_intersect( src, current_area_src )) {
+          src->w = src->h = 0;
+          dst->w = dst->h = 0;
+          return false;
+     }
+
+     /* clipping of the source rectangle must be applied to the destination */
+     if (src->x != orig_src.x)
+          dst->x += (int)( (src->x - orig_src.x) *
+                           (dst->w / (float)orig_src.w) + 0.5f);
+
+     if (src->y != orig_src.y)
+          dst->y += (int)( (src->y - orig_src.y) *
+                           (dst->h / (float)orig_src.h) + 0.5f);
+
+     if (src->w != orig_src.w) {
+          dst->w = (dst->w * (src->w / (float)orig_src.w));
+          if (!fixed_point)
+               dst->w = D_ICEIL(dst->w);
+          /* don't round in the fixed point case, as we want to keep the
+             precision */
+     }
+
+     if (src->h != orig_src.h) {
+          dst->h = (int) (dst->h * (src->h / (float)orig_src.h));
+          if (!fixed_point)
+               dst->h = D_ICEIL(dst->h);
+          /* don't round in the fixed point case, as we want to keep the
+             precision */
+     }
+
+     if (!fixed_point)
+          D_DEBUG_AT( Surface, "  -> [%2d] %4d,%4d-%4dx%4d <- %4d,%4d-%4dx%4d\n",
+                      0, dst->x, dst->y, dst->w, dst->h,
+                      src->x, src->y, src->w, src->h );
+     else
+          D_DEBUG_AT( Surface, "  -> [%2d] %4d.%06d,%4d.%06d-%4d.%06dx%4d.%06d <- %4d.%06d,%4d.%06d-%4d.%06dx%4d.%06d\n",
+                      0,
+                      DFB_INT_VALf( dst->x ), DFB_INT_VALf( dst->y ),
+                      DFB_INT_VALf( dst->w ), DFB_INT_VALf( dst->h ),
+                      DFB_INT_VALf( src->x ), DFB_INT_VALf( src->y ),
+                      DFB_INT_VALf( src->w ), DFB_INT_VALf( src->h ) );
+
+     return true;
+}
+
 static DFBResult
-IDirectFBSurface_StretchBlit( IDirectFBSurface   *thiz,
-                              IDirectFBSurface   *source,
-                              const DFBRectangle *source_rect,
-                              const DFBRectangle *destination_rect )
+IDirectFBSurface_BatchStretchBlit( IDirectFBSurface *thiz,
+                                   IDirectFBSurface *source,
+                                   DFBRectangle     *source_rects,
+                                   DFBRectangle     *dest_rects,
+                                   int               num )
 {
-     DFBRectangle srect, drect;
      IDirectFBSurface_data *src_data;
+     int                    i;
+     const DFBRectangle    *scaled_current_src;
+     DFBRectangle           temp;
+     int                    scaled_one;
+     int                    sx, sy, dx, dy;
+     bool                   fixed_point;
 
      DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
 
-     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+     D_DEBUG_AT( Surface, "%s( %p, %d )\n", __FUNCTION__, thiz, num );
 
      if (!data->surface)
           return DFB_DESTROYED;
@@ -2087,7 +2254,7 @@
      if (data->locked)
           return DFB_LOCKED;
 
-     if (!source)
+     if (!source || !source_rects || !dest_rects || num < 1)
           return DFB_INVARG;
 
 
@@ -2097,52 +2264,55 @@
           return DFB_INVAREA;
 
 
-     /* do destination rectangle */
-     if (destination_rect) {
-          if (destination_rect->w < 1  ||  destination_rect->h < 1)
-               return DFB_INVARG;
+     fixed_point = !!(data->state.blittingflags & DSBLIT_FIXEDPOINT);
 
-          drect = *destination_rect;
+     if (!fixed_point) {
+          scaled_one = 1;
+
+          scaled_current_src = &src_data->area.current;
+
+          dx = data->area.wanted.x;
+          dy = data->area.wanted.y;
 
-          drect.x += data->area.wanted.x;
-          drect.y += data->area.wanted.y;
+          sx = src_data->area.wanted.x;
+          sy = src_data->area.wanted.y;
      }
-     else
-          drect = data->area.wanted;
+     else {
+          scaled_one = DFB_FIXED_POINT_ONE;
 
-     /* do source rectangle */
-     if (source_rect) {
-          if (source_rect->w < 1  ||  source_rect->h < 1)
-               return DFB_INVARG;
+          temp.x = DFB_FIXED_POINT_VAL( src_data->area.current.x );
+          temp.y = DFB_FIXED_POINT_VAL( src_data->area.current.y );
+          temp.w = DFB_FIXED_POINT_VAL( src_data->area.current.w );
+          temp.h = DFB_FIXED_POINT_VAL( src_data->area.current.h );
+          scaled_current_src = &temp;
 
-          srect = *source_rect;
+          dx = DFB_FIXED_POINT_VAL( data->area.wanted.x );
+          dy = DFB_FIXED_POINT_VAL( data->area.wanted.y );
 
-          srect.x += src_data->area.wanted.x;
-          srect.y += src_data->area.wanted.y;
+          sx = DFB_FIXED_POINT_VAL( src_data->area.wanted.x );
+          sy = DFB_FIXED_POINT_VAL( src_data->area.wanted.y );
      }
-     else
-          srect = src_data->area.wanted;
 
+     for (i=0; i<num; i++) {
+          DFBRectangle * __restrict src = &source_rects[i];
+          DFBRectangle * __restrict dst = &dest_rects[i];
 
-     /* clipping of the source rectangle must be applied to the destination */
-     {
-          DFBRectangle orig_src = srect;
+          if (dst->w < scaled_one || dst->h < scaled_one) {
+               dst->w = 0;
+               dst->h = 0;
+               continue;
+          }
 
-          if (!dfb_rectangle_intersect( &srect, &src_data->area.current ))
-               return DFB_INVAREA;
+          if (src->w <= 0 || src->h <= 0)
+               return DFB_INVARG;
+
+          src->x += sx;
+          src->y += sy;
+
+          dst->x += dx;
+          dst->y += dy;
 
-          if (srect.x != orig_src.x)
-               drect.x += (int)( (srect.x - orig_src.x) *
-                                 (drect.w / (float)orig_src.w) + 0.5f);
-
-          if (srect.y != orig_src.y)
-               drect.y += (int)( (srect.y - orig_src.y) *
-                                 (drect.h / (float)orig_src.h) + 0.5f);
-
-          if (srect.w != orig_src.w)
-               drect.w = D_ICEIL(drect.w * (srect.w / (float)orig_src.w));
-          if (srect.h != orig_src.h)
-               drect.h = D_ICEIL(drect.h * (srect.h / (float)orig_src.h));
+          clip_StretchBlit( src, scaled_current_src, dst, fixed_point );
      }
 
      dfb_state_set_source( &data->state, src_data->surface );
@@ -2151,11 +2321,49 @@
      if (data->state.blittingflags & DSBLIT_SRC_COLORKEY)
           dfb_state_set_src_colorkey( &data->state, src_data->src_key.value );
 
-     dfb_gfxcard_stretchblit( &srect, &drect, &data->state );
+     dfb_gfxcard_batchstretchblit( source_rects, dest_rects, num,
+                                   &data->state );
 
      return DFB_OK;
 }
 
+static DFBResult
+IDirectFBSurface_StretchBlit( IDirectFBSurface   *thiz,
+                              IDirectFBSurface   *source,
+                              const DFBRectangle *source_rect,
+                              const DFBRectangle *destination_rect )
+{
+     DFBRectangle srect, drect;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     if (destination_rect)
+          drect = *destination_rect;
+     else {
+          if (!(data->state.blittingflags & DSBLIT_FIXEDPOINT))
+               drect = (DFBRectangle) { 0, 0, data->area.wanted.w, data->area.wanted.h };
+          else
+               drect = (DFBRectangle) { 0, 0,
+                                        DFB_FIXED_POINT_VAL( data->area.wanted.w ),
+                                        DFB_FIXED_POINT_VAL( data->area.wanted.h ) };
+     }
+
+     if (source_rect)
+          srect = *source_rect;
+     else {
+          IDirectFBSurface_data *sd = (IDirectFBSurface_data*)source->priv;
+
+          if (!(data->state.blittingflags & DSBLIT_FIXEDPOINT))
+               srect = (DFBRectangle) { 0, 0, sd->area.wanted.w, sd->area.wanted.h };
+          else
+               srect = (DFBRectangle) { 0, 0,
+                                        DFB_FIXED_POINT_VAL( sd->area.wanted.w ),
+                                        DFB_FIXED_POINT_VAL( sd->area.wanted.h ) };
+     }
+
+     return IDirectFBSurface_BatchStretchBlit( thiz, source, &srect, &drect, 1 );
+}
+
 #define SET_VERTEX(v,X,Y,Z,W,S,T)  \
      do {                          \
           (v)->x = X;              \
@@ -2285,6 +2493,7 @@
      IDirectFBFont_data *font_data;
      CoreFont           *core_font;
      unsigned int        layers = 1;
+     int                 scaled_one;
 
      DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
 
@@ -2324,13 +2533,16 @@
           layers = 2;
      }
 
+     scaled_one = ((data->state.blittingflags & DSBLIT_FIXEDPOINT)
+                   ? DFB_FIXED_POINT_ONE : 1);
+
      if (!(flags & DSTF_TOP)) {
-          x += core_font->ascender * core_font->up_unit_x;
-          y += core_font->ascender * core_font->up_unit_y;
+          x += ((int) core_font->ascender * core_font->up_unit_x) * scaled_one;
+          y += ((int) core_font->ascender * core_font->up_unit_y) * scaled_one;
 
           if (flags & DSTF_BOTTOM) {
-               x -= core_font->descender * core_font->up_unit_x;
-               y -= core_font->descender * core_font->up_unit_y;
+               x -= ((int) core_font->descender * core_font->up_unit_x) * scaled_one;
+               y -= ((int) core_font->descender * core_font->up_unit_y) * scaled_one;
           }
      }
 
@@ -2374,17 +2586,18 @@
 
           /* Justify. */
           if (flags & DSTF_RIGHT) {
-               x -= xsize;
-               y -= ysize;
+               x -= (xsize * scaled_one);
+               y -= (ysize * scaled_one);
           }
           else if (flags & DSTF_CENTER) {
-               x -= xsize >> 1;
-               y -= ysize >> 1;
+               x -= (xsize * scaled_one) >> 1;
+               y -= (ysize * scaled_one) >> 1;
           }
      }
 
      dfb_gfxcard_drawstring( (const unsigned char*) text, bytes, data->encoding,
-                             data->area.wanted.x + x, data->area.wanted.y + y,
+                             data->area.wanted.x * scaled_one + x,
+                             data->area.wanted.y * scaled_one + y,
                              core_font, layers, &data->state );
 
      return DFB_OK;
@@ -2403,6 +2616,7 @@
      CoreGlyphData      *glyph[DFB_FONT_MAX_LAYERS];
      unsigned int        index;
      unsigned int        layers = 1;
+     int                 scaled_one;
 
      DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
 
@@ -2437,6 +2651,9 @@
           layers = 2;
      }
 
+     scaled_one = ((data->state.blittingflags & DSBLIT_FIXEDPOINT)
+                   ? DFB_FIXED_POINT_ONE : 1);
+
      dfb_font_lock( core_font );
 
      ret = dfb_font_decode_character( core_font, data->encoding, character, &index );
@@ -2454,28 +2671,29 @@
      }
 
      if (!(flags & DSTF_TOP)) {
-          x += core_font->ascender * core_font->up_unit_x;
-          y += core_font->ascender * core_font->up_unit_y;
+          x += ((int) core_font->ascender * core_font->up_unit_x) * scaled_one;
+          y += ((int) core_font->ascender * core_font->up_unit_y) * scaled_one;
 
           if (flags & DSTF_BOTTOM) {
-               x -= core_font->descender * core_font->up_unit_x;
-               y -= core_font->descender * core_font->up_unit_y;
+               x -= ((int) core_font->descender * core_font->up_unit_x) * scaled_one;
+               y -= ((int) core_font->descender * core_font->up_unit_y) * scaled_one;
           }
      }
 
      if (flags & (DSTF_RIGHT | DSTF_CENTER)) {
           if (flags & DSTF_RIGHT) {
-               x -= glyph[0]->xadvance;
-               y -= glyph[0]->yadvance;
+               x -= (glyph[0]->xadvance * scaled_one);
+               y -= (glyph[0]->yadvance * scaled_one);
           }
           else if (flags & DSTF_CENTER) {
-               x -= glyph[0]->xadvance >> 1;
-               y -= glyph[0]->yadvance >> 1;
+               x -= (glyph[0]->xadvance * scaled_one) >> 1;
+               y -= (glyph[0]->yadvance * scaled_one) >> 1;
           }
      }
 
      dfb_gfxcard_drawglyph( glyph,
-                            data->area.wanted.x + x, data->area.wanted.y + y,
+                            data->area.wanted.x * scaled_one + x,
+                            data->area.wanted.y * scaled_one + y,
                             core_font, layers, &data->state );
 
      dfb_font_unlock( core_font );
@@ -2924,6 +3142,7 @@
      thiz->BatchBlit = IDirectFBSurface_BatchBlit;
      thiz->BatchBlit2 = IDirectFBSurface_BatchBlit2;
      thiz->StretchBlit = IDirectFBSurface_StretchBlit;
+     thiz->BatchStretchBlit = IDirectFBSurface_BatchStretchBlit;
      thiz->TextureTriangles = IDirectFBSurface_TextureTriangles;
 
      thiz->SetDrawingFlags = IDirectFBSurface_SetDrawingFlags;
@@ -3003,8 +3222,10 @@
                data->area.wanted = data->area.granted = data->area.current = rect;
 
           /* Reset clip to avoid crashes caused by drawing out of bounds. */
-          if (data->clip_set)
-               thiz->SetClip( thiz, &data->clip_wanted );
+          if (data->clip_set) {
+               DFBRegion clip = data->clip_wanted;
+               thiz->SetClip( thiz, &clip );
+          }
           else
                thiz->SetClip( thiz, NULL );
      }
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/src/gfx/clip.c DirectFB-1.4.12+STM2011.09.27/src/gfx/clip.c
--- DirectFB/src/gfx/clip.c	2015-06-02 22:40:08.175547147 +0200
+++ DirectFB-1.4.12+STM2011.09.27/src/gfx/clip.c	2012-06-06 18:41:31.000000000 +0200
@@ -123,9 +123,10 @@
 }
 
 DFBEdgeFlags
-dfb_clip_edges( const DFBRegion *clip, DFBRectangle *rect )
+dfb_clip_edges_f( const DFBRegion *clip, DFBRectangle *rect, bool fixedpoint )
 {
      DFBEdgeFlags flags = DFEF_ALL;
+     int offset = fixedpoint ? DFB_FIXED_POINT_ONE : 1;
 
      if ((clip->x1 >= rect->x + rect->w) ||
          (clip->x2 < rect->x) ||
@@ -147,14 +148,14 @@
           flags &= ~DFEF_TOP;
      }
 
-     if (clip->x2 < rect->x + rect->w - 1) {
-          rect->w = clip->x2 - rect->x + 1;
+     if (clip->x2 < rect->x + rect->w - offset) {
+          rect->w = clip->x2 - rect->x + offset;
 
           flags &= ~DFEF_RIGHT;
      }
 
-     if (clip->y2 < rect->y + rect->h - 1) {
-          rect->h = clip->y2 - rect->y + 1;
+     if (clip->y2 < rect->y + rect->h - offset) {
+          rect->h = clip->y2 - rect->y + offset;
 
           flags &= ~DFEF_BOTTOM;
      }
@@ -162,9 +163,17 @@
      return flags;
 }
 
+DFBEdgeFlags
+dfb_clip_edges( const DFBRegion *clip, DFBRectangle *rect )
+{
+     return dfb_clip_edges_f( clip, rect, false );
+}
+
 DFBBoolean
-dfb_clip_rectangle( const DFBRegion *clip, DFBRectangle *rect )
+dfb_clip_rectangle_f( const DFBRegion *clip, DFBRectangle *rect, bool fixedpoint )
 {
+     int offset = fixedpoint ? DFB_FIXED_POINT_ONE : 1;
+
      if ((clip->x1 >= rect->x + rect->w) ||
          (clip->x2 < rect->x) ||
          (clip->y1 >= rect->y + rect->h) ||
@@ -181,16 +190,22 @@
           rect->y = clip->y1;
      }
 
-     if (clip->x2 < rect->x + rect->w - 1)
-          rect->w = clip->x2 - rect->x + 1;
+     if (clip->x2 < rect->x + rect->w - offset)
+          rect->w = clip->x2 - rect->x + offset;
 
-     if (clip->y2 < rect->y + rect->h - 1)
-          rect->h = clip->y2 - rect->y + 1;
+     if (clip->y2 < rect->y + rect->h - offset)
+          rect->h = clip->y2 - rect->y + offset;
 
      return DFB_TRUE;
 }
 
 DFBBoolean
+dfb_clip_rectangle( const DFBRegion *clip, DFBRectangle *rect )
+{
+     return dfb_clip_rectangle_f( clip, rect, false );
+}
+
+DFBBoolean
 dfb_clip_triangle_precheck( const DFBRegion *clip, const DFBTriangle *tri )
 {
     int x, y, w, h;
@@ -329,38 +344,47 @@
 
 
 void
-dfb_clip_blit( const DFBRegion *clip,
-               DFBRectangle *srect, int *dx, int *dy )
+dfb_clip_blit_f( const DFBRegion *clip,
+                 DFBRectangle *srect, int *dx, int *dy, bool fixedpoint )
 {
+     int offset = fixedpoint ? DFB_FIXED_POINT_ONE : 1;
+
      if (clip->x1 > *dx ) {
-          srect->w = MIN( (clip->x2 - clip->x1) + 1,
+          srect->w = MIN( (clip->x2 - clip->x1) + offset,
                     (*dx + srect->w) - clip->x1);
 
           srect->x+= clip->x1 - *dx;
           *dx = clip->x1;
      }
-     else if (clip->x2 < *dx + srect->w - 1) {
-          srect->w = clip->x2 - *dx + 1;
+     else if (clip->x2 < *dx + srect->w - offset) {
+          srect->w = clip->x2 - *dx + offset;
      }
 
      if (clip->y1 > *dy ) {
-          srect->h = MIN( (clip->y2 - clip->y1) + 1,
+          srect->h = MIN( (clip->y2 - clip->y1) + offset,
                           (*dy + srect->h) - clip->y1);
           srect->y+= clip->y1 - *dy;
           *dy = clip->y1;
      }
-     else if (clip->y2 < *dy + srect->h - 1) {
-          srect->h = clip->y2 - *dy + 1;
+     else if (clip->y2 < *dy + srect->h - offset) {
+          srect->h = clip->y2 - *dy + offset;
      }
 }
 
 void
-dfb_clip_stretchblit( const DFBRegion *clip,
-                      DFBRectangle *srect, DFBRectangle *drect )
+dfb_clip_blit( const DFBRegion *clip,
+               DFBRectangle *srect, int *dx, int *dy )
+{
+     dfb_clip_blit_f( clip, srect, dx, dy, false );
+}
+
+void
+dfb_clip_stretchblit_f( const DFBRegion *clip,
+                        DFBRectangle *srect, DFBRectangle *drect, bool fixedpoint )
 {
      DFBRectangle orig_dst = *drect;
 
-     dfb_clip_rectangle( clip, drect );
+     dfb_clip_rectangle_f( clip, drect, fixedpoint );
 
      if (drect->x != orig_dst.x)
           srect->x += (int)( (drect->x - orig_dst.x) *
@@ -377,3 +401,9 @@
           srect->h = (int)( srect->h * (drect->h / (float)orig_dst.h) );
 }
 
+void
+dfb_clip_stretchblit( const DFBRegion *clip,
+                      DFBRectangle *srect, DFBRectangle *drect )
+{
+     dfb_clip_stretchblit_f( clip, srect, drect, false );
+}
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/src/gfx/clip.h DirectFB-1.4.12+STM2011.09.27/src/gfx/clip.h
--- DirectFB/src/gfx/clip.h	2015-06-02 22:40:08.175547147 +0200
+++ DirectFB-1.4.12+STM2011.09.27/src/gfx/clip.h	2012-06-06 18:41:31.000000000 +0200
@@ -52,21 +52,33 @@
  * Clips the rectangle to the clipping region.
  * Returns true if there was an intersection with the clipping region.
  */
+DFBBoolean   dfb_clip_rectangle_f( const DFBRegion *clip, DFBRectangle *rect,
+                                   bool fixedpoint );
 DFBBoolean   dfb_clip_rectangle( const DFBRegion *clip, DFBRectangle *rect );
 
 /*
  * Clips the rectangle to the clipping region.
  * Returns a flag for each edge that wasn't cut off.
  */
+DFBEdgeFlags dfb_clip_edges_f( const DFBRegion *clip, DFBRectangle *rect,
+                               bool fixedpoint );
 DFBEdgeFlags dfb_clip_edges( const DFBRegion *clip, DFBRectangle *rect );
 
 static inline DFBBoolean
-dfb_clip_needed( const DFBRegion *clip, DFBRectangle *rect )
+dfb_clip_needed_f( const DFBRegion *clip, DFBRectangle *rect, bool fixedpoint )
 {
+     int scaled_one = fixedpoint ? DFB_FIXED_POINT_ONE : 1;
+
      return ((clip->x1 > rect->x) ||
              (clip->y1 > rect->y) ||
-             (clip->x2 < rect->x + rect->w - 1) ||
-             (clip->y2 < rect->y + rect->h - 1));
+             (clip->x2 < rect->x + rect->w - scaled_one) ||
+             (clip->y2 < rect->y + rect->h - scaled_one));
+}
+
+static inline DFBBoolean
+dfb_clip_needed( const DFBRegion *clip, DFBRectangle *rect )
+{
+     return dfb_clip_needed_f( clip, rect, false );
 }
 
 /*
@@ -92,10 +104,12 @@
  * Returns true if blitting may need to be performed.
  */
 static inline DFBBoolean
-dfb_clip_blit_precheck( const DFBRegion *clip,
-                        int w, int h, int dx, int dy )
+dfb_clip_blit_precheck_f( const DFBRegion *clip,
+                          int w, int h, int dx, int dy, bool fixedpoint )
 {
-     if (w < 1 || h < 1 ||
+     int scaled_one = fixedpoint ? DFB_FIXED_POINT_ONE : 1;
+
+     if (w < scaled_one || h < scaled_one ||
          (clip->x1 >= dx + w) ||
          (clip->x2 < dx) ||
          (clip->y1 >= dy + h) ||
@@ -105,10 +119,19 @@
      return DFB_TRUE;
 }
 
+static inline DFBBoolean
+dfb_clip_blit_precheck( const DFBRegion *clip,
+                        int w, int h, int dx, int dy )
+{
+     return dfb_clip_blit_precheck_f( clip, w, h, dx, dy, false );
+}
+
 /*
  * Clips the blitting request to the clipping region.
  * This includes adjustment of source AND destination coordinates.
  */
+void dfb_clip_blit_f( const DFBRegion *clip,
+                      DFBRectangle *srect, int *dx, int *dy, bool fixedpoint );
 void dfb_clip_blit( const DFBRegion *clip,
                     DFBRectangle *srect, int *dx, int *dy );
 
@@ -117,6 +140,10 @@
  * This includes adjustment of source AND destination coordinates
  * based on the scaling factor.
  */
+void dfb_clip_stretchblit_f( const DFBRegion *clip,
+                             DFBRectangle    *srect,
+                             DFBRectangle    *drect,
+                             bool             fixedpoint );
 void dfb_clip_stretchblit( const DFBRegion *clip,
                            DFBRectangle    *srect,
                            DFBRectangle    *drect );
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/src/idirectfb.c DirectFB-1.4.12+STM2011.09.27/src/idirectfb.c
--- DirectFB/src/idirectfb.c	2015-06-02 22:40:08.179547649 +0200
+++ DirectFB-1.4.12+STM2011.09.27/src/idirectfb.c	2012-06-06 18:41:31.000000000 +0200
@@ -997,7 +997,7 @@
 
      DIRECT_ALLOCATE_INTERFACE( iface, IDirectFBPalette );
 
-     ret = IDirectFBPalette_Construct( iface, palette );
+     ret = IDirectFBPalette_Construct( iface, palette, data->core );
 
      dfb_palette_unref( palette );
 
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/src/media/idirectfbimageprovider.c DirectFB-1.4.12+STM2011.09.27/src/media/idirectfbimageprovider.c
--- DirectFB/src/media/idirectfbimageprovider.c	2015-06-02 22:40:08.179547649 +0200
+++ DirectFB-1.4.12+STM2011.09.27/src/media/idirectfbimageprovider.c	2012-06-06 18:41:31.000000000 +0200
@@ -96,6 +96,16 @@
 }
 
 static DFBResult
+IDirectFBImageProvider_SetFlags ( IDirectFBImageProvider *thiz,
+                                  DFBImageProviderFlags   flags )
+{
+     if (flags == DIPFLAGS_NONE)
+          return DFB_OK;
+
+     return DFB_UNIMPLEMENTED;
+}
+
+static DFBResult
 IDirectFBImageProvider_RenderTo( IDirectFBImageProvider *thiz,
                                  IDirectFBSurface       *destination,
                                  const DFBRectangle     *destination_rect )
@@ -117,6 +127,13 @@
 }
 
 static DFBResult
+IDirectFBImageProvider_Sync( IDirectFBImageProvider    *thiz,
+                             DFBImageProviderSyncFlags  flags )
+{
+     return DFB_UNIMPLEMENTED;
+}
+
+static DFBResult
 IDirectFBImageProvider_WriteBack( IDirectFBImageProvider *thiz,
                                   IDirectFBSurface       *surface,
                                   const DFBRectangle     *src_rect,
@@ -132,8 +149,10 @@
      thiz->Release               = IDirectFBImageProvider_Release;
      thiz->GetSurfaceDescription = IDirectFBImageProvider_GetSurfaceDescription;
      thiz->GetImageDescription   = IDirectFBImageProvider_GetImageDescription;
+     thiz->SetFlags              = IDirectFBImageProvider_SetFlags;
      thiz->RenderTo              = IDirectFBImageProvider_RenderTo;
      thiz->SetRenderCallback     = IDirectFBImageProvider_SetRenderCallback;
+     thiz->Sync                  = IDirectFBImageProvider_Sync;
      thiz->WriteBack             = IDirectFBImageProvider_WriteBack;
 }
      
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/src/media/Makefile.am DirectFB-1.4.12+STM2011.09.27/src/media/Makefile.am
--- DirectFB/src/media/Makefile.am	2015-06-02 22:40:08.179547649 +0200
+++ DirectFB-1.4.12+STM2011.09.27/src/media/Makefile.am	2012-06-06 18:41:31.000000000 +0200
@@ -35,4 +35,5 @@
 	idirectfbdatabuffer_file.c	\
 	idirectfbdatabuffer_memory.c	\
 	idirectfbdatabuffer_streamed.c
-libdirectfb_media_la_LDFLAGS = $(MEDIALIB)
+
+libdirectfb_media_la_LIBADD = $(LIBM)
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/systems/Makefile.am DirectFB-1.4.12+STM2011.09.27/systems/Makefile.am
--- DirectFB/systems/Makefile.am	2015-06-02 22:40:08.183548151 +0200
+++ DirectFB-1.4.12+STM2011.09.27/systems/Makefile.am	2012-06-06 18:41:31.000000000 +0200
@@ -30,6 +30,12 @@
 FBDEV_DIR =
 endif
 
+if STMFBDEV_CORE
+STMFBDEV_DIR = stmfbdev
+else
+STMFBDEV_DIR =
+endif
+
 if VNC_CORE
 VNC_DIR = vnc
 else
@@ -41,6 +47,7 @@
 	dummy \
 	$(DEVMEM_DIR) \
 	$(FBDEV_DIR) \
+	$(STMFBDEV_DIR) \
 	$(X11_DIR) \
 	$(SDL_DIR) \
 	$(OSX_DIR) \
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/systems/stmfbdev/fb.h DirectFB-1.4.12+STM2011.09.27/systems/stmfbdev/fb.h
--- DirectFB/systems/stmfbdev/fb.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/systems/stmfbdev/fb.h	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,366 @@
+#ifndef _LINUX_FB_H
+#define _LINUX_FB_H
+
+#include <dfb_types.h>
+
+/* Definitions of frame buffers						*/
+
+#define FB_MAJOR		29
+#define FB_MAX			32	/* sufficient for now */
+
+/* ioctls
+   0x46 is 'F'								*/
+#define FBIOGET_VSCREENINFO	0x4600
+#define FBIOPUT_VSCREENINFO	0x4601
+#define FBIOGET_FSCREENINFO	0x4602
+#define FBIOGETCMAP		0x4604
+#define FBIOPUTCMAP		0x4605
+#define FBIOPAN_DISPLAY		0x4606
+#define FBIO_CURSOR            _IOWR('F', 0x08, struct fb_cursor)
+/* 0x4607-0x460B are defined below */
+/* #define FBIOGET_MONITORSPEC	0x460C */
+/* #define FBIOPUT_MONITORSPEC	0x460D */
+/* #define FBIOSWITCH_MONIBIT	0x460E */
+#define FBIOGET_CON2FBMAP	0x460F
+#define FBIOPUT_CON2FBMAP	0x4610
+#define FBIOBLANK		0x4611		/* arg: 0 or vesa level + 1 */
+#define FBIOGET_VBLANK		_IOR('F', 0x12, struct fb_vblank)
+#define FBIO_ALLOC              0x4613
+#define FBIO_FREE               0x4614
+#define FBIOGET_GLYPH           0x4615
+#define FBIOGET_HWCINFO         0x4616
+#define FBIOPUT_MODEINFO        0x4617
+#define FBIOGET_DISPINFO        0x4618
+
+
+#define FB_TYPE_PACKED_PIXELS		0	/* Packed Pixels	*/
+#define FB_TYPE_PLANES			1	/* Non interleaved planes */
+#define FB_TYPE_INTERLEAVED_PLANES	2	/* Interleaved planes	*/
+#define FB_TYPE_TEXT			3	/* Text/attributes	*/
+#define FB_TYPE_VGA_PLANES		4	/* EGA/VGA planes	*/
+
+#define FB_AUX_TEXT_MDA		0	/* Monochrome text */
+#define FB_AUX_TEXT_CGA		1	/* CGA/EGA/VGA Color text */
+#define FB_AUX_TEXT_S3_MMIO	2	/* S3 MMIO fasttext */
+#define FB_AUX_TEXT_MGA_STEP16	3	/* MGA Millenium I: text, attr, 14 reserved bytes */
+#define FB_AUX_TEXT_MGA_STEP8	4	/* other MGAs:      text, attr,  6 reserved bytes */
+
+#define FB_AUX_VGA_PLANES_VGA4		0	/* 16 color planes (EGA/VGA) */
+#define FB_AUX_VGA_PLANES_CFB4		1	/* CFB4 in planes (VGA) */
+#define FB_AUX_VGA_PLANES_CFB8		2	/* CFB8 in planes (VGA) */
+
+#define FB_VISUAL_MONO01		0	/* Monochr. 1=Black 0=White */
+#define FB_VISUAL_MONO10		1	/* Monochr. 1=White 0=Black */
+#define FB_VISUAL_TRUECOLOR		2	/* True color	*/
+#define FB_VISUAL_PSEUDOCOLOR		3	/* Pseudo color (like atari) */
+#define FB_VISUAL_DIRECTCOLOR		4	/* Direct color */
+#define FB_VISUAL_STATIC_PSEUDOCOLOR	5	/* Pseudo color readonly */
+
+#define FB_ACCEL_NONE		0	/* no hardware accelerator	*/
+#define FB_ACCEL_ATARIBLITT	1	/* Atari Blitter		*/
+#define FB_ACCEL_AMIGABLITT	2	/* Amiga Blitter                */
+#define FB_ACCEL_S3_TRIO64	3	/* Cybervision64 (S3 Trio64)    */
+#define FB_ACCEL_NCR_77C32BLT	4	/* RetinaZ3 (NCR 77C32BLT)      */
+#define FB_ACCEL_S3_VIRGE	5	/* Cybervision64/3D (S3 ViRGE)	*/
+#define FB_ACCEL_ATI_MACH64GX	6	/* ATI Mach 64GX family		*/
+#define FB_ACCEL_DEC_TGA	7	/* DEC 21030 TGA		*/
+#define FB_ACCEL_ATI_MACH64CT	8	/* ATI Mach 64CT family		*/
+#define FB_ACCEL_ATI_MACH64VT	9	/* ATI Mach 64CT family VT class */
+#define FB_ACCEL_ATI_MACH64GT	10	/* ATI Mach 64CT family GT class */
+#define FB_ACCEL_SUN_CREATOR	11	/* Sun Creator/Creator3D	*/
+#define FB_ACCEL_SUN_CGSIX	12	/* Sun cg6			*/
+#define FB_ACCEL_SUN_LEO	13	/* Sun leo/zx			*/
+#define FB_ACCEL_IMS_TWINTURBO	14	/* IMS Twin Turbo		*/
+#define FB_ACCEL_3DLABS_PERMEDIA2 15	/* 3Dlabs Permedia 2		*/
+#define FB_ACCEL_MATROX_MGA2064W 16	/* Matrox MGA2064W (Millenium)	*/
+#define FB_ACCEL_MATROX_MGA1064SG 17	/* Matrox MGA1064SG (Mystique)	*/
+#define FB_ACCEL_MATROX_MGA2164W 18	/* Matrox MGA2164W (Millenium II) */
+#define FB_ACCEL_MATROX_MGA2164W_AGP 19	/* Matrox MGA2164W (Millenium II) */
+#define FB_ACCEL_MATROX_MGAG100	20	/* Matrox G100 (Productiva G100) */
+#define FB_ACCEL_MATROX_MGAG200	21	/* Matrox G200 (Myst, Mill, ...) */
+#define FB_ACCEL_SUN_CG14	22	/* Sun cgfourteen		 */
+#define FB_ACCEL_SUN_BWTWO	23	/* Sun bwtwo			*/
+#define FB_ACCEL_SUN_CGTHREE	24	/* Sun cgthree			*/
+#define FB_ACCEL_SUN_TCX	25	/* Sun tcx			*/
+#define FB_ACCEL_MATROX_MGAG400	26	/* Matrox G400			*/
+#define FB_ACCEL_NV3		27	/* nVidia RIVA 128              */
+#define FB_ACCEL_NV4		28	/* nVidia RIVA TNT		*/
+#define FB_ACCEL_NV5		29	/* nVidia RIVA TNT2		*/
+#define FB_ACCEL_CT_6555x	30	/* C&T 6555x			*/
+#define FB_ACCEL_3DFX_BANSHEE	31	/* 3Dfx Banshee			*/
+#define FB_ACCEL_ATI_RAGE128	32	/* ATI Rage128 family		*/
+#define FB_ACCEL_IGS_CYBER2000	33	/* CyberPro 2000		*/
+#define FB_ACCEL_IGS_CYBER2010	34	/* CyberPro 2010		*/
+#define FB_ACCEL_IGS_CYBER5000	35	/* CyberPro 5000		*/
+#define FB_ACCEL_SIS_GLAMOUR    36	/* SiS 300/630/540              */
+#define FB_ACCEL_3DLABS_PERMEDIA3 37	/* 3Dlabs Permedia 3		*/
+#define FB_ACCEL_ATI_RADEON	38	/* ATI Radeon family		*/
+#define FB_ACCEL_I810           39      /* Intel 810/815                */
+#define FB_ACCEL_SIS_GLAMOUR_2  40	/* SiS 315, 650, 740		*/
+#define FB_ACCEL_SIS_XABRE      41	/* SiS 330 ("Xabre")		*/
+#define FB_ACCEL_I830           42      /* Intel 830M/845G/85x/865G     */
+#define FB_ACCEL_NV_10          43      /* nVidia Arch 10               */
+#define FB_ACCEL_NV_20          44      /* nVidia Arch 20               */
+#define FB_ACCEL_NV_30          45      /* nVidia Arch 30               */
+#define FB_ACCEL_NV_40          46      /* nVidia Arch 40               */
+#define FB_ACCEL_XGI_VOLARI_V	47	/* XGI Volari V3XT, V5, V8      */
+#define FB_ACCEL_XGI_VOLARI_Z	48	/* XGI Volari Z7                */
+#define FB_ACCEL_NEOMAGIC_NM2070 90	/* NeoMagic NM2070              */
+#define FB_ACCEL_NEOMAGIC_NM2090 91	/* NeoMagic NM2090              */
+#define FB_ACCEL_NEOMAGIC_NM2093 92	/* NeoMagic NM2093              */
+#define FB_ACCEL_NEOMAGIC_NM2097 93	/* NeoMagic NM2097              */
+#define FB_ACCEL_NEOMAGIC_NM2160 94	/* NeoMagic NM2160              */
+#define FB_ACCEL_NEOMAGIC_NM2200 95	/* NeoMagic NM2200              */
+#define FB_ACCEL_NEOMAGIC_NM2230 96	/* NeoMagic NM2230              */
+#define FB_ACCEL_NEOMAGIC_NM2360 97	/* NeoMagic NM2360              */
+#define FB_ACCEL_NEOMAGIC_NM2380 98	/* NeoMagic NM2380              */
+#define FB_ACCEL_EP9X            99     /* CirrusLogic EP9X family      */
+
+#define FB_ACCEL_SAVAGE4        0x80	/* S3 Savage4                   */
+#define FB_ACCEL_SAVAGE3D       0x81	/* S3 Savage3D                  */
+#define FB_ACCEL_SAVAGE3D_MV    0x82	/* S3 Savage3D-MV               */
+#define FB_ACCEL_SAVAGE2000     0x83	/* S3 Savage2000                */
+#define FB_ACCEL_SAVAGE_MX_MV   0x84	/* S3 Savage/MX-MV              */
+#define FB_ACCEL_SAVAGE_MX      0x85	/* S3 Savage/MX                 */
+#define FB_ACCEL_SAVAGE_IX_MV   0x86	/* S3 Savage/IX-MV              */
+#define FB_ACCEL_SAVAGE_IX      0x87	/* S3 Savage/IX                 */
+#define FB_ACCEL_PROSAVAGE_PM   0x88	/* S3 ProSavage PM133           */
+#define FB_ACCEL_PROSAVAGE_KM   0x89	/* S3 ProSavage KM133           */
+#define FB_ACCEL_S3TWISTER_P    0x8a	/* S3 Twister                   */
+#define FB_ACCEL_S3TWISTER_K    0x8b	/* S3 TwisterK                  */
+#define FB_ACCEL_SUPERSAVAGE    0x8c    /* S3 Supersavage               */
+#define FB_ACCEL_PROSAVAGE_DDR  0x8d	/* S3 ProSavage DDR             */
+#define FB_ACCEL_PROSAVAGE_DDRK 0x8e	/* S3 ProSavage DDR-K           */
+
+struct fb_fix_screeninfo {
+	char id[16];			/* identification string eg "TT Builtin" */
+	unsigned long smem_start;	/* Start of frame buffer mem */
+					/* (physical address) */
+	u32 smem_len;			/* Length of frame buffer mem */
+	u32 type;			/* see FB_TYPE_*		*/
+	u32 type_aux;			/* Interleave for interleaved Planes */
+	u32 visual;			/* see FB_VISUAL_*		*/
+	u16 xpanstep;			/* zero if no hardware panning  */
+	u16 ypanstep;			/* zero if no hardware panning  */
+	u16 ywrapstep;			/* zero if no hardware ywrap    */
+	u32 line_length;		/* length of a line in bytes    */
+	unsigned long mmio_start;	/* Start of Memory Mapped I/O   */
+					/* (physical address) */
+	u32 mmio_len;			/* Length of Memory Mapped I/O  */
+	u32 accel;			/* Indicate to driver which	*/
+					/*  specific chip/card we have	*/
+	u16 reserved[3];		/* Reserved for future compatibility */
+};
+
+/* Interpretation of offset for color fields: All offsets are from the right,
+ * inside a "pixel" value, which is exactly 'bits_per_pixel' wide (means: you
+ * can use the offset as right argument to <<). A pixel afterwards is a bit
+ * stream and is written to video memory as that unmodified. This implies
+ * big-endian byte order if bits_per_pixel is greater than 8.
+ */
+struct fb_bitfield {
+	u32 offset;			/* beginning of bitfield	*/
+	u32 length;			/* length of bitfield		*/
+	u32 msb_right;			/* != 0 : Most significant bit is */
+					/* right */ 
+};
+
+#define FB_NONSTD_HAM		1	/* Hold-And-Modify (HAM)        */
+
+#define FB_ACTIVATE_NOW		0	/* set values immediately (or vbl)*/
+#define FB_ACTIVATE_NXTOPEN	1	/* activate on next open	*/
+#define FB_ACTIVATE_TEST	2	/* don't set, round up impossible */
+#define FB_ACTIVATE_MASK       15
+					/* values			*/
+#define FB_ACTIVATE_VBL	       16	/* activate values on next vbl  */
+#define FB_CHANGE_CMAP_VBL     32	/* change colormap on vbl	*/
+#define FB_ACTIVATE_ALL	       64	/* change all VCs on this fb	*/
+#define FB_ACTIVATE_FORCE     128	/* force apply even when no change*/
+#define FB_ACTIVATE_INV_MODE  256       /* invalidate videomode */
+
+#define FB_ACCELF_TEXT		1	/* (OBSOLETE) see fb_info.flags and vc_mode */
+
+#define FB_SYNC_HOR_HIGH_ACT	1	/* horizontal sync high active	*/
+#define FB_SYNC_VERT_HIGH_ACT	2	/* vertical sync high active	*/
+#define FB_SYNC_EXT		4	/* external sync		*/
+#define FB_SYNC_COMP_HIGH_ACT	8	/* composite sync high active   */
+#define FB_SYNC_BROADCAST	16	/* broadcast video timings      */
+					/* vtotal = 144d/288n/576i => PAL  */
+					/* vtotal = 121d/242n/484i => NTSC */
+#define FB_SYNC_ON_GREEN	32	/* sync on green */
+
+#define FB_VMODE_NONINTERLACED  0	/* non interlaced */
+#define FB_VMODE_INTERLACED	1	/* interlaced	*/
+#define FB_VMODE_DOUBLE		2	/* double scan */
+#define FB_VMODE_MASK		255
+
+#define FB_VMODE_YWRAP		256	/* ywrap instead of panning     */
+#define FB_VMODE_SMOOTH_XPAN	512	/* smooth xpan possible (internally used) */
+#define FB_VMODE_CONUPDATE	512	/* don't update x/yoffset	*/
+
+/*
+ * Display rotation support
+ */
+#define FB_ROTATE_UR      0
+#define FB_ROTATE_CW      1
+#define FB_ROTATE_UD      2
+#define FB_ROTATE_CCW     3
+
+#define PICOS2KHZ(a) (1000000000UL/(a))
+#define KHZ2PICOS(a) (1000000000UL/(a))
+
+struct fb_var_screeninfo {
+	u32 xres;			/* visible resolution		*/
+	u32 yres;
+	u32 xres_virtual;		/* virtual resolution		*/
+	u32 yres_virtual;
+	u32 xoffset;			/* offset from virtual to visible */
+	u32 yoffset;			/* resolution			*/
+
+	u32 bits_per_pixel;		/* guess what			*/
+	u32 grayscale;			/* != 0 Graylevels instead of colors */
+
+	struct fb_bitfield red;		/* bitfield in fb mem if true color, */
+	struct fb_bitfield green;	/* else only length is significant */
+	struct fb_bitfield blue;
+	struct fb_bitfield transp;	/* transparency			*/	
+
+	u32 nonstd;			/* != 0 Non standard pixel format */
+
+	u32 activate;			/* see FB_ACTIVATE_*		*/
+
+	u32 height;			/* height of picture in mm    */
+	u32 width;			/* width of picture in mm     */
+
+	u32 accel_flags;		/* (OBSOLETE) see fb_info.flags */
+
+	/* Timing: All values in pixclocks, except pixclock (of course) */
+	u32 pixclock;			/* pixel clock in ps (pico seconds) */
+	u32 left_margin;		/* time from sync to picture	*/
+	u32 right_margin;		/* time from picture to sync	*/
+	u32 upper_margin;		/* time from sync to picture	*/
+	u32 lower_margin;
+	u32 hsync_len;			/* length of horizontal sync	*/
+	u32 vsync_len;			/* length of vertical sync	*/
+	u32 sync;			/* see FB_SYNC_*		*/
+	u32 vmode;			/* see FB_VMODE_*		*/
+	u32 rotate;			/* angle we rotate counter clockwise */
+	u32 reserved[5];		/* Reserved for future compatibility */
+};
+
+struct fb_cmap {
+	u32 start;			/* First entry	*/
+	u32 len;			/* Number of entries */
+	u16 *red;			/* Red values	*/
+	u16 *green;
+	u16 *blue;
+	u16 *transp;			/* transparency, can be NULL */
+};
+
+struct fb_con2fbmap {
+	u32 console;
+	u32 framebuffer;
+};
+
+/* VESA Blanking Levels */
+#define VESA_NO_BLANKING        0
+#define VESA_VSYNC_SUSPEND      1
+#define VESA_HSYNC_SUSPEND      2
+#define VESA_POWERDOWN          3
+
+
+enum {
+	/* screen: unblanked, hsync: on,  vsync: on */
+	FB_BLANK_UNBLANK       = VESA_NO_BLANKING,
+
+	/* screen: blanked,   hsync: on,  vsync: on */
+	FB_BLANK_NORMAL        = VESA_NO_BLANKING + 1,
+
+	/* screen: blanked,   hsync: on,  vsync: off */
+	FB_BLANK_VSYNC_SUSPEND = VESA_VSYNC_SUSPEND + 1,
+
+	/* screen: blanked,   hsync: off, vsync: on */
+	FB_BLANK_HSYNC_SUSPEND = VESA_HSYNC_SUSPEND + 1,
+
+	/* screen: blanked,   hsync: off, vsync: off */
+	FB_BLANK_POWERDOWN     = VESA_POWERDOWN + 1
+};
+
+#define FB_VBLANK_VBLANKING	0x001	/* currently in a vertical blank */
+#define FB_VBLANK_HBLANKING	0x002	/* currently in a horizontal blank */
+#define FB_VBLANK_HAVE_VBLANK	0x004	/* vertical blanks can be detected */
+#define FB_VBLANK_HAVE_HBLANK	0x008	/* horizontal blanks can be detected */
+#define FB_VBLANK_HAVE_COUNT	0x010	/* global retrace counter is available */
+#define FB_VBLANK_HAVE_VCOUNT	0x020	/* the vcount field is valid */
+#define FB_VBLANK_HAVE_HCOUNT	0x040	/* the hcount field is valid */
+#define FB_VBLANK_VSYNCING	0x080	/* currently in a vsync */
+#define FB_VBLANK_HAVE_VSYNC	0x100	/* verical syncs can be detected */
+
+struct fb_vblank {
+	u32 flags;			/* FB_VBLANK flags */
+	u32 count;			/* counter of retraces since boot */
+	u32 vcount;			/* current scanline position */
+	u32 hcount;			/* current scandot position */
+	u32 reserved[4];		/* reserved for future compatibility */
+};
+
+/* Internal HW accel */
+#define ROP_COPY 0
+#define ROP_XOR  1
+
+struct fb_copyarea {
+	u32 dx;
+	u32 dy;
+	u32 width;
+	u32 height;
+	u32 sx;
+	u32 sy;
+};
+
+struct fb_fillrect {
+	u32 dx;		/* screen-relative */
+	u32 dy;
+	u32 width;
+	u32 height;
+	u32 color;
+	u32 rop;
+};
+
+struct fb_image {
+	u32 dx;			/* Where to place image */
+	u32 dy;
+	u32 width;		/* Size of image */
+	u32 height;
+	u32 fg_color;		/* Only used when a mono bitmap */
+	u32 bg_color;
+	u8  depth;		/* Depth of the image */
+	const char *data;	/* Pointer to image data */
+	struct fb_cmap cmap;	/* color map info */
+};
+
+/*
+ * hardware cursor control
+ */
+
+#define FB_CUR_SETIMAGE 0x01
+#define FB_CUR_SETPOS   0x02
+#define FB_CUR_SETHOT   0x04
+#define FB_CUR_SETCMAP  0x08
+#define FB_CUR_SETSHAPE 0x10
+#define FB_CUR_SETSIZE	0x20
+#define FB_CUR_SETALL   0xFF
+
+struct fbcurpos {
+	u16 x, y;
+};
+
+struct fb_cursor {
+	u16 set;		/* what to set */
+	u16 enable;		/* cursor on/off */
+	u16 rop;		/* bitop operation */
+	const char *mask;	/* cursor mask bits */
+	struct fbcurpos hot;	/* cursor hot spot */
+	struct fb_image	image;	/* Cursor image */
+};
+
+#endif /* _LINUX_FB_H */
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/systems/stmfbdev/Makefile.am DirectFB-1.4.12+STM2011.09.27/systems/stmfbdev/Makefile.am
--- DirectFB/systems/stmfbdev/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/systems/stmfbdev/Makefile.am	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,39 @@
+## Makefile.am for DirectFB/systems/stmfbdev
+
+INCLUDES = \
+	-I$(top_builddir)/include	\
+	-I$(top_builddir)/lib		\
+	-I$(top_srcdir)/include		\
+	-I$(top_srcdir)/lib		\
+	-I$(top_srcdir)/src
+
+
+internalincludedir = $(INTERNALINCLUDEDIR)/stmfbdev
+
+internalinclude_HEADERS = \
+	fb.h			\
+	vt.h			\
+	stmfbdev.h
+
+systemsdir = $(MODULEDIR)/systems
+
+if BUILD_STATIC
+systems_DATA = libdirectfb_stmfbdev.o
+endif
+systems_LTLIBRARIES = libdirectfb_stmfbdev.la
+
+libdirectfb_stmfbdev_la_LDFLAGS = \
+	-avoid-version	\
+	-module
+
+libdirectfb_stmfbdev_la_SOURCES = \
+	vt.c				\
+	stmfbdev.c
+
+libdirectfb_stmfbdev_la_LIBADD = \
+	$(top_builddir)/lib/direct/libdirect.la \
+	$(top_builddir)/lib/fusion/libfusion.la \
+	$(top_builddir)/src/libdirectfb.la
+
+
+include $(top_srcdir)/rules/libobject.make
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/systems/stmfbdev/stmfbdev.c DirectFB-1.4.12+STM2011.09.27/systems/stmfbdev/stmfbdev.c
--- DirectFB/systems/stmfbdev/stmfbdev.c	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/systems/stmfbdev/stmfbdev.c	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,549 @@
+/*
+   (c) Copyright 2010       STMicroelectronics (R&D) Ltd.
+   (c) Copyright 2001-2009  The world wide DirectFB Open Source Community (directfb.org)
+   (c) Copyright 2000-2004  Convergence (integrated media) GmbH
+
+   All rights reserved.
+
+   Written by Andr Draszik <andre.draszik@st.com>.
+ 
+   Based on work by Denis Oliver Kropp <dok@directfb.org>,
+                    Andreas Hundt <andi@fischlustig.de>,
+                    Sven Neumann <neo@directfb.org>,
+                    Ville Syrjl <syrjala@sci.fi> and
+                    Claudio Ciccani <klan@users.sf.net>.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/kd.h>
+
+#include <directfb.h>
+
+#include <direct/mem.h>
+#include <direct/memcpy.h>
+#include <direct/signals.h>
+
+#include <fusion/fusion.h>
+#include <fusion/arena.h>
+#include <fusion/shmalloc.h>
+#include <fusion/call.h>
+
+#include <core/core.h>
+#include <core/surface_pool.h>
+#include <core/screens.h>
+#include <core/layers.h>
+
+#include <misc/conf.h>
+
+#include "stmfbdev.h"
+#include "fb.h"
+
+
+#include <core/core_system.h>
+
+DFB_CORE_SYSTEM( stmfbdev )
+
+D_DEBUG_DOMAIN( STMfbdev_System, "STMfbdev/System", "STMfb System Module" );
+
+/**********************************************************************************************************************/
+
+STMfbdev *dfb_stmfbdev;
+
+/**********************************************************************************************************************/
+
+static DFBResult
+dfb_stmfbdev_open( STMfbdev * const stmfbdev )
+{
+     mode_t mode = O_RDWR;
+#ifdef O_CLOEXEC
+     /* should be closed automatically in children upon exec(...), but is
+        only available since Linux 2.6.23 */
+     mode |= O_CLOEXEC;
+#endif
+
+     D_MAGIC_ASSERT( stmfbdev, STMfbdev );
+     D_ASSERT( stmfbdev->fd < 0 );
+
+     if (dfb_config->fb_device) {
+          stmfbdev->fd = open( dfb_config->fb_device, mode );
+          if (stmfbdev->fd < 0) {
+               D_PERROR( "DirectFB/STMfbdev: Error opening '%s'!\n",
+                         dfb_config->fb_device);
+
+               return errno2result( errno );
+          }
+     }
+     else if (getenv( "FRAMEBUFFER" ) && *getenv( "FRAMEBUFFER" ) != '\0') {
+          stmfbdev->fd = open( getenv ( "FRAMEBUFFER" ), mode );
+          if (stmfbdev->fd < 0) {
+               D_PERROR( "DirectFB/STMfbdev: Error opening '%s'!\n",
+                          getenv( "FRAMEBUFFER" ) );
+
+               return errno2result( errno );
+          }
+     }
+     else {
+          stmfbdev->fd = direct_try_open( "/dev/fb0", "/dev/fb/0", mode, true );
+          if (stmfbdev->fd < 0) {
+               D_ERROR( "DirectFB/STMfbdev: Error opening framebuffer device!\n" );
+               D_ERROR( "DirectFB/STMfbdev: Use 'fbdev' option or set FRAMEBUFFER environment variable.\n" );
+               return DFB_INIT;
+          }
+     }
+
+#ifndef O_CLOEXEC
+     if (fcntl( stmfbdev->fd, F_SETFD, FD_CLOEXEC ) < 0) {
+          D_PERROR( "DirectFB/STMfbdev: Setting FD_CLOEXEC flag failed!\n" );
+          return errno2result( errno );
+     }
+#endif
+
+     return DFB_OK;
+}
+
+
+
+
+static void
+system_get_info( CoreSystemInfo *info )
+{
+     info->version.major = 0;
+     info->version.minor = 9;
+
+     info->type = CORE_STMFBDEV;
+     info->caps = CSCAPS_ACCELERATION;
+
+     snprintf( info->name, sizeof (info->name), "STMfbdev" );
+     snprintf( info->vendor, sizeof (info->vendor), "STMicroelectronics (R&D) Ltd." );
+     snprintf( info->url, sizeof (info->url), "http://www.stlinux.com" );
+     snprintf( info->license, sizeof (info->license), "LGPL" );
+}
+
+static DFBResult
+system_initialize( CoreDFB *core, void **data )
+{
+     DFBResult            ret;
+     long                 page_size;
+     STMfbdevSharedData  *shared;
+     FusionSHMPoolShared *shmpool;
+     STMfbdev            *stmfbdev;
+
+     D_DEBUG_AT( STMfbdev_System, "%s()\n", __FUNCTION__ );
+
+     D_ASSERT( dfb_stmfbdev == NULL );
+
+     shmpool = dfb_core_shmpool( core );
+
+     *data = dfb_stmfbdev = stmfbdev = D_CALLOC( 1, sizeof(STMfbdev) );
+     if (!stmfbdev)
+          return D_OOM();
+
+     D_MAGIC_SET( stmfbdev, STMfbdev );
+     stmfbdev->fd = -1;
+
+     shared = (STMfbdevSharedData *) SHCALLOC( shmpool, 1,
+                                               sizeof(STMfbdevSharedData) );
+     if (!shared) {
+          ret = D_OOSHM();
+          goto error;
+     }
+
+     D_MAGIC_SET( shared, STMfbdevSharedData );
+
+     shared->shmpool = shmpool;
+
+     fusion_arena_add_shared_field( dfb_core_arena( core ), "stmfbdev", shared );
+
+     stmfbdev->core   = core;
+     stmfbdev->shared = shared;
+
+     page_size = direct_pagesize();
+     shared->page_mask = page_size < 0 ? 0 : (page_size - 1);
+
+     ret = dfb_stmfbdev_open( stmfbdev );
+     if (ret)
+          goto error;
+
+     if (dfb_config->vt) {
+          ret = dfb_vt_initialize();
+          if (ret)
+               goto error;
+     }
+
+     /* Retrieve fixed information like video ram size */
+     if (ioctl( stmfbdev->fd, FBIOGET_FSCREENINFO, &shared->fix ) < 0) {
+          D_PERROR( "DirectFB/STMfbdev: "
+                    "Could not get fixed screen information!\n" );
+          ret = errno2result( errno );
+          goto error;
+     }
+
+     D_INFO( "DirectFB/STMfbdev: Found '%s' (ID %d) with frame buffer at 0x%08lx, %dk (MMIO 0x%08lx, %dk)\n",
+             shared->fix.id, shared->fix.accel,
+             shared->fix.smem_start, shared->fix.smem_len >> 10,
+             shared->fix.mmio_start, shared->fix.mmio_len >> 10 );
+
+     /* Map the framebuffer */
+     stmfbdev->framebuffer_base = mmap( NULL, shared->fix.smem_len,
+                                        PROT_READ | PROT_WRITE, MAP_SHARED,
+                                        stmfbdev->fd, 0 );
+     if (stmfbdev->framebuffer_base == MAP_FAILED) {
+          D_PERROR( "DirectFB/STMfbdev: "
+                    "Could not mmap the framebuffer!\n");
+          stmfbdev->framebuffer_base = NULL;
+          ret = errno2result( errno );
+          goto error;
+     }
+
+     return DFB_OK;
+
+
+error:
+     if (shared)
+          SHFREE( shmpool, shared );
+
+     if (stmfbdev->framebuffer_base)
+          munmap( stmfbdev->framebuffer_base, shared->fix.smem_len );
+
+     if (stmfbdev->fd != -1)
+          close( stmfbdev->fd );
+
+     D_FREE( stmfbdev );
+     *data = dfb_stmfbdev = NULL;
+
+     return ret;
+}
+
+static DFBResult
+system_join( CoreDFB *core, void **data )
+{
+     DFBResult  ret;
+     STMfbdev  *stmfbdev;
+     void      *shared;
+
+     D_DEBUG_AT( STMfbdev_System, "%s()\n", __FUNCTION__ );
+
+     D_ASSERT( dfb_stmfbdev == NULL );
+
+     *data = dfb_stmfbdev = stmfbdev = D_CALLOC( 1, sizeof(STMfbdev) );
+     if (!stmfbdev)
+          return D_OOM();
+
+     D_MAGIC_SET( stmfbdev, STMfbdev );
+     stmfbdev->fd = -1;
+
+     fusion_arena_get_shared_field( dfb_core_arena( core ),
+                                    "stmfbdev", &shared );
+     stmfbdev->shared = shared;
+     D_MAGIC_ASSERT( stmfbdev->shared, STMfbdevSharedData );
+
+     stmfbdev->core = core;
+
+     /* Open framebuffer device */
+     ret = dfb_stmfbdev_open( stmfbdev );
+     if (ret)
+          goto error;
+
+     if (dfb_config->vt) {
+          ret = dfb_vt_join();
+          if (ret)
+               goto error;
+     }
+
+     /* Map the framebuffer */
+     stmfbdev->framebuffer_base = mmap( NULL, stmfbdev->shared->fix.smem_len,
+                                        PROT_READ | PROT_WRITE, MAP_SHARED,
+                                        stmfbdev->fd, 0 );
+     if (stmfbdev->framebuffer_base == MAP_FAILED) {
+          D_PERROR( "DirectFB/STMfbdev: "
+                    "Could not mmap the framebuffer!\n");
+          stmfbdev->framebuffer_base = NULL;
+          ret = errno2result( errno );
+          goto error;
+     }
+
+     return DFB_OK;
+
+
+error:
+     if (stmfbdev->fd != -1)
+          close( stmfbdev->fd );
+
+     D_FREE( stmfbdev );
+     *data = dfb_stmfbdev = NULL;
+
+     return ret;
+}
+
+static DFBResult
+system_shutdown( bool emergency )
+{
+     DFBResult ret;
+
+     D_DEBUG_AT( STMfbdev_System, "%s()\n", __FUNCTION__ );
+
+     D_MAGIC_ASSERT( dfb_stmfbdev, STMfbdev );
+     D_MAGIC_ASSERT( dfb_stmfbdev->shared, STMfbdevSharedData );
+
+     munmap( dfb_stmfbdev->framebuffer_base,
+             dfb_stmfbdev->shared->fix.smem_len );
+
+     if (dfb_config->vt) {
+          ret = dfb_vt_shutdown( emergency );
+          if (ret)
+               return ret;
+     }
+
+     close( dfb_stmfbdev->fd );
+
+     D_MAGIC_CLEAR( dfb_stmfbdev->shared );
+     D_MAGIC_CLEAR( dfb_stmfbdev );
+
+     SHFREE( dfb_stmfbdev->shared->shmpool, dfb_stmfbdev->shared );
+     D_FREE( dfb_stmfbdev );
+     dfb_stmfbdev = NULL;
+
+     return DFB_OK;
+}
+
+static DFBResult
+system_leave( bool emergency )
+{
+     DFBResult ret;
+
+     D_DEBUG_AT( STMfbdev_System, "%s()\n", __FUNCTION__ );
+
+     D_MAGIC_ASSERT( dfb_stmfbdev, STMfbdev );
+     D_MAGIC_ASSERT( dfb_stmfbdev->shared, STMfbdevSharedData );
+
+     munmap( dfb_stmfbdev->framebuffer_base,
+             dfb_stmfbdev->shared->fix.smem_len );
+
+     if (dfb_config->vt) {
+          ret = dfb_vt_leave( emergency );
+          if (ret)
+               return ret;
+     }
+
+     close( dfb_stmfbdev->fd );
+
+     D_MAGIC_CLEAR( dfb_stmfbdev );
+
+     D_FREE( dfb_stmfbdev );
+     dfb_stmfbdev = NULL;
+
+     return DFB_OK;
+}
+
+static DFBResult
+system_suspend( void )
+{
+     return DFB_OK;
+}
+
+static DFBResult
+system_resume( void )
+{
+     return DFB_OK;
+}
+
+/******************************************************************************/
+
+static volatile void *
+system_map_mmio( unsigned int    offset,
+                 int             length )
+{
+     void *addr;
+
+     D_MAGIC_ASSERT( dfb_stmfbdev, STMfbdev );
+
+     if (length <= 0)
+          length = dfb_stmfbdev->shared->fix.mmio_len;
+
+     addr = mmap( NULL, length, PROT_READ | PROT_WRITE, MAP_SHARED,
+                  dfb_stmfbdev->fd,
+                  dfb_stmfbdev->shared->fix.smem_len + offset );
+     if (addr == MAP_FAILED) {
+          D_PERROR( "DirectFB/STMfbdev: Could not mmap MMIO region "
+                     "(offset %d, length %d)!\n", offset, length );
+          return NULL;
+     }
+
+     return(volatile void*) ((u8*) addr + (dfb_stmfbdev->shared->fix.mmio_start
+                                           & dfb_stmfbdev->shared->page_mask));
+}
+
+static void
+system_unmap_mmio( volatile void  *addr,
+                   int             length )
+{
+     D_MAGIC_ASSERT( dfb_stmfbdev, STMfbdev );
+
+     if (length <= 0)
+          length = dfb_stmfbdev->shared->fix.mmio_len;
+
+     if (munmap( (void*) ((u8*) addr - (dfb_stmfbdev->shared->fix.mmio_start
+                                        & dfb_stmfbdev->shared->page_mask)),
+                 length ) < 0)
+          D_PERROR( "DirectFB/STMfbdev: Could not unmap MMIO region "
+                     "at %p (length %d)!\n", addr, length );
+}
+
+static int
+system_get_accelerator( void )
+{
+     D_MAGIC_ASSERT( dfb_stmfbdev, STMfbdev );
+
+     if (dfb_config->accelerator)
+          return dfb_config->accelerator;
+
+     return dfb_stmfbdev->shared->fix.accel;
+}
+
+static VideoMode *
+system_get_modes( void )
+{
+     return NULL;
+}
+
+static VideoMode *
+system_get_current_mode( void )
+{
+     return NULL;
+}
+
+static DFBResult
+system_thread_init( void )
+{
+     if (dfb_config->block_all_signals)
+          direct_signals_block_all();
+
+     return DFB_OK;
+}
+
+static bool
+system_input_filter( CoreInputDevice *device,
+                     DFBInputEvent   *event )
+{
+     if (dfb_config->vt && dfb_config->vt_switching) {
+          switch (event->type) {
+               case DIET_KEYPRESS:
+                    if (DFB_KEY_TYPE(event->key_symbol) == DIKT_FUNCTION &&
+                        event->modifiers == (DIMM_CONTROL | DIMM_ALT))
+                         return dfb_vt_switch( event->key_symbol - DIKS_F1 + 1 );
+
+                    break;
+
+               case DIET_KEYRELEASE:
+                    if (DFB_KEY_TYPE(event->key_symbol) == DIKT_FUNCTION &&
+                        event->modifiers == (DIMM_CONTROL | DIMM_ALT))
+                         return true;
+
+                    break;
+
+               default:
+                    break;
+          }
+     }
+
+     return false;
+}
+
+static unsigned long
+system_video_memory_physical( unsigned int offset )
+{
+     D_MAGIC_ASSERT( dfb_stmfbdev, STMfbdev );
+
+     return dfb_stmfbdev->shared->fix.smem_start + offset;
+}
+
+static void *
+system_video_memory_virtual( unsigned int offset )
+{
+     D_MAGIC_ASSERT( dfb_stmfbdev, STMfbdev );
+
+     return(void*)((u8*)(dfb_stmfbdev->framebuffer_base) + offset);
+}
+
+static unsigned int
+system_videoram_length( void )
+{
+     D_MAGIC_ASSERT( dfb_stmfbdev, STMfbdev );
+
+     return dfb_stmfbdev->shared->fix.smem_len;
+}
+
+static unsigned long
+system_aux_memory_physical( unsigned int offset )
+{
+     return 0;
+}
+
+static void *
+system_aux_memory_virtual( unsigned int offset )
+{
+     return NULL;
+}
+
+static unsigned int
+system_auxram_length( void )
+{
+     return 0;
+}
+
+static void
+system_get_busid( int *ret_bus, int *ret_dev, int *ret_func )
+{
+     return;
+}
+
+static void
+system_get_deviceid( unsigned int *ret_vendor_id,
+                     unsigned int *ret_device_id )
+{
+     *ret_vendor_id = 0x104a; /* STMicroelectronics */
+
+     return;
+}
+
+static int
+system_surface_data_size( void )
+{
+     /* Return zero because shared surface data is unneeded. */
+     return 0;
+}
+
+static void
+system_surface_data_init( CoreSurface *surface, void *data )
+{
+     /* Ignore since unneeded. */
+}
+
+static void
+system_surface_data_destroy( CoreSurface *surface, void *data )
+{
+     /* Ignore since unneeded. */
+}
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/systems/stmfbdev/stmfbdev.h DirectFB-1.4.12+STM2011.09.27/systems/stmfbdev/stmfbdev.h
--- DirectFB/systems/stmfbdev/stmfbdev.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/systems/stmfbdev/stmfbdev.h	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,71 @@
+/*
+   (c) Copyright 2010       STMicroelectronics (R&D) Ltd.
+   (c) Copyright 2001-2009  The world wide DirectFB Open Source Community (directfb.org)
+   (c) Copyright 2000-2004  Convergence (integrated media) GmbH
+
+   All rights reserved.
+
+   Written by Andr Draszik <andre.draszik@st.com>.
+ 
+   Based on work by Denis Oliver Kropp <dok@directfb.org>,
+                    Andreas Hundt <andi@fischlustig.de>,
+                    Sven Neumann <neo@directfb.org>,
+                    Ville Syrjl <syrjala@sci.fi> and
+                    Claudio Ciccani <klan@users.sf.net>.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#ifndef __STMFBDEV__STMFBDEV_H__
+#define __STMFBDEV__STMFBDEV_H__
+
+#include <core/system.h>
+
+#include <fusion/shmalloc.h>
+
+#include <core/surface_pool.h>
+
+#include "fb.h"
+#include "vt.h"
+
+
+typedef struct {
+     int magic;
+
+     struct fb_fix_screeninfo fix; /* fbdev fixed screeninfo, contains info
+                                      about memory and type of card */
+
+     int        num_screens;
+     int        num_layers;
+
+     unsigned long page_mask;
+
+     FusionSHMPoolShared *shmpool;
+} STMfbdevSharedData;
+
+typedef struct {
+     int magic;
+
+     CoreDFB *core;
+
+     STMfbdevSharedData *shared;
+     int                 fd;
+     void               *framebuffer_base;
+     VirtualTerminal    *vt;
+} STMfbdev;
+
+
+#endif /* __STMFBDEV__STMFBDEV_H__ */
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/systems/stmfbdev/vt.c DirectFB-1.4.12+STM2011.09.27/systems/stmfbdev/vt.c
--- DirectFB/systems/stmfbdev/vt.c	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/systems/stmfbdev/vt.c	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,675 @@
+/*
+   (c) Copyright 2001-2009  The world wide DirectFB Open Source Community (directfb.org)
+   (c) Copyright 2000-2004  Convergence (integrated media) GmbH
+
+   All rights reserved.
+
+   Written by Denis Oliver Kropp <dok@directfb.org>,
+              Andreas Hundt <andi@fischlustig.de>,
+              Sven Neumann <neo@directfb.org>,
+              Ville Syrjl <syrjala@sci.fi> and
+              Claudio Ciccani <klan@users.sf.net>.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+
+#include <asm/types.h>    /* Needs to be included before dfb_types.h */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/vt.h>
+#include <sys/kd.h>
+#include <errno.h>
+#include <pthread.h>
+
+#include <directfb.h>
+
+#include <misc/conf.h>
+#include <misc/util.h>
+
+#include <direct/debug.h>
+#include <direct/mem.h>
+#include <direct/messages.h>
+#include <direct/thread.h>
+#include <direct/util.h>
+
+#include <core/core.h>
+#include <core/coredefs.h>
+#include <core/coretypes.h>
+#include <core/gfxcard.h>
+
+#include "stmfbdev.h"
+#include "fb.h"
+#include "vt.h"
+
+D_DEBUG_DOMAIN( VT, "STMfbdev/VT", "STMfbdev System Module VT Handling" );
+
+/*
+ *  FIXME: the following looks like a bad hack.
+ *
+ *  SIGUNUSED is no longer unused, but is defined for backwards compatibility.
+ *  sparc, mips and alpha signal.h however do not define SIGUNUSED.
+ */
+
+#ifdef SIGUNUSED
+     #define SIG_SWITCH_FROM  (SIGUNUSED + 10)
+     #define SIG_SWITCH_TO    (SIGUNUSED + 11)
+#else
+     #define SIG_SWITCH_FROM  (31 + 10)
+     #define SIG_SWITCH_TO    (31 + 11)
+#endif
+
+#ifndef SI_KERNEL
+/* glibc 2.1.x doesn't have this in /usr/include/bits/siginfo.h */
+     #define SI_KERNEL 0x80
+#endif
+
+
+extern STMfbdev *dfb_stmfbdev;
+
+static VirtualTerminal *dfb_vt = NULL;
+
+static DFBResult vt_init_switching( void );
+static int       vt_get_fb( int vt );
+static void      vt_set_fb( int vt, int fb );
+static void     *vt_thread( DirectThread *thread, void *arg );
+
+static void      vt_start_flushing( void );
+static void      vt_stop_flushing( void );
+static void     *vt_flush_thread( DirectThread *thread, void *arg );
+
+DFBResult
+dfb_vt_initialize( void )
+{
+     DFBResult ret;
+     struct vt_stat vs;
+
+     D_DEBUG_AT( VT, "%s()\n", __FUNCTION__ );
+
+     dfb_vt = D_CALLOC( 1, sizeof(VirtualTerminal) );
+     if (!dfb_vt)
+          return D_OOM();
+
+     setsid();
+     dfb_vt->fd0 = open( "/dev/tty0", O_RDONLY | O_NOCTTY );
+     if (dfb_vt->fd0 < 0) {
+          if (errno == ENOENT) {
+               dfb_vt->fd0 = open( "/dev/vc/0", O_RDONLY | O_NOCTTY );
+               if (dfb_vt->fd0 < 0) {
+                    if (errno == ENOENT) {
+                         D_PERROR( "DirectFB/core/vt: Couldn't open "
+                                    "neither `/dev/tty0' nor `/dev/vc/0'!\n" );
+                    }
+                    else {
+                         D_PERROR( "DirectFB/core/vt: "
+                                    "Error opening `/dev/vc/0'!\n" );
+                    }
+
+                    D_FREE( dfb_vt );
+                    dfb_vt = NULL;
+
+                    return DFB_INIT;
+               }
+          }
+          else {
+               D_PERROR( "DirectFB/core/vt: Error opening `/dev/tty0'!\n");
+
+               D_FREE( dfb_vt );
+               dfb_vt = NULL;
+
+               return DFB_INIT;
+          }
+     }
+
+     if (ioctl( dfb_vt->fd0, VT_GETSTATE, &vs ) < 0) {
+          D_PERROR( "DirectFB/core/vt: VT_GETSTATE failed!\n" );
+          close( dfb_vt->fd0 );
+          D_FREE( dfb_vt );
+          dfb_vt = NULL;
+          return DFB_INIT;
+     }
+
+     dfb_vt->prev = vs.v_active;
+
+
+     if (!dfb_config->vt_switch) {
+          if (dfb_config->vt_num != -1)
+               dfb_vt->num = dfb_config->vt_num;
+          else
+               dfb_vt->num = dfb_vt->prev;
+
+          /* move vt to framebuffer */
+          dfb_vt->old_fb = vt_get_fb( dfb_vt->num );
+          vt_set_fb( dfb_vt->num, -1 );
+     }
+     else {
+          if (dfb_config->vt_num == -1) {
+               int n;
+
+               n = ioctl( dfb_vt->fd0, VT_OPENQRY, &dfb_vt->num );
+               if (n < 0 || dfb_vt->num == -1) {
+                    D_PERROR( "DirectFB/core/vt: Cannot allocate VT!\n" );
+                    close( dfb_vt->fd0 );
+                    D_FREE( dfb_vt );
+                    dfb_vt = NULL;
+                    return DFB_INIT;
+               }
+          }
+          else {
+               dfb_vt->num = dfb_config->vt_num;
+          }
+
+          /* move vt to framebuffer */
+          dfb_vt->old_fb = vt_get_fb( dfb_vt->num );
+          vt_set_fb( dfb_vt->num, -1 );
+
+          /* switch to vt */
+          while (ioctl( dfb_vt->fd0, VT_ACTIVATE, dfb_vt->num ) < 0) {
+               if (errno == EINTR)
+                    continue;
+               D_PERROR( "DirectFB/core/vt: VT_ACTIVATE failed!\n" );
+               close( dfb_vt->fd0 );
+               D_FREE( dfb_vt );
+               dfb_vt = NULL;
+               return DFB_INIT;
+          }
+
+          while (ioctl( dfb_vt->fd0, VT_WAITACTIVE, dfb_vt->num ) < 0) {
+               if (errno == EINTR)
+                    continue;
+               D_PERROR( "DirectFB/core/vt: VT_WAITACTIVE failed!\n" );
+               close( dfb_vt->fd0 );
+               D_FREE( dfb_vt );
+               dfb_vt = NULL;
+               return DFB_INIT;
+          }
+
+          usleep( 40000 );
+     }
+
+     ret = vt_init_switching();
+     if (ret) {
+          if (dfb_config->vt_switch) {
+               D_DEBUG_AT( VT, "  -> switching back...\n" );
+               ioctl( dfb_vt->fd0, VT_ACTIVATE, dfb_vt->prev );
+               ioctl( dfb_vt->fd0, VT_WAITACTIVE, dfb_vt->prev );
+               D_DEBUG_AT( VT, "  -> ...switched back\n" );
+               ioctl( dfb_vt->fd0, VT_DISALLOCATE, dfb_vt->num );
+          }
+
+          close( dfb_vt->fd0 );
+          D_FREE( dfb_vt );
+          dfb_vt = NULL;
+          return ret;
+     }
+
+     vt_start_flushing();
+
+     dfb_stmfbdev->vt = dfb_vt;
+
+     return DFB_OK;
+}
+
+DFBResult
+dfb_vt_join( void )
+{
+     D_DEBUG_AT( VT, "%s()\n", __FUNCTION__ );
+
+     dfb_vt_detach( true );
+
+     return DFB_OK;
+}
+
+DFBResult
+dfb_vt_shutdown( bool emergency )
+{
+     const char cursoron_str[] = "\033[?0;0;0c";
+     const char blankon_str[] = "\033[9;10]";
+
+     D_DEBUG_AT( VT, "%s()\n", __FUNCTION__ );
+
+     if (!dfb_vt)
+          return DFB_OK;
+
+     vt_stop_flushing();
+
+     if (dfb_config->vt_switching) {
+          if (ioctl( dfb_vt->fd, VT_SETMODE, &dfb_vt->vt_mode ) < 0)
+               D_PERROR( "DirectFB/fbdev/vt: Unable to restore VT mode!!!\n" );
+
+          sigaction( SIG_SWITCH_FROM, &dfb_vt->sig_usr1, NULL );
+          sigaction( SIG_SWITCH_TO, &dfb_vt->sig_usr2, NULL );
+
+          direct_thread_cancel( dfb_vt->thread );
+          direct_thread_join( dfb_vt->thread );
+          direct_thread_destroy( dfb_vt->thread );
+
+          pthread_mutex_destroy( &dfb_vt->lock );
+          pthread_cond_destroy( &dfb_vt->wait );
+     }
+
+     if (dfb_config->kd_graphics) {
+          if (ioctl( dfb_vt->fd, KDSETMODE, KD_TEXT ) < 0)
+               D_PERROR( "DirectFB/fbdev/vt: KD_TEXT failed!\n" );
+     }
+     else {
+          write( dfb_vt->fd, blankon_str, sizeof(blankon_str) );
+     }
+     write( dfb_vt->fd, cursoron_str, sizeof(cursoron_str) );
+
+     if (tcsetattr( dfb_vt->fd, TCSAFLUSH, &dfb_vt->old_ts ) < 0)
+          D_PERROR("DirectFB/fbdev/vt: tcsetattr for original values failed!\n");
+
+     if (ioctl( dfb_vt->fd, KDSKBMODE, K_XLATE ) < 0)
+          D_PERROR( "DirectFB/fbdev/vt: K_XLATE failed!\n" );
+
+     if (dfb_config->vt_switch) {
+          D_DEBUG_AT( VT, "  -> switching back...\n" );
+
+          if (ioctl( dfb_vt->fd0, VT_ACTIVATE, dfb_vt->prev ) < 0)
+               D_PERROR( "DirectFB/core/vt: VT_ACTIVATE" );
+
+          if (ioctl( dfb_vt->fd0, VT_WAITACTIVE, dfb_vt->prev ) < 0)
+               D_PERROR( "DirectFB/core/vt: VT_WAITACTIVE" );
+
+          D_DEBUG_AT( VT, "  -> switched back...\n" );
+
+          usleep( 40000 );
+
+          /* restore con2fbmap */
+          vt_set_fb( dfb_vt->num, dfb_vt->old_fb );
+
+          if (close( dfb_vt->fd ) < 0)
+               D_PERROR( "DirectFB/core/vt: Unable to "
+                          "close file descriptor of allocated VT!\n" );
+
+          if (ioctl( dfb_vt->fd0, VT_DISALLOCATE, dfb_vt->num ) < 0)
+               D_PERROR( "DirectFB/core/vt: Unable to disallocate VT!\n" );
+     }
+     else {
+          /* restore con2fbmap */
+          vt_set_fb( dfb_vt->num, dfb_vt->old_fb );
+
+          if (close( dfb_vt->fd ) < 0)
+               D_PERROR( "DirectFB/core/vt: Unable to "
+                          "close file descriptor of current VT!\n" );
+     }
+
+     if (close( dfb_vt->fd0 ) < 0)
+          D_PERROR( "DirectFB/core/vt: Unable to "
+                     "close file descriptor of tty0!\n" );
+
+     D_FREE( dfb_vt );
+     dfb_vt = dfb_stmfbdev->vt = NULL;
+
+     return DFB_OK;
+}
+
+DFBResult
+dfb_vt_leave( bool emergency )
+{
+     D_DEBUG_AT( VT, "%s()\n", __FUNCTION__ );
+
+     return DFB_OK;
+}
+
+DFBResult
+dfb_vt_detach( bool force )
+{
+     D_DEBUG_AT( VT, "%s()\n", __FUNCTION__ );
+
+     if (dfb_config->vt_switch || force) {
+          int            fd;
+          struct vt_stat vt_state;
+
+          fd = open( "/dev/tty", O_RDONLY | O_NOCTTY );
+          if (fd < 0) {
+               if (errno == ENXIO)
+                    return DFB_OK;
+
+               D_PERROR( "DirectFB/VT: Opening /dev/tty failed!\n" );
+               return errno2result( errno );
+          }
+
+          if (ioctl( fd, VT_GETSTATE, &vt_state )) {
+               close( fd );
+               return DFB_OK;
+          }
+
+          if (ioctl( fd, TIOCNOTTY )) {
+               D_PERROR( "DirectFB/VT: TIOCNOTTY on /dev/tty failed\n" );
+               close( fd );
+               return errno2result( errno );
+          }
+
+          close( fd );
+     }
+
+     return DFB_OK;
+}
+
+bool
+dfb_vt_switch( int num )
+{
+     D_DEBUG_AT( VT, "%s( %d )\n", __FUNCTION__, num );
+
+     if (!dfb_config->vt_switching)
+          return false;
+
+     D_DEBUG_AT( VT, "  -> switching to vt %d...\n", num );
+
+     if (ioctl( dfb_vt->fd0, VT_ACTIVATE, num ) < 0)
+          D_PERROR( "DirectFB/fbdev/vt: VT_ACTIVATE failed\n" );
+
+     return true;
+}
+
+static void *
+vt_thread( DirectThread *thread, void *arg )
+{
+     D_DEBUG_AT( VT, "%s( %p, %p )\n", __FUNCTION__, thread, arg );
+
+     pthread_mutex_lock( &dfb_vt->lock );
+
+     while (true) {
+          direct_thread_testcancel( thread );
+
+          D_DEBUG_AT( VT, "...%s (signal %d)\n", __FUNCTION__, dfb_vt->vt_sig);
+
+          switch (dfb_vt->vt_sig) {
+               default:
+                    D_BUG( "unexpected vt_sig" );
+                    /* fall through */
+
+               case -1:
+                    pthread_cond_wait( &dfb_vt->wait, &dfb_vt->lock );
+                    continue;
+
+               case SIG_SWITCH_FROM:
+                    if (dfb_core_suspend( dfb_stmfbdev->core ) == DFB_OK) {
+                         if (ioctl( dfb_vt->fd, VT_RELDISP, VT_ACKACQ ) < 0)
+                              D_PERROR( "DirectFB/fbdev/vt: VT_RELDISP failed\n" );
+                    }
+
+                    break;
+
+               case SIG_SWITCH_TO:
+                    if (dfb_core_resume( dfb_stmfbdev->core ) == DFB_OK) {
+                         if (ioctl( dfb_vt->fd, VT_RELDISP, VT_ACKACQ ) < 0)
+                              D_PERROR( "DirectFB/fbdev/vt: VT_RELDISP failed\n" );
+
+                         if (dfb_config->kd_graphics) {
+                              if (ioctl( dfb_vt->fd, KDSETMODE, KD_GRAPHICS ) < 0)
+                                   D_PERROR( "DirectFB/fbdev/vt: KD_GRAPHICS failed!\n" );
+                         }
+                    }
+
+                    break;
+          }
+
+          dfb_vt->vt_sig = -1;
+
+          pthread_cond_signal( &dfb_vt->wait );
+     }
+
+     return NULL;
+}
+
+static void
+vt_switch_handler( int signum )
+{
+     D_DEBUG_AT( VT, "%s( %d )\n", __FUNCTION__, signum );
+
+     pthread_mutex_lock( &dfb_vt->lock );
+
+     while (dfb_vt->vt_sig != -1)
+          pthread_cond_wait( &dfb_vt->wait, &dfb_vt->lock );
+
+     dfb_vt->vt_sig = signum;
+
+     pthread_cond_signal( &dfb_vt->wait );
+
+     pthread_mutex_unlock( &dfb_vt->lock );
+}
+
+static DFBResult
+vt_init_switching( void )
+{
+     struct termios ts;
+     const char cursoroff_str[] = "\033[?1;0;0c";
+     const char blankoff_str[] = "\033[9;0]";
+     char buf[32];
+
+     D_DEBUG_AT( VT, "%s()\n", __FUNCTION__ );
+
+     /* FIXME: Opening the device should be moved out of this function. */
+
+     snprintf(buf, 32, "/dev/tty%d", dfb_vt->num);
+     dfb_vt->fd = open( buf, O_RDWR | O_NOCTTY );
+     if (dfb_vt->fd < 0) {
+          if (errno == ENOENT) {
+               snprintf(buf, 32, "/dev/vc/%d", dfb_vt->num);
+               dfb_vt->fd = open( buf, O_RDWR | O_NOCTTY );
+               if (dfb_vt->fd < 0) {
+                    if (errno == ENOENT) {
+                         D_PERROR( "DirectFB/core/vt: Couldn't open "
+                                    "neither `/dev/tty%d' nor `/dev/vc/%d'!\n",
+                                    dfb_vt->num, dfb_vt->num );
+                    }
+                    else {
+                         D_PERROR( "DirectFB/core/vt: "
+                                    "Error opening `%s'!\n", buf );
+                    }
+
+                    return errno2result( errno );
+               }
+          }
+          else {
+               D_PERROR( "DirectFB/core/vt: Error opening `%s'!\n", buf );
+               return errno2result( errno );
+          }
+     }
+
+     /* attach to the new TTY before doing anything like KDSETMODE with it,
+        otherwise we'd get access denied error: */
+     ioctl( dfb_vt->fd, TIOCSCTTY, 0 );
+
+     if (ioctl( dfb_vt->fd, KDSKBMODE, K_MEDIUMRAW ) < 0) {
+          D_PERROR( "DirectFB/fbdev/vt: K_MEDIUMRAW failed!\n" );
+          close( dfb_vt->fd );
+          return DFB_INIT;
+     }
+
+     if (tcgetattr( dfb_vt->fd, &dfb_vt->old_ts ) < 0) {
+          D_PERROR( "DirectFB/fbdev/vt: tcgetattr failed!\n" );
+          ioctl( dfb_vt->fd, KDSKBMODE, K_XLATE );
+          close( dfb_vt->fd );
+          return DFB_INIT;
+     }
+     ts = dfb_vt->old_ts;
+     ts.c_cc[VTIME] = 0;
+     ts.c_cc[VMIN] = 1;
+     ts.c_lflag &= ~(ICANON|ECHO|ISIG);
+     ts.c_iflag = 0;
+     if (tcsetattr( dfb_vt->fd, TCSAFLUSH, &ts ) < 0) {
+          D_PERROR( "DirectFB/fbdev/vt: tcsetattr for new values failed!\n" );
+          ioctl( dfb_vt->fd, KDSKBMODE, K_XLATE );
+          close( dfb_vt->fd );
+          return DFB_INIT;
+     }
+
+     write( dfb_vt->fd, cursoroff_str, sizeof(cursoroff_str) );
+     if (dfb_config->kd_graphics) {
+          if (ioctl( dfb_vt->fd, KDSETMODE, KD_GRAPHICS ) < 0) {
+               D_PERROR( "DirectFB/fbdev/vt: KD_GRAPHICS failed!\n" );
+               tcsetattr( dfb_vt->fd, TCSAFLUSH, &dfb_vt->old_ts );
+               ioctl( dfb_vt->fd, KDSKBMODE, K_XLATE );
+               close( dfb_vt->fd );
+               return DFB_INIT;
+          }
+     }
+     else {
+          write( dfb_vt->fd, blankoff_str, sizeof(blankoff_str) );
+     }
+
+     if (dfb_config->vt_switching) {
+          struct vt_mode vt;
+          struct sigaction sig_tty;
+
+          memset( &sig_tty, 0, sizeof( sig_tty ) );
+          sig_tty.sa_handler = vt_switch_handler;
+          sigfillset( &sig_tty.sa_mask );
+
+          if (sigaction( SIG_SWITCH_FROM, &sig_tty, &dfb_vt->sig_usr1 ) ||
+              sigaction( SIG_SWITCH_TO, &sig_tty, &dfb_vt->sig_usr2 )) {
+               D_PERROR( "DirectFB/fbdev/vt: sigaction failed!\n" );
+               tcsetattr( dfb_vt->fd, TCSAFLUSH, &dfb_vt->old_ts );
+               ioctl( dfb_vt->fd, KDSKBMODE, K_XLATE );
+               close( dfb_vt->fd );
+               return DFB_INIT;
+          }
+
+
+          vt.mode   = VT_PROCESS;
+          vt.waitv  = 0;
+          vt.relsig = SIG_SWITCH_FROM;
+          vt.acqsig = SIG_SWITCH_TO;
+
+          if (ioctl( dfb_vt->fd, VT_SETMODE, &vt ) < 0) {
+               D_PERROR( "DirectFB/fbdev/vt: VT_SETMODE failed!\n" );
+
+               sigaction( SIG_SWITCH_FROM, &dfb_vt->sig_usr1, NULL );
+               sigaction( SIG_SWITCH_TO, &dfb_vt->sig_usr2, NULL );
+
+               tcsetattr( dfb_vt->fd, TCSAFLUSH, &dfb_vt->old_ts );
+               ioctl( dfb_vt->fd, KDSKBMODE, K_XLATE );
+               close( dfb_vt->fd );
+
+               return DFB_INIT;
+          }
+
+          direct_util_recursive_pthread_mutex_init( &dfb_vt->lock );
+
+          pthread_cond_init( &dfb_vt->wait, NULL );
+
+          dfb_vt->vt_sig = -1;
+
+          dfb_vt->thread = direct_thread_create( DTT_CRITICAL, vt_thread, NULL, "VT Switcher" );
+     }
+
+     return DFB_OK;
+}
+
+static int
+vt_get_fb( int vt )
+{
+     struct fb_con2fbmap c2m;
+
+     D_DEBUG_AT( VT, "%s( %d )\n", __FUNCTION__, vt );
+
+     c2m.console = vt;
+
+     if (ioctl( dfb_stmfbdev->fd, FBIOGET_CON2FBMAP, &c2m )) {
+          D_PERROR( "DirectFB/FBDev/vt: "
+                     "FBIOGET_CON2FBMAP failed!\n" );
+          return 0;
+     }
+
+     D_DEBUG_AT( VT, "  -> %d\n", c2m.framebuffer );
+
+     return c2m.framebuffer;
+}
+
+static void
+vt_set_fb( int vt, int fb )
+{
+     struct fb_con2fbmap c2m;
+     struct stat         sbf;
+
+     D_DEBUG_AT( VT, "%s( %d, %d )\n", __FUNCTION__, vt, fb );
+
+     if (fstat( dfb_stmfbdev->fd, &sbf )) {
+          D_PERROR( "DirectFB/FBDev/vt: Could not fstat fb device!\n" );
+          return;
+     }
+
+     if (fb >= 0)
+          c2m.framebuffer = fb;
+     else
+          c2m.framebuffer = (sbf.st_rdev & 0xFF) >> 5;
+
+     c2m.console = vt;
+
+     if (ioctl( dfb_stmfbdev->fd, FBIOPUT_CON2FBMAP, &c2m ) < 0) {
+          D_PERROR( "DirectFB/FBDev/vt: "
+                     "FBIOPUT_CON2FBMAP failed!\n" );
+     }
+}
+
+static void
+vt_start_flushing( void )
+{
+     dfb_vt->flush = true;
+     dfb_vt->flush_thread = direct_thread_create( DTT_DEFAULT, vt_flush_thread, NULL, "VT Flusher" );
+}
+
+static void
+vt_stop_flushing( void )
+{
+     dfb_vt->flush = false;
+     direct_thread_cancel( dfb_vt->flush_thread );
+     direct_thread_join( dfb_vt->flush_thread );
+     direct_thread_destroy( dfb_vt->flush_thread );
+     dfb_vt->flush_thread = NULL;
+}
+
+/*
+ * If the vt buffer in not kept clean the kernel may stop sleeping.
+ */
+static void *
+vt_flush_thread( DirectThread *thread, void *arg )
+{
+     D_DEBUG_AT( VT, "%s( %p, %p )\n", __FUNCTION__, thread, arg );
+
+     while (dfb_vt->flush) {
+          fd_set set;
+          int ret;
+
+          FD_ZERO( &set );
+          FD_SET( dfb_vt->fd, &set );
+
+          ret = select( dfb_vt->fd + 1, &set, NULL, NULL, NULL );
+
+          if (ret < 0 && errno == EINTR)
+               continue;
+
+          if (ret < 0)
+               break;
+
+          tcflush( dfb_vt->fd, TCIFLUSH );
+     }
+
+     return NULL;
+}
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/systems/stmfbdev/vt.h DirectFB-1.4.12+STM2011.09.27/systems/stmfbdev/vt.h
--- DirectFB/systems/stmfbdev/vt.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/systems/stmfbdev/vt.h	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,83 @@
+/*
+   (c) Copyright 2001-2009  The world wide DirectFB Open Source Community (directfb.org)
+   (c) Copyright 2000-2004  Convergence (integrated media) GmbH
+
+   All rights reserved.
+
+   Written by Denis Oliver Kropp <dok@directfb.org>,
+              Andreas Hundt <andi@fischlustig.de>,
+              Sven Neumann <neo@directfb.org>,
+              Ville Syrjl <syrjala@sci.fi> and
+              Claudio Ciccani <klan@users.sf.net>.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#ifndef __VT_H__
+#define __VT_H__
+
+#include <signal.h>
+#include <termios.h>
+#include <unistd.h>
+#include <linux/vt.h>
+
+#include <directfb.h>
+
+typedef struct {
+     int fd0;                      /* file descriptor of /dev/tty0 */
+     int fd;                       /* file descriptor of /dev/ttyN
+                                      where N is the number of the allocated VT,
+                                      may be equal to 'fd0' if VT allocation
+                                      is disabled by "--no-vt-switch" */
+
+     int num;                      /* number of vt where DirectFB runs */
+     int prev;                     /* number of vt DirectFB was started from */
+
+     int old_fb;                   /* original fb mapped to vt */
+
+     struct sigaction sig_usr1;    /* previous signal handler for USR1 */
+     struct sigaction sig_usr2;    /* previous signal handler for USR2 */
+
+     struct vt_mode   vt_mode;     /* previous VT mode */
+
+     DirectThread    *thread;
+     pthread_mutex_t  lock;
+     pthread_cond_t   wait;
+
+     int              vt_sig;
+     struct termios   old_ts;
+
+     bool             flush;
+     DirectThread    *flush_thread;
+} VirtualTerminal;
+
+/*
+ * allocates and switches to a new virtual terminal
+ */
+DFBResult dfb_vt_initialize( void );
+DFBResult dfb_vt_join( void );
+
+/*
+ * deallocates virtual terminal
+ */
+DFBResult dfb_vt_shutdown( bool emergency );
+DFBResult dfb_vt_leave( bool emergency );
+
+DFBResult dfb_vt_detach( bool force );
+
+bool dfb_vt_switch( int num );
+
+#endif
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/tests/fixup_rle.c DirectFB-1.4.12+STM2011.09.27/tests/fixup_rle.c
--- DirectFB/tests/fixup_rle.c	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/tests/fixup_rle.c	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,180 @@
+/*
+ * Copyright (C) 2006 ST-Microelectronics R&D <alain.clement@st.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+/*
+ *              BD-RLE8 FILE HEADER FIXUP
+ */
+
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
+
+#include <directfb.h>
+#include <direct/messages.h>
+
+#include "unit_test_rle_helpers.h"
+#include "rle_build_packet.h"
+
+
+#define DFBFAIL(err)                                           \
+    {                                                          \
+        fprintf( stderr, "%s <%d>:\n\t", __FILE__, __LINE__ ); \
+        DirectFBErrorFatal( #err, err );                         \
+    }
+
+
+#define DFBCHECK(x)                                            \
+  {                                                            \
+    DFBResult err = x;                                         \
+                                                               \
+    if (err != DFB_OK)        DFBFAIL(err);                    \
+  }
+
+#define DISPLAY_INFO(x...) do {                                \
+                              if (!direct_config->quiet)       \
+                                   direct_messages_info( x );  \
+                           } while (0)
+
+
+
+static DFBResult
+rle_fixup_file_header (char *filename, long force_bdmode)
+{
+    //    Buffer and size in bytes
+    void                       *buffer         = NULL;
+    unsigned long               buffer_size    = 0;
+
+
+    //    Image file elements and information
+    unsigned long               width          = 0;
+    unsigned long               height         = 0;
+    unsigned long               depth          = 0;
+
+    //    Image file boolean attributes
+    unsigned long               rawmode        = 0;
+    unsigned long               bdmode         = 0;
+    unsigned long               topfirst       = 0;
+
+    unsigned long               payload_size   = 0;
+    unsigned long               colormap_size  = 0;
+
+    void                        *payload       = NULL;
+    void                        *colormap      = NULL;
+
+    int                         status;
+
+    //    We actually read the file contents into memory and collect details
+    //    using a helper function (see "unit_test_rle_helpers.h").
+    //    NOTE: rle_load_image will allocate payload and colormap buffers
+    //          NULL buffer pointers means internal "allocation requested"
+    //          Those buffers must be released.
+    status  = rle_load_image   (filename, &width, &height, &depth,
+                                &rawmode, &bdmode, &topfirst, &buffer_size,
+                                &payload, &payload_size,
+                                &colormap, &colormap_size);
+
+    if (!status)
+    {
+        printf ("%s: Couldn't load image file %s\n",__FUNCTION__,filename);
+        return status;
+    }
+
+
+    if (force_bdmode) bdmode=1;
+
+    //DISPLAY_INFO (" colormap : %d\n",       (int)   colormap);
+    //DISPLAY_INFO (" colormap_size : %d\n",  (int)   colormap_size);
+    //DISPLAY_INFO (" payload : %d\n",        (int)   payload);
+    //DISPLAY_INFO (" payload_size : %d\n",   (int)   payload_size);
+
+
+    //    We attach the colormap to the RLE packet :
+    //    RLE header, colormap (if available) and payload together
+    buffer_size = RLE_HEADER_SIZE + colormap_size + payload_size;
+
+    //    Static memory data buffer allocation.
+    buffer = malloc (buffer_size);
+    if (!buffer) return DFB_FAILURE;
+
+    //    We now rebuild the whole image buffer, setting up the header,
+    //    copying the (eventual) collected colormap and payload.
+    //    We are using another helper function (see "rle_build_packet.h").
+    DFBCHECK ( rle_build_packet (buffer, buffer_size, width, height, depth,
+                                                    rawmode, bdmode, topfirst,
+                                                    colormap, colormap_size,
+                                                    payload, payload_size));
+
+    //    Now we can release colormap & payload buffers eventually allocated
+    //    previously by  "rle_load_image"  helper function (since "buffer" has
+    //    just been set by  "rle_build_packet")
+    if (colormap)    free(colormap);  colormap = NULL;   colormap_size = 0;
+    if (payload)     free(payload);   payload  = NULL;   payload_size  = 0;
+
+
+    //    Write full buffer to new file
+    {
+        FILE  *file;
+        char newfilename[512];
+        sprintf (newfilename, "%s.%s", filename, "RLE");
+
+        file = fopen(newfilename, "wb");
+        if (!file)
+        {
+            DISPLAY_INFO ("Can't fix up : %s\n", newfilename);
+            return 0;
+        }
+        else
+        {
+            DISPLAY_INFO ("Writing full buffer to : %s\n", newfilename);
+            fwrite (buffer, sizeof(char), buffer_size, file);
+            fclose (file);
+        }
+    }
+
+    //  Release the main buffer, we don't need it anymore.
+    if (buffer)      free(buffer);    buffer   = NULL;   buffer_size   = 0;
+
+    return DFB_OK;
+}
+
+
+
+//------------------------------------------------------------------------------
+//  Unit Test main
+//------------------------------------------------------------------------------
+int main (int argc, char **argv)
+{
+    int j;
+
+    //    File name to load logo image from
+    char *filename      =   NULL;
+    long force_bdmode   =   1;
+
+    DISPLAY_INFO ("Fixing up %d files\n",argc);
+    for (j=1; j<argc; j++)
+    {
+        filename     =     argv[j];
+        DISPLAY_INFO ("Fixing up : %s\n",filename);
+        //    Process file
+        DFBCHECK ( rle_fixup_file_header (filename, force_bdmode));
+    }
+
+    return 0;
+}
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/tests/Makefile.am DirectFB-1.4.12+STM2011.09.27/tests/Makefile.am
--- DirectFB/tests/Makefile.am	2015-06-02 22:40:08.191549155 +0200
+++ DirectFB-1.4.12+STM2011.09.27/tests/Makefile.am	2012-06-06 18:41:31.000000000 +0200
@@ -38,7 +38,9 @@
 	dfbtest_window	\
 	dfbtest_window_flip_once	\
 	direct_stream	\
-	direct_test
+	direct_test	\
+	unit_test_rle	\
+	fixup_rle
 
 libdirectfb = $(top_builddir)/src/libdirectfb.la
 libfusion = $(top_builddir)/lib/fusion/libfusion.la
@@ -99,3 +101,20 @@
 
 fusion_stream_SOURCES = fusion_stream.c
 fusion_stream_LDADD   = $(libdirectfb) $(libfusion) $(libdirect)
+
+
+unit_test_rle_SOURCES = \
+	unit_test_rle.c				\
+	unit_test_rle_helpers.c			\
+	rle_build_packet.c			\
+	unit_test_rle_helpers.h			\
+	rle_build_packet.h
+unit_test_rle_LDADD = $(libdirectfb) $(libfusion) $(libdirect)
+
+fixup_rle_SOURCES = \
+	fixup_rle.c				\
+	unit_test_rle_helpers.c			\
+	rle_build_packet.c			\
+	unit_test_rle_helpers.h			\
+	rle_build_packet.h
+fixup_rle_LDADD = $(libdirectfb) $(libfusion) $(libdirect)
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/tests/README DirectFB-1.4.12+STM2011.09.27/tests/README
--- DirectFB/tests/README	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/tests/README	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,22 @@
+INTRODUCTION
+------------
+
+This directory contains unit-test code.
+
+
+
+DESCRIPTION
+-----------
+
+unit_test_rle
+
+	Displays and blits around an image over the primary surface.
+	The RLE/BMP image gets loaded into a static memory buffer first;
+	it is then associated to a DirectFB data buffer tied to an Image Provider.
+
+USAGE
+-----
+
+unit_test_rle	[file_name]
+
+	(the file name defaults to "directfb.bmp" in the current working directory)
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/tests/rle_build_packet.c DirectFB-1.4.12+STM2011.09.27/tests/rle_build_packet.c
--- DirectFB/tests/rle_build_packet.c	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/tests/rle_build_packet.c	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,274 @@
+/*
+ * Copyright (C) 2006 ST-Microelectronics R&D <alain.clement@st.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+/*
+ *              RLE PACKET HELPER LIBRARY
+ */
+
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
+
+#include "rle_build_packet.h"
+
+/*******************************************************************************
+ *
+ *   rle_build_packet:
+ *
+ *             DirectFB static memory buffer setup for RLE Image Provider
+ *
+ *   RLE Image Provider expects its DirectFB buffer holding header data+colormap
+ *   (RLE_OVERHEAD) and the RLE payload. This helper function sets up such a
+ *   buffer given a minimal set of parameters. The application must account for
+ *   RLE_HEADER_SIZE bytes at the beginning, then colormap bytes (variable,
+ *   dependent on depth) then the payload. The application must supply the
+ *   colormap but has the flexibility of submitting the payload data for copy
+ *   in the allocated I/O buffer (non NULL payload parameter), or collecting the
+ *   data from source ahead of time into the I/O buffer, thus avoiding a copy
+ *   step, as long as the payload sections make room for RLE_OVERHEAD(depth)
+ *   reserved bytes at the beginning of "buffer".
+ *
+ *   Note 1:The colormap is not required to be supplied. In such a case (NULL
+ *          pointer), the colormap section gets skipped (absent from header).
+ *
+ *   Note 2:BMP/DIB row addressing normally starts from the bottom. A negative
+ *          height means images start from the top of the bitmap (weirdness ?)
+ *          "topfirstmode" flag is provided here to get a start from the top of
+ *          the bitmap. This behavior is normally applicable to non RLE
+ *          compressed images, but extended to any format in our RLE Image
+ *          Provider implementation.
+ *
+ *     -------------------------------------------------------------------------
+ *                             DirectFB buffer Mapping
+ *     -------------------------------------------------------------------------
+ *
+ *         RLE_PREAMBLE
+ *             (14)
+ *     -------------------    RLE_HEADER
+ *                             (54)
+ *         RLE_BIHEADER
+ *             (40)
+ *     --------------------------------------    RLE_OVERHEAD
+ *                                                 (54-310)
+ *                         RLE_PALETTE
+ *                             (0-256)
+ *     ------------------------------------------------------  RLE_DFB_BUFFER
+ *                                                              (Packet Size)
+ *
+ *
+ *                                             RLE_PAYLOAD
+ *
+ *                      rawmode = Raw-Pixels (1) or Run-Length coded (0)
+ *                      bdmode  = BD-RLE     (1) or Legacy-RLE coded (0)
+ *
+ *     -------------------------------------------------------------------------
+ *
+ *******************************************************************************/
+
+DFBResult
+rle_build_packet (
+    u8        *buffer,       /*    I/O  :    Packet buffer            */
+    u32        buffer_size,  /*    I    :    Packet size              */
+    u32        width,        /*    I    :    Image width              */
+    u32        height,       /*    I    :    Image height             */
+    u32        depth,        /*    I    :    Pixels depth             */
+    u32        rawmode,      /*    I    :    Raw mode flag      (0/1) */
+    u32        bdmode,       /*    I    :    BD-RLE mode flag   (0/1) */
+    u32        topfirstmode, /*    I    :    Topfirst mode flag (0/1) */
+    DFBColor  *colormap,     /*    I    :    Palette / NULL           */
+    u32        colormap_size,/*    I    :    Palette size             */
+    void      *payload,      /*    I    :    Payload / NULL           */
+    u32        payload_size  /*    I    :    Payload size             */
+)
+{
+	/*
+	 * RLE Compression identifier (see BMP/RLE header - Offset:30 --- DWORD)
+	 */
+	typedef enum {
+	     RLEIC_NONE      = 0,   /* Implemented      as of version 1.0.0 */
+	     RLEIC_RLE8      = 1,   /* Implemented      as of version 1.0.0 */
+	     RLEIC_RLE4      = 2,   /* Unimplemented */
+	     RLEIC_BITFIELDS = 3,   /* Unimplemented */
+	     RLEIC_BD_RLE8   = 4    /* Implemented      as of version 1.1.0 */
+	} RLEImageCompression;
+
+
+
+
+
+     /* Little-endian portable data bytes order ... */
+     #define RLE_HEADER_SET_MAGIC(ptr,l,h)       {      \
+             ptr[0]=(u8)l;                              \
+             ptr[1]=(u8)h;                              \
+             }
+     #define RLE_HEADER_WRITE_LE_16(ptr,data)    {      \
+            *ptr++    =    (data>>0 ) & 0xff;           \
+            *ptr++    =    (data>>8 ) & 0xff;           \
+     }
+     #define RLE_HEADER_WRITE_LE_32(ptr,data)    {      \
+            *ptr++    =    (data>>0 ) & 0xff;           \
+            *ptr++    =    (data>>8 ) & 0xff;           \
+            *ptr++    =    (data>>16) & 0xff;           \
+            *ptr++    =    (data>>24) & 0xff;           \
+     }
+
+     #define RLE_PALETTE_SIZE          (colormap_size & ~0x03)
+     #define RLE_OVERHEAD              (RLE_HEADER_SIZE+RLE_PALETTE_SIZE)
+
+     #define MIN(a,b)   (((a)<(b)) ? (a) : (b))
+
+     DFBResult ret = DFB_OK;
+     u8  *hptr;
+     u32  bihsize          = RLE_BIHEADER_SIZE;
+     u32  num_colors       = RLE_PALETTE_SIZE/4;
+     u32  imp_colors       = RLE_PALETTE_SIZE/4;
+     u32  img_offset       = RLE_OVERHEAD;
+     int  payload_max_size = MIN(buffer_size-RLE_OVERHEAD,payload_size);
+     int  height_dib       = topfirstmode ? -height : height;
+
+     RLEImageCompression  compression;
+
+     /* Check for any payload/buffer size discrepancy */
+     if (payload_max_size<0) {
+         return DFB_INVARG;
+     }
+
+     /* Switch compression mode */
+     if (rawmode) {
+         switch (depth) {
+              case 16:
+              case 24:
+              case 32:
+              case 8:
+              case 4:
+              case 1:
+                  compression = RLEIC_NONE;
+                  break;
+              default:
+                   return DFB_INVARG;
+         }
+     }
+     else {
+         switch (depth) {
+              case 8:
+                   if (!bdmode)     {
+                       compression = RLEIC_RLE8;
+                       break;
+                   }
+                   else             {
+                       compression = RLEIC_BD_RLE8;
+                       break;
+                   }
+              case 4:
+                   if (!bdmode)     {
+                       compression = RLEIC_RLE4;
+                       break;
+                   }
+              case 1:
+              case 16:
+              case 24:
+              case 32:
+              default:
+                   return DFB_INVARG;
+         }
+     }
+
+     /* Cleanup preamble, header and eventual palette area */
+     memset( buffer, 0,  img_offset);
+
+     /* Pointer to buffer header start */
+     hptr = buffer;
+
+     /* Offset:00 --- 2 bytes: Magic - Zero for now */
+     RLE_HEADER_WRITE_LE_16 (hptr, 0);
+
+     /* Offset:02 --- 4 bytes: FileSize */
+     RLE_HEADER_WRITE_LE_32 (hptr, buffer_size);
+
+     /* Offset:06 --- 4 bytes: Reserved */
+     RLE_HEADER_WRITE_LE_32 (hptr, 0);
+
+     /* Offset:10 --- 4 bytes: DataOffset */
+     RLE_HEADER_WRITE_LE_32 (hptr, img_offset);
+
+     /* Offset:14 --- 4 bytes: HeaderSize */
+     RLE_HEADER_WRITE_LE_32 (hptr, bihsize);
+
+     /* Offset:18 --- 4 bytes: Width */
+     RLE_HEADER_WRITE_LE_32 (hptr, width);
+
+     /* Offset:22 --- 4 bytes: Height (negative value means top first mode) */
+     RLE_HEADER_WRITE_LE_32 (hptr, height_dib);
+
+     /* Offset:26 --- 2 bytes: Planes */
+     RLE_HEADER_WRITE_LE_16 (hptr, 1);
+
+     /* Offset:28 --- 2 bytes: Depth */
+     RLE_HEADER_WRITE_LE_16 (hptr, depth);
+
+     /* Offset:30 --- 4 bytes: Compression */
+     RLE_HEADER_WRITE_LE_32 (hptr, compression);
+
+     /* Offset:34 --- 4 bytes: CompressedSize */
+     RLE_HEADER_WRITE_LE_32 (hptr, payload_max_size);
+
+     /* Offset:38 --- 4 bytes: HorizontalResolution (don't care ...) */
+     RLE_HEADER_WRITE_LE_32 (hptr, 0);
+
+     /* Offset:42 --- 4 bytes: VerticalResolution (don't care ...) */
+     RLE_HEADER_WRITE_LE_32 (hptr, 0);
+
+     /* Offset:46 --- 4 bytes: UsedColors */
+     RLE_HEADER_WRITE_LE_32 (hptr, num_colors);
+
+     /* Offset:50 --- 4 bytes: ImportantColors (don't care ...) */
+     RLE_HEADER_WRITE_LE_32 (hptr, imp_colors);
+
+     /* Offset:54 --- 4 x num_colors bytes: Palette */
+     if (colormap_size>0 && colormap) {
+          int i;
+          for (i = 0; i < num_colors; i++) {
+
+               if (i>=colormap_size/4){
+                    RLE_HEADER_WRITE_LE_32 (hptr, 0);
+                    continue;
+               }
+
+               ((u8*)hptr)[i*4+3] = colormap[i].a;
+               ((u8*)hptr)[i*4+2] = colormap[i].r;
+               ((u8*)hptr)[i*4+1] = colormap[i].g;
+               ((u8*)hptr)[i*4+0] = colormap[i].b;
+          }
+     }
+
+     /* Offset:54 + 4 x num_colors ---  bytes: Payload */
+     if (payload_max_size>0 && payload) {
+         memcpy( buffer+img_offset, payload, payload_max_size);
+     }
+
+     /* Set first 2 bytes: Magic - valid header now */
+     RLE_HEADER_SET_MAGIC(buffer,'R','L');
+
+     return ret;
+}
+
+
+
+
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/tests/rle_build_packet.h DirectFB-1.4.12+STM2011.09.27/tests/rle_build_packet.h
--- DirectFB/tests/rle_build_packet.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/tests/rle_build_packet.h	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2006 ST-Microelectronics R&D <alain.clement@st.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef RLE_BUILD_PACKET_H_
+#define RLE_BUILD_PACKET_H_
+
+#include <directfb.h>
+
+DFBResult
+rle_build_packet (
+    u8        *buffer,       /*    I/O  :    Packet buffer            */
+    u32        buffer_size,  /*    I    :    Packet size              */
+    u32        width,        /*    I    :    Image width              */
+    u32        height,       /*    I    :    Image height             */
+    u32        depth,        /*    I    :    Pixels depth             */
+    u32        rawmode,      /*    I    :    Raw mode flag      (0/1) */
+    u32        bdmode,       /*    I    :    BD-RLE mode flag   (0/1) */
+    u32        topfirstmode, /*    I    :    Topfirst mode flag (0/1) */
+    DFBColor  *colormap,     /*    I    :    Palette / NULL           */
+    u32        colormap_size,/*    I    :    Palette size             */
+    void      *payload,      /*    I    :    Payload / NULL           */
+    u32        payload_size  /*    I    :    Payload size             */
+);
+
+#define RLE_PREAMBLE_SIZE         (14)
+#define RLE_BIHEADER_SIZE         (40)
+#define RLE_HEADER_SIZE           (RLE_PREAMBLE_SIZE+RLE_BIHEADER_SIZE)
+
+#endif /*RLE_BUILD_PACKET_H_*/
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/tests/unit_test_rle.c DirectFB-1.4.12+STM2011.09.27/tests/unit_test_rle.c
--- DirectFB/tests/unit_test_rle.c	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/tests/unit_test_rle.c	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,419 @@
+/*
+ * Copyright (C) 2006 ST-Microelectronics R&D <alain.clement@st.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+/*
+ *              RLE IMAGE PROVIDER UNIT TEST
+ */
+
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
+
+#include <directfb.h>
+#include <direct/messages.h>
+
+#include "unit_test_rle_helpers.h"
+#include "rle_build_packet.h"
+
+#define DFBFAIL(err)                                           \
+    {                                                          \
+        fprintf( stderr, "%s <%d>:\n\t", __FILE__, __LINE__ ); \
+        DirectFBErrorFatal( #err, err );                         \
+    }
+
+#define DFBCHECK(x)                                            \
+  {                                                            \
+    DFBResult err = x;                                         \
+                                                               \
+    if (err != DFB_OK)        DFBFAIL(err);                    \
+  }
+
+#define DISPLAY_INFO(x...) do {                                \
+                              if (!direct_config->quiet)       \
+                                   direct_messages_info( x );  \
+                           } while (0)
+
+
+// WE'RE USING A CLEVER APPROACH FOR THE RLE PACKET BUILDER NOW
+#define CLEVER_APPROACH
+
+// WE'RE USING THE RLE PACKET BUILDER ONLY FOR NOW (DIRECT FILE ACCESS)
+#define USE_PACKET_BUILDER_ONLY
+
+// WE WANT TO DISPLAY SUBTITLES
+#define SUBTITLES_MODE
+
+
+//------------------------------------------------------------------------------
+//    Pointer to user-managed buffer holding RLE packet data bytes
+//------------------------------------------------------------------------------
+static void                 *buffer            = NULL;
+
+#   ifdef CLEVER_APPROACH
+
+    static  DFBColor        *color_palette     = NULL;
+    static  unsigned int     number_of_colors  = 0;
+
+#   endif
+
+
+
+//------------------------------------------------------------------------------
+//  Destroy DirectFB data buffer
+//------------------------------------------------------------------------------
+static DFBResult
+rle_destroy_databuffer (IDirectFBDataBuffer *databuffer)
+{
+    //  Release the databuffer, we don't need it anymore.
+    if (databuffer)     databuffer->Release (databuffer);
+    //  Release the static buffer, we don't need it anymore.
+    if (buffer)         free(buffer);           buffer         = NULL;
+
+#   ifdef CLEVER_APPROACH
+
+    //  Release the static colormap, we don't need it anymore.
+    if (color_palette)  free(color_palette);    color_palette  = NULL;
+    number_of_colors = 0;
+
+#   endif
+
+    return DFB_OK;
+}
+
+
+
+
+//------------------------------------------------------------------------------
+//  Create a DirectFB static data buffer holding our RLE data (read from a file)
+//------------------------------------------------------------------------------
+static DFBResult
+rle_build_databuffer (IDirectFB *dfb, char *filename,
+                                      IDirectFBDataBuffer **pdatabuffer)
+{
+    //  An Image provider instance can also be created from a directfb buffer
+    IDirectFBDataBuffer        *databuffer     = NULL;
+
+    //    Buffer description
+    DFBDataBufferDescription    buffer_dsc;
+
+    //    Image file elements and information
+    unsigned long               width          = 0;
+    unsigned long               height         = 0;
+    unsigned long               depth          = 0;
+
+    //    Image file boolean attributes
+    unsigned long               rawmode    	   = 0;
+    unsigned long               bdmode         = 0;
+    unsigned long               topfirst       = 0;
+
+      //     Size in bytes
+    unsigned long               buffer_size    = 0;
+
+    unsigned long               payload_size   = 0;
+    unsigned long               colormap_size  = 0;
+
+    void                        *payload       = NULL;
+    void                        *colormap      = NULL;
+
+    int                         success;
+
+    //    We actually read the file contents into memory and collect details
+    //    using a helper function (see "unit_test_rle_helpers.h").
+    //    NOTE: rle_load_image will allocate payload and colormap buffers
+    //          NULL buffer pointers means internal "allocation requested"
+    //          Those buffers must be released.
+    success = rle_load_image   (filename, &width, &height, &depth,
+                                &rawmode, &bdmode, &topfirst, &buffer_size,
+                                &payload, &payload_size,
+                                &colormap, &colormap_size);
+
+    if (!success)
+    {
+        DISPLAY_INFO ("%s: Couldn't load image file %s\n",__FUNCTION__,filename);
+        return DFB_UNSUPPORTED;
+    }
+
+
+#   ifdef CLEVER_APPROACH
+
+    //    Let's stash our colormap in global space first
+    {
+        int   i;
+
+        number_of_colors = colormap_size/4;
+
+        color_palette = malloc (number_of_colors*4);
+        if (!color_palette) return DFB_FAILURE;
+
+        for (i = 0; i < number_of_colors; i++)
+        {
+               DFBColor c;
+
+               c.a = 0xff;
+               c.r = ((u8*)colormap)[i*4+2];
+               c.g = ((u8*)colormap)[i*4+1];
+               c.b = ((u8*)colormap)[i*4+0];
+
+               color_palette[i] = c;
+        }
+    }
+
+    //    We won't attach the colormap to the RLE packet :
+    //    RLE header and payload only
+    buffer_size = RLE_HEADER_SIZE + payload_size;
+
+    //    Static memory data buffer (packet) allocation.
+    buffer = malloc (buffer_size);
+    if (!buffer) return DFB_FAILURE;
+
+    //    Let's paste our payload for encapsulation
+    //    (could have been read from the PES stream fragments as well).
+    memcpy (buffer+RLE_HEADER_SIZE, payload, payload_size);
+
+    //    We only want to setup the header, thus completing the encapsulation
+    //    We are using another helper function (see "rle_build_packet.h").
+    //    NULL payload and colormap means that we don't want the helper
+    //    function to copy anything. Zero "colormap_size" means that we don't
+    //    intend to attach any colormap to the packet.
+    //    "payload_size" must be set though" ...
+    DFBCHECK ( rle_build_packet (buffer, buffer_size, width, height, depth,
+                                                    rawmode, bdmode, topfirst,
+                                                    NULL, 0,
+                                                    NULL, payload_size));
+
+    //    NOTE: FEEL FREE TO TWEAK THE HELPER FUNCTION ABOVE IN ORDER TO
+    //          ACHIEVE TRUE ZERO-COPY ENCAPSULATION (PERHAPS USING THE
+    //          PAYLOAD OFFSET). YOU GET THE IDEA ...
+    //          THE RLE IMAGE PROVIDER DOESN'T HANDLE PAYLOAD FRAGMENTS,
+    //          SO THE PAYLOAD MUST USE A CONTIGUOUS SEGMENT IN THE RLE
+    //          PACKET.
+
+#   else
+
+    //    We attach the colormap to the RLE packet :
+    //    RLE header, colormap (if available) and payload together
+    buffer_size = RLE_HEADER_SIZE + colormap_size + payload_size;
+
+    //    Static memory data buffer allocation.
+    buffer = malloc (buffer_size);
+    if (!buffer) return DFB_FAILURE;
+
+    //    We now rebuild the whole image buffer, setting up the header,
+    //    copying the (eventual) collected colormap and payload.
+    //    We are using another helper function (see "rle_build_packet.h").
+    DFBCHECK ( rle_build_packet (buffer, buffer_size, width, height, depth,
+    												rawmode, bdmode, topfirst,
+                                                    colormap, colormap_size,
+                                                    payload, payload_size));
+
+    //    Note: we avoided colormap & payload copies by adopting a
+    //    more clever approach previously ...
+
+#   endif
+
+    //    Now we can release colormap & payload buffers eventually allocated
+    //    previously by  "rle_load_image"  helper function (since "buffer" has
+    //    just been set by  "rle_build_packet")
+    if (colormap)    free(colormap);  colormap = NULL;   colormap_size = 0;
+    if (payload)     free(payload);   payload  = NULL;   payload_size  = 0;
+
+    //    An Image Provider can be obtained from a directfb data buffer that
+    //    we specify and set up by ourselves using a static memory buffer
+    buffer_dsc.flags            =    DBDESC_MEMORY;
+    buffer_dsc.file             =    NULL;
+    buffer_dsc.memory.data      =    buffer;
+    buffer_dsc.memory.length    =    buffer_size;
+    DFBCHECK (dfb->CreateDataBuffer (dfb, &buffer_dsc, &databuffer));
+    //    Note: if no description had been specified (NULL), a streamed data
+    //    buffer would have been created instead.
+
+    //    Return newly created databuffer
+    *pdatabuffer = databuffer;
+
+    return DFB_OK;
+}
+
+
+
+//------------------------------------------------------------------------------
+//  Unit Test main
+//------------------------------------------------------------------------------
+int main (int argc, char **argv)
+{
+    int i, j;
+    DFBResult rle_build_databuffer_err;
+
+    //    File name to load logo image from
+    char *filename                           = NULL;
+
+    //    Basic directfb elements
+    IDirectFB               *dfb             = NULL;
+    IDirectFBSurface        *primary         = NULL;
+    int                      screen_width    = 0;
+    int                      screen_height   = 0;
+
+    //    The image is to be loaded into a surface that we can blit from.
+    IDirectFBSurface         *logo           = NULL;
+
+    //    Loading an image is done with an Image Provider.
+    IDirectFBImageProvider   *provider       = NULL;
+
+    //    An Image provider instance can also be created from a directfb buffer
+    IDirectFBDataBuffer      *databuffer     = NULL;
+
+    //    Surface description
+    DFBSurfaceDescription     surface_dsc;
+
+
+
+    //    Initialize directfb first
+    DFBCHECK (DirectFBInit (&argc, &argv));
+    DFBCHECK (DirectFBCreate (&dfb));
+    DFBCHECK (dfb->SetCooperativeLevel (dfb, DFSCL_FULLSCREEN));
+
+
+    //  Create primary surface
+    surface_dsc.flags = DSDESC_CAPS;
+    surface_dsc.caps  = DSCAPS_PRIMARY | DSCAPS_FLIPPING;
+    DFBCHECK (dfb->CreateSurface( dfb, &surface_dsc, &primary ));
+    DFBCHECK (primary->GetSize (primary, &screen_width, &screen_height));
+
+    if (argc==1)
+    {
+        argv[1] = "./data/directfb.rle";
+        argc++;
+    }
+
+    DISPLAY_INFO ("Rendering %d files\n",argc-1);
+    for (j=1; j<argc; j++)
+    {
+
+        //
+        //  --- WE CREATE OUR IMAGE PROVIDER INSTANCE HERE
+        //
+        filename     =     argv[j];
+        DISPLAY_INFO ("Rendering : %s\n",filename);
+
+        //  We create a directfb data buffer holding RLE image contents that we
+        //  pick up from a file (could get the RLE contents from memory as well).
+        //  "rle_build_databuffer" details the process of dealing with a memory
+        //  RLE packet as a matter of fact.
+        rle_build_databuffer_err = rle_build_databuffer (dfb, filename, &databuffer);
+        if (rle_build_databuffer_err == DFB_OK) {
+            //  We want to create an Image Provider tied to a directfb data buffer.
+            //  DirectFB will find (or not) an Image Provider for the data type
+            //  depending on Image Providers probe method (sniffing data headers)
+            DFBCHECK (databuffer->CreateImageProvider (databuffer, &provider));
+        }
+        else {
+#       ifdef   USE_PACKET_BUILDER_ONLY
+            DFBFAIL(rle_build_databuffer_err);
+#       else
+            //  We could also create an Image Provider by passing a filename.
+            //  DirectFB will find (or not) an Image Provider matching the file type.
+            DFBCHECK (dfb->CreateImageProvider (dfb, filename, &provider));
+#       endif
+        }
+
+
+
+        //    Get a surface description from the provider. It will contain the width,
+        //    height, bits per pixel and the flag for an alphachannel if the image
+        //    has one. If the image has no alphachannel the bits per pixel is set to
+        //    the bits per pixel of the primary layer to use simple blitting without
+        //    pixel format conversion.
+        DFBCHECK (provider->GetSurfaceDescription (provider, &surface_dsc));
+
+        //    Create a surface based on the description of the provider.
+        DFBCHECK (dfb->CreateSurface( dfb, &surface_dsc, &logo ));
+
+        //    Let the provider render to our surface. Image providers are supposed
+        //    to support every destination pixel format and size. If the size
+        //    differs the image will be scaled (bilinear). The last parameter allows
+        //    to specify an optional destination rectangle. We use NULL here so that
+        //    our image covers the whole logo surface.
+        DFBCHECK (provider->RenderTo (provider, logo, NULL));
+        //    Note: RLE Image Provider allows for direct non-scaled LUT-8 surface
+        //          rendering without any attached colormap.
+
+        #ifdef CLEVER_APPROACH
+        //    Let's setup our logo surface palette outside of the RLE Image
+        //    Provider if we got a colormap from rle_build_databuffer ...
+        if (color_palette)
+        {
+            IDirectFBPalette *palette;
+            DFBCHECK (logo->GetPalette (logo, &palette));
+            palette->SetEntries (palette, color_palette, number_of_colors, 0);
+            palette->Release (palette);
+        }
+        #endif
+
+        //
+        //  --- WE GET RID OF OUR IMAGE PROVIDER INSTANCE HERE
+        //
+        //    Release the provider, we don't need it anymore.
+        provider->Release (provider);           provider    = NULL;
+        //    Destroy the databuffer as well, we don't need it anymore.
+        rle_destroy_databuffer (databuffer);    databuffer  = NULL;
+
+
+#   ifndef SUBTITLES_MODE
+        //    We want to let the logo slide in on the left and slide out on the
+        //    right.
+        for (i = -surface_dsc.width; i < screen_width; i++)
+#   else
+        //    We want to let the logo slide in on the right and slide out on the
+        //    left.
+        for (i = screen_width-1; i >= -surface_dsc.width; i--)
+#   endif
+        {
+            //    Clear the screen.
+            DFBCHECK (primary->FillRectangle (primary, 0, 0,
+                                              screen_width, screen_height));
+
+            //    Blit the logo vertically centered with "i" as the X coordinate.
+            //    NULL means that we want to blit the whole surface.
+            DFBCHECK (primary->Blit (primary, logo, NULL, i,
+                                     (screen_height - surface_dsc.height) / 2));
+
+            //    Flip the front and back buffer, but wait for the vertical
+            //    retrace to avoid tearing.
+            DFBCHECK (primary->Flip (primary, NULL, DSFLIP_WAITFORSYNC));
+
+            if (argc < 3)
+            {
+                usleep(1000*5);
+            }
+        }
+
+        //    Release the image.
+        if (logo)
+        {
+            logo->Release (logo);
+        }
+
+   }
+
+   //    Release everything else
+   primary->Release (primary);
+   dfb->Release (dfb);
+
+   return 0;
+}
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/tests/unit_test_rle_helpers.c DirectFB-1.4.12+STM2011.09.27/tests/unit_test_rle_helpers.c
--- DirectFB/tests/unit_test_rle_helpers.c	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/tests/unit_test_rle_helpers.c	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,387 @@
+/*
+ * Copyright (C) 2006 ST-Microelectronics R&D <alain.clement@st.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+/*
+ *              RLE/BMP FILE FORMAT HELPER LIBRARY
+ */
+
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
+
+#include "unit_test_rle_helpers.h"
+
+typedef    unsigned long    DATA32;
+
+/*******************************************************************************
+ *
+ *                      RLE/BMP TYPE DEFINITIONS
+ *
+ *******************************************************************************/
+
+typedef struct tagRGBQUAD {
+   unsigned char       rgbBlue;
+   unsigned char       rgbGreen;
+   unsigned char       rgbRed;
+   unsigned char       rgbReserved;
+} RGBQUAD;
+
+
+/*
+ * RLE Compression identifier (see BMP/RLE header - Offset:30 --- DWORD)
+ */
+typedef enum {
+     RLEIC_NONE      = 0,   /* Implemented      as of version 1.0.0 */
+     RLEIC_RLE8      = 1,   /* Implemented      as of version 1.0.0 */
+     RLEIC_RLE4      = 2,   /* Unimplemented */
+     RLEIC_BITFIELDS = 3,   /* Unimplemented */
+     RLEIC_BD_RLE8   = 4    /* Implemented      as of version 1.1.0 */
+} RLEImageCompression;
+
+
+/*******************************************************************************
+ *
+ *                      RLE/BMP LITTLE-ENDIAN UTILITIES
+ *
+ *******************************************************************************/
+
+static int    ReadleShort             (FILE * file, unsigned short *ret)
+{
+   unsigned char       b[2];
+
+   if (fread(b, sizeof(unsigned char), 2, file) != 2) return 0;
+
+   *ret = (b[1] << 8) | b[0];
+   return 1;
+}
+
+static int    ReadleSignedShort       (FILE * file, signed short *ret)
+{
+   unsigned char       b[2];
+
+   if (fread(b, sizeof(unsigned char), 2, file) != 2) return 0;
+
+   *ret = (b[1] << 8) | b[0];
+   return 1;
+}
+
+static int    ReadleLong              (FILE * file, unsigned long *ret)
+{
+   unsigned char       b[4];
+
+   if (fread(b, sizeof(unsigned char), 4, file) != 4) return 0;
+
+   *ret = (b[3] << 24) | (b[2] << 16) | (b[1] << 8) | b[0];
+   return 1;
+}
+
+static int    ReadleSignedLong        (FILE * file, signed long *ret)
+{
+   unsigned char       b[4];
+
+   if (fread(b, sizeof(unsigned char), 4, file) != 4) return 0;
+
+   *ret = (b[3] << 24) | (b[2] << 16) | (b[1] << 8) | b[0];
+   return 1;
+}
+
+/*******************************************************************************
+ *
+ *                      RLE/BMP FILE FORMAT HELPER FUNCTION
+ *
+ *******************************************************************************/
+
+int  rle_load_image        (char              *filename,
+                            unsigned long     *width_ptr,
+                            unsigned long     *height_ptr,
+                            unsigned long     *depth_ptr,
+                            unsigned long     *rawmode_ptr,
+                            unsigned long     *bdmode_ptr,
+                            unsigned long     *topfirst_ptr,
+                            unsigned long     *buffer_size_ptr,
+                            void             **payload_ptr,
+                            unsigned long     *payload_size_ptr,
+                            void             **colormap_ptr,
+                            unsigned long     *colormap_size_ptr)
+{
+   FILE               *f;
+   char                type[2];
+   unsigned long       size, offset, headSize, comp, imgsize;
+   unsigned short      tmpShort, planes, bitcount, ncols;
+   signed short        tmpSignedShort;
+   signed long         tmpSignedLong;
+   unsigned long       topfirst;
+   unsigned long       i, w, h;
+   RGBQUAD             rgbQuads[256];
+   unsigned long       rmask = 0xff, gmask = 0xff, bmask = 0xff;
+   unsigned long       rshift = 0, gshift = 0, bshift = 0;
+
+   const    unsigned long    preambleSize = 14;
+
+    f = fopen(filename, "rb");
+	if (!f)
+	{
+		return 0;
+	}
+
+	/* HEADER */
+	{
+		struct stat statbuf;
+
+		if (stat(filename, &statbuf)== -1)
+		{
+			fclose(f);
+			return 0;
+		}
+		size = statbuf.st_size;
+
+		if (fread(type, 1, 2, f)!= 2)
+		{
+			fclose(f);
+			return 0;
+		}
+
+#       define IS_MAGIC(ptr,l,h)       ((ptr[0]==l) &&  (ptr[1]==h))
+		if (!IS_MAGIC(type, 'R','L') && !IS_MAGIC(type, 'B','M'))
+		{
+			fclose(f);
+			return 0;
+		}
+
+		fseek(f, 8, SEEK_CUR);
+		ReadleLong(f, &offset);
+		ReadleLong(f, &headSize);
+		if (offset >= size || offset < headSize + preambleSize)
+		{
+			fclose(f);
+			return 0;
+		}
+
+		/* HEADER DATA */
+		switch (headSize)
+		{
+		case 40:
+			ReadleLong(f, &w);
+			tmpSignedLong = 0;
+			ReadleSignedLong(f, &tmpSignedLong);
+			topfirst = tmpSignedLong < 0 ? 1 : 0;
+			h = topfirst ? -tmpSignedLong : tmpSignedLong;
+			ReadleShort(f, &planes);
+			ReadleShort(f, &bitcount);
+			ReadleLong(f, &comp);
+			ReadleLong(f, &imgsize);
+			imgsize = size - offset;
+
+			fseek(f, 16, SEEK_CUR);
+			break;
+
+		case 12:
+			ReadleShort(f, &tmpShort);
+			w = tmpShort;
+			tmpSignedShort = 0;
+			ReadleSignedShort(f, &tmpSignedShort);
+			topfirst = tmpSignedShort < 0 ? 1 : 0;
+			h = topfirst ? -tmpSignedShort : tmpSignedShort;
+			ReadleShort(f, &planes);
+			ReadleShort(f, &bitcount);
+			imgsize = size - offset;
+			comp = RLEIC_NONE;
+			//break;                    /* UNSUPPORTED BACKWARD COMPAT. */
+		default:
+			fclose(f);
+			return 0;
+
+		}
+
+		if (planes!=1)
+		{
+			fclose(f);
+			return 0;
+		}
+
+		if ((w < 1) || (h < 1) || (w > 8192) || (h > 8192))
+		{
+			fclose(f);
+			return 0;
+		}
+
+		ncols = 0;
+
+		if (bitcount < 16)
+		{
+			/* COLORMAP DATA */
+			switch (headSize)
+			{
+			case 40:
+				ncols = (offset - headSize - preambleSize) / 4;
+				if (ncols > 256)
+					ncols = 256;
+				fread(rgbQuads, 4, ncols, f);
+				break;
+
+			case 12:
+				ncols = (offset - headSize - preambleSize) / 3;
+				if (ncols > 256)
+					ncols = 256;
+				for (i = 0; i < ncols; i++)
+					fread(&rgbQuads[i], 3, 1, f);
+				//break;              /* UNSUPPORTED BACKWARD COMPAT. */
+			default:
+				fclose(f); /* UNSUPPORTED BACKWARD COMPAT. */
+				return 0;
+
+			}
+		}
+		else if (bitcount == 16 || bitcount == 32)
+		{
+			if (comp == RLEIC_BITFIELDS)
+			{
+				int bit;
+
+				ReadleLong(f, &bmask);
+				ReadleLong(f, &gmask);
+				ReadleLong(f, &rmask);
+				for (bit = bitcount - 1; bit >= 0; bit--)
+				{
+					if (bmask & (1 << bit))
+						bshift = bit;
+					if (gmask & (1 << bit))
+						gshift = bit;
+					if (rmask & (1 << bit))
+						rshift = bit;
+				}
+				fclose(f); /* UNSUPPORTED BACKWARD COMPAT. */
+				return 0;
+			}
+			else if (bitcount == 16)
+			{
+				rmask = 0x7C00;
+				gmask = 0x03E0;
+				bmask = 0x001F;
+				rshift = 10;
+				gshift = 5;
+				bshift = 0;
+			}
+			else if (bitcount == 32)
+			{
+				rmask = 0x00FF0000;
+				gmask = 0x0000FF00;
+				bmask = 0x000000FF;
+				rshift = 16;
+				gshift = 8;
+				bshift = 0;
+			}
+		}
+
+	}
+
+	if (payload_ptr)
+	{
+		fseek(f, offset, SEEK_SET);
+        if (!*payload_ptr)
+        {
+            *payload_ptr = malloc(imgsize);
+        }
+        else if (!payload_size_ptr || *payload_size_ptr < imgsize)
+        {
+            return 0;
+        }
+
+
+		if (!*payload_ptr)
+		{
+			fclose(f);
+			return 0;
+		}
+
+		fread(*payload_ptr, imgsize, 1, f);
+	}
+
+    fclose(f);
+
+
+
+	if (colormap_ptr && bitcount < 16)
+	{
+
+        if (ncols==0)
+        {
+            char palname[512];
+            sprintf (palname, "%s.%s", filename, "pal");
+            f = fopen(palname, "rb");
+            if (f)
+            {
+                fread(rgbQuads, 4, ncols=256, f);
+                fclose(f);
+            }
+        }
+
+
+		if (ncols>0)
+		{
+            if (!*colormap_ptr)
+            {
+                *colormap_ptr = malloc(sizeof(RGBQUAD)*ncols);
+
+                if (!*colormap_ptr)
+                {
+                     return 0;
+                }
+            }
+            else if (!colormap_size_ptr
+                    || *colormap_size_ptr < sizeof(RGBQUAD)*ncols)
+            {
+                return 0;
+            }
+
+			memcpy(*colormap_ptr, rgbQuads, sizeof(RGBQUAD)*ncols);
+		}
+		else
+		{
+			*colormap_ptr = NULL;
+		}
+	}
+
+
+
+    if (payload_size_ptr)
+        *payload_size_ptr = imgsize;
+
+	if (colormap_size_ptr)
+		*colormap_size_ptr = sizeof(RGBQUAD)*ncols;
+
+    if (width_ptr)
+		*width_ptr = w;
+	if (height_ptr)
+		*height_ptr = h;
+	if (depth_ptr)
+		*depth_ptr = bitcount;
+	if (rawmode_ptr)
+		*rawmode_ptr  = comp == RLEIC_NONE		? 1:0;
+	if (bdmode_ptr)
+		*bdmode_ptr   = comp == RLEIC_BD_RLE8	? 1:0;
+	if (topfirst_ptr)
+		*topfirst_ptr = comp == RLEIC_BD_RLE8   ? 1:topfirst;
+	if (buffer_size_ptr)
+		*buffer_size_ptr =preambleSize+headSize+imgsize+sizeof(RGBQUAD)*ncols;
+
+	return 1;
+}
+
diff -Naur '--exclude=.git*' '--exclude=.cvsignore' DirectFB/tests/unit_test_rle_helpers.h DirectFB-1.4.12+STM2011.09.27/tests/unit_test_rle_helpers.h
--- DirectFB/tests/unit_test_rle_helpers.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.4.12+STM2011.09.27/tests/unit_test_rle_helpers.h	2012-06-06 18:41:31.000000000 +0200
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2006 ST-Microelectronics R&D <alain.clement@st.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef UNIT_TEST_RLE_HELPERS_H_
+#define UNIT_TEST_RLE_HELPERS_H_
+
+extern int rle_load_image (char           *filename,
+                           unsigned long  *width_ptr,
+                           unsigned long  *height_ptr,
+                           unsigned long  *depth_ptr,
+                           unsigned long  *rawmode_ptr,
+                           unsigned long  *bdmode_ptr,
+                           unsigned long  *topfirst_ptr,
+                           unsigned long  *buffer_size_ptr,
+                           void          **payload_ptr,
+                           unsigned long  *payload_size_ptr,
+                           void          **colormap_ptr,
+                           unsigned long  *colormap_size_ptr);
+
+#endif /* __UNIT_TEST_RLE_HELPERS_H__ */

diff -Naur DirectFB-1.7.7/configure.in DirectFB-1.7.7.stm/configure.in
--- DirectFB-1.7.7/configure.in	2015-02-09 18:16:46.000000000 +0100
+++ DirectFB-1.7.7.stm/configure.in	2015-05-15 18:48:56.629641067 +0200
@@ -1186,6 +1186,25 @@
 
 
 
+dnl Test for STMicroelectronics frame buffer system
+
+if test "$enable_fbdev" = "yes"; then
+  AC_CHECK_HEADER([linux/stmfb.h],
+                  [have_stmfb_h=yes
+                  AC_DEFINE(HAVE_STMFB_H,1,[Define to 1 if you have the <linux/stmfb.h> header file.])],
+                  [have_stmfb_h=no],
+                  [#include <linux/fb.h>])
+  AM_CONDITIONAL(STMFB_H, [test "$have_stmfb_h" = "yes"])
+fi
+
+AC_ARG_ENABLE(stmfbdev,
+              AC_HELP_STRING([--enable-stmfbdev],
+                             [build with STMicroelectronics stmfb system support @<:@default=auto@:>@]),
+              [], [enable_stmfbdev=yes])
+AM_CONDITIONAL(STMFBDEV_CORE, test "$enable_stmfbdev" = "yes")
+
+
+
 dnl Test for SDL
 AC_ARG_ENABLE(sdl,
               AC_HELP_STRING([--enable-sdl],
@@ -1242,7 +1261,7 @@
 if test "$enable_mesa" = "yes"; then
   PKG_CHECK_MODULES(MESA, [glesv2 egl libdrm gbm], [enable_mesa=yes], [enable_mesa=no
     AC_MSG_WARN([
-*** gl egl libdrm gbm packages not found -- Building without MESA support.])
+*** glesv2 egl libdrm gbm packages not found -- Building without MESA support.])
     ])
 fi
 
@@ -1268,13 +1287,79 @@
 
 
 
+dnl test for MME
+MME=no
+mme_own_headers=no
+mme_own_transformers=no
+AC_ARG_ENABLE(mme,
+              AC_HELP_STRING([--enable-mme],
+			     [build with MME support @<:@default=yes@:>@]),
+              [], [enable_mme=yes])
+if test "$enable_mme" = "yes" ; then
+    MME=yes
+    AC_DEFINE(USE_MME, 1, [Define to 1 if MME should be used])
+
+    dnl use our own copy of mme.h and try to dlopen() libmme.so
+    AC_MSG_WARN([*** MME library not found. Will use dlopen().])
+    AC_DEFINE(MME_USE_DLOPEN, 1, [Define to 1 if dlopen() etc should be used for MME libraries])
+    LIBMME=
+
+    AC_CHECK_HEADER([mme.h], [mme_ok="yes"], [mme_ok="no"])
+    if test "$mme_ok" != "yes"; then
+        AC_MSG_WARN([*** MME header files not found. Will use own copy!])
+        AC_DEFINE(MME_USE_OWN_HEADERS, 1, [Define to 1 if builtin MME headers should be used])
+        mme_own_headers=yes
+    fi
+    AC_CHECK_HEADERS([JPEG_TransformerTypes.h JPEGDECHW_VideoTransformerTypes.h PNGDecode_interface.h RLEDecode_interface.h],
+		     [mme_ok="yes"], [mme_ok="no"])
+    if test "$mme_ok" != "yes"; then
+        AC_MSG_WARN([*** MME Transformer header files not found. Will use own copies!])
+        mme_own_transformers=yes
+    fi
+else
+    MME=no
+fi
+
+AM_CONDITIONAL(MME_USE_OWN_HEADERS, test "$mme_own_headers" = "yes")
+AM_CONDITIONAL(MME_USE_OWN_TRANSFORMERS, test "$mme_own_transformers" = "yes")
+AC_SUBST(LIBMME)
+
+
+dnl Test for RLE
+RLE=no
+RLE_HW=no
+AC_ARG_ENABLE(rle,
+              AC_HELP_STRING([--enable-rle],
+	                     [build RLE image provider @<:@default=yes@:>@]),
+              [], [enable_rle=yes])
+if test "$enable_rle" = "yes" ; then
+  RLE=yes
+  if test "$MME" = "yes" ; then
+    AC_DEFINE(RLE_PROVIDER_USE_MME, 1, [Define to 1 if RLE provider should use MME, too])
+    RLE_LIBMME=$LIBMME
+  fi
+fi
+AM_CONDITIONAL(RLE_PROVIDER, test "$RLE" = "yes")
+AC_SUBST(RLE_LIBMME)
+
+
 dnl Test for libjpeg
 JPEG=no
+JPEG_HW=no
+JPEG_HW_V4L2=no
 
 AC_ARG_ENABLE(jpeg,
               AC_HELP_STRING([--enable-jpeg],
                              [build JPEG image provider @<:@default=yes@:>@]),
               [], [enable_jpeg=yes])
+AC_ARG_ENABLE(hwjpeg,
+              AC_HELP_STRING([--enable-hwjpeg],
+                             [add hardware acceleration to JPEG image provider @<:@default=yes@:>@]),
+              [], [enable_hwjpeg=yes])
+AC_ARG_ENABLE(hwjpeg_v4l2,
+              AC_HELP_STRING([--enable-hwjpeg-v4l2],
+                             [enable hardware accelerated JPEG decoding via V4L2 @<:@default=no@:>@]),
+              [], [enable_hwjpeg_v4l2=no])
 
 if test "$enable_jpeg" = "yes"; then
   if test -z "$LIBJPEG"; then
@@ -1303,11 +1388,37 @@
   fi
 fi
 
+if test "$enable_hwjpeg" != "no"; then
+  if test "$JPEG" = "yes"; then
+    if test "$MME" = "yes" ; then
+      AC_DEFINE(JPEG_PROVIDER_USE_MME, 1, [Define to 1 to enable hardware JPEG decoder])
+      JPEG_HW=yes
+      JPEG_LIBMME=$LIBMME
+    else
+      AC_MSG_WARN([*** MME not found. Hardware JPEG image provider will not be built.])
+      JPEG_HW=no
+    fi
+  else
+    AC_MSG_WARN([*** JPEG decoding not enabled. Hardware JPEG image provider can not be built.])
+    JPEG_HW=no
+  fi
+else
+  JPEG_HW=no
+fi
+
+if test "$enable_hwjpeg_v4l2" = "yes"; then
+  JPEG_HW_V4L2=yes
+fi
+
 AM_CONDITIONAL(JPEG_PROVIDER, test "$JPEG" = "yes")
+AM_CONDITIONAL(JPEG_PROVIDER_HW, test "$JPEG_HW" = "yes")
+AM_CONDITIONAL(JPEG_PROVIDER_HW_V4L2, test "$JPEG_HW_V4L2" = "yes")
 
-if test "$enable_jpeg" != "no" && test "$JPEG" != "yes"; then
-  jpeg_warning="
+if test "$JPEG" != "yes"; then
+  if test "$enable_jpeg" != "no" || test "$enable_hwjpeg" != "no" ; then
+    jpeg_warning="
 JPEG support is missing - many applications won't work correctly!"
+  fi
 fi
 
 
@@ -1341,22 +1452,49 @@
 
 dnl Test for libpng
 PNG=no
+PNG_HW=no
 
 AC_ARG_ENABLE(png,
               AC_HELP_STRING([--enable-png],
                              [build PNG image provider, @<:@default=yes@:>@]),
               [], [enable_png=yes])
+AC_ARG_ENABLE(hwpng,
+              AC_HELP_STRING([--enable-hwpng],
+	                     [add hardware acceleration to PNG image provider @<:@default=yes@:>@]),
+              [], enable_hwpng="yes")
+
 if test "$enable_png" = "yes"; then
   PKG_CHECK_MODULES([LIBPNG], [libpng >= 1.2.2], [PNG=yes], [PNG=no
     AC_MSG_WARN([*** PNG library not found. PNG image provider will not be built.])])
 fi
 
+if test "$enable_hwpng" != "no"; then
+  if test "$PNG" = "yes" ; then
+    if test "$MME" = "yes"; then
+      AC_DEFINE(PNG_PROVIDER_USE_MME, 1, [Define to 1 to enable hardware PNG decoder])
+      PNG_HW=yes
+      PNG_LIBMME=$LIBMME
+    else
+      AC_MSG_WARN([*** MME not found. Hardware PNG image provider will not be built.])
+      PNG_HW=no
+    fi
+  else
+    AC_MSG_WARN([*** PNG decoding not enabled. Hardware PNG image provider can not be built.])
+    PNG_HW=no
+  fi
+else
+  PNG_HW=no
+fi
+
 AM_CONDITIONAL(PNG_PROVIDER, test "$PNG" = "yes")
+AM_CONDITIONAL(PNG_PROVIDER_HW, test "$PNG_HW" = "yes")
 AM_CONDITIONAL(BUILD_DIRECTFB_CSOURCE, test "$PNG" = "yes")
 
-if test "$enable_png" != "no" && test "$PNG" != "yes"; then
-  png_warning="
+if test "$PNG" != "yes"; then
+  if test "$enable_png" != "no" || "$enable_hwpng" != "no" ; then
+    png_warning="
 PNG support is missing - many applications won't work correctly!"
+  fi
 fi
 
 
@@ -2628,7 +2766,7 @@
             AC_HELP_STRING([--with-runtime-sysroot=DIR],
                            [search for lib/share et al within DIR at runtime,]
                            [e.g. when loading modules]),
-            [RUNTIME_SYSROOT="$withval"], [RUNTIME_SYSROOT=])
+            [RUNTIME_SYSROOT=], [RUNTIME_SYSROOT=])
 test x"$RUNTIME_SYSROOT" = x"no" && RUNTIME_SYSROOT=
 AC_SUBST(RUNTIME_SYSROOT)
 
@@ -2646,6 +2784,14 @@
 fi
 
 
+AC_ARG_WITH(cxxstd,
+            AC_HELP_STRING([--with-cxxstd],
+                           [select C++ standard for compiler @<:@default=c++11@:>@]),
+            [cxxstd="$withval"], [cxxstd="c++11"])
+test x"$cxxstd" = x"no" && cxxstd="c++11"
+CXXSTD="$cxxstd"
+AC_SUBST(CXXSTD)
+
 
 AM_CONDITIONAL(GFX_ATI128, test "$ati128" = "yes")
 AM_CONDITIONAL(GFX_CLE266, test "$cle266" = "yes")
@@ -2750,11 +2896,14 @@
 AC_SUBST(GIF_PROVIDER)
 AC_SUBST(JPEG_PROVIDER)
 AC_SUBST(LIBJPEG)
+AC_SUBST(JPEG_LIBMME)
 AC_SUBST(MNG_PROVIDER)
 AC_SUBST(LIBMNG)
 AC_SUBST(PNG_PROVIDER)
 AC_SUBST(LIBPNG_CFLAGS)
 AC_SUBST(LIBPNG_LIBS)
+AC_SUBST(PNG_LIBMME)
+AC_SUBST(RLE_PROVIDER)
 AC_SUBST(FREETYPE_PROVIDER)
 AC_SUBST(FREETYPE_CFLAGS)
 AC_SUBST(FREETYPE_LIBS)
@@ -2887,6 +3036,7 @@
 systems/osx/Makefile
 systems/sdl/Makefile
 systems/vnc/Makefile
+systems/stmfbdev/Makefile
 
 wm/Makefile
 wm/default/Makefile
@@ -3032,6 +3182,7 @@
   Dithering 565             $with_dither_rgb16
   zlib compression          $use_zlib                 $ZLIB_LIBS
   Using setsockopt          $with_setsockopt
+  c++ compiler standard     $cxxstd
 
 Building Tests              $with_tests
 Building Tools              $with_tools
@@ -3048,6 +3199,7 @@
   OSX support               $enable_osx                 $OSX_CFLAGS $OSX_LIBS
   SDL support               $enable_sdl                 $SDL_CFLAGS $SDL_LIBS
   VNC support               $enable_vnc                 $VNC_CFLAGS $VNC_LIBS
+  STM stmfb support         $enable_stmfbdev
 
 Building Window Manager Modules:
   Default                   yes
@@ -3057,7 +3209,10 @@
 Building Image Provider Modules:
   GIF                       $enable_gif
   JPEG                      $JPEG                 $LIBJPEG
+    - hardware              $JPEG_HW                 $JPEG_LIBMME
+    - hardware via v4l2     $JPEG_HW_V4L2
   PNG                       $PNG                  $LIBPNG_CFLAGS $LIBPNG_LIBS
+    - hardware              $PNG_HW                 $PNG_LIBMME
   Imlib2                    $imlib2               $IMLIB2_CFLAGS $IMLIB2_LIBS
   PNM                       $enable_pnm
   SVG                       $svg                  $LIBSVG_CFLAGS $LIBSVG_LIBS
diff -Naur DirectFB-1.7.7/configure.in.orig DirectFB-1.7.7.stm/configure.in.orig
--- DirectFB-1.7.7/configure.in.orig	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7.stm/configure.in.orig	2015-05-15 18:43:05.010361968 +0200
@@ -0,0 +1,3172 @@
+dnl Process this file with autoconf to produce a configure script.
+
+AC_INIT(include/directfb.h)
+
+AC_PREREQ(2.52)
+
+#
+# Making releases:
+#   DIRECTFB_MICRO_VERSION += 1;
+#   DIRECTFB_INTERFACE_AGE += 1;
+#   DIRECTFB_BINARY_AGE += 1;
+# if any functions have been added, set DIRECTFB_INTERFACE_AGE to 0.
+# if backwards compatibility has been broken,
+# set DIRECTFB_BINARY_AGE and DIRECTFB_INTERFACE_AGE to 0.
+#
+#
+DIRECTFB_MAJOR_VERSION=1
+DIRECTFB_MINOR_VERSION=7
+DIRECTFB_MICRO_VERSION=7
+DIRECTFB_INTERFACE_AGE=0
+DIRECTFB_BINARY_AGE=0
+DIRECTFB_VERSION=$DIRECTFB_MAJOR_VERSION.$DIRECTFB_MINOR_VERSION.$DIRECTFB_MICRO_VERSION
+
+#fluxcomp 1.4.2
+FLUXCOMP_REQUIRED_VERSIONCODE=1004002
+
+AC_SUBST(DIRECTFB_MAJOR_VERSION)
+AC_SUBST(DIRECTFB_MINOR_VERSION)
+AC_SUBST(DIRECTFB_MICRO_VERSION)
+AC_SUBST(DIRECTFB_INTERFACE_AGE)
+AC_SUBST(DIRECTFB_BINARY_AGE)
+AC_SUBST(DIRECTFB_VERSION)
+
+AC_DEFINE_UNQUOTED(DIRECTFB_VERSION,"$DIRECTFB_VERSION",[The DirectFB version])
+
+#
+# DirectFB Vendor Version:
+#
+DIRECTFB_VERSION_VENDOR=$DIRECTFB_VERSION_VENDOR
+
+AC_SUBST(DIRECTFB_VERSION_VENDOR)
+
+AC_DEFINE_UNQUOTED(DIRECTFB_VERSION_VENDOR,"$DIRECTFB_VERSION_VENDOR",[Vendor specific version])
+
+
+# libtool versioning
+LT_RELEASE=$DIRECTFB_MAJOR_VERSION.$DIRECTFB_MINOR_VERSION
+LT_CURRENT=`expr $DIRECTFB_MICRO_VERSION - $DIRECTFB_INTERFACE_AGE`
+LT_BINARY=`expr $DIRECTFB_MICRO_VERSION - $DIRECTFB_BINARY_AGE`
+LT_REVISION=$DIRECTFB_INTERFACE_AGE
+LT_AGE=`expr $DIRECTFB_BINARY_AGE - $DIRECTFB_INTERFACE_AGE`
+
+AC_SUBST(LT_RELEASE)
+AC_SUBST(LT_CURRENT)
+AC_SUBST(LT_BINARY)
+AC_SUBST(LT_REVISION)
+AC_SUBST(LT_AGE)
+
+# The earliest version that this release has binary compatibility with.
+# This is used for module locations.
+BINARY_VERSION=$DIRECTFB_MAJOR_VERSION.$DIRECTFB_MINOR_VERSION-$LT_BINARY
+
+
+VERSION=$DIRECTFB_VERSION
+PACKAGE=DirectFB
+
+AC_CANONICAL_HOST
+AC_CANONICAL_TARGET
+
+AM_INIT_AUTOMAKE($PACKAGE, $VERSION, no-define)
+m4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])
+PKG_PROG_PKG_CONFIG
+
+
+AC_CONFIG_HEADER([config.h])
+AM_MAINTAINER_MODE
+AC_DISABLE_STATIC
+
+
+case x"$target" in
+  xNONE | x)
+    target_or_host="$host" ;;
+  *)
+    target_or_host="$target" ;;
+esac
+
+
+case "$target_or_host" in
+  *-cygwin)
+dnl    AC_ENABLE_STATIC
+dnl    AC_DISABLE_SHARED
+    ;;
+esac
+
+
+AC_PROG_CC
+AC_PROG_CXX
+AM_PROG_CC_C_O
+AC_PROG_CXX
+ifdef([AM_PROG_AS],[AM_PROG_AS],[])
+AM_PROG_LIBTOOL
+AM_SANITY_CHECK
+AC_SUBST(LD)
+AC_ISC_POSIX
+AC_PROG_INSTALL
+AC_PROG_MAKE_SET
+AC_HEADER_STDC
+AC_C_BIGENDIAN
+
+AC_CHECK_SIZEOF(int)
+AC_CHECK_SIZEOF(long)
+AC_CHECK_SIZEOF(long long)
+AC_CHECK_FUNCS(fork)
+
+
+## Work around libstuhl during cross build...
+if test "$host" != "$build"; then
+  sys_lib_dlsearch_path_spec=""
+  sys_lib_search_path_spec=""
+fi
+
+AC_PATH_PROGS(PERL, perl5 perl)
+
+AC_PATH_PROG(MAN2HTML, man2html, no)
+AC_SUBST(MAN2HTML)
+AM_CONDITIONAL(HAVE_MAN2HTML, test "$MAN2HTML" != "no")
+
+AC_PATH_TOOL(FLUXCOMP, fluxcomp)
+AC_SUBST(FLUXCOMP)
+if test -z "$FLUXCOMP"; then
+  if ! test -e $srcdir/src/core/CoreDFB.cpp; then
+    AC_MSG_ERROR([
+*** DirectFB compilation requires fluxcomp ***
+
+Unless you are compiling from a distributed tarball you need fluxcomp
+available from git://git.directfb.org/git/directfb/core/flux installed
+in your PATH.
+])
+  fi
+else
+  FLUXCOMP_VERSIONCODE=`$FLUXCOMP -V`
+  if test $FLUXCOMP_VERSIONCODE -lt $FLUXCOMP_REQUIRED_VERSIONCODE ; then
+    AC_MSG_ERROR([
+*** DirectFB compilation requires a newer fluxcomp ***
+available from git://git.directfb.org/git/directfb/core/flux
+])
+  fi
+fi
+
+dnl Test for OSX
+AC_ARG_ENABLE(osx,
+              AC_HELP_STRING([--enable-osx],
+                             [build with Mac OS X support @<:@default=auto@:>@]),
+              [], [enable_osx=yes])
+if test "$enable_osx" = "yes"; then
+  AC_CHECK_HEADER(Carbon/Carbon.h, osx_found=yes, osx_found=no)
+  if test "$osx_found" = no; then
+    enable_osx=no
+    AC_MSG_WARN([
+*** no Carbon/Carbon.h found -- building without Mac OS X support.])
+  else
+    OSX_LIBS="-framework Carbon"
+  fi
+fi
+
+AM_CONDITIONAL(OSX_CORE, test "$enable_osx" = "yes")
+
+dnl Test for X11
+AC_ARG_ENABLE(x11,
+              AC_HELP_STRING([--enable-x11],
+                             [build with X11 support @<:@default=auto@:>@]),
+              [], [enable_x11=yes])
+if test "$enable_x11" = "yes"; then
+  PKG_CHECK_MODULES([X11], [xproto x11 xext], [enable_x11="yes"], [enable_x11="no"
+    AC_MSG_WARN([*** no X11 found -- building without X11 support])])
+fi
+
+AM_CONDITIONAL(X11_CORE, test "$enable_x11" = "yes")
+
+
+dnl Test for X11VDPAU
+AC_ARG_ENABLE(x11vdpau,
+              AC_HELP_STRING([--enable-x11vdpau],
+                             [build with X11/VDPAU support @<:@default=auto@:>@]),
+              [], [enable_x11vdpau=yes])
+if test "$enable_x11vdpau" = "yes"; then
+  PKG_CHECK_MODULES([X11VDPAU], [xproto x11 xext vdpau], [enable_x11vdpau="yes"], [enable_x11vdpau="no"
+    AC_MSG_WARN([*** no X11/VDPAU found -- building without X11/VDPAU support])])
+fi
+
+AM_CONDITIONAL(X11VDPAU_CORE, test "$enable_x11vdpau" = "yes")
+
+
+AC_CHECK_HEADERS(linux/compiler.h linux/unistd.h asm/page.h signal.h)
+
+
+dnl Clear default CFLAGS
+if test x"$CFLAGS" = x"-g -O2"; then
+  CFLAGS=
+fi
+
+CFLAGS="-ffast-math -pipe $CFLAGS"
+
+DFB_INTERNAL_CFLAGS="-D_GNU_SOURCE $DFB_INTERNAL_CFLAGS"
+
+AC_ARG_ENABLE(extra-warnings,
+              AC_HELP_STRING([--enable-extra-warnings],
+                             [enable extra warnings @<:@default=no@:>@]),
+              [], [enable_extra_warnings=no])
+if test "$enable_extra_warnings" = "yes"; then
+  CFLAGS="-W -Wno-sign-compare -Wno-unused-parameter -Wundef -Wcast-qual -Wcast-align -Waggregate-return -Wmissing-declarations -Winline $CFLAGS"
+fi
+
+# FIXME
+#if test "$GCC" = "yes"; then
+#  CFLAGS="-Wall -Wno-strict-aliasing $CFLAGS"
+#fi
+
+if test "$GCC" = "yes"; then
+  CFLAGS_STD="-std=gnu99"
+fi
+
+
+#
+# check target architecture
+#
+have_x86=no
+have_x86_64=no
+have_arm=no
+have_mips=no
+have_ppc=no
+have_sh=no
+have_sh3=no
+have_sh4=no
+
+case "$target_or_host" in
+  i*86-*-*)
+    have_x86=yes
+    AC_DEFINE(ARCH_X86,1,[Define to 1 if you are compiling for ix86.])
+    ;;
+
+  x86_64-*)
+    have_x86=yes
+    have_x86_64=yes
+    AC_DEFINE(ARCH_X86_64,1,[Define to 1 if you are compiling for AMD64.])
+    ;;
+
+  *arm*)
+    have_arm=yes
+	AC_DEFINE(ARCH_ARM,1,[Define to 1 if you are compiling for ARM.])
+    if test -n "`echo $CFLAGS | grep 'march=armv7\-a'`"; then
+      AC_DEFINE(ARCH_ARMv7,1,[Define to 1 if you are compiling for ARMv7.])
+    fi
+    ;;
+
+  *mips*)
+    have_mips=yes
+    AC_DEFINE(ARCH_MIPS,1,[Define to 1 if you are compiling for MIPS.])
+    ;;
+
+  ppc-*-linux* | powerpc-*)
+    have_ppc=yes
+    AC_DEFINE(ARCH_PPC,1,[Define to 1 if you are compiling for PowerPC.])
+    ;;
+
+  sh3-*)
+    have_sh=yes
+    have_sh3=yes
+    AC_DEFINE(ARCH_SH,1,[Define to 1 if you are compiling for SuperH.])
+    AC_DEFINE(ARCH_SH3,1,[Define to 1 if you are compiling for SH3.])
+    ;;
+
+  sh4-* | sh-*)
+    have_sh=yes
+    have_sh4=yes
+    AC_DEFINE(ARCH_SH,1,[Define to 1 if you are compiling for SuperH.])
+    AC_DEFINE(ARCH_SH4,1,[Define to 1 if you are compiling for SH4.])
+    ;;
+
+  *)
+    ;;
+esac
+
+
+have_linux=no
+have_cygwin=no
+have_kos=no
+need_libc_r=no
+need_libdl=yes
+need_librt=no
+want_ppcasm=yes
+want_armasm=yes
+
+case "$target_or_host" in
+  *-*linux*)
+    have_linux=yes
+    need_librt=yes
+    ;;
+
+  *-cygwin)
+    have_cygwin=yes
+    need_libdl=no
+    ;;
+
+  *-freebsd*)
+    need_libc_r=yes
+    need_libdl=no
+    want_ppcasm=yes
+	want_armasm=yes
+    CPPFLAGS="$CPPFLAGS -I/usr/local/include"
+    LDFLAGS="$LDFLAGS -L/usr/local/lib"
+    ;;
+
+  *-openbsd*)
+    need_libc_r=yes
+    need_libdl=no
+    want_ppcasm=no
+	want_armasm=no
+    CPPFLAGS="$CPPFLAGS -I/usr/local/include"
+    LDFLAGS="$LDFLAGS -L/usr/local/lib"
+    ;;
+
+  *-netbsd*)
+    need_libc_r=no
+    need_libdl=no
+    want_ppcasm=yes
+	want_armasm=yes
+    CPPFLAGS="$CPPFLAGS -I/usr/pkg/include"
+    LDFLAGS="$LDFLAGS -L/usr/pkg/lib"
+    ;;
+
+  *-darwin*)
+    need_libc_r=no
+    need_libdl=yes
+    want_ppcasm=no
+	want_armasm=no
+    CPPFLAGS="$CPPFLAGS -I/sw/include"
+    LDFLAGS="$LDFLAGS -L/sw/lib"
+    ;;
+
+  sh-*-elf)
+    if test "$CC" = "kos-cc"; then
+      need_libc_r=no
+      need_libdl=no
+      have_kos=yes
+    fi
+    ;;
+esac
+
+AM_CONDITIONAL(HAVE_LINUX, test "$have_linux" = "yes")
+
+AM_CONDITIONAL(BUILDPPCASM, test "$have_ppc" = "yes" && test "$want_ppcasm" = "yes")
+
+if test "$have_ppc" = "yes" && test "$want_ppcasm" = "yes"; then
+    AC_DEFINE(USE_PPCASM,1,[Define to 1 if ppc assembly is available.])
+fi
+
+
+AM_CONDITIONAL(BUILDARMASM, test "$have_arm" = "yes" && test "$want_armasm" = "yes")
+
+if test "$have_arm" = "yes" && test "$want_armasm" = "yes"; then
+    AC_DEFINE(USE_ARMASM,1,[Define to 1 if arm assembly is available.])
+fi
+
+if test "$have_kos" = "yes"; then
+    AC_DEFINE(USE_KOS,1,[Define to 1 if compiling on KallistiOS.])
+fi
+
+dnl Threads
+
+THREADFLAGS="-D_REENTRANT"
+
+if test "$have_kos" = "no"; then
+  if test "$need_libc_r" = "yes"; then
+    AC_CHECK_LIB(c_r, pthread_attr_init, ,
+      AC_MSG_ERROR([
+*** DirectFB requires phtreads in libc_r.]))
+    THREADLIB="-lc_r"
+  else
+    AC_CHECK_LIB(pthread, pthread_attr_init, ,
+      AC_MSG_ERROR([
+*** DirectFB requires libpthread.]))
+    THREADLIB="-lpthread"
+  fi
+fi
+
+AC_CHECK_DECLS(PTHREAD_MUTEX_RECURSIVE,,
+  AC_MSG_WARN([
+*** PTHREAD_MUTEX_RECURSIVE is not defined! Dead locks might occur!]), [
+#define _GNU_SOURCE
+#include <pthread.h>])
+
+AC_CHECK_DECLS(PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP,,
+  AC_MSG_WARN([
+*** PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP is not defined! Dead locks might occur!]), [
+#define _GNU_SOURCE
+#include <pthread.h>])
+
+AC_SUBST(THREADFLAGS)
+AC_SUBST(THREADLIB)
+
+CPPFLAGS="$THREADFLAGS $CPPFLAGS"
+
+
+dnl RT Library
+RTLIB=""
+if test "$need_librt" = "yes"; then
+  AC_CHECK_LIB(rt, clock_gettime, ,
+    AC_MSG_ERROR([
+*** DirectFB requires librt.]))
+  RTLIB="-lrt"
+fi
+
+AC_SUBST(RTLIB)
+
+
+dnl Dynamic Linker
+DYNLIB=""
+if test "$need_libdl" = "yes"; then
+  if test "$enable_shared" = "yes"; then
+    AC_CHECK_LIB(dl, dlopen, ,
+      AC_MSG_ERROR([
+*** DirectFB requires libdl.]))
+    DYNLIB="-ldl"
+  fi
+fi
+
+AC_SUBST(DYNLIB)
+
+
+if test "$have_x86" = "yes"; then
+##
+## HACK HACK HACK automake uses @AS@ like a gcc
+##
+  AS=$CC
+  ASFLAGS=$CFLAGS
+  AC_SUBST(AS)
+  AC_SUBST(ASFLAGS)
+
+  AC_DEFINE(HAVE_INB_OUTB_IOPL,1,
+            [Define to 1 if inb, outb and iopl are available.])
+  AC_MSG_CHECKING([for sys/io.h])
+  AC_TRY_COMPILE([#include <sys/io.h>], [char x = inb(0); (void)x;],
+    AC_DEFINE(HAVE_SYSIO,1,
+              [Define to 1 if you have the <sys/io.h> header file.])
+    have_sysio=yes
+    AC_MSG_RESULT(yes),
+    AC_MSG_RESULT(no))
+else
+  have_sysio=no
+fi
+
+
+AC_ARG_ENABLE(profiling,
+              AC_HELP_STRING([--enable-profiling],
+                             [enable profiling support @<:@default=no@:>@]),
+              [], [enable_profiling=no])
+if test "$enable_profiling" = "yes"; then
+    CFLAGS="$CFLAGS -pg -g3"
+else
+    DFB_CFLAGS_OMIT_FRAME_POINTER="-fomit-frame-pointer"
+fi
+
+
+AC_ARG_ENABLE(debug,
+              AC_HELP_STRING([--enable-debug],
+                             [enable debugging @<:@default=no@:>@]),
+              [], [enable_debug=no])
+if test "$enable_debug" = "yes"; then
+    CFLAGS="-g3 -O0 -fno-inline -Wno-inline $CFLAGS"
+    DIRECT_BUILD_DEBUG=1
+else
+    DIRECT_BUILD_DEBUG=0
+fi
+AM_CONDITIONAL(ENABLE_DEBUG, test "$enable_debug" = "yes")
+
+AC_SUBST(DIRECT_BUILD_DEBUG)
+
+
+AC_ARG_ENABLE(debug-support,
+              AC_HELP_STRING([--enable-debug-support],
+                             [enable debugging support @<:@default=yes@:>@]),
+              [], [enable_debug_support=yes])
+if test "$enable_debug_support" = "yes" || test "$enable_debug" = "yes"; then
+    enable_debug_support=yes
+    if test "$enable_debug" = "no"; then
+        CFLAGS="-g2 $CFLAGS"
+    fi
+    CFLAGS="-O3 $CFLAGS"
+    DIRECT_BUILD_DEBUGS=1
+else
+    CFLAGS="-O3 -g0 $CFLAGS"
+    DIRECT_BUILD_DEBUGS=0
+fi
+AM_CONDITIONAL(ENABLE_DEBUGS, test "$enable_debug_support" = "yes")
+
+AC_SUBST(DIRECT_BUILD_DEBUGS)
+
+
+AC_ARG_ENABLE(trace,
+              AC_HELP_STRING([--enable-trace],
+                             [enable call tracing @<:@default=no@:>@]),
+              [], [enable_trace=no])
+if test "$enable_trace" = "yes"; then
+    DFB_INTERNAL_CFLAGS="$DFB_INTERNAL_CFLAGS -finstrument-functions"
+    DIRECT_BUILD_TRACE=1
+else
+    DIRECT_BUILD_TRACE=0
+fi
+AM_CONDITIONAL(ENABLE_TRACE, test "$enable_trace" = "yes")
+
+AC_SUBST(DIRECT_BUILD_TRACE)
+
+
+AC_ARG_ENABLE(text,
+              AC_HELP_STRING([--enable-text],
+                             [enable text output @<:@default=yes@:>@]),
+              [], [enable_text=yes])
+if test "$enable_text" = "no"; then
+    DIRECT_BUILD_TEXT=0
+else
+    DIRECT_BUILD_TEXT=1
+fi
+
+AC_SUBST(DIRECT_BUILD_TEXT)
+
+
+AC_ARG_ENABLE(gettid,
+              AC_HELP_STRING([--enable-gettid],
+                             [enable usage of gettid() @<:@default=yes@:>@]),
+              [], [enable_gettid=yes])
+if test "$enable_gettid" = "no"; then
+    DIRECT_BUILD_GETTID=0
+else
+    DIRECT_BUILD_GETTID=1
+fi
+
+AC_SUBST(DIRECT_BUILD_GETTID)
+
+
+AC_ARG_ENABLE(network,
+              AC_HELP_STRING([--enable-network],
+                             [enable network support @<:@default=yes@:>@]),
+              [], [enable_network=yes])
+if test "$enable_network" = "no"; then
+    DIRECT_BUILD_NETWORK=0
+else
+    DIRECT_BUILD_NETWORK=1
+fi
+
+AC_SUBST(DIRECT_BUILD_NETWORK)
+
+
+AC_CHECK_HEADER(stdbool.h, DIRECT_BUILD_STDBOOL=1, DIRECT_BUILD_STDBOOL=0)
+
+AC_SUBST(DIRECT_BUILD_STDBOOL)
+
+
+AC_ARG_ENABLE(dynload,
+              AC_HELP_STRING([--enable-dynload],
+                             [enable dynload support @<:@default=yes@:>@]),
+              [], [enable_dynload=yes])
+if test "$enable_dynload" = "no"; then
+    DIRECT_BUILD_DYNLOAD=0
+else
+    DIRECT_BUILD_DYNLOAD=1
+fi
+
+AC_SUBST(DIRECT_BUILD_DYNLOAD)
+
+
+AC_ARG_ENABLE(multicore,
+              AC_HELP_STRING([--enable-multicore],
+                             [enable multicore support @<:@default=yes@:>@]),
+              [],[enable_multicore=yes])
+if test "$enable_multicore" = "no"; then
+    DIRECT_BUILD_MULTICORE=0
+else
+    DIRECT_BUILD_MULTICORE=1
+fi
+
+AC_SUBST(DIRECT_BUILD_MULTICORE)
+
+
+AC_ARG_ENABLE(gcc-atomics,
+              AC_HELP_STRING([--enable-gcc-atomics],
+                             [force GCC atomics usage (prefer over arch specific) @<:@default=no@:>@]),
+              [],[enable_gcc_atomics=no])
+if test "$enable_gcc_atomics" = "no"; then
+    DIRECT_BUILD_GCC_ATOMICS=0
+else
+    DIRECT_BUILD_GCC_ATOMICS=1
+fi
+
+AC_SUBST(DIRECT_BUILD_GCC_ATOMICS)
+
+
+DIRECT_BUILD_OSTYPE=DIRECT_OS_LINUX_GNU_LIBC
+AC_SUBST(DIRECT_BUILD_OSTYPE)
+
+
+AC_ARG_ENABLE(multi,
+              AC_HELP_STRING([--disable-multi],
+                             [disable multi application core @<:@default=no@:>@]),
+              [], [enable_multi=no])
+if test "$enable_multi" = "yes"; then
+  FUSION_BUILD_MULTI=1
+else
+  FUSION_BUILD_MULTI=0
+  enable_multi=no
+fi
+
+
+
+AC_ARG_ENABLE(multi-kernel,
+              AC_HELP_STRING([--enable-multi-kernel],
+                             [enable multi app linux fusion kernel device @<:@default=yes@:>@]),
+              [], [enable_multi_kernel=yes])
+
+if test "$enable_multi" = "yes"; then
+  dnl Test for Fusion Kernel Device
+
+  if test "$enable_multi_kernel" = "yes"; then
+    AC_CHECK_HEADER( [linux/fusion.h], [], [enable_multi_kernel=no])
+    if test "$enable_multi_kernel" = "no"; then
+       AC_MSG_ERROR([
+*** Linux-Fusion header not found. Required for --enable-multi-kernel option! *** ])
+    fi
+  fi
+fi
+
+if test "$enable_multi_kernel" = "yes"; then
+  FUSION_BUILD_KERNEL=1
+else
+  FUSION_BUILD_KERNEL=0
+  enable_multi_kernel=no
+fi
+
+
+
+AC_ARG_ENABLE(one,
+              AC_HELP_STRING([--enable-one],
+                             [enable One (IPC) @<:@default=no@:>@]),
+              [], [enable_one=no])
+if test "$enable_one" = "yes"; then
+    DIRECTFB_BUILD_ONE=1
+    DEP_ONE=one
+else
+    DIRECTFB_BUILD_ONE=0
+    enable_one=no
+    DEP_ONE=
+fi
+
+
+AC_ARG_ENABLE(voodoo,
+              AC_HELP_STRING([--enable-voodoo],
+                             [enable Voodoo (network support) @<:@default=no@:>@]),
+              [], [enable_voodoo=no])
+if test "$enable_voodoo" = "yes"; then
+    DIRECTFB_BUILD_VOODOO=1
+    DEP_VOODOO=voodoo
+else
+    DIRECTFB_BUILD_VOODOO=0
+    enable_voodoo=no
+    DEP_VOODOO=
+fi
+
+
+AC_ARG_ENABLE(pure_voodoo,
+              AC_HELP_STRING([--enable-pure-voodoo],
+                             [enable pure Voodoo mode @<:@default=no@:>@]),
+              [], [enable_pure_voodoo=no])
+if test "$enable_pure_voodoo" = "yes"; then
+    enable_voodoo=yes
+    DIRECTFB_BUILD_VOODOO=1
+    DIRECTFB_BUILD_PURE_VOODOO=1
+    DEP_VOODOO=voodoo
+
+    enable_multi=no
+
+    DIRECTFB_BUILD_ONE=0
+    enable_one=no
+
+    FUSION_BUILD_MULTI=0
+    FUSION_BUILD_KERNEL=0
+else
+    DIRECTFB_BUILD_PURE_VOODOO=0
+    enable_pure_voodoo=no
+fi
+
+AC_ARG_ENABLE(divine,
+              AC_HELP_STRING([--enable-divine],
+                             [enable DiVine @<:@default=no@:>@]),
+              [], [enable_divine=no])
+
+AC_ARG_ENABLE(sawman,
+              AC_HELP_STRING([--enable-sawman],
+                             [enable SaWMan (window manager and application mananger) @<:@default=no@:>@]),
+              [], [enable_sawman=no])
+
+AC_ARG_ENABLE(fusiondale,
+              AC_HELP_STRING([--enable-fusiondale],
+                             [enable FusionDale @<:@default=no@:>@]),
+              [], [enable_fusiondale=no])
+
+AC_ARG_ENABLE(fusionsound,
+              AC_HELP_STRING([--enable-fusionsound],
+                             [enable FusionSound @<:@default=no@:>@]),
+              [], [enable_fusionsound=no])
+if test "$enable_fusionsound" = "yes"; then
+  AC_DEFINE(HAVE_FUSIONSOUND,1,[Define to 1 if you want FusionSound support.])
+fi
+
+#
+# fusionsound options
+#
+
+AC_ARG_ENABLE(fs-ieee-floats,
+              AC_HELP_STRING([--enable-fs-ieee-floats],
+                             [enable using IEEE floats for internal mixing routines @<:@default=no@:>@]),
+              [], [enable_fs_ieee_floats=no])
+if test "x$enable_fs_ieee_floats" = xyes; then
+  AC_DEFINE(FS_USE_IEEE_FLOATS,1,[Define to 1 to enable IEEE floats for mixing routines.])
+fi
+
+AC_ARG_ENABLE(fs-precision,
+              AC_HELP_STRING([--enable-fs-precision],
+                             [privilege precision over speed @<:@default=auto@:>@]),
+              [], [enable_fs_precision=auto])
+if test "x$enable_fs_precision" = xauto; then
+  if test "x$have_x86" = xyes || test "x$have_ppc" = xyes; then
+    enable_fs_precision=yes
+  else
+    enable_fs_precision=no
+  fi
+fi
+if test "x$enable_fs_precision" = xyes; then
+  AC_DEFINE(FS_ENABLE_PRECISION,1,[Define to 1 to enable precision.])
+fi
+
+AC_ARG_ENABLE(fs-linear-filter,
+              AC_HELP_STRING([--enable-fs-linear-filter],
+                             [enable linear filtering @<:@default=yes@:>@]),
+              [], [enable_fs_linear_filter=yes])
+if test "x$enable_fs_linear_filter" = xyes; then
+  AC_DEFINE(FS_ENABLE_LINEAR_FILTER,1,[Define to 1 to enable linear filter.])
+fi
+
+AC_ARG_ENABLE(fs-multichannel,
+              AC_HELP_STRING([--disable-fs-multichannel],
+                             [disable support for more than 2 channels @<:@default=no@:>@]),
+              [], [enable_fs_multichannel=yes])
+if test "x$enable_fs_multichannel" = xyes; then
+  FS_MAX_CHANNELS=6
+else
+  FS_MAX_CHANNELS=2
+fi
+AC_SUBST(FS_MAX_CHANNELS)
+
+
+# Check for fusionsound drivers
+#
+fsdriver_oss=no
+fsdriver_alsa=no
+fsdriver_wave=no
+
+AC_MSG_CHECKING(which fusionsound drivers should be built)
+AC_ARG_WITH(fs-drivers,
+            AC_HELP_STRING([--with-fs-drivers=LIST],
+                           [LIST is a comma separated selection of fusionsound drivers]
+                           [to build. Possible drivers are: all (builds all]
+                           [drivers), none (builds none), oss, alsa, wave.]
+                           [@<:@default=all@:>@]),
+            [fsdrivers="$withval"], [fsdrivers=all])
+if test "$fsdrivers" = "all"; then
+  checkfor_oss=yes
+  checkfor_alsa=yes
+  checkfor_wave=yes
+else
+  if test "$fsdrivers" != "none"; then
+    fsdrivers=`echo $fsdrivers | sed 's/,/ /g'`
+    for fsdriver in $fsdrivers
+    do
+      case "$fsdriver" in
+        oss)
+            checkfor_oss=yes
+            ;;
+        alsa)
+            checkfor_alsa=yes
+            ;;
+        wave)
+            checkfor_wave=yes
+            ;;
+        *)
+            ;;
+      esac
+    done
+  fi
+fi
+
+AC_MSG_RESULT($fsdrivers)
+
+if test "x$checkfor_oss" = "xyes"; then
+  AC_CHECK_HEADER( [sys/soundcard.h], fsdriver_oss=yes, fsdriver_oss=no
+  AC_MSG_WARN([*** OSS driver will not be built.]))
+fi
+
+if test "x$checkfor_alsa" = "xyes"; then
+  AC_MSG_CHECKING(for alsa >= 0.9)
+  if $PKG_CONFIG --atleast-version 0.9 alsa; then
+     ALSA_CFLAGS=`$PKG_CONFIG --cflags alsa`
+     ALSA_LIBS=`$PKG_CONFIG --libs alsa`
+     fsdriver_alsa=yes
+     AC_MSG_RESULT(yes)
+  else
+     AC_MSG_RESULT(no)
+  fi
+fi
+
+if test "x$checkfor_wave" = "xyes"; then
+  fsdriver_wave=yes
+fi
+
+AC_SUBST(ALSA_CFLAGS)
+AC_SUBST(ALSA_LIBS)
+
+AM_CONDITIONAL(BUILD_OSS, test "x$fsdriver_oss" = "xyes")
+AM_CONDITIONAL(BUILD_ALSA, test "x$fsdriver_alsa" = "xyes")
+AM_CONDITIONAL(BUILD_WAVE, test "x$fsdriver_wave" = "xyes")
+
+
+# fusionsound music providers
+
+#
+# Check for Timidity
+#
+timidity="no"
+AC_ARG_WITH(timidity,
+            AC_HELP_STRING([--with-timidity],
+                           [build Timidity music provider @<:@default=yes@:>@]),
+            [], [with_timidity=yes])
+if test "x$with_timidity" = "xyes"; then
+  AC_MSG_CHECKING([for libtimidity >= 0.1.0])
+  if $PKG_CONFIG --atleast-version=0.1.0 libtimidity; then
+    AC_MSG_RESULT(yes)
+    timidity="yes"
+    TIMIDITY_CFLAGS=`$PKG_CONFIG --cflags libtimidity`
+    TIMIDITY_LIBS=`$PKG_CONFIG --libs libtimidity`
+  else
+    AC_MSG_RESULT(no)
+    AC_MSG_WARN([
+*** libtimidity is required - Timidity music provider will not be built.])
+  fi
+fi
+
+AC_SUBST(TIMIDITY_CFLAGS)
+AC_SUBST(TIMIDITY_LIBS)
+AM_CONDITIONAL(BUILD_TIMIDITY, test "x$timidity" = "xyes")
+
+
+#
+# Check for Wave
+#
+AC_ARG_WITH(wave,
+            AC_HELP_STRING([--with-wave],
+                           [build Wave music provider @<:@default=yes@:>@]),
+            [if test $fsdriver_wave != yes ; then
+               with_wave="$withval"
+             else
+               with_wave=yes
+             fi], [with_wave=yes])
+
+AM_CONDITIONAL(BUILD_WAVE, test "x$with_wave" = "xyes")
+
+
+#
+# Check for Vorbis
+#
+vorbis="no"
+tremor="no"
+AC_ARG_WITH(vorbis,
+            AC_HELP_STRING([--with-vorbis],
+                           [build Ogg/Vorbis music provider @<:@default=yes@:>@]),
+            [], [with_vorbis=yes])
+AC_ARG_WITH(tremor,
+            AC_HELP_STRING([--with-tremor],
+                           [build Ogg/Vorbis music provider using Tremor @<:@default=no@:>@]),
+            [], [with_tremor=no])
+if test "x$with_vorbis" = "xyes"; then
+  if test "x$with_tremor" = "xyes"; then
+    AC_CHECK_HEADER(tremor/ivorbiscodec.h,
+      AC_CHECK_LIB(vorbisidec, ov_clear, tremor="yes", ), )
+
+    if test "x$tremor" = "xyes"; then
+      vorbis="yes"
+      VORBISFILE_CFLAGS=""
+      VORBISFILE_LIBS="-lvorbisidec"
+      AC_DEFINE(USE_TREMOR,1,[Define to 1 to use Tremor Ogg/Vorbis decoder.])
+    else
+      AC_MSG_WARN([
+*** Tremor is required - Ogg/Vorbis music provider will not be built.])
+    fi
+  else
+    VORBIS_REQUIRED_VERSION=1.0.0
+    AC_MSG_CHECKING(for vorbisfile >= $VORBIS_REQUIRED_VERSION)
+
+    if $PKG_CONFIG --atleast-version $VORBIS_REQUIRED_VERSION vorbisfile; then
+      vorbis="yes"
+      VORBISFILE_CFLAGS=`$PKG_CONFIG --cflags vorbisfile`
+      VORBISFILE_LIBS=`$PKG_CONFIG --libs vorbisfile`
+      AC_MSG_RESULT(yes)
+    else
+      AC_MSG_RESULT(no)
+      AC_MSG_WARN([
+*** vorbisfile $VORBIS_REQUIRED_VERSION or newer is required - Ogg/Vorbis music provider will not be built.])
+    fi
+  fi
+fi
+
+AC_SUBST(VORBISFILE_CFLAGS)
+AC_SUBST(VORBISFILE_LIBS)
+AM_CONDITIONAL(BUILD_VORBIS, test "x$vorbis" = "xyes")
+
+
+#
+# Check for MAD
+#
+mad="no"
+AC_ARG_WITH(mad,
+            AC_HELP_STRING([--with-mad],
+                           [build MAD MP3 music provider @<:@default=yes@:>@]),
+            [], [with_mad=yes])
+if test "x$with_mad" = "xyes"; then
+  AC_CHECK_LIB(mad, mad_timer_add, mad="yes", mad="no")
+  if test "x$mad" = "xyes"; then
+    AC_CHECK_HEADER(mad.h, mad="yes", mad="no")
+    if test "x$mad" = "xno"; then
+      AC_MSG_WARN([
+*** MAD header not found - MAD music provider will not be built.])
+    else
+      MAD_LIBS="-lmad"
+    fi
+  else
+    AC_MSG_WARN([
+*** MAD library not found - MAD music provider will not be built.])
+  fi
+fi
+
+AC_SUBST(MAD_LIBS)
+AM_CONDITIONAL(BUILD_MAD, test "x$mad" = "xyes")
+
+
+#
+# Check for CD-DA
+#
+cdda="no"
+AC_ARG_WITH(cdda,
+            AC_HELP_STRING([--with-cdda],
+                           [build CD-DA music provider @<:@default=yes@:>@]),
+            [], [with_cdda=yes])
+if test "x$with_cdda" = "xyes"; then
+  cdda="yes"
+  if $PKG_CONFIG --atleast-version 1.0.0 libcddb; then
+    AC_DEFINE(HAVE_CDDB,1,[Define to 1 if you have libcddb.])
+    CDDB_CFLAGS=`$PKG_CONFIG --cflags libcddb`
+    CDDB_LIBS=`$PKG_CONFIG --libs libcddb`
+  else
+    AC_MSG_WARN([
+*** libcddb 1.0.0 or newer not found - CD-DA Music Provider will be built without CDDB support.])
+  fi
+fi
+
+AC_SUBST(CDDB_CFLAGS)
+AC_SUBST(CDDB_LIBS)
+AM_CONDITIONAL(BUILD_CDDA, test "x$cdda" = "xyes")
+
+
+#
+# Check for Playlist
+#
+AC_ARG_WITH(playlist,
+            AC_HELP_STRING([--with-playlist],
+                           [build Playlist music provider @<:@default=yes@:>@]),
+            [], [with_playlist=yes])
+
+AM_CONDITIONAL(BUILD_PLAYLIST, test "x$with_playlist" = "xyes")
+
+# fusionsound music providers end
+
+
+AC_SUBST(DIRECTFB_BUILD_ONE)
+AM_CONDITIONAL(DIRECTFB_BUILD_ONE, test "$DIRECTFB_BUILD_ONE" = "1")
+
+AC_SUBST(DIRECTFB_BUILD_VOODOO)
+AM_CONDITIONAL(DIRECTFB_BUILD_VOODOO, test "$DIRECTFB_BUILD_VOODOO" = "1")
+
+AC_SUBST(DIRECTFB_BUILD_PURE_VOODOO)
+AM_CONDITIONAL(DIRECTFB_BUILD_PURE_VOODOO, test "$DIRECTFB_BUILD_PURE_VOODOO" = "1")
+
+AC_SUBST(DEP_ONE)
+AC_SUBST(DEP_VOODOO)
+
+dnl If we're not building a pure voodoo lib, we need sqrt sin cos for
+dnl various files
+LIBM=""
+if test "$enable_pure_voodoo" = "no"; then
+    safe_LIBS=$LIBS
+    save_CFLAGS="$CFLAGS"
+    CFLAGS="$CFLAGS -Wno-error"
+    AC_SEARCH_LIBS([sqrt], [m], [LIBM=$ac_cv_search_sqrt], [LIBM=no], [])
+    CFLAGS="$save_CFLAGS"
+    LIBS=$safe_LIBS
+    if test "$LIBM" = "none required" ; then
+        LIBM=""
+    elif test "$LIBM" = "no" ; then
+        AC_MSG_ERROR([*** DirectFB requires libm.])
+    fi
+fi
+AC_SUBST(LIBM)
+
+AM_CONDITIONAL(ENABLE_MULTI, test "$enable_multi" = "yes")
+
+AC_SUBST(FUSION_BUILD_MULTI)
+AC_SUBST(FUSION_BUILD_KERNEL)
+
+AM_CONDITIONAL(ENABLE_ONE, test "$enable_one" = "yes")
+AM_CONDITIONAL(ENABLE_VOODOO, test "$enable_voodoo" = "yes")
+AM_CONDITIONAL(ENABLE_SAWMAN, test "$enable_sawman" = "yes")
+AM_CONDITIONAL(ENABLE_FUSIONDALE, test "$enable_fusiondale" = "yes")
+AM_CONDITIONAL(ENABLE_FUSIONSOUND, test "$enable_fusionsound" = "yes")
+AM_CONDITIONAL(ENABLE_DIVINE, test "$enable_divine" = "yes")
+
+
+AC_ARG_ENABLE(unique,
+              AC_HELP_STRING([--enable-unique],
+                             [enable Unique (WM Module) @<:@default=no@:>@]),
+              [], [enable_unique=no])
+
+AM_CONDITIONAL(ENABLE_UNIQUE, test "$enable_unique" = "yes")
+
+
+AC_ARG_WITH(cxxstd,
+            AC_HELP_STRING([--with-cxxstd],
+                           [select C++ standard for compiler @<:@default=c++0x@:>@]),
+            [cxxstd="$withval"], [cxxstd="c++0x"])
+test x"$cxxstd" = x"no" && cxxstd="c++0x"
+CXXSTD="$cxxstd"
+AC_SUBST(CXXSTD)
+
+
+AC_ARG_ENABLE(mmx,
+              AC_HELP_STRING([--enable-mmx],
+                             [enable MMX support @<:@default=auto@:>@]),
+              [], [enable_mmx=$have_x86])
+
+AC_ARG_ENABLE(sse,
+              AC_HELP_STRING([--enable-sse],
+                             [enable SSE support @<:@default=auto@:>@]),
+              [], [enable_sse=$have_x86])
+
+if test "$enable_mmx" = "yes"; then
+
+  dnl Necessary for assembler sources
+  save_ac_ext="$ac_ext"
+  ac_ext=S
+
+  AC_MSG_CHECKING(whether the binutils support MMX)
+
+  echo "       movq 0, %mm0" > conftest.S
+  if AC_TRY_EVAL(ac_compile); then
+    AC_DEFINE(USE_MMX,1,[Define to 1 if MMX assembly is available.])
+    AC_MSG_RESULT(yes)
+
+    if test "$enable_sse" = "yes"; then
+
+      AC_MSG_CHECKING(whether the binutils support SSE)
+
+      echo "       movntps %xmm0, 0" > conftest.S
+      if AC_TRY_EVAL(ac_compile); then
+        AC_DEFINE(USE_SSE,1,[Define to 1 if SSE assembly is available.])
+        AC_MSG_RESULT(yes)
+      else
+        enable_sse=no
+        AC_MSG_RESULT(no)
+        AC_MSG_WARN([
+****************************************************************
+ The installed assembler does not support the SSE command set.
+ Update your binutils package, if you want to compile SSE code.
+****************************************************************])
+      fi
+
+    fi
+
+  else
+    enable_mmx=no
+    AC_MSG_RESULT(no)
+    AC_MSG_WARN([
+****************************************************************
+ The installed assembler does not support the MMX command set.
+ Update your binutils package, if you want to compile MMX code.
+****************************************************************])
+  fi
+
+  rm conftest*
+  ac_ext="$save_ac_ext"
+
+else
+  enable_sse=no
+fi
+
+AM_CONDITIONAL(BUILDMMX, test "$enable_mmx" = "yes")
+
+
+
+dnl Test for PVR2D system
+AC_ARG_ENABLE(pvr2d,
+              AC_HELP_STRING([--enable-pvr2d],
+                             [build with PVR2D support @<:@default=yes@:>@]),
+              [], [enable_pvr2d=no])
+
+AM_CONDITIONAL(PVR2D_CORE, test "$enable_pvr2d" = "yes")
+
+AC_SUBST(PVR2D_LIBS)
+AC_SUBST(PVR2D_CFLAGS)
+
+
+dnl Test for EGL
+AC_ARG_ENABLE(egl,
+              AC_HELP_STRING([--enable-egl],
+                             [build with EGL support @<:@default=no@:>@]),
+              [], [enable_egl=no])
+if test "$enable_egl" = "yes"; then
+  PKG_CHECK_MODULES(EGL, [gl egl], [enable_egl=yes], [enable_egl=no
+    AC_MSG_WARN([
+*** gl egl packages not found -- Building without EGL support.])
+    ])
+fi
+
+AM_CONDITIONAL(EGL_CORE, test "$enable_egl" = "yes")
+
+AC_SUBST(EGL_LIBS)
+AC_SUBST(EGL_CFLAGS)
+
+
+dnl Test for EGL
+AC_ARG_ENABLE(idirectfbgl-egl,
+              AC_HELP_STRING([--enable-idirectfbgl-egl],
+                             [build with EGL support @<:@default=no@:>@]),
+              [], [enable_idirectfbgl_egl=no])
+if test "$enable_idirectfbgl_egl" = "yes"; then
+  PKG_CHECK_MODULES(EGL, [gl egl], [enable_idirectfbgl_egl=yes], [enable_idirectfbgl_egl=no
+    AC_MSG_WARN([
+*** gl egl packages not found -- Building without IDirectFBGL-EGL support.])
+    ])
+fi
+
+AM_CONDITIONAL(IDIRECTFBGL_EGL, test "$enable_idirectfbgl_egl" = "yes")
+
+AC_SUBST(EGL_LIBS)
+AC_SUBST(EGL_CFLAGS)
+
+
+
+dnl Test for DevMem system
+AC_ARG_ENABLE(devmem,
+              AC_HELP_STRING([--enable-devmem],
+                             [build with generic /dev/mem support @<:@default=yes@:>@]),
+              [], [enable_devmem=yes])
+
+AM_CONDITIONAL(DEVMEM_CORE, test "$enable_devmem" = "yes")
+
+
+
+dnl Test for Linux frame buffer device
+AC_ARG_ENABLE(fbdev,
+              AC_HELP_STRING([--enable-fbdev],
+                             [build with linux fbdev support @<:@default=auto@:>@]),
+              [], [enable_fbdev=yes])
+if test "$have_linux" = "no"; then
+  enable_fbdev=no
+  AC_MSG_WARN([
+*** no linux kernel -- building without linux fbdev support.])
+fi
+
+AM_CONDITIONAL(FBDEV_CORE, test "$enable_fbdev" = "yes")
+
+
+
+dnl Test for SDL
+AC_ARG_ENABLE(sdl,
+              AC_HELP_STRING([--enable-sdl],
+                             [build with SDL support @<:@default=no@:>@]),
+              [], [enable_sdl=no])
+if test "$enable_sdl" = "yes"; then
+  if test "$enable_osx" = "yes"; then
+    AC_MSG_WARN([
+*** SDL is now unsupported on OSX.])
+    enable_sdl=no
+  else
+    PKG_CHECK_MODULES([SDL], [sdl],
+                      [enable_sdl=yes],
+                      [
+                        enable_sdl=no
+                        AC_MSG_WARN([*** no sdl -- building without SDL support.])
+                      ])
+  fi
+fi
+
+AC_SUBST(OSX_LIBS)
+AM_CONDITIONAL(SDL_CORE, test "$enable_sdl" = "yes")
+
+
+
+dnl Test for VNC
+AC_ARG_ENABLE(vnc,
+              AC_HELP_STRING([--enable-vnc],
+                             [build with VNC support @<:@default=auto@:>@]),
+              [], [enable_vnc=yes])
+if test "$enable_vnc" = "yes"; then
+  AC_PATH_PROG(VNC_CONFIG, libvncserver-config, no)
+  if test "$VNC_CONFIG" = "no"; then
+    enable_vnc=no
+    AC_MSG_WARN([
+*** libvncserver-config not found -- building without VNC support. See http://libvncserver.sourceforge.net])
+  else
+    VNC_CFLAGS=`$VNC_CONFIG --cflags`
+    VNC_LIBS=`$VNC_CONFIG --libs`
+  fi
+fi
+
+AM_CONDITIONAL(VNC_CORE, test "$enable_vnc" = "yes")
+AC_SUBST(VNC_LIBS)
+AC_SUBST(VNC_CFLAGS)
+
+
+
+dnl Test for Mesa
+AC_ARG_ENABLE(mesa,
+              AC_HELP_STRING([--enable-mesa],
+                             [build with Mesa support @<:@default=auto@:>@]),
+              [], [enable_mesa=yes])
+if test "$enable_mesa" = "yes"; then
+  PKG_CHECK_MODULES(MESA, [glesv2 egl libdrm gbm], [enable_mesa=yes], [enable_mesa=no
+    AC_MSG_WARN([
+*** gl egl libdrm gbm packages not found -- Building without MESA support.])
+    ])
+fi
+
+AM_CONDITIONAL(MESA_CORE, test "$enable_mesa" = "yes")
+AC_SUBST(MESA_LIBS)
+AC_SUBST(MESA_CFLAGS)
+
+dnl Test for drm/kms
+AC_ARG_ENABLE(drmkms,
+              AC_HELP_STRING([--enable-drmkms],
+                             [build with DRM/KMS support @<:@default=auto@:>@]),
+              [], [enable_drmkms=yes])
+if test "$enable_drmkms" = "yes"; then
+  PKG_CHECK_MODULES(DRMKMS, [libdrm libkms], [enable_drmkms=yes], [enable_drmkms=no
+    AC_MSG_WARN([
+*** libdrm gbm packages not found -- Building without DRM/KMS support.])
+    ])
+fi
+
+AM_CONDITIONAL(DRMKMS_CORE, test "$enable_drmkms" = "yes")
+AC_SUBST(DRMKMS_LIBS)
+AC_SUBST(DRMKMS_CFLAGS)
+
+
+
+dnl Test for libjpeg
+JPEG=no
+
+AC_ARG_ENABLE(jpeg,
+              AC_HELP_STRING([--enable-jpeg],
+                             [build JPEG image provider @<:@default=yes@:>@]),
+              [], [enable_jpeg=yes])
+
+if test "$enable_jpeg" = "yes"; then
+  if test -z "$LIBJPEG"; then
+    AC_CHECK_LIB(jpeg, jpeg_destroy_decompress,
+      jpeg_ok=yes,
+      jpeg_ok=no)
+    if test "$jpeg_ok" = yes; then
+      AC_CHECK_HEADER(jpeglib.h,
+        jpeg_ok=yes,
+        jpeg_ok=no)
+      if test "$jpeg_ok" = yes; then
+	JPEG=yes
+	LIBJPEG='-ljpeg'
+      else
+	JPEG=no
+	AC_MSG_WARN([
+*** JPEG header files not found. JPEG image provider will not be built.])
+      fi
+    else
+      JPEG=no
+      AC_MSG_WARN([
+*** JPEG library not found. JPEG image provider will not be built.])
+    fi
+  else
+    JPEG=yes
+  fi
+fi
+
+AM_CONDITIONAL(JPEG_PROVIDER, test "$JPEG" = "yes")
+
+if test "$enable_jpeg" != "no" && test "$JPEG" != "yes"; then
+  jpeg_warning="
+JPEG support is missing - many applications won't work correctly!"
+fi
+
+
+
+AC_ARG_ENABLE(zlib,
+              AC_HELP_STRING([--enable-zlib],
+                             [use zlib, e.g. for screen shots @<:@default=no@:>@]),
+              [], [enable_zlib=no])
+
+use_zlib=no
+ZLIB_LIBS=
+
+if test "$enable_zlib" = "yes"; then
+  dnl Test for libz
+  AC_CHECK_LIB(z, gzsetparams,
+    [
+	AC_CHECK_HEADER(zlib.h,
+	use_zlib=yes
+        AC_DEFINE(USE_ZLIB,1,[Define to 1 to build with zlib compression.])
+	ZLIB_LIBS='-lz',
+	AC_MSG_ERROR([
+*** libz header files not found.]))
+    ],[
+	AC_MSG_ERROR([ *** libz not found.])
+    ])
+fi
+
+AC_SUBST(ZLIB_LIBS)
+
+
+
+dnl Test for libpng
+PNG=no
+
+AC_ARG_ENABLE(png,
+              AC_HELP_STRING([--enable-png],
+                             [build PNG image provider, @<:@default=yes@:>@]),
+              [], [enable_png=yes])
+if test "$enable_png" = "yes"; then
+  PKG_CHECK_MODULES([LIBPNG], [libpng >= 1.2.2], [PNG=yes], [PNG=no
+    AC_MSG_WARN([*** PNG library not found. PNG image provider will not be built.])])
+fi
+
+AM_CONDITIONAL(PNG_PROVIDER, test "$PNG" = "yes")
+AM_CONDITIONAL(BUILD_DIRECTFB_CSOURCE, test "$PNG" = "yes")
+
+if test "$enable_png" != "no" && test "$PNG" != "yes"; then
+  png_warning="
+PNG support is missing - many applications won't work correctly!"
+fi
+
+
+
+dnl Test for libmng
+MNG=no
+
+AC_ARG_ENABLE(mng,
+              AC_HELP_STRING([--enable-mng],
+                             [build MNG video provider @<:@default=no@:>@]),
+              [], [enable_mng=no])
+if test "$enable_mng" = "yes"; then
+  if test -z "$LIBMNG"; then
+    AC_CHECK_LIB(mng, mng_version_text,
+      mng_ok=yes,
+      mng_ok=no)
+    if test "$mng_ok" = yes; then
+      AC_CHECK_HEADER(libmng.h,
+        mng_ok=yes,
+        mng_ok=no)
+      if test "$mng_ok" = yes; then
+	MNG=yes
+	LIBMNG='-lmng'
+      else
+	MNG=no
+	AC_MSG_WARN([
+*** MNG header files not found. MNG video provider will not be built.])
+      fi
+    else
+      MNG=no
+      AC_MSG_WARN([
+*** MNG library not found. MNG video provider will not be built.])
+    fi
+  else
+    MNG=yes
+  fi
+fi
+
+AM_CONDITIONAL(MNG_PROVIDER, test "$MNG" = "yes")
+
+dnl Allow to disable GSTREAMER support
+gstreamer=no
+AC_ARG_ENABLE(gstreamer,
+              AC_HELP_STRING([--enable-gstreamer],
+	                      [build gstreamer video provider @<:@default=no@:>@]),
+              [], [enable_gstreamer=no])
+
+AM_CONDITIONAL(GSTREAMER_PROVIDER, test "$enable_gstreamer" = "yes")
+
+HAVE_GSTREAMER_1_0=no
+if test "x$enable_gstreamer" = "xyes"; then
+    AC_MSG_CHECKING(for Gstreamer >= 1.0)
+    if $PKG_CONFIG --atleast-version "0.11" gstreamer-app-1.0 ; then
+      AC_MSG_RESULT([found])
+      HAVE_GSTREAMER_1_0=yes
+    else
+      AC_MSG_RESULT([not found])
+    fi
+    if test "$HAVE_GSTREAMER_1_0" = "no"; then
+      GSTREAMER_INCL=`$PKG_CONFIG --cflags-only-I gstreamer-app-0.10`
+      GSTREAMER_LIBS=`$PKG_CONFIG --libs gstreamer-app-0.10`
+    else
+      GSTREAMER_INCL=`$PKG_CONFIG --cflags-only-I gstreamer-app-1.0`
+      GSTREAMER_INCL="$GSTREAMER_INCL -DHAVE_GSTREAMER_1_0_API"
+      GSTREAMER_LIBS=`$PKG_CONFIG --libs gstreamer-app-1.0`
+    fi
+    gstreamer=yes
+else
+    GSTREAMER_INCL=
+    GSTREAMER_LIBS=
+fi
+
+AC_SUBST(GSTREAMER_LIBS)
+AC_SUBST(GSTREAMER_INCL)
+
+
+dnl Allow to disable GIF support
+AC_ARG_ENABLE(gif,
+              AC_HELP_STRING([--enable-gif],
+                             [build GIF image/video provider @<:@default=yes@:>@]),
+              [], [enable_gif=yes])
+
+AM_CONDITIONAL(GIF_PROVIDER, test "$enable_gif" = "yes")
+
+tiff="no"
+AC_ARG_ENABLE(tiff,
+              AC_HELP_STRING([--enable-tiff],
+                             [build TIFF image provider, @<:@default=auto@:>@]),
+              [], [enable_tiff=yes])
+if test "$enable_tiff" = "yes"; then
+  PKG_CHECK_MODULES([LIBTIFF], [libtiff-4], [tiff=yes], [tiff=no
+    AC_MSG_WARN([*** TIFF library not found. TIFF image provider will not be built.])])
+fi
+
+AM_CONDITIONAL(TIFF_PROVIDER, test "$tiff" = "yes")
+
+
+
+dnl Imlib2 check
+imlib2="no"
+AC_ARG_ENABLE(imlib2,
+              AC_HELP_STRING([--enable-imlib2],
+                             [build Imlib2 image provider @<:@default=no@:>@]),
+              [], [enable_imlib2=no])
+if test "x$enable_imlib2" = "xyes"; then
+  AC_PATH_PROG(IMLIB2_CONFIG, imlib2-config, no)
+  if test "x$IMLIB2_CONFIG" = xno; then
+    AC_MSG_WARN([*** Imlib2 library not found, building without Imlib2 support ***])
+    imlib2="no"
+  else
+    IMLIB2_CFLAGS=`imlib2-config --cflags`
+    IMLIB2_LIBS=`imlib2-config --libs`
+    imlib2="yes"
+  fi
+fi
+
+AC_SUBST(IMLIB2_LIBS)
+AC_SUBST(IMLIB2_CFLAGS)
+
+AM_CONDITIONAL(IMLIB2, test "x$imlib2" = xyes)
+
+
+dnl PNM check
+AC_ARG_ENABLE(pnm,
+              AC_HELP_STRING([--enable-pnm],
+                             [build PNM (PBM/PGM/PPM) image provider @<:@default=yes@:>@]),
+              [], [enable_pnm=yes])
+
+AM_CONDITIONAL(PNM, test "x$enable_pnm" = "xyes")
+
+
+dnl SVG check
+SVGCAIRO_REQUIRED_VERSION=0.1.6
+
+svg="no"
+AC_ARG_ENABLE(svg,
+              AC_HELP_STRING([--enable-svg],
+                             [build SVG image provider @<:@default=no@:>@]),
+              [], [enable_svg=no])
+if test "x$enable_svg" = "xyes"; then
+  AC_MSG_CHECKING(for libsvg-cairo >= $SVGCAIRO_REQUIRED_VERSION)
+  if $PKG_CONFIG --atleast-version=$SVGCAIRO_REQUIRED_VERSION libsvg-cairo; then
+    SVG_CFLAGS=`$PKG_CONFIG --cflags libsvg-cairo`
+    SVG_LIBS=`$PKG_CONFIG --libs libsvg-cairo`
+    SVG_VERSION=`$PKG_CONFIG --modversion libsvg-cairo`
+    AC_MSG_RESULT([found (version $SVG_VERSION)])
+    svg="yes"
+  else
+    AC_MSG_RESULT([not found])
+    AC_MSG_WARN([
+*** SVG-Cairo at least $SVGCAIRO_REQUIRED_VERSION not found -- SVG image provider will not be built.])
+  fi
+fi
+
+AC_SUBST(SVG_CFLAGS)
+AC_SUBST(SVG_LIBS)
+
+AM_CONDITIONAL(SVG, test "x$svg" = "xyes")
+
+
+dnl MPEG2 check
+AC_ARG_ENABLE(mpeg2,
+              AC_HELP_STRING([--enable-mpeg2],
+                             [build MPEG2 image provider @<:@default=yes@:>@]),
+              [], [enable_mpeg2=yes])
+
+AM_CONDITIONAL(MPEG2, test "x$enable_mpeg2" = "xyes")
+
+
+dnl BMP check
+AC_ARG_ENABLE(bmp,
+              AC_HELP_STRING([--enable-bmp],
+                             [build BMP image provider @<:@default=yes@:>@]),
+              [], [enable_bmp=yes])
+
+AM_CONDITIONAL(BMP, test "x$enable_bmp" = "xyes")
+
+
+dnl JPEG2000 Check
+AC_ARG_ENABLE(jpeg2000,
+              AC_HELP_STRING([--enable-jpeg2000],
+                             [build JPEG2000 image provider @<:@default=yes@:>@]),
+              [], [enable_jpeg2000=yes])
+
+if test "$enable_jpeg2000" = "yes"; then
+  dnl Test for libjasper
+  AC_CHECK_LIB(jasper, jas_image_decode, jasper="yes", jasper="no", [-lm])
+  if test "$jasper" = "yes"; then
+    AC_CHECK_HEADER(jasper/jasper.h,, jasper="no")
+  fi
+  if test "$jasper" == "yes"; then
+    JASPER_LIBS="-ljasper -lm -ljpeg"
+  else
+    AC_MSG_WARN([
+*** Jasper not found. JPEG2000 image provider will not be built.])
+    enable_jpeg2000="no"
+  fi
+fi
+
+AC_SUBST(JASPER_LIBS)
+
+AM_CONDITIONAL(JPEG2000, test "x$enable_jpeg2000" = "xyes")
+
+
+#
+# OpenQuicktime check
+#
+openquicktime="no"
+AC_ARG_ENABLE(openquicktime,
+              AC_HELP_STRING([--enable-openquicktime],
+                             [build OpenQuicktime video provider @<:@default=no@:>@]),
+              [], [enable_openquicktime=no])
+if test "x$enable_openquicktime" = "xyes"; then
+  AC_CHECK_LIB(openquicktime, quicktime_open, openquicktime="yes", openquicktime="no")
+  if test "x$openquicktime" = xyes; then
+    OPENQUICKTIME_LIBS="-lopenquicktime"
+
+    AC_CHECK_HEADER(openquicktime/openquicktime.h, , openquicktime="no")
+    if test "x$openquicktime" = xno; then
+      AC_MSG_WARN([*** OpenQuicktime header not found, building without OpenQuicktime support ***])
+    fi
+  else
+    AC_MSG_WARN([*** OpenQuicktime library not found, building without OpenQuicktime support ***])
+  fi
+fi
+
+AC_SUBST(OPENQUICKTIME_LIBS)
+
+AM_CONDITIONAL(OPENQUICKTIME_PROVIDER, test "x$openquicktime" = xyes)
+
+#
+# Avifile check
+#
+avifile=no
+AC_ARG_ENABLE(avifile,
+              AC_HELP_STRING([--enable-avifile],
+                             [build AviFile video provider @<:@default=no@:>@]),
+              [], [enable_avifile=no])
+if test x$enable_avifile = xyes; then
+  AC_PATH_PROG(AVIFILE_CONFIG, avifile-config, no)
+  if test x$AVIFILE_CONFIG = xno; then
+    AC_MSG_WARN([
+*** avifile-config not found -- AVI media provider will not be built.])
+  else
+    AC_PROG_CXX
+    avifile=yes
+    AVIFILE_CFLAGS=`$AVIFILE_CONFIG --cflags`
+    AVIFILE_LIBS="`$AVIFILE_CONFIG --libs` -lstdc++"
+  fi
+fi
+
+AC_SUBST(AVIFILE_CFLAGS)
+AC_SUBST(AVIFILE_LIBS)
+
+AM_CONDITIONAL(AVIFILE_PROVIDER, test x$avifile = xyes)
+
+#
+# libmpeg3 check
+#
+mpeg3=no
+AC_ARG_ENABLE(libmpeg3,
+              AC_HELP_STRING([--enable-libmpeg3],
+                             [build Libmpeg3 video provider @<:@default=no@:>@]),
+              [], [enable_libmpeg3=no])
+if test x$enable_libmpeg3 = xyes; then
+  AC_CHECK_LIB(mpeg3, mpeg3_open,
+    [
+      AC_CHECK_HEADER(libmpeg3.h,
+        mpeg3=yes
+        LIBMPEG3_LIBS='-lmpeg3',
+        AC_MSG_WARN([
+*** libmpeg3 headers not found -- Libmpeg3 video provider will not be built.]))
+    ],[
+      AC_MSG_WARN([
+*** libmpeg3 not found -- Libmpeg3 video provider will not be build.])
+    ], -lm -lpthread)
+fi
+
+AM_CONDITIONAL(LIBMPEG3_PROVIDER, test x$mpeg3 = xyes)
+AC_SUBST(LIBMPEG3_LIBS)
+
+#
+# Libflash check
+#
+flash=no
+AC_ARG_ENABLE(flash,
+              AC_HELP_STRING([--enable-flash],
+                             [build Flash media provider @<:@default=no@:>@]),
+              [], [enable_flash=no])
+if test x$enable_flash = xyes; then
+  AC_CHECK_HEADER(flash.h,
+    [ AC_PROG_CXX
+      AC_LANG_PUSH(C++)
+      AC_CHECK_LIB(z, gzsetparams, LIBZ=-lz)
+      AC_CHECK_LIB(jpeg, jpeg_destroy_decompress, LIBJPEG=-ljpeg)
+      AC_CHECK_LIB(flash, FlashGetInfo,
+        [  flash=yes
+           FLASH_LIBS="-lflash $LIBJPEG $LIBZ -lm"],
+        [  AC_MSG_WARN([
+*** libflash not found -- Flash media provider will not be built.])
+        ], $LIBJPEG $LIBZ -lm)
+      AC_LANG_POP(C++)
+    ],[  AC_MSG_WARN([
+*** libflash headers not found -- Flash media provider will not be built.])
+    ])
+fi
+
+AC_SUBST(FLASH_LIBS)
+
+AM_CONDITIONAL(FLASH_PROVIDER, test x$flash = xyes)
+
+#
+# Xine check
+#
+xine="no"
+AC_ARG_ENABLE(xine,
+              AC_HELP_STRING([--enable-xine],
+                             [build Xine video provider @<:@default=no@:>@]),
+              [], [enable_xine=no])
+if test "x$enable_xine" = "xyes"; then
+	AC_PATH_PROG(XINE_CONFIG, xine-config, no)
+	if test "x$XINE_CONFIG" = "xno"; then
+		AC_MSG_WARN([
+*** xine-config not found -- Xine video provider will not be built.])
+	else
+		AC_MSG_CHECKING([for xine-lib >= 1.0.0])
+		XINE_VERSION=`$XINE_CONFIG --version`
+		case $XINE_VERSION in
+			1.*)
+				AC_MSG_RESULT(yes)
+				xine="yes"
+				XINE_CFLAGS=`$XINE_CONFIG --cflags`
+				XINE_LIBS=`$XINE_CONFIG --libs`
+				XINE_PLUGINDIR=`$XINE_CONFIG --plugindir`
+				;;
+			*)
+				AC_MSG_RESULT(no)
+				AC_MSG_WARN([
+*** xine-lib 1.0.0 or newer is required - Xine video provider will not be built.])
+				;;
+		esac
+	fi
+fi
+
+AC_SUBST(XINE_CFLAGS)
+AC_SUBST(XINE_LIBS)
+AC_SUBST(XINE_PLUGINDIR)
+
+AM_CONDITIONAL(XINE_PROVIDER, test "x$xine" = "xyes")
+
+
+#
+# Xine/VDPAU check
+#
+xine_vdpau="no"
+AC_ARG_ENABLE(xine-vdpau,
+              AC_HELP_STRING([--enable-xine-vdpau],
+                             [build Xine/VDPAU video provider @<:@default=no@:>@]),
+              [], [enable_xine_vdpau=no])
+if test "x$enable_xine_vdpau" = "xyes"; then
+	AC_PATH_PROG(PKG_CONFIG, pkg-config, no)
+	if test "$PKG_CONFIG" = "no"; then
+		AC_MSG_WARN([
+*** pkg-config not found -- Xine/VDPAU video provider will not be built.])
+	else
+		AC_MSG_CHECKING([for xine-lib >= 1.1.90])
+      if $PKG_CONFIG --atleast-version 1.1.90 libxine; then
+         AC_MSG_RESULT(yes)
+
+         AC_MSG_CHECKING([for vdpau >= 0.3])
+         if $PKG_CONFIG --atleast-version 0.3 vdpau; then
+            AC_MSG_RESULT(yes)
+            xine_vdpau="yes"
+            XINE_VDPAU_CFLAGS=`$PKG_CONFIG --cflags libxine vdpau`
+            XINE_VDPAU_LIBS=`$PKG_CONFIG --libs libxine vdpau`
+            XINE_VDPAU_PLUGINDIR=`$PKG_CONFIG --variable=plugindir libxine`
+         else
+            AC_MSG_RESULT(no)
+            AC_MSG_WARN([
+*** vdpau 0.3 or newer is required - Xine/VDPAU video provider will not be built.])
+         fi
+      else
+         AC_MSG_RESULT(no)
+         AC_MSG_WARN([
+*** xine-lib 1.1.90 or newer is required - Xine/VDPAU video provider will not be built.])
+      fi
+	fi
+fi
+
+AC_SUBST(XINE_VDPAU_CFLAGS)
+AC_SUBST(XINE_VDPAU_LIBS)
+AC_SUBST(XINE_VDPAU_PLUGINDIR)
+
+AM_CONDITIONAL(XINE_VDPAU_PROVIDER, test "x$xine_vdpau" = "xyes")
+
+
+#
+# Swfdec check
+#
+swfdec="no"
+AC_ARG_ENABLE(swfdec,
+              AC_HELP_STRING([--enable-swfdec],
+                             [build Swfdec (Flash decoder) video provider @<:@default=no@:>@]),
+              [], [enable_swfdec=no])
+if test "x$enable_swfdec" = "xyes"; then
+    swfdec_pc="no"
+    AC_MSG_CHECKING([for libswfdec >= 0.5.0])
+    for i in "swfdec" "swfdec-0.5"; do
+        if $PKG_CONFIG --atleast-version=0.5.0 $i; then
+            swfdec_pc=$i
+        fi
+    done
+    if test "x$swfdec_pc" != "xno"; then
+        AC_MSG_RESULT(yes)
+        swfdec="yes"
+        SWFDEC_CFLAGS=`$PKG_CONFIG --cflags $swfdec_pc`
+        SWFDEC_LIBS=`$PKG_CONFIG --libs $swfdec_pc`
+    else
+        AC_MSG_RESULT(no)
+        AC_MSG_WARN([
+*** Swfdec 0.5.0 or newer is required - Swfdec video provider will not be built.])
+    fi
+fi
+
+AC_SUBST(SWFDEC_CFLAGS)
+AC_SUBST(SWFDEC_LIBS)
+
+AM_CONDITIONAL(SWFDEC_PROVIDER, test "x$swfdec" = "xyes")
+
+#
+# FFmpeg check
+#
+ffmpeg="no"
+AC_ARG_ENABLE(ffmpeg,
+              AC_HELP_STRING([--enable-ffmpeg],
+                             [build FFmpeg video provider @<:@default=no@:>@]),
+              [], [enable_ffmpeg=no])
+if test "x$enable_ffmpeg" = "xyes"; then
+    AC_MSG_CHECKING([for libavcodec/libavformat/libavutil/libswscale])
+    if $PKG_CONFIG libavcodec libavformat libavutil libswscale; then
+        AC_MSG_RESULT(yes)
+        ffmpeg="yes"
+        FFMPEG_CFLAGS=`$PKG_CONFIG --cflags libavcodec libavformat libavutil libswscale`
+        FFMPEG_LIBS=`$PKG_CONFIG --libs libavcodec libavformat libavutil libswscale`
+    else
+        AC_MSG_RESULT(no)
+        AC_MSG_WARN([
+*** libavcodec/libavformat/libavutil are required - FFmpeg video provider and music provider will not be built.])
+    fi
+fi
+
+
+AC_SUBST(FFMPEG_CFLAGS)
+AC_SUBST(FFMPEG_LIBS)
+
+AM_CONDITIONAL(FFMPEG_PROVIDER, test "x$ffmpeg" = "xyes")
+AM_CONDITIONAL(BUILD_FFMPEG, test "x$ffmpeg" = "xyes")
+
+
+
+dnl Test for freetype
+AC_ARG_ENABLE(freetype,
+              AC_HELP_STRING([--enable-freetype],
+                             [build FreeType2 font provider @<:@default=yes@:>@]),
+              [], [enable_freetype=yes])
+if test "$enable_freetype" = "yes"; then
+  PKG_CHECK_MODULES(FREETYPE, freetype2, FREETYPE="yes", [FREETYPE="no"
+    AC_MSG_WARN([*** no freetype -- FreeType font provider will not be built.])])
+fi
+
+AM_CONDITIONAL(FREETYPE_PROVIDER, test "$FREETYPE" = "yes")
+
+if test "$enable_freetype" != "no" && test "$FREETYPE" != "yes"; then
+  freetype_warning="
+FreeType2 support is missing - many applications won't work correctly!"
+fi
+
+
+
+
+dnl Test for linotype
+AC_ARG_ENABLE(linotype,
+              AC_HELP_STRING([--enable-linotype],
+                             [build LinoType font provider @<:@default=yes@:>@]),
+              [], [])
+if test "x$enable_linotype" != "xno"; then
+  PKG_CHECK_MODULES(LINOTYPE, linotype, LINOTYPE="yes", [LINOTYPE="no"
+    AC_MSG_WARN([*** no linotype -- LinoType font provider will not be built.])])
+fi
+
+AM_CONDITIONAL(LINOTYPE_PROVIDER, test "$LINOTYPE" = "yes")
+
+
+dnl Test for video4linux
+V4L=no
+
+if test "$have_linux" = "yes"; then
+  AC_ARG_ENABLE(video4linux,
+                AC_HELP_STRING([--enable-video4linux],
+                               [build Video4Linux video provider @<:@default=yes@:>@]),
+                [], [enable_video4linux=yes])
+  if test "$enable_video4linux" = "yes"; then
+    V4L=yes
+  fi
+fi
+
+AM_CONDITIONAL(V4L_PROVIDER, test "$V4L" = "yes")
+
+
+
+dnl Test for video4linux
+V4L2=no
+
+if test "$V4L" = "yes"; then
+  AC_ARG_ENABLE(video4linux2,
+                AC_HELP_STRING([--enable-video4linux2],
+                               [build with Video4Linux2 support @<:@default=no@:>@]),
+                [], [enable_video4linux2=no])
+  if test "$enable_video4linux2" = "yes"; then
+    V4L2=yes
+    AC_DEFINE( DFB_HAVE_V4L2, 1, [Define to 1 if Video4Linux 2 is supported.] )
+  fi
+fi
+
+dnl Test for libwebp
+webp=no
+
+AC_ARG_ENABLE(webp,
+              AC_HELP_STRING([--enable-webp],
+                             [build WebP image provider, @<:@default=auto@:>@]),
+              [], [enable_webp=yes])
+if test "$enable_webp" = "yes"; then
+  PKG_CHECK_MODULES([LIBWEBP], [libwebp >= 0.2.1], [webp=yes], [webp=no
+    AC_MSG_WARN([*** WebP library not found. WEBP image provider will not be built.])])
+fi
+
+AM_CONDITIONAL(WEBP_PROVIDER, test "$webp" = "yes")
+
+
+
+dnl check which gfxdrivers to build
+ati128=no
+cle266=no
+cyber5k=no
+davinci=no
+ep9x=no
+gp2d=no
+gl=no
+gles2=no
+glx=no
+i810=no
+i830=no
+mach64=no
+matrox=no
+neomagic=no
+nsc=no
+nvidia=no
+omap=no
+pvr2d=no
+egl=no
+pxa3xx=no
+radeon=no
+savage=no
+sh772x=no
+sis315=no
+tdfx=no
+unichrome=no
+vdpau=no
+vmware=no
+
+if test "$have_linux" = "yes"; then
+
+AC_MSG_CHECKING(which gfxdrivers should be built)
+AC_ARG_WITH(gfxdrivers,
+            AC_HELP_STRING([--with-gfxdrivers=LIST],
+                           [LIST is a comma separated selection of gfxdrivers]
+                           [to build. Possible gfxdrivers are: all (builds most]
+                           [drivers), none (builds none), ati128, cle266,]
+                           [cyber5k, davinci, ep9x, gp2d, gl, gles2, i810, i830, mach64,]
+                           [matrox, neomagic, nsc, nvidia, omap, pvr2d, pxa3xx,]
+                           [radeon, savage, sh772x, sis315, tdfx, unichrome,]
+                           [vdpau, vmware. @<:@default=all@:>@]),
+            [gfxdrivers="$withval"], [gfxdrivers=all])
+if test "$gfxdrivers" = "all"; then
+  checkfor_ati128=yes
+  checkfor_cle266=no
+  checkfor_cyber5k=no
+  checkfor_davinci="$have_arm"
+  checkfor_ep9x=yes
+  checkfor_gp2d=no
+  checkfor_gl=yes
+  checkfor_gles2=yes
+  checkfor_i810=yes
+  checkfor_i830=yes
+  checkfor_mach64=yes
+  checkfor_matrox=yes
+  checkfor_neomagic=yes
+  checkfor_nsc=yes
+  checkfor_nvidia=yes
+  checkfor_omap="$have_arm"
+  checkfor_pvr2d=yes
+  checkfor_pxa3xx=yes
+  checkfor_radeon=no
+  checkfor_savage=no
+  checkfor_sh772x=yes
+  checkfor_sis315=yes
+  checkfor_tdfx=yes
+  checkfor_unichrome=no
+  checkfor_vdpau=yes
+  checkfor_vmware=no
+
+  AC_MSG_RESULT(all)
+else
+  if test "$gfxdrivers" != "none"; then
+    gfxdrivers=`echo $gfxdrivers | sed 's/,/ /g'`
+    for gfxdriver in $gfxdrivers
+    do
+      case "$gfxdriver" in
+          ati128)
+                  checkfor_ati128=yes
+                  ;;
+          cle266)
+                  checkfor_cle266=yes
+                  ;;
+          cyber5k)
+                  checkfor_cyber5k=yes
+                  ;;
+          davinci)
+                  checkfor_davinci=yes
+                  ;;
+          ep9x)
+                  checkfor_ep9x=yes
+                  ;;
+          gp2d)
+                  checkfor_gp2d=yes
+                  ;;
+          gl)
+                  checkfor_gl=yes
+                  ;;
+          gles2)
+                  checkfor_gles2=yes
+                  ;;
+          i810)
+                  checkfor_i810=yes
+                  ;;
+          i830)
+                  checkfor_i830=yes
+                  ;;
+          mach64)
+                  checkfor_mach64=yes
+                  ;;
+          matrox)
+                  checkfor_matrox=yes
+                  ;;
+          neomagic)
+                  checkfor_neomagic=yes
+                  ;;
+          nsc)
+                  checkfor_nsc=yes
+                  ;;
+          nvidia)
+                  checkfor_nvidia=yes
+                  ;;
+          omap)
+                  checkfor_omap=yes
+                  ;;
+          pvr2d)
+                  checkfor_pvr2d=yes
+                  ;;
+          pxa3xx)
+                  checkfor_pxa3xx=yes
+                  ;;
+          radeon)
+                  checkfor_radeon=yes
+                  ;;
+          savage)
+                  checkfor_savage=yes
+                  ;;
+          sh772x)
+                  checkfor_sh772x=yes
+                  ;;
+          sis315)
+                  checkfor_sis315=yes
+                  ;;
+          tdfx)
+                  checkfor_tdfx=yes
+                  ;;
+          unichrome)
+                  checkfor_unichrome=yes
+                  ;;
+          vmware)
+                  checkfor_vmware=yes
+                  ;;
+          vdpau)
+                  checkfor_vdpau=yes
+                  ;;
+          *)
+                  echo "Unknown gfxdriver $gfxdriver, exiting!"
+                  exit 1
+                  ;;
+      esac
+    done
+    AC_MSG_RESULT($gfxdrivers)
+  fi
+fi
+
+if test "$checkfor_ati128" = "yes"; then
+  ati128=yes
+fi
+
+if test "$checkfor_cle266" = "yes" && test "$have_sysio" = "yes"; then
+  cle266=yes
+fi
+
+if test "$checkfor_cyber5k" = "yes"; then
+  cyber5k=yes
+fi
+
+if test "$checkfor_davinci" = "yes"; then
+  davinci=yes
+fi
+
+if test "$checkfor_ep9x" = "yes"; then
+  ep9x=yes
+fi
+
+if test "$checkfor_gp2d" = "yes"; then
+  gp2d=yes
+fi
+
+AC_SUBST(GP2D_LIBS)
+AC_SUBST(GP2D_CFLAGS)
+
+if test "$checkfor_gl" = "yes"; then
+  AC_CHECK_HEADER(GL/gl.h, gl=yes)
+  AC_CHECK_HEADER(GL/glx.h, [
+                  glx=yes
+                  AC_DEFINE(USE_GLX,1,[Define to 1 if GLX has been selected or detected])
+                  ])
+  GL_LIBS="-lGL"
+fi
+
+AC_SUBST(GL_LIBS)
+
+if test "$checkfor_gles2" = "yes"; then
+   if test "$enable_egl" = "yes"; then
+      GLES2_CFLAGS="$GLES2_CFLAGS $EGL_CFLAGS -DGLES2_EGL"
+      GLES2_LIBS="$GLES2_LIBS $EGL_LIBS"
+   fi
+   if test "$enable_mesa" = "yes"; then
+      GLES2_CFLAGS="$GLES2_CFLAGS $MESA_CFLAGS -DGLES2_MESA"
+      GLES2_LIBS="$GLES2_LIBS $MESA_LIBS"
+   fi
+   if test "$enable_pvr2d" = "yes"; then
+      GLES2_CFLAGS="$GLES2_CFLAGS $PVR2D_CFLAGS -DGLES2_PVR2D"
+      GLES2_LIBS="$GLES2_LIBS $PVR2D_LIBS"
+   fi
+
+   if test -n "$GLES2_CFLAGS"; then
+      gles2=yes
+   fi
+fi
+
+AC_SUBST(GLES2_LIBS)
+AC_SUBST(GLES2_CFLAGS)
+
+if test "$checkfor_i810" = "yes" && test "$have_sysio" = "yes"; then
+  i810=yes
+fi
+
+if test "$checkfor_i830" = "yes" && test "$have_sysio" = "yes"; then
+  i830=yes
+fi
+
+if test "$checkfor_mach64" = "yes"; then
+  mach64=yes
+fi
+
+if test "$checkfor_matrox" = "yes"; then
+  matrox=yes
+fi
+
+if test "$checkfor_neomagic" = "yes" && test "$have_sysio" = "yes"; then
+  neomagic=yes
+fi
+
+if test "$checkfor_nsc" = "yes"; then
+  nsc=yes
+fi
+
+if test "$checkfor_nvidia" = "yes"; then
+  nvidia=yes
+fi
+
+if test "$checkfor_omap" = "yes"; then
+  omap=yes
+fi
+
+if test "$checkfor_pvr2d" = "yes"; then
+  if test "$enable_pvr2d" = "yes"; then
+    pvr2d=yes
+  fi
+fi
+
+if test "$checkfor_pxa3xx" = "yes"; then
+  pxa3xx=yes
+fi
+
+if test "$checkfor_radeon" = "yes"; then
+  radeon=yes
+fi
+
+if test "$checkfor_savage" = "yes" && test "$have_sysio" = "yes"; then
+  savage=yes
+fi
+
+if test "$checkfor_sh772x" = "yes" && test "$have_sh4" = "yes"; then
+  PKG_CHECK_MODULES([SH772X_DEP],
+    [uiomux >= 1.5.0 shbeu >= 1.0.2], [sh772x=yes], [sh772x=no])
+  if test "$sh772x" = "no"; then
+       AC_MSG_WARN([*** Missing UIOMUX or SHBEU library -- sh772x driver will not be built.])
+  fi
+  PKG_CHECK_MODULES([SH772X_SHJPEG_DEP], [shjpeg >= 1.3.3], [sh772x_shjpeg=yes], [sh772x_shjpeg=no])
+  if test "$sh772x_shjpeg" = "no"; then
+       AC_MSG_WARN([*** Missing SHJPEG library -- sh772x driver will be build without shjpeg support.])
+  fi
+fi
+if test "$sh772x" = "yes"; then
+  AC_DEFINE(HAVE_GFX_SH772X, [], [Define to 1 if sh772x])
+fi
+
+if test "$checkfor_sis315" = "yes"; then
+  sis315=yes
+fi
+
+if test "$checkfor_tdfx" = "yes"; then
+  tdfx=yes
+fi
+
+if test "$checkfor_unichrome" = "yes" && test "$have_sysio" = "yes"; then
+  unichrome=yes
+fi
+
+if test "$checkfor_vmware" = "yes"; then
+  vmware=yes
+fi
+
+if test "$checkfor_vdpau" = "yes"; then
+   if test "$enable_x11vdpau" = "yes"; then
+      vdpau=yes
+   fi
+fi
+
+# lets check for input driver
+
+checkfor_dbox2remote=no
+checkfor_dreamboxremote=no
+checkfor_dynapro=no
+checkfor_elo=no
+checkfor_gunze=no
+checkfor_h3600ts=no
+checkfor_input_hub=no
+checkfor_joystick=no
+checkfor_keyboard=no
+checkfor_linux_input=no
+checkfor_lirc=no
+checkfor_mutouch=no
+checkfor_zytronic=no
+checkfor_penmount=no
+checkfor_ps2mouse=no
+checkfor_serialmouse=no
+checkfor_sonypijogdial=no
+checkfor_tslib=no
+checkfor_ucb1x00=no
+checkfor_wm97xx=no
+
+AC_MSG_CHECKING(which inputdrivers should be built)
+AC_ARG_WITH(inputdrivers,
+            AC_HELP_STRING([--with-inputdrivers=LIST],
+                           [LIST is a comma separated selection of]
+                           [inputdrivers to build. Possible inputdrivers]
+                           [are: all (builds all drivers), none (builds none),]
+                           [dbox2remote, dreamboxremote, dynapro, elo-input,]
+                           [gunze, h3600_ts, input_hub, joystick, keyboard, linuxinput,]
+                           [lirc, mutouch, penmount, ps2mouse, serialmouse,]
+                           [sonypijogdial, tslib, ucb1x00, wm97xx, zytronic.]
+                           [@<:@default=all@:>@]),
+            [inputdrivers="$withval"], [inputdrivers=all])
+if test "$inputdrivers" = "all"; then
+  checkfor_dbox2remote=yes
+  checkfor_dreamboxremote=yes
+  checkfor_dynapro=no
+  checkfor_elo=no
+  checkfor_gunze=no
+  checkfor_h3600ts=yes
+  checkfor_input_hub=yes
+  checkfor_joystick=yes
+  checkfor_keyboard=yes
+  checkfor_linux_input=yes
+  checkfor_lirc=yes
+  checkfor_mutouch=yes
+  checkfor_zytronic=yes
+  checkfor_penmount=yes
+  checkfor_ps2mouse=yes
+  checkfor_serialmouse=yes
+  checkfor_sonypijogdial=yes
+  checkfor_tslib=yes
+  checkfor_ucb1x00="$have_arm"
+  checkfor_wm97xx=yes
+  AC_MSG_RESULT(all)
+else
+  if test "$inputdrivers" != "none"; then
+    inputdrivers=`echo $inputdrivers | sed 's/,/ /g'`
+    for inputdriver in $inputdrivers
+    do
+      case "$inputdriver" in
+          dbox2remote)
+                  checkfor_dbox2remote=yes
+                  ;;
+          dreamboxremote)
+                  checkfor_dreamboxremote=yes
+                  ;;
+          dynapro)
+                  checkfor_dynapro=yes
+                  ;;
+          elo-input)
+                  checkfor_elo=yes
+                  ;;
+          gunze)
+                  checkfor_gunze=yes
+                  ;;
+          h3600_ts)
+                  checkfor_h3600ts=yes
+                  ;;
+          input_hub)
+                  checkfor_input_hub=yes
+                  ;;
+          joystick)
+                  checkfor_joystick=yes
+                  ;;
+          keyboard)
+                  checkfor_keyboard=yes
+                  ;;
+          linuxinput)
+                  checkfor_linux_input=yes
+                  ;;
+          lirc)
+                  checkfor_lirc=yes
+                  ;;
+          mutouch)
+                  checkfor_mutouch=yes
+                  ;;
+          zytronic)
+                  checkfor_zytronic=yes
+                  ;;
+          penmount)
+                  checkfor_penmount=yes
+                  ;;
+          ps2mouse)
+                  checkfor_ps2mouse=yes
+                  ;;
+          serialmouse)
+                  checkfor_serialmouse=yes
+                  ;;
+          sonypijogdial)
+                  checkfor_sonypijogdial=yes
+                  ;;
+          tslib)
+                  checkfor_tslib=yes
+                  ;;
+          ucb1x00)
+                  checkfor_ucb1x00=yes
+                  ;;
+          wm97xx)
+                  checkfor_wm97xx=yes
+                  ;;
+          *)
+                  echo "Unknown inputdriver $inputdriver, exiting!"
+                  exit 1
+                  ;;
+      esac
+    done
+    AC_MSG_RESULT($inputdrivers)
+  fi
+fi
+
+enable_dbox2remote=no
+if test "$checkfor_dbox2remote" = "yes"; then
+  dnl Test for dbox2 remote support in the kernel
+    AC_CHECK_HEADER( [dbox/fp.h], enable_dbox2remote=yes, enable_dbox2remote=no
+    AC_MSG_WARN([*** DBox2 Remote input driver will not be built.]))
+fi
+
+enable_dreamboxremote=no
+if test "$checkfor_dreamboxremote" = "yes"; then
+  dnl Test for dreambox remote support in the kernel
+    AC_CHECK_HEADER( [dbox/fp.h], enable_dreamboxremote=yes, enable_dreamboxremote=no
+    AC_MSG_WARN([*** DreamBox Remote input driver will not be built.]))
+fi
+
+enable_dynapro_ts=no
+if test "$checkfor_dynapro" = "yes"; then
+  dnl Test for Dynapro Touchscreen support
+  enable_dynapro_ts=yes
+fi
+
+enable_elo_input=no
+if test "$checkfor_elo" = "yes"; then
+  dnl Test for ELO Touchscreen support
+  enable_elo_input=yes
+fi
+
+enable_gunze_input=no
+if test "$checkfor_gunze" = "yes"; then
+  dnl Test for Gunze Touchscreen support
+  enable_gunze_input=yes
+fi
+
+enable_h3600_ts=no
+if test "$checkfor_h3600ts" = "yes"; then
+  dnl Test for H3600 Touchscreen support
+  AC_CHECK_HEADER( [linux/h3600_ts.h], enable_h3600_ts=yes, enable_h3600_ts=no
+    AC_MSG_WARN([*** H3600 Touchscreen driver will not be built.]))
+fi
+
+enable_input_hub=no
+if test "$checkfor_input_hub" = "yes"; then
+    enable_input_hub=yes
+fi
+
+enable_joystick=no
+if test "$checkfor_joystick" = "yes"; then
+  dnl Test for linux/joystick.h in the kernel
+
+  AC_CHECK_HEADER([linux/joystick.h], enable_joystick=yes, enable_joystick=no
+     AC_MSG_WARN([*** no linux/joystick.h -- Joystick driver will not be built.]))
+fi
+
+enable_keyboard=no
+if test "$checkfor_keyboard" = "yes"; then
+    enable_keyboard=yes
+fi
+
+enable_linux_input=no
+if test "$checkfor_linux_input" = "yes"; then
+  AC_CHECK_HEADER([linux/input.h], enable_linux_input=yes, enable_linux_input=no
+    AC_MSG_WARN([*** no linux/input.h -- Linux Input driver will not be built.]))
+
+  if test "$enable_linux_input" = "yes"; then
+    AC_MSG_CHECKING([for struct input_absinfo in linux/input.h])
+    AC_TRY_COMPILE([#include <linux/input.h>], [struct input_absinfo x; (void)x;],
+       AC_DEFINE(HAVE_INPUT_ABSINFO,1,
+         [Define to 1 if struct input_absinfo is defined in linux/input.h.])
+       AC_MSG_RESULT(yes),
+       AC_MSG_RESULT(no))
+  fi
+fi
+
+enable_lirc=no
+if test "$checkfor_lirc" = "yes"; then
+    enable_lirc=yes
+fi
+
+enable_mutouch=no
+if test "$checkfor_mutouch" = "yes"; then
+  dnl Allow to enable driver for Microtouch serial touchscreen
+  dnl This driver is not built by default since it needs to be configured
+  dnl by changing some defines in the source.
+    enable_mutouch=yes
+fi
+
+enable_zytronic=no
+if test "$checkfor_zytronic" = "yes"; then
+    enable_zytronic=yes
+fi
+
+enable_penmount=no
+if test "$checkfor_penmount" = "yes"; then
+    enable_penmount=yes
+fi
+
+enable_ps2mouse=no
+if test "$checkfor_ps2mouse" = "yes"; then
+    enable_ps2mouse=yes
+fi
+
+enable_serial_mouse=no
+if test "$checkfor_serialmouse" = "yes"; then
+  dnl Test for linux/serial.h in the kernel
+  AC_CHECK_HEADER([linux/serial.h], enable_serial_mouse=yes, enable_serial_mouse=no
+     AC_MSG_WARN([*** no linux/serial.h -- serial mouse driver will not be built.]))
+fi
+
+enable_sonypi_jogdial=no
+if test "$checkfor_sonypijogdial" = "yes"; then
+  dnl Test for SonyPI Jogdial support
+  AC_CHECK_HEADER([linux/sonypi.h], enable_sonypi_jogdial=yes, enable_sonypi_jogdial=no
+    AC_MSG_WARN([*** no linux/sonypi.h -- SonyPI Jogdial driver will not be built.]))
+fi
+
+enable_tslib=no
+if test "$checkfor_tslib" = "yes"; then
+  PKG_CHECK_MODULES([TSLIB], [tslib-1.0 >= 1.0.0], [enable_tslib=yes], [enable_tslib=no])
+  if test "$enable_tslib" = "no"; then
+     PKG_CHECK_MODULES([TSLIB], [tslib-0.0], [enable_tslib=yes], [enable_tslib=no
+       AC_MSG_WARN([*** no tslib -- tslib driver will not be built.])])
+  fi
+fi
+
+enable_ucb1x00_ts=no
+if test "$checkfor_ucb1x00" = "yes"; then
+  dnl Test for UCB1x00 Touchscreen support
+  enable_ucb1x00_ts=yes
+fi
+
+enable_wm97xx_ts=no
+if test "$checkfor_wm97xx" = "yes"; then
+  dnl Test for WM97xx Touchscreen support
+  enable_wm97xx_ts=yes
+fi
+
+ dnl *** end of if $testlinux ***
+fi
+
+
+
+AC_ARG_WITH(software,
+            AC_HELP_STRING([--without-software],
+                           [build without software rendering (can decrease binary size by >100k)]),
+            [], [])
+if test "$with_software" != "no"; then
+  with_software=yes
+fi
+
+AM_CONDITIONAL(SOFTWARE_RENDERING, test "$with_software" != "no")
+
+
+
+AC_ARG_WITH(smooth-scaling,
+            AC_HELP_STRING([--with-smooth-scaling],
+                           [build with smooth software scaling code (can increase binary size by >100k)]),
+            [], [])
+if test "$with_smooth_scaling" != "yes" -o "$with_software" != "yes"; then
+  with_smooth_scaling=no
+else
+  AC_DEFINE(DFB_SMOOTH_SCALING,1,[Define to 1 if smooth scaling code should be built.])
+fi
+
+AC_SUBST(DFB_SMOOTH_SCALING)
+
+
+
+AC_DEFINE(DFB_DITHER_SIMPLE,1,[Simple dithering, uses small dither table])
+AC_DEFINE(DFB_DITHER_ADVANCED,2,[Advanced dithering, uses large dither table])
+
+AC_ARG_WITH(dither-rgb16,
+            AC_HELP_STRING([--with-dither-rgb16=TYPE],
+                           [dithering to use when loading images into RGB16]
+                           [surfaces. Possible values for TYPE are: none]
+                           [(no dithering), simple (simple dithering, which]
+                           [increases the data section by 256 bytes), advanced]
+                           [(advanced dithering, which increases the data]
+                           [section by 64 KBytes). @<:@default=none@:>@]),
+            [], [with_dither_rgb16=none])
+case x"$with_dither_rgb16" in
+     x | xnone)
+          with_dither_rgb16=none
+          ;;
+     xsimple)
+          AC_DEFINE(DFB_DITHER565,DFB_DITHER_SIMPLE,[Dithering to use when rendering to RGB16 surfaces])
+          ;;
+     xadvanced)
+          AC_DEFINE(DFB_DITHER565,DFB_DITHER_ADVANCED,[Dithering to use when rendering to RGB16 surfaces])
+          ;;
+     *)
+          echo "Unknown dithering type $with_dither_rgb16, exiting!"
+          exit 1
+          ;;
+esac
+
+
+
+AC_ARG_WITH(dither,
+            AC_HELP_STRING([--with-dither=TYPE],
+                           [dithering to use when loading images into non-RGB16]
+                           [surfaces. Possible values for TYPE are: none]
+                           [(no dithering), simple (simple dithering, which]
+                           [increases the data section by 64 bytes), advanced]
+                           [(advanced dithering, which increases the data]
+                           [section by 16 KBytes). @<:@default=none@:>@]),
+            [], [with_dither=none])
+case x"$with_dither" in
+     x | xnone)
+          with_dither=none
+          ;;
+     xsimple)
+          AC_DEFINE(DFB_DITHER,DFB_DITHER_SIMPLE,[Dithering to use when rendering to non-RGB16 surfaces])
+          ;;
+     xadvanced)
+          AC_DEFINE(DFB_DITHER,DFB_DITHER_ADVANCED,[Dithering to use when rendering to non-RGB16 surfaces])
+          ;;
+     *)
+          echo "Unknown dithering type $with_dither, exiting!"
+          exit 1
+          ;;
+esac
+
+
+
+
+AC_ARG_WITH(setsockopt,
+            AC_HELP_STRING([--without-setsockopt],
+                           [build without setsockopt]),
+            [], [])
+if test "$with_setsockopt" != "no"; then
+  with_setsockopt=yes
+  VOODOO_BUILD_NO_SETSOCKOPT=0
+else
+  VOODOO_BUILD_NO_SETSOCKOPT=1
+fi
+
+AC_SUBST(VOODOO_BUILD_NO_SETSOCKOPT)
+
+
+AC_ARG_WITH(tests,
+            AC_HELP_STRING([--with-tests],
+                           [build test programs]),
+            [], [])
+if test "$with_tests" != "yes"; then
+  with_tests=no
+fi
+
+
+
+# How big of a buffer fluxed code uses for static args (times two with return)
+AC_ARG_WITH(args-size,
+            AC_HELP_STRING([--with-args-size=SIZE],
+                           [allow static args up to SIZE bytes @<:@default=1024@:>@]),
+            [], [with_args_size=no])
+test x"$with_args_size" = x"no" && with_args_size=1024
+FLUXED_ARGS_BYTES=$with_args_size
+AC_SUBST(FLUXED_ARGS_BYTES)
+
+
+# How big of a buffer fusion uses to read messages from the fusion device
+AC_ARG_WITH(message-size,
+            AC_HELP_STRING([--with-message-size=SIZE],
+                           [allow fusion messages up to SIZE bytes @<:@default=16384@:>@]),
+            [], [with_message_size=no])
+test x"$with_message_size" = x"no" && with_message_size=16384
+FUSION_MESSAGE_SIZE=$with_message_size
+AC_SUBST(FUSION_MESSAGE_SIZE)
+
+
+
+# Build tools?
+AC_ARG_WITH(tools,
+            AC_HELP_STRING([--without-tools],
+                           [do not build any tools]),
+            [], [])
+if test "$with_tools" != "no"; then
+  with_tools=yes
+fi
+
+
+
+# Sysroot used for runtime module loading, etc.
+AC_ARG_WITH(runtime-sysroot,
+            AC_HELP_STRING([--with-runtime-sysroot=DIR],
+                           [search for lib/share et al within DIR at runtime,]
+                           [e.g. when loading modules]),
+            [RUNTIME_SYSROOT="$withval"], [RUNTIME_SYSROOT=])
+test x"$RUNTIME_SYSROOT" = x"no" && RUNTIME_SYSROOT=
+AC_SUBST(RUNTIME_SYSROOT)
+
+
+
+dnl *** Look for directfb-csource in PATH if we are cross-compiling ***
+
+if test "$enable_unique" = "yes"; then
+  if test "$cross_compiling" = "yes" || test "$with_tools" = "no"; then
+    AC_PATH_PROG(DIRECTFB_CSOURCE, directfb-csource, no)
+    if test "x$DIRECTFB_CSOURCE" = "xno"; then
+      AC_MSG_ERROR(Could not find a directfb-csource in your PATH)
+    fi
+  fi
+fi
+
+
+
+AM_CONDITIONAL(GFX_ATI128, test "$ati128" = "yes")
+AM_CONDITIONAL(GFX_CLE266, test "$cle266" = "yes")
+AM_CONDITIONAL(GFX_CYBER5K, test "$cyber5k" = "yes")
+AM_CONDITIONAL(GFX_DAVINCI, test "$davinci" = "yes")
+AM_CONDITIONAL(GFX_EP9X, test "$ep9x" = "yes")
+AM_CONDITIONAL(GFX_GP2D, test "$gp2d" = "yes")
+AM_CONDITIONAL(GFX_GL, test "$gl" = "yes")
+AM_CONDITIONAL(GFX_GLES2, test "$gles2" = "yes")
+AM_CONDITIONAL(GFX_GLX, test "$glx" = "yes")
+AM_CONDITIONAL(GFX_I810, test "$i810" = "yes")
+AM_CONDITIONAL(GFX_I830, test "$i830" = "yes")
+AM_CONDITIONAL(GFX_MACH64, test "$mach64" = "yes")
+AM_CONDITIONAL(GFX_MATROX, test "$matrox" = "yes")
+AM_CONDITIONAL(GFX_NEOMAGIC, test "$neomagic" = "yes")
+AM_CONDITIONAL(GFX_NSC, test "$nsc" = "yes")
+AM_CONDITIONAL(GFX_NVIDIA, test "$nvidia" = "yes")
+AM_CONDITIONAL(GFX_OMAP, test "$omap" = "yes")
+AM_CONDITIONAL(GFX_PVR2D, test "$pvr2d" = "yes")
+AM_CONDITIONAL(GFX_PXA3XX, test "$pxa3xx" = "yes")
+AM_CONDITIONAL(GFX_RADEON, test "$radeon" = "yes")
+AM_CONDITIONAL(GFX_SAVAGE, test "$savage" = "yes")
+AM_CONDITIONAL(GFX_SH772X, test "$sh772x" = "yes")
+AM_CONDITIONAL(GFX_SIS315, test "$sis315" = "yes")
+AM_CONDITIONAL(GFX_TDFX, test "$tdfx" = "yes")
+AM_CONDITIONAL(GFX_UNICHROME, test "$unichrome" = "yes")
+AM_CONDITIONAL(GFX_VMWARE, test "$vmware" = "yes")
+AM_CONDITIONAL(GFX_VDPAU, test "$vdpau" = "yes")
+
+AM_CONDITIONAL(SH772X_SHJPEG, test "$sh772x_shjpeg" = "yes")
+
+AM_CONDITIONAL(DBOX2REMOTE, test "$enable_dbox2remote" = "yes")
+AM_CONDITIONAL(DREAMBOXREMOTE, test "$enable_dreamboxremote" = "yes")
+AM_CONDITIONAL(DYNAPRO_INPUT, test "$enable_dynapro_ts" = "yes")
+AM_CONDITIONAL(ELO_INPUT, test "$enable_elo_input" = "yes")
+AM_CONDITIONAL(GUNZE_INPUT, test "$enable_gunze_input" = "yes")
+AM_CONDITIONAL(H3600_TS, test "$enable_h3600_ts" = "yes")
+AM_CONDITIONAL(INPUT_HUB, test "$enable_input_hub" = "yes")
+AM_CONDITIONAL(JOYSTICK_INPUT, test "$enable_joystick" = "yes")
+AM_CONDITIONAL(KEYBOARD_INPUT, test "$enable_keyboard" = "yes")
+AM_CONDITIONAL(LINUX_INPUT, test "$enable_linux_input" = "yes")
+AM_CONDITIONAL(LIRC_INPUT, test "$enable_lirc" = "yes")
+AM_CONDITIONAL(MUTOUCH_TS, test "$enable_mutouch" = "yes")
+AM_CONDITIONAL(ZYTRONIC_TS, test "$enable_zytronic" = "yes")
+AM_CONDITIONAL(PENMOUNT_TS, test "$enable_penmount" = "yes" )
+AM_CONDITIONAL(PS2MOUSE_INPUT, test "$enable_ps2mouse" = "yes")
+AM_CONDITIONAL(SERIAL_MOUSE_INPUT, test "$enable_serial_mouse" = "yes")
+AM_CONDITIONAL(SONYPI, test "$enable_sonypi_jogdial" = "yes")
+AM_CONDITIONAL(TSLIB, test "$enable_tslib" = "yes")
+AM_CONDITIONAL(UCB1X00_TS, test "$enable_ucb1x00_ts" = "yes")
+AM_CONDITIONAL(WM97XX_TS, test "$enable_wm97xx_ts" = "yes")
+
+AM_CONDITIONAL(BUILD_TESTS, test "$with_tests" = "yes")
+AM_CONDITIONAL(BUILD_TOOLS, test "$with_tools" = "yes")
+AM_CONDITIONAL(CROSS_COMPILING, test "$cross_compiling" = "yes")
+
+CFLAGS="$CFLAGS $DFB_INTERNAL_CFLAGS"
+CXXFLAGS="$CXXFLAGS ${CFLAGS//-Werror-implicit-function-declaration/}"
+DFB_LDFLAGS="$LDFLAGS $ZLIB_LIBS"
+
+CFLAGS="$CFLAGS $CFLAGS_STD"
+
+
+# Honor aclocal flags
+ACLOCAL="$ACLOCAL $ACLOCAL_FLAGS"
+
+
+AM_CONDITIONAL(BUILD_SHARED, test "$enable_shared" = "yes")
+AM_CONDITIONAL(BUILD_STATIC, test "$enable_static" = "yes")
+
+
+# Change the module directory only for builds that don't *support* debug
+if test "$enable_debug_support" = "no"; then
+  MODULEDIRNAME=directfb-$BINARY_VERSION-pure
+else
+  MODULEDIRNAME=directfb-$BINARY_VERSION
+fi
+
+MODULEDIR=$libdir/$MODULEDIRNAME
+DATADIR=$datadir/directfb-$VERSION
+INCLUDEDIR=$includedir/directfb
+INTERNALINCLUDEDIR=$includedir/directfb-internal
+
+GENERIC_INCLUDEDIR=$includedir
+
+SOPATH=$libdir/libdirectfb-$LT_RELEASE.so.$LT_CURRENT
+AC_SUBST(SOPATH)
+
+AC_SUBST(HAVE_LINUX)
+AC_SUBST(DFB_CFLAGS_OMIT_FRAME_POINTER)
+AC_SUBST(DFB_LDFLAGS)
+AC_SUBST(DFB_INTERNAL_CFLAGS)
+AC_SUBST(X11_CFLAGS)
+AC_SUBST(X11_LIBS)
+AC_SUBST(X11VDPAU_CFLAGS)
+AC_SUBST(X11VDPAU_LIBS)
+AC_SUBST(SDL_CFLAGS)
+AC_SUBST(SDL_LIBS)
+AC_SUBST(TSLIB_CFLAGS)
+AC_SUBST(TSLIB_LIBS)
+AC_SUBST(ZLIB_LIBS)
+AC_SUBST(GIF_PROVIDER)
+AC_SUBST(JPEG_PROVIDER)
+AC_SUBST(LIBJPEG)
+AC_SUBST(MNG_PROVIDER)
+AC_SUBST(LIBMNG)
+AC_SUBST(PNG_PROVIDER)
+AC_SUBST(LIBPNG_CFLAGS)
+AC_SUBST(LIBPNG_LIBS)
+AC_SUBST(FREETYPE_PROVIDER)
+AC_SUBST(FREETYPE_CFLAGS)
+AC_SUBST(FREETYPE_LIBS)
+
+AC_SUBST(DATADIR)
+AC_SUBST(MODULEDIR)
+AC_SUBST(MODULEDIRNAME)
+AC_SUBST(INCLUDEDIR)
+AC_SUBST(INTERNALINCLUDEDIR)
+
+AC_SUBST(GENERIC_INCLUDEDIR)
+
+AS_AC_EXPAND(SYSCONFDIR, $sysconfdir)
+
+CFLAGS="$CFLAGS -Werror-implicit-function-declaration"
+
+AC_ARG_ENABLE(extra-warnings,
+              AC_HELP_STRING([--enable-extra-warnings],
+                             [enable extra warnings @<:@default=no@:>@]),
+              [], [enable_extra_warnings=no])
+if test "$enable_extra_warnings" = "yes"; then
+  CFLAGS="-W -Wno-sign-compare -Wno-unused-parameter -Wundef -Wcast-qual -Wcast-align -Waggregate-return -Wmissing-declarations -Winline $CFLAGS"
+fi
+
+if test "$GCC" = "yes"; then
+  CFLAGS="-Wall -Wstrict-prototypes -Wmissing-prototypes -Wno-strict-aliasing -Werror-implicit-function-declaration $CFLAGS"
+  CXXFLAGS="-Wall -Wno-strict-aliasing -std=$CXXSTD $CXXFLAGS"
+fi
+
+AM_CONDITIONAL(BUILD_DVC, test "x$ffmpeg" = "xyes")
+
+AC_OUTPUT([
+
+build-android/Makefile
+
+directfb-config
+directfb.pc
+directfb-internal.pc
+directfb.spec
+
+Makefile
+
+include/Makefile
+include/directfb_build.h
+include/directfb_version.h
+
+include/++dfb/Makefile
+
+lib/Makefile
+
+lib/direct/Makefile
+lib/direct/build.h
+lib/direct/direct.pc
+lib/direct/os/Makefile
+lib/direct/os/linux/glibc/Makefile
+
+lib/fusion/Makefile
+lib/fusion/build.h
+lib/fusion/fusion.pc
+lib/fusion/shm/Makefile
+
+lib/One/Makefile
+lib/One/one.pc
+
+lib/voodoo/Makefile
+lib/voodoo/build.h
+lib/voodoo/unix/Makefile
+lib/voodoo/voodoo.pc
+
+lib/sawman/Makefile
+lib/sawman/sawman.pc
+
+lib/fusiondale/Makefile
+lib/fusiondale/coma/Makefile
+lib/fusiondale/core/Makefile
+lib/fusiondale/messenger/Makefile
+lib/fusiondale/misc/Makefile
+lib/fusiondale/one/Makefile
+lib/fusiondale/fusiondale.pc
+lib/fusiondale/fusiondale_version.h
+
+lib/fusionsound/Makefile
+lib/fusionsound/core/Makefile
+lib/fusionsound/drivers/Makefile
+lib/fusionsound/media/Makefile
+lib/fusionsound/misc/Makefile
+lib/fusionsound/fusionsound.pc
+lib/fusionsound/fusionsound-internal.pc
+lib/fusionsound/fusionsound_limits.h
+lib/fusionsound/fusionsound_version.h
+
+lib/divine/Makefile
+lib/divine/divine.pc
+
+lib/dvc/Makefile
+
+lib/++dfb/Makefile
+lib/++dfb/++dfb.pc
+
+patches/Makefile
+
+proxy/Makefile
+proxy/compressor/Makefile
+proxy/dispatcher/Makefile
+proxy/requestor/Makefile
+
+rules/Makefile
+
+src/Makefile
+src/core/Makefile
+src/display/Makefile
+src/gfx/Makefile
+src/gfx/generic/Makefile
+src/input/Makefile
+src/media/Makefile
+src/misc/Makefile
+src/windows/Makefile
+
+systems/Makefile
+systems/android/Makefile
+systems/devmem/Makefile
+systems/dummy/Makefile
+systems/fbdev/Makefile
+systems/mesa/Makefile
+systems/drmkms/Makefile
+systems/pvr2d/Makefile
+systems/egl/Makefile
+systems/x11/Makefile
+systems/x11vdpau/Makefile
+systems/osx/Makefile
+systems/sdl/Makefile
+systems/vnc/Makefile
+
+wm/Makefile
+wm/default/Makefile
+wm/unique/Makefile
+wm/unique/classes/Makefile
+wm/unique/data/Makefile
+wm/unique/devices/Makefile
+wm/sawman/Makefile
+
+gfxdrivers/Makefile
+gfxdrivers/ati128/Makefile
+gfxdrivers/cle266/Makefile
+gfxdrivers/cyber5k/Makefile
+gfxdrivers/davinci/Makefile
+gfxdrivers/ep9x/Makefile
+gfxdrivers/gp2d/Makefile
+gfxdrivers/gl/Makefile
+gfxdrivers/gles2/Makefile
+gfxdrivers/i810/Makefile
+gfxdrivers/i830/Makefile
+gfxdrivers/mach64/Makefile
+gfxdrivers/matrox/Makefile
+gfxdrivers/neomagic/Makefile
+gfxdrivers/nsc/Makefile
+gfxdrivers/nsc/include/Makefile
+gfxdrivers/nvidia/Makefile
+gfxdrivers/omap/Makefile
+gfxdrivers/pvr2d/Makefile
+gfxdrivers/pxa3xx/Makefile
+gfxdrivers/radeon/Makefile
+gfxdrivers/savage/Makefile
+gfxdrivers/sh772x/Makefile
+gfxdrivers/sis315/Makefile
+gfxdrivers/tdfx/Makefile
+gfxdrivers/unichrome/Makefile
+gfxdrivers/vdpau/Makefile
+gfxdrivers/vmware/Makefile
+
+inputdrivers/Makefile
+inputdrivers/dbox2remote/Makefile
+inputdrivers/divine/Makefile
+inputdrivers/dreamboxremote/Makefile
+inputdrivers/dynapro/Makefile
+inputdrivers/elo/Makefile
+inputdrivers/gunze/Makefile
+inputdrivers/h3600_ts/Makefile
+inputdrivers/input_hub/Makefile
+inputdrivers/joystick/Makefile
+inputdrivers/keyboard/Makefile
+inputdrivers/linux_input/Makefile
+inputdrivers/lirc/Makefile
+inputdrivers/mutouch/Makefile
+inputdrivers/zytronic/Makefile
+inputdrivers/penmount/Makefile
+inputdrivers/ps2mouse/Makefile
+inputdrivers/serialmouse/Makefile
+inputdrivers/sonypi/Makefile
+inputdrivers/tslib/Makefile
+inputdrivers/ucb1x00_ts/Makefile
+inputdrivers/wm97xx_ts/Makefile
+
+interfaces/Makefile
+interfaces/ICoreResourceManager/Makefile
+interfaces/IDirectFBFont/Makefile
+interfaces/IDirectFBGL/Makefile
+interfaces/IDirectFBGL/EGL/Makefile
+interfaces/IDirectFBImageProvider/Makefile
+interfaces/IDirectFBImageProvider/mpeg2/Makefile
+interfaces/IDirectFBVideoProvider/Makefile
+interfaces/IDirectFBVideoProvider/video_out_dfb/Makefile
+interfaces/IDirectFBWindows/Makefile
+interfaces/IFusionSound/Makefile
+interfaces/IFusionSoundMusicProvider/Makefile
+interfaces/IWater/Makefile
+
+data/Makefile
+
+tests/Makefile
+tests/voodoo/Makefile
+tools/Makefile
+examples/fusiondale/Makefile
+examples/fusionsound/Makefile
+examples/++dfb/Makefile
+examples/++dfb/tests/Makefile
+examples/++dfb/tests/data/Makefile
+docs/Makefile
+docs/dfbg.1
+docs/directfb-csource.1
+docs/directfbrc.5
+docs/html/Makefile
+
+], [chmod +x directfb-config])
+
+
+eval eval_moduledir=$MODULEDIR
+eval eval_moduledir=$eval_moduledir
+eval eval_moduledir=$eval_moduledir
+
+
+AC_MSG_RESULT([
+Build options:
+  Version                   $VERSION
+  Linux powered             $have_linux
+  Install prefix            $prefix
+  Config files in           $SYSCONFDIR
+  Build shared libs         $enable_shared
+  Build static libs         $enable_static
+  Module directory          $eval_moduledir
+  CC                        $CC
+  CXX                       $CXX
+  LD                        $LD
+  CPPFLAGS                  $CPPFLAGS
+  CFLAGS                    $CFLAGS
+  CXXFLAGS                  $CXXFLAGS
+  LDFLAGS                   $LDFLAGS
+  LIBS                      $LIBS
+  DYNLIB                    $DYNLIB
+  RTLIB                     $RTLIB
+  THREADFLAGS               $THREADFLAGS
+  THREADLIB                 $THREADLIB
+
+Misc options:
+  Multi Application Core    $enable_multi
+  Fusion Kernel Device      $enable_multi_kernel
+  Fusion message size       $with_message_size
+  Fluxed args size          $with_args_size
+  One (IPC)                 $enable_one
+  Voodoo (network support)  $enable_voodoo
+  Pure Voodoo (net only)    $enable_pure_voodoo
+  DiVine (virtual input)    $enable_divine
+  FusionDale                $enable_fusiondale
+  Debug supported           $enable_debug_support
+  Debug enabled             $enable_debug
+  Trace support             $enable_trace
+  MMX support               $enable_mmx
+  SSE support               $enable_sse
+  GCC Atomics usage         $enable_gcc_atomics
+  Network support           $enable_network
+  Include all strings       $enable_text
+  Software Rendering        $with_software
+  Smooth SW Scaling         $with_smooth_scaling
+  Dithering                 $with_dither
+  Dithering 565             $with_dither_rgb16
+  zlib compression          $use_zlib                 $ZLIB_LIBS
+  Using setsockopt          $with_setsockopt
+
+Building Tests              $with_tests
+Building Tools              $with_tools
+
+Building System Modules:
+  Linux FBDev support       $enable_fbdev
+  Generic /dev/mem support  $enable_devmem
+  Mesa/DRM/KMS support      $enable_mesa                $MESA_CFLAGS $MESA_LIBS
+  DRM/KMS support           $enable_drmkms              $DRMKMS_CFLAGS $DRMKMS_LIBS
+  PVR2D                     $enable_pvr2d               $PVR2D_CFLAGS $PVR2D_LIBS
+  EGL                       $enable_egl                 $EGL_CFLAGS $EGL_LIBS
+  X11 support               $enable_x11                 $X11_CFLAGS $X11_LIBS
+  X11/VDPAU support         $enable_x11vdpau            $X11VDPAU_CFLAGS $X11VDPAU_LIBS
+  OSX support               $enable_osx                 $OSX_CFLAGS $OSX_LIBS
+  SDL support               $enable_sdl                 $SDL_CFLAGS $SDL_LIBS
+  VNC support               $enable_vnc                 $VNC_CFLAGS $VNC_LIBS
+
+Building Window Manager Modules:
+  Default                   yes
+  UniQuE                    $enable_unique
+  SaWMan                    $enable_sawman
+
+Building Image Provider Modules:
+  GIF                       $enable_gif
+  JPEG                      $JPEG                 $LIBJPEG
+  PNG                       $PNG                  $LIBPNG_CFLAGS $LIBPNG_LIBS
+  Imlib2                    $imlib2               $IMLIB2_CFLAGS $IMLIB2_LIBS
+  PNM                       $enable_pnm
+  SVG                       $svg                  $LIBSVG_CFLAGS $LIBSVG_LIBS
+  BMP                       $enable_bmp
+  WEBP                      $webp                 $LIBWEBP_CFLAGS $LIBWEBP_LIBS
+  JPEG2000                  $enable_jpeg2000             $JASPER_LIBS
+  MPEG2                     $enable_mpeg2
+  TIFF                      $tiff                 $LIBTIFF_CFLAGS $LIBTIFF_LIBS
+
+
+
+Building Video Provider Modules:
+  GIF                       $enable_gif
+  Video4Linux               $V4L (v2: $V4L2)
+  MNG                       $MNG                 $LIBMNG_CFLAGS $LIBMNG_LIBS
+  Gstreamer                 $gstreamer (v1: $HAVE_GSTREAMER_1_0)       $GSTREAMER_INCL $GSTREAMER_LIBS
+    with FusionSound        $enable_fusionsound
+  AviFile                   $avifile
+  Flash                     $flash
+  Libmpeg3                  $mpeg3
+  OpenQuicktime             $openquicktime
+  Xine                      $xine
+  Xine/VDPAU                $xine_vdpau
+  Swfdec                    $swfdec
+  FFmpeg                    $ffmpeg
+
+Building Font Modules:
+  FreeType2                 $FREETYPE                 $FREETYPE_CFLAGS $FREETYPE_LIBS
+  LinoType                  $LINOTYPE                 $LINOTYPE_CFLAGS $LINOTYPE_LIBS
+  Default font              yes
+
+Building FusionSound        $enable_fusionsound]);
+
+if test "$enable_fusionsound" = "yes"; then
+AC_MSG_RESULT([
+  Options:
+    IEEE floats:            $enable_fs_ieee_floats
+    Precision:              $enable_fs_precision
+    Linear filter:          $enable_fs_linear_filter
+    Multichannel            $enable_fs_multichannel
+  Drivers:
+    OSS                     $fsdriver_oss
+    ALSA                    $fsdriver_alsa
+    WAVE                    $fsdriver_wave
+  Music Providers:
+    Timidity                $timidity
+    Wave                    $with_wave
+    Ogg/Vorbis              $vorbis
+    MAD                     $mad
+    CD-DA                   $cdda
+    FFmpeg                  $ffmpeg
+    Playlist                $with_playlist]);
+fi
+
+if test "$have_linux" = "yes"; then
+AC_MSG_RESULT([
+Building Graphics Drivers:
+  3Dfx Voodoo               $tdfx
+  ATI Mach64                $mach64
+  ATI Rage 128              $ati128
+  ATI Radeon                $radeon
+  Cirrus EP9X               $ep9x
+  Intel i810                $i810
+  Intel i830                $i830
+  Matrox                    $matrox
+  NeoMagic                  $neomagic
+  NSC Geode                 $nsc
+  nVidia                    $nvidia
+  PVR2D                     $pvr2d
+  PXA 3xx                   $pxa3xx
+  Renesas R-Car GP2D        $gp2d                 $GP2D_CFLAGS  $GP2D_LIBS
+  Renesas SH7722/SH7723     $sh772x
+  S3 Savage                 $savage
+  SiS 315                   $sis315
+  TI Davinci                $davinci
+  TI OMAP                   $omap
+  TVIA CyberPro             $cyber5k
+  VIA CLE266                $cle266
+  VIA UniChrome             $unichrome
+  VMWare                    $vmware
+  VDPAU                     $vdpau
+  --
+  OpenGL                    $gl (GLX: $glx)
+  OpenGL ES 2.0             $gles2 (Mesa:  $enable_mesa, PVR2D: $enable_pvr2d)
+                                       $GLES2_CFLAGS $GLES2_LIBS
+
+  IDirectFBGL-EGL           $enable_idirectfbgl_egl       $EGL_CFLAGS $EGL_LIBS
+
+Building Input Drivers:
+  DBox2 Remote              $enable_dbox2remote
+  DreamBox Remote           $enable_dreamboxremote
+  Dynapro Touchscreen       $enable_dynapro_ts
+  ELO Touchscreen           $enable_elo_input
+  Gunze Touchscreen         $enable_gunze_input
+  H3600 Touchscreen         $enable_h3600_ts
+  Input Hub                 $enable_input_hub
+  Joystick                  $enable_joystick
+  Keyboard                  $enable_keyboard
+  Linux Input               $enable_linux_input
+  LiRC                      $enable_lirc
+  MuTouch touchscreen       $enable_mutouch
+  Zytronic touchscreen      $enable_zytronic
+  PS/2 Mouse                $enable_ps2mouse
+  Serial Mouse              $enable_serial_mouse
+  SonyPI Jogdial            $enable_sonypi_jogdial
+  tslib                     $enable_tslib                 $TSLIB_CFLAGS $TSLIB_LIBS
+  ucb1x00 Touchscreen       $enable_ucb1x00_ts
+  WM97xx Touchscreen        $enable_wm97xx_ts]);
+fi
+
+AC_MSG_RESULT([$png_warning $jpeg_warning $freetype_warning
+]);
diff -Naur DirectFB-1.7.7/data/Makefile.am DirectFB-1.7.7.stm/data/Makefile.am
--- DirectFB-1.7.7/data/Makefile.am	2013-12-19 01:16:24.000000000 +0100
+++ DirectFB-1.7.7.stm/data/Makefile.am	2015-05-15 18:43:40.001319075 +0200
@@ -5,3 +5,10 @@
 miscdata_DATA = cursor.dat cursor.png decker.dgiff decker.ttf
 
 EXTRA_DIST = $(miscdata_DATA)
+
+noinst_MISCDATA = \
+	directfb.rle	\
+	directfb.png	\
+	directfb.bmp	\
+	BD-RLE8.tar.gz	\
+	README
diff -Naur DirectFB-1.7.7/data/README DirectFB-1.7.7.stm/data/README
--- DirectFB-1.7.7/data/README	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7.stm/data/README	2015-05-15 18:43:40.001319075 +0200
@@ -0,0 +1,22 @@
+INTRODUCTION
+------------
+This directory contains image files.
+
+
+DESCRIPTION
+-----------
+
+BD-RLE8 subdirectory contains a collection of BD-RLE8 encoded files only
+(after extracting from BD-RLE8.tar.gz ... e.g  # tar -zxvf BD-RLE8.tar.gz)
+
+ *.BDRLE8.rle	:	BD-RLE8 compressed payload files, "RL" comaptible header
+					without palette table
+ *.BDRLE8.pal	:	Palette table files (typically 256 entries for e.g. BD-RLE8)
+ *.BDRLE8.RLE	:	BD-RLE8 compressed payload files, "RL" comaptible header
+					with palette table and correct compression ID
+
+The following files contain DirectFB logo in various common formats:
+
+ directfb.rle   :   legacy RLE8 format using "RL" header ID
+ directfb.bmp   :   legacy BMP format and header using RLE compression
+ directfb.png   :   legacy PNG (unrelated / test for other ImageProvider)
diff -Naur DirectFB-1.7.7/docs/Makefile.am DirectFB-1.7.7.stm/docs/Makefile.am
--- DirectFB-1.7.7/docs/Makefile.am	2013-12-19 01:16:24.000000000 +0100
+++ DirectFB-1.7.7.stm/docs/Makefile.am	2015-05-15 18:43:40.001319075 +0200
@@ -34,6 +34,8 @@
 
 
 EXTRA_DIST = \
+	DirectFB_Extensions_RLE_Image_Provider_Specs_and_Report.pdf \
+	README.rle		\
 	README.screenshots	\
 	dfbg.1.in		\
 	directfbrc.5.in		\
diff -Naur DirectFB-1.7.7/docs/README.rle DirectFB-1.7.7.stm/docs/README.rle
--- DirectFB-1.7.7/docs/README.rle	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7.stm/docs/README.rle	2015-05-15 18:43:40.005323075 +0200
@@ -0,0 +1,371 @@
+--------------------------------------------------------------------------------
+                            RLE Image Provider
+--------------------------------------------------------------------------------
+
+Support for RLE image format.
+
+
+
+*** CURRENT RLE IMAGE PROVIDER SPECIFICATIONS ***
+
+--------------------------------------------------------------------------------
+[A] Supported payload formats:
+
+  [1] Compressed:   [RLEIC_RLE8]
+
+  * RLE8      8 bits LUT-indexed / run-length-compressed / block mode
+
+  * BD-RLE8   8 bits LUT-indexed / run-length-compressed / block mode
+
+  [2] Uncompressed: [RLEIC_NONE] / backward compatibility
+
+  * Uncompressed 1/2/4/8 bits LUT-indexed / row mode
+
+  * Uncompressed 16/24 bits fixed RGB bit-field components / row mode
+
+
+  NB:  Single plane picture only
+       Provisions for extensions / RLE formats variants
+--------------------------------------------------------------------------------
+
+--------------------------------------------------------------------------------
+[B] Supported source buffer structure:
+
+  * Header : 54 bytes  (unoptimized - byte-packed, BMP standard layout)
+
+  * Palette: indexed RGB24 - (3x8 bits + 1x8 bits) x max_colors (2-256)
+
+  * Payload: encapsulated within packet at given offset location
+
+
+  NB:  Provisions for static memory/file access or streaming modes
+--------------------------------------------------------------------------------
+
+--------------------------------------------------------------------------------
+[C] Supported output surface:
+
+  * ARGB 32 surface - Opaque alpha channel (set to 0xff)
+
+  * LUT8 indexed support provision
+--------------------------------------------------------------------------------
+
+--------------------------------------------------------------------------------
+[D] Supported Image-Provider modes:
+
+  * Direct memory static DFB buffer
+
+  * Standard File loader
+
+  * No hardware acceleration
+
+  * Non optimized software fall-back only
+
+  NB:  Provisions for DFB streaming mode
+       Provisions for future hardware acceleration
+--------------------------------------------------------------------------------
+
+--------------------------------------------------------------------------------
+[E] Packaging:
+
+  * Ships with unit-test code
+    [1]  Unit-test (DirectFB sample code) :
+         Brief application source code showing how to use a DFB static memory
+         buffer issued Image-Provider instance in order to render the RLE
+         object stored in memory to some surface
+         - Packet build helper function provided (see rle_build_packet.c).
+
+--------------------------------------------------------------------------------
+
+--------------------------------------------------------------------------------
+[F] Standard Compliance:
+
+- Little Endian / byte alignment
+
+- BMP-Compliant - BMP packet/file header (see enclosed specs below)
+
+- RLE-8  - Run-Lenght RLE-8 decoder - Top or Bottom first (see enclosed specs)
+--------------------------------------------------------------------------------
+
+
+--------------------------------------------------------------------------------
+[G] Lisensing:
+
+- Released under the terms of the GNU General Public License version 2
+
+  NB:  Until further notice (TBD)
+
+--------------------------------------------------------------------------------
+
+
+================================================================================
+
+    ANNEX A    -    RLE-8 Specifications    (RLE-8 Payload data)
+
+================================================================================
+RLE-8 bitmaps are compressed by using a run-length encoding (rle) format for an
+8-bit bitmap. this format can be compressed in encoded or absolute modes. both
+modes can occur anywhere in the same bitmap.
+--------------------------------------------------------------------------------
+    * encoded mode consists of two bytes:
+
+        The first byte specifies the number of consecutive pixels to be drawn
+        using the color index contained in the second byte. in addition, the
+        first byte of the pair can be set to zero to indicate an escape that
+        denotes an end of line, end of bitmap, or delta. the interpretation
+        of the escape depends on the value of the second byte of the pair,
+        which can be one of the following:
+
+            0        end of line.
+
+            1        end of bitmap.
+
+            2        delta. the two bytes following the escape contain unsigned
+                    values indicating the horizontal and vertical offsets of the
+                    next pixel from the current position.
+--------------------------------------------------------------------------------
+    * absolute mode.
+
+        The first byte is zero and the second byte is a value in the range 03h
+        through ffh. the second byte represents the number of bytes that follow,
+        each of which contains the color index of a single pixel. when the
+        second byte is 2 or less, the escape has the same meaning as in encoded
+        mode. in absolute mode, each run must be aligned on a word boundary.
+--------------------------------------------------------------------------------
+    The following example shows the hexadecimal values of an 8-bit compressed
+    bitmap:
+
+        03 04 05 06 00 03 45 56 67 00 02 78 00 02 05 01 02 78 00 00 09 1e 00 01
+
+    This bitmap would expand as follows (two-digit values represent a color
+    index for a single pixel):
+        04 04 04
+        06 06 06 06 06
+        45 56 67
+        78 78
+
+    Move current position 5 right and 1 down
+        78 78
+
+    End of line
+        1e 1e 1e 1e 1e 1e 1e 1e 1e
+
+    End of rle bitmap
+================================================================================
+
+
+
+
+================================================================================
+
+    ANNEX B    -    PACKET/FILE FORMAT: (BMP specifications except identifier)
+
+================================================================================
+offset        field               size        contents
+================================================================================
+0000h       identifier             2 bytes  the signature identifying the bitmap.
+                                            Possible entries :  'BM' or 'RL'
+--------------------------------------------------------------------------------
+0002h        file/packet size      1 dword  complete file/packet size in bytes.
+--------------------------------------------------------------------------------
+0006h        reserved              1 dword  reserved for later use.
+--------------------------------------------------------------------------------
+000ah        bitmap data offset    1 dword  offset from beginning of file/packet
+                                            to the beginning of the bitmap data.
+--------------------------------------------------------------------------------
+000eh        bitmap header size    1 dword  length of the bitmap info header
+                                            used to describe the bitmap colors,
+                                            compression;
+                                            the following sizes are possible:
+                                             40 = 28h - Default
+                                             12 = 0ch - UNSUPPORTED
+                                            240 = f0h - UNSUPPORTED
+--------------------------------------------------------------------------------
+0012h        width                 1 dword  horizontal width of bitmap in pixels.
+0016h        height                1 dword  vertical height of bitmap in pixels.
+001ah        planes                1 word   number of planes in this bitmap.
+001ch        bits per pixel        1 word   bits per pixel used to store palette
+                                            entry information. this also
+                                            identifies in an indirect way the
+                                            number of possible colors.
+                                            possible values are:
+                                              1 - monochrome bitmap
+                                              4 - 16 color bitmap
+                                              8 - 256 color bitmap
+                                             16 - 16bit (high color) bitmap
+                                             24 - 24bit (true color) bitmap
+                                             32 - 32bit (true color) bitmap
+--------------------------------------------------------------------------------
+001eh        compression           1 dword  compression specifications.
+                                            the following values are possible:
+                                            0 - none       (ID: bi_rgb)
+                                            1 - rle 8-bit (bi_rle8)
+                                            2 - rle 4-bit (bi_rle4)  UNSUPPORTED
+                                            3 - fields (bi_bitfield) UNSUPPORTED
+--------------------------------------------------------------------------------
+0022h        bitmap data size      1 dword  size of the bitmap data in bytes.
+                                            this number must be rounded to the
+                                            next 4 byte boundary.
+--------------------------------------------------------------------------------
+0026h        hresolution           1 dword  horizontal resolution expressed in
+                                            pixel per meter.         UNSUPPORTED
+--------------------------------------------------------------------------------
+002ah        vresolution           1 dword  vertical resolution expressed in
+                                            pixels per meter.        UNSUPPORTED
+--------------------------------------------------------------------------------
+002eh        colors                1 dword  number of colors used by this bitmap.
+                                            for a 8-bit / pixel bitmap this will
+                                            be 100h or 256.
+--------------------------------------------------------------------------------
+0032h        important colors      1 dword  number of important colors. this
+                                            number will be equal to the number
+                                            of colors when any color is important.
+--------------------------------------------------------------------------------
+0036h        palette            n * 4 byte  colormap specification. for every
+                                            entry in the palette four bytes are
+                                            used to describe the rgb values of
+                                            the color in the following way:
+                                                1 byte for blue  component
+                                                1 byte for green component
+                                                1 byte for red   component
+                                                1 byte filler which is set to 0
+--------------------------------------------------------------------------------
+0436h        bitmap data           x bytes  depending on the compression specs,
+                                            this field contains all the bitmap
+                                            data bytes which represent indexes
+                                            in the color palette for indexed
+                                            formats.
+================================================================================
+
+
+
+
+================================================================================
+
+    ANNEX C    -    PACKET/FILE FORMAT: FIELDS DETAILS
+
+================================================================================
+
+height field:
+
+    the height field identifies the height of the bitmap in pixels. in other
+    words, it describes the number of scan lines of the bitmap. if this field
+    is negative, indicating a top-down dib, the compression field must be either
+    bi_rgb or bi_bitfields. top-down dibs cannot be compressed.
+
+bits per pixel field:
+
+    the bits per pixel (bbp) field of the bitmap file determines the number of
+    bits that define each pixel and the maximum number of colors in the bitmap.
+
+    * when this field is equal to 1.
+        the bitmap is monochrome, and the palette contains two entries. each bit
+        in the bitmap array represents a pixel. if the bit is clear, the pixel
+        is displayed with the color of the first entry in the palette; if the
+        bit is set, the pixel has the color of the second entry in the table.
+
+    * when this field is equal to 4.
+        the bitmap has a maximum of 16 colors, and the palette contains up to 16
+        entries. each pixel in the bitmap is represented by a 4-bit index into
+        the palette. for example, if the first byte in the bitmap is 1fh, the
+        byte represents two pixels. the first pixel contains the color in the
+        second palette entry, and the second pixel contains the color in the
+        sixteenth palette entry.
+
+    * when this field is equal to 8.
+        the bitmap has a maximum of 256 colors, and the palette contains up to
+        256 entries. in this case, each byte in the array represents a single
+        pixel.
+
+    * when this field is equal to 16.
+        the bitmap has a maximum of 2^16 colors. if the compression field of the
+        bitmap file is set to bi_rgb, the palette field does not contain any
+        entries. each word in the bitmap array represents a single pixel. the
+        relative intensities of red, green, and blue are represented with 5 bits
+        for each color component. the value for blue is in the least significant
+        5 bits, followed by 5 bits each for green and red, respectively. the
+        most significant bit is not used.
+
+    * when this field is equal to 24.
+        the bitmap has a maximum of 2^24 colors, and the palette field does not
+        contain any entries. each 3-byte triplet in the bitmap array represents
+        the relative intensities of blue, green, and red, respectively, for a
+        pixel.
+
+    * when this field is equal to 32.
+        the bitmap has a maximum of 2^32 colors. if the compression field of the
+        bitmap is set to bi_rgb, the palette field does not contain any entries.
+        each dword in the bitmap array represents the relative intensities of
+        blue, green, and red, respectively, for a pixel. the high byte in each
+        dword is not used.
+
+        NOTE:
+        if the compression field of the bitmap file is set to bi_bitfields, the
+        palette field contains three dword color masks that specify the red,
+        green, and blue components, respectively, of each pixel. each word in
+        the bitmap array represents a single pixel.
+
+compression field:
+
+    The compression field specifies the way the bitmap data is stored in the
+    file/packet. this information together with the bits per pixel (bpp) field
+    identifies the compression algorithm to follow.
+
+    The following values are possible in this field:
+
+    ============================================================================
+    value                meaning
+    ============================================================================
+
+    bi_rgb              An uncompressed format.
+
+    bi_rle8             A run-length encoded (rle) format for bitmaps with 8
+                        bits per pixel. the compression format is a two-byte
+                        format consisting of a count byte followed by a byte
+                        containing a color index. for more information, see the
+                        following remarks section.
+
+
+    bi_rle4             A rle format for bitmaps with 4 bits per pixel. the
+                        compression format is a two-byte format consisting of a
+        (UNSUPPORTED)   count byte followed by two word-length color indexes.
+                        for more information, see the following remarks section.
+
+
+    bi_bitfields        Specifies that the bitmap is not compressed and that the
+                        color table consists of three double word color masks
+        (UNSUPPORTED)   that specify the red, green, and blue components,
+                        respectively, of each pixel. this is valid when used
+                        with 16- and 32- bits-per-pixel bitmaps.
+                        UNSUPPORTED
+
+    ============================================================================
+
+colors field:
+
+    The colors field specifies the number of color indexes in the color table
+    that are actually used by the bitmap. if this value is zero, the bitmap uses
+    the maximum number of colors corresponding to the value of the bbp field for
+    the compression mode specified by the compression field.
+
+    if the colors field is nonzero and the bbp field less than 16, the colors
+    field specifies the actual number of colors the graphics engine or device
+    driver accesses.
+
+    if the bbp field is 16 or greater, then colors field specifies the size of
+    the color table used to optimize performance of windows color palettes.
+
+    if bbp equals 16 or 32, the optimal color palette starts immediately
+    following the three double word masks.
+
+    if the bitmap is a packed bitmap (a bitmap in which the bitmap array
+    immediately follows the bitmap header and which is referenced by a single
+    pointer), the colors field must be either 0 or the actual size of the color
+    table.
+
+important colors field:
+        (UNSUPPORTED)
+    The important colors field specifies the number of color indexes that are
+    considered important for displaying the bitmap. if this value is zero, all
+    colors are important.
+
+================================================================================
diff -Naur DirectFB-1.7.7/include/directfb.h DirectFB-1.7.7.stm/include/directfb.h
--- DirectFB-1.7.7/include/directfb.h	2015-02-01 20:36:12.000000000 +0100
+++ DirectFB-1.7.7.stm/include/directfb.h	2015-05-15 18:43:40.009327075 +0200
@@ -544,7 +544,8 @@
 typedef enum {
      DIRENDER_NONE           = 0x00000000,
      DIRENDER_FAST           = 0x00000001,   /* Select fast rendering method */
-     DIRENDER_ALL            = 0x00000001
+     DIRENDER_BACKGROUND     = 0x00000002,   /* Async rendering */
+     DIRENDER_ALL            = 0x00000003
 } DIRenderFlags;
 
 /*
@@ -860,8 +861,9 @@
      DIDTF_JOYSTICK      = 0x00000004,  /* Can be used as a joystick. */
      DIDTF_REMOTE        = 0x00000008,  /* Is a remote control. */
      DIDTF_VIRTUAL       = 0x00000010,  /* Is a virtual input device. */
+     DIDTF_SENSOR        = 0x00000020,  /* Is a motion sensing input device. */
 
-     DIDTF_ALL           = 0x0000001F   /* All type flags set. */
+     DIDTF_ALL           = 0x0000003F   /* All type flags set. */
 } DFBInputDeviceTypeFlags;
 
 /*
@@ -872,8 +874,9 @@
      DICAPS_KEYS         = 0x00000001,  /* device supports key events */
      DICAPS_AXES         = 0x00000002,  /* device supports axis events */
      DICAPS_BUTTONS      = 0x00000004,  /* device supports button events */
+     DICAPS_SENSORS      = 0x00000008,  /* device supports sensor events */
 
-     DICAPS_ALL          = 0x00000007   /* all capabilities */
+     DICAPS_ALL          = 0x0000000F   /* all capabilities */
 #else
      DIDCAPS_NONE        = 0x00000000,  /* device supports no events */
      DIDCAPS_KEYS        = 0x00000001,  /* device supports key events */ 
@@ -914,6 +917,26 @@
      DIAI_LAST           = 0x0000001F   /* 32 axes maximum */
 } DFBInputDeviceAxisIdentifier;
 
+
+/*
+ * Sensors identifiers for sensors-equipped input devices
+ *
+ * Only motion generating sensors are defined here. Depending on its type as
+ * specified by DFBInputDeviceSensorIdentifier, the actual sensor data is
+ * stored in the <i>sensor_data</i> field of the DFBInputEvent structure and
+ * is expressed in a common referential (unit) across devices.
+ */
+typedef enum {
+     DISI_ACCELEROMETER       = 0x00000001,  /* Accelerometer sensor type */
+     DISI_GYROSCOPE           = 0x00000002,  /* Device rotation around
+                                                X, Y and Z axes  */
+     DISI_LINEAR_ACCELERATION = 0x00000010,  /* Acceleration along each device
+                                                axis (without gravity value) */
+     DISI_ORIENTATION         = 0x00000020,  /* Yaw, pitch and roll */
+     DISI_ALL                 = 0x0000003F   /* All sensors mask */
+} DFBInputDeviceSensorIdentifier;
+
+
 /*
  * Flags defining which fields of a DFBWindowDescription are valid.
  */
@@ -1311,11 +1334,24 @@
      DSPF_ALUT8     = DFB_SURFACE_PIXELFORMAT( 40,  8, 8, 1, 0, 2, 0, 0, 0, 1, 0 ),
 
      /*  1 bit    LUT (1 byte/ 8 pixel, 1 bit color and alpha lookup from palette) */
-     DSPF_LUT1      = DFB_SURFACE_PIXELFORMAT( 41,  1, 0, 1, 1, 0, 7, 0, 0, 1, 0 )
+     DSPF_LUT1      = DFB_SURFACE_PIXELFORMAT( 41,  1, 0, 1, 1, 0, 7, 0, 0, 1, 0 ),
+
+     /* 24 bit   RGB (3 byte, blue 8@16, green 8@8, red 8@0) */
+     DSPF_BGR24     = DFB_SURFACE_PIXELFORMAT( 42, 24, 0, 0, 0, 3, 0, 0, 0, 0, 0 ),
+
+     /* 12 bit   YUV (8 bit Y plane followed by one 16 bit quarter size Cb|Cr [7:0|7:0] plane) in Omega2 macroblock format */
+     DSPF_NV12MB    = DFB_SURFACE_PIXELFORMAT( 43, 12, 0, 0, 0, 1, 0, 2, 0, 0, 0 ),
+
+     /* 16 bit   YUV (8 bit Y plane followed by one 16 bit half width Cb|Cr [7:0|7:0] plane) in Omega2 macroblock format */
+     DSPF_NV16MB    = DFB_SURFACE_PIXELFORMAT( 44, 24, 0, 0, 0, 1, 0, 0, 1, 0, 0 ),
+
+     /* 24 bit   YUV (8 bit Y plane followed by one 16 bit full width Cb|Cr [7:0|7:0] plane) */
+     DSPF_NV24     = DFB_SURFACE_PIXELFORMAT( 45, 24, 0, 0, 0, 1, 0, 0, 2, 0, 0 )
+
 } DFBSurfacePixelFormat;
 
 /* Number of pixelformats defined */
-#define DFB_NUM_PIXELFORMATS            42
+#define DFB_NUM_PIXELFORMATS            46
 
 /* These macros extract information about the pixel format. */
 #define DFB_PIXELFORMAT_INDEX(fmt)      (((fmt) & 0x0000007F)      )
@@ -1361,6 +1397,7 @@
       ((fmt) == DSPF_BGR555)       ||   \
       ((fmt) == DSPF_ARGB8565)     ||   \
       ((fmt) == DSPF_ABGR)         ||   \
+      ((fmt) == DSPF_BGR24)        ||   \
       ((fmt) == DSPF_RGBAF88871))
 
 #define DFB_COLOR_IS_YUV(fmt)           \
@@ -1370,7 +1407,10 @@
       ((fmt) == DSPF_YV12)         ||   \
       ((fmt) == DSPF_NV12)         ||   \
       ((fmt) == DSPF_NV16)         ||   \
+      ((fmt) == DSPF_NV12MB)       ||   \
+      ((fmt) == DSPF_NV16MB)       ||   \
       ((fmt) == DSPF_NV21)         ||   \
+      ((fmt) == DSPF_NV24)         ||   \
       ((fmt) == DSPF_AYUV)         ||   \
       ((fmt) == DSPF_YUV444P)      ||   \
       ((fmt) == DSPF_AVYU)         ||   \
@@ -1550,6 +1590,8 @@
                                                         identifier */
      DFBInputDeviceButtonIdentifier     max_button;  /* highest button
                                                         identifier */
+     DFBInputDeviceSensorIdentifier     sensors;     /* supported sensors
+                                                        identifier */
 
      char name[DFB_INPUT_DEVICE_DESC_NAME_LENGTH];   /* Device name */
 
@@ -1741,12 +1783,25 @@
 typedef enum {
      DVPLAY_NOFX        = 0x00000000, /* normal playback           */
      DVPLAY_REWIND      = 0x00000001, /* reverse playback          */
-     DVPLAY_LOOPING     = 0x00000002  /* automatically restart
+     DVPLAY_LOOPING     = 0x00000002, /* automatically restart
                                          playback when end-of-stream
                                          is reached (gapless).     */
+     DVPLAY_PACED       = 0x00000004, /* decoding pace is controlled
+                                         by the caller, the decoder
+                                         won't wait on its own while
+                                         decoding frames.          */
 } DFBVideoProviderPlaybackFlags;
 
 /*
+ * Playback context passed to IDirectFBVideoProvider::PlayTo()
+ * when decoding in DVPLAY_PACED mode.
+ */
+typedef struct {
+     unsigned int num_frame;
+     void        *ctx;
+} DFBVideoProviderPacedPlaybackCtx;
+
+/*
  * Flags to allow Audio Unit selection.
  */
 typedef enum {
@@ -5272,7 +5327,8 @@
      DIET_KEYRELEASE,              /* a key is been released */
      DIET_BUTTONPRESS,             /* a (mouse) button is been pressed */
      DIET_BUTTONRELEASE,           /* a (mouse) button is been released */
-     DIET_AXISMOTION               /* mouse/joystick movement */
+     DIET_AXISMOTION,              /* mouse/joystick movement */
+     DIET_SENSOR,                  /* sensor event */
 } DFBInputEventType;
 
 /*
@@ -5306,7 +5362,10 @@
      DIEF_FOLLOW         = 0x0800,   /* another event will follow immediately, e.g. x/y axis */
 
      DIEF_MIN            = 0x1000,   /* minimum value is set, e.g. for absolute axis motion */
-     DIEF_MAX            = 0x2000    /* maximum value is set, e.g. for absolute axis motion */
+     DIEF_MAX            = 0x2000,   /* maximum value is set, e.g. for absolute axis motion */
+
+     DIEF_SENSOR         = 0x4000,   /* sensor type and data are valid, contents
+                                        depend on sensor type */
 } DFBInputEventFlags;
 
 /*
@@ -5357,6 +5416,11 @@
      /* general information */
      int                             min;        /* minimum possible value */
      int                             max;        /* maximum possible value */
+
+/* DIET_SENSOR */
+     DFBInputDeviceSensorIdentifier  sensor;     /* in case of a sensor event */
+     float                           sensor_data[3]; /* sensor data, depending
+                                                        on DFBInputDeviceSensorIdentifier */
 } DFBInputEvent;
 
 /*
@@ -5612,6 +5676,7 @@
      unsigned int   DIET_BUTTONPRESS;
      unsigned int   DIET_BUTTONRELEASE;
      unsigned int   DIET_AXISMOTION;
+     unsigned int   DIET_SENSOR;
 
      unsigned int   DWET_POSITION;
      unsigned int   DWET_SIZE;
@@ -6774,6 +6839,14 @@
 )
 
 /*
+ * Flags for image providers.
+ */
+typedef enum {
+    DIPSYNCFLAGS_SYNC, /* sync, i.e. wait for the image provider to finish */
+    DIPSYNCFLAGS_TRYSYNC /* figure out if image provider is finished or still busy */
+} DFBImageProviderSyncFlags;
+
+/*
  * Capabilities of an image.
  */
 typedef enum {
@@ -6870,6 +6943,10 @@
       * Registers a callback for progressive image loading.
       *
       * The function is called each time a chunk of the image is decoded.
+      *
+      * In case of an image provider working in the background, the
+      * callback could be called in a different thread context! So you
+      * might have to take appropriate actions to handle this.
       */
      DFBResult (*SetRenderCallback) (
           IDirectFBImageProvider   *thiz,
@@ -6882,6 +6959,30 @@
       *
       * This is optional and might be unsupported by some image providers
       */
+     /*
+      * Set image provider flags.
+      *
+      * This allows one to switch an image provider's mode of
+      * operation, between default and background.
+      *
+      * In default (which is also the traditional) mode, a call to
+      * RenderTo() will block until the image provider has finished
+      * decoding the image. This is also the behaviour if this API
+      * is not used at all.
+      *
+      * In background mode, the image is being decoded in the background,
+      * i.e. the call to RenderTo() will return almost immediately. The
+      * application may do other useful processing while the image is being
+      * decoded. In most implementations, background decode will just use
+      * a worker thread.
+      *
+      * Not all image providers support background mode and will return
+      * DFB_UNSUPPORTED in that case.
+      *
+      * Calling SetFlags() after RenderTo() makes no sense and is
+      * unsupported.
+      *
+      */
      DFBResult (*SetRenderFlags) (
           IDirectFBImageProvider   *thiz,
           DIRenderFlags            flags
@@ -6898,6 +6999,25 @@
           const DFBRectangle       *src_rect,
           const char               *filename
      );
+
+
+   /** Rendering **/
+
+     /*
+      * For a background image provider, waits for it to finish
+      * decoding the image.
+      *
+      * For a default image provider, does nothing.
+      *
+      * This needs to be called for background image providers
+      * before accessing the destination surface (using either the
+      * software or the hardware), to make sure that the image has been
+      * completely decoded.
+      */
+     DFBResult (*Sync) (
+          IDirectFBImageProvider    *thiz,
+          DFBImageProviderSyncFlags  flags
+     );
 )
 
 /*
diff -Naur DirectFB-1.7.7/inputdrivers/linux_input/linux_input.c DirectFB-1.7.7.stm/inputdrivers/linux_input/linux_input.c
--- DirectFB-1.7.7/inputdrivers/linux_input/linux_input.c	2014-07-15 08:54:58.000000000 +0200
+++ DirectFB-1.7.7.stm/inputdrivers/linux_input/linux_input.c	2015-05-15 18:43:40.009327075 +0200
@@ -116,6 +116,7 @@
 #define DISABLE_INPUT_HOTPLUG_FUNCTION_STUB
 
 #include <fbdev/fbdev.h>
+#include <stmfbdev/stmfbdev.h>
 
 #include <core/input_driver.h>
 
@@ -1258,7 +1259,7 @@
      int   i;
      char *tsdev;
 
-     if (!(dfb_config->linux_input_force || (dfb_system_type() == CORE_FBDEV) || (dfb_system_type() == CORE_MESA) || (dfb_system_type() == CORE_DRMKMS)  ))
+     if (!(dfb_config->linux_input_force || (dfb_system_type() == CORE_FBDEV) || (dfb_system_type() == CORE_MESA) || (dfb_system_type() == CORE_DRMKMS) || (dfb_system_type() == CORE_STMFBDEV)  ))
           return 0;
 
      if (dfb_system_type() == CORE_FBDEV && !dfb_config->linux_input_force) {
@@ -1271,6 +1272,16 @@
           if (!dfb_fbdev->vt || dfb_fbdev->vt->fd < 0)
                return 0;
      }
+     else if (dfb_system_type() == CORE_STMFBDEV) {
+          const STMfbdev * const dfb_stm_fbdev = dfb_system_data();
+          D_ASSERT( dfb_stm_fbdev );
+
+          // Only allow USB keyboard and mouse support if the systems driver has
+          // the Virtual Terminal file ("/dev/tty0") open and available for use.
+          // FIXME:  Additional logic needed for system drivers not similar to fbdev?
+          if (!dfb_stm_fbdev->vt || dfb_stm_fbdev->vt->fd < 0)
+               return 0;
+     }
 
      /* Use the devices specified in the configuration. */
      if (fusion_vector_has_elements( &dfb_config->linux_input_devices )) {
@@ -1490,6 +1501,16 @@
                goto exit;
           }
      }
+     if (dfb_system_type() == CORE_STMFBDEV) {
+          const STMfbdev * const dfb_stm_fbdev = dfb_system_data();
+          D_ASSERT( dfb_stm_fbdev );
+
+          // Only allow USB keyboard and mouse support if the systems driver has
+          // the Virtual Terminal file ("/dev/tty0") open and available for use.
+          // FIXME:  Additional logic needed for system drivers not similar to fbdev?
+          if (!dfb_stm_fbdev->vt || dfb_stm_fbdev->vt->fd < 0)
+               goto exit;
+     }
 
      D_DEBUG_AT( Debug_LinuxInput, "  -> returning HOTPLUG\n" );
 
@@ -1863,6 +1884,11 @@
 
                if (dfb_fbdev->vt)
                     data->vt_fd = dup( dfb_fbdev->vt->fd );
+          } else if (dfb_system_type() == CORE_STMFBDEV) {
+               const STMfbdev * const dfb_stm_fbdev = dfb_system_data();
+
+               if (dfb_stm_fbdev->vt)
+                    data->vt_fd = dup( dfb_stm_fbdev->vt->fd );
           }
           if (data->vt_fd < 0)
                data->vt_fd = open( "/dev/tty0", O_RDWR | O_NOCTTY );
diff -Naur DirectFB-1.7.7/interfaces/IDirectFBImageProvider/debug_helper.h DirectFB-1.7.7.stm/interfaces/IDirectFBImageProvider/debug_helper.h
--- DirectFB-1.7.7/interfaces/IDirectFBImageProvider/debug_helper.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7.stm/interfaces/IDirectFBImageProvider/debug_helper.h	2015-05-15 18:43:40.017335075 +0200
@@ -0,0 +1,53 @@
+#ifndef __DEBUG_HELPER_H__
+#define __DEBUG_HELPER_H__
+
+
+/* Some colour for debug */
+#define BLACK   "\033[22;30m"
+#define RED     "\033[22;31m"
+#define GREEN   "\033[22;32m"
+#define BROWN   "\033[22;33m"
+
+
+
+/* These messages should be provided through DirectFB's error and warning */
+#define DEBUG_ERROR(x)          D_ERROR x
+#define DEBUG_WARNING(x)        D_WARN x
+
+
+#ifdef DEBUG
+/* *Very* Verbose */
+#  define DEBUG_INFO(x)           D_PRINTF x
+/* Outputs various Buffer and surface sizes */
+#  define DEBUG_SCALE(x)          D_PRINTF x
+/* Outputs Timing Information */
+#  define DEBUG_PERFORMANCE(x)    D_PRINTF x
+
+#else
+
+#  define DEBUG_INFO(x)   __debug_msg x
+#  define DEBUG_SCALE(x)  __debug_msg x
+static inline int __attribute__ ((format (printf, 1, 2)))
+__debug_msg (const char *format, ...)
+{
+  return 0;
+}
+
+#endif
+
+
+#ifdef DIRECT_BUILD_DEBUG
+
+#  define deb_gettimeofday(tv,tz)  gettimeofday(tv, tz)
+#  define deb_timersub(a,b,res)    timersub(a, b, res)
+
+#else
+
+#  define deb_gettimeofday(tv,tz)  ( { } )
+#  define deb_timersub(a,b,res)    ( { } )
+
+#endif
+
+
+
+#endif /* __DEBUG_HELPER_H__ */
diff -Naur DirectFB-1.7.7/interfaces/IDirectFBImageProvider/idirectfbimageprovider_hwjpeg_v4l2.c DirectFB-1.7.7.stm/interfaces/IDirectFBImageProvider/idirectfbimageprovider_hwjpeg_v4l2.c
--- DirectFB-1.7.7/interfaces/IDirectFBImageProvider/idirectfbimageprovider_hwjpeg_v4l2.c	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7.stm/interfaces/IDirectFBImageProvider/idirectfbimageprovider_hwjpeg_v4l2.c	2015-05-15 18:43:40.021339075 +0200
@@ -0,0 +1,753 @@
+/*
+   (c) Copyright 2012 STMicroelectronics R&D
+
+based on code:
+   (c) Copyright 2001-2010  The world wide DirectFB Open Source Community (directfb.org)
+   (c) Copyright 2000-2004  Convergence (integrated media) GmbH
+
+   All rights reserved.
+
+   Written by Ilyes Gouta <ilyes.gouta@st.com>
+   Based on code by:
+              Andre' Draszik <andre.draszik@st.com>,
+              Denis Oliver Kropp <dok@directfb.org>,
+              Andreas Hundt <andi@fischlustig.de>,
+              Sven Neumann <neo@directfb.org>,
+              Ville Syrjl <syrjala@sci.fi> and
+              Claudio Ciccani <klan@users.sf.net>.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <errno.h>
+#include <string.h>
+#include <stdarg.h>
+#include <sys/ioctl.h>
+
+#include <directfb.h>
+
+#include <display/idirectfbsurface.h>
+
+#include <media/idirectfbimageprovider.h>
+
+#include <core/layers.h>
+
+#include <core/CoreSurface.h>
+#include <core/palette.h>
+
+#include <direct/interface.h>
+#include <direct/mem.h>
+#include <direct/memcpy.h>
+#include <direct/thread.h>
+#include <direct/messages.h>
+
+#include <misc/gfx_util.h>
+#include <misc/util.h>
+
+#include <linux/videodev2.h>
+
+#include "idirectfbimageprovider_hwjpeg_v4l2.h"
+
+D_DEBUG_DOMAIN (HWJPEG_V4L2, "HWJPEG_V4L2", "STM h/w JPEG V4L2 decoder");
+
+static DFBResult
+Probe( IDirectFBImageProvider_ProbeContext *ctx );
+
+static DFBResult
+Construct( IDirectFBImageProvider *thiz,
+           ... );
+
+#include <direct/interface_implementation.h>
+
+DIRECT_INTERFACE_IMPLEMENTATION( IDirectFBImageProvider, hwJPEG )
+
+static DFBResult
+IDirectFBImageProvider_hwJPEG_RenderTo( IDirectFBImageProvider *thiz,
+                                        IDirectFBSurface       *destination,
+                                        const DFBRectangle     *destination_rect );
+
+static DFBResult
+IDirectFBImageProvider_hwJPEG_GetSurfaceDescription( IDirectFBImageProvider *thiz,
+                                                     DFBSurfaceDescription  *dsc );
+
+static DFBResult
+IDirectFBImageProvider_hwJPEG_GetImageDescription( IDirectFBImageProvider *thiz,
+                                                   DFBImageDescription    *dsc );
+
+static DFBResult
+IDirectFBImageProvider_hwJPEG_SetRenderFlags( IDirectFBImageProvider *thiz,
+                                              DIRenderFlags flags );
+
+static DFBResult
+JPEG_hwRenderTo( IDirectFBImageProvider_hwJPEG_data *data,
+                 CoreSurface                        *dst_surface,
+                 DFBRectangle                       *rect,
+                 const DFBRegion                    *clip );
+
+static void
+IDirectFBImageProvider_hwJPEG_Destruct( IDirectFBImageProvider *thiz )
+{
+    IDirectFBImageProvider_hwJPEG_data *data =
+            (IDirectFBImageProvider_hwJPEG_data*)thiz->priv;
+
+     if (data->decode_surface) {
+          dfb_gfxcard_wait_serial( &data->serial );
+          dfb_surface_unref( data->decode_surface );
+          data->decode_surface = NULL;
+     }
+}
+
+static DFBResult
+Probe( IDirectFBImageProvider_ProbeContext *ctx )
+{
+     /* Look of the Jpeg SOI marker */
+     if (ctx->header[0] == 0xff && ctx->header[1] == 0xd8) {
+          /* Look for JFIF or Exif strings, also could look at header[3:2] for APP0(0xFFE0),
+           * APP1(0xFFE1) or even other APPx markers.
+           */
+          if (strncmp ((char*) ctx->header + 6, "JFIF", 4) == 0 ||
+              strncmp ((char*) ctx->header + 6, "Exif", 4) == 0 ||
+              strncmp ((char*) ctx->header + 6, "VVL", 3) == 0 ||
+              strncmp ((char*) ctx->header + 6, "WANG", 4) == 0)
+               return DFB_OK;
+
+          /* Else look for Quantization table marker or Define Huffman table marker,
+           * useful for EXIF thumbnails that have no APPx markers.
+           */
+          if (ctx->header[2] == 0xff && (ctx->header[3] == 0xdb || ctx->header[3] == 0xc4))
+               return DFB_OK;
+
+          if (ctx->filename && strchr (ctx->filename, '.' ) &&
+             (strcasecmp ( strchr (ctx->filename, '.' ), ".jpg" ) == 0 ||
+              strcasecmp ( strchr (ctx->filename, '.' ), ".jpeg") == 0))
+               return DFB_OK;
+     }
+
+     return DFB_UNSUPPORTED;
+}
+
+static DFBResult
+Construct( IDirectFBImageProvider *thiz,
+           ... )
+{
+     IDirectFBDataBuffer *buffer;
+     CoreDFB             *core;
+     va_list              tag;
+     struct v4l2_fmtdesc  fmtdesc;
+
+     DFBRegion region = {
+          .x1 = 0,
+          .y1 = 0,
+          .x2 = 255,
+          .y2 = 255
+     };
+
+     DIRECT_ALLOCATE_INTERFACE_DATA( thiz, IDirectFBImageProvider_hwJPEG )
+
+     va_start( tag, thiz );
+     buffer = va_arg( tag, IDirectFBDataBuffer * );
+     core = va_arg( tag, CoreDFB * );
+     va_end( tag );
+
+     D_ASSERT( core != NULL );
+
+     data->fd = open( "/dev/video0", O_RDWR );
+
+     if (data->fd < 0) {
+         D_DEBUG_AT( HWJPEG_V4L2,
+                     "%s: couldn't open /dev/video0\n",
+                     __FUNCTION__ );
+         DIRECT_DEALLOCATE_INTERFACE( thiz );
+         return DFB_FAILURE;
+     }
+
+     memset( &fmtdesc, 0, sizeof(fmtdesc) );
+
+     fmtdesc.index = 0;
+     fmtdesc.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+
+     if (ioctl( data->fd, VIDIOC_ENUM_FMT, &fmtdesc ) < 0) {
+          D_DEBUG_AT( HWJPEG_V4L2,
+                      "%s: couldn't enumerate output formats on /dev/video0\n",
+                      __FUNCTION__ );
+          close( data->fd );
+          DIRECT_DEALLOCATE_INTERFACE( thiz );
+          return DFB_FAILURE;
+     }
+
+     close( data->fd );
+
+     if (fmtdesc.pixelformat != V4L2_PIX_FMT_JPEG) {
+          D_DEBUG_AT( HWJPEG_V4L2,
+                      "%s: /dev/video0 doesn't accept JPEG streams\n",
+                      __FUNCTION__ );
+          DIRECT_DEALLOCATE_INTERFACE( thiz );
+          return DFB_FAILURE;
+     }
+
+     data->base.ref    = 1;
+     data->base.buffer = buffer;
+     data->base.core   = core;
+
+     /* check if the h/w decoder can really decode the JPEG.
+        It will return the recommended destination buffer width, height
+        and pixel format on success. */
+     if (JPEG_hwRenderTo( data, NULL, NULL, &region ) != DFB_OK) {
+          D_DEBUG_AT( HWJPEG_V4L2,
+                      "%s: /dev/video0 can't decode the JPEG picture\n",
+                      __FUNCTION__ );
+          DIRECT_DEALLOCATE_INTERFACE( thiz );
+          return DFB_FAILURE;
+     }
+
+     buffer->AddRef( buffer );
+
+     data->base.Destruct = IDirectFBImageProvider_hwJPEG_Destruct;
+
+     thiz->RenderTo = IDirectFBImageProvider_hwJPEG_RenderTo;
+     thiz->Sync = NULL;
+     thiz->GetImageDescription =
+               IDirectFBImageProvider_hwJPEG_GetImageDescription;
+     thiz->SetRenderFlags = IDirectFBImageProvider_hwJPEG_SetRenderFlags;
+     thiz->GetSurfaceDescription =
+               IDirectFBImageProvider_hwJPEG_GetSurfaceDescription;
+
+     return DFB_OK;
+}
+
+static void
+JPEG_stretchblit( IDirectFBImageProvider_hwJPEG_data *data,
+                  CardState                          *state,
+                  DFBRectangle                       *src_rect,
+                  DFBRectangle                       *dst_rect )
+{
+     D_DEBUG_AT( HWJPEG_V4L2, "StretchBlit %dx%d -> %dx%d (%s -> %s)\n",
+                 src_rect->w, src_rect->h, dst_rect->w, dst_rect->h,
+                 dfb_pixelformat_name( state->source->config.format),
+                 dfb_pixelformat_name( state->destination->config.format ) );
+
+     /* thankfully this is intelligent enough to do a simple blit if
+        possible */
+     dfb_gfxcard_stretchblit( src_rect, dst_rect, state );
+     /* we need to remember the serial in case a new surface is created
+        (and written to) at the same address as the decode_surface before the
+        blit operation is finished. This can happen if we get into the
+        destructor before the blit operation is finished, which can happen on
+        fast CPUs. */
+     data->serial = state->serial;
+}
+
+DFBResult
+JPEG_hwRenderTo( IDirectFBImageProvider_hwJPEG_data *data,
+                 CoreSurface                        *dst_surface,
+                 DFBRectangle                       *rect,
+                 const DFBRegion                    *clip )
+{
+     DFBResult              ret = DFB_OK;
+     unsigned int           length;
+     unsigned int           ret_read;
+     int                    type;
+     int                    size = 0;
+
+     CoreSurfaceConfig      config;
+
+     IDirectFBDataBuffer   *buffer;
+
+     struct v4l2_requestbuffers reqbufs;
+
+     struct v4l2_format src_format;
+     struct v4l2_format dst_format;
+
+     struct v4l2_buffer srcbuf;
+     struct v4l2_buffer dstbuf;
+
+     CoreSurfaceBufferLock src_lock = { .pitch = 0 };
+     CoreSurfaceBufferLock dst_lock = { .pitch = 0 };
+
+     D_ASSERT( data != NULL );
+     D_ASSERT( clip != NULL );
+
+     D_ASSERT( data->base.core != NULL );
+
+     if (!data->base.core)
+          return DFB_FAILURE;
+
+     if (data->decode_surface) {
+           dfb_gfxcard_wait_serial( &data->serial );
+           dfb_surface_unref( data->decode_surface );
+           data->decode_surface = NULL;
+     }
+
+     D_ASSERT( data->source_surface == NULL );
+     D_ASSERT( data->decode_surface == NULL );
+
+     data->fd = open( "/dev/video0", O_RDWR );
+
+     if (data->fd < 0) {
+          D_DEBUG_AT( HWJPEG_V4L2,
+                      "%s: couldn't open /dev/video0\n",
+                      __FUNCTION__ );
+          return DFB_FAILURE;
+     }
+
+     data->source_surface = NULL;
+
+     data->width = -1;
+     data->height = -1;
+
+     buffer = data->base.buffer;
+
+     if (buffer->GetLength( buffer, &length )) {
+          D_ERROR( "%s: failed getting source length\n",
+                   __FUNCTION__ );
+          close( data->fd );
+          return DFB_UNSUPPORTED;
+     }
+
+     config.size.w = 4 * sysconf(_SC_PAGESIZE);
+     config.size.h = length / config.size.w + 1;
+
+     if ((ret = dfb_surface_create_simple( data->base.core,
+                                           config.size.w,
+                                           config.size.h,
+                                           DSPF_BYTE,
+                                           DSCS_BT601,
+                                           DSCAPS_VIDEOONLY,
+                                           CSTF_EXTERNAL,
+                                           0,
+                                           NULL,
+                                           &data->source_surface ))) {
+          D_ERROR( "%s: failed to create the source surface\n",
+                   __FUNCTION__ );
+
+          close( data->fd );
+          return ret;
+     }
+
+     D_DEBUG_AT( HWJPEG_V4L2, "allocated a %s surface (%dx%d) for JPEG data\n",
+                 dfb_pixelformat_name( data->source_surface->config.format ),
+                 config.size.w, config.size.h );
+
+     if ((ret = dfb_surface_lock_buffer( data->source_surface,
+                                         CSBR_BACK, CSAID_CPU,
+                                         CSAF_WRITE, &src_lock ))) {
+          D_ERROR( "%s: couldn't lock source buffer\n",
+                   __FUNCTION__ );
+
+          dfb_surface_unref( data->source_surface );
+          data->source_surface = NULL;
+
+          close( data->fd );
+          return ret;
+     }
+
+     buffer->SeekTo( buffer, 0 );
+
+     if ((ret = buffer->GetData( buffer, length, src_lock.addr, &ret_read ))) {
+          D_ERROR( "%s: couldn't upload source data to video memory\n",
+                   __FUNCTION__ );
+          goto fini;
+     }
+
+
+     memset( &reqbufs, 0, sizeof( reqbufs ) );
+
+     reqbufs.count = 1;
+     reqbufs.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+     reqbufs.memory = V4L2_MEMORY_USERPTR;
+
+     if (ioctl( data->fd, VIDIOC_REQBUFS, &reqbufs ) < 0) {
+          D_ERROR( "%s: couldn't request capture buffers\n",
+                   __FUNCTION__ );
+          ret = DFB_FAILURE;
+          goto fini;
+     }
+
+     reqbufs.count = 1;
+     reqbufs.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+     reqbufs.memory = V4L2_MEMORY_USERPTR;
+
+     if (ioctl( data->fd, VIDIOC_REQBUFS, &reqbufs ) < 0) {
+          D_ERROR( "%s: couldn't request output buffers\n",
+                   __FUNCTION__ );
+          ret = DFB_FAILURE;
+          goto fini;
+     }
+
+     type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+
+     if (ioctl( data->fd, VIDIOC_STREAMON, &type ) < 0) {
+          D_ERROR( "%s: couldn't toggle streaming on\n",
+                   __FUNCTION__ );
+          ret = DFB_FAILURE;
+          goto fini;
+     }
+
+     type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+     if (ioctl( data->fd, VIDIOC_STREAMON, &type ) < 0) {
+          D_ERROR( "%s: couldn't toggle streaming on\n",
+                   __FUNCTION__ );
+          ret = DFB_FAILURE;
+          goto fini;
+     }
+
+     memset( &src_format, 0, sizeof( src_format ) );
+
+     src_format.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+     src_format.fmt.pix.pixelformat = V4L2_PIX_FMT_JPEG;
+
+     if (ioctl( data->fd, VIDIOC_S_FMT, &src_format ) < 0) {
+          D_ERROR( "%s: couldn't set output format\n",
+                   __FUNCTION__ );
+          ret = DFB_FAILURE;
+          goto fini;
+     }
+
+     memset( &srcbuf, 0, sizeof( srcbuf ) );
+
+     srcbuf.index = 0;
+     srcbuf.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+     srcbuf.memory = V4L2_MEMORY_USERPTR;
+     srcbuf.m.userptr = (unsigned long)src_lock.addr;
+     srcbuf.length = length;
+
+     if (ioctl( data->fd, VIDIOC_QBUF, &srcbuf ) < 0) {
+          D_ERROR( "%s: couldn't queue source buffer\n",
+                   __FUNCTION__ );
+          ret = DFB_FAILURE;
+          goto fini;
+     }
+
+     memset( &src_format, 0, sizeof( src_format ) );
+
+     src_format.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+
+     if (ioctl( data->fd, VIDIOC_G_FMT, &src_format ) < 0) {
+          D_ERROR( "%s: couldn't get source format\n",
+                   __FUNCTION__ );
+          ret = DFB_FAILURE;
+          goto fini;
+     }
+
+     D_DEBUG_AT( HWJPEG_V4L2, "JPEG picture is a %dx%d w/ fourcc 0x%08x\n",
+                 src_format.fmt.pix.width, src_format.fmt.pix.height,
+                 src_format.fmt.pix.pixelformat );
+
+     src_format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+     src_format.fmt.pix.width = rect ? rect->w : src_format.fmt.pix.width;
+     src_format.fmt.pix.height = rect ? rect->h : src_format.fmt.pix.height;
+
+     dst_format = src_format;
+
+     if (ioctl( data->fd, VIDIOC_TRY_FMT, &dst_format ) < 0) {
+          D_ERROR( "%s: couldn't get suggested capture format\n",
+                   __FUNCTION__ );
+          ret = DFB_FAILURE;
+          goto fini;
+     }
+
+     if (dst_format.fmt.pix.pixelformat != V4L2_PIX_FMT_NV12
+         && dst_format.fmt.pix.pixelformat != V4L2_PIX_FMT_NV16
+         && dst_format.fmt.pix.pixelformat != V4L2_PIX_FMT_NV24) {
+          D_ERROR( "%s: capture format isn't a valid NV fourcc\n",
+                   __FUNCTION__ );
+          ret = DFB_FAILURE;
+          goto fini;
+     }
+
+     config.flags = CSCONF_SIZE | CSCONF_FORMAT;
+
+     switch (dst_format.fmt.pix.pixelformat) {
+     case V4L2_PIX_FMT_NV12:
+          config.format = DSPF_NV12;
+          break;
+     case V4L2_PIX_FMT_NV16:
+          config.format = DSPF_NV16;
+          break;
+     case V4L2_PIX_FMT_NV24:
+          config.format = DSPF_NV24;
+          break;
+     default:
+          D_DEBUG_AT( HWJPEG_V4L2, "invalid pixelformat!\n" );
+          ret = DFB_FAILURE;
+          goto fini;
+     }
+
+     D_DEBUG_AT( HWJPEG_V4L2, "h/w decoder suggested %dx%d %s buffer "
+                 "(%dx%d requested)\n",
+                 dst_format.fmt.pix.width,
+                 dst_format.fmt.pix.height,
+                 dfb_pixelformat_name( config.format ),
+                 src_format.fmt.pix.width,
+                 src_format.fmt.pix.height );
+
+     /* Construct() will provide a dst_surface == NULL so once we're here
+        the JPEG header has been parsed and the recommended width, height and
+        pixel format have been retrieved. */
+     if (!dst_surface) {
+          data->width = dst_format.fmt.pix.width;
+          data->height = dst_format.fmt.pix.height;
+          data->pixelformat = config.format;
+          ret = DFB_OK;
+          goto fini;
+     }
+
+     /* specify the pitch returned by VIDIOC_TRY_FMT as a width */
+     config.size.w = dst_format.fmt.pix.bytesperline;
+     config.size.h = dst_format.fmt.pix.height;
+
+     if ((ret = dfb_surface_create_simple( data->base.core,
+                                           config.size.w,
+                                           config.size.h,
+                                           config.format,
+                                           DSCS_BT601,
+                                           DSCAPS_VIDEOONLY,
+                                           CSTF_EXTERNAL,
+                                           0,
+                                           NULL,
+                                           &data->decode_surface ))) {
+          D_ERROR( "%s: failed to create the nv1x decode surface\n",
+                   __FUNCTION__ );
+          goto fini;
+     }
+
+     D_DEBUG_AT( HWJPEG_V4L2, "allocated a %s surface (%dx%d) for decode\n",
+                 dfb_pixelformat_name( data->decode_surface->config.format ),
+                 config.size.w, config.size.h );
+
+     dfb_surface_calc_buffer_size( data->decode_surface, 1, 1, NULL, &size );
+
+     src_format.fmt.pix.sizeimage = size;
+     src_format.fmt.pix.pixelformat = dst_format.fmt.pix.pixelformat;
+
+     /* VIDIOC_S_FMT takes the original requested dimensions */
+     if (ioctl( data->fd, VIDIOC_S_FMT, &src_format ) < 0) {
+          D_ERROR( "%s: couldn't set capture format\n",
+                   __FUNCTION__ );
+          ret = DFB_FAILURE;
+          goto fini;
+     }
+
+     if ((ret = dfb_surface_lock_buffer( data->decode_surface,
+                                         CSBR_BACK, CSAID_GPU,
+                                         CSAF_WRITE, &dst_lock ))) {
+          D_ERROR( "%s: couldn't lock source buffer\n",
+                   __FUNCTION__ );
+          goto fini;
+     }
+
+     D_DEBUG_AT( HWJPEG_V4L2, "locked h/w decode buffer @ 0x%08x, pitch: %d\n",
+                 (unsigned int)dst_lock.addr, dst_lock.pitch );
+
+     if (dst_lock.pitch != dst_format.fmt.pix.bytesperline) {
+          D_ERROR( "%s: unaligned decode surface pitch!\n",
+                   __FUNCTION__ );
+          ret = DFB_FAILURE;
+          goto fini;
+     }
+
+     memset( &dstbuf, 0, sizeof( dstbuf ) );
+
+     /* planar capture */
+     dstbuf.index = 0;
+     dstbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+     dstbuf.memory = V4L2_MEMORY_USERPTR;
+     dstbuf.m.userptr = (unsigned long)dst_lock.addr;
+     dstbuf.length = dst_format.fmt.pix.sizeimage;
+
+     if (ioctl( data->fd, VIDIOC_QBUF, &dstbuf ) < 0) {
+          D_ERROR( "%s: couldn't queue capture buffer\n",
+                   __FUNCTION__ );
+          ret = DFB_FAILURE;
+          goto fini;
+     }
+
+     if (ioctl( data->fd, VIDIOC_DQBUF, &dstbuf ) < 0) {
+          D_ERROR( "%s: couldn't dequeue capture buffer\n",
+                   __FUNCTION__ );
+          ret = DFB_FAILURE;
+          goto fini;
+     }
+
+     memset( &dst_format, 0, sizeof( dst_format ) );
+
+     dst_format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+     if (ioctl( data->fd, VIDIOC_G_FMT, &dst_format ) < 0) {
+          D_ERROR( "%s: couldn't get capture final format\n",
+                   __FUNCTION__ );
+          ret = DFB_FAILURE;
+          goto fini;
+     }
+
+     D_DEBUG_AT( HWJPEG_V4L2, "decoded picture is a %dx%d %s buffer "
+                 "(pitch: %d)\n", dst_format.fmt.pix.width,
+                 dst_format.fmt.pix.height,
+                 (dst_format.fmt.pix.pixelformat == V4L2_PIX_FMT_NV12) ? "NV12"
+                 : ((dst_format.fmt.pix.pixelformat == V4L2_PIX_FMT_NV16)
+                    ? "NV16" : "NV24"),
+                 dst_format.fmt.pix.bytesperline );
+
+fini:
+     if (data->decode_surface && dst_lock.pitch)
+          dfb_surface_unlock_buffer( data->decode_surface, &dst_lock );
+
+     type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+
+     if (ioctl( data->fd, VIDIOC_STREAMOFF, &type ) < 0)
+          D_ERROR( "%s: couldn't turn streaming off\n",
+                   __FUNCTION__ );
+
+     type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+     if (ioctl( data->fd, VIDIOC_STREAMOFF, &type ) < 0)
+          D_ERROR( "%s: couldn't turn streaming off\n",
+                   __FUNCTION__ );
+
+     if (data->source_surface) {
+          if (src_lock.pitch)
+               dfb_surface_unlock_buffer( data->source_surface, &src_lock );
+
+          dfb_surface_unref( data->source_surface );
+          data->source_surface = NULL;
+     }
+
+     close( data->fd );
+
+     /* don't blit to destination if something went wrong */
+     if (data->decode_surface && ret == DFB_OK) {
+          CardState    state;
+          DFBRectangle src_rect = {
+               .x = 0,
+               .y = 0,
+               .w = dst_format.fmt.pix.width,
+               .h = dst_format.fmt.pix.height
+          };
+
+          /* use DFB to convert the intermediary NV format to the
+             final destination format, applying any necessary additional
+             clip/stretch */
+          dfb_state_init( &state, data->base.core );
+          dfb_state_set_source( &state, data->decode_surface );
+          dfb_state_set_destination( &state, dst_surface );
+          dfb_state_set_clip( &state, clip );
+
+          JPEG_stretchblit( data, &state, &src_rect, rect );
+
+          /* remove the state */
+          dfb_state_set_source( &state, NULL );
+          dfb_state_set_destination( &state, NULL );
+          dfb_state_destroy( &state );
+
+          if (data->base.render_callback) {
+               DFBRectangle r = { 0, 0,
+                                  dst_format.fmt.pix.width,
+                                  dst_format.fmt.pix.height };
+               data->base.render_callback( &r,
+                                           data->base.render_callback_context );
+          }
+     }
+
+     return ret;
+}
+
+static DFBResult
+IDirectFBImageProvider_hwJPEG_RenderTo( IDirectFBImageProvider *thiz,
+                                        IDirectFBSurface       *destination,
+                                        const DFBRectangle     *dest_rect )
+{
+     IDirectFBSurface_data *dst_data;
+     CoreSurface           *dst_surface;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBImageProvider_hwJPEG)
+
+     dst_data = (IDirectFBSurface_data*) destination->priv;
+     if (!dst_data)
+          return DFB_DEAD;
+
+     dst_surface = dst_data->surface;
+     if (!dst_surface)
+          return DFB_DESTROYED;
+
+     dfb_region_from_rectangle( &data->clip, &dst_data->area.current );
+
+     if (dest_rect) {
+          if (dest_rect->w < 1 || dest_rect->h < 1)
+               return DFB_INVARG;
+
+          data->rect = *dest_rect;
+          data->rect.x += dst_data->area.wanted.x;
+          data->rect.y += dst_data->area.wanted.y;
+
+          if (!dfb_rectangle_region_intersects( &data->rect, &data->clip ))
+               return DFB_OK;
+     }
+     else {
+          data->rect = dst_data->area.wanted;
+     }
+
+     return JPEG_hwRenderTo( data, dst_surface, &data->rect, &data->clip );
+}
+
+static DFBResult
+IDirectFBImageProvider_hwJPEG_GetSurfaceDescription( IDirectFBImageProvider *thiz,
+                                                     DFBSurfaceDescription  *dsc )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBImageProvider_hwJPEG)
+
+     if (!dsc)
+          return DFB_INVARG;
+
+     if (data->width < 0
+         || data->height < 0)
+          return DFB_INVARG;
+
+     dsc->flags  = DSDESC_WIDTH | DSDESC_HEIGHT | DSDESC_PIXELFORMAT;
+     dsc->width  = data->width;
+     dsc->height = data->height;
+     dsc->pixelformat = data->pixelformat;
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBImageProvider_hwJPEG_SetRenderFlags( IDirectFBImageProvider *thiz,
+                                              DIRenderFlags flags )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBImageProvider_hwJPEG)
+
+     return DFB_UNSUPPORTED;
+}
+
+static DFBResult
+IDirectFBImageProvider_hwJPEG_GetImageDescription( IDirectFBImageProvider *thiz,
+                                                   DFBImageDescription    *dsc )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBImageProvider_hwJPEG)
+
+     if (!dsc)
+          return DFB_INVARG;
+
+     dsc->caps = DICAPS_NONE;
+
+     return DFB_OK;
+}
diff -Naur DirectFB-1.7.7/interfaces/IDirectFBImageProvider/idirectfbimageprovider_hwjpeg_v4l2.h DirectFB-1.7.7.stm/interfaces/IDirectFBImageProvider/idirectfbimageprovider_hwjpeg_v4l2.h
--- DirectFB-1.7.7/interfaces/IDirectFBImageProvider/idirectfbimageprovider_hwjpeg_v4l2.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7.stm/interfaces/IDirectFBImageProvider/idirectfbimageprovider_hwjpeg_v4l2.h	2015-05-15 18:43:40.025343075 +0200
@@ -0,0 +1,59 @@
+/*
+   (c) Copyright 2012 STMicroelectronics R&D
+
+based on code:
+   (c) Copyright 2001-2010  The world wide DirectFB Open Source Community (directfb.org)
+   (c) Copyright 2000-2004  Convergence (integrated media) GmbH
+
+   All rights reserved.
+
+   Written by Ilyes Gouta <ilyes.gouta@st.com>
+   Based on code by:
+              Andre' Draszik <andre.draszik@st.com>,
+              Denis Oliver Kropp <dok@directfb.org>,
+              Andreas Hundt <andi@fischlustig.de>,
+              Sven Neumann <neo@directfb.org>,
+              Ville Syrjl <syrjala@sci.fi> and
+              Claudio Ciccani <klan@users.sf.net>.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#ifndef __IDIRECTFBIMAGEPROVIDER_HWJPEG_H__
+#define __IDIRECTFBIMAGEPROVIDER_HWJPEG_H__
+
+/* private data struct of IDirectFBImageProvider_hwJPEG */
+typedef struct
+{
+     IDirectFBImageProvider_data base;
+
+     int                         fd;
+
+     unsigned int                width;
+     unsigned int                height;
+
+     DFBSurfacePixelFormat       pixelformat;
+
+     CoreSurface                *source_surface;
+     CoreSurface                *decode_surface;
+
+     CoreGraphicsSerial          serial;
+
+     DFBRectangle                rect;
+     DFBRegion                   clip;
+} IDirectFBImageProvider_hwJPEG_data;
+
+#endif /* __IDIRECTFBIMAGEPROVIDER_HWJPEG_H__ */
diff -Naur DirectFB-1.7.7/interfaces/IDirectFBImageProvider/idirectfbimageprovider_jpeg.c DirectFB-1.7.7.stm/interfaces/IDirectFBImageProvider/idirectfbimageprovider_jpeg.c
--- DirectFB-1.7.7/interfaces/IDirectFBImageProvider/idirectfbimageprovider_jpeg.c	2014-07-15 11:26:03.000000000 +0200
+++ DirectFB-1.7.7.stm/interfaces/IDirectFBImageProvider/idirectfbimageprovider_jpeg.c	2015-05-15 18:43:40.065383075 +0200
@@ -1,6 +1,8 @@
 /*
    (c) Copyright 2012-2013  DirectFB integrated media GmbH
    (c) Copyright 2001-2013  The world wide DirectFB Open Source Community (directfb.org)
+   (c) Copyright 2006-2010  ST Microelectronics R&D
+
    (c) Copyright 2000-2004  Convergence (integrated media) GmbH
 
    All rights reserved.
@@ -48,12 +50,14 @@
 #include <core/layers.h>
 
 #include <core/CoreSurface.h>
+#include <core/palette.h>
 
 #include <misc/gfx_util.h>
 #include <misc/util.h>
 #include <direct/interface.h>
 #include <direct/mem.h>
 #include <direct/memcpy.h>
+#include <direct/thread.h>
 #include <direct/messages.h>
 
 #include <setjmp.h>
@@ -62,6 +66,36 @@
 #undef HAVE_STDLIB_H
 #include <jpeglib.h>
 
+#if !defined(JPEG_PROVIDER_USE_MME)
+#undef USE_MME
+#endif
+
+
+#include "debug_helper.h"
+
+D_DEBUG_DOMAIN (JPEG,      "JPEG",      "STM JPEG decoder");
+D_DEBUG_DOMAIN (JPEG_RAW,  "JPEG/raw",  "STM JPEG decoder (raw decode)");
+D_DEBUG_DOMAIN (JPEG_MME,  "JPEG/MME",  "STM JPEG decoder (MME)");
+D_DEBUG_DOMAIN (JPEG_SEMA, "JPEG/SEMA", "STM JPEG decoder (semaphores");
+D_DEBUG_DOMAIN (JPEG_TIME, "JPEG/Time", "STM JPEG decoder (timing");
+#define MME_DEBUG_DOMAIN  JPEG_MME
+#define SEMA_DEBUG_DOMAIN JPEG_SEMA
+#define MME_TEXT_DOMAIN "JPEG"
+
+#include "mme_helper.h"
+#include "idirectfbimageprovider_jpeg.h"
+#if defined(JPEG_PROVIDER_USE_MME)
+#include "sema_helper.h"
+static DFBResult JPEG_HardwareRenderTo( IDirectFBImageProvider_JPEG_data *data,
+                                        CoreSurface                      *dst_surface,
+                                        DFBSurfacePixelFormat             format,
+                                        DFBRectangle                     *rect,
+                                        const DFBRegion                  *clip );
+#else /* JPEG_PROVIDER_USE_MME */
+#define JPEG_HardwareRenderTo(data,dst_surface, \
+                              format,rect,clip) DFB_NOSUCHINSTANCE
+#endif /* JPEG_PROVIDER_USE_MME */
+
 
 static DFBResult
 Probe( IDirectFBImageProvider_ProbeContext *ctx );
@@ -72,23 +106,11 @@
 
 #include <direct/interface_implementation.h>
 
-DIRECT_INTERFACE_IMPLEMENTATION( IDirectFBImageProvider, JPEG )
-
-/*
- * private data struct of IDirectFBImageProvider_JPEG
- */
-typedef struct {
-     IDirectFBImageProvider_data base;
-
-     int                  width;    /*  width of the JPEG image   */
-     int                  height;   /*  height of the JPEG image  */
-
-     u32                 *image;        /*  decoded image data    */
-     int                  image_width;  /*  width of image data   */
-     int                  image_height; /*  height of image data  */
-
-     DIRenderFlags        flags;        /*  selected idct method  */
-} IDirectFBImageProvider_JPEG_data;
+#if defined(JPEG_PROVIDER_USE_MME)
+DIRECT_INTERFACE_IMPLEMENTATION( IDirectFBImageProvider, hwJPEG )
+#else /* JPEG_PROVIDER_USE_MME */
+DIRECT_INTERFACE_IMPLEMENTATION( IDirectFBImageProvider, swJPEG )
+#endif /* JPEG_PROVIDER_USE_MME */
 
 
 static DFBResult
@@ -97,6 +119,10 @@
                                       const DFBRectangle     *destination_rect );
 
 static DFBResult
+IDirectFBImageProvider_JPEG_Sync( IDirectFBImageProvider    *thiz,
+                                  DFBImageProviderSyncFlags  flags );
+
+static DFBResult
 IDirectFBImageProvider_JPEG_GetSurfaceDescription( IDirectFBImageProvider *thiz,
                                                    DFBSurfaceDescription  *dsc );
 
@@ -108,6 +134,10 @@
 IDirectFBImageProvider_JPEG_SetRenderFlags( IDirectFBImageProvider *thiz,
                                             DIRenderFlags flags );
 
+static void *
+JPEGrenderThread( DirectThread *thread, void *driver_data );
+
+
 #define JPEG_PROG_BUF_SIZE    0x10000
 
 typedef struct {
@@ -228,74 +258,6 @@
      longjmp(myerr->setjmp_buffer, 1);
 }
 
-static inline void
-copy_line32( u32 *argb, const u8 *rgb, int width )
-{
-     while (width--) {
-          *argb++ = 0xFF000000 | (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
-
-          rgb += 3;
-     }
-}
-
-static inline void
-copy_line_nv16( u16 *yy, u16 *cbcr, const u8 *src_ycbcr, int width )
-{
-     int x;
-
-     for (x=0; x<width/2; x++) {
-#ifdef WORDS_BIGENDIAN
-          yy[x] = (src_ycbcr[0] << 8) | src_ycbcr[3];
-
-          cbcr[x] = (((src_ycbcr[1] + src_ycbcr[4]) << 7) & 0xff00) |
-                     ((src_ycbcr[2] + src_ycbcr[5]) >> 1);
-#else
-          yy[x] = (src_ycbcr[3] << 8) | src_ycbcr[0];
-
-          cbcr[x] = (((src_ycbcr[2] + src_ycbcr[5]) << 7) & 0xff00) |
-                     ((src_ycbcr[1] + src_ycbcr[4]) >> 1);
-#endif
-
-          src_ycbcr += 6;
-     }
-
-     if (width & 1) {
-          u8 *y = (u8*) yy;
-
-          y[width-1] = src_ycbcr[0];
-
-#ifdef WORDS_BIGENDIAN
-          cbcr[x] = (src_ycbcr[1] << 8) | src_ycbcr[2];
-#else
-          cbcr[x] = (src_ycbcr[2] << 8) | src_ycbcr[1];
-#endif
-     }
-}
-
-static inline void
-copy_line_uyvy( u32 *uyvy, const u8 *src_ycbcr, int width )
-{
-     int x;
-
-     for (x=0; x<width/2; x++) {
-#ifdef WORDS_BIGENDIAN
-          uyvy[x] = (src_ycbcr[1] << 24) | (src_ycbcr[0] << 16) | (src_ycbcr[5] << 8) | src_ycbcr[3];
-#else
-          uyvy[x] = (src_ycbcr[3] << 24) | (src_ycbcr[5] << 16) | (src_ycbcr[0] << 8) | src_ycbcr[1];
-#endif
-
-          src_ycbcr += 6;
-     }
-
-     if (width & 1) {
-#ifdef WORDS_BIGENDIAN
-          uyvy[x] = (src_ycbcr[1] << 24) | (src_ycbcr[0] << 16) | (src_ycbcr[1] << 8) | src_ycbcr[0];
-#else
-          uyvy[x] = (src_ycbcr[0] << 24) | (src_ycbcr[1] << 16) | (src_ycbcr[0] << 8) | src_ycbcr[1];
-#endif
-     }
-}
-
 
 static void
 IDirectFBImageProvider_JPEG_Destruct( IDirectFBImageProvider *thiz )
@@ -303,8 +265,20 @@
      IDirectFBImageProvider_JPEG_data *data =
                               (IDirectFBImageProvider_JPEG_data*)thiz->priv;
 
-     if (data->image)
-          D_FREE( data->image );
+     if (data->thread) {
+          /* terminate the decoding thread, if necessary... */
+          direct_thread_cancel( data->thread );
+          direct_thread_join( data->thread );
+          direct_thread_destroy( data->thread );
+
+          pthread_mutex_destroy( &data->lock );
+          pthread_cond_destroy( &data->cond );
+     }
+
+     if (data->common.decode_surface) {
+          dfb_gfxcard_wait_serial( &data->common.serial );
+          dfb_surface_unref( data->common.decode_surface );
+     }
 }
 
 static DFBResult
@@ -354,9 +328,9 @@
      core = va_arg( tag, CoreDFB * );
      va_end( tag );
 
-     data->base.ref    = 1;
-     data->base.buffer = buffer;
-     data->base.core   = core;
+     data->common.base.ref    = 1;
+     data->common.base.buffer = buffer;
+     data->common.base.core   = core;
 
      buffer->AddRef( buffer );
 
@@ -377,8 +351,13 @@
      jpeg_read_header(&cinfo, TRUE);
      jpeg_start_decompress(&cinfo);
 
-     data->width = cinfo.output_width;
-     data->height = cinfo.output_height;
+     data->common.width = cinfo.output_width;
+     data->common.height = cinfo.output_height;
+
+#if defined(JPEG_PROVIDER_USE_MME)
+     data->num_components = cinfo.num_components;
+     data->progressive_mode = cinfo.progressive_mode;
+#endif
 
      data->flags = DIRENDER_NONE;
 
@@ -391,9 +370,10 @@
           return DFB_FAILURE;
      }
 
-     data->base.Destruct = IDirectFBImageProvider_JPEG_Destruct;
+     data->common.base.Destruct = IDirectFBImageProvider_JPEG_Destruct;
 
      thiz->RenderTo = IDirectFBImageProvider_JPEG_RenderTo;
+     thiz->Sync = IDirectFBImageProvider_JPEG_Sync;
      thiz->GetImageDescription =IDirectFBImageProvider_JPEG_GetImageDescription;
      thiz->SetRenderFlags = IDirectFBImageProvider_JPEG_SetRenderFlags;
      thiz->GetSurfaceDescription =
@@ -402,73 +382,597 @@
      return DFB_OK;
 }
 
+static void
+JPEG_stretchblit( IDirectFBImageProvider_JPEG_data *data,
+                  CardState                        *state,
+                  DFBRectangle                     *src_rect,
+                  DFBRectangle                     *dst_rect )
+{
+     D_DEBUG_AT( JPEG, "StretchBlit %dx%d -> %dx%d (%s -> %s)\n",
+                 src_rect->w, src_rect->h, dst_rect->w, dst_rect->h,
+                 dfb_pixelformat_name( state->source->config.format),
+                 dfb_pixelformat_name( state->destination->config.format ) );
+
+     /* thankfully this is intelligent enough to do a simple blit if
+        possible */
+     dfb_gfxcard_stretchblit( src_rect, dst_rect, state );
+     /* we need to remember the serial in case a new surface is created
+        (and written to) at the same address as the decode_surface before the
+        blit operation is finished. This can happen if we get into the
+        destructor before the blit operation is finished, which can happen on
+        fast CPUs. */
+     data->common.serial = state->serial;
+}
+
+#define _ROUND_UP_8(x)  (((x)+ 7) & ~ 7)
+#define _ROUND_UP_16(x) (((x)+15) & ~15)
+static void
+JPEG_setup_yuv444p( const struct jpeg_decompress_struct *cinfo,
+                    CoreSurfaceConfig                   *config,
+                    int                                 *pitch_y,
+                    int                                 *pitch_cb,
+                    int                                 *pitch_cr,
+                    int                                 *offset_cb,
+                    int                                 *offset_cr )
+{
+     config->format = DSPF_YUV444P;
+
+     config->size.w = _ROUND_UP_8( cinfo->cur_comp_info[0]
+                                                        ->downsampled_width );
+     config->size.h = _ROUND_UP_8( cinfo->cur_comp_info[0]
+                                                       ->downsampled_height );
+
+     /* pad an extra (decimated) MCU row for the iDCT write-out */
+#if JPEG_LIB_VERSION >= 70
+     config->size.h += cinfo->max_v_samp_factor *
+                       cinfo->min_DCT_v_scaled_size;
+#else
+     config->size.h += cinfo->max_v_samp_factor *
+                       cinfo->min_DCT_scaled_size;
+#endif
+
+     *pitch_y  = config->size.w;
+     if (cinfo->num_components == 3) {
+          *pitch_cb = _ROUND_UP_8( cinfo->cur_comp_info[1]->downsampled_width );
+          *pitch_cr = _ROUND_UP_8( cinfo->cur_comp_info[2]->downsampled_width );
+     }
+
+     *offset_cb
+          = *offset_cr
+          = *pitch_y * config->size.h;
+}
+
 static DFBResult
-IDirectFBImageProvider_JPEG_RenderTo( IDirectFBImageProvider *thiz,
-                                      IDirectFBSurface       *destination,
-                                      const DFBRectangle     *dest_rect )
+JPEG_raw_decode_common( IDirectFBImageProvider_JPEG_data *data,
+                        CoreSurface                      *dst_surface,
+                        DFBRectangle                     *rect,
+                        struct jpeg_decompress_struct    *cinfo,
+                        CardState                        *state,
+                        CoreSurfaceBufferLock            *lock,
+                        CoreSurfaceConfig                *config,
+                        CorePalette                      *palette,
+                        int                               pitch_y,
+                        int                               pitch_cb,
+                        int                               pitch_cr,
+                        int                               offset_cb,
+                        int                               offset_cr,
+                        int                               y_v_sampl,
+                        int                               cb_v_sampl,
+                        int                               cr_v_sampl)
 {
-     DFBResult              ret;
-     bool                   direct = false;
-     DFBRegion              clip;
-     DFBRectangle           rect;
-     DFBSurfacePixelFormat  format;
-     IDirectFBSurface_data *dst_data;
-     CoreSurface           *dst_surface;
-     CoreSurfaceBufferLock  lock;
+     DFBResult res;
      DIRenderCallbackResult cb_result = DIRCR_OK;
+     DFBRectangle src_rect;
 
-     DIRECT_INTERFACE_GET_DATA(IDirectFBImageProvider_JPEG)
+     int i;
 
-     dst_data = (IDirectFBSurface_data*) destination->priv;
-     if (!dst_data)
-          return DFB_DEAD;
+     /* Worst case, is 4x4 chroma subsampling where an MCU is 32 lines. libjpeg
+        won't decode more than one MCU in any one go. */
+#if JPEG_LIB_VERSION >= 70
+     const int idct_window_size = (cinfo->max_v_samp_factor
+                                   * cinfo->min_DCT_v_scaled_size);
+#else
+     const int idct_window_size = (cinfo->max_v_samp_factor
+                                   * cinfo->min_DCT_scaled_size);
+#endif
 
-     dst_surface = dst_data->surface;
-     if (!dst_surface)
-          return DFB_DESTROYED;
+#undef _NO_STACK
+#ifndef _NO_STACK
+     JSAMPROW Yrows[idct_window_size];
+     JSAMPROW Cbrows[idct_window_size];
+     JSAMPROW Crrows[idct_window_size];
+     JSAMPARRAY jpeg_buffer[3] = {
+          [0] = Yrows
+     };
+#else
+     /* valgrind can't check stack variables */
+#warning this is not for production use, as we do not clean up on errors
+     JSAMPROW *Yrows, *Cbrows, *Crrows;
+     JSAMPARRAY *jpeg_buffer;
+
+     /* over allocate, least trouble */
+     Yrows = malloc( sizeof(JSAMPROW) * idct_window_size) ;
+     Cbrows = malloc( sizeof(JSAMPROW) * idct_window_size );
+     Crrows = malloc( sizeof(JSAMPROW) * idct_window_size );
 
-     ret = destination->GetPixelFormat( destination, &format );
-     if (ret)
-          return ret;
+     jpeg_buffer = malloc( 3 * sizeof(JSAMPARRAY) );
+     jpeg_buffer[0] = Yrows;
+#endif
 
-     dfb_region_from_rectangle( &clip, &dst_data->area.current );
 
-     if (dest_rect) {
-          if (dest_rect->w < 1 || dest_rect->h < 1)
-               return DFB_INVARG;
+     if (cb_v_sampl) {
+          jpeg_buffer[1] = Cbrows;
+          jpeg_buffer[2] = Crrows;
+     }
 
-          rect = *dest_rect;
-          rect.x += dst_data->area.wanted.x;
-          rect.y += dst_data->area.wanted.y;
+     config->flags = CSCONF_SIZE | CSCONF_FORMAT | CSCONF_COLORSPACE | CSCONF_CAPS;
+     #ifdef __SH4__
+     config->caps = DSCAPS_VIDEOONLY;
+     #else
+     config->caps = 0;
+     #endif
+     #ifdef DIRECT_BUILD_DEBUG
+     config->caps |= DSCAPS_SHARED;
+     #endif
+
+     res = dfb_surface_create( data->common.base.core, config, CSTF_NONE, 0,
+                               palette,
+                               &data->common.decode_surface );
+     if (palette)
+          /* decode_surface holds a reference to the palette now */
+          dfb_palette_unref( palette );
+
+     if (res != DFB_OK) {
+          D_ERROR( "failed to create temporary decode surface\n" );
+          return DFB_UNSUPPORTED;
+     }
 
-          if (!dfb_rectangle_region_intersects( &rect, &clip ))
-               return DFB_OK;
+     if (dfb_surface_lock_buffer( data->common.decode_surface,
+                                  CSBR_BACK, CSAID_CPU, CSAF_WRITE, lock )) {
+          dfb_surface_unref( data->common.decode_surface );
+          data->common.decode_surface = NULL;
+          return DFB_UNSUPPORTED;
+     }
+
+     cinfo->raw_data_out = true;
+     jpeg_start_decompress( cinfo );
+
+     dfb_state_set_source( state, data->common.decode_surface );
+
+     /* Initialize the various pointers to build a planar YUV buffer. */
+     for (i = 0; i < idct_window_size; ++i)
+          Yrows[i] = lock->addr + i * pitch_y;
+     if (cb_v_sampl) {
+          void *cbaddr = lock->addr + offset_cb;
+          void *craddr = cbaddr + offset_cr;
+          for (i = 0; i < idct_window_size; ++i) {
+               Cbrows[i] = cbaddr + i * pitch_cb;
+               Crrows[i] = craddr + i * pitch_cr;
+          }
+     }
+
+     while (cinfo->output_scanline < data->common.decoded_height
+            && cb_result == DIRCR_OK) {
+          int x = jpeg_read_raw_data( cinfo, jpeg_buffer,
+                                      idct_window_size );
+          if (x <= 0)
+               /* Actually, x == 0 means that we don't have enough data to
+                  continue decoding the picture. */
+               break;
+
+          D_DEBUG_AT( JPEG_RAW,
+                      "  -> decoded %d scanlines (out of %d (%d))\n",
+                      cinfo->output_scanline, data->common.decoded_height,
+                      config->size.h );
+
+          /* increment the pointers by the number of decoded (luma)
+             scanlines. */
+          for (i = 0; i < idct_window_size; ++i)
+               Yrows[i] += (x * pitch_y) / y_v_sampl;
+          if (cb_v_sampl) {
+               for (i = 0; i < idct_window_size; ++i) {
+                    Cbrows[i] += (x * pitch_cb) / cb_v_sampl;
+                    Crrows[i] += (x * pitch_cr) / cr_v_sampl;
+               }
+          }
+
+          if (data->common.base.render_callback) {
+               DFBRectangle r;
+               DFBRectangle dst_rect;
+               float factor;
+
+               src_rect = (DFBRectangle) {
+                    .x = 0,
+                    .y = cinfo->output_scanline - x,
+                    .w = data->common.decoded_width,
+                    .h = x,
+               };
+               r = src_rect;
+               factor = (rect->h / (float) data->common.decoded_height);
+               dst_rect = (DFBRectangle) {
+                    .x = rect->x,
+                    .y = (int) (src_rect.y * factor),
+                    .w = rect->w,
+                    .h = (int) (src_rect.h * factor),
+               };
+
+               D_DEBUG_AT( JPEG_RAW,
+                           "  -> render callback %d,%d %dx%d -> %d,%d %dx%d\n",
+                           src_rect.x, src_rect.y, src_rect.w,
+                           src_rect.h, dst_rect.x, dst_rect.y,
+                           dst_rect.w, dst_rect.h );
+
+               JPEG_stretchblit( data, state, &src_rect, &dst_rect );
+
+               cb_result = data->common.base.render_callback( &r,
+                                                              data->common.base.render_callback_context );
+          }
+     }
+
+     D_DEBUG_AT( JPEG_RAW, "  -> decoded %d scanlines (out of %d)\n",
+                 cinfo->output_scanline, data->common.decoded_height );
+
+     if (cinfo->output_scanline < data->common.decoded_height
+         || cb_result != DIRCR_OK) {
+          if (cb_result != DIRCR_OK)
+               D_ERROR( "raw decode failed after %d of %d scanlines, "
+                        "trying pure software\n",
+                        cinfo->output_scanline, cinfo->output_height );
+          jpeg_abort_decompress( cinfo );
+          jpeg_destroy_decompress( cinfo );
+          dfb_surface_unlock_buffer( data->common.decode_surface, lock );
+          lock->pitch = 0;
+          dfb_surface_unref( data->common.decode_surface );
+          data->common.decode_surface = NULL;
+
+          if (cb_result != DIRCR_OK)
+               return DFB_INTERRUPTED;
+
+          return DFB_FAILURE; /* restart */
+     }
+
+     jpeg_finish_decompress( cinfo );
+     jpeg_destroy_decompress( cinfo );
+
+     dfb_surface_unlock_buffer( data->common.decode_surface, lock );
+     lock->pitch = 0;
+
+     /* use DFB to convert raw YCbCr to destination format, and apply any
+        necessary additional clip/stretch */
+     src_rect = (DFBRectangle) {
+          .x = 0,
+          .y = 0,
+          .w = data->common.decoded_width,
+          .h = data->common.decoded_height
+     };
+
+     JPEG_stretchblit( data, state, &src_rect, rect );
+
+     if (data->common.base.render_callback)
+          data->common.base.render_callback( &src_rect,
+                                             data->common.base.render_callback_context );
+
+#ifdef _NO_STACK
+     free( Yrows );
+     if (cb_v_sampl) {
+          free( Cbrows );
+          free( Crrows );
+     }
+     free( jpeg_buffer );
+#endif
+
+     return DFB_OK;
+}
+
+static DFBResult
+JPEG_raw_decode_YCbCr( IDirectFBImageProvider_JPEG_data *data,
+                       CoreSurface                      *dst_surface,
+                       DFBRectangle                     *rect,
+                       struct jpeg_decompress_struct    *cinfo,
+                       CardState                        *state,
+                       CoreSurfaceBufferLock            *lock )
+{
+     CoreSurfaceConfig config;
+     int pitch_y, pitch_cb, pitch_cr;
+     int offset_cb; /* cb from y */
+     int offset_cr; /* cr from cb */
+     int y_v_sampl = 1;
+     int cb_v_sampl = 1;
+     int cr_v_sampl = 1;
+
+     const int v_samp[3] = { cinfo->cur_comp_info[0]->v_samp_factor,
+                             cinfo->cur_comp_info[1]->v_samp_factor,
+                             cinfo->cur_comp_info[2]->v_samp_factor };
+
+#if JPEG_LIB_VERSION >= 70
+     const int idct_window_size = (cinfo->max_v_samp_factor
+                                   * cinfo->min_DCT_v_scaled_size);
+#else
+     const int idct_window_size = (cinfo->max_v_samp_factor
+                                   * cinfo->min_DCT_scaled_size);
+#endif
+
+     D_DEBUG_AT( JPEG_RAW, "trying YCbCr raw decode\n" );
+
+     if (cinfo->max_h_samp_factor == 1
+         && cinfo->max_v_samp_factor == 1
+         && cinfo->cur_comp_info[0]->h_samp_factor == 1
+         && v_samp[0] == 1
+         && cinfo->cur_comp_info[1]->h_samp_factor == 1
+         && v_samp[1] == 1
+         && cinfo->cur_comp_info[2]->h_samp_factor == 1
+         && v_samp[2] == 1) {
+          /* The image is YCbCr 4:4:4 */
+          D_DEBUG_AT( JPEG_RAW, "  -> 4:4:4 image\n" );
+
+          JPEG_setup_yuv444p( cinfo, &config,
+                              &pitch_y, &pitch_cb, &pitch_cr,
+                              &offset_cb, &offset_cr );
+     }
+     else if (cinfo->max_h_samp_factor == 2
+              && cinfo->max_v_samp_factor == 2
+              && cinfo->cur_comp_info[0]->h_samp_factor == 2
+              && v_samp[0] == 2
+              && cinfo->cur_comp_info[1]->h_samp_factor == 1
+              && v_samp[1] == 1
+              && cinfo->cur_comp_info[2]->h_samp_factor == 1
+              && v_samp[2] == 1) {
+          /* The image is YCbCr 4:2:0 ... */
+          D_DEBUG_AT( JPEG_RAW, "  -> 4:2:0 (I420) image\n" );
+
+          if ((cinfo->scale_num != cinfo->scale_denom)
+              && ((((float)cinfo->scale_denom / cinfo->scale_num)
+                    == (float)(cinfo->scale_denom / cinfo->scale_num))
+                  || (cinfo->scale_num < 4 && cinfo->scale_num != 1)) /* only when JPEG_LIB_VERSION >= 70 */
+              && (cinfo->cur_comp_info[1]->downsampled_width
+                  == cinfo->cur_comp_info[0]->downsampled_width)
+              && (cinfo->cur_comp_info[2]->downsampled_width
+                  == cinfo->cur_comp_info[0]->downsampled_width)) {
+               /* ... but because we are iDCT scaling during decompression it
+                  might end up scaled to 4:4:4, as libjpeg can (and will) apply
+                  different scaling factors for the three components. */
+               D_DEBUG_AT( JPEG_RAW, "    -> iDCT %u/%u scaled to 4:4:4\n",
+                           cinfo->scale_num, cinfo->scale_denom );
+
+               JPEG_setup_yuv444p( cinfo, &config,
+                                   &pitch_y, &pitch_cb, &pitch_cr,
+                                   &offset_cb, &offset_cr );
+          }
+          else if ((cinfo->scale_num == cinfo->scale_denom)
+                   || (((float)cinfo->scale_denom / cinfo->scale_num)
+                       != (float)(cinfo->scale_denom / cinfo->scale_num))
+                   || ((cinfo->cur_comp_info[1]->downsampled_width
+                        == ((cinfo->cur_comp_info[0]->downsampled_width + 1)
+                            / 2))
+                       && (cinfo->cur_comp_info[2]->downsampled_width
+                           == ((cinfo->cur_comp_info[0]->downsampled_width + 1)
+                               / 2)))) {
+               /* ... no iDCT scaling, which means it really ends up
+                  as 4:2:0. */
+               config.format = DSPF_I420;
+
+               config.size.w = _ROUND_UP_16( cinfo->cur_comp_info[0]
+                                                        ->downsampled_width );
+               config.size.h = _ROUND_UP_16( cinfo->cur_comp_info[0]
+                                                       ->downsampled_height );
+
+               /* pad an extra (decimated) MCU row for the iDCT write-out */
+               config.size.h += idct_window_size;
+
+               pitch_y = config.size.w;
+               pitch_cb
+                    = pitch_cr
+                    = pitch_y / 2;
+
+               offset_cb = pitch_y  * config.size.h;
+               offset_cr = pitch_cb * config.size.h / 2;
+
+               cb_v_sampl
+                    = cr_v_sampl
+                    = 2;
+          }
+          else {
+               /* shouldn't happen, really */
+               D_DEBUG_AT( JPEG_RAW, "  -> unsupported (unexpected)!\n" );
+               return DFB_UNSUPPORTED;
+          }
+     }
+     else if (cinfo->max_h_samp_factor == 2
+              && cinfo->max_v_samp_factor == 1
+              && cinfo->cur_comp_info[0]->h_samp_factor == 2
+              && v_samp[0] == 1
+              && cinfo->cur_comp_info[1]->h_samp_factor == 1
+              && v_samp[1] == 1
+              && cinfo->cur_comp_info[2]->h_samp_factor == 1
+              && v_samp[2] == 1) {
+          /* The image is YCbCr 4:2:2 ... */
+          D_DEBUG_AT( JPEG_RAW, "  -> 4:2:2 (YV16) image\n" );
+
+          if ((cinfo->scale_num != cinfo->scale_denom)
+              && ((((float)cinfo->scale_denom / cinfo->scale_num)
+                    == (float)(cinfo->scale_denom / cinfo->scale_num))
+                  || (cinfo->scale_num < 4 && cinfo->scale_num != 1)) /* only when JPEG_LIB_VERSION >= 70 */
+              && (cinfo->cur_comp_info[1]->downsampled_width
+                  == cinfo->cur_comp_info[0]->downsampled_width)
+              && (cinfo->cur_comp_info[2]->downsampled_width
+                  == cinfo->cur_comp_info[0]->downsampled_width)) {
+               /* ... iDCT scaling again, as above. */
+               D_DEBUG_AT( JPEG_RAW, "    -> iDCT %u/%u scaled to 4:4:4\n",
+                           cinfo->scale_num, cinfo->scale_denom );
+
+               JPEG_setup_yuv444p( cinfo, &config,
+                                   &pitch_y, &pitch_cb, &pitch_cr,
+                                   &offset_cb, &offset_cr );
+          }
+          else if ((cinfo->scale_num == cinfo->scale_denom)
+                   || (((float)cinfo->scale_denom / cinfo->scale_num)
+                       != (float)(cinfo->scale_denom / cinfo->scale_num))
+                   || ((cinfo->cur_comp_info[1]->downsampled_width
+                        == ((cinfo->cur_comp_info[0]->downsampled_width + 1)
+                            / 2))
+                       && (cinfo->cur_comp_info[2]->downsampled_width
+                           == ((cinfo->cur_comp_info[0]->downsampled_width + 1)
+                               / 2)))) {
+               /* ... no iDCT scaling, as above. */
+               config.format = DSPF_YV16;
+
+               config.size.w = _ROUND_UP_16( cinfo->cur_comp_info[0]
+                                                        ->downsampled_width );
+               config.size.h = _ROUND_UP_16( cinfo->cur_comp_info[0]
+                                                       ->downsampled_height );
+
+               /* pad an extra (decimated) MCU row for the iDCT write-out */
+               config.size.h += idct_window_size;
+
+               pitch_y = config.size.w;
+               pitch_cb
+                    = pitch_cr
+                    = pitch_y / 2;
+
+               /* YV16 has Cr/Cb planes not Cb/Cr */
+               offset_cb = (pitch_y + pitch_cr) * config.size.h;
+               offset_cr = -pitch_cr * config.size.h;
+          }
+          else {
+               /* shouldn't happen, really */
+               D_DEBUG_AT( JPEG_RAW, "  -> unsupported (unexpected)!\n" );
+               return DFB_UNSUPPORTED;
+          }
      }
      else {
-          rect = dst_data->area.wanted;
+          D_DEBUG_AT( JPEG_RAW, "  -> unsupported!\n" );
+          return DFB_UNSUPPORTED;
      }
 
-     ret = dfb_surface_lock_buffer( dst_surface, CSBR_BACK, CSAID_CPU, CSAF_WRITE, &lock );
-     if (ret)
-          return ret;
+     /* FIXME: is this correct for all JPEG images? */
+     config.colorspace = DSCS_BT601_FULLRANGE;
+
+     /* We can handle this raw format! */
+     return JPEG_raw_decode_common( data, dst_surface, rect,
+                                    cinfo, state, lock,
+                                    &config, NULL,
+                                    pitch_y, pitch_cb, pitch_cr,
+                                    offset_cb, offset_cr,
+                                    y_v_sampl, cb_v_sampl, cr_v_sampl );
+}
+
+static DFBResult
+JPEG_raw_decode_Grayscale( IDirectFBImageProvider_JPEG_data *data,
+                           CoreSurface                      *dst_surface,
+                           DFBRectangle                     *rect,
+                           struct jpeg_decompress_struct    *cinfo,
+                           CardState                        *state,
+                           CoreSurfaceBufferLock            *lock )
+{
+     CoreSurfaceConfig config;
+     CorePalette *lut8_palette;
+     int pitch_y;
 
-     if (data->image &&
-         (rect.x || rect.y || rect.w != data->image_width || rect.h != data->image_height)) {
-           D_FREE( data->image );
-           data->image        = NULL;
-           data->image_width  = 0;
-           data->image_height = 0;
+     unsigned int i;
+
+     D_DEBUG_AT( JPEG_RAW, "trying grayscale raw decode\n" );
+
+     if (cinfo->max_h_samp_factor == 1
+         && cinfo->max_v_samp_factor == 1
+         && cinfo->cur_comp_info[0]->h_samp_factor == 1
+         && cinfo->cur_comp_info[0]->v_samp_factor == 1) {
+          int dummy;
+
+          /* The image is grayscale 4:4:4 */
+          D_DEBUG_AT( JPEG_RAW, "  -> 4:4:4 grayscale image\n" );
+
+          JPEG_setup_yuv444p( cinfo, &config, &pitch_y, &dummy, &dummy,
+                              &dummy, &dummy );
+
+          /* Override the YUV444P format set by JPEG_setup_yuv444p() */
+          config.format = DSPF_LUT8;
+     }
+     else {
+          D_DEBUG_AT( JPEG_RAW, "  -> unsupported grayscale image!\n" );
+          return DFB_UNSUPPORTED;
+     }
+
+     /* We can handle this raw format! */
+     if (dfb_palette_create( data->common.base.core, 256, &lut8_palette )) {
+          D_ERROR( "failed to create a palette for the decode surface\n" );
+          return DFB_UNSUPPORTED;
+     }
+
+     for (i = 0; i < lut8_palette->num_entries; i++) {
+          lut8_palette->entries[i].a = 255;
+          lut8_palette->entries[i].r = i;
+          lut8_palette->entries[i].g = i;
+          lut8_palette->entries[i].b = i;
+     }
+
+     config.colorspace = DSCS_RGB;
+
+     return JPEG_raw_decode_common( data, dst_surface, rect,
+                                    cinfo, state, lock,
+                                    &config, lut8_palette,
+                                    pitch_y, 0, 0,
+                                    0, 0,
+                                    1, 0, 0 );
+}
+
+static DFBResult
+JPEG_raw_decode( IDirectFBImageProvider_JPEG_data *data,
+                 CoreSurface                      *dst_surface,
+                 DFBRectangle                     *rect,
+                 struct jpeg_decompress_struct    *cinfo,
+                 CardState                        *state,
+                 CoreSurfaceBufferLock            *lock )
+{
+     if (cinfo->data_precision != 8)
+          return DFB_UNSUPPORTED;
+
+     if (cinfo->num_components == 3
+         && cinfo->jpeg_color_space == JCS_YCbCr)
+          return JPEG_raw_decode_YCbCr( data, dst_surface, rect,
+                                        cinfo, state, lock );
+
+     if (cinfo->num_components == 1
+         && cinfo->jpeg_color_space == JCS_GRAYSCALE)
+          return JPEG_raw_decode_Grayscale( data, dst_surface, rect,
+                                            cinfo, state, lock );
+
+     return DFB_UNSUPPORTED;
+}
+
+static DFBResult
+JPEG_SoftwareRenderTo( IDirectFBImageProvider_JPEG_data *data,
+                       CoreSurface                      *dst_surface,
+                       DFBSurfacePixelFormat             format,
+                       DFBRectangle                     *rect,
+                       const DFBRegion                  *clip )
+{
+     DFBResult              ret;
+     DIRenderCallbackResult cb_result = DIRCR_OK;
+     bool                   try_raw = true;
+
+     D_ASSERT( data != NULL );
+     D_ASSERT( dst_surface != NULL );
+     D_ASSERT( clip != NULL );
+     D_ASSERT( rect != NULL );
+
+     if (data->common.decode_surface &&
+         (rect->x || rect->y || rect->w != data->common.decoded_width || rect->h != data->common.decoded_height)) {
+           dfb_gfxcard_wait_serial( &data->common.serial );
+           dfb_surface_unref( data->common.decode_surface );
+           data->common.decode_surface = NULL;
+           data->common.decoded_width  = 0;
+           data->common.decoded_height = 0;
      }
 
      /* actual loading and rendering */
-     if (!data->image) {
+     if (!data->common.decode_surface) {
           struct jpeg_decompress_struct cinfo;
           struct my_error_mgr jerr;
           JSAMPARRAY buffer;      /* Output row buffer */
-          int row_stride;         /* physical row width in output buffer */
-          u32 *row_ptr;
+          JSAMPLE *row_ptr;
           int y = 0;
-          int uv_offset = 0;
+          CardState state;
+          CoreSurfaceBufferLock lock_raw = { .pitch = 0 };
 
           cinfo.err = jpeg_std_error(&jerr.pub);
           jerr.pub.error_exit = jpeglib_panic;
@@ -478,28 +982,59 @@
 
                jpeg_destroy_decompress( &cinfo );
 
-               if (data->image) {
-                    dfb_scale_linear_32( data->image, data->image_width, data->image_height,
-                                         lock.addr, lock.pitch, &rect, dst_surface, &clip );
-                    dfb_surface_unlock_buffer( dst_surface, &lock );
-                    if (data->base.render_callback) {
-                         DFBRectangle r = { 0, 0, data->image_width, data->image_height };
+               if (try_raw) {
+                    dfb_state_set_source( &state, NULL );
+                    dfb_state_set_destination( &state, NULL );
+                    dfb_state_destroy( &state);
+               }
+               if (data->common.decode_surface) {
+                    CardState state;
+                    DFBRectangle src_rect = {
+                         .x = 0,
+                         .y = 0,
+                         .w = data->common.decoded_width,
+                         .h = data->common.decoded_height
+                    };
+
+                    if (lock_raw.pitch)
+                         dfb_surface_unlock_buffer( data->common.decode_surface,
+                                                    &lock_raw );
+
+                    /* use DFB to convert the raw or BGR24 to destination
+                       format, and apply any necessary additional
+                       clip/stretch */
+                    dfb_state_init( &state, data->common.base.core );
+                    dfb_state_set_source( &state, data->common.decode_surface );
+                    dfb_state_set_destination( &state, dst_surface );
+                    dfb_state_set_clip( &state, clip );
+
+                    JPEG_stretchblit( data, &state, &src_rect, rect );
+
+                    /* remove the state */
+                    dfb_state_set_source( &state, NULL );
+                    dfb_state_set_destination( &state, NULL );
+                    dfb_state_destroy( &state );
+
+                    dfb_gfxcard_wait_serial( &data->common.serial );
+                    dfb_surface_unref( data->common.decode_surface );
+                    data->common.decode_surface = NULL;
+
+                    if (data->common.base.render_callback) {
+                         DFBRectangle r = { 0, 0, data->common.decoded_width, data->common.decoded_height };
 
-                         if (data->base.render_callback( &r,
-                                                         data->base.render_callback_context ) != DIRCR_OK)
+                         if (data->common.base.render_callback( &r, data->common.base.render_callback_context ) != DIRCR_OK)
                               return DFB_INTERRUPTED;
                     }
 
                     return DFB_INCOMPLETE;
                }
                else
-                    dfb_surface_unlock_buffer( dst_surface, &lock );
-
-               return DFB_FAILURE;
+                    return DFB_FAILURE;
           }
 
+restart:
           jpeg_create_decompress( &cinfo );
-          jpeg_buffer_src( &cinfo, data->base.buffer, 0 );
+          jpeg_buffer_src( &cinfo, data->common.base.buffer, 0 );
           jpeg_read_header( &cinfo, TRUE );
 
 #if JPEG_LIB_VERSION >= 70
@@ -511,19 +1046,16 @@
 #endif
           jpeg_calc_output_dimensions( &cinfo );
 
-          if (cinfo.output_width == (unsigned)rect.w && cinfo.output_height == (unsigned)rect.h) {
-               direct = true;
-          }
-          else if (rect.x == 0 && rect.y == 0) {
+          if (rect->x == 0 && rect->y == 0) {
 #if JPEG_LIB_VERSION >= 70
                /*  The supported scaling ratios in libjpeg 7 and 8
                 *  are N/8 with all N from 1 to 16.
                 */
                cinfo.scale_num = 1;
                jpeg_calc_output_dimensions( &cinfo );
-               while (cinfo.scale_num < 16
-                      && cinfo.output_width < (unsigned)rect.w
-                      && cinfo.output_height < (unsigned)rect.h) {
+               while (cinfo.scale_num < 8
+                      && cinfo.output_width < (unsigned)rect->w
+                      && cinfo.output_height < (unsigned)rect->h) {
                     ++cinfo.scale_num;
                     jpeg_calc_output_dimensions( &cinfo );
                }
@@ -532,8 +1064,8 @@
                 *  are 1/1, 1/2, 1/4, and 1/8.
                 */
                while (cinfo.scale_denom < 8
-                      && ((cinfo.output_width >> 1) >= (unsigned)rect.w)
-                      && ((cinfo.output_height >> 1) >= (unsigned)rect.h)) {
+                      && ((cinfo.output_width >> 1) >= (unsigned)rect->w)
+                      && ((cinfo.output_height >> 1) >= (unsigned)rect->h)) {
                     cinfo.scale_denom <<= 1;
                     jpeg_calc_output_dimensions( &cinfo );
                }
@@ -542,138 +1074,147 @@
 
           cinfo.output_components = 3;
 
-          switch (dst_surface->config.format) {
-               case DSPF_NV16:
-                    uv_offset = dst_surface->config.size.h * lock.pitch;
-
-                    if (direct && !rect.x && !rect.y) {
-                         D_INFO( "JPEG: Using YCbCr color space directly! (%dx%d)\n",
-                                 cinfo.output_width, cinfo.output_height );
-                         cinfo.out_color_space = JCS_YCbCr;
-                         break;
-                    }
-                    D_INFO( "JPEG: Going through RGB color space! (%dx%d -> %dx%d @%d,%d)\n",
-                            cinfo.output_width, cinfo.output_height, rect.w, rect.h, rect.x, rect.y );
-                    cinfo.out_color_space = JCS_RGB;
-                    break;
-
-               case DSPF_UYVY:
-                    if (direct && !rect.x && !rect.y) {
-                         cinfo.out_color_space = JCS_YCbCr;
+          data->common.decoded_width = cinfo.output_width;
+          data->common.decoded_height = cinfo.output_height;
+
+          cinfo.do_fancy_upsampling = FALSE;
+          cinfo.do_block_smoothing = FALSE;
+
+          if (try_raw) {
+               /* init a state, so that we can use gfxcard/blit to convert
+                  YCbCr to requested destination format */
+               dfb_state_init( &state, data->common.base.core );
+               dfb_state_set_destination( &state, dst_surface );
+               dfb_state_set_clip( &state, clip );
+
+               ret = JPEG_raw_decode( data, dst_surface, rect, &cinfo,
+                                      &state, &lock_raw );
+
+               /* remove the state */
+               dfb_state_set_source( &state, NULL );
+               dfb_state_set_destination( &state, NULL );
+               dfb_state_destroy( &state );
+
+               switch (ret) {
+                    case DFB_OK:
+                    case DFB_INTERRUPTED:
+                         /* All ok, or callback signalled abort. */
+                         return ret;
+
+                    case DFB_UNSUPPORTED:
+                         /* Not enough video memory or source image format not
+                            supported. jpeg_start_decompress() was not yet
+                            called, so we can just break.
+                            We have to reset try_raw, in case the software
+                            decode throws an exception, though. */
+                         try_raw = false;
                          break;
-                    }
-                    D_INFO( "JPEG: Going through RGB color space! (%dx%d -> %dx%d @%d,%d)\n",
-                            cinfo.output_width, cinfo.output_height, rect.w, rect.h, rect.x, rect.y );
-                    cinfo.out_color_space = JCS_RGB;
-                    break;
-
-               default:
-                    cinfo.out_color_space = JCS_RGB;
-                    break;
+
+                    default:
+                         D_BUG( "JPEG_raw_decode() returned unknown "
+                                "result %d\n", ret );
+                    case DFB_FAILURE:
+                         /* General failure during compression, we restart
+                            trying a software decoding and in for that have to
+                            reinitialise cinfo. */
+                         try_raw = false;
+                         goto restart;
+               }
           }
 
-          if (data->flags & DIRENDER_FAST)
-               cinfo.dct_method = JDCT_IFAST;
 
-          jpeg_start_decompress( &cinfo );
+          /* start using the full software decode path */
+          cinfo.out_color_space = JCS_RGB;
 
-          data->image_width = cinfo.output_width;
-          data->image_height = cinfo.output_height;
+          if (data->flags & DIRENDER_FAST)
+               cinfo.dct_method = JDCT_FASTEST;
+
+          CoreSurfaceConfig config = { .flags = (CSCONF_SIZE
+                                                 | CSCONF_FORMAT
+                                                 | CSCONF_COLORSPACE),
+                                       .format = DSPF_BGR24,
+                                       .colorspace = DSCS_RGB,
+                                       .size.w = data->common.decoded_width,
+                                       .size.h = data->common.decoded_height };
+          if (dfb_surface_create( data->common.base.core, &config, CSTF_NONE,
+                                  0, NULL, &data->common.decode_surface )) {
+               D_ERROR( "failed to create temporary decode surface\n" );
+               return DFB_UNSUPPORTED;
+          }
 
-          row_stride = cinfo.output_width * 3;
+          if ((ret = dfb_surface_lock_buffer( data->common.decode_surface,
+                                              CSBR_BACK, CSAID_CPU,
+                                              CSAF_WRITE, &lock_raw ))) {
+               dfb_surface_unref( data->common.decode_surface );
+               data->common.decode_surface = NULL;
 
-          buffer = (*cinfo.mem->alloc_sarray)( (j_common_ptr) &cinfo,
-                                               JPOOL_IMAGE, row_stride, 1 );
+               jpeg_abort_decompress( &cinfo );
+               jpeg_destroy_decompress( &cinfo );
 
-          data->image = D_CALLOC( data->image_height, data->image_width * 4 );
-          if (!data->image) {
-               dfb_surface_unlock_buffer( dst_surface, &lock );
-               return D_OOM();
+               return ret;
           }
-          row_ptr = data->image;
 
-          while (cinfo.output_scanline < cinfo.output_height && cb_result == DIRCR_OK) {
-               jpeg_read_scanlines( &cinfo, buffer, 1 );
+          jpeg_start_decompress( &cinfo );
 
-               switch (dst_surface->config.format) {
-                    case DSPF_NV16:
-                    case DSPF_UYVY:
-                         if (direct) {
-                              switch (dst_surface->config.format) {
-                                   case DSPF_NV16:
-                                        copy_line_nv16( lock.addr, (u16*)lock.addr + uv_offset, *buffer, rect.w );
-                                        break;
-
-                                   case DSPF_UYVY:
-                                        copy_line_uyvy( lock.addr, *buffer, rect.w );
-                                        break;
-
-                                   default:
-                                        break;
-                              }
-
-                              lock.addr = (u8*)lock.addr + lock.pitch;
-
-                              if (data->base.render_callback) {
-                                   DFBRectangle r = { 0, y, data->image_width, 1 };
-
-                                   cb_result = data->base.render_callback( &r,
-                                                                           data->base.render_callback_context );
-                              }
-                              break;
-                         }
+          row_ptr = lock_raw.addr;
+          buffer = &row_ptr;
 
-                    default:
-                         copy_line32( row_ptr, *buffer, data->image_width );
+          while (cinfo.output_scanline < cinfo.output_height && cb_result == DIRCR_OK) {
+               jpeg_read_scanlines( &cinfo, buffer, 1 );
 
-                         if (direct) {
-                              DFBRectangle r = { rect.x, rect.y+y, rect.w, 1 };
-                              dfb_copy_buffer_32( row_ptr, lock.addr, lock.pitch,
-                                                  &r, dst_surface, &clip );
-                              if (data->base.render_callback) {
-                                   r = (DFBRectangle){ 0, y, data->image_width, 1 };
-                                   cb_result = data->base.render_callback( &r,
-                                                                           data->base.render_callback_context );
-                              }
-                         }
-                         break;
+               if (data->common.base.render_callback) {
+                    DFBRectangle r =
+                              (DFBRectangle){ 0, y, data->common.decoded_width, 1 };
+                    cb_result = data->common.base.render_callback( &r,
+                                                                   data->common.base.render_callback_context );
                }
 
-               row_ptr += data->image_width;
+               row_ptr += lock_raw.pitch;
                y++;
           }
 
-          if (!direct) {
-               dfb_scale_linear_32( data->image, data->image_width, data->image_height,
-                                    lock.addr, lock.pitch, &rect, dst_surface, &clip );
-               if (data->base.render_callback) {
-                    DFBRectangle r = { 0, 0, data->image_width, data->image_height };
-                    cb_result = data->base.render_callback( &r,
-                                                            data->base.render_callback_context );
-               }
-          }
+          dfb_surface_unlock_buffer( data->common.decode_surface, &lock_raw );
 
           if (cb_result != DIRCR_OK) {
                jpeg_abort_decompress( &cinfo );
-               D_FREE( data->image );
-               data->image = NULL;
           }
           else {
                jpeg_finish_decompress( &cinfo );
           }
           jpeg_destroy_decompress( &cinfo );
      }
-     else {
-          dfb_scale_linear_32( data->image, data->image_width, data->image_height,
-                               lock.addr, lock.pitch, &rect, dst_surface, &clip );
-          if (data->base.render_callback) {
-               DFBRectangle r = { 0, 0, data->image_width, data->image_height };
-               data->base.render_callback( &r,
-                                           data->base.render_callback_context );
+
+     if (data->common.decode_surface) {
+          CardState    state;
+          DFBRectangle src_rect = {
+               .x = 0,
+               .y = 0,
+               .w = data->common.decoded_width,
+               .h = data->common.decoded_height
+          };
+
+          /* use DFB to convert the YCbCr or BGR24 to destination format and
+             apply any necessary additional clip/stretch */
+          dfb_state_init( &state, data->common.base.core );
+          dfb_state_set_source( &state, data->common.decode_surface );
+          dfb_state_set_destination( &state, dst_surface );
+          dfb_state_set_clip( &state, clip );
+
+          JPEG_stretchblit( data, &state, &src_rect, rect );
+
+          /* remove the state */
+          dfb_state_set_source( &state, NULL );
+          dfb_state_set_destination( &state, NULL );
+          dfb_state_destroy( &state );
+
+          if (data->common.base.render_callback) {
+               DFBRectangle r = { 0, 0, data->common.decoded_width, data->common.decoded_height };
+               data->common.base.render_callback( &r,
+                                                  data->common.base.render_callback_context );
           }
      }
 
-     dfb_surface_unlock_buffer( dst_surface, &lock );
+     D_DEBUG_AT( JPEG, "software decoding finished\n" );
 
      if (cb_result != DIRCR_OK)
           return DFB_INTERRUPTED;
@@ -681,6 +1222,167 @@
      return DFB_OK;
 }
 
+
+
+static DFBResult
+JPEG_RenderTo( IDirectFBImageProvider_JPEG_data *data,
+               CoreSurface                      *dst_surface,
+               DFBSurfacePixelFormat             format,
+               DFBRectangle                     *rect,
+               const DFBRegion                  *clip )
+{
+     DFBResult res;
+
+     D_ASSERT( data != NULL );
+     D_ASSERT( dst_surface != NULL );
+     D_ASSERT( clip != NULL );
+     D_ASSERT( rect != NULL );
+
+     res = JPEG_HardwareRenderTo( data, dst_surface, format, rect, clip );
+     if (res != DFB_OK) {
+          if (res == DFB_IO) {
+               /* IO error - there's no point in retrying */
+               D_DEBUG_AT( JPEG, "hardware decode failed: %d (%s)\n",
+                           res, DirectFBErrorString( res ) );
+               return res;
+          }
+
+          D_DEBUG_AT( JPEG, "hardware decode failed: %d (%s) - "
+                      "attempting software fallback\n",
+                      res, DirectFBErrorString( res ) );
+
+          res = JPEG_SoftwareRenderTo( data, dst_surface, format, rect, clip );
+          if (unlikely (res != DFB_OK))
+               D_DEBUG_AT( JPEG, "software decode failed: %d (%s)\n",
+                           res, DirectFBErrorString( res ) );
+     }
+
+     return res;
+}
+
+static DFBResult
+IDirectFBImageProvider_JPEG_RenderTo( IDirectFBImageProvider *thiz,
+                                      IDirectFBSurface       *destination,
+                                      const DFBRectangle     *dest_rect )
+{
+     IDirectFBSurface_data *dst_data;
+     CoreSurface           *dst_surface;
+     DFBSurfacePixelFormat  format;
+     DFBResult              ret;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBImageProvider_JPEG)
+
+     dst_data = (IDirectFBSurface_data*) destination->priv;
+     if (!dst_data)
+          return DFB_DEAD;
+
+     dst_surface = dst_data->surface;
+     if (!dst_surface)
+          return DFB_DESTROYED;
+
+     ret = destination->GetPixelFormat( destination, &format );
+     if (ret)
+          return ret;
+
+     if (data->thread)
+          pthread_mutex_lock( &data->lock );
+
+     dfb_region_from_rectangle( &data->clip, &dst_data->area.current );
+
+     if (dest_rect) {
+          if (dest_rect->w < 1 || dest_rect->h < 1) {
+               if (data->thread)
+                    pthread_mutex_unlock( &data->lock );
+               return DFB_INVARG;
+          }
+
+          data->rect = *dest_rect;
+          data->rect.x += dst_data->area.wanted.x;
+          data->rect.y += dst_data->area.wanted.y;
+
+          if (!dfb_rectangle_region_intersects( &data->rect, &data->clip )) {
+               if (data->thread)
+                    pthread_mutex_unlock( &data->lock );
+               return DFB_OK;
+          }
+     }
+     else {
+          data->rect = dst_data->area.wanted;
+     }
+
+     if (!D_FLAGS_IS_SET (data->flags, DIRENDER_BACKGROUND)) {
+          /* threaded operation was not requested */
+          data->thread_res = JPEG_RenderTo( data, dst_surface, format,
+                                            &data->rect, &data->clip );
+          if (data->thread)
+               pthread_mutex_unlock( &data->lock );
+          return data->thread_res;
+     }
+
+     if (!data->thread) {
+          /* for the case that somebody does a RenderTo() twice on us, we
+             have to create new thread, because the initial thread will have
+             finished already */
+
+          D_ASSERT( data->destination == NULL );
+
+          /* as long as we haven't even started yet, we are in INIT state */
+          data->thread_res = DFB_INIT;
+          data->thread = direct_thread_create( DTT_DEFAULT, JPEGrenderThread,
+                                               thiz, "JPEG" );
+     }
+
+     D_ASSERT( data->destination == NULL );
+
+     destination->AddRef( destination );
+     data->destination = destination;
+
+     pthread_cond_signal( &data->cond );
+     pthread_mutex_unlock( &data->lock );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBImageProvider_JPEG_Sync( IDirectFBImageProvider    *thiz,
+                                  DFBImageProviderSyncFlags  flags )
+{
+     DFBResult res;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBImageProvider_JPEG)
+
+     switch (flags)
+       {
+       case DIPSYNCFLAGS_TRYSYNC:
+            if (data->thread) {
+                 if (data->thread_res == DFB_INIT
+                     || data->thread_res == DFB_BUSY) {
+                      /* DFB_INIT (user didn't call RenderTo() yet)
+                         DFB_BUSY (still busy decoding) */
+                      return data->thread_res;
+                 }
+                 /* else we are done, either because of some error or because
+                    we have processed all the data already */
+            }
+            /* fall through */
+
+       case DIPSYNCFLAGS_SYNC:
+            if (data->thread) {
+                 direct_thread_join( data->thread );
+                 direct_thread_destroy( data->thread );
+                 data->thread = NULL;
+            }
+            break;
+
+       default:
+            return DFB_OK;
+       }
+
+     res = data->thread_res;
+     data->thread_res = DFB_OK;
+     return res;
+}
+
 static DFBResult
 IDirectFBImageProvider_JPEG_GetSurfaceDescription( IDirectFBImageProvider *thiz,
                                                    DFBSurfaceDescription  *dsc )
@@ -691,8 +1393,8 @@
           return DFB_INVARG;
 
      dsc->flags  = DSDESC_WIDTH |  DSDESC_HEIGHT | DSDESC_PIXELFORMAT;
-     dsc->height = data->height;
-     dsc->width  = data->width;
+     dsc->width  = data->common.width;
+     dsc->height = data->common.height;
      dsc->pixelformat = dfb_primary_layer_pixelformat();
 
      return DFB_OK;
@@ -703,6 +1405,30 @@
 {
      DIRECT_INTERFACE_GET_DATA(IDirectFBImageProvider_JPEG)
 
+     /* if we have decoded the image already, don't do anything... */
+     if (data->common.decode_surface)
+          return DFB_UNSUPPORTED;
+
+     if (!(flags & DIRENDER_BACKGROUND) && data->thread) {
+          /* terminate the decoding thread, if necessary... */
+          direct_thread_cancel( data->thread );
+          direct_thread_join( data->thread );
+          direct_thread_destroy( data->thread );
+          data->thread = NULL;
+
+          pthread_cond_destroy( &data->cond );
+          pthread_mutex_destroy( &data->lock );
+     }
+     else if (flags & DIRENDER_BACKGROUND && !data->thread) {
+          /* or create it */
+          pthread_cond_init( &data->cond, NULL );
+          pthread_mutex_init( &data->lock, NULL );
+          /* as long as we haven't even started yet, we are in INIT state */
+          data->thread_res = DFB_INIT;
+          data->thread = direct_thread_create( DTT_DEFAULT, JPEGrenderThread,
+                                               thiz, "JPEG_DECODER?" );
+     }
+
      data->flags = flags;
 
      return DFB_OK;
@@ -721,3 +1447,1147 @@
 
      return DFB_OK;
 }
+
+static void
+render_cleanup( void *cleanup_data )
+{
+     IDirectFBImageProvider           *thiz = cleanup_data;
+     IDirectFBImageProvider_JPEG_data *data;
+
+     D_MAGIC_ASSERT( (IAny*)thiz, DirectInterface );
+     data = (IDirectFBImageProvider_JPEG_data *) thiz->priv;
+     D_ASSERT( data != NULL );
+
+     if (data->destination) {
+          data->destination->Release( data->destination );
+          data->destination = NULL;
+     }
+
+     /* in case we get terminated from outside, set the state to DFB_DEAD */
+     data->thread_res = DFB_DEAD;
+
+     pthread_mutex_unlock( &data->lock );
+}
+
+static void *
+JPEGrenderThread( DirectThread *thread, void *driver_data )
+{
+     IDirectFBImageProvider           *thiz = driver_data;
+     IDirectFBImageProvider_JPEG_data *data;
+     IDirectFBSurface_data            *dst_data;
+     CoreSurface                      *dst_surface;
+     DFBSurfacePixelFormat             format;
+     DFBResult                         res;
+
+     D_MAGIC_ASSERT( (IAny*)thiz, DirectInterface );
+     data = (IDirectFBImageProvider_JPEG_data *) thiz->priv;
+     D_ASSERT( data != NULL );
+
+     pthread_mutex_lock( &data->lock );
+
+     pthread_cleanup_push( render_cleanup, thiz );
+
+     while (!data->destination) {
+          pthread_cond_wait( &data->cond, &data->lock );
+     }
+
+     dst_data = (IDirectFBSurface_data*) data->destination->priv;
+     D_ASSERT( dst_data != NULL );
+
+     dst_surface = dst_data->surface;
+     D_ASSERT( dst_surface != NULL );
+
+     res = data->destination->GetPixelFormat( data->destination, &format );
+     D_ASSERT( res == DFB_OK );
+
+     /* as long as we haven't finished decoding we are busy */
+     data->thread_res = DFB_BUSY;
+
+     res = JPEG_RenderTo( data, dst_surface, format, &data->rect, &data->clip );
+
+     pthread_cleanup_pop( 1 );
+
+     /* in case we exit normally, apply the real return value */
+     data->thread_res = res;
+
+     return NULL;
+}
+
+
+#if defined(JPEG_PROVIDER_USE_MME)
+static DFBResult
+fetch_data( IDirectFBDataBuffer *buffer,
+            MME_DataBuffer_t    *dbuf,
+            int                  len )
+{
+     dbuf->ScatterPages_p[0].BytesUsed = 0;
+     dbuf->ScatterPages_p[0].FlagsIn   = 0;
+     dbuf->ScatterPages_p[0].FlagsOut  = 0;
+
+     return buffer_to_ptr_copy( buffer, dbuf->ScatterPages_p[0].Page_p, len );
+}
+
+
+static void
+TransformerCallback( MME_Event_t    Event,
+                     MME_Command_t *CallbackData,
+                     void          *UserData )
+{
+     const JPEGDEC_TransformReturnParams_t *transform_result =
+          CallbackData->CmdStatus.AdditionalInfo_p;
+//     const JPEGDECHW_VideoDecodeReturnParams_t *transform_result_hw =
+//          CallbackData->CmdStatus.AdditionalInfo_p;
+     struct _MMECommon * const mme = (struct _MMECommon *) UserData;
+     IDirectFBImageProvider_JPEG_data * const jpeg =
+          container_of( mme, IDirectFBImageProvider_JPEG_data, common );
+
+/*     if (CallbackData->CmdStatus.AdditionalInfo_p == &jpeg->hw_return_params) {
+          transform_result_hw = CallbackData->CmdStatus.AdditionalInfo_p;
+          transform_result = NULL;
+     } else */ {
+          transform_result = CallbackData->CmdStatus.AdditionalInfo_p;
+//          transform_result_hw = NULL;
+     }
+
+     if (!mme->name_set) {
+          char name[25];
+          snprintf( name, sizeof(name),
+                    "MME (%s)", mme->transformer_name );
+          direct_thread_set_name( name );
+          mme->name_set = true;
+     }
+
+     D_DEBUG_AT( JPEG_MME,
+                 "%sTransformerCallback: Event: %d: (%s)%s\n",
+                 RED, Event, get_mme_event_string( Event ), BLACK );
+     D_DEBUG_AT( JPEG_MME,
+                 "  -> CallbackData->CmdStatus.State: %d (%s)\n",
+                 CallbackData->CmdStatus.State,
+                 get_mme_state_string( CallbackData->CmdStatus.State ) );
+     D_DEBUG_AT( JPEG_MME,
+                 "  -> CallbackData->CmdStatus.CmdId: %u (%.8x)\n",
+                 CallbackData->CmdStatus.CmdId,
+                 CallbackData->CmdStatus.CmdId );
+     D_DEBUG_AT( JPEG_MME,
+                 "  -> CallbackData->CmdStatus.AdditionalInfoSize: %u\n",
+                 CallbackData->CmdStatus.AdditionalInfoSize );
+     D_DEBUG_AT( JPEG_MME,
+                 "  -> mme->decode_success: %d\n",
+                 mme->decode_success );
+
+     switch (Event) {
+     case MME_COMMAND_COMPLETED_EVT:
+          pthread_mutex_lock( &mme->pending_commands_lock );
+          direct_hash_remove( mme->pending_commands,
+                              CallbackData->CmdStatus.CmdId );
+          if (likely (CallbackData->CmdStatus.CmdId != mme->TransformCommand.CmdStatus.CmdId))
+               --mme->n_pending_buffers;
+          pthread_mutex_unlock( &mme->pending_commands_lock );
+
+          switch (CallbackData->CmdStatus.State) {
+          case MME_COMMAND_COMPLETED:
+               if (unlikely (CallbackData->CmdStatus.CmdId
+                             == mme->TransformCommand.CmdStatus.CmdId)) {
+                    deb_gettimeofday( &mme->endtime, NULL );
+                    deb_timersub( &mme->endtime, &mme->starttime,
+                                  &mme->endtime );
+                    D_DEBUG_AT( JPEG_TIME, "  -> total time %lu.%06lu\n",
+                                mme->endtime.tv_sec, mme->endtime.tv_usec );
+
+                    /* This info is available as data->ReturnParams. too!
+                    mme->decoded_bytes  = (unsigned int) transform_result->bytes_written;
+                    mme->decoded_height = (int) transform_result->decodedImageHeight;
+                    mme->decoded_width  = (int) transform_result->decodedImageWidth;
+                    */
+
+                    if (transform_result) {
+                         D_DEBUG_AT( JPEG_MME, "  -> expanded bytes: %u\n",
+                                     transform_result->bytes_written );
+                         D_DEBUG_AT( JPEG_MME, "  -> decoded w/h: %dx%d\n",
+                                     transform_result->decodedImageWidth,
+                                     transform_result->decodedImageHeight );
+
+                         if (jpeg->progressive_mode) {
+                              mme->width = transform_result->decodedImageWidth;
+                              mme->height = transform_result->decodedImageHeight;
+                         }
+
+                         if (transform_result->Total_cycle)
+                              D_DEBUG_AT( JPEG_MME,
+                                          "  -> cycles: total/dmiss/imiss: %u/%u/%u\n",
+                                          transform_result->Total_cycle,
+                                          transform_result->DMiss_Cycle,
+                                          transform_result->IMiss_Cycle );
+                         D_DEBUG_AT( JPEG_MME,
+                                     "  -> JPEG result code: %d (%s)\n",
+                                     transform_result->ErrorType,
+                                     get_jpeg_error_string( transform_result->ErrorType ) );
+                    } /* else {
+                         D_DEBUG_AT( JPEG_MME,
+                                     "  -> cycles/dmiss/imiss: %u/%u/%u\n",
+                                     transform_result_hw->pm_cycles,
+                                     transform_result_hw->pm_dmiss,
+                                     transform_result_hw->pm_imiss );
+                         D_DEBUG_AT( JPEG_MME,
+                                     "  -> bundles/prefetches: %u/%u\n",
+                                     transform_result_hw->pm_bundles,
+                                     transform_result_hw->pm_pft );
+
+                         D_DEBUG_AT( JPEG_MME,
+                                     "  -> JPEGHW result code: %d (%s)\n",
+                                     transform_result_hw->ErrorCode,
+                                     get_jpeghw_error_string( transform_result_hw->ErrorCode ) );
+                    }
+*/
+                    mme->decode_success = 1;
+                    sema_signal_event( &mme->decode_event );
+
+                    /* in case of bogus data (too much), abort pending data
+                       buffers */
+                    abort_transformer( mme );
+               } else {
+                    /* buffer completed */
+                    struct _MMEHelper_buffer *buf =
+                         container_of( CallbackData->DataBuffers_p,
+                                       struct _MMEHelper_buffer, buffer );
+
+                    D_DEBUG_AT( JPEG_MME,
+                                "  -> buffer %p completed (container @ %p)\n",
+                                CallbackData->DataBuffers_p[0], buf );
+
+                    sema_signal_event( &buf->sema );
+               }
+               break; /* MME_COMMAND_COMPLETED */
+
+          case MME_COMMAND_FAILED:
+               D_WARN( "(%5d) %s: command %u (%.8x) failed: error %d (%s)",
+                       direct_gettid(), mme->name,
+                       CallbackData->CmdStatus.CmdId,
+                       CallbackData->CmdStatus.CmdId,
+                       CallbackData->CmdStatus.Error,
+                       get_mme_error_string( CallbackData->CmdStatus.Error ) );
+
+               if (likely (CallbackData->CmdStatus.CmdId
+                           == mme->TransformCommand.CmdStatus.CmdId)) {
+                    /* transform command failed */
+                    D_WARN( "(%5d) %s: jpeg failure code: %d (%s)",
+                            direct_gettid(), mme->name,
+                            transform_result->ErrorType,
+                            get_jpeg_error_string( transform_result->ErrorType ) );
+                    switch (transform_result->ErrorType) {
+                    case UNSUPPORTED_COLORSPACE:
+                    case UNABLE_ALLOCATE_MEMORY:
+                    case UNSUPPORTED_SCALING:
+                    case INSUFFICIENT_OUTPUTBUFFER_SIZE:
+                         /* the transformer doesn't support this, but pure
+                            libjpeg should. */
+                         mme->decode_success = -1;
+                         break;
+
+                    case UNSUPPORTED_ROTATION_ANGLE:
+                    default:
+                         /* fake a success, there's no point in retrying
+                            libjpeg, as it already failed via MME. */
+                         mme->decode_success = 1;
+                         D_DEBUG_AT( JPEG_MME, "  -> faking success\n" );
+                         break;
+                    }
+
+                    sema_signal_event( &mme->decode_event );
+               } else {
+                    /* buffer failed */
+                    struct _MMEHelper_buffer *buf =
+                         container_of( CallbackData->DataBuffers_p,
+                                       struct _MMEHelper_buffer, buffer );
+                    if (mme->decode_success == 0)
+                         /* only if we didn't succeed yet */
+                         mme->decode_success = -1;
+                    sema_signal_event( &buf->sema );
+               }
+               break; /* MME_COMMAND_FAILED */
+
+          case MME_COMMAND_IDLE:
+          case MME_COMMAND_PENDING:
+          case MME_COMMAND_EXECUTING:
+          default:
+               D_WARN( "(%5d) %s: command %u (%.8x) completed in unknown state: %d (%s)",
+                       direct_gettid(), mme->name,
+                       CallbackData->CmdStatus.CmdId,
+                       CallbackData->CmdStatus.CmdId,
+                       CallbackData->CmdStatus.State,
+                       get_mme_state_string( CallbackData->CmdStatus.State ) );
+               break;
+          }
+          break; /* MME_COMMAND_COMPLETED_EVT */
+
+     case MME_DATA_UNDERFLOW_EVT:
+          /* because of the way the transformer works (and how we communicate
+             with it), we get exactly one underflow event on startup */
+          D_DEBUG_AT( JPEG_MME,
+                      "  -> %sdata underflow on command %u (%.8x)\n",
+                      (mme->n_underflows == 0) ? "(anticipated) " : "",
+                      CallbackData->CmdStatus.CmdId,
+                      CallbackData->CmdStatus.CmdId);
+          if (++mme->n_underflows > 1) {
+               /* check if the IDirectFBDataBuffer definitely(!) hit an EOF
+                  and we have no buffers queued */
+               bool end_of_data;
+               char tmp;
+               pthread_mutex_lock( &mme->pending_commands_lock );
+               DFBResult has_data = mme->base.buffer->PeekData( mme->base.buffer,
+                                                                1, 0,
+                                                                &tmp, NULL );
+               /* n_pending_buffers is checked to be == 0 because the
+                  TransformCommand itself is not stored in there. */
+               end_of_data = (has_data == DFB_EOF
+                              && mme->n_pending_buffers == 0);
+               pthread_mutex_unlock( &mme->pending_commands_lock );
+
+               /* if so, signal completion */
+               if (end_of_data) {
+                    D_DEBUG_AT( JPEG_MME,
+                                "  -> no more data available, signalling fail\n" );
+                    mme->decode_success = -2;
+                    sema_signal_event( &mme->decode_event );
+               }
+          }
+          break; /* MME_DATA_UNDERFLOW_EVT */
+
+     case MME_NOT_ENOUGH_MEMORY_EVT:
+     case MME_NEW_COMMAND_EVT:
+     default:
+          D_WARN( "(%5d) %s: unhandled event %d (%s) occured on command %u (%.8x)",
+                  direct_gettid(), mme->name, Event,
+                  get_mme_event_string( Event ),
+                  CallbackData->CmdStatus.CmdId,
+                  CallbackData->CmdStatus.CmdId );
+
+          D_WARN( "(%5d) %s: CallbackData->CmdStatus.AdditionalInfoSize: %u",
+                  direct_gettid(), mme->name,
+                  CallbackData->CmdStatus.AdditionalInfoSize );
+
+          if (CallbackData->CmdStatus.CmdId == mme->TransformCommand.CmdStatus.CmdId) {
+               if (transform_result) {
+                    D_WARN( "(%5d) %s: transform_result->bytes_written: %u",
+                            direct_gettid(), mme->name,
+                            transform_result->bytes_written );
+                    D_WARN( "(%5d) %s: transform_result->decodedImageHeight: %d",
+                            direct_gettid(), mme->name,
+                            transform_result->decodedImageHeight );
+                    D_WARN( "(%5d) %s: transform_result->decodedImageWidth: %d",
+                            direct_gettid(), mme->name,
+                            transform_result->decodedImageWidth );
+                    if (transform_result->Total_cycle)
+                         D_WARN( "(%5d) %s: transform_result->cycles: total/dmiss/imiss: %u/%u/%u\n",
+                                 direct_gettid(), mme->name,
+                                 transform_result->Total_cycle,
+                                 transform_result->DMiss_Cycle,
+                                 transform_result->IMiss_Cycle );
+                    D_WARN( "(%5d) %s: result code: %d (%s)\n",
+                            direct_gettid(), mme->name,
+                            transform_result->ErrorType,
+                            get_jpeg_error_string( transform_result->ErrorType ) );
+               } /* else if (transform_result_hw) {
+                    D_WARN( "(%5d) %s: transform_result->cycles/dmiss/imiss: %u/%u/%u\n",
+                            direct_gettid(), mme->name,
+                            transform_result_hw->pm_cycles,
+                            transform_result_hw->pm_dmiss,
+                            transform_result_hw->pm_imiss );
+                    D_WARN( "(%5d) %s: transform_result->bundles/prefetches: %u/%u\n",
+                            direct_gettid(), mme->name,
+                            transform_result_hw->pm_bundles,
+                            transform_result_hw->pm_pft );
+
+                    D_WARN( "(%5d) %s: transform_result->JPEGHW result code: %d (%s)\n",
+                            direct_gettid(), mme->name,
+                            transform_result_hw->ErrorCode,
+                            get_jpeghw_error_string( transform_result_hw->ErrorCode ) );
+               }
+*/
+          }
+          break;
+     }
+}
+
+#if 0
+static void
+TransformerCallback2( MME_Event_t    Event,
+                      MME_Command_t *CallbackData,
+                      void          *UserData )
+{
+     const JPEGDECHW_VideoDecodeReturnParams_t * const transform_result_hw =
+          CallbackData->CmdStatus.AdditionalInfo_p;
+     struct _MMECommon * const mme = (struct _MMECommon *) UserData;
+
+     if (!mme->name_set) {
+          direct_thread_set_name( "MME (hwjpeg)" );
+          mme->name_set = true;
+     }
+
+     D_DEBUG_AT( JPEG_MME,
+                 "%sTransformerCallback2: Event: %d: (%s)%s\n",
+                 RED, Event, get_mme_event_string( Event ), BLACK );
+     D_DEBUG_AT( JPEG_MME,
+                 "  -> CallbackData->CmdStatus.State: %d (%s)\n",
+                 CallbackData->CmdStatus.State,
+                 get_mme_state_string( CallbackData->CmdStatus.State ) );
+     D_DEBUG_AT( JPEG_MME,
+                 "  -> CallbackData->CmdStatus.CmdId: %u (%.8x)\n",
+                 CallbackData->CmdStatus.CmdId,
+                 CallbackData->CmdStatus.CmdId );
+     D_DEBUG_AT( JPEG_MME,
+                 "  -> CallbackData->CmdStatus.AdditionalInfoSize: %u\n",
+                 CallbackData->CmdStatus.AdditionalInfoSize );
+     D_DEBUG_AT( JPEG_MME,
+                 "  -> mme->decode_success: %d\n", mme->decode_success );
+}
+#endif
+
+
+/* Pre-Scaling Calculations for JPEG Hardware Scaling
+ * These functions should be used anywhere where SOURCE width and height are
+   referenced */
+static unsigned int
+pre_scale_value( const IDirectFBImageProvider_JPEG_data *data,
+                 const DFBRectangle                     *dest_rect )
+{
+     unsigned int scale;
+
+     D_ASSERT( data != NULL );
+
+#ifdef PRE_SCALE_SPEED_SPACE_OPTIMISED
+     /* Speed and Space */
+     if (data->common.width <= dest_rect->w || data->common.height <= dest_rect->h)
+          scale = 1;
+     else if ((data->common.width / 2 <= dest_rect->w) && (data->common.height / 2 <= dest_rect->h))
+          scale = 2;
+     else if ((data->common.width / 4 <= dest_rect->w) && (data->common.height / 4 <= dest_rect->h))
+          scale = 4;
+     else if ((data->common.width / 8 <= dest_rect->w) && (data->common.height / 8 <= dest_rect->h))
+          scale = 8;
+     else
+          scale = 1;
+#endif
+
+#ifdef PRE_SCALE_QUALITY_OPTIMISED
+     /* Quality */
+     if ((data->common.width / 8 >= dest_rect->w) && (data->common.height / 8 >= dest_rect->h))
+          scale = 8;
+     else if ((data->common.width / 4 >= dest_rect->w) && (data->common.height / 4 >= dest_rect->h))
+          scale = 4;
+     else if ((data->common.width / 2 >= dest_rect->w) && (data->common.height / 2 >= dest_rect->h))
+          scale = 2;
+     else
+          scale = 1;
+#endif
+
+#if !defined(PRE_SCALE_SPEED_SPACE_OPTIMISED) && !defined(PRE_SCALE_QUALITY_OPTIMISED)
+     scale = 1;
+#endif
+
+     return scale;
+}
+
+static inline unsigned int
+pre_scaled_width( const IDirectFBImageProvider_JPEG_data *data,
+                  const DFBRectangle                     *dest_rect )
+{
+     D_ASSERT( data != NULL );
+
+     unsigned int w = (data->common.width + 15) & ~15; /* Macro Block Rounding */
+     return w / pre_scale_value( data, dest_rect );
+}
+
+static inline unsigned int
+pre_scaled_height( const IDirectFBImageProvider_JPEG_data *data,
+                   const DFBRectangle                     *dest_rect )
+{
+     D_ASSERT( data != NULL );
+
+     unsigned int h = (data->common.height + 15) & ~15; /* Macro Block Rounding */
+     return h / pre_scale_value( data, dest_rect );
+}
+
+/* warning: MME_AbortCommand() works only for the MME_TRANSFORM command;
+   individual buffers can be aborted, too, but MME_TermTransformer() will
+   not work afterwards anymore! */
+static bool
+pending_fe_func( DirectHash    *hash,
+                 unsigned long  key,
+                 void          *value,
+                 void          *ctx )
+{
+     struct _MMECommon * const mme = ctx;
+     MME_CommandId_t    CmdId = key;
+
+     if (key != mme->TransformCommand.CmdStatus.CmdId) {
+          if (direct_hash_lookup( hash,
+                                  mme->TransformCommand.CmdStatus.CmdId ))
+               D_WARN( "(%5d) aborting MME command %u (%.8x) can lead to a "
+                       "crash somewhere in the JPEG transformer!",
+                       direct_gettid(), CmdId, CmdId );
+     } else
+          D_DEBUG_AT( JPEG_MME,
+                      "aborting (main transform) command %u (%.8x)\n",
+                      CmdId, CmdId );
+
+     MME_ERROR res = MME_AbortCommand( mme->Handle, CmdId );
+     if (res != MME_SUCCESS)
+          D_WARN( "(%5d) MME_AbortCommand(%x, %.8x) for %s failed: %d (%s)\n",
+                  direct_gettid(), mme->Handle, CmdId,
+                  mme->name, res, get_mme_error_string( res ) );
+
+     /* continue iterating */
+     return true;
+}
+
+static DFBResult
+abort_transformer( struct _MMECommon * const mme )
+{
+     if (!mme)
+          return DFB_THIZNULL;
+
+     /* FIXME: what about locking? */
+     direct_hash_iterate( mme->pending_commands,
+                          pending_fe_func,
+                          mme );
+
+     return DFB_OK;
+}
+
+
+static void
+_imageprovider_update_transform_params( struct _MMECommon           * const mme,
+                                        void                        * const params,
+                                        const CoreSurfaceBufferLock * const lock )
+{
+     IDirectFBImageProvider_JPEG_data * const data =
+          container_of( mme, IDirectFBImageProvider_JPEG_data, common );
+
+     data->OutputParams.outputSettings.Pitch = lock->pitch;
+     data->OutputParams.outputSettings.ROTATEFLAG |= 0x80000000;
+}
+
+/*
+ *  Set up JPEG transform command
+ *  Establish Decode Parameters,
+ *  and prepare destination surface
+ *
+ */
+static DFBResult
+jpeg_start_transformer( IDirectFBImageProvider_JPEG_data *data,
+                        CoreSurface                      *dst_surface,
+                        CoreSurfaceBufferLock            *lock )
+{
+     DFBResult res;
+     MME_ERROR mme_res;
+
+     /* If height and width are NOT values divisible by 16 - then decode will
+        not work as expected. */
+     data->OutputParams.outputSettings.xvalue0 = 0;
+     data->OutputParams.outputSettings.xvalue1 = 0;
+     data->OutputParams.outputSettings.yvalue0 = 0;
+     data->OutputParams.outputSettings.yvalue1 = 0;
+
+     data->OutputParams.outputSettings.outputWidth = 0;  //Buffersize used to prevent bufferoverflows;
+     data->OutputParams.outputSettings.outputHeight = 0; //Buffersize used to prevent bufferoverflows;
+     data->OutputParams.outputSettings.ROTATEFLAG = 0;
+     data->OutputParams.outputSettings.Rotatedegree = 0;
+     data->OutputParams.outputSettings.HorizantalFlip = 0;
+     data->OutputParams.outputSettings.VerticalFlip = 0;
+
+     res = _mme_helper_start_transformer_core( &data->common,
+                                               sizeof(data->ReturnParams),
+                                               &data->ReturnParams,
+                                               sizeof(data->OutputParams),
+                                               &data->OutputParams,
+                                               dst_surface, lock );
+     if (res != DFB_OK)
+          return res;
+
+     _imageprovider_update_transform_params( &data->common,
+                                             &data->OutputParams, lock );
+
+     /* if pitch != width - we'll have issues with the hardware decode */
+     /* FIXME: the comment makes no sense. And the D_ASSUME() does sth
+        different... */
+     D_ASSUME( lock->pitch != dst_surface->config.size.w );
+
+     D_DEBUG_AT( MME_DEBUG_DOMAIN, "issuing MME_TRANSFORM\n" );
+
+     /* lock access to hash, because otherwise the callback could be called
+        before we've had a chance to put the command id into the hash */
+     D_ASSERT( &data->common.pending_commands != NULL );
+     pthread_mutex_lock( &data->common.pending_commands_lock );
+
+     mme_res = MME_SendCommand( data->common.Handle,
+                                &data->common.TransformCommand );
+     if (mme_res != MME_SUCCESS) {
+          pthread_mutex_unlock( &data->common.pending_commands_lock );
+
+          D_WARN( "(%5d) %s: starting transformer failed: %d (%s)",
+                  direct_gettid(), data->common.name,
+                  mme_res, get_mme_error_string( mme_res ) );
+
+          dfb_surface_unlock_buffer( dst_surface, lock );
+
+          D_FREE( data->common.OutDataBuffers );
+          data->common.OutDataBuffers = NULL;
+
+          return DFB_FAILURE;
+     }
+
+     direct_hash_insert( data->common.pending_commands,
+                         data->common.TransformCommand.CmdStatus.CmdId,
+                         (void *) 1 );
+     D_DEBUG_AT( JPEG_MME, "sent packet's CmdId is %u (%.8x)\n",
+                 data->common.TransformCommand.CmdStatus.CmdId,
+                 data->common.TransformCommand.CmdStatus.CmdId );
+
+     deb_gettimeofday( &data->common.starttime, NULL );
+
+     pthread_mutex_unlock( &data->common.pending_commands_lock );
+
+     return DFB_OK;
+}
+
+#if 0
+#include <../gfxdrivers/stgfx/stgfx.h>
+#include <../gfxdrivers/stgfx2/stm_gfxdriver.h>
+static STMFB_GFXMEMORY_PARTITION
+bdisp_surface_pool_get_partition( const CoreSurfacePool * const pool )
+{
+     unsigned i;
+
+     switch (dfb_system_get_accelerator()) {
+     case FB_ACCEL_ST_GAMMA:
+     case FB_ACCEL_ST_BDISP:
+          {
+          const STGFXDeviceData * const stdev = dfb_gfxcard_get_device_data();
+          for (i = 0; i < D_ARRAY_SIZE(stdev->aux_pools); ++i)
+               if (stdev->aux_pools[i] == pool)
+                    return STMFBGP_GFX0 + i;
+          }
+          break;
+
+     case FB_ACCEL_ST_BDISP_USER:
+          {
+          const STGFX2DeviceData * const stdev = dfb_gfxcard_get_device_data();
+          for (i = 0; i < D_ARRAY_SIZE(stdev->aux_pools); ++i)
+               if (stdev->aux_pools[i] == pool)
+                    return STMFBGP_GFX0 + i;
+          }
+          break;
+
+     default:
+          return STMFBGP_FRAMEBUFFER;
+     }
+
+     return STMFBGP_FRAMEBUFFER;
+}
+#endif
+
+#if 0
+static DFBResult
+jpeg_start_transformer2( IDirectFBImageProvider_JPEG_data *data,
+                         CoreSurface                      *dst_surface,
+                         CoreSurfaceBufferLock            *lock )
+{
+     DFBResult             res;
+     CoreSurfaceBufferLock raw_lock;
+     CoreSurfaceBufferLock chr_lock;
+
+
+     /* src surface */
+     CoreSurface *raw_surface;
+
+     /* FIXME: this is BAD (tm) -> think streaming media! */
+     data->common.buffer->SeekTo( data->common.buffer, 0 );
+     /* find out the length of the buffer */
+     unsigned int src_bytes;
+     data->common.buffer->GetLength( data->common.buffer, &src_bytes );
+
+     {
+     CoreSurfaceConfig config = { .size.w = src_bytes,
+                                  .size.h = 1 };
+     /* create temporary surface to store the compressed data in. */
+     config.flags = CSCONF_SIZE | CSCONF_FORMAT | CSCONF_CAPS;
+     config.format = DSPF_LUT8;
+     config.caps   = DSCAPS_VIDEOONLY;
+     #ifdef DIRECT_BUILD_DEBUG
+     config.caps   |= DSCAPS_SHARED;
+     #endif
+     if ((res = dfb_surface_create( data->common.core,
+                                    &config,
+                                    CSTF_NONE,
+                                    0,
+                                    NULL,
+                                    &raw_surface )) != DFB_OK)
+          goto out1;
+     if ((res = dfb_surface_lock_buffer( raw_surface, CSBR_BACK, CSAID_CPU,
+                                         CSAF_WRITE, &raw_lock )) != DFB_OK)
+          goto out2;
+     }
+
+     {
+     unsigned int sz;
+     u8 *addr = raw_lock.addr;
+     res = data->common.buffer->GetData( data->common.buffer,
+                                         src_bytes, addr, &sz );
+     if (sz != src_bytes)
+          goto out3;
+     printf( "src data @ %.8lx\n", lock->phys );
+     }
+     /* FIXME: this is BAD (tm) -> think streaming media! */
+     data->common.buffer->SeekTo( data->common.buffer, 0 );
+     res = dfb_surface_unlock_buffer( raw_surface, &raw_lock );
+
+
+     CoreSurface *chr_surface;
+     {
+     CoreSurfaceConfig config = { .size.w = data->common.width,
+                                  .size.h = data->common.height };
+     config.size.h += 2;
+     /* create temporary surface to store the compressed data in. */
+     config.flags = CSCONF_SIZE | CSCONF_FORMAT | CSCONF_COLORSPACE | CSCONF_CAPS;
+     config.format = DSPF_ARGB;
+     config.caps   = DSCAPS_VIDEOONLY;
+     #ifdef DIRECT_BUILD_DEBUG
+     config.caps   |= DSCAPS_SHARED;
+     #endif
+     config.colorspace = DSCS_RGB;
+     if ((res = dfb_surface_create( data->common.core,
+                                    &config,
+                                    CSTF_NONE,
+                                    0,
+                                    NULL,
+                                    &chr_surface )) != DFB_OK)
+          goto out4;
+     }
+
+
+     res = dfb_surface_lock_buffer( raw_surface,
+                                    CSBR_FRONT, CSAID_ACCEL0, CSAF_READ,
+                                    &raw_lock );
+     res = dfb_surface_lock_buffer( data->common.decode_surface,
+                                    CSBR_BACK, CSAID_ACCEL0, CSAF_WRITE,
+                                    lock );
+     res = dfb_surface_lock_buffer( chr_surface,
+                                    CSBR_BACK, CSAID_ACCEL0, CSAF_WRITE,
+                                    &chr_lock );
+
+     /* should be aligned on 256byte boundary */
+     D_ASSUME( (chr_lock.phys & 0xff) == 0 );
+     D_ASSUME( (lock->phys & 0xff) == 0 );
+     printf( "raw/dst/chr phys: 0x%.8lx 0x%.8lx 0x%.8lx\n",
+             raw_lock.phys, lock->phys, chr_lock.phys );
+
+     u32 raw_phys = raw_lock.phys;
+     u32 dst_phys = (lock->phys + 255) & 0xffffff00;
+     printf( "dst_phys %.8x\n", dst_phys );
+     u32 chr_phys = (chr_lock.phys + 255) & 0xffffff00;
+     printf( "chr_phys %.8x\n", chr_phys );
+
+     raw_phys += 0x10000000;
+     dst_phys += 0x10000000;
+     chr_phys += 0x10000000;
+
+     /* If height and width are NOT values divisible by 16 - then decode will
+        not work as expected. */
+     data->hw_decode_params.PictureStartAddr_p = (void *) raw_phys;
+     data->hw_decode_params.PictureEndAddr_p   = (void *) (raw_phys + src_bytes);
+     data->hw_decode_params.DecodedBufferAddr.Luma_p            = (void *) dst_phys;
+     data->hw_decode_params.DecodedBufferAddr.Chroma_p          = (void *) chr_phys;
+     data->hw_decode_params.DecodedBufferAddr.LumaDecimated_p   = (void *) (dst_phys + 512);
+     data->hw_decode_params.DecodedBufferAddr.ChromaDecimated_p = (void *) (chr_phys + 512);
+     data->hw_decode_params.MainAuxEnable = JPEGDECHW_MAINOUT_EN;
+     data->hw_decode_params.HorizontalDecimationFactor = JPEGDECHW_HDEC_1;
+     data->hw_decode_params.VerticalDecimationFactor   = JPEGDECHW_VDEC_1;
+     data->hw_decode_params.xvalue0 = 0;
+     data->hw_decode_params.yvalue0 = 0;
+     data->hw_decode_params.xvalue1 = 0;
+     data->hw_decode_params.yvalue1 = 0;
+     data->hw_decode_params.DecodingMode = JPEGDECHW_NORMAL_DECODE;
+     data->hw_decode_params.AdditionalFlags = JPEGDECHW_ADDITIONAL_FLAG_NONE;
+
+     data->hw_decode_params.MainAuxEnable = JPEGDECHW_AUXOUT_EN;
+     data->hw_decode_params.AdditionalFlags = 64; /* raster */
+
+     /* set up the transform command */
+     data->common.TransformCommand.StructSize = sizeof(MME_Command_t);
+     data->common.TransformCommand.CmdCode    = MME_TRANSFORM;
+     data->common.TransformCommand.CmdEnd     = MME_COMMAND_END_RETURN_NOTIFY;
+     data->common.TransformCommand.DueTime    = (MME_Time_t) 0;
+     data->common.TransformCommand.NumberInputBuffers  = 0;
+     data->common.TransformCommand.NumberOutputBuffers = 0;
+     data->common.TransformCommand.DataBuffers_p = NULL;
+     data->common.TransformCommand.ParamSize  = sizeof(data->hw_decode_params);
+     data->common.TransformCommand.Param_p    = &data->hw_decode_params;
+
+     /* init the transform command */
+     memset( &(data->common.TransformCommand.CmdStatus), 0, sizeof(MME_CommandStatus_t) );
+     data->common.TransformCommand.CmdStatus.AdditionalInfoSize = sizeof(data->hw_return_params);
+     data->common.TransformCommand.CmdStatus.AdditionalInfo_p = &data->hw_return_params;
+
+     D_DEBUG_AT( MME_DEBUG_DOMAIN, "issuing MME_TRANSFORM\n" );
+
+     /* lock access to hash, because otherwise the callback could be called
+        before we've had a chance to put the command id into the hash */
+     D_ASSERT( &data->common.pending_commands != NULL );
+     pthread_mutex_lock( &data->common.pending_commands_lock );
+
+     res = MME_SendCommand( data->common.Handle,
+                            &data->common.TransformCommand );
+     if (res != MME_SUCCESS) {
+          pthread_mutex_unlock( &data->common.pending_commands_lock );
+
+          D_WARN( "(%5d) %s: starting transformer failed: %d (%s)",
+                  direct_gettid(), data->common.name,
+                  res, get_mme_error_string( res ) );
+
+          res = DFB_FAILURE;
+
+          goto out5;
+     }
+
+     direct_hash_insert( data->common.pending_commands,
+                         data->common.TransformCommand.CmdStatus.CmdId,
+                         (void *) 1 );
+     D_DEBUG_AT( JPEG_MME, "sent packet's CmdId is %u (%.8x)\n",
+                 data->common.TransformCommand.CmdStatus.CmdId,
+                 data->common.TransformCommand.CmdStatus.CmdId );
+
+     deb_gettimeofday( &data->common.starttime, NULL );
+
+     pthread_mutex_unlock( &data->common.pending_commands_lock );
+
+
+     /* wait until the decode is complete (or until the abort was
+        acknowledged) */
+     D_DEBUG_AT( JPEG_MME, "waiting for completion\n" );
+     while ((sema_wait_event( &data->common.decode_event ) == -1)
+            && errno == EINTR)
+          ;
+     if (data->common.decode_success != 1)
+          res = DFB_FAILURE;
+
+
+     mme_helper_deinit_transformer( &data->common );
+
+
+out5:
+     dfb_surface_unlock_buffer( chr_surface, &chr_lock );
+     dfb_surface_unref( chr_surface );
+     dfb_surface_unlock_buffer( data->common.decode_surface, lock );
+
+
+out4:
+out3:
+     dfb_surface_unlock_buffer( raw_surface, &raw_lock );
+out2:
+     dfb_surface_unref( raw_surface );
+out1:
+     return res;
+}
+#endif
+
+
+static DFBResult
+JPEG_HardwareRenderTo( IDirectFBImageProvider_JPEG_data *data,
+                       CoreSurface                      *dst_surface,
+                       DFBSurfacePixelFormat             format,
+                       DFBRectangle                     *rect,
+                       const DFBRegion                  *clip )
+{
+     DFBResult              dfbret = dfbret;
+     CoreSurfaceBufferLock  lock;
+
+     D_ASSERT( data != NULL );
+     D_ASSERT( dst_surface != NULL );
+     D_ASSERT( rect != NULL );
+     D_ASSERT( clip != NULL );
+
+     CoreSurfaceConfig config;
+
+     config.size.w = pre_scaled_width( data, rect );
+     config.size.h = pre_scaled_height( data, rect );
+
+     if (unlikely (data->progressive_mode)) {
+          int src_width  = (data->common.width + 15) & ~15;
+          int src_height = (data->common.height + 15) & ~15;
+          int totalsize = data->num_components * src_width * src_height;
+          int scale;
+
+#define MAX_MEMORY_FOR_PROGRESSIVE_IMAGE  (1 * 1024 * 1024)
+          if (totalsize < MAX_MEMORY_FOR_PROGRESSIVE_IMAGE)
+               scale = 1;
+          else if (totalsize/4 < MAX_MEMORY_FOR_PROGRESSIVE_IMAGE)
+               scale = 2;
+          else if (totalsize/16 < MAX_MEMORY_FOR_PROGRESSIVE_IMAGE)
+               scale = 4;
+          else if (totalsize/64 < MAX_MEMORY_FOR_PROGRESSIVE_IMAGE)
+               scale = 8;
+          else
+               return DFB_UNSUPPORTED;
+
+          data->common.width /= scale;
+          data->common.height /= scale;
+//          data->common.width = src_width / scale;
+//          data->common.height = src_height / scale;
+
+          config.size.w = src_width / scale;
+          config.size.h = src_height / scale;
+     } else {
+          int pre_scale = pre_scale_value( data, rect );
+
+          config.size.w = pre_scaled_width( data, rect );
+          config.size.h = pre_scaled_height( data, rect );
+          data->common.width /= pre_scale;
+          data->common.height /= pre_scale;
+     }
+
+     /* FIXME: check if the image is big enough to warrant a HW decode */
+     if (!data->common.decode_surface
+         || config.size.w != data->common.decode_surface->config.size.w
+         || config.size.h != data->common.decode_surface->config.size.h) {
+          /* create destination surface to MME-decode the image onto before
+             stretchblit ... and if we can't create a surface in video memory
+             then we can't blit */
+          /* Also, decide on the decode size.
+             Limitations are:
+               - closest match to a 1/1 1/2 1/4 1/8 reduction
+               - AND a 16 pixel macroblock size. */
+          config.flags = CSCONF_SIZE | CSCONF_FORMAT | CSCONF_COLORSPACE | CSCONF_CAPS;
+          config.format = DSPF_UYVY;
+          config.colorspace = DSCS_BT601_FULLRANGE;
+#ifdef __SH4__
+          config.caps = DSCAPS_VIDEOONLY;
+#else
+          config.caps = 0;
+#endif
+          #ifdef DIRECT_BUILD_DEBUG
+          config.caps |= DSCAPS_SHARED;
+          #endif
+
+          D_DEBUG_AT( JPEG_MME, "%dx%d prescaled to %dx%d\n",
+                      rect->w, rect->h, config.size.w, config.size.h );
+
+          if (data->common.decode_surface)
+               dfb_surface_unref( data->common.decode_surface );
+
+          if (dfb_surface_create( data->common.base.core,
+                                  &config,
+                                  CSTF_NONE,
+                                  0,
+                                  NULL,
+                                  &data->common.decode_surface )) {
+               data->common.decode_surface = NULL;
+               return DFB_NOVIDEOMEMORY;
+          }
+
+          data->common.decode_success = 0;
+     }
+
+     if (data->common.decode_success <= 0) {
+          data->common.name = "hwJPEG";
+          data->common.decode_success = 0;
+
+#if 0
+          data->common.name = "hwJPEGHW";
+          {
+          static const char * const transformers[] = {
+               "JPEG_DECODER_HW1",
+               "JPEG_DECODER_HW0",
+               "JPEG_DECODER_HW4",
+               "JPEG_DECODER_HW3",
+               "JPEG_DECODER_HW2",
+               "JPEG_DECODER_HW",
+               NULL
+          };
+          unsigned int index;
+          JPEGDECHW_VideoDecodeInitParams_t init;
+          /* we should probably allocate some mme memory 2048*2048 */
+          init.CircularBufferBeginAddr_p = (JPEGDECHW_CompressedData_t) 0x00000000;
+          init.CircularBufferEndAddr_p   = (JPEGDECHW_CompressedData_t) 0xfffffff8;
+//          init.CircularBufferBeginAddr_p = 0;
+//          init.CircularBufferEndAddr_p   = 0;
+          dfbret = mme_helper_init_transformer2( &data->common, transformers,
+                                                 sizeof(init), &init, &index,
+                                                 &TransformerCallback );
+          if (dfbret != DFB_OK)
+               goto cont;
+
+          MME_TransformerCapability_t cap;
+          _mme_helper_get_capability( &data->common,
+                                      transformers[index], &cap );
+
+          if (data->flags & DIPFLAGS_BACKGROUND_DECODE)
+               direct_thread_set_name( transformers[index] );
+
+          /* store the current data buffer position for software fallback
+             should we not succeed */
+          unsigned int bufpos;
+          data->common.buffer->GetPosition( data->common.buffer, &bufpos );
+
+          sema_init_event( &data->common.decode_event, 0 );
+
+          /* Tell the transformer what to do and where to put result.
+             Depending on dst - may need to consider pitch! */
+          dfbret = jpeg_start_transformer2( data, data->common.decode_surface,
+                                            &lock );
+          goto stretch;
+          }
+
+cont: ;
+#endif
+
+          static const char * const transformers[] = {
+               JPEGDEC_MME_TRANSFORMER_NAME"0",
+               JPEGDEC_MME_TRANSFORMER_NAME"1",
+               JPEGDEC_MME_TRANSFORMER_NAME"2",
+               JPEGDEC_MME_TRANSFORMER_NAME"3",
+               JPEGDEC_MME_TRANSFORMER_NAME"4",
+               JPEGDEC_MME_TRANSFORMER_NAME,
+               NULL
+          };
+          unsigned int index;
+          dfbret = mme_helper_init_transformer( &data->common, transformers,
+                                                0, NULL, &index );
+          if (dfbret == DFB_OK) {
+               MME_TransformerCapability_t cap;
+               _mme_helper_get_capability( &data->common,
+                                           transformers[index], &cap );
+
+#if 0
+               if (cap.Version != 2) {
+                    /* incompatible with old transformer, it has just way too
+                       many bugs! */
+                    mme_helper_deinit_transformer( &data->common );
+                    dfbret = DFB_FAILURE;
+                    continue;
+               }
+
+               data->common.transformer_name = *transformers[transformer_index];
+               if (data->flags & DIPFLAGS_BACKGROUND_DECODE)
+                    direct_thread_set_name( *transformers[transformer_index] );
+
+               break;
+#endif
+          }
+
+          if (dfbret == DFB_OK) {
+               bool locked = false;
+
+               data->common.transformer_name = transformers[index];
+               if (data->flags & DIRENDER_BACKGROUND)
+                    direct_thread_set_name( transformers[index] );
+
+               /* store the current data buffer position for software
+                  fallback should we not succeed */
+               unsigned int bufpos;
+               data->common.base.buffer->GetPosition( data->common.base.buffer,
+                                                      &bufpos );
+
+               sema_init_event( &data->common.decode_event, 0 );
+
+               /* Tell the transformer what to do and where to put result.
+                  Depending on dst - may need to consider pitch! */
+               dfbret = jpeg_start_transformer( data,
+                                                data->common.decode_surface,
+                                                &lock );
+               if (dfbret == DFB_OK) {
+                    locked = true;
+
+                    D_DEBUG_AT( JPEG_MME,
+                                "Transform sent, sending data buffers now\n" );
+
+                    mme_helper_calculate_packets( &data->common );
+                    dfbret = mme_helper_send_packets( &data->common, -1 );
+                    if (dfbret != DFB_OK) {
+                         D_DEBUG_AT( JPEG_MME,
+                                     "aborting (main) transform command %u (%.8x)\n",
+                                     data->common.TransformCommand.CmdStatus.CmdId,
+                                     data->common.TransformCommand.CmdStatus.CmdId );
+                         MME_ERROR res = MME_AbortCommand( data->common.Handle,
+                                                           data->common.TransformCommand.CmdStatus.CmdId );
+                         if (res != MME_SUCCESS)
+                              D_WARN( "(%5d) MME_AbortCommand(%x, %.8x) for %s failed: %d (%s)\n",
+                                      direct_gettid(), data->common.Handle,
+                                      data->common.TransformCommand.CmdStatus.CmdId,
+                                      data->common.name,
+                                      res, get_mme_error_string( res ) );
+                    }
+
+                    /* wait until the decode is complete (or until the abort
+                       was acknowledged) */
+                    D_DEBUG_AT( JPEG_MME, "waiting for completion\n" );
+                    while ((sema_wait_event( &data->common.decode_event ) == -1)
+                           && errno == EINTR)
+                         ;
+                    if (data->common.decode_success != 1)
+                         dfbret = DFB_FAILURE;
+               } else {
+                    if (data->common.decode_success < 0)
+                         dfbret = DFB_FAILURE;
+                    D_DEBUG_AT( JPEG_MME, "couldn't start transformer\n" );
+               }
+
+               /* we always get an underflow on startup at the moment - update
+                  the value so only interesting underflow get printed ... */
+               if (data->common.n_underflows)
+                    --data->common.n_underflows;
+
+               abort_transformer( &data->common );
+               /* wait till all commands are aborted and acknowledged */
+               while (data->common.n_pending_buffers
+                      || direct_hash_lookup( data->common.pending_commands,
+                                             data->common.TransformCommand.CmdStatus.CmdId ))
+                    usleep( 1 );
+
+               mme_helper_deinit_transformer( &data->common );
+
+               if (likely (locked))
+                    dfb_surface_unlock_buffer( data->common.decode_surface,
+                                               &lock );
+
+               if (data->common.OutDataBuffers) {
+                    D_FREE( data->common.OutDataBuffers );
+                    data->common.OutDataBuffers = NULL;
+               }
+
+               unsigned int i;
+               for (i = 0; i < D_ARRAY_SIZE(data->common.SendDataBuffers); ++i) {
+                    if (data->common.SendDataBuffers[i].buffer) {
+                         MME_FreeDataBuffer( data->common.SendDataBuffers[i].buffer );
+                         data->common.SendDataBuffers[i].buffer = NULL;
+
+                         sema_close_event( &data->common.SendDataBuffers[i].sema );
+                    }
+               }
+
+               sema_close_event( &data->common.decode_event );
+
+               data->common.base.buffer->SeekTo( data->common.base.buffer,
+                                                 bufpos );
+          } else {
+               D_ASSUME( data->common.decode_surface != NULL );
+               dfb_surface_unref( data->common.decode_surface );
+               data->common.decode_surface = NULL;
+          }
+     }
+
+     if (data->common.decode_success == 1) {
+          /* stretch blit the decoded image to the destination surface and
+             size */
+          mme_helper_stretch_blit( &data->common, data->common.decode_surface,
+                                   dst_surface, rect );
+          dfbret = DFB_OK;
+     } else {
+          if (data->common.decode_surface)
+               dfb_surface_unref( data->common.decode_surface );
+          data->common.decode_surface = NULL;
+     }
+
+     return dfbret;
+}
+#endif /* JPEG_PROVIDER_USE_MME */
diff -Naur DirectFB-1.7.7/interfaces/IDirectFBImageProvider/idirectfbimageprovider_jpeg.h DirectFB-1.7.7.stm/interfaces/IDirectFBImageProvider/idirectfbimageprovider_jpeg.h
--- DirectFB-1.7.7/interfaces/IDirectFBImageProvider/idirectfbimageprovider_jpeg.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7.stm/interfaces/IDirectFBImageProvider/idirectfbimageprovider_jpeg.h	2015-05-15 18:43:40.069387074 +0200
@@ -0,0 +1,113 @@
+#ifndef __IDIRECTFBIMAGEPROVIDER_JPEG_H__
+#define __IDIRECTFBIMAGEPROVIDER_JPEG_H__
+
+#if defined(JPEG_PROVIDER_USE_MME)
+/* HW Decode Requirements */
+#include <mme.h>
+#include <semaphore.h>
+
+#include <JPEG_VideoTransformerTypes.h>
+//#include <JPEGDECHW_VideoTransformerTypes.h>
+#endif /* JPEG_PROVIDER_USE_MME */
+
+/* The following define controls prescaling
+ *
+ * PRE_SCALE_QUALITY_OPTIMISED : Better Quality
+ * When defined pre-scale will scale to larger than the requested
+ * size and use the blitter to reduce down.
+ * - This option will take precedence if both options are defined.
+ *
+ * PRE_SCALE_SPACE_OPTIMISED : Faster and Less Memory
+ * When defined pre-scale will scale below requested size, and
+ * use the blitter to enlarge
+ *
+ * Removing both defines will safely disable the pre-scaler
+ */
+#define PRE_SCALE_QUALITY_OPTIMISED
+//#define PRE_SCALE_SPEED_SPACE_OPTIMISED
+
+
+
+/* private data struct of IDirectFBImageProvider_JPEG */
+typedef struct
+{
+  /* hardware decode specifics */
+  struct _MMECommon common;
+
+  DFBRectangle      rect;
+  DFBRegion         clip;
+
+  /* thread stuff */
+  DIRenderFlags     flags;
+  pthread_mutex_t   lock;
+  pthread_cond_t    cond;
+  DirectThread     *thread;
+  IDirectFBSurface *destination;
+  DFBResult         thread_res;
+
+#if defined(JPEG_PROVIDER_USE_MME)
+  int  num_components;
+  bool progressive_mode;
+
+  JPEGDEC_TransformParams_t       OutputParams;
+  JPEGDEC_TransformReturnParams_t ReturnParams;
+
+//  JPEGDECHW_VideoDecodeParams_t       hw_decode_params;
+//  JPEGDECHW_VideoDecodeReturnParams_t hw_return_params;
+#endif /* JPEG_PROVIDER_USE_MME */
+} IDirectFBImageProvider_JPEG_data;
+
+
+#if defined(JPEG_PROVIDER_USE_MME)
+static inline const char *
+get_jpeg_error_string (unsigned int e)
+{
+  static const char *JpegErrorType_strings[] = {
+    "Successfully Decoded", /* JPEG_NO_ERROR */
+    "UNDEFINED_HUFF_TABLE",
+    "UNSUPPORTED_MARKER",
+    "UNABLE_ALLOCATE_MEMORY",
+    "NON_SUPPORTED_SAMP_FACTORS",
+    "BAD_PARAMETER",
+    "DECODE_ERROR",
+    "BAD_RESTART_MARKER",
+    "UNSUPPORTED_COLORSPACE",
+    "BAD_SOS_SPECTRAL",
+    "BAD_SOS_SUCCESSIVE",
+    "BAD_HEADER_LENGTH",
+    "BAD_COUNT_VALUE",
+    "BAD_DHT_MARKER",
+    "BAD_INDEX_VALUE",
+    "BAD_NUMBER_HUFFMAN_TABLES",
+    "BAD_QUANT_TABLE_LENGHT",
+    "BAD_NUMBER_QUANT_TABLES",
+    "BAD_COMPONENT_COUNT",
+    "DIVIDE_BY_ZERO_ERROR",
+    "NOT_JPG_IMAGE",
+    "UNSUPPORTED_ROTATION_ANGLE",
+    "UNSUPPORTED_SCALING",
+    "INSUFFICIENT_OUTPUTBUFFER_SIZE"
+  };
+
+  return ((e < D_ARRAY_SIZE (JpegErrorType_strings))
+          ? JpegErrorType_strings[e]
+          : "* Unknown JpegError code *");
+}
+
+static inline const char *
+get_jpeghw_error_string (unsigned int e)
+{
+  static const char *JpegHWErrorType_strings[] = {
+    "Successfully Decoded", /* JPEG_DECODER_NO_ERROR */
+    "", "", "", "", "", "", "", "",
+    "JPEG_DECODER_ERROR_TASK_TIMEOUT"
+  };
+
+  return ((e < D_ARRAY_SIZE (JpegHWErrorType_strings))
+          ? JpegHWErrorType_strings[e]
+          : "* Unknown JpegHWError code *");
+}
+#endif /* JPEG_PROVIDER_USE_MME */
+
+
+#endif /* __IDIRECTFBIMAGEPROVIDER_JPEG_H__ */
diff -Naur DirectFB-1.7.7/interfaces/IDirectFBImageProvider/idirectfbimageprovider_png.c DirectFB-1.7.7.stm/interfaces/IDirectFBImageProvider/idirectfbimageprovider_png.c
--- DirectFB-1.7.7/interfaces/IDirectFBImageProvider/idirectfbimageprovider_png.c	2013-12-19 01:16:24.000000000 +0100
+++ DirectFB-1.7.7.stm/interfaces/IDirectFBImageProvider/idirectfbimageprovider_png.c	2015-05-15 18:43:40.077395075 +0200
@@ -1,6 +1,8 @@
 /*
    (c) Copyright 2012-2013  DirectFB integrated media GmbH
    (c) Copyright 2001-2013  The world wide DirectFB Open Source Community (directfb.org)
+   (c) Copyright 2006-2010  ST Microelectronics R&D
+
    (c) Copyright 2000-2004  Convergence (integrated media) GmbH
 
    All rights reserved.
@@ -65,10 +67,40 @@
 #include <direct/interface.h>
 #include <direct/mem.h>
 #include <direct/memcpy.h>
+#include <direct/thread.h>
 #include <direct/messages.h>
 #include <direct/util.h>
 
-#include "config.h"
+#if !defined(PNG_PROVIDER_USE_MME)
+#undef USE_MME
+#endif
+
+
+#include "debug_helper.h"
+
+D_DEBUG_DOMAIN (HWPNG,      "PNG",      "STM MME-based PNG decoder");
+D_DEBUG_DOMAIN (HWPNG_MME,  "PNG/MME",  "STM MME-based PNG decoder (MME)");
+D_DEBUG_DOMAIN (HWPNG_SEMA, "PNG/SEMA", "STM MME-based PNG decoder (semaphores");
+D_DEBUG_DOMAIN (HWPNG_TIME, "PNG/Time", "STM MME-based PNG decoder (timing");
+#define MME_DEBUG_DOMAIN  HWPNG_MME
+#define SEMA_DEBUG_DOMAIN HWPNG_SEMA
+#define MME_TEXT_DOMAIN "PNG"
+
+#define fetch_data   buffer_to_mme_copy
+#include "mme_helper.h"
+#include "idirectfbimageprovider_png.h"
+#if defined(PNG_PROVIDER_USE_MME)
+#include "sema_helper.h"
+static DFBResult PNG_HardwareRenderTo( IDirectFBImageProvider_PNG_data *data,
+                                       CoreSurface                     *dst_surface,
+                                       DFBSurfacePixelFormat            format,
+                                       DFBRectangle                    *rect,
+                                       const DFBRegion                 *clip );
+#else /* PNG_PROVIDER_USE_MME */
+#define PNG_HardwareRenderTo(data,dst_surface, \
+                             format, rect, clip) DFB_NOSUCHINSTANCE
+#endif /* PNG_PROVIDER_USE_MME */
+
 
 D_DEBUG_DOMAIN( imageProviderPNG,  "ImageProvider/PNG",  "libPNG based image decoder" );
 
@@ -86,8 +118,11 @@
 
 #include <direct/interface_implementation.h>
 
-DIRECT_INTERFACE_IMPLEMENTATION( IDirectFBImageProvider, PNG )
-
+#if defined(PNG_PROVIDER_USE_MME)
+DIRECT_INTERFACE_IMPLEMENTATION( IDirectFBImageProvider, hwPNG )
+#else /* PNG_PROVIDER_USE_MME */
+DIRECT_INTERFACE_IMPLEMENTATION( IDirectFBImageProvider, swPNG )
+#endif /* PNG_PROVIDER_USE_MME */
 
 enum {
      STAGE_ABORT = -2,
@@ -98,31 +133,10 @@
      STAGE_END
 };
 
-/*
- * private data struct of IDirectFBImageProvider_PNG
- */
-typedef struct {
-     IDirectFBImageProvider_data base;
-
-     int                  stage;
-     int                  rows;
-
-     png_structp          png_ptr;
-     png_infop            info_ptr;
-
-     png_int_32           width;
-     png_int_32           height;
-     int                  bpp;
-     int                  color_type;
-     png_uint_32          color_key;
-     bool                 color_keyed;
-
-     void                *image;
-     int                  pitch;
-     u32                  palette[256];
-     DFBColor             colors[256];
-} IDirectFBImageProvider_PNG_data;
 
+static DFBResult
+IDirectFBImageProvider_PNG_SetRenderFlags ( IDirectFBImageProvider *thiz,
+                                            DIRenderFlags           flags );
 
 static DFBResult
 IDirectFBImageProvider_PNG_RenderTo( IDirectFBImageProvider *thiz,
@@ -130,6 +144,10 @@
                                      const DFBRectangle     *destination_rect );
 
 static DFBResult
+IDirectFBImageProvider_PNG_Sync( IDirectFBImageProvider    *thiz,
+                                 DFBImageProviderSyncFlags  flags );
+
+static DFBResult
 IDirectFBImageProvider_PNG_GetSurfaceDescription( IDirectFBImageProvider *thiz,
                                                   DFBSurfaceDescription  *dsc );
 
@@ -137,6 +155,10 @@
 IDirectFBImageProvider_PNG_GetImageDescription( IDirectFBImageProvider *thiz,
                                                 DFBImageDescription    *dsc );
 
+static void *
+PNGrenderThread( DirectThread *thread, void *driver_data );
+
+
 /* Called at the start of the progressive load, once we have image info */
 static void
 png_info_callback (png_structp png_read_ptr,
@@ -169,11 +191,31 @@
      IDirectFBImageProvider_PNG_data *data =
                               (IDirectFBImageProvider_PNG_data*)thiz->priv;
 
-     png_destroy_read_struct( &data->png_ptr, &data->info_ptr, NULL );
+     if (data->thread) {
+          /* terminate the decoding thread, if necessary... */
+          direct_thread_cancel( data->thread );
+          direct_thread_join( data->thread );
+          direct_thread_destroy( data->thread );
+
+          pthread_mutex_destroy( &data->lock );
+          pthread_cond_destroy( &data->cond );
+     }
+
+     if (data->png_ptr) {
+          png_destroy_read_struct( &data->png_ptr, &data->info_ptr, NULL );
+          data->png_ptr = NULL;
+     }
 
      /* Deallocate image data. */
-     if (data->image)
-          D_FREE( data->image );
+     if (data->common.image)
+          D_FREE( data->common.image );
+
+#if defined(PNG_PROVIDER_USE_MME)
+     if (data->common.decode_surface) {
+          dfb_gfxcard_wait_serial( &data->common.serial );
+          dfb_surface_unref( data->common.decode_surface );
+     }
+#endif
 }
 
 /**********************************************************************************************************************/
@@ -206,9 +248,9 @@
      core = va_arg( tag, CoreDFB * );
      va_end( tag );
 
-     data->base.ref    = 1;
-     data->base.buffer = buffer;
-     data->base.core   = core;
+     data->common.base.ref    = 1;
+     data->common.base.buffer = buffer;
+     data->common.base.core   = core;
 
      /* Increase the data buffer reference counter. */
      buffer->AddRef( buffer );
@@ -235,15 +277,16 @@
                                   png_row_callback,
                                   png_end_callback );
 
-
      /* Read until info callback is called. */
      ret = push_data_until_stage( data, STAGE_INFO, 64 );
      if (ret)
           goto error;
 
-     data->base.Destruct = IDirectFBImageProvider_PNG_Destruct;
+     data->common.base.Destruct = IDirectFBImageProvider_PNG_Destruct;
 
+     thiz->SetRenderFlags        = IDirectFBImageProvider_PNG_SetRenderFlags;
      thiz->RenderTo              = IDirectFBImageProvider_PNG_RenderTo;
+     thiz->Sync                  = IDirectFBImageProvider_PNG_Sync;
      thiz->GetImageDescription   = IDirectFBImageProvider_PNG_GetImageDescription;
      thiz->GetSurfaceDescription = IDirectFBImageProvider_PNG_GetSurfaceDescription;
 
@@ -255,8 +298,8 @@
 
      buffer->Release( buffer );
 
-     if (data->image)
-          D_FREE( data->image );
+     if (data->common.image)
+          D_FREE( data->common.image );
 
      DIRECT_DEALLOCATE_INTERFACE(thiz);
 
@@ -266,53 +309,66 @@
 /**********************************************************************************************************************/
 
 static DFBResult
-IDirectFBImageProvider_PNG_RenderTo( IDirectFBImageProvider *thiz,
-                                     IDirectFBSurface       *destination,
-                                     const DFBRectangle     *dest_rect )
+IDirectFBImageProvider_PNG_SetRenderFlags( IDirectFBImageProvider *thiz,
+                                           DIRenderFlags           flags )
 {
-     DFBResult              ret = DFB_OK;
-     IDirectFBSurface_data *dst_data;
-     CoreSurface           *dst_surface;
-     DFBRegion              clip;
-     DFBRectangle           rect;
-     int                    x, y;
-     DFBRectangle           clipped;
-
-     DIRECT_INTERFACE_GET_DATA (IDirectFBImageProvider_PNG)
-
-     D_DEBUG_AT( imageProviderPNG, "%s(%d)\n", __FUNCTION__, __LINE__ );
+     DIRECT_INTERFACE_GET_DATA(IDirectFBImageProvider_PNG)
 
-     dst_data = (IDirectFBSurface_data*) destination->priv;
-     if (!dst_data)
-          return DFB_DEAD;
+     /* if we have decoded the image already, don't do anything... */
+     if (data->common.image
+#if defined(PNG_PROVIDER_USE_MME)
+         || data->common.decode_surface
+#endif /* PNG_PROVIDER_USE_MME */
+        )
+          return DFB_UNSUPPORTED;
+
+     if (!(flags & DIRENDER_NONE) && data->thread) {
+          /* terminate the decoding thread, if necessary... */
+          direct_thread_cancel( data->thread );
+          direct_thread_join( data->thread );
+          direct_thread_destroy( data->thread );
+          data->thread = NULL;
 
-     dst_surface = dst_data->surface;
-     if (!dst_surface)
-          return DFB_DESTROYED;
+          pthread_cond_destroy( &data->cond );
+          pthread_mutex_destroy( &data->lock );
+     }
+     else if (flags & DIRENDER_BACKGROUND && !data->thread) {
+          /* or create it */
+          pthread_cond_init( &data->cond, NULL );
+          pthread_mutex_init( &data->lock, NULL );
+          /* as long as we haven't even started yet, we are in INIT state */
+          data->thread_res = DFB_INIT;
+          data->thread = direct_thread_create( DTT_DEFAULT, PNGrenderThread,
+                                               thiz, "PNG_DECODER?" );
+     }
 
-     D_DEBUG_AT( imageProviderPNG, "  -> dst_surface %s\n", ToString_CoreSurface(dst_surface) );
+     data->flags = flags;
 
-     dfb_region_from_rectangle( &clip, &dst_data->area.current );
+     return DFB_OK;
+}
 
-     if (dest_rect) {
-          D_DEBUG_AT( imageProviderPNG, "  -> dest_rect %4d,%4d-%4dx%4d\n", DFB_RECTANGLE_VALS(dest_rect) );
 
-          if (dest_rect->w < 1 || dest_rect->h < 1)
-               return DFB_INVARG;
-          rect = *dest_rect;
+static DFBResult
+PNG_SoftwareRenderTo( IDirectFBImageProvider_PNG_data *data,
+                      CoreSurface                     *dst_surface,
+                      DFBSurfacePixelFormat            format,
+                      DFBRectangle                    *rect,
+                      const DFBRegion                 *clip )
+{
 
-          if (dst_data->area.wanted.x || dst_data->area.wanted.y) {
-               rect.x += dst_data->area.wanted.x;
-               rect.y += dst_data->area.wanted.y;
+     DFBResult    ret = DFB_OK;
+     png_infop    info;
+     int          x, y;
+     DFBRectangle clipped;
+
+     D_ASSERT( data != NULL );
+     D_ASSERT( dst_surface != NULL );
+     D_ASSERT( clip != NULL );
+     D_ASSERT( rect != NULL );
 
-               D_DEBUG_AT( imageProviderPNG, "  -> dest_rect %4d,%4d-%4dx%4d\n", DFB_RECTANGLE_VALS(&rect) );
-          }
-     }
-     else {
-          rect = dst_data->area.wanted;
+     D_DEBUG_AT(imageProviderPNG,"%s(%d)\n",__FUNCTION__,__LINE__);
 
-          D_DEBUG_AT( imageProviderPNG, "  -> dest_rect %4d,%4d-%4dx%4d (from dst)\n", DFB_RECTANGLE_VALS(&rect) );
-     }
+     info = data->info_ptr;
 
      if (setjmp( png_jmpbuf(data->png_ptr) )) {
           D_ERROR( "ImageProvider/PNG: Error during decoding!\n" );
@@ -330,27 +386,23 @@
                return ret;
      }
 
-     clipped = rect;
+     clipped = *rect;
 
-     D_DEBUG_AT( imageProviderPNG, "  -> clip      %4d,%4d-%4dx%4d\n", DFB_RECTANGLE_VALS_FROM_REGION(&clip) );
-
-     if (!dfb_rectangle_intersect_by_region( &clipped, &clip ))
+     if (!dfb_rectangle_intersect_by_region( &clipped, clip ))
           return DFB_INVAREA;
 
-     D_DEBUG_AT( imageProviderPNG, "  -> clipped   %4d,%4d-%4dx%4d\n", DFB_RECTANGLE_VALS(&clipped) );
-
      /* actual rendering */
      if (0    &&   // FIXME
-           rect.w == data->width && rect.h == data->height &&
+           rect->w == data->common.width && rect->h == data->common.height &&
          (data->color_type == PNG_COLOR_TYPE_RGB || data->color_type == PNG_COLOR_TYPE_RGBA) &&
          (dst_surface->config.format == DSPF_RGB32 || dst_surface->config.format == DSPF_ARGB) &&
          !(dst_surface->config.caps & DSCAPS_PREMULTIPLIED))
      {
           //ret = dfb_surface_write_buffer( dst_surface, CSBR_BACK,
-          //                                data->image +
-          //                                   (clipped.x - rect.x) * 4 +
-          //                                   (clipped.y - rect.y) * data->width * 4,
-          //                                data->width * 4, &clipped );
+          //                                data->common.image +
+          //                                   (clipped.x - rect->x) * 4 +
+          //                                   (clipped.y - rect->y) * data->common.width * 4,
+          //                                data->common.width * 4, &clipped );
      }
      else {
           CoreSurfaceBufferLock lock;
@@ -369,17 +421,17 @@
                           */
 
                          /* FIXME: Limitation for LUT8 is to load complete surface only. */
-                         dfb_clip_rectangle( &clip, &rect );
-                         if (rect.x == 0 && rect.y == 0 &&
-                             rect.w == dst_surface->config.size.w  &&
-                             rect.h == dst_surface->config.size.h &&
-                             rect.w == data->width         &&
-                             rect.h == data->height)
+                         dfb_clip_rectangle( clip, rect );
+                         if (rect->x == 0 && rect->y == 0 &&
+                             rect->w == dst_surface->config.size.w  &&
+                             rect->h == dst_surface->config.size.h &&
+                             rect->w == data->common.width         &&
+                             rect->h == data->common.height)
                          {
-                              for (y = 0; y < data->height; y++)
+                              for (y = 0; y < data->common.height; y++)
                                    direct_memcpy( (u8*)lock.addr + lock.pitch * y,
-                                                  (u8*)data->image + data->pitch * y,
-                                                  data->width );
+                                                  (u8*)data->common.image + data->pitch * y,
+                                                  data->common.width );
 
                               break;
                          }
@@ -396,15 +448,15 @@
                          for (x = 0; x < 256; x++)
                               data->palette[x] = 0xff000000 | (x << 16) | (x << 8) | x;
 
-                         dfb_scale_linear_32( data->image, data->width, data->height,
-                                              lock.addr, lock.pitch, &rect, dst_surface, &clip );
+                         dfb_scale_linear_32( data->common.image, data->common.width, data->common.height,
+                                              lock.addr, lock.pitch, rect, dst_surface, clip );
                          break;
                     }
 
                     // FIXME: allocates four additional bytes because the scaling functions
                     //        in src/misc/gfx_util.c have an off-by-one bug which causes
                     //        segfaults on darwin/osx (not on linux)
-                    int size = data->width * data->height * 4 + 4;
+                    int size = data->common.width * data->common.height * 4 + 4;
 
                     /* allocate image data */
                     void *image_argb = D_MALLOC( size );
@@ -427,21 +479,21 @@
 
                          switch (bit_depth) {
                               case 8:
-                                   for (y = 0; y < data->height; y++) {
-                                        u8  *S = (u8*)data->image + data->pitch * y;
-                                        u32 *D = (u32*)((u8*)image_argb  + data->width * y * 4);
+                                   for (y = 0; y < data->common.height; y++) {
+                                        u8  *S = (u8*)data->common.image + data->pitch * y;
+                                        u32 *D = (u32*)((u8*)image_argb  + data->common.width * y * 4);
 
-                                        for (x = 0; x < data->width; x++)
+                                        for (x = 0; x < data->common.width; x++)
                                              D[x] = data->palette[ S[x] ];
                                    }
                                    break;
 
                               case 4:
-                                   for (y = 0; y < data->height; y++) {
-                                        u8  *S = (u8*)data->image + data->pitch * y;
-                                        u32 *D = (u32*)((u8*)image_argb  + data->width * y * 4);
+                                   for (y = 0; y < data->common.height; y++) {
+                                        u8  *S = (u8*)data->common.image + data->pitch * y;
+                                        u32 *D = (u32*)((u8*)image_argb  + data->common.width * y * 4);
 
-                                        for (x = 0; x < data->width; x++) {
+                                        for (x = 0; x < data->common.width; x++) {
                                              if (x & 1)
                                                   D[x] = data->palette[ S[x>>1] & 0xf ];
                                              else
@@ -451,12 +503,12 @@
                                    break;
 
                               case 2:
-                                   for (y = 0; y < data->height; y++) {
+                                   for (y = 0; y < data->common.height; y++) {
                                         int  n = 6;
-                                        u8  *S = (u8*)data->image + data->pitch * y;
-                                        u32 *D = (u32*)((u8*)image_argb  + data->width * y * 4);
+                                        u8  *S = (u8*)data->common.image + data->pitch * y;
+                                        u32 *D = (u32*)((u8*)image_argb  + data->common.width * y * 4);
 
-                                        for (x = 0; x < data->width; x++) {
+                                        for (x = 0; x < data->common.width; x++) {
                                              D[x] = data->palette[ (S[x>>2] >> n) & 3 ];
 
                                              n = (n ? n - 2 : 6);
@@ -465,12 +517,12 @@
                                    break;
 
                               case 1:
-                                   for (y = 0; y < data->height; y++) {
+                                   for (y = 0; y < data->common.height; y++) {
                                         int  n = 7;
-                                        u8  *S = (u8*)data->image + data->pitch * y;
-                                        u32 *D = (u32*)((u8*)image_argb  + data->width * y * 4);
+                                        u8  *S = (u8*)data->common.image + data->pitch * y;
+                                        u32 *D = (u32*)((u8*)image_argb  + data->common.width * y * 4);
 
-                                        for (x = 0; x < data->width; x++) {
+                                        for (x = 0; x < data->common.width; x++) {
                                              D[x] = data->palette[ (S[x>>3] >> n) & 1 ];
 
                                              n = (n ? n - 1 : 7);
@@ -483,19 +535,20 @@
                                             bit_depth );
                          }
 
-                         dfb_scale_linear_32( image_argb, data->width, data->height,
-                                              lock.addr, lock.pitch, &rect, dst_surface, &clip );
+                         dfb_scale_linear_32( image_argb, data->common.width, data->common.height,
+                                              lock.addr, lock.pitch, rect, dst_surface, clip );
 
                          D_FREE( image_argb );
                     }
                     break;
                }
+
                default:
                     /*
                      * Generic loading code.
                      */
-                    dfb_scale_linear_32( data->image, data->width, data->height,
-                                         lock.addr, lock.pitch, &rect, dst_surface, &clip );
+                    dfb_scale_linear_32( data->common.image, data->common.width, data->common.height,
+                                         lock.addr, lock.pitch, rect, dst_surface, clip );
                     break;
           }
 
@@ -508,6 +561,164 @@
      return ret;
 }
 
+
+static DFBResult
+PNG_RenderTo( IDirectFBImageProvider_PNG_data *data,
+              CoreSurface                     *dst_surface,
+              DFBSurfacePixelFormat            format,
+              DFBRectangle                    *rect,
+              const DFBRegion                 *clip )
+{
+     DFBResult res;
+
+     D_ASSERT( data != NULL );
+     D_ASSERT( dst_surface != NULL );
+     D_ASSERT( clip != NULL );
+     D_ASSERT( rect != NULL );
+
+     res = PNG_HardwareRenderTo (data, dst_surface, format, rect, clip);
+     if (res != DFB_OK) {
+          if (unlikely (res == DFB_IO)) {
+               /* IO error - there's no point in retrying */
+               D_DEBUG_AT (HWPNG, "hardware decode failed: %d (%s)\n",
+                           res, DirectFBErrorString (res));
+               return res;
+          }
+
+          if (res == DFB_UNSUPPORTED)
+               D_DEBUG_AT (HWPNG, "doing software decode since it's faster "
+                           "than hardware for this image\n");
+          else
+               D_DEBUG_AT (HWPNG, "hardware decode failed: %d (%s) - "
+                           "attempting software fallback\n",
+                           res, DirectFBErrorString (res));
+
+          res = PNG_SoftwareRenderTo (data, dst_surface, format, rect, clip);
+          if (unlikely (res != DFB_OK))
+               D_DEBUG_AT (HWPNG, "software decode failed: %d (%s)\n",
+                           res, DirectFBErrorString (res));
+     }
+
+     return res;
+}
+
+static DFBResult
+IDirectFBImageProvider_PNG_RenderTo( IDirectFBImageProvider *thiz,
+                                     IDirectFBSurface       *destination,
+                                     const DFBRectangle     *dest_rect )
+{
+     IDirectFBSurface_data *dst_data;
+     CoreSurface           *dst_surface;
+     DFBSurfacePixelFormat  format;
+     DFBResult              ret;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBImageProvider_PNG)
+
+     dst_data = (IDirectFBSurface_data*) destination->priv;
+     if (!dst_data)
+          return DFB_DEAD;
+
+     dst_surface = dst_data->surface;
+     if (!dst_surface)
+          return DFB_DESTROYED;
+
+     ret = destination->GetPixelFormat( destination, &format );
+     if (ret)
+          return ret;
+
+     if (data->thread)
+          pthread_mutex_lock( &data->lock );
+
+     dfb_region_from_rectangle( &data->clip, &dst_data->area.current );
+
+     if (dest_rect) {
+          if (dest_rect->w < 1 || dest_rect->h < 1) {
+               if (data->thread)
+                    pthread_mutex_unlock (&data->lock);
+               return DFB_INVARG;
+          }
+
+          data->rect = *dest_rect;
+          data->rect.x += dst_data->area.wanted.x;
+          data->rect.y += dst_data->area.wanted.y;
+     }
+     else {
+          data->rect = dst_data->area.wanted;
+     }
+
+     if (!D_FLAGS_IS_SET (data->flags, DIRENDER_BACKGROUND)) {
+          /* threaded operation was not requested */
+          data->thread_res = PNG_RenderTo( data, dst_surface, format,
+                                           &data->rect, &data->clip );
+          if (data->thread)
+               pthread_mutex_unlock( &data->lock );
+          return data->thread_res;
+     }
+
+     if (!data->thread) {
+          /* for the case that somebody does a RenderTo() twice on us, we
+             have to create new thread, because the initial thread will have
+             finished already */
+
+          D_ASSERT( data->destination == NULL );
+
+          /* as long as we haven't even started yet, we are in INIT state */
+          data->thread_res = DFB_INIT;
+          data->thread = direct_thread_create( DTT_DEFAULT, PNGrenderThread,
+                                               thiz, "PNG" );
+     }
+
+     D_ASSERT( data->destination == NULL );
+
+     destination->AddRef( destination );
+     data->destination = destination;
+
+     pthread_cond_signal( &data->cond );
+     pthread_mutex_unlock( &data->lock );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBImageProvider_PNG_Sync( IDirectFBImageProvider    *thiz,
+                                 DFBImageProviderSyncFlags  flags )
+{
+     DFBResult res;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBImageProvider_PNG)
+
+     switch (flags)
+       {
+       case DIPSYNCFLAGS_TRYSYNC:
+            if (data->thread) {
+                 if (data->thread_res == DFB_INIT
+                     || data->thread_res == DFB_BUSY) {
+                      /* DFB_INIT (user didn't call RenderTo() yet)
+                         DFB_BUSY (still busy decoding) */
+                      return data->thread_res;
+                 }
+                 /* else we are done, either because of some error or because
+                    we have processed all the data already */
+            }
+            /* fall through */
+
+       case DIPSYNCFLAGS_SYNC:
+            if (data->thread) {
+                 direct_thread_join( data->thread );
+                 direct_thread_destroy( data->thread );
+                 data->thread = NULL;
+            }
+            break;
+
+       default:
+            return DFB_OK;
+       }
+
+     res = data->thread_res;
+     data->thread_res = DFB_OK;
+     return res;
+}
+
 static DFBResult
 IDirectFBImageProvider_PNG_GetSurfaceDescription( IDirectFBImageProvider *thiz,
                                                   DFBSurfaceDescription  *dsc )
@@ -517,18 +728,13 @@
      DIRECT_INTERFACE_GET_DATA (IDirectFBImageProvider_PNG)
 
      dsc->flags  = DSDESC_WIDTH | DSDESC_HEIGHT | DSDESC_PIXELFORMAT;
-     dsc->width  = data->width;
-     dsc->height = data->height;
+     dsc->width  = data->common.width;
+     dsc->height = data->common.height;
 
-     if (dfb_config->image_format) {
-          dsc->pixelformat = dfb_config->image_format;
-     }
-     else {
-          if (data->color_type & PNG_COLOR_MASK_ALPHA)
-               dsc->pixelformat = DFB_PIXELFORMAT_HAS_ALPHA(primary_format) ? primary_format : DSPF_ARGB;
-          else
-               dsc->pixelformat = primary_format;
-     }
+     if (data->color_type & PNG_COLOR_MASK_ALPHA)
+          dsc->pixelformat = DFB_PIXELFORMAT_HAS_ALPHA(primary_format) ? primary_format : DSPF_ARGB;
+     else
+          dsc->pixelformat = DSPF_RGB24;
 
      if (data->color_type == PNG_COLOR_TYPE_PALETTE) {
           dsc->flags |= DSDESC_PALETTE;
@@ -565,6 +771,71 @@
      return DFB_OK;
 }
 
+static void
+render_cleanup( void *cleanup_data )
+{
+     IDirectFBImageProvider           *thiz = cleanup_data;
+     IDirectFBImageProvider_PNG_data *data;
+
+     D_MAGIC_ASSERT( (IAny*)thiz, DirectInterface );
+     data = (IDirectFBImageProvider_PNG_data *) thiz->priv;
+     D_ASSERT( data != NULL );
+
+     if (data->destination) {
+          data->destination->Release( data->destination );
+          data->destination = NULL;
+     }
+
+     /* in case we get terminated from outside, set the state to DFB_DEAD */
+     data->thread_res = DFB_DEAD;
+
+     pthread_mutex_unlock( &data->lock );
+}
+
+static void *
+PNGrenderThread( DirectThread *thread, void *driver_data )
+{
+     IDirectFBImageProvider          *thiz = driver_data;
+     IDirectFBImageProvider_PNG_data *data;
+     IDirectFBSurface_data           *dst_data;
+     CoreSurface                     *dst_surface;
+     DFBSurfacePixelFormat            format;
+     DFBResult                        res;
+
+     D_MAGIC_ASSERT( (IAny*)thiz, DirectInterface );
+     data = (IDirectFBImageProvider_PNG_data *) thiz->priv;
+     D_ASSERT( data != NULL );
+
+     pthread_mutex_lock( &data->lock );
+
+     pthread_cleanup_push( render_cleanup, thiz );
+
+     while (!data->destination) {
+          pthread_cond_wait( &data->cond, &data->lock );
+     }
+
+     dst_data = (IDirectFBSurface_data*) data->destination->priv;
+     D_ASSERT( dst_data != NULL );
+
+     dst_surface = dst_data->surface;
+     D_ASSERT( dst_surface != NULL );
+
+     res = data->destination->GetPixelFormat( data->destination, &format );
+     D_ASSERT( res == DFB_OK );
+
+     /* as long as we haven't finished decoding we are busy */
+     data->thread_res = DFB_BUSY;
+
+     res = PNG_RenderTo( data, dst_surface, format, &data->rect, &data->clip );
+
+     pthread_cleanup_pop( 1 );
+
+     /* in case we exit normally, apply the real return value */
+     data->thread_res = res;
+
+     return NULL;
+}
+
 /**********************************************************************************************************************/
 
 #define MAXCOLORMAPSIZE 256
@@ -623,6 +894,8 @@
 {
      int                              i,ret;
      IDirectFBImageProvider_PNG_data *data;
+     png_int_32 width;
+     png_int_32 height;
 
      u32 bpp1[2] = {0, 0xff};
      u32 bpp2[4] = {0, 0x55, 0xaa, 0xff};
@@ -642,13 +915,16 @@
      data->stage = STAGE_INFO;
 
      ret = png_get_IHDR( data->png_ptr, data->info_ptr,
-                         (png_uint_32 *)&data->width, (png_uint_32 *)&data->height, &data->bpp, &data->color_type,
+                         (png_uint_32 *)&width, (png_uint_32 *)&height, &data->bpp, &data->color_type,
                          NULL, NULL, NULL );
 
      /* Let's not do anything with badly sized or corrupted images */
-     if ( (data->height == 0) || (data->width == 0) || (ret != 1) )
+     if ( (height == 0) || (width == 0) || (ret != 1) )
          return;
 
+     data->common.width = width;
+     data->common.height = height;
+
      if (png_get_valid( data->png_ptr, data->info_ptr, PNG_INFO_tRNS )) {
           data->color_keyed = true;
 
@@ -798,13 +1074,13 @@
                                                    data->colors[i].b );
                }
 
-               data->pitch = (data->width + 7) & ~7;
+               data->pitch = (data->common.width + 7) & ~7;
                break;
           }
 
           case PNG_COLOR_TYPE_GRAY:
                if (data->bpp < 16) {
-                    data->pitch = data->width;
+                    data->pitch = data->common.width;
                     break;
                }
 
@@ -814,7 +1090,7 @@
 
                /* fall through */
           default:
-               data->pitch = data->width * 4;
+               data->pitch = data->common.width * 4;
 
                if (!data->color_keyed)
                     png_set_strip_16( data->png_ptr ); /* if it is color keyed we will handle conversion ourselves */
@@ -863,15 +1139,15 @@
      data->stage = STAGE_IMAGE;
 
      /* check image data pointer */
-     if (!data->image) {
+     if (!data->common.image) {
           // FIXME: allocates four additional bytes because the scaling functions
           //        in src/misc/gfx_util.c have an off-by-one bug which causes
           //        segfaults on darwin/osx (not on linux)
-          int size = data->pitch * data->height + 4;
+          int size = data->pitch * data->common.height + 4;
 
           /* allocate image data */
-          data->image = D_CALLOC( 1, size );
-          if (!data->image) {
+          data->common.image = D_CALLOC( 1, size );
+          if (!data->common.image) {
                D_ERROR( "DirectFB/ImageProvider_PNG: Could not "
                         "allocate %d bytes of system memory!\n", size );
 
@@ -884,7 +1160,7 @@
 
      /* write to image data */
      if (data->bpp == 16 && data->color_keyed) {
-          u8 *dst = (u8*)((u8*)data->image + row_num * data->pitch);
+          u8 *dst = (u8*)((u8*)data->common.image + row_num * data->pitch);
           u8 *src = (u8*)new_row;
 
           if (src) {
@@ -933,7 +1209,7 @@
                u16 *src16 = (u16*)src + src16_initial_offset;
                u32 *dst32 = (u32*)dst + dst32_initial_offset;
 
-               int remaining = data->width - dst32_initial_offset;
+               int remaining = data->common.width - dst32_initial_offset;
 
                while (remaining > 0) {
                     int keyed = 0;
@@ -973,17 +1249,17 @@
           }
      }
      else
-         png_progressive_combine_row( data->png_ptr, (png_bytep)((u8*)data->image + row_num * data->pitch), new_row );
+         png_progressive_combine_row( data->png_ptr, (png_bytep)((u8*)data->common.image + row_num * data->pitch), new_row );
 
      /* increase row counter, FIXME: interlaced? */
      data->rows++;
 
-     if (data->base.render_callback) {
+     if (data->common.base.render_callback) {
           DIRenderCallbackResult r;
-          DFBRectangle rect = { 0, row_num, data->width, 1 };
+          DFBRectangle rect = { 0, row_num, data->common.width, 1 };
 
-          r = data->base.render_callback( &rect,
-                                          data->base.render_callback_context );
+          r = data->common.base.render_callback( &rect,
+                                                 data->common.base.render_callback_context );
           if (r != DIRCR_OK)
                data->stage = STAGE_ABORT;
      }
@@ -1017,7 +1293,7 @@
                        int                              buffer_size)
 {
      DFBResult            ret;
-     IDirectFBDataBuffer *buffer = data->base.buffer;
+     IDirectFBDataBuffer *buffer = data->common.base.buffer;
 
      while (data->stage < stage) {
           unsigned int  len;
@@ -1059,3 +1335,711 @@
 
      return DFB_OK;
 }
+
+
+
+#if defined(PNG_PROVIDER_USE_MME)
+static void
+TransformerCallback (MME_Event_t    Event,
+                     MME_Command_t *CallbackData,
+                     void          *UserData)
+{
+  static const char *color_types[] = { "gray", "?", "rgb", "palette",
+                                       "alpha", "?", "rgba" };
+  static const char *interlace_types[] = { "none", "adam7" };
+
+  const PNGDecode_TransformReturnParams_t * const transform_result =
+    CallbackData->CmdStatus.AdditionalInfo_p;
+  const PNGDecode_GlobalTransformReturnParams_t * const global_transform_result =
+    CallbackData->CmdStatus.AdditionalInfo_p;
+  struct _MMECommon * const mme = (struct _MMECommon *) UserData;
+  IDirectFBImageProvider_PNG_data * const data =
+    container_of (mme, IDirectFBImageProvider_PNG_data, common);
+
+  if (!mme->name_set)
+    {
+      char name[20];
+      snprintf (name, sizeof (name), "MME (%s)", mme->transformer_name);
+      direct_thread_set_name (name);
+      mme->name_set = true;
+    }
+
+  D_DEBUG_AT (HWPNG, "%sTransformerCallback: Event: %d: (%s)%s\n",
+              RED, Event, get_mme_event_string (Event), BLACK);
+  D_DEBUG_AT (HWPNG, "  -> CallbackData->CmdStatus.State: %d (%s)\n",
+              CallbackData->CmdStatus.State,
+              get_mme_state_string (CallbackData->CmdStatus.State));
+  D_DEBUG_AT (HWPNG, "  -> CallbackData->CmdStatus.CmdId: %u (%.8x)\n",
+              CallbackData->CmdStatus.CmdId,
+              CallbackData->CmdStatus.CmdId);
+  D_DEBUG_AT (HWPNG, "  -> CallbackData->CmdStatus.Error: %d (%s)\n",
+              CallbackData->CmdStatus.Error,
+              get_mme_error_string (CallbackData->CmdStatus.Error));
+  D_DEBUG_AT (HWPNG, "  -> CallbackData->CmdStatus.AdditionalInfoSize: %u\n",
+              CallbackData->CmdStatus.AdditionalInfoSize);
+  D_DEBUG_AT (HWPNG, "  -> mme->decode_success: %d\n", mme->decode_success);
+
+  switch (Event)
+    {
+    case MME_COMMAND_COMPLETED_EVT:
+      pthread_mutex_lock (&mme->pending_commands_lock);
+      direct_hash_remove (mme->pending_commands,
+                          CallbackData->CmdStatus.CmdId);
+      if (likely (CallbackData->CmdStatus.CmdId != mme->TransformCommand.CmdStatus.CmdId
+                  && CallbackData->CmdStatus.CmdId != data->SetGlobalCommand.CmdStatus.CmdId))
+        --mme->n_pending_buffers;
+      pthread_mutex_unlock (&mme->pending_commands_lock);
+
+      switch (CallbackData->CmdStatus.State)
+        {
+        case MME_COMMAND_COMPLETED:
+          if (unlikely (CallbackData->CmdStatus.CmdId
+                        == mme->TransformCommand.CmdStatus.CmdId))
+            {
+              deb_gettimeofday (&mme->endtime, NULL);
+              deb_timersub (&mme->endtime, &mme->starttime, &mme->endtime);
+              D_DEBUG_AT (HWPNG_TIME, "  -> total time %lu.%06lu\n",
+                          mme->endtime.tv_sec, mme->endtime.tv_usec);
+
+              D_DEBUG_AT (HWPNG, "  -> expanded bytes: %u\n",
+                          transform_result->BytesWritten);
+
+              D_DEBUG_AT (HWPNG, "  -> PNG result code: %d (%s)\n",
+                          transform_result->ErrorType,
+                          get_png_error_string (transform_result->ErrorType));
+
+              if (transform_result->Cycles)
+                {
+                  D_DEBUG_AT (HWPNG, "  -> profiling data: cyc/bu/i/d/n: "
+                                     "%u/%u/%u/%u/%u\n",
+                              transform_result->Cycles,
+                              transform_result->Bundles,
+                              transform_result->ICacheMiss,
+                              transform_result->DCacheMiss,
+                              transform_result->NopBundles);
+                }
+
+              mme->decode_success = 1;
+              sema_signal_event (&mme->decode_event);
+
+              /* in case of bogus data (too much), abort pending data
+                 buffers */
+              abort_transformer (mme);
+            }
+          else if (unlikely (CallbackData->CmdStatus.CmdId
+                             == data->SetGlobalCommand.CmdStatus.CmdId))
+            {
+              D_DEBUG_AT (HWPNG, "  -> size: %ux%u @ %ubpp\n",
+                          global_transform_result->PictureWidth,
+                          global_transform_result->PictureHeight,
+                          global_transform_result->BitDepth);
+              D_DEBUG_AT (HWPNG, "  -> ColorType      : %d (%s)\n",
+                          global_transform_result->ColorType,
+                          (global_transform_result->ColorType
+                           < D_ARRAY_SIZE (color_types))
+                          ? color_types[global_transform_result->ColorType]
+                          : "?" );
+              D_DEBUG_AT (HWPNG, "  -> InterlaceType  : %d (%s)\n",
+                          global_transform_result->InterlaceType,
+                          (global_transform_result->InterlaceType
+                           < D_ARRAY_SIZE (interlace_types))
+                          ? interlace_types[global_transform_result->InterlaceType]
+                          : "?");
+              D_DEBUG_AT (HWPNG, "  -> CompressionType: %d\n", global_transform_result->CompressionType);
+              D_DEBUG_AT (HWPNG, "  -> FilterMethod   : %d\n", global_transform_result->FilterMethod);
+              D_DEBUG_AT (HWPNG, "  -> ErrorType      : %d (%s)\n", global_transform_result->ErrorType, get_png_error_string (global_transform_result->ErrorType));
+
+              D_DEBUG_AT (HWPNG, "  -> ColorFormatOutput: %d\n", global_transform_result->ColorFormatOutput);
+              D_DEBUG_AT (HWPNG, "  -> ColorKey: %c\n", global_transform_result->HaveColorKey ? 'y' : 'n');
+              if (global_transform_result->HaveColorKey)
+                  D_DEBUG_AT (HWPNG, "  -> ColorKey (xRGB): %.6x\n", global_transform_result->ColorKey);
+              D_DEBUG_AT (HWPNG, "  -> pitch: %d\n", global_transform_result->pitch);
+
+              sema_signal_event (&data->global_event);
+            }
+          else
+            {
+              /* buffer completed */
+              struct _MMEHelper_buffer *buf =
+                container_of (CallbackData->DataBuffers_p,
+                              struct _MMEHelper_buffer, buffer);
+
+              D_DEBUG_AT (HWPNG, "  -> buffer %p completed (container @ %p)\n",
+                          CallbackData->DataBuffers_p[0], buf);
+
+              sema_signal_event (&buf->sema);
+            }
+          break; /* MME_COMMAND_COMPLETED */
+
+        case MME_COMMAND_FAILED:
+          if (CallbackData->CmdStatus.Error != MME_COMMAND_ABORTED)
+            D_WARN ("(%5d) %s: command %u (%.8x) failed: error %d (%s)",
+                    direct_gettid (), mme->name,
+                    CallbackData->CmdStatus.CmdId,
+                    CallbackData->CmdStatus.CmdId,
+                    CallbackData->CmdStatus.Error,
+                    get_mme_error_string (CallbackData->CmdStatus.Error));
+
+          if (likely (CallbackData->CmdStatus.CmdId
+                      == mme->TransformCommand.CmdStatus.CmdId))
+            {
+              /* transform command failed */
+              D_DEBUG_AT (HWPNG, "  -> transform->ErrorType: %d (%s)\n",
+                          transform_result->ErrorType,
+                          get_png_error_string (transform_result->ErrorType));
+
+              mme->decode_success = -1;
+              sema_signal_event (&mme->decode_event);
+            }
+          else if (likely (CallbackData->CmdStatus.CmdId
+                   == data->SetGlobalCommand.CmdStatus.CmdId))
+            {
+              /* global transform params command failed */
+              D_DEBUG_AT (HWPNG, "  -> global->ErrorType: %d (%s)\n",
+                          global_transform_result->ErrorType,
+                          get_png_error_string (global_transform_result->ErrorType));
+
+              mme->decode_success = -1;
+              sema_signal_event (&data->global_event);
+            }
+          else
+            {
+              /* buffer failed */
+              struct _MMEHelper_buffer *buf =
+                container_of (CallbackData->DataBuffers_p,
+                              struct _MMEHelper_buffer, buffer);
+              if (mme->decode_success == 0)
+                /* only if we didn't succeed yet */
+                mme->decode_success = -1;
+              sema_signal_event (&buf->sema);
+            }
+          break; /* MME_COMMAND_FAILED */
+
+        case MME_COMMAND_IDLE:
+        case MME_COMMAND_PENDING:
+        case MME_COMMAND_EXECUTING:
+        default:
+          D_WARN ("(%5d) %s: command %u (%.8x) completed in unknown state: %d (%s)",
+                  direct_gettid (), mme->name,
+                  CallbackData->CmdStatus.CmdId, CallbackData->CmdStatus.CmdId,
+                  CallbackData->CmdStatus.State,
+                  get_mme_state_string (CallbackData->CmdStatus.State));
+          break;
+        }
+      break; /* MME_COMMAND_COMPLETED_EVT */
+
+    case MME_DATA_UNDERFLOW_EVT:
+      ++mme->n_underflows;
+      {
+      /* check if the IDirectFBDataBuffer definitely(!) hit an EOF and
+         we have no buffers queued */
+      bool end_of_data;
+      char tmp;
+      pthread_mutex_lock (&mme->pending_commands_lock);
+      DFBResult has_data = mme->base.buffer->PeekData (mme->base.buffer,
+                                                       1, 0, &tmp, NULL);
+      /* n_pending_buffers is checked to be == 0 because the
+         TransformCommand itself is not stored in there. */
+      end_of_data = (has_data == DFB_EOF
+                     && mme->n_pending_buffers == 0);
+      pthread_mutex_unlock (&mme->pending_commands_lock);
+
+      /* if so, signal completion */
+      if (end_of_data)
+        {
+          D_DEBUG_AT (HWPNG, "  -> no more data available, signalling fail\n");
+          mme->decode_success = -2;
+          sema_signal_event (&mme->decode_event);
+        }
+      }
+      break; /* MME_DATA_UNDERFLOW_EVT */
+
+    case MME_NOT_ENOUGH_MEMORY_EVT:
+    case MME_NEW_COMMAND_EVT:
+    default:
+      D_WARN ("(%5d) %s: unhandled event %d (%s) occured on command %u (%.8x)",
+              direct_gettid (), mme->name, Event,
+              get_mme_event_string (Event), CallbackData->CmdStatus.CmdId,
+              CallbackData->CmdStatus.CmdId);
+
+      D_WARN ("(%5d) %s: CallbackData->CmdStatus.AdditionalInfoSize: %u",
+              direct_gettid (), mme->name, CallbackData->CmdStatus.AdditionalInfoSize);
+
+      if (CallbackData->CmdStatus.CmdId == mme->TransformCommand.CmdStatus.CmdId)
+        {
+          D_WARN ("(%5d) %s: transform_result->bytes_written: %u",
+                  direct_gettid (), mme->name, transform_result->BytesWritten);
+          D_WARN ("(%5d) %s: result code: %d (%s)\n", direct_gettid (),
+                  mme->name, transform_result->ErrorType,
+                  get_png_error_string (transform_result->ErrorType));
+        }
+      else if (CallbackData->CmdStatus.CmdId == data->SetGlobalCommand.CmdStatus.CmdId)
+        {
+          D_WARN ("(%5d) %s: size: %ux%u @ %ubpp\n",
+                  direct_gettid (), mme->name,
+                  global_transform_result->PictureWidth,
+                  global_transform_result->PictureHeight,
+                  global_transform_result->BitDepth);
+          D_WARN ("(%5d) %s: ColorType      : %d (%s)\n",
+                  direct_gettid (), mme->name,
+                  global_transform_result->ColorType,
+                  (global_transform_result->ColorType
+                   < D_ARRAY_SIZE (color_types))
+                  ? color_types[global_transform_result->ColorType]
+                  : "?" );
+          D_WARN ("(%5d) %s: InterlaceType  : %d (%s)\n",
+                  direct_gettid (), mme->name,
+                  global_transform_result->InterlaceType,
+                      (global_transform_result->InterlaceType
+                       < D_ARRAY_SIZE (interlace_types))
+                      ? interlace_types[global_transform_result->InterlaceType]
+                      : "?");
+          D_WARN ("(%5d) %s: CompressionType: %d\n", direct_gettid (), mme->name, global_transform_result->CompressionType);
+          D_WARN ("(%5d) %s: FilterMethod   : %d\n", direct_gettid (), mme->name, global_transform_result->FilterMethod);
+          D_WARN ("(%5d) %s: ErrorType      : %d (%s)\n", direct_gettid (), mme->name, global_transform_result->ErrorType, get_png_error_string (global_transform_result->ErrorType));
+
+          D_DEBUG_AT (HWPNG, "  -> ColorFormatOutput: %d\n", global_transform_result->ColorFormatOutput);
+          D_DEBUG_AT (HWPNG, "  -> ColorKey: %c\n", global_transform_result->HaveColorKey ? 'y' : 'n');
+          if (global_transform_result->HaveColorKey)
+              D_DEBUG_AT (HWPNG, "  -> ColorKey (xRGB): %.6x\n", global_transform_result->ColorKey);
+          D_DEBUG_AT (HWPNG, "  -> pitch: %d\n", global_transform_result->pitch);
+        }
+      break;
+    }
+}
+
+
+/* warning: MME_AbortCommand() works only for the MME_TRANSFORM command;
+   individual buffers can be aborted, too, but MME_TermTransformer() will
+   not work afterwards anymore! */
+static bool
+pending_fe_func (DirectHash    *hash,
+                 unsigned long  key,
+                 void          *value,
+                 void          *ctx)
+{
+  struct _MMECommon * const mme = ctx;
+  __attribute__((unused))
+  IDirectFBImageProvider_PNG_data * const data =
+    container_of (mme, IDirectFBImageProvider_PNG_data, common);
+  MME_CommandId_t    CmdId = key;
+
+  D_DEBUG_AT (HWPNG, "aborting %s command %u (%.8x)\n",
+              ((CmdId == mme->TransformCommand.CmdStatus.CmdId)
+               ? "(main transform)"
+               : ((CmdId == data->SetGlobalCommand.CmdStatus.CmdId)
+                  ? "(global)"
+                  : "(buffer)"
+                 )
+              ), CmdId, CmdId);
+
+  MME_ERROR res = MME_AbortCommand (mme->Handle, CmdId);
+  if (res != MME_SUCCESS)
+    {
+      /* this would mean the command is about to finish, but we didn't
+         notice yet... */
+      D_WARN ("(%5d) MME_AbortCommand(%x, %.8x) for %s failed: %d (%s)\n",
+              direct_gettid (), mme->Handle, CmdId,
+              mme->name, res, get_mme_error_string (res));
+    }
+
+  /* continue iterating */
+  return true;
+}
+
+static DFBResult
+abort_transformer (struct _MMECommon * const mme)
+{
+  if (!mme)
+       return DFB_THIZNULL;
+
+  /* FIXME: what about locking? */
+  direct_hash_iterate (mme->pending_commands,
+                       pending_fe_func,
+                       mme);
+
+  return DFB_OK;
+}
+
+
+static DFBResult
+set_global_transform_params (IDirectFBImageProvider_PNG_data *data)
+{
+  MME_ERROR ret;
+
+  data->SetGlobalCommand.StructSize          = sizeof (MME_Command_t);
+  data->SetGlobalCommand.CmdCode             = MME_SET_GLOBAL_TRANSFORM_PARAMS;
+  data->SetGlobalCommand.CmdEnd              = MME_COMMAND_END_RETURN_NOTIFY;
+  data->SetGlobalCommand.DueTime             = (MME_Time_t) 0;
+  data->SetGlobalCommand.NumberInputBuffers  = 0;
+  data->SetGlobalCommand.NumberOutputBuffers = 0;
+  data->SetGlobalCommand.DataBuffers_p       = NULL;
+
+  /* clear the commandstatus from the previous run */
+  memset (&( data->SetGlobalCommand.CmdStatus), 0, sizeof (MME_CommandStatus_t));
+
+  data->SetGlobalCommand.CmdStatus.AdditionalInfoSize = sizeof (PNGDecode_GlobalTransformReturnParams_t);
+  data->SetGlobalCommand.CmdStatus.AdditionalInfo_p = &data->GlobalReturnParams;
+
+  data->SetGlobalCommand.NumberInputBuffers = 0;
+  data->SetGlobalCommand.NumberOutputBuffers = 0;
+
+  /* set parameters - just settings flags to 0 should make this compatible
+     with old transformer versions, 0 means PNGDECODE_OF_EXPAND */
+//  data->GlobalParams.flags = PNGDECODE_PARAM_FORMAT;
+//  data->GlobalParams.format = PNGDECODE_OF_EXPAND;
+//  data->SetGlobalCommand.ParamSize = sizeof (PNGDecode_GlobalParams_t);
+//  data->SetGlobalCommand.Param_p   = &data->GlobalParams;
+  data->SetGlobalCommand.ParamSize = 0;
+  data->SetGlobalCommand.Param_p   = NULL;
+
+  D_DEBUG_AT (HWPNG, "sending global command\n");
+
+  pthread_mutex_lock (&data->common.pending_commands_lock);
+  ret = MME_SendCommand (data->common.Handle, &data->SetGlobalCommand);
+  if (ret != MME_SUCCESS)
+    {
+      pthread_mutex_unlock (&data->common.pending_commands_lock);
+      D_INFO ("%s: MME_SendCommand() failed: %d (%s)\n",
+              data->common.name, ret, get_mme_error_string (ret));
+      return DFB_FAILURE;
+    }
+
+  direct_hash_insert (data->common.pending_commands,
+                      data->SetGlobalCommand.CmdStatus.CmdId,
+                      (void *) 1);
+  D_DEBUG_AT (HWPNG, "sent packet's CmdId is %u (%.8x)\n",
+              data->SetGlobalCommand.CmdStatus.CmdId,
+              data->SetGlobalCommand.CmdStatus.CmdId);
+  pthread_mutex_unlock (&data->common.pending_commands_lock);
+
+  return DFB_OK;
+}
+
+
+static void
+_imageprovider_update_transform_params (struct _MMECommon           * const mme,
+                                        void                        * const params,
+                                        const CoreSurfaceBufferLock * const lock)
+{
+  IDirectFBImageProvider_PNG_data * const data =
+    container_of (mme, IDirectFBImageProvider_PNG_data, common);
+
+  if (data->GlobalReturnParams.pitch != lock->pitch)
+    {
+      PNGDecode_TransformParams_t * const p = params;
+
+      p->flags |= PNGDECODE_PARAM_PITCH;
+      p->pitch = lock->pitch;
+    }
+}
+
+
+#define HWREND_THRESHOLD 20000
+
+static pthread_mutex_t transformer_index_mutex = PTHREAD_MUTEX_INITIALIZER;
+static unsigned int transformer_index;
+static DFBResult
+PNG_HardwareRenderTo( IDirectFBImageProvider_PNG_data *data,
+                      CoreSurface                     *dst_surface,
+                      DFBSurfacePixelFormat            format,
+                      DFBRectangle                    *rect,
+                      const DFBRegion                 *clip )
+{
+  DFBResult              dfbret = dfbret;
+  CoreSurfaceBufferLock  lock;
+  unsigned int           bufpos = 0;
+
+  D_ASSERT( data != NULL );
+  D_ASSERT( dst_surface != NULL);
+  D_ASSERT( rect != NULL );
+  D_ASSERT( clip != NULL );
+
+  /* FIXME: check if the image is big enough to warrant a HW decode */
+  if ((dst_surface->config.size.w * dst_surface->config.size.h) < HWREND_THRESHOLD)
+    return DFB_UNSUPPORTED;
+
+  /* only decode if we haven't decoded before */
+  if (data->common.decode_success <= 0)
+    {
+      MME_TransformerCapability_t cap;
+      bool                        surface_locked = false;
+
+      data->common.name = "hwPNG";
+      static const char  *transformers0[] = { PNGDECODER_MME_TRANSFORMER_NAME"0", NULL };
+      static const char  *transformers1[] = { PNGDECODER_MME_TRANSFORMER_NAME"1", NULL };
+      static const char  *transformers2[] = { PNGDECODER_MME_TRANSFORMER_NAME"2", NULL };
+      static const char  *transformers3[] = { PNGDECODER_MME_TRANSFORMER_NAME"3", NULL };
+      static const char  *transformers4[] = { PNGDECODER_MME_TRANSFORMER_NAME"4", NULL };
+      static const char  *transformers5[] = { PNGDECODER_MME_TRANSFORMER_NAME, NULL };
+      static const char **transformers[] = { transformers0, transformers1,
+                                             transformers2, transformers3,
+                                             transformers4, transformers5 };
+
+      unsigned i;
+      transformer_index = -1;
+      pthread_mutex_lock (&transformer_index_mutex);
+      for (i = 0; i < D_ARRAY_SIZE (transformers); ++i)
+        {
+          ++transformer_index;
+          transformer_index %= D_ARRAY_SIZE (transformers);
+
+          PNGDecode_InitTransformerParams_t png_init;
+          png_init.flags = PNGDECODE_PARAM_FORMAT;
+          png_init.format = PNGDECODE_OF_EXPAND;
+          dfbret = mme_helper_init_transformer (&data->common,
+                                                transformers[transformer_index],
+                                                sizeof (png_init),
+                                                &png_init, NULL);
+          if (dfbret == DFB_OK)
+            {
+              /* need to init this because old transformer versions didn't
+                 touch it at all. */
+              cap.Version = 0;
+              _mme_helper_get_capability (&data->common,
+                                          *transformers[transformer_index],
+                                          &cap);
+
+              if (cap.Version != 11)
+                {
+                  /* incompatible with old transformer, it has just way too
+                     many bugs! */
+                  mme_helper_deinit_transformer (&data->common);
+                  dfbret = DFB_FAILURE;
+                  continue;
+                }
+
+              data->common.transformer_name = *transformers[transformer_index];
+              if (data->flags & DIRENDER_BACKGROUND)
+                direct_thread_set_name (*transformers[transformer_index]);
+
+              break;
+            }
+        }
+      pthread_mutex_unlock (&transformer_index_mutex);
+
+      if (dfbret != DFB_OK)
+        return dfbret;
+
+      sema_init_event (&data->common.decode_event, 0); /* Alerts to completion */
+      sema_init_event (&data->global_event, 0);
+
+      {
+      /* store the current data buffer position for software fallback should
+         we not succeed */
+      data->common.base.buffer->GetPosition (data->common.base.buffer,
+                                             &bufpos);
+
+      /* as an optimization we first send one packet, otherwise
+         SET_GLOBAL_TRANSFORM_COMMAND would through a data underflow event */
+      mme_helper_calculate_packets (&data->common);
+      dfbret = mme_helper_send_packets (&data->common, 1);
+      if (dfbret != DFB_OK)
+        goto err_abort_commands;
+
+      dfbret = set_global_transform_params (data);
+      if (dfbret != DFB_OK)
+        goto err_abort_commands;
+
+      D_DEBUG_AT (HWPNG, "  -> waiting for global transform to finish\n");
+      while ((sema_wait_event (&data->global_event) == -1)
+             && errno == EINTR)
+        ;
+      D_DEBUG_AT (HWPNG, "    -> global transform finished (failed: %c)\n",
+                  (data->common.decode_success != 0) ? 'y' : 'n');
+
+      /* the transformer encountered an error */
+      if (data->common.decode_success != 0)
+        {
+          dfbret = DFB_FAILURE;
+          goto err_abort_commands;
+        }
+
+      if (!data->common.decode_surface)
+        {
+          /* create a destination surface to MME-decode the image onto before
+             stretchblit ... and if we can't create a surface in video
+             memory then we can't blit */
+          CoreSurfaceConfig  config;
+          CorePalette       *palette = NULL;
+
+          switch (data->GlobalReturnParams.ColorFormatOutput)
+            {
+            case PNGDECODE_COLOR_TYPE_PALETTE:
+              config.format = DSPF_LUT8;
+
+              dfbret = dfb_palette_create (data->common.base.core,
+                                           256, &palette);
+              if (dfbret != DFB_OK)
+                goto err_abort_commands;
+
+              direct_memcpy (palette->entries,
+                             data->GlobalReturnParams.palette,
+                             256 * sizeof (DFBColor));
+              dfb_palette_update (palette, 0, 256 - 1);
+              break;
+
+            case PNGDECODE_COLOR_TYPE_RGB:
+              config.format = DSPF_RGB24;
+              break;
+
+            case PNGDECODE_COLOR_TYPE_RGB_ALPHA:
+            default:
+              config.format = DSPF_ARGB;
+              break;
+            }
+          config.flags = CSCONF_SIZE | CSCONF_FORMAT | CSCONF_CAPS;
+          config.size.w = data->common.width;
+          config.size.h = data->common.height;
+          config.caps   = DSCAPS_VIDEOONLY;
+          #ifdef DIRECT_BUILD_DEBUG
+          config.caps   |= DSCAPS_SHARED;
+          #endif
+
+          dfbret = dfb_surface_create (data->common.base.core, &config,
+                                       CSTF_NONE, 0, palette,
+                                       &data->common.decode_surface);
+          if (palette)
+            dfb_palette_unref (palette);
+
+          if (dfbret != DFB_OK)
+            goto err_abort_commands;
+        }
+
+      /* tell the transformer what to do and where to put the result */
+      data->TransformParams.flags = 0;
+      dfbret = mme_helper_start_transformer (&data->common,
+                                             sizeof (data->ReturnParams),
+                                             &data->ReturnParams,
+                                             sizeof (data->TransformParams),
+                                             &data->TransformParams,
+                                             data->common.decode_surface,
+                                             &lock);
+      if (dfbret != DFB_OK)
+        {
+          D_DEBUG_AT (HWPNG, "couldn't start transformer\n");
+          goto err_abort_commands;
+        }
+
+      surface_locked = true;
+
+      /* Now send the rest of the data */
+      D_DEBUG_AT (HWPNG, "Transform sent, sending data buffers now\n");
+      dfbret = mme_helper_send_packets (&data->common, -1);
+      if (dfbret != DFB_OK)
+        {
+          D_DEBUG_AT (HWPNG, "couldn't send all buffers\n");
+          goto err_abort_commands;
+        }
+
+      /* wait until the decode is complete */
+      D_DEBUG_AT (HWPNG, "waiting for completion\n");
+      while ((sema_wait_event (&data->common.decode_event) == -1)
+             && errno == EINTR)
+        ;
+      /* the transformer encountered an error */
+      if (data->common.decode_success != 1)
+        {
+          dfbret = DFB_FAILURE;
+          goto err_abort_commands;
+        }
+      }
+
+err_abort_commands:
+      {
+        /* we need to do this explicitly here because the generic code will
+           not call abort_transformer() if no TransformCommand is pending.
+           Unfortunately in the PNG case, we always send a buffer before the
+           transform command. This buffer would otherwise not be aborted.
+           Should probably change the code to be more in line with JPEG. */
+        abort_transformer (&data->common);
+        /* wait till all commands are aborted and acknowledged */
+        while (data->common.n_pending_buffers
+               || direct_hash_lookup (data->common.pending_commands,
+                                      data->common.TransformCommand.CmdStatus.CmdId))
+          usleep (1);
+
+      if (surface_locked)
+        {
+          mme_helper_deinit_transformer (&data->common);
+
+          dfb_surface_unlock_buffer (data->common.decode_surface, &lock);
+        }
+
+
+      if (data->common.OutDataBuffers)
+        {
+          D_FREE (data->common.OutDataBuffers);
+          data->common.OutDataBuffers = NULL;
+        }
+
+      unsigned int i;
+      for (i = 0; i < D_ARRAY_SIZE (data->common.SendDataBuffers); ++i)
+        {
+          if (data->common.SendDataBuffers[i].buffer)
+            {
+              MME_FreeDataBuffer (data->common.SendDataBuffers[i].buffer);
+              data->common.SendDataBuffers[i].buffer = NULL;
+
+              sema_close_event (&data->common.SendDataBuffers[i].sema);
+            }
+        }
+
+      sema_close_event (&data->common.decode_event);
+      sema_close_event (&data->global_event);
+
+      if (data->common.decode_success != 1)
+        {
+          /* if we saw corrupt data, there's no point in trying libpng, just
+             display the result as far as possible. */
+          if (data->common.TransformCommand.CmdStatus.State == MME_COMMAND_FAILED
+              && data->common.TransformCommand.CmdStatus.Error == MME_INVALID_ARGUMENT)
+            {
+              const PNGDecode_TransformReturnParams_t * __restrict r =
+                &data->ReturnParams;
+
+              switch (r->ErrorType)
+                {
+                case PNGDECODE_CRC_ERROR:
+                case PNGDECODE_INVALID_STREAM:
+                case PNGDECODE_STREAM_ERROR:
+                  /* just assume invalid data and display what we have */
+                  D_DEBUG_AT (HWPNG, "faking success due to corrupt data\n");
+                  data->common.decode_success = 1;
+
+                default:
+                  break;
+                }
+            }
+          else if (dfbret == DFB_IO)
+            {
+              D_DEBUG_AT (HWPNG, "faking success due to EOF\n");
+              dfbret = DFB_OK;
+              data->common.decode_success = 1;
+            }
+
+          if (data->common.decode_success != 1)
+            data->common.base.buffer->SeekTo (data->common.base.buffer,
+                                              bufpos);
+        }
+      }
+    }
+
+
+  if (data->common.decode_success == 1)
+    {
+      /* stretch blit the decoded image to the destination surface and size */
+      mme_helper_stretch_blit (&data->common, data->common.decode_surface,
+                               dst_surface, rect);
+      dfbret = DFB_OK;
+
+      if (data->GlobalReturnParams.HaveColorKey)
+        {
+          data->color_keyed = true;
+          data->color_key = data->GlobalReturnParams.ColorKey;
+        }
+    }
+
+  return dfbret;
+}
+#endif /* PNG_PROVIDER_USE_MME */
diff -Naur DirectFB-1.7.7/interfaces/IDirectFBImageProvider/idirectfbimageprovider_png.h DirectFB-1.7.7.stm/interfaces/IDirectFBImageProvider/idirectfbimageprovider_png.h
--- DirectFB-1.7.7/interfaces/IDirectFBImageProvider/idirectfbimageprovider_png.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7.stm/interfaces/IDirectFBImageProvider/idirectfbimageprovider_png.h	2015-05-15 18:43:40.077395075 +0200
@@ -0,0 +1,83 @@
+#ifndef __IDIRECTFBIMAGEPROVIDER_PNG_H__
+#define __IDIRECTFBIMAGEPROVIDER_PNG_H__
+
+#if defined(PNG_PROVIDER_USE_MME)
+/* HW Decode Requirements */
+#include <mme.h>
+#include <semaphore.h>
+
+#define PNGDEC_MME_VERSION 11
+#define PNGDECODE_PROFILING_ENABLE
+#include <PNGDecode_interface.h>
+#endif /* PNG_PROVIDER_USE_MME */
+
+
+/* private data struct of IDirectFBImageProvider_PNG */
+typedef struct
+{
+  struct _MMECommon common;
+
+  int               stage;
+  int               rows;
+
+  png_structp       png_ptr;
+  png_infop         info_ptr;
+
+  int               bpp;
+  int               color_type;
+  png_uint_32       color_key;
+  bool              color_keyed;
+
+  int               pitch;
+  u32               palette[256];
+  DFBColor          colors[256];
+
+  DFBRectangle      rect;
+  DFBRegion         clip;
+
+  /* thread stuff */
+  DIRenderFlags     flags;
+  pthread_mutex_t   lock;
+  pthread_cond_t    cond;
+  DirectThread     *thread;
+  IDirectFBSurface *destination;
+  DFBResult         thread_res;
+
+#if defined(PNG_PROVIDER_USE_MME)
+  PNGDecode_TransformParams_t       TransformParams;
+  PNGDecode_TransformReturnParams_t ReturnParams;
+
+  PNGDecode_GlobalTransformReturnParams_t GlobalReturnParams;
+
+  MME_Command_t SetGlobalCommand;
+
+  sem_t global_event;
+#endif /* PNG_PROVIDER_USE_MME */
+} IDirectFBImageProvider_PNG_data;
+
+
+
+#if defined(PNG_PROVIDER_USE_MME)
+/****************************************************************************/
+static inline const char *
+get_png_error_string (PNGDecode_ErrorCodes_t e)
+{
+  static const char *PNGErrorType_strings[] = {
+    "PNGDECODE_NO_ERROR",
+    "PNGDECODE_MEMEORY_ALLOCATION_ERROR",
+    "PNGDECODE_CRC_ERROR",
+    "PNGDECODE_INVALID_STREAM",
+    "PNGDECODE_INTERNAL_ERROR",
+    "PNGDECODE_INVALID_ARGUMENT",
+    "PNGDECODE_STREAM_ERROR"
+  };
+
+  return (((unsigned int) e) < D_ARRAY_SIZE (PNGErrorType_strings))
+         ? PNGErrorType_strings[e]
+         : "* Unknown PngError code *";
+}
+#endif /* PNG_PROVIDER_USE_MME */
+
+
+
+#endif /* __IDIRECTFBIMAGEPROVIDER_PNG_H__ */
diff -Naur DirectFB-1.7.7/interfaces/IDirectFBImageProvider/idirectfbimageprovider_rle.c DirectFB-1.7.7.stm/interfaces/IDirectFBImageProvider/idirectfbimageprovider_rle.c
--- DirectFB-1.7.7/interfaces/IDirectFBImageProvider/idirectfbimageprovider_rle.c	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7.stm/interfaces/IDirectFBImageProvider/idirectfbimageprovider_rle.c	2015-05-15 18:43:40.093411075 +0200
@@ -0,0 +1,2259 @@
+/*
+ * Copyright (C) 2006-2009 ST-Microelectronics R&D
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+//#define DIRECT_ENABLE_DEBUG
+
+#include <config.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <directfb.h>
+
+#include <core/coredefs.h>
+#include <core/coretypes.h>
+
+#include <gfx/convert.h>
+
+#include <misc/gfx_util.h>
+#include <misc/util.h>
+
+#include <direct/types.h>
+#include <direct/messages.h>
+#include <direct/mem.h>
+#include <direct/memcpy.h>
+#include <direct/interface.h>
+
+#include <display/idirectfbsurface.h>
+#include <media/idirectfbimageprovider.h>
+
+#if defined(RLE_PROVIDER_HW)
+#include <sys/ioctl.h>
+#include <fbdev/fbdev.h>
+#include <linux/stmfb.h>
+#endif
+
+/*******************************************************************************
+ *
+ *                      TYPES DEFINITION SECTION
+ *
+ *******************************************************************************/
+//#define PERFORMANCE_MONITORING
+#define ALLOW_FORCE_SOFTWARE
+#define ALLOW_DUMP_RAW_TO_FILE
+
+#define MAX_STREAMING_COMMANDS          1
+#define MME_STREAMING_BUFFERSIZE        (1024 * 1024) /* Maximum size */
+
+D_DEBUG_DOMAIN (HWRLE,      "RLE",      "STM hardware-/MME- based RLE decoder");
+D_DEBUG_DOMAIN (HWRLE_MME,  "RLE/MME",  "STM MME-based RLE decoder (MME)");
+D_DEBUG_DOMAIN (HWRLE_SEMA, "RLE/SEMA", "STM MME-based RLE decoder (semaphores");
+D_DEBUG_DOMAIN (HWRLE_TIME, "RLE/Time", "STM MME-based RLE decoder (timing");
+#define MME_DEBUG_DOMAIN  HWRLE_MME
+#define SEMA_DEBUG_DOMAIN HWRLE_SEMA
+#define MME_TEXT_DOMAIN "RLE"
+
+#include "debug_helper.h"
+#define fetch_data   buffer_to_mme_copy
+struct _MMECommon;
+static void
+_imageprovider_update_transform_params (struct _MMECommon           * const mme,
+                                        void                        * const params,
+                                        const CoreSurfaceBufferLock * const lock)
+{
+}
+#include "mme_helper.h"
+#include "sema_helper.h"
+#include "idirectfbimageprovider_rle.h"
+
+
+/*******************************************************************************
+ *
+ *                      INTERFACE DEFINITION SECTION
+ *
+ *******************************************************************************/
+
+static DFBResult Probe( IDirectFBImageProvider_ProbeContext *ctx );
+
+static DFBResult Construct( IDirectFBImageProvider *thiz,
+                            ... );
+
+#include <direct/interface_implementation.h>
+
+DIRECT_INTERFACE_IMPLEMENTATION( IDirectFBImageProvider, RLE )
+
+
+/*******************************************************************************
+ *
+ *                      PRIVATE STATIC SECTION     (Little-Endian specific code)
+ *
+ *******************************************************************************/
+
+static u8
+rle_input_byte (const u8 ** const pptr,
+                const u8  * const end)
+{
+  return (*pptr < end) ? *(*pptr)++ : 0;
+}
+
+static void
+rle_output_byte (u8       ** const pptr,
+                 const u8  * const end,
+                 u8         byte)
+{
+  if (*pptr < end)
+    *(*pptr)++ = byte;
+}
+
+static u8 *
+rle_set_position (u8   * const ptr,
+                  uint  x,
+                  uint  y,
+                  uint  w,
+                  uint  h,
+                  uint  top)
+{
+  return &ptr[( x + (top ? y : (h-1-y)) * w)];
+}
+
+
+
+static u16
+read_le_16 (const u8 ** const pptr)
+{
+  const u8 * const ptr = *pptr;
+  *pptr += 2;
+  return (ptr[1] << 8) | ptr[0];
+}
+
+static u32
+read_le_32 (const u8 ** const pptr)
+{
+  const u8 * const ptr = *pptr;
+  *pptr += 4;
+  return (ptr[3] << 24) | (ptr[2] << 16) | (ptr[1] << 8) | ptr[0];
+}
+
+static void
+__attribute__((unused))
+write_le_16 (u8  ** const pptr,
+             u16   data)
+{
+  u8 * const ptr = *pptr;
+  *pptr += 2;
+  ptr[0] = (data >> 0) & 0xff;
+  ptr[1] = (data >> 8) & 0xff;
+}
+
+static void
+__attribute__((unused))
+write_le_32 (u8  ** const pptr,
+             u32   data)
+{
+  u8 * const ptr = *pptr;
+  *pptr += 4;
+  ptr[0] = (data >>  0) & 0xff;
+  ptr[1] = (data >>  8) & 0xff;
+  ptr[2] = (data >> 16) & 0xff;
+  ptr[3] = (data >> 24) & 0xff;
+}
+
+/*******************************************************************************
+ *
+ *                      PRIVATE STATIC SECTION      (RLE/RGB specific code)
+ *
+ *******************************************************************************/
+static DFBResult
+rle_decode_header (IDirectFBImageProvider_RLE_data *data)
+{
+#   define READ_LE_16(ptr,data)    {data=read_le_16(&ptr);TRACE(data);}
+#   define READ_LE_32(ptr,data)    {data=read_le_32(&ptr);TRACE(data);}
+#   define WRITE_LE_16(ptr,data)   write_le_16    (&ptr,(u16)data)
+#   define WRITE_LE_32(ptr,data)   write_le_32    (&ptr,(u32)data)
+#   define IS_MAGIC(ptr,l,h)       ((ptr[0]==l) &&  (ptr[1]==h))
+#   define SET_MAGIC(ptr,l,h)      {ptr[0]=(u8)l; ptr[1]=(u8)h;}
+
+  DFBResult  ret;
+  u8         preamble[RLE_PREAMBLE_SIZE];
+  u8         header[RLE_BIHEADER_SIZE];
+  const u8  *hptr;
+  u32        bihsize;
+
+  /* Preamble section */
+  memset (preamble, 0, RLE_PREAMBLE_SIZE);
+  ret = buffer_to_ptr_copy (data->common.base.buffer, preamble,
+                            RLE_PREAMBLE_SIZE);
+  if (ret)
+    return ret;
+  hptr = preamble;
+
+  /* Check first 2 bytes: Magic */
+  if (!IS_MAGIC (hptr, 'R', 'L') && !IS_MAGIC (hptr, 'B', 'M'))
+    {
+      D_ERROR ("Invalid magic (%c%c)!\n", hptr[0], hptr[1]);
+      return DFB_UNSUPPORTED;
+    }
+
+  /* Offset:00 --- 2 bytes: Magic */
+  READ_LE_16 (hptr, data->magic);
+
+  /* Offset:02 --- 4 bytes: FileSize */
+  READ_LE_32 (hptr, data->file_size);
+
+  /* Offset:06 --- 4 bytes: Reserved */
+  READ_LE_32 (hptr, data->reserved);
+
+  /* Offset:10 --- 4 bytes: DataOffset */
+  READ_LE_32 (hptr, data->img_offset);
+  if (data->img_offset < 54)
+    {
+      D_ERROR ("Invalid offset %08x!\n", data->img_offset);
+      return DFB_UNSUPPORTED;
+    }
+
+
+  /* Header section */
+  memset (header, 0, RLE_BIHEADER_SIZE);
+  ret = buffer_to_ptr_copy (data->common.base.buffer, header,
+                            RLE_BIHEADER_SIZE);
+  if (ret)
+    return ret;
+  hptr = header;
+
+  /* Offset:14 --- 4 bytes: HeaderSize */
+  READ_LE_32 (hptr, bihsize);
+  if (bihsize < 40)
+    {
+      D_ERROR ("Invalid image header size %d!\n", bihsize);
+      return DFB_UNSUPPORTED;
+    }
+
+  /* Offset:18 --- 4 bytes: Width */
+  READ_LE_32 (hptr, data->width);
+  if (data->width < 1 || data->width > 0xffff)
+    {
+      D_ERROR ("Invalid width %d!\n", data->width);
+      return DFB_UNSUPPORTED;
+    }
+
+  /* Offset:22 --- 4 bytes: Height */
+  READ_LE_32 (hptr, data->height_dib);
+  /* Deal with top-first mode DIB (negative height means just that ...) */
+  data->topfirst = data->height_dib < 0;
+  data->height   = data->topfirst ? -data->height_dib : data->height_dib;
+  if (data->height < 1 || data->height > 0xffff)
+    {
+      D_ERROR ("Invalid height %d!\n", data->height);
+      return DFB_UNSUPPORTED;
+    }
+
+  /* Offset:26 --- 2 bytes: Planes */
+  READ_LE_16 (hptr, data->num_planes);
+  if (data->num_planes != 1)
+    {
+      D_ERROR ("Unsupported number of planes %d!\n", data->num_planes);
+      return DFB_UNSUPPORTED;
+    }
+
+  /* Offset:28 --- 2 bytes: Depth */
+  READ_LE_16 (hptr, data->depth);
+  switch (data->depth)
+    {
+    case 1:
+    case 4:
+    case 8:
+      data->indexed = true;
+      /* fall through */
+    case 16:
+    case 24:
+    case 32:
+      break;
+
+    default:
+      D_ERROR ("Unsupported depth %d!\n", data->depth);
+      return DFB_UNSUPPORTED;
+    }
+
+  /* Offset:30 --- 4 bytes: Compression */
+  READ_LE_32 (hptr, data->compression);
+  switch (data->compression)
+    {
+    case RLEIC_NONE:
+      data->compressed = false;
+      break;
+
+    case RLEIC_BD_RLE8:
+      if (data->depth != 8)
+        {
+          D_ERROR ("Unsupported compression %d with depth %d!\n",
+                   data->compression, data->depth);
+          return DFB_UNSUPPORTED;
+        }
+      data->compressed = true;
+      break;
+
+    case RLEIC_RLE8:
+      if (data->depth != 8)
+        {
+          D_ERROR ("Unsupported compression %d with depth %d!\n",
+                   data->compression, data->depth);
+          return DFB_UNSUPPORTED;
+        }
+      data->compressed = true;
+      break;
+
+    case RLEIC_H2_DVD:
+      if (data->depth != 8)
+        {
+          D_ERROR ("Unsupported compression %d with depth %d!\n",
+                   data->compression, data->depth);
+          return DFB_UNSUPPORTED;
+        }
+      data->compressed = true;
+      D_INFO ("Detected H2DVD File\n");
+      break;
+
+    case RLEIC_H8_DVD:
+      if (data->depth != 8)
+        {
+          D_ERROR ("Unsupported compression %d with depth %d!\n",
+                   data->compression, data->depth);
+          return DFB_UNSUPPORTED;
+        }
+      data->compressed = true;
+      D_INFO ("Detected H8-DVD File\n");
+      break;
+
+    case RLEIC_RLE4:        /* Unimplemented as of version 1.1.0    */
+      if (data->depth != 4)
+        {
+          D_ERROR ("Unsupported compression %d with depth %d!\n",
+                   data->compression, data->depth);
+          return DFB_UNSUPPORTED;
+        }
+      data->compressed = true;
+      //break;
+
+    case RLEIC_BITFIELDS:   /* Unimplemented (no plans for support) */
+      data->compressed = false;
+
+    default:
+      D_ERROR ("Unsupported compression - %d!\n", data->compression);
+      return DFB_UNSUPPORTED;
+    }
+
+  /* Offset:34 --- 4 bytes: CompressedSize */
+  READ_LE_32 (hptr, data->payload_size);
+
+  /* Offset:38 --- 4 bytes: HorizontalResolution */
+  READ_LE_32 (hptr, data->h_resolution);
+
+  /* Offset:42 --- 4 bytes: VerticalResolution */
+  READ_LE_32 (hptr, data->v_resolution);
+
+  /* Offset:46 --- 4 bytes: UsedColors */
+  READ_LE_32 (hptr, data->num_colors);
+
+  /* Offset:50 --- 4 bytes: ImportantColors (don't care ...) */
+  READ_LE_32 (hptr, data->imp_colors);
+
+  /* Offset:54 --- bihsize-40 bytes: Skip remaining bytes */
+  if (bihsize > 40)
+    {
+      bihsize -= 40;
+      while (bihsize--)
+        {
+          u8 b;
+          ret = buffer_to_ptr_copy (data->common.base.buffer, &b, 1);
+          if (ret)
+            return ret;
+        }
+    }
+
+
+  /* Fixup source data pitch - used for any source raster-scan image */
+  data->pitch        = (((data->width*data->depth + 7) >> 3) + 3) & ~3;
+
+  /* Special mode colormap-less indexed source picture */
+  data->no_palette   = data->indexed && (data->img_offset == RLE_PALETTE_IMAGE_OFFSET);
+
+  /* Setup number of colors anyway ... */
+  if (data->num_colors == 0)
+    data->num_colors = 1 << data->depth;
+
+
+  /* Offset:16+bihsize     --- 4 x num_colors bytes: Palette management*/
+  if (data->indexed && !data->no_palette)
+    {
+      uint      pal_size = data->num_colors;
+      void     *src;
+      DFBColor  c;
+      int       i;
+
+      data->palette = src = D_MALLOC (pal_size * 4);
+      if (!data->palette)
+        return D_OOM ();
+
+      ret = buffer_to_ptr_copy (data->common.base.buffer, src,
+                                data->num_colors * 4);
+      if (ret)
+        return ret;
+
+      for (i = 0; i < data->num_colors; ++i)
+        {
+          c.a = 0xff;
+          c.r = ((u8 *) src)[i * 4 + 2];
+          c.g = ((u8 *) src)[i * 4 + 1];
+          c.b = ((u8 *) src)[i * 4 + 0];
+
+          data->palette[i] = c;
+        }
+    }
+
+  return DFB_OK;
+}
+
+static DFBResult
+rle_decode_rgb_row (IDirectFBImageProvider_RLE_data *data,
+                    int                              row)
+{
+  DFBResult  ret;
+  u8         local_buf[data->pitch];
+  const u8  *buf;
+  u32       * const dst = data->common.image + row * data->width;
+  int        i;
+
+  if (data->indexed && data->no_palette)
+    return DFB_INVARG;
+
+  switch (data->compression)
+    {
+    case RLEIC_NONE:
+    case RLEIC_RLE4:
+    case RLEIC_RLE8:
+    case RLEIC_BD_RLE8:
+    case RLEIC_H2_DVD:
+    case RLEIC_H8_DVD:
+      break;
+
+    case RLEIC_BITFIELDS: /* Unimplemented */
+    default:
+      D_ERROR ("Unsupported compression %d!\n", data->compression);
+      return DFB_UNSUPPORTED;
+    }
+
+  if (data->indexed)
+    {
+      /* Source indexes picked up indirectly from decomp. buffer */
+      D_ASSERT (data->image_indexes != NULL);
+      if (data->depth > 8)
+        return DFB_INVARG;
+      buf = data->image_indexes + row * data->width;
+    }
+  else
+    {
+      /* Source (RGB or indexes) picked up directly from payload */
+      D_ASSERT (data->common.base.buffer != NULL);
+      ret = buffer_to_ptr_copy (data->common.base.buffer, local_buf,
+                                data->pitch);
+      if (ret)
+        return ret;
+      buf = local_buf;
+    }
+
+  D_ASSERT (data->common.image != NULL);
+
+  switch (data->depth)
+    {
+    case 1:
+    case 4:
+    case 8:
+      for (i = 0; i < data->width; ++i)
+        {
+          u8 byte = buf[i];
+          DFBColor c = data->palette[byte];
+          dst[i] = c.b | (c.g << 8) | (c.r << 16) | (c.a << 24);
+        }
+      break;
+
+    case 16:
+      for (i = 0; i < data->width; i++)
+        {
+          u32 r, g, b;
+          u16 c;
+
+          c = buf[i*2+0] | (buf[i*2+1]<<8);
+          r = (c >> 10) & 0x1f;
+          g = (c >>  5) & 0x1f;
+          b = (c      ) & 0x1f;
+          r = (r << 3) | (r >> 2);
+          g = (g << 3) | (g >> 2);
+          b = (b << 3) | (b >> 2);
+
+          dst[i] = b | (g<<8) | (r<<16) | 0xff000000;
+        }
+      break;
+
+    case 24:
+      for (i = 0; i < data->width; i++)
+        dst[i] = (0
+                  | 0xff000000
+                  | (buf[i * 3 + 2] << 16)
+                  | (buf[i * 3 + 1] <<  8)
+                  | (buf[i * 3 + 0]      )
+                 );
+      break;
+
+    case 32:
+      for (i = 0; i < data->width; i++)
+        dst[i] = (0
+                  | 0xff000000
+                  | (buf[i * 4 + 2] << 16)
+                  | (buf[i * 4 + 1] <<  8)
+                  | (buf[i * 4 + 0]      )
+                 );
+      break;
+
+    default:
+      return DFB_UNSUPPORTED;
+    }
+
+  return DFB_OK;
+}
+
+
+
+static DFBResult
+rle_expand_image_indexes (IDirectFBImageProvider_RLE_data *data)
+{
+  DFBResult ret;
+  u8        buf[data->pitch];
+  int       row;
+
+  switch (data->compression)
+    {
+    case RLEIC_NONE:
+      break;
+
+    case RLEIC_RLE4:
+    case RLEIC_RLE8:
+    case RLEIC_BD_RLE8:
+    case RLEIC_BITFIELDS: /* Unimplemented */
+    default:
+      D_ERROR ("Unsupported compression %d!\n", data->compression);
+      return DFB_UNSUPPORTED;
+    }
+
+  D_ASSERT (data->common.base.buffer != NULL);
+  D_ASSERT (data->image_indexes != NULL);
+
+
+  for (row = 0; row < data->height; ++row)
+    {
+      int y = data->topfirst ? row : data->height-1-row;
+      u8 * const dst = data->image_indexes + y * data->width;
+
+      /* Source (RGB or indexes) picked up directly from payload */
+      ret = buffer_to_ptr_copy (data->common.base.buffer, buf, data->pitch);
+      if (ret)
+        return ret;
+
+      switch (data->depth)
+        {
+        int i;
+
+        case 1:
+          for (i = 0; data->width; ++i)
+            dst[i] = buf[i >> 3] & (0x80 >> (i & 7));
+          break;
+
+        case 4:
+          for (i = 0; i < data->width; ++i)
+            dst[i] = buf[i >> 1] & (0xf0 >> (i & 1));
+          break;
+
+        case 8:
+          for (i = 0; i < data->width; ++i)
+            dst[i] = buf[i];
+          break;
+
+        default:
+          return DFB_UNSUPPORTED;
+        }
+    }
+
+  return DFB_OK;
+}
+
+
+
+static DFBResult
+rle_decode_BI_RLE8 (const u8 * const buffer,
+                    uint      size,
+                    u8       * const image,
+                    uint      w,
+                    uint      h,
+                    uint      top)
+{
+  const u8 *buffer_ptr = buffer;
+  const u8 * const buffer_end = buffer + size;
+
+  u16  run_length;
+  u8   byte;
+  u8   pixel;
+
+  u16  x = 0;
+  u16  y = 0;
+
+  u8       *image_ptr = rle_set_position (image, 0, y, w, h, top);
+  const u8 * const image_end = image + (h * w);
+
+  D_DEBUG_AT (HWRLE, "%s: input: %u bytes, output: %ux%u pixels\n",
+              __FUNCTION__, size, w, h);
+
+  while (buffer_ptr < buffer_end)
+    {
+      byte = rle_input_byte (&buffer_ptr, buffer_end);
+
+      if (byte > 0)
+        {
+          pixel = rle_input_byte (&buffer_ptr, buffer_end);
+
+          for (run_length = byte; run_length > 0 && x < w; --run_length, ++x)
+            rle_output_byte (&image_ptr, image_end, pixel);
+
+          continue;
+        }
+
+      byte = rle_input_byte (&buffer_ptr, buffer_end);
+
+      switch (byte)
+        {
+        case 0:
+          x = 0;
+          ++y;
+          image_ptr = rle_set_position (image, x, y, w, h, top);
+          break;
+
+        case 1:
+          buffer_ptr = buffer_end;
+          break;
+
+        case 2:
+          x += rle_input_byte (&buffer_ptr, buffer_end);
+          y += rle_input_byte (&buffer_ptr, buffer_end);
+          image_ptr = rle_set_position (image, x, y, w, h, top);
+          break;
+
+        default:
+          for (run_length = byte; run_length > 0 && x < w; --run_length, ++x)
+            {
+              pixel = rle_input_byte (&buffer_ptr, buffer_end);
+              rle_output_byte (&image_ptr, image_end, pixel);
+            }
+          buffer_ptr += run_length;
+          if (byte & 1)
+            rle_input_byte (&buffer_ptr, buffer_end);
+        }
+    }
+
+  return DFB_OK;
+}
+
+
+static unsigned int
+rle_get_n_bits (const u8       ** const buffer_ptr_ptr,
+                const u8        * const buffer_end,
+                unsigned short   n)
+{
+  unsigned int dest = 0;
+  static unsigned short currentbit = 7; /* Start at left most bit */
+  static unsigned short srcbyte;
+
+  if (!n)
+    return 0; /* 0 bits == 0 */
+
+  /* Re-Align to Byte Boundary */
+  if (n > sizeof (unsigned int) * 8)
+    {
+      currentbit = 7;
+      return 0;
+    }
+
+  for ( ; n; --n) /* iterate until n or currentbit runs out */
+    {
+      unsigned int tmp;
+
+      if (currentbit == 7)
+        srcbyte = rle_input_byte (buffer_ptr_ptr, buffer_end);
+
+      //printf(".");
+      tmp = (srcbyte & (1 << currentbit));
+      tmp = tmp >> currentbit;
+      tmp = tmp << (n - 1);
+
+      if (currentbit)
+        --currentbit;
+      else
+        currentbit = 7;
+
+      dest |= tmp;
+    }
+
+  //printf("dest = %x : n = %d, currentbit = %d\n", dest, n, currentbit);
+
+  return dest;
+}
+
+
+static u8
+__attribute__((unused))
+rle_fetch_half_byte (const u8 ** const buffer_ptr_ptr,
+                     const u8  * const buffer_end)
+{
+  static bool top = 1;
+  static u8   byte = 0;
+
+  if (top)
+    {
+      byte = rle_input_byte (buffer_ptr_ptr, buffer_end);
+      D_DEBUG_AT (HWRLE, "%s: byte: {%x}\n", __FUNCTION__, byte);
+      top = 0;
+      return byte >> 4;
+    }
+  else
+    {
+      top = 1;
+      return byte & 0x0f;
+    }
+}
+
+static DFBResult
+rle_decode_H2_DVD (const u8 * const buffer,
+                   uint      size,
+                   u8       * const image,
+                   uint      w,
+                   uint      h)
+{
+  const u8 *buffer_ptr = buffer;
+  const u8 * const buffer_end = buffer + size;
+
+  u16 run_length;
+  u8  pixel;
+
+  uint x = 0;
+  uint y = 0;
+
+  u8       *image_ptr = image;
+  const u8 * const image_end = image + (h * w);
+
+  D_DEBUG_AT (HWRLE, "%s: input: %u bytes, output: %ux%u pixels\n",
+              __FUNCTION__, size, w, h);
+
+  while (buffer_ptr < buffer_end)
+    {
+      unsigned int v, t;
+
+      v = 0;
+
+      for (t = 1; v < t && t <= 0x40; t <<= 2)
+        v = (v << 4) | rle_get_n_bits (&buffer_ptr, buffer_end, 4);
+
+      pixel = v & 3;
+
+      if (v < 4)  /* Code for fill rest of line */
+        run_length = w - x;
+      else
+        run_length = v >> 2;
+
+
+      //run_length = MIN( w - x, run_length );
+
+      //printf("[x:%d r:%d p:%d]", x, run_length, pixel);
+
+      while (run_length--)
+        {
+          rle_output_byte (&image_ptr, image_end, pixel);
+          ++x;
+
+          /* EOL Check */
+          if (x >= w)
+            {
+              //D_ERROR ("Run passed EOL x=%d, w=%d, y=%d\n",x, w, y);
+              x = 0;
+              ++y;
+            }
+
+          if (y > h)
+            {
+              D_ERROR ("%s: Run passed EOF y/h: %d/%d, run_length: %d\n",
+                       __FUNCTION__, y, h, run_length);
+              return DFB_OK;
+            }
+        }
+    }
+
+  return DFB_OK;
+}
+
+
+
+static DFBResult
+rle_decode_H8_DVD (const u8 * const buffer,
+                   uint      size,
+                   u8       * const image,
+                   uint      w,
+                   uint      h)
+{
+  const u8 *buffer_ptr = buffer;
+  const u8 * const buffer_end = buffer + size;
+
+  uint x = 0;
+  uint y = 0;
+
+  u8       *image_ptr = image;
+  const u8 * const image_end = image + (h * w);
+
+  D_DEBUG_AT (HWRLE, "%s: input: %u bytes, output: %ux%u pixels\n",
+              __FUNCTION__, size, w, h);
+
+  while (buffer_ptr < buffer_end)
+    {
+      u8  pixel;
+      u32 run_length;
+
+      bool run = rle_get_n_bits (&buffer_ptr, buffer_end, 1);
+
+      /* Read Pixel Value */
+      bool eightbit = rle_get_n_bits (&buffer_ptr, buffer_end, 1);
+
+      if (eightbit)
+        pixel = rle_get_n_bits (&buffer_ptr, buffer_end, 8);
+      else
+        pixel = rle_get_n_bits (&buffer_ptr, buffer_end, 2);
+
+      /* Establish Run-Length */
+      if (run)
+        {
+          if (rle_get_n_bits (&buffer_ptr, buffer_end, 1) /* b4 or b10 */)
+            {
+              run_length = rle_get_n_bits (&buffer_ptr, buffer_end, 7);
+              if (run_length)
+                run_length += 9;
+              else
+                /* Run till EOL */
+                run_length = w - x;
+            }
+          else
+            run_length = rle_get_n_bits (&buffer_ptr, buffer_end, 3) + 2;
+        }
+      else
+        run_length = 1;
+
+      //printf("[x:%d y:%d r:0x%x p:%d]", x, y, run_length, pixel);
+
+      run_length = MIN (w - x, run_length); /* Run shouldn't over run a line! */
+
+      while (run_length-- > 0)
+        {
+          rle_output_byte (&image_ptr, image_end, pixel);
+          ++x;
+
+          /* EOL Check */
+          if (x >= w)
+            {
+              //D_ERROR ("Run passed EOL x=%d, w=%d, y=%d\n",x, w, y);
+              x = 0;
+              ++y;
+
+              /* Align bit stream */
+              rle_get_n_bits (&buffer_ptr, buffer_end, -1);
+            }
+
+          if (y >= h)
+            {
+              D_ERROR ("%s: Run passed EOF y/h: %d/%d, run_length: %d\n",
+                       __FUNCTION__, y, h, run_length);
+              return DFB_OK;
+            }
+        }
+    }
+
+  D_DEBUG_AT (HWRLE, "%s: decode completed @ x/y: %u/%u\n",
+              __FUNCTION__, x , y);
+
+  return DFB_OK;
+}
+
+
+static DFBResult
+rle_decode_BD_RLE8 (const u8 * const buffer,
+                    uint      size,
+                    u8       * const image,
+                    uint      w,
+                    uint      h)
+{
+  const u8 *buffer_ptr = buffer;
+  const u8 * const buffer_end = buffer + size;
+
+  const u8 long_run_length = 0x40;
+  const u8 non_zero_run    = 0x80;
+
+  uint x = 0;
+  uint y = 0;
+
+  u8       *image_ptr = image;
+  const u8 * const image_end = image + (h * w);
+
+  D_DEBUG_AT (HWRLE, "%s: input: %u bytes, output: %ux%u pixels\n",
+              __FUNCTION__, size, w, h);
+
+  while (buffer_ptr < buffer_end)
+    {
+      u8  pixel;
+      u8  byte;
+      u16 run_length;
+
+      pixel = rle_input_byte (&buffer_ptr, buffer_end);
+      if (pixel > 0)
+        {
+          rle_output_byte (&image_ptr, image_end, pixel);
+          ++x;
+          continue;
+        }
+
+      byte = rle_input_byte (&buffer_ptr, buffer_end);
+      if (byte == 0)
+        {
+          if (y < h)
+            {
+              x = 0;
+              ++y;
+              image_ptr = image + (w * y);
+              continue;
+            }
+          else
+            break;
+        }
+
+      if (byte & long_run_length)
+        {
+          run_length   = byte & 0x3f;
+          run_length <<= 8;
+          run_length  |= rle_input_byte (&buffer_ptr, buffer_end);
+        }
+      else
+        run_length = byte & 0x3f;
+
+      if (byte & non_zero_run)
+        pixel = rle_input_byte (&buffer_ptr, buffer_end);
+      else
+        pixel = 0;
+
+      while (run_length--)
+        {
+          rle_output_byte (&image_ptr, image_end, pixel);
+          ++x;
+        }
+    }
+
+  return DFB_OK;
+}
+
+
+static DFBResult
+rle_decode_BI_RLE4 (const u8 * const buffer,
+                    uint      size,
+                    u8       * const data_ptr,
+                    uint      w,
+                    uint      h,
+                    uint      top)
+{
+  D_WARN ("Unimplemented compression format in %s!\n", __FUNCTION__);
+
+  return DFB_UNIMPLEMENTED;
+}
+
+
+
+static DFBResult
+rle_decode_index_block (IDirectFBImageProvider_RLE_data *data)
+{
+  DFBResult  ret    = DFB_OK;
+  uint       size   = data->payload_size;
+  u8        *dst    = data->image_indexes;
+  uint       width  = data->width;
+  uint       height = data->height;
+  uint       top    = data->topfirst ? 1 : 0;
+  u8         buf[size];
+
+  switch (data->compression)
+    {
+    case RLEIC_NONE:
+      switch (data->depth)
+        {
+        case 1:
+        case 4:
+        case 8:
+          break;
+
+        default:
+          return DFB_UNSUPPORTED;
+        }
+
+      ret = rle_expand_image_indexes (data);
+      break;
+
+    case RLEIC_RLE8:
+      ret = buffer_to_ptr_copy (data->common.base.buffer, buf, size);
+      if (ret)
+        return ret;
+
+      if (data->depth != 8)
+        {
+          D_ERROR ("%s: Unsupported compression %d with depth %d!\n",
+                   __FUNCTION__, data->compression, data->depth);
+          return DFB_UNSUPPORTED;
+        }
+
+      ret = rle_decode_BI_RLE8 (buf, size, dst, width, height, top);
+      break;
+
+    case RLEIC_BD_RLE8:
+      ret = buffer_to_ptr_copy (data->common.base.buffer, buf, size);
+      if (ret)
+        return ret;
+
+      if (data->depth != 8)
+        {
+          D_ERROR ("%s: Unsupported compression %d with depth %d!\n",
+                   __FUNCTION__, data->compression, data->depth);
+          return DFB_UNSUPPORTED;
+        }
+
+      ret = rle_decode_BD_RLE8 (buf, size, dst, width, height);
+      break;
+
+    case RLEIC_H2_DVD:
+      ret = buffer_to_ptr_copy (data->common.base.buffer, buf, size);
+      if (ret)
+        return ret;
+
+      if (data->depth != 8)
+        {
+          D_ERROR ("%s: Unsupported compression %d with depth %d!\n",
+                   __FUNCTION__, data->compression, data->depth);
+          return DFB_UNSUPPORTED;
+        }
+
+      ret = rle_decode_H2_DVD (buf, size, dst, width, height);
+      break;
+
+    case RLEIC_H8_DVD:
+      ret = buffer_to_ptr_copy (data->common.base.buffer, buf, size);
+      if (ret)
+        return ret;
+
+      if (data->depth != 8)
+        {
+          D_ERROR ("%s: Unsupported compression %d with depth %d!\n",
+                   __FUNCTION__, data->compression, data->depth);
+          return DFB_UNSUPPORTED;
+        }
+
+      ret = rle_decode_H8_DVD (buf, size, dst, width, height);
+      break;
+
+    case RLEIC_RLE4:      /* Unimplemented as of version 1.0.0 */
+      ret = buffer_to_ptr_copy (data->common.base.buffer, buf, size);
+      if (ret)
+        return ret;
+
+      if (data->depth != 4)
+        {
+          D_ERROR ("%s: Unsupported compression %d with depth %d!\n",
+                   __FUNCTION__, data->compression, data->depth);
+          return DFB_UNSUPPORTED;
+        }
+
+      ret = rle_decode_BI_RLE4 (buf, size, dst, width, height, top);
+      break;
+
+    default:
+      D_ERROR ("%s: Unsupported compression %d!\n",
+               __FUNCTION__, data->compression);
+      return DFB_UNSUPPORTED;
+    }
+
+  return ret;
+}
+
+
+/*******************************************************************************
+ *
+ *                      PRIVATE STATIC SECTION     (Hardware Decode Section)
+ *
+ *******************************************************************************/
+
+#if defined(RLE_PROVIDER_HW)
+#include <../gfxdrivers/stgfx/stgfx.h>
+#include <../gfxdrivers/stgfx2/stm_gfxdriver.h>
+#include <dlfcn.h>
+static STMFB_GFXMEMORY_PARTITION
+bdisp_surface_pool_get_partition (const CoreSurfacePool * const pool)
+{
+  unsigned i;
+
+  switch (dfb_system_get_accelerator ())
+    {
+    case FB_ACCEL_ST_GAMMA:
+    case FB_ACCEL_ST_BDISP:
+      {
+      const STGFXDeviceData * const stdev = dfb_gfxcard_get_device_data ();
+      for (i = 0; i < D_ARRAY_SIZE (stdev->aux_pools); ++i)
+        if (stdev->aux_pools[i] == pool)
+          return STMFBGP_GFX0 + i;
+      }
+      break;
+
+    case FB_ACCEL_ST_BDISP_USER:
+      {
+      const STGFX2DeviceData * const stdev = dfb_gfxcard_get_device_data ();
+      for (i = 0; i < D_ARRAY_SIZE (stdev->aux_pools); ++i)
+        if (stdev->aux_pools[i] == pool)
+          return STMFBGP_GFX0 + i;
+      }
+      break;
+
+    default:
+      return STMFBGP_FRAMEBUFFER;
+    }
+
+  return STMFBGP_FRAMEBUFFER;
+}
+
+
+static DFBResult
+stgfb_hardware_rle_decode (IDirectFBImageProvider * const thiz,
+                           IDirectFBSurface       * const destination,
+                           DFBRectangle           * const dest_rect)
+{
+  DFBResult             dfbret;
+  CoreSurfaceBufferLock lock;
+
+  DIRECT_INTERFACE_GET_DATA (IDirectFBImageProvider_RLE)
+
+  IDirectFBSurface_data * const dst_data = destination->priv;
+
+  switch (data->compression)
+    {
+    case RLEIC_BD_RLE8:
+      /* Supported BDisp Decode */
+      break;
+
+    case RLEIC_H2_DVD:	/* Currently Unsupported in BDisp */
+    case RLEIC_H8_DVD:  /* Move when available */
+    default:
+      return DFB_UNSUPPORTED;
+    }
+
+  /* BDisp decode follows ... */
+  D_DEBUG_AT (HWRLE, "%s: attempting BDisp decode\n", __FUNCTION__);
+
+  /* We must ensure the parameters are correct for the Blit, or the blitter
+     will hang */
+
+  /* Ensure dest_rect matches the appropriate width and height */
+  if (dest_rect->w != data->width
+      || dest_rect->h != data->height)
+    {
+      D_ERROR ("%s: invalid arguments: dest w/h: %d/%d, w/h: %u/%u\n",
+               __FUNCTION__, 
+               dest_rect->w, dest_rect->h, data->width, data->height);
+      return DFB_INVARG;
+    }
+
+  /* We only need to create and load the raw RLE data once. After that, we
+     can just blit this quickly to dest. */
+  if (!data->compressed_data)
+    {
+      CoreSurfaceConfig config;
+
+      config.flags = CSCONF_SIZE | CSCONF_FORMAT | CSCONF_CAPS;
+      config.size.w = data->payload_size;
+      config.size.h = 1;
+      config.format = DSPF_A8; /* any 8bpp format would work here */
+      config.caps   = DSCAPS_VIDEOONLY;
+      #ifdef DIRECT_BUILD_DEBUG
+      config.caps   |= DSCAPS_SHARED;
+      #endif
+
+      if (dfb_surface_create (data->common.core,
+                              &config,
+                              CSTF_NONE,
+                              0,
+                              NULL,
+                              &data->compressed_data))
+        return DFB_NOVIDEOMEMORY;
+
+      /**** copy data onto raw surface ****/
+
+      /* Set Data Buffer pointer ... */
+      data->common.buffer->SeekTo (data->common.buffer, data->img_offset);
+
+      dfbret = dfb_surface_lock_buffer (data->compressed_data, CSBR_BACK,
+                                        CSAID_CPU, CSAF_WRITE, &lock);
+      if (dfbret)
+        return dfbret;
+
+      dfbret = buffer_to_ptr_copy (data->common.buffer, lock.addr,
+                                   data->payload_size);
+      dfb_surface_unlock_buffer (data->compressed_data, &lock);
+      if (dfbret)
+        return dfbret;
+    }
+
+  /* the following code tries to do the stretch blit through stgfx2, if that
+     fails, the normal approach through the ioctl() interface is done for the
+     kernel based driver */
+  bool direct_success = false;
+  CoreSurfaceBufferLock lock_src, lock_dst;
+
+  dfbret = dfb_surface_lock_buffer (data->compressed_data, CSBR_BACK,
+                                    CSAID_GPU, CSAF_READ, &lock_src);
+  if (dfbret)
+    return dfbret;
+  dfbret = dfb_surface_lock_buffer (dst_data->surface, CSBR_BACK,
+                                    CSAID_GPU, CSAF_WRITE, &lock_dst);
+  if (dfbret)
+    {
+      dfb_surface_unlock_buffer (data->compressed_data, &lock_src);
+      return dfbret;
+    }
+
+  if (likely (data->rle_stretch))
+    direct_success = data->rle_stretch (dfb_gfxcard_get_driver_data (),
+                                        dfb_gfxcard_get_device_data (),
+                                        lock_src.phys,
+                                        data->compressed_data->config.size.w,
+                                        &lock_dst,
+                                        dest_rect);
+  if (likely (direct_success))
+    ;
+  else
+    {
+      static const SURF_FMT  rleic_to_surf[] = { SURF_RLD_BD, SURF_RLD_H2,
+                                                 SURF_RLD_H8 };
+      STMFBIO_BLT_DATA       blit;
+      /* this is needed to obtain framebuffer fd */
+      const FBDev           * const dfb_fbdev = (FBDev *) dfb_system_data ();
+
+      /* Create command structure to send to FBDev */
+      /* Request decode operation to destination surface */
+
+      /* Perform a Copy Blit. STGFB will treat RLE as a surface type. */
+      blit.operation = BLT_OP_COPY;
+
+      /* Inform copy complex that this is an RLE Decode */
+      blit.ulFlags = BLT_OP_FLAGS_RLE_DECODE;
+
+      blit.srcMemBase = bdisp_surface_pool_get_partition (lock_src.allocation->pool);
+      blit.srcOffset  = lock_src.offset;
+      blit.srcPitch   = data->compressed_data->config.size.w;
+      blit.srcFormat  = rleic_to_surf[data->compression - RLEIC_BD_RLE8];
+
+      blit.dstMemBase = bdisp_surface_pool_get_partition (lock_dst.allocation->pool);
+      blit.dstOffset  = lock_dst.offset;
+      blit.dstPitch   = lock_dst.pitch;
+
+      blit.src_top    = 0;
+      blit.src_bottom = data->compressed_data->config.size.h;
+      blit.src_left   = 0;
+      blit.src_right  = 0;
+
+      /* (data->indexed) ? DSPF_LUT8 : DSPF_RGB32; */
+      blit.dstFormat  = (data->indexed) ? SURF_CLUT8 : SURF_ARGB8888;
+
+      if (dest_rect)
+        {
+          blit.dst_left   = dest_rect->x;
+          blit.dst_top    = dest_rect->y;
+          blit.dst_right  = dest_rect->x + dest_rect->w;
+          blit.dst_bottom = dest_rect->y + dest_rect->h;
+        }
+      else
+        {
+          blit.dst_left   = 0;
+          blit.dst_top    = 0;
+          blit.dst_right  = dst_data->surface->config.size.w;
+          blit.dst_bottom = dst_data->surface->config.size.h;
+        }
+
+      /* Send the ioctl */
+      D_DEBUG_AT (HWRLE,
+                  "%s: flags: %.8lx src base/l/r/t/b: %d/%hu/%hu/%hu/%hu "
+                  "dst base/l/r/t/b: %d/%hu/%hu/%hu/%hu\n", __FUNCTION__,
+                  blit.ulFlags,
+                  blit.srcMemBase, blit.src_left, blit.src_right,
+                  blit.src_top, blit.src_bottom,
+                  blit.dstMemBase, blit.dst_left, blit.dst_right,
+                  blit.dst_top, blit.dst_bottom);
+      D_DEBUG_AT (HWRLE, "%s: src offs/pitch/fmt: %.8lx/%lu/%d "
+                  "dst offs/pitch/fmt: %.8lx/%lu/%d\n", __FUNCTION__,
+                  blit.srcOffset, blit.srcPitch, blit.srcFormat,
+                  blit.dstOffset, blit.dstPitch, blit.dstFormat);
+
+#ifdef ALLOW_DUMP_RAW_TO_FILE
+      if (getenv ("RLE_DUMP_RAW_TO_FILE"))
+        {
+          char fn[1024];
+          FILE *f;
+          const STMFBIO_BLT_DATA * const r = &blit;
+
+          snprintf (fn, sizeof (fn), "/tmp/rle/raw_%05d.txt", data->idx);
+          if ((f = fopen (fn, "w+")) != NULL)
+            {
+              fprintf (f,
+                       "op %d, flg %.8lx, col %.8lx, alph %.8lx, key %.8lx, msk %.8lx\n"
+                       "src: %u + %lu, pitch %lu\n"
+                       "dst: %u + %lu, pitch %lu\n"
+                       "src/dst fmt %d/%d"
+                       "src: t/p/l/r %hu %hu %hu %hu"
+                       "dst: t/p/l/r %hu %hu %hu %hu\n",
+                       r->operation, r->ulFlags,
+                       r->colour, r->globalAlpha, r->colourKey, r->planeMask,
+                       r->srcMemBase, r->srcOffset, r->srcPitch,
+                       r->dstMemBase, r->dstOffset, r->dstPitch,
+                       r->srcFormat, r->dstFormat,
+                       r->src_top, r->src_bottom, r->src_left, r->src_right,
+                       r->dst_top, r->dst_bottom, r->dst_left, r->dst_right);
+              fflush (f);
+              fclose (f);
+            }
+          else
+            fprintf (stderr, "Failed to open file %05d\n", data->idx);
+        }
+#endif /* ALLOW_DUMP_RAW_TO_FILE */
+
+      int ret;
+      if ((ret = ioctl (dfb_fbdev->fd, STMFBIO_BLT, &blit)) == 0)
+        {
+          D_DEBUG_AT (HWRLE,
+                      "%s: success: input: %d bytes, output: %dx%d pixels\n",
+                      __FUNCTION__, data->compressed_data->config.size.w,
+                      dst_data->surface->config.size.w,
+                      dst_data->surface->config.size.h);
+          dfbret = DFB_OK;
+        }
+      else
+        {
+          D_DEBUG_AT (HWRLE,
+                      "%s: failed: %d input: %d bytes, output: %dx%d pixels\n",
+                      __FUNCTION__, errno, data->compressed_data->config.size.w,
+                      dst_data->surface->config.size.w,
+                      dst_data->surface->config.size.h);
+          dfbret = DFB_FAILURE;
+        }
+    }
+  dfb_surface_unlock_buffer (dst_data->surface, &lock_dst);
+  dfb_surface_unlock_buffer (data->compressed_data, &lock_src);
+
+  if (dfbret == DFB_OK)
+    {
+      deb_gettimeofday (&data->common.endtime, NULL);
+      deb_timersub (&data->common.endtime, &data->common.starttime,
+                    &data->common.endtime);
+      D_DEBUG_AT (HWRLE_TIME, "  -> BDispII RLE decode total time %lu.%06lu\n",
+                  data->common.endtime.tv_sec, data->common.endtime.tv_usec);
+    }
+
+  return dfbret;
+}
+#else /* RLE_PROVIDER_HW */
+#define stgfb_hardware_rle_decode(thiz,destination,dest_rect) DFB_UNIMPLEMENTED
+#endif /* RLE_PROVIDER_HW */
+
+
+
+#if defined(RLE_PROVIDER_USE_MME)
+static void
+TransformerCallback (MME_Event_t    Event,
+                     MME_Command_t *CallbackData,
+                     void          *UserData)
+{
+  const RLEDecode_TransformReturnParams_t * const transform_result =
+    CallbackData->CmdStatus.AdditionalInfo_p;
+  struct _MMECommon * const mme = (struct _MMECommon *) UserData;
+
+  D_DEBUG_AT (HWRLE, "%sTransformerCallback: Event: %d: (%s)%s\n",
+              RED, Event, get_mme_event_string (Event), BLACK);
+  D_DEBUG_AT (HWRLE, "  -> CallbackData->CmdStatus.State: %d (%s)\n",
+              CallbackData->CmdStatus.State,
+              get_mme_state_string (CallbackData->CmdStatus.State));
+  D_DEBUG_AT (HWRLE, "  -> CallbackData->CmdStatus.CmdId: %u (%.8x)\n",
+              CallbackData->CmdStatus.CmdId,
+              CallbackData->CmdStatus.CmdId);
+  D_DEBUG_AT (HWRLE, "  -> CallbackData->CmdStatus.Error: %d (%s)\n",
+              CallbackData->CmdStatus.Error,
+              get_mme_error_string (CallbackData->CmdStatus.Error));
+  D_DEBUG_AT (HWRLE, "  -> CallbackData->CmdStatus.AdditionalInfoSize: %u\n",
+              CallbackData->CmdStatus.AdditionalInfoSize);
+  D_DEBUG_AT (HWRLE, "  -> mme->decode_success: %d\n", mme->decode_success);
+
+  switch (Event)
+    {
+    case MME_COMMAND_COMPLETED_EVT:
+      switch (CallbackData->CmdStatus.State)
+        {
+        case MME_COMMAND_COMPLETED:
+          if (CallbackData->CmdStatus.CmdId
+              == mme->TransformCommand.CmdStatus.CmdId)
+            {
+              deb_gettimeofday (&mme->endtime, NULL);
+              deb_timersub (&mme->endtime, &mme->starttime, &mme->endtime);
+              D_DEBUG_AT (HWRLE_TIME, "  -> MME decode total time %lu.%06lu\n",
+                          mme->endtime.tv_sec, mme->endtime.tv_usec);
+
+              D_DEBUG_AT (HWRLE, "  -> expanded bytes: %u\n",
+                          transform_result->BytesWritten);
+
+              D_DEBUG_AT (HWRLE, "  -> RLE result code: %d (%s)\n",
+                          transform_result->ErrorType,
+                          get_rle_error_string (transform_result->ErrorType));
+
+              mme->decode_success = 1;
+              sema_signal_event (&mme->decode_event);
+            }
+          else
+            {
+              /* buffer completed */
+              struct _MMEHelper_buffer *buf =
+                container_of (CallbackData->DataBuffers_p,
+                              struct _MMEHelper_buffer, buffer);
+
+              D_DEBUG_AT (HWRLE, "  -> buffer %p completed (container @ %p)\n",
+                          CallbackData->DataBuffers_p[0], buf);
+
+              sema_signal_event (&buf->sema);
+            }
+          break;
+
+        case MME_COMMAND_FAILED:
+          D_WARN ("(%5d) %s: command %u (%.8x) failed: error %d (%s)",
+                  direct_gettid (), mme->name,
+                  CallbackData->CmdStatus.CmdId,
+                  CallbackData->CmdStatus.CmdId,
+                  CallbackData->CmdStatus.Error,
+                  get_mme_error_string (CallbackData->CmdStatus.Error));
+
+          if (CallbackData->CmdStatus.CmdId
+              == mme->TransformCommand.CmdStatus.CmdId)
+            {
+              mme->decode_success = -1;
+
+              /* On Failure allow main flow to continue and tidy up */
+              sema_signal_event (&mme->decode_event);
+            }
+          break;
+
+        case MME_COMMAND_IDLE:
+        case MME_COMMAND_PENDING:
+        case MME_COMMAND_EXECUTING:
+        default:
+          D_WARN ("(%5d) %s: command %u (%.8x) completed in unknown state: %d (%s)",
+                  direct_gettid (), mme->name,
+                  CallbackData->CmdStatus.CmdId, CallbackData->CmdStatus.CmdId,
+                  CallbackData->CmdStatus.State,
+                  get_mme_state_string (CallbackData->CmdStatus.State));
+          break;
+        }
+      break; /* MME_COMMAND_COMPLETED_EVT */
+
+    case MME_DATA_UNDERFLOW_EVT:
+      ++mme->n_underflows;
+      break; /* MME_DATA_UNDERFLOW_EVT */
+
+    case MME_NOT_ENOUGH_MEMORY_EVT:
+    case MME_NEW_COMMAND_EVT:
+    default:
+      D_WARN ("(%5d) %s: unhandled event %d (%s) occured on command %u (%.8x)",
+              direct_gettid (), mme->name, Event,
+              get_mme_event_string (Event), CallbackData->CmdStatus.CmdId,
+              CallbackData->CmdStatus.CmdId);
+
+      D_WARN ("(%5d) %s: CallbackData->CmdStatus.AdditionalInfoSize: %u",
+              direct_gettid (), mme->name, CallbackData->CmdStatus.AdditionalInfoSize);
+
+      if (CallbackData->CmdStatus.CmdId == mme->TransformCommand.CmdStatus.CmdId)
+        {
+          D_WARN ("(%5d) %s: transform_result->bytes_written: %u",
+                  direct_gettid (), mme->name, transform_result->BytesWritten);
+          D_WARN ("(%5d) %s: result code: %d (%s)\n", direct_gettid (),
+                  mme->name, transform_result->ErrorType,
+                  get_rle_error_string (transform_result->ErrorType));
+        }
+      break;
+    } /* switch (Event) */
+}
+
+
+static DFBResult
+abort_transformer (struct _MMECommon * const mme)
+{
+  IDirectFBImageProvider_RLE_data * const data =
+    container_of (mme, IDirectFBImageProvider_RLE_data, common);
+
+  if (!mme)
+       return DFB_THIZNULL;
+
+  if (!data)
+       return DFB_DEAD;
+
+  return DFB_OK;
+}
+
+
+
+static DFBResult
+send_rle_image (struct _MMECommon * const data)
+{
+  DFBResult res = MME_SUCCESS;
+
+  unsigned int i;
+
+  mme_helper_calculate_packets (data);
+  D_ASSERT (data->packets == 1);
+
+  /* Clean buffer pointers, as we create based on them being empty! */
+  memset (&data->SendDataBuffers, 0, sizeof (data->SendDataBuffers));
+
+  D_DEBUG_AT (HWRLE, "%s: iterating %d packets for %f chunks of data out of "
+              "%d bytes\n", __FUNCTION__,
+              data->packets,
+              (float) ((float) data->bytes / (float) MME_STREAMING_BUFFERSIZE),
+              data->bytes);
+  //data->InDataBuffers = (MME_DataBuffer_t **)D_MALLOC(sizeof(MME_DataBuffer_t *) * MAX_STREAMING_BUFFERS);
+
+  for (i = 0; i < data->packets; ++i)
+    {
+      unsigned int this_read = MIN (data->bytes, MME_STREAMING_BUFFERSIZE);
+      unsigned int currentbuffer = i % MAX_STREAMING_COMMANDS;
+      struct _MMEHelper_buffer * const buffer =
+        &data->SendDataBuffers[currentbuffer];
+
+      D_DEBUG_AT (HWRLE, "%s sending packet %u through buffer %u\n",
+                  __FUNCTION__, i, currentbuffer);
+
+      if (!buffer->buffer)
+        {
+          res = _alloc_send_buffer (data->Handle, this_read, buffer);
+          if (res != DFB_OK)
+            return res;
+        }
+      else
+        {
+          /* Wait for a buffer to be available (maybe in streaming version!) */
+          while ((sema_wait_event (&buffer->sema) == -1)
+                 && errno == EINTR)
+            ;
+        }
+
+      /* Some checking - We've waited ... should we continue ...*/
+      if (data->decode_success < 0)
+        {
+          D_WARN ("(%5d) ImageProvider/%s: error sending data. Transform "
+                  "error reported from callback",
+                  direct_gettid (), data->name);
+          sema_signal_event (&buffer->sema);
+          return DFB_FAILURE;
+        }
+
+      if (buffer_to_mme_copy (data->base.buffer, buffer->buffer,
+                              this_read) != DFB_OK)
+        {
+          D_WARN ("(%5d) Fetching %u bytes of data failed: res: %d",
+                  direct_gettid (), this_read, res);
+          sema_signal_event (&buffer->sema);
+          /* hm, DirectFB (always?) returns DFB_FAILURE here... */
+          return DFB_IO;
+        }
+
+      /* Subtract read data amount */
+      data->bytes -= this_read;
+
+      /* send the command */
+      D_DEBUG_AT (HWRLE, "%s: Send Data Command\n", __FUNCTION__);
+
+      res = MME_SendCommand (data->Handle, &buffer->command);
+
+      D_DEBUG_AT (HWRLE, "%s: sent data: %d bytes remaining\n",
+                  __FUNCTION__, data->bytes);
+
+      if (res != MME_SUCCESS)
+        {
+          D_ERROR ("%s: MME_SendCommand failed: buffer %u: %s\n",
+                   __FUNCTION__, currentbuffer, get_mme_error_string (res));
+          res = DFB_FAILURE;
+        }
+    }
+
+  return res;
+}
+
+static DFBResult
+lx_multicom_rle_decode (IDirectFBImageProvider *thiz,
+                        IDirectFBSurface       *destination,
+                        const DFBRectangle     *dest_rect)
+{
+  int                    err;
+
+  DFBRegion              clip;
+  DFBRectangle           rect;
+  DFBSurfacePixelFormat  format;
+  IDirectFBSurface_data *dst_data;
+  CoreSurface           *dst_surface;
+  CoreSurfaceBufferLock  lock;
+
+  DFBResult              ret;
+
+  dst_data = (IDirectFBSurface_data *) destination->priv;
+  DIRECT_INTERFACE_GET_DATA (IDirectFBImageProvider_RLE)
+
+  /* Initialise Multicom */
+  /* Send *WHOLE FILE* (LXRLEDecode has no streaming support) */
+  /* Request Transform (with output buffer) */
+  /* Hope it works */
+
+  /* Any problems - just bail out and let something else do it */
+
+  if (!dst_data)
+    return DFB_DEAD;
+
+  dst_surface = dst_data->surface;
+
+  if (!dst_surface)
+    return DFB_DESTROYED;
+
+  /* Need to check the pitch is the same as the width - or we'll be writing in the wrong buffer space */
+  /* If the pitch is not the same as the width - let SH4 handle it until the LX decoder is more advanced ! */
+
+  err = destination->GetPixelFormat (destination, &format);
+  if (err)
+    return err;
+
+  dfb_region_from_rectangle (&clip, &dst_data->area.current);
+
+  if (dest_rect)
+    {
+      if (dest_rect->w < 1 || dest_rect->h < 1)
+        return DFB_INVARG;
+
+      rect = *dest_rect;
+      rect.x += dst_data->area.wanted.x;
+      rect.y += dst_data->area.wanted.y;
+
+      if (!dfb_rectangle_region_intersects (&rect, &clip))
+        return DFB_OK;
+    }
+  else
+    rect = dst_data->area.wanted;
+
+  data->common.name = "hwRLE";
+  static const char * const transformers[] = { "RLE_DECODER",
+                                               "RLE_DECODER4",
+                                               "RLE_DECODER3",
+                                               "RLE_DECODER2",
+                                               "RLE_DECODER1",
+                                               "RLE_DECODER0",
+                                               NULL };
+  ret = mme_helper_init_transformer (&data->common, transformers, 0, NULL, NULL);
+  if (ret == DFB_OK)
+    {
+      bool locked = false;
+
+      sema_init_event (&data->common.decode_event, 0); /* Alerts to completion */
+
+      ret = send_rle_image (&data->common);
+      if (ret == DFB_OK)
+        {
+          ret = mme_helper_start_transformer (&data->common,
+                                              sizeof (RLEDecode_TransformReturnParams_t),
+                                              &data->ReturnParams,
+                                              0, NULL,
+                                              dst_surface, &lock);
+          if (ret == DFB_OK)
+            {
+              D_DEBUG_AT (HWRLE, "%s: waiting for completion\n", __FUNCTION__);
+
+              locked = true;
+
+              /* Wait until the decode is complete */
+              while ((sema_wait_event (&data->common.decode_event) == -1)
+                     && errno == EINTR)
+                ;
+
+              D_DEBUG_AT (HWRLE, "%s: performed LX decode\n", __FUNCTION__);
+            }
+        }
+
+      mme_helper_deinit_transformer (&data->common);
+
+      if (likely (locked))
+        dfb_surface_unlock_buffer (dst_surface, &lock);
+
+      if (data->common.OutDataBuffers)
+        {
+          D_FREE (data->common.OutDataBuffers);
+          data->common.OutDataBuffers = NULL;
+        }
+
+      unsigned i;
+      for (i = 0; i < D_ARRAY_SIZE (data->common.SendDataBuffers); ++i)
+        {
+          if (data->common.SendDataBuffers[i].buffer)
+            {
+              MME_FreeDataBuffer (data->common.SendDataBuffers[i].buffer);
+              data->common.SendDataBuffers[i].buffer = NULL;
+
+              sema_close_event (&data->common.SendDataBuffers[i].sema);
+            }
+        }
+
+      sema_close_event (&data->common.decode_event);
+    }
+
+  return ret;
+}
+#else /* RLE_PROVIDER_USE_MME */
+#define lx_multicom_rle_decode(thiz,destination,dest_rect) DFB_UNIMPLEMENTED
+#endif
+
+#if defined(RLE_PROVIDER_HW) || defined(RLE_PROVIDER_USE_MME)
+static DFBResult
+hardware_rle_decode (IDirectFBImageProvider * const thiz,
+                     IDirectFBSurface       * const destination,
+                     DFBRectangle           * const dest_rect)
+
+{
+  DFBResult ret;
+
+  DIRECT_INTERFACE_GET_DATA (IDirectFBImageProvider_RLE)
+
+  /* 1) try the BDisp in STGFB.
+     2) Then where supported try an LX ...
+     3) Finally - return - and let the image provider deal with the image
+        on the SH4
+  */
+
+  /* store the current data buffer position for software fallback should we
+     not succeed */
+  unsigned int bufpos;
+  data->common.base.buffer->GetPosition (data->common.base.buffer,
+                                         &bufpos);
+
+  deb_gettimeofday (&data->common.starttime, NULL);
+
+  switch (data->compression)
+    {
+    case RLEIC_BD_RLE8:
+#ifdef ALLOW_FORCE_SOFTWARE
+      if (getenv ("RLE_FORCE_SOFTWARE"))
+        {
+          ret = -1;
+          break;
+        }
+#endif /* ALLOW_FORCE_SOFTWARE */
+
+      ret = stgfb_hardware_rle_decode (thiz, destination, dest_rect);
+      break;
+
+      /* BD_RLE8 decoding seems to be b0rken on the LX */
+    case RLEIC_H2_DVD:
+    case RLEIC_H8_DVD:
+      ret = stgfb_hardware_rle_decode (thiz, destination, dest_rect);
+      if (unlikely (ret))
+        ret = lx_multicom_rle_decode (thiz, destination, dest_rect );
+      break;
+
+    default:
+      ret = DFB_UNSUPPORTED;
+      break;
+    }
+
+  /* Restore Buffer location to continue software decode */
+  data->common.base.buffer->SeekTo (data->common.base.buffer, bufpos);
+
+  return ret;
+}
+#else /* RLE_PROVIDER_HW || RLE_PROVIDER_USE_MME */
+#define hardware_rle_decode(thiz,destination,dest_rect) DFB_UNIMPLEMENTED
+#endif /* RLE_PROVIDER_HW || RLE_PROVIDER_USE_MME */
+
+
+/*******************************************************************************
+ *
+ *                      PUBLIC INTERFACE STATIC SECTION
+ *
+ *******************************************************************************/
+
+static DFBResult
+IDirectFBImageProvider_RLE_RenderTo (IDirectFBImageProvider *thiz,
+                                     IDirectFBSurface       *destination,
+                                     const DFBRectangle     *dest_rect)
+{
+  IDirectFBSurface_data  *dst_data;
+  CoreSurface            *dst_surface;
+  DFBRectangle            rect;
+  DFBRegion               clip;
+  CoreSurfaceBufferLock   lock;
+  DIRenderCallbackResult  cb_result = DIRCR_OK;
+  DFBResult               ret       = DFB_OK;
+
+  DIRECT_INTERFACE_GET_DATA (IDirectFBImageProvider_RLE)
+
+  if (!destination)
+    return DFB_INVARG;
+
+  dst_data = destination->priv;
+  if (!dst_data || !dst_data->surface)
+    return DFB_DESTROYED;
+
+  dst_surface = dst_data->surface;
+
+  if (dest_rect)
+    {
+      if (dest_rect->w < 1 || dest_rect->h < 1)
+        return DFB_INVARG;
+      rect = *dest_rect;
+      rect.x += dst_data->area.wanted.x;
+      rect.y += dst_data->area.wanted.y;
+    }
+  else
+    rect = dst_data->area.wanted;
+
+  dfb_region_from_rectangle (&clip, &dst_data->area.current);
+  if (!dfb_rectangle_region_intersects (&rect, &clip))
+    return DFB_OK;
+
+  /* Attempt a decode using the Any hardware acceleration available */
+  if (DFB_OK == hardware_rle_decode (thiz, destination, &rect))
+    return DFB_OK;
+
+  /* Hardware wasn't capable or happy. Lets try ourselves */
+
+  /* Software Decode */
+  ret = dfb_surface_lock_buffer (dst_surface, CSBR_BACK, CSAID_CPU,
+                                 CSAF_WRITE, &lock);
+  if (ret)
+    return ret;
+
+
+  /* Decompress RLE coded data to packed indexes into local buffer. */
+  if (data->indexed && !data->image_indexes)
+    {
+      struct timeval __attribute__ ((unused)) start, end;
+
+      data->image_indexes = D_MALLOC (data->width*data->height);
+
+      if (!data->image_indexes)
+        {
+          dfb_surface_unlock_buffer (dst_surface, &lock);
+          return D_OOM ();
+        }
+
+      /* Source indexes will be picked up indirectly from decomp. buffer */
+      data->common.base.buffer->SeekTo (data->common.base.buffer,
+                                        data->img_offset);
+
+      deb_gettimeofday (&start, NULL);
+
+      ret = rle_decode_index_block (data);
+      if (ret)
+        {
+          dfb_surface_unlock_buffer (dst_surface, &lock);
+          return ret;
+        }
+
+      deb_gettimeofday (&end, NULL);
+      deb_timersub (&end, &start, &end);
+      D_DEBUG_AT (HWRLE_TIME, "%s: SW RLE decode took %lu.%06lus\n",
+                  __FUNCTION__, end.tv_sec, end.tv_usec);
+    }
+
+  /* Special indexed to LUT8 loading. */
+  if (data->indexed && dst_surface->config.format == DSPF_LUT8)
+    {
+      bool direct;
+
+      if (!data->no_palette)
+        {
+          IDirectFBPalette *palette;
+          ret = destination->GetPalette (destination, &palette);
+          if (ret)
+            {
+              dfb_surface_unlock_buffer (dst_surface, &lock);
+              return ret;
+            }
+          palette->SetEntries (palette, data->palette, data->num_colors, 0);
+          palette->Release (palette);
+        }
+
+      /* Limitation for direct LUT8 access is to blit complete surface only */
+      direct = (rect.x == 0
+                && rect.y == 0
+                && rect.w == dst_surface->config.size.w
+                && rect.h == dst_surface->config.size.h
+                && rect.w == data->width
+                && rect.h == data->height);
+
+      if (direct)
+        {
+          int  y, row;
+
+          for (row = 0; row < data->height && cb_result == DIRCR_OK; ++row)
+            {
+              y = data->topfirst ? row : data->height-1-row;
+
+              direct_memcpy (lock.addr + lock.pitch * y,
+                             data->image_indexes + data->width * y,
+                             data->width);
+
+              if (data->common.base.render_callback)
+                {
+                  DFBRectangle r = (DFBRectangle) { 0, y, data->width, 1 };
+
+                  cb_result = data->common.base.render_callback (&r,
+                                                                 data->common.base.render_callback_context);
+                }
+            }
+
+          if (cb_result != DIRCR_OK)
+            ret = DFB_INTERRUPTED;
+
+          dfb_surface_unlock_buffer (dst_surface, &lock);
+          return ret;
+        }
+    }
+
+
+  /* Invalid indexed to non-direct LUT8 loading without attached colormap. */
+  if (data->indexed && data->no_palette)
+    {
+      dfb_surface_unlock_buffer (dst_surface, &lock);
+      return DFB_INVARG;
+    }
+
+
+  /* Convert to ARGB and use generic loading code. */
+  if (!data->common.image)
+    {
+      bool direct = (rect.w == data->width
+                     && rect.h == data->height
+                     && data->common.base.render_callback);
+      int  y, row;
+
+      data->common.image = D_MALLOC (data->width*data->height * 4);
+      if (!data->common.image)
+        {
+          dfb_surface_unlock_buffer (dst_surface, &lock);
+          return D_OOM ();
+        }
+
+      if (!data->indexed)
+        /* Source (RGB or indexes) picked up directly from payload */
+        data->common.base.buffer->SeekTo (data->common.base.buffer,
+                                          data->img_offset);
+
+      for (row = 0; row < data->height && cb_result == DIRCR_OK; ++row)
+        {
+          y = data->topfirst ? row : data->height-1-row;
+
+          ret = rle_decode_rgb_row (data, y);
+          if (ret)
+            break;
+
+          if (direct)
+            {
+              DFBRectangle r = { rect.x, rect.y+y, data->width, 1 };
+
+              dfb_copy_buffer_32 (data->common.image + y * data->width,
+                                  lock.addr, lock.pitch, &r, dst_surface,
+                                  &clip );
+
+              if (data->common.base.render_callback)
+                {
+                  r = (DFBRectangle) { 0, y, data->width, 1 };
+                  cb_result = data->common.base.render_callback (&r,
+                                                                 data->common.base.render_callback_context);
+                }
+            }
+        }
+
+      if (!direct)
+        {
+          dfb_scale_linear_32 (data->common.image, data->width, data->height,
+                               lock.addr, lock.pitch, &rect, dst_surface,
+                               &clip);
+
+          if (data->common.base.render_callback)
+            {
+              DFBRectangle r = { 0, 0, data->width, data->height };
+
+              data->common.base.render_callback (&r,
+                                                 data->common.base.render_callback_context);
+            }
+        }
+
+      if (cb_result != DIRCR_OK)
+        {
+          D_FREE (data->common.image);
+          data->common.image = NULL;
+          ret = DFB_INTERRUPTED;
+        }
+    }
+  else
+    {
+      dfb_scale_linear_32 (data->common.image, data->width, data->height,
+                           lock.addr, lock.pitch, &rect, dst_surface, &clip);
+
+      if (data->common.base.render_callback)
+        {
+          DFBRectangle r = {0, 0, data->width, data->height};
+          data->common.base.render_callback (&r,
+                                             data->common.base.render_callback_context);
+        }
+    }
+
+  //dfb_surface_dump (data->common.core, dst_surface, "results", "RLE-H2");
+
+  dfb_surface_unlock_buffer (dst_surface, &lock);
+  return ret;
+}
+
+static void
+IDirectFBImageProvider_RLE_Destruct (IDirectFBImageProvider *thiz)
+{
+  IDirectFBImageProvider_RLE_data *data = thiz->priv;
+
+#if defined(RLE_PROVIDER_HW)
+  dlclose (data->stgfx2_handle);
+#endif /* RLE_PROVIDER_HW */
+
+  if (data->common.image)
+    D_FREE (data->common.image);
+  if (data->image_indexes)
+    D_FREE (data->image_indexes);
+  if (data->palette)
+    D_FREE (data->palette);
+
+#if defined(RLE_PROVIDER_HW)
+  if (data->compressed_data)
+    {
+      dfb_surface_unref (data->compressed_data);
+      data->compressed_data = NULL;
+    }
+#endif
+
+#if defined(RLE_PROVIDER_USE_MME)
+  if (data->common.decode_surface)
+    dfb_surface_unref( data->common.decode_surface );
+#endif
+}
+
+static DFBResult
+IDirectFBImageProvider_RLE_GetSurfaceDescription (IDirectFBImageProvider *thiz,
+                                                  DFBSurfaceDescription  *desc)
+{
+  DIRECT_INTERFACE_GET_DATA (IDirectFBImageProvider_RLE)
+
+  if (!desc)
+    return DFB_INVARG;
+
+  desc->flags       = DSDESC_WIDTH | DSDESC_HEIGHT | DSDESC_PIXELFORMAT | DSDESC_CAPS;
+  desc->width       = data->width;
+  desc->height      = data->height;
+  desc->pixelformat = (data->indexed) ? DSPF_LUT8 : DSPF_RGB32;
+  desc->caps        = DSCAPS_NONE;
+
+  return DFB_OK;
+}
+
+static DFBResult
+IDirectFBImageProvider_RLE_GetImageDescription (IDirectFBImageProvider *thiz,
+                                                DFBImageDescription    *desc)
+{
+  DIRECT_INTERFACE_GET_DATA (IDirectFBImageProvider_RLE)
+
+  if (!desc)
+    return DFB_INVARG;
+
+  desc->caps = DICAPS_NONE;
+
+  return DFB_OK;
+}
+
+/*******************************************************************************
+ *
+ *              PUBLIC INTERFACE EXPORTED SYMBOLS SECTION
+ *
+ *******************************************************************************/
+
+static DFBResult
+Probe (IDirectFBImageProvider_ProbeContext *ctx)
+{
+  /* 2 bytes of Magic */
+  if (IS_MAGIC (ctx->header,'R','L')
+      || IS_MAGIC (ctx->header,'B','M'))
+    return DFB_OK;
+
+  return DFB_UNSUPPORTED;
+}
+
+#ifdef ALLOW_DUMP_RAW_TO_FILE
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+static char filename[4096];
+static const char *
+_get_filename (const char * const directory,
+               const char * const prefix,
+               int        * const idx)
+{
+  unsigned int num = 0;
+
+  if (prefix)
+    {
+      /* find the lowest unused index */
+      int found = false;
+      while (!found && ++num < 100000)
+        {
+          snprintf (filename, sizeof (filename),
+                    "%s/%s_%05d.rle", directory, prefix, num);
+          if (access (filename, F_OK) != 0)
+            /* found an available filename */
+            found = true;
+        }
+
+      if (!found)
+        {
+          D_ERROR ("DirectFBImageProvider_RLE:: "
+                   "couldn't find an unused index for RLE dump!\n");
+          return NULL;
+        }
+    }
+
+  if (idx)
+    *idx = num;
+
+  return filename;
+}
+#endif /* ALLOW_DUMP_RAW_TO_FILE */
+
+static DFBResult
+Construct (IDirectFBImageProvider *thiz,
+           ...)
+{
+  DFBResult ret;
+
+  IDirectFBDataBuffer *buffer;
+  CoreDFB             *core;
+  va_list              tag;
+
+  DIRECT_ALLOCATE_INTERFACE_DATA (thiz, IDirectFBImageProvider_RLE)
+
+  va_start (tag, thiz);
+  buffer = va_arg (tag, IDirectFBDataBuffer *);
+  core = va_arg (tag, CoreDFB *);
+  va_end (tag);
+
+  data->common.base.ref    = 1;
+  data->common.base.buffer = buffer;
+  data->common.base.core   = core;
+
+#if defined(RLE_PROVIDER_HW)
+  if (dfb_system_get_accelerator () == FB_ACCEL_ST_BDISP_USER)
+    {
+      data->stgfx2_handle = dlopen ("libdirectfb_stgfx2.so", RTLD_LAZY);
+      data->rle_stretch = dlsym (data->stgfx2_handle,
+                                 "bdisp_aq_StretchBlit_RLE");
+    }
+#endif
+
+  buffer->AddRef (buffer);
+
+#ifdef ALLOW_DUMP_RAW_TO_FILE
+  if (getenv ("RLE_DUMP_RAW_TO_FILE"))
+  {
+  const char * const fn = _get_filename ("/tmp/rle", "raw", &data->idx);
+  if (fn)
+    {
+      unsigned char buf[1024];
+      unsigned int len = sizeof (buf);
+
+      int dump_fd = open (fn, O_RDWR | O_CREAT | O_TRUNC, 0644);
+      if (dump_fd != -1)
+        {
+          DFBResult res;
+          unsigned int ret_len = len;
+          unsigned int total = 0;
+
+          while (len)
+            {
+              res = buffer->WaitForData (buffer, len);
+              if (res == DFB_OK)
+                res = buffer->GetData (buffer, len, buf, &ret_len);
+
+              if (res)
+                break;
+
+              write (dump_fd, buf, ret_len);
+
+              len = ret_len;
+
+              total += ret_len;
+            }
+          D_DEBUG_AT (HWRLE, "%s: wrote %d bytes to %d\n",
+                      __FUNCTION__, total, data->idx);
+
+          fsync (dump_fd);
+          close (dump_fd);
+          buffer->SeekTo (buffer, 0);
+        }
+    }
+  sync ();
+  sync ();
+  sync ();
+  }
+#endif /* ALLOW_DUMP_RAW_TO_FILE */
+
+  ret = rle_decode_header (data);
+  if (ret)
+    {
+      IDirectFBImageProvider_RLE_Destruct (thiz);
+      return ret;
+    }
+
+  data->common.base.Destruct = IDirectFBImageProvider_RLE_Destruct;
+
+  thiz->RenderTo              = IDirectFBImageProvider_RLE_RenderTo;
+  thiz->GetImageDescription   = IDirectFBImageProvider_RLE_GetImageDescription;
+  thiz->GetSurfaceDescription = IDirectFBImageProvider_RLE_GetSurfaceDescription;
+
+  return DFB_OK;
+}
diff -Naur DirectFB-1.7.7/interfaces/IDirectFBImageProvider/idirectfbimageprovider_rle.h DirectFB-1.7.7.stm/interfaces/IDirectFBImageProvider/idirectfbimageprovider_rle.h
--- DirectFB-1.7.7/interfaces/IDirectFBImageProvider/idirectfbimageprovider_rle.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7.stm/interfaces/IDirectFBImageProvider/idirectfbimageprovider_rle.h	2015-05-15 18:43:40.093411075 +0200
@@ -0,0 +1,135 @@
+#ifndef __IDIRECTFBIMAGEPROVIDER_RLE_H__
+#define __IDIRECTFBIMAGEPROVIDER_RLE_H__
+
+#include <stdarg.h>
+
+#include <direct/messages.h>
+
+
+#if defined(RLE_PROVIDER_USE_MME)
+/* HW Decode Requirements */
+#include <mme.h>
+#include <semaphore.h>
+
+#include <RLEDecode_interface.h>
+#endif /* RLE_PROVIDER_USE_MME */
+#if defined(RLE_PROVIDER_HW)
+#include <../gfxdrivers/stgfx2/bdisp_accel.h>
+#endif
+
+#define THIS_MODULE         "IDirectFBImageProvider_RLE"
+
+
+#ifdef  USE_MEDIA_TRACE
+#define TRACE(data) \
+    D_INFO(THIS_MODULE": %4.2xh (%6.2d) -> "#data"\n", (int)(data), (int)(data))
+#else
+#define TRACE(data)
+#endif
+
+
+/* local types */
+typedef        unsigned char    uchar;
+typedef        unsigned int     uint;
+typedef        unsigned long    ulong;
+typedef        unsigned short   ushort;
+
+
+
+/*
+ * RLE Compression identifier (see BMP/RLE header - Offset:30 --- DWORD)
+ */
+typedef enum {
+  RLEIC_NONE      = 0,   /* Implemented      as of version 1.0.0 */
+  RLEIC_RLE8      = 1,   /* Implemented      as of version 1.0.0 */
+  RLEIC_RLE4      = 2,   /* Unimplemented */
+  RLEIC_BITFIELDS = 3,   /* Unimplemented */
+  RLEIC_BD_RLE8   = 4,   /* Implemented      as of version 1.1.0 */
+  RLEIC_H2_DVD    = 5,   /* Implemented      as of version 1.1.3-7 */
+  RLEIC_H8_DVD    = 6    /* Implemented      as of version 1.1.3-7 */
+} RLEImageCompression;
+
+
+
+/*
+ * Header info
+ */
+#define RLE_PREAMBLE_SIZE         (14)
+#define RLE_BIHEADER_SIZE         (40)
+#define RLE_HEADER_SIZE           (RLE_PREAMBLE_SIZE+RLE_BIHEADER_SIZE)
+#define RLE_PALETTE_IMAGE_OFFSET  (0x36)
+
+/*
+ * Private service data structure
+ */
+typedef struct IDirectFBImageProvider_RLE_data_t
+{
+  struct _MMECommon common;
+
+  uint                   magic;
+  uint                   file_size;
+  uint                   reserved;
+  uint                   img_offset;
+  uint                   payload_size;
+
+  uint                   width;
+  uint                   height;
+  uint                   depth;
+  uint                   num_planes;
+  uint                   num_colors;
+  uint                   imp_colors;
+  RLEImageCompression    compression;
+  uint                   h_resolution;
+  uint                   v_resolution;
+
+  bool                   indexed;
+  bool                   topfirst;
+  bool                   no_palette;
+  bool                   compressed;
+
+  int                    height_dib;
+  int                    pitch;
+
+  DFBColor              *palette;
+  u8                    *image_indexes;
+
+#if defined(RLE_PROVIDER_HW)
+  void                          *stgfx2_handle;
+  bdisp_aq_StretchBlit_RLE_func  rle_stretch;
+  CoreSurface           *compressed_data;
+#endif
+
+#if defined(RLE_PROVIDER_USE_MME)
+  /* Hardware Variables */
+  RLEDecode_TransformReturnParams_t ReturnParams;
+#endif /* RLE_PROVIDER_USE_MME */
+
+#ifdef ALLOW_DUMP_RAW_TO_FILE
+  int idx;
+#endif /* DUMP_RAW_TO_FILE */
+} IDirectFBImageProvider_RLE_data;
+
+
+
+#if defined(RLE_PROVIDER_USE_MME)
+/****************************************************************************/
+static inline const char *
+get_rle_error_string (RLEDecode_ErrorCodes_t e)
+{
+  static const char *RLEErrorType_strings[] = {
+    "RLEDECODE_NO_ERROR",
+    "RLEDECODE_MEMEORY_ALLOCATION_ERROR",
+    "RLEDECODE_CRC_ERROR",
+    "RLEDECODE_INVALID_STREAM",
+    "RLEDECODE_INTERNAL_ERROR"
+  };
+
+  return (((unsigned int) e) < D_ARRAY_SIZE (RLEErrorType_strings))
+         ? RLEErrorType_strings[e]
+         : "* Unknown RleError code *";
+}
+#endif /* RLE_PROVIDER_USE_MME */
+
+
+
+#endif /* __IDIRECTFBIMAGEPROVIDER_RLE_H__ */
diff -Naur DirectFB-1.7.7/interfaces/IDirectFBImageProvider/idirectfbimageprovider_tiff.c DirectFB-1.7.7.stm/interfaces/IDirectFBImageProvider/idirectfbimageprovider_tiff.c
--- DirectFB-1.7.7/interfaces/IDirectFBImageProvider/idirectfbimageprovider_tiff.c	2014-07-15 11:26:22.000000000 +0200
+++ DirectFB-1.7.7.stm/interfaces/IDirectFBImageProvider/idirectfbimageprovider_tiff.c	2015-05-15 18:43:40.097415075 +0200
@@ -224,6 +224,9 @@
      if (data->base.buffer)
           data->base.buffer->Release( data->base.buffer );
 
+     if (data->tif)
+          TIFFClose( data->tif );
+
      DIRECT_DEALLOCATE_INTERFACE( thiz );
 }
 
@@ -309,6 +312,8 @@
           goto error;
      }
 
+     data->base.buffer->SeekTo( data->base.buffer, 0 );
+
      TIFFReadRGBAImageOriented( data->tif, lock.pitch / 4, data->image_height, (uint32 *)(lock.addr), ORIENTATION_TOPLEFT, 0 );
 
      dfb_surface_unlock_buffer( data->decode_surface, &lock );
diff -Naur DirectFB-1.7.7/interfaces/IDirectFBImageProvider/Makefile.am DirectFB-1.7.7.stm/interfaces/IDirectFBImageProvider/Makefile.am
--- DirectFB-1.7.7/interfaces/IDirectFBImageProvider/Makefile.am	2014-03-22 21:05:18.000000000 +0100
+++ DirectFB-1.7.7.stm/interfaces/IDirectFBImageProvider/Makefile.am	2015-05-15 18:43:40.017335075 +0200
@@ -59,6 +59,12 @@
 MPEG2_PROVIDER =
 endif
 
+if JPEG_PROVIDER_HW_V4L2
+JPEG_PROVIDER_HW_V4L2_PROVIDER = libidirectfbimageprovider_hwjpeg_v4l2.la
+else
+JPEG_PROVIDER_HW_V4L2_PROVIDER =
+endif
+
 if WEBP_PROVIDER
 WEBP_PROVIDER = libidirectfbimageprovider_webp.la
 else
@@ -77,13 +83,27 @@
 FFMPEG_PROVIDER_LTLIB =
 endif
 
+if MME_USE_OWN_HEADERS
+MME_INCLUDE_PATH = -I$(top_srcdir)/interfaces/IDirectFBImageProvider/mme
+else
+MME_INCLUDE_PATH =
+endif
+if MME_USE_OWN_TRANSFORMERS
+TRANSFORMER_INCLUDE_PATH = -I$(srcdir)/mme/transform
+else
+TRANSFORMER_INCLUDE_PATH =
+endif
+
 INCLUDES = \
 	-I$(top_builddir)/include	\
 	-I$(top_builddir)/lib	\
 	-I$(top_builddir)/src	\
 	-I$(top_srcdir)/include	\
 	-I$(top_srcdir)/lib	\
-	-I$(top_srcdir)/src
+	-I$(top_srcdir)/src	\
+	-I$(top_srcdir)/systems	\
+	$(MME_INCLUDE_PATH)	\
+	$(TRANSFORMER_INCLUDE_PATH)
 
 AM_CPPFLAGS = -DDATADIR=\"${RUNTIME_SYSROOT}@DATADIR@\" $(LIBJPEG_CFLAGS) $(LIBPNG_CFLAGS) $(FFMPEG_CFLAGS)
 
@@ -97,6 +117,7 @@
 	$(SVG_PROVIDER)				\
 	$(BMP_PROVIDER)				\
 	$(JPEG2000_PROVIDER)			\
+	$(JPEG_PROVIDER_HW_V4L2_PROVIDER)       \
 	$(MPEG2_PROVIDER)			\
 	$(TIFF_PROVIDER)			\
 	$(WEBP_PROVIDER) 		        \
@@ -119,7 +140,7 @@
 libidirectfbimageprovider_webp_la_LDFLAGS = -avoid-version -module
 
 libidirectfbimageprovider_png_la_SOURCES = idirectfbimageprovider_png.c
-libidirectfbimageprovider_png_la_LIBADD = $(libdirect) $(libdirectfb) $(LIBPNG_LIBS)
+libidirectfbimageprovider_png_la_LIBADD = $(libdirect) $(libdirectfb) $(LIBPNG_LIBS) $(PNG_LIBMME)
 libidirectfbimageprovider_png_la_LDFLAGS = -avoid-version -module
 
 libidirectfbimageprovider_dfiff_la_SOURCES = idirectfbimageprovider_dfiff.c
@@ -131,7 +152,7 @@
 libidirectfbimageprovider_gif_la_LDFLAGS = -avoid-version -module
 
 libidirectfbimageprovider_jpeg_la_SOURCES = idirectfbimageprovider_jpeg.c
-libidirectfbimageprovider_jpeg_la_LIBADD = $(libdirect) $(libdirectfb) $(LIBJPEG)
+libidirectfbimageprovider_jpeg_la_LIBADD = $(libdirect) $(libdirectfb) $(LIBJPEG) $(JPEG_LIBMME)
 libidirectfbimageprovider_jpeg_la_LDFLAGS = -avoid-version -module
 
 libidirectfbimageprovider_imlib2_la_SOURCES = idirectfbimageprovider_imlib2.c
@@ -158,6 +179,10 @@
 libidirectfbimageprovider_mpeg2_la_LIBADD = $(libdirect) $(libdirectfb) mpeg2/libmpeg2decode.la
 libidirectfbimageprovider_mpeg2_la_LDFLAGS = -avoid-version -module
 
+libidirectfbimageprovider_hwjpeg_v4l2_la_SOURCES = idirectfbimageprovider_hwjpeg_v4l2.c
+libidirectfbimageprovider_hwjpeg_v4l2_la_LIBADD = $(libdirect) $(libdirectfb)
+libidirectfbimageprovider_hwjpeg_v4l2_la_LDFLAGS = -avoid-version -module
+
 libidirectfbimageprovider_ffmpeg_la_SOURCES = idirectfbimageprovider_ffmpeg.c
 libidirectfbimageprovider_ffmpeg_la_LIBADD = $(libdirect) $(libdirectfb) $(FFMPEG_LIBS)
 libidirectfbimageprovider_ffmpeg_la_LDFLAGS = -avoid-version -module -lavformat -lavutil -lavcodec -lswscale
diff -Naur DirectFB-1.7.7/interfaces/IDirectFBImageProvider/mme/mme_debug.h DirectFB-1.7.7.stm/interfaces/IDirectFBImageProvider/mme/mme_debug.h
--- DirectFB-1.7.7/interfaces/IDirectFBImageProvider/mme/mme_debug.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7.stm/interfaces/IDirectFBImageProvider/mme/mme_debug.h	2015-05-15 18:43:40.101419076 +0200
@@ -0,0 +1,63 @@
+/**************************************************************
+ * Copyright (C) 2010   STMicroelectronics. All Rights Reserved.
+ * This file is part of the latest release of the Multicom4 project. This release 
+ * is fully functional and provides all of the original MME functionality.This 
+ * release  is now considered stable and ready for integration with other software 
+ * components.
+
+ * Multicom4 is a free software; you can redistribute it and/or modify it under the 
+ * terms of the GNU General Public License as published by the Free Software Foundation 
+ * version 2.
+
+ * Multicom4 is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
+ * See the GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along with Multicom4; 
+ * see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - 
+ * Suite 330, Boston, MA 02111-1307, USA.
+
+ * Written by Multicom team at STMicroelectronics in November 2010.  
+ * Contact multicom.support@st.com. 
+**************************************************************/
+
+/* 
+ * 
+ */ 
+
+#ifndef _MME_DEBUG_H
+#define _MME_DEBUG_H
+
+typedef enum mme_debug_flags 
+{
+  MME_DBG             = 0x0000,		/* Always displayed */
+
+  MME_DBG_ERR         = 0x0001,		/* Display all error paths */
+  MME_DBG_INIT        = 0x0002,		/* Initialisation operations */
+  MME_DBG_MANAGER     = 0x0004,		/* MME management operations */
+
+  MME_DBG_RECEIVER    = 0x0010,		/* Transformer receiver task (companion) */
+  MME_DBG_TRANSFORMER = 0x0020,		/* Transformer operations (host) */
+  MME_DBG_EXEC        = 0x0040,		/* Execution tasks */
+
+  MME_DBG_COMMAND     = 0x0100,		/* Transformer Command issue */
+  MME_DBG_BUFFER      = 0x0200,		/* DataBuffer Alloc/Free */
+
+} MME_DBG_FLAGS;
+
+const char *MME_ErrorStr (MME_ERROR res);
+MME_ERROR   MME_DebugFlags (MME_DBG_FLAGS flags);
+
+/* These were inconsistently named originally */
+#define MME_Error_Str		MME_ErrorStr
+#define MME_Debug_Flags		MME_DebugFlags
+
+#endif /* _MME_DEBUG_H */
+
+/*
+ * Local Variables:
+ *  tab-width: 8
+ *  c-indent-level: 2
+ *  c-basic-offset: 2
+ * End:
+ */
diff -Naur DirectFB-1.7.7/interfaces/IDirectFBImageProvider/mme/mme.h DirectFB-1.7.7.stm/interfaces/IDirectFBImageProvider/mme/mme.h
--- DirectFB-1.7.7/interfaces/IDirectFBImageProvider/mme/mme.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7.stm/interfaces/IDirectFBImageProvider/mme/mme.h	2015-05-15 18:43:40.097415075 +0200
@@ -0,0 +1,586 @@
+/**************************************************************
+ * Copyright (C) 2010   STMicroelectronics. All Rights Reserved.
+ * This file is part of the latest release of the Multicom4 project. This release 
+ * is fully functional and provides all of the original MME functionality.This 
+ * release  is now considered stable and ready for integration with other software 
+ * components.
+
+ * Multicom4 is a free software; you can redistribute it and/or modify it under the 
+ * terms of the GNU General Public License as published by the Free Software Foundation 
+ * version 2.
+
+ * Multicom4 is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
+ * See the GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along with Multicom4; 
+ * see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - 
+ * Suite 330, Boston, MA 02111-1307, USA.
+
+ * Written by Multicom team at STMicroelectronics in November 2010.  
+ * Contact multicom.support@st.com. 
+**************************************************************/
+
+/* 
+ * 
+ */ 
+
+#ifndef _MME_H
+#define _MME_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif	/* __cplusplus */
+
+/* Constants */
+
+#define MME_MAX_TRANSFORMER_NAME 	(63U)
+
+#define MME_MAX_CACHE_LINE		(32)
+#define MME_CACHE_LINE_ALIGN(X)		((void*)(((unsigned) (X) + (MME_MAX_CACHE_LINE-1)) & ~(MME_MAX_CACHE_LINE-1)))
+#define MME_CACHE_LINE_ALIGNED(X)	(((unsigned) (X) & (MME_MAX_CACHE_LINE-1)) == 0)
+
+/* Aliased names for some of the inconsistently named (or simply overly long) identifiers */
+
+#define MME_Deinit     			MME_Term
+#define MME_Error_t    			MME_ERROR
+#define MME_NO_MEMORY  			MME_NOMEM
+#define MME_SET_GLOBAL_TRANSFORM_PARAMS	MME_SET_PARAMS 			
+#define MME_EMBX_ERROR			MME_ICS_ERROR
+
+/* Version info */
+
+#define __MULTICOM_VERSION__		"4.0.51 : Orly"
+#define __MULTICOM_VERSION_MAJOR__	(4)
+#define __MULTICOM_VERSION_MINOR__	(0)
+#define __MULTICOM_VERSION_PATCH__	(51)
+
+/* Version macros like the ones found in Linux */
+#define MULTICOM_VERSION(a,b,c)		(((a) << 16) + ((b) << 8) + (c))
+#define MULTICOM_VERSION_CODE		MULTICOM_VERSION(__MULTICOM_VERSION_MAJOR__, __MULTICOM_VERSION_MINOR__, __MULTICOM_VERSION_PATCH__)
+
+/* Enumerations */
+
+/* MME_AllocationFlags_t: 
+ * Used to qualify MME_DataBuffer_t memory allocation
+ */
+typedef enum MME_AllocationFlags_t {
+  MME_ALLOCATION_PHYSICAL = 1,
+  MME_ALLOCATION_CACHED   = 2,
+  MME_ALLOCATION_UNCACHED = 4
+} MME_AllocationFlags_t;
+  
+/* MME_CommandCode_t: 
+ * Used to specify a command to a transformer
+ */
+typedef enum MME_CommandCode_t {
+  MME_SET_PARAMS,
+  MME_TRANSFORM,
+  MME_SEND_BUFFERS,
+  MME_PING				/* MME4 API extension */
+} MME_CommandCode_t;
+
+/* MME_CommandState_t:
+ * Used to specify the current state of a submitted command
+ */
+typedef enum MME_CommandState_t {
+  MME_COMMAND_IDLE,
+  MME_COMMAND_PENDING,
+  MME_COMMAND_EXECUTING,
+  MME_COMMAND_COMPLETED,
+  MME_COMMAND_FAILED
+} MME_CommandState_t;
+
+/* MME_CommandEndType_t:
+ * Used to specify whether the Client callback or Wake
+ * should be actioned on command completion
+ *
+ * MME_COMMAND_END_RETURN_NO_INFO - No Callback/Wake
+ * MME_COMMAND_END_RETURN_NOTIFY  - Call Client callback
+ * MME_COMMAND_END_RETURN_WAKE    - Wakeup MME_Wait() call
+ */
+typedef enum MME_CommandEndType_t {
+  MME_COMMAND_END_RETURN_NO_INFO,
+  MME_COMMAND_END_RETURN_NOTIFY,
+  MME_COMMAND_END_RETURN_WAKE		/* MME4 API extension */
+} MME_CommandEndType_t;
+
+/* MME_Event_t:
+ * Used to indicate a transform event type to the Client callback
+ */
+typedef enum MME_Event_t {
+  MME_COMMAND_COMPLETED_EVT,
+  MME_DATA_UNDERFLOW_EVT,
+  MME_NOT_ENOUGH_MEMORY_EVT,
+  MME_NEW_COMMAND_EVT,
+  MME_TRANSFORMER_TIMEOUT
+} MME_Event_t;
+
+
+/* MME_ERROR:
+ * The errors that may be returned by MME API functions or by
+ * transformer entry point functions
+ */
+typedef enum MME_ERROR {
+  MME_SUCCESS                     = 0,
+  MME_DRIVER_NOT_INITIALIZED      = 1,
+  MME_DRIVER_ALREADY_INITIALIZED  = 2,
+  MME_NOMEM                       = 3,
+  MME_INVALID_TRANSPORT           = 4,	/* DEPRECATED */
+  MME_INVALID_HANDLE              = 5,
+  MME_INVALID_ARGUMENT            = 6,
+  MME_UNKNOWN_TRANSFORMER         = 7,
+  MME_TRANSFORMER_NOT_RESPONDING  = 8,
+  MME_HANDLES_STILL_OPEN          = 9,
+  MME_COMMAND_STILL_EXECUTING     = 10,
+  MME_COMMAND_ABORTED             = 11,
+  MME_DATA_UNDERFLOW              = 12,
+  MME_DATA_OVERFLOW               = 13,
+  MME_TRANSFORM_DEFERRED          = 14,
+  MME_SYSTEM_INTERRUPT            = 15,
+  MME_ICS_ERROR                   = 16,
+  MME_INTERNAL_ERROR              = 17,
+  MME_NOT_IMPLEMENTED             = 18,
+  MME_COMMAND_TIMEOUT             = 19	/* MME4 API extension */
+} MME_ERROR;
+
+/* MME_CacheFlags_t
+ * Cache management flags used allow optimizations to be applied
+ * for each MME_ScatterPage_t (FlagsIn/FlagsOut)
+ */
+typedef enum MME_CacheFlags_t {
+  MME_DATA_CACHE_COHERENT   = (1 << 31), /* In/Out: Memory/Page is already coherent with cache */
+  MME_DATA_TRANSIENT        = (1 << 30), /* In: Cache flush is not necessary in Companion */
+  MME_REMOTE_CACHE_COHERENT = (1 << 29), /* Out: Remote Page translation should be COHERENT */
+  MME_DATA_PHYSICAL         = (1 << 28)	 /* In/Out: Memory address is Physical don't translate */
+} MME_CacheFlags_t;
+
+/* MME_Tuneable_t:
+ * Keys used to modify tuneable parameters
+ */
+typedef enum {
+  /* no need to MME_THREAD_STACK_SIZE, this is managed by the ICS call */
+  MME_TUNEABLE_MANAGER_THREAD_PRIORITY,
+  MME_TUNEABLE_TRANSFORMER_THREAD_PRIORITY,
+  MME_TUNEABLE_EXECUTION_LOOP_HIGHEST_PRIORITY,
+  MME_TUNEABLE_EXECUTION_LOOP_ABOVE_NORMAL_PRIORITY,
+  MME_TUNEABLE_EXECUTION_LOOP_NORMAL_PRIORITY,
+  MME_TUNEABLE_EXECUTION_LOOP_BELOW_NORMAL_PRIORITY,
+  MME_TUNEABLE_EXECUTION_LOOP_LOWEST_PRIORITY,
+  /* TIMEOUT SUPPORT - allow default timeout to be modified */
+  MME_TUNEABLE_TRANSFORMER_TIMEOUT,
+  MME_TUNEABLE_BUFFER_POOL_SIZE, 	/* MME4 API Extension */
+  MME_TUNEABLE_COMMAND_TIMEOUT,		/* MME4 API Extension */
+
+  MME_TUNEABLE_MAX
+} MME_Tuneable_t;
+		
+/* MME_Priority_t:
+ * The MME scheduler priority at which a transform is executed
+ */
+typedef enum MME_Priority_t {
+  MME_PRIORITY_HIGHEST      = 5000,
+  MME_PRIORITY_ABOVE_NORMAL = 4000,
+  MME_PRIORITY_NORMAL       = 3000,
+  MME_PRIORITY_BELOW_NORMAL = 2000,
+  MME_PRIORITY_LOWEST       = 1000
+} MME_Priority_t;
+
+/* Types: simple */
+
+/* CPU architecture-specific */
+
+#if defined __sh__ || defined(__st200__) || defined(__ILP32__) || defined(__arm__)
+/* SH4/ST40 */
+typedef unsigned int  MME_UINT;
+typedef unsigned long MME_ULONG;
+typedef unsigned long MME_SIZE;
+typedef double        MME_GENERIC64;
+#define               MME_MaxTime_c 0xffffffff
+#else
+#error Unsupported CPU type
+#endif
+
+/* TIMEOUT SUPPORT: Maximum timeout value which basically means don't timeout */
+#define MME_TIMEOUT_INFINITE	MME_MaxTime_c
+
+/* Architecture neutral */
+/* MME_Time_t: 
+ * MME time
+ */
+typedef MME_UINT MME_Time_t;
+
+/* MME_GenericParams_t: 
+ * A transformer specific parameter
+ */
+typedef void* MME_GenericParams_t;
+
+/* MME_CommandId_t: 
+ * The identifier assigned by MME to a submitted command
+ */
+typedef MME_UINT MME_CommandId_t;
+
+/* MME_TransformerHandle_t: 
+ * The handle of a transformer instance assigned by MME
+ */
+typedef MME_UINT MME_TransformerHandle_t;
+
+/* MME_MemoryHandle_t: 
+ * The handle of a registered memory region assigned by MME
+ */
+typedef MME_UINT MME_MemoryHandle_t;
+
+/* Types: structures */
+
+/* MME_CommandStatus_t:
+ * Structure containing state associated with a command
+ */
+typedef struct MME_CommandStatus_t {
+  MME_CommandId_t       CmdId;
+  MME_CommandState_t    State;
+  MME_Time_t            ProcessedTime;
+  MME_ERROR             Error;
+  MME_UINT              AdditionalInfoSize;
+  MME_GenericParams_t   AdditionalInfo_p;
+} MME_CommandStatus_t;
+
+/* MME_ScatterPage_t:
+ * Structure describing a single scatter page - see MME_DataBuffer_t
+ */
+typedef struct MME_ScatterPage_t {
+  void*                 Page_p;
+  MME_UINT              Size;
+  MME_UINT              BytesUsed;
+  MME_UINT              FlagsIn;
+  MME_UINT              FlagsOut;
+} MME_ScatterPage_t;
+
+/* MME_DataBuffer_t:
+ * Structure describing a data buffer
+ */
+typedef struct MME_DataBuffer_t {
+  MME_UINT              StructSize;
+  void*                 UserData_p;
+  MME_UINT              Flags;
+  MME_UINT              StreamNumber;
+  MME_UINT              NumberOfScatterPages;
+  MME_ScatterPage_t*    ScatterPages_p;
+  MME_UINT              TotalSize;
+  MME_UINT              StartOffset;
+} MME_DataBuffer_t;
+
+/* MME_Command_t:
+ * Structure to pass a command to a transformer
+ */
+typedef struct MME_Command_t {
+  MME_UINT              StructSize;
+  MME_CommandCode_t     CmdCode;
+  MME_CommandEndType_t  CmdEnd;
+  MME_Time_t            DueTime;
+  MME_UINT              NumberInputBuffers;
+  MME_UINT              NumberOutputBuffers;
+  MME_DataBuffer_t**    DataBuffers_p;
+  MME_CommandStatus_t   CmdStatus;
+  MME_UINT              ParamSize;
+  MME_GenericParams_t   Param_p;
+} MME_Command_t;
+
+/* MME_DataFormat_t:
+ * Structure describing the data format that a transformer supports
+ */
+typedef struct MME_DataFormat_t {
+  unsigned char         FourCC[4];
+} MME_DataFormat_t;
+
+
+/* MME_TransformerCapability_t:
+ * Structure containing information pertaining to a transformer's capability
+ */
+typedef struct MME_TransformerCapability_t {
+  MME_UINT              StructSize;
+  MME_UINT              Version;
+  MME_DataFormat_t      InputType;
+  MME_DataFormat_t      OutputType;
+  MME_UINT              TransformerInfoSize;
+  MME_GenericParams_t   TransformerInfo_p;
+} MME_TransformerCapability_t;
+
+
+/* Transformer Client callback function */
+typedef void (*MME_GenericCallback_t) (MME_Event_t event, MME_Command_t * callbackData, void *userData);
+
+/* MME_TransformerInitParams_t:
+ * The parameters with which to initialize a transformer
+ */
+typedef struct MME_TransformerInitParams_t {
+  MME_UINT		StructSize;
+  MME_Priority_t	Priority;
+  MME_GenericCallback_t	Callback;
+  void*			CallbackUserData;
+  MME_UINT		TransformerInitParamsSize;
+  MME_GenericParams_t	TransformerInitParams_p;
+} MME_TransformerInitParams_t;
+
+/* Types: functions */
+
+/* Transformer: AbortCommand entry point */
+typedef MME_ERROR (*MME_AbortCommand_t) (void *context, MME_CommandId_t commandId);
+
+/* Transformer: GetTransformerCapability entry point */
+typedef MME_ERROR (*MME_GetTransformerCapability_t) (MME_TransformerCapability_t * capability);
+
+/* Transformer: InitTransformer entry point */
+typedef MME_ERROR (*MME_InitTransformer_t) (MME_UINT initParamsLength, MME_GenericParams_t initParams, void **context);
+
+/* Transformer: ProcessCommand entry point */
+typedef MME_ERROR (*MME_ProcessCommand_t) (void *context, MME_Command_t * commandInfo);
+
+/* Transformer: TermTransformer entry point */
+typedef MME_ERROR (*MME_TermTransformer_t) (void *context);
+
+/* Macros */
+
+/* These macros are shown in their most simplistic form. On mixed endian   
+ * systems these macros can use (sizeof(field) == n) if networks to cope.
+ * Since such a network can be solved at compile time this would not impact
+ * runtime performance.
+ */
+
+/* MME_PARAM has a different implementation of machines with a different
+ * endian. This permits the MME implementation on a big endian machine
+ * to perform a 64-bit byte swap
+ */
+
+#if defined(__sh__) || defined(__st200__) || defined(__LITTLE_ENDIAN__) || defined(__arm__)
+/* this is the definition of MME_PARAM for little endian machines */
+#define _MME_PARAM_ADDRESS(p, f)   ((MME_TYPE_##f*)(((MME_GENERIC64*)p)+MME_OFFSET_##f))
+
+#else
+/* this is the definition of MME_PARAM for big endian machines */
+#define _MME_PARAM_ADDRESS(p, f)					\
+  ((MME_TYPE_##f *)(((char *)((MME_GENERIC64*)p+MME_OFFSET_##f))+(sizeof(MME_GENERIC64)-sizeof(MME_TYPE_##f))))
+
+/* At the moment we do not support BE machines */
+#error Unsupported CPU type
+#endif
+
+/* A parameter */
+#define MME_PARAM(p, f)            (*_MME_PARAM_ADDRESS(p, f))
+
+/* A parameter sublist */
+#define MME_PARAM_SUBLIST(p, f)    _MME_PARAM_ADDRESS(p, f)
+
+/* Access a parameter at a given index */
+#define MME_INDEXED_PARAM(p, f, i) (*((MME_TYPE_##f*)(((MME_GENERIC64*)p)+MME_OFFSET_##f+(i))))
+
+/* Get number of paramters */
+#define MME_LENGTH(id)             (MME_LENGTH_##id)
+
+/* Get number of paramters */
+#define MME_LENGTH_BYTES(id)       ((MME_LENGTH_##id)*sizeof(MME_GENERIC64))
+
+/* Function declarations */
+
+/* MME_AbortCommand()
+ * Attempt to abort a submitted command
+ *
+ * Asyncrhonous operation whose success will be observed in the CmdStatus of the aborted command
+ */
+MME_ERROR MME_AbortCommand (MME_TransformerHandle_t handle, MME_CommandId_t cmdId);
+
+/* MME_KillCommand()
+ * Abort a command without communicating with the remote processor. Should only be used 
+ * when we know the transformer processor has definitely crashed
+ */
+MME_ERROR MME_KillCommand (MME_TransformerHandle_t handle, MME_CommandId_t cmdId);
+
+/* MME_KillCommandAll()
+ * Abort all commands without communicating with the remote processor. Should only be used 
+ * when we know the transformer processor has definitely crashed
+ */
+MME_ERROR MME_KillCommandAll (MME_TransformerHandle_t handle);
+
+/* MME_AllocDataBuffer()
+ * Allocate a data buffer that is optimal for the transformer instantiation
+ * to pass between a Client and companion
+ */
+MME_ERROR MME_AllocDataBuffer (MME_TransformerHandle_t handle,
+			       MME_UINT size,
+			       MME_AllocationFlags_t flags,
+			       MME_DataBuffer_t ** dataBuffer_p);
+
+/* MME_DeregisterTransformer()
+ * Deregister a transformer that has been registered
+ */
+MME_ERROR MME_DeregisterTransformer (const char *name);
+
+/* MME_DeregisterTransport()
+ * Deregister an EMBX transport being used by MME
+ * 
+ * DEPRECATED
+ */
+MME_ERROR MME_DeregisterTransport (const char *name);
+
+/* MME_FreeDataBuffer()
+ * Free a buffer previously allocated with MME_AllocDataBuffer 
+ */
+MME_ERROR MME_FreeDataBuffer (MME_DataBuffer_t * DataBuffer);
+
+/* MME_GetTransformerCapability()
+ * Obtain the capabilities of a transformer 
+ */
+MME_ERROR MME_GetTransformerCapability (const char *name,
+					MME_TransformerCapability_t * capability);
+
+/* MME_Init()
+ * Initialize MME 
+ */
+MME_ERROR MME_Init (void);
+
+/* MME_InitTransformer()
+ * Create a transformer instance on a companion 
+ */
+MME_ERROR MME_InitTransformer (const char *name,
+			       MME_TransformerInitParams_t * params, 
+			       MME_TransformerHandle_t * handlep);
+  
+/* MME_ModifyTuneable()
+ * Modify system wide configuration parameters such as thread priority.
+ */
+MME_ERROR MME_ModifyTuneable (MME_Tuneable_t key, MME_UINT value);
+
+/* MME_GetTuneable()
+ * Returns current value of system wide configuration parameters such as thread priority.
+ */
+MME_UINT MME_GetTuneable (MME_Tuneable_t key);
+
+/* MME_NotifyHost()
+ * Notify the Command Client that a transformer event has occurred
+ */
+MME_ERROR MME_NotifyHost (MME_Event_t event, MME_Command_t * commandInfo, MME_ERROR res);
+
+/* MME_RegisterTransformer()
+ * Register a transformer after which instantiations may be made
+ */
+MME_ERROR MME_RegisterTransformer (const char *name,
+				   MME_AbortCommand_t abortFunc,
+				   MME_GetTransformerCapability_t getTransformerCapabilityFunc,
+				   MME_InitTransformer_t initTransformerFunc,
+				   MME_ProcessCommand_t processCommandFunc,
+				   MME_TermTransformer_t termTransformerFunc);
+  
+/* MME_RegisterTransport()
+ * Register an existing EMBX transport for use by MME
+ * 
+ * DEPRECATED
+ */
+MME_ERROR MME_RegisterTransport (const char *name);
+
+/* MME_Run()
+ * Run the MME message loop on a companion CPU
+ *
+ * DEPRECATED
+ */
+MME_ERROR MME_Run (void);
+
+/* MME_SendCommand()
+ * Send a transformer command to a transformer instance
+ */
+MME_ERROR MME_SendCommand (MME_TransformerHandle_t handle, MME_Command_t *commandInfo);
+
+/* MME_Term()
+ * Terminate MME on the local CPU.
+ */
+MME_ERROR MME_Term (void);
+
+/* MME_TermTransformer()
+ * Terminate a transformer instance
+ */
+MME_ERROR MME_TermTransformer (MME_TransformerHandle_t handle);
+
+/* MME_KillTransformer()
+ * Terminate a transformer instance, without communicating 
+ * with the remote processor, which we assume has crashed
+ */
+MME_ERROR MME_KillTransformer (MME_TransformerHandle_t handle);
+
+/* MME_IsStillAlive()
+ * Ping a remote transformer to see if it's still running
+ * Sets alive to be non zero if it replies, zero otherwise
+ */
+MME_ERROR MME_IsStillAlive (MME_TransformerHandle_t handle, MME_UINT *alive);
+
+/*
+ * Multihost extensions - DEPRECATED
+ */
+MME_ERROR MME_HostRegisterTransport(const char *name);
+MME_ERROR MME_HostDeregisterTransport(const char* name);
+MME_ERROR MME_HostInit(void);
+MME_ERROR MME_HostTerm(void);
+
+/*
+ * MME4 New APIs 
+ */
+
+/*
+ * Return a pointer to the MME version string
+ *
+ * This string takes the form: 
+ *
+ *   {major number}.{minor number}.{patch number} [text]
+ *
+ * That is, a major, minor and release number, separated by
+ * decimal points, and optionally followed by a space and a text string.
+ */
+const char *MME_Version (void);
+
+/* MME_WaitCommand()
+ * Block waiting for an issued Command to complete. Command must have been
+ * issued using the MME_COMMAND_END_RETURN_WAKE CmdEnd notification type
+ *
+ * Returns MME_SUCCESS when transformation has completed and CmdStatus has been updated
+ * Corresponding MME_Event status is updated via eventp
+ *
+ * Can return MME_COMMAND_TIMEOUT, MME_SYSTEM_INTERRUPT or MME_ICS_ERROR
+ */
+MME_ERROR MME_WaitCommand (MME_TransformerHandle_t handle,
+			   MME_CommandId_t cmdId,
+			   MME_Event_t *eventp,
+			   MME_Time_t timeout);
+
+/* MME_PingTransformer()
+ * Ping a remote transformer to see if it's still running
+ * Waits for timeout period for response before returning an error
+ */
+MME_ERROR MME_PingTransformer (MME_TransformerHandle_t handle, MME_Time_t timeout);
+
+/*
+ * Register a memory region for use with the specified transformer instance
+ *
+ * Only data buffers which lie within the specified region can be used
+ * during transform operations
+ *
+ */
+MME_ERROR MME_RegisterMemory (MME_TransformerHandle_t handle,
+			      void *base,
+			      MME_SIZE size,
+			      MME_MemoryHandle_t *handlep);
+
+MME_ERROR MME_DeregisterMemory (MME_MemoryHandle_t handle);
+
+
+#include <mme/mme_debug.h>		/* Debug logging */
+
+
+#ifdef __cplusplus
+}
+#endif	/* __cplusplus */
+#endif	/* _MME_H */
+
+/*
+ * Local Variables:
+ *  tab-width: 8
+ *  c-indent-level: 2
+ *  c-basic-offset: 2
+ * End:
+ */
diff -Naur DirectFB-1.7.7/interfaces/IDirectFBImageProvider/mme/transform/JPEGDECHW_VideoTransformerTypes.h DirectFB-1.7.7.stm/interfaces/IDirectFBImageProvider/mme/transform/JPEGDECHW_VideoTransformerTypes.h
--- DirectFB-1.7.7/interfaces/IDirectFBImageProvider/mme/transform/JPEGDECHW_VideoTransformerTypes.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7.stm/interfaces/IDirectFBImageProvider/mme/transform/JPEGDECHW_VideoTransformerTypes.h	2015-05-15 18:43:40.101419076 +0200
@@ -0,0 +1,379 @@
+///
+/// @file     : JPEGDECHW_VideoTransformerTypes.h
+///
+/// @brief    : JPEG Video Decoder specific types for MME
+///
+/// @par OWNER: 
+///
+/// @author   : Prabhat Awasthi
+///
+/// @par SCOPE:
+///
+/// @date     : 2008-08-01
+///
+/// &copy; 2006 ST Microelectronics. All Rights Reserved.
+///
+
+#ifndef _JPEGDECHW_VIDEOTRANSFORMERTYPES_H_
+#define _JPEGDECHW_VIDEOTRANSFORMERTYPES_H_
+
+#include "stddefs.h"
+
+/*===============================================
+               JPEG_DECODER
+===============================================*/
+
+#define JPEGHWDEC_MME_TRANSFORMER_NAME    "JPEG_DECODER_HW"
+
+/*
+JPEGHW_MME_VERSION:
+Identifies the MME API version of the JPEGHW firmware.
+If wants to build the firmware for old MME API version, change this string correspondingly.
+*/
+#ifndef JPEGHW_MME_VERSION
+	#define JPEGHW_MME_VERSION	 17		/* Latest MME API version */ 		
+#endif
+
+#if (JPEGHW_MME_VERSION >= 17)
+    #define JPEGHWDEC_MME_API_VERSION "1.7"
+#elif (JPEGHW_MME_VERSION >= 16)
+    #define JPEGHWDEC_MME_API_VERSION "1.6"
+#elif (JPEGHW_MME_VERSION >= 15)
+    #define JPEGHWDEC_MME_API_VERSION "1.5"
+#elif (JPEGHW_MME_VERSION >= 14)
+    #define JPEGHWDEC_MME_API_VERSION "1.4"
+#elif (JPEGHW_MME_VERSION >= 13)
+    #define JPEGHWDEC_MME_API_VERSION "1.3"
+#elif (JPEGHW_MME_VERSION >= 12)
+    #define JPEGHWDEC_MME_API_VERSION "1.2"
+#elif (JPEGHW_MME_VERSION >= 11)
+    #define JPEGHWDEC_MME_API_VERSION "1.1"
+#else
+    #define JPEGHWDEC_MME_API_VERSION "1.0"
+#endif
+
+
+#define JPEGDECHW_NUMBER_OF_CEH_INTERVALS 32
+
+/*
+** JPEGDECHW_CompressedData_t :
+**   Defines the address type for the JPEGDECHW compressed data
+*/
+typedef U32 *JPEGDECHW_CompressedData_t;
+
+
+/*
+** JPEGDECHW_LumaAddress_t :
+**   Defines the address type for the JPEGDECHW decoded Luma datas
+**   Bits 0 to 7 shall be set to 0 
+*/
+typedef U32 *JPEGDECHW_LumaAddress_t;
+
+
+/*
+** JPEGDECHW_ChromaAddress_t :
+**   Defines the address type for the JPEGDECHW decoded Chroma datas 
+**   Bits 0 to 7 shall be set to 0
+*/
+typedef U32 *JPEGDECHW_ChromaAddress_t;
+
+
+/*
+** JPEGDECHW_DecodedBufferAddress_t :
+**   Defines the addresses where the decoded picture/additional info related to the block 
+**   structures will be stored 
+*/
+typedef struct _JPEGDECHWDECODEDBUFFERADDRESS_T_
+{
+	JPEGDECHW_LumaAddress_t Luma_p;
+	JPEGDECHW_ChromaAddress_t Chroma_p;
+#if (JPEGHW_MME_VERSION < 15) /* Not required For Reference reconstruction block*/
+	JPEGDECHW_LumaAddress_t LumaDecimated_p;
+	JPEGDECHW_ChromaAddress_t ChromaDecimated_p;
+#endif
+}	JPEGDECHW_DecodedBufferAddress_t;
+
+
+#if (JPEGHW_MME_VERSION >= 15)
+/*
+** JPEGDECHW_DisplayBufferAddress_t :
+** Defines the addresses (used by Display Reconstruction block) where the pictures to be displayed will be stored 
+*/
+typedef struct _JPEGDECHWDISPLAYBUFFERADDRESS_T_
+{
+	U32							StructSize;               /* Size of the structure in bytes */
+    JPEGDECHW_LumaAddress_t		DisplayLuma_p;            /* address of the Luma buffer     */
+	JPEGDECHW_ChromaAddress_t	DisplayChroma_p;          /* address of the Chroma buffer   */ 
+	JPEGDECHW_LumaAddress_t		DisplayDecimatedLuma_p;   /* address of the decimated Luma buffer */
+	JPEGDECHW_ChromaAddress_t	DisplayDecimatedChroma_p; /* address of the decimated Chroma buffer */ 
+}	JPEGDECHW_DisplayBufferAddress_t;
+#endif
+
+
+#if (JPEGHW_MME_VERSION >= 15)
+/*
+** JPEGDECHW_RcnRefDispEnable_t :
+** Used for enabling Main/Aux outputs for both Display & Reference reconstruction blocks 
+*/
+typedef enum _JPEGDECHW_RCNREFDISPENABLE_T_
+{
+	JPEGDECHW_DISP_AUX_EN               = 0x00000010,  /* Enable decimated (for display) reconstruction             */
+	JPEGDECHW_DISP_MAIN_EN              = 0x00000020,  /* Enable main (for display) reconstruction                  */
+	JPEGDECHW_DISP_AUX_MAIN_EN          = 0x00000030,  /* Enable both main & decimated (for display) reconstruction */
+	JPEGDECHW_REF_MAIN_EN  				= 0x00000100,  /* Enable only reference output(ex. for Trick modes)*/
+	JPEGDECHW_REF_MAIN_DISP_AUX_EN      = 0x00000110,  /* Enable reference output with decimated (for display) reconstruction  */
+	JPEGDECHW_REF_MAIN_DISP_MAIN_EN     = 0x00000120,  /* Enable reference output with main (for display) reconstruction  */
+	JPEGDECHW_REF_MAIN_DISP_MAIN_AUX_EN = 0x00000130   /* Enable reference output with main & decimated (for display) reconstruction */
+}	JPEGDECHW_RcnRefDispEnable_t;
+
+#else
+
+/*
+** JPEGDECHW_MainAuxEnable_t :
+** Used for enabling Main/Aux outputs
+*/
+typedef enum _JPEGDECHW_MAINAUXENABLE_T_
+{
+	JPEGDECHW_AUXOUT_EN       = 0x00000010, /* enable decimated reconstruction */
+	JPEGDECHW_MAINOUT_EN      = 0x00000020, /* enable main reconstruction */
+	JPEGDECHW_AUX_MAIN_OUT_EN = 0x00000030 /* enable both main & decimated reconstruction */
+}	JPEGDECHW_MainAuxEnable_t;
+
+#endif
+
+
+/*
+** JPEGDECHW_HorizontalDeciFactor _t :
+** Identifies the horizontal decimation factor
+*/
+typedef enum _JPEGDECHW_HORIZONTALDECIFACTOR_T_
+{
+	JPEGDECHW_HDEC_1 = 0x00000000, /* no resize */
+    JPEGDECHW_HDEC_ADVANCED_2 = 0x00000101, /* Advanced H/2 resize using improved 8-tap filters */
+    JPEGDECHW_HDEC_ADVANCED_4 = 0x00000102  /* Advanced H/4 resize using improved 8-tap filters */
+}	JPEGDECHW_HorizontalDeciFactor_t;
+
+
+/*
+** JPEGDECHW_VerticalDeciFactor _t :
+** Identifies the vertical decimation factor
+*/
+typedef enum _JPEGDECHW_VERTICALDECIFACTOR_T_
+{
+	JPEGDECHW_VDEC_1 = 0x00000000, /* no resize */
+	JPEGDECHW_VDEC_ADVANCED_2_PROG = 0x00000204, /* V/2 , progressive resize */
+	JPEGDECHW_VDEC_ADVANCED_2_INT = 0x000000208 /* V/2 , interlaced resize */
+}	JPEGDECHW_VerticalDeciFactor_t;
+
+
+/*
+** JPEGDECHW_VideoDecodeInitParams_t :
+** Identifies the Initialization parameters for the transformer.
+*/
+typedef struct _JPEGDECHW_VIDEODECODEINITPARAMS_T_
+{
+	JPEGDECHW_CompressedData_t CircularBufferBeginAddr_p;
+	JPEGDECHW_CompressedData_t CircularBufferEndAddr_p;
+}	JPEGDECHW_VideoDecodeInitParams_t;
+
+
+/*
+** JPEGDECHW_DecodingError_t :
+** Status of the decoding process
+*/
+typedef enum
+{
+	/* The firmware has been sucessful */
+#if (JPEGHW_MME_VERSION >= 13)
+	JPEG_DECODER_NO_ERROR							= 0,
+	JPEG_DECODER_UNDEFINED_HUFF_TABLE				= 1,
+	JPEG_DECODER_UNSUPPORTED_MARKER					= 2,
+	JPEG_DECODER_UNABLE_ALLOCATE_MEMORY				= 3,
+	JPEG_DECODER_NON_SUPPORTED_SAMP_FACTORS			= 4,
+	JPEG_DECODER_BAD_PARAMETER						= 5,
+	JPEG_DECODER_DECODE_ERROR						= 6,
+	JPEG_DECODER_BAD_RESTART_MARKER					= 7,
+	JPEG_DECODER_UNSUPPORTED_COLORSPACE				= 8,
+	JPEG_DECODER_BAD_SOS_SPECTRAL					= 9,
+	JPEG_DECODER_BAD_SOS_SUCCESSIVE					= 10,
+	JPEG_DECODER_BAD_HEADER_LENGHT					= 11,
+	JPEG_DECODER_BAD_COUNT_VALUE					= 12,
+	JPEG_DECODER_BAD_DHT_MARKER						= 13,
+	JPEG_DECODER_BAD_INDEX_VALUE					= 14,
+	JPEG_DECODER_BAD_NUMBER_HUFFMAN_TABLES			= 15,
+	JPEG_DECODER_BAD_QUANT_TABLE_LENGHT				= 16,
+	JPEG_DECODER_BAD_NUMBER_QUANT_TABLES			= 17,
+	JPEG_DECODER_BAD_COMPONENT_COUNT				= 18,
+	JPEG_DECODER_DIVIDE_BY_ZERO_ERROR				= 19,
+	JPEG_DECODER_NOT_JPG_IMAGE						= 20,
+	JPEG_DECODER_UNSUPPORTED_ROTATION_ANGLE			= 21,
+	JPEG_DECODER_UNSUPPORTED_SCALING				= 22,
+	JPEG_DECODER_INSUFFICIENT_OUTPUTBUFFER_SIZE		= 23,
+	JPEG_DECODER_BAD_HWCFG_GP_VERSION_VALUE			= 24,
+	JPEG_DECODER_BAD_VALUE_FROM_RED					= 25,
+	JPEG_DECODER_BAD_SUBREGION_PARAMETERS			= 26,
+	JPEG_DECODER_PROGRESSIVE_DECODE_NOT_SUPPORTED	= 27,
+    JPEG_DECODER_ERROR_TASK_TIMEOUT					= 28
+#else
+	JPEG_DECODER_NO_ERROR = 0,
+    JPEG_DECODER_ERROR_NOT_RECOVERED = 4,
+    JPEG_DECODER_ERROR_TASK_TIMEOUT = 8
+#endif
+}	JPEGDECHW_DecodingError_t;
+
+
+/*
+** JPEGDECHW_DecodingMode_t :
+** Identifies the decoding mode.
+*/
+typedef enum
+{
+    JPEGDECHW_NORMAL_DECODE = 0,
+    /* Other values to be added later */
+}	JPEGDECHW_DecodingMode_t;
+
+
+/*
+** JPEGDECHW_AdditionalFlags_t :
+** Identifies the different flags that will be passed to JPEG firmware
+*/
+#if (JPEGHW_MME_VERSION >= 14)
+typedef enum
+{
+    JPEGDECHW_ADDITIONAL_FLAG_NONE = 0,
+    JPEGDECHW_ADDITIONAL_FLAG_CEH  = 1, /* Request firmware to return values of the CEH registers */
+	JPEGDECHW_ADDITIONAL_FLAG_RASTER = 64, /* Output storage of Auxillary reconstruction in Raster format. */
+	JPEGDECHW_ADDITIONAL_FLAG_420MB = 128 /* Output storage of Auxillary reconstruction in 420MB format. */
+}	JPEGDECHW_AdditionalFlags_t;
+#elif (JPEGHW_MME_VERSION >= 12)
+typedef enum
+{
+    JPEGDECHW_ADDITIONAL_FLAG_NONE = 0,
+    JPEGDECHW_ADDITIONAL_FLAG_CEH  = 1, /* Request firmware to return values of the CEH registers */
+	JPEGDECHW_ADDITIONAL_FLAG_RASTER = 64 /* Output storage of Auxillary reconstruction in Raster format. */
+}	JPEGDECHW_AdditionalFlags_t;
+#else
+typedef enum
+{
+    JPEGDECHW_ADDITIONAL_FLAG_NONE = 0,
+    JPEGDECHW_ADDITIONAL_FLAG_CEH  = 1 /* Request firmware to return values of the CEH registers */
+}	JPEGDECHW_AdditionalFlags_t;
+#endif
+
+
+/*
+** JPEGDECHW_VideoDecodeReturnParams_t :
+** Identifies the parameters to be returned back to the driver by decoder.
+*/
+typedef struct _JPEGDECHWVIDEODECODERETURNPARAMS_T_
+{
+	/* profiling info */
+#if (JPEGHW_MME_VERSION >= 17)
+    U32 DecodeTimeInMicros;
+#endif
+#if (JPEGHW_MME_VERSION <= 16) || defined (DUMP_PROFILE_INFO)
+	U32 pm_cycles;
+	U32 pm_dmiss;
+	U32 pm_imiss;
+	U32 pm_bundles;
+	U32 pm_pft;
+#endif
+	JPEGDECHW_DecodingError_t ErrorCode;
+    // CEHRegisters[] is an array where values of the
+    // Contrast Enhancement Histogram (CEH) registers will be stored.
+    // CEHRegisters[0] will correspond to register MBE_CEH_0_7, CEHRegisters[1] will
+    // correspond to register MBE_CEH_8_15., CEHRegisters[2], correspond to register
+    // MBE_CEH_16_23.
+    // Note that elements of this array will be updated only if
+    // VC9_TransformParam_t.AdditionalFlags will have the flag
+    // VC9_ADDITIONAL_FLAG_CEH set. They will remain unchanged otherwise.
+	U32 CEHRegisters[JPEGDECHW_NUMBER_OF_CEH_INTERVALS];
+#ifdef JPEGHW_DEBUG
+	S32 LastDecodedMB;
+#endif	
+}	JPEGDECHW_VideoDecodeReturnParams_t;
+
+
+/*
+** JPEGDECHW_VideoDecodeCapabilityParams_t :
+** Transformer capability parameters.
+*/
+typedef struct _JPEGDECHW_VIDEODECODECAPABILITYPARAMS_T_
+{
+	U32 api_version;	// Omega2 frame buffer size (luma+chroma)
+}	JPEGDECHW_VideoDecodeCapabilityParams_t;
+
+
+/*
+** JPEGDECHW_VideoDecodeParams_t :
+** Parameters to be sent along with the Transform command
+*/
+typedef struct _JPEGDECHW_VIDEODECODEPARAMS_T_
+{
+	JPEGDECHW_CompressedData_t		PictureStartAddr_p;
+	JPEGDECHW_CompressedData_t		PictureEndAddr_p;
+	JPEGDECHW_DecodedBufferAddress_t DecodedBufferAddr;
+#if (JPEGHW_MME_VERSION >= 15)
+	JPEGDECHW_DisplayBufferAddress_t	DisplayBufferAddr;
+#endif
+#if (JPEGHW_MME_VERSION >= 15)
+	JPEGDECHW_RcnRefDispEnable_t		MainAuxEnable;	/* enable Main and/or Aux outputs */ 
+#else
+	JPEGDECHW_MainAuxEnable_t			MainAuxEnable;  /* enable Main and/or Aux outputs */ 
+#endif
+	JPEGDECHW_HorizontalDeciFactor_t HorizontalDecimationFactor;
+	JPEGDECHW_VerticalDeciFactor_t	VerticalDecimationFactor;
+	U32	xvalue0;				/* The X(0) coordinate for subregion decoding                                                 */
+	U32	xvalue1;				/* The X(1) coordinate for subregion decoding                                                 */
+	U32	yvalue0;				/* The Y(0) coordinate for subregion decoding                                                 */
+	U32	yvalue1;				/* The Y(1) coordinate for subregion decoding                                                */
+	JPEGDECHW_DecodingMode_t		DecodingMode;
+#if (JPEGHW_MME_VERSION >= 12)
+    U32 AdditionalFlags;		/* Additonal Flags */
+#else
+    JPEGDECHW_AdditionalFlags_t     AdditionalFlags; /* Additonal Flags */
+#endif
+#if (JPEGHW_MME_VERSION >= 16)
+	U32									FieldFlag; /* Determines Frame/Field Scan */
+#endif
+#ifdef JPEG_PIC_SEQ_DEBUG_INFO
+	U8 *DebugBufferPtr;
+#endif
+}	JPEGDECHW_VideoDecodeParams_t;
+
+
+#ifdef JPEG_PIC_SEQ_DEBUG_INFO
+/*
+** JPEG_DebugPicture_t :
+** Parameters to be sent along with the Transform command
+*/
+typedef struct _JPEG_DEBUGPICTURE_T_
+{
+	U32 PicStdConfig;
+	U32 PictureWidthWord;
+	U32 PictureHeightWord;
+	U32 PicType_IPF;
+	U32 PictureWidthWord_IPF;
+	U32 PictureHeightWord_IPF;
+}	JPEG_DebugPicture_t;
+#endif
+
+#ifdef JPEG_MB_DEBUG_INFO
+/*
+** JPEG_DebugMb_t :
+** Parameters to be sent along with the Transform command
+*/
+typedef struct _JPEG_DEBUGMB_T_
+{
+	U32 SMB_WORD_0;
+	U32 SMB_WORD_1;
+	U32 MbType;
+	U32 LmbWord2;
+	U32 Data2PipeWord[192];
+	U32 BitBuf_LSB[6];
+	U32 BitBuf_MSB[6];
+}	JPEG_DebugMb_t;
+#endif
+
+#endif /* _JPEGDECHW_VIDEOTRANSFORMERTYPES_H_ */
+
diff -Naur DirectFB-1.7.7/interfaces/IDirectFBImageProvider/mme/transform/JPEG_VideoTransformerTypes.h DirectFB-1.7.7.stm/interfaces/IDirectFBImageProvider/mme/transform/JPEG_VideoTransformerTypes.h
--- DirectFB-1.7.7/interfaces/IDirectFBImageProvider/mme/transform/JPEG_VideoTransformerTypes.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7.stm/interfaces/IDirectFBImageProvider/mme/transform/JPEG_VideoTransformerTypes.h	2015-05-15 18:43:40.101419076 +0200
@@ -0,0 +1,192 @@
+/*
+   ST Microelectronics MME JPEG transformer - user API
+
+   (c) Copyright 2010       STMicroelectronics Ltd.
+
+   All rights reserved.
+*/
+
+#ifndef __JPEG_VIDEOTRANSFORMERTYPES_H__
+#define __JPEG_VIDEOTRANSFORMERTYPES_H__
+
+
+#define JPEGDEC_MME_TRANSFORMER_NAME "JPEG_Transformer"
+
+#if JPEGDEC_MME_VERSION == 0
+#  define JPEGDEC_MME_VERSION 1
+#endif
+
+#if (JPEGDEC_MME_VERSION == 20)
+#  define JPEGDEC_MME_API_VERSION "2.0"
+#elif (JPEGDEC_MME_VERSION == 1)
+#  define JPEGDEC_MME_API_VERSION "1.0"
+#else
+#  error only API versions 1 or 2.0 are supported
+#endif
+
+/* Common driver error constants */
+#if (JPEGDEC_MME_VERSION == 1)
+#  define JPEGDEC_ERROR_ID   0
+#  define JPEGDEC_ERROR_BASE (JPEG_ERROR_ID << 16)
+#else
+#  include <jerror.h>
+#endif
+
+
+
+
+#if (JPEGDEC_MME_VERSION == 1)
+/* Structure for GetTransformerCapability() */
+typedef struct
+{
+  /* for further expansion... */
+  unsigned int dummy;
+} JPEGDEC_TransformerInfo_t;
+
+typedef struct
+{
+  unsigned int caps_len;
+}JPEGDEC_Capability_t;
+#elif (JPEGDEC_MME_VERSION == 20)
+enum JPEGDEC_TransformFlags {
+  JDIF_ROTATE90            = 0x00000001,
+  JDIF_ROTATE270           = 0x00000002,
+  JDIF_FLIP_HORIZONTAL     = 0x00000004,
+  JDIF_FLIP_VERTICAL       = 0x00000008,
+  JDIF_ALL                 = 0x0000000f,
+};
+#endif
+
+
+
+/* Structure for the Transformer Initialization */
+typedef struct
+{
+  /* coardinates for subregion decoding */
+  unsigned int xvalue0;
+  unsigned int xvalue1;
+  unsigned int yvalue0;
+  unsigned int yvalue1;
+
+  /* Output width and height of the decoded image. Used for IDCT select and
+     resizing (if done in the core). */
+  int outputWidth;
+  int outputHeight;
+
+#if (JPEGDEC_MME_VERSION == 1)
+  /* TRUE if Rotatedegree is other than zero degree
+     Rotation clockwise/anticlockwise is required */
+  int ROTATEFLAG;
+  /* degree of rotation clockwise/anti-clockwise || 90 | 180 | 270 */
+  int Rotatedegree;
+  /* Flag set TRUE when vertical flip of the picture is required */
+  int VerticalFlip;
+  /* Flag set TRUE when vertical flip of the picture is required */
+  int HorizantalFlip;
+
+  /* the pitch. Valid only if ROTATEFLAG & 0x80000000 */
+  int Pitch;
+#elif (JPEGDEC_MME_VERSION == 20)
+  /* you should really set this, otherwise some default value is used, which
+     doesn't necessarily coincides with what you assume. */
+  int pitch;
+#endif
+} JPEGDEC_InitParams_t;
+
+
+
+
+
+typedef enum
+{
+  /* planar 3 buffer YCbCr, 4:4:4, 4:2:2 or 4:2:0 (not implemented) */
+  /* 24 bit YUV planar (3 planes, Y Cb Cr, each 8 bit) */
+  JPEGDEC_OF_YCbCr4xxp,
+  /* 16 bit YUV        ( 8 bit Y plane followed by one
+                        16 bit half width CbCr [15:0] plane) */
+  JPEGDEC_OF_NV16,
+  /* 16 bit YUV        (4 byte/ 2 pixel, macropixel contains YCbYCr [31:0]) */
+  JPEGDEC_OF_UYVY,
+  /* 24 bit VYU 4:4:4  (3 byte, Cr 8@16, Y 8@8, Cb 8@0) */
+  JPEGDEC_OF_YCbCr444r, /* DSPF_VYU in DirectFB */
+  /* 24 bit RGB        (3 byte, red 8@16, green 8@8, blue 8@0) */
+  JPEGDEC_OF_RGB,
+} JPEGDEC_OutputFormat_t;
+
+
+/* Structure for the databuffers passed with TRANSFORM commands */
+typedef struct
+{
+  /* Steering of size/widht/height of output picture */
+  JPEGDEC_InitParams_t outputSettings;
+#if (JPEGDEC_MME_VERSION == 20)
+  JPEGDEC_OutputFormat_t OutputFormat;
+  enum JPEGDEC_TransformFlags flags;
+#endif
+} JPEGDEC_TransformParams_t;
+
+
+#if (JPEGDEC_MME_VERSION == 1)
+typedef enum
+{
+  JPEG_NO_ERROR,
+  UNDEFINED_HUFF_TABLE,
+  UNSUPPORTED_MARKER,
+  UNABLE_ALLOCATE_MEMORY,
+  NON_SUPPORTED_SAMP_FACTORS,
+  BAD_PARAMETER,
+  DECODE_ERROR,
+  BAD_RESTART_MARKER,
+  UNSUPPORTED_COLORSPACE,
+  BAD_SOS_SPECTRAL,
+  BAD_SOS_SUCCESSIVE,
+  BAD_HEADER_LENGHT,
+  BAD_COUNT_VALUE,
+  BAD_DHT_MARKER,
+  BAD_INDEX_VALUE,
+  BAD_NUMBER_HUFFMAN_TABLES,
+  BAD_QUANT_TABLE_LENGHT,
+  BAD_NUMBER_QUANT_TABLES,
+  BAD_COMPONENT_COUNT,
+  DIVIDE_BY_ZERO_ERROR,
+  NOT_JPG_IMAGE,
+  UNSUPPORTED_ROTATION_ANGLE,
+  UNSUPPORTED_SCALING,
+  INSUFFICIENT_OUTPUTBUFFER_SIZE
+}JPEGDEC_ErrorCodes_t;
+#endif
+
+
+/* Structure for return parameters of TRANSFORM commands */
+typedef struct
+{
+  /* bytes written to the o/p buffer sent back to the host */
+  unsigned int bytes_written;
+  /* scaled image output height / width */
+  int decodedImageHeight;
+  int decodedImageWidth;
+
+#if (JPEGDEC_MME_VERSION == 1)
+  unsigned int Total_cycle;
+  unsigned int DMiss_Cycle;
+  unsigned int IMiss_Cycle;
+  JPEGDEC_ErrorCodes_t ErrorType;
+#elif (JPEGDEC_MME_VERSION == 20)
+
+  int pitch;
+
+  J_MESSAGE_CODE ErrorType;
+#  if defined(JPEGDEC_PROFILING_ENABLE)
+  unsigned int Cycles;
+  unsigned int Bundles;
+  unsigned int ICacheMiss;
+  unsigned int DCacheMiss;
+  unsigned int NopBundles;
+#  endif
+
+#endif
+} JPEGDEC_TransformReturnParams_t;
+
+
+
+#endif /* __JPEG_VIDEOTRANSFORMERTYPES_H__ */
diff -Naur DirectFB-1.7.7/interfaces/IDirectFBImageProvider/mme/transform/PNGDecode_interface.h DirectFB-1.7.7.stm/interfaces/IDirectFBImageProvider/mme/transform/PNGDecode_interface.h
--- DirectFB-1.7.7/interfaces/IDirectFBImageProvider/mme/transform/PNGDecode_interface.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7.stm/interfaces/IDirectFBImageProvider/mme/transform/PNGDecode_interface.h	2015-05-15 18:43:40.101419076 +0200
@@ -0,0 +1,191 @@
+#ifndef PNGDECODERINTERFACE_H
+#define PNGDECODERINTERFACE_H
+
+#define PNGDECODER_MME_TRANSFORMER_NAME "PNGDECODER"
+
+#if (PNGDEC_MME_VERSION == 11)
+    #define PNGDECODER_MME_API_VERSION "1.1"
+#elif (PNGDEC_MME_VERSION == 10)
+    #define PNGDECODER_MME_API_VERSION "1.0"
+#else
+    #define PNGDECODER_MME_API_VERSION "undefined"
+#endif
+
+#define PNGDECODE_COLOR_MASK_PALETTE    1
+#define PNGDECODE_COLOR_MASK_COLOR       2
+#define PNGDECODE_COLOR_MASK_ALPHA       4
+
+#define PNGDECODE_MAX_PALETTE  256
+
+typedef enum
+{
+	PNGDECODE_COLOR_TYPE_GRAY = 0 /* PNG_COLOR_TYPE_GRAY */,
+	PNGDECODE_COLOR_TYPE_PALETTE = PNGDECODE_COLOR_MASK_COLOR | PNGDECODE_COLOR_MASK_PALETTE /* PNG_COLOR_TYPE_PALETTE */,
+	PNGDECODE_COLOR_TYPE_RGB =  PNGDECODE_COLOR_MASK_COLOR /* PNG_COLOR_TYPE_RGB */,
+	PNGDECODE_COLOR_TYPE_RGB_ALPHA = PNGDECODE_COLOR_MASK_COLOR | PNGDECODE_COLOR_MASK_ALPHA /* PNG_COLOR_TYPE_RGB_ALPHA */,
+	PNGDECODE_COLOR_TYPE_GRAY_ALPHA = PNGDECODE_COLOR_MASK_ALPHA /* PNG_COLOR_TYPE_GRAY_ALPHA*/ 
+}PNGDecode_ColorType_t;
+
+typedef enum
+{
+	PNGDECODE_INTERLACE_NONE = 0 /* PNG_INTERLACE_NONE */,
+	PNGDECODE_INTERLACE_ADAM7 = 1 /* PNG_INTERLACE_ADAM7 */
+}PNGDecode_InterlaceType_t;
+
+typedef enum
+{
+	PNGDECODE_COMPRESSION_TYPE_BASE = 0 /* PNG_COMPRESSION_TYPE_BASE */
+}PNGDecode_CompressionType_t;
+
+
+typedef enum
+{
+	PNGDECODE_FILTER_TYPE_BASE = 0 /* PNG_FILTER_TYPE_BASE */
+}PNGDecode_FilterMethod_t;
+
+/* for an MME_TRANSFORM command the ones marked with a star or plus denote
+   possibly corrupt data when seen together with MME_INVALID_ARGUMENT. A plus
+   is given for PNGDEC_MME_VERSION == 10 and a star for
+   PNGDEC_MME_VERSION == 11. In theory, PNGDECODE_MEMORY_ALLOCATION_ERROR
+   could denote corrupt data, too, but it's unlikely any data was decoded
+   at all, thus it doesn't make sense to display the result, either try
+   again or use libpng on the host! For version 10,
+   PNGDECODE_INTERNAL_ERROR is returned in more occasions than just data
+   corruption. */
+typedef enum
+{
+	PNGDECODE_NO_ERROR,
+	PNGDECODE_MEMORY_ALLOCATION_ERROR,
+	PNGDECODE_CRC_ERROR               /* +* */,
+	PNGDECODE_INVALID_STREAM          /* +* */,
+	PNGDECODE_INTERNAL_ERROR          /* + */
+#if (PNGDEC_MME_VERSION > 10)
+	,PNGDECODE_INVALID_ARGUMENT
+    ,PNGDECODE_STREAM_ERROR           /* * */
+#endif
+} PNGDecode_ErrorCodes_t;
+
+
+typedef struct 
+{
+    /* Picture Width in pixels */
+	unsigned int  PictureWidth;
+	
+	/* Picture Height in pixels */ 
+	unsigned int  PictureHeight;
+	
+    /* bitstream information: */
+	/* Number of bits per sample or palette index */ 
+	unsigned int  BitDepth;
+	/* Color type as encoded in the bitstream */
+	PNGDecode_ColorType_t ColorType;	
+	/* Transmission order of image data */
+	PNGDecode_InterlaceType_t InterlaceType;
+	/* Only compression type 0 is supported */ 
+	PNGDecode_CompressionType_t CompressionType;
+	/* Only Filter method 0 is supported */
+	PNGDecode_FilterMethod_t FilterMethod; 
+	
+	PNGDecode_ErrorCodes_t ErrorType;
+
+#if (PNGDEC_MME_VERSION > 10)
+    /* transformer return params: */
+    /* Color type as returned by the transformer:
+       - PNGDECODE_COLOR_TYPE_PALETTE (LUT8)
+       - PNGDECODE_COLOR_TYPE_RGB (RGB24)
+       - PNGDECODE_COLOR_TYPE_RGB_ALPHA (ARGB32) */
+    PNGDecode_ColorType_t ColorFormatOutput;
+
+    int HaveColorKey;
+    unsigned int ColorKey; /* 32 bit xRGB */
+
+    unsigned int pitch;
+
+    unsigned char palette[4 * PNGDECODE_MAX_PALETTE]; /* ARGB ARGB ARGB */
+#endif
+} PNGDecode_GlobalTransformReturnParams_t;
+
+
+#if (PNGDEC_MME_VERSION == 10)
+
+typedef enum
+{
+    /* always ARGB */
+    PNGDECODE_OUTPUTFORMAT_ARGB = 0
+} PNGDecode_OutputFormat_t;
+
+typedef struct
+{
+    /* indicates seven step display in case of interlaced pictures */
+    unsigned int             ProgressiveDisplayFlag;
+    PNGDecode_OutputFormat_t OutputFormat;
+} PNGDecode_GlobalParams_t;
+
+typedef struct
+{
+    unsigned int caps_len;
+} caps_len_t;
+
+typedef struct
+{
+    unsigned char *caps;
+} caps_t;
+
+#elif (PNGDEC_MME_VERSION > 10)
+
+typedef enum
+{
+    /* PNGDecode_OutputFormat_t, valid in PNGDecode_GlobalParams_t and
+       PNGDecode_InitTransformerParams_t */
+    PNGDECODE_PARAM_FORMAT      = 0x00000001,
+    /* pitch, only valid in PNGDecode_TransformParams_t */
+    PNGDECODE_PARAM_PITCH       = 0x00000002
+} PNGDecode_Params_Flags_t;
+
+typedef enum
+{
+    /* expand everything to RGB24 (if the image has no alpha components, else
+       to ARGB32) */
+    PNGDECODE_OF_EXPAND,
+    /* keep indexed images:
+       - LUT8 for all (non alpha) greyscale (any bitdepth) and 8bit palette
+         images
+       - RGB24 for all other non alpha images
+       - ARGB32 for alpha images */
+    PNGDECODE_OF_COMPRESSED,
+    /* always expand to ARGB32 */
+    PNGDECODE_OF_EXPAND_FORCE_ALPHA
+} PNGDecode_OutputFormat_t;
+
+typedef struct
+{
+    PNGDecode_Params_Flags_t flags;
+    /* if not specified, PNGDECODE_OF_EXPAND is assumed */
+    PNGDecode_OutputFormat_t format;
+    /* if not specified, the pitch will be as returned in
+       PNGDecode_GlobalTransformReturnParams_t */
+    int pitch;
+} PNGDecode_InitTransformerParams_t,
+  PNGDecode_TransformParams_t,
+  PNGDecode_GlobalParams_t;
+
+#endif
+
+
+typedef struct
+{	/* Number of bytes written by the decoder into the output buffer*/
+	unsigned int BytesWritten;
+	/* Error encountered while decoding the picture */
+	PNGDecode_ErrorCodes_t ErrorType;
+
+#if defined(PNGDECODE_PROFILING_ENABLE)
+	unsigned int Cycles;
+	unsigned int Bundles;
+	unsigned int ICacheMiss;
+	unsigned int DCacheMiss;
+	unsigned int NopBundles;
+#endif
+} PNGDecode_TransformReturnParams_t;
+
+
+#endif /* PNGDECODERINTERFACE_H */
diff -Naur DirectFB-1.7.7/interfaces/IDirectFBImageProvider/mme/transform/RLEDecode_interface.h DirectFB-1.7.7.stm/interfaces/IDirectFBImageProvider/mme/transform/RLEDecode_interface.h
--- DirectFB-1.7.7/interfaces/IDirectFBImageProvider/mme/transform/RLEDecode_interface.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7.stm/interfaces/IDirectFBImageProvider/mme/transform/RLEDecode_interface.h	2015-05-15 18:43:40.105423076 +0200
@@ -0,0 +1,119 @@
+
+#ifndef RLEDECODERINTERFACE_H
+#define RLEDECODERINTERFACE_H
+
+#define RLEDECODER_MME_TRANSFORMER_NAME "RLEDECODER"
+
+#if (RLEDECODER_MME_VERSION==10)
+    #define RLEDECODER_MME_API_VERSION "1.0"
+#else
+    #define RLEDECODER_MME_API_VERSION "undefined"
+#endif
+
+#define RLEDECODE_COLOR_MASK_PALETTE    1
+#define RLEDECODE_COLOR_MASK_COLOR       2
+#define RLEDECODE_COLOR_MASK_ALPHA       4
+
+typedef enum
+{
+	RLEDECODE_COLOR_TYPE_GRAY = 0,
+	RLEDECODE_COLOR_TYPE_PALETTE =  (RLEDECODE_COLOR_MASK_COLOR | RLEDECODE_COLOR_MASK_PALETTE),
+	RLEDECODE_COLOR_TYPE_RGB =  (RLEDECODE_COLOR_MASK_COLOR),
+	RLEDECODE_COLOR_TYPE_RGB_ALPHA = (RLEDECODE_COLOR_MASK_COLOR | RLEDECODE_COLOR_MASK_ALPHA),
+	RLEDECODE_COLOR_TYPE_GRAY_ALPHA =  (RLEDECODE_COLOR_MASK_ALPHA)
+}RLEDecode_ColorType_t;
+
+typedef enum
+{
+	RLEDECODE_INTERLACE_NONE = 0,
+	RLEDECODE_INTERLACE_ADAM7 = 1
+}RLEDecode_InterlaceType_t;
+
+typedef enum
+{
+	RLEDECODE_COMPRESSION_TYPE_BASE = 0
+}RLEDecode_CompressionType_t;
+
+
+typedef enum
+{
+	RLEDECODE_FILTER_TYPE_BASE = 0
+}RLEDecode_FilterMethod_t;
+
+typedef enum
+{
+	RLEDECODE_OUTPUTFORMAT_ARGB = 0
+}RLEDecode_OutputFormat_t;
+
+typedef enum
+{
+	RLEDECODE_NO_ERROR,
+	RLEDECODE_MEMEORY_ALLOCATION_ERROR,
+	RLEDECODE_CRC_ERROR,
+	RLEDECODE_INVALID_STREAM,
+	RLEDECODE_INTERNAL_ERROR
+} RLEDecode_ErrorCodes_t;
+
+
+typedef struct 
+{	/* Picture Width in pixels */
+	unsigned int  PictureWidth;
+	
+	/* Picture Height in pixels */ 
+	unsigned int  PictureHeight;
+	
+	/* Number of bits per sample or palette index */ 
+	unsigned int  BitDepth;
+ 	
+	/* Color type as encoded in the bitstream */
+	RLEDecode_ColorType_t ColorType;	
+	 
+	/* Transmission order of image data */
+	RLEDecode_InterlaceType_t InterlaceType;
+
+	/* Only compression type 0 is supported */ 
+	RLEDecode_CompressionType_t CompressionType;
+
+	/* Only Filter method 0 is supported */
+	RLEDecode_FilterMethod_t FilterMethod; 
+	
+	RLEDecode_ErrorCodes_t ErrorType;
+
+} RLEDecode_GlobalTransformReturnParams_t; 
+
+
+typedef struct 
+{	/* Indicates seven step display in case if interlaced 	pictures */
+  	unsigned int		ProgressiveDisplayFlag;
+	RLEDecode_OutputFormat_t OutputFormat;
+	
+} RLEDecode_GlobalParams_t;
+
+typedef struct 
+{	/* Number of bytes written by the decoder into the output 	buffer*/
+  	unsigned int	BytesWritten;
+	/* Error encountered while decoding the picture */
+	RLEDecode_ErrorCodes_t ErrorType;
+
+#ifdef RLEDECODE_PROFILING_ENABLE
+	unsigned int Cycles;
+	unsigned int Bundles;
+	unsigned int ICacheMiss;
+	unsigned int DCacheMiss;
+	unsigned int NopBundles;
+#endif
+
+}RLEDecode_TransformReturnParams_t;
+
+typedef struct
+{
+	unsigned int caps_len;
+}caps_len_t;
+
+typedef struct
+{
+	unsigned char *caps;
+}caps_t;
+
+#endif /* RLEDECODERINTERFACE_H */
+
diff -Naur DirectFB-1.7.7/interfaces/IDirectFBImageProvider/mme_helper.h DirectFB-1.7.7.stm/interfaces/IDirectFBImageProvider/mme_helper.h
--- DirectFB-1.7.7/interfaces/IDirectFBImageProvider/mme_helper.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7.stm/interfaces/IDirectFBImageProvider/mme_helper.h	2015-05-15 18:43:40.109427075 +0200
@@ -0,0 +1,1042 @@
+#ifndef __MME_HELPER_H__
+#define __MME_HELPER_H__
+
+
+#if defined(USE_MME)
+#include <semaphore.h>
+#include <mme.h>
+#include <direct/hash.h>
+#endif /* USE_MME */
+#include <direct/util.h>
+#include "sema_helper.h"
+
+#define likely(x)       __builtin_expect(!!(x),1)
+#define unlikely(x)     __builtin_expect(!!(x),0)
+
+#define container_of(ptr, type, member) ({ \
+    const typeof( ((type *)0)->member ) *__mptr = (ptr); \
+    (type *)( (char *)__mptr - offsetof(type,member) );})
+
+#ifndef MAX_STREAMING_COMMANDS
+  #define MAX_STREAMING_COMMANDS    5
+#endif
+#ifndef MME_STREAMING_BUFFERSIZE
+  #define MME_STREAMING_BUFFERSIZE  (32 * 1024) /* this must _not_ be less
+                                                   than 8 k */
+#endif
+
+
+#if defined(USE_MME)
+struct _MMEHelper_buffer {
+  MME_DataBuffer_t *buffer;
+  MME_Command_t     command;
+  sem_t             sema;
+};
+#endif /* USE_MME */
+
+typedef struct _MMECommon
+{
+  IDirectFBImageProvider_data base;
+
+  const char *name;
+
+  void         *image; /* decoded image data */
+  unsigned int  width; /* width of the JPEG/PNG image */
+  unsigned int  height; /* height of the JPEG/PNG image */
+
+#ifdef DIRECT_BUILD_DEBUG
+  /* performance monitoring */
+  struct timeval starttime, endtime;
+#endif /* DIRECT_BUILD_DEBUG */
+
+  CoreSurface        *decode_surface;
+  CoreGraphicsSerial  serial;
+
+  unsigned int decoded_width;
+  unsigned int decoded_height;
+
+#if defined(USE_MME)
+  bool name_set;
+  const char *transformer_name;
+
+  /* hardware decode specifics */
+  MME_TransformerHandle_t Handle;
+
+  MME_DataBuffer_t  **OutDataBuffers;
+  MME_ScatterPage_t   OutDataBufferScatterPage;
+  MME_DataBuffer_t    OutDataBuffer;
+
+  struct _MMEHelper_buffer SendDataBuffers[MAX_STREAMING_COMMANDS];
+
+  MME_Command_t TransformCommand; /* provide the output buffer and request
+                                     transform */
+
+  pthread_mutex_t  pending_commands_lock;
+  DirectHash      *pending_commands;
+  unsigned int     n_pending_buffers;
+
+  sem_t decode_event;
+
+  int decode_success;
+
+  /* bytes remaining to be decoded */
+  unsigned int  bytes;
+  unsigned int  packets;
+
+  /* just for statistics */
+  unsigned int  n_underflows;
+#endif /* USE_MME */
+} MMECommon;
+
+
+#if defined(USE_MME)
+/* every user should provide those... */
+static void TransformerCallback( MME_Event_t    Event,
+                                 MME_Command_t *CallbackData,
+                                 void          *UserData );
+static DFBResult abort_transformer( struct _MMECommon *mme );
+static DFBResult fetch_data( IDirectFBDataBuffer *buffer,
+                             MME_DataBuffer_t    *dbuf,
+                             int                  len );
+static void
+_imageprovider_update_transform_params (MMECommon                   * const mme,
+                                        void                        * const params,
+                                        const CoreSurfaceBufferLock * const lock);
+#endif /* USE_MME */
+
+
+static DFBResult
+buffer_to_ptr_copy (IDirectFBDataBuffer * const buffer,
+                    void                * ptr,
+                    int                  len)
+{
+  DFBResult ret;
+
+  while (len > 0)
+    {
+      unsigned int read;
+
+      ret = buffer->WaitForData (buffer, len);
+      if (ret == DFB_OK)
+        ret = buffer->GetData (buffer, len, ptr, &read);
+
+      if (ret)
+        return ret;
+
+      ptr += read;
+      len -= read;
+    }
+
+  return DFB_OK;
+}
+
+
+#if !defined(USE_MME)
+
+#define mme_helper_LoadLib (data) DFB_FILENOTFOUND
+#define mme_helper_UnloadLib (struct _MMECommon * const data) {( )}
+
+#else /* USE_MME */
+
+/* Some Error and Debug Management */
+
+
+static inline const char *
+get_mme_event_string (MME_Event_t ev)
+{
+  static const char *mme_event_strings[] = {
+    "MME_COMMAND_COMPLETED_EVT",
+    "MME_DATA_UNDERFLOW_EVT",
+    "MME_NOT_ENOUGH_MEMORY_EVT",
+    "MME_NEW_COMMAND_EVT",
+  };
+
+  return (((unsigned int) ev) < D_ARRAY_SIZE (mme_event_strings))
+         ? mme_event_strings[ev]
+         : "* Unknown Event code *";
+}
+
+static inline const char *
+get_mme_state_string (MME_CommandState_t s)
+{
+  static const char *mme_command_state_strings[] ={
+    "MME_COMMAND_IDLE",
+    "MME_COMMAND_PENDING",
+    "MME_COMMAND_EXECUTING",
+    "MME_COMMAND_COMPLETED",
+    "MME_COMMAND_FAILED"
+  };
+
+  return (((unsigned int) s) < D_ARRAY_SIZE (mme_command_state_strings))
+         ? mme_command_state_strings[s]
+         : "* Unknown State code *";
+}
+
+static inline const char *
+get_mme_error_string (MME_ERROR e)
+{
+  static const char *mme_error_type_strings[] = {
+    "MME_SUCCESS",
+    "MME_DRIVER_NOT_INITIALIZED",
+    "MME_DRIVER_ALREADY_INITIALIZED",
+    "MME_NOMEM",
+    "MME_INVALID_TRANSPORT",
+    "MME_INVALID_HANDLE",
+    "MME_INVALID_ARGUMENT",
+    "MME_UNKNOWN_TRANSFORMER",
+    "MME_TRANSFORMER_NOT_RESPONDING",
+    "MME_HANDLES_STILL_OPEN",
+    "MME_COMMAND_STILL_EXECUTING",
+    "MME_COMMAND_ABORTED",
+    "MME_DATA_UNDERFLOW",
+    "MME_DATA_OVERFLOW",
+    "MME_TRANSFORM_DEFERRED",
+    "MME_SYSTEM_INTERRUPT",
+    "MME_EMBX_ERROR",
+    "MME_INTERNAL_ERROR",
+    "MME_NOT_IMPLEMENTED"
+  };
+
+  return (((unsigned int) e) < D_ARRAY_SIZE (mme_error_type_strings))
+         ? mme_error_type_strings[e]
+         : "* Unknown Error code *";
+}
+
+
+#if defined(MME_USE_DLOPEN)
+#include <dlfcn.h>
+typedef MME_ERROR (*MME_Init_func) (void);
+typedef MME_ERROR (*MME_Term_func) (void);
+typedef MME_ERROR (*MME_SendCommand_func) (MME_TransformerHandle_t  Handle,
+                                           MME_Command_t           *CmdInfo_p);
+typedef MME_ERROR (*MME_AbortCommand_func) (MME_TransformerHandle_t Handle,
+                                            MME_CommandId_t         CmdId);
+typedef MME_ERROR (*MME_AllocDataBuffer_func) (MME_TransformerHandle_t  handle,
+                                               MME_UINT                 size,
+                                               MME_AllocationFlags_t    flags,
+                                               MME_DataBuffer_t        **dataBuffer_p);
+typedef MME_ERROR (*MME_FreeDataBuffer_func)  (MME_DataBuffer_t         *DataBuffer_p);
+typedef MME_ERROR (*MME_GetTransformerCapability_func) (const char                  *TransformerName,
+                                                        MME_TransformerCapability_t *TransformerCapability_p);
+typedef MME_ERROR (*MME_InitTransformer_func) (const char *Name,
+                                               MME_TransformerInitParams_t *Params_p,
+                                               MME_TransformerHandle_t     *Handle_p);
+typedef MME_ERROR (*MME_IsTransformerRegistered_func) (const char *name);
+typedef MME_ERROR (*MME_TermTransformer_func) (MME_TransformerHandle_t handle);
+typedef const char (*MME_Version_func) (void);
+
+static MME_ERROR _mme_helper_MME_func (void)
+{
+  return MME_DRIVER_NOT_INITIALIZED;
+}
+
+static MME_Init_func _MME_Init = (MME_Init_func) _mme_helper_MME_func;
+static MME_Term_func _MME_Term = (MME_Term_func) _mme_helper_MME_func;
+static MME_SendCommand_func  _MME_SendCommand = (MME_SendCommand_func) _mme_helper_MME_func;
+static MME_AbortCommand_func _MME_AbortCommand = (MME_AbortCommand_func) _mme_helper_MME_func;
+static MME_AllocDataBuffer_func _MME_AllocDataBuffer = (MME_AllocDataBuffer_func) _mme_helper_MME_func;
+static MME_FreeDataBuffer_func  _MME_FreeDataBuffer  = (MME_FreeDataBuffer_func) _mme_helper_MME_func;
+static MME_GetTransformerCapability_func _MME_GetTransformerCapability = (MME_GetTransformerCapability_func) _mme_helper_MME_func;
+static MME_InitTransformer_func _MME_InitTransformer = (MME_InitTransformer_func) _mme_helper_MME_func;
+static MME_IsTransformerRegistered_func _MME_IsTransformerRegistered = (MME_IsTransformerRegistered_func) _mme_helper_MME_func;
+static MME_TermTransformer_func _MME_TermTransformer = (MME_TermTransformer_func) _mme_helper_MME_func;
+static MME_Version_func _MME_Version = (MME_Version_func) _mme_helper_MME_func;
+#define MME_Init _MME_Init
+#define MME_Term _MME_Term
+#define MME_SendCommand  _MME_SendCommand
+#define MME_AbortCommand _MME_AbortCommand
+#define MME_AllocDataBuffer _MME_AllocDataBuffer
+#define MME_FreeDataBuffer _MME_FreeDataBuffer
+#define MME_GetTransformerCapability _MME_GetTransformerCapability
+#define MME_InitTransformer _MME_InitTransformer
+#define MME_IsTransformerRegistered _MME_IsTransformerRegistered
+#define MME_TermTransformer _MME_TermTransformer
+#define MME_Version _MME_Version
+
+static void *mme_helper_libmme;
+#endif /* MME_USE_DLOPEN */
+
+static bool mme_lib_inited;
+
+
+static void
+__attribute__((constructor))
+mme_helper_ctor(void)
+{
+#if defined(MME_USE_DLOPEN)
+  if ((mme_helper_libmme = dlopen ("libmme.so", RTLD_LAZY)) != NULL
+      || (mme_helper_libmme = dlopen ("libmme_host.so", RTLD_LAZY)) != NULL)
+    {
+      _MME_Init = dlsym (mme_helper_libmme, "MME_Init");
+      _MME_Term = dlsym (mme_helper_libmme, "MME_Term");
+      _MME_SendCommand  = dlsym (mme_helper_libmme, "MME_SendCommand");
+      _MME_AbortCommand = dlsym (mme_helper_libmme, "MME_AbortCommand");
+      _MME_AllocDataBuffer = dlsym (mme_helper_libmme, "MME_AllocDataBuffer");
+      _MME_FreeDataBuffer  = dlsym (mme_helper_libmme, "MME_FreeDataBuffer");
+      _MME_GetTransformerCapability = dlsym (mme_helper_libmme, "MME_GetTransformerCapability");
+      _MME_InitTransformer = dlsym (mme_helper_libmme, "MME_InitTransformer");
+
+      /* only available in Multicom 4 and onward */
+      _MME_Version = dlsym (mme_helper_libmme, "MME_Version");
+      if (_MME_Version)
+        _MME_IsTransformerRegistered = dlsym (mme_helper_libmme, "MME_IsTransformerRegistered");
+
+      _MME_TermTransformer = dlsym (mme_helper_libmme, "MME_TermTransformer");
+
+      if (unlikely (!_MME_Init || !_MME_Term
+                    || !_MME_SendCommand || !_MME_AbortCommand
+                    || !_MME_AllocDataBuffer || !_MME_FreeDataBuffer
+                    || !_MME_GetTransformerCapability
+                    || (_MME_Version && !_MME_IsTransformerRegistered)
+                    || !_MME_InitTransformer || !_MME_TermTransformer))
+        {
+          _MME_Init = (MME_Init_func) _mme_helper_MME_func;
+          _MME_Term = (MME_Term_func) _mme_helper_MME_func;
+          _MME_SendCommand = (MME_SendCommand_func) _mme_helper_MME_func;
+          _MME_AbortCommand = (MME_AbortCommand_func) _mme_helper_MME_func;
+          _MME_AllocDataBuffer = (MME_AllocDataBuffer_func) _mme_helper_MME_func;
+          _MME_FreeDataBuffer  = (MME_FreeDataBuffer_func) _mme_helper_MME_func;
+          _MME_GetTransformerCapability = (MME_GetTransformerCapability_func) _mme_helper_MME_func;
+          _MME_InitTransformer = (MME_InitTransformer_func) _mme_helper_MME_func;
+          _MME_IsTransformerRegistered = (MME_IsTransformerRegistered_func) _mme_helper_MME_func;
+          _MME_TermTransformer = (MME_TermTransformer_func) _mme_helper_MME_func;
+          _MME_Version = (MME_Version_func) _mme_helper_MME_func;
+
+          dlclose (mme_helper_libmme);
+          mme_helper_libmme = NULL;
+
+          D_WARN ("Unable to use libmme.so for "MME_TEXT_DOMAIN": (%s)",
+                  dlerror ());
+        }
+      else
+#endif /* MME_USE_DLOPEN */
+        {
+          MME_ERROR mme_res = MME_Init ();
+          D_DEBUG_AT (MME_DEBUG_DOMAIN, "MME_Init() returned %d (%s)\n",
+                      mme_res, get_mme_error_string (mme_res));
+          switch (mme_res)
+            {
+            case MME_DRIVER_ALREADY_INITIALIZED:
+              mme_res = MME_SUCCESS;
+            case MME_SUCCESS:
+              break;
+
+            default:
+              /* probably kernel module or /dev node required */
+              D_ONCE ("failed to initialize MME for "MME_TEXT_DOMAIN": %d (%s)",
+                      mme_res, get_mme_error_string (mme_res));
+              break;
+            }
+
+          mme_lib_inited = (mme_res == MME_SUCCESS);
+          D_DEBUG_AT (MME_DEBUG_DOMAIN, "mme_lib_inited %d\n", mme_lib_inited);
+        }
+#if defined(MME_USE_DLOPEN)
+    }
+  else
+    D_INFO ("Couldn't resolve libmme.so for "MME_TEXT_DOMAIN", can't "
+            "use MME for hw accelerated decoding\n");
+#endif /* MME_USE_DLOPEN */
+}
+
+static void
+__attribute__((destructor))
+mme_helper_dtor(void)
+{
+  /* we can't MME_Term() here - there might be other users of MME still
+     active. MME should implement some use counters instead. */
+//  MME_ERROR mme_res = MME_Term ();
+//  D_DEBUG_AT (MME_DEBUG_DOMAIN, "MME_Term() returned %d (%s)\n",
+//              mme_res, get_mme_error_string (mme_res));
+  mme_lib_inited = false;
+
+#if defined(MME_USE_DLOPEN)
+  if (mme_helper_libmme)
+    {
+      _MME_Init = (MME_Init_func) _mme_helper_MME_func;
+      _MME_Term = (MME_Term_func) _mme_helper_MME_func;
+      _MME_SendCommand = (MME_SendCommand_func) _mme_helper_MME_func;
+      _MME_AbortCommand = (MME_AbortCommand_func) _mme_helper_MME_func;
+      _MME_AllocDataBuffer = (MME_AllocDataBuffer_func) _mme_helper_MME_func;
+      _MME_FreeDataBuffer  = (MME_FreeDataBuffer_func) _mme_helper_MME_func;
+      _MME_InitTransformer = (MME_InitTransformer_func) _mme_helper_MME_func;
+      _MME_IsTransformerRegistered = (MME_IsTransformerRegistered_func) _mme_helper_MME_func;
+      _MME_TermTransformer = (MME_TermTransformer_func) _mme_helper_MME_func;
+      _MME_Version = (MME_Version_func) _mme_helper_MME_func;
+
+      dlclose (mme_helper_libmme);
+      mme_helper_libmme = NULL;
+    }
+#endif /* MME_USE_DLOPEN */
+}
+
+
+/***************************************/
+
+static DFBResult
+__attribute__((unused))
+_mme_helper_get_capability (struct _MMECommon           * const data,
+                            const char                  * const name,
+                            MME_TransformerCapability_t * const cap)
+{
+  volatile u32 _len = 0;
+  MME_ERROR res;
+
+  cap->TransformerInfoSize = sizeof (_len);
+  cap->TransformerInfo_p = (u32 *) &_len;
+
+  cap->StructSize = sizeof (*cap);
+
+  res = MME_GetTransformerCapability (name, cap);
+  if (res != MME_SUCCESS)
+    return DFB_FAILURE;
+
+  D_DEBUG_AT (MME_DEBUG_DOMAIN,
+              "'%s' 1: sz/v/it/ot/is/p: %u, %u (%x), %.2x%.2x%.2x%.2x, "
+              "%.2x%.2x%.2x%.2x, %u, %p (%u bytes)\n",
+              name,
+              cap->StructSize, cap->Version, cap->Version,
+              cap->InputType.FourCC[0], cap->InputType.FourCC[1],
+              cap->InputType.FourCC[2], cap->InputType.FourCC[3],
+              cap->OutputType.FourCC[0], cap->OutputType.FourCC[1],
+              cap->OutputType.FourCC[2], cap->OutputType.FourCC[3],
+              cap->TransformerInfoSize, cap->TransformerInfo_p, _len);
+  if (_len)
+    {
+      char *buf = D_CALLOC (1, _len);
+
+      cap->TransformerInfo_p = buf;
+      cap->TransformerInfoSize = _len;
+
+      res = MME_GetTransformerCapability (name, cap);
+      if (res != MME_SUCCESS)
+        {
+          D_FREE (buf);
+          return DFB_FAILURE;
+        }
+
+      D_DEBUG_AT (MME_DEBUG_DOMAIN,
+                  "'%s' 2: sz/v/it/ot/is/p: %u, %u (%x), '%c%c%c%c' "
+                  "(%.2x%.2x%.2x%.2x), '%c%c%c%c' (%.2x%.2x%.2x%.2x), %u, "
+                  "%p (%u bytes)\n",
+                  name,
+                  cap->StructSize, cap->Version, cap->Version,
+                  cap->InputType.FourCC[0], cap->InputType.FourCC[1],
+                  cap->InputType.FourCC[2], cap->InputType.FourCC[3],
+                  cap->InputType.FourCC[0], cap->InputType.FourCC[1],
+                  cap->InputType.FourCC[2], cap->InputType.FourCC[3],
+                  cap->OutputType.FourCC[0], cap->OutputType.FourCC[1],
+                  cap->OutputType.FourCC[2], cap->OutputType.FourCC[3],
+                  cap->OutputType.FourCC[0], cap->OutputType.FourCC[1],
+                  cap->OutputType.FourCC[2], cap->OutputType.FourCC[3],
+                  cap->TransformerInfoSize, cap->TransformerInfo_p, _len);
+      D_DEBUG_AT (MME_DEBUG_DOMAIN, "caps: '%s'\n", buf);
+
+      D_FREE (buf);
+      cap->TransformerInfo_p = NULL;
+    }
+
+  return DFB_OK;
+}
+
+static DFBResult
+mme_helper_deinit_transformer (struct _MMECommon * const data)
+{
+  MME_ERROR ret;
+
+  if (!data->Handle)
+    return DFB_OK;
+
+  D_DEBUG_AT (MME_DEBUG_DOMAIN, "terminating %s transformer w/ handle %x\n",
+              data->name, data->Handle);
+
+  /* if we are still waiting for the main decode command to finish (because
+     we ran out of data but the transformer is still waiting), abort it.
+     JPEG needs this. */
+  /* FIXME: what about locking? */
+  if (direct_hash_lookup (data->pending_commands,
+                          data->TransformCommand.CmdStatus.CmdId))
+    {
+      abort_transformer (data);
+      while ((sema_wait_event (&data->decode_event) == -1)
+             && errno == EINTR)
+        ;
+    }
+
+  if (data->n_underflows)
+    {
+      D_INFO ("%s: %d data underflow(s) during decode\n",
+              data->name, data->n_underflows);
+      data->n_underflows = 0;
+    }
+
+  ret = MME_TermTransformer (data->Handle);
+  if (ret != MME_SUCCESS)
+    {
+      D_WARN ("(%5d) Couldn't terminate %s transformer w/ handle %x: %d (%s)",
+              direct_gettid (), data->name, data->Handle, ret,
+              get_mme_error_string (ret));
+      return DFB_FAILURE;
+    }
+
+  D_DEBUG_AT (MME_DEBUG_DOMAIN, "  -> terminated %s transformer w/ handle %x\n",
+              data->name, data->Handle);
+
+  if (data->pending_commands)
+    {
+      pthread_mutex_destroy (&data->pending_commands_lock);
+      direct_hash_destroy (data->pending_commands);
+      data->pending_commands = NULL;
+    }
+
+  data->Handle = 0;
+  return DFB_OK;
+}
+
+static DFBResult
+mme_helper_init_transformer2 (struct _MMECommon * const data,
+                              const char const  * const transformer_names[],
+                              size_t             transformer_params_size,
+                              void              * const transformer_params,
+                              unsigned int      * const ret_index,
+                              MME_GenericCallback_t Callback)
+{
+  DFBResult dfb_res;
+  unsigned int index;
+
+  MME_ERROR ret;
+  MME_TransformerInitParams_t params;
+
+  D_ASSUME (data->Handle == 0);
+  D_ASSUME ((transformer_params_size == 0 && transformer_params == NULL)
+            || (transformer_params_size && transformer_params));
+
+  if (!mme_lib_inited)
+    return DFB_NOSUCHINSTANCE;
+
+  params.StructSize = sizeof (params);
+  params.Priority   = MME_PRIORITY_BELOW_NORMAL;
+  params.Callback         = Callback;
+  params.CallbackUserData = data;
+  params.TransformerInitParamsSize = transformer_params_size;
+  params.TransformerInitParams_p   = transformer_params;
+
+  D_DEBUG_AT (MME_DEBUG_DOMAIN, "initializing %s tranformer:\n", data->name);
+
+  index = 0;
+  do
+    {
+      D_DEBUG_AT (MME_DEBUG_DOMAIN, "  -> %s\n", transformer_names[index]);
+
+      if (MME_IsTransformerRegistered != (MME_IsTransformerRegistered_func) _mme_helper_MME_func)
+        {
+          ret = MME_IsTransformerRegistered (transformer_names[index]);
+          if (ret != MME_SUCCESS)
+            continue;
+        }
+
+      ret = MME_InitTransformer (transformer_names[index],
+                                 &params, &data->Handle);
+    }
+  while (ret != MME_SUCCESS && transformer_names[++index] != NULL);
+
+  if (ret != MME_SUCCESS)
+    {
+      if (ret != MME_DRIVER_NOT_INITIALIZED
+          && ret != MME_DRIVER_ALREADY_INITIALIZED
+          && ret != MME_UNKNOWN_TRANSFORMER)
+        D_WARN ("(%5d) %s transformer initialisation failed: %s",
+                direct_gettid (), data->name, get_mme_error_string (ret));
+      data->Handle = 0;
+      return DFB_IDNOTFOUND;
+    }
+
+  D_DEBUG_AT (MME_DEBUG_DOMAIN, "    -> OK (handle %x)\n", data->Handle);
+
+  D_ASSUME (data->n_pending_buffers == 0);
+  data->n_pending_buffers = 0;
+  pthread_mutex_init (&data->pending_commands_lock, NULL);
+  if ((dfb_res = direct_hash_create (17, &data->pending_commands)) != DFB_OK)
+    {
+      data->pending_commands = NULL;
+      mme_helper_deinit_transformer (data);
+    }
+
+  if (ret_index)
+    *ret_index = index;
+
+  return dfb_res;
+}
+
+static DFBResult
+mme_helper_init_transformer (struct _MMECommon * const data,
+                             const char const  * const transformer_names[],
+                             size_t             transformer_params_size,
+                             void              * const transformer_params,
+                             unsigned int      * const ret_index)
+{
+  return mme_helper_init_transformer2 (data, transformer_names,
+                                       transformer_params_size,
+                                       transformer_params,
+                                       ret_index,
+                                       &TransformerCallback);
+}
+
+
+/* Create MME_DataBuffer Structures required to map an Existing Buffer */
+static void
+create_MME_output_data_buffer (struct _MMECommon * const data,
+                               MME_DataBuffer_t  * const buf,
+                               unsigned int       flags,
+                               void              * const dstbuf,
+                               unsigned int       size)
+{
+  buf->StructSize           = sizeof (MME_DataBuffer_t);
+  buf->Flags                = flags;
+  buf->StreamNumber         = 0;
+  buf->NumberOfScatterPages = 1;
+
+  /* create scatter page detail */
+  buf->ScatterPages_p  = &data->OutDataBufferScatterPage;
+  buf->TotalSize       = size;
+  buf->StartOffset     = 0;
+
+  /* scatter page for the data buffer passed in */
+  buf->ScatterPages_p[0].Page_p    = dstbuf;
+  buf->ScatterPages_p[0].Size      = size;
+  buf->ScatterPages_p[0].BytesUsed = 0;
+  buf->ScatterPages_p[0].FlagsIn   = 0;
+  buf->ScatterPages_p[0].FlagsOut  = 0;
+}
+
+
+static inline DFBResult
+buffer_to_mme_copy (IDirectFBDataBuffer * const buffer,
+                    MME_DataBuffer_t    * const dbuf,
+                    int                  len)
+{
+  dbuf->ScatterPages_p[0].BytesUsed = len;
+
+  return buffer_to_ptr_copy (buffer, dbuf->ScatterPages_p[0].Page_p, len);
+}
+
+
+
+
+static DFBResult
+_mme_helper_start_transformer_core (struct _MMECommon     * const data,
+                                    size_t                 return_params_size,
+                                    void                  * const return_params,
+                                    size_t                 params_size,
+                                    void                  * const params,
+                                    CoreSurface           * const dst_surface,
+                                    CoreSurfaceBufferLock * const lock)
+{
+  DFBResult    res;
+  unsigned int buffersize;
+
+  D_ASSERT (data->OutDataBuffers == NULL);
+
+  res = dfb_surface_lock_buffer (dst_surface, CSBR_BACK, CSAID_ACCEL0,
+                                 CSAF_WRITE, lock);
+  if (res != DFB_OK)
+    return res;
+
+  buffersize = lock->pitch * dst_surface->config.size.h;
+
+  data->OutDataBuffers = (MME_DataBuffer_t **) D_MALLOC (sizeof (MME_DataBuffer_t *));
+  if (!data->OutDataBuffers)
+    goto out;
+  create_MME_output_data_buffer (data, &data->OutDataBuffer,
+                                 MME_ALLOCATION_PHYSICAL,
+                                 lock->addr, buffersize);
+  data->OutDataBuffers[0] = &data->OutDataBuffer;
+
+  data->TransformCommand.DataBuffers_p = data->OutDataBuffers;
+
+  D_DEBUG_AT (MME_DEBUG_DOMAIN, "surface locked @ %p (pitch %u)\n",
+              lock->addr, lock->pitch);
+
+  /* init the commandstatus */
+  memset (&(data->TransformCommand.CmdStatus), 0, sizeof (MME_CommandStatus_t));
+  data->TransformCommand.CmdStatus.AdditionalInfoSize = return_params_size;
+  data->TransformCommand.CmdStatus.AdditionalInfo_p = return_params;
+
+  /* Setting up the command */
+  data->TransformCommand.StructSize = sizeof (MME_Command_t);
+  data->TransformCommand.CmdCode    = MME_TRANSFORM;
+  data->TransformCommand.CmdEnd     = MME_COMMAND_END_RETURN_NOTIFY;
+  data->TransformCommand.DueTime    = (MME_Time_t) 0;
+  data->TransformCommand.NumberInputBuffers  = 0;
+  data->TransformCommand.NumberOutputBuffers = 1;
+  data->TransformCommand.ParamSize  = params_size;
+  data->TransformCommand.Param_p    = params;
+
+  data->TransformCommand.DataBuffers_p[0]->ScatterPages_p[0].Size
+    = data->TransformCommand.DataBuffers_p[0]->TotalSize;
+  data->TransformCommand.DataBuffers_p[0]->ScatterPages_p[0].BytesUsed = 0;
+  data->TransformCommand.DataBuffers_p[0]->ScatterPages_p[0].FlagsIn = 0;
+  data->TransformCommand.DataBuffers_p[0]->ScatterPages_p[0].FlagsOut = 0;
+
+  return DFB_OK;
+
+out:
+  dfb_surface_unlock_buffer (dst_surface, lock);
+  return D_OOM ();
+}
+
+
+static DFBResult
+__attribute__((unused))
+mme_helper_start_transformer (struct _MMECommon     * const data,
+                              size_t                 return_params_size,
+                              void                  * const return_params,
+                              size_t                 params_size,
+                              void                  * const params,
+                              CoreSurface           * const dst_surface,
+                              CoreSurfaceBufferLock * const lock)
+{
+  DFBResult dfb_res;
+  MME_ERROR mme_res;
+
+  /* setup transform command */
+  dfb_res = _mme_helper_start_transformer_core (data,
+                                                return_params_size,
+                                                return_params,
+                                                params_size, params,
+                                                dst_surface, lock);
+  if (dfb_res != DFB_OK)
+    return dfb_res;
+
+  _imageprovider_update_transform_params (data, params, lock);
+
+  D_DEBUG_AT (MME_DEBUG_DOMAIN, "issuing MME_TRANSFORM\n");
+
+  /* lock access to hash, because otherwise the callback could be called
+     before we've had a chance to put the command id into the hash */
+  D_ASSERT (data->pending_commands != NULL);
+  pthread_mutex_lock (&data->pending_commands_lock);
+
+  mme_res = MME_SendCommand (data->Handle, &data->TransformCommand);
+  if (mme_res != MME_SUCCESS)
+    {
+      pthread_mutex_unlock (&data->pending_commands_lock);
+
+      D_WARN ("(%5d) %s: starting transformer failed: %d (%s)",
+              direct_gettid (), data->name, mme_res,
+              get_mme_error_string (mme_res));
+
+      dfb_surface_unlock_buffer (dst_surface, lock);
+
+      D_FREE (data->OutDataBuffers);
+      data->OutDataBuffers = NULL;
+
+      return DFB_FAILURE;
+    }
+
+  direct_hash_insert (data->pending_commands,
+                      data->TransformCommand.CmdStatus.CmdId,
+                      (void *) 1);
+  D_DEBUG_AT (MME_DEBUG_DOMAIN, "sent packet's CmdId is %u (%.8x)\n",
+              data->TransformCommand.CmdStatus.CmdId,
+              data->TransformCommand.CmdStatus.CmdId);
+
+  deb_gettimeofday (&data->starttime, NULL);
+
+  pthread_mutex_unlock (&data->pending_commands_lock);
+
+  return DFB_OK;
+}
+
+
+static DFBResult
+_alloc_send_buffer (MME_TransformerHandle_t   handle,
+                    size_t                    size,
+                    struct _MMEHelper_buffer * const buffer)
+{
+  MME_ERROR res;
+  size_t    this_size = MIN (size, MME_STREAMING_BUFFERSIZE);
+
+  D_ASSERT (buffer != NULL);
+  D_ASSUME (size != 0);
+  D_ASSERT (buffer->buffer == NULL);
+
+  D_DEBUG_AT (MME_DEBUG_DOMAIN, "    -> allocating MME buffer for %u bytes\n",
+              this_size);
+
+  res = MME_AllocDataBuffer (handle, this_size, MME_ALLOCATION_PHYSICAL,
+                             &buffer->buffer);
+  if (unlikely (res))
+    {
+      D_WARN ("(%5d) MME_AllocDataBuffer() for %u bytes failed: %s",
+              direct_gettid (), this_size, get_mme_error_string (res));
+
+      return DFB_NOSYSTEMMEMORY;
+    }
+
+  buffer->command.StructSize = sizeof (MME_Command_t);
+  buffer->command.CmdCode = MME_SEND_BUFFERS;
+  buffer->command.CmdEnd  = MME_COMMAND_END_RETURN_NOTIFY;
+  buffer->command.DueTime = (MME_Time_t) 0;
+  buffer->command.NumberInputBuffers  = 1;
+  buffer->command.NumberOutputBuffers = 0;
+  buffer->command.DataBuffers_p = &buffer->buffer;
+  buffer->command.ParamSize = 0;
+  buffer->command.Param_p   = NULL;
+
+  sema_init_event (&buffer->sema, 0);
+
+  D_DEBUG_AT (MME_DEBUG_DOMAIN, "      -> @ %p (%p)\n",
+              buffer, buffer->buffer);
+
+  return DFB_OK;
+}
+
+
+static void
+mme_helper_calculate_packets (struct _MMECommon * const data)
+{
+  D_ASSUME (data->bytes == 0);
+
+  /* FIXME: this is BAD (tm) -> think streaming media! */
+  data->base.buffer->SeekTo (data->base.buffer, 0);
+
+  /* find out the length of the buffer */
+  data->base.buffer->GetLength (data->base.buffer, &data->bytes);
+
+  data->packets = data->bytes / MME_STREAMING_BUFFERSIZE;
+  if ((data->packets * MME_STREAMING_BUFFERSIZE) < data->bytes)
+    ++data->packets;
+
+  D_DEBUG_AT (MME_DEBUG_DOMAIN,
+              "calculated transfer: %u bytes (%u packets, %u bytes each)\n",
+              data->bytes, data->packets, MME_STREAMING_BUFFERSIZE);
+}
+
+static DFBResult
+__attribute__((unused))
+mme_helper_send_packets (struct _MMECommon * const data,
+                         unsigned int       n_packets)
+{
+  unsigned int orig_packets;
+  unsigned int currentbuffer = currentbuffer;
+
+  D_ASSUME (n_packets != 0);
+
+  if (!data->packets && !data->bytes)
+    return DFB_OK;
+
+  D_ASSUME (data->packets != 0);
+  D_ASSUME (data->bytes != 0);
+
+  DFBResult res = DFB_OK;
+  MME_ERROR mme_res;
+
+  orig_packets = n_packets = MIN (n_packets, data->packets);
+  D_DEBUG_AT (MME_DEBUG_DOMAIN, "Sending %u buffers (out of %u remaining)\n",
+              n_packets, data->packets);
+
+//#define MME_OOM
+//#define MME_IOERR
+//#define MME_SENDFAIL
+//#define MME_DATA_CORRUPTION
+#if defined(MME_OOM) || defined(MME_IOERR) || defined(MME_SENDFAIL) || defined(MME_DATA_CORRUPTION)
+int i = 0;
+#endif
+  for (; n_packets && data->packets; --data->packets, --n_packets)
+    {
+      struct _MMEHelper_buffer *buffer;
+      unsigned int this_read = MIN (data->bytes, MME_STREAMING_BUFFERSIZE);
+
+      ++currentbuffer;
+      currentbuffer %= MAX_STREAMING_COMMANDS;
+
+      buffer = &data->SendDataBuffers[currentbuffer];
+
+      /* some checking - We've waited ... should we continue ... */
+      if (data->decode_success == -1)
+        {
+          D_WARN ("(%5d) ImageProvider/%s: error sending data. Transform "
+                  "error reported from callback",
+                  direct_gettid (), data->name);
+          return DFB_FAILURE;
+        }
+
+      /* if we are allocating a new buffer, we don't have to wait on the
+         semaphore, as the new buffer will not yet be known to mme, and thus
+         not in use, of course */
+      if (!buffer->buffer)
+        {
+#ifdef MME_OOM
+if (++i == 4)
+  {
+    fprintf (stderr, "emulating MME_AllocDataBuffer() failure (MME OOM)\n");
+    res = DFB_NOSYSTEMMEMORY;
+  }
+else
+#endif
+          res = _alloc_send_buffer (data->Handle, this_read, buffer);
+          if (res != DFB_OK)
+            return res;
+        }
+      else
+        {
+          /* wait for some buffer to be available */
+          if (unlikely (sema_trywait (&buffer->sema) == -1))
+            {
+              ++data->packets;
+              ++n_packets;
+              usleep (1);
+              continue;
+            }
+        }
+
+      D_DEBUG_AT (MME_DEBUG_DOMAIN, "  -> sending packet %u, using buffer %u @ %p (%p)\n",
+                  orig_packets - n_packets, currentbuffer, buffer,
+                  buffer->buffer);
+      D_DEBUG_AT (MME_DEBUG_DOMAIN, "  -> %u bytes remaining (this read: %u)\n",
+                  data->bytes, this_read);
+
+      /* lock access to hash, because otherwise the callback could be called
+         before we've had a chance to put the command id into the hash */
+      /* it also locks acces to data->buffer, because otherwise the callback
+         might determine we ran out of data if called between fetch_data()
+         and actually sending the MME_SendCommand() below. */
+      D_ASSERT (data->pending_commands != NULL);
+      pthread_mutex_lock (&data->pending_commands_lock);
+
+      /* don't move the abort out of the pending_commands lock! The JPEG
+         transformer might deadlock otherwise */
+      if (data->decode_success == 1)
+        {
+          /* corrupt data -> file can be bigger than actual JPEG data */
+          pthread_mutex_unlock (&data->pending_commands_lock);
+          return DFB_OK;
+        }
+
+#ifdef MME_IOERR
+if (++i == 8)
+  {
+    fprintf (stderr, "emulating IO (read) error\n");
+    res = DFB_FAILURE;
+    usleep (1 * 1000 * 1000);
+  }
+else
+#endif
+      res = fetch_data (data->base.buffer, buffer->buffer, this_read);
+      if (res != DFB_OK)
+        {
+          pthread_mutex_unlock (&data->pending_commands_lock);
+
+          D_WARN ("(%5d) Fetching %u bytes of data failed: res: %d",
+                  direct_gettid (), this_read, res);
+          sema_signal_event (&buffer->sema);
+          /* hm, DirectFB (always?) returns DFB_FAILURE here... */
+          return DFB_IO;
+        }
+#ifdef MME_DATA_CORRUPTION
+if (++i == 2)
+  {
+    fprintf (stderr, "emulating data corruption\n");
+    memset (&buffer->buffer->ScatterPages_p[0].Page_p[15], 0x15, 10);
+  }
+#endif
+
+      /* we just read data, nobody should have determined that we ran into
+         an EOF! */
+      D_ASSERT (data->decode_success != -2);
+
+      data->bytes -= this_read;
+
+      D_DEBUG_AT (MME_DEBUG_DOMAIN, "  -> sending command in buffer %u\n",
+                  currentbuffer);
+
+      /* send the command */
+#ifdef MME_SENDFAIL
+if (++i == 4)
+  {
+    fprintf (stderr, "emulating MME_SendCommand() failure\n");
+    mme_res = MME_NOMEM;
+  }
+else
+#endif
+      mme_res = MME_SendCommand (data->Handle, &buffer->command);
+      if (mme_res != MME_SUCCESS)
+        {
+          pthread_mutex_unlock (&data->pending_commands_lock);
+
+          D_WARN ("(%5d) send DataCommand failed: %s",
+                  direct_gettid (), get_mme_error_string (mme_res));
+          res = DFB_FAILURE;
+          return DFB_FAILURE;
+        }
+
+      res = DFB_OK;
+
+      direct_hash_insert (data->pending_commands,
+                          buffer->command.CmdStatus.CmdId, (void *) 1);
+      ++data->n_pending_buffers;
+      D_DEBUG_AT (MME_DEBUG_DOMAIN, "sent packet's CmdId is %u (%.8x), %u packets pending now\n",
+                  buffer->command.CmdStatus.CmdId,
+                  buffer->command.CmdStatus.CmdId,
+                  data->n_pending_buffers);
+      pthread_mutex_unlock (&data->pending_commands_lock);
+    }
+
+  D_DEBUG_AT (MME_DEBUG_DOMAIN, "done sending packets (%u remaining)\n",
+              data->packets);
+
+  return res;
+}
+
+
+static DFBResult
+__attribute__((unused))
+mme_helper_stretch_blit (struct _MMECommon * const data,
+                         CoreSurface       * const src,
+                         CoreSurface       * const dst,
+                         DFBRectangle      * const dst_rect)
+{
+  CardState    state;
+  DFBRectangle src_rect;
+
+  dfb_state_init (&state, data->base.core);
+
+  /* set clipping and sizes */
+  state.clip.x1 = 0;
+  state.clip.y1 = 0;
+  state.clip.x2 = dst_rect->w - 1;
+  state.clip.y2 = dst_rect->h - 1;
+
+  state.modified |= SMF_CLIP;
+
+  src_rect.x = 0;
+  src_rect.y = 0;
+  src_rect.w = data->width;
+  src_rect.h = data->height;
+
+  dfb_state_set_source (&state, src);
+  dfb_state_set_destination (&state, dst);
+
+  extern const char *dfb_pixelformat_name( DFBSurfacePixelFormat format );
+  D_DEBUG_AT (MME_DEBUG_DOMAIN, "StretchBlit %dx%d (%dx%d) -> %dx%d (%s -> %s)\n",
+              data->width, data->height, src_rect.w, src_rect.h,
+              dst_rect->w, dst_rect->h,
+              dfb_pixelformat_name (src->config.format),
+              dfb_pixelformat_name (dst->config.format));
+
+  /* thankfully this is intelligent enough to do a simple blit if possible */
+  dfb_gfxcard_stretchblit (&src_rect, dst_rect, &state);
+  data->serial = state.serial;
+
+  /* remove the state */
+  dfb_state_set_source (&state, NULL);
+  dfb_state_set_destination (&state, NULL);
+  dfb_state_destroy (&state);
+
+  return DFB_OK;
+}
+#endif /* USE_MME */
+
+
+#endif /* __MME_HELPER_H__ */
diff -Naur DirectFB-1.7.7/interfaces/IDirectFBImageProvider/sema_helper.h DirectFB-1.7.7.stm/interfaces/IDirectFBImageProvider/sema_helper.h
--- DirectFB-1.7.7/interfaces/IDirectFBImageProvider/sema_helper.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7.stm/interfaces/IDirectFBImageProvider/sema_helper.h	2015-05-15 18:43:40.117435076 +0200
@@ -0,0 +1,61 @@
+#ifndef __SEMA_HELPER_H__
+#define __SEMA_HELPER_H__
+
+#include <semaphore.h>
+
+
+static inline unsigned int
+__attribute__((warn_unused_result))
+sema_get_event_val (sem_t * const sema)
+{
+  int semval;
+
+  sem_getvalue (sema, &semval);
+
+  return semval;
+}
+
+static inline int
+__attribute__((warn_unused_result))
+sema_wait_event (sem_t * const sema)
+{
+  D_DEBUG_AT (SEMA_DEBUG_DOMAIN, "waiting on %p (val: %u)\n", sema, sema_get_event_val (sema));
+
+  return sem_wait (sema);
+}
+
+static inline int
+__attribute__((warn_unused_result))
+sema_trywait (sem_t * const sema)
+{
+  D_DEBUG_AT (SEMA_DEBUG_DOMAIN, "trywait on %p (val: %u)\n", sema, sema_get_event_val (sema));
+
+  return sem_trywait (sema);
+}
+
+static inline void
+sema_signal_event (sem_t * const sema)
+{
+  D_DEBUG_AT (SEMA_DEBUG_DOMAIN, "signalling %p (val: %u)\n", sema, sema_get_event_val (sema));
+
+  sem_post (sema);
+}
+
+static inline void
+sema_init_event (sem_t        * const sema,
+                 unsigned int  val)
+{
+  D_DEBUG_AT (SEMA_DEBUG_DOMAIN, "init'ing sema %p to %u\n", sema, val);
+
+  sem_init (sema, 0, val);
+}
+
+static inline void
+sema_close_event (sem_t * const sema)
+{
+  D_DEBUG_AT (SEMA_DEBUG_DOMAIN, "destroying sema %p\n", sema);
+
+  sem_destroy (sema);
+}
+
+#endif /* __SEMA_HELPER_H__ */
diff -Naur DirectFB-1.7.7/interfaces/IDirectFBVideoProvider/idirectfbvideoprovider_gif.c DirectFB-1.7.7.stm/interfaces/IDirectFBVideoProvider/idirectfbvideoprovider_gif.c
--- DirectFB-1.7.7/interfaces/IDirectFBVideoProvider/idirectfbvideoprovider_gif.c	2013-12-19 01:16:24.000000000 +0100
+++ DirectFB-1.7.7.stm/interfaces/IDirectFBVideoProvider/idirectfbvideoprovider_gif.c	2015-05-15 18:43:40.125443076 +0200
@@ -36,7 +36,9 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <stdarg.h>
 #include <sys/time.h>
+#include <assert.h>
 
 #include <pthread.h>
 
@@ -64,7 +66,7 @@
 static DFBResult Probe( IDirectFBVideoProvider_ProbeContext *ctx );
 
 static DFBResult Construct( IDirectFBVideoProvider *thiz,
-                            IDirectFBDataBuffer    *buffer );
+                            ... );
 
 
 #include <direct/interface_implementation.h>
@@ -97,19 +99,28 @@
      IDirectFBSurface              *destination;
      IDirectFBSurface_data         *dst_data;
      DFBRectangle                   dst_rect;
-     
-     u32                           *image;
-     
+
+     DFBColor                       palette[MAXCOLORMAPSIZE];
+
+     CoreSurface                   *decode_surface;
+     CoreSurfaceBufferLock          buffer_lock;
+
      DirectThread                  *thread;
      pthread_mutex_t                lock;
      pthread_cond_t                 cond;
      
+     int                            paused;
+
      DFBVideoProviderStatus         status;
      DFBVideoProviderPlaybackFlags  flags;
      double                         speed;
      
      unsigned int                   start_pos;
 
+     unsigned int                   frame;
+     unsigned int                   target_frame; /* only in DVPLAY_PACED */
+     unsigned int                   last_frame; /* only in DVPLAY_PACED */
+
      char                           Version[4];
      unsigned int                   Width;
      unsigned int                   Height;
@@ -137,6 +148,8 @@
 
      DVFrameCallback                callback;
      void                          *callback_ctx;
+
+     CoreDFB                       *core;
 } IDirectFBVideoProvider_GIF_data;
 
 #define GIFERRORMSG(x, ...) \
@@ -171,7 +184,7 @@
 }
 
 static int ReadColorMap( IDirectFBDataBuffer *buffer, int number,
-                         u8 buf[3][MAXCOLORMAPSIZE] )
+                         DFBColor palette[MAXCOLORMAPSIZE] )
 {
      int  i;
      u8   rgb[3*number];
@@ -182,9 +195,10 @@
      }
 
      for (i = 0; i < number; ++i) {
-          buf[CM_RED][i]   = rgb[i*3+0];
-          buf[CM_GREEN][i] = rgb[i*3+1];
-          buf[CM_BLUE][i]  = rgb[i*3+2];
+          palette[i].r = rgb[i*3+0];
+          palette[i].g = rgb[i*3+1];
+          palette[i].b = rgb[i*3+2];
+          palette[i].a = 0xff;
      }
      
      return 0;
@@ -407,12 +421,13 @@
 
 static int ReadImage( IDirectFBVideoProvider_GIF_data *data, 
                       int left, int top, int width, int height,
-                      u8 cmap[3][MAXCOLORMAPSIZE], bool interlace, bool ignore )
+                      int pitch, DFBColor palette[MAXCOLORMAPSIZE],
+                      bool interlace, bool ignore )
 {
      u8   c;
      int  v;
      int  xpos = 0, ypos = 0, pass = 0;
-     u32 *image, *dst;
+     u32 *image = image, *dst = dst;
 
      /*
      **  Initialize the decompression routines
@@ -426,7 +441,7 @@
      /*
      **  If this is an "uninteresting picture" ignore it.
      */
-     if (ignore) {
+     if (ignore && !data->disposal) {
           GIFDEBUGMSG("skipping image...");
 
           while (LWZReadByte( data, false, c ) >= 0)
@@ -436,8 +451,7 @@
      
      switch (data->disposal) {
           case 2:
-               GIFDEBUGMSG("restoring to background color...");
-               memset( data->image, 0, data->Width * data->Height * 4 );
+               GIFDEBUGMSG("restoring to background color is unsupported");
                break;
           case 3:
                GIFERRORMSG("restoring to previous frame is unsupported");
@@ -446,17 +460,18 @@
                break;
      }
      
-     dst = image = data->image + (top * data->Width + left);
+     dst = image = ((u32 *)(data->buffer_lock.addr)
+                    + (top * (pitch / 4) + left));
 
      GIFDEBUGMSG("reading %dx%d at %dx%d %sGIF image",
                  width, height, left, top, interlace ? " interlaced " : "" );
 
      while ((v = LWZReadByte( data, false, c )) >= 0 ) {
           if (v != data->transparent) {
-               dst[xpos] = (0xFF000000              |
-                            cmap[CM_RED][v]   << 16 |
-                            cmap[CM_GREEN][v] << 8  |
-                            cmap[CM_BLUE][v]);
+               dst[xpos] = (0xFF000000         |
+                            palette[v].r << 16 |
+                            palette[v].g << 8  |
+                            palette[v].b);
           }
 
           ++xpos;
@@ -496,8 +511,10 @@
                else {
                     ++ypos;
                }
-               dst = image + ypos * data->Width;
-          } 
+
+               dst = image + ypos * (pitch >> 2);
+          }
+
           if (ypos >= height) {
                break;
           }
@@ -519,9 +536,6 @@
      data->delayTime   = 1000000; /* default: 1s */
      data->inputFlag   = -1;
      data->disposal    = 0;
-     
-     if (data->image)
-          memset( data->image, 0, data->Width*data->Height*4 );
 }
 
 static DFBResult GIFReadHeader( IDirectFBVideoProvider_GIF_data *data )
@@ -561,7 +575,7 @@
           data->AspectRatio = (data->Width << 8) / data->Height;
 
      if (BitSet(buf[4], LOCALCOLORMAP)) {    /* Global Colormap */
-          if (ReadColorMap( data->buffer, data->BitPixel, data->ColorMap )) {
+          if (ReadColorMap( data->buffer, data->BitPixel, data->palette )) {
                GIFERRORMSG("error reading global colormap");
                return DFB_FAILURE;
           }
@@ -575,8 +589,10 @@
      u8    buf[16], c;
      int   top, left;
      int   width, height;
-     u8    localColorMap[3][MAXCOLORMAPSIZE];
+     DFBColor  local_palette[MAXCOLORMAPSIZE];
      bool  useGlobalColormap;
+     int   ignore = 0;
+     int   num_frames = 0;
 
      data->curbit = data->lastbit = data->done = data->last_byte = 0;
 
@@ -586,21 +602,41 @@
      data->firstcode = data->oldcode =
      data->clear_code = data->end_code = 0;
 
-     for (;;) {
+     dfb_surface_lock_buffer( data->decode_surface,
+                              CSBR_BACK, CSAID_CPU, CSAF_WRITE,
+                              &data->buffer_lock );
+
+     if (data->flags & DVPLAY_PACED
+         && data->target_frame != -1) {
+          ignore = data->target_frame != (data->frame + 1);
+          num_frames = data->target_frame - data->frame - 1;
+     }
+
+     if (!data->frame)
+          num_frames++;
+
+     for (; num_frames >= 0;) {
           DFBResult ret;
           
           ret = FetchData( data->buffer, &c, 1);
           if (ret) {
                GIFERRORMSG("EOF / read error on image data" );
+               dfb_surface_unlock_buffer( data->decode_surface,
+                                          &data->buffer_lock );
                return DFB_EOF;
           }
 
-          if (c == ';') /* GIF terminator */
+          if (c == ';') { /* GIF terminator */
+               dfb_surface_unlock_buffer( data->decode_surface,
+                                          &data->buffer_lock );
                return DFB_EOF;
+          }
 
           if (c == '!') { /* Extension */
                if (FetchData( data->buffer, &c, 1)) {
                     GIFERRORMSG("EOF / read error on extention function code");
+                    dfb_surface_unlock_buffer( data->decode_surface,
+                                               &data->buffer_lock );
                     return DFB_EOF;
                }
                DoExtension( data, c );
@@ -615,6 +651,8 @@
           ret = FetchData( data->buffer, buf, 9 );
           if (ret) {
                GIFERRORMSG("couldn't read left/top/width/height");
+               dfb_surface_unlock_buffer( data->decode_surface,
+                                          &data->buffer_lock );
                return ret;
           }
                
@@ -627,21 +665,28 @@
 
           if (!useGlobalColormap) {
                int bitPixel = 2 << (buf[8] & 0x07);
-               if (ReadColorMap( data->buffer, bitPixel, localColorMap ))
+               if (ReadColorMap( data->buffer, bitPixel, local_palette ))
                     GIFERRORMSG("error reading local colormap");
           }
 
+          data->frame++;
+          num_frames--;
+
+
           if (ReadImage( data, left, top, width, height,
-                        (useGlobalColormap ?
-                         data->ColorMap : localColorMap),
-                         BitSet( buf[8], INTERLACE ), 0 )) {
+                         data->buffer_lock.pitch,
+                         (useGlobalColormap ?
+                         data->palette : local_palette),
+                         BitSet( buf[8], INTERLACE ), ignore )) {
                GIFERRORMSG("error reading image");
+               dfb_surface_unlock_buffer( data->decode_surface,
+                                          &data->buffer_lock );
                return DFB_FAILURE;
           }
-          
-          break;
      }
      
+     dfb_surface_unlock_buffer( data->decode_surface, &data->buffer_lock );
+
      return DFB_OK;
 }
 
@@ -653,13 +698,31 @@
      IDirectFBVideoProvider_GIF_data *data = thiz->priv;
      
      thiz->Stop( thiz );
-     
-     if (data->image)
-          D_FREE( data->image );
-     
+    
+     if (data->thread) {
+          direct_thread_cancel( data->thread );
+          pthread_mutex_lock( &data->lock );
+          pthread_cond_signal( &data->cond );
+          pthread_mutex_unlock( &data->lock );
+          direct_thread_join( data->thread );
+          direct_thread_destroy( data->thread );
+          data->thread = NULL;
+     }
+
      if (data->buffer)
           data->buffer->Release( data->buffer );
-    
+
+     if (data->destination) {
+          data->destination->Release( data->destination );
+          data->destination = NULL;
+          data->dst_data    = NULL;
+     }
+
+     if (data->decode_surface) {
+          dfb_surface_unref( data->decode_surface );
+          data->decode_surface = NULL;
+     }
+
      pthread_cond_destroy( &data->cond );
      pthread_mutex_destroy( &data->lock );
           
@@ -709,12 +772,11 @@
      
      if (!desc)
           return DFB_INVARG;
-          
-     desc->flags       = DSDESC_WIDTH | DSDESC_HEIGHT | DSDESC_PIXELFORMAT;
-     desc->width       = data->Width;
-     desc->height      = data->Height;
-     desc->pixelformat = DSPF_ARGB;
      
+     desc->width = data->Width;
+     desc->height = data->Height;
+     desc->pixelformat = DSPF_ARGB;
+
      return DFB_OK;
 }
 
@@ -742,19 +804,58 @@
      return DFB_OK;
 }
 
+static void
+clear_decode_surface(IDirectFBVideoProvider_GIF_data *data)
+{
+     CardState     state;
+     DFBRectangle  rect = { .x = 0,
+                            .y = 0,
+                            .w = data->Width,
+                            .h = data->Height };
+
+     DFBColor      color = { .r = 0,
+                             .g = 0,
+                             .b = 0,
+                             .a = 0 };
+
+     DFBRegion     clip  = { .x1 = 0,
+                             .y1 = 0,
+                             .x2 = data->Width - 1,
+                             .y2 = data->Height - 1 };
+
+     /* init a fillrect state */
+     dfb_state_init( &state, data->core );
+     dfb_state_set_color( &state, &color );
+     dfb_state_set_source( &state, NULL );
+     dfb_state_set_destination( &state, data->decode_surface );
+     dfb_state_set_clip( &state, &clip );
+
+     dfb_gfxcard_fillrectangles( &rect, 1, &state );
+
+     /* wait for the h/w to complete */
+     dfb_gfxcard_wait_serial( &state.serial );
+
+     /* remove the state */
+     dfb_state_set_source( &state, NULL );
+     dfb_state_set_destination( &state, NULL );
+     dfb_state_destroy( &state );
+}
+
 static void*
 GIFVideo( DirectThread *self, void *arg )
 {
      IDirectFBVideoProvider_GIF_data *data = arg;
      
      pthread_setcancelstate( PTHREAD_CANCEL_DISABLE, NULL );
-     
+
+     data->frame = 0;
+
+     clear_decode_surface( data );
+
      while (!direct_thread_is_canceled( self )) {
           DFBResult              ret;
           DFBRectangle           rect;
           DFBRegion              clip;
-          CoreSurface           *surface;
-          CoreSurfaceBufferLock  lock;
           
           pthread_mutex_lock( &data->lock );
           
@@ -763,10 +864,36 @@
                break;
           }
           
+          /* check if the requested frame doesn't exist */
+          if (data->flags & DVPLAY_PACED
+              && data->last_frame
+              && data->target_frame > data->last_frame) {
+               /* notify the caller */
+               data->target_frame = -1;
+               data->callback( data->callback_ctx );
+               /* wait for the next call */
+               data->status = DVSTATE_STOP;
+               pthread_cond_wait( &data->cond, &data->lock );
+               pthread_mutex_unlock( &data->lock );
+               continue;
+          }
+
+          /* restart decoding if the newly requested frame precedes or is
+             the last decoded one when in DVPLAY_PACED mode */
+          if (data->flags & DVPLAY_PACED
+              && data->target_frame != -1
+              && data->target_frame < data->frame) {
+               GIFReset( data );
+               data->frame = 0;
+               data->buffer->SeekTo( data->buffer, data->start_pos );
+          }
+
           ret = GIFReadFrame( data );
           if (ret) { 
                if (ret == DFB_EOF) {
+                    data->last_frame = data->frame;
                     GIFReset( data );
+                    data->frame = 0;
                     if (data->flags & DVPLAY_LOOPING) {
                          data->buffer->SeekTo( data->buffer, data->start_pos );
                     }
@@ -776,6 +903,15 @@
                          break;
                     }
                }
+               /* bail out if stream is invalid */
+               if (data->flags & DVPLAY_PACED) {
+                    /* notify the caller */
+                    data->target_frame = -1; /* error */
+                    data->callback( data->callback_ctx );
+                    /* wait for the next call */
+                    data->status = DVSTATE_STOP;
+                    pthread_cond_wait( &data->cond, &data->lock );
+               }
                pthread_mutex_unlock( &data->lock );
                continue;
           }
@@ -784,41 +920,58 @@
                  ? data->dst_data->area.wanted : data->dst_rect;          
           dfb_region_from_rectangle( &clip, &data->dst_data->area.current );
           
-          surface = data->dst_data->surface;
-          D_MAGIC_ASSERT( surface, CoreSurface );
+          CardState     state;
+          CoreSurface  *dst_surface;
+          DFBRectangle  srect = { .x = 0,
+                                  .y = 0,
+                                  .w = data->Width,
+                                  .h = data->Height, };
+
+          dst_surface = data->dst_data->surface;
+          D_MAGIC_ASSERT( dst_surface, CoreSurface );
+
+          /* init a state, so that we can use gfxcard/blit to do the
+             format conversion. */
+          dfb_state_init( &state, data->core );
+          dfb_state_set_source( &state, data->decode_surface );
+          dfb_state_set_destination( &state, dst_surface );
+          dfb_state_set_clip( &state, &clip );
+
+          dfb_gfxcard_stretchblit( &srect, &rect, &state );
+
+          /* remove the state */
+          dfb_state_set_source( &state, NULL );
+          dfb_state_set_destination( &state, NULL );
+          dfb_state_destroy( &state );
 
-          if (dfb_rectangle_region_intersects( &rect, &clip ) &&
-              dfb_surface_lock_buffer( surface, CSBR_BACK, CSAID_CPU, CSAF_WRITE, &lock ) == DFB_OK)
+          if (data->callback)
+               data->callback( data->callback_ctx );
+
+          if (!(data->flags & DVPLAY_PACED))
           {
-               dfb_scale_linear_32( data->image, data->Width, data->Height,
-                                    lock.addr, lock.pitch, &rect, data->dst_data->surface, &clip );
-                                    
-               dfb_surface_unlock_buffer( surface, &lock );
-               
-               if (data->callback)
-                    data->callback( data->callback_ctx );
-          }
+               if (!data->speed)
+                    pthread_cond_wait( &data->cond, &data->lock );
+               else {
+                    struct timespec ts;
+                    struct timeval  tv;
+                    unsigned long   us;
+
+                    gettimeofday( &tv, NULL );
 
-          if (!data->speed) {
+                    us = data->delayTime;
+                    if (data->speed != 1.0)
+                         us = ((double)us / data->speed + .5);
+                    us += tv.tv_usec;
+
+                    ts.tv_sec  = tv.tv_sec + us/1000000;
+                    ts.tv_nsec = (us%1000000) * 1000;
+
+                    pthread_cond_timedwait( &data->cond, &data->lock, &ts );
+               }
+          } else {
+               data->status = DVSTATE_STOP;
                pthread_cond_wait( &data->cond, &data->lock );
           }
-          else {
-               struct timespec ts;
-               struct timeval  tv;
-               unsigned long   us;
-               
-               gettimeofday( &tv, NULL );
-                    
-               us = data->delayTime;
-               if (data->speed != 1.0)
-                    us = ((double)us / data->speed + .5);
-               us += tv.tv_usec;                 
-                    
-               ts.tv_sec  = tv.tv_sec + us/1000000;
-               ts.tv_nsec = (us%1000000) * 1000;
-                    
-               pthread_cond_timedwait( &data->cond, &data->lock, &ts );
-          }
           
           pthread_mutex_unlock( &data->lock );
      }
@@ -836,7 +989,10 @@
      IDirectFBSurface_data *dst_data;
      DFBRectangle           rect = { 0, 0, 0, 0 };
      DFBResult              ret;
-     
+
+     DFBVideoProviderPacedPlaybackCtx *Ctx =
+               (DFBVideoProviderPacedPlaybackCtx *)ctx;
+
      DIRECT_INTERFACE_GET_DATA( IDirectFBVideoProvider_GIF )
      
      if (!destination)
@@ -845,7 +1001,7 @@
      dst_data = destination->priv;
      if (!dst_data || !dst_data->surface)
           return DFB_DESTROYED;
-          
+
      if (dest_rect) {
           if (dest_rect->w < 1 || dest_rect->h < 1)
                return DFB_INVARG;
@@ -855,6 +1011,11 @@
           rect.y += dst_data->area.wanted.y;
      }          
      
+     if (data->flags & DVPLAY_PACED) {
+          if (!Ctx || !callback)
+               return DFB_INVARG;
+     }
+
      pthread_mutex_lock( &data->lock );
      
      if (data->status == DVSTATE_FINISHED) {
@@ -866,14 +1027,6 @@
      }
      data->status = DVSTATE_PLAY;
      
-     if (!data->image) {          
-          data->image = D_CALLOC( 4, data->Width * data->Height );
-          if (!data->image) {
-               pthread_mutex_unlock( &data->lock );
-               return D_OOM();
-          }
-     }
-     
      if (data->destination)
           data->destination->Release( data->destination );
      
@@ -881,10 +1034,32 @@
      data->destination = destination;
      data->dst_data    = dst_data;
      data->dst_rect    = rect;
-     
+
      data->callback     = callback;
      data->callback_ctx = ctx;
+     if (data->flags & DVPLAY_PACED)
+          data->target_frame = Ctx->num_frame;
      
+     if (!data->decode_surface) {
+          ret = dfb_surface_create_simple( data->core,
+                                           data->Width, data->Height,
+                                           DSPF_ARGB, DSCS_RGB,
+                                           DSCAPS_NONE, CSTF_NONE, 0,
+                                           NULL, &data->decode_surface );
+          if (ret != DFB_OK) {
+               pthread_mutex_unlock( &data->lock );
+               return ret;
+          }
+     }
+
+     /* Playback has already been started by a previous call to PlayTo() */
+     if (data->thread && (data->flags & DVPLAY_PACED)) {
+          data->paused = 0;
+          pthread_cond_signal( &data->cond );
+          pthread_mutex_unlock( &data->lock );
+          return DFB_OK;
+     }
+
      if (!data->thread) {
           data->thread = direct_thread_create( DTT_DEFAULT, GIFVideo,
                                               (void*)data, "GIF Video" );
@@ -899,25 +1074,33 @@
 IDirectFBVideoProvider_GIF_Stop( IDirectFBVideoProvider *thiz )
 {
      DIRECT_INTERFACE_GET_DATA( IDirectFBVideoProvider_GIF )
-     
-     if (data->thread) {
-          direct_thread_cancel( data->thread );
-          pthread_mutex_lock( &data->lock );
-          pthread_cond_signal( &data->cond );
-          pthread_mutex_unlock( &data->lock );
-          direct_thread_join( data->thread );
-          direct_thread_destroy( data->thread );
-          data->thread = NULL;
-     }
-     
-     if (data->destination) {
-          data->destination->Release( data->destination );
-          data->destination = NULL;
-          data->dst_data    = NULL;
+
+     if (data->flags & DVPLAY_PACED) {
+        /* sync with the decoding thread */
+        pthread_mutex_lock( &data->lock );
+        assert( data->status == DVSTATE_STOP );
+        pthread_mutex_unlock( &data->lock );
+        return DFB_OK;
+     } else {
+          if (data->thread) {
+               direct_thread_cancel( data->thread );
+               pthread_mutex_lock( &data->lock );
+               pthread_cond_signal( &data->cond );
+               pthread_mutex_unlock( &data->lock );
+               direct_thread_join( data->thread );
+               direct_thread_destroy( data->thread );
+               data->thread = NULL;
+          }
+
+          if (data->destination) {
+               data->destination->Release( data->destination );
+               data->destination = NULL;
+               data->dst_data = NULL;
+          }
+
+          data->status = DVSTATE_STOP;
      }
      
-     data->status = DVSTATE_STOP;
-     
      return DFB_OK;
 }
 
@@ -981,11 +1164,14 @@
 {
      DIRECT_INTERFACE_GET_DATA( IDirectFBVideoProvider_GIF )
      
-     if (flags & ~DVPLAY_LOOPING)
+     if (flags & ~(DVPLAY_LOOPING | DVPLAY_PACED))
           return DFB_UNSUPPORTED;
           
      if (flags & DVPLAY_LOOPING && !data->seekable)
           return DFB_UNSUPPORTED;
+
+     if (flags & DVPLAY_PACED)
+          data->target_frame = -1;
           
      data->flags = flags;
      
@@ -1037,12 +1223,22 @@
 
 static DFBResult
 Construct( IDirectFBVideoProvider *thiz,
-           IDirectFBDataBuffer    *buffer )
+           ... )
 {
      DFBResult ret;
 
+     IDirectFBDataBuffer *buffer;
+     CoreDFB             *core;
+     va_list              tag;
+
      DIRECT_ALLOCATE_INTERFACE_DATA( thiz, IDirectFBVideoProvider_GIF )
 
+     va_start( tag, thiz );
+     buffer = va_arg( tag, IDirectFBDataBuffer * );
+     core = va_arg( tag, CoreDFB * );
+     va_end( tag );
+
+     data->core   = core;
      data->ref    = 1;
      data->status = DVSTATE_STOP;
      data->buffer = buffer;
@@ -1060,9 +1256,13 @@
      
      data->buffer->GetPosition( data->buffer, &data->start_pos );
      
-     direct_util_recursive_pthread_mutex_init( &data->lock );
+     pthread_mutex_init( &data->lock, NULL );
      pthread_cond_init( &data->cond, NULL );
      
+     data->paused = 0;
+     data->decode_surface = NULL;
+     data->last_frame = 0;
+
      thiz->AddRef                = IDirectFBVideoProvider_GIF_AddRef;
      thiz->Release               = IDirectFBVideoProvider_GIF_Release;
      thiz->GetCapabilities       = IDirectFBVideoProvider_GIF_GetCapabilities;
diff -Naur DirectFB-1.7.7/lib/fusion/fusion.c DirectFB-1.7.7.stm/lib/fusion/fusion.c
--- DirectFB-1.7.7/lib/fusion/fusion.c	2015-02-01 20:36:12.000000000 +0100
+++ DirectFB-1.7.7.stm/lib/fusion/fusion.c	2015-05-15 18:43:40.129447076 +0200
@@ -509,6 +509,11 @@
 
 /**********************************************************************************************************************/
 
+#if defined(__SH4__)
+#  define shm_align_mask  (0x3fff)
+#else
+#  define shm_align_mask  (direct_pagesize()-1)
+#endif
 static DirectResult
 map_shared_root( void               *shm_base,
                  int                 world_index,
@@ -523,6 +528,7 @@
      int            flags = O_RDONLY;
      int            prot  = PROT_READ;
      unsigned long  size = direct_page_align(sizeof(FusionWorldShared));
+     size = (size + shm_align_mask) & ~shm_align_mask;
      unsigned long  base = (unsigned long) shm_base + (size + direct_pagesize()) * world_index;
 
      if (master || !fusion_config->secure_fusion) {
@@ -3216,6 +3222,159 @@
      return NULL;
 }
 
+DirectResult
+fusion_dispatch( FusionWorld *world,
+                 size_t       buf_size )
+{
+     ssize_t  len = 0;
+     char    *buf;
+     char    *buf_p;
+
+     struct sockaddr_un  addr;
+     socklen_t           addr_len = sizeof(addr);
+     fd_set              set;
+
+     int     result;
+     ssize_t msg_size;
+
+     D_DEBUG_AT( Fusion_Main_Dispatch, "%s( world %p, buf_size %zu )\n", __FUNCTION__, world, buf_size );
+
+     D_MAGIC_ASSERT( world, FusionWorld );
+
+     if (buf_size == 0)
+          buf_size = FUSION_MESSAGE_SIZE * 4;
+     else
+          D_ASSUME( buf_size >= FUSION_MESSAGE_SIZE );
+
+     buf = buf_p = malloc( buf_size );
+
+//     if (world->dispatch_stop) {
+//          D_DEBUG_AT( Fusion_Main_Dispatch, "  -> IGNORING (dispatch_stop!)\n" );
+//          return DR_SUSPENDED;
+//     }
+
+     D_DEBUG_AT( Fusion_Main_Dispatch, "  = = dispatch -> reading up to %zu bytes...\n", buf_size );
+
+     D_MAGIC_ASSERT( world, FusionWorld );
+
+     FD_ZERO( &set );
+     FD_SET( world->fusion_fd, &set );
+
+     while (true) {
+          result = select( world->fusion_fd + 1, &set, NULL, NULL, NULL );
+          if (result < 0) {
+               switch (errno) {
+                    case EINTR:
+                         continue;
+
+                    default:
+                         D_PERROR( "Fusion/Dispatcher: select() failed!\n" );
+                         return DR_IO;
+               }
+          } else
+               break;
+     }
+
+     D_MAGIC_ASSERT( world, FusionWorld );
+
+     if (world->dispatch_loop)
+          direct_thread_lock( world->dispatch_loop );
+
+     if (FD_ISSET( world->fusion_fd, &set ) &&
+         (msg_size = recvfrom( world->fusion_fd, buf, buf_size, 0, (struct sockaddr*)&addr, &addr_len )) > 0) {
+          FusionMessage *msg = (FusionMessage*)buf;
+
+          D_DEBUG_AT( Fusion_Main_Dispatch, "  = = dispatch -> got %zu bytes (of up to %zu)\n", msg_size, buf_size );
+
+          pthread_setcancelstate( PTHREAD_CANCEL_DISABLE, NULL );
+
+          D_DEBUG_AT( Fusion_Main_Dispatch, " -> message from '%s'...\n", addr.sun_path );
+
+          if (world->dispatch_stop) {
+               D_DEBUG_AT( Fusion_Main_Dispatch, "  -> IGNORING (dispatch_stop!)\n" );
+          }
+          else {
+               switch (msg->type) {
+                    case FMT_SEND:
+                         D_DEBUG_AT( Fusion_Main_Dispatch, "  -> FMT_SEND...\n" );
+                         break;
+
+                    case FMT_ENTER:
+                         D_DEBUG_AT( Fusion_Main_Dispatch, "  -> FMT_ENTER...\n" );
+                         if (!fusion_master( world )) {
+                              D_ERROR( "Fusion/Dispatch: Got ENTER request, but I'm not master!\n" );
+                              break;
+                         }
+                         if (msg->enter.fusion_id == world->fusion_id) {
+                              D_ERROR( "Fusion/Dispatch: Received ENTER request from myself!\n" );
+                              break;
+                         }
+                         /* Nothing to do here. Send back message. */
+                         _fusion_send_message( world->fusion_fd, msg, sizeof(FusionEnter), &addr );
+                         break;
+
+                    case FMT_LEAVE:
+                         D_DEBUG_AT( Fusion_Main_Dispatch, "  -> FMT_LEAVE...\n" );
+                         if (!fusion_master( world )) {
+                              D_ERROR( "Fusion/Dispatch: Got LEAVE request, but I'm not master!\n" );
+                              break;
+                         }
+                         if (world->fusion_id == FUSION_ID_MASTER) {
+                              direct_mutex_lock( &world->refs_lock );
+                              direct_map_iterate( world->refs_map, refs_iterate, &msg->leave.fusion_id );
+                              direct_mutex_unlock( &world->refs_lock );
+                         }
+                         if (msg->leave.fusion_id == world->fusion_id) {
+                              D_ERROR( "Fusion/Dispatch: Received LEAVE request from myself!\n" );
+                              break;
+                         }
+                         _fusion_remove_fusionee( world, msg->leave.fusion_id );
+                         break;
+
+                    case FMT_CALL:
+                         D_DEBUG_AT( Fusion_Main_Dispatch, "  -> FMT_CALL...\n" );
+
+                         if (((FusionCallMessage*)msg)->caller == 0)    // FIXME: currently caller is set to non-zero even for ref_watch
+                              handle_dispatch_cleanups( world );
+
+                         _fusion_call_process( world, msg->call.call_id, &msg->call,
+                                               (msg_size != sizeof(FusionCallMessage)) ? (((FusionCallMessage*)msg) + 1) : NULL );
+                         break;
+
+                    case FMT_REACTOR:
+                         D_DEBUG_AT( Fusion_Main_Dispatch, "  -> FMT_REACTOR...\n" );
+                         _fusion_reactor_process_message( world, msg->reactor.id, msg->reactor.channel,
+                                                          &buf[sizeof(FusionReactorMessage)] );
+                         if (msg->reactor.ref) {
+                              fusion_ref_down( msg->reactor.ref, true );
+                              if (fusion_ref_zero_trylock( msg->reactor.ref ) == DR_OK) {
+                                   fusion_ref_destroy( msg->reactor.ref );
+                                   SHFREE( world->shared->main_pool, msg->reactor.ref );
+                              }
+                         }
+                         break;
+
+                    default:
+                         D_BUG( "unexpected message type (%d)", msg->type );
+                         break;
+               }
+          }
+
+          handle_dispatch_cleanups( world );
+
+          D_DEBUG_AT( Fusion_Main_Dispatch, " ...done\n" );
+
+          pthread_setcancelstate( PTHREAD_CANCEL_ENABLE, NULL );
+     }
+
+     if (world->dispatch_loop)
+          direct_thread_unlock( world->dispatch_loop );
+
+     free( buf );
+
+     return DR_OK;
+}
+
 /*
  * Wait until all pending messages are processed.
  */
diff -Naur DirectFB-1.7.7/lib/fusion/lock.c DirectFB-1.7.7.stm/lib/fusion/lock.c
--- DirectFB-1.7.7/lib/fusion/lock.c	2013-12-19 01:16:24.000000000 +0100
+++ DirectFB-1.7.7.stm/lib/fusion/lock.c	2015-05-15 18:43:40.129447076 +0200
@@ -226,11 +226,10 @@
                     continue;
 
                case EINVAL:
-                    D_ERROR ("Fusion/Lock: invalid skirmish\n");
+                    D_DEBUG_AT( Fusion_Skirmish, "Fusion/Lock: invalid skirmish\n" );
                     return DR_DESTROYED;
           }
 
-          D_PERROR ("FUSION_SKIRMISH_PREVAIL");
           return DR_FUSION;
      }
 
@@ -266,7 +265,7 @@
                     return DR_BUSY;
 
                case EINVAL:
-                    D_ERROR ("Fusion/Lock: invalid skirmish\n");
+                    D_DEBUG_AT( Fusion_Skirmish, "Fusion/Lock: invalid skirmish\n" );
                     return DR_DESTROYED;
           }
 
@@ -312,7 +311,7 @@
                     continue;
 
                case EINVAL:
-                    D_ERROR ("Fusion/Lock: invalid skirmish\n");
+                    D_DEBUG_AT( Fusion_Skirmish, "Fusion/Lock: invalid skirmish\n" );
                     return DR_DESTROYED;
            }
 
@@ -350,7 +349,7 @@
                     continue;
 
                case EINVAL:
-                    D_ERROR ("Fusion/Lock: invalid skirmish\n");
+                    D_DEBUG_AT( Fusion_Skirmish, "Fusion/Lock: invalid skirmish\n" );
                     return DR_DESTROYED;
           }
 
@@ -393,7 +392,7 @@
                     continue;
                     
                case EINVAL:
-                    D_ERROR ("Fusion/Lock: invalid skirmish\n");
+                    D_DEBUG_AT( Fusion_Skirmish, "Fusion/Lock: invalid skirmish\n" );
                     return DR_DESTROYED;
           }
 
@@ -438,7 +437,7 @@
                     return DR_TIMEOUT;
 
                case EINVAL:
-                    D_ERROR ("Fusion/Lock: invalid skirmish\n");
+                    D_DEBUG_AT( Fusion_Skirmish, "Fusion/Lock: invalid skirmish\n" );
                     return DR_DESTROYED;
           }
 
@@ -472,7 +471,7 @@
                     continue;
 
                case EINVAL:
-                    D_ERROR ("Fusion/Lock: invalid skirmish\n");
+                    D_DEBUG_AT( Fusion_Skirmish, "Fusion/Lock: invalid skirmish\n" );
                     return DR_DESTROYED;
           }
 
diff -Naur DirectFB-1.7.7/lib/fusion/object.c DirectFB-1.7.7.stm/lib/fusion/object.c
--- DirectFB-1.7.7/lib/fusion/object.c	2015-02-01 20:36:12.000000000 +0100
+++ DirectFB-1.7.7.stm/lib/fusion/object.c	2015-05-15 18:43:40.129447076 +0200
@@ -84,8 +84,6 @@
      }
 #endif
 
-     D_MAGIC_ASSERT( pool, FusionObjectPool );
-
      /* Lock the pool. */
      if (fusion_skirmish_prevail( &pool->lock ))
           return FCHR_RETURN;
diff -Naur DirectFB-1.7.7/lib/fusion/object.h DirectFB-1.7.7.stm/lib/fusion/object.h
--- DirectFB-1.7.7/lib/fusion/object.h	2015-02-01 20:36:12.000000000 +0100
+++ DirectFB-1.7.7.stm/lib/fusion/object.h	2015-05-15 18:43:40.129447076 +0200
@@ -55,7 +55,6 @@
 
 
 #ifdef __cplusplus
-}
 
 #include <map>
 
@@ -364,5 +363,9 @@
 
 FUSION_OBJECT_METHODS( void, fusion_object )
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif
 
diff -Naur DirectFB-1.7.7/lib/fusion/reactor.c DirectFB-1.7.7.stm/lib/fusion/reactor.c
--- DirectFB-1.7.7/lib/fusion/reactor.c	2014-07-15 11:29:28.000000000 +0200
+++ DirectFB-1.7.7.stm/lib/fusion/reactor.c	2015-05-15 18:43:40.133451076 +0200
@@ -1698,7 +1698,9 @@
 
      pthread_mutex_lock( &reactor->reactions_lock );
 
-     direct_list_remove( &reactor->reactions, &reaction->link );
+     /* reaction->link might be invalidated in fusion's event_dispatcher_loop() */
+     if (reaction->link.prev || reaction->link.next)
+          direct_list_remove( &reactor->reactions, &reaction->link );
 
      pthread_mutex_unlock( &reactor->reactions_lock );
 
diff -Naur DirectFB-1.7.7/lib/fusion/ref.c DirectFB-1.7.7.stm/lib/fusion/ref.c
--- DirectFB-1.7.7/lib/fusion/ref.c	2014-03-22 21:05:18.000000000 +0100
+++ DirectFB-1.7.7.stm/lib/fusion/ref.c	2015-05-15 18:43:40.133451076 +0200
@@ -239,8 +239,10 @@
                return DR_FAILURE;
           }
 
+#if 0
           D_DEBUG_AT( Fusion_Ref, "  -> %d references now\n",
                       ioctl( _fusion_fd( ref->multi.shared ), FUSION_REF_STAT, &ref->multi.id ) );
+#endif
      }
 
      return ret;
@@ -1704,7 +1706,7 @@
 
                     direct_mutex_unlock( &ref->single.lock );
 
-                    fusion_call_execute( &copy_call, FCEF_NODIRECT | FCEF_ONEWAY, copy_arg, NULL, NULL );
+                    fusion_call_execute( &copy_call, FCEF_ONEWAY, copy_arg, NULL, NULL );
 
                     return DR_OK;
                }
diff -Naur DirectFB-1.7.7/lib/fusion/shm/heap.c DirectFB-1.7.7.stm/lib/fusion/shm/heap.c
--- DirectFB-1.7.7/lib/fusion/shm/heap.c	2013-12-19 01:16:24.000000000 +0100
+++ DirectFB-1.7.7.stm/lib/fusion/shm/heap.c	2015-05-15 18:43:40.133451076 +0200
@@ -657,7 +657,7 @@
           goto error;
      }
 
-     D_DEBUG_AT( Fusion_SHMHeap, "  -> mmaping shared memory file... (%d bytes)\n", size );
+     D_DEBUG_AT( Fusion_SHMHeap, "  -> mmaping shared memory file... (%p %d bytes)\n", addr_base, size );
 
      /* map it shared */
      heap = mmap( addr_base, size + space, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_FIXED, fd, 0 );
@@ -716,7 +716,6 @@
      shmalloc_heap   *heap = NULL;
      int              open_flags = write ? O_RDWR : O_RDONLY;
      int              prot_flags = PROT_READ;
-     int              heapsize   = (size + BLOCKSIZE-1) / BLOCKSIZE;
 
      (void)shared;
 
@@ -729,8 +728,7 @@
      D_MAGIC_ASSERT( shm, FusionSHM );
      D_ASSERT( filename != NULL );
      D_ASSERT( addr_base != NULL );
-
-     size += BLOCKALIGN(sizeof(shmalloc_heap)) + BLOCKALIGN( heapsize * sizeof(shmalloc_info) );
+     D_ASSERT( size >= sizeof(shmalloc_heap) );
 
      shared = shm->shared;
 
diff -Naur DirectFB-1.7.7/lib/fusion/shm/pool.c DirectFB-1.7.7.stm/lib/fusion/shm/pool.c
--- DirectFB-1.7.7/lib/fusion/shm/pool.c	2013-12-19 01:16:24.000000000 +0100
+++ DirectFB-1.7.7.stm/lib/fusion/shm/pool.c	2015-05-15 18:43:40.133451076 +0200
@@ -716,7 +716,12 @@
                                 BLOCKALIGN( (max_size + BLOCKSIZE-1) / BLOCKSIZE * sizeof(shmalloc_info) );
 
      pool_addr_base = world->shared->pool_base;
-     world->shared->pool_base += ((pool_max_size + page_size - 1) & ~(page_size - 1)) + page_size;
+#ifdef __SH4__
+  #define SHM_ALIGN_SIZE 0x4000
+#else
+  #define SHM_ALIGN_SIZE page_size
+#endif
+     world->shared->pool_base += ((pool_max_size + page_size - 1) & ~(SHM_ALIGN_SIZE - 1)) + SHM_ALIGN_SIZE;
      /* Exceeded limit? */
      if (world->shared->pool_base > world->shared->pool_max)
           return DR_NOSHAREDMEMORY;
diff -Naur DirectFB-1.7.7/lib/fusiondale/one/ifusiondale_one.c DirectFB-1.7.7.stm/lib/fusiondale/one/ifusiondale_one.c
--- DirectFB-1.7.7/lib/fusiondale/one/ifusiondale_one.c	2013-12-19 01:16:24.000000000 +0100
+++ DirectFB-1.7.7.stm/lib/fusiondale/one/ifusiondale_one.c	2015-05-15 18:43:40.137455077 +0200
@@ -1147,6 +1147,8 @@
 
      D_DEBUG_AT( IFusionDale_One, "  -> TLS registered\n" );
 
+     data->base.core = data->core;
+
      thiz->AddRef          = IFusionDale_One_AddRef;
      thiz->Release         = IFusionDale_One_Release;
      thiz->EnterComa       = IFusionDale_One_EnterComa;
diff -Naur DirectFB-1.7.7/lib/Makefile.am DirectFB-1.7.7.stm/lib/Makefile.am
--- DirectFB-1.7.7/lib/Makefile.am	2015-02-01 20:36:12.000000000 +0100
+++ DirectFB-1.7.7.stm/lib/Makefile.am	2015-05-15 18:46:40.453596770 +0200
@@ -20,4 +20,3 @@
 endif
 
 SUBDIRS = direct fusion $(ONE_DIR) $(VOODOO_DIR) $(FUSIONDALE_DIRS) $(FUSIONSOUND_DIRS)
-
diff -Naur DirectFB-1.7.7/SPECS/stm-target-directfb.template DirectFB-1.7.7.stm/SPECS/stm-target-directfb.template
--- DirectFB-1.7.7/SPECS/stm-target-directfb.template	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7.stm/SPECS/stm-target-directfb.template	2015-05-15 18:48:00.657723298 +0200
@@ -0,0 +1,721 @@
+%define _dfb_build_config	x@BUILD_CONFIG@
+
+Name:		%{_stm_pkg_prefix}-target-directfb@BUILD_CONFIG@
+Summary:	Hardware graphics acceleration library
+Group:		DirectFB/Libraries
+%define _dfbversion	1.7.6
+%define _abiversion	1.7-6
+%define _stmversion	+STM2015.01.16
+Version:	1.7.6%{_stmversion}
+Release:	5
+Epoch: 1
+License:	LGPL
+# created by:
+# git archive --format=tar --prefix=DirectFB-1.7.6/ e2221b1 | bzip2 --best > DirectFB-1.7.6.tar.bz2
+# git diff e2221b1..DIRECTFB_1_7_6_STM2015.01.16 | bzip2 --best > DirectFB-1.7.6.stm.patch.bz2
+# old way:
+# git archive --format=tar --prefix=DirectFB-1.6.1+STM2012.07.25/ DIRECTFB_1_6_1_STM2012.07.25 | bzip2 --best > DirectFB-1.6.1+STM2012.07.25.tar.bz2
+Source0:	DirectFB-%{_dfbversion}.tar.bz2
+Patch0:	DirectFB-%{_dfbversion}.stm.patch.bz2
+
+
+URL:		http://www.directfb.org
+Buildroot:	%(mktemp -ud %{_tmppath}/%{name}-%{version}-%{release}-%{_stm_target_arch}-XXXXXX)
+Prefix:		%{_stm_cross_target_dir}
+
+BuildRequires: %{_stm_pkg_prefix}-%{_stm_target_arch}-libpng-dev
+BuildRequires: %{_stm_pkg_prefix}-host-fluxcomp >= 1.4.4
+%if %target_cpu arm sh
+%define _mme_enabled no
+%define _stmfbdev --enable-stmfbdev
+%else
+%define _mme_enabled no
+%define _stmfbdev --disable-stmfbdev
+%endif
+%if %target_cpu arm
+%define _multicore_enabled yes
+%else
+%define _multicore_enabled no
+%endif
+%if "%{_dfb_build_config}" == "x-multi"
+BuildRequires: %{_stm_pkg_prefix}-%{_stm_target_arch}-linux-fusion-headers >= 9.0.3
+%define _dfb_multiapp --enable-multi
+%else
+%if "%{_dfb_build_config}" == "x"
+%define _dfb_multiapp --disable-multi
+%else
+# unsupported, error out
+unsupported BUILD_CONFIG option
+%endif
+%endif
+
+Obsoletes: %{_stm_pkg_prefix}-%{_stm_target_arch}-fusiondale
+Obsoletes: %{_stm_pkg_prefix}-%{_stm_target_arch}-fusiondale-dev
+Obsoletes: %{_stm_pkg_prefix}-%{_stm_target_arch}-sawman
+Obsoletes: %{_stm_pkg_prefix}-%{_stm_target_arch}-sawman-bin
+Obsoletes: %{_stm_pkg_prefix}-%{_stm_target_arch}-sawman-dev
+
+%define _pkgname	%{_stm_pkg_prefix}-%{_stm_target_arch}-directfb
+%define _fullname	directfb-%{_abiversion}
+%define _docdir		%{_stm_cross_target_dir}%{_stm_target_doc_dir}
+
+#
+#  SRPM Package
+#
+%description
+The source package for DirectFB.
+
+#
+#  RPMS
+#
+%package -n %{_pkgname}@BUILD_CONFIG@
+Summary:	Hardware graphics acceleration library
+Group:		DirectFB/Libraries
+Provides:	%{_pkgname} = %{version}-%{release}
+
+%if "%{_dfb_build_config}" == "x-multi"
+Provides:	%{_pkgname}-multi = %{version}-%{release}
+Conflicts:	%{_pkgname}-single
+%else
+%if "%{_dfb_build_config}" == "x"
+Provides:	%{_pkgname}-single = %{version}-%{release}
+Conflicts:	%{_pkgname}-multi
+%endif
+%endif
+Obsoletes: %{_stm_pkg_prefix}-%{_stm_target_arch}-fusiondale
+Obsoletes: %{_stm_pkg_prefix}-%{_stm_target_arch}-sawman
+Obsoletes: %{_stm_pkg_prefix}-%{_stm_target_arch}-sawman-bin
+
+%description -n %{_pkgname}@BUILD_CONFIG@
+DirectFB is a thin library that provides developers with hardware graphics
+acceleration, input device handling and abstraction, an integrated windowing
+system with support for translucent windows and multiple display layers on top
+of the Linux frame buffer device. It is a complete hardware abstraction layer
+with software fallbacks for every graphics operation that is not supported by
+the underlying hardware.
+%if "%{_dfb_build_config}" == "x-multi"
+This version has been built with the Multi Application Core.
+%else
+%if "%{_dfb_build_config}" == "x"
+This version has been built with the Single Application Core.
+%endif
+%endif
+
+
+%package -n %{_pkgname}@BUILD_CONFIG@-dev
+Summary:	Hardware graphics acceleration library - development
+Group:		DirectFB/Development
+AutoReq:	no
+Provides:	%{_pkgname}-dev = %{version}-%{release}
+%if "%{_dfb_build_config}" == "x-multi"
+Requires:	%{_pkgname}-multi = %{version}-%{release}
+Provides:	%{_pkgname}-multi-dev = %{version}-%{release}
+%else
+%if "%{_dfb_build_config}" == "x"
+Requires:	%{_pkgname}-single = %{version}-%{release}
+Provides:	%{_pkgname}-single-dev = %{version}-%{release}
+%endif
+%endif
+Obsoletes: %{_stm_pkg_prefix}-%{_stm_target_arch}-fusiondale-dev
+Obsoletes: %{_stm_pkg_prefix}-%{_stm_target_arch}-sawman-dev
+
+%description -n %{_pkgname}@BUILD_CONFIG@-dev
+DirectFB header files needed for building DirectFB applications.
+
+%package -n %{_pkgname}@BUILD_CONFIG@-dbg
+Summary:	Hardware graphics acceleration library - debug info
+Group:		DirectFB/Development
+AutoReq:	no
+Provides:	%{_pkgname}-dbg = %{version}-%{release}
+%if "%{_dfb_build_config}" == "x-multi"
+Requires:	%{_pkgname}-multi = %{version}-%{release}
+Provides:	%{_pkgname}-multi-dbg = %{version}-%{release}
+%else
+%if "%{_dfb_build_config}" == "x"
+Requires:	%{_pkgname}-single = %{version}-%{release}
+Provides:	%{_pkgname}-single-dbg = %{version}-%{release}
+%endif
+%endif
+%description -n %{_pkgname}@BUILD_CONFIG@-dbg
+This package provides debug information for DirectFB. Debug information
+is useful for providing meaningful backtraces in case of bugs.
+
+%package -n %{_pkgname}-bin
+Summary:	Hardware graphics acceleration library - binaries
+Group:		DirectFB/Development
+%description -n %{_pkgname}-bin
+ DirectFB is a graphics library which was designed with embedded systems
+ in mind. It offers maximum hardware accelerated performance at a minimum
+ of resource usage and overhead.
+ .
+ This package contains the various DirectFB tools, e.g. a background
+ configuration tool, and also the directfbrc man page.
+
+%package -n %{_pkgname}-tests
+Summary:	Hardware graphics acceleration library - tests
+Group:		DirectFB/Development
+%description -n %{_pkgname}-tests
+ DirectFB is a graphics library which was designed with embedded systems
+ in mind. It offers maximum hardware accelerated performance at a minimum
+ of resource usage and overhead.
+ .
+ This package various tests that come with the DirectFB source tree. They
+ are normally not needed, except for maybe driver validatation.
+
+
+%prep
+%target_setup
+%setup -qn DirectFB-%{_dfbversion}
+%patch0 -p1
+# the patch contains symlinks (in git format), but only git-patch can
+# deal with these, do it manually
+for i in fb.h vt.h ; do
+  rm -f systems/stmfbdev/${i}
+  ln -s ../fbdev/${i} systems/stmfbdev/
+done
+%target_autoreconf
+
+%build
+%target_setup
+# the st231 compiler emits a warning when it encounters multiple -O statements,
+# which makes auto* assume that some of its tests failed. Strip out existing -O
+# and add -O3
+_stripped_flags=
+for _this_flag in $CFLAGS ; do
+  _stripped_flags="${_stripped_flags} `echo $_this_flag | sed -e 's,-O.,,'`"
+done
+export CFLAGS="${_stripped_flags} -O3"
+# add -g for debug package
+export CFLAGS="${CFLAGS} -g3"
+export CXXFLAGS="${CFLAGS} -g3"
+export DIRECTFB_VERSION_VENDOR="%{_stmversion}"
+%target_do_configure \
+	--enable-static \
+	\
+	--disable-devmem \
+	--disable-sdl \
+	%{_stmfbdev} \
+	\
+	--enable-voodoo \
+	\
+	--with-gfxdrivers=none \
+	--enable-mme=%{_mme_enabled} \
+	--enable-multicore=%{_multicore_enabled} \
+	--with-message-size=65536 \
+	\
+	%{_dfb_multiapp} \
+	\
+	--enable-one \
+	--enable-divine \
+	--enable-sawman \
+	--enable-fusiondale \
+	\
+	--with-tests
+%make
+
+
+%install
+%target_setup
+%target_makeinstall_destdir
+# make sure the graphics drivers directory exists as we don't (necessarily)
+# build graphics drivers. This will ensure a defined owner of this directory
+# (the DirectFB RPMs), also ensuring that the directory is removed during
+# uninstall of the DFB RPMs.
+mkdir -p %{buildroot}%{_stm_cross_target_dir}%{_stm_target_lib_dir}/%{_fullname}/gfxdrivers
+
+# build directfb-config for host environment
+# we assume that _stm_target_lib_dir is in the default search path of both the cross
+# and target dynamic linkers, to suppres spurious -L/usr/lib in *.la files
+mkdir -p %{buildroot}%{_stm_cross_bin_dir}
+sed -e "s,libs=-L%{_stm_target_lib_dir},libs=,g" \
+    -e "s,%{_stm_target_prefix},%{_stm_cross_target_dir}%{_stm_target_prefix},g" \
+    < %{buildroot}%{_stm_cross_target_dir}%{_stm_target_bin_dir}/directfb-config \
+    > %{buildroot}%{_stm_cross_bin_dir}/%{_stm_target_toolprefix}directfb-config
+chmod +x %{buildroot}%{_stm_cross_bin_dir}/%{_stm_target_toolprefix}directfb-config
+
+%target_install_fixup
+# Process target .pc files so they are useful in a cross environment
+for f in %{buildroot}%{_stm_cross_target_dir}%{_stm_target_pkgconfig_dir}/*.pc ; do
+  sed -i '/^prefix=/!s,%{_stm_target_prefix},${prefix},' $f
+done
+
+
+cd ..
+cp COPYING LICENSE
+
+
+# pull debug from elf files out into separate files, to be packaged in the -dbg package
+: > debugfiles.list
+files=`find %{buildroot}%{_stm_cross_target_dir}%{_stm_target_bin_dir} -type f` || true
+files="${files} `find %{buildroot}%{_stm_cross_target_dir}%{_stm_target_lib_dir} -name '*so*' -type f | egrep -v '\.debug$' | egrep '(\.so$|\.so\.)'`"
+for elffile in ${files} ; do
+  sofile=`readelf -h ${elffile} 2> /dev/null | grep "DYN"` || true
+  execfile=`readelf -h ${elffile} 2> /dev/null | grep "EXEC"` || true
+  if [ "X${sofile}" != "X" -o "X${execfile}" != "X" ] ; then
+    debugfile=%{_stm_cross_target_dir}%{_stm_target_debug_dir}`echo ${elffile} | sed -e s,%{buildroot}%{_stm_cross_target_dir},,`.debug
+    mkdir -p `dirname %{buildroot}${debugfile}`
+    %{_stm_target_toolprefix}objcopy --only-keep-debug ${elffile} %{buildroot}${debugfile}
+    %{_stm_target_toolprefix}objcopy --strip-debug ${elffile}
+    %{_stm_target_toolprefix}objcopy --add-gnu-debuglink=%{buildroot}${debugfile} ${elffile}
+    echo ${debugfile} >> debugfiles.list
+  fi
+done
+
+
+%clean
+rm -rf %{buildroot}
+
+
+%files -n %{_pkgname}@BUILD_CONFIG@
+%defattr(-,root,root)
+%{_stm_cross_target_dir}%{_stm_target_lib_dir}/lib*.so.*
+%dir %{_stm_cross_target_dir}%{_stm_target_lib_dir}/%{_fullname}
+%dir %{_stm_cross_target_dir}%{_stm_target_lib_dir}/%{_fullname}/*
+%{_stm_cross_target_dir}%{_stm_target_lib_dir}/%{_fullname}/*/lib*.so
+%dir %{_stm_cross_target_dir}%{_stm_target_lib_dir}/%{_fullname}/interfaces/*
+%{_stm_cross_target_dir}%{_stm_target_lib_dir}/%{_fullname}/interfaces/*/lib*.so
+%dir %{_stm_cross_target_dir}%{_stm_target_data_dir}/directfb-%{_dfbversion}
+%{_stm_cross_target_dir}%{_stm_target_data_dir}/directfb-%{_dfbversion}/cursor.dat
+%{_stm_cross_target_dir}%{_stm_target_data_dir}/directfb-%{_dfbversion}/cursor.png
+%{_stm_cross_target_dir}%{_stm_target_data_dir}/directfb-%{_dfbversion}/decker.ttf
+%doc AUTHORS ChangeLog LICENSE NEWS README TODO
+
+%files -n %{_pkgname}@BUILD_CONFIG@-dev
+%defattr(-,root,root)
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/directfb-config
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/directfb-csource
+%{_stm_cross_target_dir}%{_stm_target_include_dir}/directfb
+%{_stm_cross_target_dir}%{_stm_target_include_dir}/directfb-internal
+%{_stm_cross_target_dir}%{_stm_target_include_dir}/++dfb
+%{_stm_cross_target_dir}%{_stm_target_include_dir}/One
+%{_stm_cross_target_dir}%{_stm_target_include_dir}/divine
+%{_stm_cross_target_dir}%{_stm_target_include_dir}/fusiondale
+%{_stm_cross_target_dir}%{_stm_target_include_dir}/sawman
+%{_stm_cross_target_dir}%{_stm_target_lib_dir}/lib*.so
+%{_stm_cross_target_dir}%{_stm_target_lib_dir}/lib*.a
+%{_stm_cross_target_dir}%{_stm_target_lib_dir}/lib*.la
+%{_stm_cross_target_dir}%{_stm_target_lib_dir}/%{_fullname}/*/lib*.a
+%{_stm_cross_target_dir}%{_stm_target_lib_dir}/%{_fullname}/*/lib*.la
+%{_stm_cross_target_dir}%{_stm_target_lib_dir}/%{_fullname}/*/lib*.o
+%{_stm_cross_target_dir}%{_stm_target_lib_dir}/%{_fullname}/interfaces/*/lib*.a
+%{_stm_cross_target_dir}%{_stm_target_lib_dir}/%{_fullname}/interfaces/*/lib*.la
+%{_stm_cross_target_dir}%{_stm_target_lib_dir}/%{_fullname}/interfaces/*/lib*.o
+%{_stm_cross_target_dir}%{_stm_target_pkgconfig_dir}/*.pc
+%{_stm_cross_target_dir}%{_stm_target_data_dir}/man/man1/directfb-csource*1*
+%{_stm_cross_bin_dir}/*
+%doc AUTHORS ChangeLog LICENSE NEWS README TODO
+
+%files -n %{_pkgname}@BUILD_CONFIG@-dbg -f debugfiles.list
+%defattr(-,root,root)
+%doc AUTHORS ChangeLog LICENSE NEWS README TODO
+
+%files -n %{_pkgname}-bin
+%defattr(-,root,root)
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/dfbdump
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/dfbfx
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/dfbg
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/dfbinfo
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/dfbinput
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/dfbinspector
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/dfblayer
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/dfbmaster
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/dfbpenmount
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/dfbproxy
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/dfbscreen
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/dfbdumpinput
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/dfbplay
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/dfbshow
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/dfbswitch
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/mkdfiff
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/mkdgiff
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/mkdgifft
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/voodooplay
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/voodooplay_client
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/voodooplay_server
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/divine_test
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/fddump
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/fdmaster
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/fdtest_bench
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/fdtest_coma
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/fdtest_init
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/sample1
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/spooky
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/swmdump
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/testman
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/testrun
+%{_stm_cross_target_dir}%{_stm_target_data_dir}/man/man1/dfbg*1*
+%{_stm_cross_target_dir}%{_stm_target_data_dir}/man/man5/directfbrc*5*
+%doc AUTHORS ChangeLog LICENSE NEWS README TODO
+
+%files -n %{_pkgname}-tests
+%defattr(-,root,root)
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/coretest_*
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/dfbtest_*
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/direct_*
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/fusion_*
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/voodoo_bench*
+%dir %{_stm_cross_target_dir}%{_stm_target_data_dir}/directfb-%{_dfbversion}
+%{_stm_cross_target_dir}%{_stm_target_data_dir}/directfb-%{_dfbversion}/decker.dgiff
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/OneBench
+%{_stm_cross_target_dir}%{_stm_target_bin_dir}/OneTest
+%doc AUTHORS ChangeLog LICENSE NEWS README TODO
+
+
+%changelog
+* Thu Dec 04 2014 Ilyes Gouta <ilyes.gouta@st.com> 4
+- [Bugzilla: 63244] Disable Multicom integration
+
+* Fri Nov 14 2014 Frederic Pillon <frederic.pillon@st.com> 3
+- [Spec] Correct Obsoletes macro as it was not take in account.
+
+* Fri Oct 31 2014 Gilles Grandjouan <gilles.grandjouan@st.com> 2
+- [Spec] Bump the release number for 2.4 product release.
+- [Spec] Bump the release number to force rebuild against updated libjpeg
+
+* Thu Oct 23 2014 Ilyes Gouta <ilyes.gouta@st.com> 1:1.7.6+STM2014.10.23-1
+- [Update: 1.7.6] Update to DirectFB-1.7 API (+STM patches)
+
+* Wed Sep 24 2014 Ilyes Gouta <ilyes.gouta@st.com> 1:1.6.4+STM2014.09.24-1
+- [Bugzilla: 59216] Improve shutdown sequence in DirectFB-1.6
+
+* Fri Sep 12 2014 Ilyes Gouta <ilyes.gouta@st.com> 1:1.6.4+STM2014.09.12-1
+- [Bugzilla: 56438] fix a memory leak in the TIFF image provider
+- fbdev: don't destroy the surface pool if already freed
+- core: flush and wait for pending h/w ops. prior surface destruction
+- libfusion: fix secure-fusion mode for reactor_globals and arenas_lock
+- [Delete patch: 0001-configure-ignore-with-sysroot-option.patch]
+  not needed anymore
+
+* Thu Jul 24 2014 Gilles Grandjouan <gilles.grandjouan@st.com> 1:1.6.4+STM2014.07.22-2
+- [Bugzilla: 54814] Applied patch received from Ilyes
+
+* Tue Jul 22 2014 Ilyes Gouta <ilyes.gouta@st.com> 1:1.6.4+STM2014.07.22-1
+- [Bugzilla: 54814] segmentation fault when creating the IDirectFB interface twice
+
+* Fri Jun 27 2014 Christian Bruel <christian.bruel@st.com> 2
+- [Spec] Reinstall with correct dependencies in .la.
+
+* Wed Apr 23 2014 BogusDateBot
+- Eliminated rpmbuild "bogus date" warnings due to inconsistent weekday,
+  by assuming the date is correct and changing the weekday.
+  Tue Jul 29 2009 --> Tue Jul 28 2009 or Wed Jul 29 2009 or Tue Aug 04 2009 or ....
+  Wed Mar 09 2010 --> Wed Mar 03 2010 or Tue Mar 09 2010 or Wed Mar 10 2010 or ....
+
+* Mon Apr 21 2014 Ilyes Gouta <ilyes.gouta@st.com> 1:1.6.4+STM2014.04.21-1
+- [Bugzilla: 37637] FBDev: Enable stmfb auxiliary memory support on STM platforms
+- [Bugzilla: 39840] Revert implementation for CORE_STMFBDEV system
+  STMfbdev has been discontinued in STLinux and is now part of SDK2 deliverables
+- [Bugzilla: 42061] Busy allocations should have a valid parent buffer
+- [Bugzilla: 48949] Avoid calling direct_shutdown() twice
+- [Bugzilla: 48950] Initialize the shm pool lock as a shared object
+- libfusion: hash resizing in fusion_hash_replace (when new)
+- Core: Don't freeze when moving layer (update_primary_region_config)
+
+* Mon Mar  3 2014 Gilles Grandjouan <gilles.grandjouan@st.com> 1:1.6.4+STM2013.11.29-3
+- [Spec] Bump release to force rebuild against updated libjpeg
+
+* Mon Feb 03 2014 Mohamed Hafsia <mohamed.hafsia@st.com> 1:1.6.4+STM2013.11.29-2
+- [Spec] bump release to rebuild against updated libwebp
+
+* Fri Nov 29 2013 Ilyes Gouta <ilyes.gouta@st.com> - 1:1.6.4+STM2013.11.29-1
+- Update to the latest directfb-1.6 (SHA1 cc46784)
+- [Bugzilla: 32930] Enable One in DirectFB-1.6.x, FusionDale
+- [Bugzilla: 34641] Fusiondale not supporting Secure Mode
+- [Bugzilla: 38142] DirectFB: Add 4k display resolution
+- [Bugzilla: 39478] direct_list_contains_element_EXPENSIVE( *list, link ) fails
+- [Bugzilla: 40435] Swapped red/blue channels when decoding a TIFF picture
+
+* Fri Aug 30 2013 Ilyes Gouta <ilyes.gouta@st.com> - 1:1.6.3+STM2013.08.30-1
+- [Bugzilla: 29557] colour fill to NV12 and NV21 broken
+- [Bugzilla: 29559] IDirectFBSurface::Dump() for DSPF_YUV444P incorrect
+- [Bugzilla: 29496] IDirectFBSurface::Dump() for DSPF_(A)VYU incorrect
+- [Bugzilla: 29512] IDirectFBSurface::Dump() for DSPF_YV16 incorrect
+- [Bugzilla: 29985] DSPF_NV12MB and DSPF_NV16MB aren't marked as YCbCr
+- [Bugzilla: 35133] WebP imageprovider crashes when doing multiple RenderTo()
+- inputdrivers: set DICAPS_KEYS only for input devices with keys
+- imageprovider: add a new TIFF image provider
+
+* Wed Jun 12 2013 Andr Draszik <andre.draszik@st.com> - 1:1.6.3+STM2013.04.10-2
+- [Spec; Bugzilla: 31952] make sure we create and own the gfxdrivers directory
+
+* Wed Apr 10 2013 Ilyes Gouta <ilyes.gouta@st.com> - 1:1.6.3+STM2013.04.10-1
+- [Bugzilla: 29280] idirectfb: allow creating NV1xMB surfaces with
+  DSCAPS_PREMULTIPLIED set
+- imageprovider: add WebP imageprovider
+- hwjpeg: early validate the JPEG buffer with the h/w decoder
+- hwjpeg: don't downsample NV24 to a temporary NV16 buffer
+- [Bugzilla: 27188] fusion: ref: immediately execute FusionCall in
+  fusion_ref_down()
+- [Bugzilla: 16971] Revert
+  "direct: replace C++ style comments by standard C comments"
+- [Bugzilla: 27699] interfaces: gif: fix up DVPLAY_PACED decoding mode
+- [Bugzilla: 27886] idirectfb: don't clear config.surface_caps if already set
+
+* Mon Feb 25 2013 Francesco Virlinzi <francesco.virlinzi@st.com> 2
+- [Spec; Bugzilla: 23138] Make compatible with rpm-build 4.10.
+
+* Fri Feb 01 2013 Ilyes Gouta <ilyes.gouta@st.com> - 1:1.6.3+STM2013.02.01-1
+- [Update: 1.6.3] update to 1.6.3 release
+- [Bugzilla: 25124] direct: reimplement direct_waitqueue_wait_timeout() to use
+  clock_gettime()
+- interfaces: jpeg: new hwjpeg-v4l2 image provider
+- directfb: new DSPF_NV24 pixel format
+- directfb: new DSPF_BYTE pixel format
+
+* Fri Sep 21 2012 Ilyes Gouta <ilyes.gouta@st.com> - 1:1.6.1+STM2012.09.21-1
+- [Bugzilla: 21232] DirectFB-1.6: Grayscale JPEG decoding is broken
+- [Bugzilla: 21233] DirectFB-1.6: LUT4 (or LUT2) animated gif doesn't
+		    get rendered properly
+- [Bugzilla: 16971] DirectFB-1.6: replace C++ style comments by
+		    standard C comments
+- [Bugzilla: 18969] Bad interaction between libmme.so and DirectFB
+
+* Wed Aug 01 2012 Ilyes Gouta <ilyes.gouta@st.com> - 1:1.6.1+STM2012.07.25-1
+- [Spec] configure with a 65356 bytes per Fusion message buffer (IPC)
+- [Spec] disable parallel build process (fluxcomp/gcc concurrency)
+
+* Wed Jul 25 2012 Andr Draszik <andre.draszik@st.com> - 1:1.6.1+STM2012.07.25-1
+- [Update: 1.6.1] update to 1.6.1 release
+- [Spec] change contents of SRPM to contain pristine tarball + STM patch
+- [Spec] add BuildRequires for fluxcomp
+- [Spec] enable voodoo during configure
+- [Spec] package binaries in new -bin package and move man pages here
+- [Spec] package tests in new -tests package
+- [Spec] always fully disable gfxdrivers, stgfx(1) is completely gone,
+  and stgfx2 is now hosted elsewhere
+- [Spec] build armv7 version with multicore support (SMP)
+- [Spec] always fully disable gfxdrivers, stgfx(1) is completely gone,
+  and stgfx2 is now hosted elsewhere
+- [Spec] forcefully enable stmfbdev on SH4 and ARM
+- [Bugzilla: 18771] stmfbdev: don't error out if display driver announced no
+  supported modes
+- stmfbdev: fix to actually allow configuring DVO, allow selection
+  between RGB 24bit and YCbCr 444 16bit
+- stmfbdev: add support for 960x540 and 1440x540 NTG5 modes
+- stmfbdev: for HDMI outputs, be more explicit about YCbCr 444 / 422 / RGB
+- move all of the stmfbdev layer and screen handling out of stgfx2, so that
+  stmfbdev can be used independently of any hardware acceleration
+- [Bugzilla: 12425] JPEG decode segfaults for iDCT downscaled grayscale images
+- [Bugzilla: 16039] jpeg software decode error path broken in case h/w decode
+  failed earlier
+- [Bugzilla: 16040] jpeg: optimise grayscale JPEG decoding
+- jpeg: use JDCT_FASTEST instead of JDCT_IFAST
+- image providers: change the backgrounded image provider API to use the
+  DIRenderFlags that upstream added recently, instead of our
+  DFBImageProviderFlags
+- rle: remove image provider
+- add DSPF_LUT4 implementation
+- add DSPF_BGR24 implementation
+- add DSPF_NV12MB and DSPF_NV16MB and (incomplete) implementation
+- directfb: extend IDirectFBInputDevice to recognize sensors-based input devices
+
+* Fri Jun 08 2012 Ilyes Gouta <ilyes.gouta@st.com> 1:1.4.12+STM2011.09.27-3
+- [Bugzilla: 17925] jpeg: fix stack corruption when going through hardware
+  assisted decode
+- [Bugzilla: 17956] fix SIGSEGV when downscaling via iDCT in the JPEG raw
+  decode path
+- [Bugzilla: 17958] image provider: have to wait for the hardware in certain
+  cases
+- [Bugzilla: 18969] prefer runtime dynamic linking for certain image providers
+- [Delete patch: DirectFB-1.4.12-directfb-improved-idirectfbvideoprovider_gif.patch,
+   DirectFB-1.4.12-directfb-DVPLAY_PACED-declaration.patch,
+   DirectFB-1.4.12-directfb-palette_pass_data-core_instead_of_NULL.patch]
+  not needed anymore
+
+* Thu Feb 16 2012 Mohamed Hafsia <mohamed.hafsia@st.com> 1:1.4.12+STM2011.09.27-2
+- [Bugzilla: 16564] Rework IDirectFBVideoProvider_GIF to implement a paced decode
+- [Add patch: DirectFB-1.4.12-directfb-improved-idirectfbvideoprovider_gif.patch,
+   DirectFB-1.4.12-directfb-DVPLAY_PACED-declaration.patch
+   DirectFB-1.4.12-directfb-palette_pass_data-core_instead_of_NULL.patch]
+  Improved DirectFB IDirectFBVideoProvider_gif
+
+* Tue Sep 27 2011 Andr Draszik <andre.draszik@st.com> - 1:1.4.12+STM2011.09.27-1
+- [Bugzilla: 14222] subpixel based backwards blits don't look perfect
+- [Delete patch:
+   DirectFB-1.4.12+STM2011.05.05-bdisp2_accel-fix-directions-for-backwards-copy.patch,
+   DirectFB-1.4.12+STM2011.05.05-bdisp_accel-hot-fix-for-backwards-blits-than-don-t-r.patch]
+  not needed anymore
+
+* Fri Sep 16 2011 Andr Draszik <andre.draszik@st.com> - 1:1.4.12+STM2011.05.05-3
+- [Bugzilla: 14177; Add patch:
+   DirectFB-1.4.12+STM2011.05.05-bdisp2_accel-fix-directions-for-backwards-copy.patch,
+   DirectFB-1.4.12+STM2011.05.05-bdisp_accel-hot-fix-for-backwards-blits-than-don-t-r.patch]
+  hotfix for STLinux bugzilla 14177
+
+* Wed Aug 31 2011 Giuseppe Condorelli <giuseppe.condorelli@st.com> 1:1.4.12+STM2011.05.05-2
+- [Spec] Add libpng BuildRequires, also rebuilding package against updated libpng
+
+* Thu May 05 2011 Andr Draszik <andre.draszik@st.com> 1:1.4.12+STM2011.05.05-1
+- [Bugzilla: 11922] really fix raw jpeg decoding for libjpeg >= v7
+- [Bugzilla: 10850, 12050] clipping in "fb_gfxcard_drawstring" not checked correctly
+- fix small memory leak in DirectGetInterface()
+
+* Thu Apr 14 2011 Andr Draszik <andre.draszik@st.com> 1:1.4.12+STM2011.04.14-1
+- [Update: 1.4.12+STM2011.04.14] update to DirectFB 1.4.12 and latest STM version
+- [Bugzilla: 11689] inputdrivers: support lirc>=0.8.6
+- [Bugzilla: 11884] build: libidirectfbfont_ft2 must be linked against libm
+- [Delete patch: DirectFB-1.4.11-non-mme-hotfix.patch] not needed anymore
+- [Bugzilla: 11922] fix raw jpeg decoding for libjpeg >= v7
+
+* Tue Apr 05 2011 Andr Draszik <andre.draszik@st.com> 1:1.4.11+STM2010.12.15-4
+- [Bugzilla: 11825; Spec] add debug info package
+- [Spec] update summary of -dev package
+
+* Thu Jan 06 2011 Andr Draszik <andre.draszik@st.com> 1:1.4.11+STM2010.12.15-3
+- [Add patch: DirectFB-1.4.11-non-mme-hotfix.patch] hotfix for builds with
+  disabled MME
+- Breaks binary compatibility with Mali drivers (Mali drivers need to be rebuilt)
+
+* Wed Jan 05 2011 Andr Draszik <andre.draszik@st.com> 1:1.4.11+STM2010.12.15-2
+- [Spec] disable MME use for image decoding for non sh4 builds during configure
+  to fix build failures on ARM
+
+* Wed Dec 15 2010 Andr Draszik <andre.draszik@st.com> 1:1.4.11+STM2010.12.15-1
+- [Update: 1.4.11+STM2010.12.15] new release based on 1.4.11 + git 811a8c0
+- [Bugzilla: 10320] don't set any output resolution on startup
+- [Bugzilla: 10344] take DirectFB's init-layer=<x> option into account
+- [Bugzilla: 10769] want SOURCE2 support in DirectFB BDisp driver
+- image providers: accelerate JPEG and PNG using MME
+- fixed point fixes
+- [Delete patch: DirectFB-1.4.3-0001-stgfx2-version-bump.patch] integrated upstream
+- [Spec] Bump BuildRequires for linux-fusion to 8.2.0
+- [Spec] drop setting of LIBPNG_CONFIG - it's not needed anymore
+
+* Thu Oct 21 2010 Andr Draszik <andre.draszik@st.com> 1:1.4.3+STM2010.10.15-1
+- [Add patch: DirectFB-1.4.3-0001-stgfx2-version-bump.patch] bump stgfx2 version
+  to 0.8
+
+* Fri Oct 15 2010 Andr Draszik <andre.draszik@st.com> 1:1.4.3+STM2010.10.15-1
+- [Update: 1.4.3+STM2010.10.15] new release
+- [Bugzilla: 10253] jpeg: fix raw decode error paths
+- [Bugzilla: 10242] stgfx2: DSBLIT_XOR does not work
+- [Bugzilla: 10254] stgfx2: incorrect use of line filters for 'slim' stretch blits
+- [Bugzilla: 10228] stgfx2: disable use of hw based clipping
+- [Bugzilla: 10226] stgfx2: full DSBLIT_BLEND_COLORALPHA support
+- [Bugzilla: 10227] stgfx2: fix some 'unusual' PorterDuff blends
+- [Bugzilaa: 10247] stgfx2: DSPD_CLEAR crashes the BDisp in 422r modes
+- stgfx2 cleanup: blit state rewrite, compiler warnings, debug for DirectFB 1.4.3,
+  fixes for RGB32
+- [Spec] some changes so as to make future updates easier
+
+* Thu Aug 26 2010 Andr Draszik <andre.draszik@st.com> 1:1.4.3+STM2010.06.22-2
+- [Spec] fix build requires to reference correct stmfb headers package version
+  on sh4
+
+* Wed Aug 25 2010 Andr Draszik <andre.draszik@st.com> 1:1.4.3+STM2010.06.22-1
+- [Update: 1.4.3+STM2010.06.22] new release
+- [Delete patch: DirectFB-1.4.3+STM2010.06.16-stmfb0029.patch] we have an up to
+  date stmfb in STLinux 2.4 now, so this patch is a) harmful for STi7108 support
+  and b) not needed anymore anyway
+- stgfx2: fix clip validation
+
+* Wed Jun 16 2010 Andr Draszik <andre.draszik@st.com> 1:1.4.3+STM2010.06.16-1
+- [Update: 1.4.3.STM2010.06.16] new release
+- [Delete patch: DirectFB-1.4.3.STM2010.03.10-libjpeg7.patch,
+   DirectFB-1.4.3.STM2010.03.10-libjpeg7_2.patch]
+  jpeg problems correctly fixed upstream
+- [Delete patch: DirectFB-1.4-Revert-versioned-DirectFB-libraries.patch]
+  not needed anymore
+- [Add patch: DirectFB-1.4.3+STM2010.06.16-stmfb0029.patch] needed now
+
+* Tue Apr 27 2010 Andr Draszik <andre.draszik@st.com> 1.4.3.STM2010.03.10-4
+- [Bugzilla: 8912; Add patch: DirectFB-1.4.3.STM2010.03.10-libjpeg7.patch,
+   DirectFB-1.4.3.STM2010.03.10-libjpeg7_2.patch]
+  fix libjpeg usage for libjpeg versions >= 7
+- [Spec] simplify file ownership list
+- [Spec] bump version to rebuild against updated libjpeg
+
+* Tue Apr 13 2010 Andr Draszik <andre.draszik@st.com> 1.4.3.STM2010.03.10-3
+- [Spec] fix source package name
+
+* Wed Mar 31 2010 Stuart Menefy <stuart.menefy@st.com> 2
+- [Spec] Bump the release number for 2.4 product release.
+- [Spec] Update BuildRoot to use %%(mktemp ...) to guarantee a unique name.
+
+* Tue Mar 09 2010 Andr Draszik <andre.draszik@st.com> 1.4.3.STM2010.03.10-1
+  Wed Mar 09 2010 --> Wed Mar 03 2010 or Tue Mar 09 2010 or Wed Mar 10 2010 or ....
+- [Spec] add some more files to main package's documentation
+- merge in latest updates from DirectFB/master branch
+- input: handle button devices with just up/down keys as keyboards, too
+- stgfx2: fix shutdown error path
+- stgfx2: big cleanup regarding the destination address
+- stgfx2: slightly smaller cleanup regarding the s3 address & type
+- stgfx2: cleanup regarding s2 address & type
+- stgfx2: huge cleanup regarding drawing state
+- the above four changes yield in about 10% less CPU usage on fills!
+- [Bugzilla: 8256] XOR doesn't work as expected
+- [Bugzilla: 8406] prevent BDisp crash when doing YCbCr422R fast blit
+- [Bugzilla: 8366] desaturation of YCbCr surfaces
+- stgfx2: back to bdisp_aq_VideoYCbCr601_2_RGB matrix for YCbCr->RGB conversions
+- stgfx2: allow 'other' accelerators to access our surface pools
+- stgfx2: RGB32 updates
+
+* Fri Feb 05 2010 Andr Draszik <andre.draszik@st.com> 1.4.3.STM2010.02.08-1
+- [Bugzilla: 8193] do necessary changes (pollvsync_after)
+- [Bugzilla: 7360, 8077] subpixel vertical filter setup has been
+  greatly simplified and corrected
+
+* Fri Feb 05 2010 Andr Draszik <andre.draszik@st.com> 1.4.3.STM2010.02.05-1
+- stgfx stgfx2: fix shutdown when not running in stmfbdev system
+- linux_input: fix compilation if stmfbdev is disabled
+
+* Sun Jan 31 2010 Andr Draszik <andre.draszik@st.com> 1.4.3.STM2010.01.31-1
+- merge in latest updates from DirectFB/master branch
+- stmfbdev: address compiler warnings in non debug builds
+- stmfbdev: fix crash in shutdown
+- stmfbdev: optimize ioctl handling
+- stmfbdev: don't instanciate screens, layers & surface pools anymore
+- stgfx/stgfx2: move instanciation of the above here, this gets us rid of more of DirectFB's startup warnings
+
+* Fri Jan 29 2010 Andr Draszik <andre.draszik@st.com> 1.4.3.STM2010.01.29-1
+- [Bugzilla: 7995] new system: 'stmfbdev' for many new features reg. screen control
+- stgfx2:
+  + some fixes for blit and fill if destination is YUV
+  + WA for https://bugzilla.stlinux.com/show_bug.cgi?id=7084
+  + update alignment restrictions for STi7108
+  + stgfx surface pools: prevent confusing startup message
+- stgfx:
+  + update alignment restrictions for STi7108
+  + stgfx surface pools: prevent confusing startup message
+- misc:
+  + dfbscreen: little fixes
+  + generic: LUT8 is not a YUV format
+  + screen: NTSC and PAL60 standards are defined as 59.94Hz not 60Hz
+  + IDirectFBScreen: add IDirectFBScreen::GetVSyncCount()
+  + directfb.h: add a DVO 656 'connector'
+  + dfblayer: allow to set layer position and size using command line
+  + dfbinspector: add DSPF_AVYU and DSPF_VYU pixelformats
+- [Delete patch: DirectFB-1.4.3.STM2009.12.11-CLUT8_fix.patch] integrated upstream
+
+* Fri Jan 29 2010 Andr Draszik <andre.draszik@st.com> 1.4.3.STM2009.12.11-4
+- [Add patch: DirectFB-1.4.3.STM2009.12.11-CLUT8_fix.patch] fix CLUT8 issue in
+  software renderer
+
+* Mon Jan 11 2010 Andr Draszik <andre.draszik@st.com> 1.4.3.STM2009.12.11-3
+- [Spec] unify multi app and single app spec files
+
+* Wed Dec 16 2009 Andr Draszik <andre.draszik@st.com> 1.4.3.STM2009.12.11-2
+- [Add patch: DirectFB-1.4.3.STM2009.12.11-autoconf259.patch] so as to enable
+  successful build on arm with old autotools in STLinux-2.3
+
+* Fri Dec 11 2009 Andr Draszik <andre.draszik@st.com> 1.4.3.STM2009.12.11-1
+- [update: 2009-12.11] update to DirectFB 1.4.3
+- misc: use pkgconfig to detect X11
+- misc: surface: replace GetFramebufferOffset() with GetPhysicalAddress()
+- stgfx2: pick up all updates from 1.0.1 branch
+- stgfx2: release surface pools on shutdown
+- [Bugzilla: 7776] stgfx2: cleanup draw/blitting wrt flags
+- stgfx: release surface pools on shutdown
+- [Bugzilla: 7570] jpeg: implement decimated decode for software JPEG decoder
+- [Bugzilla: 7636] jpeg: implement raw libjpeg decode for possible HW acceleration (using stgfx2)
+
+* Fri Aug 21 2009 Andr Draszik <andre.draszik@st.com> 1.4.1.STM2009.08.21-1
+- [update: 2009-08-21]
+  allow source widths and heights < 1.0 (but > 0) in BatchStretchBlit()
+
+* Tue Aug 18 2009 Andr Draszik <andre.draszik@st.com> 1.4.1.STM2009.08.18-1
+- [update: 2009-08-18]
+
+* Wed Jul 29 2009 Andr Draszik <andre.draszik@st.com> 1
+  Tue Jul 29 2009 --> Tue Jul 28 2009 or Wed Jul 29 2009 or Tue Aug 04 2009 or ....
+- [update: 1.4.1] new upstream version with all the STM patches
diff -Naur DirectFB-1.7.7/src/core/core.c DirectFB-1.7.7.stm/src/core/core.c
--- DirectFB-1.7.7/src/core/core.c	2015-02-01 20:36:12.000000000 +0100
+++ DirectFB-1.7.7.stm/src/core/core.c	2015-05-15 18:43:40.189507078 +0200
@@ -1349,7 +1349,7 @@
 {
      CoreDFBShared *shared;
 
-     D_ASSUME( core != NULL );
+//     D_ASSUME( core != NULL );
 
      if (!core)
           core = core_dfb;
@@ -1368,7 +1368,7 @@
 {
      CoreDFBShared *shared;
 
-     D_ASSUME( core != NULL );
+//     D_ASSUME( core != NULL );
 
      if (!core)
           core = core_dfb;
@@ -1737,7 +1737,7 @@
      dfb_gfx_cleanup();
 
      while (loops--) {
-          fusion_dispatch( core->world, 16384 );
+          fusion_dispatch( core->world, FUSION_MESSAGE_SIZE );
 
           ret = dfb_core_wait_all( core, 10000 );
           if (ret == DFB_OK)
diff -Naur DirectFB-1.7.7/src/core/CoreSurfaceAllocation.flux DirectFB-1.7.7.stm/src/core/CoreSurfaceAllocation.flux
--- DirectFB-1.7.7/src/core/CoreSurfaceAllocation.flux	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7.stm/src/core/CoreSurfaceAllocation.flux	2015-05-15 18:43:40.189507078 +0200
@@ -0,0 +1,40 @@
+interface {
+	name        ISurfaceAllocation
+	version     1.0
+	object      CoreSurfaceAllocation
+
+
+        method {
+               name	Update
+
+               arg {
+                       name        region
+                       direction   input
+                       type        struct
+                       typename    DFBRegion
+                       optional    yes
+               }
+        }
+
+
+        method {
+               name	Updated
+
+               arg {
+                       name        updates
+                       direction   input
+                       type        struct
+                       typename    DFBBox
+                       optional    yes
+                       count       num_updates
+               }
+
+               arg {
+                       name        num_updates
+                       direction   input
+                       type        int
+                       typename    u32
+               }
+        }
+}
+
diff -Naur DirectFB-1.7.7/src/core/CoreSurfaceAllocation_includes.h DirectFB-1.7.7.stm/src/core/CoreSurfaceAllocation_includes.h
--- DirectFB-1.7.7/src/core/CoreSurfaceAllocation_includes.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7.stm/src/core/CoreSurfaceAllocation_includes.h	2015-05-15 18:43:40.189507078 +0200
@@ -0,0 +1,30 @@
+#include "CoreDFB_includes.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#include <core/surface.h>
+#include <core/surface_allocation.h>
+
+
+static __inline__ DirectResult
+CoreSurfaceAllocation_Call( CoreSurfaceAllocation *allocation,
+                            FusionCallExecFlags    flags,
+                            int                    call_arg,
+                            void                  *ptr,
+                            unsigned int           length,
+                            void                  *ret_ptr,
+                            unsigned int           ret_size,
+                            unsigned int          *ret_length )
+{
+     return fusion_call_execute3( &allocation->call,
+                                  (FusionCallExecFlags)(dfb_config->call_nodirect | flags),
+                                  call_arg, ptr, length, ret_ptr, ret_size, ret_length );
+}
+
+#ifdef __cplusplus
+}
+#endif
+
diff -Naur DirectFB-1.7.7/src/core/CoreSurfaceAllocation_real.cpp DirectFB-1.7.7.stm/src/core/CoreSurfaceAllocation_real.cpp
--- DirectFB-1.7.7/src/core/CoreSurfaceAllocation_real.cpp	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7.stm/src/core/CoreSurfaceAllocation_real.cpp	2015-05-15 18:43:40.189507078 +0200
@@ -0,0 +1,110 @@
+/*
+   (c) Copyright 2001-2011  The world wide DirectFB Open Source Community (directfb.org)
+   (c) Copyright 2000-2004  Convergence (integrated media) GmbH
+
+   All rights reserved.
+
+   Written by Denis Oliver Kropp <dok@directfb.org>,
+              Andreas Hundt <andi@fischlustig.de>,
+              Sven Neumann <neo@directfb.org>,
+              Ville Syrjl <syrjala@sci.fi> and
+              Claudio Ciccani <klan@users.sf.net>.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+
+#include <directfb.h>
+
+
+extern "C" {
+#include <direct/debug.h>
+#include <direct/mem.h>
+#include <direct/messages.h>
+}
+
+#include <direct/ToString.h>
+
+#include <core/CoreSurfaceAllocation.h>
+
+
+D_DEBUG_DOMAIN( DirectFB_CoreSurfaceAllocation, "DirectFB/CoreSurfaceAllocation", "DirectFB CoreSurfaceAllocation" );
+
+/*********************************************************************************************************************/
+
+namespace DirectFB {
+
+
+DFBResult
+ISurfaceAllocation_Real::Update(
+                   const DFBRegion                              *region
+                   )
+{
+     D_DEBUG_AT( DirectFB_CoreSurfaceAllocation, "ISurfaceAllocation_Real::%s( region %p )\n", __FUNCTION__, region );
+
+     D_UNIMPLEMENTED();
+
+     return DFB_UNIMPLEMENTED;
+}
+
+DFBResult
+ISurfaceAllocation_Real::Updated( const DFBBox *updates,
+                                  u32           num_updates )
+{
+     DFBResult          ret;
+     CoreSurfaceBuffer *buffer;
+
+     D_DEBUG_AT( DirectFB_CoreSurfaceAllocation, "ISurfaceAllocation_Real::%s( obj %p, updates %p, num %u )\n", __FUNCTION__, obj, updates, num_updates );
+
+     ret = (DFBResult) fusion_object_get( core->shared->surface_buffer_pool, obj->buffer_id, (FusionObject**) &buffer );
+     if (ret && ret != DFB_DEAD)
+          return ret;
+
+     if (ret == DFB_DEAD) {
+          D_DEBUG_AT( DirectFB_CoreSurfaceAllocation, "  -> dead object!\n" );
+     }
+     else {
+          if (obj->buffer) {
+               D_ASSERT( obj->buffer == buffer );
+          
+               D_DEBUG_AT( DirectFB_CoreSurfaceAllocation, "  <- buffer  %s\n", *ToString<CoreSurfaceBuffer>( *buffer ) );
+               D_DEBUG_AT( DirectFB_CoreSurfaceAllocation, "  <- written %p\n", buffer->written );
+               D_DEBUG_AT( DirectFB_CoreSurfaceAllocation, "  <- read    %p\n", buffer->read );
+               D_DEBUG_AT( DirectFB_CoreSurfaceAllocation, "  <- serial  %lu (this %lu)\n", buffer->serial.value, obj->serial.value );
+               
+               direct_serial_increase( &buffer->serial );
+               
+               direct_serial_copy( &obj->serial, &buffer->serial );
+               
+               buffer->written = obj;
+               buffer->read    = NULL;
+               
+               D_DEBUG_AT( DirectFB_CoreSurfaceAllocation, "  -> serial  %lu\n", buffer->serial.value );
+          }
+          else {
+               D_DEBUG_AT( DirectFB_CoreSurfaceAllocation, "  -> already decoupled!\n" );
+          }
+
+          dfb_surface_buffer_unref( buffer );
+     }
+
+     return DFB_OK;
+}
+
+
+}
+
diff -Naur DirectFB-1.7.7/src/core/shared_surface_pool.c DirectFB-1.7.7.stm/src/core/shared_surface_pool.c
--- DirectFB-1.7.7/src/core/shared_surface_pool.c	2013-12-19 01:16:24.000000000 +0100
+++ DirectFB-1.7.7.stm/src/core/shared_surface_pool.c	2015-05-15 18:43:40.193511078 +0200
@@ -44,6 +44,8 @@
 
 #include <misc/conf.h>
 
+D_DEBUG_DOMAIN( Core_SharedSurfacePool, "Core/SharedSurfacePool", "Core Shared Surface Pool" );
+
 /**********************************************************************************************************************/
 
 typedef struct {
@@ -94,6 +96,8 @@
      SharedPoolData      *data  = pool_data;
      SharedPoolLocalData *local = pool_local;
 
+     D_DEBUG_AT( Core_SharedSurfacePool, "%s()\n", __FUNCTION__ );
+
      D_MAGIC_ASSERT( pool, CoreSurfacePool );
      D_ASSERT( ret_desc != NULL );
 
@@ -145,6 +149,8 @@
      SharedPoolData       *data  = pool_data;
      SharedAllocationData *alloc = alloc_data;
 
+     D_DEBUG_AT( Core_SharedSurfacePool, "%s()\n", __FUNCTION__ );
+
      D_MAGIC_ASSERT( pool, CoreSurfacePool );
      D_MAGIC_ASSERT( buffer, CoreSurfaceBuffer );
 
@@ -163,6 +169,8 @@
           dfb_surface_calc_buffer_size( surface, dfb_config->system_surface_align_pitch, 0,
                                         &alloc->pitch, &alloc->size );
 
+          D_DEBUG_AT( Core_SharedSurfacePool, "Allocating %d bytes for allocation 0x%p\n", alloc->size + dfb_config->system_surface_align_base, alloc );
+
           alloc->addr = SHMALLOC( data->shmpool, alloc->size + dfb_config->system_surface_align_base );
           if ( !alloc->addr )
                return D_OOSHM();
@@ -180,6 +188,8 @@
 
           dfb_surface_calc_buffer_size( surface, 8, 0, &alloc->pitch, &alloc->size );
 
+          D_DEBUG_AT( Core_SharedSurfacePool, "Allocating %d bytes for allocation 0x%p\n", alloc->size, alloc );
+
           alloc->addr = SHMALLOC( data->shmpool, alloc->size );
           if (!alloc->addr)
                return D_OOSHM();
@@ -204,8 +214,12 @@
      SharedPoolData       *data  = pool_data;
      SharedAllocationData *alloc = alloc_data;
 
+     D_DEBUG_AT( Core_SharedSurfacePool, "%s()\n", __FUNCTION__ );
+
      D_MAGIC_ASSERT( pool, CoreSurfacePool );
 
+     D_DEBUG_AT( Core_SharedSurfacePool, "Freeing %d bytes of allocation 0x%p\n", alloc->size, alloc );
+
      SHFREE( data->shmpool, alloc->addr );
 
      return DFB_OK;
@@ -221,6 +235,8 @@
 {
      SharedAllocationData *alloc = alloc_data;
 
+     D_DEBUG_AT( Core_SharedSurfacePool, "%s()\n", __FUNCTION__ );
+
      D_MAGIC_ASSERT( pool, CoreSurfacePool );
      D_MAGIC_ASSERT( allocation, CoreSurfaceAllocation );
      D_MAGIC_ASSERT( lock, CoreSurfaceBufferLock );
@@ -244,6 +260,8 @@
               void                  *alloc_data,
               CoreSurfaceBufferLock *lock )
 {
+     D_DEBUG_AT( Core_SharedSurfacePool, "%s()\n", __FUNCTION__ );
+
      D_MAGIC_ASSERT( pool, CoreSurfacePool );
      D_MAGIC_ASSERT( allocation, CoreSurfaceAllocation );
      D_MAGIC_ASSERT( lock, CoreSurfaceBufferLock );
diff -Naur DirectFB-1.7.7/src/core/surface_allocation.cpp DirectFB-1.7.7.stm/src/core/surface_allocation.cpp
--- DirectFB-1.7.7/src/core/surface_allocation.cpp	2015-02-01 20:36:12.000000000 +0100
+++ DirectFB-1.7.7.stm/src/core/surface_allocation.cpp	2015-05-15 18:43:40.197515079 +0200
@@ -326,6 +326,15 @@
                }
                break;
 
+          case DSPF_NV24:
+               for (i=0; i<config->size.h; i++) {
+                    direct_memcpy( dst, src,
+                                   DFB_BYTES_PER_LINE( config->format, config->size.w ) * 2 );
+                    src += srcpitch;
+                    dst += dstpitch;
+               }
+               break;
+
           case DSPF_YUV444P:
                for (i=0; i<config->size.h*2; i++) {
                     direct_memcpy( dst, src,
diff -Naur DirectFB-1.7.7/src/core/surface_buffer.c DirectFB-1.7.7.stm/src/core/surface_buffer.c
--- DirectFB-1.7.7/src/core/surface_buffer.c	2015-02-01 20:36:12.000000000 +0100
+++ DirectFB-1.7.7.stm/src/core/surface_buffer.c	2015-05-15 18:55:52.425034186 +0200
@@ -707,6 +707,8 @@
      CoreSurface       *surface;
      CorePalette       *palette = NULL;
 
+     bool               IsYCbCrMb = false;
+
      D_DEBUG_AT( Core_SurfBuffer, "%s( %p, %p, %p )\n", __FUNCTION__, buffer, directory, prefix );
 
      D_MAGIC_ASSERT( buffer, CoreSurfaceBuffer );
@@ -717,6 +719,7 @@
 
      /* Check pixel format. */
      switch (buffer->format) {
+          case DSPF_LUT4:
           case DSPF_LUT8:
           case DSPF_ALUT8:
                palette = surface->palette;
@@ -754,6 +757,7 @@
           case DSPF_RGB332:
           case DSPF_RGB16:
           case DSPF_RGB24:
+          case DSPF_BGR24:
           case DSPF_RGB32:
           case DSPF_YUY2:
           case DSPF_UYVY:
@@ -763,10 +767,16 @@
           case DSPF_RGB555:
           case DSPF_BGR555:
           case DSPF_YUV444P:
+          case DSPF_NV24:
           case DSPF_VYU:
                rgb   = true;
                break;
 
+          case DSPF_NV12MB:
+          case DSPF_NV16MB:
+               IsYCbCrMb = true;
+               break;
+
 
           default:
                D_ERROR( "DirectFB/core/surfaces: surface dump for format "
@@ -845,6 +855,23 @@
           }
      }
 
+     /* Create a .gam file for Omega2 MB buffers. */
+     if (IsYCbCrMb) {
+          if (prefix)
+               snprintf( filename, len, "%s/%s_%04d.gam", directory, prefix, num );
+          else
+               snprintf( filename, len, "%s.gam", directory );
+
+          fd_p = open( filename, O_EXCL | O_CREAT | O_WRONLY, 0644 );
+          if (fd_p < 0) {
+               D_PERROR("DirectFB/core/surfaces: "
+                        "could not open %s!\n", filename);
+               if (palette)
+                    dfb_palette_unref( palette );
+               return DFB_IO;
+          }
+     }
+
 #ifdef USE_ZLIB
      if (rgb)
           gz_p = gzdopen( fd_p, "wb" );
@@ -880,6 +907,40 @@
 	 }
      }
 
+     /* Write the .gam header. */
+     if (IsYCbCrMb) {
+          struct GamPictureHeader {
+               uint16_t header_size;
+               uint16_t signature;
+               uint16_t type;
+               uint16_t properties;
+               uint32_t pictureWidth;
+               uint32_t pictureHeight;
+               uint32_t lumaSize;
+               uint32_t chromaSize;
+          } header;
+
+          unsigned int chromaHeight = surface->config.size.h;
+          if (buffer->format == DSPF_NV12MB)
+               chromaHeight >>= 1;
+
+          header.header_size = 0x6;
+          header.signature = (buffer->format == DSPF_NV12MB) ? 0x420f : 0x422f;
+          header.type = (buffer->format == DSPF_NV12MB) ? 0x94 : 0x95;
+          header.properties = 0x10;
+          header.pictureWidth = surface->config.size.w;
+          header.pictureHeight = surface->config.size.h;
+          header.lumaSize = surface->config.size.w * surface->config.size.h;
+          header.chromaSize = surface->config.size.w * chromaHeight;
+
+#ifdef USE_ZLIB
+          gzwrite( gz_p, &header, sizeof(header) );
+#else
+          res = write( fd_p, &header, sizeof(header) );
+          (void)res;
+#endif
+     }
+
      /* Write the pixmap (and graymap) data. */
      for (i=0; i<surface->config.size.h; i++) {
           int n3;
@@ -929,6 +990,18 @@
                          buf_p[n3+2] = palette->entries[src8[n]].b;
                     }
                }
+               else if (buffer->format == DSPF_LUT4) {
+                    for (n=0, n3=0; n<(surface->config.size.w>>1); n+=1, n3+=6) {
+                         int i = src8[n] & 0xf; /* 4 lsbs */
+                         buf_p[n3+0] = palette->entries[i].r;
+                         buf_p[n3+1] = palette->entries[i].g;
+                         buf_p[n3+2] = palette->entries[i].b;
+                         i = src8[n] >> 4; /* 4 msbs */
+                         buf_p[n3+3] = palette->entries[i].r;
+                         buf_p[n3+4] = palette->entries[i].g;
+                         buf_p[n3+5] = palette->entries[i].b;
+                    }
+               }
                else
                     dfb_convert_to_rgb24( buffer->format,
                                           srces[0], pitches[0],
@@ -952,6 +1025,14 @@
                     for (n=0; n<surface->config.size.w; n++)
                          buf_g[n] = palette->entries[src8[n]].a;
                }
+               else if (buffer->format == DSPF_LUT4) {
+                    for (n=0; n<(surface->config.size.w>>1); n++) {
+                         int i = src8[n] & 0xf; /* 4 lsbs */
+                         buf_g[2 * n] = palette->entries[i].a;
+                         i = src8[n] >> 4; /* 4 msbs */
+                         buf_g[2 * n + 1] = palette->entries[i].a;
+                    }
+               }
                else
                     dfb_convert_to_a8( buffer->format, srces[0], pitches[0], surface->config.size.h,
                                        buf_g, surface->config.size.w, surface->config.size.w, 1 );
@@ -962,6 +1043,33 @@
                (void)res;
 #endif
           }
+
+          /* Write luma data. */
+          if (IsYCbCrMb) {
+#ifdef USE_ZLIB
+               gzwrite( gz_p, srces[0], surface->config.size.w );
+#else
+               res = write( fd_p, srces[0], surface->config.size.w );
+               (void)res;
+#endif
+          }
+     }
+
+     /* Write chroma data. */
+     if (IsYCbCrMb) {
+          unsigned int chroma_height = surface->config.size.h;
+          if (buffer->format == DSPF_NV12MB)
+               chroma_height >>= 1;
+#ifdef USE_ZLIB
+          gzwrite( gz_p, 
+                       addr + pitch * surface->config.size.h,
+                       pitch * chroma_height );
+#else
+          res = write( fd_p,
+                       addr + pitch * surface->config.size.h,
+                       pitch * chroma_height );
+          (void)res;
+#endif
      }
 
      /* Release the palette. */
@@ -984,6 +1092,10 @@
      if (alpha && !raw)
           close( fd_g );
 
+     /* Close the .gam file. */
+     if (IsYCbCrMb)
+          close( fd_p );
+
      return DFB_OK;
 }
 
diff -Naur DirectFB-1.7.7/src/core/surface.c DirectFB-1.7.7.stm/src/core/surface.c
--- DirectFB-1.7.7/src/core/surface.c	2015-02-01 20:36:12.000000000 +0100
+++ DirectFB-1.7.7.stm/src/core/surface.c	2015-05-15 18:43:40.197515079 +0200
@@ -1396,6 +1396,7 @@
      char                   head[30];
      bool                   rgb   = false;
      bool                   alpha = false;
+     bool                   IsYCbCrMb = false;
 #ifdef USE_ZLIB
      gzFile                 gz_p = NULL, gz_g = NULL;
      static const char     *gz_ext = ".gz";
@@ -1440,6 +1441,7 @@
 
      /* Check pixel format. */
      switch (lock.buffer->format) {
+          case DSPF_LUT4:
           case DSPF_LUT8:
                palette = surface->palette;
 
@@ -1479,6 +1481,7 @@
           case DSPF_RGB332:
           case DSPF_RGB16:
           case DSPF_RGB24:
+          case DSPF_BGR24:
           case DSPF_RGB32:
           case DSPF_YUY2:
           case DSPF_UYVY:
@@ -1488,10 +1491,16 @@
           case DSPF_RGB555:
           case DSPF_BGR555:
           case DSPF_YUV444P:
+          case DSPF_NV24:
           case DSPF_VYU:
                rgb   = true;
                break;
 
+          case DSPF_NV12MB:
+          case DSPF_NV16MB:
+               IsYCbCrMb = true;
+               break;
+
 
           default:
                D_ERROR( "DirectFB/core/surfaces: surface dump for format "
@@ -1573,6 +1582,24 @@
           }
      }
 
+     /* Create a .gam file for Omega2 MB buffers. */
+     if (IsYCbCrMb) {
+          if (prefix)
+               snprintf( filename, len, "%s/%s_%04d.gam", path, prefix, num );
+          else
+               snprintf( filename, len, "%s.gam", path );
+
+          fd_p = open( filename, O_EXCL | O_CREAT | O_WRONLY, 0644 );
+          if (fd_p < 0) {
+               D_PERROR("DirectFB/core/surfaces: "
+                        "could not open %s!\n", filename);
+               dfb_surface_buffer_unlock( &lock );
+               if (palette)
+                    dfb_palette_unref( palette );
+               return DFB_IO;
+          }
+     }
+
 #ifdef USE_ZLIB
      if (rgb)
           gz_p = gzdopen( fd_p, "wb" );
@@ -1603,6 +1630,35 @@
 #endif
      }
 
+     /* Write the .gam header. */
+     if (IsYCbCrMb) {
+          struct GamPictureHeader {
+               uint16_t header_size;
+               uint16_t signature;
+               uint16_t type;
+               uint16_t properties;
+               uint32_t pictureWidth;
+               uint32_t pictureHeight;
+               uint32_t lumaSize;
+               uint32_t chromaSize;
+          } header;
+
+          unsigned int chromaHeight = surface->config.size.h;
+          if (lock.buffer->format == DSPF_NV12MB)
+               chromaHeight >>= 1;
+
+          header.header_size = 0x6;
+          header.signature = (lock.buffer->format == DSPF_NV12MB) ? 0x420f : 0x422f;
+          header.type = (lock.buffer->format == DSPF_NV12MB) ? 0x94 : 0x95;
+          header.properties = 0x10;
+          header.pictureWidth = surface->config.size.w;
+          header.pictureHeight = surface->config.size.h;
+          header.lumaSize = surface->config.size.w * surface->config.size.h;
+          header.chromaSize = surface->config.size.w * chromaHeight;
+
+          res = write( fd_p, &header, sizeof(header) );
+     }
+
      /* Write the pixmap (and graymap) data. */
      for (i=0; i<surface->config.size.h; i++) {
           int n3;
@@ -1627,6 +1683,18 @@
                          buf_p[n3+2] = palette->entries[src8[n]].b;
                     }
                }
+               else if (lock.buffer->format == DSPF_LUT4) {
+                    for (n=0, n3=0; n<(surface->config.size.w>>1); n+=1, n3+=6) {
+                         int i = src8[n] & 0xf; /* 4 lsbs */
+                         buf_p[n3+0] = palette->entries[i].r;
+                         buf_p[n3+1] = palette->entries[i].g;
+                         buf_p[n3+2] = palette->entries[i].b;
+                         i = src8[n] >> 4; /* 4 msbs */
+                         buf_p[n3+3] = palette->entries[i].r;
+                         buf_p[n3+4] = palette->entries[i].g;
+                         buf_p[n3+5] = palette->entries[i].b;
+                    }
+               }
                else
                     dfb_convert_to_rgb24( lock.buffer->format,
                                           srces[0], pitches[0],
@@ -1648,6 +1716,14 @@
                     for (n=0; n<surface->config.size.w; n++)
                          buf_g[n] = palette->entries[src8[n]].a;
                }
+               else if (lock.buffer->format == DSPF_LUT4) {
+                    for (n=0; n<(surface->config.size.w>>1); n++) {
+                         int i = src8[n] & 0xf; /* 4 lsbs */
+                         buf_g[2 * n] = palette->entries[i].a;
+                         i = src8[n] >> 4; /* 4 msbs */
+                         buf_g[2 * n + 1] = palette->entries[i].a;
+                    }
+               }
                else
                     dfb_convert_to_a8( lock.buffer->format, srces[0], pitches[0], surface->config.size.h,
                                        buf_g, surface->config.size.w, surface->config.size.w, 1 );
@@ -1657,6 +1733,20 @@
                res = write( fd_g, buf_g, surface->config.size.w );
 #endif
           }
+
+          /* Write luma data. */
+          if (IsYCbCrMb)
+               res = write( fd_p, src8, surface->config.size.w );
+     }
+
+     /* Write chroma data. */
+     if (IsYCbCrMb) {
+          unsigned int chroma_height = surface->config.size.h;
+          if (lock.buffer->format == DSPF_NV12MB)
+               chroma_height >>= 1;
+          res = write( fd_p,
+                       lock.addr + lock.pitch * surface->config.size.h,
+                       lock.pitch * chroma_height );
      }
 
      /* Unlock the surface buffer. */
@@ -1682,6 +1772,10 @@
      if (alpha)
           close( fd_g );
 
+     /* Close the .gam file. */
+     if (IsYCbCrMb)
+          close( fd_p );
+
      return DFB_OK;
 }
 
diff -Naur DirectFB-1.7.7/src/core/surface.h DirectFB-1.7.7.stm/src/core/surface.h
--- DirectFB-1.7.7/src/core/surface.h	2015-02-01 20:36:12.000000000 +0100
+++ DirectFB-1.7.7.stm/src/core/surface.h	2015-05-15 18:43:40.197515079 +0200
@@ -501,9 +501,9 @@
      D_ASSERT( data != NULL );
      D_ASSERT( pitch > 0 );
      D_ASSERT( x >= 0 );
-     D_ASSERT( x < config->size.w );
+     D_ASSERT( config->size.w && x < config->size.w );
      D_ASSERT( y >= 0 );
-     D_ASSERT( y < config->size.h );
+     D_ASSERT( config->size.h && y < config->size.h );
      D_ASSERT( !num
                || (num && pointers && pitches) );
 
diff -Naur DirectFB-1.7.7/src/core/surface_pool.c DirectFB-1.7.7.stm/src/core/surface_pool.c
--- DirectFB-1.7.7/src/core/surface_pool.c	2015-02-09 18:16:46.000000000 +0100
+++ DirectFB-1.7.7.stm/src/core/surface_pool.c	2015-05-15 18:43:40.201519079 +0200
@@ -876,7 +876,7 @@
      fusion_vector_foreach (allocation, i, pool->allocs) {
           CORE_SURFACE_ALLOCATION_ASSERT( allocation );
 
-          if (allocation->flags & CSALF_MUCKOUT) {
+          if (allocation->buffer && (allocation->flags & CSALF_MUCKOUT)) {
                CoreSurface       *alloc_surface;
                CoreSurfaceBuffer *alloc_buffer;
 
diff -Naur DirectFB-1.7.7/src/core/system.h DirectFB-1.7.7.stm/src/core/system.h
--- DirectFB-1.7.7/src/core/system.h	2013-12-19 01:16:24.000000000 +0100
+++ DirectFB-1.7.7.stm/src/core/system.h	2015-05-15 18:43:40.201519079 +0200
@@ -56,6 +56,7 @@
      CORE_CARE1,
      CORE_ANDROID,
      CORE_EGL,
+     CORE_STMFBDEV,
      CORE_DRMKMS
 } CoreSystemType;
 
diff -Naur DirectFB-1.7.7/src/display/idirectfbsurface.c DirectFB-1.7.7.stm/src/display/idirectfbsurface.c
--- DirectFB-1.7.7/src/display/idirectfbsurface.c	2015-02-01 20:45:25.000000000 +0100
+++ DirectFB-1.7.7.stm/src/display/idirectfbsurface.c	2015-05-15 18:43:40.205523079 +0200
@@ -3808,7 +3808,6 @@
 
      if (notification->flags & CSNF_DESTROY) {
           if (data->surface) {
-               D_WARN( "IDirectFBSurface surface destroyed" );
                data->surface = NULL;
           }
           return RS_REMOVE;
diff -Naur DirectFB-1.7.7/src/display/idirectfbsurface.c.orig DirectFB-1.7.7.stm/src/display/idirectfbsurface.c.orig
--- DirectFB-1.7.7/src/display/idirectfbsurface.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7.stm/src/display/idirectfbsurface.c.orig	2015-05-15 18:43:05.042393969 +0200
@@ -0,0 +1,3911 @@
+/*
+   (c) Copyright 2012-2013  DirectFB integrated media GmbH
+   (c) Copyright 2001-2013  The world wide DirectFB Open Source Community (directfb.org)
+   (c) Copyright 2000-2004  Convergence (integrated media) GmbH
+
+   All rights reserved.
+
+   Written by Denis Oliver Kropp <dok@directfb.org>,
+              Andreas Shimokawa <andi@directfb.org>,
+              Marek Pikarski <mass@directfb.org>,
+              Sven Neumann <neo@directfb.org>,
+              Ville Syrjl <syrjala@sci.fi> and
+              Claudio Ciccani <klan@users.sf.net>.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+
+
+#include <config.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <alloca.h>
+
+#include <math.h>
+
+
+#include <directfb.h>
+
+#include <core/core.h>
+#include <core/coredefs.h>
+#include <core/coretypes.h>
+
+#include <core/gfxcard.h>
+#include <core/fonts.h>
+#include <core/state.h>
+#include <core/palette.h>
+#include <core/surface.h>
+#include <core/surface_buffer.h>
+
+#include <core/CoreDFB.h>
+#include <core/CoreGraphicsState.h>
+#include <core/CoreSurface.h>
+#include <core/CoreSurfaceClient.h>
+#include <core/Debug.h>
+
+#include <media/idirectfbfont.h>
+
+#include <display/idirectfbsurface.h>
+#include <display/idirectfbpalette.h>
+
+#include <input/idirectfbinputbuffer.h>
+
+#include <misc/util.h>
+
+#include <direct/debug.h>
+#include <direct/interface.h>
+#include <direct/mem.h>
+#include <direct/memcpy.h>
+#include <direct/messages.h>
+#include <direct/util.h>
+
+#include <gfx/convert.h>
+#include <gfx/util.h>
+
+
+D_DEBUG_DOMAIN( Surface,         "IDirectFBSurface",         "IDirectFBSurface Interface" );
+D_DEBUG_DOMAIN( Surface_Updates, "IDirectFBSurface/Updates", "IDirectFBSurface Interface Updates" );
+
+/**********************************************************************************************************************/
+
+static ReactionResult IDirectFBSurface_listener( const void *msg_data, void *ctx );
+
+/**********************************************************************************************************************/
+
+static DFBResult
+register_prealloc( IDirectFBSurface_data *data )
+{
+     DFBResult     ret;
+     unsigned int  i;
+     CoreSurface  *surface = data->surface;
+
+     if (surface->config.caps & DSCAPS_TRIPLE)
+          data->memory_permissions_count = 3;
+     else if (surface->config.caps & DSCAPS_DOUBLE)
+          data->memory_permissions_count = 2;
+     else
+          data->memory_permissions_count = 1;
+
+     for (i=0; i<data->memory_permissions_count; i++) {
+          ret = dfb_core_memory_permissions_add( data->core, CMPF_READ | CMPF_WRITE,
+                                                 surface->config.preallocated[i].addr,
+                                                 surface->config.preallocated[i].pitch *
+                                                 DFB_PLANE_MULTIPLY( surface->config.format, surface->config.size.h ),
+                                                 &data->memory_permissions[i] );
+          if (ret)
+               goto error;
+     }
+
+     return DFB_OK;
+
+
+error:
+     for (--i; i>=0; i--)
+          dfb_core_memory_permissions_remove( data->core, data->memory_permissions[i] );
+
+     data->memory_permissions_count = 0;
+
+     return ret;
+}
+
+static DFBResult
+unregister_prealloc( IDirectFBSurface_data *data )
+{
+     unsigned int i;
+
+     for (i=0; i<data->memory_permissions_count; i++)
+          dfb_core_memory_permissions_remove( data->core, data->memory_permissions[i] );
+
+     data->memory_permissions_count = 0;
+
+     return DFB_OK;
+}
+
+/**********************************************************************************************************************/
+
+void
+IDirectFBSurface_Destruct( IDirectFBSurface *thiz )
+{
+     IDirectFBSurface_data *data;
+     IDirectFBSurface      *parent;
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     D_ASSERT( thiz != NULL );
+
+     data = thiz->priv;
+
+     D_ASSERT( data != NULL );
+     D_ASSERT( data->children_data == NULL );
+
+     D_DEBUG_AT( Surface, "  -> flushing graphics state...\n" );
+
+     if (data->memory_permissions_count) {
+          // FIXME: currently just enough for df_dok
+          CoreGraphicsStateClient_FlushCurrent( 1 );
+
+          CoreDFB_Roundtrip( data->core );
+
+          unregister_prealloc( data );
+     }
+     else
+          CoreGraphicsStateClient_FlushCurrent( 0 );
+
+     if (data->surface_client) {
+          D_DEBUG_AT( Surface, "  -> releasing surface client...\n" );
+
+          dfb_surface_client_unref( data->surface_client );
+     }
+
+     parent = data->parent;
+     if (parent) {
+          IDirectFBSurface_data *parent_data;
+
+          D_MAGIC_ASSERT( (IAny*) parent, DirectInterface );
+
+          parent_data = parent->priv;
+          D_ASSERT( parent_data != NULL );
+
+          pthread_mutex_lock( &parent_data->children_lock );
+
+          direct_list_remove( &parent_data->children_data, &data->link );
+
+          pthread_mutex_unlock( &parent_data->children_lock );
+     }
+
+     if (data->surface)
+          dfb_surface_detach( data->surface, &data->reaction );
+
+     CoreGraphicsStateClient_Deinit( &data->state_client );
+
+     dfb_state_stop_drawing( &data->state );
+
+     dfb_state_set_destination( &data->state, NULL );
+     dfb_state_set_source( &data->state, NULL );
+     dfb_state_set_source_mask( &data->state, NULL );
+     dfb_state_set_source2( &data->state, NULL );
+
+     dfb_state_destroy( &data->state );
+
+     if (data->font) {
+          D_DEBUG_AT( Surface, "  -> releasing font...\n" );
+
+          data->font->Release( data->font );
+     }
+
+     if (data->surface) {
+          if (data->locked) {
+               D_DEBUG_AT( Surface, "  -> unlocking buffer...\n" );
+
+               dfb_surface_unlock_buffer( data->surface, &data->lock );
+          }
+
+          D_DEBUG_AT( Surface, "  -> releasing surface...\n" );
+
+          dfb_surface_unref( data->surface );
+     }
+
+     pthread_mutex_destroy( &data->children_lock );
+
+     direct_waitqueue_deinit( &data->back_buffer_wq );
+     direct_mutex_deinit( &data->back_buffer_lock );
+
+     direct_mutex_deinit( &data->surface_client_lock );
+
+     DIRECT_DEALLOCATE_INTERFACE( thiz );
+
+     if (parent) {
+          D_DEBUG_AT( Surface, "  -> releasing parent...\n" );
+
+          parent->Release( parent );
+     }
+
+     D_DEBUG_AT( Surface, "  -> done.\n" );
+}
+
+static DirectResult
+IDirectFBSurface_AddRef( IDirectFBSurface *thiz )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     data->ref++;
+
+     return DFB_OK;
+}
+
+static DirectResult
+IDirectFBSurface_Release( IDirectFBSurface *thiz )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     if (--data->ref == 0)
+          IDirectFBSurface_Destruct( thiz );
+
+     return DFB_OK;
+}
+
+
+static DFBResult
+IDirectFBSurface_GetPixelFormat( IDirectFBSurface      *thiz,
+                                 DFBSurfacePixelFormat *format )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     if (!data->surface)
+          return DFB_DESTROYED;
+
+     if (!format)
+          return DFB_INVARG;
+
+     *format = data->surface->config.format;
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_GetColorSpace( IDirectFBSurface      *thiz,
+                                DFBSurfaceColorSpace  *colorspace )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     if (!data->surface)
+          return DFB_DESTROYED;
+
+     if (!colorspace)
+          return DFB_INVARG;
+
+     *colorspace = data->surface->config.colorspace;
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_GetAccelerationMask( IDirectFBSurface    *thiz,
+                                      IDirectFBSurface    *source,
+                                      DFBAccelerationMask *ret_mask )
+{
+     DFBResult           ret;
+     DFBAccelerationMask mask;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     if (!data->surface)
+          return DFB_DESTROYED;
+
+     if (!ret_mask)
+          return DFB_INVARG;
+
+     if (source) {
+          IDirectFBSurface_data *src_data = source->priv;
+
+          dfb_state_set_source( &data->state, src_data->surface );
+          dfb_state_set_source2( &data->state, data->surface ); // FIXME
+     }
+
+     ret = CoreGraphicsStateClient_GetAccelerationMask( &data->state_client, &mask );
+     if (ret)
+          return ret;
+
+     /* Check text rendering function */
+     if (data->font) {
+          IDirectFBFont_data *font_data = data->font->priv;
+
+          if (dfb_gfxcard_drawstring_check_state( font_data->font, &data->state, &data->state_client, DSTF_NONE ))
+               mask |= DFXL_DRAWSTRING;
+     }
+
+     *ret_mask = mask;
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_GetPosition( IDirectFBSurface *thiz,
+                          int              *x,
+                          int              *y )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     if (!x && !y)
+          return DFB_INVARG;
+
+     if (x)
+          *x = data->area.wanted.x;
+
+     if (y)
+          *y = data->area.wanted.y;
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_GetSize( IDirectFBSurface *thiz,
+                          int              *width,
+                          int              *height )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     if (!width && !height)
+          return DFB_INVARG;
+
+     if (width)
+          *width = data->area.wanted.w;
+
+     if (height)
+          *height = data->area.wanted.h;
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_GetVisibleRectangle( IDirectFBSurface *thiz,
+                                      DFBRectangle     *rect )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     if (!rect)
+          return DFB_INVARG;
+
+     rect->x = data->area.current.x - data->area.wanted.x;
+     rect->y = data->area.current.y - data->area.wanted.y;
+     rect->w = data->area.current.w;
+     rect->h = data->area.current.h;
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_GetCapabilities( IDirectFBSurface       *thiz,
+                                  DFBSurfaceCapabilities *caps )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     if (!caps)
+          return DFB_INVARG;
+
+     *caps = data->caps;
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_GetPalette( IDirectFBSurface  *thiz,
+                             IDirectFBPalette **interface )
+{
+     DFBResult         ret;
+     CoreSurface      *surface;
+     CorePalette      *core_palette;
+     IDirectFBPalette *palette;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     surface = data->surface;
+     if (!surface)
+          return DFB_DESTROYED;
+
+     if (!surface->palette)
+          return DFB_UNSUPPORTED;
+
+     if (!interface)
+          return DFB_INVARG;
+
+     ret = CoreSurface_GetPalette( surface, &core_palette );
+     if (ret)
+          return ret;
+
+     DIRECT_ALLOCATE_INTERFACE( palette, IDirectFBPalette );
+
+     ret = IDirectFBPalette_Construct( palette, core_palette, data->core );
+     if (ret)
+          goto out;
+
+     *interface = palette;
+
+out:
+     dfb_palette_unref( core_palette );
+
+     return ret;
+}
+
+static DFBResult
+IDirectFBSurface_SetPalette( IDirectFBSurface *thiz,
+                             IDirectFBPalette *palette )
+{
+     CoreSurface           *surface;
+     IDirectFBPalette_data *palette_data;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     surface = data->surface;
+     if (!surface)
+          return DFB_DESTROYED;
+
+     if (!palette)
+          return DFB_INVARG;
+
+     if (! DFB_PIXELFORMAT_IS_INDEXED( surface->config.format ))
+          return DFB_UNSUPPORTED;
+
+     palette_data = (IDirectFBPalette_data*) palette->priv;
+     if (!palette_data)
+          return DFB_DEAD;
+
+     if (!palette_data->palette)
+          return DFB_DESTROYED;
+
+     CoreSurface_SetPalette( surface, palette_data->palette );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_SetAlphaRamp( IDirectFBSurface *thiz,
+                               u8                a0,
+                               u8                a1,
+                               u8                a2,
+                               u8                a3 )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     if (!data->surface)
+          return DFB_DESTROYED;
+
+     CoreSurface_SetAlphaRamp( data->surface, a0, a1, a2, a3 );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_Lock( IDirectFBSurface *thiz,
+                       DFBSurfaceLockFlags flags,
+                       void **ret_ptr, int *ret_pitch )
+{
+     DFBResult              ret;
+     CoreSurfaceBufferRole  role   = CSBR_FRONT;
+     CoreSurfaceAccessFlags access = CSAF_NONE;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     if (!data->surface)
+          return DFB_DESTROYED;
+
+     if (data->locked)
+          return DFB_LOCKED;
+
+     if (!flags || !ret_ptr || !ret_pitch)
+          return DFB_INVARG;
+
+     if (!data->area.current.w || !data->area.current.h)
+          return DFB_INVAREA;
+
+     if (flags & DSLF_READ)
+          access |= CSAF_READ;
+
+     if (flags & DSLF_WRITE) {
+          access |= CSAF_WRITE;
+          role = CSBR_BACK;
+     }
+
+     CoreGraphicsStateClient_FlushCurrent( 0 );
+
+     ret = dfb_surface_lock_buffer( data->surface, role, CSAID_CPU, access, &data->lock );
+     if (ret)
+          return ret;
+
+     data->locked = true;
+
+     *ret_ptr   = data->lock.addr + data->lock.pitch * data->area.current.y +
+                  DFB_BYTES_PER_LINE( data->surface->config.format, data->area.current.x );
+     *ret_pitch = data->lock.pitch;
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_GetFramebufferOffset( IDirectFBSurface *thiz,
+                                       int *offset )
+{
+     /*
+      * Previously returned the framebuffer offset of a locked surface.
+      * However, it is not a safe API to use at all, since it is not
+      * guaranteed that the offset actually belongs to fbmem (e.g. could be AGP memory).
+      */
+
+     return DFB_FAILURE;
+}
+
+static DFBResult
+IDirectFBSurface_GetPhysicalAddress( IDirectFBSurface *thiz,
+                                     unsigned long    *addr )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     if (!data->surface)
+          return DFB_DESTROYED;
+
+     if (!addr)
+          return DFB_INVARG;
+
+     if (!data->locked)
+          return DFB_ACCESSDENIED;
+
+     if (!data->lock.phys) {
+          /* The surface is probably in a system buffer if there's no physical address. */
+          return DFB_UNSUPPORTED;
+     }
+
+     *addr = data->lock.phys;
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_Unlock( IDirectFBSurface *thiz )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     if (!data->surface)
+          return DFB_DESTROYED;
+
+     if (data->locked) {
+          dfb_surface_unlock_buffer( data->surface, &data->lock );
+
+          data->locked = false;
+     }
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_Write( IDirectFBSurface    *thiz,
+                        const DFBRectangle  *rect,
+                        const void          *ptr,
+                        int                  pitch )
+{
+     CoreSurface *surface;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p, %p, %p [%d] )\n", __FUNCTION__, thiz, rect, ptr, pitch );
+
+     surface = data->surface;
+     if (!surface)
+          return DFB_DESTROYED;
+
+     if (!rect || !ptr)
+          return DFB_INVARG;
+
+     if (ABS(pitch) < DFB_BYTES_PER_LINE( surface->config.format, rect->w ))
+          return DFB_INVARG;
+
+     if (data->locked)
+          return DFB_LOCKED;
+
+     if (!data->area.current.w || !data->area.current.h) {
+          D_DEBUG_AT( Surface, "  -> NO AREA (current " DFB_RECT_FORMAT ")\n", DFB_RECTANGLE_VALS( &data->area.current ) );
+          return DFB_INVAREA;
+     }
+
+     D_DEBUG_AT( Surface, "  ->      %4d,%4d-%4dx%4d\n", DFB_RECTANGLE_VALS( rect ) );
+
+     //FIXME: check rectangle
+
+     return dfb_surface_write_buffer( data->surface, CSBR_BACK, ptr, pitch, rect );
+}
+
+static DFBResult
+IDirectFBSurface_Read( IDirectFBSurface    *thiz,
+                       const DFBRectangle  *rect,
+                       void                *ptr,
+                       int                  pitch )
+{
+     CoreSurface *surface;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p, %p, %p [%d] )\n", __FUNCTION__, thiz, rect, ptr, pitch );
+
+     surface = data->surface;
+     if (!surface)
+          return DFB_DESTROYED;
+
+     if (!rect || !ptr || pitch < DFB_BYTES_PER_LINE(surface->config.format,rect->w ) )
+          return DFB_INVARG;
+
+     if (data->locked)
+          return DFB_LOCKED;
+
+     if (!data->area.current.w || !data->area.current.h)
+          return DFB_INVAREA;
+
+     D_DEBUG_AT( Surface, "  ->      %4d,%4d-%4dx%4d\n", DFB_RECTANGLE_VALS( rect ) );
+
+     //FIXME: check rectangle
+
+     return dfb_surface_read_buffer( data->surface, CSBR_FRONT, ptr, pitch, rect );
+}
+
+static DFBResult
+IDirectFBSurface_Flip( IDirectFBSurface    *thiz,
+                       const DFBRegion     *region,
+                       DFBSurfaceFlipFlags  flags )
+{
+     DFBResult    ret = DFB_OK;
+     DFBRegion    reg;
+     CoreSurface *surface;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p, %p, 0x%08x )\n", __FUNCTION__, thiz, region, flags );
+
+     surface = data->surface;
+     if (!surface)
+          return DFB_DESTROYED;
+
+     if (data->locked)
+          return DFB_LOCKED;
+
+     if (!data->area.current.w || !data->area.current.h ||
+         (region && (region->x1 > region->x2 || region->y1 > region->y2)))
+          return DFB_INVAREA;
+
+     IDirectFBSurface_StopAll( data );
+
+     /* FIXME: This is a temporary workaround for LiTE. */
+     if (data->parent) {
+          IDirectFBSurface_data *parent_data;
+
+          DIRECT_INTERFACE_GET_DATA_FROM( data->parent, parent_data, IDirectFBSurface );
+
+          if (parent_data) {
+               /* Signal end of sequence of operations. */
+               dfb_state_lock( &parent_data->state );
+               dfb_state_stop_drawing( &parent_data->state );
+               dfb_state_unlock( &parent_data->state );
+          }
+     }
+
+     dfb_region_from_rectangle( &reg, &data->area.current );
+
+     if (region) {
+          DFBRegion clip = DFB_REGION_INIT_TRANSLATED( region,
+                                                       data->area.wanted.x,
+                                                       data->area.wanted.y );
+
+          if (!dfb_region_region_intersect( &reg, &clip ))
+               return DFB_INVAREA;
+     }
+
+     D_DEBUG_AT( Surface, "  ->      %4d,%4d-%4dx%4d\n", DFB_RECTANGLE_VALS_FROM_REGION( &reg ) );
+
+     CoreGraphicsStateClient_FlushCurrent( 0 );
+
+     data->local_flip_buffers = surface->num_buffers;
+
+     if (dfb_config->force_frametime && !data->current_frame_time)
+          thiz->GetFrameTime( thiz, &data->current_frame_time );
+
+     if (surface->config.caps & DSCAPS_FLIPPING) {
+          if ((flags & DSFLIP_SWAP) || (!(flags & DSFLIP_BLIT) &&
+                                        reg.x1 == 0 && reg.y1 == 0 &&
+                                        reg.x2 == surface->config.size.w - 1 &&
+                                        reg.y2 == surface->config.size.h - 1))
+               data->local_flip_count++;
+     }
+
+     ret = CoreSurface_Flip2( data->surface, DFB_FALSE, &reg, NULL, flags, data->current_frame_time );
+
+     data->current_frame_time = 0;
+
+     if (ret)
+          return ret;
+
+     IDirectFBSurface_WaitForBackBuffer( data );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_SetField( IDirectFBSurface    *thiz,
+                           int                  field )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     if (!data->surface)
+          return DFB_DESTROYED;
+
+     if (!(data->surface->config.caps & DSCAPS_INTERLACED))
+          return DFB_UNSUPPORTED;
+
+     if (field < 0 || field > 1)
+          return DFB_INVARG;
+
+     CoreSurface_SetField( data->surface, field );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_Clear( IDirectFBSurface *thiz,
+                        u8 r, u8 g, u8 b, u8 a )
+{
+     DFBColor                old_color;
+     unsigned int            old_index;
+     DFBSurfaceDrawingFlags  old_flags;
+     DFBSurfaceRenderOptions old_options;
+     CoreSurface            *surface;
+     DFBColor                color = { a, r, g, b };
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p, 0x%08x )\n", __FUNCTION__, thiz, PIXEL_ARGB(a,r,g,b) );
+
+     surface = data->surface;
+     if (!surface)
+          return DFB_DESTROYED;
+
+     if (!data->area.current.w || !data->area.current.h)
+          return DFB_INVAREA;
+
+     if (data->locked)
+          return DFB_LOCKED;
+
+     /* save current color and drawing flags */
+     old_color   = data->state.color;
+     old_index   = data->state.color_index;
+     old_flags   = data->state.drawingflags;
+     old_options = data->state.render_options;
+
+     /* set drawing flags */
+     dfb_state_set_drawing_flags( &data->state, DSDRAW_NOFX );
+
+     /* set render options */
+     dfb_state_set_render_options( &data->state, DSRO_NONE );
+
+     /* set color */
+     if (DFB_PIXELFORMAT_IS_INDEXED( surface->config.format ))
+          dfb_state_set_color_index( &data->state,
+                                     dfb_palette_search( surface->palette, r, g, b, a ) );
+
+     dfb_state_set_color( &data->state, &color );
+
+     /* fill the visible rectangle */
+     CoreGraphicsStateClient_FillRectangles( &data->state_client, &data->area.current, 1 );
+
+     /* clear the depth buffer */
+     if (data->caps & DSCAPS_DEPTH)
+          dfb_clear_depth( data->surface, &data->state.clip );
+
+     /* restore drawing flags */
+     dfb_state_set_drawing_flags( &data->state, old_flags );
+
+     /* restore render options */
+     dfb_state_set_render_options( &data->state, old_options );
+
+     /* restore color */
+     if (DFB_PIXELFORMAT_IS_INDEXED( surface->config.format ))
+          dfb_state_set_color_index( &data->state, old_index );
+
+     dfb_state_set_color( &data->state, &old_color );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_SetClip( IDirectFBSurface *thiz, const DFBRegion *clip )
+{
+     DFBRegion newclip;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p, %p )\n", __FUNCTION__, thiz, clip );
+
+     D_DEBUG_AT( Surface, "  <-      %4d,%4d-%4dx%4d\n", DFB_RECTANGLE_VALS(&data->area.wanted) );
+
+     if (!data->area.current.w || !data->area.current.h)
+          return DFB_INVAREA;
+
+     if (clip) {
+          newclip = DFB_REGION_INIT_TRANSLATED( clip, data->area.wanted.x, data->area.wanted.y );
+
+          D_DEBUG_AT( Surface, "  <-      %4d,%4d-%4dx%4d\n", DFB_RECTANGLE_VALS_FROM_REGION(&newclip) );
+
+          if (!dfb_unsafe_region_rectangle_intersect( &newclip,
+                                                      &data->area.wanted ))
+               return DFB_INVARG;
+
+          D_DEBUG_AT( Surface, "  ->      %4d,%4d-%4dx%4d\n", DFB_RECTANGLE_VALS_FROM_REGION(&newclip) );
+
+          data->clip_set = true;
+          data->clip_wanted = newclip;
+
+          if (!dfb_region_rectangle_intersect( &newclip, &data->area.current ))
+               return DFB_INVAREA;
+     }
+     else {
+          dfb_region_from_rectangle( &newclip, &data->area.current );
+          data->clip_set = false;
+     }
+
+     D_DEBUG_AT( Surface, "  => CLIP %4d,%4d-%4dx%4d\n", DFB_RECTANGLE_VALS_FROM_REGION(&newclip) );
+
+     dfb_state_set_clip( &data->state, &newclip );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_GetClip( IDirectFBSurface *thiz, DFBRegion *ret_clip )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     if (!ret_clip)
+          return DFB_INVARG;
+
+     if (!data->area.current.w || !data->area.current.h)
+          return DFB_INVAREA;
+
+     *ret_clip = DFB_REGION_INIT_TRANSLATED( &data->state.clip, -data->area.wanted.x, -data->area.wanted.y );
+
+     D_DEBUG_AT( Surface, "  ->      %4d,%4d-%4dx%4d\n", DFB_RECTANGLE_VALS_FROM_REGION(ret_clip) );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_SetColor( IDirectFBSurface *thiz,
+                           u8 r, u8 g, u8 b, u8 a )
+{
+     CoreSurface *surface;
+     DFBColor     color = { a, r, g, b };
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p, COLOR 0x%08x )\n", __FUNCTION__, thiz, PIXEL_ARGB(a, r, g, b) );
+
+     surface = data->surface;
+     if (!surface)
+          return DFB_DESTROYED;
+
+     dfb_state_set_color( &data->state, &color );
+
+     if (DFB_PIXELFORMAT_IS_INDEXED( surface->config.format ))
+          dfb_state_set_color_index( &data->state,
+                                     dfb_palette_search( surface->palette, r, g, b, a ) );
+
+     data->state.colors[0]        = data->state.color;
+     data->state.color_indices[0] = data->state.color_index;
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_SetColors( IDirectFBSurface *thiz,
+                            const DFBColorID *ids,
+                            const DFBColor   *colors,
+                            unsigned int      num )
+{
+     unsigned int  i;
+     CoreSurface  *surface;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p, %p, %p, %u )\n", __FUNCTION__, thiz, ids, colors, num );
+
+     surface = data->surface;
+     if (!surface)
+          return DFB_DESTROYED;
+
+     for (i=0; i<num; i++) {
+          D_DEBUG_AT( Surface, "  -> [%d] id %d = %02x %02x %02x %02x\n",
+                      i, ids[i], colors[i].a, colors[i].r, colors[i].g, colors[i].b );
+
+          if (ids[i] >= DFB_COLOR_IDS_MAX)
+               return DFB_INVARG;
+
+          data->state.colors[ids[i]] = colors[i];
+
+          if (DFB_PIXELFORMAT_IS_INDEXED( surface->config.format ))
+               data->state.color_indices[ids[i]] = dfb_palette_search( surface->palette,
+                                                                       colors[i].r, colors[i].g, colors[i].b, colors[i].a );
+     }
+
+     dfb_state_set_color( &data->state, &data->state.colors[0] );
+     dfb_state_set_color_index( &data->state, data->state.color_indices[0] );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_SetColorIndex( IDirectFBSurface *thiz,
+                                unsigned int      index )
+{
+     CoreSurface *surface;
+     CorePalette *palette;
+     DFBResult    ret;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p, COLOR INDEX %3u )\n", __FUNCTION__, thiz, index );
+
+     surface = data->surface;
+     if (!surface)
+          return DFB_DESTROYED;
+
+     if (! DFB_PIXELFORMAT_IS_INDEXED( surface->config.format ))
+          return DFB_UNSUPPORTED;
+
+     palette = surface->palette;
+     if (!palette)
+          return DFB_UNSUPPORTED;
+
+     if (index > palette->num_entries)
+          return DFB_INVARG;
+
+     // FIXME: why do we call this explicitly here as opposed to other functions?
+     ret = CoreGraphicsStateClient_SetColorAndIndex( &data->state_client, &palette->entries[index], index );
+     if (ret)
+          return ret;
+
+     dfb_state_set_color( &data->state, &palette->entries[index] );
+     dfb_state_set_color_index( &data->state, index );
+
+     data->state.colors[0]        = data->state.color;
+     data->state.color_indices[0] = data->state.color_index;
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_SetSrcBlendFunction( IDirectFBSurface        *thiz,
+                                      DFBSurfaceBlendFunction  src )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p, %d )\n", __FUNCTION__, thiz, src );
+
+     switch (src) {
+          case DSBF_ZERO:
+          case DSBF_ONE:
+          case DSBF_SRCCOLOR:
+          case DSBF_INVSRCCOLOR:
+          case DSBF_SRCALPHA:
+          case DSBF_INVSRCALPHA:
+          case DSBF_DESTALPHA:
+          case DSBF_INVDESTALPHA:
+          case DSBF_DESTCOLOR:
+          case DSBF_INVDESTCOLOR:
+          case DSBF_SRCALPHASAT:
+               dfb_state_set_src_blend( &data->state, src );
+               return DFB_OK;
+
+          default:
+               break;
+     }
+
+     return DFB_INVARG;
+}
+
+static DFBResult
+IDirectFBSurface_SetDstBlendFunction( IDirectFBSurface        *thiz,
+                                      DFBSurfaceBlendFunction  dst )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p, %d )\n", __FUNCTION__, thiz, dst );
+
+     switch (dst) {
+          case DSBF_ZERO:
+          case DSBF_ONE:
+          case DSBF_SRCCOLOR:
+          case DSBF_INVSRCCOLOR:
+          case DSBF_SRCALPHA:
+          case DSBF_INVSRCALPHA:
+          case DSBF_DESTALPHA:
+          case DSBF_INVDESTALPHA:
+          case DSBF_DESTCOLOR:
+          case DSBF_INVDESTCOLOR:
+          case DSBF_SRCALPHASAT:
+               dfb_state_set_dst_blend( &data->state, dst );
+               return DFB_OK;
+
+          default:
+               break;
+     }
+
+     return DFB_INVARG;
+}
+
+static DFBResult
+IDirectFBSurface_SetPorterDuff( IDirectFBSurface         *thiz,
+                                DFBSurfacePorterDuffRule  rule )
+{
+     DFBSurfaceBlendFunction src;
+     DFBSurfaceBlendFunction dst;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p, %d )\n", __FUNCTION__, thiz, rule );
+
+
+     switch (rule) {
+          case DSPD_NONE:
+               src = DSBF_SRCALPHA;
+               dst = DSBF_INVSRCALPHA;
+               break;
+          case DSPD_CLEAR:
+               src = DSBF_ZERO;
+               dst = DSBF_ZERO;
+               break;
+          case DSPD_SRC:
+               src = DSBF_ONE;
+               dst = DSBF_ZERO;
+               break;
+          case DSPD_SRC_OVER:
+               src = DSBF_ONE;
+               dst = DSBF_INVSRCALPHA;
+               break;
+          case DSPD_DST_OVER:
+               src = DSBF_INVDESTALPHA;
+               dst = DSBF_ONE;
+               break;
+          case DSPD_SRC_IN:
+               src = DSBF_DESTALPHA;
+               dst = DSBF_ZERO;
+               break;
+          case DSPD_DST_IN:
+               src = DSBF_ZERO;
+               dst = DSBF_SRCALPHA;
+               break;
+          case DSPD_SRC_OUT:
+               src = DSBF_INVDESTALPHA;
+               dst = DSBF_ZERO;
+               break;
+          case DSPD_DST_OUT:
+               src = DSBF_ZERO;
+               dst = DSBF_INVSRCALPHA;
+               break;
+          case DSPD_SRC_ATOP:
+               src = DSBF_DESTALPHA;
+               dst = DSBF_INVSRCALPHA;
+               break;
+          case DSPD_DST_ATOP:
+               src = DSBF_INVDESTALPHA;
+               dst = DSBF_SRCALPHA;
+               break;
+          case DSPD_ADD:
+               src = DSBF_ONE;
+               dst = DSBF_ONE;
+               break;
+          case DSPD_XOR:
+               src = DSBF_INVDESTALPHA;
+               dst = DSBF_INVSRCALPHA;
+               break;
+          case DSPD_DST:
+               src = DSBF_ZERO;
+               dst = DSBF_ONE;
+               break;
+          default:
+               return DFB_INVARG;
+     }
+
+     dfb_state_set_src_blend( &data->state, src );
+     dfb_state_set_dst_blend( &data->state, dst );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_SetSrcColorKey( IDirectFBSurface *thiz,
+                                 u8                r,
+                                 u8                g,
+                                 u8                b )
+{
+     CoreSurface *surface;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     surface = data->surface;
+     if (!surface)
+          return DFB_DESTROYED;
+
+     data->src_key.r = r;
+     data->src_key.g = g;
+     data->src_key.b = b;
+
+     if (DFB_PIXELFORMAT_IS_INDEXED( surface->config.format ))
+          data->src_key.value = dfb_palette_search( surface->palette,
+                                                    r, g, b, 0x80 );
+     else
+          data->src_key.value = dfb_color_to_pixel( surface->config.format, r, g, b );
+
+     /* The new key won't be applied to this surface's state.
+        The key will be taken by the destination surface to apply it
+        to its state when source color keying is used. */
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_SetSrcColorKeyIndex( IDirectFBSurface *thiz,
+                                      unsigned int      index )
+{
+     CoreSurface *surface;
+     CorePalette *palette;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     surface = data->surface;
+     if (!surface)
+          return DFB_DESTROYED;
+
+     if (! DFB_PIXELFORMAT_IS_INDEXED( surface->config.format ))
+          return DFB_UNSUPPORTED;
+
+     palette = surface->palette;
+     if (!palette)
+          return DFB_UNSUPPORTED;
+
+     if (index > palette->num_entries)
+          return DFB_INVARG;
+
+     data->src_key.r = palette->entries[index].r;
+     data->src_key.g = palette->entries[index].g;
+     data->src_key.b = palette->entries[index].b;
+
+     data->src_key.value = index;
+
+     /* The new key won't be applied to this surface's state.
+        The key will be taken by the destination surface to apply it
+        to its state when source color keying is used. */
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_SetDstColorKey( IDirectFBSurface *thiz,
+                                 u8                r,
+                                 u8                g,
+                                 u8                b )
+{
+     CoreSurface *surface;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     surface = data->surface;
+     if (!surface)
+          return DFB_DESTROYED;
+
+     data->dst_key.r = r;
+     data->dst_key.g = g;
+     data->dst_key.b = b;
+
+     if (DFB_PIXELFORMAT_IS_INDEXED( surface->config.format ))
+          data->dst_key.value = dfb_palette_search( surface->palette,
+                                                    r, g, b, 0x80 );
+     else
+          data->dst_key.value = dfb_color_to_pixel( surface->config.format, r, g, b );
+
+     dfb_state_set_dst_colorkey( &data->state, data->dst_key.value );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_SetDstColorKeyIndex( IDirectFBSurface *thiz,
+                                      unsigned int      index )
+{
+     CoreSurface *surface;
+     CorePalette *palette;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     surface = data->surface;
+     if (!surface)
+          return DFB_DESTROYED;
+
+     if (! DFB_PIXELFORMAT_IS_INDEXED( surface->config.format ))
+          return DFB_UNSUPPORTED;
+
+     palette = surface->palette;
+     if (!palette)
+          return DFB_UNSUPPORTED;
+
+     if (index > palette->num_entries)
+          return DFB_INVARG;
+
+     data->dst_key.r = palette->entries[index].r;
+     data->dst_key.g = palette->entries[index].g;
+     data->dst_key.b = palette->entries[index].b;
+
+     data->dst_key.value = index;
+
+     dfb_state_set_dst_colorkey( &data->state, data->dst_key.value );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_SetIndexTranslation( IDirectFBSurface *thiz,
+                                      const int        *indices,
+                                      int               num_indices )
+{
+     CoreSurface *surface;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     surface = data->surface;
+     if (!surface)
+          return DFB_DESTROYED;
+
+     if (! DFB_PIXELFORMAT_IS_INDEXED( surface->config.format ))
+          return DFB_UNSUPPORTED;
+
+     if (!indices && num_indices > 0)
+          return DFB_INVAREA;
+
+     if (num_indices < 0 || num_indices > 256)
+          return DFB_INVARG;
+
+     return dfb_state_set_index_translation( &data->state, indices, num_indices );
+}
+
+static DFBResult
+IDirectFBSurface_SetFont( IDirectFBSurface *thiz,
+                          IDirectFBFont    *font )
+{
+     DFBResult ret;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p, %p )\n", __FUNCTION__, thiz, font );
+
+     if (data->font != font) {
+         if (font) {
+              IDirectFBFont_data *font_data;
+
+              ret = font->AddRef( font );
+              if (ret)
+                   return ret;
+
+              DIRECT_INTERFACE_GET_DATA_FROM( font, font_data, IDirectFBFont );
+
+              if (font_data)
+                   data->encoding = font_data->encoding;
+         }
+
+         if (data->font)
+              data->font->Release( data->font );
+
+         data->font = font;
+     }
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_GetFont( IDirectFBSurface  *thiz,
+                          IDirectFBFont    **ret_font )
+{
+     DFBResult      ret;
+     IDirectFBFont *font;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     if (!ret_font)
+          return DFB_INVARG;
+
+     font = data->font;
+     if (!font) {
+          *ret_font = NULL;
+          return DFB_MISSINGFONT;
+     }
+
+     ret = font->AddRef( font );
+     if (ret)
+          return ret;
+
+     *ret_font = font;
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_SetDrawingFlags( IDirectFBSurface       *thiz,
+                                  DFBSurfaceDrawingFlags  flags )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p, 0x%08x )\n", __FUNCTION__, thiz, flags );
+
+     dfb_state_set_drawing_flags( &data->state, flags );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_FillRectangle( IDirectFBSurface *thiz,
+                                int x, int y, int w, int h )
+{
+     DFBRectangle rect = { x, y, w, h };
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+     D_DEBUG_AT( Surface, "  -> [%2d] %4d,%4d-%4dx%4d\n", 0, x, y, w, h );
+
+     if (!data->surface)
+          return DFB_DESTROYED;
+
+
+     if (!data->area.current.w || !data->area.current.h)
+          return DFB_INVAREA;
+
+     if (data->locked)
+          return DFB_LOCKED;
+
+     if (w<=0 || h<=0)
+          return DFB_INVARG;
+
+     rect.x += data->area.wanted.x;
+     rect.y += data->area.wanted.y;
+
+     CoreGraphicsStateClient_FillRectangles( &data->state_client, &rect, 1 );
+
+     return DFB_OK;
+}
+
+
+static DFBResult
+IDirectFBSurface_DrawLine( IDirectFBSurface *thiz,
+                           int x1, int y1, int x2, int y2 )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+     D_DEBUG_AT( Surface, "  -> [%2d] %4d,%4d-%4d,%4d\n", 0, x1, y1, x2, y2 );
+
+     if (!data->surface)
+          return DFB_DESTROYED;
+
+
+     if (!data->area.current.w || !data->area.current.h)
+          return DFB_INVAREA;
+
+     if (data->locked)
+          return DFB_LOCKED;
+
+     if ((x1 == x2 || y1 == y2) && !(data->state.render_options & DSRO_MATRIX)) {
+          DFBRectangle rect;
+
+          if (x1 <= x2) {
+               rect.x = x1;
+               rect.w = x2 - x1 + 1;
+          }
+          else {
+               rect.x = x2;
+               rect.w = x1 - x2 + 1;
+          }
+
+          if (y1 <= y2) {
+               rect.y = y1;
+               rect.h = y2 - y1 + 1;
+          }
+          else {
+               rect.y = y2;
+               rect.h = y1 - y2 + 1;
+          }
+
+          rect.x += data->area.wanted.x;
+          rect.y += data->area.wanted.y;
+
+          CoreGraphicsStateClient_FillRectangles( &data->state_client, &rect, 1 );
+     }
+     else {
+          DFBRegion line = { x1, y1, x2, y2 };
+
+          line.x1 += data->area.wanted.x;
+          line.x2 += data->area.wanted.x;
+          line.y1 += data->area.wanted.y;
+          line.y2 += data->area.wanted.y;
+
+          CoreGraphicsStateClient_DrawLines( &data->state_client, &line, 1 );
+     }
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_DrawLines( IDirectFBSurface *thiz,
+                            const DFBRegion  *lines,
+                            unsigned int      num_lines )
+{
+     unsigned int i;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p, %p [%d] )\n", __FUNCTION__, thiz, lines, num_lines );
+
+     if (!data->surface)
+          return DFB_DESTROYED;
+
+
+     if (!data->area.current.w || !data->area.current.h)
+          return DFB_INVAREA;
+
+     if (data->locked)
+          return DFB_LOCKED;
+
+     if (!lines || !num_lines)
+          return DFB_INVARG;
+
+     /* Check if all lines are either horizontal or vertical */
+     for (i=0; i<num_lines; i++) {
+          if (lines[i].x1 != lines[i].x2 && lines[i].y1 != lines[i].y2)
+               break;
+     }
+
+     /* Use real line drawing? */
+     if (i < num_lines) {
+          DFBRegion *local_lines = alloca(sizeof(DFBRegion) * num_lines);
+
+          if (data->area.wanted.x || data->area.wanted.y) {
+               for (i=0; i<num_lines; i++) {
+                    local_lines[i].x1 = lines[i].x1 + data->area.wanted.x;
+                    local_lines[i].x2 = lines[i].x2 + data->area.wanted.x;
+                    local_lines[i].y1 = lines[i].y1 + data->area.wanted.y;
+                    local_lines[i].y2 = lines[i].y2 + data->area.wanted.y;
+               }
+          }
+          else
+               /* clipping may modify lines, so we copy them */
+               direct_memcpy( local_lines, lines, sizeof(DFBRegion) * num_lines );
+
+          CoreGraphicsStateClient_DrawLines( &data->state_client, local_lines, num_lines );
+     }
+     /* Optimized rectangle drawing */
+     else {
+          DFBRectangle *local_rects = alloca(sizeof(DFBRectangle) * num_lines);
+
+          for (i=0; i<num_lines; i++) {
+               /* Vertical line? */
+               if (lines[i].x1 == lines[i].x2) {
+                    local_rects[i].x = data->area.wanted.x + lines[i].x1;
+                    local_rects[i].y = data->area.wanted.y + MIN( lines[i].y1, lines[i].y2 );
+                    local_rects[i].w = 1;
+                    local_rects[i].h = ABS( lines[i].y2 - lines[i].y1 ) + 1;
+               }
+               /* Horizontal line */
+               else {
+                    local_rects[i].x = data->area.wanted.x + MIN( lines[i].x1, lines[i].x2 );
+                    local_rects[i].y = data->area.wanted.y + lines[i].y1;
+                    local_rects[i].w = ABS( lines[i].x2 - lines[i].x1 ) + 1;
+                    local_rects[i].h = 1;
+               }
+          }
+
+          CoreGraphicsStateClient_FillRectangles( &data->state_client, local_rects, num_lines );
+     }
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_DrawRectangle( IDirectFBSurface *thiz,
+                                int x, int y, int w, int h )
+{
+     DFBRectangle rect = { x, y, w, h };
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+     D_DEBUG_AT( Surface, "  -> [%2d] %4d,%4d-%4dx%4d\n", 0, x, y, w, h );
+
+     if (!data->surface)
+          return DFB_DESTROYED;
+
+
+     if (!data->area.current.w || !data->area.current.h)
+          return DFB_INVAREA;
+
+     if (data->locked)
+          return DFB_LOCKED;
+
+     if (w<=0 || h<=0)
+          return DFB_INVARG;
+
+     rect.x += data->area.wanted.x;
+     rect.y += data->area.wanted.y;
+
+     CoreGraphicsStateClient_DrawRectangles( &data->state_client, &rect, 1 );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_FillTriangle( IDirectFBSurface *thiz,
+                               int x1, int y1,
+                               int x2, int y2,
+                               int x3, int y3 )
+{
+     DFBTriangle tri = { x1, y1, x2, y2, x3, y3 };
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+     D_DEBUG_AT( Surface, "  -> [%2d] %4d,%4d-%4d,%4d-%4d,%4d\n", 0, x1, y1, x2, y2, x3, y3 );
+
+     if (!data->surface)
+          return DFB_DESTROYED;
+
+
+     if (!data->area.current.w || !data->area.current.h)
+          return DFB_INVAREA;
+
+     if (data->locked)
+          return DFB_LOCKED;
+
+     tri.x1 += data->area.wanted.x;
+     tri.y1 += data->area.wanted.y;
+     tri.x2 += data->area.wanted.x;
+     tri.y2 += data->area.wanted.y;
+     tri.x3 += data->area.wanted.x;
+     tri.y3 += data->area.wanted.y;
+
+     CoreGraphicsStateClient_FillTriangles( &data->state_client, &tri, 1 );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_FillTrapezoids( IDirectFBSurface   *thiz,
+                                 const DFBTrapezoid *traps,
+                                 unsigned int        num_traps )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     if (!data->surface)
+          return DFB_DESTROYED;
+
+
+     if (!data->area.current.w || !data->area.current.h)
+          return DFB_INVAREA;
+
+     if (data->locked)
+          return DFB_LOCKED;
+
+     if (!traps || !num_traps)
+          return DFB_INVARG;
+
+     if (data->area.wanted.x || data->area.wanted.y) {
+          unsigned int  i;
+          DFBTrapezoid  *local_traps;
+          bool           malloced = (num_traps > 170);
+
+          if (malloced)
+               local_traps = D_MALLOC( sizeof(DFBTrapezoid) * num_traps );
+          else
+               local_traps = alloca( sizeof(DFBTrapezoid) * num_traps );
+
+          for (i=0; i<num_traps; i++) {
+               local_traps[i].x1 = traps[i].x1 + data->area.wanted.x;
+               local_traps[i].y1 = traps[i].y1 + data->area.wanted.y;
+               local_traps[i].w1 = traps[i].w1;
+               local_traps[i].x2 = traps[i].x2 + data->area.wanted.x;
+               local_traps[i].y2 = traps[i].y2 + data->area.wanted.y;
+               local_traps[i].w2 = traps[i].w2;
+          }
+
+          CoreGraphicsStateClient_FillTrapezoids( &data->state_client, local_traps, num_traps );
+
+          if (malloced)
+               D_FREE( local_traps );
+     }
+     else
+          CoreGraphicsStateClient_FillTrapezoids( &data->state_client, traps, num_traps );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_FillRectangles( IDirectFBSurface   *thiz,
+                                 const DFBRectangle *rects,
+                                 unsigned int        num_rects )
+{
+     unsigned int i;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p, %p [%d] )\n", __FUNCTION__, thiz, rects, num_rects );
+
+     DFB_RECTANGLES_DEBUG_AT( Surface, rects, num_rects );
+
+
+     if (!data->surface)
+          return DFB_DESTROYED;
+
+
+     if (!data->area.current.w || !data->area.current.h)
+          return DFB_INVAREA;
+
+     if (data->locked)
+          return DFB_LOCKED;
+
+     if (!rects || !num_rects)
+          return DFB_INVARG;
+
+     if (data->area.wanted.x || data->area.wanted.y) {
+          unsigned int  i;
+          DFBRectangle *local_rects;
+          bool          malloced = (num_rects > 256);
+
+          if (malloced)
+               local_rects = D_MALLOC( sizeof(DFBRectangle) * num_rects );
+          else
+               local_rects = alloca( sizeof(DFBRectangle) * num_rects );
+
+          for (i=0; i<num_rects; i++) {
+               local_rects[i].x = rects[i].x + data->area.wanted.x;
+               local_rects[i].y = rects[i].y + data->area.wanted.y;
+               local_rects[i].w = rects[i].w;
+               local_rects[i].h = rects[i].h;
+          }
+
+          for (i=0; i<num_rects; i+=200) {
+               CoreGraphicsStateClient_FillRectangles( &data->state_client, &local_rects[i],
+                                                       MIN(200, num_rects-i) );
+          }
+
+          if (malloced)
+               D_FREE( local_rects );
+     }
+     else {
+          for (i=0; i<num_rects; i+=200) {
+               CoreGraphicsStateClient_FillRectangles( &data->state_client, &rects[i],
+                                                       MIN(200, num_rects-i) );
+          }
+     }
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_FillSpans( IDirectFBSurface *thiz,
+                            int               y,
+                            const DFBSpan    *spans,
+                            unsigned int      num_spans )
+{
+     DFBSpan *local_spans = alloca(sizeof(DFBSpan) * num_spans);
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     if (!data->surface)
+          return DFB_DESTROYED;
+
+
+     if (!data->area.current.w || !data->area.current.h)
+          return DFB_INVAREA;
+
+     if (data->locked)
+          return DFB_LOCKED;
+
+     if (!spans || !num_spans)
+          return DFB_INVARG;
+
+     if (data->area.wanted.x || data->area.wanted.y) {
+          unsigned int i;
+
+          for (i=0; i<num_spans; i++) {
+               local_spans[i].x = spans[i].x + data->area.wanted.x;
+               local_spans[i].w = spans[i].w;
+          }
+     }
+     else
+          /* clipping may modify spans, so we copy them */
+          direct_memcpy( local_spans, spans, sizeof(DFBSpan) * num_spans );
+
+     CoreGraphicsStateClient_FillSpans( &data->state_client, y + data->area.wanted.y, local_spans, num_spans );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_FillTriangles( IDirectFBSurface  *thiz,
+                                const DFBTriangle *tris,
+                                unsigned int       num_tris )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     if (!data->surface)
+          return DFB_DESTROYED;
+
+
+     if (!data->area.current.w || !data->area.current.h)
+          return DFB_INVAREA;
+
+     if (data->locked)
+          return DFB_LOCKED;
+
+     if (!tris || !num_tris)
+          return DFB_INVARG;
+
+     if (data->area.wanted.x || data->area.wanted.y) {
+          unsigned int  i;
+          DFBTriangle  *local_tris;
+          bool          malloced = (num_tris > 170);
+
+          if (malloced)
+               local_tris = D_MALLOC( sizeof(DFBTriangle) * num_tris );
+          else
+               local_tris = alloca( sizeof(DFBTriangle) * num_tris );
+
+          for (i=0; i<num_tris; i++) {
+               local_tris[i].x1 = tris[i].x1 + data->area.wanted.x;
+               local_tris[i].y1 = tris[i].y1 + data->area.wanted.y;
+               local_tris[i].x2 = tris[i].x2 + data->area.wanted.x;
+               local_tris[i].y2 = tris[i].y2 + data->area.wanted.y;
+               local_tris[i].x3 = tris[i].x3 + data->area.wanted.x;
+               local_tris[i].y3 = tris[i].y3 + data->area.wanted.y;
+          }
+
+          CoreGraphicsStateClient_FillTriangles( &data->state_client, local_tris, num_tris );
+
+          if (malloced)
+               D_FREE( local_tris );
+     }
+     else
+          CoreGraphicsStateClient_FillTriangles( &data->state_client, tris, num_tris );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_SetBlittingFlags( IDirectFBSurface        *thiz,
+                                   DFBSurfaceBlittingFlags  flags )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p, 0x%08x )\n", __FUNCTION__, thiz, flags );
+
+     dfb_state_set_blitting_flags( &data->state, flags );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_Blit( IDirectFBSurface   *thiz,
+                       IDirectFBSurface   *source,
+                       const DFBRectangle *sr,
+                       int dx, int dy )
+{
+     DFBRectangle srect;
+     IDirectFBSurface_data *src_data;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p, %d,%d )\n", __FUNCTION__, thiz, dx, dy );
+
+     if (sr)
+          D_DEBUG_AT( Surface, "  -> [%2d] %4d,%4d-%4dx%4d <- %4d,%4d\n", 0, dx, dy, sr->w, sr->h, sr->x, sr->y );
+
+     if (!data->surface)
+          return DFB_DESTROYED;
+
+     if (!source)
+          return DFB_INVARG;
+
+     if (!data->area.current.w || !data->area.current.h)
+          return DFB_INVAREA;
+
+     if (data->locked)
+          return DFB_LOCKED;
+
+
+     src_data = (IDirectFBSurface_data*)source->priv;
+
+     if (!src_data->area.current.w || !src_data->area.current.h)
+          return DFB_INVAREA;
+
+     if (sr) {
+          if (sr->w < 1  ||  sr->h < 1)
+               return DFB_OK;
+
+          srect = *sr;
+
+          srect.x += src_data->area.wanted.x;
+          srect.y += src_data->area.wanted.y;
+
+          if (!dfb_rectangle_intersect( &srect, &src_data->area.current ))
+               return DFB_INVAREA;
+
+          dx += srect.x - (sr->x + src_data->area.wanted.x);
+          dy += srect.y - (sr->y + src_data->area.wanted.y);
+     }
+     else {
+          srect = src_data->area.current;
+
+          dx += srect.x - src_data->area.wanted.x;
+          dy += srect.y - src_data->area.wanted.y;
+     }
+
+     CoreGraphicsStateClient_Flush( &src_data->state_client, 0, CGSCFF_NONE );
+
+     if (src_data->surface_client) {
+          direct_mutex_lock( &data->surface_client_lock );
+
+          D_DEBUG_AT( Surface_Updates, "  -> blit client surface (flip count %u)\n", src_data->surface_client_flip_count );
+
+          dfb_state_set_source_2( &data->state, src_data->surface, src_data->surface_client_flip_count );
+     }
+     else
+          dfb_state_set_source( &data->state, src_data->surface );
+
+     dfb_state_set_from( &data->state, CSBR_FRONT, src_data->src_eye );
+
+     /* fetch the source color key from the source if necessary */
+     if (data->state.blittingflags & DSBLIT_SRC_COLORKEY)
+          dfb_state_set_src_colorkey( &data->state, src_data->src_key.value );
+
+     DFBPoint p = { data->area.wanted.x + dx, data->area.wanted.y + dy };
+
+     CoreGraphicsStateClient_Blit( &data->state_client, &srect, &p, 1 );
+
+     if (src_data->surface_client)
+          direct_mutex_unlock( &data->surface_client_lock );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_TileBlit( IDirectFBSurface   *thiz,
+                           IDirectFBSurface   *source,
+                           const DFBRectangle *sr,
+                           int dx, int dy )
+{
+     DFBRectangle           srect;
+     DFBPoint               p1, p2;
+     IDirectFBSurface_data *src_data;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     if (sr)
+          D_DEBUG_AT( Surface, "  -> [%2d] %4d,%4d-%4dx%4d <- %4d,%4d\n", 0, dx, dy, sr->w, sr->h, sr->x, sr->y );
+
+     if (!data->surface)
+          return DFB_DESTROYED;
+
+
+     if (!data->area.current.w || !data->area.current.h)
+          return DFB_INVAREA;
+
+     if (data->locked)
+          return DFB_LOCKED;
+
+     if (!source)
+          return DFB_INVARG;
+
+
+     src_data = (IDirectFBSurface_data*)source->priv;
+
+     if (!src_data->area.current.w || !src_data->area.current.h)
+          return DFB_INVAREA;
+
+
+     if (sr) {
+          if (sr->w < 1  ||  sr->h < 1)
+               return DFB_OK;
+
+          srect = *sr;
+
+          srect.x += src_data->area.wanted.x;
+          srect.y += src_data->area.wanted.y;
+
+          if (!dfb_rectangle_intersect( &srect, &src_data->area.current ))
+               return DFB_INVAREA;
+
+          dx += srect.x - (sr->x + src_data->area.wanted.x);
+          dy += srect.y - (sr->y + src_data->area.wanted.y);
+     }
+     else {
+          srect = src_data->area.current;
+
+          dx += srect.x - src_data->area.wanted.x;
+          dy += srect.y - src_data->area.wanted.y;
+     }
+
+     CoreGraphicsStateClient_Flush( &src_data->state_client, 0, CGSCFF_NONE );
+
+     dfb_state_set_source( &data->state, src_data->surface );
+
+     dfb_state_set_from( &data->state, CSBR_FRONT, src_data->src_eye );
+
+     /* fetch the source color key from the source if necessary */
+     if (data->state.blittingflags & DSBLIT_SRC_COLORKEY)
+          dfb_state_set_src_colorkey( &data->state, src_data->src_key.value );
+
+     dx %= srect.w;
+     if (dx > 0)
+          dx -= srect.w;
+
+     dy %= srect.h;
+     if (dy > 0)
+          dy -= srect.h;
+
+     dx += data->area.wanted.x;
+     dy += data->area.wanted.y;
+
+     p1.x = dx;
+     p1.y = dy;
+
+     p2.x = dx + data->area.wanted.w + srect.w - 1;
+     p2.y = dy + data->area.wanted.h + srect.h - 1;
+
+     CoreGraphicsStateClient_TileBlit( &data->state_client, &srect, &p1, &p2, 1 );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_BatchBlit( IDirectFBSurface   *thiz,
+                            IDirectFBSurface   *source,
+                            const DFBRectangle *source_rects,
+                            const DFBPoint     *dest_points,
+                            int                 num )
+{
+     int                    i, dx, dy, sx, sy;
+     DFBRectangle          *rects;
+     DFBPoint              *points;
+     IDirectFBSurface_data *src_data;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p, source %p, source_rects %p, dest_points %p, num %d )\n", __FUNCTION__, thiz, source, source_rects, dest_points, num );
+
+     if (!data->surface)
+          return DFB_DESTROYED;
+
+     if (!source || !source_rects || !dest_points || num < 1) {
+          D_DEBUG_AT( Surface, "     !source || !source_rects || !dest_points || num < 1\n" );
+          return DFB_INVARG;
+     }
+
+     if (!data->area.current.w || !data->area.current.h) {
+          D_DEBUG_AT( Surface, "     !data->area.current.w || !data->area.current.h\n" );
+          return DFB_INVAREA;
+     }
+
+     if (data->locked) {
+          D_DEBUG_AT( Surface, "     data->locked\n" );
+          return DFB_LOCKED;
+     }
+
+
+     src_data = (IDirectFBSurface_data*)source->priv;
+
+     if (!src_data->area.current.w || !src_data->area.current.h) {
+          D_DEBUG_AT( Surface, "     !src_data->area.current.w || !src_data->area.current.h\n" );
+          return DFB_INVAREA;
+     }
+
+     dx = data->area.wanted.x;
+     dy = data->area.wanted.y;
+
+     sx = src_data->area.wanted.x;
+     sy = src_data->area.wanted.y;
+
+     rects  = alloca( sizeof(DFBRectangle) * num );
+     points = alloca( sizeof(DFBPoint) * num );
+
+     direct_memcpy( rects, source_rects, sizeof(DFBRectangle) * num );
+     direct_memcpy( points, dest_points, sizeof(DFBPoint) * num );
+
+     for (i=0; i<num; i++) {
+          rects[i].x += sx;
+          rects[i].y += sy;
+
+          points[i].x += dx;
+          points[i].y += dy;
+
+          if (!dfb_rectangle_intersect( &rects[i], &src_data->area.current ))
+               rects[i].w = rects[i].h = 0;
+
+          points[i].x += rects[i].x - (source_rects[i].x + sx);
+          points[i].y += rects[i].y - (source_rects[i].y + sy);
+
+          D_DEBUG_AT( Surface, "     [%3d] %4d,%4d - %dx%4d -> %4d,%4d\n",
+                      i, DFB_RECTANGLE_VALS(&source_rects[i]), dest_points[i].x, dest_points[i].y );
+     }
+
+     CoreGraphicsStateClient_Flush( &src_data->state_client, 0, CGSCFF_NONE );
+
+     dfb_state_set_source( &data->state, src_data->surface );
+
+     dfb_state_set_from( &data->state, CSBR_FRONT, src_data->src_eye );
+
+     /* fetch the source color key from the source if necessary */
+     if (data->state.blittingflags & DSBLIT_SRC_COLORKEY)
+          dfb_state_set_src_colorkey( &data->state, src_data->src_key.value );
+
+     CoreGraphicsStateClient_Blit( &data->state_client, rects, points, num );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_BatchBlit2( IDirectFBSurface   *thiz,
+                             IDirectFBSurface   *source,
+                             IDirectFBSurface   *source2,
+                             const DFBRectangle *source_rects,
+                             const DFBPoint     *dest_points,
+                             const DFBPoint     *source2_points,
+                             int                 num )
+{
+     int                    i, dx, dy, sx, sy, sx2, sy2;
+     DFBRectangle          *rects;
+     DFBPoint              *points;
+     DFBPoint              *points2;
+     IDirectFBSurface_data *src_data;
+     IDirectFBSurface_data *src2_data;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     if (!data->surface)
+          return DFB_DESTROYED;
+
+     if (!source || !source_rects || !dest_points || num < 1)
+          return DFB_INVARG;
+
+     if (!data->area.current.w || !data->area.current.h)
+          return DFB_INVAREA;
+
+     if (data->locked)
+          return DFB_LOCKED;
+
+
+     src_data = (IDirectFBSurface_data*)source->priv;
+
+     if (!src_data->area.current.w || !src_data->area.current.h)
+          return DFB_INVAREA;
+
+     src2_data = (IDirectFBSurface_data*)source2->priv;
+
+     if (!src2_data->area.current.w || !src2_data->area.current.h)
+          return DFB_INVAREA;
+
+
+     dx = data->area.wanted.x;
+     dy = data->area.wanted.y;
+
+     sx = src_data->area.wanted.x;
+     sy = src_data->area.wanted.y;
+
+     sx2 = src2_data->area.wanted.x;
+     sy2 = src2_data->area.wanted.y;
+
+     rects   = alloca( sizeof(DFBRectangle) * num );
+     points  = alloca( sizeof(DFBPoint) * num );
+     points2 = alloca( sizeof(DFBPoint) * num );
+
+     direct_memcpy( rects, source_rects, sizeof(DFBRectangle) * num );
+     direct_memcpy( points, dest_points, sizeof(DFBPoint) * num );
+     direct_memcpy( points2, source2_points, sizeof(DFBPoint) * num );
+
+     for (i=0; i<num; i++) {
+          DFBRectangle rect2;
+
+          rects[i].x += sx;
+          rects[i].y += sy;
+
+          points[i].x += dx;
+          points[i].y += dy;
+
+          points2[i].x += sx2;
+          points2[i].y += sy2;
+
+          if (!dfb_rectangle_intersect( &rects[i], &src_data->area.current ))
+               rects[i].w = rects[i].h = 0;
+          else {
+               points[i].x += rects[i].x - (source_rects[i].x + sx);
+               points[i].y += rects[i].y - (source_rects[i].y + sy);
+               points2[i].x += rects[i].x - (source_rects[i].x + sx);
+               points2[i].y += rects[i].y - (source_rects[i].y + sy);
+
+
+               rect2.x = points2[i].x;
+               rect2.y = points2[i].y;
+               rect2.w = rects[i].w;
+               rect2.h = rects[i].h;
+
+               if (!dfb_rectangle_intersect( &rect2, &src2_data->area.current ))
+                    rects[i].w = rects[i].h = 0;
+
+               points[i].x += rect2.x - points2[i].x;
+               points[i].y += rect2.y - points2[i].y;
+               points2[i].x += rect2.x - points2[i].x;
+               points2[i].y += rect2.y - points2[i].y;
+
+               rects[i].w = rect2.w;
+               rects[i].h = rect2.h;
+          }
+     }
+
+     CoreGraphicsStateClient_Flush( &src_data->state_client, 0, CGSCFF_NONE );
+     CoreGraphicsStateClient_Flush( &src2_data->state_client, 0, CGSCFF_NONE );
+
+     dfb_state_set_source( &data->state, src_data->surface );
+     dfb_state_set_source2( &data->state, src2_data->surface );
+
+     dfb_state_set_from( &data->state, CSBR_FRONT, src_data->src_eye );
+
+     /* fetch the source color key from the source if necessary */
+     if (data->state.blittingflags & DSBLIT_SRC_COLORKEY)
+          dfb_state_set_src_colorkey( &data->state, src_data->src_key.value );
+
+     CoreGraphicsStateClient_Blit2( &data->state_client, rects, points, points2, num );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_BatchStretchBlit( IDirectFBSurface   *thiz,
+                                   IDirectFBSurface   *source,
+                                   const DFBRectangle *source_rects,
+                                   const DFBRectangle *dest_rects,
+                                   int                 num )
+{
+     int i, dx, dy, sx, sy;
+     DFBRectangle *srects, *drects;
+     IDirectFBSurface_data *src_data;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p, %d )\n", __FUNCTION__, thiz, num );
+
+     if (!data->surface)
+          return DFB_DESTROYED;
+
+
+     if (!data->area.current.w || !data->area.current.h)
+          return DFB_INVAREA;
+
+     if (data->locked)
+          return DFB_LOCKED;
+
+     if (!source || !source_rects || !dest_rects || num < 1)
+          return DFB_INVARG;
+
+
+     src_data = (IDirectFBSurface_data*)source->priv;
+
+     if (!src_data->area.current.w || !src_data->area.current.h)
+          return DFB_INVAREA;
+
+     dx = data->area.wanted.x;
+     dy = data->area.wanted.y;
+
+     sx = src_data->area.wanted.x;
+     sy = src_data->area.wanted.y;
+
+     srects = alloca( sizeof(DFBRectangle) * num );
+     drects = alloca( sizeof(DFBRectangle) * num );
+
+     direct_memcpy( srects, source_rects, sizeof(DFBRectangle) * num );
+     direct_memcpy( drects, dest_rects, sizeof(DFBRectangle) * num );
+
+     for (i=0; i<num; ++i) {
+          DFBRectangle orig_src;
+
+          if (drects[i].w < 1 || drects[i].h < 1) {
+               drects[i].w = 0;
+               drects[i].h = 0;
+               continue;
+          }
+          drects[i].x += dx;
+          drects[i].y += dy;
+
+          if (srects[i].w < 1 || srects[i].h < 1)
+               return DFB_INVARG;
+          srects[i].x += sx;
+          srects[i].y += sy;
+
+          /* clipping of the source rectangle must be applied to the destination */
+          orig_src = srects[i];
+
+          if (!dfb_rectangle_intersect( &srects[i], &src_data->area.current )) {
+               srects[i].w = srects[i].h = 0;
+               drects[i].w = drects[i].h = 0;
+               continue;
+          }
+
+          if (srects[i].x != orig_src.x)
+               drects[i].x += (int)( (srects[i].x - orig_src.x) *
+                                     (drects[i].w / (float)orig_src.w) + 0.5f);
+
+          if (srects[i].y != orig_src.y)
+               drects[i].y += (int)( (srects[i].y - orig_src.y) *
+                                     (drects[i].h / (float)orig_src.h) + 0.5f);
+
+          if (srects[i].w != orig_src.w)
+               drects[i].w = D_ICEIL(drects[i].w * (srects[i].w / (float)orig_src.w));
+          if (srects[i].h != orig_src.h)
+               drects[i].h = D_ICEIL(drects[i].h * (srects[i].h / (float)orig_src.h));
+
+          D_DEBUG_AT( Surface, "  -> [%2d] %4d,%4d-%4dx%4d <- %4d,%4d-%4dx%4d\n",
+                      i, drects[i].x, drects[i].y, drects[i].w, drects[i].h,
+                      srects[i].x, srects[i].y, srects[i].w, srects[i].h );
+     }
+
+     CoreGraphicsStateClient_Flush( &src_data->state_client, 0, CGSCFF_NONE );
+
+     dfb_state_set_source( &data->state, src_data->surface );
+
+     dfb_state_set_from( &data->state, CSBR_FRONT, src_data->src_eye );
+
+     /* fetch the source color key from the source if necessary */
+     if (data->state.blittingflags & DSBLIT_SRC_COLORKEY)
+          dfb_state_set_src_colorkey( &data->state, src_data->src_key.value );
+
+     CoreGraphicsStateClient_StretchBlit( &data->state_client, srects, drects, num );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_StretchBlit( IDirectFBSurface   *thiz,
+                              IDirectFBSurface   *source,
+                              const DFBRectangle *source_rect,
+                              const DFBRectangle *destination_rect )
+{
+     DFBRectangle srect, drect;
+
+     if (!source)
+          return DFB_INVARG;
+
+     if (destination_rect)
+          drect = *destination_rect;
+     else {
+          DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+          drect = (DFBRectangle) { 0, 0, data->area.wanted.w, data->area.wanted.h };
+     }
+
+     if (source_rect)
+          srect = *source_rect;
+     else {
+          IDirectFBSurface_data *sd = (IDirectFBSurface_data*)source->priv;
+
+          srect = (DFBRectangle) { 0, 0, sd->area.wanted.w, sd->area.wanted.h };
+     }
+
+     return IDirectFBSurface_BatchStretchBlit( thiz, source, &srect, &drect, 1 );
+}
+
+#define SET_VERTEX(v,X,Y,Z,W,S,T)  \
+     do {                          \
+          (v)->x = X;              \
+          (v)->y = Y;              \
+          (v)->z = Z;              \
+          (v)->w = W;              \
+          (v)->s = S;              \
+          (v)->t = T;              \
+     } while (0)
+
+static DFBResult
+IDirectFBSurface_TextureTriangles( IDirectFBSurface     *thiz,
+                                   IDirectFBSurface     *source,
+                                   const DFBVertex      *vertices,
+                                   const int            *indices,
+                                   int                   num,
+                                   DFBTriangleFormation  formation )
+{
+     int                    i;
+     DFBVertex             *translated;
+     IDirectFBSurface_data *src_data;
+     bool                   src_sub;
+     float                  x0 = 0;
+     float                  y0 = 0;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     if (!data->surface)
+          return DFB_DESTROYED;
+
+
+     if (!data->area.current.w || !data->area.current.h)
+          return DFB_INVAREA;
+
+     if (data->locked)
+          return DFB_LOCKED;
+
+     if (!source || !vertices || num < 3)
+          return DFB_INVARG;
+
+     src_data = (IDirectFBSurface_data*)source->priv;
+
+     if ((src_sub = (src_data->caps & DSCAPS_SUBSURFACE))) {
+          D_ONCE( "sub surface texture not fully working with 'repeated' mapping" );
+
+          x0 = data->area.wanted.x;
+          y0 = data->area.wanted.y;
+     }
+
+     switch (formation) {
+          case DTTF_LIST:
+               if (num % 3)
+                    return DFB_INVARG;
+               break;
+
+          case DTTF_STRIP:
+          case DTTF_FAN:
+               break;
+
+          default:
+               return DFB_INVARG;
+     }
+
+     translated = alloca( num * sizeof(DFBVertex) );
+     if (!translated)
+          return DFB_NOSYSTEMMEMORY;
+
+     /* TODO: pass indices through to driver */
+     if (src_sub) {
+          float oowidth  = 1.0f / src_data->surface->config.size.w;
+          float ooheight = 1.0f / src_data->surface->config.size.h;
+
+          float s0 = src_data->area.wanted.x * oowidth;
+          float t0 = src_data->area.wanted.y * ooheight;
+
+          float fs = src_data->area.wanted.w * oowidth;
+          float ft = src_data->area.wanted.h * ooheight;
+
+          for (i=0; i<num; i++) {
+               const DFBVertex *in  = &vertices[ indices ? indices[i] : i ];
+               DFBVertex       *out = &translated[i];
+
+               SET_VERTEX( out, x0 + in->x, y0 + in->y, in->z, in->w,
+                           s0 + fs * in->s, t0 + ft * in->t );
+          }
+     }
+     else {
+          if (indices) {
+               for (i=0; i<num; i++) {
+                    const DFBVertex *in  = &vertices[ indices[i] ];
+                    DFBVertex       *out = &translated[i];
+
+                    SET_VERTEX( out, x0 + in->x, y0 + in->y, in->z, in->w, in->s, in->t );
+               }
+          }
+          else {
+               direct_memcpy( translated, vertices, num * sizeof(DFBVertex) );
+
+               for (i=0; i<num; i++) {
+                    translated[i].x += x0;
+                    translated[i].y += y0;
+               }
+          }
+     }
+
+     CoreGraphicsStateClient_Flush( &src_data->state_client, 0, CGSCFF_NONE );
+
+     dfb_state_set_source( &data->state, src_data->surface );
+
+     dfb_state_set_from( &data->state, CSBR_FRONT, src_data->src_eye );
+
+     /* fetch the source color key from the source if necessary */
+     if (data->state.blittingflags & DSBLIT_SRC_COLORKEY)
+          dfb_state_set_src_colorkey( &data->state, src_data->src_key.value );
+
+     CoreGraphicsStateClient_TextureTriangles( &data->state_client, translated, num, formation );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_DrawString( IDirectFBSurface *thiz,
+                             const char *text, int bytes,
+                             int x, int y,
+                             DFBSurfaceTextFlags flags )
+{
+     DFBResult           ret;
+     IDirectFBFont      *font;
+     IDirectFBFont_data *font_data;
+     CoreFont           *core_font;
+     unsigned int        layers = 1;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     if (!data->surface)
+          return DFB_DESTROYED;
+
+     if (!text)
+          return DFB_INVARG;
+
+     if (!data->area.current.w || !data->area.current.h)
+          return DFB_INVAREA;
+
+     if (data->locked)
+          return DFB_LOCKED;
+
+     if (!data->font)
+          return DFB_MISSINGFONT;
+
+     if (bytes < 0)
+          bytes = strlen (text);
+
+     if (bytes == 0)
+          return DFB_OK;
+
+     font = data->font;
+
+     DIRECT_INTERFACE_GET_DATA_FROM( font, font_data, IDirectFBFont );
+
+     if(!font_data)
+          return DFB_DESTROYED;
+
+     if (core_dfb->shutdown_running)
+          return DFB_OK;
+
+     core_font = font_data->font;
+
+     if (flags & DSTF_OUTLINE) {
+          if (!(core_font->attributes & DFFA_OUTLINED))
+               return DFB_UNSUPPORTED;
+
+          layers = 2;
+     }
+
+     if (!(flags & DSTF_TOP)) {
+          x += core_font->ascender * core_font->up_unit_x;
+          y += core_font->ascender * core_font->up_unit_y;
+
+          if (flags & DSTF_BOTTOM) {
+               x -= core_font->descender * core_font->up_unit_x;
+               y -= core_font->descender * core_font->up_unit_y;
+          }
+     }
+
+     if (flags & (DSTF_RIGHT | DSTF_CENTER)) {
+          int          i, num, kx, ky;
+          int          xsize = 0;
+          int          ysize = 0;
+          unsigned int prev = 0;
+          unsigned int indices[bytes];
+
+          /* FIXME: Avoid double locking and decoding. */
+          dfb_font_lock( core_font );
+
+          /* Decode string to character indices. */
+          ret = dfb_font_decode_text( core_font, data->encoding, text, bytes, indices, &num );
+          if (ret) {
+               dfb_font_unlock( core_font );
+               return ret;
+          }
+
+          D_ASSERT( num <= bytes );
+
+          /* Calculate string width. */
+          for (i=0; i<num; i++) {
+               unsigned int   current = indices[i];
+               CoreGlyphData *glyph;
+
+               if (dfb_font_get_glyph_data( core_font, current, 0, &glyph ) == DFB_OK) {
+                    xsize += glyph->xadvance;
+                    ysize += glyph->yadvance;
+
+                    if (prev && core_font->GetKerning &&
+                        core_font->GetKerning( core_font, prev, current, &kx, &ky ) == DFB_OK) {
+                         xsize += kx << 8;
+                         ysize += ky << 8;
+                    }
+               }
+
+               prev = current;
+          }
+
+          dfb_font_unlock( core_font );
+
+          /* Justify. */
+          if (flags & DSTF_RIGHT) {
+               x -= xsize >> 8;
+               y -= ysize >> 8;
+          }
+          else if (flags & DSTF_CENTER) {
+               x -= xsize >> 9;
+               y -= ysize >> 9;
+          }
+     }
+
+     dfb_gfxcard_drawstring( (const unsigned char*) text, bytes, data->encoding,
+                             data->area.wanted.x + x, data->area.wanted.y + y,
+                             core_font, layers, &data->state_client, flags );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_DrawGlyph( IDirectFBSurface *thiz,
+                            unsigned int character, int x, int y,
+                            DFBSurfaceTextFlags flags )
+{
+     DFBResult           ret;
+     int                 l;
+     IDirectFBFont      *font;
+     IDirectFBFont_data *font_data;
+     CoreFont           *core_font;
+     CoreGlyphData      *glyph[DFB_FONT_MAX_LAYERS];
+     unsigned int        index;
+     unsigned int        layers = 1;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p, 0x%x, %d,%d, 0x%x )\n",
+                 __FUNCTION__, thiz, character, x, y, flags );
+
+     if (!data->surface)
+          return DFB_DESTROYED;
+
+     if (!character)
+          return DFB_INVARG;
+
+     if (!data->area.current.w || !data->area.current.h)
+          return DFB_INVAREA;
+
+     if (data->locked)
+          return DFB_LOCKED;
+
+     if (!data->font)
+          return DFB_MISSINGFONT;
+
+     font = data->font;
+
+     DIRECT_INTERFACE_GET_DATA_FROM( font, font_data, IDirectFBFont );
+
+     if (!font_data)
+          return DFB_DESTROYED;
+
+     if (core_dfb->shutdown_running)
+          return DFB_OK;
+
+     core_font = font_data->font;
+
+     if (flags & DSTF_OUTLINE) {
+          if (!(core_font->attributes & DFFA_OUTLINED))
+               return DFB_UNSUPPORTED;
+
+          layers = 2;
+     }
+
+     dfb_font_lock( core_font );
+
+     ret = dfb_font_decode_character( core_font, data->encoding, character, &index );
+     if (ret) {
+          dfb_font_unlock( core_font );
+          return ret;
+     }
+
+     for (l=0; l<layers; l++) {
+          ret = dfb_font_get_glyph_data( core_font, index, l, &glyph[l] );
+          if (ret) {
+               dfb_font_unlock( core_font );
+               return ret;
+          }
+     }
+
+     if (!(flags & DSTF_TOP)) {
+          x += core_font->ascender * core_font->up_unit_x;
+          y += core_font->ascender * core_font->up_unit_y;
+
+          if (flags & DSTF_BOTTOM) {
+               x -= core_font->descender * core_font->up_unit_x;
+               y -= core_font->descender * core_font->up_unit_y;
+          }
+     }
+
+     if (flags & (DSTF_RIGHT | DSTF_CENTER)) {
+          if (flags & DSTF_RIGHT) {
+               x -= glyph[0]->xadvance;
+               y -= glyph[0]->yadvance;
+          }
+          else if (flags & DSTF_CENTER) {
+               x -= glyph[0]->xadvance >> 1;
+               y -= glyph[0]->yadvance >> 1;
+          }
+     }
+
+     dfb_gfxcard_drawglyph( glyph,
+                            data->area.wanted.x + x, data->area.wanted.y + y,
+                            core_font, layers, &data->state_client, flags );
+
+     dfb_font_unlock( core_font );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_SetEncoding( IDirectFBSurface  *thiz,
+                              DFBTextEncodingID  encoding )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p, %d )\n", __FUNCTION__, thiz, encoding );
+
+     /* TODO: check for support or fail later? */
+     data->encoding = encoding;
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_GetSubSurface( IDirectFBSurface    *thiz,
+                                const DFBRectangle  *rect,
+                                IDirectFBSurface   **surface )
+{
+     DFBResult ret;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     /* Check arguments */
+     if (!data->surface)
+          return DFB_DESTROYED;
+
+     if (!surface)
+          return DFB_INVARG;
+
+     /* Allocate interface */
+     DIRECT_ALLOCATE_INTERFACE( *surface, IDirectFBSurface );
+
+     if (rect || data->limit_set) {
+          DFBRectangle wanted, granted;
+
+          /* Compute wanted rectangle */
+          if (rect) {
+               wanted = *rect;
+
+               wanted.x += data->area.wanted.x;
+               wanted.y += data->area.wanted.y;
+
+               if (wanted.w <= 0 || wanted.h <= 0) {
+                    wanted.w = 0;
+                    wanted.h = 0;
+               }
+          }
+          else {
+               wanted = data->area.wanted;
+          }
+
+          /* Compute granted rectangle */
+          granted = wanted;
+
+          dfb_rectangle_intersect( &granted, &data->area.granted );
+
+          /* Construct */
+          ret = IDirectFBSurface_Construct( *surface, thiz,
+                                            &wanted, &granted, &data->area.insets,
+                                            data->surface,
+                                            data->caps | DSCAPS_SUBSURFACE, data->core, data->idirectfb );
+     }
+     else {
+          /* Construct */
+          ret = IDirectFBSurface_Construct( *surface, thiz,
+                                            NULL, NULL, &data->area.insets,
+                                            data->surface,
+                                            data->caps | DSCAPS_SUBSURFACE, data->core, data->idirectfb );
+     }
+
+     return ret;
+}
+
+static DFBResult
+IDirectFBSurface_MakeSubSurface( IDirectFBSurface   *thiz,
+                                 IDirectFBSurface   *from,
+                                 const DFBRectangle *rect )
+{
+     CoreSurface           *surface;
+     DFBRectangle           wanted, granted;
+     DFBRectangle           full_rect;
+     IDirectFBSurface_data *from_data;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     /* Check arguments */
+     if (!from)
+          return DFB_INVARG;
+
+     surface = data->surface;
+     if (!surface)
+          return DFB_DESTROYED;
+
+     DIRECT_INTERFACE_GET_DATA_FROM(from, from_data, IDirectFBSurface);
+
+     if (!from_data)
+          return DFB_DESTROYED;
+
+     /* Check if CoreSurface is the same */
+     if (from_data->surface != surface)
+          return DFB_UNSUPPORTED;
+
+
+     full_rect.x = 0;
+     full_rect.y = 0;
+     full_rect.w = surface->config.size.w;
+     full_rect.h = surface->config.size.h;
+
+     if (rect || from_data->limit_set) {
+          /* Compute wanted rectangle */
+          if (rect) {
+               wanted = *rect;
+
+               wanted.x += from_data->area.wanted.x;
+               wanted.y += from_data->area.wanted.y;
+
+               if (wanted.w <= 0 || wanted.h <= 0) {
+                    wanted.w = 0;
+                    wanted.h = 0;
+               }
+          }
+          else {
+               wanted = from_data->area.wanted;
+          }
+
+          /* Compute granted rectangle */
+          granted = wanted;
+
+          dfb_rectangle_intersect( &granted, &from_data->area.granted );
+     }
+     else {
+          wanted  = full_rect;
+          granted = full_rect;
+     }
+
+
+     data->caps |= DSCAPS_SUBSURFACE;
+
+
+     data->area.wanted  = wanted;
+     data->area.granted = granted;
+
+     data->area.current = data->area.granted;
+     dfb_rectangle_intersect( &data->area.current, &full_rect );
+
+
+     data->state.clip.x1   = data->area.current.x;
+     data->state.clip.y1   = data->area.current.y;
+     data->state.clip.x2   = data->area.current.x + (data->area.current.w ? : 1) - 1;
+     data->state.clip.y2   = data->area.current.y + (data->area.current.h ? : 1) - 1;
+
+     data->state.modified |= SMF_CLIP;
+
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_GetGL( IDirectFBSurface   *thiz,
+                        IDirectFBGL       **interface )
+{
+     DFBResult ret;
+     DirectInterfaceFuncs *funcs = NULL;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     if (!data->surface)
+          return DFB_DESTROYED;
+
+     if (!interface)
+          return DFB_INVARG;
+
+     if (!data->area.current.w || !data->area.current.h)
+          return DFB_INVAREA;
+
+
+     ret = DirectGetInterface( &funcs, "IDirectFBGL", NULL, DirectProbeInterface, thiz );
+     if (ret)
+          return ret;
+
+     ret = funcs->Allocate( (void**)interface );
+     if (ret)
+          return ret;
+
+     ret = funcs->Construct( *interface, thiz, data->idirectfb );
+     if (ret)
+          *interface = NULL;
+
+     return ret;
+}
+
+static DFBResult
+IDirectFBSurface_Dump( IDirectFBSurface   *thiz,
+                       const char         *directory,
+                       const char         *prefix )
+{
+     CoreSurface *surface;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     if (!directory)
+          return DFB_INVARG;
+
+     if (!data->area.current.w || !data->area.current.h)
+          return DFB_INVAREA;
+
+     if (data->caps & DSCAPS_SUBSURFACE) {
+          D_ONCE( "sub surface dumping not supported yet" );
+          return DFB_UNSUPPORTED;
+     }
+
+     surface = data->surface;
+     if (!surface)
+          return DFB_DESTROYED;
+
+     CoreGraphicsStateClient_FlushCurrent( 0 );
+
+     return dfb_surface_dump_buffer2( surface, CSBR_FRONT, DSSE_LEFT, directory, prefix );
+}
+
+static DFBResult
+IDirectFBSurface_DumpRaw( IDirectFBSurface   *thiz,
+                          const char         *directory,
+                          const char         *prefix )
+{
+     CoreSurface *surface;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     if (!directory)
+          return DFB_INVARG;
+
+     if (!data->area.current.w || !data->area.current.h)
+          return DFB_INVAREA;
+
+     if (data->caps & DSCAPS_SUBSURFACE) {
+          D_ONCE( "sub surface dumping not supported yet" );
+          return DFB_UNSUPPORTED;
+     }
+
+     surface = data->surface;
+     if (!surface)
+          return DFB_DESTROYED;
+
+     return dfb_surface_dump_raw_buffer( surface, CSBR_FRONT, directory, prefix );
+}
+
+static DFBResult
+IDirectFBSurface_DisableAcceleration( IDirectFBSurface    *thiz,
+                                      DFBAccelerationMask  mask )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     if (D_FLAGS_INVALID( mask, DFXL_ALL ))
+          return DFB_INVARG;
+
+     data->state.disabled = mask;
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_ReleaseSource( IDirectFBSurface *thiz )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     dfb_state_set_source( &data->state, NULL );
+     dfb_state_set_source_mask( &data->state, NULL );
+     dfb_state_set_source2( &data->state, NULL );
+
+     CoreGraphicsStateClient_ReleaseSource( &data->state_client );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_SetRenderOptions( IDirectFBSurface        *thiz,
+                                   DFBSurfaceRenderOptions  options )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     dfb_state_set_render_options( &data->state, options );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_SetMatrix( IDirectFBSurface *thiz,
+                            const s32        *matrix )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p, %p )\n", __FUNCTION__, thiz, matrix );
+
+     if (!matrix)
+          return DFB_INVARG;
+
+     dfb_state_set_matrix( &data->state, matrix );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_SetSourceMask( IDirectFBSurface    *thiz,
+                                IDirectFBSurface    *mask,
+                                int                  x,
+                                int                  y,
+                                DFBSurfaceMaskFlags  flags )
+{
+     DFBResult              ret;
+     DFBPoint               offset = { x, y };
+     IDirectFBSurface_data *mask_data;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p, %p, %d,%d, 0x%04x )\n", __FUNCTION__, thiz, mask, x, y, flags );
+
+     if (!mask || flags & ~DSMF_ALL)
+          return DFB_INVARG;
+
+     DIRECT_INTERFACE_GET_DATA_FROM(mask, mask_data, IDirectFBSurface);
+
+     if (!mask_data)
+          return DFB_DESTROYED;
+
+     if (!mask_data->surface)
+          return DFB_DESTROYED;
+
+     CoreGraphicsStateClient_Flush( &mask_data->state_client, 0, CGSCFF_NONE );
+
+     ret = dfb_state_set_source_mask( &data->state, mask_data->surface );
+     if (ret)
+          return ret;
+
+     dfb_state_set_source_mask_vals( &data->state, &offset, flags );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_GetStereoEye( IDirectFBSurface    *thiz,
+                               DFBSurfaceStereoEye *ret_eye )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p, %p )\n", __FUNCTION__, thiz, ret_eye );
+
+     if (!data->surface)
+          return DFB_DESTROYED;
+
+     if (!(data->surface->config.caps & DSCAPS_STEREO))
+          return DFB_UNSUPPORTED;
+
+     *ret_eye = data->src_eye;
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_SetStereoEye( IDirectFBSurface    *thiz,
+                               DFBSurfaceStereoEye  eye )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p, %d )\n", __FUNCTION__, thiz, eye );
+
+     if (!data->surface)
+          return DFB_DESTROYED;
+
+     if (!(data->surface->config.caps & DSCAPS_STEREO))
+          return DFB_UNSUPPORTED;
+
+     dfb_state_set_to( &data->state, CSBR_BACK, eye );
+
+     data->src_eye = eye;
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_FlipStereo( IDirectFBSurface    *thiz,
+                             const DFBRegion     *left_region,
+                             const DFBRegion     *right_region,
+                             DFBSurfaceFlipFlags  flags )
+{
+     DFBResult ret = DFB_OK;
+     DFBRegion l_reg, r_reg;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p, %p, %p, 0x%08x )\n", __FUNCTION__, thiz, left_region, right_region, flags );
+
+     if (!data->surface)
+          return DFB_DESTROYED;
+
+     if (!(data->surface->config.caps & DSCAPS_STEREO))
+          return DFB_UNSUPPORTED;
+
+     if (data->locked)
+          return DFB_LOCKED;
+
+     if (!data->area.current.w || !data->area.current.h ||
+         (left_region && (left_region->x1 > left_region->x2 || left_region->y1 > left_region->y2)) ||
+         (right_region && (right_region->x1 > right_region->x2 || right_region->y1 > right_region->y2)))
+          return DFB_INVAREA;
+
+
+     IDirectFBSurface_StopAll( data );
+
+     if (data->parent) {
+          IDirectFBSurface_data *parent_data;
+
+          DIRECT_INTERFACE_GET_DATA_FROM( data->parent, parent_data, IDirectFBSurface );
+
+          if (parent_data) {
+               /* Signal end of sequence of operations. */
+               dfb_state_lock( &parent_data->state );
+               dfb_state_stop_drawing( &parent_data->state );
+               dfb_state_unlock( &parent_data->state );
+          }
+     }
+
+     dfb_region_from_rectangle( &l_reg, &data->area.current );
+     dfb_region_from_rectangle( &r_reg, &data->area.current );
+
+     if (left_region) {
+          DFBRegion clip = DFB_REGION_INIT_TRANSLATED( left_region,
+                                                       data->area.wanted.x,
+                                                       data->area.wanted.y );
+
+          if (!dfb_region_region_intersect( &l_reg, &clip ))
+               return DFB_INVAREA;
+     }
+     if (right_region) {
+          DFBRegion clip = DFB_REGION_INIT_TRANSLATED( right_region,
+                                                       data->area.wanted.x,
+                                                       data->area.wanted.y );
+
+          if (!dfb_region_region_intersect( &r_reg, &clip ))
+               return DFB_INVAREA;
+     }
+
+     D_DEBUG_AT( Surface, "  -> FLIPSTEREO Left: %4d,%4d-%4dx%4d Right: %4d,%4d-%4dx%4d\n",
+                 DFB_RECTANGLE_VALS_FROM_REGION( &l_reg ), DFB_RECTANGLE_VALS_FROM_REGION( &r_reg ) );
+
+     CoreGraphicsStateClient_FlushCurrent( 0 );
+
+     data->local_flip_buffers = data->surface->num_buffers;
+
+     if (dfb_config->force_frametime && !data->current_frame_time)
+          thiz->GetFrameTime( thiz, &data->current_frame_time );
+
+     if (data->surface->config.caps & DSCAPS_FLIPPING) {
+          if ((flags & DSFLIP_SWAP) || (!(flags & DSFLIP_BLIT) &&
+                                        l_reg.x1 == 0 && l_reg.y1 == 0 &&
+                                        l_reg.x2 == data->surface->config.size.w - 1 &&
+                                        l_reg.y2 == data->surface->config.size.h - 1 &&
+                                        r_reg.x1 == 0 && r_reg.y1 == 0 &&
+                                        r_reg.x2 == data->surface->config.size.w - 1 &&
+                                        r_reg.y2 == data->surface->config.size.h - 1))
+               data->local_flip_count++;
+     }
+
+     ret = CoreSurface_Flip2( data->surface, DFB_FALSE, &l_reg, &r_reg, flags, data->current_frame_time );
+
+     data->current_frame_time = 0;
+
+     if (ret)
+          return ret;
+
+     IDirectFBSurface_WaitForBackBuffer( data );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_SetWriteMaskBits( IDirectFBSurface *thiz,
+                                   u64               bits )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p, MASK 0x%08zx )\n", __FUNCTION__, thiz, (size_t)bits );
+
+     dfb_state_set_write_mask_bits( &data->state, bits );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_SetRop( IDirectFBSurface      *thiz,
+                         DFBSurfaceRopCode      rop_code,
+                         const DFBColor        *fg_color,
+                         const DFBColor        *bg_color,
+                         const u32             *pattern,
+                         DFBSurfacePatternMode  pattern_mode )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p, CODE 0x%02x )\n", __FUNCTION__, thiz, rop_code );
+
+     dfb_state_set_rop_code( &data->state, rop_code );
+     dfb_state_set_rop_fg_color( &data->state, fg_color );
+     dfb_state_set_rop_bg_color( &data->state, bg_color );
+     dfb_state_set_rop_pattern( &data->state, pattern, pattern_mode );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_SetSrcColorKeyExtended( IDirectFBSurface          *thiz,
+                                         const DFBColorKeyExtended *colorkey_extended )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     dfb_state_set_src_colorkey_extended( &data->state, colorkey_extended );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_SetDstColorKeyExtended( IDirectFBSurface          *thiz,
+                                         const DFBColorKeyExtended *colorkey_extended )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     dfb_state_set_dst_colorkey_extended( &data->state, colorkey_extended );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_DrawMonoGlyphs( IDirectFBSurface             *thiz,
+                                 const void                   *glyphs[],
+                                 const DFBMonoGlyphAttributes *attributes,
+                                 const DFBPoint               *dest_points,
+                                 unsigned int                  num )
+{
+     int       i, dx, dy;
+     DFBPoint *points;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     if (!data->surface)
+          return DFB_DESTROYED;
+
+     if (!glyphs || !attributes || !dest_points || num < 1)
+          return DFB_INVARG;
+
+     if (!data->area.current.w || !data->area.current.h)
+          return DFB_INVAREA;
+
+     if (data->locked)
+          return DFB_LOCKED;
+
+     dx = data->area.wanted.x;
+     dy = data->area.wanted.y;
+
+     points = alloca( sizeof(DFBPoint) * num );
+
+     for (i=0; i<num; i++) {
+          points[i].x = dest_points[i].x + dx;
+          points[i].y = dest_points[i].y + dy;
+     }
+
+     dfb_gfxcard_draw_mono_glyphs( glyphs, attributes, points, num, &data->state );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_SetSrcColorMatrix( IDirectFBSurface *thiz,
+                                    const s32        *matrix )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p, %p )\n", __FUNCTION__, thiz, matrix );
+
+     if (!matrix)
+          return DFB_INVARG;
+
+     dfb_state_set_src_colormatrix( &data->state, matrix );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_SetSrcConvolution( IDirectFBSurface           *thiz,
+                                    const DFBConvolutionFilter *filter )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p, %p )\n", __FUNCTION__, thiz, filter );
+
+     if (!filter)
+          return DFB_INVARG;
+
+     dfb_state_set_src_convolution( &data->state, filter );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_GetID( IDirectFBSurface *thiz,
+                        DFBSurfaceID     *ret_id )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     if (!data->surface)
+          return DFB_DESTROYED;
+
+     if (!ret_id)
+          return DFB_INVARG;
+
+     *ret_id = data->surface->object.id;
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_AllowAccess( IDirectFBSurface *thiz,
+                              const char       *executable )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     if (!data->surface)
+          return DFB_DESTROYED;
+
+     return CoreDFB_AllowSurface( data->core, data->surface, executable, strlen(executable)+1 );
+}
+
+static DFBResult
+IDirectFBSurface_CreateEventBuffer( IDirectFBSurface      *thiz,
+                                    IDirectFBEventBuffer **ret_buffer )
+{
+     IDirectFBEventBuffer *buffer;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s()\n", __FUNCTION__ );
+
+     if (!data->surface)
+          return DFB_DESTROYED;
+
+     DIRECT_ALLOCATE_INTERFACE( buffer, IDirectFBEventBuffer );
+
+     IDirectFBEventBuffer_Construct( buffer, NULL, NULL );
+
+     IDirectFBEventBuffer_AttachSurface( buffer, data->surface );
+
+     *ret_buffer = buffer;
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_AttachEventBuffer( IDirectFBSurface     *thiz,
+                                    IDirectFBEventBuffer *buffer )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s()\n", __FUNCTION__ );
+
+     if (!data->surface)
+          return DFB_DESTROYED;
+
+     IDirectFBEventBuffer_AttachSurface( buffer, data->surface );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_DetachEventBuffer( IDirectFBSurface     *thiz,
+                                    IDirectFBEventBuffer *buffer )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s()\n", __FUNCTION__ );
+
+     return IDirectFBEventBuffer_DetachSurface( buffer, data->surface );
+}
+
+static DFBResult
+IDirectFBSurface_MakeClient( IDirectFBSurface *thiz )
+{
+     DFBResult ret;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface_Updates, "%s( %p [%d] )\n", __FUNCTION__, data->surface, data->surface->object.id );
+
+     if (data->surface_client) {
+          D_DEBUG_AT( Surface_Updates, "  -> ALREADY CLIENT!\n" );
+          return DFB_BUSY;
+     }
+
+     ret = CoreSurface_CreateClient( data->surface, &data->surface_client );
+     if (ret)
+          return ret;
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_FrameAck( IDirectFBSurface *thiz,
+                           u32               flip_count )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface_Updates, "%s( %p )\n", __FUNCTION__, thiz );
+
+     if (!data->surface_client)
+          return DFB_UNSUPPORTED;
+
+     direct_mutex_lock( &data->surface_client_lock );
+
+     D_DEBUG_AT( Surface_Updates, "  -> surface %p [%u]\n", data->surface, data->surface->object.id );
+     D_DEBUG_AT( Surface_Updates, "  -> flip count %d\n", flip_count );
+
+     data->surface_client_flip_count = flip_count;
+
+     CoreSurfaceClient_FrameAck( data->surface_client, flip_count );
+
+     direct_mutex_unlock( &data->surface_client_lock );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_GetFrameTime( IDirectFBSurface *thiz,
+                               long long        *ret_micros )
+{
+     long long    now;
+     long long    interval = 0;
+     long long    max = 0;
+     CoreSurface *surface;
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface_Updates, "%s( %p )\n", __FUNCTION__, thiz );
+
+     surface = data->surface;
+     if (!surface)
+          return DFB_DEAD;
+
+     interval = surface->frametime_config.interval;
+
+     D_DEBUG_AT( Surface_Updates, "  -> from surface interval: %lld\n", interval );
+
+     D_DEBUG_AT( Surface_Updates, "  -> config flags: 0x%08x\n", data->frametime_config.flags );
+
+     if (surface->frametime_config.flags & DFTCF_MAX_ADVANCE)
+          max = surface->frametime_config.max_advance;
+
+     if (data->frametime_config.flags & DFTCF_INTERVAL) {
+          interval = data->frametime_config.interval;
+
+          D_DEBUG_AT( Surface_Updates, "  -> local configured interval: %lld\n", interval );
+     }
+
+     if (data->frametime_config.flags & DFTCF_MAX_ADVANCE)
+          max = data->frametime_config.max_advance;
+
+     if (!interval) {
+          interval = 16666;
+
+          D_DEBUG_AT( Surface_Updates, "  -> using fallback default interval: %lld\n", interval );
+     }
+
+     if (!max)
+          max = dfb_config->max_frame_advance;
+
+     data->current_frame_time += interval;
+
+     now = direct_clock_get_time( DIRECT_CLOCK_MONOTONIC );
+
+     if (now > data->current_frame_time)
+          data->current_frame_time = now;
+     else if (max) {
+          while (data->current_frame_time - now > max) {
+               D_DEBUG_AT( Surface_Updates, "  -> sleeping for %lld us...\n", data->current_frame_time - now - max );
+
+               direct_thread_sleep( data->current_frame_time - now - max );
+
+               now = direct_clock_get_time( DIRECT_CLOCK_MONOTONIC );
+          }
+     }
+
+     D_DEBUG_AT( Surface_Updates, "  -> %lld (%lld ahead)\n", data->current_frame_time, data->current_frame_time - now );
+
+     if (ret_micros)
+          *ret_micros = data->current_frame_time;
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBSurface_SetFrameTimeConfig( IDirectFBSurface         *thiz,
+                                     const DFBFrameTimeConfig *config )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBSurface)
+
+     D_DEBUG_AT( Surface_Updates, "%s( %p )\n", __FUNCTION__, thiz );
+
+     if (config) {
+          if (config->flags & DFTCF_INTERVAL)
+               D_DEBUG_AT( Surface_Updates, "  -> interval: %lld\n", config->interval );
+
+          if (config->flags & DFTCF_MAX_ADVANCE)
+               D_DEBUG_AT( Surface_Updates, "  -> max_advance: %lld\n", config->max_advance );
+
+          data->frametime_config = *config;
+     }
+     else
+          memset( &data->frametime_config, 0, sizeof(data->frametime_config) );
+
+     return DFB_OK;
+}
+
+/******/
+
+DFBResult IDirectFBSurface_Construct( IDirectFBSurface       *thiz,
+                                      IDirectFBSurface       *parent,
+                                      DFBRectangle           *wanted,
+                                      DFBRectangle           *granted,
+                                      DFBInsets              *insets,
+                                      CoreSurface            *surface,
+                                      DFBSurfaceCapabilities  caps,
+                                      CoreDFB                *core,
+                                      IDirectFB              *idirectfb )
+{
+     DFBResult    ret;
+     DFBRectangle rect = { 0, 0, surface->config.size.w, surface->config.size.h };
+
+     DIRECT_ALLOCATE_INTERFACE_DATA(thiz, IDirectFBSurface)
+
+     D_DEBUG_AT( Surface, "%s( %p )\n", __FUNCTION__, thiz );
+
+     data->ref       = 1;
+     data->caps      = caps | surface->config.caps;
+     data->core      = core;
+     data->idirectfb = idirectfb;
+
+     if (dfb_surface_ref( surface )) {
+          DIRECT_DEALLOCATE_INTERFACE(thiz);
+          return DFB_FAILURE;
+     }
+
+     D_DEBUG_AT( Surface, "  -> surface %s\n", ToString_CoreSurface( surface ) );
+
+     if (parent && dfb_config->startstop) {
+          IDirectFBSurface_data *parent_data;
+
+          if (parent->AddRef( parent )) {
+               dfb_surface_unref( surface );
+               DIRECT_DEALLOCATE_INTERFACE(thiz);
+               return DFB_FAILURE;
+          }
+
+          DIRECT_INTERFACE_GET_DATA_FROM( parent, parent_data, IDirectFBSurface );
+
+          if(!parent_data)
+               return DFB_DESTROYED;
+
+          pthread_mutex_lock( &parent_data->children_lock );
+
+          direct_list_append( &parent_data->children_data, &data->link );
+
+          pthread_mutex_unlock( &parent_data->children_lock );
+
+          data->parent = parent;
+     }
+
+     pthread_mutex_init( &data->children_lock, NULL );
+
+     direct_waitqueue_init( &data->back_buffer_wq );
+     direct_mutex_init( &data->back_buffer_lock );
+
+     direct_mutex_init( &data->surface_client_lock );
+
+     /* The area insets */
+     if (insets) {
+          data->area.insets = *insets;
+          dfb_rectangle_subtract( &rect, insets );
+     }
+
+     /* The area that was requested */
+     if (wanted)
+          data->area.wanted = *wanted;
+     else
+          data->area.wanted = rect;
+
+     /* The area that will never be exceeded */
+     if (granted)
+          data->area.granted = *granted;
+     else
+          data->area.granted = data->area.wanted;
+
+     /* The currently accessible rectangle */
+     data->area.current = data->area.granted;
+     dfb_rectangle_intersect( &data->area.current, &rect );
+
+     D_DEBUG_AT( Surface, "  -> wanted  " DFB_RECT_FORMAT "\n", DFB_RECTANGLE_VALS( &data->area.wanted ) );
+     D_DEBUG_AT( Surface, "  -> granted " DFB_RECT_FORMAT "\n", DFB_RECTANGLE_VALS( &data->area.granted ) );
+     D_DEBUG_AT( Surface, "  -> current " DFB_RECT_FORMAT "\n", DFB_RECTANGLE_VALS( &data->area.current ) );
+
+     /* Whether granted rectangle is meaningful */
+     data->limit_set = (granted != NULL);
+
+     data->surface = surface;
+
+     dfb_state_init( &data->state, core );
+     dfb_state_set_destination( &data->state, surface );
+
+     data->state.clip.x1  = data->area.current.x;
+     data->state.clip.y1  = data->area.current.y;
+     data->state.clip.x2  = data->area.current.x + (data->area.current.w ? : 1) - 1;
+     data->state.clip.y2  = data->area.current.y + (data->area.current.h ? : 1) - 1;
+
+     data->state.modified = SMF_ALL;
+
+     data->src_eye = DSSE_LEFT;
+
+     D_DEBUG_AT( Surface, "  -> initializing CoreGraphicsStateClient...\n" );
+
+     ret = CoreGraphicsStateClient_Init( &data->state_client, &data->state );
+     if (ret)
+          return ret;    // FIXME: deinit
+
+     if (data->surface->config.flags & CSCONF_PREALLOCATED) {
+
+          ret = register_prealloc( data );
+
+          if (ret)
+               return ret;    // FIXME: deinit
+     }
+
+     thiz->AddRef = IDirectFBSurface_AddRef;
+     thiz->Release = IDirectFBSurface_Release;
+
+     thiz->GetCapabilities = IDirectFBSurface_GetCapabilities;
+     thiz->GetPosition = IDirectFBSurface_GetPosition;
+     thiz->GetSize = IDirectFBSurface_GetSize;
+     thiz->GetVisibleRectangle = IDirectFBSurface_GetVisibleRectangle;
+     thiz->GetPixelFormat = IDirectFBSurface_GetPixelFormat;
+     thiz->GetColorSpace = IDirectFBSurface_GetColorSpace;
+     thiz->GetAccelerationMask = IDirectFBSurface_GetAccelerationMask;
+
+     thiz->GetPalette = IDirectFBSurface_GetPalette;
+     thiz->SetPalette = IDirectFBSurface_SetPalette;
+     thiz->SetAlphaRamp = IDirectFBSurface_SetAlphaRamp;
+
+     thiz->Lock = IDirectFBSurface_Lock;
+     thiz->GetFramebufferOffset = IDirectFBSurface_GetFramebufferOffset;
+     thiz->GetPhysicalAddress = IDirectFBSurface_GetPhysicalAddress;
+     thiz->Unlock = IDirectFBSurface_Unlock;
+     thiz->Flip = IDirectFBSurface_Flip;
+     thiz->SetField = IDirectFBSurface_SetField;
+     thiz->Clear = IDirectFBSurface_Clear;
+
+     thiz->SetClip = IDirectFBSurface_SetClip;
+     thiz->GetClip = IDirectFBSurface_GetClip;
+     thiz->SetColor = IDirectFBSurface_SetColor;
+     thiz->SetColorIndex = IDirectFBSurface_SetColorIndex;
+     thiz->SetSrcBlendFunction = IDirectFBSurface_SetSrcBlendFunction;
+     thiz->SetDstBlendFunction = IDirectFBSurface_SetDstBlendFunction;
+     thiz->SetPorterDuff = IDirectFBSurface_SetPorterDuff;
+     thiz->SetSrcColorKey = IDirectFBSurface_SetSrcColorKey;
+     thiz->SetSrcColorKeyIndex = IDirectFBSurface_SetSrcColorKeyIndex;
+     thiz->SetDstColorKey = IDirectFBSurface_SetDstColorKey;
+     thiz->SetDstColorKeyIndex = IDirectFBSurface_SetDstColorKeyIndex;
+     thiz->SetIndexTranslation = IDirectFBSurface_SetIndexTranslation;
+
+     thiz->SetBlittingFlags = IDirectFBSurface_SetBlittingFlags;
+     thiz->Blit = IDirectFBSurface_Blit;
+     thiz->TileBlit = IDirectFBSurface_TileBlit;
+     thiz->BatchBlit = IDirectFBSurface_BatchBlit;
+     thiz->BatchBlit2 = IDirectFBSurface_BatchBlit2;
+     thiz->StretchBlit = IDirectFBSurface_StretchBlit;
+     thiz->BatchStretchBlit = IDirectFBSurface_BatchStretchBlit;
+     thiz->TextureTriangles = IDirectFBSurface_TextureTriangles;
+
+     thiz->SetDrawingFlags = IDirectFBSurface_SetDrawingFlags;
+     thiz->FillRectangle = IDirectFBSurface_FillRectangle;
+     thiz->DrawLine = IDirectFBSurface_DrawLine;
+     thiz->DrawLines = IDirectFBSurface_DrawLines;
+     thiz->DrawRectangle = IDirectFBSurface_DrawRectangle;
+     thiz->FillTriangle = IDirectFBSurface_FillTriangle;
+     thiz->FillRectangles = IDirectFBSurface_FillRectangles;
+     thiz->FillSpans = IDirectFBSurface_FillSpans;
+     thiz->FillTriangles = IDirectFBSurface_FillTriangles;
+     thiz->FillTrapezoids = IDirectFBSurface_FillTrapezoids;
+
+     thiz->SetFont = IDirectFBSurface_SetFont;
+     thiz->GetFont = IDirectFBSurface_GetFont;
+     thiz->DrawString = IDirectFBSurface_DrawString;
+     thiz->DrawGlyph = IDirectFBSurface_DrawGlyph;
+     thiz->SetEncoding = IDirectFBSurface_SetEncoding;
+
+     thiz->GetSubSurface = IDirectFBSurface_GetSubSurface;
+
+     thiz->GetGL = IDirectFBSurface_GetGL;
+
+     thiz->Dump = IDirectFBSurface_Dump;
+     thiz->DumpRaw = IDirectFBSurface_DumpRaw;
+     thiz->DisableAcceleration = IDirectFBSurface_DisableAcceleration;
+     thiz->ReleaseSource = IDirectFBSurface_ReleaseSource;
+
+     thiz->SetRenderOptions = IDirectFBSurface_SetRenderOptions;
+     thiz->SetMatrix        = IDirectFBSurface_SetMatrix;
+     thiz->SetSourceMask    = IDirectFBSurface_SetSourceMask;
+
+     thiz->MakeSubSurface = IDirectFBSurface_MakeSubSurface;
+
+     thiz->Write = IDirectFBSurface_Write;
+     thiz->Read  = IDirectFBSurface_Read;
+
+     thiz->SetColors = IDirectFBSurface_SetColors;
+
+     thiz->GetStereoEye = IDirectFBSurface_GetStereoEye;
+     thiz->SetStereoEye = IDirectFBSurface_SetStereoEye;
+     thiz->FlipStereo   = IDirectFBSurface_FlipStereo;
+
+     thiz->SetWriteMaskBits = IDirectFBSurface_SetWriteMaskBits;
+     thiz->SetRop = IDirectFBSurface_SetRop;
+
+     thiz->SetSrcColorKeyExtended = IDirectFBSurface_SetSrcColorKeyExtended;
+     thiz->SetDstColorKeyExtended = IDirectFBSurface_SetDstColorKeyExtended;
+
+     thiz->DrawMonoGlyphs = IDirectFBSurface_DrawMonoGlyphs;
+
+     thiz->SetSrcColorMatrix = IDirectFBSurface_SetSrcColorMatrix;
+     thiz->SetSrcConvolution = IDirectFBSurface_SetSrcConvolution;
+
+     thiz->GetID       = IDirectFBSurface_GetID;
+     thiz->AllowAccess = IDirectFBSurface_AllowAccess;
+
+     thiz->CreateEventBuffer = IDirectFBSurface_CreateEventBuffer;
+     thiz->AttachEventBuffer = IDirectFBSurface_AttachEventBuffer;
+     thiz->DetachEventBuffer = IDirectFBSurface_DetachEventBuffer;
+
+     thiz->MakeClient = IDirectFBSurface_MakeClient;
+     thiz->FrameAck   = IDirectFBSurface_FrameAck;
+
+     thiz->GetFrameTime       = IDirectFBSurface_GetFrameTime;
+     thiz->SetFrameTimeConfig = IDirectFBSurface_SetFrameTimeConfig;
+
+     dfb_surface_attach( surface,
+                         IDirectFBSurface_listener, thiz, &data->reaction );
+
+     return DFB_OK;
+}
+
+
+/* internal */
+
+static ReactionResult
+IDirectFBSurface_listener( const void *msg_data, void *ctx )
+{
+     const CoreSurfaceNotification *notification = msg_data;
+     IDirectFBSurface              *thiz         = ctx;
+     IDirectFBSurface_data         *data         = thiz->priv;
+     CoreSurface                   *surface      = data->surface;
+
+     D_DEBUG_AT( Surface, "%s( %p, %p )\n", __FUNCTION__, msg_data, ctx );
+
+     if (notification->flags & CSNF_DESTROY) {
+          if (data->surface) {
+               D_WARN( "IDirectFBSurface surface destroyed" );
+               data->surface = NULL;
+          }
+          return RS_REMOVE;
+     }
+
+     if (notification->flags & CSNF_SIZEFORMAT) {
+          DFBRectangle rect = { 0, 0, surface->config.size.w, surface->config.size.h };
+
+          dfb_rectangle_subtract( &rect, &data->area.insets );
+
+          if (data->limit_set) {
+               data->area.current = data->area.granted;
+
+               dfb_rectangle_intersect( &data->area.current, &rect );
+          }
+          else
+               data->area.wanted = data->area.granted = data->area.current = rect;
+
+          /* Reset clip to avoid crashes caused by drawing out of bounds. */
+          if (data->clip_set)
+               thiz->SetClip( thiz, &data->clip_wanted );
+          else
+               thiz->SetClip( thiz, NULL );
+     }
+
+     if (notification->flags & CSNF_FRAME) {
+          direct_mutex_lock( &data->back_buffer_lock );
+
+          D_DEBUG_AT( Surface_Updates, "  -> Got frame ack %d\n", notification->flip_count );
+
+          data->frame_ack = notification->flip_count;
+
+          if (data->local_flip_count < notification->flip_count) {
+               D_DEBUG_AT( Surface_Updates, "  -> Local count (%d) lower than frame ack (%d)\n",
+                           data->local_flip_count,
+                           notification->flip_count );
+
+               data->local_flip_count = notification->flip_count;
+          }
+
+          direct_waitqueue_broadcast( &data->back_buffer_wq );
+
+          direct_mutex_unlock( &data->back_buffer_lock );
+     }
+
+     return RS_OK;
+}
+
+void
+IDirectFBSurface_StopAll( IDirectFBSurface_data *data )
+{
+     if (!dfb_config->startstop)
+          return;
+
+     if (data->children_data) {
+          IDirectFBSurface_data *child;
+
+          pthread_mutex_lock( &data->children_lock );
+
+          direct_list_foreach (child, data->children_data)
+               IDirectFBSurface_StopAll( child );
+
+          pthread_mutex_unlock( &data->children_lock );
+     }
+
+     /* Signal end of sequence of operations. */
+     dfb_state_lock( &data->state );
+     dfb_state_stop_drawing( &data->state );
+     dfb_state_unlock( &data->state );
+}
+
+void
+IDirectFBSurface_WaitForBackBuffer( IDirectFBSurface_data *data )
+{
+     CoreSurface *surface;
+
+     D_DEBUG_AT( Surface_Updates, "%s( %p [%u] )\n", __FUNCTION__, data, data->surface->object.id );
+     D_DEBUG_AT( Surface_Updates, "  -> (surface %d, notify %d)\n",
+                 data->local_flip_count, data->frame_ack );
+
+     surface = data->surface;
+     CORE_SURFACE_ASSERT( surface );
+
+     direct_mutex_lock( &data->back_buffer_lock );
+
+     while (data->local_flip_count - data->frame_ack >= data->local_flip_buffers-1) {
+          D_DEBUG_AT( Surface_Updates, "  -> waiting for back buffer... (surface %d, notify %d)\n",
+                      data->local_flip_count, data->frame_ack );
+
+          if (data->local_flip_buffers <= 1)
+               break;
+
+          direct_waitqueue_wait( &data->back_buffer_wq, &data->back_buffer_lock );
+     }
+
+     D_DEBUG_AT( Surface_Updates, "  -> OK\n" );
+
+     direct_mutex_unlock( &data->back_buffer_lock );
+}
+
diff -Naur DirectFB-1.7.7/src/gfx/convert.c DirectFB-1.7.7.stm/src/gfx/convert.c
--- DirectFB-1.7.7/src/gfx/convert.c	2014-01-22 17:10:44.000000000 +0100
+++ DirectFB-1.7.7.stm/src/gfx/convert.c	2015-05-15 18:43:40.217535079 +0200
@@ -119,6 +119,7 @@
 
           case DSPF_ABGR:
                ret_color->a = pixel >> 24;
+          case DSPF_BGR24:
                ret_color->b = (pixel & 0xff0000) >> 16;
                ret_color->g = (pixel & 0x00ff00) >>  8;
                ret_color->r = (pixel & 0x0000ff);
@@ -208,6 +209,9 @@
           case DSPF_RGB24:
                return PIXEL_RGB32( color->r, color->g, color->b ) & 0xffffff;
 
+          case DSPF_BGR24:
+               return PIXEL_RGB32( color->b, color->g, color->r ) & 0xffffff;
+
           case DSPF_RGB32:
                return PIXEL_RGB32( color->r, color->g, color->b ) & 0xffffff;
 
@@ -336,6 +340,7 @@
 
           case DSPF_ABGR:
                *a  = pixel >> 24;
+          case DSPF_BGR24:
                *c0 = (pixel & 0xff0000) >> 16;
                *c1 = (pixel & 0x00ff00) >>  8;
                *c2 = (pixel & 0x0000ff);
@@ -441,6 +446,28 @@
                }
                break;
 
+          case DSPF_NV24:
+               while (height--) {
+                    const u8  *src8  = src;
+                    const u16 *src16 = src + surface_height * spitch;
+
+                    for (x=0; x<width; x++) {
+                         int r, g, b;
+
+#ifdef WORDS_BIGENDIAN
+                         YCBCR_TO_RGB( src8[x], src16[x] >> 8, src16[x] & 0xff, r, g, b );
+#else
+                         YCBCR_TO_RGB( src8[x], src16[x] & 0xff, src16[x] >> 8, r, g, b );
+#endif
+
+                         dst[x] = PIXEL_RGB16( r, g, b );
+                    }
+
+                    src += spitch;
+                    dst += dp2;
+               }
+               break;
+
           case DSPF_UYVY:
                while (height--) {
                     const u32 *src32 = src;
@@ -753,6 +780,28 @@
                }
                break;
 
+          case DSPF_NV24:
+               while (height--) {
+                    const u8  *src8  = src;
+                    const u16 *src16 = src + surface_height * spitch;
+
+                    for (x=0; x<width; x++) {
+                         int r, g, b;
+
+#ifdef WORDS_BIGENDIAN
+                         YCBCR_TO_RGB( src8[x], src16[x] >> 8, src16[x] & 0xff, r, g, b );
+#else
+                         YCBCR_TO_RGB( src8[x], src16[x] & 0xff, src16[x] >> 8, r, g, b );
+#endif
+
+                         dst[x] = PIXEL_RGB555( r, g, b );
+                    }
+
+                    src += spitch;
+                    dst += dp2;
+               }
+               break;
+
           case DSPF_RGB444:
           case DSPF_ARGB4444:
                while (height--) {
@@ -1046,6 +1095,26 @@
                }
                break;
 
+          case DSPF_BGR24:
+               while (height--) {
+                    const u8 *src8 = src;
+
+                    for (x=0; x<width; x++)
+#ifdef WORDS_BIGENDIAN
+                         dst[x] = ( src8[x*3+2] << 16 ) |
+                                  ( src8[x*3+1] <<  8 ) |
+                                  ( src8[x*3+0]       );
+#else
+                         dst[x] = ( src8[x*3+0] << 16 ) |
+                                  ( src8[x*3+1] <<  8 ) |
+                                  ( src8[x*3+2]       );
+#endif
+
+                    src += spitch;
+                    dst += dp4;
+               }
+               break;
+
           case DSPF_AYUV:
                while (height--) {
                     const u32 *src32 = src;
@@ -1085,6 +1154,28 @@
                }
                break;
 
+          case DSPF_NV24:
+               while (height--) {
+                    const u8  *src8  = src;
+                    const u16 *src16 = src + surface_height * spitch;
+
+                    for (x=0; x<width; x++) {
+                         int r, g, b;
+
+#ifdef WORDS_BIGENDIAN
+                         YCBCR_TO_RGB( src8[x], src16[x] >> 8, src16[x] & 0xff, r, g, b );
+#else
+                         YCBCR_TO_RGB( src8[x], src16[x] & 0xff, src16[x] >> 8, r, g, b );
+#endif
+
+                         dst[x] = PIXEL_RGB32( r, g, b );
+                    }
+
+                    src += spitch;
+                    dst += dp4;
+               }
+               break;
+
           case DSPF_RGB444:
           case DSPF_ARGB4444:
                while (height--) {
@@ -1364,6 +1455,26 @@
                }
                break;
 
+          case DSPF_BGR24:
+               while (height--) {
+                    const u8 *src8 = src;
+
+                    for (x=0; x<width; x++)
+#ifdef WORDS_BIGENDIAN
+                         dst[x] = ( src8[x*3+2] << 16 ) |
+                                  ( src8[x*3+1] <<  8 ) |
+                                  ( src8[x*3+0]       ) | 0xff000000;
+#else
+                         dst[x] = ( src8[x*3+0] << 16 ) |
+                                  ( src8[x*3+1] <<  8 ) |
+                                  ( src8[x*3+2]       ) | 0xff000000;
+#endif
+
+                    src += spitch;
+                    dst += dp4;
+               }
+               break;
+
           case DSPF_AYUV:
                while (height--) {
                     const u32 *src32 = src;
@@ -1403,6 +1514,28 @@
                }
                break;
 
+          case DSPF_NV24:
+               while (height--) {
+                    const u8  *src8  = src;
+                    const u16 *src16 = src + surface_height * spitch;
+
+                    for (x=0; x<width; x++) {
+                         int r, g, b;
+
+#ifdef WORDS_BIGENDIAN
+                         YCBCR_TO_RGB( src8[x], src16[x] >> 8, src16[x] & 0xff, r, g, b );
+#else
+                         YCBCR_TO_RGB( src8[x], src16[x] & 0xff, src16[x] >> 8, r, g, b );
+#endif
+
+                         dst[x] = PIXEL_ARGB( 0xff, r, g, b );
+                    }
+
+                    src += spitch;
+                    dst += dp4;
+               }
+               break;
+
           case DSPF_ARGB4444:
                while (height--) {
                     const u16 *src16 = src;
@@ -1864,6 +1997,26 @@
                     dst += dpitch;
                }
                break;
+          case DSPF_BGR24:
+               while (height--) {
+                    const u8 *src8 = src;
+
+                    for (n=0, n3=0; n<width; n++, n3+=3) {
+#ifdef WORDS_BIGENDIAN
+                         dst[n3+0] = src8[n3+2];
+                         dst[n3+1] = src8[n3+1];
+                         dst[n3+2] = src8[n3+0];
+#else
+                         dst[n3+0] = src8[n3+0];
+                         dst[n3+1] = src8[n3+1];
+                         dst[n3+2] = src8[n3+2];
+#endif
+                    }
+
+                    src += spitch;
+                    dst += dpitch;
+               }
+               break;
           case DSPF_RGB32:
                while (height--) {
                     const u32 *src32 = src;
@@ -2036,6 +2189,25 @@
                     dst += dpitch;
                }
                break;
+          case DSPF_NV24:
+               while (height--) {
+                    const u16 *cbcr = src + surface_height * spitch;
+                    const u8  *src8 = src;
+
+                    for (n=0, n3=0; n<width; n++, n3+=3) {
+#ifdef WORDS_BIGENDIAN
+                         YCBCR_TO_RGB( src8[n], cbcr[n] >> 8, cbcr[n] & 0xff,
+                                       dst[n3+0], dst[n3+1], dst[n3+2] );
+#else
+                         YCBCR_TO_RGB( src8[n], cbcr[n] & 0xff, cbcr[n] >> 8,
+                                       dst[n3+0], dst[n3+1], dst[n3+2] );
+#endif
+                    }
+
+                    src += spitch;
+                    dst += dpitch;
+               }
+               break;
           case DSPF_RGBA5551:
                while (height--) {
                     const u16 *src16 = src;
@@ -2255,6 +2427,7 @@
           case DSPF_BGR555:
           case DSPF_RGB16:
           case DSPF_RGB24:
+          case DSPF_BGR24:
           case DSPF_RGB32:
           case DSPF_VYU:
           case DSPF_YUY2:
@@ -2262,6 +2435,7 @@
           case DSPF_NV16:
           case DSPF_YV16:
           case DSPF_YUV444P:
+          case DSPF_NV24:
                while (height--) {
                     memset( dst, 0xff, width );
 
diff -Naur DirectFB-1.7.7/src/gfx/generic/generic.c DirectFB-1.7.7.stm/src/gfx/generic/generic.c
--- DirectFB-1.7.7/src/gfx/generic/generic.c	2013-12-19 01:16:24.000000000 +0100
+++ DirectFB-1.7.7.stm/src/gfx/generic/generic.c	2015-05-15 18:43:40.229547079 +0200
@@ -124,7 +124,7 @@
 #define Bop_PFI_OP_Aop_PFI( op ) Bop_12vv_##op##_Aop
 #include "template_colorkey_16.h"
 
-/* RGB24/VYU */
+/* RGB24/BGR24/VYU */
 #define RGB_MASK 0xffffff
 #define Cop_OP_Aop_PFI( op ) Cop_##op##_Aop_24_24
 #define Bop_PFI_OP_Aop_PFI( op ) Bop_24_24_##op##_Aop
@@ -424,6 +424,24 @@
 #define B_MASK 0x0000ff
 #include "template_acc_24.h"
 
+/* BGR24 */
+#define EXPAND_Ato8( a ) 0xff
+#define EXPAND_Rto8( r ) (r)
+#define EXPAND_Gto8( g ) (g)
+#define EXPAND_Bto8( b ) (b)
+#define PIXEL_OUT( a, r, g, b ) PIXEL_RGB32( b, g, r )
+#define Sop_PFI_OP_Dacc( op ) Sop_bgr24_##op##_Dacc
+#define Sacc_OP_Aop_PFI( op ) Sacc_##op##_Aop_bgr24
+#define A_SHIFT 0
+#define B_SHIFT 16
+#define G_SHIFT 8
+#define R_SHIFT 0
+#define A_MASK 0
+#define B_MASK 0xff0000
+#define G_MASK 0x00ff00
+#define R_MASK 0x0000ff
+#include "template_acc_24.h"
+
 /* ARGB1666 */
 #define EXPAND_Ato8( a ) EXPAND_1to8( a )
 #define EXPAND_Rto8( r ) EXPAND_6to8( r )
@@ -516,6 +534,7 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = false,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = true,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = true,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = true,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = false,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = false,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = false,
@@ -538,11 +557,21 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = true,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = false,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = true,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = false,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = false,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = true,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = true,
 };
 
 
 /********************************* Cop_to_Aop_PFI *****************************/
 
+static void Cop_to_Aop_4( GenefxState *gfxs )
+{
+     u8 color = ((gfxs->Cop & 0xf) << 4) | (gfxs->Cop & 0xf);
+     memset( gfxs->Aop[0], color, gfxs->length >> 1 );
+}
+
 static void Cop_to_Aop_8( GenefxState *gfxs )
 {
      memset( gfxs->Aop[0], gfxs->Cop, gfxs->length );
@@ -753,6 +782,18 @@
      }
 }
 
+static void Cop_to_Aop_nv24( GenefxState *gfxs )
+{
+     u16   *D   = gfxs->Aop[1];
+     int    w   = gfxs->length + 1;
+     u16    Cop = gfxs->CbCop | (gfxs->CrCop << 8);
+
+     memset( gfxs->Aop[0], gfxs->YCop, gfxs->length );
+
+     while (--w)
+          *D++ = Cop;
+}
+
 static void Cop_to_Aop_nv21( GenefxState *gfxs )
 {
      memset( gfxs->Aop[0], gfxs->YCop, gfxs->length );
@@ -768,6 +809,14 @@
      }
 }
 
+static void Cop_to_Aop_nv12mb( GenefxState *gfxs )
+{
+     int y0 = (short)(((u32)gfxs->Aop[2] >> 16) & 0xffff);
+
+     dfb_write_nv1xmb_span( NULL, gfxs->YCop, (u8**) gfxs->Aop,
+                            gfxs->length, gfxs->AopY - y0 );
+}
+
 static void Cop_to_Aop_yuv444p( GenefxState *gfxs )
 {
      memset( gfxs->Aop[0], gfxs->YCop, gfxs->length );
@@ -794,6 +843,7 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = Cop_to_Aop_nv12,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = Cop_to_Aop_nv12,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = Cop_to_Aop_nv24,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Cop_to_Aop_16,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Cop_to_Aop_16,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Cop_to_Aop_16,
@@ -816,10 +866,36 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Cop_to_Aop_vyu,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = Cop_to_Aop_yv16,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = Cop_to_Aop_4,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Cop_to_Aop_24,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = Cop_to_Aop_nv12mb,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = Cop_to_Aop_nv12mb,
 };
 
 /********************************* Cop_toK_Aop_PFI ****************************/
 
+static void Cop_toK_Aop_4( GenefxState *gfxs )
+{
+     int    w    = (gfxs->length >> 1) + 1;
+     u8    *D    = gfxs->Aop[0];
+     u32    Cop  = gfxs->Cop;
+     u32    Dkey = gfxs->Dkey;
+     u8     pixel;
+
+     while (--w) {
+          pixel = *D;
+
+          if (Dkey == (*D & 0x0F))
+               pixel = Cop;
+          if (Dkey == (*D >> 4)) {
+               pixel &= 0x0F;
+               pixel |= (Cop << 4);
+          }
+
+          *D++ = pixel;
+     }
+}
+
 static void Cop_toK_Aop_8( GenefxState *gfxs )
 {
      int    w    = gfxs->length+1;
@@ -945,6 +1021,7 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Cop_toK_Aop_14,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Cop_toK_Aop_12,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Cop_toK_Aop_12vv,
@@ -967,6 +1044,10 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Cop_toK_Aop_24_24,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = Cop_toK_Aop_4,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Cop_toK_Aop_24_24,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /********************************* Bop_PFI_to_Aop_PFI *************************/
@@ -1019,6 +1100,17 @@
           direct_memmove( gfxs->Aop[1], gfxs->Bop[1], gfxs->length&~1 );
 }
 
+static void Bop_NV24_to_Aop( GenefxState *gfxs )
+{
+     direct_memmove( gfxs->Aop[0], gfxs->Bop[0], gfxs->length );
+     direct_memmove( gfxs->Aop[1], gfxs->Bop[1], gfxs->length * 2 );
+}
+
+static void Bop_nv12mb_to_Aop( GenefxState *gfxs )
+{
+     direct_memmove( gfxs->Aop[0], gfxs->Bop[0], gfxs->length );
+}
+
 static void Bop_yuv444p_to_Aop( GenefxState *gfxs )
 {
      direct_memmove( gfxs->Aop[0], gfxs->Bop[0], gfxs->length );
@@ -1045,6 +1137,7 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = Bop_NV_to_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = Bop_NV_to_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = Bop_NV24_to_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Bop_16_to_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Bop_16_to_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Bop_16_to_Aop,
@@ -1067,6 +1160,10 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Bop_24_to_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = Bop_yv16_to_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = Bop_4_to_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Bop_24_to_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = Bop_nv12mb_to_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = Bop_nv12mb_to_Aop,
 };
 
 /********************************* Bop_PFI_toR_Aop_PFI *************************/
@@ -1200,6 +1297,22 @@
      }
 }
 
+static void Bop_NV24_toR_Aop( GenefxState *gfxs )
+{
+     int w = gfxs->length + 1;
+     int Dstep = gfxs->Astep;
+     u16 * S = gfxs->Bop[1];
+     u16 * D = gfxs->Aop[1];
+
+     Bop_8_toR_Aop( gfxs );
+
+     while(--w)
+     {
+          *D = *S++;
+          D += Dstep;
+     }
+}
+
 static void Bop_yuv444p_toR_Aop( GenefxState *gfxs )
 {
      int       w     = gfxs->length + 1;
@@ -1246,6 +1359,7 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = Bop_NV_toR_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = Bop_NV_toR_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = Bop_NV24_toR_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Bop_16_toR_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Bop_16_toR_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Bop_16_toR_Aop,
@@ -1268,10 +1382,20 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Bop_24_toR_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = Bop_yv16_toR_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = Bop_4_toR_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Bop_24_toR_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /********************************* Bop_PFI_Kto_Aop_PFI ************************/
 
+static void Bop_lut4_Kto_Aop( GenefxState *gfxs )
+{
+     /* no color to key */
+     direct_memmove( gfxs->Aop[0], gfxs->Bop[0], gfxs->length >> 1 );
+}
+
 static void Bop_a8_Kto_Aop( GenefxState *gfxs )
 {
      /* no color to key */
@@ -1444,6 +1568,7 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Bop_14_Kto_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Bop_12_Kto_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Bop_12vv_Kto_Aop,
@@ -1466,6 +1591,10 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Bop_24_24_Kto_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = Bop_lut4_Kto_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Bop_24_24_Kto_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /********************************* Bop_PFI_toK_Aop_PFI ************************/
@@ -1567,6 +1696,29 @@
      }
 }
 
+static void Bop_4_toK_Aop( GenefxState *gfxs )
+{
+      int   w    = (gfxs->length >> 1) + 1;
+      u8   *D    = gfxs->Aop[0];
+      u8   *S    = gfxs->Bop[0];
+      u8    Dkey = gfxs->Dkey;
+      u8    pixel;
+
+      while (--w) {
+           pixel = *D;
+
+           if (Dkey == (*D & 0x0F))
+                pixel = *S & 0xF;
+           if (Dkey == (*D >> 4)) {
+                pixel &= 0x0F;
+                pixel |= *S & 0xF0;
+           }
+
+           *D++ = pixel;
+           S++;
+      }
+}
+
 static void Bop_8_toK_Aop( GenefxState *gfxs )
 {
       int   w    = gfxs->length+1;
@@ -1602,6 +1754,7 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Bop_14_toK_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Bop_12_toK_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Bop_12vv_toK_Aop,
@@ -1624,6 +1777,10 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Bop_24_24_toK_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = Bop_4_toK_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Bop_24_24_toK_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /********************************* Bop_PFI_KtoK_Aop_PFI ***********************/
@@ -1686,6 +1843,7 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Bop_14_KtoK_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Bop_12_KtoK_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Bop_12vv_KtoK_Aop,
@@ -1708,6 +1866,10 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Bop_24_24_KtoK_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Bop_24_24_KtoK_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /********************************* Bop_PFI_Sto_Aop_PFI ************************/
@@ -1952,6 +2114,25 @@
      }
 }
 
+static void Bop_NV24_Sto_Aop( GenefxState *gfxs )
+{
+     int   w     = gfxs->length + 1;
+     int   i     = gfxs->Xphase;
+     u8   *Dy    = gfxs->Aop[0];
+     u8   *Sy    = gfxs->Bop[0];
+     int   SperD = gfxs->SperD;
+
+     u16 *Duv = gfxs->Aop[1];
+     u16 *Suv = gfxs->Bop[1];
+
+     while (--w) {
+          *Dy++ = Sy[i>>16];
+          *Duv++ = Suv[i>>16];
+
+          i += SperD;
+     }
+}
+
 static void Bop_yuv444p_Sto_Aop( GenefxState *gfxs )
 {
      int       w         = gfxs->length + 1;
@@ -1996,6 +2177,7 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = Bop_NV_Sto_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = Bop_NV_Sto_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = Bop_NV24_Sto_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Bop_16_Sto_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Bop_16_Sto_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Bop_16_Sto_Aop,
@@ -2018,6 +2200,10 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Bop_24_Sto_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = Bop_yv16_Sto_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Bop_24_Sto_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /********************************* Bop_PFI_SKto_Aop_PFI ***********************/
@@ -2238,6 +2424,7 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Bop_14_SKto_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Bop_12_SKto_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Bop_12vv_SKto_Aop,
@@ -2260,6 +2447,10 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Bop_24_24_SKto_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Bop_24_24_SKto_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /********************************* Bop_PFI_StoK_Aop_PFI ***********************/
@@ -2316,6 +2507,7 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Bop_14_StoK_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Bop_12_StoK_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Bop_12vv_StoK_Aop,
@@ -2338,6 +2530,10 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Bop_24_24_StoK_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Bop_24_24_StoK_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /********************************* Bop_PFI_SKtoK_Aop_PFI **********************/
@@ -2396,6 +2592,7 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Bop_14_SKtoK_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Bop_12_SKtoK_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Bop_12vv_SKtoK_Aop,
@@ -2418,6 +2615,10 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Bop_24_24_SKtoK_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Bop_24_24_SKtoK_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /********************************* Bop_PFI_TEX_to_Aop_PFI ************************/
@@ -2519,6 +2720,7 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,//Bop_NV_TEX_to_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,//Bop_NV_TEX_to_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = NULL,//Bop_16_TEX_to_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = NULL,//Bop_16_TEX_to_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = NULL,//Bop_16_TEX_to_Aop,
@@ -2541,6 +2743,10 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Bop_24_TEX_to_Aop,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,//Bop_yv16_TEX_to_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Bop_24_TEX_to_Aop,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /********************************* Sop_PFI_Sto_Dacc ***************************/
@@ -2761,6 +2967,28 @@
      }
 }
 
+static void Sop_nv24_Sto_Dacc( GenefxState *gfxs )
+{
+     int w     = gfxs->length+1;
+     int i     = gfxs->Xphase;
+     int SperD = gfxs->SperD;
+
+     GenefxAccumulator *D   = gfxs->Dacc;
+     u8                *Sy  = gfxs->Sop[0];
+     u16               *Suv = gfxs->Sop[1];
+
+     while (--w) {
+          D->YUV.a = 0xFF;
+          D->YUV.y = Sy[i>>16];
+          D->YUV.u = Suv[i>>16] & 0xFF;
+          D->YUV.v = Suv[i>>16] >> 8;
+
+          i += SperD;
+
+          ++D;
+     }
+}
+
 static void Sop_nv21_Sto_Dacc( GenefxState *gfxs )
 {
      int w     = gfxs->length+1;
@@ -2929,6 +3157,7 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = Sop_nv12_Sto_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = Sop_nv12_Sto_Dacc,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = Sop_nv24_Sto_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Sop_argb2554_Sto_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Sop_argb4444_Sto_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Sop_rgba4444_Sto_Dacc,
@@ -2951,6 +3180,10 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Sop_vyu_Sto_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = Sop_i420_Sto_Dacc,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Sop_bgr24_Sto_Dacc,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /********************************* Sop_PFI_SKto_Dacc **************************/
@@ -3320,6 +3553,7 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Sop_argb2554_SKto_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Sop_argb4444_SKto_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Sop_rgba4444_SKto_Dacc,
@@ -3342,6 +3576,10 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Sop_vyu_SKto_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Sop_bgr24_SKto_Dacc,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /********************************* Sop_PFI_to_Dacc ****************************/
@@ -3472,6 +3710,33 @@
      }
 }
 
+static void Sop_lut4_to_Dacc( GenefxState *gfxs )
+{
+     int                w = (gfxs->length >> 1) + 1;
+     GenefxAccumulator *D = gfxs->Dacc;
+     u8                *S = gfxs->Sop[0];
+
+     DFBColor *entries = gfxs->Slut->entries;
+
+     while (--w) {
+          u8 s = *S++;
+
+          D->RGB.a = entries[s & 0xF].a;
+          D->RGB.r = entries[s & 0xF].r;
+          D->RGB.g = entries[s & 0xF].g;
+          D->RGB.b = entries[s & 0xF].b;
+
+          D++;
+
+          D->RGB.a = entries[s >> 4].a;
+          D->RGB.r = entries[s >> 4].r;
+          D->RGB.g = entries[s >> 4].g;
+          D->RGB.b = entries[s >> 4].b;
+
+          D++;
+     }
+}
+
 static void Sop_lut8_to_Dacc( GenefxState *gfxs )
 {
      int                w = gfxs->length+1;
@@ -3557,6 +3822,88 @@
      }
 }
 
+static void Sop_nv24_to_Dacc( GenefxState *gfxs )
+{
+     int                w   = gfxs->length+1;
+     GenefxAccumulator *D   = gfxs->Dacc;
+     u8                *Sy  = gfxs->Sop[0];
+     u16               *Suv = gfxs->Sop[1];
+
+     while (--w) {
+          D[0].YUV.a = 0xFF;
+          D[0].YUV.y = *Sy++;
+          D[0].YUV.u = Suv[0] & 0xFF;
+          D[0].YUV.v = Suv[0] >> 8;
+
+          ++Suv;
+          D++;
+     }
+}
+
+static void Sop_nv12mb_to_Dacc( GenefxState *gfxs )
+{
+     int i, l, idx;
+     short dy;
+     u8 *d1, *dy1;
+     int y0;
+
+     GenefxAccumulator *D = gfxs->Dacc;
+
+     int y_offet_table[32] = {
+          8, 72, 136, 200, 0, 64, 128, 192, 24, 88, 152, 216, 16,
+          80, 144, 208, 40, 104, 168, 232, 32, 96, 160, 224, 56, 120,
+          184, 248, 48, 112, 176, 240
+     };
+
+     d1 = gfxs->Sop[0];
+
+     y0 = (short)(((u32)gfxs->Aop[2] >> 16) & 0xffff);
+
+     if (gfxs->Sop == gfxs->Aop)
+          dy = gfxs->AopY - y0;
+     else
+          dy = gfxs->BopY - y0;
+
+     idx = (dy % 16) * 2;
+     dy1 = d1 + y_offet_table[idx];
+
+     /* gfxs->length is assumed to be always even */
+     for (i = 0, l = 0; i < (gfxs->length - 1); i += 2)
+     {
+          if (l == 16) {
+               d1 += 2 * 256;
+
+               idx = (dy % 16) * 2;
+               dy1 = d1 + y_offet_table[idx];
+
+               l = 0;
+          }
+
+          if (l < 8) {
+               D[0].YUV.y = dy1[7 - l];
+               D[1].YUV.y = dy1[7 - (l + 1)];
+
+               D[0].YUV.u = D[1].YUV.u = 127;
+               D[0].YUV.v = D[1].YUV.v = 127;
+               D[0].YUV.a = D[1].YUV.a = 255;
+          } else {
+               if (l == 8) {
+                    dy1 = d1 + y_offet_table[++idx];
+               }
+
+               D[0].YUV.y = dy1[15 - l];
+               D[1].YUV.y = dy1[15 - (l + 1)];
+
+               D[0].YUV.u = D[1].YUV.u = 127;
+               D[0].YUV.v = D[1].YUV.v = 127;
+               D[0].YUV.a = D[1].YUV.a = 255;
+          }
+
+          l += 2;
+          D += 2;
+     }
+}
+
 static void Sop_nv21_to_Dacc( GenefxState *gfxs )
 {
      int                w   = (gfxs->length>>1)+1;
@@ -3676,6 +4023,7 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = Sop_nv12_to_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = Sop_nv12_to_Dacc,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = Sop_nv24_to_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Sop_argb2554_to_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Sop_argb4444_to_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Sop_rgba4444_to_Dacc,
@@ -3698,6 +4046,10 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Sop_vyu_to_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = Sop_i420_to_Dacc,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = Sop_lut4_to_Dacc,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Sop_bgr24_to_Dacc,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = Sop_nv12mb_to_Dacc,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = Sop_nv12mb_to_Dacc,
 };
 
 /********************************* Sop_PFI_Kto_Dacc ***************************/
@@ -4053,6 +4405,7 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Sop_argb2554_Kto_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Sop_argb4444_Kto_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Sop_rgba4444_Kto_Dacc,
@@ -4075,6 +4428,10 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Sop_vyu_Kto_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Sop_bgr24_Kto_Dacc,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /********************************* Sacc_to_Aop_PFI ****************************/
@@ -4230,6 +4587,35 @@
      }
 }
 
+static void Sacc_to_Aop_lut4( GenefxState *gfxs )
+{
+     int                w = (gfxs->length >> 1) + 1;
+     GenefxAccumulator *S = gfxs->Sacc;
+     u8                *D = gfxs->Aop[0];
+     u8                 pixel;
+
+     while (--w) {
+          pixel = 0;
+          if (!(S->RGB.a & 0xF000)) {
+               pixel = dfb_palette_search( gfxs->Alut,
+                                           (S->RGB.r & 0xFF00) ? 0xFF : S->RGB.r,
+                                           (S->RGB.g & 0xFF00) ? 0xFF : S->RGB.g,
+                                           (S->RGB.b & 0xFF00) ? 0xFF : S->RGB.b,
+                                           (S->RGB.a & 0xFF00) ? 0xFF : S->RGB.a );
+          }
+          S++;
+          if (!(S->RGB.a & 0xF000)) {
+               pixel |= (dfb_palette_search( gfxs->Alut,
+                                             (S->RGB.r & 0xFF00) ? 0xFF : S->RGB.r,
+                                             (S->RGB.g & 0xFF00) ? 0xFF : S->RGB.g,
+                                             (S->RGB.b & 0xFF00) ? 0xFF : S->RGB.b,
+                                             (S->RGB.a & 0xFF00) ? 0xFF : S->RGB.a )) << 4;
+          }
+          *D++ = pixel;
+          S++;
+     }
+}
+
 static void Sacc_to_Aop_lut8( GenefxState *gfxs )
 {
      int                w = gfxs->length+1;
@@ -4422,6 +4808,96 @@
      }
 }
 
+static void Sacc_to_Aop_nv24( GenefxState *gfxs )
+{
+     int                w  = gfxs->length+1;
+     GenefxAccumulator *S  = gfxs->Sacc;
+     u8                *Dy = gfxs->Aop[0];
+     u16               *Duv = gfxs->Aop[1];
+
+     while (--w) {
+          if (!(S->YUV.a & 0xF000))
+               *Dy = (S->YUV.y & 0xFF00) ? 0xFF : S->YUV.y;
+
+          ++S;
+          ++Dy;
+     }
+
+     w = gfxs->length+1;
+     S = gfxs->Sacc;
+
+     while (--w) {
+          u32 cb, cr;
+
+          if (!(S[0].YUV.a & 0xF000)) {
+               cb = ((*Duv & 0xFF) + ((S[0].YUV.u & 0xFF00) ? 0xFF : S[0].YUV.u)) >> 1;
+               cr = ((*Duv >> 8)   + ((S[0].YUV.v & 0xFF00) ? 0xFF : S[0].YUV.v)) >> 1;
+               *Duv = cb | (cr << 8);
+          }
+
+          S++;
+          ++Duv;
+     }
+}
+
+static void Sacc_to_Aop_nv12mb( GenefxState *gfxs )
+{
+     int i, l, idx;
+     short dy;
+     u8 *d1, *dy1;
+     int y0;
+
+     GenefxAccumulator *src;
+
+     int y_offet_table[32] = {
+          8, 72, 136, 200, 0, 64, 128, 192, 24, 88, 152, 216, 16,
+          80, 144, 208, 40, 104, 168, 232, 32, 96, 160, 224, 56, 120,
+          184, 248, 48, 112, 176, 240
+     };
+
+     d1 = gfxs->Aop[0];
+
+     y0 = (short)(((u32)gfxs->Aop[2] >> 16) & 0xffff);
+     dy = gfxs->AopY - y0;
+
+     src = gfxs->Sacc;
+
+     idx = (dy % 16) * 2;
+     dy1 = d1 + y_offet_table[idx];
+
+     /* gfxs->length is assumed to be always even */
+     for (i = 0, l = 0; i < (gfxs->length - 1); i += 2)
+     {
+          int y0, y1;
+
+          if (l == 16) {
+               d1 += 2 * 256;
+
+               idx = (dy % 16) * 2;
+               dy1 = d1 + y_offet_table[idx];
+
+               l = 0;
+          }
+
+          y0 = src[i + 0].YUV.y;
+          y1 = src[i + 1].YUV.y;
+
+          if (l < 8) {
+               dy1[7 - l] = (y0 & 0xFF00) ? 0xFF : y0;
+               dy1[7 - (l + 1)] = (y1 & 0xFF00) ? 0xFF : y1;
+          } else {
+               if (l == 8) {
+                    dy1 = d1 + y_offet_table[++idx];
+               }
+
+               dy1[15 - l] = (y0 & 0xFF00) ? 0xFF : y0;
+               dy1[15 - (l + 1)] = (y1 & 0xFF00) ? 0xFF : y1;
+          }
+
+          l += 2;
+     }
+}
+
 static void Sacc_to_Aop_nv21( GenefxState *gfxs )
 {
      int                w  = gfxs->length+1;
@@ -4607,6 +5083,7 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = Sacc_to_Aop_nv12,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = Sacc_to_Aop_nv12,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = Sacc_to_Aop_nv24,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Sacc_to_Aop_argb2554,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Sacc_to_Aop_argb4444,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Sacc_to_Aop_rgba4444,
@@ -4629,6 +5106,10 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Sacc_to_Aop_vyu,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = Sacc_to_Aop_yv16,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = Sacc_to_Aop_lut4,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Sacc_to_Aop_bgr24,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = Sacc_to_Aop_nv12mb,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = Sacc_to_Aop_nv12mb,
 };
 
 /********************************* Sop_PFI_TEX_to_Dacc ****************************/
@@ -4674,6 +5155,7 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Sop_argb2554_TEX_to_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Sop_argb4444_TEX_to_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Sop_rgba4444_TEX_to_Dacc,
@@ -4696,6 +5178,10 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = NULL,//Sop_vyu_TEX_to_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Sop_bgr24_TEX_to_Dacc,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /********************************* Sop_PFI_TEX_Kto_Dacc ****************************/
@@ -4720,6 +5206,7 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Sop_argb2554_TEX_Kto_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Sop_argb4444_TEX_Kto_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Sop_rgba4444_TEX_Kto_Dacc,
@@ -4742,6 +5229,10 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = NULL,//Sop_vyu_TEX_Kto_Dacc,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Sop_bgr24_TEX_Kto_Dacc,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /********************************* Sacc_Sto_Aop_PFI ***************************/
@@ -5142,6 +5633,44 @@
      }
 }
 
+static void Sacc_Sto_Aop_nv24( GenefxState *gfxs )
+{
+     int                i     = gfxs->Xphase;
+     int                w     = gfxs->length+1;
+     GenefxAccumulator *Sacc  = gfxs->Sacc;
+     u8                *Dy    = gfxs->Aop[0];
+     int                SperD = gfxs->SperD;
+
+     while (--w) {
+          GenefxAccumulator *S = &Sacc[i>>16];
+
+          if (!(S->YUV.a & 0xF000))
+               *Dy = (S->YUV.y & 0xFF00) ? 0xFF : S->YUV.y;
+
+          ++Dy;
+          i += SperD;
+     }
+
+     u16 *Duv = gfxs->Aop[1];
+
+     w = gfxs->length+1;
+     i = gfxs->Xphase;
+
+     while (--w) {
+          GenefxAccumulator *S0 = &Sacc[i>>16];
+          u32                cb, cr;
+
+          if (!(S0->YUV.a & 0xF000)) {
+               cb = ((*Duv & 0xFF) + ((S0->YUV.u & 0xFF00) ? 0xFF : S0->YUV.u)) >> 1;
+               cr = ((*Duv >> 8)   + ((S0->YUV.v & 0xFF00) ? 0xFF : S0->YUV.v)) >> 1;
+               *Duv = cb | (cr << 8);
+          }
+
+          ++Duv;
+          i += SperD;
+     }
+}
+
 static void Sacc_Sto_Aop_nv21( GenefxState *gfxs )
 {
      int                i     = gfxs->Xphase;
@@ -5201,6 +5730,69 @@
      }
 }
 
+static void Sacc_Sto_Aop_nv12mb( GenefxState *gfxs )
+{
+     int i, l, idx;
+     short dy;
+     u8 *d1, *dy1;
+     int SperD, phase;
+     int y0;
+
+     GenefxAccumulator *src;
+
+     int y_offet_table[32] = {
+          8, 72, 136, 200, 0, 64, 128, 192, 24, 88, 152, 216, 16,
+          80, 144, 208, 40, 104, 168, 232, 32, 96, 160, 224, 56, 120,
+          184, 248, 48, 112, 176, 240
+     };
+
+     d1 = gfxs->Aop[0];
+
+     y0 = (short)(((u32)gfxs->Aop[2] >> 16) & 0xffff);
+     dy = gfxs->AopY - y0;
+
+     src = gfxs->Sacc;
+
+     SperD = gfxs->SperD;
+     phase = gfxs->Xphase;
+
+     idx = (dy % 16) * 2;
+     dy1 = d1 + y_offet_table[idx];
+
+     /* gfxs->length is assumed to be always even */
+     for (i = 0, l = 0; i < (gfxs->length - 1); i += 2)
+     {
+          int y0, y1;
+
+          if (l == 16) {
+               d1 += 2 * 256;
+
+               idx = (dy % 16) * 2;
+               dy1 = d1 + y_offet_table[idx];
+
+               l = 0;
+          }
+
+          y0 = src[(phase >> 16)].YUV.y;
+          y1 = src[(phase + SperD) >> 16].YUV.y;
+
+          if (l < 8) {
+               dy1[7 - l] = (y0 & 0xFF00) ? 0xFF : y0;
+               dy1[7 - (l + 1)] = (y1 & 0xFF00) ? 0xFF : y1;
+          } else {
+               if (l == 8) {
+                    dy1 = d1 + y_offet_table[++idx];
+               }
+
+               dy1[15 - l] = (y0 & 0xFF00) ? 0xFF : y0;
+               dy1[15 - (l + 1)] = (y1 & 0xFF00) ? 0xFF : y1;
+          }
+
+          l += 2;
+          phase += (2 * SperD);
+     }
+}
+
 static void Sacc_Sto_Aop_ayuv( GenefxState *gfxs )
 {
      int                w     = gfxs->length+1;
@@ -5323,6 +5915,7 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = Sacc_Sto_Aop_nv12,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = Sacc_Sto_Aop_nv12,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = Sacc_Sto_Aop_nv24,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Sacc_Sto_Aop_argb2554,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Sacc_Sto_Aop_argb4444,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Sacc_Sto_Aop_rgba4444,
@@ -5345,6 +5938,10 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Sacc_Sto_Aop_vyu,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = Sacc_Sto_Aop_yv16,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Sacc_Sto_Aop_bgr24,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = Sacc_Sto_Aop_nv12mb,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = Sacc_Sto_Aop_nv12mb,
 };
 
 /********************************* Sacc_toK_Aop_PFI ***************************/
@@ -5666,6 +6263,7 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Sacc_toK_Aop_argb2554,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Sacc_toK_Aop_argb4444,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Sacc_toK_Aop_rgba4444,
@@ -5688,6 +6286,10 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Sacc_toK_Aop_vyu,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Sacc_toK_Aop_bgr24,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /********************************* Sacc_StoK_Aop_PFI **************************/
@@ -5802,6 +6404,7 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Sacc_StoK_Aop_argb2554,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Sacc_StoK_Aop_argb4444,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Sacc_StoK_Aop_rgba4444,
@@ -5824,6 +6427,10 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Sacc_StoK_Aop_vyu,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Sacc_StoK_Aop_bgr24,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /************** Bop_a8_set_alphapixel_Aop_PFI *********************************/
@@ -6114,6 +6721,42 @@
 #undef SET_PIXEL
 }
 
+static void Bop_a8_set_alphapixel_Aop_bgr24( GenefxState *gfxs )
+{
+     int       w     = gfxs->length;
+     u8       *S     = gfxs->Bop[0];
+     u8       *D     = gfxs->Aop[0];
+     DFBColor  color = gfxs->color;
+
+#define SET_PIXEL(d,r,g,b,a)\
+     switch (a) {\
+         case 0xff:\
+               d[0] = r;\
+               d[1] = g;\
+               d[2] = b;\
+          case 0: break;\
+          default: {\
+               register u16 s = a+1;\
+               d[0] = ((r-d[0]) * s + (d[0] << 8)) >> 8;\
+               d[1] = ((g-d[1]) * s + (d[1] << 8)) >> 8;\
+               d[2] = ((b-d[2]) * s + (d[2] << 8)) >> 8;\
+          }\
+     }
+
+     while (w>4) {
+          SET_PIXEL( D, color.r, color.g, color.b, *S ); D+=3; S++;
+          SET_PIXEL( D, color.r, color.g, color.b, *S ); D+=3; S++;
+          SET_PIXEL( D, color.r, color.g, color.b, *S ); D+=3; S++;
+          SET_PIXEL( D, color.r, color.g, color.b, *S ); D+=3; S++;
+          w-=4;
+     }
+     while (w--) {
+          SET_PIXEL( D, color.r, color.g, color.b, *S ); D+=3, S++;
+     }
+
+#undef SET_PIXEL
+}
+
 static void Bop_a8_set_alphapixel_Aop_rgb32( GenefxState *gfxs )
 {
      int    w   = gfxs->length;
@@ -6524,6 +7167,7 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = NULL,
@@ -6546,6 +7190,10 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = Bop_a8_set_alphapixel_Aop_vyu,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Bop_a8_set_alphapixel_Aop_bgr24,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /************** Bop_a1_set_alphapixel_Aop_PFI *********************************/
@@ -6701,6 +7349,25 @@
      }
 }
 
+static void Bop_a1_set_alphapixel_Aop_bgr24( GenefxState *gfxs )
+{
+     int       i;
+     int       w     = gfxs->length;
+     u8       *S     = gfxs->Bop[0];
+     u8       *D     = gfxs->Aop[0];
+     DFBColor  color = gfxs->color;
+
+     for (i=0; i<w; i++) {
+          if (S[i>>3] & (0x80 >> (i&7))) {
+               D[0] = color.r;
+               D[1] = color.g;
+               D[2] = color.b;
+          }
+
+          D += 3;
+     }
+}
+
 static void Bop_a1_set_alphapixel_Aop_rgb32( GenefxState *gfxs )
 {
      int    i;
@@ -6909,6 +7576,7 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Bop_a1_set_alphapixel_Aop_argb2554,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Bop_a1_set_alphapixel_Aop_argb4444,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = Bop_a1_set_alphapixel_Aop_rgba4444,
@@ -6931,6 +7599,10 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Bop_a1_set_alphapixel_Aop_bgr24,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /************** Bop_a1_lsb_set_alphapixel_Aop_PFI *********************************/
@@ -7045,6 +7717,25 @@
      }
 }
 
+static void Bop_a1_lsb_set_alphapixel_Aop_bgr24( GenefxState *gfxs )
+{
+     int       i;
+     int       w     = gfxs->length;
+     u8       *S     = gfxs->Bop[0];
+     u8       *D     = gfxs->Aop[0];
+     DFBColor  color = gfxs->color;
+
+     for (i=0; i<w; i++) {
+          if (S[i>>3] & (1 << (i&7))) {
+               D[0] = color.r;
+               D[1] = color.g;
+               D[2] = color.b;
+          }
+
+          D += 3;
+     }
+}
+
 static void Bop_a1_lsb_set_alphapixel_Aop_rgb32( GenefxState *gfxs )
 {
      int    i;
@@ -7221,6 +7912,7 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = Bop_a1_lsb_set_alphapixel_Aop_argb2554,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = Bop_a1_lsb_set_alphapixel_Aop_argb4444,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = NULL,
@@ -7243,6 +7935,10 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = Bop_a1_lsb_set_alphapixel_Aop_bgr24,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /**************************** Bop_translate_to_Aop ****************************/
@@ -8282,6 +8978,7 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = NULL,
@@ -8304,6 +9001,10 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /**********************************************************************************************************************/
@@ -8362,6 +9063,7 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = NULL,
@@ -8384,6 +9086,10 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /**********************************************************************************************************************/
@@ -8447,6 +9153,7 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_A1)]       = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV12)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_NV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB2554)] = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_ARGB4444)] = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_RGBA4444)] = NULL,
@@ -8469,6 +9176,10 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
 };
 
 /**********************************************************************************************************************/
@@ -8959,6 +9670,9 @@
           case DSPF_NV12:
           case DSPF_NV21:
           case DSPF_NV16:
+          case DSPF_NV24:
+          case DSPF_NV12MB:
+          case DSPF_NV16MB:
                gfxs->dst_org[1] = gfxs->dst_org[0] + gfxs->dst_height * gfxs->dst_pitch;
                break;
           case DSPF_YUV444P:
@@ -9004,6 +9718,9 @@
                case DSPF_NV12:
                case DSPF_NV21:
                case DSPF_NV16:
+               case DSPF_NV24:
+               case DSPF_NV12MB:
+               case DSPF_NV16MB:
                     gfxs->src_org[1] = gfxs->src_org[0] + gfxs->src_height * gfxs->src_pitch;
                     break;
                case DSPF_YUV444P:
@@ -9085,6 +9802,9 @@
           case DSPF_RGB24:
                gfxs->Cop = PIXEL_RGB32( color.r, color.g, color.b );
                break;
+          case DSPF_BGR24:
+               gfxs->Cop = PIXEL_RGB32( color.b, color.g, color.r );
+               break;
           case DSPF_RGB32:
                gfxs->Cop = PIXEL_RGB32( color.r, color.g, color.b );
                break;
@@ -9131,6 +9851,9 @@
           case DSPF_NV12:
           case DSPF_NV21:
           case DSPF_NV16:
+          case DSPF_NV24:
+          case DSPF_NV12MB:
+          case DSPF_NV16MB:
           case DSPF_YUV444P:
                RGB_TO_YCBCR( color.r, color.g, color.b,
                              gfxs->YCop, gfxs->CbCop, gfxs->CrCop );
@@ -9138,6 +9861,7 @@
                break;
           case DSPF_LUT1:
           case DSPF_LUT2:
+          case DSPF_LUT4:
           case DSPF_LUT8:
                gfxs->Cop  = state->color_index;
                gfxs->Alut = destination->palette;
@@ -9199,6 +9923,7 @@
           switch (gfxs->src_format) {
                case DSPF_LUT1:
                case DSPF_LUT2:
+               case DSPF_LUT4:
                case DSPF_LUT8:
                case DSPF_ALUT44:
                     gfxs->Blut = source->palette;
@@ -9213,6 +9938,7 @@
                case DSPF_RGB16:
                case DSPF_RGB18:
                case DSPF_RGB24:
+               case DSPF_BGR24:
                case DSPF_RGB32:
                case DSPF_ARGB:
                case DSPF_ABGR:
@@ -9241,6 +9967,9 @@
                case DSPF_NV12:
                case DSPF_NV21:
                case DSPF_NV16:
+               case DSPF_NV24:
+               case DSPF_NV12MB:
+               case DSPF_NV16MB:
                     if (simpld_blittingflags & DSBLIT_SRC_COLORKEY)
                          return false;
                case DSPF_YUY2:
diff -Naur DirectFB-1.7.7/src/gfx/generic/generic_stretch_blit.c DirectFB-1.7.7.stm/src/gfx/generic/generic_stretch_blit.c
--- DirectFB-1.7.7/src/gfx/generic/generic_stretch_blit.c	2013-12-19 01:16:24.000000000 +0100
+++ DirectFB-1.7.7.stm/src/gfx/generic/generic_stretch_blit.c	2015-05-15 18:43:40.229547079 +0200
@@ -300,6 +300,11 @@
      [DFB_PIXELFORMAT_INDEX(DSPF_VYU)]      = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_A1_LSB)]   = NULL,
      [DFB_PIXELFORMAT_INDEX(DSPF_YV16)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_LUT4)]     = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_BGR24)]    = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV12MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV16MB)]   = NULL,
+     [DFB_PIXELFORMAT_INDEX(DSPF_NV24)]     = NULL,
 };
 
 /**********************************************************************************************************************/
diff -Naur DirectFB-1.7.7/src/gfx/generic/generic_util.c DirectFB-1.7.7.stm/src/gfx/generic/generic_util.c
--- DirectFB-1.7.7/src/gfx/generic/generic_util.c	2013-12-19 01:16:24.000000000 +0100
+++ DirectFB-1.7.7.stm/src/gfx/generic/generic_util.c	2015-05-15 18:43:40.229547079 +0200
@@ -110,7 +110,14 @@
                case DSPF_NV16:
                     x &= ~1;
                     break;
+               case DSPF_NV12MB:
+               case DSPF_NV16MB:
+                    y &= ~31L;
+                    x &= ~31L;
+                    gfxs->AopY = y;
+                    break;
                case DSPF_YUV444P: /* nothing to adjust */
+               case DSPF_NV24:
                default:
                     break;
           }
@@ -125,6 +132,25 @@
 
           gfxs->Aop[1] += y * pitch + x;
           gfxs->Aop[2] += y * pitch + x;
+
+          switch (gfxs->dst_format) {
+               /* overwrite Aop[] when dst_format is a DSPF_NV1xMB */
+               case DSPF_NV12MB:
+               case DSPF_NV16MB:
+                    gfxs->Aop[0] = RASTER_TO_NV1xMB_ADDR(gfxs->dst_org[0],
+                                                         pitch, x, y, 0);
+                    /* we don't handle chroma yet */
+                    gfxs->Aop[1] = 0;
+                    /* orignal signed coordinates */
+                    gfxs->Aop[2] = (void*)(((y & 0xffff) << 16) | (x & 0xffff));
+                    break;
+               case DSPF_NV24:
+                    /* adjust again as chroma is fully sampled */
+                    gfxs->Aop[1] += y * pitch + x;
+                    break;
+               default:
+                    break;
+          }
      }
 }
 
@@ -219,6 +245,18 @@
                     gfxs->Aop[2] += pitch;
                }
           }
+          else if (gfxs->dst_format == DSPF_NV12MB
+                   || gfxs->dst_format == DSPF_NV16MB) {
+               int x0 = ((u32)gfxs->Aop[2] & 0xffff);
+               int y0 = (short)(((u32)gfxs->Aop[2] >> 16) & 0xffff);
+               gfxs->Aop[0] = RASTER_TO_NV1xMB_ADDR(gfxs->dst_org[0], pitch,
+                                                    x0, (gfxs->AopY + 1),
+                                                    (gfxs->AopY + 1) - y0);
+               gfxs->Aop[1] = 0;
+          }
+          else if (gfxs->dst_format == DSPF_NV24) {
+               gfxs->Aop[1] += pitch * 2;
+          }
           else { /* NV16 */
                if (gfxs->dst_caps & DSCAPS_SEPARATED) {
                     if (gfxs->Aop_field & 1)
@@ -314,6 +352,18 @@
                     gfxs->Aop[2] -= pitch;
                }
           }
+          else if (gfxs->dst_format == DSPF_NV12MB
+                   || gfxs->dst_format == DSPF_NV16MB) {
+               int x0 = ((u32)gfxs->Aop[2] & 0xffff);
+               int y0 = (short)(((u32)gfxs->Aop[2] >> 16) & 0xffff);
+               gfxs->Aop[0] = RASTER_TO_NV1xMB_ADDR(gfxs->dst_org[0], pitch,
+                                                    x0, (gfxs->AopY - 1),
+                                                    (gfxs->AopY - 1) - y0);
+               gfxs->Aop[1] = 0;
+          }
+          else if (gfxs->dst_format == DSPF_NV24) {
+               gfxs->Aop[1] -= pitch * 2;
+          }
           else { /* NV16 */
                if (gfxs->dst_caps & DSCAPS_SEPARATED) {
                     if (gfxs->Aop_field & 1)
@@ -373,7 +423,14 @@
                case DSPF_NV16:
                     x &= ~1;
                     break;
+               case DSPF_NV12MB:
+               case DSPF_NV16MB:
+                    y &= ~31L;
+                    x &= ~31L;
+                    gfxs->BopY = y;
+                    break;
                case DSPF_YUV444P: /* nothing to adjust */
+               case DSPF_NV24:
                default:
                     break;
           }
@@ -388,6 +445,25 @@
 
           gfxs->Bop[1] += y * pitch + x;
           gfxs->Bop[2] += y * pitch + x;
+
+          switch (gfxs->src_format) {
+               /* overwrite Aop[] when dst_format is & DSPF_NV1xMB */
+               case DSPF_NV12MB:
+               case DSPF_NV16MB:
+                    gfxs->Bop[0] = RASTER_TO_NV1xMB_ADDR(gfxs->src_org[0],
+                                                         pitch, x, y, 0);
+                    /* we don't handle chroma yet */
+                    gfxs->Bop[1] = 0;
+                    /* orignal signed coordinates */
+                    gfxs->Bop[2] = (void*)(((y & 0xffff) << 16) | (x & 0xffff));
+                    break;
+               case DSPF_NV24:
+                    /* adjust again as chroma is fully sampled */
+                    gfxs->Bop[1] += y * pitch + x;
+                    break;
+               default:
+                    break;
+          }
      }
 }
 
@@ -470,6 +546,18 @@
                     gfxs->Bop[2] += pitch;
                }
           }
+          else if (gfxs->src_format == DSPF_NV12MB
+                   || gfxs->src_format == DSPF_NV16MB) {
+               int x0 = ((u32)gfxs->Bop[2] & 0xffff);
+               int y0 = (short)(((u32)gfxs->Bop[2] >> 16) & 0xffff);
+               gfxs->Bop[0] = RASTER_TO_NV1xMB_ADDR(gfxs->src_org[0], pitch,
+                                                    x0, (gfxs->BopY + 1),
+                                                    (gfxs->BopY + 1) - y0);
+               gfxs->Bop[1] = 0;
+          }
+          else if (gfxs->src_format == DSPF_NV24) {
+               gfxs->Bop[1] += pitch * 2;
+          }
           else { /* NV16 */
                if (gfxs->src_caps & DSCAPS_SEPARATED) {
                     if (gfxs->Bop_field & 1)
@@ -565,6 +653,18 @@
                     gfxs->Bop[2] -= pitch;
                }
           }
+          else if (gfxs->src_format == DSPF_NV12MB
+                   || gfxs->src_format == DSPF_NV16MB) {
+               int x0 = ((u32)gfxs->Bop[2] & 0xffff);
+               int y0 = (short)(((u32)gfxs->Bop[2] >> 16) & 0xffff);
+               gfxs->Bop[0] = RASTER_TO_NV1xMB_ADDR(gfxs->src_org[0], pitch,
+                                                    x0, (gfxs->BopY - 1),
+                                                    (gfxs->BopY - 1) - y0);
+               gfxs->Bop[1] = 0;
+          }
+          else if (gfxs->src_format == DSPF_NV24) {
+               gfxs->Bop[1] -= pitch * 2;
+          }
           else { /* NV16 */
                if (gfxs->src_caps & DSCAPS_SEPARATED) {
                     if (gfxs->Bop_field & 1)
diff -Naur DirectFB-1.7.7/src/idirectfb.c DirectFB-1.7.7.stm/src/idirectfb.c
--- DirectFB-1.7.7/src/idirectfb.c	2015-02-01 20:36:12.000000000 +0100
+++ DirectFB-1.7.7.stm/src/idirectfb.c	2015-05-15 18:43:40.233551080 +0200
@@ -308,8 +308,6 @@
 
      DIRECT_DEALLOCATE_INTERFACE( thiz );
 
-     direct_shutdown();
-
      if (thiz == idirectfb_singleton)
           idirectfb_singleton = NULL;
 
@@ -370,7 +368,7 @@
                if (dfb_config->primary_id)
                     return DFB_ACCESSDENIED;
 
-               if (dfb_config->force_windowed || dfb_config->force_desktop)
+               if (dfb_config->force_windowed || dfb_config->force_desktop || dfb_config->force_offscreen)
                     return DFB_ACCESSDENIED;
 
                if (data->level == DFSCL_NORMAL) {
@@ -668,11 +666,13 @@
           case DSPF_I420:
           case DSPF_LUT1:
           case DSPF_LUT2:
+          case DSPF_LUT4:
           case DSPF_LUT8:
           case DSPF_ALUT44:
           case DSPF_RGB16:
           case DSPF_RGB18:
           case DSPF_RGB24:
+          case DSPF_BGR24:
           case DSPF_RGB32:
           case DSPF_RGB332:
           case DSPF_UYVY:
@@ -688,6 +688,15 @@
           case DSPF_BGR555:
           case DSPF_RGBAF88871:
           case DSPF_YUV444P:
+          case DSPF_NV24:
+               break;
+
+          case DSPF_NV12MB:
+          case DSPF_NV16MB:
+               if ((width & 31L) || (height & 31L)
+                   || (caps & (DSCAPS_SEPARATED
+                               | DSCAPS_INTERLACED)))
+                    return DFB_INVARG;
                break;
 
           default:
@@ -696,7 +705,11 @@
      }
 
      if (caps & DSCAPS_PRIMARY) {
+          D_DEBUG_AT( IDFB, "  -> PRIMARY\n" );
+
           if (dfb_config->primary_id) {
+               D_DEBUG_AT( IDFB, "  -> primary-id 0x%x\n", dfb_config->primary_id );
+
                ret = CoreDFB_GetSurface( data->core, dfb_config->primary_id, &surface );
                if (ret)
                     return ret;
@@ -761,12 +774,20 @@
                     or should we return an error? */
           switch (data->level) {
                case DFSCL_NORMAL:
-                    if (dfb_config->force_desktop) {
+                    D_DEBUG_AT( IDFB, "  -> level normal\n" );
+
+                    if (dfb_config->force_desktop || dfb_config->force_offscreen) {
                          CoreSurface *surface;
 
                          /* Source compatibility with older programs */
-                         if ((caps & DSCAPS_FLIPPING) == DSCAPS_FLIPPING)
-                              caps &= ~DSCAPS_TRIPLE;
+                         if (dfb_config->force_desktop) {
+                              if ((caps & DSCAPS_FLIPPING) == DSCAPS_FLIPPING)
+                                   caps &= ~DSCAPS_TRIPLE;
+                         }
+                         else {
+                              if ((caps & DSCAPS_FLIPPING) == DSCAPS_FLIPPING)
+                                   caps &= ~DSCAPS_DOUBLE;
+                         }
 
                          ret = dfb_surface_create_simple( data->core,
                                                           width, height,
@@ -775,8 +796,9 @@
                                                           NULL, &surface );
                          if (ret)
                               return ret;
-
-                         surface->notifications |= CSNF_FLIP;
+                  
+                         if (dfb_config->force_desktop)
+                              surface->notifications |= CSNF_FLIP;    // FIXME
 
                          init_palette( surface, desc );
 
@@ -785,8 +807,12 @@
                          ret = IDirectFBSurface_Construct( iface, NULL,
                                                            NULL, NULL, NULL, surface, caps, data->core, thiz );
                          if (ret == DFB_OK) {
-                              CoreWindowStack_BackgroundSetImage( data->stack, surface );
-                              CoreWindowStack_BackgroundSetMode( data->stack, DLBM_IMAGE );
+                              if (dfb_config->force_desktop) {
+                                   CoreWindowStack_BackgroundSetImage( data->stack, surface );
+                                   CoreWindowStack_BackgroundSetMode( data->stack, DLBM_IMAGE );
+                              }
+
+                              D_INFO( "Primary Surface (offscreen) with ID 0x%x\n", surface->object.id );
                          }
 
                          dfb_surface_unref( surface );
@@ -905,7 +931,8 @@
                     //if ((caps & DSCAPS_FLIPPING) == DSCAPS_FLIPPING)
                     //     caps &= ~DSCAPS_TRIPLE;
 
-                    config.surface_caps = DSCAPS_NONE;
+                    if (!(config.flags & DLCONF_SURFACE_CAPS))
+                         config.surface_caps = DSCAPS_NONE;
 
                     if (caps & DSCAPS_PREMULTIPLIED) {
                           config.flags        |= DLCONF_SURFACE_CAPS;
diff -Naur DirectFB-1.7.7/src/media/idirectfbimageprovider.c DirectFB-1.7.7.stm/src/media/idirectfbimageprovider.c
--- DirectFB-1.7.7/src/media/idirectfbimageprovider.c	2013-12-19 01:16:24.000000000 +0100
+++ DirectFB-1.7.7.stm/src/media/idirectfbimageprovider.c	2015-05-15 18:43:40.233551080 +0200
@@ -127,6 +127,16 @@
 IDirectFBImageProvider_SetRenderFlags( IDirectFBImageProvider *thiz,
                                        DIRenderFlags           flags )
 {
+     if (flags == DIRENDER_NONE)
+          return DFB_OK;
+
+     return DFB_UNIMPLEMENTED;
+}
+
+static DFBResult
+IDirectFBImageProvider_Sync( IDirectFBImageProvider    *thiz,
+                             DFBImageProviderSyncFlags  flags )
+{
      return DFB_UNIMPLEMENTED;
 }
 
@@ -149,6 +159,7 @@
      thiz->RenderTo              = IDirectFBImageProvider_RenderTo;
      thiz->SetRenderCallback     = IDirectFBImageProvider_SetRenderCallback;
      thiz->SetRenderFlags        = IDirectFBImageProvider_SetRenderFlags;
+     thiz->Sync                  = IDirectFBImageProvider_Sync;
      thiz->WriteBack             = IDirectFBImageProvider_WriteBack;
 }
      
diff -Naur DirectFB-1.7.7/src/misc/conf.c DirectFB-1.7.7.stm/src/misc/conf.c
--- DirectFB-1.7.7/src/misc/conf.c	2015-02-01 20:46:09.000000000 +0100
+++ DirectFB-1.7.7.stm/src/misc/conf.c	2015-05-15 18:43:40.237555080 +0200
@@ -107,6 +107,7 @@
      "  [no-]surface-sentinel          Enable surface sentinels at the end of chunks in video memory\n"
      "  [no-]force-windowed            Primary surface always is a window\n"
      "  force-desktop                  Primary surface is the desktop background\n"
+     "  force-offscreen                Primary surface is created offscreen (DFBSurfaceID will be logged)\n"
      "  [no-]hardware                  Enable/disable hardware acceleration\n"
      "  [no-]software                  Enable/disable software fallbacks\n"
      "  [no-]software-warn             Show warnings when doing/dropping software operations\n"
@@ -872,6 +873,15 @@
      if (strcmp (name, "force-desktop" ) == 0) {
           dfb_config->force_desktop = true;
      } else
+     if (strcmp (name, "no-force-desktop" ) == 0) {
+          dfb_config->force_desktop = false;
+     } else
+     if (strcmp (name, "force-offscreen" ) == 0) {
+          dfb_config->force_offscreen = true;
+     } else
+     if (strcmp (name, "no-force-offscreen" ) == 0) {
+          dfb_config->force_offscreen = false;
+     } else
      if (strcmp (name, "hardware" ) == 0) {
           dfb_config->software_only = false;
      } else
diff -Naur DirectFB-1.7.7/src/misc/conf.h DirectFB-1.7.7.stm/src/misc/conf.h
--- DirectFB-1.7.7/src/misc/conf.h	2015-02-01 20:36:12.000000000 +0100
+++ DirectFB-1.7.7.stm/src/misc/conf.h	2015-05-15 18:43:40.237555080 +0200
@@ -162,6 +162,8 @@
 
      bool      force_desktop;                     /* Desktop background is
                                                      the primary surface. */
+     bool      force_offscreen;                   /* Creates a new surface for
+                                                     the primary surface. */
 
      bool      linux_input_ir_only;               /* Ignore non-IR devices. */
 
diff -Naur DirectFB-1.7.7/src/misc/gfx_util.c DirectFB-1.7.7.stm/src/misc/gfx_util.c
--- DirectFB-1.7.7/src/misc/gfx_util.c	2013-12-19 01:16:24.000000000 +0100
+++ DirectFB-1.7.7.stm/src/misc/gfx_util.c	2015-05-15 18:43:40.237555080 +0200
@@ -77,6 +77,68 @@
 };
 
 
+/* Only write to the 4:2:x Omega2 MB buffer's luma channel */
+void dfb_write_nv1xmb_span( u32 *src, u8 color, u8 *dst[], int len, int dy )
+{
+     int  i, l, idx;
+     u8  *d1, *dy1;
+
+     static const int y_offet_table[32] = {
+            8,  72, 136, 200,   0,  64, 128, 192,  24,  88,
+          152, 216,  16,  80, 144, 208,  40, 104, 168, 232,
+           32,  96, 160, 224,  56, 120, 184, 248,  48, 112,
+          176, 240
+     };
+
+     d1 = dst[0];
+
+     idx = (dy % 16) * 2;
+     dy1 = d1 + y_offet_table[idx];
+
+     /* len is assumed to be always even */
+     for (i = 0, l = 0; i < (len - 1); i += 2) {
+          u32 y0, u0, v0;
+          u32 y1, u1, v1;
+
+          if (l == 16) {
+               d1 += 2 * 256;
+
+               idx = (dy % 16) * 2;
+               dy1 = d1 + y_offet_table[idx];
+
+               l = 0;
+          }
+
+          if (src) {
+               RGB_TO_YCBCR( (src[i + 0] >> 16) & 0xff,
+                             (src[i + 0] >>  8) & 0xff,
+                             (src[i + 0]      ) & 0xff, y0, u0, v0 );
+               RGB_TO_YCBCR( (src[i + 1] >> 16) & 0xff,
+                             (src[i + 1] >>  8) & 0xff,
+                             (src[i + 1]      ) & 0xff, y1, u1, v1 );
+               /* we currently only handle luma */
+               (void) u0;
+               (void) v0;
+               (void) u1;
+               (void) v1;
+          } else
+               y0 = y1 = color;
+
+          if (l < 8) {
+               dy1[7 - l] = y0;
+               dy1[7 - (l + 1)] = y1;
+          } else {
+               if (l == 8)
+                    dy1 = d1 + y_offet_table[++idx];
+
+               dy1[15 - l] = y0;
+               dy1[15 - (l + 1)] = y1;
+          }
+
+          l += 2;
+     }
+}
+
 static void write_argb_span (u32 *src, u8 *dst[], int len,
                              int dx, int dy, CoreSurface *dst_surface,
                              bool premultiply)
@@ -264,6 +326,20 @@
                }
                break;
 
+          case DSPF_BGR24:
+               for (i = 0; i < len; i++) {
+#ifdef WORDS_BIGENDIAN
+                    *d++ = src[i];
+                    *d++ = src[i] >> 8;
+                    *d++ = src[i] >> 16;
+#else
+                    *d++ = src[i] >> 16;
+                    *d++ = src[i] >> 8;
+                    *d++ = src[i];
+#endif
+               }
+               break;
+
           case DSPF_RGB32:
           case DSPF_ARGB:
                direct_memcpy( d, src, len*4 );
@@ -279,6 +355,25 @@
                     ((u32*)d)[i] = src[i] ^ 0xff000000;
                break;
 
+          case DSPF_LUT4:
+               if (palette) {
+                    for (i = 0; i < len; i += 2) {
+                         u8 pixel = 0;
+                         pixel = dfb_palette_search( palette,
+                                                     (src[i] >> 16) & 0xff,
+                                                     (src[i] >>  8) & 0xff,
+                                                     (src[i]      ) & 0xff,
+                                                     (src[i] >> 24) & 0xff );
+                         pixel |= (dfb_palette_search( palette,
+                                                       (src[i + 1] >> 16) & 0xff,
+                                                       (src[i + 1] >>  8) & 0xff,
+                                                       (src[i + 1]      ) & 0xff,
+                                                       (src[i + 1] >> 24) & 0xff )) << 4;
+                         d[i] = pixel;
+                    }
+               }
+               break;
+
           case DSPF_LUT8:
                if (palette) {
                     for (i = 0; i < len; i++) {
@@ -524,6 +619,26 @@
                }
                break;
 
+          case DSPF_NV24:
+               d1 = dst[1];
+               for (i = 0; i < len; i++) {
+                    u32 y0, u0, v0;
+
+                    RGB_TO_YCBCR( (src[i+0] >> 16) & 0xff,
+                                  (src[i+0] >>  8) & 0xff,
+                                  (src[i+0]      ) & 0xff, y0, u0, v0 );
+
+                    d[i + 0]      = y0;
+                    d1[2 * i + 0] = u0;
+                    d1[2 * i + 1] = v0;
+               }
+               break;
+
+          case DSPF_NV12MB:
+          case DSPF_NV16MB:
+               dfb_write_nv1xmb_span( src, 0, dst, len, dy );
+               break;
+
           case DSPF_NV21:
                d1 = dst[1];
                for (i = 0; i < (len-1); i += 2) {
@@ -724,6 +839,34 @@
                }
                break;
 
+          case DSPF_NV12MB:
+          case DSPF_NV16MB:
+               dst1 = dst + dpitch * dst_surface->config.size.h;
+
+               if ((x & 31L) || (drect->y & 31L)
+                   || (drect->h & 31L) || (drect->w & 15L)) {
+                    D_WARN ("nv1xmb copy not performed because of a non 32 pixels aligned offsets.");
+                    break;
+               }
+
+               /* Clear the chroma channel for 4:2:x Omega2 MB buffers */
+               if (dst_surface->config.format == DSPF_NV12MB)
+                    memset(dst1, 127, dpitch * (dst_surface->config.size.h >> 1));
+               if (dst_surface->config.format == DSPF_NV16MB)
+                    memset(dst1, 127, dpitch * dst_surface->config.size.h);
+
+               for (y = drect->y; y < drect->y + drect->h; y++) {
+                    u8 *d[2];
+
+                    d[0] = RASTER_TO_NV1xMB_ADDR( dst, dpitch, drect->x,
+                                                  y, y - drect->y );
+
+                    write_argb_span( src, d, drect->w, x, y - drect->y, dst_surface, true );
+
+                    src += sw;
+               }
+               break;
+
           case DSPF_NV16:
                dst1 = (u8*)dst + dpitch * dst_surface->config.size.h;
 
@@ -741,6 +884,23 @@
                }
                break;
 
+          case DSPF_NV24:
+               dst1 = (u8*)dst + dpitch * dst_surface->config.size.h;
+
+               for (y = drect->y; y < drect->y + drect->h; y++) {
+                    u8 *d[2];
+
+                    d[0] = LINE_PTR( dst, dst_surface->config.caps, y,
+                                     dst_surface->config.size.h, dpitch ) + x;
+                    d[1] = LINE_PTR( dst1, dst_surface->config.caps, y,
+                                     dst_surface->config.size.h, dpitch * 2 ) + x * 2;
+
+                    write_argb_span( src, d, drect->w, x, y, dst_surface, true );
+
+                    src += sw;
+               }
+               break;
+
           case DSPF_YUV444P:
                dst1 = (u8*)dst  + dpitch * dst_surface->config.size.h;
                dst2 = dst1 + dpitch * dst_surface->config.size.h;
@@ -1026,8 +1186,11 @@
                dst1 = dst2 + dpitch/2 * dst_surface->config.size.h;
                break;
           case DSPF_NV12:
+          case DSPF_NV12MB:
+          case DSPF_NV16MB:
           case DSPF_NV21:
           case DSPF_NV16:
+          case DSPF_NV24:
                dst1 = (u8*)dst + dpitch * dst_surface->config.size.h;
                break;
           case DSPF_YUV444P:
@@ -1038,6 +1201,12 @@
                break;
      }
 
+     /* Clear the chroma channel for 4:2:x Omega2 MB buffers */
+     if (dst_surface->config.format == DSPF_NV12MB)
+          memset(dst1, 127, dpitch * (dst_surface->config.size.h >> 1));
+     if (dst_surface->config.format == DSPF_NV16MB)
+          memset(dst1, 127, dpitch * dst_surface->config.size.h);
+
      buf = (u32*) alloca( drect->w * 4 );
 
      for (i = drect->y; i < drect->y + drect->h; i++) {
@@ -1125,6 +1294,15 @@
                     d[1] = LINE_PTR( dst1, dst_surface->config.caps, i,
                                      dst_surface->config.size.h, dpitch ) + (drect->x&~1);
                     break;
+               case DSPF_NV24:
+                    d[1] = LINE_PTR( dst1, dst_surface->config.caps, i,
+                                     dst_surface->config.size.h, dpitch * 2 ) + (drect->x * 2);
+                    break;
+               case DSPF_NV16MB:
+               case DSPF_NV12MB:
+                    d[0] = RASTER_TO_NV1xMB_ADDR( dst, dpitch, drect->x,
+                                                  i, i - drect->y );
+                    break;
                case DSPF_YUV444P:
                     d[1] = LINE_PTR( dst1, dst_surface->config.caps, i,
                                      dst_surface->config.size.h, dpitch ) + drect->x;
@@ -1135,7 +1313,11 @@
                     break;
           }
 
-          write_argb_span( buf, d, drect->w, drect->x, i, dst_surface, false );
+          if ((dst_surface->config.format == DSPF_NV12MB)
+              || (dst_surface->config.format == DSPF_NV16MB))
+               write_argb_span( buf, d, drect->w, drect->x, i - drect->y, dst_surface, false );
+          else
+               write_argb_span( buf, d, drect->w, drect->x, i, dst_surface, false );
      }
 
      D_FREE(filter.weights);
diff -Naur DirectFB-1.7.7/src/misc/gfx_util.h DirectFB-1.7.7.stm/src/misc/gfx_util.h
--- DirectFB-1.7.7/src/misc/gfx_util.h	2013-12-19 01:16:24.000000000 +0100
+++ DirectFB-1.7.7.stm/src/misc/gfx_util.h	2015-05-15 18:43:40.237555080 +0200
@@ -45,5 +45,11 @@
                           void *dst, int dpitch, DFBRectangle *drect,
                           CoreSurface *dst_surface, const DFBRegion *dst_clip );
 
+#define RASTER_TO_NV1xMB_ADDR( dst, pitch, dx, y, dy ) \
+     (dst + ((y / 32) * (pitch / 16) * 256 * 2) \
+          + (((dy / 16) & 1L) ? ((dx / 16) * 2 + 1) * 256 \
+                              : (dx / 16) * 2 * 256))
+
+void dfb_write_nv1xmb_span( u32 *src, u8 color, u8 *dst[], int len, int dy );
 
 #endif
diff -Naur DirectFB-1.7.7/src/misc/util.c DirectFB-1.7.7.stm/src/misc/util.c
--- DirectFB-1.7.7/src/misc/util.c	2014-07-15 11:25:20.000000000 +0200
+++ DirectFB-1.7.7.stm/src/misc/util.c	2015-05-15 18:43:40.241559080 +0200
@@ -472,6 +472,8 @@
                return DSPF_LUT1;
           case 2:
                return DSPF_LUT2;
+          case 4:
+               return DSPF_LUT4;
           case 8:
                return DSPF_LUT8;
           case 12:
diff -Naur DirectFB-1.7.7/systems/devmem/surfacemanager.c DirectFB-1.7.7.stm/systems/devmem/surfacemanager.c
--- DirectFB-1.7.7/systems/devmem/surfacemanager.c	2013-12-19 01:16:24.000000000 +0100
+++ DirectFB-1.7.7.stm/systems/devmem/surfacemanager.c	2015-05-15 18:43:40.241559080 +0200
@@ -285,7 +285,7 @@
           D_MAGIC_ASSERT( chunk, Chunk );
 
           allocation = chunk->allocation;
-          if (allocation) {
+          if (allocation && allocation->buffer) {
                CoreSurfaceBuffer *other;
                int                size, locks;
 
diff -Naur DirectFB-1.7.7/systems/fbdev/fbdev_aux_surface_pool.c DirectFB-1.7.7.stm/systems/fbdev/fbdev_aux_surface_pool.c
--- DirectFB-1.7.7/systems/fbdev/fbdev_aux_surface_pool.c	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7.stm/systems/fbdev/fbdev_aux_surface_pool.c	2015-05-15 18:43:40.253571080 +0200
@@ -0,0 +1,595 @@
+/*
+   FBDev system driver - auxmem surface pool memory
+
+   (c) Copyright 2009-2014  STMicroelectronics Ltd.
+
+   Based on code by Andr Draszik <andre.draszik@st.com>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+
+#include <asm/types.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+
+#include <directfb_util.h>
+
+#include <direct/debug.h>
+#include <direct/mem.h>
+
+#include <core/core.h>
+#include <core/surface_pool.h>
+
+#include <gfx/convert.h>
+
+#include <misc/conf.h>
+
+#include "surfacemanager.h"
+
+#include <core/system.h>
+
+#include "fbdev.h"
+#include "fbdev_aux_surface_pool.h"
+
+#include <linux/types.h>
+
+#include <linux/stmfb.h>
+
+extern FBDev *dfb_fbdev;
+
+D_DEBUG_DOMAIN (FBDev_Surfaces_Aux, "FBDev/Surfaces/Aux", "FBDev Aux Surface Pool");
+D_DEBUG_DOMAIN (FBDev_SurfLock_Aux, "FBDev/SurfLock/Aux", "FBDev Aux Surface Pool Locks");
+
+/****************************************************************************/
+
+typedef struct
+{
+  int             magic;
+
+  SurfaceManager *manager;
+
+  unsigned long   part_base;
+  unsigned int    aux_part;
+} STMFB_AuxSurfacePoolData;
+
+typedef struct
+{
+  int      magic;
+
+  CoreDFB *core;
+  void    *mem;
+} STMFB_AuxSurfacePoolLocalData;
+
+typedef struct
+{
+  int    magic;
+
+  Chunk *chunk;
+} STMFB_AuxSurfacePoolAllocationData;
+
+/****************************************************************************/
+
+static int
+fbdev_aux_PoolDataSize (void)
+{
+  return sizeof (STMFB_AuxSurfacePoolData);
+}
+
+static int
+fbdev_aux_PoolLocalDataSize (void)
+{
+  return sizeof (STMFB_AuxSurfacePoolLocalData);
+}
+
+static int
+fbdev_aux_AllocationDataSize (void)
+{
+  return sizeof (STMFB_AuxSurfacePoolAllocationData);
+}
+
+static DFBResult
+fbdev_aux_LeavePool (CoreSurfacePool *pool,
+                     void            *pool_data,
+                     void            *pool_local)
+{
+  STMFB_AuxSurfacePoolData      * const data = pool_data;
+  STMFB_AuxSurfacePoolLocalData * const local = pool_local;
+
+  D_DEBUG_AT (FBDev_Surfaces_Aux, "%s (%d)\n", __func__, data->aux_part);
+
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_MAGIC_ASSERT (data, STMFB_AuxSurfacePoolData);
+  D_MAGIC_ASSERT (local, STMFB_AuxSurfacePoolLocalData);
+
+  D_UNUSED_P (data);
+
+  if (local->mem && local->mem != MAP_FAILED)
+    {
+      munmap (local->mem, pool->desc.size);
+      local->mem = NULL;
+    }
+
+  D_MAGIC_CLEAR (local);
+
+  return DFB_OK;
+}
+
+static DFBResult
+fbdev_aux_JoinPool (CoreDFB         *core,
+                    CoreSurfacePool *pool,
+                    void            *pool_data,
+                    void            *pool_local,
+                    void            *system_data)
+{
+  STMFB_AuxSurfacePoolData      * const data  = pool_data;
+  STMFB_AuxSurfacePoolLocalData * const local = pool_local;
+
+  D_DEBUG_AT (FBDev_Surfaces_Aux, "%s (%d)\n", __func__, data->aux_part);
+
+  D_ASSERT (core != NULL);
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_MAGIC_ASSERT (data, STMFB_AuxSurfacePoolData);
+  D_ASSERT (local != NULL);
+
+  D_MAGIC_SET (local, STMFB_AuxSurfacePoolLocalData);
+
+  local->mem = mmap (NULL, pool->desc.size, PROT_READ | PROT_WRITE,
+                     MAP_SHARED, dfb_fbdev->fd, data->part_base);
+  if (local->mem == MAP_FAILED)
+    {
+      D_PERROR ("STMfbdev/Surfaces/Aux: Could not mmap gfx part %d!\n",
+                data->aux_part);
+      return DFB_INIT;
+    }
+
+  local->core = core;
+
+  return DFB_OK;
+}
+
+static DFBResult
+fbdev_aux_DestroyPool (CoreSurfacePool *pool,
+                       void            *pool_data,
+                       void            *pool_local)
+{
+  STMFB_AuxSurfacePoolData      * const data  = pool_data;
+  STMFB_AuxSurfacePoolLocalData * const local = pool_local;
+
+  D_DEBUG_AT (FBDev_Surfaces_Aux, "%s (%d)\n", __func__, data->aux_part);
+
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_MAGIC_ASSERT (data, STMFB_AuxSurfacePoolData);
+  D_MAGIC_ASSERT (local, STMFB_AuxSurfacePoolLocalData);
+
+  D_UNUSED_P (local);
+
+  fbdev_aux_LeavePool (pool, pool_data, pool_local);
+
+  dfb_surfacemanager_destroy (data->manager);
+
+  D_MAGIC_CLEAR (data);
+
+  return DFB_OK;
+}
+
+static DFBResult
+fbdev_aux_InitPool (CoreDFB                    *core,
+                    CoreSurfacePool            *pool,
+                    void                       *pool_data,
+                    void                       *pool_local,
+                    void                       *system_data,
+                    CoreSurfacePoolDescription *ret_desc)
+{
+  DFBResult                      ret;
+  STMFB_AuxSurfacePoolData      * const data  = pool_data;
+  STMFB_AuxSurfacePoolLocalData * const local = pool_local;
+  struct stmfbio_auxmem2         auxmem;
+
+  D_DEBUG_AT (FBDev_Surfaces_Aux, "%s (%d)\n", __func__,
+              dfb_fbdev->shared->aux_pool_index);
+
+  D_ASSERT (core != NULL);
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_ASSERT (data != NULL);
+  D_ASSERT (local != NULL);
+  D_ASSERT (ret_desc != NULL);
+
+  D_UNUSED_P (local);
+
+  D_MAGIC_SET (data, STMFB_AuxSurfacePoolData);
+
+  auxmem.index = dfb_fbdev->shared->aux_pool_index;
+
+  snprintf (ret_desc->name, DFB_SURFACE_POOL_DESC_NAME_LENGTH,
+            "STMFB AuxMemory %d", auxmem.index);
+
+  /* query auxmem */
+  if (ioctl (dfb_fbdev->fd, STMFBIO_GET_AUXMEMORY2, &auxmem) != 0)
+    return DFB_IO;
+
+  if (!auxmem.size)
+    return DFB_ITEMNOTFOUND;
+
+  D_INFO ("FBDev/Surfaces/Aux: found auxmem @ %.8x (%ukB)!\n",
+          auxmem.physical, auxmem.size / 1024);
+  /* auxmem partitions will never cross a 64MB boundary, stmfb should make
+     sure that's the case. And it does in fact :-), which is why we don't need
+     to check for configuration errors. */
+
+  ret = dfb_surfacemanager_create (core, auxmem.size, &data->manager);
+  if (ret)
+    return ret;
+
+  data->aux_part  = auxmem.index;
+  data->part_base = auxmem.physical;
+
+  ret_desc->caps              = CSPCAPS_PHYSICAL | CSPCAPS_VIRTUAL;
+  ret_desc->access[CSAID_CPU] = CSAF_READ | CSAF_WRITE | CSAF_SHARED;
+  ret_desc->access[CSAID_GPU] = CSAF_READ | CSAF_WRITE | CSAF_SHARED;
+  ret_desc->types             = (0
+                                 | CSTF_WINDOW | CSTF_CURSOR | CSTF_FONT
+                                 | CSTF_SHARED | CSTF_EXTERNAL
+                                );
+  ret_desc->priority          = CSPP_DEFAULT;
+  ret_desc->size              = auxmem.size;
+
+  ret = fbdev_aux_JoinPool (core, pool, pool_data, pool_local, system_data);
+  if (ret)
+    {
+      fbdev_aux_DestroyPool (pool, pool_data, pool_local);
+      return ret;
+    }
+
+  return DFB_OK;
+}
+
+static DFBResult
+fbdev_aux_TestConfig (CoreSurfacePool         *pool,
+                      void                    *pool_data,
+                      void                    *pool_local,
+                      CoreSurfaceBuffer       *buffer,
+                      const CoreSurfaceConfig *config)
+{
+  CoreSurface                   *surface;
+  STMFB_AuxSurfacePoolData      * const data  = pool_data;
+  STMFB_AuxSurfacePoolLocalData * const local = pool_local;
+  DFBResult                      ret;
+
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_MAGIC_ASSERT (data, STMFB_AuxSurfacePoolData);
+  D_MAGIC_ASSERT (local, STMFB_AuxSurfacePoolLocalData);
+  D_MAGIC_ASSERT (buffer, CoreSurfaceBuffer);
+  D_ASSERT (config != NULL);
+
+  surface = buffer->surface;
+  D_MAGIC_ASSERT (surface, CoreSurface);
+
+  D_DEBUG_AT (FBDev_Surfaces_Aux,
+              "%s (part/buffer/type/id: %u/%p/0x%x/%lu)\n",
+              __func__, data->aux_part, buffer,
+              surface->type, surface->resource_id);
+
+  /* FIXME: this depends on the hardware, but we have no interface at the
+     moment anyway... */
+  if (surface->type & CSTF_LAYER)
+    return DFB_BUG;
+
+  ret = dfb_surfacemanager_allocate (local->core, data->manager,
+                                     buffer, NULL, NULL, false);
+
+  D_DEBUG_AT (FBDev_Surfaces_Aux, "  -> %s\n", DirectFBErrorString (ret));
+
+  return ret;
+}
+
+static DFBResult
+fbdev_aux_AllocateBuffer (CoreSurfacePool       *pool,
+                          void                  *pool_data,
+                          void                  *pool_local,
+                          CoreSurfaceBuffer     *buffer,
+                          CoreSurfaceAllocation *allocation,
+                          void                  *alloc_data)
+{
+  CoreSurface                        *surface;
+  STMFB_AuxSurfacePoolData           * const data  = pool_data;
+  STMFB_AuxSurfacePoolLocalData      * const local = pool_local;
+  STMFB_AuxSurfacePoolAllocationData * const alloc = alloc_data;
+  DFBResult                           ret;
+  Chunk                              *chunk;
+
+  D_DEBUG_AT (FBDev_Surfaces_Aux, "%s (%d, %p)\n", __func__,
+              data->aux_part, buffer);
+
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_MAGIC_ASSERT (data, STMFB_AuxSurfacePoolData);
+  D_MAGIC_ASSERT (local, STMFB_AuxSurfacePoolLocalData);
+  D_MAGIC_ASSERT (buffer, CoreSurfaceBuffer);
+  D_MAGIC_ASSERT (allocation, CoreSurfaceAllocation);
+
+  surface = buffer->surface;
+  D_MAGIC_ASSERT (surface, CoreSurface);
+
+  /* FIXME: this depends on the hardware, but we have no interface at the
+     moment anyway... */
+  if (surface->type & CSTF_LAYER)
+    return DFB_BUG;
+
+  ret = dfb_surfacemanager_allocate (local->core, data->manager, buffer,
+                                     allocation, &chunk, false);
+  if (ret)
+    return ret;
+
+  D_MAGIC_ASSERT (chunk, Chunk);
+
+  alloc->chunk = chunk;
+
+  D_DEBUG_AT (FBDev_Surfaces_Aux,
+              "  -> offset 0x%.8x (%u), format: %s, pitch %d, size %d\n",
+              chunk->offset, chunk->offset,
+              dfb_pixelformat_name (buffer->format), chunk->pitch,
+              chunk->length);
+
+  allocation->size   = chunk->length;
+  allocation->offset = chunk->offset;
+
+  D_MAGIC_SET (alloc, STMFB_AuxSurfacePoolAllocationData);
+
+  return DFB_OK;
+}
+
+static DFBResult
+fbdev_aux_DeallocateBuffer (CoreSurfacePool       *pool,
+                            void                  *pool_data,
+                            void                  *pool_local,
+                            CoreSurfaceBuffer     *buffer,
+                            CoreSurfaceAllocation *allocation,
+                            void                  *alloc_data)
+{
+  STMFB_AuxSurfacePoolData            * const data  = pool_data;
+  const STMFB_AuxSurfacePoolLocalData * const local = pool_local;
+  STMFB_AuxSurfacePoolAllocationData  * const alloc = alloc_data;
+
+  D_DEBUG_AT (FBDev_Surfaces_Aux, "%s (%d, %p)\n", __func__,
+              data->aux_part, buffer);
+
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_MAGIC_ASSERT (data, STMFB_AuxSurfacePoolData);
+  D_MAGIC_ASSERT (local, STMFB_AuxSurfacePoolLocalData);
+  D_MAGIC_ASSERT (allocation, CoreSurfaceAllocation);
+  D_MAGIC_ASSERT (alloc, STMFB_AuxSurfacePoolAllocationData);
+
+  (void) local;
+
+  D_ASSERT (alloc->chunk != NULL);
+  dfb_surfacemanager_deallocate (data->manager, alloc->chunk);
+
+  D_MAGIC_CLEAR (alloc);
+
+  return DFB_OK;
+}
+
+static DFBResult
+fbdev_aux_MuckOut (CoreSurfacePool   *pool,
+                   void              *pool_data,
+                   void              *pool_local,
+                   CoreSurfaceBuffer *buffer )
+{
+  STMFB_AuxSurfacePoolData            * const data  = pool_data;
+  const STMFB_AuxSurfacePoolLocalData * const local = pool_local;
+
+  D_DEBUG_AT (FBDev_Surfaces_Aux, "%s (%p)\n", __func__, buffer);
+
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_MAGIC_ASSERT (data, STMFB_AuxSurfacePoolData);
+  D_MAGIC_ASSERT (local, STMFB_AuxSurfacePoolLocalData);
+  D_MAGIC_ASSERT (buffer, CoreSurfaceBuffer);
+
+  return dfb_surfacemanager_displace (local->core, data->manager, buffer);
+}
+
+static DFBResult
+fbdev_aux_Lock (CoreSurfacePool       *pool,
+                void                  *pool_data,
+                void                  *pool_local,
+                CoreSurfaceAllocation *allocation,
+                void                  *alloc_data,
+                CoreSurfaceBufferLock *lock)
+{
+  const STMFB_AuxSurfacePoolData           * const data  = pool_data;
+  const STMFB_AuxSurfacePoolLocalData      * const local = pool_local;
+  const STMFB_AuxSurfacePoolAllocationData * const alloc = alloc_data;
+  const Chunk                              *chunk;
+
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_MAGIC_ASSERT (data, STMFB_AuxSurfacePoolData);
+  D_MAGIC_ASSERT (local, STMFB_AuxSurfacePoolLocalData);
+  D_MAGIC_ASSERT (allocation, CoreSurfaceAllocation);
+  D_MAGIC_ASSERT (alloc, STMFB_AuxSurfacePoolAllocationData);
+  D_MAGIC_ASSERT (lock, CoreSurfaceBufferLock);
+
+  D_DEBUG_AT (FBDev_SurfLock_Aux, "%s (%d, %p)\n", __func__,
+              data->aux_part, lock->buffer);
+
+  D_MAGIC_ASSERT (alloc->chunk, Chunk);
+  chunk = alloc->chunk;
+
+  lock->pitch  = chunk->pitch;
+  lock->offset = chunk->offset;
+  lock->addr   = local->mem + chunk->offset;
+  lock->phys   = data->part_base + chunk->offset;
+
+  D_DEBUG_AT (FBDev_SurfLock_Aux,
+              "  -> offset 0x%.8lx (%lu), pitch %d, addr %p, phys 0x%.8lx\n",
+              lock->offset, lock->offset, lock->pitch, lock->addr, lock->phys);
+
+  return DFB_OK;
+}
+
+static DFBResult
+fbdev_aux_Unlock (CoreSurfacePool       *pool,
+                  void                  *pool_data,
+                  void                  *pool_local,
+                  CoreSurfaceAllocation *allocation,
+                  void                  *alloc_data,
+                  CoreSurfaceBufferLock *lock)
+{
+  const STMFB_AuxSurfacePoolData           * const data  = pool_data;
+  const STMFB_AuxSurfacePoolLocalData      * const local = pool_local;
+  const STMFB_AuxSurfacePoolAllocationData * const alloc = alloc_data;
+
+  D_MAGIC_ASSERT (pool, CoreSurfacePool);
+  D_MAGIC_ASSERT (data, STMFB_AuxSurfacePoolData);
+  D_MAGIC_ASSERT (local, STMFB_AuxSurfacePoolLocalData);
+  D_MAGIC_ASSERT (allocation, CoreSurfaceAllocation);
+  D_MAGIC_ASSERT (alloc, STMFB_AuxSurfacePoolAllocationData);
+  D_MAGIC_ASSERT (lock, CoreSurfaceBufferLock);
+
+  D_DEBUG_AT (FBDev_SurfLock_Aux, "%s (%d, %p)\n", __func__,
+              data->aux_part, lock->buffer);
+
+  D_UNUSED_P (data);
+  D_UNUSED_P (local);
+  D_UNUSED_P (alloc);
+
+  return DFB_OK;
+}
+
+static const SurfacePoolFuncs fbdev_aux_SurfacePoolFuncs = {
+  .PoolDataSize       = fbdev_aux_PoolDataSize,
+  .PoolLocalDataSize  = fbdev_aux_PoolLocalDataSize,
+  .AllocationDataSize = fbdev_aux_AllocationDataSize,
+
+  .InitPool    = fbdev_aux_InitPool,
+  .JoinPool    = fbdev_aux_JoinPool,
+  .DestroyPool = fbdev_aux_DestroyPool,
+  .LeavePool   = fbdev_aux_LeavePool,
+
+  .TestConfig       = fbdev_aux_TestConfig,
+  .AllocateBuffer   = fbdev_aux_AllocateBuffer,
+  .DeallocateBuffer = fbdev_aux_DeallocateBuffer,
+
+  .MuckOut = fbdev_aux_MuckOut,
+
+  .Lock   = fbdev_aux_Lock,
+  .Unlock = fbdev_aux_Unlock,
+};
+
+void
+fbdev_aux_surface_pools_init (CoreDFB * const core)
+{
+  unsigned long           total_auxmem = 0;
+  struct stmfbio_auxmem2  auxmem;
+  int                     i;
+
+  D_ASSERT (dfb_core_is_master (core));
+
+  D_ASSUME (D_ARRAY_SIZE (dfb_fbdev->shared->aux_pools) ==
+            (STMFBGP_GFX_LAST - STMFBGP_GFX_FIRST + 1));
+
+  for (i = -1, auxmem.index = 0;
+       auxmem.index < D_ARRAY_SIZE (dfb_fbdev->shared->aux_pools);
+       ++auxmem.index)
+    {
+      CoreSurfacePool *pool;
+
+      if (ioctl (dfb_fbdev->fd, STMFBIO_GET_AUXMEMORY2, &auxmem) != 0)
+        break;
+
+      if (!auxmem.size)
+        continue;
+
+      dfb_fbdev->shared->aux_pool_index = auxmem.index;
+
+      if (dfb_surface_pool_initialize (core,
+                                       &fbdev_aux_SurfacePoolFuncs, &pool))
+        continue;
+
+      dfb_fbdev->shared->aux_pools[++i] = pool;
+      total_auxmem += pool->desc.size;
+    }
+
+  dfb_fbdev->shared->aux_pool_index = -1;
+
+  if (total_auxmem)
+    D_INFO ("FBDev/Surfaces/Aux: %lukB of auxmem!\n", total_auxmem / 1024);
+  else
+    D_INFO ("FBDev/Surfaces/Aux: no auxmem available!\n");
+}
+
+void
+fbdev_aux_surface_pools_destroy (CoreDFB * const core)
+{
+  int       i;
+
+  D_ASSERT (dfb_core_is_master (core));
+
+  for (i = 0; i < D_ARRAY_SIZE (dfb_fbdev->shared->aux_pools); ++i)
+    {
+      CoreSurfacePool * const pool = dfb_fbdev->shared->aux_pools[i];
+      if (!pool)
+        continue;
+
+      if (dfb_surface_pool_destroy (pool))
+        continue;
+
+      dfb_fbdev->shared->aux_pools[i] = NULL;
+    }
+}
+
+void
+fbdev_aux_surface_pools_join (CoreDFB * const core)
+{
+  unsigned long  total_auxmem = 0;
+  int            i;
+
+  D_ASSERT (!dfb_core_is_master (core));
+
+  for (i = 0; i < D_ARRAY_SIZE (dfb_fbdev->shared->aux_pools); ++i)
+    {
+      CoreSurfacePool * const pool = dfb_fbdev->shared->aux_pools[i];
+      if (!pool)
+        continue;
+
+      if (dfb_surface_pool_join (core, pool, &fbdev_aux_SurfacePoolFuncs))
+        continue;
+
+      total_auxmem += pool->desc.size;
+    }
+
+  if (total_auxmem)
+    D_INFO ("FBDev/Surfaces/Aux: %lukB of auxmem!\n", total_auxmem / 1024);
+  else
+    D_INFO ("FBDev/Surfaces/Aux: no auxmem available!\n");
+}
+
+void
+fbdev_aux_surface_pools_leave (CoreDFB * const core)
+{
+  int       i;
+
+  D_ASSERT (!dfb_core_is_master (core));
+
+  for (i = 0; i < D_ARRAY_SIZE (dfb_fbdev->shared->aux_pools); ++i)
+    {
+      CoreSurfacePool * const pool = dfb_fbdev->shared->aux_pools[i];
+      if (!pool)
+        continue;
+
+      dfb_surface_pool_leave (pool);
+    }
+}
diff -Naur DirectFB-1.7.7/systems/fbdev/fbdev_aux_surface_pool.h DirectFB-1.7.7.stm/systems/fbdev/fbdev_aux_surface_pool.h
--- DirectFB-1.7.7/systems/fbdev/fbdev_aux_surface_pool.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7.stm/systems/fbdev/fbdev_aux_surface_pool.h	2015-05-15 18:43:40.253571080 +0200
@@ -0,0 +1,42 @@
+/*
+   FBDev system driver - auxmem surface pool memory
+
+   (c) Copyright 2009-2014  STMicroelectronics Ltd.
+
+   Based on code by Andr Draszik <andre.draszik@st.com>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#ifndef __STMFB_AUX_SURFACE_POOL_H__
+#define __STMFB_AUX_SURFACE_POOL_H__
+
+#include <core/coretypes.h>
+
+extern void
+fbdev_aux_surface_pools_init (CoreDFB * const core);
+
+extern void
+fbdev_aux_surface_pools_destroy (CoreDFB * const core);
+
+extern void
+fbdev_aux_surface_pools_join (CoreDFB * const core);
+
+extern void
+fbdev_aux_surface_pools_leave (CoreDFB * const core);
+
+
+#endif /* __STMFB_AUX_SURFACE_POOL_H__ */
diff -Naur DirectFB-1.7.7/systems/fbdev/fbdev.c DirectFB-1.7.7.stm/systems/fbdev/fbdev.c
--- DirectFB-1.7.7/systems/fbdev/fbdev.c	2015-02-01 20:42:59.000000000 +0100
+++ DirectFB-1.7.7.stm/systems/fbdev/fbdev.c	2015-05-15 18:43:40.241559080 +0200
@@ -98,6 +98,10 @@
 
 #include <core/core_system.h>
 
+#if HAVE_STMFB_H
+#include "fbdev_aux_surface_pool.h"
+#endif
+
 DFB_CORE_SYSTEM( fbdev )
 
 
@@ -607,6 +611,10 @@
 
      dfb_surface_pool_initialize( core, &fbdevSurfacePoolFuncs, &dfb_fbdev->shared->pool );
 
+#if HAVE_STMFB_H
+     fbdev_aux_surface_pools_init( core );
+#endif
+
      /* Register primary screen functions */
      screen = dfb_screens_register( NULL, NULL, &primaryScreenFuncs );
 
@@ -705,6 +713,10 @@
 
      dfb_surface_pool_join( core, dfb_fbdev->shared->pool, &fbdevSurfacePoolFuncs );
 
+#if HAVE_STMFB_H
+     fbdev_aux_surface_pools_join( core );
+#endif
+
      /* Register primary screen functions */
      screen = dfb_screens_register( NULL, NULL, &primaryScreenFuncs );
 
@@ -765,7 +777,12 @@
 
      dfb_agp_shutdown();
 
-     dfb_surface_pool_destroy( dfb_fbdev->shared->pool );
+     if (dfb_fbdev->shared->pool)
+          dfb_surface_pool_destroy( dfb_fbdev->shared->pool );
+
+#if HAVE_STMFB_H
+     fbdev_aux_surface_pools_destroy( dfb_fbdev->core );
+#endif
 
      munmap( dfb_fbdev->framebuffer_base, shared->fix.smem_len );
 
@@ -793,6 +810,10 @@
 
      dfb_agp_leave();
 
+#if HAVE_STMFB_H
+     fbdev_aux_surface_pools_leave( dfb_fbdev->core );
+#endif
+
      dfb_surface_pool_leave( dfb_fbdev->shared->pool );
 
      munmap( dfb_fbdev->framebuffer_base,
diff -Naur DirectFB-1.7.7/systems/fbdev/fbdev.h DirectFB-1.7.7.stm/systems/fbdev/fbdev.h
--- DirectFB-1.7.7/systems/fbdev/fbdev.h	2013-12-19 01:16:24.000000000 +0100
+++ DirectFB-1.7.7.stm/systems/fbdev/fbdev.h	2015-05-15 18:43:40.245563080 +0200
@@ -102,6 +102,10 @@
      CoreLayerRegionConfig    config;
 
      SurfaceManager          *manager;
+
+     CoreSurfacePool         *aux_pools[5]; /* STMFBGP_GFX_LAST - STMFBGP_GFX_FIRST + 1 */
+     /* for exclusive use by fbdev_aux_surface_pool.c */
+     unsigned int             aux_pool_index;
 } FBDevShared;
 
 typedef struct {
diff -Naur DirectFB-1.7.7/systems/fbdev/fbdev_surface_pool.c DirectFB-1.7.7.stm/systems/fbdev/fbdev_surface_pool.c
--- DirectFB-1.7.7/systems/fbdev/fbdev_surface_pool.c	2013-12-19 01:16:24.000000000 +0100
+++ DirectFB-1.7.7.stm/systems/fbdev/fbdev_surface_pool.c	2015-05-15 18:43:40.257575080 +0200
@@ -247,7 +247,7 @@
      if ((surface->type & CSTF_LAYER) && surface->resource_id == DLID_PRIMARY)
           return DFB_OK;
 
-     ret = dfb_surfacemanager_allocate( local->core, data->manager, buffer, NULL, NULL );
+     ret = dfb_surfacemanager_allocate( local->core, data->manager, buffer, NULL, NULL, true );
 
      D_DEBUG_AT( FBDev_Surfaces, "  -> %s\n", DirectFBErrorString(ret) );
 
@@ -284,7 +284,7 @@
           dfb_surface_calc_buffer_size( surface, 8, 1, NULL, &allocation->size );
      }
      else {
-          ret = dfb_surfacemanager_allocate( local->core, data->manager, buffer, allocation, &alloc->chunk );
+          ret = dfb_surfacemanager_allocate( local->core, data->manager, buffer, allocation, &alloc->chunk, true );
           if (ret)
                return ret;
 
diff -Naur DirectFB-1.7.7/systems/fbdev/Makefile.am DirectFB-1.7.7.stm/systems/fbdev/Makefile.am
--- DirectFB-1.7.7/systems/fbdev/Makefile.am	2013-07-17 04:49:59.000000000 +0200
+++ DirectFB-1.7.7.stm/systems/fbdev/Makefile.am	2015-05-15 18:43:40.241559080 +0200
@@ -38,6 +38,12 @@
 	surfacemanager.c	\
 	vt.c
 
+
+if STMFB_H
+internalinclude_HEADERS += fbdev_aux_surface_pool.h
+libdirectfb_fbdev_la_SOURCES += fbdev_aux_surface_pool.c
+endif
+
 libdirectfb_fbdev_la_LIBADD = \
 	$(top_builddir)/lib/direct/libdirect.la \
 	$(top_builddir)/lib/fusion/libfusion.la \
diff -Naur DirectFB-1.7.7/systems/fbdev/surfacemanager.c DirectFB-1.7.7.stm/systems/fbdev/surfacemanager.c
--- DirectFB-1.7.7/systems/fbdev/surfacemanager.c	2013-12-19 01:16:24.000000000 +0100
+++ DirectFB-1.7.7.stm/systems/fbdev/surfacemanager.c	2015-05-15 18:43:40.257575080 +0200
@@ -192,7 +192,8 @@
                                        SurfaceManager         *manager,
                                        CoreSurfaceBuffer      *buffer,
                                        CoreSurfaceAllocation  *allocation,
-                                       Chunk                 **ret_chunk )
+                                       Chunk                 **ret_chunk,
+                                       bool                    need_workaround )
 {
      int pitch;
      int length;
@@ -233,11 +234,11 @@
      D_MAGIC_ASSERT( c, Chunk );
 
      /* FIXME_SC_2  Workaround creation happening before graphics driver initialization. */
-     if (!c->next) {
+     if (need_workaround && !c->next) {
           int length = dfb_gfxcard_memory_length();
 
           if (c->length != length - manager->offset) {
-               D_WARN( "workaround" );
+               D_WARN( "workaround due to reserved video memory" );
 
                manager->length = length;
                manager->avail  = length - manager->offset;
@@ -326,7 +327,7 @@
           D_MAGIC_ASSERT( chunk, Chunk );
 
           allocation = chunk->allocation;
-          if (allocation) {
+          if (allocation && allocation->buffer) {
                CoreSurfaceBuffer *other;
                int                size, locks;
 
diff -Naur DirectFB-1.7.7/systems/fbdev/surfacemanager.h DirectFB-1.7.7.stm/systems/fbdev/surfacemanager.h
--- DirectFB-1.7.7/systems/fbdev/surfacemanager.h	2013-12-19 01:16:24.000000000 +0100
+++ DirectFB-1.7.7.stm/systems/fbdev/surfacemanager.h	2015-05-15 18:43:40.257575080 +0200
@@ -104,7 +104,8 @@
                                        SurfaceManager         *manager,
                                        CoreSurfaceBuffer      *buffer,
                                        CoreSurfaceAllocation  *allocation,
-                                       Chunk                 **ret_chunk );
+                                       Chunk                 **ret_chunk,
+                                       bool                    need_workaround );
 
 DFBResult dfb_surfacemanager_displace( CoreDFB           *core,
                                        SurfaceManager    *manager,
diff -Naur DirectFB-1.7.7/systems/Makefile.am DirectFB-1.7.7.stm/systems/Makefile.am
--- DirectFB-1.7.7/systems/Makefile.am	2013-12-19 01:16:24.000000000 +0100
+++ DirectFB-1.7.7.stm/systems/Makefile.am	2015-05-15 18:43:40.241559080 +0200
@@ -66,6 +66,12 @@
 VNC_DIR =
 endif
   
+if STMFBDEV_CORE
+STMFBDEV_DIR = stmfbdev
+else
+STMFBDEV_DIR =
+endif
+
 
 SUBDIRS = \
 	android \
@@ -80,4 +86,5 @@
 	$(X11VDPAU_DIR) \
 	$(SDL_DIR) \
 	$(OSX_DIR) \
-	$(VNC_DIR)
+	$(VNC_DIR) \
+	$(STMFBDEV_DIR)
diff -Naur DirectFB-1.7.7/systems/stmfbdev/Makefile.am DirectFB-1.7.7.stm/systems/stmfbdev/Makefile.am
--- DirectFB-1.7.7/systems/stmfbdev/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7.stm/systems/stmfbdev/Makefile.am	2015-05-15 18:43:40.257575080 +0200
@@ -0,0 +1,11 @@
+## Makefile.am for DirectFB/systems/stmfbdev
+
+internalincludedir = $(INTERNALINCLUDEDIR)/stmfbdev
+
+internalinclude_HEADERS = \
+	vt.h			\
+	stmfbdev.h
+
+systemsdir = $(MODULEDIR)/systems
+
+include $(top_srcdir)/rules/libobject.make
diff -Naur DirectFB-1.7.7/systems/stmfbdev/stmfbdev.h DirectFB-1.7.7.stm/systems/stmfbdev/stmfbdev.h
--- DirectFB-1.7.7/systems/stmfbdev/stmfbdev.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7.stm/systems/stmfbdev/stmfbdev.h	2015-05-15 18:43:40.261579081 +0200
@@ -0,0 +1,56 @@
+/*
+   (c) Copyright 2010       STMicroelectronics (R&D) Ltd.
+   (c) Copyright 2001-2009  The world wide DirectFB Open Source Community (directfb.org)
+   (c) Copyright 2000-2004  Convergence (integrated media) GmbH
+
+   All rights reserved.
+
+   Written by Andr Draszik <andre.draszik@st.com>.
+
+   Based on work by Denis Oliver Kropp <dok@directfb.org>,
+                    Andreas Hundt <andi@fischlustig.de>,
+                    Sven Neumann <neo@directfb.org>,
+                    Ville Syrjl <syrjala@sci.fi> and
+                    Claudio Ciccani <klan@users.sf.net>.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#ifndef __STMFBDEV__STMFBDEV_H__
+#define __STMFBDEV__STMFBDEV_H__
+
+#include <core/system.h>
+
+#include <fusion/shmalloc.h>
+
+#include <core/surface_pool.h>
+
+#include "vt.h"
+
+
+typedef struct {
+     int magic;
+
+     CoreDFB *core;
+
+     struct _STMfbdevSharedData *shared;
+     int                 fd;
+     void               *framebuffer_base;
+     VirtualTerminal    *vt;
+} STMfbdev;
+
+
+#endif /* __STMFBDEV__STMFBDEV_H__ */
diff -Naur DirectFB-1.7.7/systems/stmfbdev/vt.h DirectFB-1.7.7.stm/systems/stmfbdev/vt.h
--- DirectFB-1.7.7/systems/stmfbdev/vt.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7.stm/systems/stmfbdev/vt.h	2015-05-15 18:43:04.814165962 +0200
@@ -0,0 +1,87 @@
+/*
+   (c) Copyright 2012-2013  DirectFB integrated media GmbH
+   (c) Copyright 2001-2013  The world wide DirectFB Open Source Community (directfb.org)
+   (c) Copyright 2000-2004  Convergence (integrated media) GmbH
+
+   All rights reserved.
+
+   Written by Denis Oliver Kropp <dok@directfb.org>,
+              Andreas Shimokawa <andi@directfb.org>,
+              Marek Pikarski <mass@directfb.org>,
+              Sven Neumann <neo@directfb.org>,
+              Ville Syrjl <syrjala@sci.fi> and
+              Claudio Ciccani <klan@users.sf.net>.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+
+
+#ifndef __VT_H__
+#define __VT_H__
+
+#include <signal.h>
+#include <termios.h>
+#include <unistd.h>
+#include <linux/vt.h>
+
+#include <directfb.h>
+
+typedef struct {
+     int fd0;                      /* file descriptor of /dev/tty0 */
+     int fd;                       /* file descriptor of /dev/ttyN
+                                      where N is the number of the allocated VT,
+                                      may be equal to 'fd0' if VT allocation
+                                      is disabled by "--no-vt-switch" */
+
+     int num;                      /* number of vt where DirectFB runs */
+     int prev;                     /* number of vt DirectFB was started from */
+
+     int old_fb;                   /* original fb mapped to vt */
+
+     struct sigaction sig_usr1;    /* previous signal handler for USR1 */
+     struct sigaction sig_usr2;    /* previous signal handler for USR2 */
+
+     struct vt_mode   vt_mode;     /* previous VT mode */
+
+     DirectThread    *thread;
+     pthread_mutex_t  lock;
+     pthread_cond_t   wait;
+
+     int              vt_sig;
+     struct termios   old_ts;
+
+     bool             flush;
+     DirectThread    *flush_thread;
+} VirtualTerminal;
+
+/*
+ * allocates and switches to a new virtual terminal
+ */
+DFBResult dfb_vt_initialize( void );
+DFBResult dfb_vt_join( void );
+
+/*
+ * deallocates virtual terminal
+ */
+DFBResult dfb_vt_shutdown( bool emergency );
+DFBResult dfb_vt_leave( bool emergency );
+
+DFBResult dfb_vt_detach( bool force );
+
+bool dfb_vt_switch( int num );
+
+#endif
diff -Naur DirectFB-1.7.7/systems/x11/surfacemanager.c DirectFB-1.7.7.stm/systems/x11/surfacemanager.c
--- DirectFB-1.7.7/systems/x11/surfacemanager.c	2013-12-19 01:16:24.000000000 +0100
+++ DirectFB-1.7.7.stm/systems/x11/surfacemanager.c	2015-05-15 18:43:40.261579081 +0200
@@ -270,7 +270,7 @@
           D_MAGIC_ASSERT( chunk, Chunk );
 
           allocation = chunk->allocation;
-          if (allocation) {
+          if (allocation && allocation->buffer) {
                CoreSurfaceBuffer *other;
                int                size, locks;
 
diff -Naur DirectFB-1.7.7/tests/fixup_rle.c DirectFB-1.7.7.stm/tests/fixup_rle.c
--- DirectFB-1.7.7/tests/fixup_rle.c	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7.stm/tests/fixup_rle.c	2015-05-15 18:43:40.261579081 +0200
@@ -0,0 +1,180 @@
+/*
+ * Copyright (C) 2006 ST-Microelectronics R&D <alain.clement@st.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+/*
+ *              BD-RLE8 FILE HEADER FIXUP
+ */
+
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
+
+#include <directfb.h>
+#include <direct/messages.h>
+
+#include "unit_test_rle_helpers.h"
+#include "rle_build_packet.h"
+
+
+#define DFBFAIL(err)                                           \
+    {                                                          \
+        fprintf( stderr, "%s <%d>:\n\t", __FILE__, __LINE__ ); \
+        DirectFBErrorFatal( #err, err );                         \
+    }
+
+
+#define DFBCHECK(x)                                            \
+  {                                                            \
+    DFBResult err = x;                                         \
+                                                               \
+    if (err != DFB_OK)        DFBFAIL(err);                    \
+  }
+
+#define DISPLAY_INFO(x...) do {                                \
+                              if (!direct_config->quiet)       \
+                                   direct_messages_info( x );  \
+                           } while (0)
+
+
+
+static DFBResult
+rle_fixup_file_header (char *filename, long force_bdmode)
+{
+    //    Buffer and size in bytes
+    void                       *buffer         = NULL;
+    unsigned long               buffer_size    = 0;
+
+
+    //    Image file elements and information
+    unsigned long               width          = 0;
+    unsigned long               height         = 0;
+    unsigned long               depth          = 0;
+
+    //    Image file boolean attributes
+    unsigned long               rawmode        = 0;
+    unsigned long               bdmode         = 0;
+    unsigned long               topfirst       = 0;
+
+    unsigned long               payload_size   = 0;
+    unsigned long               colormap_size  = 0;
+
+    void                        *payload       = NULL;
+    void                        *colormap      = NULL;
+
+    int                         status;
+
+    //    We actually read the file contents into memory and collect details
+    //    using a helper function (see "unit_test_rle_helpers.h").
+    //    NOTE: rle_load_image will allocate payload and colormap buffers
+    //          NULL buffer pointers means internal "allocation requested"
+    //          Those buffers must be released.
+    status  = rle_load_image   (filename, &width, &height, &depth,
+                                &rawmode, &bdmode, &topfirst, &buffer_size,
+                                &payload, &payload_size,
+                                &colormap, &colormap_size);
+
+    if (!status)
+    {
+        printf ("%s: Couldn't load image file %s\n",__FUNCTION__,filename);
+        return status;
+    }
+
+
+    if (force_bdmode) bdmode=1;
+
+    //DISPLAY_INFO (" colormap : %d\n",       (int)   colormap);
+    //DISPLAY_INFO (" colormap_size : %d\n",  (int)   colormap_size);
+    //DISPLAY_INFO (" payload : %d\n",        (int)   payload);
+    //DISPLAY_INFO (" payload_size : %d\n",   (int)   payload_size);
+
+
+    //    We attach the colormap to the RLE packet :
+    //    RLE header, colormap (if available) and payload together
+    buffer_size = RLE_HEADER_SIZE + colormap_size + payload_size;
+
+    //    Static memory data buffer allocation.
+    buffer = malloc (buffer_size);
+    if (!buffer) return DFB_FAILURE;
+
+    //    We now rebuild the whole image buffer, setting up the header,
+    //    copying the (eventual) collected colormap and payload.
+    //    We are using another helper function (see "rle_build_packet.h").
+    DFBCHECK ( rle_build_packet (buffer, buffer_size, width, height, depth,
+                                                    rawmode, bdmode, topfirst,
+                                                    colormap, colormap_size,
+                                                    payload, payload_size));
+
+    //    Now we can release colormap & payload buffers eventually allocated
+    //    previously by  "rle_load_image"  helper function (since "buffer" has
+    //    just been set by  "rle_build_packet")
+    if (colormap)    free(colormap);  colormap = NULL;   colormap_size = 0;
+    if (payload)     free(payload);   payload  = NULL;   payload_size  = 0;
+
+
+    //    Write full buffer to new file
+    {
+        FILE  *file;
+        char newfilename[512];
+        sprintf (newfilename, "%s.%s", filename, "RLE");
+
+        file = fopen(newfilename, "wb");
+        if (!file)
+        {
+            DISPLAY_INFO ("Can't fix up : %s\n", newfilename);
+            return 0;
+        }
+        else
+        {
+            DISPLAY_INFO ("Writing full buffer to : %s\n", newfilename);
+            fwrite (buffer, sizeof(char), buffer_size, file);
+            fclose (file);
+        }
+    }
+
+    //  Release the main buffer, we don't need it anymore.
+    if (buffer)      free(buffer);    buffer   = NULL;   buffer_size   = 0;
+
+    return DFB_OK;
+}
+
+
+
+//------------------------------------------------------------------------------
+//  Unit Test main
+//------------------------------------------------------------------------------
+int main (int argc, char **argv)
+{
+    int j;
+
+    //    File name to load logo image from
+    char *filename      =   NULL;
+    long force_bdmode   =   1;
+
+    DISPLAY_INFO ("Fixing up %d files\n",argc);
+    for (j=1; j<argc; j++)
+    {
+        filename     =     argv[j];
+        DISPLAY_INFO ("Fixing up : %s\n",filename);
+        //    Process file
+        DFBCHECK ( rle_fixup_file_header (filename, force_bdmode));
+    }
+
+    return 0;
+}
diff -Naur DirectFB-1.7.7/tests/README DirectFB-1.7.7.stm/tests/README
--- DirectFB-1.7.7/tests/README	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7.stm/tests/README	2015-05-15 18:43:40.261579081 +0200
@@ -0,0 +1,22 @@
+INTRODUCTION
+------------
+
+This directory contains unit-test code.
+
+
+
+DESCRIPTION
+-----------
+
+unit_test_rle
+
+	Displays and blits around an image over the primary surface.
+	The RLE/BMP image gets loaded into a static memory buffer first;
+	it is then associated to a DirectFB data buffer tied to an Image Provider.
+
+USAGE
+-----
+
+unit_test_rle	[file_name]
+
+	(the file name defaults to "directfb.bmp" in the current working directory)
diff -Naur DirectFB-1.7.7/tests/rle_build_packet.c DirectFB-1.7.7.stm/tests/rle_build_packet.c
--- DirectFB-1.7.7/tests/rle_build_packet.c	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7.stm/tests/rle_build_packet.c	2015-05-15 18:43:40.265583081 +0200
@@ -0,0 +1,272 @@
+/*
+ * Copyright (C) 2006 ST-Microelectronics R&D <alain.clement@st.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+/*
+ *              RLE PACKET HELPER LIBRARY
+ */
+
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
+
+#include "rle_build_packet.h"
+
+/*******************************************************************************
+ *
+ *   rle_build_packet:
+ *
+ *             DirectFB static memory buffer setup for RLE Image Provider
+ *
+ *   RLE Image Provider expects its DirectFB buffer holding header data+colormap
+ *   (RLE_OVERHEAD) and the RLE payload. This helper function sets up such a
+ *   buffer given a minimal set of parameters. The application must account for
+ *   RLE_HEADER_SIZE bytes at the beginning, then colormap bytes (variable,
+ *   dependent on depth) then the payload. The application must supply the
+ *   colormap but has the flexibility of submitting the payload data for copy
+ *   in the allocated I/O buffer (non NULL payload parameter), or collecting the
+ *   data from source ahead of time into the I/O buffer, thus avoiding a copy
+ *   step, as long as the payload sections make room for RLE_OVERHEAD(depth)
+ *   reserved bytes at the beginning of "buffer".
+ *
+ *   Note 1:The colormap is not required to be supplied. In such a case (NULL
+ *          pointer), the colormap section gets skipped (absent from header).
+ *
+ *   Note 2:BMP/DIB row addressing normally starts from the bottom. A negative
+ *          height means images start from the top of the bitmap (weirdness ?)
+ *          "topfirstmode" flag is provided here to get a start from the top of
+ *          the bitmap. This behavior is normally applicable to non RLE
+ *          compressed images, but extended to any format in our RLE Image
+ *          Provider implementation.
+ *
+ *     -------------------------------------------------------------------------
+ *                             DirectFB buffer Mapping
+ *     -------------------------------------------------------------------------
+ *
+ *         RLE_PREAMBLE
+ *             (14)
+ *     -------------------    RLE_HEADER
+ *                             (54)
+ *         RLE_BIHEADER
+ *             (40)
+ *     --------------------------------------    RLE_OVERHEAD
+ *                                                 (54-310)
+ *                         RLE_PALETTE
+ *                             (0-256)
+ *     ------------------------------------------------------  RLE_DFB_BUFFER
+ *                                                              (Packet Size)
+ *
+ *
+ *                                             RLE_PAYLOAD
+ *
+ *                      rawmode = Raw-Pixels (1) or Run-Length coded (0)
+ *                      bdmode  = BD-RLE     (1) or Legacy-RLE coded (0)
+ *
+ *     -------------------------------------------------------------------------
+ *
+ *******************************************************************************/
+
+DFBResult
+rle_build_packet (
+    u8        *buffer,       /*    I/O  :    Packet buffer            */
+    u32        buffer_size,  /*    I    :    Packet size              */
+    u32        width,        /*    I    :    Image width              */
+    u32        height,       /*    I    :    Image height             */
+    u32        depth,        /*    I    :    Pixels depth             */
+    u32        rawmode,      /*    I    :    Raw mode flag      (0/1) */
+    u32        bdmode,       /*    I    :    BD-RLE mode flag   (0/1) */
+    u32        topfirstmode, /*    I    :    Topfirst mode flag (0/1) */
+    DFBColor  *colormap,     /*    I    :    Palette / NULL           */
+    u32        colormap_size,/*    I    :    Palette size             */
+    void      *payload,      /*    I    :    Payload / NULL           */
+    u32        payload_size  /*    I    :    Payload size             */
+)
+{
+	/*
+	 * RLE Compression identifier (see BMP/RLE header - Offset:30 --- DWORD)
+	 */
+	typedef enum {
+	     RLEIC_NONE      = 0,   /* Implemented      as of version 1.0.0 */
+	     RLEIC_RLE8      = 1,   /* Implemented      as of version 1.0.0 */
+	     RLEIC_RLE4      = 2,   /* Unimplemented */
+	     RLEIC_BITFIELDS = 3,   /* Unimplemented */
+	     RLEIC_BD_RLE8   = 4    /* Implemented      as of version 1.1.0 */
+	} RLEImageCompression;
+
+
+
+
+
+     /* Little-endian portable data bytes order ... */
+     #define RLE_HEADER_SET_MAGIC(ptr,l,h)       {      \
+             ptr[0]=(u8)l;                              \
+             ptr[1]=(u8)h;                              \
+             }
+     #define RLE_HEADER_WRITE_LE_16(ptr,data)    {      \
+            *ptr++    =    (data>>0 ) & 0xff;           \
+            *ptr++    =    (data>>8 ) & 0xff;           \
+     }
+     #define RLE_HEADER_WRITE_LE_32(ptr,data)    {      \
+            *ptr++    =    (data>>0 ) & 0xff;           \
+            *ptr++    =    (data>>8 ) & 0xff;           \
+            *ptr++    =    (data>>16) & 0xff;           \
+            *ptr++    =    (data>>24) & 0xff;           \
+     }
+
+     #define RLE_PALETTE_SIZE          (colormap_size & ~0x03)
+     #define RLE_OVERHEAD              (RLE_HEADER_SIZE+RLE_PALETTE_SIZE)
+
+     DFBResult ret = DFB_OK;
+     u8  *hptr;
+     u32  bihsize          = RLE_BIHEADER_SIZE;
+     u32  num_colors       = RLE_PALETTE_SIZE/4;
+     u32  imp_colors       = RLE_PALETTE_SIZE/4;
+     u32  img_offset       = RLE_OVERHEAD;
+     int  payload_max_size = MIN(buffer_size-RLE_OVERHEAD,payload_size);
+     int  height_dib       = topfirstmode ? -height : height;
+
+     RLEImageCompression  compression;
+
+     /* Check for any payload/buffer size discrepancy */
+     if (payload_max_size<0) {
+         return DFB_INVARG;
+     }
+
+     /* Switch compression mode */
+     if (rawmode) {
+         switch (depth) {
+              case 16:
+              case 24:
+              case 32:
+              case 8:
+              case 4:
+              case 1:
+                  compression = RLEIC_NONE;
+                  break;
+              default:
+                   return DFB_INVARG;
+         }
+     }
+     else {
+         switch (depth) {
+              case 8:
+                   if (!bdmode)     {
+                       compression = RLEIC_RLE8;
+                       break;
+                   }
+                   else             {
+                       compression = RLEIC_BD_RLE8;
+                       break;
+                   }
+              case 4:
+                   if (!bdmode)     {
+                       compression = RLEIC_RLE4;
+                       break;
+                   }
+              case 1:
+              case 16:
+              case 24:
+              case 32:
+              default:
+                   return DFB_INVARG;
+         }
+     }
+
+     /* Cleanup preamble, header and eventual palette area */
+     memset( buffer, 0,  img_offset);
+
+     /* Pointer to buffer header start */
+     hptr = buffer;
+
+     /* Offset:00 --- 2 bytes: Magic - Zero for now */
+     RLE_HEADER_WRITE_LE_16 (hptr, 0);
+
+     /* Offset:02 --- 4 bytes: FileSize */
+     RLE_HEADER_WRITE_LE_32 (hptr, buffer_size);
+
+     /* Offset:06 --- 4 bytes: Reserved */
+     RLE_HEADER_WRITE_LE_32 (hptr, 0);
+
+     /* Offset:10 --- 4 bytes: DataOffset */
+     RLE_HEADER_WRITE_LE_32 (hptr, img_offset);
+
+     /* Offset:14 --- 4 bytes: HeaderSize */
+     RLE_HEADER_WRITE_LE_32 (hptr, bihsize);
+
+     /* Offset:18 --- 4 bytes: Width */
+     RLE_HEADER_WRITE_LE_32 (hptr, width);
+
+     /* Offset:22 --- 4 bytes: Height (negative value means top first mode) */
+     RLE_HEADER_WRITE_LE_32 (hptr, height_dib);
+
+     /* Offset:26 --- 2 bytes: Planes */
+     RLE_HEADER_WRITE_LE_16 (hptr, 1);
+
+     /* Offset:28 --- 2 bytes: Depth */
+     RLE_HEADER_WRITE_LE_16 (hptr, depth);
+
+     /* Offset:30 --- 4 bytes: Compression */
+     RLE_HEADER_WRITE_LE_32 (hptr, compression);
+
+     /* Offset:34 --- 4 bytes: CompressedSize */
+     RLE_HEADER_WRITE_LE_32 (hptr, payload_max_size);
+
+     /* Offset:38 --- 4 bytes: HorizontalResolution (don't care ...) */
+     RLE_HEADER_WRITE_LE_32 (hptr, 0);
+
+     /* Offset:42 --- 4 bytes: VerticalResolution (don't care ...) */
+     RLE_HEADER_WRITE_LE_32 (hptr, 0);
+
+     /* Offset:46 --- 4 bytes: UsedColors */
+     RLE_HEADER_WRITE_LE_32 (hptr, num_colors);
+
+     /* Offset:50 --- 4 bytes: ImportantColors (don't care ...) */
+     RLE_HEADER_WRITE_LE_32 (hptr, imp_colors);
+
+     /* Offset:54 --- 4 x num_colors bytes: Palette */
+     if (colormap_size>0 && colormap) {
+          int i;
+          for (i = 0; i < num_colors; i++) {
+
+               if (i>=colormap_size/4){
+                    RLE_HEADER_WRITE_LE_32 (hptr, 0);
+                    continue;
+               }
+
+               ((u8*)hptr)[i*4+3] = colormap[i].a;
+               ((u8*)hptr)[i*4+2] = colormap[i].r;
+               ((u8*)hptr)[i*4+1] = colormap[i].g;
+               ((u8*)hptr)[i*4+0] = colormap[i].b;
+          }
+     }
+
+     /* Offset:54 + 4 x num_colors ---  bytes: Payload */
+     if (payload_max_size>0 && payload) {
+         memcpy( buffer+img_offset, payload, payload_max_size);
+     }
+
+     /* Set first 2 bytes: Magic - valid header now */
+     RLE_HEADER_SET_MAGIC(buffer,'R','L');
+
+     return ret;
+}
+
+
+
+
diff -Naur DirectFB-1.7.7/tests/rle_build_packet.h DirectFB-1.7.7.stm/tests/rle_build_packet.h
--- DirectFB-1.7.7/tests/rle_build_packet.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7.stm/tests/rle_build_packet.h	2015-05-15 18:43:40.265583081 +0200
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2006 ST-Microelectronics R&D <alain.clement@st.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef RLE_BUILD_PACKET_H_
+#define RLE_BUILD_PACKET_H_
+
+#include <directfb.h>
+
+DFBResult
+rle_build_packet (
+    u8        *buffer,       /*    I/O  :    Packet buffer            */
+    u32        buffer_size,  /*    I    :    Packet size              */
+    u32        width,        /*    I    :    Image width              */
+    u32        height,       /*    I    :    Image height             */
+    u32        depth,        /*    I    :    Pixels depth             */
+    u32        rawmode,      /*    I    :    Raw mode flag      (0/1) */
+    u32        bdmode,       /*    I    :    BD-RLE mode flag   (0/1) */
+    u32        topfirstmode, /*    I    :    Topfirst mode flag (0/1) */
+    DFBColor  *colormap,     /*    I    :    Palette / NULL           */
+    u32        colormap_size,/*    I    :    Palette size             */
+    void      *payload,      /*    I    :    Payload / NULL           */
+    u32        payload_size  /*    I    :    Payload size             */
+);
+
+#define RLE_PREAMBLE_SIZE         (14)
+#define RLE_BIHEADER_SIZE         (40)
+#define RLE_HEADER_SIZE           (RLE_PREAMBLE_SIZE+RLE_BIHEADER_SIZE)
+
+#endif /*RLE_BUILD_PACKET_H_*/
diff -Naur DirectFB-1.7.7/tests/unit_test_rle.c DirectFB-1.7.7.stm/tests/unit_test_rle.c
--- DirectFB-1.7.7/tests/unit_test_rle.c	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7.stm/tests/unit_test_rle.c	2015-05-15 18:43:40.265583081 +0200
@@ -0,0 +1,419 @@
+/*
+ * Copyright (C) 2006 ST-Microelectronics R&D <alain.clement@st.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+/*
+ *              RLE IMAGE PROVIDER UNIT TEST
+ */
+
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
+
+#include <directfb.h>
+#include <direct/messages.h>
+
+#include "unit_test_rle_helpers.h"
+#include "rle_build_packet.h"
+
+#define DFBFAIL(err)                                           \
+    {                                                          \
+        fprintf( stderr, "%s <%d>:\n\t", __FILE__, __LINE__ ); \
+        DirectFBErrorFatal( #err, err );                         \
+    }
+
+#define DFBCHECK(x)                                            \
+  {                                                            \
+    DFBResult err = x;                                         \
+                                                               \
+    if (err != DFB_OK)        DFBFAIL(err);                    \
+  }
+
+#define DISPLAY_INFO(x...) do {                                \
+                              if (!direct_config->quiet)       \
+                                   direct_messages_info( x );  \
+                           } while (0)
+
+
+// WE'RE USING A CLEVER APPROACH FOR THE RLE PACKET BUILDER NOW
+#define CLEVER_APPROACH
+
+// WE'RE USING THE RLE PACKET BUILDER ONLY FOR NOW (DIRECT FILE ACCESS)
+#define USE_PACKET_BUILDER_ONLY
+
+// WE WANT TO DISPLAY SUBTITLES
+#define SUBTITLES_MODE
+
+
+//------------------------------------------------------------------------------
+//    Pointer to user-managed buffer holding RLE packet data bytes
+//------------------------------------------------------------------------------
+static void                 *buffer            = NULL;
+
+#   ifdef CLEVER_APPROACH
+
+    static  DFBColor        *color_palette     = NULL;
+    static  unsigned int     number_of_colors  = 0;
+
+#   endif
+
+
+
+//------------------------------------------------------------------------------
+//  Destroy DirectFB data buffer
+//------------------------------------------------------------------------------
+static DFBResult
+rle_destroy_databuffer (IDirectFBDataBuffer *databuffer)
+{
+    //  Release the databuffer, we don't need it anymore.
+    if (databuffer)     databuffer->Release (databuffer);
+    //  Release the static buffer, we don't need it anymore.
+    if (buffer)         free(buffer);           buffer         = NULL;
+
+#   ifdef CLEVER_APPROACH
+
+    //  Release the static colormap, we don't need it anymore.
+    if (color_palette)  free(color_palette);    color_palette  = NULL;
+    number_of_colors = 0;
+
+#   endif
+
+    return DFB_OK;
+}
+
+
+
+
+//------------------------------------------------------------------------------
+//  Create a DirectFB static data buffer holding our RLE data (read from a file)
+//------------------------------------------------------------------------------
+static DFBResult
+rle_build_databuffer (IDirectFB *dfb, char *filename,
+                                      IDirectFBDataBuffer **pdatabuffer)
+{
+    //  An Image provider instance can also be created from a directfb buffer
+    IDirectFBDataBuffer        *databuffer     = NULL;
+
+    //    Buffer description
+    DFBDataBufferDescription    buffer_dsc;
+
+    //    Image file elements and information
+    unsigned long               width          = 0;
+    unsigned long               height         = 0;
+    unsigned long               depth          = 0;
+
+    //    Image file boolean attributes
+    unsigned long               rawmode    	   = 0;
+    unsigned long               bdmode         = 0;
+    unsigned long               topfirst       = 0;
+
+      //     Size in bytes
+    unsigned long               buffer_size    = 0;
+
+    unsigned long               payload_size   = 0;
+    unsigned long               colormap_size  = 0;
+
+    void                        *payload       = NULL;
+    void                        *colormap      = NULL;
+
+    int                         success;
+
+    //    We actually read the file contents into memory and collect details
+    //    using a helper function (see "unit_test_rle_helpers.h").
+    //    NOTE: rle_load_image will allocate payload and colormap buffers
+    //          NULL buffer pointers means internal "allocation requested"
+    //          Those buffers must be released.
+    success = rle_load_image   (filename, &width, &height, &depth,
+                                &rawmode, &bdmode, &topfirst, &buffer_size,
+                                &payload, &payload_size,
+                                &colormap, &colormap_size);
+
+    if (!success)
+    {
+        DISPLAY_INFO ("%s: Couldn't load image file %s\n",__FUNCTION__,filename);
+        return DFB_UNSUPPORTED;
+    }
+
+
+#   ifdef CLEVER_APPROACH
+
+    //    Let's stash our colormap in global space first
+    {
+        int   i;
+
+        number_of_colors = colormap_size/4;
+
+        color_palette = malloc (number_of_colors*4);
+        if (!color_palette) return DFB_FAILURE;
+
+        for (i = 0; i < number_of_colors; i++)
+        {
+               DFBColor c;
+
+               c.a = 0xff;
+               c.r = ((u8*)colormap)[i*4+2];
+               c.g = ((u8*)colormap)[i*4+1];
+               c.b = ((u8*)colormap)[i*4+0];
+
+               color_palette[i] = c;
+        }
+    }
+
+    //    We won't attach the colormap to the RLE packet :
+    //    RLE header and payload only
+    buffer_size = RLE_HEADER_SIZE + payload_size;
+
+    //    Static memory data buffer (packet) allocation.
+    buffer = malloc (buffer_size);
+    if (!buffer) return DFB_FAILURE;
+
+    //    Let's paste our payload for encapsulation
+    //    (could have been read from the PES stream fragments as well).
+    memcpy (buffer+RLE_HEADER_SIZE, payload, payload_size);
+
+    //    We only want to setup the header, thus completing the encapsulation
+    //    We are using another helper function (see "rle_build_packet.h").
+    //    NULL payload and colormap means that we don't want the helper
+    //    function to copy anything. Zero "colormap_size" means that we don't
+    //    intend to attach any colormap to the packet.
+    //    "payload_size" must be set though" ...
+    DFBCHECK ( rle_build_packet (buffer, buffer_size, width, height, depth,
+                                                    rawmode, bdmode, topfirst,
+                                                    NULL, 0,
+                                                    NULL, payload_size));
+
+    //    NOTE: FEEL FREE TO TWEAK THE HELPER FUNCTION ABOVE IN ORDER TO
+    //          ACHIEVE TRUE ZERO-COPY ENCAPSULATION (PERHAPS USING THE
+    //          PAYLOAD OFFSET). YOU GET THE IDEA ...
+    //          THE RLE IMAGE PROVIDER DOESN'T HANDLE PAYLOAD FRAGMENTS,
+    //          SO THE PAYLOAD MUST USE A CONTIGUOUS SEGMENT IN THE RLE
+    //          PACKET.
+
+#   else
+
+    //    We attach the colormap to the RLE packet :
+    //    RLE header, colormap (if available) and payload together
+    buffer_size = RLE_HEADER_SIZE + colormap_size + payload_size;
+
+    //    Static memory data buffer allocation.
+    buffer = malloc (buffer_size);
+    if (!buffer) return DFB_FAILURE;
+
+    //    We now rebuild the whole image buffer, setting up the header,
+    //    copying the (eventual) collected colormap and payload.
+    //    We are using another helper function (see "rle_build_packet.h").
+    DFBCHECK ( rle_build_packet (buffer, buffer_size, width, height, depth,
+    												rawmode, bdmode, topfirst,
+                                                    colormap, colormap_size,
+                                                    payload, payload_size));
+
+    //    Note: we avoided colormap & payload copies by adopting a
+    //    more clever approach previously ...
+
+#   endif
+
+    //    Now we can release colormap & payload buffers eventually allocated
+    //    previously by  "rle_load_image"  helper function (since "buffer" has
+    //    just been set by  "rle_build_packet")
+    if (colormap)    free(colormap);  colormap = NULL;   colormap_size = 0;
+    if (payload)     free(payload);   payload  = NULL;   payload_size  = 0;
+
+    //    An Image Provider can be obtained from a directfb data buffer that
+    //    we specify and set up by ourselves using a static memory buffer
+    buffer_dsc.flags            =    DBDESC_MEMORY;
+    buffer_dsc.file             =    NULL;
+    buffer_dsc.memory.data      =    buffer;
+    buffer_dsc.memory.length    =    buffer_size;
+    DFBCHECK (dfb->CreateDataBuffer (dfb, &buffer_dsc, &databuffer));
+    //    Note: if no description had been specified (NULL), a streamed data
+    //    buffer would have been created instead.
+
+    //    Return newly created databuffer
+    *pdatabuffer = databuffer;
+
+    return DFB_OK;
+}
+
+
+
+//------------------------------------------------------------------------------
+//  Unit Test main
+//------------------------------------------------------------------------------
+int main (int argc, char **argv)
+{
+    int i, j;
+    DFBResult rle_build_databuffer_err;
+
+    //    File name to load logo image from
+    char *filename                           = NULL;
+
+    //    Basic directfb elements
+    IDirectFB               *dfb             = NULL;
+    IDirectFBSurface        *primary         = NULL;
+    int                      screen_width    = 0;
+    int                      screen_height   = 0;
+
+    //    The image is to be loaded into a surface that we can blit from.
+    IDirectFBSurface         *logo           = NULL;
+
+    //    Loading an image is done with an Image Provider.
+    IDirectFBImageProvider   *provider       = NULL;
+
+    //    An Image provider instance can also be created from a directfb buffer
+    IDirectFBDataBuffer      *databuffer     = NULL;
+
+    //    Surface description
+    DFBSurfaceDescription     surface_dsc;
+
+
+
+    //    Initialize directfb first
+    DFBCHECK (DirectFBInit (&argc, &argv));
+    DFBCHECK (DirectFBCreate (&dfb));
+    DFBCHECK (dfb->SetCooperativeLevel (dfb, DFSCL_FULLSCREEN));
+
+
+    //  Create primary surface
+    surface_dsc.flags = DSDESC_CAPS;
+    surface_dsc.caps  = DSCAPS_PRIMARY | DSCAPS_FLIPPING;
+    DFBCHECK (dfb->CreateSurface( dfb, &surface_dsc, &primary ));
+    DFBCHECK (primary->GetSize (primary, &screen_width, &screen_height));
+
+    if (argc==1)
+    {
+        argv[1] = "./data/directfb.rle";
+        argc++;
+    }
+
+    DISPLAY_INFO ("Rendering %d files\n",argc-1);
+    for (j=1; j<argc; j++)
+    {
+
+        //
+        //  --- WE CREATE OUR IMAGE PROVIDER INSTANCE HERE
+        //
+        filename     =     argv[j];
+        DISPLAY_INFO ("Rendering : %s\n",filename);
+
+        //  We create a directfb data buffer holding RLE image contents that we
+        //  pick up from a file (could get the RLE contents from memory as well).
+        //  "rle_build_databuffer" details the process of dealing with a memory
+        //  RLE packet as a matter of fact.
+        rle_build_databuffer_err = rle_build_databuffer (dfb, filename, &databuffer);
+        if (rle_build_databuffer_err == DFB_OK) {
+            //  We want to create an Image Provider tied to a directfb data buffer.
+            //  DirectFB will find (or not) an Image Provider for the data type
+            //  depending on Image Providers probe method (sniffing data headers)
+            DFBCHECK (databuffer->CreateImageProvider (databuffer, &provider));
+        }
+        else {
+#       ifdef   USE_PACKET_BUILDER_ONLY
+            DFBFAIL(rle_build_databuffer_err);
+#       else
+            //  We could also create an Image Provider by passing a filename.
+            //  DirectFB will find (or not) an Image Provider matching the file type.
+            DFBCHECK (dfb->CreateImageProvider (dfb, filename, &provider));
+#       endif
+        }
+
+
+
+        //    Get a surface description from the provider. It will contain the width,
+        //    height, bits per pixel and the flag for an alphachannel if the image
+        //    has one. If the image has no alphachannel the bits per pixel is set to
+        //    the bits per pixel of the primary layer to use simple blitting without
+        //    pixel format conversion.
+        DFBCHECK (provider->GetSurfaceDescription (provider, &surface_dsc));
+
+        //    Create a surface based on the description of the provider.
+        DFBCHECK (dfb->CreateSurface( dfb, &surface_dsc, &logo ));
+
+        //    Let the provider render to our surface. Image providers are supposed
+        //    to support every destination pixel format and size. If the size
+        //    differs the image will be scaled (bilinear). The last parameter allows
+        //    to specify an optional destination rectangle. We use NULL here so that
+        //    our image covers the whole logo surface.
+        DFBCHECK (provider->RenderTo (provider, logo, NULL));
+        //    Note: RLE Image Provider allows for direct non-scaled LUT-8 surface
+        //          rendering without any attached colormap.
+
+        #ifdef CLEVER_APPROACH
+        //    Let's setup our logo surface palette outside of the RLE Image
+        //    Provider if we got a colormap from rle_build_databuffer ...
+        if (color_palette)
+        {
+            IDirectFBPalette *palette;
+            DFBCHECK (logo->GetPalette (logo, &palette));
+            palette->SetEntries (palette, color_palette, number_of_colors, 0);
+            palette->Release (palette);
+        }
+        #endif
+
+        //
+        //  --- WE GET RID OF OUR IMAGE PROVIDER INSTANCE HERE
+        //
+        //    Release the provider, we don't need it anymore.
+        provider->Release (provider);           provider    = NULL;
+        //    Destroy the databuffer as well, we don't need it anymore.
+        rle_destroy_databuffer (databuffer);    databuffer  = NULL;
+
+
+#   ifndef SUBTITLES_MODE
+        //    We want to let the logo slide in on the left and slide out on the
+        //    right.
+        for (i = -surface_dsc.width; i < screen_width; i++)
+#   else
+        //    We want to let the logo slide in on the right and slide out on the
+        //    left.
+        for (i = screen_width-1; i >= -surface_dsc.width; i--)
+#   endif
+        {
+            //    Clear the screen.
+            DFBCHECK (primary->FillRectangle (primary, 0, 0,
+                                              screen_width, screen_height));
+
+            //    Blit the logo vertically centered with "i" as the X coordinate.
+            //    NULL means that we want to blit the whole surface.
+            DFBCHECK (primary->Blit (primary, logo, NULL, i,
+                                     (screen_height - surface_dsc.height) / 2));
+
+            //    Flip the front and back buffer, but wait for the vertical
+            //    retrace to avoid tearing.
+            DFBCHECK (primary->Flip (primary, NULL, DSFLIP_WAITFORSYNC));
+
+            if (argc < 3)
+            {
+                usleep(1000*5);
+            }
+        }
+
+        //    Release the image.
+        if (logo)
+        {
+            logo->Release (logo);
+        }
+
+   }
+
+   //    Release everything else
+   primary->Release (primary);
+   dfb->Release (dfb);
+
+   return 0;
+}
diff -Naur DirectFB-1.7.7/tests/unit_test_rle_helpers.c DirectFB-1.7.7.stm/tests/unit_test_rle_helpers.c
--- DirectFB-1.7.7/tests/unit_test_rle_helpers.c	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7.stm/tests/unit_test_rle_helpers.c	2015-05-15 18:43:40.269587080 +0200
@@ -0,0 +1,387 @@
+/*
+ * Copyright (C) 2006 ST-Microelectronics R&D <alain.clement@st.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+/*
+ *              RLE/BMP FILE FORMAT HELPER LIBRARY
+ */
+
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
+
+#include "unit_test_rle_helpers.h"
+
+typedef    unsigned long    DATA32;
+
+/*******************************************************************************
+ *
+ *                      RLE/BMP TYPE DEFINITIONS
+ *
+ *******************************************************************************/
+
+typedef struct tagRGBQUAD {
+   unsigned char       rgbBlue;
+   unsigned char       rgbGreen;
+   unsigned char       rgbRed;
+   unsigned char       rgbReserved;
+} RGBQUAD;
+
+
+/*
+ * RLE Compression identifier (see BMP/RLE header - Offset:30 --- DWORD)
+ */
+typedef enum {
+     RLEIC_NONE      = 0,   /* Implemented      as of version 1.0.0 */
+     RLEIC_RLE8      = 1,   /* Implemented      as of version 1.0.0 */
+     RLEIC_RLE4      = 2,   /* Unimplemented */
+     RLEIC_BITFIELDS = 3,   /* Unimplemented */
+     RLEIC_BD_RLE8   = 4    /* Implemented      as of version 1.1.0 */
+} RLEImageCompression;
+
+
+/*******************************************************************************
+ *
+ *                      RLE/BMP LITTLE-ENDIAN UTILITIES
+ *
+ *******************************************************************************/
+
+static int    ReadleShort             (FILE * file, unsigned short *ret)
+{
+   unsigned char       b[2];
+
+   if (fread(b, sizeof(unsigned char), 2, file) != 2) return 0;
+
+   *ret = (b[1] << 8) | b[0];
+   return 1;
+}
+
+static int    ReadleSignedShort       (FILE * file, signed short *ret)
+{
+   unsigned char       b[2];
+
+   if (fread(b, sizeof(unsigned char), 2, file) != 2) return 0;
+
+   *ret = (b[1] << 8) | b[0];
+   return 1;
+}
+
+static int    ReadleLong              (FILE * file, unsigned long *ret)
+{
+   unsigned char       b[4];
+
+   if (fread(b, sizeof(unsigned char), 4, file) != 4) return 0;
+
+   *ret = (b[3] << 24) | (b[2] << 16) | (b[1] << 8) | b[0];
+   return 1;
+}
+
+static int    ReadleSignedLong        (FILE * file, signed long *ret)
+{
+   unsigned char       b[4];
+
+   if (fread(b, sizeof(unsigned char), 4, file) != 4) return 0;
+
+   *ret = (b[3] << 24) | (b[2] << 16) | (b[1] << 8) | b[0];
+   return 1;
+}
+
+/*******************************************************************************
+ *
+ *                      RLE/BMP FILE FORMAT HELPER FUNCTION
+ *
+ *******************************************************************************/
+
+int  rle_load_image        (char              *filename,
+                            unsigned long     *width_ptr,
+                            unsigned long     *height_ptr,
+                            unsigned long     *depth_ptr,
+                            unsigned long     *rawmode_ptr,
+                            unsigned long     *bdmode_ptr,
+                            unsigned long     *topfirst_ptr,
+                            unsigned long     *buffer_size_ptr,
+                            void             **payload_ptr,
+                            unsigned long     *payload_size_ptr,
+                            void             **colormap_ptr,
+                            unsigned long     *colormap_size_ptr)
+{
+   FILE               *f;
+   char                type[2];
+   unsigned long       size, offset, headSize, comp, imgsize;
+   unsigned short      tmpShort, planes, bitcount, ncols;
+   signed short        tmpSignedShort;
+   signed long         tmpSignedLong;
+   unsigned long       topfirst;
+   unsigned long       i, w, h;
+   RGBQUAD             rgbQuads[256];
+   unsigned long       rmask = 0xff, gmask = 0xff, bmask = 0xff;
+   unsigned long       rshift = 0, gshift = 0, bshift = 0;
+
+   const    unsigned long    preambleSize = 14;
+
+    f = fopen(filename, "rb");
+	if (!f)
+	{
+		return 0;
+	}
+
+	/* HEADER */
+	{
+		struct stat statbuf;
+
+		if (stat(filename, &statbuf)== -1)
+		{
+			fclose(f);
+			return 0;
+		}
+		size = statbuf.st_size;
+
+		if (fread(type, 1, 2, f)!= 2)
+		{
+			fclose(f);
+			return 0;
+		}
+
+#       define IS_MAGIC(ptr,l,h)       ((ptr[0]==l) &&  (ptr[1]==h))
+		if (!IS_MAGIC(type, 'R','L') && !IS_MAGIC(type, 'B','M'))
+		{
+			fclose(f);
+			return 0;
+		}
+
+		fseek(f, 8, SEEK_CUR);
+		ReadleLong(f, &offset);
+		ReadleLong(f, &headSize);
+		if (offset >= size || offset < headSize + preambleSize)
+		{
+			fclose(f);
+			return 0;
+		}
+
+		/* HEADER DATA */
+		switch (headSize)
+		{
+		case 40:
+			ReadleLong(f, &w);
+			tmpSignedLong = 0;
+			ReadleSignedLong(f, &tmpSignedLong);
+			topfirst = tmpSignedLong < 0 ? 1 : 0;
+			h = topfirst ? -tmpSignedLong : tmpSignedLong;
+			ReadleShort(f, &planes);
+			ReadleShort(f, &bitcount);
+			ReadleLong(f, &comp);
+			ReadleLong(f, &imgsize);
+			imgsize = size - offset;
+
+			fseek(f, 16, SEEK_CUR);
+			break;
+
+		case 12:
+			ReadleShort(f, &tmpShort);
+			w = tmpShort;
+			tmpSignedShort = 0;
+			ReadleSignedShort(f, &tmpSignedShort);
+			topfirst = tmpSignedShort < 0 ? 1 : 0;
+			h = topfirst ? -tmpSignedShort : tmpSignedShort;
+			ReadleShort(f, &planes);
+			ReadleShort(f, &bitcount);
+			imgsize = size - offset;
+			comp = RLEIC_NONE;
+			//break;                    /* UNSUPPORTED BACKWARD COMPAT. */
+		default:
+			fclose(f);
+			return 0;
+
+		}
+
+		if (planes!=1)
+		{
+			fclose(f);
+			return 0;
+		}
+
+		if ((w < 1) || (h < 1) || (w > 8192) || (h > 8192))
+		{
+			fclose(f);
+			return 0;
+		}
+
+		ncols = 0;
+
+		if (bitcount < 16)
+		{
+			/* COLORMAP DATA */
+			switch (headSize)
+			{
+			case 40:
+				ncols = (offset - headSize - preambleSize) / 4;
+				if (ncols > 256)
+					ncols = 256;
+				fread(rgbQuads, 4, ncols, f);
+				break;
+
+			case 12:
+				ncols = (offset - headSize - preambleSize) / 3;
+				if (ncols > 256)
+					ncols = 256;
+				for (i = 0; i < ncols; i++)
+					fread(&rgbQuads[i], 3, 1, f);
+				//break;              /* UNSUPPORTED BACKWARD COMPAT. */
+			default:
+				fclose(f); /* UNSUPPORTED BACKWARD COMPAT. */
+				return 0;
+
+			}
+		}
+		else if (bitcount == 16 || bitcount == 32)
+		{
+			if (comp == RLEIC_BITFIELDS)
+			{
+				int bit;
+
+				ReadleLong(f, &bmask);
+				ReadleLong(f, &gmask);
+				ReadleLong(f, &rmask);
+				for (bit = bitcount - 1; bit >= 0; bit--)
+				{
+					if (bmask & (1 << bit))
+						bshift = bit;
+					if (gmask & (1 << bit))
+						gshift = bit;
+					if (rmask & (1 << bit))
+						rshift = bit;
+				}
+				fclose(f); /* UNSUPPORTED BACKWARD COMPAT. */
+				return 0;
+			}
+			else if (bitcount == 16)
+			{
+				rmask = 0x7C00;
+				gmask = 0x03E0;
+				bmask = 0x001F;
+				rshift = 10;
+				gshift = 5;
+				bshift = 0;
+			}
+			else if (bitcount == 32)
+			{
+				rmask = 0x00FF0000;
+				gmask = 0x0000FF00;
+				bmask = 0x000000FF;
+				rshift = 16;
+				gshift = 8;
+				bshift = 0;
+			}
+		}
+
+	}
+
+	if (payload_ptr)
+	{
+		fseek(f, offset, SEEK_SET);
+        if (!*payload_ptr)
+        {
+            *payload_ptr = malloc(imgsize);
+        }
+        else if (!payload_size_ptr || *payload_size_ptr < imgsize)
+        {
+            return 0;
+        }
+
+
+		if (!*payload_ptr)
+		{
+			fclose(f);
+			return 0;
+		}
+
+		fread(*payload_ptr, imgsize, 1, f);
+	}
+
+    fclose(f);
+
+
+
+	if (colormap_ptr && bitcount < 16)
+	{
+
+        if (ncols==0)
+        {
+            char palname[512];
+            sprintf (palname, "%s.%s", filename, "pal");
+            f = fopen(palname, "rb");
+            if (f)
+            {
+                fread(rgbQuads, 4, ncols=256, f);
+                fclose(f);
+            }
+        }
+
+
+		if (ncols>0)
+		{
+            if (!*colormap_ptr)
+            {
+                *colormap_ptr = malloc(sizeof(RGBQUAD)*ncols);
+
+                if (!*colormap_ptr)
+                {
+                     return 0;
+                }
+            }
+            else if (!colormap_size_ptr
+                    || *colormap_size_ptr < sizeof(RGBQUAD)*ncols)
+            {
+                return 0;
+            }
+
+			memcpy(*colormap_ptr, rgbQuads, sizeof(RGBQUAD)*ncols);
+		}
+		else
+		{
+			*colormap_ptr = NULL;
+		}
+	}
+
+
+
+    if (payload_size_ptr)
+        *payload_size_ptr = imgsize;
+
+	if (colormap_size_ptr)
+		*colormap_size_ptr = sizeof(RGBQUAD)*ncols;
+
+    if (width_ptr)
+		*width_ptr = w;
+	if (height_ptr)
+		*height_ptr = h;
+	if (depth_ptr)
+		*depth_ptr = bitcount;
+	if (rawmode_ptr)
+		*rawmode_ptr  = comp == RLEIC_NONE		? 1:0;
+	if (bdmode_ptr)
+		*bdmode_ptr   = comp == RLEIC_BD_RLE8	? 1:0;
+	if (topfirst_ptr)
+		*topfirst_ptr = comp == RLEIC_BD_RLE8   ? 1:topfirst;
+	if (buffer_size_ptr)
+		*buffer_size_ptr =preambleSize+headSize+imgsize+sizeof(RGBQUAD)*ncols;
+
+	return 1;
+}
+
diff -Naur DirectFB-1.7.7/tests/unit_test_rle_helpers.h DirectFB-1.7.7.stm/tests/unit_test_rle_helpers.h
--- DirectFB-1.7.7/tests/unit_test_rle_helpers.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7.stm/tests/unit_test_rle_helpers.h	2015-05-15 18:43:40.269587080 +0200
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2006 ST-Microelectronics R&D <alain.clement@st.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef UNIT_TEST_RLE_HELPERS_H_
+#define UNIT_TEST_RLE_HELPERS_H_
+
+extern int rle_load_image (char           *filename,
+                           unsigned long  *width_ptr,
+                           unsigned long  *height_ptr,
+                           unsigned long  *depth_ptr,
+                           unsigned long  *rawmode_ptr,
+                           unsigned long  *bdmode_ptr,
+                           unsigned long  *topfirst_ptr,
+                           unsigned long  *buffer_size_ptr,
+                           void          **payload_ptr,
+                           unsigned long  *payload_size_ptr,
+                           void          **colormap_ptr,
+                           unsigned long  *colormap_size_ptr);
+
+#endif /* __UNIT_TEST_RLE_HELPERS_H__ */
diff -Naur DirectFB-1.7.7/wm/default/default.c DirectFB-1.7.7.stm/wm/default/default.c
--- DirectFB-1.7.7/wm/default/default.c	2015-02-01 20:36:12.000000000 +0100
+++ DirectFB-1.7.7.stm/wm/default/default.c	2015-05-15 18:43:40.273591081 +0200
@@ -3416,7 +3416,7 @@
      DFBResult  ret;
      WMData    *wmdata = wm_data;
 
-     fusion_skirmish_init2( &wmdata->update_skirmish, "WM/Update", dfb_core_world(core), fusion_config->secure_fusion );
+     fusion_skirmish_init2( &wmdata->update_skirmish, "WM/Update", dfb_core_world(core), true );
 
      ret = local_init( wm_data, core );
      if (ret)
@@ -3429,6 +3429,9 @@
 wm_join( CoreDFB *core, void *wm_data, void *shared_data )
 {
      DFBResult ret;
+     WMData    *wmdata = wm_data;
+
+     fusion_skirmish_init2( &wmdata->update_skirmish, "WM/Update", dfb_core_world(core), true );
 
      ret = local_init( wm_data, core );
      if (ret)
diff -Naur DirectFB-1.7.7/wm/sawman/sawman_wm.c DirectFB-1.7.7.stm/wm/sawman/sawman_wm.c
--- DirectFB-1.7.7/wm/sawman/sawman_wm.c	2015-02-01 20:36:12.000000000 +0100
+++ DirectFB-1.7.7.stm/wm/sawman/sawman_wm.c	2015-05-15 18:43:40.285603081 +0200
@@ -1267,7 +1267,7 @@
      WMData    *data   = wm_data;
      SaWMan    *sawman = shared_data;
 
-     fusion_skirmish_init2( &data->update_skirmish, "WM/Update", dfb_core_world(core), fusion_config->secure_fusion );
+     fusion_skirmish_init2( &data->update_skirmish, "WM/Update", dfb_core_world(core), true );
 
      ret = local_init( data, sawman, core );
      if (ret)
@@ -1283,10 +1283,14 @@
      WMData    *data   = wm_data;
      SaWMan    *sawman = shared_data;
 
+     fusion_skirmish_init2( &data->update_skirmish, "WM/Update", dfb_core_world(core), true );
+
      ret = local_init( data, sawman, core );
      if (ret)
           return ret;
 
+     local_ref( data );
+
      return sawman_join( sawman, data->world, &data->process );
 }
 
@@ -1309,6 +1313,8 @@
      WMData *data   = wm_data;
      SaWMan *sawman = shared_data;
 
+     local_unref( data );
+
      local_deinit( data );
 
      return sawman_leave( sawman, data->world );
